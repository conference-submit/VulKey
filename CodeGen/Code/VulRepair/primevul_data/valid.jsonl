{"source": "CWE-190 String preg_quote ( const String & str , const String & delimiter ) { const char * in_str = str . data ( ) ; const char * in_str_end = in_str + str . size ( ) ; if ( in_str == in_str_end ) { return str ; } char delim_char = 0 ; bool quote_delim = false ; if ( ! delimiter . empty ( ) ) { delim_char = delimiter . charAt ( 0 ) ; quote_delim = true ; } <S2SV_StartBug> <S2SV_EndBug> String ret ( 4 * str . size ( ) + 1 , ReserveString ) ; char * out_str = ret . mutableData ( ) ; const char * p ; char * q ; for ( p = in_str , q = out_str ; p != in_str_end ; p ++ ) { char c = * p ; switch ( c ) { case '.' : case '\\\\\\\\' : case '+' : case '*' : case '?' : case '[' : case '^' : case ']' : case '$' : case '(' : case ')' : case '{' : case '}' : case '=' : case '!' : case '>' : case '<' : case '|' : case ':' : case '-' : case '#' : * q ++ = '\\\\\\\\' ; * q ++ = c ; break ; case '\\\\0' : * q ++ = '\\\\\\\\' ; * q ++ = '0' ; * q ++ = '0' ; * q ++ = '0' ; break ; default : if ( quote_delim && c == delim_char ) * q ++ = '\\\\\\\\' ; * q ++ = c ; break ; } } * q = '\\\\0' ; return ret . setSize ( q - out_str ) ; }", "target": "<S2SV_ModStart> true ; } static_assert ( ( StringData : : MaxSize * 4 + 1 ) < std : : numeric_limits < int64_t > : : max ( ) ) ;"}
{"source": "CWE-190 static int xbuf_format_converter ( char * * outbuf , const char * fmt , va_list ap ) { register char * s = nullptr ; char * q ; int s_len ; register int min_width = 0 ; int precision = 0 ; enum { LEFT , RIGHT } adjust ; char pad_char ; char prefix_char ; double fp_num ; wide_int i_num = ( wide_int ) 0 ; u_wide_int ui_num ; char num_buf [ NUM_BUF_SIZE ] ; char char_buf [ 2 ] ; # ifdef HAVE_LOCALE_H struct lconv * lconv = nullptr ; # endif length_modifier_e modifier ; boolean_e alternate_form ; boolean_e print_sign ; boolean_e print_blank ; boolean_e adjust_precision ; boolean_e adjust_width ; int is_negative ; int size = 240 ; char * result = ( char * ) malloc ( size ) ; int outpos = 0 ; while ( * fmt ) { if ( * fmt != '%' ) { appendchar ( & result , & outpos , & size , * fmt ) ; } else { adjust = RIGHT ; alternate_form = print_sign = print_blank = NO ; pad_char = '<S2SV_blank>' ; prefix_char = NUL ; fmt ++ ; if ( isascii ( ( int ) * fmt ) && ! islower ( ( int ) * fmt ) ) { for ( ; ; fmt ++ ) { if ( * fmt == '-' ) adjust = LEFT ; else if ( * fmt == '+' ) print_sign = YES ; else if ( * fmt == '#' ) alternate_form = YES ; else if ( * fmt == '<S2SV_blank>' ) print_blank = YES ; else if ( * fmt == '0' ) pad_char = '0' ; else break ; } if ( isdigit ( ( int ) * fmt ) ) { STR_TO_DEC ( fmt , min_width ) ; adjust_width = YES ; } else if ( * fmt == '*' ) { min_width = va_arg ( ap , int ) ; fmt ++ ; adjust_width = YES ; if ( min_width < 0 ) { adjust = LEFT ; min_width = - min_width ; } } else adjust_width = NO ; if ( * fmt == '.' ) { adjust_precision = YES ; fmt ++ ; if ( isdigit ( ( int ) * fmt ) ) { STR_TO_DEC ( fmt , precision ) ; } else if ( * fmt == '*' ) { precision = va_arg ( ap , int ) ; fmt ++ ; if ( precision < 0 ) precision = 0 ; } else precision = 0 ; } else adjust_precision = NO ; } else adjust_precision = adjust_width = NO ; switch ( * fmt ) { case 'L' : fmt ++ ; modifier = LM_LONG_DOUBLE ; break ; case 'I' : fmt ++ ; # if SIZEOF_LONG_LONG if ( * fmt == '6' && * ( fmt + 1 ) == '4' ) { fmt += 2 ; modifier = LM_LONG_LONG ; } else # endif if ( * fmt == '3' && * ( fmt + 1 ) == '2' ) { fmt += 2 ; modifier = LM_LONG ; } else { # ifdef _WIN64 modifier = LM_LONG_LONG ; # else modifier = LM_LONG ; # endif } break ; case 'l' : fmt ++ ; # if SIZEOF_LONG_LONG if ( * fmt == 'l' ) { fmt ++ ; modifier = LM_LONG_LONG ; } else # endif modifier = LM_LONG ; break ; case 'z' : fmt ++ ; modifier = LM_SIZE_T ; break ; case 'j' : fmt ++ ; # if SIZEOF_INTMAX_T modifier = LM_INTMAX_T ; # else modifier = LM_SIZE_T ; # endif break ; case 't' : fmt ++ ; # if SIZEOF_PTRDIFF_T modifier = LM_PTRDIFF_T ; # else modifier = LM_SIZE_T ; # endif break ; case 'h' : fmt ++ ; if ( * fmt == 'h' ) { fmt ++ ; } default : modifier = LM_STD ; break ; } switch ( * fmt ) { case 'u' : switch ( modifier ) { default : i_num = ( wide_int ) va_arg ( ap , unsigned int ) ; break ; case LM_LONG_DOUBLE : goto fmt_error ; case LM_LONG : i_num = ( wide_int ) va_arg ( ap , unsigned long int ) ; break ; case LM_SIZE_T : i_num = ( wide_int ) va_arg ( ap , size_t ) ; break ; # if SIZEOF_LONG_LONG case LM_LONG_LONG : i_num = ( wide_int ) va_arg ( ap , u_wide_int ) ; break ; # endif # if SIZEOF_INTMAX_T case LM_INTMAX_T : i_num = ( wide_int ) va_arg ( ap , uintmax_t ) ; break ; # endif # if SIZEOF_PTRDIFF_T case LM_PTRDIFF_T : i_num = ( wide_int ) va_arg ( ap , ptrdiff_t ) ; break ; # endif } case 'd' : case 'i' : if ( ( * fmt ) != 'u' ) { switch ( modifier ) { default : i_num = ( wide_int ) va_arg ( ap , int ) ; break ; case LM_LONG_DOUBLE : goto fmt_error ; case LM_LONG : i_num = ( wide_int ) va_arg ( ap , long int ) ; break ; case LM_SIZE_T : # if SIZEOF_SSIZE_T i_num = ( wide_int ) va_arg ( ap , ssize_t ) ; # else i_num = ( wide_int ) va_arg ( ap , size_t ) ; # endif break ; # if SIZEOF_LONG_LONG case LM_LONG_LONG : i_num = ( wide_int ) va_arg ( ap , wide_int ) ; break ; # endif # if SIZEOF_INTMAX_T case LM_INTMAX_T : i_num = ( wide_int ) va_arg ( ap , intmax_t ) ; break ; # endif # if SIZEOF_PTRDIFF_T case LM_PTRDIFF_T : i_num = ( wide_int ) va_arg ( ap , ptrdiff_t ) ; break ; # endif } } s = ap_php_conv_10 ( i_num , ( * fmt ) == 'u' , & is_negative , & num_buf [ NUM_BUF_SIZE ] , & s_len ) ; FIX_PRECISION ( adjust_precision , precision , s , s_len ) ; if ( * fmt != 'u' ) { if ( is_negative ) prefix_char = '-' ; else if ( print_sign ) prefix_char = '+' ; else if ( print_blank ) prefix_char = '<S2SV_blank>' ; } break ; case 'o' : switch ( modifier ) { default : ui_num = ( u_wide_int ) va_arg ( ap , unsigned int ) ; break ; case LM_LONG_DOUBLE : goto fmt_error ; case LM_LONG : ui_num = ( u_wide_int ) va_arg ( ap , unsigned long int ) ; break ; case LM_SIZE_T : ui_num = ( u_wide_int ) va_arg ( ap , size_t ) ; break ; # if SIZEOF_LONG_LONG case LM_LONG_LONG : ui_num = ( u_wide_int ) va_arg ( ap , u_wide_int ) ; break ; # endif # if SIZEOF_INTMAX_T case LM_INTMAX_T : ui_num = ( u_wide_int ) va_arg ( ap , uintmax_t ) ; break ; # endif # if SIZEOF_PTRDIFF_T case LM_PTRDIFF_T : ui_num = ( u_wide_int ) va_arg ( ap , ptrdiff_t ) ; break ; # endif } s = ap_php_conv_p2 ( ui_num , 3 , * fmt , & num_buf [ NUM_BUF_SIZE ] , & s_len ) ; FIX_PRECISION ( adjust_precision , precision , s , s_len ) ; if ( alternate_form && * s != '0' ) { * -- s = '0' ; s_len ++ ; } break ; case 'x' : case 'X' : switch ( modifier ) { default : ui_num = ( u_wide_int ) va_arg ( ap , unsigned int ) ; break ; case LM_LONG_DOUBLE : goto fmt_error ; case LM_LONG : ui_num = ( u_wide_int ) va_arg ( ap , unsigned long int ) ; break ; case LM_SIZE_T : ui_num = ( u_wide_int ) va_arg ( ap , size_t ) ; break ; # if SIZEOF_LONG_LONG case LM_LONG_LONG : ui_num = ( u_wide_int ) va_arg ( ap , u_wide_int ) ; break ; # endif # if SIZEOF_INTMAX_T case LM_INTMAX_T : ui_num = ( u_wide_int ) va_arg ( ap , uintmax_t ) ; break ; # endif # if SIZEOF_PTRDIFF_T case LM_PTRDIFF_T : ui_num = ( u_wide_int ) va_arg ( ap , ptrdiff_t ) ; break ; # endif } s = ap_php_conv_p2 ( ui_num , 4 , * fmt , & num_buf [ NUM_BUF_SIZE ] , & s_len ) ; FIX_PRECISION ( adjust_precision , precision , s , s_len ) ; if ( alternate_form && i_num != 0 ) { * -- s = * fmt ; * -- s = '0' ; s_len += 2 ; } break ; case 's' : case 'v' : s = va_arg ( ap , char * ) ; if ( s != nullptr ) { s_len = strlen ( s ) ; if ( adjust_precision && precision < s_len ) s_len = precision ; } else { s = const_cast < char * > ( s_null ) ; s_len = S_NULL_LEN ; } pad_char = '<S2SV_blank>' ; break ; case 'f' : case 'F' : case 'e' : case 'E' : switch ( modifier ) { case LM_LONG_DOUBLE : fp_num = ( double ) va_arg ( ap , long double ) ; break ; case LM_STD : fp_num = va_arg ( ap , double ) ; break ; default : goto fmt_error ; } if ( std : : isnan ( fp_num ) ) { s = const_cast < char * > ( \"nan\" ) ; s_len = 3 ; } else if ( std : : isinf ( fp_num ) ) { s = const_cast < char * > ( \"inf\" ) ; s_len = 3 ; } else { # ifdef HAVE_LOCALE_H if ( ! lconv ) { lconv = localeconv ( ) ; } # endif s = php_conv_fp ( ( * fmt == 'f' ) ? 'F' : * fmt , fp_num , alternate_form , ( adjust_precision == NO ) ? FLOAT_DIGITS : precision , ( * fmt == 'f' ) ? LCONV_DECIMAL_POINT : '.' , & is_negative , & num_buf [ 1 ] , & s_len ) ; if ( is_negative ) prefix_char = '-' ; else if ( print_sign ) prefix_char = '+' ; else if ( print_blank ) prefix_char = '<S2SV_blank>' ; } break ; case 'g' : case 'k' : case 'G' : case 'H' : switch ( modifier ) { case LM_LONG_DOUBLE : fp_num = ( double ) va_arg ( ap , long double ) ; break ; case LM_STD : fp_num = va_arg ( ap , double ) ; break ; default : goto fmt_error ; } if ( std : : isnan ( fp_num ) ) { s = const_cast < char * > ( \"NAN\" ) ; s_len = 3 ; break ; } else if ( std : : isinf ( fp_num ) ) { if ( fp_num > 0 ) { s = const_cast < char * > ( \"INF\" ) ; s_len = 3 ; } else { s = const_cast < char * > ( \"-INF\" ) ; s_len = 4 ; } break ; } if ( adjust_precision == NO ) precision = FLOAT_DIGITS ; else if ( precision == 0 ) precision = 1 ; # ifdef HAVE_LOCALE_H if ( ! lconv ) { lconv = localeconv ( ) ; } # endif s = php_gcvt ( fp_num , precision , ( * fmt == 'H' || * fmt == 'k' ) ? '.' : LCONV_DECIMAL_POINT , ( * fmt == 'G' || * fmt == 'H' ) ? 'E' : 'e' , & num_buf [ 1 ] ) ; if ( * s == '-' ) prefix_char = * s ++ ; else if ( print_sign ) prefix_char = '+' ; else if ( print_blank ) prefix_char = '<S2SV_blank>' ; s_len = strlen ( s ) ; if ( alternate_form && ( q = strchr ( s , '.' ) ) == nullptr ) s [ s_len ++ ] = '.' ; break ; case 'c' : char_buf [ 0 ] = ( char ) ( va_arg ( ap , int ) ) ; s = & char_buf [ 0 ] ; s_len = 1 ; pad_char = '<S2SV_blank>' ; break ; case '%' : char_buf [ 0 ] = '%' ; s = & char_buf [ 0 ] ; s_len = 1 ; pad_char = '<S2SV_blank>' ; break ; case 'n' : * ( va_arg ( ap , int * ) ) = outpos ; goto skip_output ; case 'p' : if ( sizeof ( char * ) <= sizeof ( u_wide_int ) ) { ui_num = ( u_wide_int ) ( ( size_t ) va_arg ( ap , char * ) ) ; s = ap_php_conv_p2 ( ui_num , 4 , 'x' , & num_buf [ NUM_BUF_SIZE ] , & s_len ) ; if ( ui_num != 0 ) { * -- s = 'x' ; * -- s = '0' ; s_len += 2 ; } } else { s = const_cast < char * > ( \"%p\" ) ; s_len = 2 ; } pad_char = '<S2SV_blank>' ; break ; case NUL : continue ; fmt_error : throw Exception ( \"Illegal<S2SV_blank>length<S2SV_blank>modifier<S2SV_blank>specified<S2SV_blank>\\'%c\\'\" , * fmt ) ; default : char_buf [ 0 ] = '%' ; char_buf [ 1 ] = * fmt ; s = char_buf ; s_len = 2 ; pad_char = '<S2SV_blank>' ; break ; } if ( prefix_char != NUL ) { * -- s = prefix_char ; s_len ++ ; } if ( adjust_width && adjust == RIGHT && min_width > s_len ) { if ( pad_char == '0' && prefix_char != NUL ) { appendchar ( & result , & outpos , & size , * s ) ; s ++ ; s_len -- ; min_width -- ; } for ( int i = 0 ; i < min_width - s_len ; i ++ ) { appendchar ( & result , & outpos , & size , pad_char ) ; } } appendsimplestring ( & result , & outpos , & size , s , s_len ) ; if ( adjust_width && adjust == LEFT && min_width > s_len ) { for ( int i = 0 ; i < min_width - s_len ; i ++ ) { appendchar ( & result , & outpos , & size , pad_char ) ; } } } skip_output : fmt ++ ; } <S2SV_StartBug> result [ outpos ] = NUL ; <S2SV_EndBug> * outbuf = result ; <S2SV_StartBug> return outpos ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ++ ; } appendchar ( & result , & outpos , & size , NUL ) <S2SV_ModEnd> ; * outbuf <S2SV_ModStart> ; return outpos - 1"}
{"source": "CWE-120 bool CPlayListASX : : LoadData ( std : : istream & stream ) { CLog : : Log ( LOGINFO , \"Parsing<S2SV_blank>ASX\" ) ; if ( stream . peek ( ) == '[' ) { return LoadAsxIniInfo ( stream ) ; } else { <S2SV_StartBug> CXBMCTinyXML xmlDoc ; <S2SV_EndBug> <S2SV_StartBug> stream >> xmlDoc ; <S2SV_EndBug> if ( xmlDoc . Error ( ) ) { CLog : : Log ( LOGERROR , \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ASX<S2SV_blank>info<S2SV_blank>Error:<S2SV_blank>{}\" , xmlDoc . ErrorDesc ( ) ) ; return false ; } <S2SV_StartBug> TiXmlElement * pRootElement = xmlDoc . RootElement ( ) ; <S2SV_EndBug> TiXmlNode * pNode = pRootElement ; TiXmlNode * pChild = NULL ; std : : string value ; value = pNode -> Value ( ) ; StringUtils : : ToLower ( value ) ; pNode -> SetValue ( value ) ; while ( pNode ) { pChild = pNode -> IterateChildren ( pChild ) ; if ( pChild ) { if ( pChild -> Type ( ) == TiXmlNode : : TINYXML_ELEMENT ) { value = pChild -> Value ( ) ; StringUtils : : ToLower ( value ) ; pChild -> SetValue ( value ) ; TiXmlAttribute * pAttr = pChild -> ToElement ( ) -> FirstAttribute ( ) ; while ( pAttr ) { value = pAttr -> Name ( ) ; StringUtils : : ToLower ( value ) ; pAttr -> SetName ( value ) ; pAttr = pAttr -> Next ( ) ; } } pNode = pChild ; pChild = NULL ; continue ; } pChild = pNode ; pNode = pNode -> Parent ( ) ; } std : : string roottitle ; TiXmlElement * pElement = pRootElement -> FirstChildElement ( ) ; while ( pElement ) { value = pElement -> Value ( ) ; if ( value == \"title\" && ! pElement -> NoChildren ( ) ) { roottitle = pElement -> FirstChild ( ) -> ValueStr ( ) ; } else if ( value == \"entry\" ) { std : : string title ( roottitle ) ; TiXmlElement * pRef = pElement -> FirstChildElement ( \"ref\" ) ; TiXmlElement * pTitle = pElement -> FirstChildElement ( \"title\" ) ; if ( pTitle && ! pTitle -> NoChildren ( ) ) title = pTitle -> FirstChild ( ) -> ValueStr ( ) ; while ( pRef ) { value = XMLUtils : : GetAttribute ( pRef , \"href\" ) ; if ( ! value . empty ( ) ) { if ( title . empty ( ) ) title = value ; CLog : : Log ( LOGINFO , \"Adding<S2SV_blank>element<S2SV_blank>{},<S2SV_blank>{}\" , title , value ) ; CFileItemPtr newItem ( new CFileItem ( title ) ) ; newItem -> SetPath ( value ) ; Add ( newItem ) ; } pRef = pRef -> NextSiblingElement ( \"ref\" ) ; } } else if ( value == \"entryref\" ) { value = XMLUtils : : GetAttribute ( pElement , \"href\" ) ; if ( ! value . empty ( ) ) { std : : unique_ptr < CPlayList > playlist ( CPlayListFactory : : Create ( value ) ) ; if ( nullptr != playlist ) if ( playlist -> Load ( value ) ) Add ( * playlist ) ; } } pElement = pElement -> NextSiblingElement ( ) ; } } return true ; }", "target": "<S2SV_ModStart> } else { std : : string asxstream ( std : : istreambuf_iterator < char > ( stream ) , { } ) ; <S2SV_ModStart> CXBMCTinyXML xmlDoc ; xmlDoc . Parse ( asxstream , TIXML_DEFAULT_ENCODING ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> RootElement ( ) ; if ( ! pRootElement ) return false"}
{"source": "CWE-787 TfLiteStatus EvalFloat ( TfLiteContext * context , TfLiteNode * node , TfLiteFullyConnectedParams * params , OpData * data , const TfLiteTensor * input , const TfLiteTensor * filter , const TfLiteTensor * bias , TfLiteTensor * output ) { float output_activation_min , output_activation_max ; CalculateActivationRange ( params -> activation , & output_activation_min , & output_activation_max ) ; if ( kernel_type == kReference ) { FullyConnectedParams op_params ; op_params . float_activation_min = output_activation_min ; op_params . float_activation_max = output_activation_max ; if ( filter -> sparsity != nullptr ) { const auto & sparsity = * filter -> sparsity ; reference_ops : : FullyConnectedSparseWeight ( sparsity , op_params , GetTensorShape ( input ) , GetTensorData < float > ( input ) , GetTensorShape ( filter ) , GetTensorData < float > ( filter ) , GetTensorShape ( bias ) , GetTensorData < float > ( bias ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) ) ; } else { reference_ops : : FullyConnected ( op_params , GetTensorShape ( input ) , GetTensorData < float > ( input ) , GetTensorShape ( filter ) , GetTensorData < float > ( filter ) , GetTensorShape ( bias ) , GetTensorData < float > ( bias ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) ) ; } } else if ( kernel_type == kLegacyPie ) { return EvalPie ( context , node , params , data , input , filter , bias , output ) ; } else { FullyConnectedParams op_params ; op_params . float_activation_min = output_activation_min ; op_params . float_activation_max = output_activation_max ; if ( filter -> sparsity != nullptr ) { const auto & sparsity = * filter -> sparsity ; if ( ! SupportedSparsityFormat ( sparsity ) ) { TF_LITE_KERNEL_LOG ( context , \"Unsupported<S2SV_blank>sparse<S2SV_blank>fully-connected<S2SV_blank>weight<S2SV_blank>format.\" ) ; return kTfLiteError ; } <S2SV_StartBug> <S2SV_EndBug> if ( sparsity . dim_metadata_size == kDimMetadataSizeRandomSparse ) { optimized_ops : : FullyConnectedSparseWeight ( <S2SV_StartBug> sparsity , op_params , GetTensorShape ( input ) , <S2SV_EndBug> GetTensorData < float > ( input ) , GetTensorShape ( filter ) , GetTensorData < float > ( filter ) , GetTensorShape ( bias ) , GetTensorData < float > ( bias ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) ) ; } else if ( sparsity . dim_metadata_size == kDimMetadataSizeBlockSparse && sparsity . dim_metadata [ 2 ] . dense_size == 4 ) { optimized_ops : : FullyConnectedSparseWeight1x4 ( <S2SV_StartBug> sparsity , op_params , GetTensorShape ( input ) , <S2SV_EndBug> GetTensorData < float > ( input ) , GetTensorShape ( filter ) , GetTensorData < float > ( filter ) , GetTensorShape ( bias ) , GetTensorData < float > ( bias ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) , CpuBackendContext : : GetFromContext ( context ) ) ; } else { TF_LITE_KERNEL_LOG ( context , \"Unsupported<S2SV_blank>sparse<S2SV_blank>fully-connected<S2SV_blank>weight<S2SV_blank>format.\" ) ; return kTfLiteError ; } } else { op_params . lhs_cacheable = IsConstantTensor ( filter ) ; op_params . rhs_cacheable = IsConstantTensor ( input ) ; optimized_ops : : FullyConnected ( op_params , GetTensorShape ( input ) , GetTensorData < float > ( input ) , GetTensorShape ( filter ) , GetTensorData < float > ( filter ) , GetTensorShape ( bias ) , GetTensorData < float > ( bias ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) , CpuBackendContext : : GetFromContext ( context ) ) ; } } return kTfLiteOk ; }", "target": "<S2SV_ModStart> kTfLiteError ; } const auto & input_shape = GetTensorShape ( input ) ; const auto & filter_shape = GetTensorShape ( filter ) ; const auto & output_shape = GetTensorShape ( output ) ; const auto & bias_shape = GetTensorShape ( bias ) ; if ( ! VerifySparsity ( filter_shape , input_shape , output_shape , & sparsity ) ) { TF_LITE_KERNEL_LOG ( context , \"Invalid<S2SV_blank>sparse<S2SV_blank>fully-connected<S2SV_blank>format.\" ) ; return kTfLiteError ; } <S2SV_ModStart> , op_params , input_shape , GetTensorData < float > ( input ) , filter_shape , GetTensorData < float > ( filter ) , bias_shape , GetTensorData < float > ( bias ) , output_shape , <S2SV_ModEnd> GetTensorData < float <S2SV_ModStart> , op_params , input_shape , GetTensorData < float > ( input ) , filter_shape , GetTensorData < float > ( filter ) , bias_shape , GetTensorData < float > ( bias ) , output_shape , <S2SV_ModEnd> GetTensorData < float"}
{"source": "CWE-787 uint8_t ethereum_extractThorchainData ( const EthereumSignTx * msg , char * buffer ) { uint16_t offset = 4 + ( 5 * 32 ) ; int16_t len = msg -> data_length - offset ; <S2SV_StartBug> if ( msg -> has_data_length && len > 0 ) { <S2SV_EndBug> memcpy ( buffer , msg -> data_initial_chunk . bytes + offset , len ) ; <S2SV_StartBug> return len < 256 ? ( uint8_t ) len : 0 ; <S2SV_EndBug> } return 0 ; }", "target": "<S2SV_ModStart> len > 0 && len < 256 <S2SV_ModStart> ) ; return <S2SV_ModEnd> ( uint8_t ) <S2SV_ModStart> uint8_t ) len <S2SV_ModEnd> ; } return"}
{"source": "CWE-787 static int stszin ( int size ) { int cnt ; uint32_t ofs ; u32in ( ) ; u32in ( ) ; mp4config . frame . ents = u32in ( ) ; <S2SV_StartBug> mp4config . frame . data = malloc ( sizeof ( * mp4config . frame . data ) <S2SV_EndBug> * ( mp4config . frame . ents + 1 ) ) ; if ( ! mp4config . frame . data ) return ERR_FAIL ; ofs = 0 ; mp4config . frame . data [ 0 ] = ofs ; for ( cnt = 0 ; cnt < mp4config . frame . ents ; cnt ++ ) { uint32_t fsize = u32in ( ) ; ofs += fsize ; if ( mp4config . frame . maxsize < fsize ) mp4config . frame . maxsize = fsize ; mp4config . frame . data [ cnt + 1 ] = ofs ; if ( ofs < mp4config . frame . data [ cnt ] ) return ERR_FAIL ; } return size ; }", "target": "<S2SV_ModStart> ( ) ; if ( ! ( mp4config . frame . ents + 1 ) ) return ERR_FAIL ;"}
{"source": "CWE-122 mrb_proc_copy ( mrb_state * mrb , struct RProc * a , struct RProc * b ) { if ( a -> body . irep ) { return ; } <S2SV_StartBug> a -> flags = b -> flags ; <S2SV_EndBug> a -> body = b -> body ; a -> upper = b -> upper ; <S2SV_StartBug> if ( ! MRB_PROC_CFUNC_P ( a ) && a -> body . irep ) { <S2SV_EndBug> mrb_irep_incref ( mrb , ( mrb_irep * ) a -> body . irep ) ; } a -> e . env = b -> e . env ; }", "target": "<S2SV_ModStart> return ; } if ( ! MRB_PROC_CFUNC_P ( b ) && b -> body . irep ) { mrb_irep_incref ( mrb , ( mrb_irep * ) b -> body . irep ) ; } <S2SV_ModStart> -> upper ; <S2SV_ModEnd> a -> e"}
{"source": "CWE-617 int64_t TensorByteSize ( const TensorProto & t ) { <S2SV_StartBug> int64_t num_elems = TensorShape ( t . tensor_shape ( ) ) . num_elements ( ) ; <S2SV_EndBug> return num_elems < 0 ? - 1 : num_elems * DataTypeSize ( t . dtype ( ) ) ; }", "target": "<S2SV_ModStart> int64_t num_elems = PartialTensorShape <S2SV_ModEnd> ( t ."}
{"source": "CWE-369 TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteDepthwiseConvParams * > ( node -> builtin_data ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; bool has_bias = NumInputs ( node ) == 3 ; TF_LITE_ENSURE ( context , has_bias || NumInputs ( node ) == 2 ) ; const TfLiteTensor * input ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor , & input ) ) ; const TfLiteTensor * filter ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kFilterTensor , & filter ) ) ; const TfLiteTensor * bias = nullptr ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( input ) , 4 ) ; <S2SV_StartBug> TF_LITE_ENSURE_EQ ( context , NumDimensions ( filter ) , 4 ) ; <S2SV_EndBug> const TfLiteType data_type = input -> type ; const TfLiteType filter_type = filter -> type ; const bool is_hybrid = data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8 ; TF_LITE_ENSURE ( context , data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 || data_type == kTfLiteInt8 || data_type == kTfLiteInt16 ) ; TF_LITE_ENSURE_TYPES_EQ ( context , output -> type , data_type ) ; if ( ! is_hybrid ) { TF_LITE_ENSURE ( context , filter -> type == data_type || data_type == kTfLiteInt16 ) ; } if ( data_type == kTfLiteInt16 ) { TF_LITE_ENSURE_EQ ( context , input -> params . zero_point , 0 ) ; TF_LITE_ENSURE_EQ ( context , output -> params . zero_point , 0 ) ; } TF_LITE_ENSURE_EQ ( context , SizeOfDimension ( filter , 0 ) , 1 ) ; if ( has_bias ) { TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kBiasTensor , & bias ) ) ; if ( data_type == kTfLiteUInt8 || data_type == kTfLiteInt8 ) { TF_LITE_ENSURE_TYPES_EQ ( context , bias -> type , kTfLiteInt32 ) ; TF_LITE_ENSURE_EQ ( context , bias -> params . zero_point , 0 ) ; } else if ( data_type == kTfLiteInt16 ) { TF_LITE_ENSURE_TYPES_EQ ( context , bias -> type , kTfLiteInt64 ) ; TF_LITE_ENSURE_EQ ( context , bias -> params . zero_point , 0 ) ; } else { TF_LITE_ENSURE_TYPES_EQ ( context , bias -> type , data_type ) ; } TF_LITE_ENSURE_EQ ( context , NumDimensions ( bias ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , SizeOfDimension ( filter , 3 ) , SizeOfDimension ( bias , 0 ) ) ; } int channels_out = SizeOfDimension ( filter , 3 ) ; int width = SizeOfDimension ( input , 2 ) ; int height = SizeOfDimension ( input , 1 ) ; int filter_width = SizeOfDimension ( filter , 2 ) ; int filter_height = SizeOfDimension ( filter , 1 ) ; int batches = SizeOfDimension ( input , 0 ) ; auto padding = params -> padding ; int out_width , out_height ; data -> padding = ComputePaddingHeightWidth ( params -> stride_height , params -> stride_width , params -> dilation_height_factor , params -> dilation_width_factor , height , width , filter_height , filter_width , padding , & out_height , & out_width ) ; if ( data_type != kTfLiteFloat32 ) { TF_LITE_ENSURE_EQ ( context , filter -> quantization . type , kTfLiteAffineQuantization ) ; TF_LITE_ENSURE ( context , filter -> quantization . type != kTfLiteNoQuantization ) ; const auto * affine_quantization = reinterpret_cast < TfLiteAffineQuantization * > ( filter -> quantization . params ) ; TF_LITE_ENSURE ( context , affine_quantization ) ; TF_LITE_ENSURE ( context , affine_quantization -> scale ) ; TF_LITE_ENSURE ( context , ( affine_quantization -> scale -> size == 1 || affine_quantization -> scale -> size == channels_out ) ) ; data -> per_channel_output_multiplier . resize ( channels_out ) ; data -> per_channel_output_shift . resize ( channels_out ) ; TF_LITE_ENSURE_STATUS ( tflite : : PopulateConvolutionQuantizationParams ( context , input , filter , bias , output , params -> activation , & data -> output_multiplier , & data -> output_shift , & data -> output_activation_min , & data -> output_activation_max , data -> per_channel_output_multiplier . data ( ) , data -> per_channel_output_shift . data ( ) , channels_out ) ) ; } if ( is_hybrid ) { TF_LITE_ENSURE ( context , filter -> quantization . type != kTfLiteNoQuantization ) ; const auto * affine_quantization = reinterpret_cast < TfLiteAffineQuantization * > ( filter -> quantization . params ) ; TF_LITE_ENSURE ( context , affine_quantization ) ; TF_LITE_ENSURE ( context , affine_quantization -> scale ) ; TF_LITE_ENSURE_EQ ( context , affine_quantization -> scale -> size , filter -> dims -> data [ affine_quantization -> quantized_dimension ] ) ; int temporaries_count = 0 ; data -> input_quantized_index = temporaries_count ; if ( data -> input_quantized_id == kTensorNotAllocated ) { TF_LITE_ENSURE_OK ( context , context -> AddTensors ( context , 1 , & data -> input_quantized_id ) ) ; } ++ temporaries_count ; data -> scaling_factors_index = temporaries_count ; if ( data -> scaling_factors_id == kTensorNotAllocated ) { TF_LITE_ENSURE_OK ( context , context -> AddTensors ( context , 1 , & data -> scaling_factors_id ) ) ; } ++ temporaries_count ; data -> input_offset_index = temporaries_count ; if ( data -> input_offset_id == kTensorNotAllocated ) { TF_LITE_ENSURE_OK ( context , context -> AddTensors ( context , 1 , & data -> input_offset_id ) ) ; } ++ temporaries_count ; TfLiteIntArrayFree ( node -> temporaries ) ; node -> temporaries = TfLiteIntArrayCreate ( temporaries_count ) ; node -> temporaries -> data [ data -> input_quantized_index ] = data -> input_quantized_id ; TfLiteTensor * input_quantized ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , data -> input_quantized_index , & input_quantized ) ) ; input_quantized -> type = kTfLiteInt8 ; input_quantized -> allocation_type = kTfLiteArenaRw ; if ( ! TfLiteIntArrayEqual ( input_quantized -> dims , input -> dims ) ) { TfLiteIntArray * input_quantized_size = TfLiteIntArrayCopy ( input -> dims ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , input_quantized , input_quantized_size ) ) ; } node -> temporaries -> data [ data -> scaling_factors_index ] = data -> scaling_factors_id ; TfLiteTensor * scaling_factors ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , data -> scaling_factors_index , & scaling_factors ) ) ; scaling_factors -> type = kTfLiteFloat32 ; scaling_factors -> allocation_type = kTfLiteArenaRw ; const int batch_size = SizeOfDimension ( input , 0 ) ; int scaling_dims [ 1 ] = { batch_size } ; if ( ! TfLiteIntArrayEqualsArray ( scaling_factors -> dims , 1 , scaling_dims ) ) { TfLiteIntArray * scaling_factors_size = TfLiteIntArrayCreate ( 1 ) ; scaling_factors_size -> data [ 0 ] = batch_size ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , scaling_factors , scaling_factors_size ) ) ; } node -> temporaries -> data [ data -> input_offset_index ] = data -> input_offset_id ; TfLiteTensor * input_offsets ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , data -> input_offset_index , & input_offsets ) ) ; input_offsets -> type = kTfLiteInt32 ; input_offsets -> allocation_type = kTfLiteArenaRw ; if ( ! TfLiteIntArrayEqualsArray ( input_offsets -> dims , 1 , scaling_dims ) ) { TfLiteIntArray * input_offsets_size = TfLiteIntArrayCreate ( 1 ) ; input_offsets_size -> data [ 0 ] = batch_size ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , input_offsets , input_offsets_size ) ) ; } } TfLiteIntArray * outputSize = TfLiteIntArrayCreate ( 4 ) ; outputSize -> data [ 0 ] = batches ; outputSize -> data [ 1 ] = out_height ; outputSize -> data [ 2 ] = out_width ; outputSize -> data [ 3 ] = channels_out ; return context -> ResizeTensor ( context , output , outputSize ) ; }", "target": "<S2SV_ModStart> ) , 4 ) ; TF_LITE_ENSURE ( context , params -> dilation_height_factor > 0 ) ; TF_LITE_ENSURE ( context , params -> dilation_width_factor > 0"}
{"source": "CWE-200 static struct sock * pep_sock_accept ( struct sock * sk , int flags , int * errp , bool kern ) { struct pep_sock * pn = pep_sk ( sk ) , * newpn ; struct sock * newsk = NULL ; struct sk_buff * skb ; struct pnpipehdr * hdr ; struct sockaddr_pn dst , src ; int err ; u16 peer_type ; u8 pipe_handle , enabled , n_sb ; u8 aligned = 0 ; skb = skb_recv_datagram ( sk , 0 , flags & O_NONBLOCK , errp ) ; if ( ! skb ) return NULL ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_LISTEN ) { err = - EINVAL ; goto drop ; } sk_acceptq_removed ( sk ) ; err = - EPROTO ; if ( ! pskb_may_pull ( skb , sizeof ( * hdr ) + 4 ) ) goto drop ; hdr = pnp_hdr ( skb ) ; pipe_handle = hdr -> pipe_handle ; switch ( hdr -> state_after_connect ) { case PN_PIPE_DISABLE : enabled = 0 ; break ; case PN_PIPE_ENABLE : enabled = 1 ; break ; default : pep_reject_conn ( sk , skb , PN_PIPE_ERR_INVALID_PARAM , GFP_KERNEL ) ; goto drop ; } peer_type = hdr -> other_pep_type << 8 ; n_sb = hdr -> data [ 3 ] ; while ( n_sb > 0 ) { u8 type , buf [ 1 ] , len = sizeof ( buf ) ; const u8 * data = pep_get_sb ( skb , & type , & len , buf ) ; if ( data == NULL ) goto drop ; switch ( type ) { case PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE : if ( len < 1 ) goto drop ; peer_type = ( peer_type & 0xff00 ) | data [ 0 ] ; break ; case PN_PIPE_SB_ALIGNED_DATA : aligned = data [ 0 ] != 0 ; break ; } n_sb -- ; } newsk = pep_find_pipe ( & pn -> hlist , & dst , pipe_handle ) ; if ( unlikely ( newsk ) ) { __sock_put ( newsk ) ; newsk = NULL ; pep_reject_conn ( sk , skb , PN_PIPE_ERR_PEP_IN_USE , GFP_KERNEL ) ; goto drop ; } newsk = sk_alloc ( sock_net ( sk ) , PF_PHONET , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) { pep_reject_conn ( sk , skb , PN_PIPE_ERR_OVERLOAD , GFP_KERNEL ) ; err = - ENOBUFS ; goto drop ; } sock_init_data ( NULL , newsk ) ; newsk -> sk_state = TCP_SYN_RECV ; newsk -> sk_backlog_rcv = pipe_do_rcv ; newsk -> sk_protocol = sk -> sk_protocol ; newsk -> sk_destruct = pipe_destruct ; newpn = pep_sk ( newsk ) ; pn_skb_get_dst_sockaddr ( skb , & dst ) ; pn_skb_get_src_sockaddr ( skb , & src ) ; newpn -> pn_sk . sobject = pn_sockaddr_get_object ( & dst ) ; newpn -> pn_sk . dobject = pn_sockaddr_get_object ( & src ) ; newpn -> pn_sk . resource = pn_sockaddr_get_resource ( & dst ) ; sock_hold ( sk ) ; newpn -> listener = sk ; skb_queue_head_init ( & newpn -> ctrlreq_queue ) ; newpn -> pipe_handle = pipe_handle ; atomic_set ( & newpn -> tx_credits , 0 ) ; newpn -> ifindex = 0 ; newpn -> peer_type = peer_type ; newpn -> rx_credits = 0 ; newpn -> rx_fc = newpn -> tx_fc = PN_LEGACY_FLOW_CONTROL ; newpn -> init_enable = enabled ; newpn -> aligned = aligned ; err = pep_accept_conn ( newsk , skb ) ; if ( err ) { <S2SV_StartBug> sock_put ( newsk ) ; <S2SV_EndBug> newsk = NULL ; goto drop ; } sk_add_node ( newsk , & pn -> hlist ) ; drop : release_sock ( sk ) ; kfree_skb ( skb ) ; * errp = err ; return newsk ; }", "target": "<S2SV_ModStart> err ) { __sock_put ( sk ) ;"}
{"source": "CWE-476 GF_Err gf_isom_box_parse_ex ( GF_Box * * outBox , GF_BitStream * bs , u32 parent_type , Bool is_root_box ) { u32 type , uuid_type , hdr_size ; u64 size , start , payload_start , end ; char uuid [ 16 ] ; GF_Err e ; GF_Box * newBox ; Bool skip_logs = gf_bs_get_cookie ( bs ) ? GF_TRUE : GF_FALSE ; Bool is_special = GF_TRUE ; if ( ( bs == NULL ) || ( outBox == NULL ) ) return GF_BAD_PARAM ; * outBox = NULL ; if ( gf_bs_available ( bs ) < 8 ) { return GF_ISOM_INCOMPLETE_FILE ; } start = gf_bs_get_position ( bs ) ; uuid_type = 0 ; size = ( u64 ) gf_bs_read_u32 ( bs ) ; hdr_size = 4 ; if ( ( size >= 2 ) && ( size <= 4 ) ) { size = 4 ; type = GF_ISOM_BOX_TYPE_VOID ; } else { type = gf_bs_read_u32 ( bs ) ; hdr_size += 4 ; if ( type == GF_ISOM_BOX_TYPE_TOTL ) size = 12 ; if ( ! size ) { if ( is_root_box ) { if ( ! skip_logs ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Warning<S2SV_blank>Read<S2SV_blank>Box<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>(0x%08X)<S2SV_blank>size<S2SV_blank>0<S2SV_blank>reading<S2SV_blank>till<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file\\\\n\" , gf_4cc_to_str ( type ) , type ) ) ; } size = gf_bs_available ( bs ) + 8 ; } else { if ( ! skip_logs ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Read<S2SV_blank>Box<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>(0x%08X)<S2SV_blank>at<S2SV_blank>position<S2SV_blank>\" LLU \"<S2SV_blank>has<S2SV_blank>size<S2SV_blank>0<S2SV_blank>but<S2SV_blank>is<S2SV_blank>not<S2SV_blank>at<S2SV_blank>root/file<S2SV_blank>level,<S2SV_blank>skipping\\\\n\" , gf_4cc_to_str ( type ) , type , start ) ) ; } return GF_OK ; } } } memset ( uuid , 0 , 16 ) ; if ( type == GF_ISOM_BOX_TYPE_UUID ) { if ( gf_bs_available ( bs ) < 16 ) { return GF_ISOM_INCOMPLETE_FILE ; } gf_bs_read_data ( bs , uuid , 16 ) ; hdr_size += 16 ; uuid_type = gf_isom_solve_uuid_box ( uuid ) ; } if ( size == 1 ) { if ( gf_bs_available ( bs ) < 8 ) { return GF_ISOM_INCOMPLETE_FILE ; } size = gf_bs_read_u64 ( bs ) ; hdr_size += 8 ; } GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Read<S2SV_blank>Box<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>size<S2SV_blank>\" LLD \"<S2SV_blank>start<S2SV_blank>\" LLD \"\\\\n\" , gf_4cc_to_str ( type ) , LLD_CAST size , LLD_CAST start ) ) ; if ( size < hdr_size ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Box<S2SV_blank>size<S2SV_blank>\" LLD \"<S2SV_blank>less<S2SV_blank>than<S2SV_blank>box<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%d\\\\n\" , LLD_CAST size , hdr_size ) ) ; return GF_ISOM_INVALID_FILE ; } if ( parent_type && ( parent_type == GF_ISOM_BOX_TYPE_TREF ) ) { newBox = gf_isom_box_new ( GF_ISOM_BOX_TYPE_REFT ) ; if ( ! newBox ) return GF_OUT_OF_MEM ; ( ( GF_TrackReferenceTypeBox * ) newBox ) -> reference_type = type ; } else if ( parent_type && ( parent_type == GF_ISOM_BOX_TYPE_IREF ) ) { newBox = gf_isom_box_new ( GF_ISOM_BOX_TYPE_REFI ) ; if ( ! newBox ) return GF_OUT_OF_MEM ; ( ( GF_ItemReferenceTypeBox * ) newBox ) -> reference_type = type ; } else if ( parent_type && ( parent_type == GF_ISOM_BOX_TYPE_TRGR ) ) { newBox = gf_isom_box_new ( GF_ISOM_BOX_TYPE_TRGT ) ; if ( ! newBox ) return GF_OUT_OF_MEM ; ( ( GF_TrackGroupTypeBox * ) newBox ) -> group_type = type ; } else if ( parent_type && ( parent_type == GF_ISOM_BOX_TYPE_GRPL ) ) { newBox = gf_isom_box_new ( GF_ISOM_BOX_TYPE_GRPT ) ; if ( ! newBox ) return GF_OUT_OF_MEM ; ( ( GF_EntityToGroupTypeBox * ) newBox ) -> grouping_type = type ; } else { is_special = GF_FALSE ; newBox = gf_isom_box_new_ex ( uuid_type ? uuid_type : type , parent_type , skip_logs , is_root_box ) ; if ( ! newBox ) return GF_OUT_OF_MEM ; } if ( type == GF_ISOM_BOX_TYPE_UUID && ! is_special ) { memcpy ( ( ( GF_UUIDBox * ) newBox ) -> uuid , uuid , 16 ) ; ( ( GF_UUIDBox * ) newBox ) -> internal_4cc = uuid_type ; } if ( ! newBox -> type ) newBox -> type = type ; payload_start = gf_bs_get_position ( bs ) ; retry_unknown_box : end = gf_bs_available ( bs ) ; if ( size - hdr_size > end ) { newBox -> size = size - hdr_size - end ; * outBox = newBox ; return GF_ISOM_INCOMPLETE_FILE ; } newBox -> size = size - hdr_size ; <S2SV_StartBug> if ( newBox -> size ) { <S2SV_EndBug> e = gf_isom_full_box_read ( newBox , bs ) ; if ( ! e ) e = gf_isom_box_read ( newBox , bs ) ; newBox -> size = size ; end = gf_bs_get_position ( bs ) ; <S2SV_StartBug> } else { <S2SV_EndBug> newBox -> size = size ; e = GF_OK ; end = gf_bs_get_position ( bs ) ; } if ( e && ( e != GF_ISOM_INCOMPLETE_FILE ) ) { gf_isom_box_del ( newBox ) ; * outBox = NULL ; if ( parent_type == GF_ISOM_BOX_TYPE_STSD ) { newBox = gf_isom_box_new ( GF_ISOM_BOX_TYPE_UNKNOWN ) ; ( ( GF_UnknownBox * ) newBox ) -> original_4cc = type ; newBox -> size = size ; gf_bs_seek ( bs , payload_start ) ; goto retry_unknown_box ; } if ( ! skip_logs ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Read<S2SV_blank>Box<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>(start<S2SV_blank>\" LLU \")<S2SV_blank>failed<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>skipping\\\\n\" , gf_4cc_to_str ( type ) , start , gf_error_to_string ( e ) ) ) ; } return e ; } if ( end - start > size ) { if ( ! skip_logs ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Box<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>size<S2SV_blank>\" LLU \"<S2SV_blank>(start<S2SV_blank>\" LLU \")<S2SV_blank>invalid<S2SV_blank>(read<S2SV_blank>\" LLU \")\\\\n\" , gf_4cc_to_str ( type ) , LLU_CAST size , start , LLU_CAST ( end - start ) ) ) ; } gf_bs_seek ( bs , start + size ) ; } else if ( end - start < size ) { u32 to_skip = ( u32 ) ( size - ( end - start ) ) ; if ( ! skip_logs ) { if ( ( to_skip != 4 ) || gf_bs_peek_bits ( bs , 32 , 0 ) ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Box<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>(start<S2SV_blank>\" LLU \")<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>extra<S2SV_blank>bytes\\\\n\" , gf_4cc_to_str ( type ) , start , to_skip ) ) ; } } gf_bs_skip_bytes ( bs , to_skip ) ; } * outBox = newBox ; return e ; }", "target": "<S2SV_ModStart> - hdr_size ; <S2SV_ModEnd> e = gf_isom_full_box_read <S2SV_ModStart> bs ) ; <S2SV_ModEnd> if ( e"}
{"source": "CWE-125 <S2SV_StartBug> snmp_ber_decode_string_len_buffer ( unsigned char * buf , uint32_t * buff_len , const char * * str , uint32_t * length ) <S2SV_EndBug> { uint8_t type , i , length_bytes ; <S2SV_StartBug> buf = snmp_ber_decode_type ( buf , buff_len , & type ) ; <S2SV_EndBug> if ( buf == NULL || type != BER_DATA_TYPE_OCTET_STRING ) { <S2SV_StartBug> return NULL ; <S2SV_EndBug> } if ( ( * buf & 0x80 ) == 0 ) { <S2SV_StartBug> * length = ( uint32_t ) * buf ++ ; <S2SV_EndBug> ( * buff_len ) -- ; } else { <S2SV_StartBug> length_bytes = ( uint8_t ) ( * buf ++ & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> ( * buff_len ) -- ; <S2SV_EndBug> if ( length_bytes > 4 ) { <S2SV_StartBug> return NULL ; <S2SV_EndBug> } <S2SV_StartBug> * length = ( uint32_t ) * buf ++ ; <S2SV_EndBug> ( * buff_len ) -- ; for ( i = 1 ; i < length_bytes ; ++ i ) { * length <<= 8 ; <S2SV_StartBug> * length |= * buf ++ ; <S2SV_EndBug> ( * buff_len ) -- ; } } <S2SV_StartBug> * str = ( const char * ) buf ; <S2SV_EndBug> * buff_len -= * length ; <S2SV_StartBug> return buf + * length ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> <S2SV_null> snmp_ber_decode_string_len_buffer ( snmp_packet_t * snmp_packet <S2SV_ModEnd> , const char <S2SV_ModStart> , length_bytes ; if ( ! snmp_ber_decode_type ( snmp_packet <S2SV_ModEnd> , & type <S2SV_ModStart> & type ) ) { return 0 ; } if ( <S2SV_ModEnd> type != BER_DATA_TYPE_OCTET_STRING <S2SV_ModStart> ) { return 0 ; } if ( ( * snmp_packet -> in <S2SV_ModEnd> & 0x80 ) <S2SV_ModStart> 0 ) { if ( snmp_packet -> used == 0 ) { return 0 ; } <S2SV_ModStart> uint32_t ) * snmp_packet -> in ++ ; snmp_packet -> used <S2SV_ModEnd> -- ; } <S2SV_ModStart> } else { if ( snmp_packet -> used == 0 ) { return 0 ; } <S2SV_ModStart> ) ( * snmp_packet -> in <S2SV_ModEnd> ++ & 0x7F <S2SV_ModStart> 0x7F ) ; snmp_packet -> used <S2SV_ModEnd> -- ; if <S2SV_ModStart> ) { return 0 ; } if ( snmp_packet -> used == 0 ) { return 0 <S2SV_ModEnd> ; } * <S2SV_ModStart> uint32_t ) * snmp_packet -> in ++ ; snmp_packet -> used <S2SV_ModEnd> -- ; for <S2SV_ModStart> <<= 8 ; if ( snmp_packet -> used == 0 ) { return 0 ; } <S2SV_ModStart> length |= * snmp_packet -> in ++ ; snmp_packet -> used <S2SV_ModEnd> -- ; } <S2SV_ModStart> char * ) snmp_packet -> in ; if ( snmp_packet -> used == 0 || snmp_packet -> used - * length <= 0 ) { return 0 ; } snmp_packet -> used <S2SV_ModEnd> -= * length <S2SV_ModStart> * length ; snmp_packet -> in += * length ; return 1 <S2SV_ModEnd> ; }"}
{"source": "CWE-125 bool handleBackslash ( signed char & out ) { char ch = * p ++ ; switch ( ch ) { case 0 : return false ; case \\'\"\\' : out = ch ; return true ; case '\\\\\\\\' : out = ch ; return true ; case '/' : out = ch ; return true ; case 'b' : out = '\\\\b' ; return true ; case 'f' : out = '\\\\f' ; return true ; case 'n' : out = '\\\\n' ; return true ; case 'r' : out = '\\\\r' ; return true ; case 't' : out = '\\\\t' ; return true ; case 'u' : { if ( UNLIKELY ( is_tsimplejson ) ) { auto const ch1 = * p ++ ; <S2SV_StartBug> auto const ch2 = * p ++ ; <S2SV_EndBug> auto const dch3 = dehexchar ( * p ++ ) ; auto const dch4 = dehexchar ( * p ++ ) ; <S2SV_StartBug> if ( UNLIKELY ( ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0 ) ) { <S2SV_EndBug> return false ; } out = ( dch3 << 4 ) | dch4 ; return true ; } else { uint16_t u16cp = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { auto const hexv = dehexchar ( * p ++ ) ; if ( hexv < 0 ) return false ; u16cp <<= 4 ; u16cp |= hexv ; } if ( u16cp > 0x7f ) { return false ; } else { out = u16cp ; return true ; } } } default : return false ; } }", "target": "<S2SV_ModStart> p ++ ; <S2SV_ModEnd> if ( UNLIKELY <S2SV_ModStart> ch1 != '0' ) ) return false ; auto const ch2 = * p ++ ; if ( UNLIKELY ( <S2SV_ModEnd> ch2 != '0' <S2SV_ModStart> ch2 != '0' ) ) return false ; auto const dch3 = dehexchar ( * p ++ ) ; if ( UNLIKELY ( <S2SV_ModEnd> dch3 < 0 <S2SV_ModStart> dch3 < 0 ) ) return false ; auto const dch4 = dehexchar ( * p ++ ) ; if ( UNLIKELY ( <S2SV_ModEnd> dch4 < 0 <S2SV_ModStart> 0 ) ) return false ; <S2SV_ModEnd> out = ("}
{"source": "CWE-400 void LanLinkProvider : : addLink ( const QString & deviceId , QSslSocket * socket , NetworkPacket * receivedPacket , LanDeviceLink : : ConnectionStarted connectionOrigin ) { disconnect ( socket , & QAbstractSocket : : disconnected , socket , & QObject : : deleteLater ) ; LanDeviceLink * deviceLink ; QMap < QString , LanDeviceLink * > : : iterator linkIterator = m_links . find ( deviceId ) ; if ( linkIterator != m_links . end ( ) ) { deviceLink = linkIterator . value ( ) ; deviceLink -> reset ( socket , connectionOrigin ) ; } else { deviceLink = new LanDeviceLink ( deviceId , this , socket , connectionOrigin ) ; <S2SV_StartBug> connect ( deviceLink , & QObject : : destroyed , this , & LanLinkProvider : : deviceLinkDestroyed ) ; <S2SV_EndBug> m_links [ deviceId ] = deviceLink ; if ( m_pairingHandlers . contains ( deviceId ) ) { Q_ASSERT ( m_pairingHandlers . contains ( deviceId ) ) ; m_pairingHandlers [ deviceId ] -> setDeviceLink ( deviceLink ) ; } } Q_EMIT onConnectionReceived ( * receivedPacket , deviceLink ) ; }", "target": "<S2SV_ModStart> connectionOrigin ) ; disconnect ( socket , & QAbstractSocket : : disconnected , socket , & QObject : : deleteLater ) ; bool isDeviceTrusted = KdeConnectConfig : : instance ( ) . trustedDevices ( ) . contains ( deviceId ) ; if ( ! isDeviceTrusted && m_links . size ( ) > MAX_UNPAIRED_CONNECTIONS ) { qCWarning ( KDECONNECT_CORE ) << \"Too<S2SV_blank>many<S2SV_blank>unpaired<S2SV_blank>devices<S2SV_blank>to<S2SV_blank>remember<S2SV_blank>them<S2SV_blank>all.<S2SV_blank>Ignoring<S2SV_blank>\" << deviceId ; socket -> disconnectFromHost ( ) ; socket -> deleteLater ( ) ; return ; }"}
{"source": "CWE-703 _libssh2_packet_add ( LIBSSH2_SESSION * session , unsigned char * data , size_t datalen , int macstate ) { int rc = 0 ; <S2SV_StartBug> char * message = NULL ; <S2SV_EndBug> <S2SV_StartBug> char * language = NULL ; <S2SV_EndBug> size_t message_len = 0 ; size_t language_len = 0 ; LIBSSH2_CHANNEL * channelp = NULL ; size_t data_head = 0 ; unsigned char msg = data [ 0 ] ; switch ( session -> packAdd_state ) { case libssh2_NB_state_idle : _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , \"Packet<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>received,<S2SV_blank>length=%d\" , ( int ) msg , ( int ) datalen ) ; if ( ( macstate == LIBSSH2_MAC_INVALID ) && ( ! session -> macerror || LIBSSH2_MACERROR ( session , ( char * ) data , datalen ) ) ) { LIBSSH2_FREE ( session , data ) ; return _libssh2_error ( session , LIBSSH2_ERROR_INVALID_MAC , \"Invalid<S2SV_blank>MAC<S2SV_blank>received\" ) ; } session -> packAdd_state = libssh2_NB_state_allocated ; break ; case libssh2_NB_state_jump1 : goto libssh2_packet_add_jump_point1 ; case libssh2_NB_state_jump2 : goto libssh2_packet_add_jump_point2 ; case libssh2_NB_state_jump3 : goto libssh2_packet_add_jump_point3 ; case libssh2_NB_state_jump4 : goto libssh2_packet_add_jump_point4 ; case libssh2_NB_state_jump5 : goto libssh2_packet_add_jump_point5 ; default : break ; } if ( session -> packAdd_state == libssh2_NB_state_allocated ) { switch ( msg ) { case SSH_MSG_DISCONNECT : if ( datalen >= 5 ) { <S2SV_StartBug> size_t reason = _libssh2_ntohu32 ( data + 1 ) ; <S2SV_EndBug> if ( datalen >= 9 ) { message_len = _libssh2_ntohu32 ( data + 5 ) ; if ( message_len < datalen - 13 ) { <S2SV_StartBug> message = ( char * ) data + 9 ; <S2SV_EndBug> language_len = _libssh2_ntohu32 ( data + 9 + message_len ) ; <S2SV_StartBug> language = ( char * ) data + 9 + message_len + 4 ; <S2SV_EndBug> if ( language_len > ( datalen - 13 - message_len ) ) { language = message = NULL ; language_len = message_len = 0 ; } } else message_len = 0 ; } if ( session -> ssh_msg_disconnect ) { LIBSSH2_DISCONNECT ( session , reason , message , message_len , language , language_len ) ; } _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , \"Disconnect(%d):<S2SV_blank>%s(%s)\" , reason , message , language ) ; } LIBSSH2_FREE ( session , data ) ; session -> socket_state = LIBSSH2_SOCKET_DISCONNECTED ; session -> packAdd_state = libssh2_NB_state_idle ; return _libssh2_error ( session , LIBSSH2_ERROR_SOCKET_DISCONNECT , \"socket<S2SV_blank>disconnect\" ) ; case SSH_MSG_IGNORE : if ( datalen >= 2 ) { if ( session -> ssh_msg_ignore ) { LIBSSH2_IGNORE ( session , ( char * ) data + 1 , datalen - 1 ) ; } } else if ( session -> ssh_msg_ignore ) { LIBSSH2_IGNORE ( session , \"\" , 0 ) ; } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_DEBUG : if ( datalen >= 2 ) { int always_display = data [ 1 ] ; if ( datalen >= 6 ) { <S2SV_StartBug> message_len = _libssh2_ntohu32 ( data + 2 ) ; <S2SV_EndBug> if ( message_len <= ( datalen - 10 ) ) { <S2SV_StartBug> message = ( char * ) data + 6 ; <S2SV_EndBug> language_len = _libssh2_ntohu32 ( data + 6 + message_len ) ; if ( language_len <= ( datalen - 10 - message_len ) ) <S2SV_StartBug> language = ( char * ) data + 10 + message_len ; <S2SV_EndBug> } } if ( session -> ssh_msg_debug ) { LIBSSH2_DEBUG ( session , always_display , message , message_len , language , language_len ) ; } } _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , \"Debug<S2SV_blank>Packet:<S2SV_blank>%s\" , message ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_GLOBAL_REQUEST : if ( datalen >= 5 ) { uint32_t len = 0 ; unsigned char want_reply = 0 ; len = _libssh2_ntohu32 ( data + 1 ) ; <S2SV_StartBug> if ( datalen >= ( 6 + len ) ) { <S2SV_EndBug> want_reply = data [ 5 + len ] ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"Received<S2SV_blank>global<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%.*s<S2SV_blank>(wr<S2SV_blank>%X)\" , len , data + 5 , want_reply ) ; } if ( want_reply ) { static const unsigned char packet = SSH_MSG_REQUEST_FAILURE ; libssh2_packet_add_jump_point5 : session -> packAdd_state = libssh2_NB_state_jump5 ; rc = _libssh2_transport_send ( session , & packet , 1 , NULL , 0 ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; } } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_CHANNEL_EXTENDED_DATA : data_head += 4 ; case SSH_MSG_CHANNEL_DATA : data_head += 9 ; if ( datalen >= data_head ) channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( ! channelp ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_UNKNOWN , \"Packet<S2SV_blank>received<S2SV_blank>for<S2SV_blank>unknown<S2SV_blank>channel\" ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } # ifdef LIBSSH2DEBUG { uint32_t stream_id = 0 ; if ( msg == SSH_MSG_CHANNEL_EXTENDED_DATA ) stream_id = _libssh2_ntohu32 ( data + 5 ) ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"%d<S2SV_blank>bytes<S2SV_blank>packet_add()<S2SV_blank>for<S2SV_blank>%lu/%lu/%lu\" , ( int ) ( datalen - data_head ) , channelp -> local . id , channelp -> remote . id , stream_id ) ; } # endif if ( ( channelp -> remote . extended_data_ignore_mode == LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE ) && ( msg == SSH_MSG_CHANNEL_EXTENDED_DATA ) ) { LIBSSH2_FREE ( session , data ) ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"Ignoring<S2SV_blank>extended<S2SV_blank>data<S2SV_blank>and<S2SV_blank>refunding<S2SV_blank>%d<S2SV_blank>bytes\" , ( int ) ( datalen - 13 ) ) ; if ( channelp -> read_avail + datalen - data_head >= channelp -> remote . window_size ) datalen = channelp -> remote . window_size - channelp -> read_avail + data_head ; channelp -> remote . window_size -= datalen - data_head ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"shrinking<S2SV_blank>window<S2SV_blank>size<S2SV_blank>by<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%lu,<S2SV_blank>\" \"read_avail<S2SV_blank>%lu\" , datalen - data_head , channelp -> remote . window_size , channelp -> read_avail ) ; session -> packAdd_channelp = channelp ; libssh2_packet_add_jump_point1 : session -> packAdd_state = libssh2_NB_state_jump1 ; rc = _libssh2_channel_receive_window_adjust ( session -> packAdd_channelp , datalen - 13 , 1 , NULL ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } if ( channelp -> remote . packet_size < ( datalen - data_head ) ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED , \"Packet<S2SV_blank>contains<S2SV_blank>more<S2SV_blank>data<S2SV_blank>than<S2SV_blank>we<S2SV_blank>offered\" \"<S2SV_blank>to<S2SV_blank>receive,<S2SV_blank>truncating\" ) ; datalen = channelp -> remote . packet_size + data_head ; } if ( channelp -> remote . window_size <= channelp -> read_avail ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED , \"The<S2SV_blank>current<S2SV_blank>receive<S2SV_blank>window<S2SV_blank>is<S2SV_blank>full,\" \"<S2SV_blank>data<S2SV_blank>ignored\" ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } channelp -> remote . eof = 0 ; if ( channelp -> read_avail + datalen - data_head > channelp -> remote . window_size ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED , \"Remote<S2SV_blank>sent<S2SV_blank>more<S2SV_blank>data<S2SV_blank>than<S2SV_blank>current<S2SV_blank>\" \"window<S2SV_blank>allows,<S2SV_blank>truncating\" ) ; datalen = channelp -> remote . window_size - channelp -> read_avail + data_head ; } channelp -> read_avail += datalen - data_head ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"increasing<S2SV_blank>read_avail<S2SV_blank>by<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%lu/%lu\" , ( long ) ( datalen - data_head ) , ( long ) channelp -> read_avail , ( long ) channelp -> remote . window_size ) ; break ; case SSH_MSG_CHANNEL_EOF : if ( datalen >= 5 ) channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( ! channelp ) ; else { _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"EOF<S2SV_blank>received<S2SV_blank>for<S2SV_blank>channel<S2SV_blank>%lu/%lu\" , channelp -> local . id , channelp -> remote . id ) ; channelp -> remote . eof = 1 ; } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_CHANNEL_REQUEST : if ( datalen >= 9 ) { uint32_t channel = _libssh2_ntohu32 ( data + 1 ) ; uint32_t len = _libssh2_ntohu32 ( data + 5 ) ; unsigned char want_reply = 1 ; if ( ( len + 9 ) < datalen ) want_reply = data [ len + 9 ] ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"Channel<S2SV_blank>%d<S2SV_blank>received<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%.*s<S2SV_blank>(wr<S2SV_blank>%X)\" , channel , len , data + 9 , want_reply ) ; if ( len == sizeof ( \"exit-status\" ) - 1 && ( sizeof ( \"exit-status\" ) - 1 + 9 ) <= datalen && ! memcmp ( \"exit-status\" , data + 9 , sizeof ( \"exit-status\" ) - 1 ) ) { if ( datalen >= 20 ) channelp = _libssh2_channel_locate ( session , channel ) ; if ( channelp && ( sizeof ( \"exit-status\" ) + 13 ) <= datalen ) { channelp -> exit_status = _libssh2_ntohu32 ( data + 9 + sizeof ( \"exit-status\" ) ) ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"Exit<S2SV_blank>status<S2SV_blank>%lu<S2SV_blank>received<S2SV_blank>for<S2SV_blank>\" \"channel<S2SV_blank>%lu/%lu\" , channelp -> exit_status , channelp -> local . id , channelp -> remote . id ) ; } } else if ( len == sizeof ( \"exit-signal\" ) - 1 && ( sizeof ( \"exit-signal\" ) - 1 + 9 ) <= datalen && ! memcmp ( \"exit-signal\" , data + 9 , sizeof ( \"exit-signal\" ) - 1 ) ) { if ( datalen >= 20 ) channelp = _libssh2_channel_locate ( session , channel ) ; if ( channelp && ( sizeof ( \"exit-signal\" ) + 13 ) <= datalen ) { uint32_t namelen = _libssh2_ntohu32 ( data + 9 + sizeof ( \"exit-signal\" ) ) ; if ( namelen <= UINT_MAX - 1 ) { channelp -> exit_signal = LIBSSH2_ALLOC ( session , namelen + 1 ) ; } else { channelp -> exit_signal = NULL ; } if ( ! channelp -> exit_signal ) rc = _libssh2_error ( session , LIBSSH2_ERROR_ALLOC , \"memory<S2SV_blank>for<S2SV_blank>signal<S2SV_blank>name\" ) ; else if ( ( sizeof ( \"exit-signal\" ) + 13 + namelen <= datalen ) ) { memcpy ( channelp -> exit_signal , data + 13 + sizeof ( \"exit-signal\" ) , namelen ) ; channelp -> exit_signal [ namelen ] = '\\\\0' ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"Exit<S2SV_blank>signal<S2SV_blank>%s<S2SV_blank>received<S2SV_blank>for<S2SV_blank>\" \"channel<S2SV_blank>%lu/%lu\" , channelp -> exit_signal , channelp -> local . id , channelp -> remote . id ) ; } } } if ( want_reply ) { unsigned char packet [ 5 ] ; libssh2_packet_add_jump_point4 : session -> packAdd_state = libssh2_NB_state_jump4 ; packet [ 0 ] = SSH_MSG_CHANNEL_FAILURE ; memcpy ( & packet [ 1 ] , data + 1 , 4 ) ; rc = _libssh2_transport_send ( session , packet , 5 , NULL , 0 ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; } } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return rc ; case SSH_MSG_CHANNEL_CLOSE : if ( datalen >= 5 ) channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( ! channelp ) { LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"Close<S2SV_blank>received<S2SV_blank>for<S2SV_blank>channel<S2SV_blank>%lu/%lu\" , channelp -> local . id , channelp -> remote . id ) ; channelp -> remote . close = 1 ; channelp -> remote . eof = 1 ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_CHANNEL_OPEN : if ( datalen < 17 ) ; else if ( ( datalen >= ( sizeof ( \"forwarded-tcpip\" ) + 4 ) ) && ( ( sizeof ( \"forwarded-tcpip\" ) - 1 ) == _libssh2_ntohu32 ( data + 1 ) ) && ( memcmp ( data + 5 , \"forwarded-tcpip\" , sizeof ( \"forwarded-tcpip\" ) - 1 ) == 0 ) ) { memset ( & session -> packAdd_Qlstn_state , 0 , sizeof ( session -> packAdd_Qlstn_state ) ) ; libssh2_packet_add_jump_point2 : session -> packAdd_state = libssh2_NB_state_jump2 ; rc = packet_queue_listener ( session , data , datalen , & session -> packAdd_Qlstn_state ) ; } else if ( ( datalen >= ( sizeof ( \"x11\" ) + 4 ) ) && ( ( sizeof ( \"x11\" ) - 1 ) == _libssh2_ntohu32 ( data + 1 ) ) && ( memcmp ( data + 5 , \"x11\" , sizeof ( \"x11\" ) - 1 ) == 0 ) ) { memset ( & session -> packAdd_x11open_state , 0 , sizeof ( session -> packAdd_x11open_state ) ) ; libssh2_packet_add_jump_point3 : session -> packAdd_state = libssh2_NB_state_jump3 ; rc = packet_x11_open ( session , data , datalen , & session -> packAdd_x11open_state ) ; } if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return rc ; case SSH_MSG_CHANNEL_WINDOW_ADJUST : if ( datalen < 9 ) ; else { uint32_t bytestoadd = _libssh2_ntohu32 ( data + 5 ) ; channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( channelp ) { channelp -> local . window_size += bytestoadd ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , \"Window<S2SV_blank>adjust<S2SV_blank>for<S2SV_blank>channel<S2SV_blank>%lu/%lu,<S2SV_blank>\" \"adding<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>new<S2SV_blank>window_size=%lu\" , channelp -> local . id , channelp -> remote . id , bytestoadd , channelp -> local . window_size ) ; } } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; default : break ; } session -> packAdd_state = libssh2_NB_state_sent ; } if ( session -> packAdd_state == libssh2_NB_state_sent ) { LIBSSH2_PACKET * packetp = LIBSSH2_ALLOC ( session , sizeof ( LIBSSH2_PACKET ) ) ; if ( ! packetp ) { _libssh2_debug ( session , LIBSSH2_ERROR_ALLOC , \"memory<S2SV_blank>for<S2SV_blank>packet\" ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return LIBSSH2_ERROR_ALLOC ; } packetp -> data = data ; packetp -> data_len = datalen ; packetp -> data_head = data_head ; _libssh2_list_add ( & session -> packets , & packetp -> node ) ; session -> packAdd_state = libssh2_NB_state_sent1 ; } if ( ( msg == SSH_MSG_KEXINIT && ! ( session -> state & LIBSSH2_STATE_EXCHANGING_KEYS ) ) || ( session -> packAdd_state == libssh2_NB_state_sent2 ) ) { if ( session -> packAdd_state == libssh2_NB_state_sent1 ) { _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , \"Renegotiating<S2SV_blank>Keys\" ) ; session -> packAdd_state = libssh2_NB_state_sent2 ; } session -> readPack_state = libssh2_NB_state_idle ; session -> packet . total_num = 0 ; session -> packAdd_state = libssh2_NB_state_idle ; session -> fullpacket_state = libssh2_NB_state_idle ; memset ( & session -> startup_key_state , 0 , sizeof ( key_exchange_state_t ) ) ; rc = _libssh2_kex_exchange ( session , 1 , & session -> startup_key_state ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; } session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; }", "target": "<S2SV_ModStart> = 0 ; unsigned <S2SV_ModStart> = NULL ; unsigned <S2SV_ModStart> 5 ) { uint32_t reason = 0 ; struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> char * ) <S2SV_ModStart> * ) data ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr ++ ; _libssh2_get_u32 ( & buf , & reason ) ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; if ( session -> ssh_msg_disconnect ) { LIBSSH2_DISCONNECT ( session , reason , ( const <S2SV_ModEnd> char * ) <S2SV_ModStart> char * ) message , message_len , ( const char * ) language , language_len ) ; } <S2SV_ModEnd> _libssh2_debug ( session <S2SV_ModStart> 6 ) { struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> char * ) <S2SV_ModStart> * ) data ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr += 2 ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; } if ( session -> ssh_msg_debug ) { LIBSSH2_DEBUG ( session , always_display , ( const <S2SV_ModEnd> char * ) <S2SV_ModStart> char * ) message , message_len , ( const char * ) <S2SV_ModEnd> language , language_len <S2SV_ModStart> ; if ( ( len <= ( UINT_MAX - 6 ) ) && ( <S2SV_ModStart> 6 + len )"}
{"source": "CWE-354 void Compute ( OpKernelContext * context ) override { const Tensor & logits_in = context -> input ( 0 ) ; const Tensor & labels_in = context -> input ( 1 ) ; TensorShape shape_in = logits_in . shape ( ) ; BCast bcast ( BCast : : FromShape ( logits_in . shape ( ) ) , <S2SV_StartBug> BCast : : FromShape ( labels_in . shape ( ) ) ) ; <S2SV_EndBug> if ( ! logits_in . IsSameSize ( labels_in ) ) { OP_REQUIRES ( context , bcast . IsValid ( ) , errors : : InvalidArgument ( \"logits<S2SV_blank>and<S2SV_blank>labels<S2SV_blank>must<S2SV_blank>be<S2SV_blank>broadcastable:<S2SV_blank>logits_size=\" , logits_in . shape ( ) . DebugString ( ) , \"<S2SV_blank>labels_size=\" , labels_in . shape ( ) . DebugString ( ) ) ) ; shape_in = BCast : : ToShape ( bcast . output_shape ( ) ) ; } OP_REQUIRES ( context , TensorShapeUtils : : IsMatrix ( shape_in ) , errors : : InvalidArgument ( \"logits<S2SV_blank>and<S2SV_blank>labels<S2SV_blank>must<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\" \"2-dimensional,<S2SV_blank>or<S2SV_blank>broadcasted<S2SV_blank>to<S2SV_blank>be<S2SV_blank>\" \"2-dimensional\" ) ) ; if ( std : : is_same < Device , GPUDevice > : : value ) { OP_REQUIRES ( context , ! OpDeterminismRequired ( ) , errors : : Unimplemented ( \"The<S2SV_blank>GPU<S2SV_blank>implementation<S2SV_blank>of<S2SV_blank>SoftmaxCrossEntropyWithLogits\" \"<S2SV_blank>that<S2SV_blank>would<S2SV_blank>have<S2SV_blank>been<S2SV_blank>executed<S2SV_blank>is<S2SV_blank>not<S2SV_blank>deterministic.\" \"<S2SV_blank>Note<S2SV_blank>that<S2SV_blank>the<S2SV_blank>Python<S2SV_blank>API<S2SV_blank>uses<S2SV_blank>an<S2SV_blank>alternative,\" \"<S2SV_blank>deterministic,<S2SV_blank>GPU-accelerated<S2SV_blank>path<S2SV_blank>when<S2SV_blank>determinism<S2SV_blank>is\" \"<S2SV_blank>enabled.\" ) ) ; } Tensor scratch ; OP_REQUIRES_OK ( context , context -> allocate_temp ( DataTypeToEnum < T > : : value , TensorShape ( { shape_in . dim_size ( 0 ) , 1 } ) , & scratch ) ) ; Tensor * loss_out = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { shape_in . dim_size ( 0 ) } ) , & loss_out ) ) ; Tensor * back_out = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 1 , shape_in , & back_out ) ) ; if ( shape_in . dim_size ( 0 ) > 0 ) { functor : : XentFunctor < Device , T > functor ; <S2SV_StartBug> if ( logits_in . IsSameSize ( labels_in ) ) { <S2SV_EndBug> functor ( context -> eigen_device < Device > ( ) , shape_in . AsEigenDSizes < 2 > ( ) , Eigen : : array < Eigen : : DenseIndex , 2 > { 1 , 1 } , Eigen : : array < Eigen : : DenseIndex , 2 > { 1 , 1 } , logits_in . matrix < T > ( ) , labels_in . matrix < T > ( ) , scratch . matrix < T > ( ) , loss_out -> vec < T > ( ) , back_out -> matrix < T > ( ) ) ; } else { functor ( context -> eigen_device < Device > ( ) , shape_in . AsEigenDSizes < 2 > ( ) , BCast : : ToIndexArray < 2 > ( bcast . x_bcast ( ) ) , BCast : : ToIndexArray < 2 > ( bcast . y_bcast ( ) ) , logits_in . template shaped < T , 2 > ( bcast . x_reshape ( ) ) , labels_in . template shaped < T , 2 > ( bcast . y_reshape ( ) ) , scratch . matrix < T > ( ) , loss_out -> vec < T > ( ) , back_out -> matrix < T > ( ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> ( ) ) , false <S2SV_ModStart> > functor ; <S2SV_ModEnd> functor ( context <S2SV_ModStart> ; } } <S2SV_ModEnd>  <S2SV_null> <S2SV_null>"}
{"source": "CWE-369 Status BuildFeatureReaders ( const OpInputList & ragged_values_list , const OpInputList & ragged_splits_list , const OpInputList & sparse_indices_list , const OpInputList & sparse_values_list , const OpInputList & dense_list , int64 batch_size , FeatureReaders * features ) { features -> reserve ( input_order_ . size ( ) ) ; int next_ragged = 0 ; int next_sparse = 0 ; int next_dense = 0 ; for ( char c : input_order_ ) { if ( c == 'R' ) { <S2SV_StartBug> TF_RETURN_IF_ERROR ( BuildRaggedFeatureReader ( <S2SV_EndBug> ragged_values_list [ next_ragged ] , ragged_splits_list [ next_ragged ] , features ) ) ; next_ragged ++ ; } else if ( c == 'S' ) { <S2SV_StartBug> TF_RETURN_IF_ERROR ( BuildSparseFeatureReader ( <S2SV_EndBug> sparse_indices_list [ next_sparse ] , sparse_values_list [ next_sparse ] , batch_size , features ) ) ; next_sparse ++ ; <S2SV_StartBug> } else if ( c == 'D' ) { <S2SV_EndBug> TF_RETURN_IF_ERROR ( BuildDenseFeatureReader ( dense_list [ next_dense ++ ] , features ) ) ; } else { return errors : : InvalidArgument ( \"Unexpected<S2SV_blank>input_order<S2SV_blank>value.\" ) ; } } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> 'R' ) { if ( next_ragged >= ragged_values_list . size ( ) ) return errors : : InvalidArgument ( \"input_order<S2SV_blank>\\\\\"\" , input_order_ , \"\\\\\"<S2SV_blank>specifies<S2SV_blank>reading<S2SV_blank>a<S2SV_blank>ragged<S2SV_blank>tensor<S2SV_blank>value<S2SV_blank>at<S2SV_blank>index<S2SV_blank>\" , next_ragged , \"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>list<S2SV_blank>of<S2SV_blank>\" , ragged_values_list . size ( ) , \"<S2SV_blank>values.\" ) ; if ( next_ragged >= ragged_splits_list . size ( ) ) return errors : : InvalidArgument ( \"input_order<S2SV_blank>\\\\\"\" , input_order_ , \"\\\\\"<S2SV_blank>specifies<S2SV_blank>reading<S2SV_blank>a<S2SV_blank>ragged<S2SV_blank>tensor<S2SV_blank>split<S2SV_blank>at<S2SV_blank>index<S2SV_blank>\" , next_ragged , \"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>list<S2SV_blank>of<S2SV_blank>\" , ragged_splits_list . size ( ) , \"<S2SV_blank>splits.\" ) ; <S2SV_ModStart> 'S' ) { if ( next_sparse >= sparse_values_list . size ( ) ) return errors : : InvalidArgument ( \"input_order<S2SV_blank>\\\\\"\" , input_order_ , \"\\\\\"<S2SV_blank>specifies<S2SV_blank>reading<S2SV_blank>a<S2SV_blank>sparse<S2SV_blank>tensor<S2SV_blank>value<S2SV_blank>at<S2SV_blank>index<S2SV_blank>\" , next_sparse , \"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>list<S2SV_blank>of<S2SV_blank>\" , sparse_values_list . size ( ) , \"<S2SV_blank>values.\" ) ; if ( next_sparse >= sparse_indices_list . size ( ) ) return errors : : InvalidArgument ( \"input_order<S2SV_blank>\\\\\"\" , input_order_ , \"\\\\\"<S2SV_blank>specifies<S2SV_blank>reading<S2SV_blank>a<S2SV_blank>sparse<S2SV_blank>tensor<S2SV_blank>index<S2SV_blank>at<S2SV_blank>index<S2SV_blank>\" , next_sparse , \"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>list<S2SV_blank>of<S2SV_blank>\" , sparse_indices_list . size ( ) , \"<S2SV_blank>indices.\" ) ; <S2SV_ModStart> 'D' ) { if ( next_dense >= dense_list . size ( ) ) return errors : : InvalidArgument ( \"input_order<S2SV_blank>\\\\\"\" , input_order_ , \"\\\\\"<S2SV_blank>specifies<S2SV_blank>reading<S2SV_blank>a<S2SV_blank>dense<S2SV_blank>tensor<S2SV_blank>at<S2SV_blank>index<S2SV_blank>\" , next_dense , \"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>list<S2SV_blank>of<S2SV_blank>\" , dense_list . size ( ) , \"<S2SV_blank>tensors.\" ) ;"}
{"source": "CWE-20 void Compute ( OpKernelContext * ctx ) override { const Tensor & input = ctx -> input ( 0 ) ; const Tensor & input_min_tensor = ctx -> input ( 1 ) ; const Tensor & input_max_tensor = ctx -> input ( 2 ) ; int num_slices = 1 ; if ( axis_ > - 1 ) { num_slices = input . dim_size ( axis_ ) ; } <S2SV_StartBug> <S2SV_EndBug> Tensor * output = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , input . shape ( ) , & output ) ) ; Tensor float_output = need_cast_ ? tensorflow : : Tensor ( DT_FLOAT , input . shape ( ) ) : * output ; if ( num_slices == 1 ) { const float min_range = input_min_tensor . flat < float > ( ) ( 0 ) ; const float max_range = input_max_tensor . flat < float > ( ) ( 0 ) ; DequantizeTensor ( ctx , input , min_range , max_range , & float_output ) ; } else { OP_REQUIRES ( ctx , mode_ != QUANTIZE_MODE_MIN_FIRST , errors : : Unimplemented ( \"MIN_FIRST<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>for<S2SV_blank>\" \"Dequantize<S2SV_blank>with<S2SV_blank>axis<S2SV_blank>!=<S2SV_blank>-1.\" ) ) ; int64 pre_dim = 1 , post_dim = 1 ; for ( int i = 0 ; i < axis_ ; ++ i ) { pre_dim *= float_output . dim_size ( i ) ; } for ( int i = axis_ + 1 ; i < float_output . dims ( ) ; ++ i ) { post_dim *= float_output . dim_size ( i ) ; } auto input_tensor = input . template bit_casted_shaped < T , 3 > ( { pre_dim , num_slices , post_dim } ) ; auto output_tensor = float_output . flat_inner_outer_dims < float , 3 > ( axis_ - 1 ) ; auto min_ranges = input_min_tensor . vec < float > ( ) ; auto max_ranges = input_max_tensor . vec < float > ( ) ; for ( int i = 0 ; i < num_slices ; ++ i ) { DequantizeSlice ( ctx -> eigen_device < Device > ( ) , ctx , input_tensor . template chip < 1 > ( i ) , min_ranges ( i ) , max_ranges ( i ) , output_tensor . template chip < 1 > ( i ) ) ; } } if ( need_cast_ ) { S * out_ptr = output -> flat < S > ( ) . data ( ) ; float * in_ptr = float_output . flat < float > ( ) . data ( ) ; for ( int64 i = 0 ; i < float_output . NumElements ( ) ; ++ i ) { out_ptr [ i ] = static_cast < S > ( in_ptr [ i ] ) ; } } }", "target": "<S2SV_ModStart> ) ; } OP_REQUIRES ( ctx , input_min_tensor . NumElements ( ) == num_slices , errors : : InvalidArgument ( \"input_min_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>as<S2SV_blank>many<S2SV_blank>elements<S2SV_blank>as<S2SV_blank>input<S2SV_blank>on<S2SV_blank>\" \"the<S2SV_blank>dequantization<S2SV_blank>axis<S2SV_blank>(\" , axis_ , \"),<S2SV_blank>got<S2SV_blank>\" , input_min_tensor . NumElements ( ) , \",<S2SV_blank>expected<S2SV_blank>\" , num_slices ) ) ; OP_REQUIRES ( ctx , input_max_tensor . NumElements ( ) == num_slices , errors : : InvalidArgument ( \"input_max_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>as<S2SV_blank>many<S2SV_blank>elements<S2SV_blank>as<S2SV_blank>input<S2SV_blank>on<S2SV_blank>\" \"the<S2SV_blank>dequantization<S2SV_blank>axis<S2SV_blank>(\" , axis_ , \"),<S2SV_blank>got<S2SV_blank>\" , input_max_tensor . NumElements ( ) , \",<S2SV_blank>expected<S2SV_blank>\" , num_slices ) ) ;"}
{"source": "CWE-125 CallResult < PseudoHandle < >> JSObject : : getComputedWithReceiver_RJS ( Handle < JSObject > selfHandle , Runtime * runtime , Handle < > nameValHandle , Handle < > receiver ) { if ( selfHandle -> flags_ . fastIndexProperties ) { if ( auto arrayIndex = toArrayIndexFastPath ( * nameValHandle ) ) { PseudoHandle < > ourValue = createPseudoHandle ( getOwnIndexed ( selfHandle . get ( ) , runtime , * arrayIndex ) ) ; if ( LLVM_LIKELY ( ! ourValue -> isEmpty ( ) ) ) return ourValue ; } } auto converted = toPropertyKeyIfObject ( runtime , nameValHandle ) ; if ( LLVM_UNLIKELY ( converted == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } auto nameValPrimitiveHandle = * converted ; ComputedPropertyDescriptor desc ; MutableHandle < JSObject > propObj { runtime } ; if ( LLVM_UNLIKELY ( getComputedPrimitiveDescriptor ( selfHandle , runtime , nameValPrimitiveHandle , propObj , desc ) == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } if ( ! propObj ) return createPseudoHandle ( HermesValue : : encodeUndefinedValue ( ) ) ; if ( LLVM_LIKELY ( ! desc . flags . accessor && ! desc . flags . hostObject && ! desc . flags . proxyObject ) ) return createPseudoHandle ( getComputedSlotValue ( propObj . get ( ) , runtime , desc ) ) ; if ( desc . flags . accessor ) { auto * accessor = vmcast < PropertyAccessor > ( getComputedSlotValue ( propObj . get ( ) , runtime , desc ) ) ; if ( ! accessor -> getter ) return createPseudoHandle ( HermesValue : : encodeUndefinedValue ( ) ) ; return accessor -> getter . get ( runtime ) -> executeCall0 ( runtime -> makeHandle ( accessor -> getter ) , runtime , receiver ) ; } else if ( desc . flags . hostObject ) { SymbolID id { } ; LAZY_TO_IDENTIFIER ( runtime , nameValPrimitiveHandle , id ) ; <S2SV_StartBug> auto propRes = vmcast < HostObject > ( selfHandle . get ( ) ) -> get ( id ) ; <S2SV_EndBug> if ( propRes == ExecutionStatus : : EXCEPTION ) return ExecutionStatus : : EXCEPTION ; return createPseudoHandle ( * propRes ) ; } else { assert ( desc . flags . proxyObject && \"descriptor<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>impossible\" ) ; CallResult < Handle < >> key = toPropertyKey ( runtime , nameValPrimitiveHandle ) ; if ( key == ExecutionStatus : : EXCEPTION ) return ExecutionStatus : : EXCEPTION ; return JSProxy : : getComputed ( propObj , runtime , * key , receiver ) ; } }", "target": "<S2SV_ModStart> HostObject > ( propObj <S2SV_ModEnd> . get ("}
{"source": "CWE-476 GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; Bool zfound = GF_FALSE ; <S2SV_StartBug> GF_Err e ; <S2SV_EndBug> ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) ptr -> size ; tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) { zfound = GF_TRUE ; break ; } i ++ ; } if ( ! zfound ) <S2SV_StartBug> return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; zfound = GF_FALSE ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) { zfound = GF_TRUE ; break ; } j ++ ; } if ( ! zfound ) <S2SV_StartBug> return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; zfound = GF_FALSE ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) { zfound = GF_TRUE ; break ; } j ++ ; } if ( ! zfound ) <S2SV_StartBug> return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } <S2SV_StartBug> <S2SV_EndBug> i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; zfound = GF_FALSE ; while ( tmp_strsize ) { <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) { zfound = GF_TRUE ; break ; } i ++ ; } if ( ! zfound ) <S2SV_StartBug> return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; zfound = GF_FALSE ; while ( tmp_strsize ) { <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) { zfound = GF_TRUE ; break ; } i ++ ; } if ( ! zfound ) <S2SV_StartBug> return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; <S2SV_StartBug> gf_free ( tmp_str ) ; <S2SV_EndBug> return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_EndBug> ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; <S2SV_StartBug> gf_free ( tmp_str ) ; <S2SV_EndBug> return e ; } <S2SV_StartBug> gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; <S2SV_EndBug> } gf_free ( tmp_str ) ; return GF_OK ; }", "target": "<S2SV_ModStart> ; GF_Err e = GF_OK <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> ! zfound ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } <S2SV_ModEnd> if ( i <S2SV_ModStart> ) ; } ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> ! zfound ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } <S2SV_ModEnd> if ( j <S2SV_ModStart> ; } } if ( ptr -> server_entry_count != gf_list_count ( ptr -> server_entry_table ) ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> ! zfound ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } <S2SV_ModEnd> if ( j <S2SV_ModStart> ; } } if ( ptr -> quality_entry_count != gf_list_count ( ptr -> quality_entry_table ) ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> ! zfound ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } <S2SV_ModEnd> if ( i <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> ! zfound ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } <S2SV_ModEnd> if ( i <S2SV_ModStart> ) ; } ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> asrt ) ; goto exit <S2SV_ModEnd> ; } gf_list_add <S2SV_ModStart> ) ; } if ( ptr -> segment_run_table_count != gf_list_count ( ptr -> segment_run_table_entries ) ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } ISOM_DECREASE_SIZE_GOTO_EXIT <S2SV_ModEnd> ( ptr , <S2SV_ModStart> afrt ) ; goto exit ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } if ( ptr -> fragment_run_table_count != gf_list_count ( ptr -> fragment_run_table_entries ) ) { e = GF_ISOM_INVALID_FILE ; goto exit ; } exit : <S2SV_ModStart> e ; } <S2SV_ModEnd>  <S2SV_null> <S2SV_null>"}
{"source": "CWE-787 void sqlite3Fts5UnicodeAscii ( u8 * aArray , u8 * aAscii ) { int i = 0 ; int iTbl = 0 ; while ( i < 128 ) { int bToken = aArray [ aFts5UnicodeData [ iTbl ] & 0x1F ] ; int n = ( aFts5UnicodeData [ iTbl ] >> 5 ) + i ; for ( ; i < 128 && i < n ; i ++ ) { aAscii [ i ] = ( u8 ) bToken ; } iTbl ++ ; } <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> ++ ; } aAscii [ 0 ] = 0 ;"}
{"source": "CWE-787 int32_t * enc_untrusted_create_wait_queue ( ) { MessageWriter input ; MessageReader output ; input . Push < uint64_t > ( sizeof ( int32_t ) ) ; const auto status = NonSystemCallDispatcher ( : : asylo : : host_call : : kLocalLifetimeAllocHandler , & input , & output ) ; CheckStatusAndParamCount ( status , output , \"enc_untrusted_create_wait_queue\" , 2 ) ; int32_t * queue = reinterpret_cast < int32_t * > ( output . next < uintptr_t > ( ) ) ; <S2SV_StartBug> int klinux_errno = output . next < int > ( ) ; <S2SV_EndBug> if ( queue == nullptr ) { errno = FromkLinuxErrorNumber ( klinux_errno ) ; } enc_untrusted_disable_waiting ( queue ) ; return queue ; }", "target": "<S2SV_ModStart> ) ) ; if ( ! TrustedPrimitives : : IsOutsideEnclave ( queue , sizeof ( int32_t ) ) ) { TrustedPrimitives : : BestEffortAbort ( \"enc_untrusted_create_wait_queue:<S2SV_blank>queue<S2SV_blank>should<S2SV_blank>be<S2SV_blank>in<S2SV_blank>untrusted<S2SV_blank>memory\" ) ; }"}
{"source": "CWE-476 bool CClient : : OnTextMessage ( CTextMessage & Message ) { CString sTargets = Message . GetTarget ( ) ; VCString vTargets ; sTargets . Split ( \",\" , vTargets , false ) ; for ( CString & sTarget : vTargets ) { Message . SetTarget ( sTarget ) ; if ( m_pNetwork ) { Message . SetChan ( m_pNetwork -> FindChan ( sTarget ) ) ; } <S2SV_StartBug> if ( sTarget . TrimPrefix ( m_pUser -> GetStatusPrefix ( ) ) ) { <S2SV_EndBug> if ( sTarget . Equals ( \"status\" ) ) { CString sMsg = Message . GetText ( ) ; UserCommand ( sMsg ) ; } else { CALLMOD ( sTarget , this , m_pUser , m_pNetwork , OnModCommand ( Message . GetText ( ) ) ) ; } continue ; } bool bContinue = false ; NETWORKMODULECALL ( OnUserTextMessage ( Message ) , m_pUser , m_pNetwork , this , & bContinue ) ; if ( bContinue ) continue ; if ( ! GetIRCSock ( ) ) { if ( ! sTarget . Equals ( m_sNick ) ) PutStatus ( t_f ( \"Your<S2SV_blank>message<S2SV_blank>to<S2SV_blank>{1}<S2SV_blank>got<S2SV_blank>lost,<S2SV_blank>you<S2SV_blank>are<S2SV_blank>not<S2SV_blank>connected<S2SV_blank>\" \"to<S2SV_blank>IRC!\" ) ( Message . GetTarget ( ) ) ) ; continue ; } if ( m_pNetwork ) { AddBuffer ( Message ) ; EchoMessage ( Message ) ; PutIRC ( Message . ToString ( CMessage : : ExcludePrefix | CMessage : : ExcludeTags ) ) ; } } return true ; }", "target": "<S2SV_ModStart> ) ) { EchoMessage ( Message ) ;"}
{"source": "CWE-787 GF_Err Media_CheckDataEntry ( GF_MediaBox * mdia , u32 dataEntryIndex ) { GF_DataEntryURLBox * entry ; GF_DataMap * map ; GF_Err e ; if ( ! mdia || ! dataEntryIndex || dataEntryIndex > gf_list_count ( mdia -> information -> dataInformation -> dref -> child_boxes ) ) return GF_BAD_PARAM ; entry = ( GF_DataEntryURLBox * ) gf_list_get ( mdia -> information -> dataInformation -> dref -> child_boxes , dataEntryIndex - 1 ) ; if ( ! entry ) return GF_ISOM_INVALID_FILE ; if ( entry -> flags == 1 ) return GF_OK ; <S2SV_StartBug> if ( entry -> type == GF_ISOM_BOX_TYPE_URN ) return GF_NOT_SUPPORTED ; <S2SV_EndBug> if ( mdia -> mediaTrack -> moov -> mov -> openMode == GF_ISOM_OPEN_WRITE ) { e = gf_isom_datamap_new ( entry -> location , NULL , GF_ISOM_DATA_MAP_READ , & map ) ; } else { e = gf_isom_datamap_new ( entry -> location , mdia -> mediaTrack -> moov -> mov -> fileName , GF_ISOM_DATA_MAP_READ , & map ) ; } if ( e ) return e ; gf_isom_datamap_del ( map ) ; return GF_OK ; }", "target": "<S2SV_ModStart> ; if ( ( <S2SV_ModStart> entry -> type != GF_ISOM_BOX_TYPE_URL ) && ( entry -> type != GF_QT_BOX_TYPE_ALIS ) ) <S2SV_ModEnd> return GF_NOT_SUPPORTED ;"}
{"source": "CWE-703 R_API void r_core_fini ( RCore * c ) { if ( ! c ) { return ; } r_core_task_break_all ( & c -> tasks ) ; r_core_task_join ( & c -> tasks , NULL , - 1 ) ; r_core_wait ( c ) ; r_list_free ( c -> ropchain ) ; r_event_free ( c -> ev ) ; free ( c -> cmdlog ) ; free ( c -> lastsearch ) ; R_FREE ( c -> cons -> pager ) ; free ( c -> cmdqueue ) ; free ( c -> lastcmd ) ; free ( c -> stkcmd ) ; r_list_free ( c -> visual . tabs ) ; free ( c -> block ) ; r_core_autocomplete_free ( c -> autocomplete ) ; r_list_free ( c -> gadgets ) ; r_list_free ( c -> undos ) ; r_num_free ( c -> num ) ; <S2SV_StartBug> free ( c -> table_query ) ; <S2SV_EndBug> r_list_free ( c -> files ) ; r_list_free ( c -> watchers ) ; r_list_free ( c -> scriptstack ) ; r_core_task_scheduler_fini ( & c -> tasks ) ; c -> rcmd = r_cmd_free ( c -> rcmd ) ; r_list_free ( c -> cmd_descriptors ) ; c -> anal = r_anal_free ( c -> anal ) ; r_asm_free ( c -> assembler ) ; c -> assembler = NULL ; c -> print = r_print_free ( c -> print ) ; c -> bin = ( r_bin_free ( c -> bin ) , NULL ) ; c -> lang = ( r_lang_free ( c -> lang ) , NULL ) ; c -> dbg = ( r_debug_free ( c -> dbg ) , NULL ) ; r_io_free ( c -> io ) ; r_config_free ( c -> config ) ; r_cons_free ( ) ; r_cons_singleton ( ) -> teefile = NULL ; r_search_free ( c -> search ) ; r_flag_free ( c -> flags ) ; r_fs_free ( c -> fs ) ; r_egg_free ( c -> egg ) ; r_lib_free ( c -> lib ) ; r_buf_free ( c -> yank_buf ) ; r_agraph_free ( c -> graph ) ; free ( c -> asmqjmps ) ; sdb_free ( c -> sdb ) ; r_core_log_free ( c -> log ) ; r_parse_free ( c -> parser ) ; free ( c -> times ) ; }", "target": "<S2SV_ModStart> num ) ; R_FREE <S2SV_ModEnd> ( c ->"}
{"source": "CWE-369 inline void ComputeInterpolationWeights ( const int64 out_size , const int64 in_size , const float scale , const int resolution , InterpolationCache < T_SCALE > * interpolation ) { const Scaler scaler ; interpolation -> lower . resize ( out_size + 1 ) ; interpolation -> upper . resize ( out_size + 1 ) ; interpolation -> lerp . resize ( out_size + 1 ) ; interpolation -> ilerp . resize ( out_size + 1 ) ; interpolation -> lower [ out_size ] = 0 ; interpolation -> upper [ out_size ] = 0 ; for ( int64 i = out_size - 1 ; i >= 0 ; -- i ) { const float in = scaler ( i , scale ) ; const float in_f = std : : floor ( in ) ; interpolation -> lower [ i ] = std : : max ( static_cast < int64 > ( in_f ) , static_cast < int64 > ( 0 ) ) ; interpolation -> upper [ i ] = std : : min ( static_cast < int64 > ( std : : ceil ( in ) ) , in_size - 1 ) ; <S2SV_StartBug> interpolation -> lerp [ i ] = in - in_f ; <S2SV_EndBug> interpolation -> ilerp [ i ] = static_cast < T_SCALE > ( ( in - in_f ) * ( 1 << resolution ) ) ; } }", "target": "<S2SV_ModStart> ; interpolation -> lower [ i ] = std : : min ( interpolation -> lower [ i ] , interpolation -> upper [ i ] ) ; interpolation ->"}
{"source": "CWE-787 void Compute ( OpKernelContext * ctx ) override { const Tensor & in0 = ctx -> input ( 0 ) ; const Tensor & in1 = ctx -> input ( 1 ) ; <S2SV_StartBug> ValidateInputTensors ( ctx , in0 , in1 ) ; <S2SV_EndBug> MatMulBCast bcast ( in0 . shape ( ) . dim_sizes ( ) , in1 . shape ( ) . dim_sizes ( ) ) ; OP_REQUIRES ( ctx , bcast . IsValid ( ) , errors : : InvalidArgument ( \"In[0]<S2SV_blank>and<S2SV_blank>In[1]<S2SV_blank>must<S2SV_blank>have<S2SV_blank>compatible<S2SV_blank>batch<S2SV_blank>dimensions:<S2SV_blank>\" , in0 . shape ( ) . DebugString ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , in1 . shape ( ) . DebugString ( ) ) ) ; TensorShape out_shape = bcast . output_batch_shape ( ) ; auto batch_size = bcast . output_batch_size ( ) ; auto d0 = in0 . dim_size ( in0 . dims ( ) - 2 ) ; auto d1 = in0 . dim_size ( in0 . dims ( ) - 1 ) ; Tensor in0_reshaped ; OP_REQUIRES ( ctx , in0_reshaped . CopyFrom ( in0 , TensorShape ( { bcast . x_batch_size ( ) , d0 , d1 } ) ) , errors : : Internal ( \"Failed<S2SV_blank>to<S2SV_blank>reshape<S2SV_blank>In[0]<S2SV_blank>from<S2SV_blank>\" , in0 . shape ( ) . DebugString ( ) ) ) ; auto d2 = in1 . dim_size ( in1 . dims ( ) - 2 ) ; auto d3 = in1 . dim_size ( in1 . dims ( ) - 1 ) ; Tensor in1_reshaped ; OP_REQUIRES ( ctx , in1_reshaped . CopyFrom ( in1 , TensorShape ( { bcast . y_batch_size ( ) , d2 , d3 } ) ) , errors : : Internal ( \"Failed<S2SV_blank>to<S2SV_blank>reshape<S2SV_blank>In[1]<S2SV_blank>from<S2SV_blank>\" , in1 . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , d1 == d2 , errors : : InvalidArgument ( \"In[0]<S2SV_blank>mismatch<S2SV_blank>In[1]<S2SV_blank>shape:<S2SV_blank>\" , d1 , \"<S2SV_blank>vs.<S2SV_blank>\" , d2 , \":<S2SV_blank>\" , in0 . shape ( ) . DebugString ( ) , \"<S2SV_blank>\" , in1 . shape ( ) . DebugString ( ) , \"<S2SV_blank>\" , lower_ , \"<S2SV_blank>\" , adjoint_ ) ) ; out_shape . AddDim ( d1 ) ; out_shape . AddDim ( d3 ) ; Tensor * out = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , out_shape , & out ) ) ; if ( out -> NumElements ( ) == 0 ) { return ; } Tensor out_reshaped ; OP_REQUIRES ( ctx , out_reshaped . CopyFrom ( * out , TensorShape ( { batch_size , d1 , d3 } ) ) , errors : : Internal ( \"Failed<S2SV_blank>to<S2SV_blank>reshape<S2SV_blank>output<S2SV_blank>from<S2SV_blank>\" , out -> shape ( ) . DebugString ( ) ) ) ; LaunchBatchBandedTriangularSolve < Scalar > : : Launch ( ctx , in0_reshaped , in1_reshaped , adjoint_ , lower_ , bcast , & out_reshaped ) ; }", "target": "<S2SV_ModStart> , in1 ) ; if ( ! ctx -> status ( ) . ok ( ) ) return"}
{"source": "CWE-476 Status PyArrayDescr_to_TF_DataType ( PyArray_Descr * descr , TF_DataType * out_tf_datatype ) { PyObject * key ; PyObject * value ; Py_ssize_t pos = 0 ; <S2SV_StartBug> if ( PyDict_Next ( descr -> fields , & pos , & key , & value ) ) { <S2SV_EndBug> const char * key_string = PyBytes_Check ( key ) ? PyBytes_AsString ( key ) : PyBytes_AsString ( PyUnicode_AsASCIIString ( key ) ) ; if ( ! key_string ) { return errors : : Internal ( \"Corrupt<S2SV_blank>numpy<S2SV_blank>type<S2SV_blank>descriptor\" ) ; } tensorflow : : string key = key_string ; if ( key == \"quint8\" ) { * out_tf_datatype = TF_QUINT8 ; } else if ( key == \"qint8\" ) { * out_tf_datatype = TF_QINT8 ; } else if ( key == \"qint16\" ) { * out_tf_datatype = TF_QINT16 ; } else if ( key == \"quint16\" ) { * out_tf_datatype = TF_QUINT16 ; } else if ( key == \"qint32\" ) { * out_tf_datatype = TF_QINT32 ; } else if ( key == \"resource\" ) { * out_tf_datatype = TF_RESOURCE ; } else { return errors : : Internal ( \"Unsupported<S2SV_blank>numpy<S2SV_blank>data<S2SV_blank>type\" ) ; } return Status : : OK ( ) ; } return errors : : Internal ( \"Unsupported<S2SV_blank>numpy<S2SV_blank>data<S2SV_blank>type\" ) ; }", "target": "<S2SV_ModStart> = 0 ; if <S2SV_ModEnd> ( descr -> <S2SV_ModStart> descr -> fields == nullptr ) { return errors : : Internal ( \"Unexpected<S2SV_blank>numpy<S2SV_blank>data<S2SV_blank>type\" ) ; } if ( PyDict_Next ( descr -> fields"}
{"source": "CWE-476 vq_endchains ( struct virtio_vq_info * vq , int used_all_avail ) { struct virtio_base * base ; uint16_t event_idx , new_idx , old_idx ; <S2SV_StartBug> int intr ; <S2SV_EndBug> atomic_thread_fence ( ) ; base = vq -> base ; old_idx = vq -> save_used ; vq -> save_used = new_idx = vq -> used -> idx ; if ( used_all_avail && ( base -> negotiated_caps & ( 1 << VIRTIO_F_NOTIFY_ON_EMPTY ) ) ) intr = 1 ; else if ( base -> negotiated_caps & ( 1 << VIRTIO_RING_F_EVENT_IDX ) ) { event_idx = VQ_USED_EVENT_IDX ( vq ) ; intr = ( uint16_t ) ( new_idx - event_idx - 1 ) < ( uint16_t ) ( new_idx - old_idx ) ; } else { intr = new_idx != old_idx && ! ( vq -> avail -> flags & VRING_AVAIL_F_NO_INTERRUPT ) ; } if ( intr ) vq_interrupt ( base , vq ) ; }", "target": "<S2SV_ModStart> ; int intr ; if ( ! vq || ! vq -> used ) return"}
{"source": "CWE-703 void ComputeEasyCases ( OpKernelContext * context , bool * done , std : : vector < Tlen > * split_sizes_vec ) { const int32_t num_split = context -> num_outputs ( ) ; const Tensor & input = context -> input ( 0 ) ; const TensorShape & input_shape = input . shape ( ) ; const Tensor & split_tensor = context -> input ( 1 ) ; const Tensor & split_dim_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , split_dim_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"split_dim_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>\" \"exactly<S2SV_blank>one<S2SV_blank>element.\" ) ) ; const int32_t split_dim_orig = split_dim_tensor . flat < int32 > ( ) ( 0 ) ; const int32_t split_dim = split_dim_orig < 0 ? split_dim_orig + input . dims ( ) : split_dim_orig ; OP_REQUIRES ( context , split_tensor . dims ( ) == 1 && split_tensor . NumElements ( ) == num_split , errors : : InvalidArgument ( \"size<S2SV_blank>of<S2SV_blank>the<S2SV_blank>split_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-D<S2SV_blank>and<S2SV_blank>have<S2SV_blank>\" \"the<S2SV_blank>same<S2SV_blank>elements<S2SV_blank>as<S2SV_blank>outputs<S2SV_blank>got<S2SV_blank>\" , split_tensor . dims ( ) , \"<S2SV_blank>-D<S2SV_blank>and<S2SV_blank>\" , split_tensor . NumElements ( ) , \"<S2SV_blank>elements\" ) ) ; auto split_sizes_d = split_tensor . vec < Tlen > ( ) ; split_sizes_vec -> resize ( split_sizes_d . size ( ) ) ; std : : copy ( split_sizes_d . data ( ) , split_sizes_d . data ( ) + split_sizes_d . size ( ) , split_sizes_vec -> begin ( ) ) ; OP_REQUIRES ( context , num_split > 0 , errors : : InvalidArgument ( \"Number<S2SV_blank>of<S2SV_blank>ways<S2SV_blank>to<S2SV_blank>split<S2SV_blank>should<S2SV_blank>be<S2SV_blank>><S2SV_blank>0,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , num_split ) ) ; OP_REQUIRES ( context , 0 <= split_dim && split_dim < input . dims ( ) , errors : : InvalidArgument ( \"-input<S2SV_blank>rank(-\" , input . dims ( ) , \")<S2SV_blank><=<S2SV_blank>split_dim<S2SV_blank><<S2SV_blank>input<S2SV_blank>rank<S2SV_blank>(\" , input . dims ( ) , \"),<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , split_dim_orig ) ) ; Tlen input_size_split_dim = input_shape . dim_size ( split_dim ) ; if ( num_split == 1 ) { context -> set_output ( 0 , context -> input ( 0 ) ) ; OP_REQUIRES ( context , ( * split_sizes_vec ) [ 0 ] == input_size_split_dim , errors : : InvalidArgument ( \"If<S2SV_blank>there<S2SV_blank>is<S2SV_blank>only<S2SV_blank>one<S2SV_blank>output,<S2SV_blank>it<S2SV_blank>must<S2SV_blank>have<S2SV_blank>\" \"the<S2SV_blank>same<S2SV_blank>size<S2SV_blank>as<S2SV_blank>the<S2SV_blank>input.<S2SV_blank>Input<S2SV_blank>size:<S2SV_blank>\" , input_size_split_dim , \"<S2SV_blank>output<S2SV_blank>size:<S2SV_blank>\" , ( * split_sizes_vec ) [ 0 ] ) ) ; * done = true ; return ; } int neg_one_dim = - 1 ; Tlen determined_size = 0 ; for ( int d = 0 ; d < split_sizes_vec -> size ( ) ; ++ d ) { Tlen size = ( * split_sizes_vec ) [ d ] ; if ( size == - 1 ) { OP_REQUIRES ( context , neg_one_dim == - 1 , errors : : InvalidArgument ( \"There<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>one<S2SV_blank>-1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>\" \"input.\" ) ) ; neg_one_dim = d ; } else { determined_size += size ; } } OP_REQUIRES ( context , ( neg_one_dim == - 1 && determined_size == input_size_split_dim ) || ( neg_one_dim >= 0 && determined_size <= input_size_split_dim ) , errors : : InvalidArgument ( \"Determined<S2SV_blank>shape<S2SV_blank>must<S2SV_blank>either<S2SV_blank>match<S2SV_blank>\" \"input<S2SV_blank>shape<S2SV_blank>along<S2SV_blank>split_dim<S2SV_blank>exactly<S2SV_blank>if<S2SV_blank>\" \"fully<S2SV_blank>specified,<S2SV_blank>or<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>the<S2SV_blank>size<S2SV_blank>of<S2SV_blank>\" \"the<S2SV_blank>input<S2SV_blank>along<S2SV_blank>split_dim<S2SV_blank>if<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>\" \"specified.<S2SV_blank><S2SV_blank>Got:<S2SV_blank>\" , determined_size ) ) ; if ( neg_one_dim >= 0 ) { ( * split_sizes_vec ) [ neg_one_dim ] = input_size_split_dim - determined_size ; } <S2SV_StartBug> if ( SplitHasAlignedOutputsInFirstDimension ( <S2SV_EndBug> input_shape , split_dim , absl : : MakeConstSpan ( * split_sizes_vec ) ) ) { Tlen start = 0 ; for ( int i = 0 ; i < num_split ; ++ i ) { context -> set_output ( i , input . Slice ( start , start + ( * split_sizes_vec ) [ i ] ) ) ; start += ( * split_sizes_vec ) [ i ] ; } * done = true ; return ; } }", "target": "<S2SV_ModStart> determined_size ; } for ( int i = 0 ; i < split_sizes_vec -> size ( ) ; ++ i ) { const Tlen & split_size = ( * split_sizes_vec ) [ i ] ; OP_REQUIRES ( context , split_size >= Tlen ( 0 ) , errors : : InvalidArgument ( \"Split<S2SV_blank>size<S2SV_blank>at<S2SV_blank>index<S2SV_blank>\" , i , \"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>0.<S2SV_blank>Got:<S2SV_blank>\" , split_size ) ) ; }"}
{"source": "CWE-787 int processClientServerHello ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , uint32_t quic_version ) { struct ndpi_packet_struct * packet = & flow -> packet ; union ja3_info ja3 ; u_int8_t invalid_ja3 = 0 ; u_int16_t tls_version , ja3_str_len ; char ja3_str [ JA3_STR_LEN ] ; ndpi_MD5_CTX ctx ; u_char md5_hash [ 16 ] ; int i ; u_int16_t total_len ; u_int8_t handshake_type ; char buffer [ 64 ] = { '\\\\0' } ; int is_quic = ( quic_version != 0 ) ; int is_dtls = packet -> udp && ( ! is_quic ) ; # ifdef DEBUG_TLS printf ( \"TLS<S2SV_blank>%s()<S2SV_blank>called\\\\n\" , __FUNCTION__ ) ; # endif memset ( & ja3 , 0 , sizeof ( ja3 ) ) ; handshake_type = packet -> payload [ 0 ] ; total_len = ( packet -> payload [ 1 ] << 16 ) + ( packet -> payload [ 2 ] << 8 ) + packet -> payload [ 3 ] ; if ( ( total_len > packet -> payload_packet_len ) || ( packet -> payload [ 1 ] != 0x0 ) ) return ( 0 ) ; total_len = packet -> payload_packet_len ; if ( total_len > 4 ) { u_int16_t base_offset = ( ! is_dtls ) ? 38 : 46 ; u_int16_t version_offset = ( ! is_dtls ) ? 4 : 12 ; u_int16_t offset = ( ! is_dtls ) ? 38 : 46 , extension_len , j ; u_int8_t session_id_len = 0 ; if ( ( base_offset >= total_len ) || ( version_offset + 1 ) >= total_len ) return 0 ; session_id_len = packet -> payload [ base_offset ] ; # ifdef DEBUG_TLS printf ( \"TLS<S2SV_blank>[len:<S2SV_blank>%u][handshake_type:<S2SV_blank>%02X]\\\\n\" , packet -> payload_packet_len , handshake_type ) ; # endif tls_version = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ version_offset ] ) ) ; if ( handshake_type == 0x02 ) { int i , rc ; ja3 . server . tls_handshake_version = tls_version ; # ifdef DEBUG_TLS printf ( \"TLS<S2SV_blank>Server<S2SV_blank>Hello<S2SV_blank>[version:<S2SV_blank>0x%04X]\\\\n\" , tls_version ) ; # endif if ( packet -> udp ) offset += session_id_len + 1 ; else { if ( tls_version < 0x7F15 ) offset += session_id_len + 1 ; } if ( ( offset + 3 ) > packet -> payload_packet_len ) return ( 0 ) ; ja3 . server . num_cipher = 1 , ja3 . server . cipher [ 0 ] = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset ] ) ) ; if ( ( flow -> protos . tls_quic_stun . tls_quic . server_unsafe_cipher = ndpi_is_safe_ssl_cipher ( ja3 . server . cipher [ 0 ] ) ) == 1 ) ndpi_set_risk ( flow , NDPI_TLS_WEAK_CIPHER ) ; flow -> protos . tls_quic_stun . tls_quic . server_cipher = ja3 . server . cipher [ 0 ] ; # ifdef DEBUG_TLS printf ( \"TLS<S2SV_blank>[server][session_id_len:<S2SV_blank>%u][cipher:<S2SV_blank>%04X]\\\\n\" , session_id_len , ja3 . server . cipher [ 0 ] ) ; # endif offset += 2 + 1 ; if ( ( offset + 1 ) < packet -> payload_packet_len ) extension_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset ] ) ) ; else extension_len = 0 ; # ifdef DEBUG_TLS printf ( \"TLS<S2SV_blank>[server][extension_len:<S2SV_blank>%u]\\\\n\" , extension_len ) ; # endif offset += 2 ; for ( i = 0 ; i < extension_len ; ) { u_int16_t extension_id , extension_len ; if ( ( offset + 4 ) > packet -> payload_packet_len ) break ; extension_id = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset ] ) ) ; extension_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset + 2 ] ) ) ; if ( ja3 . server . num_tls_extension < MAX_NUM_JA3 ) ja3 . server . tls_extension [ ja3 . server . num_tls_extension ++ ] = extension_id ; # ifdef DEBUG_TLS printf ( \"TLS<S2SV_blank>[server][extension_id:<S2SV_blank>%u/0x%04X][len:<S2SV_blank>%u]\\\\n\" , extension_id , extension_id , extension_len ) ; # endif if ( extension_id == 43 ) { if ( extension_len >= 2 ) { u_int16_t tls_version = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset + 4 ] ) ) ; # ifdef DEBUG_TLS printf ( \"TLS<S2SV_blank>[server]<S2SV_blank>[TLS<S2SV_blank>version:<S2SV_blank>0x%04X]\\\\n\" , tls_version ) ; # endif flow -> protos . tls_quic_stun . tls_quic . ssl_version = ja3 . server . tls_supported_version = tls_version ; } } else if ( extension_id == 16 ) { u_int16_t s_offset = offset + 4 ; u_int16_t tot_alpn_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset ] ) ) ; char alpn_str [ 256 ] ; u_int8_t alpn_str_len = 0 , i ; # ifdef DEBUG_TLS printf ( \"Server<S2SV_blank>TLS<S2SV_blank>[ALPN:<S2SV_blank>block_len=%u/len=%u]\\\\n\" , extension_len , tot_alpn_len ) ; # endif s_offset += 2 ; tot_alpn_len += s_offset ; while ( s_offset < tot_alpn_len && s_offset < total_len ) { u_int8_t alpn_i , alpn_len = packet -> payload [ s_offset ++ ] ; if ( ( s_offset + alpn_len ) <= tot_alpn_len ) { # ifdef DEBUG_TLS printf ( \"Server<S2SV_blank>TLS<S2SV_blank>[ALPN:<S2SV_blank>%u]\\\\n\" , alpn_len ) ; # endif if ( ( alpn_str_len + alpn_len + 1 ) < ( sizeof ( alpn_str ) - 1 ) ) { if ( alpn_str_len > 0 ) { alpn_str [ alpn_str_len ] = ',' ; alpn_str_len ++ ; } for ( alpn_i = 0 ; alpn_i < alpn_len ; alpn_i ++ ) { alpn_str [ alpn_str_len + alpn_i ] = packet -> payload [ s_offset + alpn_i ] ; } s_offset += alpn_len , alpn_str_len += alpn_len ; ; } else { ndpi_set_risk ( flow , NDPI_TLS_UNCOMMON_ALPN ) ; break ; } } else { ndpi_set_risk ( flow , NDPI_TLS_UNCOMMON_ALPN ) ; break ; } } alpn_str [ alpn_str_len ] = '\\\\0' ; # ifdef DEBUG_TLS printf ( \"Server<S2SV_blank>TLS<S2SV_blank>[ALPN:<S2SV_blank>%s][len:<S2SV_blank>%u]\\\\n\" , alpn_str , alpn_str_len ) ; # endif if ( flow -> protos . tls_quic_stun . tls_quic . alpn == NULL ) flow -> protos . tls_quic_stun . tls_quic . alpn = ndpi_strdup ( alpn_str ) ; if ( flow -> protos . tls_quic_stun . tls_quic . alpn != NULL ) tlsCheckUncommonALPN ( flow ) ; snprintf ( ja3 . server . alpn , sizeof ( ja3 . server . alpn ) , \"%s\" , alpn_str ) ; for ( i = 0 ; ja3 . server . alpn [ i ] != '\\\\0' ; i ++ ) if ( ja3 . server . alpn [ i ] == ',' ) ja3 . server . alpn [ i ] = '-' ; } else if ( extension_id == 11 ) { u_int16_t s_offset = offset + 4 + 1 ; # ifdef DEBUG_TLS printf ( \"Server<S2SV_blank>TLS<S2SV_blank>[EllipticCurveFormat:<S2SV_blank>len=%u]\\\\n\" , extension_len ) ; # endif if ( ( s_offset + extension_len - 1 ) <= total_len ) { for ( i = 0 ; i < extension_len - 1 ; i ++ ) { u_int8_t s_group = packet -> payload [ s_offset + i ] ; # ifdef DEBUG_TLS printf ( \"Server<S2SV_blank>TLS<S2SV_blank>[EllipticCurveFormat:<S2SV_blank>%u]\\\\n\" , s_group ) ; # endif if ( ja3 . server . num_elliptic_curve_point_format < MAX_NUM_JA3 ) ja3 . server . elliptic_curve_point_format [ ja3 . server . num_elliptic_curve_point_format ++ ] = s_group ; else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Server<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>num<S2SV_blank>elliptic<S2SV_blank>%u\\\\n\" , ja3 . server . num_elliptic_curve_point_format ) ; # endif } } } else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Server<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>vs<S2SV_blank>%u\\\\n\" , s_offset + extension_len , total_len ) ; # endif } } i += 4 + extension_len , offset += 4 + extension_len ; } <S2SV_StartBug> ja3_str_len = snprintf ( ja3_str , sizeof ( ja3_str ) , \"%u,\" , ja3 . server . tls_handshake_version ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ja3 . server . num_cipher ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \"%s%u\" , ( i > 0 ) ? \"-\" : \"\" , ja3 . server . cipher [ i ] ) ; <S2SV_EndBug> if ( rc <= 0 ) break ; else ja3_str_len += rc ; } <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \",\" ) ; <S2SV_EndBug> if ( rc > 0 && ja3_str_len + rc < JA3_STR_LEN ) ja3_str_len += rc ; <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ja3 . server . num_tls_extension ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \"%s%u\" , ( i > 0 ) ? \"-\" : \"\" , ja3 . server . tls_extension [ i ] ) ; <S2SV_EndBug> if ( rc <= 0 ) break ; else ja3_str_len += rc ; } if ( ndpi_struct -> enable_ja3_plus ) { <S2SV_StartBug> for ( i = 0 ; i < ja3 . server . num_elliptic_curve_point_format ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \"%s%u\" , <S2SV_EndBug> ( i > 0 ) ? \"-\" : \"\" , ja3 . server . elliptic_curve_point_format [ i ] ) ; if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; else break ; } <S2SV_StartBug> if ( ja3 . server . alpn [ 0 ] != '\\\\0' ) { <S2SV_EndBug> <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \",%s\" , ja3 . server . alpn ) ; <S2SV_EndBug> if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; } # ifdef DEBUG_TLS printf ( \"[JA3+]<S2SV_blank>Server:<S2SV_blank>%s<S2SV_blank>\\\\n\" , ja3_str ) ; # endif } else { # ifdef DEBUG_TLS printf ( \"[JA3]<S2SV_blank>Server:<S2SV_blank>%s<S2SV_blank>\\\\n\" , ja3_str ) ; # endif } ndpi_MD5Init ( & ctx ) ; ndpi_MD5Update ( & ctx , ( const unsigned char * ) ja3_str , strlen ( ja3_str ) ) ; ndpi_MD5Final ( md5_hash , & ctx ) ; for ( i = 0 , j = 0 ; i < 16 ; i ++ ) { int rc = snprintf ( & flow -> protos . tls_quic_stun . tls_quic . ja3_server [ j ] , sizeof ( flow -> protos . tls_quic_stun . tls_quic . ja3_server ) - j , \"%02x\" , md5_hash [ i ] ) ; if ( rc <= 0 ) break ; else j += rc ; } # ifdef DEBUG_TLS printf ( \"[JA3]<S2SV_blank>Server:<S2SV_blank>%s<S2SV_blank>\\\\n\" , flow -> protos . tls_quic_stun . tls_quic . ja3_server ) ; # endif } else if ( handshake_type == 0x01 ) { u_int16_t cipher_len , cipher_offset ; u_int8_t cookie_len = 0 ; flow -> protos . tls_quic_stun . tls_quic . ssl_version = ja3 . client . tls_handshake_version = tls_version ; if ( flow -> protos . tls_quic_stun . tls_quic . ssl_version < 0x0302 ) ndpi_set_risk ( flow , NDPI_TLS_OBSOLETE_VERSION ) ; if ( ( session_id_len + base_offset + 3 ) > packet -> payload_packet_len ) return ( 0 ) ; if ( ! is_dtls ) { cipher_len = packet -> payload [ session_id_len + base_offset + 2 ] + ( packet -> payload [ session_id_len + base_offset + 1 ] << 8 ) ; cipher_offset = base_offset + session_id_len + 3 ; } else { cookie_len = packet -> payload [ base_offset + session_id_len + 1 ] ; # ifdef DEBUG_TLS printf ( \"[JA3]<S2SV_blank>Client:<S2SV_blank>DTLS<S2SV_blank>cookie<S2SV_blank>len<S2SV_blank>%d\\\\n\" , cookie_len ) ; # endif if ( ( session_id_len + base_offset + cookie_len + 4 ) > packet -> payload_packet_len ) return ( 0 ) ; cipher_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ base_offset + session_id_len + cookie_len + 2 ] ) ) ; cipher_offset = base_offset + session_id_len + cookie_len + 4 ; } # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[client<S2SV_blank>cipher_len:<S2SV_blank>%u][tls_version:<S2SV_blank>0x%04X]\\\\n\" , cipher_len , tls_version ) ; # endif if ( ( cipher_offset + cipher_len ) <= total_len ) { u_int8_t safari_ciphers = 0 , chrome_ciphers = 0 ; for ( i = 0 ; i < cipher_len ; ) { u_int16_t * id = ( u_int16_t * ) & packet -> payload [ cipher_offset + i ] ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[cipher<S2SV_blank>suite:<S2SV_blank>%u/0x%04X]<S2SV_blank>[%d/%u]\\\\n\" , ntohs ( * id ) , ntohs ( * id ) , i , cipher_len ) ; # endif if ( ( * id == 0 ) || ( packet -> payload [ cipher_offset + i ] != packet -> payload [ cipher_offset + i + 1 ] ) ) { u_int16_t cipher_id = ntohs ( * id ) ; if ( ja3 . client . num_cipher < MAX_NUM_JA3 ) ja3 . client . cipher [ ja3 . client . num_cipher ++ ] = cipher_id ; else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>cipher<S2SV_blank>%u\\\\n\" , ja3 . client . num_cipher ) ; # endif } switch ( cipher_id ) { case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 : case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 : safari_ciphers ++ ; break ; case TLS_CIPHER_GREASE_RESERVED_0 : case TLS_AES_128_GCM_SHA256 : case TLS_AES_256_GCM_SHA384 : case TLS_CHACHA20_POLY1305_SHA256 : chrome_ciphers ++ ; break ; case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 : case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 : case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 : case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 : case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA : case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA : case TLS_RSA_WITH_AES_128_CBC_SHA : case TLS_RSA_WITH_AES_256_CBC_SHA : case TLS_RSA_WITH_AES_128_GCM_SHA256 : case TLS_RSA_WITH_AES_256_GCM_SHA384 : safari_ciphers ++ , chrome_ciphers ++ ; break ; } } i += 2 ; } if ( chrome_ciphers == 13 ) flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_chrome_tls = 1 ; else if ( safari_ciphers == 12 ) flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_safari_tls = 1 ; } else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>vs<S2SV_blank>%u\\\\n\" , ( cipher_offset + cipher_len ) , total_len ) ; # endif } offset = base_offset + session_id_len + cookie_len + cipher_len + 2 ; offset += ( ! is_dtls ) ? 1 : 2 ; if ( offset < total_len ) { u_int16_t compression_len ; u_int16_t extensions_len ; compression_len = packet -> payload [ offset ] ; offset ++ ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[compression_len:<S2SV_blank>%u]\\\\n\" , compression_len ) ; # endif offset += compression_len ; if ( offset + 1 < total_len ) { extensions_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset ] ) ) ; offset += 2 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[extensions_len:<S2SV_blank>%u]\\\\n\" , extensions_len ) ; # endif if ( ( extensions_len + offset ) <= total_len ) { u_int extension_offset = 0 ; u_int32_t j ; while ( extension_offset < extensions_len && offset + extension_offset + 4 <= total_len ) { u_int16_t extension_id , extension_len , extn_off = offset + extension_offset ; extension_id = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset + extension_offset ] ) ) ; extension_offset += 2 ; extension_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ offset + extension_offset ] ) ) ; extension_offset += 2 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[extension_id:<S2SV_blank>%u][extension_len:<S2SV_blank>%u]\\\\n\" , extension_id , extension_len ) ; # endif if ( ( extension_id == 0 ) || ( packet -> payload [ extn_off ] != packet -> payload [ extn_off + 1 ] ) ) { if ( ja3 . client . num_tls_extension < MAX_NUM_JA3 ) ja3 . client . tls_extension [ ja3 . client . num_tls_extension ++ ] = extension_id ; else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>extensions<S2SV_blank>%u\\\\n\" , ja3 . client . num_tls_extension ) ; # endif } } if ( extension_id == 0 ) { u_int16_t len ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>Extensions:<S2SV_blank>found<S2SV_blank>server<S2SV_blank>name\\\\n\" ) ; # endif if ( ( offset + extension_offset + 4 ) < packet -> payload_packet_len ) { len = ( packet -> payload [ offset + extension_offset + 3 ] << 8 ) + packet -> payload [ offset + extension_offset + 4 ] ; len = ( u_int ) ndpi_min ( len , sizeof ( buffer ) - 1 ) ; if ( ( offset + extension_offset + 5 + len ) <= packet -> payload_packet_len ) { strncpy ( buffer , ( char * ) & packet -> payload [ offset + extension_offset + 5 ] , len ) ; buffer [ len ] = '\\\\0' ; cleanupServerName ( buffer , sizeof ( buffer ) ) ; snprintf ( flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name , sizeof ( flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name ) , \"%s\" , buffer ) ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>SNI:<S2SV_blank>[%s]\\\\n\" , buffer ) ; # endif if ( ! is_quic ) { if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , buffer , strlen ( buffer ) ) ) flow -> l4 . tcp . tls . subprotocol_detected = 1 ; } else { if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_QUIC , buffer , strlen ( buffer ) ) ) flow -> l4 . tcp . tls . subprotocol_detected = 1 ; } if ( ndpi_check_dga_name ( ndpi_struct , flow , flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name , 1 ) ) { char * sni = flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name ; int len = strlen ( sni ) ; # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>SNI:<S2SV_blank>(DGA)<S2SV_blank>[%s]\\\\n\" , flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name ) ; # endif if ( ( len >= 4 ) && ( ( strcmp ( & sni [ len - 4 ] , \".com\" ) == 0 ) || ( strcmp ( & sni [ len - 4 ] , \".net\" ) == 0 ) ) && ( strncmp ( sni , \"www.\" , 4 ) == 0 ) ) ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TOR , NDPI_PROTOCOL_TLS ) ; } else { # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>SNI:<S2SV_blank>(NO<S2SV_blank>DGA)<S2SV_blank>[%s]\\\\n\" , flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name ) ; # endif } } else { # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>Extensions<S2SV_blank>server<S2SV_blank>len<S2SV_blank>too<S2SV_blank>short:<S2SV_blank>%u<S2SV_blank>vs<S2SV_blank>%u\\\\n\" , offset + extension_offset + 5 + len , packet -> payload_packet_len ) ; # endif } } } else if ( extension_id == 10 ) { u_int16_t s_offset = offset + extension_offset + 2 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[EllipticCurveGroups:<S2SV_blank>len=%u]\\\\n\" , extension_len ) ; # endif if ( ( s_offset + extension_len - 2 ) <= total_len ) { for ( i = 0 ; i < extension_len - 2 ; ) { u_int16_t s_group = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset + i ] ) ) ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[EllipticCurve:<S2SV_blank>%u/0x%04X]\\\\n\" , s_group , s_group ) ; # endif if ( ( s_group == 0 ) || ( packet -> payload [ s_offset + i ] != packet -> payload [ s_offset + i + 1 ] ) ) { if ( ja3 . client . num_elliptic_curve < MAX_NUM_JA3 ) ja3 . client . elliptic_curve [ ja3 . client . num_elliptic_curve ++ ] = s_group ; else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>num<S2SV_blank>elliptic<S2SV_blank>%u\\\\n\" , ja3 . client . num_elliptic_curve ) ; # endif } } i += 2 ; } } else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>vs<S2SV_blank>%u\\\\n\" , ( s_offset + extension_len - 1 ) , total_len ) ; # endif } } else if ( extension_id == 11 ) { u_int16_t s_offset = offset + extension_offset + 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[EllipticCurveFormat:<S2SV_blank>len=%u]\\\\n\" , extension_len ) ; # endif if ( ( s_offset + extension_len - 1 ) <= total_len ) { for ( i = 0 ; i < extension_len - 1 ; i ++ ) { u_int8_t s_group = packet -> payload [ s_offset + i ] ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[EllipticCurveFormat:<S2SV_blank>%u]\\\\n\" , s_group ) ; # endif if ( ja3 . client . num_elliptic_curve_point_format < MAX_NUM_JA3 ) ja3 . client . elliptic_curve_point_format [ ja3 . client . num_elliptic_curve_point_format ++ ] = s_group ; else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>num<S2SV_blank>elliptic<S2SV_blank>%u\\\\n\" , ja3 . client . num_elliptic_curve_point_format ) ; # endif } } } else { invalid_ja3 = 1 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>Invalid<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>vs<S2SV_blank>%u\\\\n\" , s_offset + extension_len , total_len ) ; # endif } } else if ( extension_id == 13 ) { u_int16_t s_offset = offset + extension_offset , safari_signature_algorithms = 0 , chrome_signature_algorithms = 0 ; u_int16_t tot_signature_algorithms_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset ] ) ) ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[SIGNATURE_ALGORITHMS:<S2SV_blank>block_len=%u/len=%u]\\\\n\" , extension_len , tot_signature_algorithms_len ) ; # endif s_offset += 2 ; tot_signature_algorithms_len = ndpi_min ( ( sizeof ( ja3 . client . signature_algorithms ) / 2 ) - 1 , tot_signature_algorithms_len ) ; # ifdef TLS_HANDLE_SIGNATURE_ALGORITMS flow -> protos . tls_quic_stun . tls_quic . num_tls_signature_algorithms = ndpi_min ( tot_signature_algorithms_len / 2 , MAX_NUM_TLS_SIGNATURE_ALGORITHMS ) ; memcpy ( flow -> protos . tls_quic_stun . tls_quic . client_signature_algorithms , & packet -> payload [ s_offset ] , 2 * flow -> protos . tls_quic_stun . tls_quic . num_tls_signature_algorithms ) ; # endif for ( i = 0 ; i < tot_signature_algorithms_len ; i ++ ) { int rc = snprintf ( & ja3 . client . signature_algorithms [ i * 2 ] , sizeof ( ja3 . client . signature_algorithms ) - i * 2 , \"%02X\" , packet -> payload [ s_offset + i ] ) ; if ( rc < 0 ) break ; } for ( i = 0 ; i < tot_signature_algorithms_len ; i += 2 ) { u_int16_t cipher_id = ( u_int16_t ) ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset + i ] ) ) ; switch ( cipher_id ) { case ECDSA_SECP521R1_SHA512 : flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_firefox_tls = 1 ; break ; case ECDSA_SECP256R1_SHA256 : case ECDSA_SECP384R1_SHA384 : case RSA_PKCS1_SHA256 : case RSA_PKCS1_SHA384 : case RSA_PKCS1_SHA512 : case RSA_PSS_RSAE_SHA256 : case RSA_PSS_RSAE_SHA384 : case RSA_PSS_RSAE_SHA512 : chrome_signature_algorithms ++ , safari_signature_algorithms ++ ; break ; } } if ( flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_firefox_tls ) flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_safari_tls = 0 , flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_chrome_tls = 0 ; if ( safari_signature_algorithms != 8 ) flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_safari_tls = 0 ; if ( chrome_signature_algorithms != 8 ) flow -> protos . tls_quic_stun . tls_quic . browser_euristics . is_chrome_tls = 0 ; ja3 . client . signature_algorithms [ i * 2 ] = '\\\\0' ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[SIGNATURE_ALGORITHMS:<S2SV_blank>%s]\\\\n\" , ja3 . client . signature_algorithms ) ; # endif } else if ( extension_id == 16 ) { u_int16_t s_offset = offset + extension_offset ; u_int16_t tot_alpn_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset ] ) ) ; char alpn_str [ 256 ] ; u_int8_t alpn_str_len = 0 , i ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[ALPN:<S2SV_blank>block_len=%u/len=%u]\\\\n\" , extension_len , tot_alpn_len ) ; # endif s_offset += 2 ; tot_alpn_len += s_offset ; while ( s_offset < tot_alpn_len && s_offset < total_len ) { u_int8_t alpn_i , alpn_len = packet -> payload [ s_offset ++ ] ; if ( ( s_offset + alpn_len ) <= tot_alpn_len && ( s_offset + alpn_len ) <= total_len ) { # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[ALPN:<S2SV_blank>%u]\\\\n\" , alpn_len ) ; # endif if ( ( alpn_str_len + alpn_len + 1 ) < ( sizeof ( alpn_str ) - 1 ) ) { if ( alpn_str_len > 0 ) { alpn_str [ alpn_str_len ] = ',' ; alpn_str_len ++ ; } for ( alpn_i = 0 ; alpn_i < alpn_len ; alpn_i ++ ) alpn_str [ alpn_str_len + alpn_i ] = packet -> payload [ s_offset + alpn_i ] ; s_offset += alpn_len , alpn_str_len += alpn_len ; ; } else break ; } else break ; } alpn_str [ alpn_str_len ] = '\\\\0' ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[ALPN:<S2SV_blank>%s][len:<S2SV_blank>%u]\\\\n\" , alpn_str , alpn_str_len ) ; # endif if ( flow -> protos . tls_quic_stun . tls_quic . alpn == NULL ) flow -> protos . tls_quic_stun . tls_quic . alpn = ndpi_strdup ( alpn_str ) ; snprintf ( ja3 . client . alpn , sizeof ( ja3 . client . alpn ) , \"%s\" , alpn_str ) ; for ( i = 0 ; ja3 . client . alpn [ i ] != '\\\\0' ; i ++ ) if ( ja3 . client . alpn [ i ] == ',' ) ja3 . client . alpn [ i ] = '-' ; } else if ( extension_id == 43 ) { u_int16_t s_offset = offset + extension_offset ; u_int8_t version_len = packet -> payload [ s_offset ] ; char version_str [ 256 ] ; u_int8_t version_str_len = 0 ; version_str [ 0 ] = 0 ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[TLS<S2SV_blank>version<S2SV_blank>len:<S2SV_blank>%u]\\\\n\" , version_len ) ; # endif if ( version_len == ( extension_len - 1 ) ) { u_int8_t j ; u_int16_t supported_versions_offset = 0 ; s_offset ++ ; for ( j = 0 ; j + 1 < version_len ; j += 2 ) { u_int16_t tls_version = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset + j ] ) ) ; u_int8_t unknown_tls_version ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[TLS<S2SV_blank>version:<S2SV_blank>%s/0x%04X]\\\\n\" , ndpi_ssl_version2str ( flow , tls_version , & unknown_tls_version ) , tls_version ) ; # endif if ( ( version_str_len + 8 ) < sizeof ( version_str ) ) { int rc = snprintf ( & version_str [ version_str_len ] , sizeof ( version_str ) - version_str_len , \"%s%s\" , ( version_str_len > 0 ) ? \",\" : \"\" , ndpi_ssl_version2str ( flow , tls_version , & unknown_tls_version ) ) ; if ( rc <= 0 ) break ; else version_str_len += rc ; rc = snprintf ( & ja3 . client . supported_versions [ supported_versions_offset ] , sizeof ( ja3 . client . supported_versions ) - supported_versions_offset , \"%s%04X\" , ( j > 0 ) ? \"-\" : \"\" , tls_version ) ; if ( rc > 0 ) supported_versions_offset += rc ; } } # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[SUPPORTED_VERSIONS:<S2SV_blank>%s]\\\\n\" , ja3 . client . supported_versions ) ; # endif if ( flow -> protos . tls_quic_stun . tls_quic . tls_supported_versions == NULL ) flow -> protos . tls_quic_stun . tls_quic . tls_supported_versions = ndpi_strdup ( version_str ) ; } } else if ( extension_id == 65486 ) { u_int16_t e_offset = offset + extension_offset ; u_int16_t initial_offset = e_offset ; u_int16_t e_sni_len , cipher_suite = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ e_offset ] ) ) ; flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . cipher_suite = cipher_suite ; e_offset += 2 ; e_offset += 2 ; e_offset += ntohs ( * ( ( u_int16_t * ) & packet -> payload [ e_offset ] ) ) + 2 ; if ( ( e_offset + 4 ) < packet -> payload_packet_len ) { e_offset += ntohs ( * ( ( u_int16_t * ) & packet -> payload [ e_offset ] ) ) + 2 ; if ( ( e_offset + 4 ) < packet -> payload_packet_len ) { e_sni_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ e_offset ] ) ) ; e_offset += 2 ; if ( ( e_offset + e_sni_len - extension_len - initial_offset ) >= 0 && e_offset + e_sni_len < packet -> payload_packet_len ) { # ifdef DEBUG_ENCRYPTED_SNI printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[Encrypted<S2SV_blank>Server<S2SV_blank>Name<S2SV_blank>len:<S2SV_blank>%u]\\\\n\" , e_sni_len ) ; # endif if ( flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . esni == NULL ) { flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . esni = ( char * ) ndpi_malloc ( e_sni_len * 2 + 1 ) ; if ( flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . esni ) { u_int16_t i , off ; for ( i = e_offset , off = 0 ; i < ( e_offset + e_sni_len ) ; i ++ ) { int rc = sprintf ( & flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . esni [ off ] , \"%02X\" , packet -> payload [ i ] & 0XFF ) ; if ( rc <= 0 ) { flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . esni [ off ] = '\\\\0' ; break ; } else off += rc ; } } } } } } } else if ( extension_id == 65445 || extension_id == 57 ) { u_int16_t s_offset = offset + extension_offset ; uint16_t final_offset ; int using_var_int = is_version_with_var_int_transport_params ( quic_version ) ; if ( ! using_var_int ) { if ( s_offset + 1 >= total_len ) { final_offset = 0 ; } else { u_int16_t seq_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset ] ) ) ; s_offset += 2 ; final_offset = MIN ( total_len , s_offset + seq_len ) ; } } else { final_offset = MIN ( total_len , s_offset + extension_len ) ; } while ( s_offset < final_offset ) { u_int64_t param_type , param_len ; if ( ! using_var_int ) { if ( s_offset + 3 >= final_offset ) break ; param_type = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset ] ) ) ; param_len = ntohs ( * ( ( u_int16_t * ) & packet -> payload [ s_offset + 2 ] ) ) ; s_offset += 4 ; } else { if ( s_offset >= final_offset || ( s_offset + quic_len_buffer_still_required ( packet -> payload [ s_offset ] ) ) >= final_offset ) break ; s_offset += quic_len ( & packet -> payload [ s_offset ] , & param_type ) ; if ( s_offset >= final_offset || ( s_offset + quic_len_buffer_still_required ( packet -> payload [ s_offset ] ) ) >= final_offset ) break ; s_offset += quic_len ( & packet -> payload [ s_offset ] , & param_len ) ; } # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[QUIC<S2SV_blank>TP:<S2SV_blank>Param<S2SV_blank>0x%x<S2SV_blank>Len<S2SV_blank>%d]\\\\n\" , ( int ) param_type , ( int ) param_len ) ; # endif if ( s_offset + param_len > final_offset ) break ; if ( param_type == 0x3129 ) { # ifdef DEBUG_TLS printf ( \"UA<S2SV_blank>[%.*s]\\\\n\" , ( int ) param_len , & packet -> payload [ s_offset ] ) ; # endif http_process_user_agent ( ndpi_struct , flow , & packet -> payload [ s_offset ] , param_len ) ; break ; } s_offset += param_len ; } } extension_offset += extension_len ; # ifdef DEBUG_TLS printf ( \"Client<S2SV_blank>TLS<S2SV_blank>[extension_offset/len:<S2SV_blank>%u/%u]\\\\n\" , extension_offset , extension_len ) ; # endif } if ( ! invalid_ja3 ) { int rc ; compute_ja3c : <S2SV_StartBug> ja3_str_len = snprintf ( ja3_str , sizeof ( ja3_str ) , \"%u,\" , ja3 . client . tls_handshake_version ) ; <S2SV_EndBug> for ( i = 0 ; i < ja3 . client . num_cipher ; i ++ ) { <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \"%s%u\" , <S2SV_EndBug> ( i > 0 ) ? \"-\" : \"\" , ja3 . client . cipher [ i ] ) ; if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; else break ; } <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \",\" ) ; <S2SV_EndBug> if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; for ( i = 0 ; i < ja3 . client . num_tls_extension ; i ++ ) { <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \"%s%u\" , <S2SV_EndBug> ( i > 0 ) ? \"-\" : \"\" , ja3 . client . tls_extension [ i ] ) ; if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; else break ; } <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \",\" ) ; <S2SV_EndBug> if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; for ( i = 0 ; i < ja3 . client . num_elliptic_curve ; i ++ ) { <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \"%s%u\" , <S2SV_EndBug> ( i > 0 ) ? \"-\" : \"\" , ja3 . client . elliptic_curve [ i ] ) ; if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; else break ; } <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \",\" ) ; <S2SV_EndBug> if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; for ( i = 0 ; i < ja3 . client . num_elliptic_curve_point_format ; i ++ ) { <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , \"%s%u\" , <S2SV_EndBug> ( i > 0 ) ? \"-\" : \"\" , ja3 . client . elliptic_curve_point_format [ i ] ) ; if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; else break ; } if ( ndpi_struct -> enable_ja3_plus ) { <S2SV_StartBug> rc = snprintf ( & ja3_str [ ja3_str_len ] , sizeof ( ja3_str ) - ja3_str_len , <S2SV_EndBug> \",%s,%s,%s\" , ja3 . client . signature_algorithms , ja3 . client . supported_versions , ja3 . client . alpn ) ; if ( ( rc > 0 ) && ( ja3_str_len + rc < JA3_STR_LEN ) ) ja3_str_len += rc ; } # ifdef DEBUG_JA3C printf ( \"[JA3+]<S2SV_blank>Client:<S2SV_blank>%s<S2SV_blank>\\\\n\" , ja3_str ) ; # endif ndpi_MD5Init ( & ctx ) ; ndpi_MD5Update ( & ctx , ( const unsigned char * ) ja3_str , strlen ( ja3_str ) ) ; ndpi_MD5Final ( md5_hash , & ctx ) ; for ( i = 0 , j = 0 ; i < 16 ; i ++ ) { rc = snprintf ( & flow -> protos . tls_quic_stun . tls_quic . ja3_client [ j ] , sizeof ( flow -> protos . tls_quic_stun . tls_quic . ja3_client ) - j , \"%02x\" , md5_hash [ i ] ) ; if ( rc > 0 ) j += rc ; else break ; } # ifdef DEBUG_JA3C printf ( \"[JA3]<S2SV_blank>Client:<S2SV_blank>%s<S2SV_blank>\\\\n\" , flow -> protos . tls_quic_stun . tls_quic . ja3_client ) ; # endif if ( ndpi_struct -> malicious_ja3_automa . ac_automa != NULL ) { u_int16_t rc1 = ndpi_match_string ( ndpi_struct -> malicious_ja3_automa . ac_automa , flow -> protos . tls_quic_stun . tls_quic . ja3_client ) ; if ( rc1 > 0 ) ndpi_set_risk ( flow , NDPI_MALICIOUS_JA3 ) ; } } if ( ( flow -> protos . tls_quic_stun . tls_quic . ssl_version >= 0x0303 ) && ( flow -> protos . tls_quic_stun . tls_quic . alpn == NULL ) ) { ndpi_set_risk ( flow , NDPI_TLS_NOT_CARRYING_HTTPS ) ; } if ( flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . esni && flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name [ 0 ] != '\\\\0' ) { ndpi_set_risk ( flow , NDPI_TLS_SUSPICIOUS_ESNI_USAGE ) ; } if ( ( flow -> protos . tls_quic_stun . tls_quic . client_requested_server_name [ 0 ] == 0 ) && ( flow -> protos . tls_quic_stun . tls_quic . ssl_version >= 0x0302 ) && ( flow -> protos . tls_quic_stun . tls_quic . encrypted_sni . esni == NULL ) ) { ndpi_set_risk ( flow , NDPI_TLS_MISSING_SNI ) ; } return ( 2 ) ; } else { # ifdef DEBUG_TLS printf ( \"[TLS]<S2SV_blank>Client:<S2SV_blank>too<S2SV_blank>short<S2SV_blank>[%u<S2SV_blank>vs<S2SV_blank>%u]\\\\n\" , ( extensions_len + offset ) , total_len ) ; # endif } } else if ( offset == total_len ) { goto compute_ja3c ; } } else { # ifdef DEBUG_TLS printf ( \"[JA3]<S2SV_blank>Client:<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>detected\\\\n\" ) ; # endif } } } return ( 0 ) ; }", "target": "<S2SV_ModStart> ( ja3_str , JA3_STR_LEN <S2SV_ModEnd> , \"%u,\" , <S2SV_ModStart> = 0 ; ( <S2SV_ModStart> server . num_cipher ) && ( JA3_STR_LEN > ja3_str_len ) <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> rc ; } if ( JA3_STR_LEN > ja3_str_len ) { <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> += rc ; } <S2SV_ModStart> = 0 ; ( <S2SV_ModStart> server . num_tls_extension ) && ( JA3_STR_LEN > ja3_str_len ) <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> = 0 ; ( <S2SV_ModStart> server . num_elliptic_curve_point_format ) && ( JA3_STR_LEN > ja3_str_len ) <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> } if ( ( <S2SV_ModStart> != '\\\\0' ) && ( JA3_STR_LEN > ja3_str_len ) ) <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ( ja3_str , JA3_STR_LEN <S2SV_ModEnd> , \"%u,\" , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len , <S2SV_ModStart> ja3_str_len ] , JA3_STR_LEN <S2SV_ModEnd> - ja3_str_len ,"}
{"source": "CWE-703 void DoRealForwardFFT ( OpKernelContext * ctx , uint64 * fft_shape , const Tensor & in , Tensor * out ) { const auto axes = Eigen : : ArrayXi : : LinSpaced ( FFTRank , 1 , FFTRank ) ; auto device = ctx -> eigen_device < CPUDevice > ( ) ; auto input = Tensor ( in ) . flat_inner_dims < RealT , FFTRank + 1 > ( ) ; const auto input_dims = input . dimensions ( ) ; Eigen : : DSizes < Eigen : : DenseIndex , FFTRank + 1 > input_slice_sizes ; input_slice_sizes [ 0 ] = input_dims [ 0 ] ; TensorShape temp_shape { input_dims [ 0 ] } ; for ( int i = 1 ; i <= FFTRank ; ++ i ) { input_slice_sizes [ i ] = fft_shape [ i - 1 ] ; temp_shape . AddDim ( fft_shape [ i - 1 ] ) ; } <S2SV_StartBug> <S2SV_EndBug> auto output = out -> flat_inner_dims < ComplexT , FFTRank + 1 > ( ) ; const Eigen : : DSizes < Eigen : : DenseIndex , FFTRank + 1 > zero_start_indices ; Tensor temp ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < ComplexT > : : v ( ) , temp_shape , & temp ) ) ; auto full_fft = temp . flat_inner_dims < ComplexT , FFTRank + 1 > ( ) ; full_fft . device ( device ) = input . slice ( zero_start_indices , input_slice_sizes ) . template fft < Eigen : : BothParts , Eigen : : FFT_FORWARD > ( axes ) ; output . device ( device ) = full_fft . slice ( zero_start_indices , output . dimensions ( ) ) ; }", "target": "<S2SV_ModStart> ) ; } OP_REQUIRES ( ctx , temp_shape . num_elements ( ) > 0 , errors : : InvalidArgument ( \"Obtained<S2SV_blank>a<S2SV_blank>FFT<S2SV_blank>shape<S2SV_blank>of<S2SV_blank>0<S2SV_blank>elements:<S2SV_blank>\" , temp_shape . DebugString ( ) ) ) ;"}
{"source": "CWE-787 bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , \"{\\\\\"id\\\\\":<S2SV_blank>%d,<S2SV_blank>\\\\\"method\\\\\":<S2SV_blank>\\\\\"mining.subscribe\\\\\",<S2SV_blank>\\\\\"params\\\\\":<S2SV_blank>[\\\\\"%s\\\\\"]}\" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , \"{\\\\\"id\\\\\":<S2SV_blank>%d,<S2SV_blank>\\\\\"method\\\\\":<S2SV_blank>\\\\\"mining.subscribe\\\\\",<S2SV_blank>\\\\\"params\\\\\":<S2SV_blank>[]}\" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , \"Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum\" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , \"Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum\" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , \"JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s\" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , \"result\" ) ; err_val = json_object_get ( val , \"error\" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( \"(unknown<S2SV_blank>reason)\" ) ; applog ( LOG_INFO , \"JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s\" , ss ) ; free ( ss ) ; goto out ; } sessionid = json_array_string ( json_array_get ( res_val , 0 ) , 1 ) ; if ( ! sessionid ) { applog ( LOG_INFO , \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum\" ) ; goto out ; } nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum\" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , \"Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum\" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } mutex_lock ( & pool -> pool_lock ) ; pool -> sessionid = sessionid ; free ( pool -> nonce1 ) ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; pool -> n2size = n2size ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , \"Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s\" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( val ) json_decref ( val ) ; if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , \"Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d\" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && pool -> sessionid ) { mutex_lock ( & pool -> pool_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , \"Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh\" ) ; goto resend ; } applog ( LOG_DEBUG , \"Initiate<S2SV_blank>stratum<S2SV_blank>failed\" ) ; if ( pool -> sock != INVSOCK ) { shutdown ( pool -> sock , SHUT_RDWR ) ; pool -> sock = INVSOCK ; } } return ret ; }", "target": "<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog ("}
{"source": "CWE-369 void Compute ( OpKernelContext * ctx ) override { const Tensor * indices_t , * values_t , * shape_t , * dense_t ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"sp_indices\" , & indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"sp_values\" , & values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"sp_shape\" , & shape_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"dense\" , & dense_t ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( indices_t -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>sp_indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape:<S2SV_blank>\" , indices_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( values_t -> shape ( ) ) && TensorShapeUtils : : IsVector ( shape_t -> shape ( ) ) , errors : : InvalidArgument ( \"Inputs<S2SV_blank>sp_values<S2SV_blank>and<S2SV_blank>sp_shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>vectors<S2SV_blank>\" \"but<S2SV_blank>received<S2SV_blank>shapes:<S2SV_blank>\" , values_t -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , shape_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , values_t -> dim_size ( 0 ) == indices_t -> dim_size ( 0 ) , errors : : InvalidArgument ( \"The<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>values<S2SV_blank>and<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>match.<S2SV_blank>(\" , values_t -> dim_size ( 0 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , indices_t -> dim_size ( 0 ) , \")\" ) ) ; const auto indices_mat = indices_t -> matrix < int64 > ( ) ; const auto shape_vec = shape_t -> vec < int64 > ( ) ; const auto lhs_dims = BCast : : FromShape ( TensorShape ( shape_vec ) ) ; const auto rhs_dims = BCast : : FromShape ( dense_t -> shape ( ) ) ; BCast b ( lhs_dims , rhs_dims , false ) ; auto VecGreaterEq = [ ] ( ArraySlice < int64 > lhs , ArraySlice < int64 > rhs ) { if ( lhs . size ( ) < rhs . size ( ) ) return false ; for ( size_t i = 0 ; i < rhs . size ( ) ; ++ i ) { if ( lhs [ lhs . size ( ) - 1 - i ] < rhs [ rhs . size ( ) - 1 - i ] ) return false ; } return true ; } ; OP_REQUIRES ( ctx , VecGreaterEq ( lhs_dims , rhs_dims ) && b . IsValid ( ) , errors : : InvalidArgument ( \"SparseDenseBinaryOpShared<S2SV_blank>broadcasts<S2SV_blank>dense<S2SV_blank>to<S2SV_blank>sparse<S2SV_blank>\" \"only;<S2SV_blank>got<S2SV_blank>incompatible<S2SV_blank>shapes:<S2SV_blank>[\" , absl : : StrJoin ( lhs_dims , \",\" ) , \"]<S2SV_blank>vs.<S2SV_blank>[\" , absl : : StrJoin ( rhs_dims , \",\" ) , \"]\" ) ) ; Tensor * output_values = nullptr ; Tensor dense_gathered ; const int64 nnz = indices_t -> dim_size ( 0 ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { nnz } ) , & output_values ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > : : value , TensorShape ( { nnz } ) , & dense_gathered ) ) ; <S2SV_StartBug> <S2SV_EndBug> auto dense_gathered_flat = dense_gathered . flat < T > ( ) ; const int ndims = lhs_dims . size ( ) ; switch ( ndims ) { <S2SV_StartBug> # define CASE ( NDIM ) case NDIM : { TensorRef < Eigen : : Tensor < const T , NDIM , Eigen : : RowMajor >> rhs_ref = dense_t -> shaped < T , NDIM > ( b . y_reshape ( ) ) . broadcast ( BCast : : ToIndexArray < NDIM > ( b . y_bcast ( ) ) ) ; Eigen : : array < Eigen : : DenseIndex , NDIM > idx ; bool indices_valid = true ; for ( int i = 0 ; i < nnz ; ++ i ) { for ( int d = 0 ; d < NDIM ; ++ d ) { idx [ d ] = internal : : SubtleMustCopy ( indices_mat ( i , d ) ) ; if ( ! FastBoundsCheck ( idx [ d ] , rhs_ref . dimension ( d ) ) ) { indices_valid = false ; } } OP_REQUIRES ( ctx , indices_valid , errors : : InvalidArgument ( \"Provided<S2SV_blank>indices<S2SV_blank>are<S2SV_blank>out-of-bounds<S2SV_blank>w.r.t.<S2SV_blank>\" \"dense<S2SV_blank>side<S2SV_blank>with<S2SV_blank>broadcasted<S2SV_blank>shape\" ) ) ; dense_gathered_flat ( i ) = rhs_ref . coeff ( idx ) ; } break ; } <S2SV_EndBug> CASE ( 1 ) ; CASE ( 2 ) ; CASE ( 3 ) ; CASE ( 4 ) ; CASE ( 5 ) ; default : OP_REQUIRES ( ctx , false , errors : : InvalidArgument ( \"Only<S2SV_blank>tensors<S2SV_blank>with<S2SV_blank>ranks<S2SV_blank>between<S2SV_blank>1<S2SV_blank>and<S2SV_blank>5<S2SV_blank>\" \"are<S2SV_blank>currently<S2SV_blank>supported.<S2SV_blank><S2SV_blank>Tensor<S2SV_blank>rank:<S2SV_blank>\" , ndims ) ) ; # undef CASE } output_values -> flat < T > ( ) . device ( ctx -> eigen_device < Device > ( ) ) = values_t -> flat < T > ( ) . binaryExpr ( dense_gathered_flat , typename Functor : : func ( ) ) ; }", "target": "<S2SV_ModStart> ) ) ; bool op_is_div = false ; if ( absl : : StrContains ( ctx -> op_kernel ( ) . type_string_view ( ) , \"Div\" ) ) { op_is_div = true ; } <S2SV_ModStart> idx ) ; if ( op_is_div ) { OP_REQUIRES ( ctx , dense_gathered_flat ( i ) != 0 , errors : : InvalidArgument ( \"SparseDenseCwiseDiv<S2SV_blank>cannot<S2SV_blank>divide<S2SV_blank>by<S2SV_blank>zero,\" \"but<S2SV_blank>input<S2SV_blank>dense<S2SV_blank>tensor<S2SV_blank>contains<S2SV_blank>zero<S2SV_blank>\" ) ) ; }"}
{"source": "CWE-787 static GF_Err av1dmx_parse_flush_sample ( GF_Filter * filter , GF_AV1DmxCtx * ctx ) { u32 pck_size ; GF_FilterPacket * pck ; <S2SV_StartBug> u8 * output ; <S2SV_EndBug> gf_bs_get_content_no_truncate ( ctx -> state . bs , & ctx -> state . frame_obus , & pck_size , & ctx -> state . frame_obus_alloc ) ; if ( ! pck_size ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[AV1Dmx]<S2SV_blank>no<S2SV_blank>frame<S2SV_blank>OBU,<S2SV_blank>skipping<S2SV_blank>OBU\\\\n\" ) ) ; return GF_OK ; } pck = gf_filter_pck_new_alloc ( ctx -> opid , pck_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , pck ) ; gf_filter_pck_set_cts ( pck , ctx -> cts ) ; gf_filter_pck_set_sap ( pck , ctx -> state . frame_state . key_frame ? GF_FILTER_SAP_1 : 0 ) ; memcpy ( output , ctx -> state . frame_obus , pck_size ) ; if ( ctx -> deps ) { u8 flags = 0 ; flags = ( ctx -> state . frame_state . key_frame ) ? 2 : 1 ; flags <<= 2 ; flags |= ctx -> state . frame_state . refresh_frame_flags ? 1 : 2 ; flags <<= 2 ; gf_filter_pck_set_dependency_flags ( pck , flags ) ; } gf_filter_pck_send ( pck ) ; av1dmx_update_cts ( ctx ) ; gf_av1_reset_state ( & ctx -> state , GF_FALSE ) ; return GF_OK ; }", "target": "<S2SV_ModStart> u8 * output ; if ( ! ctx -> opid ) return GF_NON_COMPLIANT_BITSTREAM"}
{"source": "CWE-703 <S2SV_StartBug> NativeModule : : NativeModule ( const std : : string & filename ) : init ( nullptr ) { <S2SV_EndBug> if ( uv_dlopen ( filename . c_str ( ) , & lib ) != 0 ) { throw RuntimeGenericError ( \"Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>module\" ) ; } if ( uv_dlsym ( & lib , \"InitForContext\" , reinterpret_cast < void * * > ( & init ) ) != 0 || init == nullptr ) { uv_dlclose ( & lib ) ; throw RuntimeGenericError ( \"Module<S2SV_blank>is<S2SV_blank>not<S2SV_blank>isolated-vm<S2SV_blank>compatible\" ) ; } }", "target": "<S2SV_ModStart> nullptr ) { if ( ! IsolateEnvironment : : GetCurrent ( ) -> IsDefault ( ) ) { throw RuntimeGenericError ( \"NativeModule<S2SV_blank>may<S2SV_blank>only<S2SV_blank>be<S2SV_blank>instantiated<S2SV_blank>from<S2SV_blank>default<S2SV_blank>nodejs<S2SV_blank>isolate\" ) ; }"}
{"source": "CWE-476 codegen ( codegen_scope * s , node * tree , int val ) { int nt ; int rlev = s -> rlev ; if ( ! tree ) { if ( val ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } return ; } s -> rlev ++ ; if ( s -> rlev > MRB_CODEGEN_LEVEL_MAX ) { codegen_error ( s , \"too<S2SV_blank>complex<S2SV_blank>expression\" ) ; } if ( s -> irep && s -> filename_index != tree -> filename_index ) { mrb_sym fname = mrb_parser_get_filename ( s -> parser , s -> filename_index ) ; const char * filename = mrb_sym_name_len ( s -> mrb , fname , NULL ) ; mrb_debug_info_append_file ( s -> mrb , s -> irep -> debug_info , filename , s -> lines , s -> debug_start_pos , s -> pc ) ; s -> debug_start_pos = s -> pc ; s -> filename_index = tree -> filename_index ; s -> filename_sym = mrb_parser_get_filename ( s -> parser , tree -> filename_index ) ; } nt = nint ( tree -> car ) ; s -> lineno = tree -> lineno ; tree = tree -> cdr ; switch ( nt ) { case NODE_BEGIN : if ( val && ! tree ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } while ( tree ) { codegen ( s , tree -> car , tree -> cdr ? NOVAL : val ) ; tree = tree -> cdr ; } break ; case NODE_RESCUE : { int noexc ; uint32_t exend , pos1 , pos2 , tmp ; struct loopinfo * lp ; int catch_entry , begin , end ; if ( tree -> car == NULL ) goto exit ; lp = loop_push ( s , LOOP_BEGIN ) ; lp -> pc0 = new_label ( s ) ; catch_entry = catch_handler_new ( s ) ; begin = s -> pc ; codegen ( s , tree -> car , VAL ) ; pop ( ) ; lp -> type = LOOP_RESCUE ; end = s -> pc ; noexc = genjmp_0 ( s , OP_JMP ) ; catch_handler_set ( s , catch_entry , MRB_CATCH_RESCUE , begin , end , s -> pc ) ; tree = tree -> cdr ; exend = JMPLINK_START ; pos1 = JMPLINK_START ; if ( tree -> car ) { node * n2 = tree -> car ; int exc = cursp ( ) ; genop_1 ( s , OP_EXCEPT , exc ) ; push ( ) ; while ( n2 ) { node * n3 = n2 -> car ; node * n4 = n3 -> car ; dispatch ( s , pos1 ) ; pos2 = JMPLINK_START ; do { if ( n4 && n4 -> car && nint ( n4 -> car -> car ) == NODE_SPLAT ) { codegen ( s , n4 -> car , VAL ) ; gen_move ( s , cursp ( ) , exc , 0 ) ; push_n ( 2 ) ; pop_n ( 2 ) ; pop ( ) ; genop_3 ( s , OP_SEND , cursp ( ) , new_sym ( s , MRB_SYM_2 ( s -> mrb , __case_eqq ) ) , 1 ) ; } else { if ( n4 ) { codegen ( s , n4 -> car , VAL ) ; } else { genop_2 ( s , OP_GETCONST , cursp ( ) , new_sym ( s , MRB_SYM_2 ( s -> mrb , StandardError ) ) ) ; push ( ) ; } pop ( ) ; genop_2 ( s , OP_RESCUE , exc , cursp ( ) ) ; } tmp = genjmp2 ( s , OP_JMPIF , cursp ( ) , pos2 , val ) ; pos2 = tmp ; if ( n4 ) { n4 = n4 -> cdr ; } } while ( n4 ) ; pos1 = genjmp_0 ( s , OP_JMP ) ; dispatch_linked ( s , pos2 ) ; pop ( ) ; if ( n3 -> cdr -> car ) { gen_assignment ( s , n3 -> cdr -> car , NULL , exc , NOVAL ) ; } if ( n3 -> cdr -> cdr -> car ) { codegen ( s , n3 -> cdr -> cdr -> car , val ) ; if ( val ) pop ( ) ; } tmp = genjmp ( s , OP_JMP , exend ) ; exend = tmp ; n2 = n2 -> cdr ; push ( ) ; } if ( pos1 != JMPLINK_START ) { dispatch ( s , pos1 ) ; genop_1 ( s , OP_RAISEIF , exc ) ; } } pop ( ) ; tree = tree -> cdr ; dispatch ( s , noexc ) ; if ( tree -> car ) { codegen ( s , tree -> car , val ) ; } else if ( val ) { push ( ) ; } dispatch_linked ( s , exend ) ; loop_pop ( s , NOVAL ) ; } break ; case NODE_ENSURE : if ( ! tree -> cdr || ! tree -> cdr -> cdr || ( nint ( tree -> cdr -> cdr -> car ) == NODE_BEGIN && tree -> cdr -> cdr -> cdr ) ) { int catch_entry , begin , end , target ; int idx ; catch_entry = catch_handler_new ( s ) ; begin = s -> pc ; codegen ( s , tree -> car , val ) ; end = target = s -> pc ; push ( ) ; idx = cursp ( ) ; genop_1 ( s , OP_EXCEPT , idx ) ; push ( ) ; codegen ( s , tree -> cdr -> cdr , NOVAL ) ; pop ( ) ; genop_1 ( s , OP_RAISEIF , idx ) ; pop ( ) ; catch_handler_set ( s , catch_entry , MRB_CATCH_ENSURE , begin , end , target ) ; } else { codegen ( s , tree -> car , val ) ; } break ; case NODE_LAMBDA : if ( val ) { int idx = lambda_body ( s , tree , 1 ) ; genop_2 ( s , OP_LAMBDA , cursp ( ) , idx ) ; push ( ) ; } break ; case NODE_BLOCK : if ( val ) { int idx = lambda_body ( s , tree , 1 ) ; genop_2 ( s , OP_BLOCK , cursp ( ) , idx ) ; push ( ) ; } break ; case NODE_IF : { uint32_t pos1 , pos2 ; mrb_bool nil_p = FALSE ; node * elsepart = tree -> cdr -> cdr -> car ; if ( ! tree -> car ) { codegen ( s , elsepart , val ) ; goto exit ; } if ( true_always ( tree -> car ) ) { codegen ( s , tree -> cdr -> car , val ) ; goto exit ; } if ( false_always ( tree -> car ) ) { codegen ( s , elsepart , val ) ; goto exit ; } if ( nint ( tree -> car -> car ) == NODE_CALL ) { node * n = tree -> car -> cdr ; mrb_sym mid = nsym ( n -> cdr -> car ) ; mrb_sym sym_nil_p = MRB_SYM_Q_2 ( s -> mrb , nil ) ; if ( mid == sym_nil_p && n -> cdr -> cdr -> car == NULL ) { nil_p = TRUE ; codegen ( s , n -> car , VAL ) ; } } if ( ! nil_p ) { codegen ( s , tree -> car , VAL ) ; } pop ( ) ; if ( val || tree -> cdr -> car ) { if ( nil_p ) { pos2 = genjmp2_0 ( s , OP_JMPNIL , cursp ( ) , val ) ; pos1 = genjmp_0 ( s , OP_JMP ) ; dispatch ( s , pos2 ) ; } else { pos1 = genjmp2_0 ( s , OP_JMPNOT , cursp ( ) , val ) ; } codegen ( s , tree -> cdr -> car , val ) ; if ( val ) pop ( ) ; if ( elsepart || val ) { pos2 = genjmp_0 ( s , OP_JMP ) ; dispatch ( s , pos1 ) ; codegen ( s , elsepart , val ) ; dispatch ( s , pos2 ) ; } else { dispatch ( s , pos1 ) ; } } else { if ( elsepart ) { if ( nil_p ) { pos1 = genjmp2_0 ( s , OP_JMPNIL , cursp ( ) , val ) ; } else { pos1 = genjmp2_0 ( s , OP_JMPIF , cursp ( ) , val ) ; } codegen ( s , elsepart , val ) ; dispatch ( s , pos1 ) ; } else if ( val && ! nil_p ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } } } break ; case NODE_AND : { uint32_t pos ; if ( true_always ( tree -> car ) ) { codegen ( s , tree -> cdr , val ) ; goto exit ; } if ( false_always ( tree -> car ) ) { codegen ( s , tree -> car , val ) ; goto exit ; } codegen ( s , tree -> car , VAL ) ; pop ( ) ; pos = genjmp2_0 ( s , OP_JMPNOT , cursp ( ) , val ) ; codegen ( s , tree -> cdr , val ) ; dispatch ( s , pos ) ; } break ; case NODE_OR : { uint32_t pos ; if ( true_always ( tree -> car ) ) { codegen ( s , tree -> car , val ) ; goto exit ; } if ( false_always ( tree -> car ) ) { codegen ( s , tree -> cdr , val ) ; goto exit ; } codegen ( s , tree -> car , VAL ) ; pop ( ) ; pos = genjmp2_0 ( s , OP_JMPIF , cursp ( ) , val ) ; codegen ( s , tree -> cdr , val ) ; dispatch ( s , pos ) ; } break ; case NODE_WHILE : case NODE_UNTIL : { if ( true_always ( tree -> car ) ) { if ( nt == NODE_UNTIL ) { if ( val ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } goto exit ; } } else if ( false_always ( tree -> car ) ) { if ( nt == NODE_WHILE ) { if ( val ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } goto exit ; } } uint32_t pos = JMPLINK_START ; struct loopinfo * lp = loop_push ( s , LOOP_NORMAL ) ; if ( ! val ) lp -> reg = - 1 ; lp -> pc0 = new_label ( s ) ; codegen ( s , tree -> car , VAL ) ; pop ( ) ; if ( nt == NODE_WHILE ) { pos = genjmp2_0 ( s , OP_JMPNOT , cursp ( ) , NOVAL ) ; } else { pos = genjmp2_0 ( s , OP_JMPIF , cursp ( ) , NOVAL ) ; } lp -> pc1 = new_label ( s ) ; codegen ( s , tree -> cdr , NOVAL ) ; genjmp ( s , OP_JMP , lp -> pc0 ) ; dispatch ( s , pos ) ; loop_pop ( s , val ) ; } break ; case NODE_FOR : for_body ( s , tree ) ; if ( val ) push ( ) ; break ; case NODE_CASE : { int head = 0 ; uint32_t pos1 , pos2 , pos3 , tmp ; node * n ; pos3 = JMPLINK_START ; if ( tree -> car ) { head = cursp ( ) ; codegen ( s , tree -> car , VAL ) ; } tree = tree -> cdr ; while ( tree ) { n = tree -> car -> car ; pos1 = pos2 = JMPLINK_START ; while ( n ) { codegen ( s , n -> car , VAL ) ; if ( head ) { gen_move ( s , cursp ( ) , head , 0 ) ; push ( ) ; push ( ) ; pop ( ) ; pop ( ) ; pop ( ) ; if ( nint ( n -> car -> car ) == NODE_SPLAT ) { genop_3 ( s , OP_SEND , cursp ( ) , new_sym ( s , MRB_SYM_2 ( s -> mrb , __case_eqq ) ) , 1 ) ; } else { genop_3 ( s , OP_SEND , cursp ( ) , new_sym ( s , MRB_OPSYM_2 ( s -> mrb , eqq ) ) , 1 ) ; } } else { pop ( ) ; } tmp = genjmp2 ( s , OP_JMPIF , cursp ( ) , pos2 , NOVAL ) ; pos2 = tmp ; n = n -> cdr ; } if ( tree -> car -> car ) { pos1 = genjmp_0 ( s , OP_JMP ) ; dispatch_linked ( s , pos2 ) ; } codegen ( s , tree -> car -> cdr , val ) ; if ( val ) pop ( ) ; tmp = genjmp ( s , OP_JMP , pos3 ) ; pos3 = tmp ; dispatch ( s , pos1 ) ; tree = tree -> cdr ; } if ( val ) { uint32_t pos = cursp ( ) ; genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; if ( pos3 != JMPLINK_START ) dispatch_linked ( s , pos3 ) ; if ( head ) pop ( ) ; if ( cursp ( ) != pos ) { gen_move ( s , cursp ( ) , pos , 0 ) ; } push ( ) ; } else { if ( pos3 != JMPLINK_START ) { dispatch_linked ( s , pos3 ) ; } if ( head ) { pop ( ) ; } } } break ; case NODE_SCOPE : scope_body ( s , tree , NOVAL ) ; break ; case NODE_FCALL : case NODE_CALL : gen_call ( s , tree , val , 0 ) ; break ; case NODE_SCALL : gen_call ( s , tree , val , 1 ) ; break ; case NODE_DOT2 : codegen ( s , tree -> car , val ) ; codegen ( s , tree -> cdr , val ) ; if ( val ) { pop ( ) ; pop ( ) ; genop_1 ( s , OP_RANGE_INC , cursp ( ) ) ; push ( ) ; } break ; case NODE_DOT3 : codegen ( s , tree -> car , val ) ; codegen ( s , tree -> cdr , val ) ; if ( val ) { pop ( ) ; pop ( ) ; genop_1 ( s , OP_RANGE_EXC , cursp ( ) ) ; push ( ) ; } break ; case NODE_COLON2 : { int sym = new_sym ( s , nsym ( tree -> cdr ) ) ; codegen ( s , tree -> car , VAL ) ; pop ( ) ; genop_2 ( s , OP_GETMCNST , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_COLON3 : { int sym = new_sym ( s , nsym ( tree ) ) ; genop_1 ( s , OP_OCLASS , cursp ( ) ) ; genop_2 ( s , OP_GETMCNST , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_ARRAY : { int n ; n = gen_values ( s , tree , val , 0 ) ; if ( val ) { if ( n >= 0 ) { pop_n ( n ) ; genop_2 ( s , OP_ARRAY , cursp ( ) , n ) ; } push ( ) ; } } break ; case NODE_HASH : case NODE_KW_HASH : { int nk = gen_hash ( s , tree , val , GEN_LIT_ARY_MAX ) ; if ( val && nk >= 0 ) { pop_n ( nk * 2 ) ; genop_2 ( s , OP_HASH , cursp ( ) , nk ) ; push ( ) ; } } break ; case NODE_SPLAT : codegen ( s , tree , val ) ; break ; case NODE_ASGN : gen_assignment ( s , tree -> car , tree -> cdr , 0 , val ) ; break ; case NODE_MASGN : { int len = 0 , n = 0 , post = 0 ; node * t = tree -> cdr , * p ; int rhs = cursp ( ) ; if ( nint ( t -> car ) == NODE_ARRAY && t -> cdr && nosplat ( t -> cdr ) ) { t = t -> cdr ; while ( t ) { codegen ( s , t -> car , VAL ) ; len ++ ; t = t -> cdr ; } tree = tree -> car ; if ( tree -> car ) { t = tree -> car ; n = 0 ; while ( t ) { if ( n < len ) { gen_assignment ( s , t -> car , NULL , rhs + n , NOVAL ) ; n ++ ; } else { genop_1 ( s , OP_LOADNIL , rhs + n ) ; gen_assignment ( s , t -> car , NULL , rhs + n , NOVAL ) ; } t = t -> cdr ; } } t = tree -> cdr ; if ( t ) { if ( t -> cdr ) { p = t -> cdr -> car ; while ( p ) { post ++ ; p = p -> cdr ; } } if ( t -> car ) { int rn ; if ( len < post + n ) { rn = 0 ; } else { rn = len - post - n ; } genop_3 ( s , OP_ARRAY2 , cursp ( ) , rhs + n , rn ) ; gen_assignment ( s , t -> car , NULL , cursp ( ) , NOVAL ) ; n += rn ; } if ( t -> cdr && t -> cdr -> car ) { t = t -> cdr -> car ; while ( n < len ) { gen_assignment ( s , t -> car , NULL , rhs + n , NOVAL ) ; t = t -> cdr ; n ++ ; } } } pop_n ( len ) ; if ( val ) { genop_2 ( s , OP_ARRAY , rhs , len ) ; push ( ) ; } } else { codegen ( s , t , VAL ) ; gen_vmassignment ( s , tree -> car , rhs , val ) ; if ( ! val ) { pop ( ) ; } } } break ; case NODE_OP_ASGN : { mrb_sym sym = nsym ( tree -> cdr -> car ) ; mrb_int len ; const char * name = mrb_sym_name_len ( s -> mrb , sym , & len ) ; int idx , callargs = - 1 , vsp = - 1 ; if ( ( len == 2 && name [ 0 ] == '|' && name [ 1 ] == '|' ) && ( nint ( tree -> car -> car ) == NODE_CONST || nint ( tree -> car -> car ) == NODE_CVAR ) ) { int catch_entry , begin , end ; int noexc , exc ; struct loopinfo * lp ; lp = loop_push ( s , LOOP_BEGIN ) ; lp -> pc0 = new_label ( s ) ; catch_entry = catch_handler_new ( s ) ; begin = s -> pc ; exc = cursp ( ) ; codegen ( s , tree -> car , VAL ) ; end = s -> pc ; noexc = genjmp_0 ( s , OP_JMP ) ; lp -> type = LOOP_RESCUE ; catch_handler_set ( s , catch_entry , MRB_CATCH_RESCUE , begin , end , s -> pc ) ; genop_1 ( s , OP_EXCEPT , exc ) ; genop_1 ( s , OP_LOADF , exc ) ; dispatch ( s , noexc ) ; loop_pop ( s , NOVAL ) ; } else if ( nint ( tree -> car -> car ) == NODE_CALL ) { node * n = tree -> car -> cdr ; int base , i , nargs = 0 ; callargs = 0 ; if ( val ) { vsp = cursp ( ) ; push ( ) ; } codegen ( s , n -> car , VAL ) ; idx = new_sym ( s , nsym ( n -> cdr -> car ) ) ; base = cursp ( ) - 1 ; if ( n -> cdr -> cdr -> car ) { nargs = gen_values ( s , n -> cdr -> cdr -> car -> car , VAL , 13 ) ; if ( nargs >= 0 ) { callargs = nargs ; } else { push ( ) ; nargs = 1 ; callargs = CALL_MAXARGS ; } } gen_move ( s , cursp ( ) , base , 1 ) ; for ( i = 0 ; i < nargs ; i ++ ) { gen_move ( s , cursp ( ) + i + 1 , base + i + 1 , 1 ) ; } push_n ( nargs + 2 ) ; pop_n ( nargs + 2 ) ; genop_3 ( s , OP_SEND , cursp ( ) , idx , callargs ) ; push ( ) ; } else { codegen ( s , tree -> car , VAL ) ; } if ( len == 2 && ( ( name [ 0 ] == '|' && name [ 1 ] == '|' ) || ( name [ 0 ] == '&' && name [ 1 ] == '&' ) ) ) { uint32_t pos ; pop ( ) ; if ( val ) { if ( vsp >= 0 ) { gen_move ( s , vsp , cursp ( ) , 1 ) ; } pos = genjmp2_0 ( s , name [ 0 ] == '|' ? OP_JMPIF : OP_JMPNOT , cursp ( ) , val ) ; } else { pos = genjmp2_0 ( s , name [ 0 ] == '|' ? OP_JMPIF : OP_JMPNOT , cursp ( ) , val ) ; } codegen ( s , tree -> cdr -> cdr -> car , VAL ) ; pop ( ) ; if ( val && vsp >= 0 ) { gen_move ( s , vsp , cursp ( ) , 1 ) ; } if ( nint ( tree -> car -> car ) == NODE_CALL ) { if ( callargs == CALL_MAXARGS ) { pop ( ) ; genop_2 ( s , OP_ARYPUSH , cursp ( ) , 1 ) ; } else { pop_n ( callargs ) ; callargs ++ ; } pop ( ) ; idx = new_sym ( s , attrsym ( s , nsym ( tree -> car -> cdr -> cdr -> car ) ) ) ; genop_3 ( s , OP_SEND , cursp ( ) , idx , callargs ) ; } else { gen_assignment ( s , tree -> car , NULL , cursp ( ) , val ) ; } dispatch ( s , pos ) ; goto exit ; } codegen ( s , tree -> cdr -> cdr -> car , VAL ) ; push ( ) ; pop ( ) ; pop ( ) ; pop ( ) ; if ( len == 1 && name [ 0 ] == '+' ) { gen_addsub ( s , OP_ADD , cursp ( ) ) ; } else if ( len == 1 && name [ 0 ] == '-' ) { gen_addsub ( s , OP_SUB , cursp ( ) ) ; } else if ( len == 1 && name [ 0 ] == '*' ) { genop_1 ( s , OP_MUL , cursp ( ) ) ; } else if ( len == 1 && name [ 0 ] == '/' ) { genop_1 ( s , OP_DIV , cursp ( ) ) ; } else if ( len == 1 && name [ 0 ] == '<' ) { genop_1 ( s , OP_LT , cursp ( ) ) ; } else if ( len == 2 && name [ 0 ] == '<' && name [ 1 ] == '=' ) { genop_1 ( s , OP_LE , cursp ( ) ) ; } else if ( len == 1 && name [ 0 ] == '>' ) { genop_1 ( s , OP_GT , cursp ( ) ) ; } else if ( len == 2 && name [ 0 ] == '>' && name [ 1 ] == '=' ) { genop_1 ( s , OP_GE , cursp ( ) ) ; } else { idx = new_sym ( s , sym ) ; genop_3 ( s , OP_SEND , cursp ( ) , idx , 1 ) ; } if ( callargs < 0 ) { gen_assignment ( s , tree -> car , NULL , cursp ( ) , val ) ; } else { if ( val && vsp >= 0 ) { gen_move ( s , vsp , cursp ( ) , 0 ) ; } if ( callargs == CALL_MAXARGS ) { pop ( ) ; genop_2 ( s , OP_ARYPUSH , cursp ( ) , 1 ) ; } else { pop_n ( callargs ) ; callargs ++ ; } pop ( ) ; idx = new_sym ( s , attrsym ( s , nsym ( tree -> car -> cdr -> cdr -> car ) ) ) ; genop_3 ( s , OP_SEND , cursp ( ) , idx , callargs ) ; } } break ; case NODE_SUPER : { codegen_scope * s2 = s ; int lv = 0 ; int n = 0 , nk = 0 , st = 0 ; push ( ) ; while ( ! s2 -> mscope ) { lv ++ ; s2 = s2 -> prev ; if ( ! s2 ) break ; } if ( tree ) { node * args = tree -> car ; if ( args ) { st = n = gen_values ( s , args , VAL , 14 ) ; if ( n < 0 ) { st = 1 ; n = 15 ; push ( ) ; } } if ( s2 && ( s2 -> ainfo & 0x1 ) && tree -> cdr -> car ) { nk = gen_hash ( s , tree -> cdr -> car -> cdr , VAL , 14 ) ; if ( nk < 0 ) { st ++ ; nk = 15 ; } else st += nk * 2 ; n |= nk << 4 ; } if ( tree -> cdr -> cdr ) { codegen ( s , tree -> cdr -> cdr , VAL ) ; } <S2SV_StartBug> else if ( ! s2 ) { <S2SV_EndBug> push ( ) ; } <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> gen_blkmove ( s , s2 -> ainfo , lv ) ; <S2SV_EndBug> } st ++ ; <S2SV_StartBug> } <S2SV_EndBug> else { if ( ! s2 ) push ( ) ; else gen_blkmove ( s , s2 -> ainfo , lv ) ; st ++ ; } pop_n ( st + 1 ) ; genop_2 ( s , OP_SUPER , cursp ( ) , n ) ; if ( val ) push ( ) ; } break ; case NODE_ZSUPER : { codegen_scope * s2 = s ; int lv = 0 ; uint16_t ainfo = 0 ; int n = CALL_MAXARGS ; int sp = cursp ( ) ; push ( ) ; while ( ! s2 -> mscope ) { lv ++ ; s2 = s2 -> prev ; if ( ! s2 ) break ; } if ( s2 && s2 -> ainfo > 0 ) { ainfo = s2 -> ainfo ; } if ( ainfo > 0 ) { genop_2S ( s , OP_ARGARY , cursp ( ) , ( ainfo << 4 ) | ( lv & 0xf ) ) ; push ( ) ; push ( ) ; push ( ) ; pop ( ) ; pop ( ) ; pop ( ) ; if ( ainfo & 0x1 ) { n |= CALL_MAXARGS << 4 ; push ( ) ; } if ( tree && tree -> cdr && tree -> cdr -> cdr ) { push ( ) ; codegen ( s , tree -> cdr -> cdr , VAL ) ; } } else { if ( tree && tree -> cdr && tree -> cdr -> cdr ) { codegen ( s , tree -> cdr -> cdr , VAL ) ; } else { gen_blkmove ( s , 0 , lv ) ; } n = 0 ; } s -> sp = sp ; genop_2 ( s , OP_SUPER , cursp ( ) , n ) ; if ( val ) push ( ) ; } break ; case NODE_RETURN : if ( tree ) { gen_retval ( s , tree ) ; } else { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; } if ( s -> loop ) { gen_return ( s , OP_RETURN_BLK , cursp ( ) ) ; } else { gen_return ( s , OP_RETURN , cursp ( ) ) ; } if ( val ) push ( ) ; break ; case NODE_YIELD : { codegen_scope * s2 = s ; int lv = 0 , ainfo = - 1 ; int n = 0 , sendv = 0 ; while ( ! s2 -> mscope ) { lv ++ ; s2 = s2 -> prev ; if ( ! s2 ) break ; } if ( s2 ) { ainfo = ( int ) s2 -> ainfo ; } if ( ainfo < 0 ) codegen_error ( s , \"invalid<S2SV_blank>yield<S2SV_blank>(SyntaxError)\" ) ; push ( ) ; if ( tree ) { n = gen_values ( s , tree , VAL , 14 ) ; if ( n < 0 ) { n = sendv = 1 ; push ( ) ; } } push ( ) ; pop ( ) ; pop_n ( n + 1 ) ; genop_2S ( s , OP_BLKPUSH , cursp ( ) , ( ainfo << 4 ) | ( lv & 0xf ) ) ; if ( sendv ) n = CALL_MAXARGS ; genop_3 ( s , OP_SEND , cursp ( ) , new_sym ( s , MRB_SYM_2 ( s -> mrb , call ) ) , n ) ; if ( val ) push ( ) ; } break ; case NODE_BREAK : loop_break ( s , tree ) ; if ( val ) push ( ) ; break ; case NODE_NEXT : if ( ! s -> loop ) { raise_error ( s , \"unexpected<S2SV_blank>next\" ) ; } else if ( s -> loop -> type == LOOP_NORMAL ) { codegen ( s , tree , NOVAL ) ; genjmp ( s , OP_JMPUW , s -> loop -> pc0 ) ; } else { if ( tree ) { codegen ( s , tree , VAL ) ; pop ( ) ; } else { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; } gen_return ( s , OP_RETURN , cursp ( ) ) ; } if ( val ) push ( ) ; break ; case NODE_REDO : if ( ! s -> loop || s -> loop -> type == LOOP_BEGIN || s -> loop -> type == LOOP_RESCUE ) { raise_error ( s , \"unexpected<S2SV_blank>redo\" ) ; } else { genjmp ( s , OP_JMPUW , s -> loop -> pc1 ) ; } if ( val ) push ( ) ; break ; case NODE_RETRY : { const char * msg = \"unexpected<S2SV_blank>retry\" ; const struct loopinfo * lp = s -> loop ; while ( lp && lp -> type != LOOP_RESCUE ) { lp = lp -> prev ; } if ( ! lp ) { raise_error ( s , msg ) ; } else { genjmp ( s , OP_JMPUW , lp -> pc0 ) ; } if ( val ) push ( ) ; } break ; case NODE_LVAR : if ( val ) { int idx = lv_idx ( s , nsym ( tree ) ) ; if ( idx > 0 ) { gen_move ( s , cursp ( ) , idx , val ) ; } else { gen_getupvar ( s , cursp ( ) , nsym ( tree ) ) ; } push ( ) ; } break ; case NODE_NVAR : if ( val ) { int idx = nint ( tree ) ; gen_move ( s , cursp ( ) , idx , val ) ; push ( ) ; } break ; case NODE_GVAR : { int sym = new_sym ( s , nsym ( tree ) ) ; genop_2 ( s , OP_GETGV , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_IVAR : { int sym = new_sym ( s , nsym ( tree ) ) ; genop_2 ( s , OP_GETIV , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_CVAR : { int sym = new_sym ( s , nsym ( tree ) ) ; genop_2 ( s , OP_GETCV , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_CONST : { int sym = new_sym ( s , nsym ( tree ) ) ; genop_2 ( s , OP_GETCONST , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_BACK_REF : if ( val ) { char buf [ ] = { '$' , nchar ( tree ) } ; int sym = new_sym ( s , mrb_intern ( s -> mrb , buf , sizeof ( buf ) ) ) ; genop_2 ( s , OP_GETGV , cursp ( ) , sym ) ; push ( ) ; } break ; case NODE_NTH_REF : if ( val ) { mrb_state * mrb = s -> mrb ; mrb_value str ; int sym ; str = mrb_format ( mrb , \"$%d\" , nint ( tree ) ) ; sym = new_sym ( s , mrb_intern_str ( mrb , str ) ) ; genop_2 ( s , OP_GETGV , cursp ( ) , sym ) ; push ( ) ; } break ; case NODE_ARG : break ; case NODE_BLOCK_ARG : if ( ! tree ) { int idx = lv_idx ( s , MRB_OPSYM_2 ( s -> mrb , and ) ) ; if ( idx == 0 ) { codegen_error ( s , \"no<S2SV_blank>anonymous<S2SV_blank>block<S2SV_blank>argument\" ) ; } gen_move ( s , cursp ( ) , idx , val ) ; <S2SV_StartBug> } <S2SV_EndBug> else { codegen ( s , tree , val ) ; } break ; case NODE_INT : if ( val ) { char * p = ( char * ) tree -> car ; int base = nint ( tree -> cdr -> car ) ; mrb_int i ; mrb_bool overflow ; i = readint ( s , p , base , FALSE , & overflow ) ; if ( overflow ) { int off = new_litbn ( s , p , base , FALSE ) ; genop_2 ( s , OP_LOADL , cursp ( ) , off ) ; } else { gen_int ( s , cursp ( ) , i ) ; } push ( ) ; } break ; # ifndef MRB_NO_FLOAT case NODE_FLOAT : if ( val ) { char * p = ( char * ) tree ; mrb_float f = mrb_float_read ( p , NULL ) ; int off = new_lit ( s , mrb_float_value ( s -> mrb , f ) ) ; genop_2 ( s , OP_LOADL , cursp ( ) , off ) ; push ( ) ; } break ; # endif case NODE_NEGATE : { nt = nint ( tree -> car ) ; switch ( nt ) { # ifndef MRB_NO_FLOAT case NODE_FLOAT : if ( val ) { char * p = ( char * ) tree -> cdr ; mrb_float f = mrb_float_read ( p , NULL ) ; int off = new_lit ( s , mrb_float_value ( s -> mrb , - f ) ) ; genop_2 ( s , OP_LOADL , cursp ( ) , off ) ; push ( ) ; } break ; # endif case NODE_INT : if ( val ) { char * p = ( char * ) tree -> cdr -> car ; int base = nint ( tree -> cdr -> cdr -> car ) ; mrb_int i ; mrb_bool overflow ; i = readint ( s , p , base , TRUE , & overflow ) ; if ( overflow ) { int off = new_litbn ( s , p , base , TRUE ) ; genop_2 ( s , OP_LOADL , cursp ( ) , off ) ; } else { gen_int ( s , cursp ( ) , i ) ; } push ( ) ; } break ; default : if ( val ) { codegen ( s , tree , VAL ) ; pop ( ) ; push_n ( 2 ) ; pop_n ( 2 ) ; mrb_sym minus = MRB_OPSYM_2 ( s -> mrb , minus ) ; if ( ! gen_uniop ( s , minus , cursp ( ) ) ) { genop_3 ( s , OP_SEND , cursp ( ) , new_sym ( s , minus ) , 0 ) ; } push ( ) ; } else { codegen ( s , tree , NOVAL ) ; } break ; } } break ; case NODE_STR : if ( val ) { char * p = ( char * ) tree -> car ; size_t len = ( intptr_t ) tree -> cdr ; int ai = mrb_gc_arena_save ( s -> mrb ) ; int off = new_lit ( s , mrb_str_new ( s -> mrb , p , len ) ) ; mrb_gc_arena_restore ( s -> mrb , ai ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; push ( ) ; } break ; case NODE_HEREDOC : tree = ( ( struct mrb_parser_heredoc_info * ) tree ) -> doc ; case NODE_DSTR : if ( val ) { node * n = tree ; if ( ! n ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; break ; } codegen ( s , n -> car , VAL ) ; n = n -> cdr ; while ( n ) { codegen ( s , n -> car , VAL ) ; pop ( ) ; pop ( ) ; genop_1 ( s , OP_STRCAT , cursp ( ) ) ; push ( ) ; n = n -> cdr ; } } else { node * n = tree ; while ( n ) { if ( nint ( n -> car -> car ) != NODE_STR ) { codegen ( s , n -> car , NOVAL ) ; } n = n -> cdr ; } } break ; case NODE_WORDS : gen_literal_array ( s , tree , FALSE , val ) ; break ; case NODE_SYMBOLS : gen_literal_array ( s , tree , TRUE , val ) ; break ; case NODE_DXSTR : { node * n ; int ai = mrb_gc_arena_save ( s -> mrb ) ; int sym = new_sym ( s , MRB_SYM_2 ( s -> mrb , Kernel ) ) ; genop_1 ( s , OP_LOADSELF , cursp ( ) ) ; push ( ) ; codegen ( s , tree -> car , VAL ) ; n = tree -> cdr ; while ( n ) { if ( nint ( n -> car -> car ) == NODE_XSTR ) { n -> car -> car = ( struct mrb_ast_node * ) ( intptr_t ) NODE_STR ; mrb_assert ( ! n -> cdr ) ; } codegen ( s , n -> car , VAL ) ; pop ( ) ; pop ( ) ; genop_1 ( s , OP_STRCAT , cursp ( ) ) ; push ( ) ; n = n -> cdr ; } push ( ) ; pop_n ( 3 ) ; sym = new_sym ( s , MRB_OPSYM_2 ( s -> mrb , tick ) ) ; genop_3 ( s , OP_SEND , cursp ( ) , sym , 1 ) ; if ( val ) push ( ) ; mrb_gc_arena_restore ( s -> mrb , ai ) ; } break ; case NODE_XSTR : { char * p = ( char * ) tree -> car ; size_t len = ( intptr_t ) tree -> cdr ; int ai = mrb_gc_arena_save ( s -> mrb ) ; int off = new_lit ( s , mrb_str_new ( s -> mrb , p , len ) ) ; int sym ; genop_1 ( s , OP_LOADSELF , cursp ( ) ) ; push ( ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; push ( ) ; push ( ) ; pop_n ( 3 ) ; sym = new_sym ( s , MRB_OPSYM_2 ( s -> mrb , tick ) ) ; genop_3 ( s , OP_SEND , cursp ( ) , sym , 1 ) ; if ( val ) push ( ) ; mrb_gc_arena_restore ( s -> mrb , ai ) ; } break ; case NODE_REGX : if ( val ) { char * p1 = ( char * ) tree -> car ; char * p2 = ( char * ) tree -> cdr -> car ; char * p3 = ( char * ) tree -> cdr -> cdr ; int ai = mrb_gc_arena_save ( s -> mrb ) ; int sym = new_sym ( s , mrb_intern_lit ( s -> mrb , REGEXP_CLASS ) ) ; int off = new_lit ( s , mrb_str_new_cstr ( s -> mrb , p1 ) ) ; int argc = 1 ; genop_1 ( s , OP_OCLASS , cursp ( ) ) ; genop_2 ( s , OP_GETMCNST , cursp ( ) , sym ) ; push ( ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; push ( ) ; if ( p2 || p3 ) { if ( p2 ) { off = new_lit ( s , mrb_str_new_cstr ( s -> mrb , p2 ) ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; } else { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; } push ( ) ; argc ++ ; if ( p3 ) { off = new_lit ( s , mrb_str_new ( s -> mrb , p3 , 1 ) ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; push ( ) ; argc ++ ; } } push ( ) ; pop_n ( argc + 2 ) ; sym = new_sym ( s , MRB_SYM_2 ( s -> mrb , compile ) ) ; genop_3 ( s , OP_SEND , cursp ( ) , sym , argc ) ; mrb_gc_arena_restore ( s -> mrb , ai ) ; push ( ) ; } break ; case NODE_DREGX : if ( val ) { node * n = tree -> car ; int ai = mrb_gc_arena_save ( s -> mrb ) ; int sym = new_sym ( s , mrb_intern_lit ( s -> mrb , REGEXP_CLASS ) ) ; int argc = 1 ; int off ; char * p ; genop_1 ( s , OP_OCLASS , cursp ( ) ) ; genop_2 ( s , OP_GETMCNST , cursp ( ) , sym ) ; push ( ) ; codegen ( s , n -> car , VAL ) ; n = n -> cdr ; while ( n ) { codegen ( s , n -> car , VAL ) ; pop ( ) ; pop ( ) ; genop_1 ( s , OP_STRCAT , cursp ( ) ) ; push ( ) ; n = n -> cdr ; } n = tree -> cdr -> cdr ; if ( n -> car ) { p = ( char * ) n -> car ; off = new_lit ( s , mrb_str_new_cstr ( s -> mrb , p ) ) ; codegen ( s , tree -> car , VAL ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; pop ( ) ; genop_1 ( s , OP_STRCAT , cursp ( ) ) ; push ( ) ; } if ( n -> cdr -> car ) { char * p2 = ( char * ) n -> cdr -> car ; off = new_lit ( s , mrb_str_new_cstr ( s -> mrb , p2 ) ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; push ( ) ; argc ++ ; } if ( n -> cdr -> cdr ) { char * p2 = ( char * ) n -> cdr -> cdr ; off = new_lit ( s , mrb_str_new_cstr ( s -> mrb , p2 ) ) ; genop_2 ( s , OP_STRING , cursp ( ) , off ) ; push ( ) ; argc ++ ; } push ( ) ; pop_n ( argc + 2 ) ; sym = new_sym ( s , MRB_SYM_2 ( s -> mrb , compile ) ) ; genop_3 ( s , OP_SEND , cursp ( ) , sym , argc ) ; mrb_gc_arena_restore ( s -> mrb , ai ) ; push ( ) ; } else { node * n = tree -> car ; while ( n ) { if ( nint ( n -> car -> car ) != NODE_STR ) { codegen ( s , n -> car , NOVAL ) ; } n = n -> cdr ; } } break ; case NODE_SYM : if ( val ) { int sym = new_sym ( s , nsym ( tree ) ) ; genop_2 ( s , OP_LOADSYM , cursp ( ) , sym ) ; push ( ) ; } break ; case NODE_DSYM : codegen ( s , tree , val ) ; if ( val ) { gen_intern ( s ) ; } break ; case NODE_SELF : if ( val ) { genop_1 ( s , OP_LOADSELF , cursp ( ) ) ; push ( ) ; } break ; case NODE_NIL : if ( val ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } break ; case NODE_TRUE : if ( val ) { genop_1 ( s , OP_LOADT , cursp ( ) ) ; push ( ) ; } break ; case NODE_FALSE : if ( val ) { genop_1 ( s , OP_LOADF , cursp ( ) ) ; push ( ) ; } break ; case NODE_ALIAS : { int a = new_sym ( s , nsym ( tree -> car ) ) ; int b = new_sym ( s , nsym ( tree -> cdr ) ) ; genop_2 ( s , OP_ALIAS , a , b ) ; if ( val ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } } break ; case NODE_UNDEF : { node * t = tree ; while ( t ) { int symbol = new_sym ( s , nsym ( t -> car ) ) ; genop_1 ( s , OP_UNDEF , symbol ) ; t = t -> cdr ; } if ( val ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } } break ; case NODE_CLASS : { int idx ; node * body ; if ( tree -> car -> car == ( node * ) 0 ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } else if ( tree -> car -> car == ( node * ) 1 ) { genop_1 ( s , OP_OCLASS , cursp ( ) ) ; push ( ) ; } else { codegen ( s , tree -> car -> car , VAL ) ; } if ( tree -> cdr -> car ) { codegen ( s , tree -> cdr -> car , VAL ) ; } else { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } pop ( ) ; pop ( ) ; idx = new_sym ( s , nsym ( tree -> car -> cdr ) ) ; genop_2 ( s , OP_CLASS , cursp ( ) , idx ) ; body = tree -> cdr -> cdr -> car ; if ( nint ( body -> cdr -> car ) == NODE_BEGIN && body -> cdr -> cdr == NULL ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; } else { idx = scope_body ( s , body , val ) ; genop_2 ( s , OP_EXEC , cursp ( ) , idx ) ; } if ( val ) { push ( ) ; } } break ; case NODE_MODULE : { int idx ; if ( tree -> car -> car == ( node * ) 0 ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } else if ( tree -> car -> car == ( node * ) 1 ) { genop_1 ( s , OP_OCLASS , cursp ( ) ) ; push ( ) ; } else { codegen ( s , tree -> car -> car , VAL ) ; } pop ( ) ; idx = new_sym ( s , nsym ( tree -> car -> cdr ) ) ; genop_2 ( s , OP_MODULE , cursp ( ) , idx ) ; if ( nint ( tree -> cdr -> car -> cdr -> car ) == NODE_BEGIN && tree -> cdr -> car -> cdr -> cdr == NULL ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; } else { idx = scope_body ( s , tree -> cdr -> car , val ) ; genop_2 ( s , OP_EXEC , cursp ( ) , idx ) ; } if ( val ) { push ( ) ; } } break ; case NODE_SCLASS : { int idx ; codegen ( s , tree -> car , VAL ) ; pop ( ) ; genop_1 ( s , OP_SCLASS , cursp ( ) ) ; if ( nint ( tree -> cdr -> car -> cdr -> car ) == NODE_BEGIN && tree -> cdr -> car -> cdr -> cdr == NULL ) { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; } else { idx = scope_body ( s , tree -> cdr -> car , val ) ; genop_2 ( s , OP_EXEC , cursp ( ) , idx ) ; } if ( val ) { push ( ) ; } } break ; case NODE_DEF : { int sym = new_sym ( s , nsym ( tree -> car ) ) ; int idx = lambda_body ( s , tree -> cdr , 0 ) ; genop_1 ( s , OP_TCLASS , cursp ( ) ) ; push ( ) ; genop_2 ( s , OP_METHOD , cursp ( ) , idx ) ; push ( ) ; pop ( ) ; pop ( ) ; genop_2 ( s , OP_DEF , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_SDEF : { node * recv = tree -> car ; int sym = new_sym ( s , nsym ( tree -> cdr -> car ) ) ; int idx = lambda_body ( s , tree -> cdr -> cdr , 0 ) ; codegen ( s , recv , VAL ) ; pop ( ) ; genop_1 ( s , OP_SCLASS , cursp ( ) ) ; push ( ) ; genop_2 ( s , OP_METHOD , cursp ( ) , idx ) ; pop ( ) ; genop_2 ( s , OP_DEF , cursp ( ) , sym ) ; if ( val ) push ( ) ; } break ; case NODE_POSTEXE : codegen ( s , tree , NOVAL ) ; break ; default : break ; } exit : s -> rlev = rlev ; }", "target": "<S2SV_ModStart> else if ( s2 ) gen_blkmove ( s , s2 -> ainfo , lv ) ; else { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; <S2SV_ModEnd> push ( ) <S2SV_ModStart> ) ; } } else { if ( s2 ) <S2SV_ModEnd> gen_blkmove ( s <S2SV_ModStart> lv ) ; else { genop_1 ( s , OP_LOADNIL , cursp ( ) ) ; push ( ) ; } <S2SV_ModStart> st ++ ; <S2SV_ModEnd> pop_n ( st <S2SV_ModStart> val ) ; if ( val ) push ( ) ;"}
{"source": "CWE-703 ecma_op_internal_buffer_append ( ecma_collection_t * container_p , ecma_value_t key_arg , ecma_value_t value_arg , lit_magic_string_id_t lit_id ) { JERRY_ASSERT ( container_p != NULL ) ; <S2SV_StartBug> ecma_collection_push_back ( container_p , ecma_copy_value_if_not_object ( key_arg ) ) ; <S2SV_EndBug> if ( lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL ) { <S2SV_StartBug> ecma_collection_push_back ( container_p , ecma_copy_value_if_not_object ( value_arg ) ) ; <S2SV_EndBug> } ECMA_CONTAINER_SET_SIZE ( container_p , ECMA_CONTAINER_GET_SIZE ( container_p ) + 1 ) ; }", "target": "<S2SV_ModStart> NULL ) ; <S2SV_ModEnd> if ( lit_id <S2SV_ModStart> LIT_MAGIC_STRING_MAP_UL ) { ecma_value_t values [ ] = { ecma_copy_value_if_not_object ( key_arg ) , ecma_copy_value_if_not_object ( value_arg ) } ; ecma_collection_append ( container_p , values , 2 ) ; } else { <S2SV_ModStart> , ecma_copy_value_if_not_object ( key_arg <S2SV_ModEnd> ) ) ;"}
{"source": "CWE-787 void Compute ( OpKernelContext * context ) override { const Tensor & input_tensor = context -> input ( 0 ) ; const auto input_tensor_flat = input_tensor . flat < int32 > ( ) ; const Tensor & input_splits = context -> input ( 1 ) ; const auto input_splits_flat = input_splits . flat < SPLITS_TYPE > ( ) ; <S2SV_StartBug> <S2SV_EndBug> OP_REQUIRES ( context , input_splits_flat ( 0 ) == 0 , errors : : InvalidArgument ( \"First<S2SV_blank>value<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero.\" ) ) ; OP_REQUIRES ( context , input_splits_flat ( input_splits_flat . size ( ) - 1 ) == input_tensor_flat . size ( ) , errors : : InvalidArgument ( \"Last<S2SV_blank>value<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\" \"equal<S2SV_blank>to<S2SV_blank>length<S2SV_blank>of<S2SV_blank>input_tensor.\" ) ) ; TensorShape output_shape ( { input_splits . dim_size ( 0 ) - 1 } ) ; Tensor * output_tensor ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"output\" , output_shape , & output_tensor ) ) ; auto output_tensor_flat = output_tensor -> flat < tstring > ( ) ; int idx = 0 ; for ( int i = 1 ; i < input_splits_flat . size ( ) ; ++ i ) { icu : : UnicodeString unicode_string ; icu : : UnicodeStringAppendable appendable_unicode_string ( unicode_string ) ; OP_REQUIRES ( context , input_splits_flat ( i - 1 ) <= input_splits_flat ( i ) , errors : : InvalidArgument ( \"Values<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>equal<S2SV_blank>or<S2SV_blank>in<S2SV_blank>ascending<S2SV_blank>order.\" ) ) ; OP_REQUIRES ( context , input_splits_flat ( i ) <= input_tensor_flat . size ( ) , errors : : InvalidArgument ( \"Values<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>or<S2SV_blank>\" \"equal<S2SV_blank>to<S2SV_blank>input_tensor<S2SV_blank>length.\" ) ) ; for ( ; idx < input_splits_flat ( i ) ; ++ idx ) { int32_t code_point = input_tensor_flat ( idx ) ; if ( ! U_IS_UNICODE_CHAR ( code_point ) ) { if ( error_options_ . error_on_malformatting ) { context -> CtxFailure ( errors : : InvalidArgument ( \"Code<S2SV_blank>point<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range<S2SV_blank>for<S2SV_blank>Unicode,<S2SV_blank>or<S2SV_blank>a<S2SV_blank>noncharacter.\" ) ) ; return ; } else if ( ! error_options_ . elide_replacement ) { code_point = error_options_ . subst ; } } appendable_unicode_string . appendCodePoint ( code_point ) ; } tstring result ; Encode ( encoding_ , unicode_string , & result ) ; output_tensor_flat ( i - 1 ) = std : : move ( result ) ; } }", "target": "<S2SV_ModStart> ( ) ; OP_REQUIRES ( context , input_splits . NumElements ( ) > 0 , errors : : InvalidArgument ( \"Input_splits<S2SV_blank>should<S2SV_blank>contain<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>\" \"given<S2SV_blank>input_values<S2SV_blank>has<S2SV_blank>0<S2SV_blank>elements\" ) ) ;"}
{"source": "CWE-787 static inline Status ParseAndCheckBoxSizes ( const Tensor & boxes , const Tensor & box_index , int * num_boxes ) { if ( boxes . NumElements ( ) == 0 && box_index . NumElements ( ) == 0 ) { * num_boxes = 0 ; return Status : : OK ( ) ; } if ( boxes . dims ( ) != 2 ) { return errors : : InvalidArgument ( \"boxes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>2-D\" , boxes . shape ( ) . DebugString ( ) ) ; } * num_boxes = boxes . dim_size ( 0 ) ; if ( boxes . dim_size ( 1 ) != 4 ) { return errors : : InvalidArgument ( \"boxes<S2SV_blank>must<S2SV_blank>have<S2SV_blank>4<S2SV_blank>columns\" ) ; } <S2SV_StartBug> if ( box_index . dims ( ) != 1 ) { <S2SV_EndBug> return errors : : InvalidArgument ( \"box_index<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-D\" , box_index . shape ( ) . DebugString ( ) ) ; } if ( box_index . dim_size ( 0 ) != * num_boxes ) { return errors : : InvalidArgument ( \"box_index<S2SV_blank>has<S2SV_blank>incompatible<S2SV_blank>shape\" ) ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ) ; } for ( int64 i = 0 ; i < * num_boxes ; i ++ ) { for ( int64 j = 0 ; j < 4 ; j ++ ) { if ( ! isfinite ( boxes . tensor < float , 2 > ( ) ( i , j ) ) ) { return errors : : InvalidArgument ( \"boxes<S2SV_blank>values<S2SV_blank>must<S2SV_blank>be<S2SV_blank>finite,<S2SV_blank>received<S2SV_blank>boxes[\" , i , \"]:<S2SV_blank>\" , boxes . tensor < float , 2 > ( ) ( i , 0 ) , \",<S2SV_blank>\" , boxes . tensor < float , 2 > ( ) ( i , 1 ) , \",<S2SV_blank>\" , boxes . tensor < float , 2 > ( ) ( i , 2 ) , \",<S2SV_blank>\" , boxes . tensor < float , 2 > ( ) ( i , 3 ) ) ; } } }"}
{"source": "CWE-415 int flb_parser_json_do ( struct flb_parser * parser , const char * in_buf , size_t in_size , void * * out_buf , size_t * out_size , struct flb_time * out_time ) { int i ; int skip ; int ret ; int slen ; int root_type ; int records ; double tmfrac = 0 ; char * mp_buf = NULL ; char * time_key ; char * tmp_out_buf = NULL ; char tmp [ 255 ] ; size_t tmp_out_size = 0 ; size_t off = 0 ; size_t map_size ; size_t mp_size ; size_t len ; msgpack_sbuffer mp_sbuf ; msgpack_packer mp_pck ; msgpack_unpacked result ; msgpack_object map ; msgpack_object * k = NULL ; msgpack_object * v = NULL ; time_t time_lookup ; struct tm tm = { 0 } ; struct flb_time * t ; ret = flb_pack_json_recs ( in_buf , in_size , & mp_buf , & mp_size , & root_type , & records ) ; if ( ret != 0 ) { return - 1 ; } if ( records != 1 ) { flb_free ( mp_buf ) ; return - 1 ; } msgpack_unpacked_init ( & result ) ; if ( msgpack_unpack_next ( & result , mp_buf , mp_size , & off ) == MSGPACK_UNPACK_SUCCESS ) { map = result . data ; if ( map . type != MSGPACK_OBJECT_MAP ) { flb_free ( mp_buf ) ; msgpack_unpacked_destroy ( & result ) ; return - 1 ; } } else { if ( mp_size > 0 ) { flb_free ( mp_buf ) ; } msgpack_unpacked_destroy ( & result ) ; return - 1 ; } tmp_out_buf = mp_buf ; tmp_out_size = mp_size ; if ( parser -> decoders ) { ret = flb_parser_decoder_do ( parser -> decoders , mp_buf , mp_size , & tmp_out_buf , & tmp_out_size ) ; if ( ret == 0 ) { off = 0 ; msgpack_unpacked_destroy ( & result ) ; msgpack_unpacked_init ( & result ) ; msgpack_unpack_next ( & result , tmp_out_buf , tmp_out_size , & off ) ; map = result . data ; } } * out_buf = tmp_out_buf ; * out_size = tmp_out_size ; if ( mp_buf != tmp_out_buf ) { flb_free ( mp_buf ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! parser -> time_fmt ) { msgpack_unpacked_destroy ( & result ) ; return * out_size ; } if ( parser -> time_key ) { time_key = parser -> time_key ; } else { time_key = \"time\" ; } slen = strlen ( time_key ) ; map_size = map . via . map . size ; skip = map_size ; for ( i = 0 ; i < map_size ; i ++ ) { k = & map . via . map . ptr [ i ] . key ; v = & map . via . map . ptr [ i ] . val ; if ( k -> via . str . size != slen ) { continue ; } if ( k -> via . str . ptr == NULL ) { <S2SV_StartBug> flb_free ( mp_buf ) ; <S2SV_EndBug> * out_buf = NULL ; msgpack_unpacked_destroy ( & result ) ; return - 1 ; } if ( strncmp ( k -> via . str . ptr , time_key , k -> via . str . size ) == 0 ) { if ( parser -> time_keep == FLB_FALSE ) { skip = i ; break ; } else { skip = - 1 ; } break ; } k = NULL ; v = NULL ; } if ( i >= map_size || ! k || ! v ) { msgpack_unpacked_destroy ( & result ) ; return * out_size ; } if ( v -> type != MSGPACK_OBJECT_STR ) { msgpack_unpacked_destroy ( & result ) ; return * out_size ; } ret = flb_parser_time_lookup ( v -> via . str . ptr , v -> via . str . size , 0 , parser , & tm , & tmfrac ) ; if ( ret == - 1 ) { len = v -> via . str . size ; if ( len > sizeof ( tmp ) - 1 ) { len = sizeof ( tmp ) - 1 ; } memcpy ( tmp , v -> via . str . ptr , len ) ; tmp [ len ] = '\\\\0' ; flb_warn ( \"[parser:%s]<S2SV_blank>invalid<S2SV_blank>time<S2SV_blank>format<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>\\'%s\\'\" , parser -> name , parser -> time_fmt_full , tmp ) ; time_lookup = 0 ; } else { time_lookup = flb_parser_tm2time ( & tm ) ; } msgpack_sbuffer_init ( & mp_sbuf ) ; msgpack_packer_init ( & mp_pck , & mp_sbuf , msgpack_sbuffer_write ) ; if ( parser -> time_keep == FLB_FALSE ) { msgpack_pack_map ( & mp_pck , map_size - 1 ) ; } else { msgpack_pack_map ( & mp_pck , map_size ) ; } for ( i = 0 ; i < map_size ; i ++ ) { if ( i == skip ) { continue ; } msgpack_pack_object ( & mp_pck , map . via . map . ptr [ i ] . key ) ; msgpack_pack_object ( & mp_pck , map . via . map . ptr [ i ] . val ) ; } flb_free ( tmp_out_buf ) ; * out_buf = mp_sbuf . data ; * out_size = mp_sbuf . size ; t = out_time ; t -> tm . tv_sec = time_lookup ; t -> tm . tv_nsec = ( tmfrac * 1000000000 ) ; msgpack_unpacked_destroy ( & result ) ; return * out_size ; }", "target": "<S2SV_ModStart> mp_buf ) ; mp_buf = NULL ; <S2SV_ModStart> flb_free ( mp_buf ) ; flb_free ( tmp_out_buf"}
{"source": "CWE-200 main ( int argc , char * * argv ) { const char * safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\" \"/usr/local/bin:/usr/local/sbin\" ; const char * confpath = NULL ; char * shargv [ ] = { NULL , NULL } ; char * sh ; const char * p ; const char * cmd ; char cmdline [ LINE_MAX ] ; struct passwd mypwstore , targpwstore ; struct passwd * mypw , * targpw ; const struct rule * rule ; uid_t uid ; uid_t target = 0 ; gid_t groups [ NGROUPS_MAX + 1 ] ; int ngroups ; int i , ch , rv ; int sflag = 0 ; int nflag = 0 ; char cwdpath [ PATH_MAX ] ; const char * cwd ; char * * envp ; setprogname ( \"doas\" ) ; closefrom ( STDERR_FILENO + 1 ) ; uid = getuid ( ) ; while ( ( ch = getopt ( argc , argv , \"+C:Lnsu:\" ) ) != - 1 ) { switch ( ch ) { case 'C' : confpath = optarg ; break ; case 'L' : # if defined ( USE_TIMESTAMP ) exit ( timestamp_clear ( ) == - 1 ) ; # else exit ( 0 ) ; # endif case 'u' : if ( parseuid ( optarg , & target ) != 0 ) errx ( 1 , \"unknown<S2SV_blank>user\" ) ; break ; case 'n' : nflag = 1 ; break ; case 's' : sflag = 1 ; break ; default : usage ( ) ; break ; } } argv += optind ; argc -= optind ; if ( confpath ) { if ( sflag ) usage ( ) ; } else if ( ( ! sflag && ! argc ) || ( sflag && argc ) ) usage ( ) ; rv = mygetpwuid_r ( uid , & mypwstore , & mypw ) ; if ( rv != 0 ) err ( 1 , \"getpwuid_r<S2SV_blank>failed\" ) ; if ( mypw == NULL ) errx ( 1 , \"no<S2SV_blank>passwd<S2SV_blank>entry<S2SV_blank>for<S2SV_blank>self\" ) ; ngroups = getgroups ( NGROUPS_MAX , groups ) ; if ( ngroups == - 1 ) err ( 1 , \"can\\'t<S2SV_blank>get<S2SV_blank>groups\" ) ; groups [ ngroups ++ ] = getgid ( ) ; if ( sflag ) { sh = getenv ( \"SHELL\" ) ; if ( sh == NULL || * sh == '\\\\0' ) { shargv [ 0 ] = mypw -> pw_shell ; } else shargv [ 0 ] = sh ; argv = shargv ; argc = 1 ; } if ( confpath ) { checkconfig ( confpath , argc , argv , uid , groups , ngroups , target ) ; exit ( 1 ) ; } if ( geteuid ( ) ) errx ( 1 , \"not<S2SV_blank>installed<S2SV_blank>setuid\" ) ; parseconfig ( DOAS_CONF , 1 ) ; ( void ) strlcpy ( cmdline , argv [ 0 ] , sizeof ( cmdline ) ) ; for ( i = 1 ; i < argc ; i ++ ) { if ( strlcat ( cmdline , \"<S2SV_blank>\" , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; if ( strlcat ( cmdline , argv [ i ] , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; } cmd = argv [ 0 ] ; if ( ! permit ( uid , groups , ngroups , & rule , target , cmd , ( const char * * ) argv + 1 ) ) { syslog ( LOG_AUTHPRIV | LOG_NOTICE , \"command<S2SV_blank>not<S2SV_blank>permitted<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s\" , mypw -> pw_name , cmdline ) ; errc ( 1 , EPERM , NULL ) ; } # if defined ( USE_SHADOW ) if ( ! ( rule -> options & NOPASS ) ) { if ( nflag ) errx ( 1 , \"Authorization<S2SV_blank>required\" ) ; shadowauth ( mypw -> pw_name , rule -> options & PERSIST ) ; } # elif ! defined ( USE_PAM ) ( void ) nflag ; if ( ! ( rule -> options & NOPASS ) ) errx ( 1 , \"Authorization<S2SV_blank>required\" ) ; # endif if ( ( p = getenv ( \"PATH\" ) ) != NULL ) formerpath = strdup ( p ) ; if ( formerpath == NULL ) formerpath = \"\" ; if ( rule -> cmd ) { if ( setenv ( \"PATH\" , safepath , 1 ) == - 1 ) err ( 1 , \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>PATH<S2SV_blank>\\'%s\\'\" , safepath ) ; } rv = mygetpwuid_r ( target , & targpwstore , & targpw ) ; if ( rv != 0 ) err ( 1 , \"getpwuid_r<S2SV_blank>failed\" ) ; if ( targpw == NULL ) errx ( 1 , \"no<S2SV_blank>passwd<S2SV_blank>entry<S2SV_blank>for<S2SV_blank>target\" ) ; # if defined ( USE_PAM ) pamauth ( targpw -> pw_name , mypw -> pw_name , ! nflag , rule -> options & NOPASS , rule -> options & PERSIST ) ; # endif # ifdef HAVE_LOGIN_CAP_H <S2SV_StartBug> if ( setusercontext ( NULL , targpw , target , LOGIN_SETGROUP | <S2SV_EndBug> LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK | LOGIN_SETUSER ) != 0 ) errx ( 1 , \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>user<S2SV_blank>context<S2SV_blank>for<S2SV_blank>target\" ) ; # else if ( setresgid ( targpw -> pw_gid , targpw -> pw_gid , targpw -> pw_gid ) != 0 ) err ( 1 , \"setresgid\" ) ; if ( initgroups ( targpw -> pw_name , targpw -> pw_gid ) != 0 ) err ( 1 , \"initgroups\" ) ; if ( setresuid ( target , target , target ) != 0 ) err ( 1 , \"setresuid\" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = \"(failed)\" ; else cwd = cwdpath ; if ( ! ( rule -> options & NOLOG ) ) { syslog ( LOG_AUTHPRIV | LOG_INFO , \"%s<S2SV_blank>ran<S2SV_blank>command<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s\" , mypw -> pw_name , cmdline , targpw -> pw_name , cwd ) ; } envp = prepenv ( rule , mypw , targpw ) ; if ( rule -> cmd ) { if ( setenv ( \"PATH\" , safepath , 1 ) == - 1 ) err ( 1 , \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>PATH<S2SV_blank>\\'%s\\'\" , safepath ) ; } else { if ( setenv ( \"PATH\" , formerpath , 1 ) == - 1 ) err ( 1 , \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>PATH<S2SV_blank>\\'%s\\'\" , formerpath ) ; } execvpe ( cmd , argv , envp ) ; if ( errno == ENOENT ) errx ( 1 , \"%s:<S2SV_blank>command<S2SV_blank>not<S2SV_blank>found\" , cmd ) ; err ( 1 , \"%s\" , cmd ) ; }", "target": "<S2SV_ModStart> target , LOGIN_SETGROUP | LOGIN_SETPATH <S2SV_ModStart> \"setresuid\" ) ; if ( setenv ( \"PATH\" , safepath , 1 ) == - 1 ) err ( 1 , \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>PATH<S2SV_blank>\\'%s\\'\" , safepath ) ;"}
{"source": "CWE-295 bool WindowsServiceControl : : install ( const QString & filePath , const QString & displayName ) { <S2SV_StartBug> m_serviceHandle = CreateService ( <S2SV_EndBug> m_serviceManager , WindowsCoreFunctions : : toConstWCharArray ( m_name ) , WindowsCoreFunctions : : toConstWCharArray ( displayName ) , SERVICE_ALL_ACCESS , SERVICE_WIN32_OWN_PROCESS , SERVICE_AUTO_START , SERVICE_ERROR_NORMAL , <S2SV_StartBug> WindowsCoreFunctions : : toConstWCharArray ( filePath ) , <S2SV_EndBug> nullptr , nullptr , L\"Tcpip\\\\0RpcSs\\\\0\\\\0\" , nullptr , nullptr ) ; if ( m_serviceHandle == nullptr ) { const auto error = GetLastError ( ) ; if ( error == ERROR_SERVICE_EXISTS ) { vCritical ( ) << qUtf8Printable ( tr ( \"The<S2SV_blank>service<S2SV_blank>\\\\\"%1\\\\\"<S2SV_blank>is<S2SV_blank>already<S2SV_blank>installed.\" ) . arg ( m_name ) ) ; } else { vCritical ( ) << qUtf8Printable ( tr ( \"The<S2SV_blank>service<S2SV_blank>\\\\\"%1\\\\\"<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>installed.\" ) . arg ( m_name ) ) ; } return false ; } SC_ACTION serviceActions ; serviceActions . Delay = 10000 ; serviceActions . Type = SC_ACTION_RESTART ; SERVICE_FAILURE_ACTIONS serviceFailureActions ; serviceFailureActions . dwResetPeriod = 0 ; serviceFailureActions . lpRebootMsg = nullptr ; serviceFailureActions . lpCommand = nullptr ; serviceFailureActions . lpsaActions = & serviceActions ; serviceFailureActions . cActions = 1 ; ChangeServiceConfig2 ( m_serviceHandle , SERVICE_CONFIG_FAILURE_ACTIONS , & serviceFailureActions ) ; vInfo ( ) << qUtf8Printable ( tr ( \"The<S2SV_blank>service<S2SV_blank>\\\\\"%1\\\\\"<S2SV_blank>has<S2SV_blank>been<S2SV_blank>installed<S2SV_blank>successfully.\" ) . arg ( m_name ) ) ; return true ; }", "target": "<S2SV_ModStart> displayName ) { const auto binaryPath = QStringLiteral ( \"\\\\\"%1\\\\\"\" ) . arg ( QString ( filePath ) . replace ( QLatin1Char ( \\'\"\\' ) , QString ( ) ) ) ; <S2SV_ModStart> : toConstWCharArray ( binaryPath <S2SV_ModEnd> ) , nullptr"}
{"source": "CWE-125 void ndpi_search_openvpn ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; const u_int8_t * ovpn_payload = packet -> payload ; const u_int8_t * session_remote ; u_int8_t opcode ; u_int8_t alen ; int8_t hmac_size ; int8_t failed = 0 ; <S2SV_StartBug> if ( packet -> payload_packet_len >= 40 ) { <S2SV_EndBug> if ( packet -> tcp != NULL ) <S2SV_StartBug> ovpn_payload += 2 ; <S2SV_EndBug> opcode = ovpn_payload [ 0 ] & P_OPCODE_MASK ; if ( packet -> udp ) { # ifdef DEBUG printf ( \"[packet_id:<S2SV_blank>%u][opcode:<S2SV_blank>%u][Packet<S2SV_blank>ID:<S2SV_blank>%d][%u<S2SV_blank><-><S2SV_blank>%u][len:<S2SV_blank>%u]\\\\n\" , flow -> num_processed_pkts , opcode , check_pkid_and_detect_hmac_size ( ovpn_payload ) , <S2SV_StartBug> htons ( packet -> udp -> source ) , htons ( packet -> udp -> dest ) , packet -> payload_packet_len ) ; <S2SV_EndBug> # endif if ( ( flow -> num_processed_pkts == 1 ) && ( <S2SV_StartBug> ( ( packet -> payload_packet_len == 112 ) <S2SV_EndBug> && ( ( opcode == 168 ) || ( opcode == 192 ) ) ) <S2SV_StartBug> || ( ( packet -> payload_packet_len == 80 ) <S2SV_EndBug> && ( ( opcode == 184 ) || ( opcode == 88 ) || ( opcode == 160 ) || ( opcode == 168 ) || ( opcode == 200 ) ) ) ) ) { NDPI_LOG_INFO ( ndpi_struct , \"found<S2SV_blank>openvpn\\\\n\" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_OPENVPN , NDPI_PROTOCOL_UNKNOWN ) ; return ; } } if ( flow -> ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && ( opcode == P_CONTROL_HARD_RESET_CLIENT_V1 || opcode == P_CONTROL_HARD_RESET_CLIENT_V2 ) ) { if ( check_pkid_and_detect_hmac_size ( ovpn_payload ) > 0 ) { memcpy ( flow -> ovpn_session_id , ovpn_payload + 1 , 8 ) ; NDPI_LOG_DBG2 ( ndpi_struct , \"session<S2SV_blank>key:<S2SV_blank>%02x%02x%02x%02x%02x%02x%02x%02x\\\\n\" , flow -> ovpn_session_id [ 0 ] , flow -> ovpn_session_id [ 1 ] , flow -> ovpn_session_id [ 2 ] , flow -> ovpn_session_id [ 3 ] , flow -> ovpn_session_id [ 4 ] , flow -> ovpn_session_id [ 5 ] , flow -> ovpn_session_id [ 6 ] , flow -> ovpn_session_id [ 7 ] ) ; } } else if ( flow -> ovpn_counter >= 1 && flow -> ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT && ( opcode == P_CONTROL_HARD_RESET_SERVER_V1 || opcode == P_CONTROL_HARD_RESET_SERVER_V2 ) ) { hmac_size = check_pkid_and_detect_hmac_size ( ovpn_payload ) ; if ( hmac_size > 0 ) { <S2SV_StartBug> alen = ovpn_payload [ P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ] ; <S2SV_EndBug> if ( alen > 0 ) { <S2SV_StartBug> session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) + 1 + alen * 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( flow -> ovpn_session_id , session_remote , 8 ) == 0 ) { <S2SV_EndBug> NDPI_LOG_INFO ( ndpi_struct , \"found<S2SV_blank>openvpn\\\\n\" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_OPENVPN , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else { NDPI_LOG_DBG2 ( ndpi_struct , \"key<S2SV_blank>mismatch:<S2SV_blank>%02x%02x%02x%02x%02x%02x%02x%02x\\\\n\" , session_remote [ 0 ] , session_remote [ 1 ] , session_remote [ 2 ] , session_remote [ 3 ] , session_remote [ 4 ] , session_remote [ 5 ] , session_remote [ 6 ] , session_remote [ 7 ] ) ; failed = 1 ; <S2SV_StartBug> } <S2SV_EndBug> } else failed = 1 ; } else failed = 1 ; } else failed = 1 ; flow -> ovpn_counter ++ ; if ( failed ) { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; } } }", "target": "<S2SV_ModStart> = 0 ; int16_t ovpn_payload_len = <S2SV_ModEnd> packet -> payload_packet_len <S2SV_ModStart> packet -> payload_packet_len ; if ( ovpn_payload_len <S2SV_ModStart> ovpn_payload += 2 , ovpn_payload_len -= 2 ; <S2SV_ModStart> dest ) , ovpn_payload_len <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( ( ( ovpn_payload_len <S2SV_ModEnd> == 112 ) <S2SV_ModStart> || ( ( ovpn_payload_len <S2SV_ModEnd> == 80 ) <S2SV_ModStart> 0 ) { u_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ; <S2SV_ModStart> = ovpn_payload [ offset ] ; <S2SV_ModEnd> if ( alen <S2SV_ModStart> 0 ) { offset += <S2SV_ModEnd> 1 + alen <S2SV_ModStart> ; if ( ( offset + 8 ) <= ovpn_payload_len ) { session_remote = & ovpn_payload [ offset ] ; if ( <S2SV_ModStart> 1 ; } } else failed = 1 ;"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { const Tensor & input_sizes = context -> input ( 0 ) ; const Tensor & filter = context -> input ( 1 ) ; const Tensor & out_backprop = context -> input ( 2 ) ; TensorShape input_shape ; OP_REQUIRES_OK ( context , Conv2DBackpropComputeInputShape ( input_sizes , filter . shape ( ) , out_backprop . shape ( ) , data_format_ , & input_shape ) ) ; ConvBackpropDimensions dims ; OP_REQUIRES_OK ( context , ConvBackpropComputeDimensionsV2 ( \"Conv2DCustomBackpropInput\" , 2 , input_shape , filter . shape ( ) , out_backprop . shape ( ) , { 1 , 1 , 1 , 1 } , strides_ , padding_ , explicit_paddings_ , data_format_ , & dims ) ) ; OP_REQUIRES ( context , dims . in_depth == filter . shape ( ) . dim_size ( 2 ) , errors : : InvalidArgument ( \"Computed<S2SV_blank>input<S2SV_blank>depth<S2SV_blank>\" , dims . in_depth , \"<S2SV_blank>doesn\\'t<S2SV_blank>match<S2SV_blank>filter<S2SV_blank>input<S2SV_blank>depth<S2SV_blank>\" , filter . shape ( ) . dim_size ( 2 ) ) ) ; OP_REQUIRES ( context , dims . out_depth == filter . shape ( ) . dim_size ( 3 ) , errors : : InvalidArgument ( \"Computed<S2SV_blank>output<S2SV_blank>depth<S2SV_blank>\" , dims . out_depth , \"<S2SV_blank>doesn\\'t<S2SV_blank>match<S2SV_blank>filter<S2SV_blank>output<S2SV_blank>depth<S2SV_blank>\" , filter . shape ( ) . dim_size ( 3 ) ) ) ; Tensor * in_backprop = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , input_shape , & in_backprop ) ) ; if ( input_shape . num_elements ( ) == 0 ) { return ; } # if defined TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS && defined TENSORFLOW_USE_LIBXSMM_BACKWARD_CONVOLUTIONS int64 pad_top , pad_bottom ; int64 pad_left , pad_right ; OP_REQUIRES_OK ( context , GetWindowedOutputSizeVerbose ( dims . spatial_dims [ 0 ] . input_size , dims . spatial_dims [ 0 ] . filter_size , dims . spatial_dims [ 0 ] . stride , padding_ , & dims . spatial_dims [ 0 ] . output_size , & pad_top , & pad_bottom ) ) ; OP_REQUIRES_OK ( context , GetWindowedOutputSizeVerbose ( dims . spatial_dims [ 1 ] . input_size , dims . spatial_dims [ 1 ] . filter_size , dims . spatial_dims [ 1 ] . stride , padding_ , & dims . spatial_dims [ 1 ] . output_size , & pad_left , & pad_right ) ) ; if ( pad_left == pad_right && pad_top == pad_bottom ) { if ( LaunchXsmmBackwardInputConvolution < Device , T > ( ) ( context , context -> eigen_device < Device > ( ) , in_backprop -> tensor < T , 4 > ( ) , filter . tensor < T , 4 > ( ) , out_backprop . tensor < T , 4 > ( ) , dims . spatial_dims [ 0 ] . input_size , dims . spatial_dims [ 1 ] . input_size , static_cast < int > ( dims . spatial_dims [ 0 ] . stride ) , static_cast < int > ( dims . spatial_dims [ 1 ] . stride ) , static_cast < int > ( pad_top ) , static_cast < int > ( pad_left ) , data_format_ ) ) { return ; } } # else int64 pad_top , pad_bottom ; int64 pad_left , pad_right ; # endif if ( padding_ == Padding : : EXPLICIT ) { pad_top = explicit_paddings_ [ 2 ] ; pad_bottom = explicit_paddings_ [ 3 ] ; pad_left = explicit_paddings_ [ 4 ] ; pad_right = explicit_paddings_ [ 5 ] ; } OP_REQUIRES_OK ( context , GetWindowedOutputSizeVerbose ( dims . spatial_dims [ 0 ] . input_size , dims . spatial_dims [ 0 ] . filter_size , dims . spatial_dims [ 0 ] . stride , padding_ , & dims . spatial_dims [ 0 ] . output_size , & pad_top , & pad_bottom ) ) ; OP_REQUIRES_OK ( context , GetWindowedOutputSizeVerbose ( dims . spatial_dims [ 1 ] . input_size , dims . spatial_dims [ 1 ] . filter_size , dims . spatial_dims [ 1 ] . stride , padding_ , & dims . spatial_dims [ 1 ] . output_size , & pad_left , & pad_right ) ) ; const int filter_total_size = dims . spatial_dims [ 0 ] . filter_size * dims . spatial_dims [ 1 ] . filter_size * dims . in_depth ; const int output_image_size = dims . spatial_dims [ 0 ] . output_size * dims . spatial_dims [ 1 ] . output_size ; const size_t l2_cache_size = 256LL << 10 ; const size_t l3_cache_size = 30LL << 20 ; const size_t target_working_set_size = l3_cache_size / sizeof ( T ) ; const size_t size_A = output_image_size * dims . out_depth ; const size_t size_B = filter_total_size * dims . out_depth ; const size_t size_C = output_image_size * filter_total_size ; const size_t work_unit_size = size_A + size_B + size_C ; auto worker_threads = * ( context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ) ; const size_t thread_work_unit_size = work_unit_size / worker_threads . num_threads ; const size_t min_thread_work_unit_size = l2_cache_size / sizeof ( T ) ; const bool use_parallel_contraction = dims . batch_size == 1 || thread_work_unit_size >= min_thread_work_unit_size ; <S2SV_StartBug> const size_t shard_size = <S2SV_EndBug> use_parallel_contraction ? 1 : ( target_working_set_size + work_unit_size - 1 ) / work_unit_size ; Tensor col_buffer ; OP_REQUIRES_OK ( context , context -> allocate_temp ( DataTypeToEnum < T > : : value , TensorShape ( { static_cast < int64 > ( shard_size ) , static_cast < int64 > ( output_image_size ) , static_cast < int64 > ( filter_total_size ) } ) , & col_buffer ) ) ; const int input_offset = dims . spatial_dims [ 0 ] . input_size * dims . spatial_dims [ 1 ] . input_size * dims . in_depth ; const int output_offset = dims . spatial_dims [ 0 ] . output_size * dims . spatial_dims [ 1 ] . output_size * dims . out_depth ; const T * filter_data = filter . template flat < T > ( ) . data ( ) ; T * col_buffer_data = col_buffer . template flat < T > ( ) . data ( ) ; const T * out_backprop_data = out_backprop . template flat < T > ( ) . data ( ) ; auto in_backprop_flat = in_backprop -> template flat < T > ( ) ; T * input_backprop_data = in_backprop_flat . data ( ) ; in_backprop_flat . device ( context -> eigen_device < Device > ( ) ) = in_backprop_flat . constant ( T ( 0 ) ) ; if ( use_parallel_contraction ) { typedef Eigen : : TensorMap < Eigen : : Tensor < T , 2 , Eigen : : RowMajor > , Eigen : : Unaligned > TensorMap ; typedef Eigen : : TensorMap < Eigen : : Tensor < const T , 2 , Eigen : : RowMajor > , Eigen : : Unaligned > ConstTensorMap ; Eigen : : array < Eigen : : IndexPair < Eigen : : DenseIndex > , 1 > contract_dims ; contract_dims [ 0 ] . first = 1 ; contract_dims [ 0 ] . second = 1 ; for ( int image_id = 0 ; image_id < dims . batch_size ; ++ image_id ) { TensorMap C ( col_buffer_data , output_image_size , filter_total_size ) ; ConstTensorMap A ( out_backprop_data + output_offset * image_id , output_image_size , dims . out_depth ) ; ConstTensorMap B ( filter_data , filter_total_size , dims . out_depth ) ; C . device ( context -> eigen_cpu_device ( ) ) = A . contract ( B , contract_dims ) ; Col2im < T > ( col_buffer_data , dims . in_depth , dims . spatial_dims [ 0 ] . input_size , dims . spatial_dims [ 1 ] . input_size , dims . spatial_dims [ 0 ] . filter_size , dims . spatial_dims [ 1 ] . filter_size , pad_top , pad_left , pad_bottom , pad_right , dims . spatial_dims [ 0 ] . stride , dims . spatial_dims [ 1 ] . stride , input_backprop_data ) ; input_backprop_data += input_offset ; } } else { for ( int image_id = 0 ; image_id < dims . batch_size ; image_id += shard_size ) { const int shard_limit = std : : min ( static_cast < int > ( shard_size ) , static_cast < int > ( dims . batch_size ) - image_id ) ; auto shard = [ & context , & dims , & pad_top , & pad_left , & pad_bottom , & pad_right , & output_image_size , & filter_total_size , & input_backprop_data , & col_buffer_data , & out_backprop_data , & filter_data , & input_offset , & output_offset , & size_C ] ( int64 start , int64 limit ) { for ( int shard_id = start ; shard_id < limit ; ++ shard_id ) { T * im2col_buf = col_buffer_data + shard_id * size_C ; T * input_data = input_backprop_data + shard_id * input_offset ; const T * out_data = out_backprop_data + shard_id * output_offset ; Conv2DCustomBackpropInputMatMulFunctor < T > ( ) ( context , out_data , filter_data , filter_total_size , output_image_size , dims . out_depth , im2col_buf ) ; Col2im < T > ( im2col_buf , dims . in_depth , dims . spatial_dims [ 0 ] . input_size , dims . spatial_dims [ 1 ] . input_size , dims . spatial_dims [ 0 ] . filter_size , dims . spatial_dims [ 1 ] . filter_size , pad_top , pad_left , pad_bottom , pad_right , dims . spatial_dims [ 0 ] . stride , dims . spatial_dims [ 1 ] . stride , input_data ) ; } } ; Shard ( worker_threads . num_threads , worker_threads . workers , shard_limit , work_unit_size , shard ) ; input_backprop_data += input_offset * shard_limit ; out_backprop_data += output_offset * shard_limit ; } } }", "target": "<S2SV_ModStart> >= min_thread_work_unit_size ; OP_REQUIRES ( context , work_unit_size > 0 , errors : : InvalidArgument ( \"input,<S2SV_blank>filter_sizes<S2SV_blank>and<S2SV_blank>out_backprop<S2SV_blank>tensors<S2SV_blank>\" \"must<S2SV_blank>all<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>1<S2SV_blank>element\" ) ) ;"}
{"source": "CWE-476 escape_xml ( const char * text ) { static char * escaped ; static size_t escaped_size ; char * out ; size_t len ; <S2SV_StartBug> if ( ! strlen ( text ) ) return \"empty<S2SV_blank>string\" ; <S2SV_EndBug> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { if ( ( len + 8 ) > escaped_size ) { char * bigger_escaped ; escaped_size += 128 ; bigger_escaped = realloc ( escaped , escaped_size ) ; if ( ! bigger_escaped ) { free ( escaped ) ; escaped = NULL ; escaped_size = 0 ; return \">>><S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank><<<\" ; } out = bigger_escaped + len ; escaped = bigger_escaped ; } switch ( * text ) { case '&' : strcpy ( out , \"&amp;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '<' : strcpy ( out , \"&lt;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '>' : strcpy ( out , \"&gt;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; default : * out = * text ; break ; } } * out = '\\\\x0' ; return escaped ; }", "target": "<S2SV_ModStart> ) ) return \"\" <S2SV_ModEnd> ; for ("}
{"source": "CWE-787 void Compute ( OpKernelContext * context ) override { <S2SV_StartBug> const float in_min = context -> input ( 2 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float in_max = context -> input ( 3 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> ImageResizerState st ( align_corners_ , false ) ; st . ValidateAndCreateOutput ( context ) ; if ( ! context -> status ( ) . ok ( ) ) return ; if ( st . output -> NumElements ( ) == 0 ) return ; typename TTypes < T , 4 > : : ConstTensor image_data ( context -> input ( 0 ) . tensor < T , 4 > ( ) ) ; typename TTypes < T , 4 > : : Tensor output_data ( st . output -> tensor < T , 4 > ( ) ) ; ResizeBilinear < T > ( image_data , st . height_scale , st . width_scale , in_min , in_max , half_pixel_centers_ , & output_data ) ; Tensor * out_min = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , { } , & out_min ) ) ; out_min -> flat < float > ( ) ( 0 ) = in_min ; Tensor * out_max = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , { } , & out_max ) ) ; out_max -> flat < float > ( ) ( 0 ) = in_max ; }", "target": "<S2SV_ModStart> override { const auto & in_min_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsScalar ( in_min_tensor . shape ( ) ) , errors : : InvalidArgument ( \"min<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) ) ; const <S2SV_ModStart> float in_min = in_min_tensor . flat < float > ( ) ( 0 ) ; const auto & in_max_tensor = <S2SV_ModStart> -> input ( 3 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsScalar ( in_max_tensor . shape ( ) ) , errors : : InvalidArgument ( \"max<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) <S2SV_ModEnd> ) ; const <S2SV_ModStart> float in_max = in_max_tensor <S2SV_ModEnd> . flat <"}
{"source": "CWE-401 void gf_inspect_format_timecode ( const u8 * data , u32 size , u32 tmcd_flags , u32 tc_num , u32 tc_den , u32 tmcd_fpt , char szFmt [ 100 ] ) ; void DumpTrackInfo ( GF_ISOFile * file , GF_ISOTrackID trackID , Bool full_dump , Bool is_track_num , Bool dump_m4sys ) { char szCodec [ RFC6381_CODEC_NAME_SIZE_MAX ] ; Double scale , max_rate , rate ; Bool is_od_track = 0 ; u32 trackNum , i , j , ts , mtype , msub_type , timescale , sr , nb_ch , count , alt_group , nb_groups , nb_edits , cdur , csize , bps , pfmt , codecid ; u64 time_slice , dur , size ; s32 cts_shift ; GF_ESD * esd ; char szDur [ 50 ] ; char * lang ; if ( ! is_track_num ) { trackNum = gf_isom_get_track_by_id ( file , trackID ) ; } else { trackNum = trackID ; trackID = gf_isom_get_track_id ( file , trackNum ) ; } if ( ! trackNum ) { M4_LOG ( GF_LOG_ERROR , ( \"No<S2SV_blank>track<S2SV_blank>with<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>found\\\\n\" , trackID ) ) ; return ; } timescale = gf_isom_get_media_timescale ( file , trackNum ) ; fprintf ( stderr , \"#<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>Info<S2SV_blank>-<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>TimeScale<S2SV_blank>%d\\\\n\" , trackNum , trackID , timescale ) ; dur = gf_isom_get_media_original_duration ( file , trackNum ) ; size = gf_isom_get_media_duration ( file , trackNum ) ; fprintf ( stderr , \"Media<S2SV_blank>Duration<S2SV_blank>%s<S2SV_blank>\" , format_duration ( dur , timescale , szDur ) ) ; if ( dur != size ) fprintf ( stderr , \"<S2SV_blank>(recomputed<S2SV_blank>%s)\" , format_duration ( size , timescale , szDur ) ) ; fprintf ( stderr , \"\\\\n\" ) ; if ( gf_isom_check_data_reference ( file , trackNum , 1 ) != GF_OK ) { M4_LOG ( GF_LOG_WARNING , ( \"Track<S2SV_blank>uses<S2SV_blank>external<S2SV_blank>data<S2SV_blank>reference<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>GPAC!\\\\n\" ) ) ; } nb_edits = gf_isom_get_edits_count ( file , trackNum ) ; if ( nb_edits ) fprintf ( stderr , \"Track<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>edits:<S2SV_blank>track<S2SV_blank>duration<S2SV_blank>is<S2SV_blank>%s\\\\n\" , nb_edits , format_duration ( gf_isom_get_track_duration ( file , trackNum ) , gf_isom_get_timescale ( file ) , szDur ) ) ; cts_shift = gf_isom_get_composition_offset_shift ( file , trackNum ) ; if ( cts_shift ) fprintf ( stderr , \"Track<S2SV_blank>composition<S2SV_blank>offset<S2SV_blank>shift<S2SV_blank>(negative<S2SV_blank>CTS<S2SV_blank>offset):<S2SV_blank>%d\\\\n\" , cts_shift ) ; if ( gf_isom_is_track_in_root_od ( file , trackNum ) ) fprintf ( stderr , \"Track<S2SV_blank>is<S2SV_blank>present<S2SV_blank>in<S2SV_blank>Root<S2SV_blank>OD\\\\n\" ) ; if ( ! gf_isom_is_track_enabled ( file , trackNum ) ) fprintf ( stderr , \"Track<S2SV_blank>is<S2SV_blank>disabled\\\\n\" ) ; gf_isom_get_media_language ( file , trackNum , & lang ) ; fprintf ( stderr , \"Media<S2SV_blank>Info:<S2SV_blank>Language<S2SV_blank>\\\\\"%s<S2SV_blank>(%s)\\\\\"<S2SV_blank>-<S2SV_blank>\" , GetLanguage ( lang ) , lang ) ; gf_free ( lang ) ; mtype = gf_isom_get_media_type ( file , trackNum ) ; fprintf ( stderr , \"Type<S2SV_blank>\\\\\"%s:\" , gf_4cc_to_str ( mtype ) ) ; msub_type = gf_isom_get_mpeg4_subtype ( file , trackNum , 1 ) ; if ( ! msub_type ) msub_type = gf_isom_get_media_subtype ( file , trackNum , 1 ) ; fprintf ( stderr , \"%s\\\\\"<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>samples\\\\n\" , gf_4cc_to_str ( msub_type ) , gf_isom_get_sample_count ( file , trackNum ) ) ; pfmt = gf_pixel_fmt_from_qt_type ( msub_type ) ; codecid = gf_codec_id_from_isobmf ( msub_type ) ; count = gf_isom_get_track_kind_count ( file , trackNum ) ; for ( i = 0 ; i < count ; i ++ ) { char * kind_scheme , * kind_value ; gf_isom_get_track_kind ( file , trackNum , i , & kind_scheme , & kind_value ) ; fprintf ( stderr , \"Kind:<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%s\\\\n\" , kind_scheme ? kind_scheme : \"null\" , kind_value ? kind_value : \"null\" ) ; if ( kind_scheme ) gf_free ( kind_scheme ) ; if ( kind_value ) gf_free ( kind_value ) ; } if ( gf_isom_is_track_fragmented ( file , trackID ) ) { u32 defaultDuration , defaultSize , defaultDescriptionIndex , defaultRandomAccess ; u8 defaultPadding ; u16 defaultDegradationPriority ; u32 frag_samples ; u64 frag_duration ; gf_isom_get_fragmented_samples_info ( file , trackID , & frag_samples , & frag_duration ) ; fprintf ( stderr , \"Fragmented<S2SV_blank>track:<S2SV_blank>%d<S2SV_blank>samples<S2SV_blank>-<S2SV_blank>Media<S2SV_blank>Duration<S2SV_blank>%s\\\\n\" , frag_samples , format_duration ( frag_duration , timescale , szDur ) ) ; gf_isom_get_fragment_defaults ( file , trackNum , & defaultDuration , & defaultSize , & defaultDescriptionIndex , & defaultRandomAccess , & defaultPadding , & defaultDegradationPriority ) ; fprintf ( stderr , \"Fragment<S2SV_blank>sample<S2SV_blank>defaults:<S2SV_blank>duration<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>stsd<S2SV_blank>%d<S2SV_blank>sync<S2SV_blank>%d<S2SV_blank>padding<S2SV_blank>%d<S2SV_blank>degradation_priority<S2SV_blank>%d\\\\n\" , defaultDuration , defaultSize , defaultDescriptionIndex , defaultRandomAccess , ( u32 ) defaultPadding , ( u32 ) defaultDegradationPriority ) ; } if ( ! gf_isom_is_self_contained ( file , trackNum , 1 ) ) { const char * url , * urn ; gf_isom_get_data_reference ( file , trackNum , 1 , & url , & urn ) ; fprintf ( stderr , \"Media<S2SV_blank>Data<S2SV_blank>Location:<S2SV_blank>%s\\\\n\" , url ? url : urn ) ; } if ( full_dump ) { const char * handler_name ; gf_isom_get_handler_name ( file , trackNum , & handler_name ) ; fprintf ( stderr , \"Handler<S2SV_blank>name:<S2SV_blank>%s\\\\n\" , handler_name ) ; } print_udta ( file , trackNum , GF_FALSE ) ; if ( gf_isom_is_video_handler_type ( mtype ) ) { s32 tx , ty ; u32 w , h ; u16 bit_depth ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; gf_isom_get_visual_bit_depth ( file , trackNum , 1 , & bit_depth ) ; fprintf ( stderr , \"Visual<S2SV_blank>Sample<S2SV_blank>Entry<S2SV_blank>Info:<S2SV_blank>width=%d<S2SV_blank>height=%d<S2SV_blank>(depth=%d<S2SV_blank>bits)\\\\n\" , w , h , ( int ) bit_depth ) ; gf_isom_get_track_layout_info ( file , trackNum , & w , & h , & tx , & ty , NULL ) ; fprintf ( stderr , \"Visual<S2SV_blank>Track<S2SV_blank>layout:<S2SV_blank>x=%d<S2SV_blank>y=%d<S2SV_blank>width=%d<S2SV_blank>height=%d\\\\n\" , tx , ty , w , h ) ; } gf_isom_get_audio_info ( file , trackNum , 1 , & sr , & nb_ch , & bps ) ; gf_isom_set_nalu_extract_mode ( file , trackNum , GF_ISOM_NALU_EXTRACT_INSPECT ) ; msub_type = gf_isom_get_media_subtype ( file , trackNum , 1 ) ; if ( msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP ) gf_isom_get_original_format_type ( file , trackNum , 1 , & msub_type ) ; if ( ( msub_type == GF_ISOM_SUBTYPE_MPEG4 ) || ( msub_type == GF_ISOM_SUBTYPE_AVC_H264 ) || ( msub_type == GF_ISOM_SUBTYPE_AVC2_H264 ) || ( msub_type == GF_ISOM_SUBTYPE_AVC3_H264 ) || ( msub_type == GF_ISOM_SUBTYPE_AVC4_H264 ) || ( msub_type == GF_ISOM_SUBTYPE_SVC_H264 ) || ( msub_type == GF_ISOM_SUBTYPE_MVC_H264 ) || ( msub_type == GF_ISOM_SUBTYPE_LSR1 ) || ( msub_type == GF_ISOM_SUBTYPE_HVC1 ) || ( msub_type == GF_ISOM_SUBTYPE_HEV1 ) || ( msub_type == GF_ISOM_SUBTYPE_HVC2 ) || ( msub_type == GF_ISOM_SUBTYPE_HEV2 ) || ( msub_type == GF_ISOM_SUBTYPE_LHV1 ) || ( msub_type == GF_ISOM_SUBTYPE_LHE1 ) || ( msub_type == GF_ISOM_SUBTYPE_HVT1 ) ) { esd = gf_isom_get_esd ( file , trackNum , 1 ) ; if ( ! esd || ! esd -> decoderConfig ) { M4_LOG ( GF_LOG_WARNING , ( \"WARNING:<S2SV_blank>Broken<S2SV_blank>MPEG-4<S2SV_blank>Track\\\\n\" ) ) ; if ( esd ) gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; } else { const char * st = gf_stream_type_name ( esd -> decoderConfig -> streamType ) ; if ( dump_m4sys ) { if ( st ) { fprintf ( stderr , \"MPEG-4<S2SV_blank>Config%s%s<S2SV_blank>Stream<S2SV_blank>-<S2SV_blank>ObjectTypeIndication<S2SV_blank>0x%02x\\\\n\" , full_dump ? \"\\\\n\\\\t\" : \":<S2SV_blank>\" , st , esd -> decoderConfig -> objectTypeIndication ) ; } else { fprintf ( stderr , \"MPEG-4<S2SV_blank>Config%sStream<S2SV_blank>Type<S2SV_blank>0x%02x<S2SV_blank>-<S2SV_blank>ObjectTypeIndication<S2SV_blank>0x%02x\\\\n\" , full_dump ? \"\\\\n\\\\t\" : \":<S2SV_blank>\" , esd -> decoderConfig -> streamType , esd -> decoderConfig -> objectTypeIndication ) ; } } if ( esd -> decoderConfig -> streamType == GF_STREAM_OD ) is_od_track = 1 ; if ( esd -> decoderConfig -> streamType == GF_STREAM_VISUAL ) { u32 w , h ; u16 rvc_predef ; w = h = 0 ; if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_MPEG4_PART2 ) { # ifndef GPAC_DISABLE_AV_PARSERS if ( ! esd -> decoderConfig -> decoderSpecificInfo ) { # else gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; fprintf ( stderr , \"MPEG-4<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; # endif M4_LOG ( GF_LOG_WARNING , ( \"Non-compliant<S2SV_blank>MPEG-4<S2SV_blank>Visual<S2SV_blank>track:<S2SV_blank>video_object_layer<S2SV_blank>infos<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>sample<S2SV_blank>description\\\\n\" ) ) ; # ifndef GPAC_DISABLE_AV_PARSERS } else { GF_M4VDecSpecInfo dsi ; gf_m4v_get_config ( esd -> decoderConfig -> decoderSpecificInfo -> data , esd -> decoderConfig -> decoderSpecificInfo -> dataLength , & dsi ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; w = dsi . width ; h = dsi . height ; fprintf ( stderr , \"MPEG-4<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%s\\\\n\" , w , h , gf_m4v_get_profile_name ( dsi . VideoPL ) ) ; if ( dsi . par_den && dsi . par_num ) { u32 tw , th ; gf_isom_get_track_layout_info ( file , trackNum , & tw , & th , NULL , NULL , NULL ) ; fprintf ( stderr , \"Pixel<S2SV_blank>Aspect<S2SV_blank>Ratio<S2SV_blank>%d:%d<S2SV_blank>-<S2SV_blank>Indicated<S2SV_blank>track<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , dsi . par_num , dsi . par_den , tw , th ) ; } } # endif } else if ( gf_isom_get_avc_svc_type ( file , trackNum , 1 ) != GF_ISOM_AVCTYPE_NONE ) { GF_AVCConfig * avccfg , * svccfg , * mvccfg ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; fprintf ( stderr , \"AVC/H264<S2SV_blank>Video<S2SV_blank>-<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; avccfg = gf_isom_avc_config_get ( file , trackNum , 1 ) ; svccfg = gf_isom_svc_config_get ( file , trackNum , 1 ) ; mvccfg = gf_isom_mvc_config_get ( file , trackNum , 1 ) ; if ( ! avccfg && ! svccfg && ! mvccfg ) { M4_LOG ( GF_LOG_ERROR , ( \"\\\\tNon-compliant<S2SV_blank>AVC<S2SV_blank>track:<S2SV_blank>SPS/PPS<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>sample<S2SV_blank>description\\\\n\" ) ) ; } else if ( avccfg ) { fprintf ( stderr , \"\\\\tAVC<S2SV_blank>Info:<S2SV_blank>%d<S2SV_blank>SPS<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>PPS\" , gf_list_count ( avccfg -> sequenceParameterSets ) , gf_list_count ( avccfg -> pictureParameterSets ) ) ; fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Profile<S2SV_blank>%s<S2SV_blank>@<S2SV_blank>Level<S2SV_blank>%g\\\\n\" , gf_avc_get_profile_name ( avccfg -> AVCProfileIndication ) , ( ( Double ) avccfg -> AVCLevelIndication ) / 10.0 ) ; fprintf ( stderr , \"\\\\tNAL<S2SV_blank>Unit<S2SV_blank>length<S2SV_blank>bits:<S2SV_blank>%d\\\\n\" , 8 * avccfg -> nal_unit_size ) ; # ifndef GPAC_DISABLE_AV_PARSERS for ( i = 0 ; i < gf_list_count ( avccfg -> sequenceParameterSets ) ; i ++ ) { s32 par_n , par_d ; GF_NALUFFParam * slc = gf_list_get ( avccfg -> sequenceParameterSets , i ) ; gf_avc_get_sps_info ( slc -> data , slc -> size , NULL , NULL , NULL , & par_n , & par_d ) ; if ( ( par_n > 0 ) && ( par_d > 0 ) ) { u32 tw , th ; gf_isom_get_track_layout_info ( file , trackNum , & tw , & th , NULL , NULL , NULL ) ; fprintf ( stderr , \"\\\\tPixel<S2SV_blank>Aspect<S2SV_blank>Ratio<S2SV_blank>%d:%d<S2SV_blank>-<S2SV_blank>Indicated<S2SV_blank>track<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , par_n , par_d , tw , th ) ; } if ( ! full_dump ) break ; } # endif if ( avccfg -> chroma_bit_depth ) { fprintf ( stderr , \"\\\\tChroma<S2SV_blank>format<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Luma<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>chroma<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d\\\\n\" , gf_avc_hevc_get_chroma_format_name ( avccfg -> chroma_format ) , avccfg -> luma_bit_depth , avccfg -> chroma_bit_depth ) ; } print_config_hash ( avccfg -> sequenceParameterSets , \"SPS\" ) ; print_config_hash ( avccfg -> pictureParameterSets , \"PPS\" ) ; gf_odf_avc_cfg_del ( avccfg ) ; } if ( svccfg ) { fprintf ( stderr , \"\\\\n\\\\tSVC<S2SV_blank>Info:<S2SV_blank>%d<S2SV_blank>SPS<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>PPS<S2SV_blank>-<S2SV_blank>Profile<S2SV_blank>%s<S2SV_blank>@<S2SV_blank>Level<S2SV_blank>%g\\\\n\" , gf_list_count ( svccfg -> sequenceParameterSets ) , gf_list_count ( svccfg -> pictureParameterSets ) , gf_avc_get_profile_name ( svccfg -> AVCProfileIndication ) , ( ( Double ) svccfg -> AVCLevelIndication ) / 10.0 ) ; fprintf ( stderr , \"\\\\tSVC<S2SV_blank>NAL<S2SV_blank>Unit<S2SV_blank>length<S2SV_blank>bits:<S2SV_blank>%d\\\\n\" , 8 * svccfg -> nal_unit_size ) ; # ifndef GPAC_DISABLE_AV_PARSERS for ( i = 0 ; i < gf_list_count ( svccfg -> sequenceParameterSets ) ; i ++ ) { GF_NALUFFParam * slc = gf_list_get ( svccfg -> sequenceParameterSets , i ) ; if ( slc ) { s32 par_n , par_d ; u32 s_w , s_h , sps_id ; gf_avc_get_sps_info ( slc -> data , slc -> size , & sps_id , & s_w , & s_h , & par_n , & par_d ) ; fprintf ( stderr , \"\\\\t\\\\tSPS<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , sps_id , s_w , s_h ) ; if ( ( par_n > 0 ) && ( par_d > 0 ) ) { u32 tw , th ; gf_isom_get_track_layout_info ( file , trackNum , & tw , & th , NULL , NULL , NULL ) ; fprintf ( stderr , \"\\\\tPixel<S2SV_blank>Aspect<S2SV_blank>Ratio<S2SV_blank>%d:%d<S2SV_blank>-<S2SV_blank>Indicated<S2SV_blank>track<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , par_n , par_d , tw , th ) ; } } } # endif print_config_hash ( svccfg -> sequenceParameterSets , \"SPS\" ) ; print_config_hash ( svccfg -> pictureParameterSets , \"PPS\" ) ; print_config_hash ( svccfg -> sequenceParameterSetExtensions , \"SPSEx\" ) ; gf_odf_avc_cfg_del ( svccfg ) ; } if ( mvccfg ) { fprintf ( stderr , \"\\\\n\\\\tMVC<S2SV_blank>Info:<S2SV_blank>%d<S2SV_blank>SPS<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>PPS<S2SV_blank>-<S2SV_blank>Profile<S2SV_blank>%s<S2SV_blank>@<S2SV_blank>Level<S2SV_blank>%g\\\\n\" , gf_list_count ( mvccfg -> sequenceParameterSets ) , gf_list_count ( mvccfg -> pictureParameterSets ) , gf_avc_get_profile_name ( mvccfg -> AVCProfileIndication ) , ( ( Double ) mvccfg -> AVCLevelIndication ) / 10.0 ) ; fprintf ( stderr , \"\\\\tMVC<S2SV_blank>NAL<S2SV_blank>Unit<S2SV_blank>length<S2SV_blank>bits:<S2SV_blank>%d\\\\n\" , 8 * mvccfg -> nal_unit_size ) ; # ifndef GPAC_DISABLE_AV_PARSERS for ( i = 0 ; i < gf_list_count ( mvccfg -> sequenceParameterSets ) ; i ++ ) { GF_NALUFFParam * slc = gf_list_get ( mvccfg -> sequenceParameterSets , i ) ; if ( slc ) { u32 s_w , s_h , sps_id ; s32 par_n , par_d ; gf_avc_get_sps_info ( slc -> data , slc -> size , & sps_id , & s_w , & s_h , & par_n , & par_d ) ; fprintf ( stderr , \"\\\\t\\\\tSPS<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , sps_id , s_w , s_h ) ; if ( ( par_n > 0 ) && ( par_d > 0 ) ) { u32 tw , th ; gf_isom_get_track_layout_info ( file , trackNum , & tw , & th , NULL , NULL , NULL ) ; fprintf ( stderr , \"\\\\tPixel<S2SV_blank>Aspect<S2SV_blank>Ratio<S2SV_blank>%d:%d<S2SV_blank>-<S2SV_blank>Indicated<S2SV_blank>track<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , par_n , par_d , tw , th ) ; } } } # endif print_config_hash ( mvccfg -> sequenceParameterSets , \"SPS\" ) ; print_config_hash ( mvccfg -> pictureParameterSets , \"PPS\" ) ; gf_odf_avc_cfg_del ( mvccfg ) ; } } else if ( ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_HEVC ) || ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_LHVC ) ) { GF_HEVCConfig * hevccfg , * lhvccfg ; GF_OperatingPointsInformation * oinf ; # if ! defined ( GPAC_DISABLE_AV_PARSERS ) && ! defined ( GPAC_DISABLE_HEVC ) HEVCState hevc_state ; memset ( & hevc_state , 0 , sizeof ( HEVCState ) ) ; hevc_state . sps_active_idx = - 1 ; # endif gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; fprintf ( stderr , \"HEVC<S2SV_blank>Video<S2SV_blank>-<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; hevccfg = gf_isom_hevc_config_get ( file , trackNum , 1 ) ; lhvccfg = gf_isom_lhvc_config_get ( file , trackNum , 1 ) ; if ( msub_type == GF_ISOM_SUBTYPE_HVT1 ) { const u8 * data ; u32 tsize ; u32 is_default , tx , ty , tw , th , id , independent ; Bool full_frame ; if ( gf_isom_get_tile_info ( file , trackNum , 1 , & is_default , & id , & independent , & full_frame , & tx , & ty , & tw , & th ) ) { fprintf ( stderr , \"\\\\tHEVC<S2SV_blank>Tile<S2SV_blank>-<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>independent<S2SV_blank>%d<S2SV_blank>(x,y,w,h)=%d,%d,%d,%d<S2SV_blank>\\\\n\" , id , independent , tx , ty , tw , th ) ; } else if ( gf_isom_get_sample_group_info ( file , trackNum , 1 , GF_ISOM_SAMPLE_GROUP_TRIF , & is_default , & data , & tsize ) ) { fprintf ( stderr , \"\\\\tHEVC<S2SV_blank>Tile<S2SV_blank>track<S2SV_blank>containing<S2SV_blank>a<S2SV_blank>tile<S2SV_blank>set\\\\n\" ) ; } else { fprintf ( stderr , \"\\\\tHEVC<S2SV_blank>Tile<S2SV_blank>track<S2SV_blank>without<S2SV_blank>tiling<S2SV_blank>info\\\\n\" ) ; } } else if ( ! hevccfg && ! lhvccfg ) { M4_LOG ( GF_LOG_ERROR , ( \"\\\\tNon-compliant<S2SV_blank>HEVC<S2SV_blank>track:<S2SV_blank>No<S2SV_blank>hvcC<S2SV_blank>or<S2SV_blank>shcC<S2SV_blank>found<S2SV_blank>in<S2SV_blank>sample<S2SV_blank>description\\\\n\" ) ) ; } if ( gf_isom_get_reference_count ( file , trackNum , GF_ISOM_REF_SABT ) ) { fprintf ( stderr , \"\\\\tHEVC<S2SV_blank>Tile<S2SV_blank>base<S2SV_blank>track\\\\n\" ) ; } if ( hevccfg ) { dump_hevc_track_info ( file , trackNum , hevccfg # if ! defined ( GPAC_DISABLE_AV_PARSERS ) && ! defined ( GPAC_DISABLE_HEVC ) , & hevc_state # endif ) ; gf_odf_hevc_cfg_del ( hevccfg ) ; fprintf ( stderr , \"\\\\n\" ) ; } if ( lhvccfg ) { dump_hevc_track_info ( file , trackNum , lhvccfg # if ! defined ( GPAC_DISABLE_AV_PARSERS ) && ! defined ( GPAC_DISABLE_HEVC ) , & hevc_state # endif ) ; gf_odf_hevc_cfg_del ( lhvccfg ) ; } if ( gf_isom_get_oinf_info ( file , trackNum , & oinf ) ) { fprintf ( stderr , \"\\\\n\\\\tOperating<S2SV_blank>Points<S2SV_blank>Information<S2SV_blank>-\" ) ; fprintf ( stderr , \"<S2SV_blank>scalability_mask<S2SV_blank>%d<S2SV_blank>(\" , oinf -> scalability_mask ) ; switch ( oinf -> scalability_mask ) { case 2 : fprintf ( stderr , \"Multiview\" ) ; break ; case 4 : fprintf ( stderr , \"Spatial<S2SV_blank>scalability\" ) ; break ; case 8 : fprintf ( stderr , \"Auxilary\" ) ; break ; default : fprintf ( stderr , \"unknown\" ) ; } fprintf ( stderr , \")<S2SV_blank>num_profile_tier_level<S2SV_blank>%d<S2SV_blank>\" , gf_list_count ( oinf -> profile_tier_levels ) ) ; fprintf ( stderr , \"<S2SV_blank>num_operating_points<S2SV_blank>%d<S2SV_blank>dependency<S2SV_blank>layers<S2SV_blank>%d<S2SV_blank>\\\\n\" , gf_list_count ( oinf -> operating_points ) , gf_list_count ( oinf -> dependency_layers ) ) ; } } else if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_THEORA ) { char * szName ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; if ( ! strnicmp ( ( char * ) & esd -> decoderConfig -> decoderSpecificInfo -> data [ 3 ] , \"theora\" , 6 ) ) szName = \"Theora\" ; else szName = \"Unknown\" ; fprintf ( stderr , \"Ogg/%s<S2SV_blank>video<S2SV_blank>/<S2SV_blank>GPAC<S2SV_blank>Mux<S2SV_blank><S2SV_blank>-<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , szName , w , h ) ; } else { u32 codec_id = gf_codecid_from_oti ( GF_STREAM_VISUAL , esd -> decoderConfig -> objectTypeIndication ) ; if ( codec_id ) { gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; fprintf ( stderr , \"%s<S2SV_blank>-<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , gf_codecid_name ( codec_id ) , w , h ) ; } } if ( ! w || ! h ) { gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; fprintf ( stderr , \"Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; } if ( gf_isom_get_rvc_config ( file , trackNum , 1 , & rvc_predef , NULL , NULL , NULL ) == GF_OK ) { fprintf ( stderr , \"Has<S2SV_blank>RVC<S2SV_blank>signaled<S2SV_blank>-<S2SV_blank>Predefined<S2SV_blank>configuration<S2SV_blank>%d\\\\n\" , rvc_predef ) ; } } else if ( esd -> decoderConfig -> streamType == GF_STREAM_AUDIO ) { # ifndef GPAC_DISABLE_AV_PARSERS GF_M4ADecSpecInfo a_cfg ; GF_Err e ; u32 oti ; # endif u32 codec_id ; Bool is_mp2 = GF_FALSE ; switch ( esd -> decoderConfig -> objectTypeIndication ) { case GF_CODECID_AAC_MPEG2_MP : case GF_CODECID_AAC_MPEG2_LCP : case GF_CODECID_AAC_MPEG2_SSRP : is_mp2 = GF_TRUE ; case GF_CODECID_AAC_MPEG4 : # ifndef GPAC_DISABLE_AV_PARSERS if ( ! esd -> decoderConfig -> decoderSpecificInfo ) e = GF_NON_COMPLIANT_BITSTREAM ; else e = gf_m4a_get_config ( esd -> decoderConfig -> decoderSpecificInfo -> data , esd -> decoderConfig -> decoderSpecificInfo -> dataLength , & a_cfg ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; if ( e ) { M4_LOG ( GF_LOG_ERROR , ( \"Corrupted<S2SV_blank>AAC<S2SV_blank>Config\\\\n\" ) ) ; } else { char * signaling = \"implicit\" ; char * heaac = \"\" ; if ( ! is_mp2 && a_cfg . has_sbr ) { if ( a_cfg . has_ps ) heaac = \"(HE-AAC<S2SV_blank>v2)<S2SV_blank>\" ; else heaac = \"(HE-AAC<S2SV_blank>v1)<S2SV_blank>\" ; } if ( a_cfg . base_object_type == 2 ) { if ( a_cfg . has_ps || a_cfg . has_sbr ) signaling = \"backward<S2SV_blank>compatible\" ; } else { signaling = \"hierarchical\" ; } fprintf ( stderr , \"%s<S2SV_blank>(AOT=%d<S2SV_blank>%s)<S2SV_blank>%s-<S2SV_blank>%d<S2SV_blank>Channel(s)<S2SV_blank>-<S2SV_blank>SampleRate<S2SV_blank>%d\" , gf_m4a_object_type_name ( a_cfg . base_object_type ) , a_cfg . base_object_type , signaling , heaac , a_cfg . nb_chan , a_cfg . base_sr ) ; if ( is_mp2 ) fprintf ( stderr , \"<S2SV_blank>(MPEG-2<S2SV_blank>Signaling)\" ) ; if ( a_cfg . has_sbr ) fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>SBR:<S2SV_blank>SampleRate<S2SV_blank>%d<S2SV_blank>Type<S2SV_blank>%s\" , a_cfg . sbr_sr , gf_m4a_object_type_name ( a_cfg . sbr_object_type ) ) ; if ( a_cfg . has_ps ) fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>PS\" ) ; fprintf ( stderr , \"\\\\n\" ) ; } # else fprintf ( stderr , \"MPEG-2/4<S2SV_blank>Audio<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>Channels<S2SV_blank>-<S2SV_blank>SampleRate<S2SV_blank>%d\\\\n\" , nb_ch , sr ) ; # endif break ; case GF_CODECID_MPEG2_PART3 : case GF_CODECID_MPEG_AUDIO : if ( msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP ) { fprintf ( stderr , \"MPEG-1/2<S2SV_blank>Audio<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>Channels<S2SV_blank>-<S2SV_blank>SampleRate<S2SV_blank>%d\\\\n\" , nb_ch , sr ) ; } else { # ifndef GPAC_DISABLE_AV_PARSERS GF_ISOSample * samp = gf_isom_get_sample ( file , trackNum , 1 , & oti ) ; if ( samp ) { u32 mhdr = GF_4CC ( ( u8 ) samp -> data [ 0 ] , ( u8 ) samp -> data [ 1 ] , ( u8 ) samp -> data [ 2 ] , ( u8 ) samp -> data [ 3 ] ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; fprintf ( stderr , \"%s<S2SV_blank>Audio<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>Channel(s)<S2SV_blank>-<S2SV_blank>SampleRate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Layer<S2SV_blank>%d\\\\n\" , gf_mp3_version_name ( mhdr ) , gf_mp3_num_channels ( mhdr ) , gf_mp3_sampling_rate ( mhdr ) , gf_mp3_layer ( mhdr ) ) ; gf_isom_sample_del ( & samp ) ; } else { M4_LOG ( GF_LOG_ERROR , ( \"Error<S2SV_blank>fetching<S2SV_blank>sample:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( gf_isom_last_error ( file ) ) ) ) ; } # else fprintf ( stderr , \"MPEG-1/2<S2SV_blank>Audio<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>Channels<S2SV_blank>-<S2SV_blank>SampleRate<S2SV_blank>%d\\\\n\" , nb_ch , sr ) ; # endif } break ; case GF_CODECID_EVRC : fprintf ( stderr , \"EVRC<S2SV_blank>Audio<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>8000<S2SV_blank>-<S2SV_blank>1<S2SV_blank>channel\\\\n\" ) ; break ; case GF_CODECID_SMV : fprintf ( stderr , \"SMV<S2SV_blank>Audio<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>8000<S2SV_blank>-<S2SV_blank>1<S2SV_blank>channel\\\\n\" ) ; break ; case GF_CODECID_QCELP : fprintf ( stderr , \"QCELP<S2SV_blank>Audio<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>8000<S2SV_blank>-<S2SV_blank>1<S2SV_blank>channel\\\\n\" ) ; break ; case GF_CODECID_EVRC_PV : if ( esd -> decoderConfig -> decoderSpecificInfo && ( esd -> decoderConfig -> decoderSpecificInfo -> dataLength == 8 ) && ! strnicmp ( ( char * ) esd -> decoderConfig -> decoderSpecificInfo -> data , \"pvmm\" , 4 ) ) { if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; fprintf ( stderr , \"EVRC<S2SV_blank>Audio<S2SV_blank>(PacketVideo<S2SV_blank>Mux)<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>8000<S2SV_blank>-<S2SV_blank>1<S2SV_blank>channel\\\\n\" ) ; } break ; default : codec_id = gf_codecid_from_oti ( GF_STREAM_AUDIO , esd -> decoderConfig -> objectTypeIndication ) ; if ( codec_id ) { fprintf ( stderr , \"%s<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)\\\\n\" , gf_codecid_name ( codec_id ) , sr , nb_ch ) ; } break ; } } else if ( esd -> decoderConfig -> streamType == GF_STREAM_SCENE ) { if ( esd -> decoderConfig -> objectTypeIndication <= 4 ) { GF_BIFSConfig * b_cfg = gf_odf_get_bifs_config ( esd -> decoderConfig -> decoderSpecificInfo , esd -> decoderConfig -> objectTypeIndication ) ; fprintf ( stderr , \"BIFS<S2SV_blank>Scene<S2SV_blank>description<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>stream\\\\n\" , b_cfg -> elementaryMasks ? \"Animation\" : \"Command\" ) ; if ( full_dump && ! b_cfg -> elementaryMasks ) { fprintf ( stderr , \"\\\\tWidth<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d<S2SV_blank>Pixel<S2SV_blank>Metrics<S2SV_blank>%s\\\\n\" , b_cfg -> pixelWidth , b_cfg -> pixelHeight , b_cfg -> pixelMetrics ? \"yes\" : \"no\" ) ; } gf_odf_desc_del ( ( GF_Descriptor * ) b_cfg ) ; } else if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_AFX ) { u8 tag = esd -> decoderConfig -> decoderSpecificInfo ? esd -> decoderConfig -> decoderSpecificInfo -> data [ 0 ] : 0xFF ; const char * afxtype = gf_stream_type_afx_name ( tag ) ; fprintf ( stderr , \"AFX<S2SV_blank>Stream<S2SV_blank>-<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>(%d)\\\\n\" , afxtype , tag ) ; } else if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_FONT ) { fprintf ( stderr , \"Font<S2SV_blank>Data<S2SV_blank>stream\\\\n\" ) ; } else if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_LASER ) { GF_LASERConfig l_cfg ; gf_odf_get_laser_config ( esd -> decoderConfig -> decoderSpecificInfo , & l_cfg ) ; fprintf ( stderr , \"LASER<S2SV_blank>Stream<S2SV_blank>-<S2SV_blank>%s\\\\n\" , l_cfg . newSceneIndicator ? \"Full<S2SV_blank>Scene\" : \"Scene<S2SV_blank>Segment\" ) ; } else if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_TEXT_MPEG4 ) { fprintf ( stderr , \"MPEG-4<S2SV_blank>Streaming<S2SV_blank>Text<S2SV_blank>stream\\\\n\" ) ; } else if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_SYNTHESIZED_TEXTURE ) { fprintf ( stderr , \"Synthetized<S2SV_blank>Texture<S2SV_blank>stream<S2SV_blank>stream\\\\n\" ) ; } else { M4_LOG ( GF_LOG_WARNING , ( \"Unknown<S2SV_blank>Systems<S2SV_blank>stream<S2SV_blank>OTI<S2SV_blank>%d\\\\n\" , esd -> decoderConfig -> objectTypeIndication ) ) ; } } if ( ! full_dump ) { if ( dump_m4sys ) { if ( ! esd -> OCRESID || ( esd -> OCRESID == esd -> ESID ) ) fprintf ( stderr , \"Self-synchronized\\\\n\" ) ; else fprintf ( stderr , \"Synchronized<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>%d\\\\n\" , esd -> OCRESID ) ; } } else { fprintf ( stderr , \"\\\\tDecoding<S2SV_blank>Buffer<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Bitrate:<S2SV_blank>avg<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>max<S2SV_blank>%d<S2SV_blank>kbps\\\\n\" , esd -> decoderConfig -> bufferSizeDB , esd -> decoderConfig -> avgBitrate / 1000 , esd -> decoderConfig -> maxBitrate / 1000 ) ; if ( esd -> dependsOnESID ) fprintf ( stderr , \"\\\\tDepends<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>decoding\\\\n\" , esd -> dependsOnESID ) ; else fprintf ( stderr , \"\\\\tNo<S2SV_blank>stream<S2SV_blank>dependencies<S2SV_blank>for<S2SV_blank>decoding\\\\n\" ) ; fprintf ( stderr , \"\\\\tStreamPriority<S2SV_blank>%d\\\\n\" , esd -> streamPriority ) ; if ( esd -> URLString ) fprintf ( stderr , \"\\\\tRemote<S2SV_blank>Data<S2SV_blank>Source<S2SV_blank>%s\\\\n\" , esd -> URLString ) ; } gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; } } else if ( msub_type == GF_ISOM_SUBTYPE_AV01 ) { GF_AV1Config * av1c ; u32 w , h ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; fprintf ( stderr , \"\\\\tAOM<S2SV_blank>AV1<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Resolution<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; av1c = gf_isom_av1_config_get ( file , trackNum , 1 ) ; <S2SV_StartBug> fprintf ( stderr , \"\\\\tversion=%u,<S2SV_blank>profile=%u,<S2SV_blank>level_idx0=%u,<S2SV_blank>tier=%u\\\\n\" , ( u32 ) av1c -> version , ( u32 ) av1c -> seq_profile , ( u32 ) av1c -> seq_level_idx_0 , ( u32 ) av1c -> seq_tier_0 ) ; <S2SV_EndBug> fprintf ( stderr , \"\\\\thigh_bitdepth=%u,<S2SV_blank>twelve_bit=%u,<S2SV_blank>monochrome=%u\\\\n\" , ( u32 ) av1c -> high_bitdepth , ( u32 ) av1c -> twelve_bit , ( u32 ) av1c -> monochrome ) ; fprintf ( stderr , \"\\\\tchroma:<S2SV_blank>subsampling_x=%u,<S2SV_blank>subsampling_y=%u,<S2SV_blank>sample_position=%u\\\\n\" , ( u32 ) av1c -> chroma_subsampling_x , ( u32 ) av1c -> chroma_subsampling_y , ( u32 ) av1c -> chroma_sample_position ) ; if ( av1c -> initial_presentation_delay_present ) fprintf ( stderr , \"\\\\tInitial<S2SV_blank>presentation<S2SV_blank>delay<S2SV_blank>%u\\\\n\" , ( u32 ) av1c -> initial_presentation_delay_minus_one + 1 ) ; count = gf_list_count ( av1c -> obu_array ) ; for ( i = 0 ; i < count ; i ++ ) { u8 hash [ 20 ] ; GF_AV1_OBUArrayEntry * obu = gf_list_get ( av1c -> obu_array , i ) ; gf_sha1_csum ( ( u8 * ) obu -> obu , ( u32 ) obu -> obu_length , hash ) ; fprintf ( stderr , \"\\\\tOBU#%d<S2SV_blank>%s<S2SV_blank>hash:<S2SV_blank>\" , i + 1 , gf_av1_get_obu_name ( obu -> obu_type ) ) ; for ( j = 0 ; j < 20 ; j ++ ) fprintf ( stderr , \"%02X\" , hash [ j ] ) ; fprintf ( stderr , \"\\\\n\" ) ; } <S2SV_StartBug> gf_odf_av1_cfg_del ( av1c ) ; <S2SV_EndBug> } else if ( msub_type == GF_ISOM_SUBTYPE_3GP_H263 ) { u32 w , h ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; fprintf ( stderr , \"\\\\t3GPP<S2SV_blank>H263<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Resolution<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_MJP2 ) { u32 w , h ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; fprintf ( stderr , \"\\\\tMotionJPEG2000<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Resolution<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; } else if ( ( msub_type == GF_ISOM_SUBTYPE_3GP_AMR ) || ( msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB ) ) { fprintf ( stderr , \"\\\\t3GPP<S2SV_blank>AMR%s<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)<S2SV_blank>%d<S2SV_blank>bps\\\\n\" , ( msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB ) ? \"<S2SV_blank>Wide<S2SV_blank>Band\" : \"\" , sr , nb_ch , ( u32 ) bps ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_3GP_EVRC ) { fprintf ( stderr , \"\\\\t3GPP<S2SV_blank>EVRC<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)<S2SV_blank>%d<S2SV_blank>bps\\\\n\" , sr , nb_ch , ( u32 ) bps ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_3GP_QCELP ) { fprintf ( stderr , \"\\\\t3GPP<S2SV_blank>QCELP<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)<S2SV_blank>%d<S2SV_blank>bps\\\\n\" , sr , nb_ch , ( u32 ) bps ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_MP3 ) { fprintf ( stderr , \"\\\\tMPEG<S2SV_blank>1/2<S2SV_blank>Audio<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)<S2SV_blank>%d<S2SV_blank>bps\\\\n\" , sr , nb_ch , ( u32 ) bps ) ; } else if ( ( msub_type == GF_ISOM_SUBTYPE_AC3 ) || ( msub_type == GF_ISOM_SUBTYPE_EC3 ) ) { u32 br = 0 ; const char * lfe = \"\" ; Bool is_ec3 = ( msub_type == GF_ISOM_SUBTYPE_EC3 ) ? GF_TRUE : GF_FALSE ; # ifndef GPAC_DISABLE_AV_PARSERS GF_AC3Config * ac3 = gf_isom_ac3_config_get ( file , trackNum , 1 ) ; if ( ac3 ) { nb_ch = gf_ac3_get_channels ( ac3 -> streams [ 0 ] . acmod ) ; for ( i = 0 ; i < ac3 -> streams [ 0 ] . nb_dep_sub ; ++ i ) { assert ( ac3 -> streams [ 0 ] . nb_dep_sub == 1 ) ; nb_ch += gf_ac3_get_channels ( ac3 -> streams [ 0 ] . chan_loc ) ; } if ( ac3 -> streams [ 0 ] . lfon ) lfe = \".1\" ; br = ac3 -> is_ec3 ? ac3 -> brcode : gf_ac3_get_bitrate ( ac3 -> brcode ) ; is_ec3 = ac3 -> is_ec3 ; gf_free ( ac3 ) ; } # endif fprintf ( stderr , \"\\\\t%s<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d%s<S2SV_blank>channel(s)<S2SV_blank>-<S2SV_blank>bitrate<S2SV_blank>%d\\\\n\" , is_ec3 ? \"EC-3\" : \"AC-3\" , sr , nb_ch , lfe , br ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_3GP_SMV ) { fprintf ( stderr , \"\\\\t3GPP<S2SV_blank>SMV<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>samples\\\\n\" , sr , nb_ch , ( u32 ) bps ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_3GP_DIMS ) { u32 w , h ; GF_DIMSDescription dims ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; gf_isom_get_dims_description ( file , trackNum , 1 , & dims ) ; fprintf ( stderr , \"\\\\t3GPP<S2SV_blank>DIMS<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Profile<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Level<S2SV_blank>%d\\\\n\" , w , h , dims . profile , dims . level ) ; fprintf ( stderr , \"\\\\tpathComponents:<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>useFullRequestHost:<S2SV_blank>%s\\\\n\" , dims . pathComponents , dims . fullRequestHost ? \"yes\" : \"no\" ) ; fprintf ( stderr , \"\\\\tstream<S2SV_blank>type:<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>redundant:<S2SV_blank>%s\\\\n\" , dims . streamType ? \"primary\" : \"secondary\" , ( dims . containsRedundant == 1 ) ? \"main\" : ( ( dims . containsRedundant == 2 ) ? \"redundant\" : \"main+redundant\" ) ) ; if ( dims . textEncoding [ 0 ] ) fprintf ( stderr , \"\\\\ttext<S2SV_blank>encoding<S2SV_blank>%s\\\\n\" , dims . textEncoding ) ; if ( dims . contentEncoding [ 0 ] ) fprintf ( stderr , \"\\\\tcontent<S2SV_blank>encoding<S2SV_blank>%s\\\\n\" , dims . contentEncoding ) ; if ( dims . content_script_types ) fprintf ( stderr , \"\\\\tscript<S2SV_blank>languages<S2SV_blank>%s\\\\n\" , dims . content_script_types ) ; } else if ( mtype == GF_ISOM_MEDIA_HINT ) { u32 refTrack ; s32 refCount = gf_isom_get_reference_count ( file , trackNum , GF_ISOM_REF_HINT ) ; if ( refCount > 0 ) { fprintf ( stderr , \"Streaming<S2SV_blank>Hint<S2SV_blank>Track<S2SV_blank>for<S2SV_blank>track%s<S2SV_blank>\" , ( refCount > 1 ) ? \"s\" : \"\" ) ; for ( i = 0 ; i < ( u32 ) refCount ; i ++ ) { gf_isom_get_reference ( file , trackNum , GF_ISOM_REF_HINT , i + 1 , & refTrack ) ; if ( i ) fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>\" ) ; fprintf ( stderr , \"ID<S2SV_blank>%d\" , gf_isom_get_track_id ( file , refTrack ) ) ; } fprintf ( stderr , \"\\\\n\" ) ; } else { fprintf ( stderr , \"Streaming<S2SV_blank>Hint<S2SV_blank>Track<S2SV_blank>(no<S2SV_blank>refs)\\\\n\" ) ; } # ifndef GPAC_DISABLE_ISOM_HINTING refCount = gf_isom_get_payt_count ( file , trackNum ) ; if ( refCount > 0 ) { for ( i = 0 ; i < ( u32 ) refCount ; i ++ ) { const char * name = gf_isom_get_payt_info ( file , trackNum , i + 1 , & refTrack ) ; fprintf ( stderr , \"\\\\tPayload<S2SV_blank>ID<S2SV_blank>%d:<S2SV_blank>type<S2SV_blank>%s\\\\n\" , refTrack , name ) ; } } # endif } else if ( mtype == GF_ISOM_MEDIA_FLASH ) { fprintf ( stderr , \"Macromedia<S2SV_blank>Flash<S2SV_blank>Movie\\\\n\" ) ; } else if ( ( mtype == GF_ISOM_MEDIA_TEXT ) || ( mtype == GF_ISOM_MEDIA_SUBT ) || ( mtype == GF_ISOM_MEDIA_MPEG_SUBT ) ) { u32 w , h ; s16 l ; s32 tx , ty ; const char * content_encoding = NULL ; const char * mime = NULL ; const char * config = NULL ; const char * _namespace = NULL ; const char * schema_loc = NULL ; const char * auxiliary_mimes = NULL ; gf_isom_get_track_layout_info ( file , trackNum , & w , & h , & tx , & ty , & l ) ; if ( msub_type == GF_ISOM_SUBTYPE_SBTT ) { gf_isom_stxt_get_description ( file , trackNum , 1 , & mime , & content_encoding , & config ) ; fprintf ( stderr , \"Textual<S2SV_blank>Subtitle<S2SV_blank>Stream<S2SV_blank>\" ) ; fprintf ( stderr , \"-<S2SV_blank>mime<S2SV_blank>%s\" , mime ) ; if ( content_encoding != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>encoding<S2SV_blank>%s\" , content_encoding ) ; } if ( config != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>config\" , ( u32 ) strlen ( config ) ) ; } } else if ( msub_type == GF_ISOM_SUBTYPE_STXT ) { gf_isom_stxt_get_description ( file , trackNum , 1 , & mime , & content_encoding , & config ) ; fprintf ( stderr , \"Simple<S2SV_blank>Timed<S2SV_blank>Text<S2SV_blank>Stream<S2SV_blank>\" ) ; fprintf ( stderr , \"-<S2SV_blank>mime<S2SV_blank>%s\" , mime ) ; if ( content_encoding != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>encoding<S2SV_blank>%s\" , content_encoding ) ; } if ( config != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>config\" , ( u32 ) strlen ( config ) ) ; } } else if ( msub_type == GF_ISOM_SUBTYPE_STPP ) { gf_isom_xml_subtitle_get_description ( file , trackNum , 1 , & _namespace , & schema_loc , & auxiliary_mimes ) ; fprintf ( stderr , \"XML<S2SV_blank>Subtitle<S2SV_blank>Stream<S2SV_blank>\" ) ; fprintf ( stderr , \"-<S2SV_blank>namespace<S2SV_blank>%s\" , _namespace ) ; if ( schema_loc != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>schema-location<S2SV_blank>%s\" , schema_loc ) ; } if ( auxiliary_mimes != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>auxiliary-mime-types<S2SV_blank>%s\" , auxiliary_mimes ) ; } } else { fprintf ( stderr , \"Unknown<S2SV_blank>Text<S2SV_blank>Stream\" ) ; } fprintf ( stderr , \"\\\\n<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Translation<S2SV_blank>X=%d<S2SV_blank>Y=%d<S2SV_blank>-<S2SV_blank>Layer<S2SV_blank>%d\\\\n\" , w , h , tx , ty , l ) ; } else if ( mtype == GF_ISOM_MEDIA_META ) { const char * content_encoding = NULL ; if ( msub_type == GF_ISOM_SUBTYPE_METT ) { const char * mime = NULL ; const char * config = NULL ; gf_isom_stxt_get_description ( file , trackNum , 1 , & mime , & content_encoding , & config ) ; fprintf ( stderr , \"Textual<S2SV_blank>Metadata<S2SV_blank>Stream<S2SV_blank>-<S2SV_blank>mime<S2SV_blank>%s\" , mime ) ; if ( content_encoding != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>encoding<S2SV_blank>%s\" , content_encoding ) ; } if ( config != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>config\" , ( u32 ) strlen ( config ) ) ; } fprintf ( stderr , \"\\\\n\" ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_METX ) { const char * _namespace = NULL ; const char * schema_loc = NULL ; gf_isom_get_xml_metadata_description ( file , trackNum , 1 , & _namespace , & schema_loc , & content_encoding ) ; fprintf ( stderr , \"XML<S2SV_blank>Metadata<S2SV_blank>Stream<S2SV_blank>-<S2SV_blank>namespace<S2SV_blank>%s\" , _namespace ) ; if ( content_encoding != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>encoding<S2SV_blank>%s\" , content_encoding ) ; } if ( schema_loc != NULL ) { fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>schema-location<S2SV_blank>%s\" , schema_loc ) ; } fprintf ( stderr , \"\\\\n\" ) ; } else { fprintf ( stderr , \"Unknown<S2SV_blank>Metadata<S2SV_blank>Stream\\\\n\" ) ; } } else if ( ( msub_type == GF_ISOM_SUBTYPE_VVC1 ) || ( msub_type == GF_ISOM_SUBTYPE_VVI1 ) ) { GF_VVCConfig * vvccfg ; u32 w , h ; # if ! defined ( GPAC_DISABLE_AV_PARSERS ) VVCState * vvc_state ; GF_SAFEALLOC ( vvc_state , VVCState ) ; if ( vvc_state ) vvc_state -> sps_active_idx = - 1 ; # endif gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; if ( full_dump ) fprintf ( stderr , \"\\\\t\" ) ; fprintf ( stderr , \"VVC<S2SV_blank>Video<S2SV_blank>-<S2SV_blank>Visual<S2SV_blank>Size<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , w , h ) ; vvccfg = gf_isom_vvc_config_get ( file , trackNum , 1 ) ; if ( ! vvccfg ) { M4_LOG ( GF_LOG_ERROR , ( \"Non-compliant<S2SV_blank>VVC<S2SV_blank>track:<S2SV_blank>No<S2SV_blank>vvcC<S2SV_blank>found<S2SV_blank>in<S2SV_blank>sample<S2SV_blank>description\\\\n\" ) ) ; } else { dump_vvc_track_info ( file , trackNum , vvccfg # if ! defined ( GPAC_DISABLE_AV_PARSERS ) , vvc_state # endif ) ; gf_odf_vvc_cfg_del ( vvccfg ) ; fprintf ( stderr , \"\\\\n\" ) ; } # if ! defined ( GPAC_DISABLE_AV_PARSERS ) if ( vvc_state ) gf_free ( vvc_state ) ; # endif } else if ( ( msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1 ) || ( msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2 ) || ( msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1 ) || ( msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2 ) ) { const u8 * compat_profiles ; u32 nb_compat_profiles ; Bool valid = GF_FALSE ; Bool allow_inband = GF_FALSE ; if ( ( msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1 ) || ( msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2 ) ) allow_inband = GF_TRUE ; fprintf ( stderr , \"\\\\tMPEG-H<S2SV_blank>Audio<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d\\\\n\" , sr ) ; esd = gf_media_map_esd ( file , trackNum , 1 ) ; if ( ! esd || ! esd -> decoderConfig || ! esd -> decoderConfig -> decoderSpecificInfo || ! esd -> decoderConfig -> decoderSpecificInfo -> data ) { if ( allow_inband ) { GF_ISOSample * samp = gf_isom_get_sample ( file , trackNum , 1 , NULL ) ; if ( samp ) { u64 ch_layout = 0 ; s32 PL = gf_mpegh_get_mhas_pl ( samp -> data , samp -> dataLength , & ch_layout ) ; if ( PL >= 0 ) { fprintf ( stderr , \"\\\\tProfileLevelIndication:<S2SV_blank>0x%02X\" , PL ) ; if ( ch_layout ) fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Reference<S2SV_blank>Channel<S2SV_blank>Layout<S2SV_blank>%s\" , gf_audio_fmt_get_layout_name ( ch_layout ) ) ; fprintf ( stderr , \"\\\\n\" ) ; } gf_isom_sample_del ( & samp ) ; } valid = GF_TRUE ; } } else if ( esd -> decoderConfig -> decoderSpecificInfo -> dataLength >= 5 ) { fprintf ( stderr , \"\\\\tProfileLevelIndication:<S2SV_blank>0x%02X<S2SV_blank>-<S2SV_blank>Reference<S2SV_blank>Channel<S2SV_blank>Layout<S2SV_blank>%s\\\\n\" , esd -> decoderConfig -> decoderSpecificInfo -> data [ 1 ] , gf_audio_fmt_get_layout_name_from_cicp ( esd -> decoderConfig -> decoderSpecificInfo -> data [ 2 ] ) ) ; valid = GF_TRUE ; } if ( ! valid ) { M4_LOG ( GF_LOG_ERROR , ( \"Invalid<S2SV_blank>MPEG-H<S2SV_blank>audio<S2SV_blank>config\\\\n\" ) ) ; } if ( esd ) gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; compat_profiles = gf_isom_get_mpegh_compatible_profiles ( file , trackNum , 1 , & nb_compat_profiles ) ; for ( i = 0 ; i < nb_compat_profiles ; i ++ ) { if ( ! i ) fprintf ( stderr , \"\\\\tCompatible<S2SV_blank>profiles:\" ) ; fprintf ( stderr , \"<S2SV_blank>0x%02X\" , compat_profiles [ i ] ) ; } if ( i ) fprintf ( stderr , \"\\\\n\" ) ; } else if ( msub_type == GF_ISOM_SUBTYPE_MLPA ) { u32 fmt , prate ; if ( gf_isom_truehd_config_get ( file , trackNum , 1 , & fmt , & prate ) != GF_OK ) { fprintf ( stderr , \"\\\\tInvalid<S2SV_blank>TrueHD<S2SV_blank>audio<S2SV_blank>config\\\\n\" ) ; } fprintf ( stderr , \"TrueHD<S2SV_blank>Audio<S2SV_blank>stream<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%u<S2SV_blank>-<S2SV_blank>channels<S2SV_blank>%u<S2SV_blank>-<S2SV_blank>format<S2SV_blank>%u<S2SV_blank>peak<S2SV_blank>rate<S2SV_blank>%u\\\\n\" , sr , nb_ch , fmt , prate ) ; } else if ( codecid ) { if ( gf_isom_is_video_handler_type ( mtype ) ) { u32 w , h ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; fprintf ( stderr , \"%s<S2SV_blank>-<S2SV_blank>Resolution<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , gf_codecid_name ( codecid ) , w , h ) ; } else if ( mtype == GF_ISOM_MEDIA_AUDIO ) { gf_isom_get_audio_info ( file , trackNum , 1 , & sr , & nb_ch , NULL ) ; fprintf ( stderr , \"%s<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)\\\\n\" , gf_codecid_name ( codecid ) , sr , nb_ch ) ; } else { fprintf ( stderr , \"%s\\\\n\" , gf_codecid_name ( codecid ) ) ; } } else if ( pfmt ) { u32 w , h ; gf_isom_get_visual_info ( file , trackNum , 1 , & w , & h ) ; fprintf ( stderr , \"Raw<S2SV_blank>video<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Resolution<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , gf_pixel_fmt_name ( pfmt ) , w , h ) ; } else if ( msub_type == GF_QT_SUBTYPE_TMCD ) { u32 stsd_idx ; GF_ISOSample * sample = gf_isom_get_sample ( file , trackNum , 1 , & stsd_idx ) ; fprintf ( stderr , \"Time<S2SV_blank>Code<S2SV_blank>stream\\\\n\" ) ; if ( sample ) { char szTimecode [ 100 ] ; u32 tmcd_flags , tmcd_num , tmcd_den , tmcd_fpt ; gf_isom_get_tmcd_config ( file , trackNum , stsd_idx , & tmcd_flags , & tmcd_num , & tmcd_den , & tmcd_fpt ) ; gf_inspect_format_timecode ( sample -> data , sample -> dataLength , tmcd_flags , tmcd_num , tmcd_den , tmcd_fpt , szTimecode ) ; gf_isom_sample_del ( & sample ) ; fprintf ( stderr , \"\\\\tFirst<S2SV_blank>timecode:<S2SV_blank>%s\\\\n\" , szTimecode ) ; } } else { GF_GenericSampleDescription * udesc ; udesc = gf_isom_get_generic_sample_description ( file , trackNum , 1 ) ; if ( udesc ) { if ( gf_isom_is_video_handler_type ( mtype ) ) { fprintf ( stderr , \"%s<S2SV_blank>-<S2SV_blank>Compressor<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>-<S2SV_blank>Resolution<S2SV_blank>%d<S2SV_blank>x<S2SV_blank>%d\\\\n\" , ( ( mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary<S2SV_blank>Video\" ) ) , udesc -> compressor_name , udesc -> width , udesc -> height ) ; } else if ( mtype == GF_ISOM_MEDIA_AUDIO ) { fprintf ( stderr , \"Audio<S2SV_blank>-<S2SV_blank>Sample<S2SV_blank>Rate<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>channel(s)\\\\n\" , udesc -> samplerate , udesc -> nb_channels ) ; } else { fprintf ( stderr , \"Unknown<S2SV_blank>media<S2SV_blank>type\\\\n\" ) ; } if ( udesc -> vendor_code ) fprintf ( stderr , \"\\\\tVendor<S2SV_blank>code<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>-<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>revision<S2SV_blank>%d\\\\n\" , gf_4cc_to_str ( udesc -> vendor_code ) , udesc -> version , udesc -> revision ) ; if ( udesc -> extension_buf ) { fprintf ( stderr , \"\\\\tCodec<S2SV_blank>configuration<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>bytes\\\\n\" , udesc -> extension_buf_size ) ; gf_free ( udesc -> extension_buf ) ; } gf_free ( udesc ) ; } else { fprintf ( stderr , \"Unknown<S2SV_blank>track<S2SV_blank>type\\\\n\" ) ; } } if ( gf_isom_is_track_encrypted ( file , trackNum ) ) { const char * scheme_URI , * KMS_URI ; u32 scheme_type , version ; u32 IV_size ; Bool use_sel_enc ; if ( gf_isom_is_ismacryp_media ( file , trackNum , 1 ) ) { gf_isom_get_ismacryp_info ( file , trackNum , 1 , NULL , & scheme_type , & version , & scheme_URI , & KMS_URI , & use_sel_enc , & IV_size , NULL ) ; fprintf ( stderr , \"\\\\n\\\\tProtected<S2SV_blank>by<S2SV_blank>ISMA<S2SV_blank>E&A<S2SV_blank>scheme<S2SV_blank>%s<S2SV_blank>(version<S2SV_blank>%d)\\\\n\" , gf_4cc_to_str ( scheme_type ) , version ) ; if ( scheme_URI ) fprintf ( stderr , \"scheme<S2SV_blank>location:<S2SV_blank>%s\\\\n\" , scheme_URI ) ; if ( KMS_URI ) { if ( ! strnicmp ( KMS_URI , \"(key)\" , 5 ) ) fprintf ( stderr , \"\\\\tKMS<S2SV_blank>location:<S2SV_blank>key<S2SV_blank>in<S2SV_blank>file\\\\n\" ) ; else fprintf ( stderr , \"\\\\tKMS<S2SV_blank>location:<S2SV_blank>%s\\\\n\" , KMS_URI ) ; } fprintf ( stderr , \"\\\\tSelective<S2SV_blank>Encryption:<S2SV_blank>%s\\\\n\" , use_sel_enc ? \"Yes\" : \"No\" ) ; if ( IV_size ) fprintf ( stderr , \"\\\\tInitialization<S2SV_blank>Vector<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>bits\\\\n\" , IV_size * 8 ) ; } else if ( gf_isom_is_omadrm_media ( file , trackNum , 1 ) ) { const char * textHdrs ; u32 enc_type , hdr_len ; u64 orig_len ; gf_isom_get_omadrm_info ( file , trackNum , 1 , NULL , & scheme_type , & version , & scheme_URI , & KMS_URI , & textHdrs , & hdr_len , & orig_len , & enc_type , & use_sel_enc , & IV_size , NULL ) ; fprintf ( stderr , \"\\\\n\\\\tProtected<S2SV_blank>by<S2SV_blank>OMA<S2SV_blank>DRM<S2SV_blank>scheme<S2SV_blank>%s<S2SV_blank>(version<S2SV_blank>%d)\\\\n\" , gf_4cc_to_str ( scheme_type ) , version ) ; fprintf ( stderr , \"\\\\tRights<S2SV_blank>Issuer:<S2SV_blank>%s\\\\n\" , KMS_URI ) ; fprintf ( stderr , \"\\\\tContent<S2SV_blank>ID:<S2SV_blank>%s\\\\n\" , scheme_URI ) ; if ( textHdrs ) { u32 offset ; const char * start = textHdrs ; fprintf ( stderr , \"\\\\tOMA<S2SV_blank>Textual<S2SV_blank>Headers:\\\\n\" ) ; i = 0 ; offset = 0 ; while ( i < hdr_len ) { if ( start [ i ] == 0 ) { fprintf ( stderr , \"\\\\t\\\\t%s\\\\n\" , start + offset ) ; offset = i + 1 ; } i ++ ; } fprintf ( stderr , \"\\\\\\\\tt%s\\\\n\" , start + offset ) ; } if ( orig_len ) fprintf ( stderr , \"\\\\tOriginal<S2SV_blank>media<S2SV_blank>size<S2SV_blank>\" LLD \"\\\\n\" , orig_len ) ; fprintf ( stderr , \"\\\\tEncryption<S2SV_blank>algorithm<S2SV_blank>%s\\\\n\" , ( enc_type == 1 ) ? \"AEA<S2SV_blank>128<S2SV_blank>CBC\" : ( enc_type ? \"AEA<S2SV_blank>128<S2SV_blank>CTR\" : \"None\" ) ) ; fprintf ( stderr , \"\\\\tSelective<S2SV_blank>Encryption:<S2SV_blank>%s\\\\n\" , use_sel_enc ? \"Yes\" : \"No\" ) ; if ( IV_size ) fprintf ( stderr , \"\\\\tInitialization<S2SV_blank>Vector<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>bits\\\\n\" , IV_size * 8 ) ; } else if ( gf_isom_is_cenc_media ( file , trackNum , 1 ) ) { const u8 * def_key ; u32 def_key_size ; Bool IsEncrypted ; u8 crypt_byte_block , skip_byte_block ; IV_size = 0 ; gf_isom_get_cenc_info ( file , trackNum , 1 , NULL , & scheme_type , & version ) ; gf_isom_cenc_get_default_info ( file , trackNum , 1 , NULL , & IsEncrypted , & crypt_byte_block , & skip_byte_block , & def_key , & def_key_size ) ; fprintf ( stderr , \"\\\\n\\\\tProtected<S2SV_blank>by<S2SV_blank>CENC<S2SV_blank>scheme<S2SV_blank>%s<S2SV_blank>version<S2SV_blank>0x%08X\" , gf_4cc_to_str ( scheme_type ) , version ) ; if ( crypt_byte_block && skip_byte_block ) fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>Pattern<S2SV_blank>%d:%d\" , ( u32 ) skip_byte_block , ( u32 ) crypt_byte_block ) ; if ( def_key && def_key [ 0 ] ) fprintf ( stderr , \"<S2SV_blank>-<S2SV_blank>MultiKey\" ) ; fprintf ( stderr , \"\\\\n\" ) ; dump_key_info ( def_key , def_key_size , IsEncrypted ) ; } else if ( gf_isom_is_adobe_protection_media ( file , trackNum , 1 ) ) { gf_isom_get_adobe_protection_info ( file , trackNum , 1 , NULL , & scheme_type , & version , NULL ) ; fprintf ( stderr , \"\\\\nProtected<S2SV_blank>by<S2SV_blank>Adobe<S2SV_blank>scheme<S2SV_blank>%s<S2SV_blank>(version<S2SV_blank>%d)\\\\n\" , gf_4cc_to_str ( scheme_type ) , version ) ; } else { fprintf ( stderr , \"\\\\nProtected<S2SV_blank>by<S2SV_blank>unknown<S2SV_blank>scheme<S2SV_blank>%s\\\\n\" , gf_4cc_to_str ( gf_isom_is_media_encrypted ( file , trackNum , 0 ) ) ) ; } fprintf ( stderr , \"\\\\n\" ) ; } if ( gf_media_get_rfc_6381_codec_name ( file , trackNum , szCodec , GF_FALSE , GF_FALSE ) == GF_OK ) { fprintf ( stderr , \"\\\\tRFC6381<S2SV_blank>Codec<S2SV_blank>Parameters:<S2SV_blank>%s\\\\n\" , szCodec ) ; } DumpMetaItem ( file , 0 , trackNum , \"\\\\tTrack<S2SV_blank>Meta\" ) ; gf_isom_get_track_switch_group_count ( file , trackNum , & alt_group , & nb_groups ) ; if ( alt_group ) { fprintf ( stderr , \"Alternate<S2SV_blank>Group<S2SV_blank>ID<S2SV_blank>%d\\\\n\" , alt_group ) ; for ( i = 0 ; i < nb_groups ; i ++ ) { u32 nb_crit , switchGroupID ; const u32 * criterias = gf_isom_get_track_switch_parameter ( file , trackNum , i + 1 , & switchGroupID , & nb_crit ) ; if ( ! nb_crit ) { fprintf ( stderr , \"\\\\tNo<S2SV_blank>criteria<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>group\\\\n\" , switchGroupID ? \"switch\" : \"alternate\" ) ; } else { if ( switchGroupID ) { fprintf ( stderr , \"\\\\tSwitchGroup<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>criterias:<S2SV_blank>\" , switchGroupID ) ; } else { fprintf ( stderr , \"\\\\tAlternate<S2SV_blank>Group<S2SV_blank>criterias:<S2SV_blank>\" ) ; } for ( j = 0 ; j < nb_crit ; j ++ ) { if ( j ) fprintf ( stderr , \"<S2SV_blank>\" ) ; fprintf ( stderr , \"%s\" , gf_4cc_to_str ( criterias [ j ] ) ) ; } fprintf ( stderr , \"\\\\n\" ) ; } } } switch ( gf_isom_has_sync_points ( file , trackNum ) ) { case 0 : fprintf ( stderr , \"\\\\tAll<S2SV_blank>samples<S2SV_blank>are<S2SV_blank>sync\\\\n\" ) ; break ; case 1 : { u32 nb_sync = gf_isom_get_sync_point_count ( file , trackNum ) - 1 ; if ( ! nb_sync ) { fprintf ( stderr , \"\\\\tOnly<S2SV_blank>one<S2SV_blank>sync<S2SV_blank>sample\\\\n\" ) ; } else { fprintf ( stderr , \"\\\\tAverage<S2SV_blank>GOP<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>samples\\\\n\" , gf_isom_get_sample_count ( file , trackNum ) / nb_sync ) ; } } break ; case 2 : fprintf ( stderr , \"\\\\tNo<S2SV_blank>sync<S2SV_blank>sample<S2SV_blank>found\\\\n\" ) ; break ; } fprintf ( stderr , \"\\\\tMax<S2SV_blank>sample<S2SV_blank>duration:<S2SV_blank>%d<S2SV_blank>/<S2SV_blank>%d\\\\n\" , gf_isom_get_max_sample_delta ( file , trackNum ) , timescale ) ; if ( ! full_dump ) { fprintf ( stderr , \"\\\\n\" ) ; return ; } dur = size = 0 ; max_rate = rate = 0 ; time_slice = 0 ; ts = gf_isom_get_media_timescale ( file , trackNum ) ; csize = gf_isom_get_constant_sample_size ( file , trackNum ) ; cdur = gf_isom_get_constant_sample_duration ( file , trackNum ) ; count = gf_isom_get_sample_count ( file , trackNum ) ; if ( csize && cdur ) { size = count * csize ; dur = cdur * count ; } else { for ( j = 0 ; j < count ; j ++ ) { GF_ISOSample * samp ; if ( is_od_track ) { samp = gf_isom_get_sample ( file , trackNum , j + 1 , NULL ) ; } else { samp = gf_isom_get_sample_info ( file , trackNum , j + 1 , NULL , NULL ) ; } if ( ! samp ) { M4_LOG ( GF_LOG_ERROR , ( \"Failed<S2SV_blank>to<S2SV_blank>fetch<S2SV_blank>sample<S2SV_blank>%d\\\\n\" , j + 1 ) ) ; return ; } dur = samp -> DTS + samp -> CTS_Offset ; size += samp -> dataLength ; rate += samp -> dataLength ; if ( samp -> DTS - time_slice > ts ) { Double max_tmp = rate * ts / ( samp -> DTS - time_slice ) ; if ( max_rate < max_tmp ) max_rate = max_tmp ; rate = 0 ; time_slice = samp -> DTS ; } gf_isom_sample_del ( & samp ) ; } } fprintf ( stderr , \"\\\\nComputed<S2SV_blank>info<S2SV_blank>from<S2SV_blank>media:\\\\n\" ) ; if ( csize && cdur ) { fprintf ( stderr , \"\\\\tConstant<S2SV_blank>sample<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>dur<S2SV_blank>%d<S2SV_blank>/<S2SV_blank>%d\\\\n\" , csize , cdur , ts ) ; } scale = 1000.0 / ts ; dur = ( u64 ) ( scale * dur ) ; fprintf ( stderr , \"\\\\tTotal<S2SV_blank>size<S2SV_blank>\" LLU \"<S2SV_blank>bytes<S2SV_blank>-<S2SV_blank>Total<S2SV_blank>samples<S2SV_blank>duration<S2SV_blank>\" LLU \"<S2SV_blank>ms\\\\n\" , size , dur ) ; if ( ! dur ) { fprintf ( stderr , \"\\\\n\" ) ; return ; } rate = 8000.0 * size / dur ; if ( ! max_rate ) max_rate = rate ; else max_rate *= 8.0 ; if ( rate >= 1500 ) { fprintf ( stderr , \"\\\\tAverage<S2SV_blank>rate<S2SV_blank>%.2f<S2SV_blank>kbps<S2SV_blank>-<S2SV_blank>Max<S2SV_blank>Rate<S2SV_blank>%.2f<S2SV_blank>kbps\\\\n\" , rate / 1000 , max_rate / 1000 ) ; } else { fprintf ( stderr , \"\\\\tAverage<S2SV_blank>rate<S2SV_blank>%.2f<S2SV_blank>bps<S2SV_blank>-<S2SV_blank>Max<S2SV_blank>Rate<S2SV_blank>%.2f<S2SV_blank>bps\\\\n\" , rate , max_rate ) ; } { u32 dmin , dmax , davg , smin , smax , savg ; gf_isom_get_chunks_infos ( file , trackNum , & dmin , & davg , & dmax , & smin , & savg , & smax ) ; fprintf ( stderr , \"\\\\tChunk<S2SV_blank>durations:<S2SV_blank>min<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>-<S2SV_blank>max<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>-<S2SV_blank>average<S2SV_blank>%d<S2SV_blank>ms\\\\n\" , ( 1000 * dmin ) / ts , ( 1000 * dmax ) / ts , ( 1000 * davg ) / ts ) ; fprintf ( stderr , \"\\\\tChunk<S2SV_blank>sizes<S2SV_blank>(bytes):<S2SV_blank>min<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>max<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>average<S2SV_blank>%d\\\\n\" , smin , smax , savg ) ; } fprintf ( stderr , \"\\\\n\" ) ; count = gf_isom_get_chapter_count ( file , trackNum ) ; if ( count ) { const char * name ; u64 time ; fprintf ( stderr , \"\\\\nChapters:\\\\n\" ) ; for ( j = 0 ; j < count ; j ++ ) { gf_isom_get_chapter ( file , trackNum , j + 1 , & time , & name ) ; fprintf ( stderr , \"\\\\tChapter<S2SV_blank>#%d<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , j + 1 , format_duration ( time , 1000 , szDur ) , name ) ; }", "target": "<S2SV_ModStart> 1 ) ; if ( ! av1c ) { fprintf ( stderr , \"\\\\tCorrupted<S2SV_blank>av1<S2SV_blank>config\\\\n\" ) ; } else { <S2SV_ModStart> av1c ) ; }"}
{"source": "CWE-787 void Compute ( OpKernelContext * context ) override { const auto & input = context -> input ( 0 ) ; auto flat_in = input . flat < tstring > ( ) ; int fixed_length ; const auto & length_input = context -> input ( 1 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsScalar ( length_input . shape ( ) ) , errors : : InvalidArgument ( \"k<S2SV_blank>must<S2SV_blank>be<S2SV_blank>scalar,<S2SV_blank>got<S2SV_blank>shape<S2SV_blank>\" , length_input . shape ( ) . DebugString ( ) ) ) ; fixed_length = length_input . scalar < int32 > ( ) ( ) ; OP_REQUIRES ( context , fixed_length % sizeof ( T ) == 0 , errors : : InvalidArgument ( \"fixed_length<S2SV_blank>(\" , fixed_length , \")<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>size<S2SV_blank>of<S2SV_blank>out_type<S2SV_blank>(\" , sizeof ( T ) , \")\" ) ) ; OP_REQUIRES ( context , fixed_length > 0 , errors : : InvalidArgument ( \"fixed_length<S2SV_blank>(\" , fixed_length , \")<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>zero.\" ) ) ; int width = fixed_length / sizeof ( T ) ; TensorShape out_shape = input . shape ( ) ; out_shape . AddDim ( width ) ; Tensor * output_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"output\" , out_shape , & output_tensor ) ) ; if ( flat_in . size ( ) == 0 ) { return ; } auto out = output_tensor -> flat_inner_dims < T > ( ) ; T * out_data = out . data ( ) ; memset ( out_data , 0 , fixed_length * flat_in . size ( ) ) ; if ( ! convert_data_endianness_ || sizeof ( T ) == 1 ) { for ( int64 i = 0 ; i < flat_in . size ( ) ; ++ i ) { <S2SV_StartBug> const T * in_data = reinterpret_cast < const T * > ( flat_in ( i ) . data ( ) ) ; <S2SV_EndBug> if ( flat_in ( i ) . size ( ) > fixed_length ) { memcpy ( out_data , in_data , fixed_length ) ; } else { memcpy ( out_data , in_data , flat_in ( i ) . size ( ) ) ; } out_data += fixed_length ; } } else { for ( int64 i = 0 ; i < flat_in . size ( ) ; ++ i ) { const char * in_data_bytes = reinterpret_cast < const char * > ( flat_in ( i ) . data ( ) ) ; char * out_data_bytes = reinterpret_cast < char * > ( out_data ) ; const char * p_in = in_data_bytes ; char * p_out = out_data_bytes ; for ( ; p_in < in_data_bytes + fixed_length ; p_in += sizeof ( T ) , p_out += sizeof ( T ) ) { std : : reverse_copy ( p_in , p_in + sizeof ( T ) , p_out ) ; } <S2SV_StartBug> out_data += fixed_length ; <S2SV_EndBug> } } }", "target": "<S2SV_ModStart> ) { const auto to_copy = std : : min ( flat_in ( i ) . size ( ) , static_cast < size_t > ( fixed_length ) ) ; memcpy ( out_data , <S2SV_ModEnd> flat_in ( i <S2SV_ModStart> data ( ) , to_copy ) ; out_data += width <S2SV_ModEnd> ; } } <S2SV_ModStart> } out_data += width <S2SV_ModEnd> ; } }"}
{"source": "CWE-369 void Compute ( OpKernelContext * ctx ) override { const Tensor & indices_tensor = ctx -> input ( 0 ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( indices_tensor . shape ( ) ) || TensorShapeUtils : : IsScalar ( indices_tensor . shape ( ) ) , errors : : InvalidArgument ( \"The<S2SV_blank>indices<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>scalar<S2SV_blank>or<S2SV_blank>vector,<S2SV_blank>got<S2SV_blank>\\\\\"\" , indices_tensor . shape ( ) . DebugString ( ) , \"\\\\\"\" ) ) ; const Tensor & dims_tensor = ctx -> input ( 1 ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( dims_tensor . shape ( ) ) , errors : : InvalidArgument ( \"The<S2SV_blank>indices<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>1-D,<S2SV_blank>got<S2SV_blank>\\\\\"\" , dims_tensor . shape ( ) . DebugString ( ) , \"\\\\\"\" ) ) ; auto dims = dims_tensor . vec < Tidx > ( ) ; <S2SV_StartBug> <S2SV_EndBug> Eigen : : Tensor < Tidx , 0 , Eigen : : RowMajor > dims_prod_eigen = dims . prod ( ) ; Tidx dims_prod = dims_prod_eigen ( ) ; const Tidx * indices = indices_tensor . flat < Tidx > ( ) . data ( ) ; int64 size = indices_tensor . NumElements ( ) ; bool check = std : : all_of ( indices , indices + size , [ & ] ( Tidx index ) { return index < dims_prod ; } ) ; OP_REQUIRES ( ctx , check , errors : : InvalidArgument ( \"index<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bound<S2SV_blank>as<S2SV_blank>with<S2SV_blank>dims\" ) ) ; Eigen : : array < bool , 1 > reverse ( { true } ) ; Tensor strides_tensor ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < Tidx > : : value , TensorShape ( { dims_tensor . NumElements ( ) } ) , & strides_tensor ) ) ; auto strides = strides_tensor . vec < Tidx > ( ) ; strides = dims . reverse ( reverse ) . scan ( 0 , Eigen : : internal : : ProdReducer < Tidx > ( ) , false ) . reverse ( reverse ) ; Tensor strides_shifted_tensor ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < Tidx > : : value , TensorShape ( { dims_tensor . NumElements ( ) } ) , & strides_shifted_tensor ) ) ; auto strides_shifted = strides_shifted_tensor . vec < Tidx > ( ) ; strides_shifted = dims . reverse ( reverse ) . scan ( 0 , Eigen : : internal : : ProdReducer < Tidx > ( ) , true ) . reverse ( reverse ) ; Tensor * output_tensor = nullptr ; if ( TensorShapeUtils : : IsScalar ( indices_tensor . shape ( ) ) ) { OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { dims_tensor . NumElements ( ) } ) , & output_tensor ) ) ; auto output = output_tensor -> vec < Tidx > ( ) ; output = output . constant ( indices_tensor . scalar < Tidx > ( ) ( ) ) ; output = output . binaryExpr ( strides , mod_op < Tidx > ( ) ) / strides_shifted ; } else { OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { dims_tensor . NumElements ( ) , indices_tensor . NumElements ( ) } ) , & output_tensor ) ) ; auto output = output_tensor -> matrix < Tidx > ( ) ; Eigen : : array < Eigen : : Index , 2 > reshape { { static_cast < Eigen : : Index > ( dims_tensor . NumElements ( ) ) , 1 } } ; Eigen : : array < Eigen : : Index , 2 > bcast ( { 1 , static_cast < Eigen : : Index > ( indices_tensor . NumElements ( ) ) } ) ; Eigen : : array < Eigen : : Index , 2 > indices_reshape { { 1 , static_cast < Eigen : : Index > ( indices_tensor . NumElements ( ) ) } } ; Eigen : : array < Eigen : : Index , 2 > indices_bcast ( { static_cast < Eigen : : Index > ( dims_tensor . NumElements ( ) ) , 1 } ) ; output = indices_tensor . vec < Tidx > ( ) . reshape ( indices_reshape ) . broadcast ( indices_bcast ) ; output = output . binaryExpr ( strides . reshape ( reshape ) . broadcast ( bcast ) , mod_op < Tidx > ( ) ) / strides_shifted . reshape ( reshape ) . broadcast ( bcast ) ; } }", "target": "<S2SV_ModStart> ( ) ; for ( int i = 0 ; i < dims . size ( ) ; i ++ ) { OP_REQUIRES ( ctx , dims ( i ) != 0 , errors : : InvalidArgument ( \"Input<S2SV_blank>dims<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>dim<S2SV_blank>of<S2SV_blank>zero,<S2SV_blank>\" \"but<S2SV_blank>dims<S2SV_blank>contains<S2SV_blank>zero<S2SV_blank>at<S2SV_blank>index<S2SV_blank>\" , i ) ) ; }"}
{"source": "CWE-476 static void nhmldump_send_header ( GF_NHMLDumpCtx * ctx ) { GF_FilterPacket * dst_pck ; char nhml [ 1024 ] ; u32 size ; u8 * output ; const GF_PropertyValue * p ; ctx -> szRootName = \"NHNTStream\" ; if ( ctx -> dims ) { ctx -> szRootName = \"DIMSStream\" ; } if ( ! ctx -> filep ) { sprintf ( nhml , \"<?xml<S2SV_blank>version=\\\\\"1.0\\\\\"<S2SV_blank>encoding=\\\\\"UTF-8\\\\\"<S2SV_blank>?>\\\\n\" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } sprintf ( nhml , \"<%s<S2SV_blank>version=\\\\\"1.0\\\\\"<S2SV_blank>\" , ctx -> szRootName ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; NHML_PRINT_UINT ( GF_PROP_PID_ID , NULL , \"trackID\" ) NHML_PRINT_UINT ( GF_PROP_PID_TIMESCALE , NULL , \"timeScale\" ) p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_IN_IOD ) ; if ( p && p -> value . boolean ) { sprintf ( nhml , \"inRootOD=\\\\\"yes\\\\\"<S2SV_blank>\" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } if ( ctx -> oti && ( ctx -> oti < GF_CODECID_LAST_MPEG4_MAPPING ) ) { sprintf ( nhml , \"streamType=\\\\\"%d\\\\\"<S2SV_blank>objectTypeIndication=\\\\\"%d\\\\\"<S2SV_blank>\" , ctx -> streamtype , ctx -> oti ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } else { p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_SUBTYPE ) ; if ( p ) { sprintf ( nhml , \"%s=\\\\\"%s\\\\\"<S2SV_blank>\" , \"mediaType\" , gf_4cc_to_str ( p -> value . uint ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; NHML_PRINT_4CC ( GF_PROP_PID_ISOM_SUBTYPE , \"mediaSubType\" , \"mediaSubType\" ) } else { NHML_PRINT_4CC ( GF_PROP_PID_CODECID , NULL , \"codecID\" ) } } if ( ctx -> w && ctx -> h ) { switch ( ctx -> streamtype ) { case GF_STREAM_VISUAL : case GF_STREAM_SCENE : sprintf ( nhml , \"width=\\\\\"%d\\\\\"<S2SV_blank>height=\\\\\"%d\\\\\"<S2SV_blank>\" , ctx -> w , ctx -> h ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; break ; default : break ; } } else if ( ctx -> sr && ctx -> chan ) { sprintf ( nhml , \"sampleRate=\\\\\"%d\\\\\"<S2SV_blank>numChannels=\\\\\"%d\\\\\"<S2SV_blank>\" , ctx -> sr , ctx -> chan ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; sprintf ( nhml , \"sampleRate=\\\\\"%d\\\\\"<S2SV_blank>numChannels=\\\\\"%d\\\\\"<S2SV_blank>\" , ctx -> sr , ctx -> chan ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; <S2SV_StartBug> p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ; <S2SV_EndBug> sprintf ( nhml , \"bitsPerSample=\\\\\"%d\\\\\"<S2SV_blank>\" , gf_audio_fmt_bit_depth ( p -> value . uint ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_4CC ( 0 , \"codec_vendor\" , \"codecVendor\" ) NHML_PRINT_UINT ( 0 , \"codec_version\" , \"codecVersion\" ) NHML_PRINT_UINT ( 0 , \"codec_revision\" , \"codecRevision\" ) NHML_PRINT_STRING ( 0 , \"compressor_name\" , \"compressorName\" ) NHML_PRINT_UINT ( 0 , \"temporal_quality\" , \"temporalQuality\" ) NHML_PRINT_UINT ( 0 , \"spatial_quality\" , \"spatialQuality\" ) NHML_PRINT_UINT ( 0 , \"hres\" , \"horizontalResolution\" ) NHML_PRINT_UINT ( 0 , \"vres\" , \"verticalResolution\" ) NHML_PRINT_UINT ( GF_PROP_PID_BIT_DEPTH_Y , NULL , \"bitDepth\" ) NHML_PRINT_STRING ( 0 , \"meta:xmlns\" , \"xml_namespace\" ) NHML_PRINT_STRING ( 0 , \"meta:schemaloc\" , \"xml_schema_location\" ) NHML_PRINT_STRING ( 0 , \"meta:mime\" , \"mime_type\" ) NHML_PRINT_STRING ( 0 , \"meta:config\" , \"config\" ) NHML_PRINT_STRING ( 0 , \"meta:aux_mimes\" , \"aux_mime_type\" ) if ( ctx -> codecid == GF_CODECID_DIMS ) { if ( gf_filter_pid_get_property_str ( ctx -> ipid , \"meta:xmlns\" ) == NULL ) { sprintf ( nhml , \"xmlns=\\\\\"http://www.3gpp.org/richmedia\\\\\"<S2SV_blank>\" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_UINT ( 0 , \"dims:profile\" , \"profile\" ) NHML_PRINT_UINT ( 0 , \"dims:level\" , \"level\" ) NHML_PRINT_UINT ( 0 , \"dims:pathComponents\" , \"pathComponents\" ) p = gf_filter_pid_get_property_str ( ctx -> ipid , \"dims:fullRequestHost\" ) ; if ( p ) { sprintf ( nhml , \"useFullRequestHost=\\\\\"%s\\\\\"<S2SV_blank>\" , p -> value . boolean ? \"yes\" : \"no\" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } p = gf_filter_pid_get_property_str ( ctx -> ipid , \"dims:streamType\" ) ; if ( p ) { sprintf ( nhml , \"stream_type=\\\\\"%s\\\\\"<S2SV_blank>\" , p -> value . boolean ? \"primary\" : \"secondary\" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } p = gf_filter_pid_get_property_str ( ctx -> ipid , \"dims:redundant\" ) ; if ( p ) { sprintf ( nhml , \"contains_redundant=\\\\\"%s\\\\\"<S2SV_blank>\" , ( p -> value . uint == 1 ) ? \"main\" : ( ( p -> value . uint == 1 ) ? \"redundant\" : \"main+redundant\" ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_UINT ( 0 , \"dims:scriptTypes\" , \"scriptTypes\" ) } if ( ctx -> opid_info ) { sprintf ( nhml , \"specificInfoFile=\\\\\"%s\\\\\"<S2SV_blank>\" , gf_file_basename ( ctx -> info_file ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; dst_pck = gf_filter_pck_new_shared ( ctx -> opid_info , ctx -> dcfg , ctx -> dcfg_size , NULL ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; gf_filter_pck_set_readonly ( dst_pck ) ; gf_filter_pck_send ( dst_pck ) ; } NHML_PRINT_STRING ( 0 , \"meta:encoding\" , \"encoding\" ) NHML_PRINT_STRING ( 0 , \"meta:contentEncoding\" , \"content_encoding\" ) ctx -> uncompress = GF_FALSE ; if ( p ) { if ( ! strcmp ( p -> value . string , \"deflate\" ) ) ctx -> uncompress = GF_TRUE ; else { GF_LOG ( GF_LOG_ERROR , GF_LOG_AUTHOR , ( \"[NHMLMx]<S2SV_blank>content_encoding<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>supported\\\\n\" , p -> value . string ) ) ; } } if ( ctx -> opid_mdia ) { sprintf ( nhml , \"baseMediaFile=\\\\\"%s\\\\\"<S2SV_blank>\" , gf_file_basename ( ctx -> media_file ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } sprintf ( nhml , \">\\\\n\" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; gf_bs_get_content_no_truncate ( ctx -> bs_w , & ctx -> nhml_buffer , & size , & ctx -> nhml_buffer_size ) ; if ( ctx -> filep ) { gf_fwrite ( ctx -> nhml_buffer , size , ctx -> filep ) ; return ; } dst_pck = gf_filter_pck_new_alloc ( ctx -> opid_nhml , size , & output ) ; memcpy ( output , ctx -> nhml_buffer , size ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_FALSE ) ; gf_filter_pck_send ( dst_pck ) ; }", "target": "<S2SV_ModStart> GF_PROP_PID_AUDIO_FORMAT ) ; if ( p )"}
{"source": "CWE-787 static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , \"number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\\\n\" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , \"number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\\\n\" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; <S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }", "target": "<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;"}
{"source": "CWE-125 static int process_base_block ( struct archive_read * a , struct archive_entry * entry ) { <S2SV_StartBug> struct rar5 * rar = get_context ( a ) ; <S2SV_EndBug> uint32_t hdr_crc , computed_crc ; size_t raw_hdr_size = 0 , hdr_size_len , hdr_size ; size_t header_id = 0 ; size_t header_flags = 0 ; const uint8_t * p ; int ret ; enum HEADER_TYPE { HEAD_MARK = 0x00 , HEAD_MAIN = 0x01 , HEAD_FILE = 0x02 , HEAD_SERVICE = 0x03 , HEAD_CRYPT = 0x04 , HEAD_ENDARC = 0x05 , HEAD_UNKNOWN = 0xff , } ; ret = skip_unprocessed_bytes ( a ) ; if ( ret != ARCHIVE_OK ) return ret ; if ( ! read_u32 ( a , & hdr_crc ) ) { return ARCHIVE_EOF ; } if ( ! read_var_sized ( a , & raw_hdr_size , & hdr_size_len ) ) { return ARCHIVE_EOF ; } <S2SV_StartBug> if ( raw_hdr_size > ( 2 * 1024 * 1024 ) ) { <S2SV_EndBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Base<S2SV_blank>block<S2SV_blank>header<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\" ) ; return ARCHIVE_FATAL ; } <S2SV_StartBug> hdr_size = raw_hdr_size + hdr_size_len ; <S2SV_EndBug> if ( ! read_ahead ( a , hdr_size , & p ) ) { return ARCHIVE_EOF ; } computed_crc = ( uint32_t ) crc32 ( 0 , p , ( int ) hdr_size ) ; if ( computed_crc != hdr_crc ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Header<S2SV_blank>CRC<S2SV_blank>error\" ) ; return ARCHIVE_FATAL ; } if ( ARCHIVE_OK != consume ( a , hdr_size_len ) ) { return ARCHIVE_EOF ; } if ( ! read_var_sized ( a , & header_id , NULL ) ) return ARCHIVE_EOF ; if ( ! read_var_sized ( a , & header_flags , NULL ) ) return ARCHIVE_EOF ; rar -> generic . split_after = ( header_flags & HFL_SPLIT_AFTER ) > 0 ; rar -> generic . split_before = ( header_flags & HFL_SPLIT_BEFORE ) > 0 ; rar -> generic . size = ( int ) hdr_size ; rar -> generic . last_header_id = ( int ) header_id ; rar -> main . endarc = 0 ; switch ( header_id ) { case HEAD_MAIN : ret = process_head_main ( a , rar , entry , header_flags ) ; if ( ret == ARCHIVE_OK ) return ARCHIVE_RETRY ; return ret ; case HEAD_SERVICE : ret = process_head_service ( a , rar , entry , header_flags ) ; return ret ; case HEAD_FILE : ret = process_head_file ( a , rar , entry , header_flags ) ; return ret ; case HEAD_CRYPT : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Encryption<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\" ) ; return ARCHIVE_FATAL ; case HEAD_ENDARC : rar -> main . endarc = 1 ; if ( rar -> main . volume ) { ret = scan_for_signature ( a ) ; if ( ret == ARCHIVE_FATAL ) { return ARCHIVE_EOF ; } else { if ( rar -> vol . expected_vol_no == UINT_MAX ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Header<S2SV_blank>error\" ) ; return ARCHIVE_FATAL ; } rar -> vol . expected_vol_no = rar -> main . vol_no + 1 ; return ARCHIVE_OK ; } } else { return ARCHIVE_EOF ; } case HEAD_MARK : return ARCHIVE_EOF ; default : if ( ( header_flags & HFL_SKIP_IF_UNKNOWN ) == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Header<S2SV_blank>type<S2SV_blank>error\" ) ; return ARCHIVE_FATAL ; } else { return ARCHIVE_RETRY ; } } # if ! defined WIN32 archive_set_error ( & a -> archive , ARCHIVE_ERRNO_PROGRAMMER , \"Internal<S2SV_blank>unpacker<S2SV_blank>error\" ) ; return ARCHIVE_FATAL ; # endif }", "target": "<S2SV_ModStart> entry ) { const size_t SMALLEST_RAR5_BLOCK_SIZE = 3 ; <S2SV_ModStart> ARCHIVE_EOF ; } hdr_size = raw_hdr_size + hdr_size_len ; if ( hdr_size <S2SV_ModEnd> > ( 2 <S2SV_ModStart> ARCHIVE_FATAL ; } if ( raw_hdr_size == 0 || hdr_size_len == 0 || hdr_size < SMALLEST_RAR5_BLOCK_SIZE ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Too<S2SV_blank>small<S2SV_blank>block<S2SV_blank>encountered<S2SV_blank>(%ld<S2SV_blank>bytes)\" , raw_hdr_size ) ; return ARCHIVE_FATAL ; } <S2SV_ModEnd> if ( !"}
{"source": "CWE-787 void Compute ( OpKernelContext * context ) override { const Tensor & input_tensor = context -> input ( 0 ) ; const auto input_tensor_flat = input_tensor . flat < int32 > ( ) ; const Tensor & input_splits = context -> input ( 1 ) ; const auto input_splits_flat = input_splits . flat < SPLITS_TYPE > ( ) ; <S2SV_StartBug> <S2SV_EndBug> TensorShape output_shape ( { input_splits . dim_size ( 0 ) - 1 } ) ; Tensor * output_tensor ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"output\" , output_shape , & output_tensor ) ) ; auto output_tensor_flat = output_tensor -> flat < tstring > ( ) ; int idx = 0 ; for ( int i = 1 ; i < input_splits_flat . size ( ) ; ++ i ) { icu : : UnicodeString unicode_string ; icu : : UnicodeStringAppendable appendable_unicode_string ( unicode_string ) ; <S2SV_StartBug> for ( ; idx < input_splits_flat ( i ) ; ++ idx ) { <S2SV_EndBug> int32 code_point = input_tensor_flat ( idx ) ; if ( ! U_IS_UNICODE_CHAR ( code_point ) ) { if ( error_options_ . error_on_malformatting ) { context -> CtxFailure ( errors : : InvalidArgument ( \"Code<S2SV_blank>point<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range<S2SV_blank>for<S2SV_blank>Unicode,<S2SV_blank>or<S2SV_blank>a<S2SV_blank>noncharacter.\" ) ) ; return ; } else if ( ! error_options_ . elide_replacement ) { code_point = error_options_ . subst ; } } appendable_unicode_string . appendCodePoint ( code_point ) ; } tstring result ; Encode ( encoding_ , unicode_string , & result ) ; output_tensor_flat ( i - 1 ) = std : : move ( result ) ; } }", "target": "<S2SV_ModStart> ( ) ; OP_REQUIRES ( context , input_splits_flat ( 0 ) == 0 , errors : : InvalidArgument ( \"First<S2SV_blank>value<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero.\" ) ) ; OP_REQUIRES ( context , input_splits_flat ( input_splits_flat . size ( ) - 1 ) == input_tensor_flat . size ( ) , errors : : InvalidArgument ( \"Last<S2SV_blank>value<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\" \"equal<S2SV_blank>to<S2SV_blank>length<S2SV_blank>of<S2SV_blank>input_tensor.\" ) ) ; <S2SV_ModStart> unicode_string ) ; OP_REQUIRES ( context , input_splits_flat ( i - 1 ) <= input_splits_flat ( i ) , errors : : InvalidArgument ( \"Values<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>equal<S2SV_blank>or<S2SV_blank>in<S2SV_blank>ascending<S2SV_blank>order.\" ) ) ; OP_REQUIRES ( context , input_splits_flat ( i ) <= input_tensor_flat . size ( ) , errors : : InvalidArgument ( \"Values<S2SV_blank>in<S2SV_blank>input_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>or<S2SV_blank>\" \"equal<S2SV_blank>to<S2SV_blank>input_tensor<S2SV_blank>length.\" ) ) ;"}
{"source": "CWE-787 void Compute ( OpKernelContext * ctx ) override { const Tensor & input = ctx -> input ( 0 ) ; <S2SV_StartBug> const int depth = ( axis_ == - 1 ) ? 1 : input . dim_size ( axis_ ) ; <S2SV_EndBug> Tensor input_min_tensor ; Tensor input_max_tensor ; Tensor * output = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , input . shape ( ) , & output ) ) ; <S2SV_StartBug> if ( range_given_ ) { <S2SV_EndBug> input_min_tensor = ctx -> input ( 1 ) ; input_max_tensor = ctx -> input ( 2 ) ; if ( axis_ == - 1 ) { auto min_val = input_min_tensor . scalar < T > ( ) ( ) ; auto max_val = input_max_tensor . scalar < T > ( ) ( ) ; OP_REQUIRES ( ctx , min_val <= max_val , errors : : InvalidArgument ( \"Invalid<S2SV_blank>range:<S2SV_blank>input_min<S2SV_blank>\" , min_val , \"<S2SV_blank>><S2SV_blank>input_max<S2SV_blank>\" , max_val ) ) ; } else { OP_REQUIRES ( ctx , input_min_tensor . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"input_min_tensor<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>was<S2SV_blank>\" , input_min_tensor . dim_size ( 0 ) , \"<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>to<S2SV_blank>match<S2SV_blank>dim<S2SV_blank>\" , axis_ , \"<S2SV_blank>of<S2SV_blank>the<S2SV_blank>input<S2SV_blank>\" , input_min_tensor . shape ( ) ) ) ; OP_REQUIRES ( ctx , input_max_tensor . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"input_max_tensor<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>was<S2SV_blank>\" , input_max_tensor . dim_size ( 0 ) , \"<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>to<S2SV_blank>match<S2SV_blank>dim<S2SV_blank>\" , axis_ , \"<S2SV_blank>of<S2SV_blank>the<S2SV_blank>input<S2SV_blank>\" , input_max_tensor . shape ( ) ) ) ; } } else { auto range_shape = ( axis_ == - 1 ) ? TensorShape ( { } ) : TensorShape ( { depth } ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > : : value , <S2SV_StartBug> range_shape , & input_min_tensor ) ) ; <S2SV_EndBug> <S2SV_StartBug> OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > : : value , <S2SV_EndBug> <S2SV_StartBug> range_shape , & input_max_tensor ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> if ( axis_ == - 1 ) { <S2SV_StartBug> functor : : QuantizeAndDequantizeOneScaleFunctor < Device , T > f ; <S2SV_EndBug> f ( ctx -> eigen_device < Device > ( ) , input . flat < T > ( ) , signed_input_ , num_bits_ , <S2SV_StartBug> range_given_ , & input_min_tensor , & input_max_tensor , round_mode_ , <S2SV_EndBug> narrow_range_ , output -> flat < T > ( ) ) ; <S2SV_StartBug> } else { <S2SV_EndBug> functor : : QuantizeAndDequantizePerChannelFunctor < Device , T > f ; f ( ctx -> eigen_device < Device > ( ) , input . template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , signed_input_ , num_bits_ , range_given_ , & input_min_tensor , & input_max_tensor , round_mode_ , narrow_range_ , output -> template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) ) ; } }", "target": "<S2SV_ModStart> 0 ) ; <S2SV_ModEnd> Tensor * output <S2SV_ModStart> ) ) ; Tensor input_min_tensor <S2SV_ModEnd> ( DataTypeToEnum < <S2SV_ModStart> : value , TensorShape ( <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; Tensor input_max_tensor <S2SV_ModEnd> ( DataTypeToEnum < <S2SV_ModStart> : value , TensorShape ( <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; input_min_tensor . template scalar < T > ( ) ( ) = static_cast < T > ( input_min_ ) ; input_max_tensor . template scalar < T > ( ) ( ) = static_cast < T > ( input_max_ ) ; <S2SV_ModEnd> functor : : <S2SV_ModStart> , T > functor ; functor <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> & input_max_tensor , ROUND_HALF_TO_EVEN , false <S2SV_ModEnd> , output -> <S2SV_ModStart> ) ; } <S2SV_ModEnd>  <S2SV_null> <S2SV_null>"}
{"source": "CWE-125 static void launch ( OpKernelContext * context , const PoolParameters & params , const Tensor & grad_in , const Tensor & argmax , Tensor * grad_out , const bool include_batch_in_index ) { const DeviceBase : : CpuWorkerThreads & worker_threads = * ( context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ) ; auto shard = [ & grad_in , & argmax , & grad_out , include_batch_in_index ] ( int64 start , int64 limit ) { const int64 batch_size = GetTensorDim ( grad_out -> shape ( ) , FORMAT_NHWC , 'N' ) ; const int64 output_size_per_batch = grad_out -> NumElements ( ) / batch_size ; const int64 input_size_per_batch = grad_in . NumElements ( ) / batch_size ; { auto grad_out_flat = grad_out -> flat < T > ( ) ; auto argmax_flat = argmax . flat < int64 > ( ) ; auto grad_in_flat = grad_in . flat < T > ( ) ; const int64 output_start = start * output_size_per_batch ; const int64 output_end = limit * output_size_per_batch ; EigenMatrixMap inputShard ( grad_out_flat . data ( ) + output_start , 1 , output_end - output_start ) ; inputShard . setConstant ( T ( 0 ) ) ; const int input_start = start * input_size_per_batch ; const int input_end = limit * input_size_per_batch ; for ( int64 index = input_start ; index < input_end ; index ++ ) { <S2SV_StartBug> int64 grad_out_index = argmax_flat ( index ) ; <S2SV_EndBug> if ( ! include_batch_in_index ) { const int64 cur_batch = index / input_size_per_batch ; grad_out_index += cur_batch * output_size_per_batch ; } CHECK ( grad_out_index >= output_start && grad_out_index < output_end ) << \"Invalid<S2SV_blank>output<S2SV_blank>gradient<S2SV_blank>index:<S2SV_blank>\" << grad_out_index << \",<S2SV_blank>\" << output_start << \",<S2SV_blank>\" << output_end ; grad_out_flat ( grad_out_index ) += grad_in_flat ( index ) ; } } } ; const int64 batch_size = GetTensorDim ( grad_out -> shape ( ) , FORMAT_NHWC , 'N' ) ; const int64 shard_cost = grad_out -> NumElements ( ) / batch_size ; Shard ( worker_threads . num_threads , worker_threads . workers , batch_size , shard_cost , shard ) ; }", "target": "<S2SV_ModStart> ++ ) { if ( index >= argmax . NumElements ( ) ) { break ; }"}
{"source": "CWE-476 void UncompressElementOp : : Compute ( OpKernelContext * ctx ) { Tensor tensor = ctx -> input ( 0 ) ; const Variant & variant = tensor . scalar < Variant > ( ) ( ) ; const CompressedElement * compressed = variant . get < CompressedElement > ( ) ; <S2SV_StartBug> <S2SV_EndBug> std : : vector < Tensor > components ; OP_REQUIRES_OK ( ctx , UncompressElement ( * compressed , & components ) ) ; OP_REQUIRES ( ctx , components . size ( ) == output_types_ . size ( ) , errors : : FailedPrecondition ( \"Expected<S2SV_blank>\" , output_types_ . size ( ) , \"<S2SV_blank>outputs<S2SV_blank>from<S2SV_blank>uncompress,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , components . size ( ) ) ) ; for ( int i = 0 ; i < components . size ( ) ; ++ i ) { OP_REQUIRES ( ctx , components [ i ] . dtype ( ) == output_types_ [ i ] , errors : : FailedPrecondition ( \"Expected<S2SV_blank>a<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( output_types_ [ i ] ) , \"<S2SV_blank>but<S2SV_blank>got<S2SV_blank>a<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( components [ i ] . dtype ( ) ) ) ) ; ctx -> set_output ( i , components [ i ] ) ; } }", "target": "<S2SV_ModStart> ( ) ; OP_REQUIRES ( ctx , compressed != nullptr , errors : : InvalidArgument ( \"Input<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>compressed<S2SV_blank>element.<S2SV_blank>Instead<S2SV_blank>got<S2SV_blank>tensor<S2SV_blank>\" , tensor . DebugString ( ) ) ) ;"}
{"source": "CWE-125 PrimitiveStatus TrustedPrimitives : : UntrustedCall ( uint64_t untrusted_selector , MessageWriter * input , MessageReader * output ) { int ret ; UntrustedCacheMalloc * untrusted_cache = UntrustedCacheMalloc : : Instance ( ) ; SgxParams * const sgx_params = reinterpret_cast < SgxParams * > ( untrusted_cache -> Malloc ( sizeof ( SgxParams ) ) ) ; Cleanup clean_up ( [ sgx_params , untrusted_cache ] { untrusted_cache -> Free ( sgx_params ) ; } ) ; sgx_params -> input_size = 0 ; sgx_params -> input = nullptr ; if ( input ) { sgx_params -> input_size = input -> MessageSize ( ) ; if ( sgx_params -> input_size > 0 ) { sgx_params -> input = untrusted_cache -> Malloc ( sgx_params -> input_size ) ; input -> Serialize ( const_cast < void * > ( sgx_params -> input ) ) ; } } sgx_params -> output_size = 0 ; sgx_params -> output = nullptr ; CHECK_OCALL ( ocall_dispatch_untrusted_call ( & ret , untrusted_selector , sgx_params ) ) ; if ( sgx_params -> input ) { untrusted_cache -> Free ( const_cast < void * > ( sgx_params -> input ) ) ; } <S2SV_StartBug> if ( sgx_params -> output ) { <S2SV_EndBug> output -> Deserialize ( sgx_params -> output , sgx_params -> output_size ) ; TrustedPrimitives : : UntrustedLocalFree ( sgx_params -> output ) ; } return PrimitiveStatus : : OkStatus ( ) ; }", "target": "<S2SV_ModStart> } if ( ! TrustedPrimitives : : IsOutsideEnclave ( sgx_params -> output , sgx_params -> output_size ) ) { TrustedPrimitives : : BestEffortAbort ( \"UntrustedCall:<S2SV_blank>sgx_param<S2SV_blank>output<S2SV_blank>should<S2SV_blank>be<S2SV_blank>in<S2SV_blank>untrusted<S2SV_blank>memory\" ) ; } if ("}
{"source": "CWE-190 StreamBufferHandle_t xStreamBufferGenericCreate ( size_t xBufferSizeBytes , size_t xTriggerLevelBytes , BaseType_t xIsMessageBuffer ) { uint8_t * pucAllocatedMemory ; uint8_t ucFlags ; if ( xIsMessageBuffer == pdTRUE ) { ucFlags = sbFLAGS_IS_MESSAGE_BUFFER ; configASSERT ( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH ) ; } else { ucFlags = 0 ; configASSERT ( xBufferSizeBytes > 0 ) ; } configASSERT ( xTriggerLevelBytes <= xBufferSizeBytes ) ; if ( xTriggerLevelBytes == ( size_t ) 0 ) { xTriggerLevelBytes = ( size_t ) 1 ; } <S2SV_StartBug> xBufferSizeBytes ++ ; <S2SV_EndBug> <S2SV_StartBug> pucAllocatedMemory = ( uint8_t * ) pvPortMalloc ( xBufferSizeBytes + sizeof ( StreamBuffer_t ) ) ; <S2SV_EndBug> if ( pucAllocatedMemory != NULL ) { prvInitialiseNewStreamBuffer ( ( StreamBuffer_t * ) pucAllocatedMemory , pucAllocatedMemory + sizeof ( StreamBuffer_t ) , xBufferSizeBytes , xTriggerLevelBytes , ucFlags ) ; traceSTREAM_BUFFER_CREATE ( ( ( StreamBuffer_t * ) pucAllocatedMemory ) , xIsMessageBuffer ) ; } else { traceSTREAM_BUFFER_CREATE_FAILED ( xIsMessageBuffer ) ; } return ( StreamBufferHandle_t ) pucAllocatedMemory ; }", "target": "<S2SV_ModStart> 1 ; } if ( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof ( StreamBuffer_t ) ) ) { <S2SV_ModStart> ) ) ; } else { pucAllocatedMemory = NULL ; }"}
{"source": "CWE-125 Status CompressElement ( const std : : vector < Tensor > & element , CompressedElement * out ) { std : : vector < TensorProto > non_memcpy_components ; int64 total_size = 0 ; for ( auto & component : element ) { if ( DataTypeCanUseMemcpy ( component . dtype ( ) ) ) { <S2SV_StartBug> total_size += DMAHelper : : buffer ( & component ) -> size ( ) ; <S2SV_EndBug> } else { non_memcpy_components . emplace_back ( ) ; component . AsProtoTensorContent ( & non_memcpy_components . back ( ) ) ; total_size += non_memcpy_components . back ( ) . ByteSizeLong ( ) ; } } tstring uncompressed ; uncompressed . resize_uninitialized ( total_size ) ; char * position = uncompressed . mdata ( ) ; int non_memcpy_component_index = 0 ; for ( auto & component : element ) { CompressedComponentMetadata * metadata = out -> mutable_component_metadata ( ) -> Add ( ) ; metadata -> set_dtype ( component . dtype ( ) ) ; component . shape ( ) . AsProto ( metadata -> mutable_tensor_shape ( ) ) ; if ( DataTypeCanUseMemcpy ( component . dtype ( ) ) ) { const TensorBuffer * buffer = DMAHelper : : buffer ( & component ) ; <S2SV_StartBug> memcpy ( position , buffer -> data ( ) , buffer -> size ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> metadata -> set_tensor_size_bytes ( buffer -> size ( ) ) ; <S2SV_EndBug> } else { TensorProto & proto = non_memcpy_components [ non_memcpy_component_index ++ ] ; proto . SerializeToArray ( position , proto . ByteSizeLong ( ) ) ; metadata -> set_tensor_size_bytes ( proto . ByteSizeLong ( ) ) ; } position += metadata -> tensor_size_bytes ( ) ; } DCHECK_EQ ( position , uncompressed . mdata ( ) + total_size ) ; if ( ! port : : Snappy_Compress ( uncompressed . mdata ( ) , total_size , out -> mutable_data ( ) ) ) { return errors : : Internal ( \"Failed<S2SV_blank>to<S2SV_blank>compress<S2SV_blank>using<S2SV_blank>snappy.\" ) ; } VLOG ( 3 ) << \"Compressed<S2SV_blank>element<S2SV_blank>from<S2SV_blank>\" << total_size << \"<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>\" << out -> data ( ) . size ( ) << \"<S2SV_blank>bytes\" ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ) ) { const TensorBuffer * buffer = DMAHelper : : buffer ( & component ) ; if ( buffer ) { total_size += buffer <S2SV_ModEnd> -> size ( <S2SV_ModStart> ( ) ; } <S2SV_ModStart> component ) ; if ( buffer ) { <S2SV_ModStart> ) ) ; }"}
{"source": "CWE-369 void Compute ( OpKernelContext * ctx ) override { const Tensor * a_indices_t , * a_values_t , * a_shape_t , * b_indices_t , * b_values_t , * b_shape_t ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"a_indices\" , & a_indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"a_values\" , & a_values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"a_shape\" , & a_shape_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"b_indices\" , & b_indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"b_values\" , & b_values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"b_shape\" , & b_shape_t ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( a_indices_t -> shape ( ) ) && TensorShapeUtils : : IsMatrix ( b_indices_t -> shape ( ) ) , errors : : InvalidArgument ( \"Inputs<S2SV_blank>a_indices<S2SV_blank>and<S2SV_blank>b_indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>\" \"matrices<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shapes:<S2SV_blank>\" , a_indices_t -> shape ( ) . DebugString ( ) , \",<S2SV_blank>\" , b_indices_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( a_values_t -> shape ( ) ) && TensorShapeUtils : : IsVector ( b_values_t -> shape ( ) ) , errors : : InvalidArgument ( \"Inputs<S2SV_blank>a_values<S2SV_blank>and<S2SV_blank>b_values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>vectors<S2SV_blank>\" \"but<S2SV_blank>received<S2SV_blank>shapes:<S2SV_blank>\" , a_values_t -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b_values_t -> shape ( ) . DebugString ( ) ) ) ; const int64 a_nnz = a_indices_t -> dim_size ( 0 ) ; const int64 b_nnz = b_indices_t -> dim_size ( 0 ) ; const auto a_values = a_values_t -> vec < T > ( ) ; const auto b_values = b_values_t -> vec < T > ( ) ; OP_REQUIRES ( ctx , a_values . size ( ) == a_nnz && b_values . size ( ) == b_nnz , errors : : InvalidArgument ( \"Expected<S2SV_blank>\" , a_nnz , \"<S2SV_blank>and<S2SV_blank>\" , b_nnz , \"<S2SV_blank>non-empty<S2SV_blank>input<S2SV_blank>values,<S2SV_blank>got<S2SV_blank>\" , a_values . size ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b_values . size ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( a_shape_t -> shape ( ) ) && TensorShapeUtils : : IsVector ( b_shape_t -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shapes<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shapes<S2SV_blank>\" , a_shape_t -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b_shape_t -> shape ( ) . DebugString ( ) ) ) ; <S2SV_StartBug> OP_REQUIRES ( ctx , a_shape_t -> IsSameSize ( * b_shape_t ) , <S2SV_EndBug> errors : : InvalidArgument ( \"Operands<S2SV_blank>do<S2SV_blank>not<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>ranks;<S2SV_blank>got<S2SV_blank>shapes:<S2SV_blank>\" , a_shape_t -> SummarizeValue ( 10 ) , \"<S2SV_blank>and<S2SV_blank>\" , b_shape_t -> SummarizeValue ( 10 ) ) ) ; const auto a_shape = a_shape_t -> flat < int64 > ( ) ; const auto b_shape = b_shape_t -> flat < int64 > ( ) ; for ( int i = 0 ; i < a_shape_t -> NumElements ( ) ; ++ i ) { OP_REQUIRES ( ctx , a_shape ( i ) == b_shape ( i ) , errors : : InvalidArgument ( \"Operands\\'<S2SV_blank>shapes<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match:<S2SV_blank>got<S2SV_blank>\" , a_shape ( i ) , \"<S2SV_blank>and<S2SV_blank>\" , b_shape ( i ) , \"<S2SV_blank>for<S2SV_blank>dimension<S2SV_blank>\" , i ) ) ; } <S2SV_StartBug> OP_REQUIRES ( <S2SV_EndBug> ctx , a_indices_t -> dim_size ( 1 ) == b_indices_t -> dim_size ( 1 ) , errors : : InvalidArgument ( \"Indices\\'<S2SV_blank>dimensions<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match:<S2SV_blank>got<S2SV_blank>\" , a_indices_t -> dim_size ( 1 ) , \"<S2SV_blank>and<S2SV_blank>\" , b_indices_t -> dim_size ( 1 ) , \"<S2SV_blank>for<S2SV_blank>the<S2SV_blank>second<S2SV_blank>dimension.\" ) ) ; const int num_dims = a_indices_t -> dim_size ( 1 ) ; const auto a_indices_mat = a_indices_t -> matrix < int64 > ( ) ; const auto b_indices_mat = b_indices_t -> matrix < int64 > ( ) ; std : : vector < T > a_augmented_values , b_augmented_values ; std : : vector < std : : pair < bool , int64 >> entries_to_copy ; UnionSparseIndicesAndValues ( a_indices_mat , a_values , a_nnz , b_indices_mat , b_values , b_nnz , num_dims , & a_augmented_values , & b_augmented_values , & entries_to_copy ) ; const int64 sum_nnz = a_augmented_values . size ( ) ; Tensor * output_indices_t , * output_values_t ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { sum_nnz , num_dims } ) , & output_indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , TensorShape ( { sum_nnz } ) , & output_values_t ) ) ; auto output_indices_mat = output_indices_t -> matrix < int64 > ( ) ; for ( int64 i = 0 ; i < sum_nnz ; ++ i ) { const bool from_a = entries_to_copy [ i ] . first ; const int64 idx = entries_to_copy [ i ] . second ; output_indices_mat . chip < 0 > ( i ) = from_a ? a_indices_mat . chip < 0 > ( idx ) : b_indices_mat . chip < 0 > ( idx ) ; } using UnalignedTensorMap = Eigen : : TensorMap < Eigen : : Tensor < const T , 1 , Eigen : : RowMajor > , Eigen : : Unaligned > ; auto a_augmented_values_t = UnalignedTensorMap ( a_augmented_values . data ( ) , sum_nnz ) ; auto b_augmented_values_t = UnalignedTensorMap ( b_augmented_values . data ( ) , sum_nnz ) ; output_values_t -> flat < T > ( ) . device ( ctx -> eigen_device < Device > ( ) ) = a_augmented_values_t . binaryExpr ( b_augmented_values_t , typename Functor : : func ( ) ) ; }", "target": "<S2SV_ModStart> ) ) ; const int num_dims = a_indices_t -> dim_size ( 1 ) ; OP_REQUIRES ( ctx , a_shape_t -> NumElements ( ) == num_dims , errors : : InvalidArgument ( \"Second<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>a_indices<S2SV_blank>and<S2SV_blank>length<S2SV_blank>of<S2SV_blank>\" \"a_shape<S2SV_blank>must<S2SV_blank>match,<S2SV_blank>got<S2SV_blank>\" , num_dims , \"<S2SV_blank>and<S2SV_blank>\" , a_shape_t -> NumElements ( ) ) ) ; OP_REQUIRES ( ctx , num_dims > 0 , errors : : InvalidArgument ( \"Tensors<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty\" ) ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> const auto a_indices_mat"}
{"source": "CWE-703 bool matches ( const Http : : RequestHeaderMap & headers ) const override { <S2SV_StartBug> if ( BaseMatcherImpl : : matchRoute ( headers ) ) { <S2SV_EndBug> const Http : : HeaderString & path = headers . Path ( ) -> value ( ) ; const absl : : string_view query_string = Http : : Utility : : findQueryStringStart ( path ) ; absl : : string_view path_view = path . getStringView ( ) ; path_view . remove_suffix ( query_string . length ( ) ) ; if ( path_matcher_ -> match ( path_view ) ) { ENVOY_LOG ( debug , \"Regex<S2SV_blank>requirement<S2SV_blank>\\'{}\\'<S2SV_blank>matched.\" , regex_str_ ) ; return true ; } } return false ; }", "target": "<S2SV_ModStart> ) ) { if ( headers . Path ( ) == nullptr ) { return false ; }"}
{"source": "CWE-787 void M_LoadDefaults ( void ) { int i ; int len ; FILE * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = M_CheckParm ( \"-config\" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( \"\\tdefault<S2SV_blank>file:<S2SV_blank>%s\\\\n\" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , \"r\" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ; <S2SV_StartBug> if ( fscanf ( f , \"%79s<S2SV_blank>%[^\\\\n]\\\\n\" , def , strparm ) == 2 ) <S2SV_EndBug> { if ( strparm [ 0 ] == \\'\"\\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , \"%x\" , & parm ) ; else sscanf ( strparm , \"%i\" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }", "target": "<S2SV_ModStart> ( f , \"%79s<S2SV_blank>%99[^\\\\n]\\\\n\" <S2SV_ModEnd> , def ,"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { typedef Eigen : : Map < const Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> ConstEigenMatrixMap ; typedef Eigen : : Map < Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> EigenMatrixMap ; constexpr int tensor_in_and_out_dims = 4 ; const Tensor & tensor_in = context -> input ( 0 ) ; OP_REQUIRES ( context , tensor_in . dims ( ) == tensor_in_and_out_dims , errors : : InvalidArgument ( \"tensor_in<S2SV_blank>must<S2SV_blank>be<S2SV_blank>4-dimensional\" ) ) ; std : : vector < int > input_size ( tensor_in_and_out_dims ) ; std : : vector < int > output_size ( tensor_in_and_out_dims ) ; for ( int i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { input_size [ i ] = tensor_in . dim_size ( i ) ; <S2SV_StartBug> } <S2SV_EndBug> for ( int i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { output_size [ i ] = static_cast < int > ( std : : floor ( input_size [ i ] / pooling_ratio_ [ i ] ) ) ; DCHECK_GT ( output_size [ i ] , 0 ) ; } std : : vector < int64 > row_cum_seq ; std : : vector < int64 > col_cum_seq ; GuardedPhiloxRandom generator ; generator . Init ( seed_ , seed2_ ) ; row_cum_seq = GeneratePoolingSequence ( input_size [ 1 ] , output_size [ 1 ] , & generator , pseudo_random_ ) ; col_cum_seq = GeneratePoolingSequence ( input_size [ 2 ] , output_size [ 2 ] , & generator , pseudo_random_ ) ; Tensor * output_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { output_size [ 0 ] , output_size [ 1 ] , output_size [ 2 ] , output_size [ 3 ] } ) , & output_tensor ) ) ; Tensor * output_row_seq_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , TensorShape ( { static_cast < int64 > ( row_cum_seq . size ( ) ) } ) , & output_row_seq_tensor ) ) ; Tensor * output_col_seq_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , TensorShape ( { static_cast < int64 > ( col_cum_seq . size ( ) ) } ) , & output_col_seq_tensor ) ) ; ConstEigenMatrixMap in_mat ( tensor_in . flat < T > ( ) . data ( ) , input_size [ 3 ] , input_size [ 2 ] * input_size [ 1 ] * input_size [ 0 ] ) ; EigenMatrixMap out_mat ( output_tensor -> flat < T > ( ) . data ( ) , output_size [ 3 ] , output_size [ 2 ] * output_size [ 1 ] * output_size [ 0 ] ) ; Eigen : : Matrix < T , Eigen : : Dynamic , 1 > out_count ( out_mat . cols ( ) ) ; out_mat . setZero ( ) ; out_count . setZero ( ) ; auto output_row_seq_flat = output_row_seq_tensor -> flat < int64 > ( ) ; auto output_col_seq_flat = output_col_seq_tensor -> flat < int64 > ( ) ; for ( int i = 0 ; i < row_cum_seq . size ( ) ; ++ i ) { output_row_seq_flat ( i ) = row_cum_seq [ i ] ; } for ( int i = 0 ; i < col_cum_seq . size ( ) ; ++ i ) { output_col_seq_flat ( i ) = col_cum_seq [ i ] ; } const int64 row_max = input_size [ 1 ] - 1 ; const int64 col_max = input_size [ 2 ] - 1 ; for ( int64 b = 0 ; b < input_size [ 0 ] ; ++ b ) { for ( int64 hs = 0 ; hs < row_cum_seq . size ( ) - 1 ; ++ hs ) { const int64 row_start = row_cum_seq [ hs ] ; int64 row_end = overlapping_ ? row_cum_seq [ hs + 1 ] : row_cum_seq [ hs + 1 ] - 1 ; row_end = std : : min ( row_end , row_max ) ; for ( int64 ws = 0 ; ws < col_cum_seq . size ( ) - 1 ; ++ ws ) { const int64 out_offset = ( b * output_size [ 1 ] + hs ) * output_size [ 2 ] + ws ; const int64 col_start = col_cum_seq [ ws ] ; int64 col_end = overlapping_ ? col_cum_seq [ ws + 1 ] : col_cum_seq [ ws + 1 ] - 1 ; col_end = std : : min ( col_end , col_max ) ; for ( int64 h = row_start ; h <= row_end ; ++ h ) { for ( int64 w = col_start ; w <= col_end ; ++ w ) { const int64 in_offset = ( b * input_size [ 1 ] + h ) * input_size [ 2 ] + w ; out_mat . col ( out_offset ) += in_mat . col ( in_offset ) ; out_count ( out_offset ) ++ ; } } } } } DCHECK_GT ( out_count . minCoeff ( ) , 0 ) ; out_mat . array ( ) . rowwise ( ) /= out_count . transpose ( ) . array ( ) ; }", "target": "<S2SV_ModStart> i ) ; OP_REQUIRES ( context , pooling_ratio_ [ i ] <= input_size [ i ] , errors : : InvalidArgument ( \"Pooling<S2SV_blank>ratio<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>input<S2SV_blank>tensor<S2SV_blank>dim<S2SV_blank>size.\" ) ) ;"}
{"source": "CWE-787 static void SpatialMaxPoolWithArgMaxHelper ( OpKernelContext * context , Tensor * output , Tensor * output_arg_max , Tensor * input_backprop , const Tensor & tensor_in , const Tensor & out_backprop , const PoolParameters & params , const bool include_batch_in_index ) { if ( input_backprop != nullptr ) { OP_REQUIRES ( context , include_batch_in_index , errors : : Internal ( \"SpatialMaxPoolWithArgMaxHelper<S2SV_blank>requires<S2SV_blank>include_batch_in_index<S2SV_blank>\" \"to<S2SV_blank>be<S2SV_blank>True<S2SV_blank>when<S2SV_blank>input_backprop<S2SV_blank>!=<S2SV_blank>nullptr\" ) ) ; OP_REQUIRES ( context , ( std : : is_same < Targmax , int64 > : : value ) , errors : : Internal ( \"SpatialMaxPoolWithArgMaxHelper<S2SV_blank>requires<S2SV_blank>Targmax<S2SV_blank>\" \"to<S2SV_blank>be<S2SV_blank>int64<S2SV_blank>when<S2SV_blank>input_backprop<S2SV_blank>!=<S2SV_blank>nullptr\" ) ) ; } typedef Eigen : : Map < const Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> ConstEigenMatrixMap ; typedef Eigen : : Map < Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> EigenMatrixMap ; typedef Eigen : : Map < Eigen : : Matrix < Targmax , Eigen : : Dynamic , Eigen : : Dynamic >> EigenIndexMatrixMap ; ConstEigenMatrixMap in_mat ( tensor_in . flat < T > ( ) . data ( ) , params . depth , params . tensor_in_cols * params . tensor_in_rows * params . tensor_in_batch ) ; EigenMatrixMap out_mat ( output -> flat < T > ( ) . data ( ) , params . depth , params . out_width * params . out_height * params . tensor_in_batch ) ; EigenIndexMatrixMap out_arg_max_mat ( output_arg_max -> flat < Targmax > ( ) . data ( ) , params . depth , params . out_width * params . out_height * params . tensor_in_batch ) ; const DeviceBase : : CpuWorkerThreads & worker_threads = * ( context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ) ; auto shard = [ & params , & in_mat , & out_mat , & out_arg_max_mat , & input_backprop , & output_arg_max , & out_backprop , include_batch_in_index ] ( int64 start , int64 limit ) { const int32 depth = params . depth ; const int32 in_rows = params . tensor_in_rows ; const int32 in_cols = params . tensor_in_cols ; const int32 pad_top = params . pad_top ; const int32 pad_left = params . pad_left ; const int32 window_rows = params . window_rows ; const int32 window_cols = params . window_cols ; const int32 row_stride = params . row_stride ; const int32 col_stride = params . col_stride ; const int32 out_height = params . out_height ; const int32 out_width = params . out_width ; { const int32 output_image_size = out_height * out_width * depth ; EigenMatrixMap out_shard ( out_mat . data ( ) + start * output_image_size , 1 , ( limit - start ) * output_image_size ) ; out_shard . setConstant ( Eigen : : NumTraits < T > : : lowest ( ) ) ; EigenIndexMatrixMap out_arg_max_shard ( out_arg_max_mat . data ( ) + start * output_image_size , 1 , ( limit - start ) * output_image_size ) ; out_arg_max_shard . setConstant ( kInvalidMaxPoolingIndex ) ; } for ( int64 b = start ; b < limit ; ++ b ) { for ( int h = 0 ; h < in_rows ; ++ h ) { for ( int w = 0 ; w < in_cols ; ++ w ) { const int hpad = h + pad_top ; const int wpad = w + pad_left ; const int h_start = ( hpad < window_rows ) ? 0 : ( hpad - window_rows ) / row_stride + 1 ; const int h_end = std : : min ( hpad / row_stride + 1 , out_height ) ; const int w_start = ( wpad < window_cols ) ? 0 : ( wpad - window_cols ) / col_stride + 1 ; const int w_end = std : : min ( wpad / col_stride + 1 , out_width ) ; const int64 in_index = ( b * in_rows + h ) * in_cols + w ; for ( int ph = h_start ; ph < h_end ; ++ ph ) { const int64 out_index_base = ( b * out_height + ph ) * out_width ; for ( int pw = w_start ; pw < w_end ; ++ pw ) { const int64 out_index = out_index_base + pw ; for ( int d = 0 ; d < depth ; ++ d ) { const T & input_ref = in_mat . coeffRef ( d , in_index ) ; T & output_ref = out_mat . coeffRef ( d , out_index ) ; Targmax & out_arg_max_ref = out_arg_max_mat . coeffRef ( d , out_index ) ; if ( output_ref < input_ref || out_arg_max_ref == kInvalidMaxPoolingIndex ) { output_ref = input_ref ; if ( include_batch_in_index ) { out_arg_max_ref = in_index * depth + d ; } else { out_arg_max_ref = ( h * in_cols + w ) * depth + d ; } } } } } } } } if ( input_backprop != nullptr ) { auto input_backprop_flat = input_backprop -> flat < T > ( ) ; auto out_arg_max_flat = output_arg_max -> flat < int64 > ( ) ; auto out_backprop_flat = out_backprop . flat < T > ( ) ; const int64 in_size = in_rows * in_cols * depth ; const int64 in_start = start * in_size ; const int64 in_end = limit * in_size ; EigenMatrixMap in_shard ( input_backprop_flat . data ( ) + in_start , 1 , in_end - in_start ) ; in_shard . setConstant ( T ( 0 ) ) ; const int out_size = out_height * out_width * depth ; const int out_start = start * out_size ; const int out_end = limit * out_size ; for ( int index = out_start ; index < out_end ; ++ index ) { int input_backprop_index = out_arg_max_flat ( index ) ; FastBoundsCheck ( input_backprop_index - in_start , in_end - in_start ) ; <S2SV_StartBug> input_backprop_flat ( input_backprop_index ) += out_backprop_flat ( index ) ; <S2SV_EndBug> } } <S2SV_StartBug> } ; <S2SV_EndBug> const int64 shard_cost = params . tensor_in_rows * params . tensor_in_cols * params . depth * params . window_rows * params . window_cols ; Shard ( worker_threads . num_threads , worker_threads . workers , params . tensor_in_batch , shard_cost , shard ) ; }", "target": "<S2SV_ModStart> in_start ) ; if ( index < out_backprop . NumElements ( ) ) { <S2SV_ModStart> } } } }"}
{"source": "CWE-125 extern \"C\" int64_t enc_untrusted_syscall ( int sysno , ... ) { if ( ! enc_is_error_handler_set ( ) ) { enc_set_error_handler ( default_error_handler ) ; } asylo : : system_call : : SystemCallDescriptor descriptor { sysno } ; if ( ! descriptor . is_valid ( ) ) { error_handler ( \"system_call.cc:<S2SV_blank>Invalid<S2SV_blank>SystemCallDescriptor<S2SV_blank>encountered.\" ) ; } std : : array < uint64_t , asylo : : system_call : : kParameterMax > parameters ; va_list args ; va_start ( args , sysno ) ; for ( int i = 0 ; i < descriptor . parameter_count ( ) ; i ++ ) { parameters [ i ] = va_arg ( args , uint64_t ) ; } va_end ( args ) ; asylo : : primitives : : Extent request ; asylo : : primitives : : PrimitiveStatus status ; status = asylo : : system_call : : SerializeRequest ( sysno , parameters , & request ) ; if ( ! status . ok ( ) ) { error_handler ( \"system_call.cc:<S2SV_blank>Encountered<S2SV_blank>serialization<S2SV_blank>error<S2SV_blank>when<S2SV_blank>serializing<S2SV_blank>\" \"syscall<S2SV_blank>parameters.\" ) ; } std : : unique_ptr < uint8_t , MallocDeleter > request_owner ( request . As < uint8_t > ( ) ) ; uint8_t * response_buffer ; size_t response_size ; if ( ! enc_is_syscall_dispatcher_set ( ) ) { error_handler ( \"system_.cc:<S2SV_blank>system<S2SV_blank>call<S2SV_blank>dispatcher<S2SV_blank>not<S2SV_blank>set.\" ) ; } status = global_syscall_callback ( request . As < uint8_t > ( ) , request . size ( ) , & response_buffer , & response_size ) ; if ( ! status . ok ( ) ) { error_handler ( \"system_call.cc:<S2SV_blank>Callback<S2SV_blank>from<S2SV_blank>syscall<S2SV_blank>dispatcher<S2SV_blank>was<S2SV_blank>unsuccessful.\" ) ; } std : : unique_ptr < uint8_t , MallocDeleter > response_owner ( response_buffer ) ; if ( ! response_buffer ) { error_handler ( \"system_call.cc:<S2SV_blank>null<S2SV_blank>response<S2SV_blank>buffer<S2SV_blank>received<S2SV_blank>for<S2SV_blank>the<S2SV_blank>syscall.\" ) ; } auto response_reader = asylo : : system_call : : MessageReader ( { response_buffer , response_size } ) ; <S2SV_StartBug> const asylo : : primitives : : PrimitiveStatus response_status = <S2SV_EndBug> response_reader . Validate ( ) ; if ( ! response_status . ok ( ) ) { error_handler ( \"system_call.cc:<S2SV_blank>Error<S2SV_blank>deserializing<S2SV_blank>response<S2SV_blank>buffer<S2SV_blank>into<S2SV_blank>response<S2SV_blank>\" \"reader.\" ) ; } for ( int i = 0 ; i < asylo : : system_call : : kParameterMax ; i ++ ) { asylo : : system_call : : ParameterDescriptor parameter = descriptor . parameter ( i ) ; if ( parameter . is_out ( ) ) { size_t size ; if ( parameter . is_fixed ( ) ) { size = parameter . size ( ) ; } else { size = parameters [ parameter . size ( ) ] * parameter . element_size ( ) ; } const void * src = response_reader . parameter_address ( i ) ; void * dst = reinterpret_cast < void * > ( parameters [ i ] ) ; if ( dst != nullptr ) { memcpy ( dst , src , size ) ; } } } uint64_t result = response_reader . header ( ) -> result ; if ( static_cast < int64_t > ( result ) == - 1 ) { int klinux_errno = response_reader . header ( ) -> error_number ; if ( klinux_errno != 0 ) { errno = FromkLinuxErrno ( klinux_errno ) ; } } return result ; }", "target": "<S2SV_ModStart> } ) ; if ( response_reader . sysno ( ) != sysno ) { error_handler ( \"system_call.cc:<S2SV_blank>Unexpected<S2SV_blank>sysno<S2SV_blank>in<S2SV_blank>response\" ) ; }"}
{"source": "CWE-703 parseNormalModeParameters ( IsoPresentation * self , uint8_t * buffer , int totalLength , int bufPos ) { int endPos = bufPos + totalLength ; self -> calledPresentationSelector . size = 0 ; self -> callingPresentationSelector . size = 0 ; bool hasUserData = false ; while ( bufPos < endPos ) { uint8_t tag = buffer [ bufPos ++ ] ; int len ; if ( bufPos == endPos ) { if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>invalid<S2SV_blank>message\\\\n\" ) ; return - 1 ; } bufPos = BerDecoder_decodeLength ( buffer , & len , bufPos , endPos ) ; if ( bufPos < 0 ) { if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>wrong<S2SV_blank>parameter<S2SV_blank>length\\\\n\" ) ; return - 1 ; } switch ( tag ) { case 0x81 : if ( len > 16 ) { if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>calling-presentation-sel<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; } else { self -> callingPresentationSelector . size = len ; int i ; for ( i = 0 ; i < len ; i ++ ) self -> callingPresentationSelector . value [ i ] = buffer [ bufPos + i ] ; } bufPos += len ; break ; case 0x82 : if ( len > 16 ) { if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>called-presentation-sel<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; } else { self -> calledPresentationSelector . size = len ; int i ; for ( i = 0 ; i < len ; i ++ ) self -> calledPresentationSelector . value [ i ] = buffer [ bufPos + i ] ; } bufPos += len ; break ; case 0x83 : if ( len > 16 ) { if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>responding-presentation-sel<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; } bufPos += len ; break ; case 0xa4 : if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>pcd<S2SV_blank>list\\\\n\" ) ; bufPos = parsePresentationContextDefinitionList ( self , buffer , len , bufPos ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case 0xa5 : bufPos += len ; break ; case 0x61 : if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>user-data\\\\n\" ) ; bufPos = parseFullyEncodedData ( self , buffer , len , bufPos ) ; if ( bufPos < 0 ) return - 1 ; <S2SV_StartBug> if ( self -> nextPayload . size > 0 ) <S2SV_EndBug> hasUserData = true ; break ; case 0x00 : break ; default : if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>unknown<S2SV_blank>tag<S2SV_blank>in<S2SV_blank>normal-mode\\\\n\" ) ; bufPos += len ; break ; } } if ( hasUserData == false ) { if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>user-data<S2SV_blank>is<S2SV_blank>missing\\\\n\" ) ; return - 1 ; } return bufPos ; }", "target": "<S2SV_ModStart> bufPos ) ; <S2SV_ModEnd> if ( bufPos <S2SV_ModStart> - 1 ; break ; case 0xa5 : bufPos += len ; break ; case 0x61 : if ( DEBUG_PRES ) printf ( \"PRES:<S2SV_blank>user-data\\\\n\" ) ; bufPos = parseFullyEncodedData ( self , buffer , len , bufPos ) ; if ( bufPos < 0 ) return - 1 ;"}
{"source": "CWE-476 # ifndef GPAC_DISABLE_ISOM_HINTING void dump_isom_sdp ( GF_ISOFile * file , char * inName , Bool is_final_name ) { const char * sdp ; u32 size , i ; FILE * dump ; if ( inName ) { char szBuf [ 1024 ] ; strcpy ( szBuf , inName ) ; if ( ! is_final_name ) { char * ext = strchr ( szBuf , '.' ) ; if ( ext ) ext [ 0 ] = 0 ; strcat ( szBuf , \"_sdp.txt\" ) ; } dump = gf_fopen ( szBuf , \"wt\" ) ; if ( ! dump ) { fprintf ( stderr , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>dumping\\\\n\" , szBuf ) ; return ; } } else { dump = stdout ; fprintf ( dump , \"*<S2SV_blank>File<S2SV_blank>SDP<S2SV_blank>content<S2SV_blank>*\\\\n\\\\n\" ) ; } gf_isom_sdp_get ( file , & sdp , & size ) ; <S2SV_StartBug> fprintf ( dump , \"%s\" , sdp ) ; <S2SV_EndBug> fprintf ( dump , \"\\\\r\\\\n\" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; gf_isom_sdp_track_get ( file , i + 1 , & sdp , & size ) ; fprintf ( dump , \"%s\" , sdp ) ; } fprintf ( dump , \"\\\\n\\\\n\" ) ;", "target": "<S2SV_ModStart> size ) ; if ( sdp && size )"}
{"source": "CWE-125 void Compute ( OpKernelContext * ctx ) override { const Tensor & shape_tensor = ctx -> input ( 0 ) ; const Tensor & means_tensor = ctx -> input ( 1 ) ; const Tensor & stddevs_tensor = ctx -> input ( 2 ) ; const Tensor & minvals_tensor = ctx -> input ( 3 ) ; const Tensor & maxvals_tensor = ctx -> input ( 4 ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( shape_tensor . shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector,<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , <S2SV_StartBug> shape_tensor . shape ( ) . DebugString ( ) ) ) ; <S2SV_EndBug> int32 num_batches = shape_tensor . flat < int32 > ( ) ( 0 ) ; int32 samples_per_batch = 1 ; const int32 num_dims = shape_tensor . dim_size ( 0 ) ; for ( int32 i = 1 ; i < num_dims ; i ++ ) { samples_per_batch *= shape_tensor . flat < int32 > ( ) ( i ) ; } const int32 num_elements = num_batches * samples_per_batch ; auto shape_vec = shape_tensor . flat < int32 > ( ) ; TensorShape tensor_shape ; OP_REQUIRES_OK ( ctx , TensorShapeUtils : : MakeShape ( shape_vec . data ( ) , shape_vec . size ( ) , & tensor_shape ) ) ; Tensor * samples_tensor ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , tensor_shape , & samples_tensor ) ) ; OP_REQUIRES ( ctx , means_tensor . dims ( ) <= 1 , errors : : InvalidArgument ( \"Input<S2SV_blank>means<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>or<S2SV_blank>vector,<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , means_tensor . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , stddevs_tensor . dims ( ) <= 1 , errors : : InvalidArgument ( \"Input<S2SV_blank>stddevs<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>or<S2SV_blank>vector,<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , stddevs_tensor . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , minvals_tensor . dims ( ) <= 1 , errors : : InvalidArgument ( \"Input<S2SV_blank>minvals<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>or<S2SV_blank>vector,<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , minvals_tensor . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , maxvals_tensor . dims ( ) <= 1 , errors : : InvalidArgument ( \"Input<S2SV_blank>maxvals<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>or<S2SV_blank>vector,<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , maxvals_tensor . shape ( ) . DebugString ( ) ) ) ; if ( ( means_tensor . dims ( ) == 0 || means_tensor . dim_size ( 0 ) == 1 ) && ( stddevs_tensor . dims ( ) == 0 || stddevs_tensor . dim_size ( 0 ) == 1 ) && minvals_tensor . dims ( ) == 0 && maxvals_tensor . dims ( ) == 0 ) { int32 size = num_batches * samples_per_batch ; int32 adjusted_samples = kDesiredBatchSize ; int32 adjusted_batches = Eigen : : divup ( size , adjusted_samples ) ; num_batches = adjusted_batches ; samples_per_batch = adjusted_samples ; } else { OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( means_tensor . shape ( ) ) || means_tensor . dim_size ( 0 ) == 1 || means_tensor . dim_size ( 0 ) == num_batches , errors : : InvalidArgument ( \"Input<S2SV_blank>means<S2SV_blank>should<S2SV_blank>have<S2SV_blank>length<S2SV_blank>1<S2SV_blank>or<S2SV_blank>shape[0],<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , means_tensor . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( stddevs_tensor . shape ( ) ) || stddevs_tensor . dim_size ( 0 ) == 1 || stddevs_tensor . dim_size ( 0 ) == num_batches , errors : : InvalidArgument ( \"Input<S2SV_blank>stddevs<S2SV_blank>should<S2SV_blank>have<S2SV_blank>length<S2SV_blank>1<S2SV_blank>or<S2SV_blank>shape[0],<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , stddevs_tensor . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( minvals_tensor . shape ( ) ) || minvals_tensor . dim_size ( 0 ) == 1 || minvals_tensor . dim_size ( 0 ) == num_batches , errors : : InvalidArgument ( \"Input<S2SV_blank>minvals<S2SV_blank>should<S2SV_blank>have<S2SV_blank>length<S2SV_blank>1<S2SV_blank>or<S2SV_blank>shape[0],<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , minvals_tensor . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( maxvals_tensor . shape ( ) ) || maxvals_tensor . dim_size ( 0 ) == 1 || maxvals_tensor . dim_size ( 0 ) == num_batches , errors : : InvalidArgument ( \"Input<S2SV_blank>maxvals<S2SV_blank>should<S2SV_blank>have<S2SV_blank>length<S2SV_blank>1<S2SV_blank>or<S2SV_blank>shape[0],<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , maxvals_tensor . shape ( ) . DebugString ( ) ) ) ; } auto truncFunctor = functor : : TruncatedNormalFunctor < Device , T > ( ) ; random : : PhiloxRandom rng = generator_ . ReserveSamples128 ( num_batches * 2 * functor : : kMaxIterations * ( samples_per_batch + 3 ) / 4 ) ; truncFunctor ( ctx , ctx -> eigen_device < Device > ( ) , num_batches , samples_per_batch , num_elements , means_tensor . flat < T > ( ) , stddevs_tensor . flat < T > ( ) , minvals_tensor . flat < T > ( ) , maxvals_tensor . flat < T > ( ) , rng , samples_tensor -> flat < T > ( ) ) ; }", "target": "<S2SV_ModStart> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , shape_tensor . NumElements ( ) > 0 , errors : : InvalidArgument ( \"Shape<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty,<S2SV_blank>got<S2SV_blank>\" , shape_tensor"}
{"source": "CWE-125 static bool checkreturn decode_pointer_field ( pb_istream_t * stream , pb_wire_type_t wire_type , pb_field_iter_t * iter ) { # ifndef PB_ENABLE_MALLOC PB_UNUSED ( wire_type ) ; PB_UNUSED ( iter ) ; PB_RETURN_ERROR ( stream , \"no<S2SV_blank>malloc<S2SV_blank>support\" ) ; # else pb_type_t type ; pb_decoder_t func ; type = iter -> pos -> type ; func = PB_DECODERS [ PB_LTYPE ( type ) ] ; switch ( PB_HTYPE ( type ) ) { case PB_HTYPE_REQUIRED : case PB_HTYPE_OPTIONAL : case PB_HTYPE_ONEOF : if ( PB_LTYPE ( type ) == PB_LTYPE_SUBMESSAGE && * ( void * * ) iter -> pData != NULL ) { pb_release_single_field ( iter ) ; } if ( PB_HTYPE ( type ) == PB_HTYPE_ONEOF ) { * ( pb_size_t * ) iter -> pSize = iter -> pos -> tag ; } if ( PB_LTYPE ( type ) == PB_LTYPE_STRING || PB_LTYPE ( type ) == PB_LTYPE_BYTES ) { return func ( stream , iter -> pos , iter -> pData ) ; } else { if ( ! allocate_field ( stream , iter -> pData , iter -> pos -> data_size , 1 ) ) return false ; initialize_pointer_field ( * ( void * * ) iter -> pData , iter ) ; return func ( stream , iter -> pos , * ( void * * ) iter -> pData ) ; } case PB_HTYPE_REPEATED : if ( wire_type == PB_WT_STRING && PB_LTYPE ( type ) <= PB_LTYPE_LAST_PACKABLE ) { bool status = true ; pb_size_t * size = ( pb_size_t * ) iter -> pSize ; size_t allocated_size = * size ; void * pItem ; pb_istream_t substream ; if ( ! pb_make_string_substream ( stream , & substream ) ) return false ; while ( substream . bytes_left ) { if ( ( size_t ) * size + 1 > allocated_size ) { allocated_size += ( substream . bytes_left - 1 ) / iter -> pos -> data_size + 1 ; if ( ! allocate_field ( & substream , iter -> pData , iter -> pos -> data_size , allocated_size ) ) { status = false ; break ; } } pItem = * ( char * * ) iter -> pData + iter -> pos -> data_size * ( * size ) ; initialize_pointer_field ( pItem , iter ) ; if ( ! func ( & substream , iter -> pos , pItem ) ) { status = false ; break ; } if ( * size == PB_SIZE_MAX ) { # ifndef PB_NO_ERRMSG stream -> errmsg = \"too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries\" ; # endif status = false ; break ; } ( * size ) ++ ; } if ( ! pb_close_string_substream ( stream , & substream ) ) return false ; return status ; } else { pb_size_t * size = ( pb_size_t * ) iter -> pSize ; void * pItem ; if ( * size == PB_SIZE_MAX ) PB_RETURN_ERROR ( stream , \"too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries\" ) ; <S2SV_StartBug> ( * size ) ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! allocate_field ( stream , iter -> pData , iter -> pos -> data_size , * size ) ) <S2SV_EndBug> return false ; <S2SV_StartBug> pItem = * ( char * * ) iter -> pData + iter -> pos -> data_size * ( * size - 1 ) ; <S2SV_EndBug> initialize_pointer_field ( pItem , iter ) ; return func ( stream , iter -> pos , pItem ) ; } default : PB_RETURN_ERROR ( stream , \"invalid<S2SV_blank>field<S2SV_blank>type\" ) ; } # endif }", "target": "<S2SV_ModStart> \"too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries\" ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> -> data_size , ( size_t ) ( * size + 1 ) <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( * size ) ; ( * size ) ++ <S2SV_ModEnd> ; initialize_pointer_field ("}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { typedef Eigen : : Map < const Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> ConstEigenMatrixMap ; typedef Eigen : : Map < Eigen : : Matrix < double , Eigen : : Dynamic , Eigen : : Dynamic >> EigenDoubleMatrixMap ; const Tensor & orig_input_tensor_shape = context -> input ( 0 ) ; OP_REQUIRES ( context , orig_input_tensor_shape . dims ( ) == 1 && orig_input_tensor_shape . NumElements ( ) == 4 , errors : : InvalidArgument ( \"original<S2SV_blank>input<S2SV_blank>tensor<S2SV_blank>shape<S2SV_blank>must<S2SV_blank>be\" \"1-dimensional<S2SV_blank>and<S2SV_blank>4<S2SV_blank>elements\" ) ) ; const Tensor & out_backprop = context -> input ( 1 ) ; const Tensor & row_seq_tensor = context -> input ( 2 ) ; const Tensor & col_seq_tensor = context -> input ( 3 ) ; const int64 out_batch = out_backprop . dim_size ( 0 ) ; const int64 out_rows = out_backprop . dim_size ( 1 ) ; const int64 out_cols = out_backprop . dim_size ( 2 ) ; const int64 out_depth = out_backprop . dim_size ( 3 ) ; <S2SV_StartBug> auto row_seq_tensor_flat = row_seq_tensor . flat < int64 > ( ) ; <S2SV_EndBug> auto col_seq_tensor_flat = col_seq_tensor . flat < int64 > ( ) ; auto orig_input_tensor_shape_flat = orig_input_tensor_shape . flat < int64 > ( ) ; const int64 in_batch = orig_input_tensor_shape_flat ( 0 ) ; const int64 in_rows = orig_input_tensor_shape_flat ( 1 ) ; const int64 in_cols = orig_input_tensor_shape_flat ( 2 ) ; const int64 in_depth = orig_input_tensor_shape_flat ( 3 ) ; constexpr int tensor_in_and_out_dims = 4 ; TensorShape in_shape ; for ( auto i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { in_shape . AddDim ( orig_input_tensor_shape_flat ( i ) ) ; } Tensor in_backprop_tensor_temp ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_temp ( { 0 } , DataTypeToEnum < double > : : v ( ) , in_shape , & in_backprop_tensor_temp ) ) ; in_backprop_tensor_temp . flat < double > ( ) . setZero ( ) ; EigenDoubleMatrixMap in_backprop_tensor_temp_mat ( in_backprop_tensor_temp . flat < double > ( ) . data ( ) , in_depth , in_cols * in_rows * in_batch ) ; ConstEigenMatrixMap out_backprop_mat ( out_backprop . flat < T > ( ) . data ( ) , out_depth , out_cols * out_rows * out_batch ) ; const int64 in_max_row_index = in_rows - 1 ; const int64 in_max_col_index = in_cols - 1 ; for ( int64 b = 0 ; b < out_batch ; ++ b ) { for ( int64 r = 0 ; r < out_rows ; ++ r ) { const int64 in_row_start = row_seq_tensor_flat ( r ) ; int64 in_row_end = overlapping_ ? row_seq_tensor_flat ( r + 1 ) : row_seq_tensor_flat ( r + 1 ) - 1 ; in_row_end = std : : min ( in_row_end , in_max_row_index ) ; for ( int64 c = 0 ; c < out_cols ; ++ c ) { const int64 in_col_start = col_seq_tensor_flat ( c ) ; int64 in_col_end = overlapping_ ? col_seq_tensor_flat ( c + 1 ) : col_seq_tensor_flat ( c + 1 ) - 1 ; in_col_end = std : : min ( in_col_end , in_max_col_index ) ; const int64 num_elements_in_pooling_cell = ( in_row_end - in_row_start + 1 ) * ( in_col_end - in_col_start + 1 ) ; const int64 out_index = ( b * out_rows + r ) * out_cols + c ; for ( int64 in_r = in_row_start ; in_r <= in_row_end ; ++ in_r ) { for ( int64 in_c = in_col_start ; in_c <= in_col_end ; ++ in_c ) { const int64 in_index = ( b * in_rows + in_r ) * in_cols + in_c ; for ( int64 d = 0 ; d < out_depth ; ++ d ) { const double out_backprop_element = static_cast < double > ( out_backprop_mat . coeffRef ( d , out_index ) ) ; double & in_backprop_ref = in_backprop_tensor_temp_mat . coeffRef ( d , in_index ) ; in_backprop_ref += out_backprop_element / num_elements_in_pooling_cell ; } } } } } } Tensor * in_backprop_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 0 , in_shape , & in_backprop_tensor ) ) ; auto in_backprop_tensor_flat = in_backprop_tensor -> flat < T > ( ) ; auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp . flat < double > ( ) ; for ( int64 i = 0 ; i < in_backprop_tensor_flat . size ( ) ; ++ i ) { in_backprop_tensor_flat ( i ) = static_cast < T > ( in_backprop_tensor_temp_flat ( i ) ) ; } }", "target": "<S2SV_ModStart> 3 ) ; OP_REQUIRES ( context , row_seq_tensor . NumElements ( ) > out_rows , errors : : InvalidArgument ( \"Given<S2SV_blank>out_backprop<S2SV_blank>shape<S2SV_blank>\" , out_backprop . shape ( ) . DebugString ( ) , \",<S2SV_blank>row_seq_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>\" , out_rows + 1 , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , row_seq_tensor . NumElements ( ) ) ) ; OP_REQUIRES ( context , col_seq_tensor . NumElements ( ) > out_cols , errors : : InvalidArgument ( \"Given<S2SV_blank>out_backprop<S2SV_blank>shape<S2SV_blank>\" , out_backprop . shape ( ) . DebugString ( ) , \",<S2SV_blank>col_seq_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>\" , out_cols + 1 , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , col_seq_tensor . NumElements ( ) ) ) ;"}
{"source": "CWE-763 static bool pb_release_union_field ( pb_istream_t * stream , pb_field_iter_t * field ) { pb_field_iter_t old_field = * field ; pb_size_t old_tag = * ( pb_size_t * ) field -> pSize ; pb_size_t new_tag = field -> tag ; if ( old_tag == 0 ) return true ; if ( old_tag == new_tag ) return true ; if ( ! pb_field_iter_find ( & old_field , old_tag ) ) PB_RETURN_ERROR ( stream , \"invalid<S2SV_blank>union<S2SV_blank>tag\" ) ; pb_release_single_field ( & old_field ) ; <S2SV_StartBug> return true ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> old_field ) ; if ( PB_ATYPE ( field -> type ) == PB_ATYPE_POINTER ) { * ( void * * ) field -> pField = NULL ; field -> pData = NULL ; }"}
{"source": "CWE-125 void ndpi_search_h323 ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int16_t dport = 0 , sport = 0 ; NDPI_LOG_DBG ( ndpi_struct , \"search<S2SV_blank>H323\\\\n\" ) ; if ( ( packet -> tcp != NULL ) && ( packet -> tcp -> dest != ntohs ( 102 ) ) ) { NDPI_LOG_DBG2 ( ndpi_struct , \"calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>tcp\\\\n\" ) ; if ( packet -> payload_packet_len >= 4 && ( packet -> payload [ 0 ] == 0x03 ) && ( packet -> payload [ 1 ] == 0x00 ) ) { struct tpkt * t = ( struct tpkt * ) packet -> payload ; u_int16_t len = ntohs ( t -> len ) ; if ( packet -> payload_packet_len == len ) { if ( packet -> payload [ 4 ] == ( packet -> payload_packet_len - sizeof ( struct tpkt ) - 1 ) ) { if ( ( packet -> payload [ 5 ] == 0xE0 ) || ( packet -> payload [ 5 ] == 0xD0 ) ) { NDPI_LOG_INFO ( ndpi_struct , \"found<S2SV_blank>RDP\\\\n\" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_RDP , NDPI_PROTOCOL_UNKNOWN ) ; return ; } } flow -> l4 . tcp . h323_valid_packets ++ ; if ( flow -> l4 . tcp . h323_valid_packets >= 2 ) { NDPI_LOG_INFO ( ndpi_struct , \"found<S2SV_blank>H323<S2SV_blank>broadcast\\\\n\" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; } } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } else if ( packet -> udp != NULL ) { sport = ntohs ( packet -> udp -> source ) , dport = ntohs ( packet -> udp -> dest ) ; NDPI_LOG_DBG2 ( ndpi_struct , \"calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>udp\\\\n\" ) ; if ( packet -> payload_packet_len >= 6 && packet -> payload [ 0 ] == 0x80 && packet -> payload [ 1 ] == 0x08 && ( packet -> payload [ 2 ] == 0xe7 || packet -> payload [ 2 ] == 0x26 ) && packet -> payload [ 4 ] == 0x00 && packet -> payload [ 5 ] == 0x00 ) { NDPI_LOG_INFO ( ndpi_struct , \"found<S2SV_blank>H323<S2SV_blank>broadcast\\\\n\" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } if ( sport == 1719 || dport == 1719 ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> NDPI_LOG_INFO ( ndpi_struct , \"found<S2SV_blank>H323<S2SV_blank>broadcast\\\\n\" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else if ( packet -> payload_packet_len >= 20 && packet -> payload_packet_len <= 117 ) { NDPI_LOG_INFO ( ndpi_struct , \"found<S2SV_blank>H323<S2SV_blank>broadcast\\\\n\" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } }", "target": "<S2SV_ModStart> == 1719 ) { if ( ( packet -> payload_packet_len >= 5 ) && <S2SV_ModEnd> ( packet -> <S2SV_ModStart> ] == 0x16 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x80 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x06 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> == 0x00 ) )"}
{"source": "CWE-369 Status ConvBackpropComputeDimensionsV2 ( StringPiece label , int num_spatial_dims , const TensorShape & input_shape , const TensorShape & filter_shape , const TensorShape & out_backprop_shape , const gtl : : ArraySlice < int32 > & dilations , const std : : vector < int32 > & strides , Padding padding , absl : : Span < const int64 > explicit_paddings , TensorFormat data_format , ConvBackpropDimensions * dims ) { const int num_dims = num_spatial_dims + 2 ; if ( input_shape . dims ( ) != num_dims ) { return errors : : InvalidArgument ( label , \":<S2SV_blank>input<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\" , num_dims , \"-dimensional\" ) ; } if ( filter_shape . dims ( ) != num_dims ) { return errors : : InvalidArgument ( label , \":<S2SV_blank>filter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\" , num_dims , \"-dimensional\" ) ; } if ( out_backprop_shape . dims ( ) != num_dims ) { return errors : : InvalidArgument ( label , \":<S2SV_blank>out_backprop<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\" , num_dims , \"-dimensional\" ) ; } int batch_dim = GetTensorBatchDimIndex ( num_dims , data_format ) ; dims -> batch_size = input_shape . dim_size ( batch_dim ) ; if ( dims -> batch_size != out_backprop_shape . dim_size ( batch_dim ) ) { return errors : : InvalidArgument ( label , \":<S2SV_blank>input<S2SV_blank>and<S2SV_blank>out_backprop<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>batch<S2SV_blank>size.\" , \"<S2SV_blank>Input<S2SV_blank>batch:<S2SV_blank>\" , dims -> batch_size , \",<S2SV_blank>outbackprop<S2SV_blank>batch:<S2SV_blank>\" , out_backprop_shape . dim_size ( batch_dim ) , \",<S2SV_blank>batch_dim:<S2SV_blank>\" , batch_dim ) ; } int feature_dim = GetTensorFeatureDimIndex ( num_dims , data_format ) ; dims -> in_depth = input_shape . dim_size ( feature_dim ) ; VLOG ( 2 ) << \"input<S2SV_blank>vs<S2SV_blank>filter_in<S2SV_blank>depth<S2SV_blank>\" << dims -> in_depth << \"<S2SV_blank>\" << filter_shape . dim_size ( num_dims - 2 ) ; <S2SV_StartBug> if ( dims -> in_depth % filter_shape . dim_size ( num_dims - 2 ) ) { <S2SV_EndBug> return errors : : InvalidArgument ( label , \":<S2SV_blank>input<S2SV_blank>depth<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>filter<S2SV_blank>depth\" ) ; } dims -> out_depth = filter_shape . dim_size ( num_dims - 1 ) ; if ( dims -> out_depth != out_backprop_shape . dim_size ( feature_dim ) ) { return errors : : InvalidArgument ( label , \":<S2SV_blank>filter<S2SV_blank>and<S2SV_blank>out_backprop<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>out_depth\" ) ; } dims -> spatial_dims . resize ( num_spatial_dims ) ; for ( int i = 0 ; i < num_spatial_dims ; ++ i ) { int image_dim = GetTensorSpatialDimIndex ( num_dims , data_format , i ) ; int64 padding_before = - 1 , padding_after = - 1 ; if ( padding == EXPLICIT ) { padding_before = explicit_paddings [ 2 * image_dim ] ; padding_after = explicit_paddings [ 2 * image_dim + 1 ] ; } TF_RETURN_IF_ERROR ( ConvBackpropExtractAndVerifyDimension ( label , input_shape , filter_shape , out_backprop_shape , dilations , strides , padding , padding_before , padding_after , image_dim , i , & dims -> spatial_dims [ i ] ) ) ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ; if ( filter_shape . dim_size ( num_dims - 2 ) <= 0 ) { return errors : : InvalidArgument ( label , \":<S2SV_blank>filter<S2SV_blank>depth<S2SV_blank>must<S2SV_blank>be<S2SV_blank>strictly<S2SV_blank>greated<S2SV_blank>than<S2SV_blank>zero\" ) ; } if ("}
{"source": "CWE-125 std : : vector < GetLengthType > CSoundFile : : GetLength ( enmGetLengthResetMode adjustMode , GetLengthTarget target ) { std : : vector < GetLengthType > results ; GetLengthType retval ; retval . startOrder = target . startOrder ; retval . startRow = target . startRow ; const bool hasSearchTarget = target . mode != GetLengthTarget : : NoTarget ; const bool adjustSamplePos = ( adjustMode & eAdjustSamplePositions ) == eAdjustSamplePositions ; SEQUENCEINDEX sequence = target . sequence ; if ( sequence >= Order . GetNumSequences ( ) ) sequence = Order . GetCurrentSequenceIndex ( ) ; const ModSequence & orderList = Order ( sequence ) ; GetLengthMemory memory ( * this ) ; CSoundFile : : PlayState & playState = * memory . state ; RowVisitor visitedRows ( * this , sequence ) ; playState . m_nNextRow = playState . m_nRow = target . startRow ; playState . m_nNextOrder = playState . m_nCurrentOrder = target . startOrder ; std : : bitset < MAX_EFFECTS > forbiddenCommands ; std : : bitset < MAX_VOLCMDS > forbiddenVolCommands ; if ( adjustSamplePos ) { forbiddenCommands . set ( CMD_ARPEGGIO ) ; forbiddenCommands . set ( CMD_PORTAMENTOUP ) ; forbiddenCommands . set ( CMD_PORTAMENTODOWN ) ; forbiddenCommands . set ( CMD_XFINEPORTAUPDOWN ) ; forbiddenCommands . set ( CMD_NOTESLIDEUP ) ; forbiddenCommands . set ( CMD_NOTESLIDEUPRETRIG ) ; forbiddenCommands . set ( CMD_NOTESLIDEDOWN ) ; forbiddenCommands . set ( CMD_NOTESLIDEDOWNRETRIG ) ; forbiddenVolCommands . set ( VOLCMD_PORTAUP ) ; forbiddenVolCommands . set ( VOLCMD_PORTADOWN ) ; for ( CHANNELINDEX i = 0 ; i < GetNumChannels ( ) ; i ++ ) { if ( ChnSettings [ i ] . dwFlags [ CHN_MUTE ] ) memory . chnSettings [ i ] . ticksToRender = GetLengthMemory : : IGNORE_CHANNEL ; } if ( target . mode == GetLengthTarget : : SeekPosition && target . pos . order < orderList . size ( ) ) { const PATTERNINDEX seekPat = orderList [ target . pos . order ] ; if ( Patterns . IsValidPat ( seekPat ) && Patterns [ seekPat ] . IsValidRow ( target . pos . row ) ) { const ModCommand * m = Patterns [ seekPat ] . GetRow ( target . pos . row ) ; for ( CHANNELINDEX i = 0 ; i < GetNumChannels ( ) ; i ++ , m ++ ) { if ( m -> note == NOTE_NOTECUT || m -> note == NOTE_KEYOFF || ( m -> note == NOTE_FADE && GetNumInstruments ( ) ) || ( m -> IsNote ( ) && ! m -> IsPortamento ( ) ) ) { memory . chnSettings [ i ] . ticksToRender = GetLengthMemory : : IGNORE_CHANNEL ; } } } } } uint32 oldTickDuration = 0 ; for ( ; ; ) { if ( target . mode == GetLengthTarget : : SeekSeconds && memory . elapsedTime >= target . time ) { retval . targetReached = true ; break ; } uint32 rowDelay = 0 , tickDelay = 0 ; playState . m_nRow = playState . m_nNextRow ; playState . m_nCurrentOrder = playState . m_nNextOrder ; if ( orderList . IsValidPat ( playState . m_nCurrentOrder ) && playState . m_nRow >= Patterns [ orderList [ playState . m_nCurrentOrder ] ] . GetNumRows ( ) ) { playState . m_nRow = 0 ; if ( m_playBehaviour [ kFT2LoopE60Restart ] ) { playState . m_nRow = playState . m_nNextPatStartRow ; playState . m_nNextPatStartRow = 0 ; } playState . m_nCurrentOrder = ++ playState . m_nNextOrder ; } playState . m_nPattern = playState . m_nCurrentOrder < orderList . size ( ) ? orderList [ playState . m_nCurrentOrder ] : orderList . GetInvalidPatIndex ( ) ; bool positionJumpOnThisRow = false ; bool patternBreakOnThisRow = false ; bool patternLoopEndedOnThisRow = false , patternLoopStartedOnThisRow = false ; if ( ! Patterns . IsValidPat ( playState . m_nPattern ) && playState . m_nPattern != orderList . GetInvalidPatIndex ( ) && target . mode == GetLengthTarget : : SeekPosition && playState . m_nCurrentOrder == target . pos . order ) { retval . targetReached = true ; break ; } while ( playState . m_nPattern >= Patterns . Size ( ) ) { if ( ( playState . m_nPattern == orderList . GetInvalidPatIndex ( ) ) || ( playState . m_nCurrentOrder >= orderList . size ( ) ) ) { if ( playState . m_nCurrentOrder == orderList . GetRestartPos ( ) ) break ; else playState . m_nCurrentOrder = orderList . GetRestartPos ( ) ; } else { playState . m_nCurrentOrder ++ ; } playState . m_nPattern = ( playState . m_nCurrentOrder < orderList . size ( ) ) ? orderList [ playState . m_nCurrentOrder ] : orderList . GetInvalidPatIndex ( ) ; playState . m_nNextOrder = playState . m_nCurrentOrder ; if ( ( ! Patterns . IsValidPat ( playState . m_nPattern ) ) && visitedRows . IsVisited ( playState . m_nCurrentOrder , 0 , true ) ) { if ( ! hasSearchTarget || ! visitedRows . GetFirstUnvisitedRow ( playState . m_nNextOrder , playState . m_nRow , true ) ) { break ; } else { retval . duration = memory . elapsedTime ; results . push_back ( retval ) ; retval . startRow = playState . m_nRow ; retval . startOrder = playState . m_nNextOrder ; memory . Reset ( ) ; playState . m_nCurrentOrder = playState . m_nNextOrder ; playState . m_nPattern = orderList [ playState . m_nCurrentOrder ] ; playState . m_nNextRow = playState . m_nRow ; break ; } } } if ( playState . m_nNextOrder == ORDERINDEX_INVALID ) { break ; } if ( ! Patterns . IsValidPat ( playState . m_nPattern ) ) { if ( playState . m_nCurrentOrder == orderList . GetRestartPos ( ) ) { if ( ! hasSearchTarget || ! visitedRows . GetFirstUnvisitedRow ( playState . m_nNextOrder , playState . m_nRow , true ) ) { break ; } else { retval . duration = memory . elapsedTime ; results . push_back ( retval ) ; retval . startRow = playState . m_nRow ; retval . startOrder = playState . m_nNextOrder ; memory . Reset ( ) ; playState . m_nNextRow = playState . m_nRow ; continue ; } } playState . m_nNextOrder = playState . m_nCurrentOrder + 1 ; continue ; } if ( playState . m_nRow >= Patterns [ playState . m_nPattern ] . GetNumRows ( ) ) playState . m_nRow = 0 ; if ( target . mode == GetLengthTarget : : SeekPosition && playState . m_nCurrentOrder == target . pos . order && playState . m_nRow == target . pos . row ) { retval . targetReached = true ; break ; } if ( visitedRows . IsVisited ( playState . m_nCurrentOrder , playState . m_nRow , true ) ) { if ( ! hasSearchTarget || ! visitedRows . GetFirstUnvisitedRow ( playState . m_nNextOrder , playState . m_nRow , true ) ) { break ; } else { retval . duration = memory . elapsedTime ; results . push_back ( retval ) ; retval . startRow = playState . m_nRow ; retval . startOrder = playState . m_nNextOrder ; memory . Reset ( ) ; playState . m_nNextRow = playState . m_nRow ; continue ; } } retval . endOrder = playState . m_nCurrentOrder ; retval . endRow = playState . m_nRow ; playState . m_nNextRow = playState . m_nRow + 1 ; if ( playState . m_nRow >= Patterns [ playState . m_nPattern ] . GetNumRows ( ) ) { playState . m_nRow = 0 ; } if ( ! playState . m_nRow ) { for ( CHANNELINDEX chn = 0 ; chn < GetNumChannels ( ) ; chn ++ ) { memory . chnSettings [ chn ] . patLoop = memory . elapsedTime ; memory . chnSettings [ chn ] . patLoopSmp = playState . m_lTotalSampleCount ; } } ModChannel * pChn = playState . Chn ; const ModCommand * p = Patterns [ playState . m_nPattern ] . GetpModCommand ( playState . m_nRow , 0 ) ; for ( CHANNELINDEX nChn = 0 ; nChn < GetNumChannels ( ) ; nChn ++ , p ++ ) { if ( m_playBehaviour [ kST3NoMutedChannels ] && ChnSettings [ nChn ] . dwFlags [ CHN_MUTE ] ) continue ; if ( p -> IsPcNote ( ) ) { # ifndef NO_PLUGINS if ( ( adjustMode & eAdjust ) && p -> instr > 0 && p -> instr <= MAX_MIXPLUGINS ) { memory . plugParams [ std : : make_pair ( p -> instr , p -> GetValueVolCol ( ) ) ] = p -> GetValueEffectCol ( ) ; } # endif pChn [ nChn ] . rowCommand . Clear ( ) ; continue ; } pChn [ nChn ] . rowCommand = * p ; switch ( p -> command ) { case CMD_SPEED : SetSpeed ( playState , p -> param ) ; break ; case CMD_TEMPO : if ( m_playBehaviour [ kMODVBlankTiming ] ) { if ( p -> param != 0 ) SetSpeed ( playState , p -> param ) ; } break ; case CMD_S3MCMDEX : if ( ( p -> param & 0xF0 ) == 0x60 ) { tickDelay += ( p -> param & 0x0F ) ; } else if ( ( p -> param & 0xF0 ) == 0xE0 && ! rowDelay ) { if ( ! ( GetType ( ) & MOD_TYPE_S3M ) || ( p -> param & 0x0F ) != 0 ) { rowDelay = 1 + ( p -> param & 0x0F ) ; } } break ; case CMD_MODCMDEX : if ( ( p -> param & 0xF0 ) == 0xE0 ) { rowDelay = 1 + ( p -> param & 0x0F ) ; } break ; } } if ( rowDelay == 0 ) rowDelay = 1 ; const uint32 numTicks = ( playState . m_nMusicSpeed + tickDelay ) * rowDelay ; const uint32 nonRowTicks = numTicks - rowDelay ; for ( CHANNELINDEX nChn = 0 ; nChn < GetNumChannels ( ) ; pChn ++ , nChn ++ ) if ( ! pChn -> rowCommand . IsEmpty ( ) ) { if ( m_playBehaviour [ kST3NoMutedChannels ] && ChnSettings [ nChn ] . dwFlags [ CHN_MUTE ] ) continue ; ModCommand : : COMMAND command = pChn -> rowCommand . command ; ModCommand : : PARAM param = pChn -> rowCommand . param ; ModCommand : : NOTE note = pChn -> rowCommand . note ; if ( pChn -> rowCommand . instr ) { pChn -> nNewIns = pChn -> rowCommand . instr ; pChn -> nLastNote = NOTE_NONE ; memory . chnSettings [ nChn ] . vol = 0xFF ; } if ( pChn -> rowCommand . IsNote ( ) ) pChn -> nLastNote = note ; if ( pChn -> rowCommand . IsNote ( ) || pChn -> rowCommand . instr ) { SAMPLEINDEX smp = 0 ; if ( GetNumInstruments ( ) ) { ModInstrument * pIns ; if ( pChn -> nNewIns <= GetNumInstruments ( ) && ( pIns = Instruments [ pChn -> nNewIns ] ) != nullptr ) { if ( pIns -> dwFlags [ INS_SETPANNING ] ) pChn -> nPan = pIns -> nPan ; if ( ModCommand : : IsNote ( note ) ) smp = pIns -> Keyboard [ note - NOTE_MIN ] ; } } else { smp = pChn -> nNewIns ; } if ( smp > 0 && smp <= GetNumSamples ( ) && Samples [ smp ] . uFlags [ CHN_PANNING ] ) { pChn -> nPan = Samples [ smp ] . nPan ; } } switch ( pChn -> rowCommand . volcmd ) { case VOLCMD_VOLUME : memory . chnSettings [ nChn ] . vol = pChn -> rowCommand . vol ; break ; case VOLCMD_VOLSLIDEUP : case VOLCMD_VOLSLIDEDOWN : if ( pChn -> rowCommand . vol != 0 ) pChn -> nOldVolParam = pChn -> rowCommand . vol ; break ; } switch ( command ) { case CMD_POSITIONJUMP : positionJumpOnThisRow = true ; playState . m_nNextOrder = static_cast < ORDERINDEX > ( CalculateXParam ( playState . m_nPattern , playState . m_nRow , nChn ) ) ; playState . m_nNextPatStartRow = 0 ; if ( ! patternBreakOnThisRow || ( GetType ( ) & ( MOD_TYPE_MOD | MOD_TYPE_XM ) ) ) playState . m_nNextRow = 0 ; if ( adjustMode & eAdjust ) { pChn -> nPatternLoopCount = 0 ; pChn -> nPatternLoop = 0 ; } break ; case CMD_PATTERNBREAK : { ROWINDEX row = PatternBreak ( playState , nChn , param ) ; if ( row != ROWINDEX_INVALID ) { patternBreakOnThisRow = true ; playState . m_nNextRow = row ; if ( ! positionJumpOnThisRow ) { playState . m_nNextOrder = playState . m_nCurrentOrder + 1 ; } if ( adjustMode & eAdjust ) { pChn -> nPatternLoopCount = 0 ; pChn -> nPatternLoop = 0 ; } } } break ; case CMD_TEMPO : if ( ! m_playBehaviour [ kMODVBlankTiming ] ) { TEMPO tempo ( CalculateXParam ( playState . m_nPattern , playState . m_nRow , nChn ) , 0 ) ; if ( ( adjustMode & eAdjust ) && ( GetType ( ) & ( MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT ) ) ) { if ( tempo . GetInt ( ) ) pChn -> nOldTempo = static_cast < uint8 > ( tempo . GetInt ( ) ) ; else tempo . Set ( pChn -> nOldTempo ) ; } if ( tempo . GetInt ( ) >= 0x20 ) playState . m_nMusicTempo = tempo ; else { TEMPO tempoDiff ( ( tempo . GetInt ( ) & 0x0F ) * nonRowTicks , 0 ) ; if ( ( tempo . GetInt ( ) & 0xF0 ) == 0x10 ) { playState . m_nMusicTempo += tempoDiff ; } else { if ( tempoDiff < playState . m_nMusicTempo ) playState . m_nMusicTempo -= tempoDiff ; else playState . m_nMusicTempo . Set ( 0 ) ; } } TEMPO tempoMin = GetModSpecifications ( ) . GetTempoMin ( ) , tempoMax = GetModSpecifications ( ) . GetTempoMax ( ) ; if ( m_playBehaviour [ kTempoClamp ] ) { tempoMax . Set ( 255 ) ; } Limit ( playState . m_nMusicTempo , tempoMin , tempoMax ) ; } break ; case CMD_S3MCMDEX : switch ( param & 0xF0 ) { case 0x90 : if ( param <= 0x91 ) { pChn -> dwFlags . set ( CHN_SURROUND , param == 0x91 ) ; } break ; case 0xA0 : pChn -> nOldHiOffset = param & 0x0F ; break ; case 0xB0 : if ( param & 0x0F ) { patternLoopEndedOnThisRow = true ; } else { CHANNELINDEX firstChn = nChn , lastChn = nChn ; if ( GetType ( ) == MOD_TYPE_S3M ) { firstChn = 0 ; lastChn = GetNumChannels ( ) - 1 ; } for ( CHANNELINDEX c = firstChn ; c <= lastChn ; c ++ ) { memory . chnSettings [ c ] . patLoop = memory . elapsedTime ; memory . chnSettings [ c ] . patLoopSmp = playState . m_lTotalSampleCount ; memory . chnSettings [ c ] . patLoopStart = playState . m_nRow ; } patternLoopStartedOnThisRow = true ; } break ; case 0xF0 : pChn -> nActiveMacro = param & 0x0F ; break ; } break ; case CMD_MODCMDEX : switch ( param & 0xF0 ) { case 0x60 : if ( param & 0x0F ) { playState . m_nNextPatStartRow = memory . chnSettings [ nChn ] . patLoopStart ; patternLoopEndedOnThisRow = true ; } else { patternLoopStartedOnThisRow = true ; memory . chnSettings [ nChn ] . patLoop = memory . elapsedTime ; memory . chnSettings [ nChn ] . patLoopSmp = playState . m_lTotalSampleCount ; memory . chnSettings [ nChn ] . patLoopStart = playState . m_nRow ; } break ; case 0xF0 : pChn -> nActiveMacro = param & 0x0F ; break ; } break ; case CMD_XFINEPORTAUPDOWN : if ( ( ( param & 0xF0 ) == 0xA0 ) && ! m_playBehaviour [ kFT2RestrictXCommand ] ) pChn -> nOldHiOffset = param & 0x0F ; break ; } if ( ! ( adjustMode & eAdjust ) ) continue ; switch ( command ) { case CMD_PORTAMENTOUP : if ( param ) { if ( ! m_playBehaviour [ kFT2PortaUpDownMemory ] ) pChn -> nOldPortaDown = param ; pChn -> nOldPortaUp = param ; } break ; case CMD_PORTAMENTODOWN : if ( param ) { if ( ! m_playBehaviour [ kFT2PortaUpDownMemory ] ) pChn -> nOldPortaUp = param ; pChn -> nOldPortaDown = param ; } break ; case CMD_TONEPORTAMENTO : if ( param ) pChn -> nPortamentoSlide = param << 2 ; break ; case CMD_OFFSET : if ( param ) pChn -> oldOffset = param << 8 ; break ; case CMD_VOLUMESLIDE : case CMD_TONEPORTAVOL : if ( param ) pChn -> nOldVolumeSlide = param ; break ; case CMD_VOLUME : memory . chnSettings [ nChn ] . vol = param ; break ; case CMD_GLOBALVOLUME : if ( ! ( GetType ( ) & GLOBALVOL_7BIT_FORMATS ) && param < 128 ) param *= 2 ; if ( param <= 128 ) { playState . m_nGlobalVolume = param * 2 ; } else if ( ! ( GetType ( ) & ( MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M ) ) ) { playState . m_nGlobalVolume = 256 ; } break ; case CMD_GLOBALVOLSLIDE : if ( m_playBehaviour [ kPerChannelGlobalVolSlide ] ) { if ( param ) pChn -> nOldGlobalVolSlide = param ; else param = pChn -> nOldGlobalVolSlide ; } else { if ( param ) playState . Chn [ 0 ] . nOldGlobalVolSlide = param ; else param = playState . Chn [ 0 ] . nOldGlobalVolSlide ; } if ( ( ( param & 0x0F ) == 0x0F ) && ( param & 0xF0 ) ) { param >>= 4 ; if ( ! ( GetType ( ) & GLOBALVOL_7BIT_FORMATS ) ) param <<= 1 ; playState . m_nGlobalVolume += param << 1 ; } else if ( ( ( param & 0xF0 ) == 0xF0 ) && ( param & 0x0F ) ) { param = ( param & 0x0F ) << 1 ; if ( ! ( GetType ( ) & GLOBALVOL_7BIT_FORMATS ) ) param <<= 1 ; playState . m_nGlobalVolume -= param ; } else if ( param & 0xF0 ) { param >>= 4 ; param <<= 1 ; if ( ! ( GetType ( ) & GLOBALVOL_7BIT_FORMATS ) ) param <<= 1 ; playState . m_nGlobalVolume += param * nonRowTicks ; } else { param = ( param & 0x0F ) << 1 ; if ( ! ( GetType ( ) & GLOBALVOL_7BIT_FORMATS ) ) param <<= 1 ; playState . m_nGlobalVolume -= param * nonRowTicks ; } Limit ( playState . m_nGlobalVolume , 0 , 256 ) ; break ; case CMD_CHANNELVOLUME : if ( param <= 64 ) pChn -> nGlobalVol = param ; break ; case CMD_CHANNELVOLSLIDE : { if ( param ) pChn -> nOldChnVolSlide = param ; else param = pChn -> nOldChnVolSlide ; int32 volume = pChn -> nGlobalVol ; if ( ( param & 0x0F ) == 0x0F && ( param & 0xF0 ) ) volume += ( param >> 4 ) ; else if ( ( param & 0xF0 ) == 0xF0 && ( param & 0x0F ) ) volume -= ( param & 0x0F ) ; else if ( param & 0x0F ) volume -= ( param & 0x0F ) * nonRowTicks ; else volume += ( ( param & 0xF0 ) >> 4 ) * nonRowTicks ; Limit ( volume , 0 , 64 ) ; pChn -> nGlobalVol = volume ; } break ; case CMD_PANNING8 : Panning ( pChn , param , Pan8bit ) ; break ; case CMD_MODCMDEX : if ( param < 0x10 ) { for ( CHANNELINDEX chn = 0 ; chn < GetNumChannels ( ) ; chn ++ ) { playState . Chn [ chn ] . dwFlags . set ( CHN_AMIGAFILTER , ! ( param & 1 ) ) ; } } MPT_FALLTHROUGH ; case CMD_S3MCMDEX : if ( ( param & 0xF0 ) == 0x80 ) { Panning ( pChn , ( param & 0x0F ) , Pan4bit ) ; } break ; case CMD_VIBRATOVOL : if ( param ) pChn -> nOldVolumeSlide = param ; param = 0 ; MPT_FALLTHROUGH ; case CMD_VIBRATO : Vibrato ( pChn , param ) ; break ; case CMD_FINEVIBRATO : FineVibrato ( pChn , param ) ; break ; case CMD_TREMOLO : Tremolo ( pChn , param ) ; break ; case CMD_PANBRELLO : Panbrello ( pChn , param ) ; break ; } switch ( pChn -> rowCommand . volcmd ) { case VOLCMD_PANNING : Panning ( pChn , pChn -> rowCommand . vol , Pan6bit ) ; break ; case VOLCMD_VIBRATOSPEED : if ( m_playBehaviour [ kFT2VolColVibrato ] ) pChn -> nVibratoSpeed = pChn -> rowCommand . vol & 0x0F ; else Vibrato ( pChn , pChn -> rowCommand . vol << 4 ) ; break ; case VOLCMD_VIBRATODEPTH : Vibrato ( pChn , pChn -> rowCommand . vol ) ; break ; } switch ( pChn -> rowCommand . command ) { case CMD_VIBRATO : case CMD_FINEVIBRATO : case CMD_VIBRATOVOL : if ( adjustMode & eAdjust ) { uint32 vibTicks = ( ( GetType ( ) & ( MOD_TYPE_IT | MOD_TYPE_MPT ) ) && ! m_SongFlags [ SONG_ITOLDEFFECTS ] ) ? numTicks : nonRowTicks ; uint32 inc = pChn -> nVibratoSpeed * vibTicks ; if ( m_playBehaviour [ kITVibratoTremoloPanbrello ] ) inc *= 4 ; pChn -> nVibratoPos += static_cast < uint8 > ( inc ) ; } break ; case CMD_TREMOLO : if ( adjustMode & eAdjust ) { uint32 tremTicks = ( ( GetType ( ) & ( MOD_TYPE_IT | MOD_TYPE_MPT ) ) && ! m_SongFlags [ SONG_ITOLDEFFECTS ] ) ? numTicks : nonRowTicks ; uint32 inc = pChn -> nTremoloSpeed * tremTicks ; if ( m_playBehaviour [ kITVibratoTremoloPanbrello ] ) inc *= 4 ; pChn -> nTremoloPos += static_cast < uint8 > ( inc ) ; } break ; case CMD_PANBRELLO : if ( adjustMode & eAdjust ) { pChn -> nPanbrelloPos += static_cast < uint8 > ( pChn -> nPanbrelloSpeed * ( numTicks - 1 ) ) ; ProcessPanbrello ( pChn ) ; } break ; } } if ( GetType ( ) == MOD_TYPE_XM && playState . m_nMusicSpeed == uint16_max ) { break ; } playState . m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat ; if ( Patterns [ playState . m_nPattern ] . GetOverrideSignature ( ) ) { playState . m_nCurrentRowsPerBeat = Patterns [ playState . m_nPattern ] . GetRowsPerBeat ( ) ; } const uint32 tickDuration = GetTickDuration ( playState ) ; const uint32 rowDuration = tickDuration * numTicks ; memory . elapsedTime += static_cast < double > ( rowDuration ) / static_cast < double > ( m_MixerSettings . gdwMixingFreq ) ; playState . m_lTotalSampleCount += rowDuration ; if ( adjustSamplePos ) { pChn = playState . Chn ; for ( CHANNELINDEX nChn = 0 ; nChn < GetNumChannels ( ) ; pChn ++ , nChn ++ ) { if ( memory . chnSettings [ nChn ] . ticksToRender == GetLengthMemory : : IGNORE_CHANNEL ) continue ; uint32 startTick = 0 ; const ModCommand & m = pChn -> rowCommand ; uint32 paramHi = m . param >> 4 , paramLo = m . param & 0x0F ; bool porta = m . command == CMD_TONEPORTAMENTO || m . command == CMD_TONEPORTAVOL || m . volcmd == VOLCMD_TONEPORTAMENTO ; bool stopNote = patternLoopStartedOnThisRow ; if ( m . instr ) pChn -> proTrackerOffset = 0 ; if ( m . IsNote ( ) ) { if ( porta && memory . chnSettings [ nChn ] . incChanged ) { pChn -> increment = GetChannelIncrement ( pChn , pChn -> nPeriod , 0 ) ; } int32 setPan = pChn -> nPan ; pChn -> nNewNote = pChn -> nLastNote ; if ( pChn -> nNewIns != 0 ) InstrumentChange ( pChn , pChn -> nNewIns , porta ) ; NoteChange ( pChn , m . note , porta ) ; memory . chnSettings [ nChn ] . incChanged = true ; if ( ( m . command == CMD_MODCMDEX || m . command == CMD_S3MCMDEX ) && ( m . param & 0xF0 ) == 0xD0 && paramLo < numTicks ) { startTick = paramLo ; } else if ( m . command == CMD_DELAYCUT && paramHi < numTicks ) { startTick = paramHi ; } if ( rowDelay > 1 && startTick != 0 && ( GetType ( ) & ( MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT ) ) ) { startTick += ( playState . m_nMusicSpeed + tickDelay ) * ( rowDelay - 1 ) ; } if ( ! porta ) memory . chnSettings [ nChn ] . ticksToRender = 0 ; if ( m . command == CMD_PANNING8 || ( ( m . command == CMD_MODCMDEX || m . command == CMD_S3MCMDEX ) && paramHi == 0x8 ) || m . volcmd == VOLCMD_PANNING ) { pChn -> nPan = setPan ; } if ( m . command == CMD_OFFSET ) { bool isExtended = false ; SmpLength offset = CalculateXParam ( playState . m_nPattern , playState . m_nRow , nChn , & isExtended ) ; if ( ! isExtended ) { offset <<= 8 ; if ( offset == 0 ) offset = pChn -> oldOffset ; offset += static_cast < SmpLength > ( pChn -> nOldHiOffset ) << 16 ; } SampleOffset ( * pChn , offset ) ; } else if ( m . command == CMD_OFFSETPERCENTAGE ) { SampleOffset ( * pChn , Util : : muldiv_unsigned ( pChn -> nLength , m . param , 255 ) ) ; } else if ( m . command == CMD_REVERSEOFFSET && pChn -> pModSample != nullptr ) { memory . RenderChannel ( nChn , oldTickDuration ) ; ReverseSampleOffset ( * pChn , m . param ) ; startTick = playState . m_nMusicSpeed - 1 ; } else if ( m . volcmd == VOLCMD_OFFSET ) { if ( m . vol <= CountOf ( pChn -> pModSample -> cues ) && pChn -> pModSample != nullptr ) { SmpLength offset ; if ( m . vol == 0 ) offset = pChn -> oldOffset ; else offset = pChn -> oldOffset = pChn -> pModSample -> cues [ m . vol - 1 ] ; SampleOffset ( * pChn , offset ) ; } } } if ( m . note == NOTE_KEYOFF || m . note == NOTE_NOTECUT || ( m . note == NOTE_FADE && GetNumInstruments ( ) ) || ( ( m . command == CMD_MODCMDEX || m . command == CMD_S3MCMDEX ) && ( m . param & 0xF0 ) == 0xC0 && paramLo < numTicks ) || ( m . command == CMD_DELAYCUT && paramLo != 0 && startTick + paramLo < numTicks ) ) { stopNote = true ; } if ( m . command == CMD_VOLUME ) { pChn -> nVolume = m . param * 4 ; } else if ( m . volcmd == VOLCMD_VOLUME ) { pChn -> nVolume = m . vol * 4 ; } if ( pChn -> pModSample && ! stopNote ) { if ( m . command < MAX_EFFECTS ) { if ( forbiddenCommands [ m . command ] ) { stopNote = true ; } else if ( m . command == CMD_MODCMDEX ) { switch ( m . param & 0xF0 ) { case 0x10 : case 0x20 : stopNote = true ; } } } if ( m . volcmd < forbiddenVolCommands . size ( ) && forbiddenVolCommands [ m . volcmd ] ) { stopNote = true ; } } if ( stopNote ) { pChn -> Stop ( ) ; memory . chnSettings [ nChn ] . ticksToRender = 0 ; } else { if ( oldTickDuration != tickDuration && oldTickDuration != 0 ) { memory . RenderChannel ( nChn , oldTickDuration ) ; } switch ( m . command ) { case CMD_TONEPORTAVOL : case CMD_VOLUMESLIDE : case CMD_VIBRATOVOL : if ( m . param || ( GetType ( ) != MOD_TYPE_MOD ) ) { for ( uint32 i = 0 ; i < numTicks ; i ++ ) { pChn -> isFirstTick = ( i == 0 ) ; VolumeSlide ( pChn , m . param ) ; } } break ; case CMD_MODCMDEX : if ( ( m . param & 0x0F ) || ( GetType ( ) & ( MOD_TYPE_XM | MOD_TYPE_MT2 ) ) ) { pChn -> isFirstTick = true ; switch ( m . param & 0xF0 ) { case 0xA0 : FineVolumeUp ( pChn , m . param & 0x0F , false ) ; break ; case 0xB0 : FineVolumeDown ( pChn , m . param & 0x0F , false ) ; break ; } } break ; case CMD_S3MCMDEX : if ( m . param == 0x9E ) { memory . RenderChannel ( nChn , oldTickDuration ) ; pChn -> dwFlags . reset ( CHN_PINGPONGFLAG ) ; } else if ( m . param == 0x9F ) { memory . RenderChannel ( nChn , oldTickDuration ) ; pChn -> dwFlags . set ( CHN_PINGPONGFLAG ) ; if ( ! pChn -> position . GetInt ( ) && pChn -> nLength && ( m . IsNote ( ) || ! pChn -> dwFlags [ CHN_LOOP ] ) ) { pChn -> position . Set ( pChn -> nLength - 1 , SamplePosition : : fractMax ) ; } } else if ( ( m . param & 0xF0 ) == 0x70 ) { } break ; } pChn -> isFirstTick = true ; switch ( m . volcmd ) { case VOLCMD_FINEVOLUP : FineVolumeUp ( pChn , m . vol , m_playBehaviour [ kITVolColMemory ] ) ; break ; case VOLCMD_FINEVOLDOWN : FineVolumeDown ( pChn , m . vol , m_playBehaviour [ kITVolColMemory ] ) ; break ; case VOLCMD_VOLSLIDEUP : case VOLCMD_VOLSLIDEDOWN : { ModCommand : : VOL vol = m . vol ; if ( vol == 0 && m_playBehaviour [ kITVolColMemory ] ) { vol = pChn -> nOldVolParam ; if ( vol == 0 ) break ; } if ( m . volcmd == VOLCMD_VOLSLIDEUP ) vol <<= 4 ; for ( uint32 i = 0 ; i < numTicks ; i ++ ) { pChn -> isFirstTick = ( i == 0 ) ; VolumeSlide ( pChn , vol ) ; } } break ; } if ( porta ) { uint32 portaTick = memory . chnSettings [ nChn ] . ticksToRender + startTick + 1 ; memory . chnSettings [ nChn ] . ticksToRender += numTicks ; memory . RenderChannel ( nChn , tickDuration , portaTick ) ; } else { memory . chnSettings [ nChn ] . ticksToRender += ( numTicks - startTick ) ; } } } } oldTickDuration = tickDuration ; if ( patternLoopEndedOnThisRow && ( ! m_playBehaviour [ kFT2PatternLoopWithJumps ] || ! ( positionJumpOnThisRow || patternBreakOnThisRow ) ) && ( ! m_playBehaviour [ kITPatternLoopWithJumps ] || ! positionJumpOnThisRow ) ) { std : : map < double , int > startTimes ; pChn = playState . Chn ; for ( CHANNELINDEX nChn = 0 ; nChn < GetNumChannels ( ) ; nChn ++ , pChn ++ ) { ModCommand : : COMMAND command = pChn -> rowCommand . command ; ModCommand : : PARAM param = pChn -> rowCommand . param ; if ( ( command == CMD_S3MCMDEX && param >= 0xB1 && param <= 0xBF ) || ( command == CMD_MODCMDEX && param >= 0x61 && param <= 0x6F ) ) { const double start = memory . chnSettings [ nChn ] . patLoop ; if ( ! startTimes [ start ] ) startTimes [ start ] = 1 ; startTimes [ start ] = mpt : : lcm ( startTimes [ start ] , 1 + ( param & 0x0F ) ) ; } } for ( const auto & i : startTimes ) { memory . elapsedTime += ( memory . elapsedTime - i . first ) * ( double ) ( i . second - 1 ) ; for ( CHANNELINDEX nChn = 0 ; nChn < GetNumChannels ( ) ; nChn ++ , pChn ++ ) { if ( memory . chnSettings [ nChn ] . patLoop == i . first ) { playState . m_lTotalSampleCount += ( playState . m_lTotalSampleCount - memory . chnSettings [ nChn ] . patLoopSmp ) * ( i . second - 1 ) ; if ( m_playBehaviour [ kITPatternLoopTargetReset ] || ( GetType ( ) == MOD_TYPE_S3M ) ) { memory . chnSettings [ nChn ] . patLoop = memory . elapsedTime ; memory . chnSettings [ nChn ] . patLoopSmp = playState . m_lTotalSampleCount ; memory . chnSettings [ nChn ] . patLoopStart = playState . m_nRow + 1 ; } break ; } } } if ( GetType ( ) == MOD_TYPE_IT ) { <S2SV_StartBug> for ( CHANNELINDEX nChn = 0 ; nChn < GetNumChannels ( ) ; nChn ++ ) <S2SV_EndBug> { if ( ( pChn -> rowCommand . command == CMD_S3MCMDEX && pChn -> rowCommand . param >= 0xB1 && pChn -> rowCommand . param <= 0xBF ) ) { memory . chnSettings [ nChn ] . patLoop = memory . elapsedTime ; memory . chnSettings [ nChn ] . patLoopSmp = playState . m_lTotalSampleCount ; } } } } } if ( adjustSamplePos ) { for ( CHANNELINDEX nChn = 0 ; nChn < GetNumChannels ( ) ; nChn ++ ) { if ( memory . chnSettings [ nChn ] . ticksToRender != GetLengthMemory : : IGNORE_CHANNEL ) { memory . RenderChannel ( nChn , oldTickDuration ) ; } } } if ( retval . targetReached || target . mode == GetLengthTarget : : NoTarget ) { retval . lastOrder = playState . m_nCurrentOrder ; retval . lastRow = playState . m_nRow ; } retval . duration = memory . elapsedTime ; results . push_back ( retval ) ; if ( adjustMode & eAdjust ) { if ( retval . targetReached || target . mode == GetLengthTarget : : NoTarget ) { m_PlayState = std : : move ( playState ) ; m_PlayState . m_nNextRow = m_PlayState . m_nRow ; m_PlayState . m_nFrameDelay = m_PlayState . m_nPatternDelay = 0 ; m_PlayState . m_nTickCount = Util : : MaxValueOfType ( m_PlayState . m_nTickCount ) - 1 ; m_PlayState . m_bPositionChanged = true ; for ( CHANNELINDEX n = 0 ; n < GetNumChannels ( ) ; n ++ ) { if ( m_PlayState . Chn [ n ] . nLastNote != NOTE_NONE ) { m_PlayState . Chn [ n ] . nNewNote = m_PlayState . Chn [ n ] . nLastNote ; } if ( memory . chnSettings [ n ] . vol != 0xFF && ! adjustSamplePos ) { m_PlayState . Chn [ n ] . nVolume = std : : min ( memory . chnSettings [ n ] . vol , uint8 ( 64 ) ) * 4 ; } } # ifndef NO_PLUGINS std : : bitset < MAX_MIXPLUGINS > plugSetProgram ; for ( const auto & param : memory . plugParams ) { PLUGINDEX plug = param . first . first - 1 ; IMixPlugin * plugin = m_MixPlugins [ plug ] . pMixPlugin ; if ( plugin != nullptr ) { if ( ! plugSetProgram [ plug ] ) { plugSetProgram . set ( plug ) ; plugin -> BeginSetProgram ( ) ; } plugin -> SetParameter ( param . first . second , param . second / PlugParamValue ( ModCommand : : maxColumnValue ) ) ; } } if ( plugSetProgram . any ( ) ) { for ( PLUGINDEX i = 0 ; i < MAX_MIXPLUGINS ; i ++ ) { if ( plugSetProgram [ i ] ) { m_MixPlugins [ i ] . pMixPlugin -> EndSetProgram ( ) ; } } } # endif } else if ( adjustMode != eAdjustOnSuccess ) { m_PlayState . m_nMusicSpeed = m_nDefaultSpeed ; m_PlayState . m_nMusicTempo = m_nDefaultTempo ; m_PlayState . m_nGlobalVolume = m_nDefaultGlobalVolume ; } if ( sequence != Order . GetCurrentSequenceIndex ( ) ) { Order . SetSequence ( sequence ) ; } visitedSongRows . Set ( visitedRows ) ; } return results ; }", "target": "<S2SV_ModStart> MOD_TYPE_IT ) { pChn = playState . Chn ; <S2SV_ModStart> ) ; nChn ++ , pChn"}
{"source": "CWE-125 static bool checkreturn decode_pointer_field ( pb_istream_t * stream , pb_wire_type_t wire_type , pb_field_iterator_t * iter ) { # ifndef PB_ENABLE_MALLOC UNUSED ( wire_type ) ; UNUSED ( iter ) ; PB_RETURN_ERROR ( stream , \"no<S2SV_blank>malloc<S2SV_blank>support\" ) ; # else pb_type_t type ; pb_decoder_t func ; type = iter -> pos -> type ; func = PB_DECODERS [ PB_LTYPE ( type ) ] ; switch ( PB_HTYPE ( type ) ) { case PB_HTYPE_REQUIRED : case PB_HTYPE_OPTIONAL : if ( PB_LTYPE ( type ) == PB_LTYPE_SUBMESSAGE && * ( void * * ) iter -> pData != NULL ) { pb_release_single_field ( iter ) ; } if ( PB_LTYPE ( type ) == PB_LTYPE_STRING || PB_LTYPE ( type ) == PB_LTYPE_BYTES ) { return func ( stream , iter -> pos , iter -> pData ) ; } else { if ( ! allocate_field ( stream , iter -> pData , iter -> pos -> data_size , 1 ) ) return false ; initialize_pointer_field ( * ( void * * ) iter -> pData , iter ) ; return func ( stream , iter -> pos , * ( void * * ) iter -> pData ) ; } case PB_HTYPE_REPEATED : if ( wire_type == PB_WT_STRING && PB_LTYPE ( type ) <= PB_LTYPE_LAST_PACKABLE ) { bool status = true ; size_t * size = ( size_t * ) iter -> pSize ; size_t allocated_size = * size ; void * pItem ; pb_istream_t substream ; if ( ! pb_make_string_substream ( stream , & substream ) ) return false ; while ( substream . bytes_left ) { if ( * size + 1 > allocated_size ) { allocated_size += ( substream . bytes_left - 1 ) / iter -> pos -> data_size + 1 ; if ( ! allocate_field ( & substream , iter -> pData , iter -> pos -> data_size , allocated_size ) ) { status = false ; break ; } } pItem = * ( uint8_t * * ) iter -> pData + iter -> pos -> data_size * ( * size ) ; initialize_pointer_field ( pItem , iter ) ; if ( ! func ( & substream , iter -> pos , pItem ) ) { status = false ; break ; } ( * size ) ++ ; } pb_close_string_substream ( stream , & substream ) ; return status ; } else { size_t * size = ( size_t * ) iter -> pSize ; void * pItem ; <S2SV_StartBug> ( * size ) ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! allocate_field ( stream , iter -> pData , iter -> pos -> data_size , * size ) ) <S2SV_EndBug> return false ; <S2SV_StartBug> pItem = * ( uint8_t * * ) iter -> pData + iter -> pos -> data_size * ( * size - 1 ) ; <S2SV_EndBug> initialize_pointer_field ( pItem , iter ) ; return func ( stream , iter -> pos , pItem ) ; } default : PB_RETURN_ERROR ( stream , \"invalid<S2SV_blank>field<S2SV_blank>type\" ) ; } # endif }", "target": "<S2SV_ModStart> * pItem ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> -> data_size , ( size_t ) ( * size + 1 ) <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( * size ) ; ( * size ) ++ <S2SV_ModEnd> ; initialize_pointer_field ("}
{"source": "CWE-787 GF_Err flac_dmx_process ( GF_Filter * filter ) { GF_FLACDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u8 * output ; u8 * start ; Bool final_flush = GF_FALSE ; u32 pck_size , remain , prev_pck_size ; u64 cts = GF_FILTER_NO_TS ; <S2SV_StartBug> FLACHeader hdr ; <S2SV_EndBug> if ( ! ctx -> duration . num ) flac_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> flac_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } final_flush = GF_TRUE ; } else { return GF_OK ; } } prev_pck_size = ctx -> flac_buffer_size ; if ( pck && ! ctx -> resume_from ) { u8 * data = ( u8 * ) gf_filter_pck_get_data ( pck , & pck_size ) ; if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { u64 byte_offset = gf_filter_pck_get_byte_offset ( pck ) ; if ( ! ctx -> flac_buffer_size ) { ctx -> byte_offset = byte_offset ; } else if ( ctx -> byte_offset + ctx -> flac_buffer_size != byte_offset ) { ctx -> byte_offset = GF_FILTER_NO_BO ; if ( ( byte_offset != GF_FILTER_NO_BO ) && ( byte_offset > ctx -> flac_buffer_size ) ) { ctx -> byte_offset = byte_offset - ctx -> flac_buffer_size ; } } } if ( ctx -> flac_buffer_size + pck_size > ctx -> flac_buffer_alloc ) { ctx -> flac_buffer_alloc = ctx -> flac_buffer_size + pck_size ; ctx -> flac_buffer = gf_realloc ( ctx -> flac_buffer , ctx -> flac_buffer_alloc ) ; } memcpy ( ctx -> flac_buffer + ctx -> flac_buffer_size , data , pck_size ) ; ctx -> flac_buffer_size += pck_size ; } if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } if ( cts == GF_FILTER_NO_TS ) { prev_pck_size = 0 ; } remain = ctx -> flac_buffer_size ; start = ctx -> flac_buffer ; if ( ctx -> resume_from ) { start += ctx -> resume_from - 1 ; remain -= ctx -> resume_from - 1 ; ctx -> resume_from = 0 ; } while ( remain > 2 ) { u32 next_frame = 0 , nb_samp ; u32 cur_size = remain - 2 ; u8 * cur_buf = start + 2 ; u8 * hdr_start = NULL ; if ( final_flush ) { next_frame = remain ; } else { while ( cur_size ) { hdr_start = memchr ( cur_buf , 0xFF , cur_size ) ; if ( ! hdr_start ) break ; next_frame = ( u32 ) ( hdr_start - start ) ; if ( next_frame == remain ) break ; if ( ( hdr_start [ 1 ] & 0xFC ) == 0xF8 ) { if ( flac_parse_header ( ctx , hdr_start , ( u32 ) remain - next_frame , & hdr ) ) break ; } cur_buf = hdr_start + 1 ; cur_size = ( u32 ) ( cur_buf - start ) ; assert ( cur_size <= remain ) ; cur_size = remain - cur_size ; hdr_start = NULL ; } if ( ! hdr_start ) break ; if ( next_frame == remain ) break ; } if ( ! ctx -> initialized ) { u32 size = next_frame ; u32 dsi_end = 0 ; gf_bs_reassign_buffer ( ctx -> bs , ctx -> flac_buffer , size ) ; u32 magic = gf_bs_read_u32 ( ctx -> bs ) ; if ( magic != GF_4CC ( 'f' , 'L' , 'a' , 'C' ) ) { <S2SV_StartBug> <S2SV_EndBug> } while ( gf_bs_available ( ctx -> bs ) ) { Bool last = gf_bs_read_int ( ctx -> bs , 1 ) ; u32 type = gf_bs_read_int ( ctx -> bs , 7 ) ; u32 len = gf_bs_read_int ( ctx -> bs , 24 ) ; if ( type == 0 ) { u16 min_block_size = gf_bs_read_u16 ( ctx -> bs ) ; u16 max_block_size = gf_bs_read_u16 ( ctx -> bs ) ; gf_bs_read_u24 ( ctx -> bs ) ; gf_bs_read_u24 ( ctx -> bs ) ; ctx -> sample_rate = gf_bs_read_int ( ctx -> bs , 20 ) ; ctx -> nb_channels = 1 + gf_bs_read_int ( ctx -> bs , 3 ) ; ctx -> bits_per_sample = 1 + gf_bs_read_int ( ctx -> bs , 5 ) ; if ( min_block_size == max_block_size ) ctx -> block_size = min_block_size ; else ctx -> block_size = 0 ; ctx -> duration . num = gf_bs_read_long_int ( ctx -> bs , 36 ) ; ctx -> duration . den = ctx -> sample_rate ; gf_bs_skip_bytes ( ctx -> bs , 16 ) ; dsi_end = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; } else { gf_bs_skip_bytes ( ctx -> bs , len ) ; } <S2SV_StartBug> if ( last ) break ; <S2SV_EndBug> } flac_dmx_check_pid ( filter , ctx , ctx -> flac_buffer + 4 , dsi_end - 4 ) ; remain -= size ; start += size ; ctx -> initialized = GF_TRUE ; if ( ! ctx -> is_playing ) break ; continue ; } if ( ( start [ 0 ] != 0xFF ) && ( ( start [ 1 ] & 0xFC ) != 0xF8 ) ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( \"[FLACDmx]<S2SV_blank>invalid<S2SV_blank>frame,<S2SV_blank>droping<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>resyncing\\\\n\" , next_frame ) ) ; start += next_frame ; remain -= next_frame ; continue ; } flac_parse_header ( ctx , start , next_frame , & hdr ) ; if ( hdr . sample_rate != ctx -> sample_rate ) { ctx -> sample_rate = hdr . sample_rate ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_SAMPLE_RATE , & PROP_UINT ( ctx -> sample_rate ) ) ; } nb_samp = hdr . block_size ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * ctx -> sample_rate ) ; if ( ctx -> cts + nb_samp >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } if ( ctx -> timescale && ! prev_pck_size && ( cts != GF_FILTER_NO_TS ) ) { ctx -> cts = cts ; cts = GF_FILTER_NO_TS ; } if ( ! ctx -> in_seek ) { dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , next_frame , & output ) ; memcpy ( output , start , next_frame ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; if ( ! ctx -> timescale || ( ctx -> timescale == ctx -> sample_rate ) ) gf_filter_pck_set_duration ( dst_pck , nb_samp ) ; else { gf_filter_pck_set_duration ( dst_pck , ( nb_samp * ctx -> timescale ) / ctx -> sample_rate ) ; } gf_filter_pck_set_sap ( dst_pck , GF_FILTER_SAP_1 ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , ctx -> byte_offset ) ; } gf_filter_pck_send ( dst_pck ) ; } flac_dmx_update_cts ( ctx , nb_samp ) ; assert ( start [ 0 ] == 0xFF ) ; assert ( ( start [ 1 ] & 0xFC ) == 0xF8 ) ; start += next_frame ; assert ( remain >= next_frame ) ; remain -= next_frame ; } if ( ! pck ) { ctx -> flac_buffer_size = 0 ; return flac_dmx_process ( filter ) ; } else { if ( remain < ctx -> flac_buffer_size ) { memmove ( ctx -> flac_buffer , start , remain ) ; } ctx -> flac_buffer_size = remain ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; } return GF_OK ; }", "target": "<S2SV_ModStart> ; FLACHeader hdr ; if ( ctx -> in_error ) return GF_NON_COMPLIANT_BITSTREAM <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( \"[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>magic\\\\n\" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM ; <S2SV_ModStart> last ) break ; } if ( ! dsi_end ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( \"[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>header\\\\n\" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM"}
{"source": "CWE-94 export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( \"export-desktop-XXXXXX\" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , \".service\" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( \".service\" ) ) ; dbus_name = g_key_file_get_string ( keyfile , \"D-BUS<S2SV_blank>Service\" , \"Name\" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( \"D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\\'%s\\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name\" ) , name ) ; } } if ( g_str_has_suffix ( name , \".desktop\" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , \"Application\" , \"tags\" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , \"X-Flatpak-Tags\" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , \"X-Flatpak\" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , \"X-Flatpak-RunOptions\" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , \"X-Flatpak-RunOptions\" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , \"TryExec\" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , \"X-GNOME-Bugzilla-ExtraInfoScript\" , NULL ) ; new_exec = g_string_new ( \"\" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR \"/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s\" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , \"%s\" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , \"Exec\" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , \"<S2SV_blank>--command=%s\" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , \"%f\" ) == 0 || strcasecmp ( old_argv [ j ] , \"%u\" ) == 0 ) { g_string_append ( new_exec , \"<S2SV_blank>--file-forwarding\" ) ; break ; } } g_string_append ( new_exec , \"<S2SV_blank>\" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , \"%f\" ) == 0 ) g_string_append_printf ( new_exec , \"<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@\" , arg ) ; else if ( strcasecmp ( arg , \"%u\" ) == 0 ) g_string_append_printf ( new_exec , \"<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@\" , arg ) ; else if ( g_str_has_prefix ( arg , \"@@\" ) ) <S2SV_StartBug> g_print ( _ ( \"Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\\n\" ) , arg ) ; <S2SV_EndBug> else g_string_append_printf ( new_exec , \"<S2SV_blank>%s\" , arg ) ; } } else { g_string_append ( new_exec , \"<S2SV_blank>\" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }", "target": "<S2SV_ModStart> \"@@\" ) ) { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( \"Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\" <S2SV_ModEnd> ) , arg <S2SV_ModStart> arg ) ; goto out ; }"}
{"source": "CWE-369 Status SparseTensorToCSRSparseMatrixCPUFunctor : : operator ( ) ( const int64 batch_size , const int num_rows , TTypes < int64 > : : ConstMatrix indices , TTypes < int32 > : : Vec batch_ptr , TTypes < int32 > : : Vec csr_row_ptr , TTypes < int32 > : : Vec csr_col_ind ) { if ( batch_ptr . size ( ) != batch_size + 1 ) { return errors : : InvalidArgument ( \"Expected<S2SV_blank>batch_ptr.size()<S2SV_blank>==<S2SV_blank>batch_size<S2SV_blank>+<S2SV_blank>1.<S2SV_blank>Got:<S2SV_blank>\" , batch_ptr . size ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , batch_size + 1 ) ; } if ( csr_row_ptr . size ( ) != batch_size * ( num_rows + 1 ) ) { return errors : : InvalidArgument ( \"Expected<S2SV_blank>csr_row_ptr.size()<S2SV_blank>==<S2SV_blank>batch_size<S2SV_blank>*<S2SV_blank>(num_rows<S2SV_blank>+<S2SV_blank>1).<S2SV_blank>Got:<S2SV_blank>\" , csr_row_ptr . size ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , batch_size * ( num_rows + 1 ) ) ; } const int64 total_nnz = indices . dimension ( 0 ) ; const int rank = indices . dimension ( 1 ) ; if ( rank == 2 && batch_size != 1 ) { return errors : : InvalidArgument ( \"Expected<S2SV_blank>batch_size<S2SV_blank>==<S2SV_blank>1<S2SV_blank>when<S2SV_blank>rank<S2SV_blank>is<S2SV_blank>2.<S2SV_blank>Got<S2SV_blank>batch_size:<S2SV_blank>\" , batch_size ) ; } if ( csr_col_ind . size ( ) != total_nnz ) { return errors : : InvalidArgument ( \"Expected<S2SV_blank>csr_col_ind.size()<S2SV_blank>==<S2SV_blank>total_nnz.<S2SV_blank>Got:<S2SV_blank>\" , csr_col_ind . size ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , total_nnz ) ; } int prev_batch = - 1 ; if ( rank == 2 ) { batch_ptr ( 0 ) = 0 ; ++ prev_batch ; for ( int64 i = 0 ; i < total_nnz ; ++ i ) { <S2SV_StartBug> csr_row_ptr ( indices ( i , 0 ) + 1 ) += 1 ; <S2SV_EndBug> csr_col_ind ( i ) = indices ( i , 1 ) ; } } else { for ( int64 i = 0 ; i < total_nnz ; ++ i ) { const int cur_batch = indices ( i , 0 ) ; csr_row_ptr ( cur_batch * ( num_rows + 1 ) + indices ( i , 1 ) + 1 ) += 1 ; csr_col_ind ( i ) = indices ( i , 2 ) ; while ( prev_batch < cur_batch ) { batch_ptr ( prev_batch + 1 ) = i ; ++ prev_batch ; } } } while ( prev_batch < batch_size ) { batch_ptr ( prev_batch + 1 ) = total_nnz ; ++ prev_batch ; } for ( int batch_idx = 0 ; batch_idx < batch_size ; ++ batch_idx ) { auto * row_ptr_batch = csr_row_ptr . data ( ) + batch_idx * ( num_rows + 1 ) ; std : : partial_sum ( row_ptr_batch , row_ptr_batch + num_rows + 1 , row_ptr_batch ) ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> i ) { int64 ix = indices ( i , 0 ) + 1 ; if ( ix >= csr_row_ptr . size ( ) ) { return errors : : InvalidArgument ( \"Got<S2SV_blank>an<S2SV_blank>index<S2SV_blank>\" , ix , \"<S2SV_blank>that<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>csr_row_ptr\" ) ; }"}
{"source": "CWE-369 TfLiteStatus EvalSimple ( TfLiteContext * context , TfLiteNode * node , const TfLiteTensor * lookup , const TfLiteTensor * value , TfLiteTensor * output ) { <S2SV_StartBug> const int row_size = SizeOfDimension ( value , 0 ) ; <S2SV_EndBug> const int row_bytes = value -> bytes / row_size ; char * output_raw = GetTensorData < char > ( output ) ; const char * value_raw = GetTensorData < char > ( value ) ; const int32_t * lookup_data = GetTensorData < int32_t > ( lookup ) ; for ( int i = 0 ; i < SizeOfDimension ( lookup , 0 ) ; i ++ ) { int idx = lookup_data [ i ] ; if ( idx >= row_size || idx < 0 ) { context -> ReportError ( context , \"Embedding<S2SV_blank>Lookup:<S2SV_blank>index<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.<S2SV_blank>\" \"Got<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>bounds<S2SV_blank>are<S2SV_blank>[0,<S2SV_blank>%d]\" , idx , row_size - 1 ) ; return kTfLiteError ; } else { std : : memcpy ( output_raw + i * row_bytes , value_raw + idx * row_bytes , row_bytes ) ; } } return kTfLiteOk ; }", "target": "<S2SV_ModStart> 0 ) ; if ( row_size == 0 ) { return kTfLiteOk ; }"}
{"source": "CWE-787 explicit ReverseSequenceOp ( OpKernelConstruction * context ) : OpKernel ( context ) { OP_REQUIRES_OK ( context , context -> GetAttr ( \"batch_dim\" , & batch_dim_ ) ) ; OP_REQUIRES_OK ( context , context -> GetAttr ( \"seq_dim\" , & seq_dim_ ) ) ; <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> ) ) ; OP_REQUIRES ( context , batch_dim_ >= 0 , errors : : InvalidArgument ( \"Invalid<S2SV_blank>batch_dim<S2SV_blank>\" , batch_dim_ ) ) ; OP_REQUIRES ( context , seq_dim_ >= 0 , errors : : InvalidArgument ( \"Invalid<S2SV_blank>seq_dim<S2SV_blank>\" , seq_dim_ ) ) ;"}
{"source": "CWE-295 static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( \"Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\\\n\" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , <S2SV_StartBug> FIELD_SIZE ) == 0 ) <S2SV_EndBug> cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( \"Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>succeeded.\\\\n\" ) ; ret = 0 ; goto free_cert ; } log_debug ( \"Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed.\\\\n\" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( \"Could<S2SV_blank>not<S2SV_blank>compute<S2SV_blank>certificate<S2SV_blank>sha256<S2SV_blank>digest.\\\\n\" ) ; goto free_cert ; } for ( i = 0 ; i < SHA256LEN ; i ++ ) sprintf ( & digest_str [ 2 * i ] , \"%02x\" , digest [ i ] ) ; digest_str [ SHA256STRLEN - 1 ] = '\\\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != NULL ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , SHA256STRLEN - 1 ) == 0 ) break ; if ( elem != NULL ) { log_debug ( \"Gateway<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>found<S2SV_blank>in<S2SV_blank>white<S2SV_blank>list.\\\\n\" ) ; ret = 0 ; goto free_cert ; } subject = X509_NAME_oneline ( subj , NULL , 0 ) ; issuer = X509_NAME_oneline ( X509_get_issuer_name ( cert ) , NULL , 0 ) ; log_error ( \"Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed,<S2SV_blank>and<S2SV_blank>the<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>in<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>local<S2SV_blank>whitelist.<S2SV_blank>If<S2SV_blank>you<S2SV_blank>trust<S2SV_blank>it,<S2SV_blank>rerun<S2SV_blank>with:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--trusted-cert<S2SV_blank>%s\\\\n\" , digest_str ) ; log_error ( \"or<S2SV_blank>add<S2SV_blank>this<S2SV_blank>line<S2SV_blank>to<S2SV_blank>your<S2SV_blank>config<S2SV_blank>file:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>trusted-cert<S2SV_blank>=<S2SV_blank>%s\\\\n\" , digest_str ) ; log_error ( \"Gateway<S2SV_blank>certificate:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>subject:\\\\n\" ) ; for ( line = strtok ( subject , \"/\" ) ; line != NULL ; line = strtok ( NULL , \"/\" ) ) log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , line ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>issuer:\\\\n\" ) ; for ( line = strtok ( issuer , \"/\" ) ; line != NULL ; line = strtok ( NULL , \"/\" ) ) log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , line ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>sha256<S2SV_blank>digest:\\\\n\" ) ; log_error ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , digest_str ) ; free_cert : X509_free ( cert ) ; return ret ; }", "target": "<S2SV_ModStart> ; # else if ( validate_hostname ( <S2SV_ModEnd> tunnel -> config <S2SV_ModStart> -> gateway_host , cert ) == MatchFound <S2SV_ModEnd> ) cert_valid ="}
{"source": "CWE-416 void CleanWriters ( GF_List * writers ) { while ( gf_list_count ( writers ) ) { <S2SV_StartBug> TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; <S2SV_EndBug> gf_isom_box_del ( writer -> stco ) ; gf_isom_box_del ( ( GF_Box * ) writer -> stsc ) ; gf_free ( writer ) ; gf_list_rem ( writers , 0 ) ; } }", "target": "<S2SV_ModStart> writers , 0 ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc"}
{"source": "CWE-416 GF_Err stbl_GetSampleInfos ( GF_SampleTableBox * stbl , u32 sampleNumber , u64 * offset , u32 * chunkNumber , u32 * descIndex , GF_StscEntry * * out_ent ) { GF_Err e ; u32 i , k , offsetInChunk , size , chunk_num ; GF_ChunkOffsetBox * stco ; GF_ChunkLargeOffsetBox * co64 ; GF_StscEntry * ent ; ( * offset ) = 0 ; ( * chunkNumber ) = ( * descIndex ) = 0 ; if ( out_ent ) ( * out_ent ) = NULL ; if ( ! stbl || ! sampleNumber ) return GF_BAD_PARAM ; if ( ! stbl -> ChunkOffset || ! stbl -> SampleToChunk || ! stbl -> SampleSize ) return GF_ISOM_INVALID_FILE ; if ( stbl -> SampleSize && stbl -> SampleToChunk -> nb_entries == stbl -> SampleSize -> sampleCount ) { ent = & stbl -> SampleToChunk -> entries [ sampleNumber - 1 ] ; if ( ! ent ) return GF_BAD_PARAM ; ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = sampleNumber ; if ( out_ent ) * out_ent = ent ; if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( ! stco -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> <S2SV_EndBug> ( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ; } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; <S2SV_StartBug> if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> ( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ; } return GF_OK ; } if ( stbl -> SampleToChunk -> firstSampleInCurrentChunk && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ) { i = stbl -> SampleToChunk -> currentIndex ; ent = & stbl -> SampleToChunk -> entries [ stbl -> SampleToChunk -> currentIndex ] ; GetGhostNum ( ent , i , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } else { i = 0 ; stbl -> SampleToChunk -> currentIndex = 0 ; stbl -> SampleToChunk -> currentChunk = 1 ; stbl -> SampleToChunk -> ghostNumber = 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk = 1 ; ent = & stbl -> SampleToChunk -> entries [ 0 ] ; GetGhostNum ( ent , 0 , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } for ( ; i < stbl -> SampleToChunk -> nb_entries ; i ++ ) { assert ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ; if ( k > stbl -> SampleToChunk -> ghostNumber ) { return GF_ISOM_INVALID_FILE ; } u32 max_chunks_in_entry = stbl -> SampleToChunk -> ghostNumber - k ; u32 nb_chunks_for_sample = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; if ( ent -> samplesPerChunk ) nb_chunks_for_sample /= ent -> samplesPerChunk ; if ( ( nb_chunks_for_sample <= max_chunks_in_entry ) && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk + ( nb_chunks_for_sample + 1 ) * ent -> samplesPerChunk > sampleNumber ) ) { stbl -> SampleToChunk -> firstSampleInCurrentChunk += nb_chunks_for_sample * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += nb_chunks_for_sample ; goto sample_found ; } max_chunks_in_entry += 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk += max_chunks_in_entry * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += max_chunks_in_entry ; if ( i + 1 != stbl -> SampleToChunk -> nb_entries ) { ent = & stbl -> SampleToChunk -> entries [ i + 1 ] ; GetGhostNum ( ent , i + 1 , stbl -> SampleToChunk -> nb_entries , stbl ) ; stbl -> SampleToChunk -> currentIndex = i + 1 ; stbl -> SampleToChunk -> currentChunk = 1 ; k = 1 ; } } return GF_ISOM_INVALID_FILE ; sample_found : ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = chunk_num = ent -> firstChunk + stbl -> SampleToChunk -> currentChunk - 1 ; if ( out_ent ) * out_ent = ent ; if ( ! * chunkNumber ) return GF_ISOM_INVALID_FILE ; offsetInChunk = 0 ; if ( stbl -> SampleSize && stbl -> SampleSize -> sampleSize ) { u32 diff = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; offsetInChunk += diff * stbl -> SampleSize -> sampleSize ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num == sampleNumber ) ) { offsetInChunk = stbl -> r_last_offset_in_chunk ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num + 1 == sampleNumber ) ) { e = stbl_GetSampleSize ( stbl -> SampleSize , stbl -> r_last_sample_num , & size ) ; if ( e ) return e ; stbl -> r_last_offset_in_chunk += size ; stbl -> r_last_sample_num = sampleNumber ; offsetInChunk = stbl -> r_last_offset_in_chunk ; } else { for ( i = stbl -> SampleToChunk -> firstSampleInCurrentChunk ; i < sampleNumber ; i ++ ) { e = stbl_GetSampleSize ( stbl -> SampleSize , i , & size ) ; if ( e ) return e ; offsetInChunk += size ; } stbl -> r_last_chunk_num = chunk_num ; stbl -> r_last_sample_num = sampleNumber ; stbl -> r_last_offset_in_chunk = offsetInChunk ; } if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( stco -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = ( u64 ) stco -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; if ( co64 -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = co64 -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } return GF_OK ; }", "target": "<S2SV_ModStart> return GF_ISOM_INVALID_FILE ; if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> co64 -> offsets ) return GF_ISOM_INVALID_FILE ; if ( co64 -> nb_entries < sampleNumber"}
{"source": "CWE-134 static mf_t * open_mf_pattern ( void * talloc_ctx , struct demuxer * d , char * filename ) { struct mp_log * log = d -> log ; int error_count = 0 ; int count = 0 ; mf_t * mf = talloc_zero ( talloc_ctx , mf_t ) ; mf -> log = log ; if ( filename [ 0 ] == '@' ) { struct stream * s = stream_create ( filename + 1 , d -> stream_origin | STREAM_READ , d -> cancel , d -> global ) ; if ( s ) { while ( 1 ) { char buf [ 512 ] ; int len = stream_read_peek ( s , buf , sizeof ( buf ) ) ; if ( ! len ) break ; bstr data = ( bstr ) { buf , len } ; int pos = bstrchr ( data , '\\\\n' ) ; data = bstr_splice ( data , 0 , pos < 0 ? data . len : pos + 1 ) ; bstr fname = bstr_strip ( data ) ; if ( fname . len ) { if ( bstrchr ( fname , '\\\\0' ) >= 0 ) { mp_err ( log , \"invalid<S2SV_blank>filename\\\\n\" ) ; break ; } char * entry = bstrto0 ( mf , fname ) ; if ( ! mp_path_exists ( entry ) ) { mp_verbose ( log , \"file<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>\\'%s\\'\\\\n\" , entry ) ; } else { MP_TARRAY_APPEND ( mf , mf -> names , mf -> nr_of_files , entry ) ; } } stream_seek_skip ( s , stream_tell ( s ) + data . len ) ; } free_stream ( s ) ; mp_info ( log , \"number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\\\n\" , mf -> nr_of_files ) ; goto exit_mf ; } mp_info ( log , \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>indirect<S2SV_blank>filelist\\\\n\" , filename + 1 ) ; } if ( strchr ( filename , ',' ) ) { mp_info ( log , \"filelist:<S2SV_blank>%s\\\\n\" , filename ) ; bstr bfilename = bstr0 ( filename ) ; while ( bfilename . len ) { bstr bfname ; bstr_split_tok ( bfilename , \",\" , & bfname , & bfilename ) ; char * fname2 = bstrdup0 ( mf , bfname ) ; if ( ! mp_path_exists ( fname2 ) ) mp_verbose ( log , \"file<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>\\'%s\\'\\\\n\" , fname2 ) ; else { mf_add ( mf , fname2 ) ; } talloc_free ( fname2 ) ; } mp_info ( log , \"number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\\\n\" , mf -> nr_of_files ) ; goto exit_mf ; } <S2SV_StartBug> char * fname = talloc_size ( mf , strlen ( filename ) + 32 ) ; <S2SV_EndBug> # if HAVE_GLOB if ( ! strchr ( filename , '%' ) ) { strcpy ( fname , filename ) ; if ( ! strchr ( filename , '*' ) ) strcat ( fname , \"*\" ) ; mp_info ( log , \"search<S2SV_blank>expr:<S2SV_blank>%s\\\\n\" , fname ) ; glob_t gg ; if ( glob ( fname , 0 , NULL , & gg ) ) { talloc_free ( mf ) ; return NULL ; } for ( int i = 0 ; i < gg . gl_pathc ; i ++ ) { if ( mp_path_isdir ( gg . gl_pathv [ i ] ) ) continue ; mf_add ( mf , gg . gl_pathv [ i ] ) ; } mp_info ( log , \"number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\\\n\" , mf -> nr_of_files ) ; globfree ( & gg ) ; goto exit_mf ; } # endif <S2SV_StartBug> mp_info ( log , \"search<S2SV_blank>expr:<S2SV_blank>%s\\\\n\" , filename ) ; <S2SV_EndBug> while ( error_count < 5 ) { <S2SV_StartBug> sprintf ( fname , filename , count ++ ) ; <S2SV_EndBug> if ( ! mp_path_exists ( fname ) ) { error_count ++ ; mp_verbose ( log , \"file<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>\\'%s\\'\\\\n\" , fname ) ; } else { mf_add ( mf , fname ) ; } } mp_info ( log , \"number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\\\n\" , mf -> nr_of_files ) ; exit_mf : return mf ; }", "target": "<S2SV_ModStart> exit_mf ; } size_t fname_avail = <S2SV_ModEnd> strlen ( filename <S2SV_ModStart> ) + 32 ; char * fname = talloc_size ( mf , fname_avail <S2SV_ModStart> } # endif const char * f = filename ; int MAXDIGS = 3 , nspec = 0 , bad_spec = 0 , c ; while ( nspec < 2 && ( c = * f ++ ) ) { if ( c != '%' ) continue ; if ( * f != '%' ) { nspec ++ ; if ( * f == '.' ) f ++ ; for ( int ndig = 0 ; mp_isdigit ( * f ) && ndig < MAXDIGS ; ndig ++ , f ++ ) ; if ( * f != 'd' ) { bad_spec ++ ; break ; } } f ++ ; } if ( bad_spec || nspec != 1 ) { mp_err ( log , \"unsupported<S2SV_blank>expr<S2SV_blank>format:<S2SV_blank>\\'%s\\'\\\\n\" , filename ) ; goto exit_mf ; } <S2SV_ModStart> 5 ) { if ( snprintf ( fname , fname_avail <S2SV_ModEnd> , filename , <S2SV_ModStart> count ++ ) >= fname_avail ) { mp_err ( log , \"format<S2SV_blank>result<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\'%s\\'\\\\n\" , filename ) ; goto exit_mf ; } <S2SV_ModEnd> if ( !"}
{"source": "CWE-125 CallResult < bool > JSObject : : putComputedWithReceiver_RJS ( Handle < JSObject > selfHandle , Runtime * runtime , Handle < > nameValHandle , Handle < > valueHandle , Handle < > receiver , PropOpFlags opFlags ) { assert ( ! opFlags . getMustExist ( ) && \"mustExist<S2SV_blank>flag<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>properties\" ) ; if ( selfHandle -> flags_ . fastIndexProperties ) { if ( auto arrayIndex = toArrayIndexFastPath ( * nameValHandle ) ) { if ( selfHandle . getHermesValue ( ) . getRaw ( ) == receiver -> getRaw ( ) ) { if ( haveOwnIndexed ( selfHandle . get ( ) , runtime , * arrayIndex ) ) { auto result = setOwnIndexed ( selfHandle , runtime , * arrayIndex , valueHandle ) ; if ( LLVM_UNLIKELY ( result == ExecutionStatus : : EXCEPTION ) ) return ExecutionStatus : : EXCEPTION ; if ( LLVM_LIKELY ( * result ) ) return true ; if ( opFlags . getThrowOnError ( ) ) { return runtime -> raiseTypeError ( \"Cannot<S2SV_blank>assign<S2SV_blank>to<S2SV_blank>read-only<S2SV_blank>property\" ) ; } return false ; } } } } auto converted = toPropertyKeyIfObject ( runtime , nameValHandle ) ; if ( LLVM_UNLIKELY ( converted == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } auto nameValPrimitiveHandle = * converted ; ComputedPropertyDescriptor desc ; MutableHandle < JSObject > propObj { runtime } ; if ( LLVM_UNLIKELY ( getComputedPrimitiveDescriptor ( selfHandle , runtime , nameValPrimitiveHandle , propObj , desc ) == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } if ( propObj ) { if ( LLVM_LIKELY ( selfHandle == propObj && selfHandle . getHermesValue ( ) . getRaw ( ) == receiver -> getRaw ( ) && ! desc . flags . accessor && ! desc . flags . internalSetter && ! desc . flags . hostObject && ! desc . flags . proxyObject && desc . flags . writable ) ) { if ( LLVM_UNLIKELY ( setComputedSlotValue ( selfHandle , runtime , desc , valueHandle ) == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } return true ; } if ( LLVM_UNLIKELY ( desc . flags . accessor ) ) { auto * accessor = vmcast < PropertyAccessor > ( getComputedSlotValue ( propObj . get ( ) , runtime , desc ) ) ; if ( ! accessor -> setter ) { if ( opFlags . getThrowOnError ( ) ) { return runtime -> raiseTypeErrorForValue ( \"Cannot<S2SV_blank>assign<S2SV_blank>to<S2SV_blank>property<S2SV_blank>\" , nameValPrimitiveHandle , \"<S2SV_blank>which<S2SV_blank>has<S2SV_blank>only<S2SV_blank>a<S2SV_blank>getter\" ) ; } return false ; } if ( accessor -> setter . get ( runtime ) -> executeCall1 ( runtime -> makeHandle ( accessor -> setter ) , runtime , receiver , valueHandle . get ( ) ) == ExecutionStatus : : EXCEPTION ) { return ExecutionStatus : : EXCEPTION ; } return true ; } if ( LLVM_UNLIKELY ( desc . flags . proxyObject ) ) { assert ( ! opFlags . getMustExist ( ) && \"MustExist<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>Proxy<S2SV_blank>objects\" ) ; CallResult < Handle < >> key = toPropertyKey ( runtime , nameValPrimitiveHandle ) ; if ( key == ExecutionStatus : : EXCEPTION ) return ExecutionStatus : : EXCEPTION ; CallResult < bool > setRes = JSProxy : : setComputed ( propObj , runtime , * key , valueHandle , receiver ) ; if ( LLVM_UNLIKELY ( setRes == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } if ( ! * setRes && opFlags . getThrowOnError ( ) ) { return runtime -> raiseTypeError ( TwineChar16 ( \"Proxy<S2SV_blank>trap<S2SV_blank>returned<S2SV_blank>false<S2SV_blank>for<S2SV_blank>property\" ) ) ; } return setRes ; } if ( LLVM_UNLIKELY ( ! desc . flags . writable ) ) { if ( desc . flags . staticBuiltin ) { SymbolID id { } ; LAZY_TO_IDENTIFIER ( runtime , nameValPrimitiveHandle , id ) ; return raiseErrorForOverridingStaticBuiltin ( selfHandle , runtime , runtime -> makeHandle ( id ) ) ; } if ( opFlags . getThrowOnError ( ) ) { return runtime -> raiseTypeErrorForValue ( \"Cannot<S2SV_blank>assign<S2SV_blank>to<S2SV_blank>read-only<S2SV_blank>property<S2SV_blank>\" , nameValPrimitiveHandle , \"\" ) ; } return false ; } if ( selfHandle == propObj && desc . flags . internalSetter ) { SymbolID id { } ; LAZY_TO_IDENTIFIER ( runtime , nameValPrimitiveHandle , id ) ; return internalSetter ( selfHandle , runtime , id , desc . castToNamedPropertyDescriptorRef ( ) , valueHandle , opFlags ) ; } } MutableHandle < JSObject > receiverHandle { runtime , * selfHandle } ; if ( selfHandle . getHermesValue ( ) . getRaw ( ) != receiver -> getRaw ( ) || receiverHandle -> isHostObject ( ) || receiverHandle -> isProxyObject ( ) ) { if ( selfHandle . getHermesValue ( ) . getRaw ( ) != receiver -> getRaw ( ) ) { receiverHandle = dyn_vmcast < JSObject > ( * receiver ) ; } if ( ! receiverHandle ) { return false ; } CallResult < bool > descDefinedRes = getOwnComputedPrimitiveDescriptor ( receiverHandle , runtime , nameValPrimitiveHandle , IgnoreProxy : : No , desc ) ; if ( LLVM_UNLIKELY ( descDefinedRes == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } DefinePropertyFlags dpf ; if ( * descDefinedRes ) { if ( LLVM_UNLIKELY ( desc . flags . accessor || ! desc . flags . writable ) ) { return false ; } if ( LLVM_LIKELY ( ! desc . flags . internalSetter && ! receiverHandle -> isHostObject ( ) && ! receiverHandle -> isProxyObject ( ) ) ) { if ( LLVM_UNLIKELY ( setComputedSlotValue ( receiverHandle , runtime , desc , valueHandle ) == ExecutionStatus : : EXCEPTION ) ) { return ExecutionStatus : : EXCEPTION ; } return true ; } } if ( LLVM_UNLIKELY ( desc . flags . internalSetter || receiverHandle -> isHostObject ( ) || receiverHandle -> isProxyObject ( ) ) ) { <S2SV_StartBug> SymbolID id { } ; <S2SV_EndBug> LAZY_TO_IDENTIFIER ( runtime , nameValPrimitiveHandle , id ) ; if ( desc . flags . internalSetter ) { return internalSetter ( receiverHandle , runtime , id , desc . castToNamedPropertyDescriptorRef ( ) , valueHandle , opFlags ) ; <S2SV_StartBug> } else if ( receiverHandle -> isHostObject ( ) ) { <S2SV_EndBug> <S2SV_StartBug> return vmcast < HostObject > ( receiverHandle . get ( ) ) -> set ( id , * valueHandle ) ; <S2SV_EndBug> } assert ( receiverHandle -> isProxyObject ( ) && \"descriptor<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>impossible\" ) ; if ( * descDefinedRes ) { dpf . setValue = 1 ; } else { dpf = DefinePropertyFlags : : getDefaultNewPropertyFlags ( ) ; } return JSProxy : : defineOwnProperty ( receiverHandle , runtime , nameValPrimitiveHandle , dpf , valueHandle , opFlags ) ; } } if ( LLVM_UNLIKELY ( ! receiverHandle -> isExtensible ( ) ) ) { if ( opFlags . getThrowOnError ( ) ) { return runtime -> raiseTypeError ( \"cannot<S2SV_blank>add<S2SV_blank>a<S2SV_blank>new<S2SV_blank>property\" ) ; } return false ; } if ( receiverHandle -> flags_ . indexedStorage ) { OptValue < uint32_t > arrayIndex ; MutableHandle < StringPrimitive > strPrim { runtime } ; TO_ARRAY_INDEX ( runtime , nameValPrimitiveHandle , strPrim , arrayIndex ) ; if ( arrayIndex ) { if ( auto * array = dyn_vmcast < JSArray > ( receiverHandle . get ( ) ) ) { if ( LLVM_UNLIKELY ( * arrayIndex >= JSArray : : getLength ( array ) ) ) { auto cr = putNamed_RJS ( receiverHandle , runtime , Predefined : : getSymbolID ( Predefined : : length ) , runtime -> makeHandle ( HermesValue : : encodeNumberValue ( * arrayIndex + 1 ) ) , opFlags ) ; if ( LLVM_UNLIKELY ( cr == ExecutionStatus : : EXCEPTION ) ) return ExecutionStatus : : EXCEPTION ; if ( LLVM_UNLIKELY ( ! * cr ) ) return false ; } } auto result = setOwnIndexed ( receiverHandle , runtime , * arrayIndex , valueHandle ) ; if ( LLVM_UNLIKELY ( result == ExecutionStatus : : EXCEPTION ) ) return ExecutionStatus : : EXCEPTION ; if ( LLVM_LIKELY ( * result ) ) return true ; if ( opFlags . getThrowOnError ( ) ) { return runtime -> raiseTypeError ( \"Cannot<S2SV_blank>assign<S2SV_blank>to<S2SV_blank>read-only<S2SV_blank>property\" ) ; } return false ; } } SymbolID id { } ; LAZY_TO_IDENTIFIER ( runtime , nameValPrimitiveHandle , id ) ; return addOwnProperty ( receiverHandle , runtime , id , DefinePropertyFlags : : getDefaultNewPropertyFlags ( ) , valueHandle , opFlags ) ; }", "target": "<S2SV_ModStart> ) ) { if ( receiverHandle -> isProxyObject ( ) ) { if ( * descDefinedRes ) { dpf . setValue = 1 ; } else { dpf = DefinePropertyFlags : : getDefaultNewPropertyFlags ( ) ; } return JSProxy : : defineOwnProperty ( receiverHandle , runtime , nameValPrimitiveHandle , dpf , valueHandle , opFlags ) ; } <S2SV_ModStart> ) ; } assert ( <S2SV_ModEnd> receiverHandle -> isHostObject <S2SV_ModStart> isHostObject ( ) && \"descriptor<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>impossible\" ) ; <S2SV_ModEnd> return vmcast < <S2SV_ModStart> , * valueHandle <S2SV_ModEnd> ) ; }"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { std : : unordered_map < int64 , int64 > old_row_to_new_row_map ; std : : vector < bool > row_id_present ; const Tensor * row_remapping_t ; OP_REQUIRES_OK ( context , context -> input ( \"row_remapping\" , & row_remapping_t ) ) ; const auto row_remapping = row_remapping_t -> vec < int64 > ( ) ; OP_REQUIRES ( context , row_remapping . size ( ) == num_rows_ , errors : : InvalidArgument ( strings : : StrCat ( \"Size<S2SV_blank>of<S2SV_blank>row_remapping<S2SV_blank>is<S2SV_blank>\" , row_remapping . size ( ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>being<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>num_rows=\" , num_rows_ ) ) ) ; OP_REQUIRES_OK ( context , RemapVectorToMap ( row_remapping , & row_id_present , & old_row_to_new_row_map ) ) ; int64 min_old_row = - 1 ; int64 max_old_row = - 1 ; for ( int i = 0 ; i < row_remapping . size ( ) ; ++ i ) { if ( min_old_row < 0 || ( row_remapping ( i ) >= 0 && row_remapping ( i ) < min_old_row ) ) { min_old_row = row_remapping ( i ) ; } if ( max_old_row < 0 || ( row_remapping ( i ) >= 0 && row_remapping ( i ) > max_old_row ) ) { max_old_row = row_remapping ( i ) ; } } std : : unordered_map < int64 , int64 > old_col_to_new_col_map ; std : : vector < bool > col_id_present ; const Tensor * col_remapping_t ; OP_REQUIRES_OK ( context , context -> input ( \"col_remapping\" , & col_remapping_t ) ) ; const auto col_remapping = col_remapping_t -> vec < int64 > ( ) ; const bool remap_cols = col_remapping . size ( ) > 0 ; if ( remap_cols ) { OP_REQUIRES ( context , col_remapping . size ( ) == num_cols_ , errors : : InvalidArgument ( strings : : StrCat ( \"Provided<S2SV_blank>col_remapping,<S2SV_blank>but<S2SV_blank>its<S2SV_blank>size<S2SV_blank>is<S2SV_blank>\" , col_remapping . size ( ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>being<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>num_cols=\" , num_cols_ ) ) ) ; OP_REQUIRES_OK ( context , RemapVectorToMap ( col_remapping , & col_id_present , & old_col_to_new_col_map ) ) ; } else { col_id_present . clear ( ) ; col_id_present . resize ( num_cols_ , true ) ; } const Tensor * ckpt_path_t ; <S2SV_StartBug> OP_REQUIRES_OK ( context , context -> input ( \"ckpt_path\" , & ckpt_path_t ) ) ; <S2SV_EndBug> const string & ckpt_path = ckpt_path_t -> scalar < tstring > ( ) ( ) ; const Tensor * old_tensor_name_t ; OP_REQUIRES_OK ( context , context -> input ( \"old_tensor_name\" , & old_tensor_name_t ) ) ; const string & old_tensor_name = old_tensor_name_t -> scalar < tstring > ( ) ( ) ; LOG ( INFO ) << \"Processing<S2SV_blank>checkpoint<S2SV_blank>:<S2SV_blank>\" << ckpt_path ; BundleReader reader ( context -> env ( ) , ckpt_path ) ; OP_REQUIRES_OK ( context , reader . status ( ) ) ; DataType tensor_type ; TensorShape tensor_shape ; OP_REQUIRES_OK ( context , reader . LookupDtypeAndShape ( old_tensor_name , & tensor_type , & tensor_shape ) ) ; OP_REQUIRES ( context , tensor_type == DT_FLOAT , errors : : InvalidArgument ( strings : : StrCat ( \"Tensor<S2SV_blank>\" , old_tensor_name , \"<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( tensor_type ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>expected<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( DT_FLOAT ) ) ) ) ; OP_REQUIRES ( context , tensor_shape . dims ( ) == 2 , errors : : InvalidArgument ( strings : : StrCat ( \"Tensor<S2SV_blank>\" , old_tensor_name , \"<S2SV_blank>has<S2SV_blank>shape<S2SV_blank>\" , tensor_shape . DebugString ( ) , \"<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>rank<S2SV_blank>\" , tensor_shape . dims ( ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>expected<S2SV_blank>shape<S2SV_blank>of<S2SV_blank>rank<S2SV_blank>2.\" ) ) ) ; if ( ! remap_cols ) { OP_REQUIRES ( context , num_cols_ == tensor_shape . dim_size ( 1 ) , errors : : InvalidArgument ( strings : : StrCat ( \"Tensor<S2SV_blank>\" , old_tensor_name , \"<S2SV_blank>has<S2SV_blank>shape<S2SV_blank>\" , tensor_shape . DebugString ( ) , \",<S2SV_blank>where<S2SV_blank>the<S2SV_blank>size<S2SV_blank>of<S2SV_blank>its<S2SV_blank>2nd<S2SV_blank>dimension<S2SV_blank>is<S2SV_blank>\" , tensor_shape . dim_size ( 1 ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>being<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>num_cols=\" , num_cols_ ) ) ) ; } std : : vector < TensorSlice > tensor_slices ; TensorSlice slice ( tensor_shape . dims ( ) ) ; if ( min_old_row >= 0 && max_old_row >= 0 ) { int64 row_start = min_old_row ; while ( row_start <= max_old_row ) { const int64 slice_length = max_rows_in_memory_ <= 0 ? max_old_row - row_start + 1 : std : : min ( max_rows_in_memory_ , max_old_row - row_start + 1 ) ; slice . set_start ( 0 , row_start ) ; slice . set_length ( 0 , slice_length ) ; tensor_slices . push_back ( slice ) ; row_start += slice_length ; } } Tensor * output_matrix_t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"output_matrix\" , TensorShape ( { num_rows_ , num_cols_ } ) , & output_matrix_t ) ) ; auto output_matrix = output_matrix_t -> matrix < float > ( ) ; int64 row_index = min_old_row ; int64 rows_copied = 0 ; Tensor loaded_tensor_t ; for ( const TensorSlice & tensor_slice : tensor_slices ) { LOG ( INFO ) << \"Loading<S2SV_blank>slice<S2SV_blank>\" << tensor_slice . DebugString ( ) ; TensorShape slice_shape ; OP_REQUIRES_OK ( context , tensor_slice . SliceTensorShape ( tensor_shape , & slice_shape ) ) ; if ( loaded_tensor_t . shape ( ) != slice_shape ) { loaded_tensor_t = Tensor ( DT_FLOAT , slice_shape ) ; } OP_REQUIRES_OK ( context , reader . LookupSlice ( old_tensor_name , tensor_slice , & loaded_tensor_t ) ) ; for ( int row = 0 ; row < loaded_tensor_t . dim_size ( 0 ) ; ++ row , ++ row_index ) { if ( row_index % 500000 == min_old_row ) { LOG ( INFO ) << \"Processing<S2SV_blank>old<S2SV_blank>row<S2SV_blank>\" << row_index ; } const int64 * new_row_ptr = gtl : : FindOrNull ( old_row_to_new_row_map , row_index ) ; if ( new_row_ptr == nullptr ) { continue ; } ++ rows_copied ; const int64 new_row = * new_row_ptr ; const auto & loaded_tensor = loaded_tensor_t . matrix < float > ( ) ; for ( int old_col = 0 ; old_col < loaded_tensor_t . dim_size ( 1 ) ; ++ old_col ) { int64 new_col = old_col ; if ( remap_cols ) { const int64 * new_col_ptr = gtl : : FindOrNull ( old_col_to_new_col_map , old_col ) ; if ( new_col_ptr == nullptr ) { continue ; } new_col = * new_col_ptr ; } OP_REQUIRES ( context , new_row < num_rows_ && new_col < num_cols_ && new_row >= 0 && new_col >= 0 , errors : : Internal ( strings : : StrCat ( \"new_row=\" , new_row , \"<S2SV_blank>and<S2SV_blank>new_col=\" , new_col , \"<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>less<S2SV_blank>than<S2SV_blank>num_rows_=\" , num_rows_ , \"<S2SV_blank>and<S2SV_blank>num_cols_=\" , num_cols_ , \"<S2SV_blank>and<S2SV_blank>non-negative.<S2SV_blank>This<S2SV_blank>should<S2SV_blank>never<S2SV_blank>have<S2SV_blank>happened<S2SV_blank>\" \"if<S2SV_blank>the<S2SV_blank>code<S2SV_blank>were<S2SV_blank>correct.<S2SV_blank>Please<S2SV_blank>file<S2SV_blank>a<S2SV_blank>bug.\" ) ) ) ; output_matrix ( new_row , new_col ) = loaded_tensor ( row , old_col ) ; } } } LOG ( INFO ) << \"Copied<S2SV_blank>\" << rows_copied << \"<S2SV_blank>rows<S2SV_blank>from<S2SV_blank>old<S2SV_blank>matrix<S2SV_blank>(with<S2SV_blank>\" << tensor_shape . dim_size ( 0 ) << \"<S2SV_blank>rows)<S2SV_blank>to<S2SV_blank>new<S2SV_blank>matrix<S2SV_blank>(with<S2SV_blank>\" << num_rows_ << \"<S2SV_blank>rows).\" ; const Tensor * initializing_values_t ; OP_REQUIRES_OK ( context , context -> input ( \"initializing_values\" , & initializing_values_t ) ) ; const auto initializing_values = initializing_values_t -> flat < float > ( ) ; int64 initializing_values_index = 0 ; for ( int i = 0 ; i < num_rows_ ; ++ i ) { for ( int j = 0 ; j < num_cols_ ; ++ j ) { if ( row_id_present [ i ] && col_id_present [ j ] ) continue ; OP_REQUIRES ( context , initializing_values_index < initializing_values . size ( ) , errors : : InvalidArgument ( \"initializing_values<S2SV_blank>contained<S2SV_blank>\" , initializing_values . size ( ) , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>more<S2SV_blank>missing<S2SV_blank>values<S2SV_blank>remain.\" ) ) ; output_matrix ( i , j ) = initializing_values ( initializing_values_index ) ; ++ initializing_values_index ; } } OP_REQUIRES ( context , initializing_values_index == initializing_values . size ( ) , errors : : InvalidArgument ( \"initializing_values<S2SV_blank>contained<S2SV_blank>\" , initializing_values . size ( ) , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>only<S2SV_blank>\" , initializing_values_index , \"<S2SV_blank>elements<S2SV_blank>were<S2SV_blank>used<S2SV_blank>to<S2SV_blank>fill<S2SV_blank>in<S2SV_blank>missing<S2SV_blank>values.\" ) ) ; }", "target": "<S2SV_ModStart> , & ckpt_path_t ) ) ; OP_REQUIRES ( context , ckpt_path_t -> NumElements ( ) == 1 , errors : : InvalidArgument ( \"The<S2SV_blank>`ckpt_path`<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>exactly<S2SV_blank>one<S2SV_blank>\" \"element,<S2SV_blank>got<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>shape<S2SV_blank>\" , ckpt_path_t -> shape ( ) . DebugString ( )"}
{"source": "CWE-125 void Compute ( OpKernelContext * ctx ) override { <S2SV_StartBug> const Tensor & input = ctx -> input ( 0 ) ; <S2SV_EndBug> const float input_min_float = ctx -> input ( 1 ) . flat < float > ( ) ( 0 ) ; const float input_max_float = ctx -> input ( 2 ) . flat < float > ( ) ( 0 ) ; Tensor * output_min = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { } ) , & output_min ) ) ; Tensor * output_max = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , TensorShape ( { } ) , & output_max ) ) ; qint32 used_min_quantized ; qint32 used_max_quantized ; CalculateUsedRange ( input , & used_min_quantized , & used_max_quantized ) ; const float used_min_float = std : : min ( 0.0f , QuantizedToFloat ( used_min_quantized , input_min_float , input_max_float ) ) ; const float used_max_float = QuantizedToFloat ( used_max_quantized , input_min_float , input_max_float ) ; output_min -> flat < float > ( ) . setConstant ( used_min_float ) ; output_max -> flat < float > ( ) . setConstant ( used_max_float ) ; }", "target": "<S2SV_ModStart> input ( 0 ) ; OP_REQUIRES ( ctx , ctx -> input ( 1 ) . NumElements ( ) > 0 , errors : : InvalidArgument ( \"Input<S2SV_blank>min<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty.\" ) ) ; OP_REQUIRES ( ctx , ctx -> input ( 2 ) . NumElements ( ) > 0 , errors : : InvalidArgument ( \"Input<S2SV_blank>max<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty.\" )"}
{"source": "CWE-703 void Compute ( OpKernelContext * ctx ) override { const Tensor & shape_t = ctx -> input ( 0 ) ; const Tensor & alpha_t = ctx -> input ( 1 ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( shape_t . shape ( ) ) && ( shape_t . dtype ( ) == DataType : : DT_INT32 || shape_t . dtype ( ) == DataType : : DT_INT64 ) , errors : : InvalidArgument ( \"shape<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>of<S2SV_blank>{int32,int64},<S2SV_blank>got<S2SV_blank>shape:<S2SV_blank>\" , shape_t . DebugString ( ) ) ) ; TensorShape samples_shape ; if ( shape_t . dtype ( ) == DataType : : DT_INT32 ) { auto vec = shape_t . flat < int32 > ( ) ; OP_REQUIRES_OK ( ctx , TensorShapeUtils : : MakeShape ( vec . data ( ) , vec . size ( ) , & samples_shape ) ) ; } else if ( shape_t . dtype ( ) == DataType : : DT_INT64 ) { auto vec = shape_t . flat < int64 > ( ) ; OP_REQUIRES_OK ( ctx , TensorShapeUtils : : MakeShape ( vec . data ( ) , vec . size ( ) , & samples_shape ) ) ; } const int64 samples_per_alpha = samples_shape . num_elements ( ) ; samples_shape . AppendShape ( alpha_t . shape ( ) ) ; Tensor * samples_t = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , samples_shape , & samples_t ) ) ; if ( samples_shape . num_elements ( ) == 0 ) return ; using random : : PhiloxRandom ; typedef random : : NormalDistribution < PhiloxRandom , double > Normal ; typedef random : : UniformDistribution < PhiloxRandom , double > Uniform ; # define UNIFORM ( X ) if ( uniform_remaining == 0 ) { uniform_remaining = Uniform : : kResultElementCount ; uniform_result = uniform ( & gen ) ; } uniform_remaining -- ; double X = uniform_result [ uniform_remaining ] static constexpr int kReservedSamplesPerOutput = 256 ; const auto alpha_flat = alpha_t . flat < T > ( ) . data ( ) ; const int64 num_alphas = alpha_t . NumElements ( ) ; OP_REQUIRES ( ctx , num_alphas > 0 , errors : : InvalidArgument ( \"Input<S2SV_blank>alpha<S2SV_blank>should<S2SV_blank>have<S2SV_blank>non-zero<S2SV_blank>element<S2SV_blank>count,<S2SV_blank>got:<S2SV_blank>\" , num_alphas ) ) ; auto samples_flat = samples_t -> flat < T > ( ) . data ( ) ; PhiloxRandom rng = generator_ . ReserveRandomOutputs ( samples_per_alpha * num_alphas , kReservedSamplesPerOutput ) ; auto DoWork = [ samples_per_alpha , num_alphas , & rng , samples_flat , <S2SV_StartBug> alpha_flat ] ( int start_output , int limit_output ) { <S2SV_EndBug> using Eigen : : numext : : exp ; using Eigen : : numext : : log ; using Eigen : : numext : : log1p ; using Eigen : : numext : : pow ; Normal normal ; Uniform uniform ; typename Normal : : ResultType norm_result ; typename Uniform : : ResultType uniform_result ; for ( int64 output_idx = start_output ; output_idx < limit_output ; ) { int64 alpha_idx = output_idx / samples_per_alpha ; T * const samples_alpha_offset = samples_flat + alpha_idx ; const double alpha = static_cast < double > ( alpha_flat [ alpha_idx ] ) ; DISABLE_FLOAT_EQUALITY_WARNING if ( alpha == static_cast < double > ( 1.0 ) ) { ENABLE_FLOAT_EQUALITY_WARNING for ( int64 sample_idx = output_idx % samples_per_alpha ; sample_idx < samples_per_alpha && output_idx < limit_output ; sample_idx ++ , output_idx ++ ) { PhiloxRandom gen = rng ; gen . Skip ( kReservedSamplesPerOutput * output_idx ) ; int16 uniform_remaining = 0 ; UNIFORM ( u ) ; const double res = - log1p ( - u ) ; samples_alpha_offset [ sample_idx * num_alphas ] = static_cast < T > ( res ) ; } } else { const bool alpha_less_than_one = alpha < 1 ; const double d = alpha + ( alpha_less_than_one ? 2.0 / 3 : - 1.0 / 3 ) ; const double c = 1.0 / 3 / sqrt ( d ) ; for ( int64 sample_idx = output_idx % samples_per_alpha ; sample_idx < samples_per_alpha && output_idx < limit_output ; sample_idx ++ , output_idx ++ ) { PhiloxRandom gen = rng ; gen . Skip ( kReservedSamplesPerOutput * output_idx ) ; int16 norm_remaining = 0 ; int16 uniform_remaining = 0 ; while ( true ) { if ( norm_remaining == 0 ) { norm_remaining = Normal : : kResultElementCount ; norm_result = normal ( & gen ) ; } norm_remaining -- ; const double x = norm_result [ norm_remaining ] ; double v = 1 + c * x ; if ( v <= 0 ) { continue ; } v = v * v * v ; UNIFORM ( u ) ; if ( ( u < 1 - 0.0331 * ( x * x ) * ( x * x ) ) || ( log ( u ) < 0.5 * x * x + d * ( 1 - v + log ( v ) ) ) ) { double res = d * v ; if ( alpha_less_than_one ) { UNIFORM ( b ) ; res *= pow ( b , 1 / alpha ) ; } samples_alpha_offset [ sample_idx * num_alphas ] = static_cast < T > ( res ) ; break ; } } } } } } ; # undef UNIFORM static const int kElementCost = 85 + 2 * Normal : : kElementCost + Uniform : : kElementCost + 3 * PhiloxRandom : : kElementCost ; auto worker_threads = * ( ctx -> device ( ) -> tensorflow_cpu_worker_threads ( ) ) ; Shard ( worker_threads . num_threads , worker_threads . workers , num_alphas * samples_per_alpha , kElementCost , DoWork ) ; }", "target": "<S2SV_ModStart> alpha_flat ] ( int64 start_output , int64 <S2SV_ModEnd> limit_output ) {"}
{"source": "CWE-20 static int dwa_uncompress ( EXRContext * s , const uint8_t * src , int compressed_size , int uncompressed_size , EXRThreadData * td ) { int64_t version , lo_usize , lo_size ; int64_t ac_size , dc_size , rle_usize , rle_csize , rle_raw_size ; int64_t ac_count , dc_count , ac_compression ; const int dc_w = td -> xsize >> 3 ; const int dc_h = td -> ysize >> 3 ; GetByteContext gb , agb ; int skip , ret ; if ( compressed_size <= 88 ) return AVERROR_INVALIDDATA ; version = AV_RL64 ( src + 0 ) ; if ( version != 2 ) return AVERROR_INVALIDDATA ; lo_usize = AV_RL64 ( src + 8 ) ; lo_size = AV_RL64 ( src + 16 ) ; ac_size = AV_RL64 ( src + 24 ) ; dc_size = AV_RL64 ( src + 32 ) ; rle_csize = AV_RL64 ( src + 40 ) ; rle_usize = AV_RL64 ( src + 48 ) ; rle_raw_size = AV_RL64 ( src + 56 ) ; ac_count = AV_RL64 ( src + 64 ) ; dc_count = AV_RL64 ( src + 72 ) ; ac_compression = AV_RL64 ( src + 80 ) ; if ( compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , src + 88 , compressed_size - 88 ) ; skip = bytestream2_get_le16 ( & gb ) ; if ( skip < 2 ) return AVERROR_INVALIDDATA ; bytestream2_skip ( & gb , skip - 2 ) ; if ( lo_size > 0 ) { if ( lo_usize > uncompressed_size ) return AVERROR_INVALIDDATA ; bytestream2_skip ( & gb , lo_size ) ; } if ( ac_size > 0 ) { unsigned long dest_len = ac_count * 2LL ; GetByteContext agb = gb ; if ( ac_count > 3LL * td -> xsize * s -> scan_lines_per_block ) return AVERROR_INVALIDDATA ; av_fast_padded_malloc ( & td -> ac_data , & td -> ac_size , dest_len ) ; if ( ! td -> ac_data ) return AVERROR ( ENOMEM ) ; switch ( ac_compression ) { case 0 : ret = huf_uncompress ( s , td , & agb , ( int16_t * ) td -> ac_data , ac_count ) ; if ( ret < 0 ) return ret ; break ; case 1 : if ( uncompress ( td -> ac_data , & dest_len , agb . buffer , ac_size ) != Z_OK || dest_len != ac_count * 2LL ) return AVERROR_INVALIDDATA ; break ; default : return AVERROR_INVALIDDATA ; } bytestream2_skip ( & gb , ac_size ) ; } <S2SV_StartBug> if ( dc_size > 0 ) { <S2SV_EndBug> unsigned long dest_len = dc_count * 2LL ; GetByteContext agb = gb ; <S2SV_StartBug> if ( dc_count > ( 6LL * td -> xsize * td -> ysize + 63 ) / 64 ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; av_fast_padded_malloc ( & td -> dc_data , & td -> dc_size , FFALIGN ( dest_len , 64 ) * 2 ) ; if ( ! td -> dc_data ) return AVERROR ( ENOMEM ) ; if ( uncompress ( td -> dc_data + FFALIGN ( dest_len , 64 ) , & dest_len , agb . buffer , dc_size ) != Z_OK || ( dest_len != dc_count * 2LL ) ) return AVERROR_INVALIDDATA ; s -> dsp . predictor ( td -> dc_data + FFALIGN ( dest_len , 64 ) , dest_len ) ; s -> dsp . reorder_pixels ( td -> dc_data , td -> dc_data + FFALIGN ( dest_len , 64 ) , dest_len ) ; bytestream2_skip ( & gb , dc_size ) ; } if ( rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0 ) { unsigned long dest_len = rle_usize ; av_fast_padded_malloc ( & td -> rle_data , & td -> rle_size , rle_usize ) ; if ( ! td -> rle_data ) return AVERROR ( ENOMEM ) ; av_fast_padded_malloc ( & td -> rle_raw_data , & td -> rle_raw_size , rle_raw_size ) ; if ( ! td -> rle_raw_data ) return AVERROR ( ENOMEM ) ; if ( uncompress ( td -> rle_data , & dest_len , gb . buffer , rle_csize ) != Z_OK || ( dest_len != rle_usize ) ) return AVERROR_INVALIDDATA ; ret = rle ( td -> rle_raw_data , td -> rle_data , rle_usize , rle_raw_size ) ; if ( ret < 0 ) return ret ; bytestream2_skip ( & gb , rle_csize ) ; } bytestream2_init ( & agb , td -> ac_data , ac_count * 2 ) ; for ( int y = 0 ; y < td -> ysize ; y += 8 ) { for ( int x = 0 ; x < td -> xsize ; x += 8 ) { memset ( td -> block , 0 , sizeof ( td -> block ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { float * block = td -> block [ j ] ; const int idx = ( x >> 3 ) + ( y >> 3 ) * dc_w + dc_w * dc_h * j ; uint16_t * dc = ( uint16_t * ) td -> dc_data ; union av_intfloat32 dc_val ; dc_val . i = half2float ( dc [ idx ] , s -> mantissatable , s -> exponenttable , s -> offsettable ) ; block [ 0 ] = dc_val . f ; ac_uncompress ( s , & agb , block ) ; dct_inverse ( block ) ; } { const float scale = s -> pixel_type == EXR_FLOAT ? 2.f : 1.f ; const int o = s -> nb_channels == 4 ; float * bo = ( ( float * ) td -> uncompressed_data ) + y * td -> xsize * s -> nb_channels + td -> xsize * ( o + 0 ) + x ; float * go = ( ( float * ) td -> uncompressed_data ) + y * td -> xsize * s -> nb_channels + td -> xsize * ( o + 1 ) + x ; float * ro = ( ( float * ) td -> uncompressed_data ) + y * td -> xsize * s -> nb_channels + td -> xsize * ( o + 2 ) + x ; float * yb = td -> block [ 0 ] ; float * ub = td -> block [ 1 ] ; float * vb = td -> block [ 2 ] ; for ( int yy = 0 ; yy < 8 ; yy ++ ) { for ( int xx = 0 ; xx < 8 ; xx ++ ) { const int idx = xx + yy * 8 ; convert ( yb [ idx ] , ub [ idx ] , vb [ idx ] , & bo [ xx ] , & go [ xx ] , & ro [ xx ] ) ; bo [ xx ] = to_linear ( bo [ xx ] , scale ) ; go [ xx ] = to_linear ( go [ xx ] , scale ) ; ro [ xx ] = to_linear ( ro [ xx ] , scale ) ; } bo += td -> xsize * s -> nb_channels ; go += td -> xsize * s -> nb_channels ; ro += td -> xsize * s -> nb_channels ; } } } } if ( s -> nb_channels < 4 ) return 0 ; for ( int y = 0 ; y < td -> ysize && td -> rle_raw_data ; y ++ ) { uint32_t * ao = ( ( uint32_t * ) td -> uncompressed_data ) + y * td -> xsize * s -> nb_channels ; uint8_t * ai0 = td -> rle_raw_data + y * td -> xsize ; uint8_t * ai1 = td -> rle_raw_data + y * td -> xsize + rle_raw_size / 2 ; for ( int x = 0 ; x < td -> xsize ; x ++ ) { uint16_t ha = ai0 [ x ] | ( ai1 [ x ] << 8 ) ; ao [ x ] = half2float ( ha , s -> mantissatable , s -> exponenttable , s -> offsettable ) ; } } return 0 ; }", "target": "<S2SV_ModStart> ) ; } <S2SV_ModEnd> { unsigned long <S2SV_ModStart> if ( dc_count != dc_w * dc_h * 3 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA"}
{"source": "CWE-369 Status ValidateInputsGenerateOutputs ( OpKernelContext * ctx , const Tensor * * inputs , const Tensor * * seq_len , Tensor * * log_prob , OpOutputList * decoded_indices , OpOutputList * decoded_values , OpOutputList * decoded_shape ) const { Status status = ctx -> input ( \"inputs\" , inputs ) ; if ( ! status . ok ( ) ) return status ; status = ctx -> input ( \"sequence_length\" , seq_len ) ; if ( ! status . ok ( ) ) return status ; const TensorShape & inputs_shape = ( * inputs ) -> shape ( ) ; if ( inputs_shape . dims ( ) != 3 ) { <S2SV_StartBug> return errors : : InvalidArgument ( \"inputs<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>3-Tensor\" ) ; <S2SV_EndBug> } const int64 max_time = inputs_shape . dim_size ( 0 ) ; const int64 batch_size = inputs_shape . dim_size ( 1 ) ; if ( max_time == 0 ) { return errors : : InvalidArgument ( \"max_time<S2SV_blank>is<S2SV_blank>0\" ) ; } if ( ! TensorShapeUtils : : IsVector ( ( * seq_len ) -> shape ( ) ) ) { return errors : : InvalidArgument ( \"sequence_length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>vector\" ) ; } if ( ! ( batch_size == ( * seq_len ) -> dim_size ( 0 ) ) ) { return errors : : FailedPrecondition ( \"len(sequence_length)<S2SV_blank>!=<S2SV_blank>batch_size.<S2SV_blank><S2SV_blank>\" , \"len(sequence_length):<S2SV_blank><S2SV_blank>\" , ( * seq_len ) -> dim_size ( 0 ) , \"<S2SV_blank>batch_size:<S2SV_blank>\" , batch_size ) ; } auto seq_len_t = ( * seq_len ) -> vec < int32 > ( ) ; for ( int b = 0 ; b < batch_size ; ++ b ) { if ( ! ( seq_len_t ( b ) <= max_time ) ) { return errors : : FailedPrecondition ( \"sequence_length(\" , b , \")<S2SV_blank><=<S2SV_blank>\" , max_time ) ; } } Status s = ctx -> allocate_output ( \"log_probability\" , TensorShape ( { batch_size , top_paths_ } ) , log_prob ) ; if ( ! s . ok ( ) ) return s ; s = ctx -> output_list ( \"decoded_indices\" , decoded_indices ) ; if ( ! s . ok ( ) ) return s ; s = ctx -> output_list ( \"decoded_values\" , decoded_values ) ; if ( ! s . ok ( ) ) return s ; s = ctx -> output_list ( \"decoded_shape\" , decoded_shape ) ; if ( ! s . ok ( ) ) return s ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> InvalidArgument ( \"inputs<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>3-Tensor\" ) ; } if ( inputs_shape . num_elements ( ) == 0 ) { return errors : : InvalidArgument ( \"inputs<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty\""}
{"source": "CWE-476 <S2SV_StartBug> void ValidateInputs ( OpKernelContext * ctx , <S2SV_EndBug> const CSRSparseMatrix & sparse_matrix , const Tensor & permutation_indices , int * batch_size , int64 * num_rows ) { <S2SV_StartBug> OP_REQUIRES ( ctx , sparse_matrix . dtype ( ) == DataTypeToEnum < T > : : value , <S2SV_EndBug> errors : : InvalidArgument ( \"Asked<S2SV_blank>for<S2SV_blank>a<S2SV_blank>CSRSparseMatrix<S2SV_blank>of<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( DataTypeToEnum < T > : : value ) , <S2SV_StartBug> \"<S2SV_blank>but<S2SV_blank>saw<S2SV_blank>dtype:<S2SV_blank>\" , DataTypeString ( sparse_matrix . dtype ( ) ) ) ) ; <S2SV_EndBug> const Tensor & dense_shape = sparse_matrix . dense_shape ( ) ; const int rank = dense_shape . dim_size ( 0 ) ; <S2SV_StartBug> OP_REQUIRES ( ctx , rank == 2 || rank == 3 , <S2SV_EndBug> errors : : InvalidArgument ( \"sparse<S2SV_blank>matrix<S2SV_blank>must<S2SV_blank>have<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>or<S2SV_blank>3;<S2SV_blank>\" , <S2SV_StartBug> \"but<S2SV_blank>dense_shape<S2SV_blank>has<S2SV_blank>size<S2SV_blank>\" , rank ) ) ; <S2SV_EndBug> const int row_dim = ( rank == 2 ) ? 0 : 1 ; auto dense_shape_vec = dense_shape . vec < int64 > ( ) ; * num_rows = dense_shape_vec ( row_dim ) ; const int64 num_cols = dense_shape_vec ( row_dim + 1 ) ; <S2SV_StartBug> OP_REQUIRES ( ctx , * num_rows == num_cols , <S2SV_EndBug> errors : : InvalidArgument ( \"sparse<S2SV_blank>matrix<S2SV_blank>must<S2SV_blank>be<S2SV_blank>square;<S2SV_blank>got:<S2SV_blank>\" , <S2SV_StartBug> * num_rows , \"<S2SV_blank>!=<S2SV_blank>\" , num_cols ) ) ; <S2SV_EndBug> const TensorShape & perm_shape = permutation_indices . shape ( ) ; <S2SV_StartBug> OP_REQUIRES ( <S2SV_EndBug> <S2SV_StartBug> ctx , perm_shape . dims ( ) + 1 == rank , <S2SV_EndBug> errors : : InvalidArgument ( \"sparse<S2SV_blank>matrix<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>rank<S2SV_blank>as<S2SV_blank>permutation;<S2SV_blank>got:<S2SV_blank>\" , rank , <S2SV_StartBug> \"<S2SV_blank>!=<S2SV_blank>\" , perm_shape . dims ( ) , \"<S2SV_blank>+<S2SV_blank>1.\" ) ) ; <S2SV_EndBug> OP_REQUIRES ( <S2SV_StartBug> ctx , perm_shape . dim_size ( rank - 2 ) == * num_rows , <S2SV_EndBug> errors : : InvalidArgument ( \"permutation<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>number<S2SV_blank>of<S2SV_blank>elements<S2SV_blank>in<S2SV_blank>each<S2SV_blank>batch<S2SV_blank>\" \"as<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>rows<S2SV_blank>in<S2SV_blank>sparse<S2SV_blank>matrix;<S2SV_blank>got:<S2SV_blank>\" , <S2SV_StartBug> perm_shape . dim_size ( rank - 2 ) , \"<S2SV_blank>!=<S2SV_blank>\" , * num_rows ) ) ; <S2SV_EndBug> * batch_size = sparse_matrix . batch_size ( ) ; if ( * batch_size > 1 ) { <S2SV_StartBug> OP_REQUIRES ( <S2SV_EndBug> <S2SV_StartBug> ctx , perm_shape . dim_size ( 0 ) == * batch_size , <S2SV_EndBug> errors : : InvalidArgument ( \"permutation<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>batch<S2SV_blank>size<S2SV_blank>\" \"as<S2SV_blank>sparse<S2SV_blank>matrix;<S2SV_blank>got:<S2SV_blank>\" , <S2SV_StartBug> perm_shape . dim_size ( 0 ) , \"<S2SV_blank>!=<S2SV_blank>\" , * batch_size ) ) ; <S2SV_EndBug> } }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> Status ValidateInputs ( <S2SV_ModEnd> const CSRSparseMatrix & <S2SV_ModStart> num_rows ) { if ( <S2SV_ModEnd> sparse_matrix . dtype <S2SV_ModStart> dtype ( ) != <S2SV_ModEnd> DataTypeToEnum < T <S2SV_ModStart> : : value ) return <S2SV_ModEnd> errors : : <S2SV_ModStart> ) ) ) <S2SV_ModEnd> ; const Tensor <S2SV_ModStart> 0 ) ; if ( rank < <S2SV_ModEnd> 2 || rank <S2SV_ModStart> 2 || rank > 3 ) return <S2SV_ModEnd> errors : : <S2SV_ModStart> \"but<S2SV_blank>dense_shape<S2SV_blank>has<S2SV_blank>size<S2SV_blank>\" , rank <S2SV_ModEnd> ) ; const <S2SV_ModStart> 1 ) ; if ( * num_rows != num_cols ) return errors : : InvalidArgument ( <S2SV_ModEnd> \"sparse<S2SV_blank>matrix<S2SV_blank>must<S2SV_blank>be<S2SV_blank>square;<S2SV_blank>got:<S2SV_blank>\" , * <S2SV_ModStart> \"<S2SV_blank>!=<S2SV_blank>\" , num_cols <S2SV_ModEnd> ) ; const <S2SV_ModStart> ( ) ; if ( <S2SV_ModEnd> perm_shape . dims <S2SV_ModStart> ) + 1 != rank ) return <S2SV_ModEnd> errors : : <S2SV_ModStart> , \"<S2SV_blank>+<S2SV_blank>1.\" ) ; if ( <S2SV_ModEnd> perm_shape . dim_size <S2SV_ModStart> - 2 ) != * num_rows ) return <S2SV_ModEnd> errors : : <S2SV_ModStart> * num_rows ) <S2SV_ModEnd> ; * batch_size <S2SV_ModStart> 1 ) { if ( <S2SV_ModEnd> perm_shape . dim_size <S2SV_ModStart> ( 0 ) != * batch_size ) return errors : : InvalidArgument ( <S2SV_ModEnd> \"permutation<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>batch<S2SV_blank>size<S2SV_blank>\" \"as<S2SV_blank>sparse<S2SV_blank>matrix;<S2SV_blank>got:<S2SV_blank>\" , <S2SV_ModStart> * batch_size ) ; } return Status : : OK ( ) ; <S2SV_ModEnd> }  <S2SV_null>"}
{"source": "CWE-787 void dmar_free_irte ( const struct intr_source * intr_src , uint16_t index ) { struct dmar_drhd_rt * dmar_unit ; union dmar_ir_entry * ir_table , * ir_entry ; union pci_bdf sid ; if ( intr_src -> is_msi ) { dmar_unit = device_to_dmaru ( ( uint8_t ) intr_src -> src . msi . bits . b , intr_src -> src . msi . fields . devfun ) ; } else { dmar_unit = ioapic_to_dmaru ( intr_src -> src . ioapic_id , & sid ) ; } <S2SV_StartBug> if ( is_dmar_unit_valid ( dmar_unit , sid ) ) { <S2SV_EndBug> ir_table = ( union dmar_ir_entry * ) hpa2hva ( dmar_unit -> ir_table_addr ) ; ir_entry = ir_table + index ; ir_entry -> bits . remap . present = 0x0UL ; iommu_flush_cache ( ir_entry , sizeof ( union dmar_ir_entry ) ) ; dmar_invalid_iec ( dmar_unit , index , 0U , false ) ; if ( ! is_irte_reserved ( dmar_unit , index ) ) { spinlock_obtain ( & dmar_unit -> lock ) ; bitmap_clear_nolock ( index & 0x3FU , & dmar_unit -> irte_alloc_bitmap [ index >> 6U ] ) ; spinlock_release ( & dmar_unit -> lock ) ; } } }", "target": "<S2SV_ModStart> , sid ) && ( index < CONFIG_MAX_IR_ENTRIES )"}
{"source": "CWE-787 static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , <S2SV_StartBug> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <S2SV_EndBug> packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ; }", "target": "<S2SV_ModStart> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->"}
{"source": "CWE-787 bool FromkLinuxSockAddr ( const struct klinux_sockaddr * input , socklen_t input_len , struct sockaddr * output , socklen_t * output_len , void ( * abort_handler ) ( const char * ) ) { if ( ! input || ! output || ! output_len || input_len == 0 ) { output = nullptr ; return false ; } int16_t klinux_family = input -> klinux_sa_family ; if ( klinux_family == kLinux_AF_UNIX ) { <S2SV_StartBug> struct klinux_sockaddr_un * klinux_sockaddr_un_in = <S2SV_EndBug> const_cast < struct klinux_sockaddr_un * > ( reinterpret_cast < const struct klinux_sockaddr_un * > ( input ) ) ; struct sockaddr_un sockaddr_un_out ; sockaddr_un_out . sun_family = AF_UNIX ; InitializeToZeroArray ( sockaddr_un_out . sun_path ) ; ReinterpretCopyArray ( sockaddr_un_out . sun_path , klinux_sockaddr_un_in -> klinux_sun_path , std : : min ( sizeof ( sockaddr_un_out . sun_path ) , sizeof ( klinux_sockaddr_un_in -> klinux_sun_path ) ) ) ; CopySockaddr ( & sockaddr_un_out , sizeof ( sockaddr_un_out ) , output , output_len ) ; } else if ( klinux_family == kLinux_AF_INET ) { <S2SV_StartBug> struct klinux_sockaddr_in * klinux_sockaddr_in_in = <S2SV_EndBug> const_cast < struct klinux_sockaddr_in * > ( reinterpret_cast < const struct klinux_sockaddr_in * > ( input ) ) ; struct sockaddr_in sockaddr_in_out ; sockaddr_in_out . sin_family = AF_INET ; sockaddr_in_out . sin_port = klinux_sockaddr_in_in -> klinux_sin_port ; InitializeToZeroSingle ( & sockaddr_in_out . sin_addr ) ; ReinterpretCopySingle ( & sockaddr_in_out . sin_addr , & klinux_sockaddr_in_in -> klinux_sin_addr ) ; InitializeToZeroArray ( sockaddr_in_out . sin_zero ) ; ReinterpretCopyArray ( sockaddr_in_out . sin_zero , klinux_sockaddr_in_in -> klinux_sin_zero ) ; CopySockaddr ( & sockaddr_in_out , sizeof ( sockaddr_in_out ) , output , output_len ) ; <S2SV_StartBug> } else if ( klinux_family == kLinux_AF_INET6 ) { <S2SV_EndBug> struct klinux_sockaddr_in6 * klinux_sockaddr_in6_in = const_cast < struct klinux_sockaddr_in6 * > ( reinterpret_cast < const struct klinux_sockaddr_in6 * > ( input ) ) ; struct sockaddr_in6 sockaddr_in6_out ; sockaddr_in6_out . sin6_family = AF_INET6 ; sockaddr_in6_out . sin6_port = klinux_sockaddr_in6_in -> klinux_sin6_port ; sockaddr_in6_out . sin6_flowinfo = klinux_sockaddr_in6_in -> klinux_sin6_flowinfo ; sockaddr_in6_out . sin6_scope_id = klinux_sockaddr_in6_in -> klinux_sin6_scope_id ; InitializeToZeroSingle ( & sockaddr_in6_out . sin6_addr ) ; ReinterpretCopySingle ( & sockaddr_in6_out . sin6_addr , & klinux_sockaddr_in6_in -> klinux_sin6_addr ) ; CopySockaddr ( & sockaddr_in6_out , sizeof ( sockaddr_in6_out ) , output , output_len ) ; } else if ( klinux_family == kLinux_AF_UNSPEC ) { output = nullptr ; * output_len = 0 ; } else { if ( abort_handler != nullptr ) { std : : string message = absl : : StrCat ( \"Type<S2SV_blank>conversion<S2SV_blank>error<S2SV_blank>-<S2SV_blank>Unsupported<S2SV_blank>AF<S2SV_blank>family:<S2SV_blank>\" , klinux_family ) ; abort_handler ( message . c_str ( ) ) ; } else { abort ( ) ; } } return true ; }", "target": "<S2SV_ModStart> kLinux_AF_UNIX ) { if ( input_len < sizeof ( struct klinux_sockaddr_un ) ) { return false ; } <S2SV_ModStart> kLinux_AF_INET ) { if ( input_len < sizeof ( struct klinux_sockaddr_in ) ) { return false ; } <S2SV_ModStart> kLinux_AF_INET6 ) { if ( input_len < sizeof ( struct klinux_sockaddr_in6 ) ) { return false ; }"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { const Tensor & input = context -> input ( 0 ) ; <S2SV_StartBug> const float input_min = context -> input ( 1 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float input_max = context -> input ( 2 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> const Tensor & mean = context -> input ( 3 ) ; <S2SV_StartBug> const float mean_min = context -> input ( 4 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float mean_max = context -> input ( 5 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> const Tensor & var = context -> input ( 6 ) ; <S2SV_StartBug> const float var_min = context -> input ( 7 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float var_max = context -> input ( 8 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> const Tensor & beta = context -> input ( 9 ) ; <S2SV_StartBug> const float beta_min = context -> input ( 10 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float beta_max = context -> input ( 11 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> const Tensor & gamma = context -> input ( 12 ) ; <S2SV_StartBug> const float gamma_min = context -> input ( 13 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float gamma_max = context -> input ( 14 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> OP_REQUIRES ( context , input . dims ( ) == 4 , errors : : InvalidArgument ( \"input<S2SV_blank>must<S2SV_blank>be<S2SV_blank>4-dimensional\" , input . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , mean . dims ( ) == 1 , errors : : InvalidArgument ( \"mean<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-dimensional\" , mean . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , var . dims ( ) == 1 , errors : : InvalidArgument ( \"var<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-dimensional\" , var . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , beta . dims ( ) == 1 , errors : : InvalidArgument ( \"beta<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-dimensional\" , beta . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , gamma . dims ( ) == 1 , errors : : InvalidArgument ( \"gamma<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-dimensional\" , <S2SV_StartBug> gamma . shape ( ) . DebugString ( ) ) ) ; <S2SV_EndBug> Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , input . shape ( ) , & output ) ) ; float output_min ; float output_max ; FixedPointBatchNorm < T1 , T2 > ( input , input_min , input_max , mean , mean_min , mean_max , var , var_min , var_max , beta , beta_min , beta_max , gamma , gamma_min , gamma_max , variance_epsilon_ , scale_after_normalization_ , output , & output_min , & output_max ) ; Tensor * output_min_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , { } , & output_min_tensor ) ) ; output_min_tensor -> flat < float > ( ) ( 0 ) = output_min ; Tensor * output_max_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , { } , & output_max_tensor ) ) ; output_max_tensor -> flat < float > ( ) ( 0 ) = output_max ; }", "target": "<S2SV_ModStart> ) ; const auto & input_min_tensor = context -> input ( 1 ) ; OP_REQUIRES ( context , input_min_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"input_min<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float input_min = input_min_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & input_max_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , input_max_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"input_max<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float input_max = input_max_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & mean_min_tensor = context -> input ( 4 ) ; OP_REQUIRES ( context , mean_min_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"mean_min<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float mean_min = mean_min_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & mean_max_tensor = context -> input ( 5 ) ; OP_REQUIRES ( context , mean_max_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"mean_max<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float mean_max = mean_max_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & var_min_tensor = context -> input ( 7 ) ; OP_REQUIRES ( context , var_min_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"var_min<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float var_min = var_min_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & var_max_tensor = context -> input ( 8 ) ; OP_REQUIRES ( context , var_max_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"var_max<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float var_max = var_max_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & beta_min_tensor = context -> input ( 10 ) ; OP_REQUIRES ( context , beta_min_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"beta_min<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float beta_min = beta_min_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & beta_max_tensor = context -> input ( 11 ) ; OP_REQUIRES ( context , beta_max_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"beta_max<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float beta_max = beta_max_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & gamma_min_tensor = context -> input ( 13 ) ; OP_REQUIRES ( context , gamma_min_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"gamma_min<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float gamma_min = gamma_min_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & gamma_max_tensor = context -> input ( 14 ) ; OP_REQUIRES ( context , gamma_max_tensor . NumElements ( ) == 1 , errors : : InvalidArgument ( \"gamma_max<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float gamma_max = gamma_max_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ( \"gamma<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-dimensional\" , gamma . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , mean . NumElements ( ) > 1 , errors : : InvalidArgument ( \"Must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>a<S2SV_blank>mean<S2SV_blank>value\" , gamma . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , mean . NumElements ( ) > 1 , errors : : InvalidArgument ( \"Must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>a<S2SV_blank>mean<S2SV_blank>value\" ) ) ; const auto last_dim = input . shape ( ) . dims ( ) - 1 ; OP_REQUIRES ( context , mean . shape ( ) . dim_size ( 0 ) == input . shape ( ) . dim_size ( last_dim ) , errors : : InvalidArgument ( \"Must<S2SV_blank>provide<S2SV_blank>as<S2SV_blank>many<S2SV_blank>means<S2SV_blank>as<S2SV_blank>the<S2SV_blank>\" \"last<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>the<S2SV_blank>input<S2SV_blank>tensor:<S2SV_blank>\" , mean . shape ( ) . DebugString ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , input . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , mean . shape ( ) . dim_size ( 0 ) == var . shape ( ) . dim_size ( 0 ) , errors : : InvalidArgument ( \"Mean<S2SV_blank>and<S2SV_blank>variance<S2SV_blank>tensors<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>shape:<S2SV_blank>\" , mean . shape ( ) . DebugString ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , var . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , mean . shape ( ) . dim_size ( 0 ) == beta . shape ( ) . dim_size ( 0 ) , errors : : InvalidArgument ( \"Mean<S2SV_blank>and<S2SV_blank>beta<S2SV_blank>tensors<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>shape:<S2SV_blank>\" , mean . shape ( ) . DebugString ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , beta . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , mean . shape ( ) . dim_size ( 0 ) == gamma . shape ( ) . dim_size ( 0 ) , errors : : InvalidArgument ( \"Mean<S2SV_blank>and<S2SV_blank>gamma<S2SV_blank>tensors<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>shape:<S2SV_blank>\" , mean . shape ( ) . DebugString ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" ,"}
{"source": "CWE-703 ImmutableConstantOp : : ImmutableConstantOp ( OpKernelConstruction * context ) : OpKernel ( context ) { OP_REQUIRES_OK ( context , context -> GetAttr ( kMemoryRegionNameAttr , & region_name_ ) ) ; OP_REQUIRES_OK ( context , context -> GetAttr ( kDTypeAttr , & dtype_ ) ) ; <S2SV_StartBug> OP_REQUIRES_OK ( context , context -> GetAttr ( kShapeAttr , & shape_ ) ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ) ) ; OP_REQUIRES ( context , dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT , errors : : InvalidArgument ( \"Resource<S2SV_blank>and<S2SV_blank>variant<S2SV_blank>dtypes<S2SV_blank>are<S2SV_blank>invalid<S2SV_blank>for<S2SV_blank>this<S2SV_blank>op.\" ) ) ;"}
{"source": "CWE-200 void * UntrustedCacheMalloc : : GetBuffer ( ) { void * * buffers = nullptr ; void * buffer ; bool is_pool_empty ; { LockGuard spin_lock ( & lock_ ) ; is_pool_empty = buffer_pool_ . empty ( ) ; if ( is_pool_empty ) { buffers = primitives : : AllocateUntrustedBuffers ( kPoolIncrement , kPoolEntrySize ) ; for ( int i = 0 ; i < kPoolIncrement ; i ++ ) { <S2SV_StartBug> if ( ! buffers [ i ] || <S2SV_EndBug> <S2SV_StartBug> ! TrustedPrimitives : : IsOutsideEnclave ( buffers [ i ] , kPoolEntrySize ) ) { <S2SV_EndBug> <S2SV_StartBug> abort ( ) ; <S2SV_EndBug> } <S2SV_StartBug> buffer_pool_ . push ( buffers [ i ] ) ; <S2SV_EndBug> } } buffer = buffer_pool_ . top ( ) ; buffer_pool_ . pop ( ) ; busy_buffers_ . insert ( buffer ) ; } if ( is_pool_empty ) { Free ( buffers ) ; } return buffer ; }", "target": "<S2SV_ModStart> ++ ) { void * buf = <S2SV_ModEnd> buffers [ i <S2SV_ModStart> [ i ] ; if ( ! buf <S2SV_ModStart> : IsOutsideEnclave ( buf <S2SV_ModEnd> , kPoolEntrySize ) <S2SV_ModStart> ) ) { TrustedPrimitives : : BestEffortAbort ( \"Cached<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>not<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>enclave\" <S2SV_ModEnd> ) ; } <S2SV_ModStart> . push ( buf <S2SV_ModEnd> ) ; }"}
{"source": "CWE-125 ImagingPcxDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , Py_ssize_t bytes ) { UINT8 n ; UINT8 * ptr ; <S2SV_StartBug> if ( strcmp ( im -> mode , \"1\" ) == 0 && state -> xsize > state -> bytes * 8 ) { <S2SV_EndBug> state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; <S2SV_StartBug> } else if ( strcmp ( im -> mode , \"P\" ) == 0 && state -> xsize > state -> bytes ) { <S2SV_EndBug> state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } <S2SV_StartBug> ptr = buf ; <S2SV_EndBug> for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { return - 1 ; } } } }", "target": "<S2SV_ModStart> ; if ( ( state -> xsize * state -> bits + 7 ) / 8 <S2SV_ModEnd> > state -> <S2SV_ModStart> state -> bytes <S2SV_ModEnd> ) { state <S2SV_ModStart> 1 ; } ptr = buf ; for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> 1 ; } <S2SV_ModEnd> } } }"}
{"source": "CWE-476 GF_Err Media_RewriteODFrame ( GF_MediaBox * mdia , GF_ISOSample * sample ) { GF_Err e ; GF_ODCodec * ODdecode ; GF_ODCodec * ODencode ; GF_ODCom * com ; GF_ESDUpdate * esdU , * esdU2 ; GF_ESDRemove * esdR , * esdR2 ; GF_ODUpdate * odU , * odU2 ; GF_ObjectDescriptor * od ; GF_IsomObjectDescriptor * isom_od ; GF_ESD * esd ; GF_ES_ID_Ref * ref ; GF_Descriptor * desc ; GF_TrackReferenceTypeBox * mpod ; u32 i , j , skipped ; if ( ! mdia || ! sample || ! sample -> data || ! sample -> dataLength ) return GF_BAD_PARAM ; mpod = NULL ; e = Track_FindRef ( mdia -> mediaTrack , GF_ISOM_BOX_TYPE_MPOD , & mpod ) ; if ( e ) return e ; if ( ! mpod || ! mpod -> trackIDs ) return GF_OK ; ODdecode = gf_odf_codec_new ( ) ; if ( ! ODdecode ) return GF_OUT_OF_MEM ; ODencode = gf_odf_codec_new ( ) ; if ( ! ODencode ) { gf_odf_codec_del ( ODdecode ) ; return GF_OUT_OF_MEM ; } e = gf_odf_codec_set_au ( ODdecode , sample -> data , sample -> dataLength ) ; if ( e ) goto err_exit ; e = gf_odf_codec_decode ( ODdecode ) ; if ( e ) goto err_exit ; while ( 1 ) { com = gf_odf_codec_get_com ( ODdecode ) ; if ( ! com ) break ; switch ( com -> tag ) { case GF_ODF_OD_UPDATE_TAG : odU = ( GF_ODUpdate * ) com ; odU2 = ( GF_ODUpdate * ) gf_odf_com_new ( GF_ODF_OD_UPDATE_TAG ) ; i = 0 ; while ( ( desc = ( GF_Descriptor * ) gf_list_enum ( odU -> objectDescriptors , & i ) ) ) { switch ( desc -> tag ) { case GF_ODF_OD_TAG : case GF_ODF_ISOM_OD_TAG : case GF_ODF_ISOM_IOD_TAG : break ; default : return GF_ISOM_INVALID_FILE ; } e = gf_odf_desc_copy ( desc , ( GF_Descriptor * * ) & isom_od ) ; if ( e ) goto err_exit ; if ( desc -> tag == GF_ODF_ISOM_IOD_TAG ) { od = ( GF_ObjectDescriptor * ) gf_malloc ( sizeof ( GF_InitialObjectDescriptor ) ) ; } else { od = ( GF_ObjectDescriptor * ) gf_malloc ( sizeof ( GF_ObjectDescriptor ) ) ; } if ( ! od ) { e = GF_OUT_OF_MEM ; goto err_exit ; } od -> ESDescriptors = gf_list_new ( ) ; od -> objectDescriptorID = isom_od -> objectDescriptorID ; od -> tag = GF_ODF_OD_TAG ; od -> URLString = isom_od -> URLString ; isom_od -> URLString = NULL ; od -> extensionDescriptors = isom_od -> extensionDescriptors ; isom_od -> extensionDescriptors = NULL ; od -> IPMP_Descriptors = isom_od -> IPMP_Descriptors ; isom_od -> IPMP_Descriptors = NULL ; od -> OCIDescriptors = isom_od -> OCIDescriptors ; isom_od -> OCIDescriptors = NULL ; if ( isom_od -> tag == GF_ODF_ISOM_IOD_TAG ) { ( ( GF_InitialObjectDescriptor * ) od ) -> audio_profileAndLevel = ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> audio_profileAndLevel ; ( ( GF_InitialObjectDescriptor * ) od ) -> inlineProfileFlag = ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> inlineProfileFlag ; ( ( GF_InitialObjectDescriptor * ) od ) -> graphics_profileAndLevel = ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> graphics_profileAndLevel ; ( ( GF_InitialObjectDescriptor * ) od ) -> OD_profileAndLevel = ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> OD_profileAndLevel ; ( ( GF_InitialObjectDescriptor * ) od ) -> scene_profileAndLevel = ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> scene_profileAndLevel ; ( ( GF_InitialObjectDescriptor * ) od ) -> visual_profileAndLevel = ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> visual_profileAndLevel ; ( ( GF_InitialObjectDescriptor * ) od ) -> IPMPToolList = ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> IPMPToolList ; ( ( GF_IsomInitialObjectDescriptor * ) isom_od ) -> IPMPToolList = NULL ; } j = 0 ; while ( ( ref = ( GF_ES_ID_Ref * ) gf_list_enum ( isom_od -> ES_ID_RefDescriptors , & j ) ) ) { <S2SV_StartBug> if ( ! mpod -> trackIDs || gf_isom_get_track_from_id ( mdia -> mediaTrack -> moov , mpod -> trackIDs [ ref -> trackRef - 1 ] ) == NULL ) continue ; <S2SV_EndBug> e = GetESDForTime ( mdia -> mediaTrack -> moov , mpod -> trackIDs [ ref -> trackRef - 1 ] , sample -> DTS , & esd ) ; if ( ! e ) e = gf_odf_desc_add_desc ( ( GF_Descriptor * ) od , ( GF_Descriptor * ) esd ) ; if ( e ) { gf_odf_desc_del ( ( GF_Descriptor * ) od ) ; gf_odf_com_del ( ( GF_ODCom * * ) & odU2 ) ; gf_odf_desc_del ( ( GF_Descriptor * ) isom_od ) ; gf_odf_com_del ( ( GF_ODCom * * ) & odU ) ; goto err_exit ; } } gf_odf_desc_del ( ( GF_Descriptor * ) isom_od ) ; gf_list_add ( odU2 -> objectDescriptors , od ) ; } gf_odf_com_del ( ( GF_ODCom * * ) & odU ) ; gf_odf_codec_add_com ( ODencode , ( GF_ODCom * ) odU2 ) ; break ; case GF_ODF_ESD_UPDATE_TAG : esdU = ( GF_ESDUpdate * ) com ; esdU2 = ( GF_ESDUpdate * ) gf_odf_com_new ( GF_ODF_ESD_UPDATE_TAG ) ; esdU2 -> ODID = esdU -> ODID ; i = 0 ; while ( ( ref = ( GF_ES_ID_Ref * ) gf_list_enum ( esdU -> ESDescriptors , & i ) ) ) { <S2SV_StartBug> if ( gf_isom_get_track_from_id ( mdia -> mediaTrack -> moov , mpod -> trackIDs [ ref -> trackRef - 1 ] ) == NULL ) continue ; <S2SV_EndBug> e = GetESDForTime ( mdia -> mediaTrack -> moov , mpod -> trackIDs [ ref -> trackRef - 1 ] , sample -> DTS , & esd ) ; if ( e ) goto err_exit ; gf_list_add ( esdU2 -> ESDescriptors , esd ) ; } gf_odf_com_del ( ( GF_ODCom * * ) & esdU ) ; gf_odf_codec_add_com ( ODencode , ( GF_ODCom * ) esdU2 ) ; break ; case GF_ODF_ESD_REMOVE_REF_TAG : esdR = ( GF_ESDRemove * ) com ; esdR2 = ( GF_ESDRemove * ) gf_odf_com_new ( GF_ODF_ESD_REMOVE_TAG ) ; esdR2 -> ODID = esdR -> ODID ; esdR2 -> NbESDs = esdR -> NbESDs ; esdR2 -> ES_ID = ( unsigned short * ) gf_malloc ( sizeof ( u32 ) * esdR -> NbESDs ) ; if ( ! esdR2 -> ES_ID ) { e = GF_OUT_OF_MEM ; goto err_exit ; } skipped = 0 ; <S2SV_StartBug> for ( i = 0 ; i < esdR -> NbESDs ; i ++ ) { <S2SV_EndBug> if ( gf_isom_get_track_from_id ( mdia -> mediaTrack -> moov , mpod -> trackIDs [ esdR -> ES_ID [ i ] - 1 ] ) == NULL ) { skipped ++ ; } else { esdR2 -> ES_ID [ i - skipped ] = mpod -> trackIDs [ esdR -> ES_ID [ i ] - 1 ] ; } } if ( skipped && ( skipped != esdR2 -> NbESDs ) ) { esdR2 -> NbESDs -= skipped ; esdR2 -> ES_ID = ( unsigned short * ) gf_realloc ( esdR2 -> ES_ID , sizeof ( u32 ) * esdR2 -> NbESDs ) ; } gf_odf_com_del ( ( GF_ODCom * * ) & esdR ) ; gf_odf_codec_add_com ( ODencode , ( GF_ODCom * ) esdR2 ) ; break ; default : e = gf_odf_codec_add_com ( ODencode , com ) ; if ( e ) goto err_exit ; } } e = gf_odf_codec_encode ( ODencode , 1 ) ; if ( e ) goto err_exit ; gf_free ( sample -> data ) ; sample -> data = NULL ; sample -> dataLength = 0 ; e = gf_odf_codec_get_au ( ODencode , & sample -> data , & sample -> dataLength ) ; err_exit : gf_odf_codec_del ( ODdecode ) ; gf_odf_codec_del ( ODencode ) ; return e ; }", "target": "<S2SV_ModStart> -> trackIDs || ! ref -> trackRef || ( ref -> trackRef > mpod -> trackIDCount ) ) continue ; if ( <S2SV_ModStart> { if ( ! mpod -> trackIDs || ! ref -> trackRef || ( ref -> trackRef > mpod -> trackIDCount ) ) continue ; if ( <S2SV_ModStart> ++ ) { if ( ! mpod -> trackIDs || ! esdR -> ES_ID [ i ] || ( esdR -> ES_ID [ i ] > mpod -> trackIDCount ) ) continue ;"}
{"source": "CWE-369 TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * output_shape ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kOutputShapeTensor , & output_shape ) ) ; const TfLiteTensor * weights ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kWeightsTensor , & weights ) ) ; const TfLiteTensor * input ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kDataInputTensor , & input ) ) ; const TfLiteTensor * bias = ( NumInputs ( node ) == 4 ) ? GetOptionalInputTensor ( context , node , kBiasTensor ) : nullptr ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; TfLiteTensor * col2im = data -> has_col2im ? GetTemporary ( context , node , data -> col2im_index ) : nullptr ; TfLiteTensor * transposed_weights = data -> weights_are_transposed ? GetTemporary ( context , node , data -> transposed_weights_index ) : nullptr ; const auto * params = <S2SV_StartBug> reinterpret_cast < TfLiteTransposeConvParams * > ( node -> builtin_data ) ; <S2SV_EndBug> if ( IsDynamicTensor ( output ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , output ) ) ; } if ( data -> has_col2im && IsDynamicTensor ( col2im ) ) { TF_LITE_ENSURE_OK ( context , ResizeCol2ImTensor ( context , output_shape , weights , input , col2im ) ) ; } const int width = SizeOfDimension ( output , 2 ) ; const int height = SizeOfDimension ( output , 1 ) ; const int filter_width = SizeOfDimension ( weights , 2 ) ; const int filter_height = SizeOfDimension ( weights , 1 ) ; int unused_output_height , unused_output_width ; data -> padding = ComputePaddingHeightWidth ( params -> stride_height , params -> stride_width , 1 , 1 , height , width , filter_height , filter_width , params -> padding , & unused_output_height , & unused_output_width ) ; switch ( input -> type ) { case kTfLiteFloat32 : { if ( data -> weights_are_transposed ) { if ( ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } } EvalFloat < kernel_type > ( context , params , data , input , weights , bias , transposed_weights , col2im , output ) ; break ; } case kTfLiteUInt8 : { TfLiteTensor * scratch_buffer ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , data -> scratch_tensor_index , & scratch_buffer ) ) ; if ( IsDynamicTensor ( scratch_buffer ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , scratch_buffer ) ) ; } if ( data -> weights_are_transposed ) { if ( ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } } EvalQuantized < kernel_type > ( context , params , data , input , weights , transposed_weights , bias , col2im , output , scratch_buffer ) ; break ; } case kTfLiteInt8 : { TfLiteTensor * scratch_buffer ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , data -> scratch_tensor_index , & scratch_buffer ) ) ; if ( IsDynamicTensor ( scratch_buffer ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , scratch_buffer ) ) ; } if ( data -> weights_are_transposed && ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } EvalQuantizedPerChannel < kernel_type > ( context , params , data , input , weights , transposed_weights , bias , col2im , output , scratch_buffer ) ; break ; } case kTfLiteInt16 : { TfLiteTensor * scratch_buffer ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , data -> scratch_tensor_index , & scratch_buffer ) ) ; if ( IsDynamicTensor ( scratch_buffer ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , scratch_buffer ) ) ; } if ( data -> weights_are_transposed && ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } EvalQuantizedPerChannel16x8 ( context , params , data , input , weights , transposed_weights , bias , col2im , output , scratch_buffer ) ; break ; } default : context -> ReportError ( context , \"Type<S2SV_blank>\\'%s\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\" , TfLiteTypeGetName ( input -> type ) ) ; return kTfLiteError ; } return kTfLiteOk ; }", "target": "<S2SV_ModStart> node -> builtin_data ) ; TF_LITE_ENSURE ( context , params -> stride_height > 0 ) ; TF_LITE_ENSURE ( context , params -> stride_width > 0"}
{"source": "CWE-787 int ecall_restore ( const char * input , uint64_t input_len , char * * output , uint64_t * output_len ) { if ( ! asylo : : primitives : : TrustedPrimitives : : IsOutsideEnclave ( input , input_len ) || ! asylo : : primitives : : TrustedPrimitives : : IsOutsideEnclave ( <S2SV_StartBug> output_len , sizeof ( uint64_t ) ) ) { <S2SV_EndBug> asylo : : primitives : : TrustedPrimitives : : BestEffortAbort ( \"ecall_restore:<S2SV_blank>input/output<S2SV_blank>found<S2SV_blank>to<S2SV_blank>not<S2SV_blank>be<S2SV_blank>in<S2SV_blank>untrusted<S2SV_blank>memory.\" ) ; } int result = 0 ; size_t tmp_output_len ; try { result = asylo : : Restore ( input , static_cast < size_t > ( input_len ) , output , & tmp_output_len ) ; } catch ( ... ) { LOG ( FATAL ) << \"Uncaught<S2SV_blank>exception<S2SV_blank>in<S2SV_blank>enclave\" ; } if ( output_len ) { * output_len = static_cast < uint64_t > ( tmp_output_len ) ; } return result ; }", "target": "<S2SV_ModStart> ( uint64_t ) ) || ! asylo : : primitives : : TrustedPrimitives : : IsOutsideEnclave ( output , * output_len"}
{"source": "CWE-22 <S2SV_StartBug> CString CWebSock : : GetSkinPath ( const CString & sSkinName ) { <S2SV_EndBug> <S2SV_StartBug> CString sRet = CZNC : : Get ( ) . GetZNCPath ( ) + \"/webskins/\" + sSkinName ; <S2SV_EndBug> if ( ! CFile : : IsDir ( sRet ) ) { <S2SV_StartBug> sRet = CZNC : : Get ( ) . GetCurPath ( ) + \"/webskins/\" + sSkinName ; <S2SV_EndBug> if ( ! CFile : : IsDir ( sRet ) ) { <S2SV_StartBug> sRet = CString ( _SKINDIR_ ) + \"/\" + sSkinName ; <S2SV_EndBug> } } return sRet + \"/\" ; }", "target": "<S2SV_ModStart> sSkinName ) { const CString sSkin = sSkinName . Replace_n ( \"/\" , \"_\" ) . Replace_n ( \".\" , \"_\" ) ; <S2SV_ModStart> + \"/webskins/\" + sSkin <S2SV_ModEnd> ; if ( <S2SV_ModStart> + \"/webskins/\" + sSkin <S2SV_ModEnd> ; if ( <S2SV_ModStart> + \"/\" + sSkin <S2SV_ModEnd> ; } }"}
{"source": "CWE-476 <S2SV_StartBug> GF_Err gf_isom_set_extraction_slc ( GF_ISOFile * the_file , u32 trackNumber , u32 StreamDescriptionIndex , const GF_SLConfig * slConfig ) <S2SV_EndBug> { GF_TrackBox * trak ; GF_SampleEntryBox * entry ; GF_Err e ; <S2SV_StartBug> GF_SLConfig * * slc ; <S2SV_EndBug> trak = gf_isom_get_track_from_file ( the_file , trackNumber ) ; if ( ! trak ) return GF_BAD_PARAM ; e = Media_GetSampleDesc ( trak -> Media , StreamDescriptionIndex , & entry , NULL ) ; if ( e ) return e ; <S2SV_StartBug> <S2SV_EndBug> switch ( entry -> type ) { case GF_ISOM_BOX_TYPE_MP4S : if ( ( ( GF_MPEGSampleEntryBox * ) entry ) -> esd -> desc -> slConfig -> predefined != SLPredef_MP4 ) return GF_BAD_PARAM ; <S2SV_StartBug> slc = & ( ( GF_MPEGSampleEntryBox * ) entry ) -> slc ; <S2SV_EndBug> break ; case GF_ISOM_BOX_TYPE_MP4A : if ( ( ( GF_MPEGAudioSampleEntryBox * ) entry ) -> esd -> desc -> slConfig -> predefined != SLPredef_MP4 ) return GF_BAD_PARAM ; <S2SV_StartBug> slc = & ( ( GF_MPEGAudioSampleEntryBox * ) entry ) -> slc ; <S2SV_EndBug> break ; case GF_ISOM_BOX_TYPE_MP4V : if ( ( ( GF_MPEGVisualSampleEntryBox * ) entry ) -> esd -> desc -> slConfig -> predefined != SLPredef_MP4 ) return GF_BAD_PARAM ; <S2SV_StartBug> slc = & ( ( GF_MPEGVisualSampleEntryBox * ) entry ) -> slc ; <S2SV_EndBug> break ; default : return GF_BAD_PARAM ; } <S2SV_StartBug> if ( * slc ) { <S2SV_EndBug> <S2SV_StartBug> gf_odf_desc_del ( ( GF_Descriptor * ) * slc ) ; <S2SV_EndBug> * slc = NULL ; } if ( ! slConfig ) return GF_OK ; return gf_odf_desc_copy ( ( GF_Descriptor * ) slConfig , ( GF_Descriptor * * ) slc ) ; }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> GF_Err gf_isom_get_extraction_slc <S2SV_ModEnd> ( GF_ISOFile * <S2SV_ModStart> u32 StreamDescriptionIndex , GF_SLConfig * * <S2SV_ModEnd> slConfig ) { <S2SV_ModStart> ; GF_SLConfig * <S2SV_ModEnd> slc ; trak <S2SV_ModStart> return e ; slc = NULL ; * slConfig = NULL ; <S2SV_ModStart> ; slc = <S2SV_ModEnd> ( ( GF_MPEGSampleEntryBox <S2SV_ModStart> ; slc = <S2SV_ModEnd> ( ( GF_MPEGAudioSampleEntryBox <S2SV_ModStart> ; slc = <S2SV_ModEnd> ( ( GF_MPEGVisualSampleEntryBox <S2SV_ModStart> } if ( ! slc ) return GF_OK ; return gf_odf_desc_copy <S2SV_ModEnd> ( ( GF_Descriptor <S2SV_ModStart> GF_Descriptor * ) slc , ( GF_Descriptor * * ) slConfig ) ; } <S2SV_ModEnd>  <S2SV_null> <S2SV_null>"}
{"source": "CWE-125 inline size_t codepoint_length ( const char * s8 , size_t l ) { if ( l ) { auto b = static_cast < uint8_t > ( s8 [ 0 ] ) ; if ( ( b & 0x80 ) == 0 ) { return 1 ; <S2SV_StartBug> } else if ( ( b & 0xE0 ) == 0xC0 ) { <S2SV_EndBug> return 2 ; <S2SV_StartBug> } else if ( ( b & 0xF0 ) == 0xE0 ) { <S2SV_EndBug> return 3 ; <S2SV_StartBug> } else if ( ( b & 0xF8 ) == 0xF0 ) { <S2SV_EndBug> return 4 ; } } return 0 ; }", "target": "<S2SV_ModStart> ) == 0xC0 && l >= 2 <S2SV_ModStart> ) == 0xE0 && l >= 3 <S2SV_ModStart> ) == 0xF0 && l >= 4"}
{"source": "CWE-703 void Compute ( OpKernelContext * context ) override { const Tensor * reverse_index_map_t ; const Tensor * grad_values_t ; OP_REQUIRES_OK ( context , context -> input ( \"reverse_index_map\" , & reverse_index_map_t ) ) ; OP_REQUIRES_OK ( context , context -> input ( \"grad_values\" , & grad_values_t ) ) ; const CPUDevice & d = context -> eigen_device < CPUDevice > ( ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( reverse_index_map_t -> shape ( ) ) , errors : : InvalidArgument ( \"reverse_index_map<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector,<S2SV_blank>saw:<S2SV_blank>\" , <S2SV_StartBug> reverse_index_map_t -> shape ( ) . DebugString ( ) ) ) ; <S2SV_EndBug> const auto reverse_index_map = reverse_index_map_t -> vec < int64 > ( ) ; const auto grad_values = grad_values_t -> vec < T > ( ) ; const int64 N = reverse_index_map_t -> shape ( ) . dim_size ( 0 ) ; const int64 N_full = grad_values_t -> shape ( ) . dim_size ( 0 ) ; Tensor * d_values_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"d_values\" , TensorShape ( { N } ) , & d_values_t ) ) ; auto d_values = d_values_t -> vec < T > ( ) ; Tensor * d_default_value_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"d_default_value\" , TensorShape ( { } ) , & d_default_value_t ) ) ; T & d_default_value = d_default_value_t -> scalar < T > ( ) ( ) ; d_default_value = T ( ) ; Tensor visited_t ; OP_REQUIRES_OK ( context , context -> allocate_temp ( DT_BOOL , TensorShape ( { N_full } ) , & visited_t ) ) ; auto visited = visited_t . vec < bool > ( ) ; visited . device ( d ) = visited . constant ( false ) ; for ( int i = 0 ; i < N ; ++ i ) { <S2SV_StartBug> d_values ( i ) = grad_values ( reverse_index_map ( i ) ) ; <S2SV_EndBug> <S2SV_StartBug> visited ( reverse_index_map ( i ) ) = true ; <S2SV_EndBug> } for ( int j = 0 ; j < N_full ; ++ j ) { if ( ! visited ( j ) ) { d_default_value += grad_values ( j ) ; } } }", "target": "<S2SV_ModStart> \"reverse_index_map<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector,<S2SV_blank>saw:<S2SV_blank>\" , reverse_index_map_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( grad_values_t -> shape ( ) ) , errors : : InvalidArgument ( \"grad_values<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector,<S2SV_blank>saw:<S2SV_blank>\" , grad_values_t <S2SV_ModStart> i ) { int64 reverse_index = reverse_index_map ( i ) ; OP_REQUIRES ( context , 0 <= reverse_index && reverse_index < N_full , errors : : InvalidArgument ( \"Elements<S2SV_blank>in<S2SV_blank>reverse<S2SV_blank>index<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>[0,<S2SV_blank>\" , N_full , \")<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , reverse_index ) ) ; <S2SV_ModStart> = grad_values ( reverse_index <S2SV_ModEnd> ) ; visited <S2SV_ModStart> ; visited ( reverse_index <S2SV_ModEnd> ) = true"}
{"source": "CWE-787 GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) { u32 i ; <S2SV_StartBug> if ( ! nb_pack ) nb_pack = 1 ; <S2SV_EndBug> if ( ! stbl -> SampleSize -> sampleCount ) { stbl -> SampleSize -> sampleSize = size ; stbl -> SampleSize -> sampleCount += nb_pack ; return GF_OK ; } if ( stbl -> SampleSize -> sampleSize && ( stbl -> SampleSize -> sampleSize == size ) ) { stbl -> SampleSize -> sampleCount += nb_pack ; return GF_OK ; } if ( ! stbl -> SampleSize -> sizes || ( stbl -> SampleSize -> sampleCount + nb_pack > stbl -> SampleSize -> alloc_size ) ) { Bool init_table = ( stbl -> SampleSize -> sizes == NULL ) ? 1 : 0 ; ALLOC_INC ( stbl -> SampleSize -> alloc_size ) ; <S2SV_StartBug> if ( stbl -> SampleSize -> sampleCount + nb_pack > stbl -> SampleSize -> alloc_size ) <S2SV_EndBug> <S2SV_StartBug> stbl -> SampleSize -> alloc_size = stbl -> SampleSize -> sampleCount + nb_pack ; <S2SV_EndBug> stbl -> SampleSize -> sizes = ( u32 * ) gf_realloc ( stbl -> SampleSize -> sizes , sizeof ( u32 ) * stbl -> SampleSize -> alloc_size ) ; if ( ! stbl -> SampleSize -> sizes ) return GF_OUT_OF_MEM ; memset ( & stbl -> SampleSize -> sizes [ stbl -> SampleSize -> sampleCount ] , 0 , sizeof ( u32 ) * ( stbl -> SampleSize -> alloc_size - stbl -> SampleSize -> sampleCount ) ) ; if ( init_table ) { for ( i = 0 ; i < stbl -> SampleSize -> sampleCount ; i ++ ) stbl -> SampleSize -> sizes [ i ] = stbl -> SampleSize -> sampleSize ; } } stbl -> SampleSize -> sampleSize = 0 ; for ( i = 0 ; i < nb_pack ; i ++ ) { stbl -> SampleSize -> sizes [ stbl -> SampleSize -> sampleCount + i ] = size ; } stbl -> SampleSize -> sampleCount += nb_pack ; if ( size > stbl -> SampleSize -> max_size ) stbl -> SampleSize -> max_size = size ; stbl -> SampleSize -> total_size += size ; stbl -> SampleSize -> total_samples += nb_pack ; return GF_OK ; }", "target": "<S2SV_ModStart> u32 i ; CHECK_PACK ( GF_ISOM_INVALID_FILE ) <S2SV_ModEnd> if ( ! <S2SV_ModStart> -> alloc_size ) { <S2SV_ModStart> + nb_pack ; }"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { const Tensor & x = context -> input ( 0 ) ; const Tensor & y = context -> input ( 1 ) ; const float min_x = context -> input ( 2 ) . flat < float > ( ) ( 0 ) ; const float max_x = context -> input ( 3 ) . flat < float > ( ) ( 0 ) ; const float min_y = context -> input ( 4 ) . flat < float > ( ) ( 0 ) ; const float max_y = context -> input ( 5 ) . flat < float > ( ) ( 0 ) ; BCast bcast ( BCast : : FromShape ( x . shape ( ) ) , BCast : : FromShape ( y . shape ( ) ) ) ; if ( ! bcast . IsValid ( ) ) { context -> SetStatus ( errors : : InvalidArgument ( \"Incompatible<S2SV_blank>shapes:<S2SV_blank>\" , x . shape ( ) . DebugString ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , y . shape ( ) . DebugString ( ) ) ) ; return ; } Tensor * z ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , BCast : : ToShape ( bcast . output_shape ( ) ) , & z ) ) ; OP_REQUIRES ( context , ( max_x > min_x ) , errors : : InvalidArgument ( \"max_x<S2SV_blank>must<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>min_x.\" ) ) ; OP_REQUIRES ( context , ( max_y > min_y ) , errors : : InvalidArgument ( \"max_y<S2SV_blank>must<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>min_y.\" ) ) ; const T * x_data = x . flat < T > ( ) . data ( ) ; const T * y_data = y . flat < T > ( ) . data ( ) ; Toutput * z_data = z -> flat < Toutput > ( ) . data ( ) ; const float smallest_min = std : : min ( min_x , min_y ) ; const float largest_max = std : : max ( max_x , max_y ) ; const float biggest_range = std : : max ( std : : abs ( smallest_min ) , std : : abs ( largest_max ) ) ; const float output_range = ( biggest_range * ( 1 << 14 ) ) ; const float min_z_value = - output_range ; const float max_z_value = output_range ; const int ndims = bcast . x_reshape ( ) . size ( ) ; if ( ndims <= 1 ) { if ( x . NumElements ( ) == 1 ) { ScalarAddition < T , Toutput > ( context , y_data , min_y , max_y , y . NumElements ( ) , x_data [ 0 ] , min_x , max_x , min_z_value , max_z_value , z_data ) ; } else if ( y . NumElements ( ) == 1 ) { ScalarAddition < T , Toutput > ( context , x_data , min_x , max_x , x . NumElements ( ) , y_data [ 0 ] , min_y , max_y , min_z_value , max_z_value , z_data ) ; } else { VectorAddition < T , Toutput > ( context , x_data , min_x , max_x , y_data , min_y , max_y , x . NumElements ( ) , min_z_value , max_z_value , z_data ) ; } } else if ( ndims == 2 ) { const T * vector_data ; int64 vector_num_elements ; float vector_min ; float vector_max ; const T * tensor_data ; int64 tensor_num_elements ; float tensor_min ; float tensor_max ; if ( x . NumElements ( ) < y . NumElements ( ) ) { vector_data = x_data ; vector_num_elements = x . NumElements ( ) ; vector_min = min_x ; vector_max = max_x ; tensor_data = y_data ; tensor_num_elements = y . NumElements ( ) ; tensor_min = min_y ; tensor_max = max_y ; } else { vector_data = y_data ; vector_num_elements = y . NumElements ( ) ; vector_min = min_y ; vector_max = max_y ; tensor_data = x_data ; tensor_num_elements = x . NumElements ( ) ; tensor_min = min_x ; tensor_max = max_x ; <S2SV_StartBug> } <S2SV_EndBug> VectorTensorAddition < T , Toutput > ( vector_data , vector_min , vector_max , vector_num_elements , tensor_data , tensor_min , tensor_max , tensor_num_elements , min_z_value , max_z_value , z_data ) ; } else { LOG ( INFO ) << \"ndims=\" << ndims ; LOG ( INFO ) << \"bcast.x_reshape()=\" << TensorShape ( bcast . x_reshape ( ) ) . DebugString ( ) ; LOG ( INFO ) << \"bcast.y_reshape()=\" << TensorShape ( bcast . y_reshape ( ) ) . DebugString ( ) ; LOG ( INFO ) << \"bcast.x_bcast()=\" << TensorShape ( bcast . x_bcast ( ) ) . DebugString ( ) ; LOG ( INFO ) << \"bcast.y_bcast()=\" << TensorShape ( bcast . y_bcast ( ) ) . DebugString ( ) ; context -> SetStatus ( errors : : Unimplemented ( \"Broadcast<S2SV_blank>between<S2SV_blank>\" , context -> input ( 0 ) . shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , context -> input ( 1 ) . shape ( ) . DebugString ( ) , \"<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet.\" ) ) ; return ; } Tensor * z_min = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , { } , & z_min ) ) ; z_min -> flat < float > ( ) ( 0 ) = min_z_value ; Tensor * z_max = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , { } , & z_max ) ) ; z_max -> flat < float > ( ) ( 0 ) = max_z_value ; }", "target": "<S2SV_ModStart> max_x ; } OP_REQUIRES ( context , vector_num_elements > 0 , errors : : InvalidArgument ( \"Must<S2SV_blank>have<S2SV_blank>some<S2SV_blank>elements<S2SV_blank>to<S2SV_blank>add\" ) ) ;"}
{"source": "CWE-369 void OneHotComputeImpl ( const OneHotContext & op_context ) { int prefix_dim_size = 1 ; for ( int i = 0 ; i < op_context . axis ; ++ i ) { prefix_dim_size *= op_context . indices -> dims -> data [ i ] ; } <S2SV_StartBug> const int suffix_dim_size = NumElements ( op_context . indices ) / prefix_dim_size ; <S2SV_EndBug> const int depth = * op_context . depth -> data . i32 ; const T on_value = * GetTensorData < T > ( op_context . on_value ) ; const T off_value = * GetTensorData < T > ( op_context . off_value ) ; T * output = GetTensorData < T > ( op_context . output ) ; const TI * indices = GetTensorData < TI > ( op_context . indices ) ; for ( int i = 0 ; i < prefix_dim_size ; ++ i ) { for ( int j = 0 ; j < depth ; ++ j ) { for ( int k = 0 ; k < suffix_dim_size ; ++ k , ++ output ) { * output = static_cast < int > ( indices [ i * suffix_dim_size + k ] ) == j ? on_value : off_value ; } } } }", "target": "<S2SV_ModStart> ] ; } if ( prefix_dim_size == 0 ) { return ; }"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { const int64 axis_input = context -> input ( 0 ) . scalar < int64 > ( ) ( ) ; const Tensor & input_indices = context -> input ( 1 ) ; const Tensor & input_values = context -> input ( 2 ) ; const Tensor & input_shape = context -> input ( 3 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsMatrix ( input_indices . shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_indices . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( input_values . shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_indices . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( input_shape . shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_shape . shape ( ) . DebugString ( ) ) ) ; const int64 input_rank = input_shape . vec < int64 > ( ) . size ( ) ; const int64 axis = ( axis_input < 0 ) ? input_rank + axis_input : axis_input ; OP_REQUIRES ( context , axis >= 0 && axis < input_rank , errors : : InvalidArgument ( \"Input<S2SV_blank>axis<S2SV_blank>should<S2SV_blank>be<S2SV_blank>in<S2SV_blank>range<S2SV_blank>[\" , - input_rank , \",<S2SV_blank>\" , input_rank , \"),<S2SV_blank>got<S2SV_blank>\" , axis_input ) ) ; OP_REQUIRES ( context , num_split_ >= 1 && num_split_ <= input_shape . vec < int64 > ( ) ( axis ) , errors : : InvalidArgument ( \"Input<S2SV_blank>num_split<S2SV_blank>should<S2SV_blank>be<S2SV_blank>between<S2SV_blank>1<S2SV_blank>\" \"and<S2SV_blank>the<S2SV_blank>splitting<S2SV_blank>dimension<S2SV_blank>size<S2SV_blank>(\" , input_shape . vec < int64 > ( ) ( axis ) , \"),<S2SV_blank>got<S2SV_blank>\" , num_split_ ) ) ; <S2SV_StartBug> sparse : : SparseTensor sparse_tensor ; <S2SV_EndBug> OP_REQUIRES_OK ( context , sparse : : SparseTensor : : Create ( input_indices , input_values , <S2SV_StartBug> TensorShape ( input_shape . vec < int64 > ( ) ) , & sparse_tensor ) ) ; <S2SV_EndBug> std : : vector < sparse : : SparseTensor > outputs ; OP_REQUIRES_OK ( context , sparse : : SparseTensor : : Split < T > ( sparse_tensor , axis , num_split_ , & outputs ) ) ; for ( int slice_index = 0 ; slice_index < num_split_ ; ++ slice_index ) { context -> set_output ( slice_index , outputs [ slice_index ] . indices ( ) ) ; context -> set_output ( slice_index + num_split_ , outputs [ slice_index ] . values ( ) ) ; Tensor * shape = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( slice_index + 2 * num_split_ , { outputs [ slice_index ] . dims ( ) } , & shape ) ) ; auto output_shape = outputs [ slice_index ] . shape ( ) ; for ( int dim = 0 ; dim < outputs [ slice_index ] . dims ( ) ; ++ dim ) { shape -> vec < int64 > ( ) ( dim ) = output_shape [ dim ] ; } } }", "target": "<S2SV_ModStart> ) ) ; TensorShape dense_shape ; const auto input_shape_flat = input_shape . flat < int64 > ( ) ; for ( int i = 0 ; i < input_shape . NumElements ( ) ; i ++ ) { OP_REQUIRES_OK ( context , dense_shape . AddDimWithStatus ( input_shape_flat ( i ) ) ) ; } <S2SV_ModStart> , input_values , dense_shape <S2SV_ModEnd> , & sparse_tensor"}
{"source": "CWE-476 GF_Err gf_hinter_finalize ( GF_ISOFile * file , GF_SDP_IODProfile IOD_Profile , u32 bandwidth ) { u32 i , sceneT , odT , descIndex , size , size64 ; GF_InitialObjectDescriptor * iod ; GF_SLConfig slc ; GF_ISOSample * samp ; Bool remove_ocr ; u8 * buffer ; char buf64 [ 5000 ] , sdpLine [ 5100 ] ; gf_isom_sdp_clean ( file ) ; if ( bandwidth ) { sprintf ( buf64 , \"b=AS:%d\" , bandwidth ) ; gf_isom_sdp_add_line ( file , buf64 ) ; } if ( gf_sys_is_test_mode ( ) ) { sprintf ( buf64 , \"a=x-copyright:<S2SV_blank>%s\" , \"MP4/3GP<S2SV_blank>File<S2SV_blank>hinted<S2SV_blank>with<S2SV_blank>GPAC<S2SV_blank>-<S2SV_blank>(c)<S2SV_blank>Telecom<S2SV_blank>ParisTech<S2SV_blank>(http://gpac.io)\" ) ; } else { sprintf ( buf64 , \"a=x-copyright:<S2SV_blank>MP4/3GP<S2SV_blank>File<S2SV_blank>hinted<S2SV_blank>with<S2SV_blank>GPAC<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%s\" , gf_gpac_version ( ) , gf_gpac_copyright ( ) ) ; } gf_isom_sdp_add_line ( file , buf64 ) ; if ( IOD_Profile == GF_SDP_IOD_NONE ) return GF_OK ; odT = sceneT = 0 ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( ! gf_isom_is_track_in_root_od ( file , i + 1 ) ) continue ; switch ( gf_isom_get_media_type ( file , i + 1 ) ) { case GF_ISOM_MEDIA_OD : odT = i + 1 ; break ; case GF_ISOM_MEDIA_SCENE : sceneT = i + 1 ; break ; } } remove_ocr = 0 ; if ( IOD_Profile == GF_SDP_IOD_ISMA_STRICT ) { IOD_Profile = GF_SDP_IOD_ISMA ; remove_ocr = 1 ; } if ( ( IOD_Profile == GF_SDP_IOD_ISMA ) && ! sceneT ) return GF_BAD_PARAM ; iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) return GF_NOT_SUPPORTED ; if ( IOD_Profile == GF_SDP_IOD_ISMA ) { GF_ESD * esd ; Bool is_ok = 1 ; while ( gf_list_count ( iod -> ESDescriptors ) ) { esd = ( GF_ESD * ) gf_list_get ( iod -> ESDescriptors , 0 ) ; gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; gf_list_rem ( iod -> ESDescriptors , 0 ) ; } if ( odT ) { esd = gf_isom_get_esd ( file , odT , 1 ) ; if ( gf_isom_get_sample_count ( file , odT ) == 1 ) { samp = gf_isom_get_sample ( file , odT , 1 , & descIndex ) ; if ( samp && gf_hinter_can_embbed_data ( samp -> data , samp -> dataLength , GF_STREAM_OD ) ) { InitSL_NULL ( & slc ) ; slc . predefined = 0 ; slc . hasRandomAccessUnitsOnlyFlag = 1 ; slc . timeScale = slc . timestampResolution = gf_isom_get_media_timescale ( file , odT ) ; slc . OCRResolution = 1000 ; slc . startCTS = samp -> DTS + samp -> CTS_Offset ; slc . startDTS = samp -> DTS ; gf_isom_set_extraction_slc ( file , odT , 1 , & slc ) ; size64 = gf_base64_encode ( samp -> data , samp -> dataLength , buf64 , 2000 ) ; buf64 [ size64 ] = 0 ; sprintf ( sdpLine , \"data:application/mpeg4-od-au;base64,%s\" , buf64 ) ; esd -> decoderConfig -> avgBitrate = 0 ; esd -> decoderConfig -> bufferSizeDB = samp -> dataLength ; esd -> decoderConfig -> maxBitrate = 0 ; size64 = ( u32 ) strlen ( sdpLine ) + 1 ; esd -> URLString = ( char * ) gf_malloc ( sizeof ( char ) * size64 ) ; strcpy ( esd -> URLString , sdpLine ) ; } else { GF_LOG ( GF_LOG_WARNING , GF_LOG_RTP , ( \"[rtp<S2SV_blank>hinter]<S2SV_blank>OD<S2SV_blank>sample<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>be<S2SV_blank>embedded<S2SV_blank>in<S2SV_blank>IOD<S2SV_blank>-<S2SV_blank>ISMA<S2SV_blank>disabled\\\\n\" ) ) ; is_ok = 0 ; } gf_isom_sample_del ( & samp ) ; } if ( remove_ocr ) esd -> OCRESID = 0 ; else if ( esd -> OCRESID == esd -> ESID ) esd -> OCRESID = 0 ; gf_list_add ( iod -> ESDescriptors , esd ) ; } esd = gf_isom_get_esd ( file , sceneT , 1 ) ; if ( gf_isom_get_sample_count ( file , sceneT ) == 1 ) { samp = gf_isom_get_sample ( file , sceneT , 1 , & descIndex ) ; <S2SV_StartBug> if ( gf_hinter_can_embbed_data ( samp -> data , samp -> dataLength , GF_STREAM_SCENE ) ) { <S2SV_EndBug> slc . timeScale = slc . timestampResolution = gf_isom_get_media_timescale ( file , sceneT ) ; slc . OCRResolution = 1000 ; slc . startCTS = samp -> DTS + samp -> CTS_Offset ; slc . startDTS = samp -> DTS ; gf_isom_set_extraction_slc ( file , sceneT , 1 , & slc ) ; size64 = gf_base64_encode ( samp -> data , samp -> dataLength , buf64 , 2000 ) ; buf64 [ size64 ] = 0 ; sprintf ( sdpLine , \"data:application/mpeg4-bifs-au;base64,%s\" , buf64 ) ; esd -> decoderConfig -> avgBitrate = 0 ; esd -> decoderConfig -> bufferSizeDB = samp -> dataLength ; esd -> decoderConfig -> maxBitrate = 0 ; esd -> URLString = ( char * ) gf_malloc ( sizeof ( char ) * ( strlen ( sdpLine ) + 1 ) ) ; strcpy ( esd -> URLString , sdpLine ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_RTP , ( \"[rtp<S2SV_blank>hinter]<S2SV_blank>Scene<S2SV_blank>description<S2SV_blank>sample<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>be<S2SV_blank>embedded<S2SV_blank>in<S2SV_blank>IOD<S2SV_blank>-<S2SV_blank>ISMA<S2SV_blank>disabled\\\\n\" ) ) ; is_ok = 0 ; } gf_isom_sample_del ( & samp ) ; } if ( remove_ocr ) esd -> OCRESID = 0 ; else if ( esd -> OCRESID == esd -> ESID ) esd -> OCRESID = 0 ; gf_list_add ( iod -> ESDescriptors , esd ) ; if ( is_ok ) { u32 has_a , has_v , has_i_a , has_i_v ; has_a = has_v = has_i_a = has_i_v = 0 ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { esd = gf_isom_get_esd ( file , i + 1 , 1 ) ; if ( ! esd ) continue ; if ( esd -> decoderConfig -> streamType == GF_STREAM_VISUAL ) { if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_MPEG4_PART2 ) has_i_v ++ ; else has_v ++ ; } else if ( esd -> decoderConfig -> streamType == GF_STREAM_AUDIO ) { if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_AAC_MPEG4 ) has_i_a ++ ; else has_a ++ ; } gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; } if ( ! has_v && ! has_a && ( has_i_v <= 1 ) && ( has_i_a <= 1 ) ) { sprintf ( sdpLine , \"a=isma-compliance:1,1.0,1\" ) ; gf_isom_sdp_add_line ( file , sdpLine ) ; } } } buffer = NULL ; size = 0 ; gf_odf_desc_write ( ( GF_Descriptor * ) iod , & buffer , & size ) ; gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; size64 = gf_base64_encode ( buffer , size , buf64 , 2000 ) ; buf64 [ size64 ] = 0 ; gf_free ( buffer ) ; sprintf ( sdpLine , \"a=mpeg4-iod:\\\\\"data:application/mpeg4-iod;base64,%s\\\\\"\" , buf64 ) ; gf_isom_sdp_add_line ( file , sdpLine ) ; return GF_OK ; }", "target": "<S2SV_ModStart> ; if ( samp &&"}
{"source": "CWE-369 Status GraphConstructor : : MakeEdge ( Node * src , int output_index , Node * dst , <S2SV_StartBug> int input_index ) { <S2SV_EndBug> DataType src_out = src -> output_type ( output_index ) ; DataType dst_in = dst -> input_type ( input_index ) ; if ( ! TypesCompatible ( dst_in , src_out ) ) { return errors : : InvalidArgument ( \"Input<S2SV_blank>\" , input_index , \"<S2SV_blank>of<S2SV_blank>node<S2SV_blank>\" , dst -> name ( ) , \"<S2SV_blank>was<S2SV_blank>passed<S2SV_blank>\" , DataTypeString ( src_out ) , \"<S2SV_blank>from<S2SV_blank>\" , src -> name ( ) , \":\" , output_index , \"<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>expected<S2SV_blank>\" , DataTypeString ( dst_in ) , \".\" ) ; } g_ -> AddEdge ( src , output_index , dst , input_index ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> input_index ) { if ( output_index >= src -> num_outputs ( ) ) { return errors : : InvalidArgument ( \"Output<S2SV_blank>\" , output_index , \"<S2SV_blank>of<S2SV_blank>node<S2SV_blank>\" , src -> name ( ) , \"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist.<S2SV_blank>Node<S2SV_blank>only<S2SV_blank>has<S2SV_blank>\" , src -> num_outputs ( ) , \"<S2SV_blank>outputs.\" ) ; } if ( input_index >= dst -> num_inputs ( ) ) { return errors : : InvalidArgument ( \"Input<S2SV_blank>\" , input_index , \"<S2SV_blank>of<S2SV_blank>node<S2SV_blank>\" , dst -> name ( ) , \"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist.<S2SV_blank>Node<S2SV_blank>only<S2SV_blank>has<S2SV_blank>\" , dst -> num_inputs ( ) , \"<S2SV_blank>inputs.\" ) ; }"}
{"source": "CWE-78 static int download ( struct SPDBDownloader * pd ) { SPDBDownloaderOpt * opt = pd -> opt ; <S2SV_StartBug> char * curl_cmd = NULL ; <S2SV_EndBug> char * extractor_cmd = NULL ; char * abspath_to_archive = NULL ; char * abspath_to_file = NULL ; char * archive_name = NULL ; size_t archive_name_len = 0 ; char * symbol_store_path = NULL ; char * dbg_file = NULL ; char * guid = NULL ; char * archive_name_escaped = NULL ; char * user_agent = NULL ; char * symbol_server = NULL ; int res = 0 ; int cmd_ret ; if ( ! opt -> dbg_file || ! * opt -> dbg_file ) { return 0 ; } <S2SV_StartBug> if ( ! checkCurl ( ) ) { <S2SV_EndBug> return 0 ; } archive_name_len = strlen ( opt -> dbg_file ) ; archive_name = malloc ( archive_name_len + 1 ) ; if ( ! archive_name ) { return 0 ; } memcpy ( archive_name , opt -> dbg_file , archive_name_len + 1 ) ; archive_name [ archive_name_len - 1 ] = '_' ; <S2SV_StartBug> symbol_store_path = r_str_escape ( opt -> symbol_store_path ) ; <S2SV_EndBug> dbg_file = r_str_escape ( opt -> dbg_file ) ; guid = r_str_escape ( opt -> guid ) ; archive_name_escaped = r_str_escape ( archive_name ) ; user_agent = r_str_escape ( opt -> user_agent ) ; symbol_server = r_str_escape ( opt -> symbol_server ) ; <S2SV_StartBug> abspath_to_archive = r_str_newf ( \"%s%s%s%s%s%s%s\" , <S2SV_EndBug> symbol_store_path , R_SYS_DIR , dbg_file , R_SYS_DIR , guid , R_SYS_DIR , archive_name_escaped ) ; abspath_to_file = strdup ( abspath_to_archive ) ; abspath_to_file [ strlen ( abspath_to_file ) - 1 ] = 'b' ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( \"File<S2SV_blank>already<S2SV_blank>downloaded.\\\\n\" ) ; R_FREE ( user_agent ) ; R_FREE ( abspath_to_archive ) ; R_FREE ( archive_name_escaped ) ; R_FREE ( symbol_store_path ) ; R_FREE ( dbg_file ) ; R_FREE ( guid ) ; R_FREE ( archive_name ) ; R_FREE ( abspath_to_file ) ; R_FREE ( symbol_server ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { res = 1 ; curl_cmd = r_str_newf ( \"curl<S2SV_blank>-sfLA<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\\\\\"%s/%s/%s/%s\\\\\"<S2SV_blank>--create-dirs<S2SV_blank>-o<S2SV_blank>\\\\\"%s\\\\\"\" , user_agent , symbol_server , dbg_file , guid , archive_name_escaped , abspath_to_archive ) ; # if __WINDOWS__ const char * cabextractor = \"expand\" ; const char * format = \"%s<S2SV_blank>%s<S2SV_blank>%s\" ; extractor_cmd = r_str_newf ( format , cabextractor , abspath_to_archive , abspath_to_file ) ; # else <S2SV_StartBug> const char * cabextractor = \"cabextract\" ; <S2SV_EndBug> const char * format = \"%s<S2SV_blank>-d<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\\\\\"%s\\\\\"\" ; char * abspath_to_dir = r_file_dirname ( abspath_to_archive ) ; <S2SV_StartBug> extractor_cmd = r_str_newf ( format , cabextractor , abspath_to_dir , abspath_to_archive ) ; <S2SV_EndBug> R_FREE ( abspath_to_dir ) ; # endif <S2SV_StartBug> eprintf ( \"Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>compressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\\\n\" , abspath_to_archive ) ; <S2SV_EndBug> if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) { eprintf ( \"curl<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%d\\\\n\" , cmd_ret ) ; res = 0 ; } eprintf ( \"Attempting<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>pdb\\\\n\" ) ; <S2SV_StartBug> if ( opt -> extract > 0 ) { <S2SV_EndBug> if ( res && ( ( cmd_ret = r_sys_cmd ( extractor_cmd ) ) != 0 ) ) { eprintf ( \"cab<S2SV_blank>extractor<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%d\\\\n\" , cmd_ret ) ; res = 0 ; } r_file_rm ( abspath_to_archive ) ; } <S2SV_StartBug> R_FREE ( curl_cmd ) ; <S2SV_EndBug> } if ( res == 0 ) { eprintf ( \"Falling<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uncompressed<S2SV_blank>pdb\\\\n\" ) ; <S2SV_StartBug> res = 1 ; <S2SV_EndBug> archive_name_escaped [ strlen ( archive_name_escaped ) - 1 ] = 'b' ; curl_cmd = r_str_newf ( \"curl<S2SV_blank>-sfLA<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\\\\\"%s/%s/%s/%s\\\\\"<S2SV_blank>--create-dirs<S2SV_blank>-o<S2SV_blank>\\\\\"%s\\\\\"\" , opt -> user_agent , opt -> symbol_server , opt -> dbg_file , opt -> guid , archive_name_escaped , abspath_to_file ) ; eprintf ( \"Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>uncompressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\\\n\" , abspath_to_file ) ; <S2SV_StartBug> if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) { <S2SV_EndBug> eprintf ( \"curl<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%d\\\\n\" , cmd_ret ) ; res = 0 ; } R_FREE ( curl_cmd ) ; } R_FREE ( abspath_to_archive ) ; R_FREE ( abspath_to_file ) ; R_FREE ( archive_name ) ; R_FREE ( extractor_cmd ) ; R_FREE ( symbol_store_path ) ; R_FREE ( dbg_file ) ; R_FREE ( guid ) ; R_FREE ( archive_name_escaped ) ; R_FREE ( user_agent ) ; R_FREE ( symbol_server ) ; return res ; }", "target": "<S2SV_ModStart> -> opt ; <S2SV_ModEnd> int res = <S2SV_ModStart> 0 ; } char * abspath_to_file = r_str_newf ( \"%s%s%s%s%s%s%s\" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , opt -> dbg_file ) ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( \"File<S2SV_blank>already<S2SV_blank>downloaded.\\\\n\" ) ; free ( abspath_to_file ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { char * extractor_cmd = NULL ; char * archive_name = strdup ( opt -> dbg_file ) ; archive_name [ strlen ( archive_name ) <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = '_' ; char * abspath_to_archive = r_str_newf ( \"%s%s%s%s%s%s%s\" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , archive_name ) ; eprintf ( \"Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>compressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\\\n\" , abspath_to_archive ) ; char * abs_arch_esc = r_str_escape_sh ( abspath_to_archive ) ; # if __WINDOWS__ char * abs_file_esc = r_str_escape_sh ( abspath_to_file ) ; extractor_cmd <S2SV_ModEnd> = r_str_newf ( <S2SV_ModStart> = r_str_newf ( \"expand<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\\\\\"%s\\\\\"\" , abs_arch_esc , abs_file_esc ) ; free ( abs_file_esc <S2SV_ModEnd> ) ; # <S2SV_ModStart> ; # else <S2SV_ModEnd> char * abspath_to_dir <S2SV_ModStart> abspath_to_archive ) ; char * abs_dir_esc = r_str_escape_sh ( abspath_to_dir ) ; <S2SV_ModStart> = r_str_newf ( \"cabextract<S2SV_blank>-d<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\\\\\"%s\\\\\"\" , abs_arch_esc , abs_dir_esc ) ; free ( abs_dir_esc ) ; free <S2SV_ModEnd> ( abspath_to_dir ) <S2SV_ModStart> ; # endif free ( abs_arch_esc ) ; res = download_and_write ( opt , archive_name ) ; <S2SV_ModEnd> if ( opt <S2SV_ModStart> extract > 0 && res ) { eprintf ( \"Attempting<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>pdb\\\\n\" ) ; if ( res && <S2SV_ModEnd> ( ( cmd_ret <S2SV_ModStart> ) ; } free ( archive_name ) ; free ( abspath_to_archive <S2SV_ModEnd> ) ; } <S2SV_ModStart> \"Falling<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uncompressed<S2SV_blank>pdb\\\\n\" ) ; <S2SV_ModEnd> eprintf ( \"Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>uncompressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\\\n\" <S2SV_ModStart> abspath_to_file ) ; res = download_and_write ( opt , opt -> dbg_file ) ; } free ( abspath_to_file <S2SV_ModEnd> ) ; return"}
{"source": "CWE-476 service_info * FindServiceEventURLPath ( service_table * table , const char * eventURLPath ) { service_info * finger = NULL ; uri_type parsed_url ; uri_type parsed_url_in ; <S2SV_StartBug> if ( table && <S2SV_EndBug> parse_uri ( eventURLPath , strlen ( eventURLPath ) , & parsed_url_in ) == HTTP_SUCCESS ) { finger = table -> serviceList ; while ( finger ) { if ( finger -> eventURL ) { if ( parse_uri ( finger -> eventURL , strlen ( finger -> eventURL ) , & parsed_url ) == HTTP_SUCCESS ) { if ( ! token_cmp ( & parsed_url . pathquery , & parsed_url_in . pathquery ) ) { return finger ; } } } finger = finger -> next ; } } return NULL ; }", "target": "<S2SV_ModStart> ; if ( ! table || ! eventURLPath ) { return NULL ; } if ( <S2SV_ModEnd> parse_uri ( eventURLPath"}
{"source": "CWE-476 service_info * FindServiceControlURLPath ( service_table * table , const char * controlURLPath ) { service_info * finger = NULL ; uri_type parsed_url ; uri_type parsed_url_in ; <S2SV_StartBug> if ( table && parse_uri ( controlURLPath , <S2SV_EndBug> strlen ( controlURLPath ) , & parsed_url_in ) == HTTP_SUCCESS ) { finger = table -> serviceList ; while ( finger ) { if ( finger -> controlURL ) { if ( parse_uri ( finger -> controlURL , strlen ( finger -> controlURL ) , & parsed_url ) == HTTP_SUCCESS ) { if ( ! token_cmp ( & parsed_url . pathquery , & parsed_url_in . pathquery ) ) { return finger ; } } } finger = finger -> next ; } } return NULL ; }", "target": "<S2SV_ModStart> ; if ( ! table || ! controlURLPath ) { return NULL ; } if ( <S2SV_ModEnd> parse_uri ( controlURLPath"}
{"source": "CWE-787 void Compute ( OpKernelContext * context ) override { const Tensor & x = context -> input ( 0 ) ; const Tensor & y = context -> input ( 1 ) ; <S2SV_StartBug> const float min_x = context -> input ( 2 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float max_x = context -> input ( 3 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float min_y = context -> input ( 4 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float max_y = context -> input ( 5 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> BCast bcast ( BCast : : FromShape ( x . shape ( ) ) , BCast : : FromShape ( y . shape ( ) ) ) ; if ( ! bcast . IsValid ( ) ) { context -> SetStatus ( errors : : InvalidArgument ( \"Incompatible<S2SV_blank>shapes:<S2SV_blank>\" , x . shape ( ) . DebugString ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , y . shape ( ) . DebugString ( ) ) ) ; return ; } Tensor * z ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , BCast : : ToShape ( bcast . output_shape ( ) ) , & z ) ) ; OP_REQUIRES ( context , ( max_x > min_x ) , errors : : InvalidArgument ( \"max_x<S2SV_blank>must<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>min_a.\" ) ) ; OP_REQUIRES ( context , ( max_y > min_y ) , errors : : InvalidArgument ( \"max_x<S2SV_blank>must<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>min_b.\" ) ) ; const int32 offset_x = FloatToQuantizedUnclamped < T > ( 0.0f , min_x , max_x ) ; const int32 offset_y = FloatToQuantizedUnclamped < T > ( 0.0f , min_y , max_y ) ; const T * x_data = x . flat < T > ( ) . data ( ) ; const T * y_data = y . flat < T > ( ) . data ( ) ; Toutput * z_data = z -> flat < Toutput > ( ) . data ( ) ; const int ndims = bcast . x_reshape ( ) . size ( ) ; if ( ndims <= 1 ) { if ( x . NumElements ( ) == 1 ) { ScalarMultiply < T , Toutput > ( context , y_data , offset_y , y . NumElements ( ) , x_data [ 0 ] , offset_x , z_data ) ; } else if ( y . NumElements ( ) == 1 ) { ScalarMultiply < T , Toutput > ( context , x_data , offset_x , x . NumElements ( ) , y_data [ 0 ] , offset_y , z_data ) ; } else { VectorMultiply < T , Toutput > ( context , x_data , offset_x , y_data , offset_y , x . NumElements ( ) , z_data ) ; } } else if ( ndims == 2 ) { const T * vector_data ; int64 vector_num_elements ; int32 vector_offset ; const T * tensor_data ; int64 tensor_num_elements ; int32 tensor_offset ; if ( x . NumElements ( ) < y . NumElements ( ) ) { vector_data = x_data ; vector_num_elements = x . NumElements ( ) ; vector_offset = offset_x ; tensor_data = y_data ; tensor_num_elements = y . NumElements ( ) ; tensor_offset = offset_y ; } else { vector_data = y_data ; vector_num_elements = y . NumElements ( ) ; vector_offset = offset_y ; tensor_data = x_data ; tensor_num_elements = x . NumElements ( ) ; tensor_offset = offset_x ; } if ( vector_num_elements == 0 ) { context -> SetStatus ( errors : : InvalidArgument ( \"vector<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>1<S2SV_blank>element\" ) ) ; return ; } VectorTensorMultiply < T , Toutput > ( vector_data , vector_offset , vector_num_elements , tensor_data , tensor_offset , tensor_num_elements , z_data ) ; } else { LOG ( INFO ) << \"ndims=\" << ndims ; LOG ( INFO ) << \"bcast.x_reshape()=\" << TensorShape ( bcast . x_reshape ( ) ) . DebugString ( ) ; LOG ( INFO ) << \"bcast.y_reshape()=\" << TensorShape ( bcast . y_reshape ( ) ) . DebugString ( ) ; LOG ( INFO ) << \"bcast.x_bcast()=\" << TensorShape ( bcast . x_bcast ( ) ) . DebugString ( ) ; LOG ( INFO ) << \"bcast.y_bcast()=\" << TensorShape ( bcast . y_bcast ( ) ) . DebugString ( ) ; context -> SetStatus ( errors : : Unimplemented ( \"Broadcast<S2SV_blank>between<S2SV_blank>\" , context -> input ( 0 ) . shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , context -> input ( 1 ) . shape ( ) . DebugString ( ) , \"<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet.\" ) ) ; return ; } float min_z_value ; float max_z_value ; QuantizationRangeForMultiplication < T , T , Toutput > ( min_x , max_x , min_y , max_y , & min_z_value , & max_z_value ) ; Tensor * z_min = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , { } , & z_min ) ) ; z_min -> flat < float > ( ) ( 0 ) = min_z_value ; Tensor * z_max = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , { } , & z_max ) ) ; z_max -> flat < float > ( ) ( 0 ) = max_z_value ; }", "target": "<S2SV_ModStart> 1 ) ; auto & min_x_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsScalar ( min_x_tensor . shape ( ) ) , errors : : InvalidArgument ( \"min_x<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) ) ; <S2SV_ModStart> float min_x = min_x_tensor . flat < float > ( ) ( 0 ) ; auto & max_x_tensor = <S2SV_ModStart> -> input ( 3 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsScalar ( max_x_tensor . shape ( ) ) , errors : : InvalidArgument ( \"max_x<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) <S2SV_ModEnd> ) ; const <S2SV_ModStart> float max_x = max_x_tensor . flat < float > ( ) ( 0 ) ; auto & min_y_tensor = <S2SV_ModStart> -> input ( 4 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsScalar ( min_y_tensor . shape ( ) ) , errors : : InvalidArgument ( \"min_y<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) <S2SV_ModEnd> ) ; const <S2SV_ModStart> float min_y = min_y_tensor . flat < float > ( ) ( 0 ) ; auto & max_y_tensor = <S2SV_ModStart> -> input ( 5 ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsScalar ( max_y_tensor . shape ( ) ) , errors : : InvalidArgument ( \"max_y<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) <S2SV_ModEnd> ) ; const <S2SV_ModStart> float max_y = max_y_tensor <S2SV_ModEnd> . flat <"}
{"source": "CWE-125 inline int MatchingDim ( const RuntimeShape & shape1 , int index1 , const RuntimeShape & shape2 , int index2 ) { TFLITE_DCHECK_EQ ( shape1 . Dims ( index1 ) , shape2 . Dims ( index2 ) ) ; <S2SV_StartBug> return shape1 . Dims ( index1 ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ) ; return std : : min ( <S2SV_ModStart> Dims ( index1 ) , shape2 . Dims ( index2 )"}
{"source": "CWE-787 void Compute ( OpKernelContext * ctx ) override { ReshapeOp : : Compute ( ctx ) ; <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> const float input_min_float = ctx -> input ( 2 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const float input_max_float = ctx -> input ( 3 ) . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> Tensor * output_min = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , TensorShape ( { } ) , & output_min ) ) ; output_min -> flat < float > ( ) ( 0 ) = input_min_float ; Tensor * output_max = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 2 , TensorShape ( { } ) , & output_max ) ) ; output_max -> flat < float > ( ) ( 0 ) = input_max_float ; }", "target": "<S2SV_ModStart> ctx ) ; if ( ! ctx -> status ( ) . ok ( ) ) { return ; } const auto & input_min_float_tensor = ctx -> input ( 2 ) ; const auto & input_min_float_shape = input_min_float_tensor . shape ( ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( input_min_float_shape ) || ( TensorShapeUtils : : IsVector ( input_min_float_shape ) && ( input_min_float_shape . dim_size ( 0 ) == 1 ) ) , errors : : InvalidArgument ( \"input_min<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>or<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>of<S2SV_blank>1<S2SV_blank>element\" ) ) ; <S2SV_ModStart> float input_min_float = input_min_float_tensor <S2SV_ModEnd> . flat < <S2SV_ModStart> ) ; const auto & input_max_float_tensor = ctx -> input ( 3 ) ; const auto & input_max_float_shape = input_max_float_tensor . shape ( ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( input_max_float_shape ) || ( TensorShapeUtils : : IsVector ( input_max_float_shape ) && ( input_max_float_shape . dim_size ( 0 ) == 1 ) ) , errors : : InvalidArgument ( \"input_max<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>or<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>of<S2SV_blank>1<S2SV_blank>element\" ) ) ; const <S2SV_ModStart> float input_max_float = input_max_float_tensor <S2SV_ModEnd> . flat <"}
{"source": "CWE-284 content : : WebContents * WebContents : : OpenURLFromTab ( content : : WebContents * source , const content : : OpenURLParams & params ) { if ( params . disposition != WindowOpenDisposition : : CURRENT_TAB ) { Emit ( \"-new-window\" , params . url , \"\" , params . disposition , \"\" , params . referrer , params . post_data ) ; return nullptr ; } <S2SV_StartBug> if ( Emit ( \"will-navigate\" , params . url ) ) <S2SV_EndBug> return nullptr ; if ( IsDestroyed ( ) ) return nullptr ; return CommonWebContentsDelegate : : OpenURLFromTab ( source , params ) ; }", "target": "<S2SV_ModStart> } if ( <S2SV_ModEnd> IsDestroyed ( )"}
{"source": "CWE-787 otError Commissioner : : GeneratePskc ( const char * aPassPhrase , const char * aNetworkName , const Mac : : ExtendedPanId & aExtPanId , Pskc & aPskc ) { otError error = OT_ERROR_NONE ; <S2SV_StartBug> const char * saltPrefix = \"Thread\" ; <S2SV_EndBug> uint8_t salt [ OT_PBKDF2_SALT_MAX_LEN ] ; uint16_t saltLen = 0 ; <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> VerifyOrExit ( ( strlen ( aPassPhrase ) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE ) && <S2SV_EndBug> <S2SV_StartBug> ( strlen ( aPassPhrase ) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE ) && <S2SV_EndBug> <S2SV_StartBug> ( strlen ( aNetworkName ) <= OT_NETWORK_NAME_MAX_SIZE ) , <S2SV_EndBug> error = OT_ERROR_INVALID_ARGS ) ; memset ( salt , 0 , sizeof ( salt ) ) ; <S2SV_StartBug> memcpy ( salt , saltPrefix , strlen ( saltPrefix ) ) ; <S2SV_EndBug> <S2SV_StartBug> saltLen += static_cast < uint16_t > ( strlen ( saltPrefix ) ) ; <S2SV_EndBug> memcpy ( salt + saltLen , aExtPanId . m8 , sizeof ( aExtPanId ) ) ; saltLen += OT_EXT_PAN_ID_SIZE ; <S2SV_StartBug> memcpy ( salt + saltLen , aNetworkName , strlen ( aNetworkName ) ) ; <S2SV_EndBug> <S2SV_StartBug> saltLen += static_cast < uint16_t > ( strlen ( aNetworkName ) ) ; <S2SV_EndBug> <S2SV_StartBug> otPbkdf2Cmac ( reinterpret_cast < const uint8_t * > ( aPassPhrase ) , static_cast < uint16_t > ( strlen ( aPassPhrase ) ) , <S2SV_EndBug> reinterpret_cast < const uint8_t * > ( salt ) , saltLen , 16384 , OT_PSKC_MAX_SIZE , aPskc . m8 ) ; exit : return error ; }", "target": "<S2SV_ModStart> ; const char saltPrefix [ ] <S2SV_ModEnd> = \"Thread\" ; <S2SV_ModStart> = 0 ; uint16_t passphraseLen ; uint8_t networkNameLen ; passphraseLen = static_cast < uint16_t > ( strnlen ( aPassPhrase , OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1 ) ) ; networkNameLen = static_cast < uint8_t > ( strnlen ( aNetworkName , OT_NETWORK_NAME_MAX_SIZE + 1 ) ) ; <S2SV_ModStart> VerifyOrExit ( ( passphraseLen <S2SV_ModEnd> >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE ) <S2SV_ModStart> ) && ( passphraseLen <S2SV_ModEnd> <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE ) <S2SV_ModStart> ) && ( networkNameLen <S2SV_ModEnd> <= OT_NETWORK_NAME_MAX_SIZE ) <S2SV_ModStart> , saltPrefix , sizeof ( saltPrefix ) - 1 <S2SV_ModEnd> ) ; saltLen <S2SV_ModStart> uint16_t > ( sizeof ( saltPrefix ) - 1 <S2SV_ModEnd> ) ; memcpy <S2SV_ModStart> , aNetworkName , networkNameLen <S2SV_ModEnd> ) ; saltLen <S2SV_ModStart> ; saltLen += networkNameLen <S2SV_ModEnd> ; otPbkdf2Cmac ( <S2SV_ModStart> aPassPhrase ) , passphraseLen , <S2SV_ModEnd> reinterpret_cast < const"}
{"source": "CWE-369 Status KernelAndDeviceOp : : Run ( ScopedStepContainer * step_container , const EagerKernelArgs & inputs , std : : vector < EagerKernelRet > * outputs , CancellationManager * cancellation_manager , const absl : : optional < EagerRemoteFunctionParams > & remote_func_params ) { OpKernelContext : : Params params ; params . device = device_ ; params . frame_iter = FrameAndIter ( 0 , 0 ) ; params . inputs = inputs . GetTensorValues ( ) ; params . op_kernel = kernel_ . get ( ) ; params . resource_manager = device_ -> resource_manager ( ) ; params . input_alloc_attrs = & input_alloc_attrs_ ; params . output_attr_array = output_alloc_attrs_ . data ( ) ; params . function_library = flr_ ; params . slice_reader_cache = & slice_reader_cache_ ; params . rendezvous = rendezvous_ ; OpExecutionState * op_execution_state = nullptr ; CancellationManager default_cancellation_manager ; if ( cancellation_manager ) { params . cancellation_manager = cancellation_manager ; } else if ( kernel_ -> is_deferred ( ) ) { op_execution_state = new OpExecutionState ; params . cancellation_manager = & op_execution_state -> cancellation_manager ; params . inc_num_deferred_ops_function = [ op_execution_state ] ( ) { op_execution_state -> Ref ( ) ; } ; params . dec_num_deferred_ops_function = [ op_execution_state ] ( ) { op_execution_state -> Unref ( ) ; } ; } else { params . cancellation_manager = & default_cancellation_manager ; } params . log_memory = log_memory_ ; params . runner = get_runner ( ) ; params . step_container = step_container == nullptr ? & step_container_ : step_container ; auto step_container_cleanup = gtl : : MakeCleanup ( [ step_container , this ] { if ( step_container == nullptr ) { this -> step_container_ . CleanUp ( ) ; } } ) ; params . collective_executor = collective_executor_ ? collective_executor_ -> get ( ) : nullptr ; OpKernelContext context ( & params ) ; { port : : ScopedFlushDenormal flush ; port : : ScopedSetRound round ( FE_TONEAREST ) ; profiler : : AnnotatedTraceMe activity ( [ & ] { return kernel_ -> TraceString ( context , false ) ; } , profiler : : TraceMeLevel : : kInfo ) ; device_ -> Compute ( kernel_ . get ( ) , & context ) ; } if ( op_execution_state != nullptr ) { op_execution_state -> Unref ( ) ; } if ( ! context . status ( ) . ok ( ) ) return context . status ( ) ; if ( outputs != nullptr ) { outputs -> clear ( ) ; for ( int i = 0 ; i < context . num_outputs ( ) ; ++ i ) { <S2SV_StartBug> outputs -> push_back ( Tensor ( * context . mutable_output ( i ) ) ) ; <S2SV_EndBug> } } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> i ) { const auto * output_tensor = context . mutable_output ( i ) ; if ( output_tensor != nullptr ) { <S2SV_ModStart> Tensor ( * output_tensor ) ) ; } else { outputs -> push_back ( Tensor ( ) ) ; } <S2SV_ModEnd> } } return"}
{"source": "CWE-703 void Compute ( OpKernelContext * ctx ) override { const auto splits = ctx -> input ( 0 ) . flat < int64 > ( ) ; const auto values = ctx -> input ( 1 ) . flat < Tidx > ( ) ; const Tensor & size_t = ctx -> input ( 2 ) ; const auto weights = ctx -> input ( 3 ) . flat < T > ( ) ; const int64 weights_size = weights . size ( ) ; Tidx size = size_t . scalar < Tidx > ( ) ( ) ; OP_REQUIRES ( ctx , size >= 0 , errors : : InvalidArgument ( \"size<S2SV_blank>(\" , size , \")<S2SV_blank>must<S2SV_blank>be<S2SV_blank>non-negative\" ) ) ; int num_rows = splits . size ( ) - 1 ; int num_values = values . size ( ) ; int batch_idx = 0 ; <S2SV_StartBug> Tensor * out_t ; <S2SV_EndBug> OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { num_rows , size } ) , & out_t ) ) ; functor : : SetZeroFunctor < Device , T > fill ; fill ( ctx -> eigen_device < Device > ( ) , out_t -> flat < T > ( ) ) ; const auto out = out_t -> matrix < T > ( ) ; for ( int idx = 0 ; idx < num_values ; ++ idx ) { while ( idx >= splits ( batch_idx ) ) { batch_idx ++ ; } Tidx bin = values ( idx ) ; OP_REQUIRES ( ctx , bin >= 0 , errors : : InvalidArgument ( \"Input<S2SV_blank>must<S2SV_blank>be<S2SV_blank>non-negative\" ) ) ; if ( bin < size ) { if ( binary_output_ ) { out ( batch_idx - 1 , bin ) = T ( 1 ) ; } else { T value = ( weights_size > 0 ) ? weights ( idx ) : T ( 1 ) ; out ( batch_idx - 1 , bin ) += value ; } } } }", "target": "<S2SV_ModStart> = 0 ; OP_REQUIRES ( ctx , splits ( 0 ) == 0 , errors : : InvalidArgument ( \"Splits<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>0,<S2SV_blank>not<S2SV_blank>with<S2SV_blank>\" , splits ( 0 ) ) ) ; OP_REQUIRES ( ctx , splits ( num_rows ) == num_values , errors : : InvalidArgument ( \"Splits<S2SV_blank>must<S2SV_blank>end<S2SV_blank>with<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values,<S2SV_blank>got<S2SV_blank>\" , splits ( num_rows ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>\" , num_values ) ) ;"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { const Tensor * input_indices ; const Tensor * input_values ; const Tensor * input_shape ; SparseTensorsMap * map ; OP_REQUIRES_OK ( context , context -> input ( \"sparse_indices\" , & input_indices ) ) ; OP_REQUIRES_OK ( context , context -> input ( \"sparse_values\" , & input_values ) ) ; OP_REQUIRES_OK ( context , context -> input ( \"sparse_shape\" , & input_shape ) ) ; OP_REQUIRES_OK ( context , GetMap ( context , true , & map ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsMatrix ( input_indices -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_indices -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( input_values -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_values -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( input_shape -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_shape -> shape ( ) . DebugString ( ) ) ) ; int rank = input_shape -> NumElements ( ) ; OP_REQUIRES ( context , rank > 1 , errors : : InvalidArgument ( \"Rank<S2SV_blank>of<S2SV_blank>input<S2SV_blank>SparseTensor<S2SV_blank>should<S2SV_blank>be<S2SV_blank>><S2SV_blank>1,<S2SV_blank>but<S2SV_blank>saw<S2SV_blank>rank:<S2SV_blank>\" , rank ) ) ; <S2SV_StartBug> TensorShape tensor_input_shape ( input_shape -> vec < int64 > ( ) ) ; <S2SV_EndBug> gtl : : InlinedVector < int64 , 8 > std_order ( rank ) ; std : : iota ( std_order . begin ( ) , std_order . end ( ) , 0 ) ; SparseTensor input_st ; OP_REQUIRES_OK ( context , SparseTensor : : Create ( * input_indices , * input_values , tensor_input_shape , std_order , & input_st ) ) ; <S2SV_StartBug> auto input_shape_t = input_shape -> vec < int64 > ( ) ; <S2SV_EndBug> <S2SV_StartBug> const int64 N = input_shape_t ( 0 ) ; <S2SV_EndBug> Tensor sparse_handles ( DT_INT64 , TensorShape ( { N } ) ) ; auto sparse_handles_t = sparse_handles . vec < int64 > ( ) ; OP_REQUIRES_OK ( context , input_st . IndicesValid ( ) ) ; TensorShape output_shape ; OP_REQUIRES_OK ( context , TensorShapeUtils : : MakeShape ( <S2SV_StartBug> input_shape_t . data ( ) + 1 , <S2SV_EndBug> input_shape -> NumElements ( ) - 1 , & output_shape ) ) ; std : : unordered_set < int64 > visited ; sparse : : GroupIterable minibatch = input_st . group ( { 0 } ) ; for ( const auto & subset : minibatch ) { const int64 b = subset . group ( ) [ 0 ] ; visited . insert ( b ) ; OP_REQUIRES ( context , b > - 1 && b < N , errors : : InvalidArgument ( \"Received<S2SV_blank>unexpected<S2SV_blank>column<S2SV_blank>0<S2SV_blank>value<S2SV_blank>in<S2SV_blank>input<S2SV_blank>SparseTensor:<S2SV_blank>\" , b , \"<S2SV_blank><<S2SV_blank>0<S2SV_blank>or<S2SV_blank>>=<S2SV_blank>N<S2SV_blank>(=<S2SV_blank>\" , N , \")\" ) ) ; const auto indices = subset . indices ( ) ; const auto values = subset . values < T > ( ) ; const int64 num_entries = values . size ( ) ; Tensor output_indices = Tensor ( DT_INT64 , { num_entries , rank - 1 } ) ; Tensor output_values = Tensor ( DataTypeToEnum < T > : : value , { num_entries } ) ; auto output_indices_t = output_indices . matrix < int64 > ( ) ; auto output_values_t = output_values . vec < T > ( ) ; for ( int i = 0 ; i < num_entries ; ++ i ) { for ( int d = 1 ; d < rank ; ++ d ) { output_indices_t ( i , d - 1 ) = indices ( i , d ) ; } output_values_t ( i ) = values ( i ) ; } SparseTensor st_i ; OP_REQUIRES_OK ( context , SparseTensor : : Create ( output_indices , output_values , output_shape , & st_i ) ) ; int64 handle ; OP_REQUIRES_OK ( context , map -> AddSparseTensor ( context , st_i , & handle ) ) ; sparse_handles_t ( b ) = handle ; } if ( visited . size ( ) < N ) { Tensor empty_indices ( DT_INT64 , { 0 , rank - 1 } ) ; Tensor empty_values ( DataTypeToEnum < T > : : value , { 0 } ) ; SparseTensor empty_st ; OP_REQUIRES_OK ( context , SparseTensor : : Create ( empty_indices , empty_values , output_shape , & empty_st ) ) ; for ( int64 b = 0 ; b < N ; ++ b ) { if ( visited . find ( b ) == visited . end ( ) ) { int64 handle ; OP_REQUIRES_OK ( context , map -> AddSparseTensor ( context , empty_st , & handle ) ) ; sparse_handles_t ( b ) = handle ; } } } context -> set_output ( 0 , sparse_handles ) ; }", "target": "<S2SV_ModStart> ) ) ; auto input_shape_vec = input_shape -> vec < int64 > ( ) ; int new_num_elements = 1 ; bool overflow_ocurred = false ; for ( int i = 0 ; i < input_shape_vec . size ( ) ; i ++ ) { new_num_elements = MultiplyWithoutOverflow ( new_num_elements , input_shape_vec ( i ) ) ; if ( new_num_elements < 0 ) { overflow_ocurred = true ; } } OP_REQUIRES ( context , ! overflow_ocurred , errors : : Internal ( \"Encountered<S2SV_blank>overflow<S2SV_blank>from<S2SV_blank>large<S2SV_blank>input<S2SV_blank>shape.\" ) ) ; <S2SV_ModStart> TensorShape tensor_input_shape ( input_shape_vec <S2SV_ModEnd> ) ; gtl <S2SV_ModStart> ) ) ; <S2SV_ModEnd> const int64 N <S2SV_ModStart> int64 N = input_shape_vec <S2SV_ModEnd> ( 0 ) <S2SV_ModStart> : MakeShape ( input_shape_vec <S2SV_ModEnd> . data ("}
{"source": "CWE-416 static int parse_playlist ( HLSContext * c , const char * url , struct playlist * pls , AVIOContext * in ) { int ret = 0 , is_segment = 0 , is_variant = 0 ; int64_t duration = 0 ; enum KeyType key_type = KEY_NONE ; uint8_t iv [ 16 ] = \"\" ; int has_iv = 0 ; char key [ MAX_URL_SIZE ] = \"\" ; char line [ MAX_URL_SIZE ] ; const char * ptr ; int close_in = 0 ; int64_t seg_offset = 0 ; int64_t seg_size = - 1 ; uint8_t * new_url = NULL ; struct variant_info variant_info ; char tmp_str [ MAX_URL_SIZE ] ; struct segment * cur_init_section = NULL ; if ( ! in ) { # if 1 AVDictionary * opts = NULL ; close_in = 1 ; av_dict_set ( & opts , \"seekable\" , \"0\" , 0 ) ; av_dict_set ( & opts , \"user-agent\" , c -> user_agent , 0 ) ; av_dict_set ( & opts , \"cookies\" , c -> cookies , 0 ) ; av_dict_set ( & opts , \"headers\" , c -> headers , 0 ) ; ret = avio_open2 ( & in , url , AVIO_FLAG_READ , c -> interrupt_callback , & opts ) ; av_dict_free ( & opts ) ; if ( ret < 0 ) return ret ; # else ret = open_in ( c , & in , url ) ; if ( ret < 0 ) return ret ; close_in = 1 ; # endif } if ( av_opt_get ( in , \"location\" , AV_OPT_SEARCH_CHILDREN , & new_url ) >= 0 ) url = new_url ; read_chomp_line ( in , line , sizeof ( line ) ) ; if ( strcmp ( line , \"#EXTM3U\" ) ) { ret = AVERROR_INVALIDDATA ; goto fail ; } if ( pls ) { free_segment_list ( pls ) ; pls -> finished = 0 ; pls -> type = PLS_TYPE_UNSPECIFIED ; } while ( ! avio_feof ( in ) ) { read_chomp_line ( in , line , sizeof ( line ) ) ; if ( av_strstart ( line , \"#EXT-X-STREAM-INF:\" , & ptr ) ) { is_variant = 1 ; memset ( & variant_info , 0 , sizeof ( variant_info ) ) ; ff_parse_key_value ( ptr , ( ff_parse_key_val_cb ) handle_variant_args , & variant_info ) ; } else if ( av_strstart ( line , \"#EXT-X-KEY:\" , & ptr ) ) { struct key_info info = { { 0 } } ; ff_parse_key_value ( ptr , ( ff_parse_key_val_cb ) handle_key_args , & info ) ; key_type = KEY_NONE ; has_iv = 0 ; if ( ! strcmp ( info . method , \"AES-128\" ) ) key_type = KEY_AES_128 ; if ( ! strcmp ( info . method , \"SAMPLE-AES\" ) ) key_type = KEY_SAMPLE_AES ; if ( ! strncmp ( info . iv , \"0x\" , 2 ) || ! strncmp ( info . iv , \"0X\" , 2 ) ) { ff_hex_to_data ( iv , info . iv + 2 ) ; has_iv = 1 ; } av_strlcpy ( key , info . uri , sizeof ( key ) ) ; } else if ( av_strstart ( line , \"#EXT-X-MEDIA:\" , & ptr ) ) { struct rendition_info info = { { 0 } } ; ff_parse_key_value ( ptr , ( ff_parse_key_val_cb ) handle_rendition_args , & info ) ; new_rendition ( c , & info , url ) ; } else if ( av_strstart ( line , \"#EXT-X-TARGETDURATION:\" , & ptr ) ) { ret = ensure_playlist ( c , & pls , url ) ; if ( ret < 0 ) goto fail ; pls -> target_duration = atoi ( ptr ) * AV_TIME_BASE ; } else if ( av_strstart ( line , \"#EXT-X-MEDIA-SEQUENCE:\" , & ptr ) ) { ret = ensure_playlist ( c , & pls , url ) ; if ( ret < 0 ) goto fail ; pls -> start_seq_no = atoi ( ptr ) ; } else if ( av_strstart ( line , \"#EXT-X-PLAYLIST-TYPE:\" , & ptr ) ) { ret = ensure_playlist ( c , & pls , url ) ; if ( ret < 0 ) goto fail ; if ( ! strcmp ( ptr , \"EVENT\" ) ) pls -> type = PLS_TYPE_EVENT ; else if ( ! strcmp ( ptr , \"VOD\" ) ) pls -> type = PLS_TYPE_VOD ; } else if ( av_strstart ( line , \"#EXT-X-MAP:\" , & ptr ) ) { struct init_section_info info = { { 0 } } ; ret = ensure_playlist ( c , & pls , url ) ; if ( ret < 0 ) goto fail ; ff_parse_key_value ( ptr , ( ff_parse_key_val_cb ) handle_init_section_args , & info ) ; cur_init_section = new_init_section ( pls , & info , url ) ; } else if ( av_strstart ( line , \"#EXT-X-ENDLIST\" , & ptr ) ) { if ( pls ) pls -> finished = 1 ; } else if ( av_strstart ( line , \"#EXTINF:\" , & ptr ) ) { is_segment = 1 ; duration = atof ( ptr ) * AV_TIME_BASE ; } else if ( av_strstart ( line , \"#EXT-X-BYTERANGE:\" , & ptr ) ) { seg_size = atoi ( ptr ) ; ptr = strchr ( ptr , '@' ) ; if ( ptr ) seg_offset = atoi ( ptr + 1 ) ; } else if ( av_strstart ( line , \"#\" , NULL ) ) { continue ; } else if ( line [ 0 ] ) { if ( is_variant ) { if ( ! new_variant ( c , & variant_info , line , url ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } is_variant = 0 ; } if ( is_segment ) { struct segment * seg ; if ( ! pls ) { if ( ! new_variant ( c , 0 , url , NULL ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } pls = c -> playlists [ c -> n_playlists - 1 ] ; } seg = av_malloc ( sizeof ( struct segment ) ) ; if ( ! seg ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } <S2SV_StartBug> seg -> duration = duration ; <S2SV_EndBug> seg -> key_type = key_type ; if ( has_iv ) { memcpy ( seg -> iv , iv , sizeof ( iv ) ) ; } else { int seq = pls -> start_seq_no + pls -> n_segments ; memset ( seg -> iv , 0 , sizeof ( seg -> iv ) ) ; AV_WB32 ( seg -> iv + 12 , seq ) ; } if ( key_type != KEY_NONE ) { ff_make_absolute_url ( tmp_str , sizeof ( tmp_str ) , url , key ) ; seg -> key = av_strdup ( tmp_str ) ; if ( ! seg -> key ) { av_free ( seg ) ; ret = AVERROR ( ENOMEM ) ; goto fail ; } } else { seg -> key = NULL ; } ff_make_absolute_url ( tmp_str , sizeof ( tmp_str ) , url , line ) ; seg -> url = av_strdup ( tmp_str ) ; if ( ! seg -> url ) { av_free ( seg -> key ) ; av_free ( seg ) ; ret = AVERROR ( ENOMEM ) ; goto fail ; } <S2SV_StartBug> dynarray_add ( & pls -> segments , & pls -> n_segments , seg ) ; <S2SV_EndBug> is_segment = 0 ; seg -> size = seg_size ; if ( seg_size >= 0 ) { seg -> url_offset = seg_offset ; seg_offset += seg_size ; seg_size = - 1 ; } else { seg -> url_offset = 0 ; seg_offset = 0 ; } seg -> init_section = cur_init_section ; } } } if ( pls ) pls -> last_load_time = av_gettime_relative ( ) ; fail : av_free ( new_url ) ; if ( close_in ) avio_close ( in ) ; return ret ; }", "target": "<S2SV_ModStart> fail ; } <S2SV_ModEnd> if ( has_iv <S2SV_ModStart> fail ; } if ( duration < 0.001 * AV_TIME_BASE ) { duration = 0.001 * AV_TIME_BASE ; } seg -> duration = duration ; seg -> key_type = key_type ;"}
{"source": "CWE-476 GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } } <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size , data , pck_size ) ; ctx -> latm_buffer_size += pck_size ; } if ( ! ctx -> bs ) ctx -> bs = gf_bs_new ( ctx -> latm_buffer , ctx -> latm_buffer_size , GF_BITSTREAM_READ ) ; else gf_bs_reassign_buffer ( ctx -> bs , ctx -> latm_buffer , ctx -> latm_buffer_size ) ; if ( ctx -> resume_from ) { gf_bs_seek ( ctx -> bs , ctx -> resume_from - 1 ) ; ctx -> resume_from = 0 ; } if ( cts == GF_FILTER_NO_TS ) prev_pck_size = 0 ; while ( 1 ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; u8 latm_buffer [ 4096 ] ; u32 latm_frame_size = 4096 ; if ( ! latm_dmx_sync_frame_bs ( ctx -> bs , & ctx -> acfg , & latm_frame_size , latm_buffer , NULL ) ) break ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } latm_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = pos + 1 ; return GF_OK ; } if ( ! ctx -> in_seek ) { GF_FilterSAPType sap = GF_FILTER_SAP_1 ; dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , latm_frame_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , latm_buffer , latm_frame_size ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> acfg . base_object_type == GF_CODECID_USAC ) { if ( latm_frame_size && ( output [ 0 ] & 0x80 ) && ! ctx -> prev_sap ) { sap = GF_FILTER_SAP_1 ; ctx -> prev_sap = GF_TRUE ; } else { sap = GF_FILTER_SAP_NONE ; ctx -> prev_sap = GF_FALSE ; } } gf_filter_pck_set_sap ( dst_pck , sap ) ; gf_filter_pck_send ( dst_pck ) ; } latm_dmx_update_cts ( ctx ) ; if ( prev_pck_size ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; if ( prev_pck_size <= pos ) { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } } if ( pck ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; assert ( ctx -> latm_buffer_size >= pos ) ; memmove ( ctx -> latm_buffer , ctx -> latm_buffer + pos , ctx -> latm_buffer_size - pos ) ; ctx -> latm_buffer_size -= pos ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; assert ( ! ctx -> resume_from ) ; } else { ctx -> latm_buffer_size = 0 ; return latm_dmx_process ( filter ) ; } return GF_OK ; }", "target": "<S2SV_ModStart> u8 * data = NULL <S2SV_ModStart> ; u32 pck_size = 0 <S2SV_ModStart> ; } } else { <S2SV_ModStart> pck_size ) ; }"}
{"source": "CWE-401 static GF_Err gf_isom_parse_movie_boxes_internal ( GF_ISOFile * mov , u32 * boxType , u64 * bytesMissing , Bool progressive_mode ) { GF_Box * a ; u64 totSize , mdat_end = 0 ; GF_Err e = GF_OK ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( mov -> single_moof_mode && mov -> single_moof_state == 2 ) { return e ; } totSize = mov -> current_top_box_start ; if ( mov -> bytes_removed ) { assert ( totSize >= mov -> bytes_removed ) ; totSize -= mov -> bytes_removed ; } gf_bs_seek ( mov -> movieFileMap -> bs , totSize ) ; # endif while ( gf_bs_available ( mov -> movieFileMap -> bs ) ) { * bytesMissing = 0 ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS mov -> current_top_box_start = gf_bs_get_position ( mov -> movieFileMap -> bs ) + mov -> bytes_removed ; GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Parsing<S2SV_blank>a<S2SV_blank>top-level<S2SV_blank>box<S2SV_blank>at<S2SV_blank>position<S2SV_blank>%d\\\\n\" , mov -> current_top_box_start ) ) ; # endif e = gf_isom_parse_root_box ( & a , mov -> movieFileMap -> bs , boxType , bytesMissing , progressive_mode ) ; if ( e >= 0 ) { } else if ( e == GF_ISOM_INCOMPLETE_FILE ) { if ( mov -> openMode != GF_ISOM_OPEN_READ ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Incomplete<S2SV_blank>MDAT<S2SV_blank>while<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>read-only\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( ( mov -> openMode == GF_ISOM_OPEN_READ ) && ! progressive_mode ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Incomplete<S2SV_blank>file<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>for<S2SV_blank>dump<S2SV_blank>-<S2SV_blank>aborting<S2SV_blank>parsing\\\\n\" ) ) ; break ; } return e ; } else { return e ; } switch ( a -> type ) { case GF_ISOM_BOX_TYPE_MOOV : if ( mov -> moov ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>MOOV<S2SV_blank>detected!\\\\n\" ) ) ; gf_isom_box_del ( a ) ; return GF_ISOM_INVALID_FILE ; } mov -> moov = ( GF_MovieBox * ) a ; mov -> original_moov_offset = mov -> current_top_box_start ; mov -> moov -> mov = mov ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( mov -> moov -> mvex ) mov -> moov -> mvex -> mov = mov ; # ifdef GF_ENABLE_CTRN if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { gf_isom_setup_traf_inheritance ( mov ) ; } # endif # endif e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; totSize += a -> size ; if ( ! mov -> moov -> mvhd ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>MovieHeaderBox\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( mov -> meta ) { gf_isom_meta_restore_items_ref ( mov , mov -> meta ) ; } if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { u32 k ; for ( k = 0 ; k < gf_list_count ( mov -> moov -> trackList ) ; k ++ ) { GF_TrackBox * trak = ( GF_TrackBox * ) gf_list_get ( mov -> moov -> trackList , k ) ; if ( trak -> sample_encryption ) { e = senc_Parse ( mov -> movieFileMap -> bs , trak , NULL , trak -> sample_encryption ) ; if ( e ) return e ; } } } else { u32 k ; for ( k = 0 ; k < gf_list_count ( mov -> moov -> trackList ) ; k ++ ) { GF_TrackBox * trak = ( GF_TrackBox * ) gf_list_get ( mov -> moov -> trackList , k ) ; if ( trak -> Media -> information -> sampleTable -> sampleGroups ) { convert_compact_sample_groups ( trak -> Media -> information -> sampleTable -> child_boxes , trak -> Media -> information -> sampleTable -> sampleGroups ) ; } } } if ( mdat_end && mov -> signal_frag_bounds && ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { gf_isom_push_mdat_end ( mov , mdat_end ) ; mdat_end = 0 ; } break ; case GF_ISOM_BOX_TYPE_META : if ( mov -> meta ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>META<S2SV_blank>detected!\\\\n\" ) ) ; gf_isom_box_del ( a ) ; return GF_ISOM_INVALID_FILE ; } mov -> meta = ( GF_MetaBox * ) a ; mov -> original_meta_offset = mov -> current_top_box_start ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) { return e ; } totSize += a -> size ; if ( mov -> moov ) { gf_isom_meta_restore_items_ref ( mov , mov -> meta ) ; } break ; case GF_ISOM_BOX_TYPE_MDAT : if ( ! mov -> first_data_toplevel_offset ) { mov -> first_data_toplevel_offset = mov -> current_top_box_start ; mov -> first_data_toplevel_size = a -> size ; } totSize += a -> size ; if ( mov -> openMode == GF_ISOM_OPEN_READ ) { if ( ! mov -> mdat ) { mov -> mdat = ( GF_MediaDataBox * ) a ; e = gf_list_add ( mov -> TopBoxes , mov -> mdat ) ; if ( e ) { return e ; } } # ifndef GPAC_DISABLE_ISOM_FRAGMENTS else if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) gf_list_add ( mov -> TopBoxes , a ) ; # endif else gf_isom_box_del ( a ) ; if ( mov -> signal_frag_bounds && ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { mdat_end = gf_bs_get_position ( mov -> movieFileMap -> bs ) ; if ( mov -> moov ) { gf_isom_push_mdat_end ( mov , mdat_end ) ; mdat_end = 0 ; } } } else if ( ! mov -> mdat && ( mov -> openMode != GF_ISOM_OPEN_READ ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) ) { gf_isom_box_del ( a ) ; mov -> mdat = ( GF_MediaDataBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_MDAT ) ; if ( ! mov -> mdat ) return GF_OUT_OF_MEM ; e = gf_list_add ( mov -> TopBoxes , mov -> mdat ) ; if ( e ) { return e ; } } else { gf_isom_box_del ( a ) ; } break ; case GF_ISOM_BOX_TYPE_FTYP : if ( mov -> brand ) { gf_isom_box_del ( a ) ; GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>\\'ftyp\\'<S2SV_blank>detected!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } mov -> brand = ( GF_FileTypeBox * ) a ; totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; break ; case GF_ISOM_BOX_TYPE_OTYP : if ( mov -> otyp ) { gf_isom_box_del ( a ) ; GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>\\'otyp\\'<S2SV_blank>detected!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { mov -> otyp = ( GF_Box * ) a ; totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; } else { GF_FileTypeBox * brand = ( GF_FileTypeBox * ) gf_isom_box_find_child ( a -> child_boxes , GF_ISOM_BOX_TYPE_FTYP ) ; if ( brand ) { s32 pos ; gf_list_del_item ( a -> child_boxes , brand ) ; pos = gf_list_del_item ( mov -> TopBoxes , mov -> brand ) ; gf_isom_box_del ( ( GF_Box * ) mov -> brand ) ; mov -> brand = brand ; if ( pos < 0 ) pos = 0 ; gf_list_insert ( mov -> TopBoxes , brand , pos ) ; <S2SV_StartBug> } <S2SV_EndBug> } break ; case GF_ISOM_BOX_TYPE_PDIN : if ( mov -> pdin ) { gf_isom_box_del ( a ) ; GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>\\'pdin\\'\\'<S2SV_blank>detected!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } mov -> pdin = ( GF_ProgressiveDownloadBox * ) a ; totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; break ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS case GF_ISOM_BOX_TYPE_STYP : { u32 brand = ( ( GF_FileTypeBox * ) a ) -> majorBrand ; switch ( brand ) { case GF_ISOM_BRAND_SISX : case GF_ISOM_BRAND_RISX : case GF_ISOM_BRAND_SSSS : mov -> is_index_segment = GF_TRUE ; break ; default : break ; } } case GF_ISOM_BOX_TYPE_SIDX : case GF_ISOM_BOX_TYPE_SSIX : if ( mov -> moov && ! mov -> first_data_toplevel_offset ) { mov -> first_data_toplevel_offset = mov -> current_top_box_start ; mov -> first_data_toplevel_size = a -> size ; } totSize += a -> size ; if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; } else if ( mov -> signal_frag_bounds && ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) ) { if ( a -> type == GF_ISOM_BOX_TYPE_SIDX ) { if ( mov -> root_sidx ) gf_isom_box_del ( ( GF_Box * ) mov -> root_sidx ) ; mov -> root_sidx = ( GF_SegmentIndexBox * ) a ; mov -> sidx_start_offset = mov -> current_top_box_start ; mov -> sidx_end_offset = gf_bs_get_position ( mov -> movieFileMap -> bs ) ; } else if ( a -> type == GF_ISOM_BOX_TYPE_STYP ) { mov -> styp_start_offset = mov -> current_top_box_start ; if ( mov -> seg_styp ) gf_isom_box_del ( mov -> seg_styp ) ; mov -> seg_styp = a ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SSIX ) { if ( mov -> seg_ssix ) gf_isom_box_del ( mov -> seg_ssix ) ; mov -> seg_ssix = a ; } else { gf_isom_box_del ( a ) ; } gf_isom_push_mdat_end ( mov , mov -> current_top_box_start ) ; } else if ( ! mov -> NextMoofNumber && ( a -> type == GF_ISOM_BOX_TYPE_SIDX ) ) { if ( mov -> main_sidx ) gf_isom_box_del ( ( GF_Box * ) mov -> main_sidx ) ; mov -> main_sidx = ( GF_SegmentIndexBox * ) a ; mov -> main_sidx_end_pos = mov -> current_top_box_start + a -> size ; } else { gf_isom_box_del ( a ) ; } break ; case GF_ISOM_BOX_TYPE_MOOF : gf_isom_disable_inplace_rewrite ( mov ) ; if ( ! mov -> moov ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Movie<S2SV_blank>fragment<S2SV_blank>but<S2SV_blank>no<S2SV_blank>moov<S2SV_blank>(yet)<S2SV_blank>-<S2SV_blank>possibly<S2SV_blank>broken<S2SV_blank>parsing!\\\\n\" ) ) ; } if ( mov -> single_moof_mode ) { mov -> single_moof_state ++ ; if ( mov -> single_moof_state > 1 ) { gf_isom_box_del ( a ) ; return GF_OK ; } } ( ( GF_MovieFragmentBox * ) a ) -> mov = mov ; totSize += a -> size ; mov -> moof = ( GF_MovieFragmentBox * ) a ; FixTrackID ( mov ) ; if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { FixSDTPInTRAF ( mov -> moof ) ; } else { u32 k ; for ( k = 0 ; k < gf_list_count ( mov -> moof -> TrackList ) ; k ++ ) { GF_TrackFragmentBox * traf = ( GF_TrackFragmentBox * ) gf_list_get ( mov -> moof -> TrackList , k ) ; if ( traf -> sampleGroups ) { convert_compact_sample_groups ( traf -> child_boxes , traf -> sampleGroups ) ; } } } if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { u32 k ; gf_list_add ( mov -> TopBoxes , a ) ; if ( mov -> moov ) { for ( k = 0 ; k < gf_list_count ( mov -> moof -> TrackList ) ; k ++ ) { GF_TrackFragmentBox * traf = gf_list_get ( mov -> moof -> TrackList , k ) ; if ( traf -> tfhd && mov -> moov -> mvex && mov -> moov -> mvex -> TrackExList ) { GF_TrackBox * trak = gf_isom_get_track_from_id ( mov -> moov , traf -> tfhd -> trackID ) ; u32 j = 0 ; while ( ( traf -> trex = ( GF_TrackExtendsBox * ) gf_list_enum ( mov -> moov -> mvex -> TrackExList , & j ) ) ) { if ( traf -> trex -> trackID == traf -> tfhd -> trackID ) { if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; break ; } traf -> trex = NULL ; } } if ( traf -> trex && traf -> tfhd && traf -> trex -> track && traf -> sample_encryption ) { GF_TrackBox * trak = GetTrackbyID ( mov -> moov , traf -> tfhd -> trackID ) ; trak -> current_traf_stsd_idx = traf -> tfhd -> sample_desc_index ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; e = senc_Parse ( mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; if ( e ) return e ; trak -> current_traf_stsd_idx = 0 ; } } } else { for ( k = 0 ; k < gf_list_count ( mov -> moof -> TrackList ) ; k ++ ) { GF_TrackFragmentBox * traf = gf_list_get ( mov -> moof -> TrackList , k ) ; if ( traf -> sample_encryption ) { e = senc_Parse ( mov -> movieFileMap -> bs , NULL , traf , traf -> sample_encryption ) ; if ( e ) return e ; } } } } else if ( mov -> openMode == GF_ISOM_OPEN_KEEP_FRAGMENTS ) { mov -> NextMoofNumber = mov -> moof -> mfhd -> sequence_number + 1 ; mov -> moof = NULL ; gf_isom_box_del ( a ) ; } else { e = MergeFragment ( ( GF_MovieFragmentBox * ) a , mov ) ; gf_isom_box_del ( a ) ; if ( e ) return e ; } if ( mov -> root_sidx ) { gf_isom_box_del ( ( GF_Box * ) mov -> root_sidx ) ; mov -> root_sidx = NULL ; } if ( mov -> root_ssix ) { gf_isom_box_del ( mov -> seg_ssix ) ; mov -> root_ssix = NULL ; } if ( mov -> seg_styp ) { gf_isom_box_del ( mov -> seg_styp ) ; mov -> seg_styp = NULL ; } mov -> sidx_start_offset = 0 ; mov -> sidx_end_offset = 0 ; mov -> styp_start_offset = 0 ; break ; # endif case GF_ISOM_BOX_TYPE_UNKNOWN : { GF_UnknownBox * box = ( GF_UnknownBox * ) a ; if ( box -> original_4cc == GF_ISOM_BOX_TYPE_JP ) { u8 * c = ( u8 * ) box -> data ; if ( ( box -> dataSize == 4 ) && ( GF_4CC ( c [ 0 ] , c [ 1 ] , c [ 2 ] , c [ 3 ] ) == ( u32 ) 0x0D0A870A ) ) mov -> is_jp2 = 1 ; gf_isom_box_del ( a ) ; } else { e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; } } break ; case GF_ISOM_BOX_TYPE_PRFT : # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { if ( mov -> last_producer_ref_time ) gf_isom_box_del ( a ) ; else mov -> last_producer_ref_time = ( GF_ProducerReferenceTimeBox * ) a ; break ; } # endif default : totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; break ; } # ifndef GPAC_DISABLE_ISOM_FRAGMENTS mov -> current_top_box_start = gf_bs_get_position ( mov -> movieFileMap -> bs ) + mov -> bytes_removed ; # endif } if ( ! mov -> moov && ! mov -> meta # ifndef GPAC_DISABLE_ISOM_FRAGMENTS && ! mov -> moof && ! mov -> is_index_segment # endif ) { return GF_ISOM_INCOMPLETE_FILE ; } if ( ! gf_opts_get_bool ( \"core\" , \"no-check\" ) ) { if ( mov -> moov && ! mov -> moov -> mvhd ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>MVHD<S2SV_blank>in<S2SV_blank>MOOV!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( mov -> meta && ! mov -> meta -> handler ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>handler<S2SV_blank>in<S2SV_blank>META!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } } # ifndef GPAC_DISABLE_ISOM_WRITE if ( mov -> moov ) { mov -> interleavingTime = mov -> moov -> mvhd -> timeScale ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( ( mov -> openMode > GF_ISOM_OPEN_READ ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) && mov -> moov -> mvex ) { gf_isom_box_del_parent ( & mov -> moov -> child_boxes , ( GF_Box * ) mov -> moov -> mvex ) ; mov -> moov -> mvex = NULL ; } # endif } if ( ! mov -> mdat && ( mov -> openMode != GF_ISOM_OPEN_READ ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) ) { mov -> mdat = ( GF_MediaDataBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_MDAT ) ; if ( ! mov -> mdat ) return GF_OUT_OF_MEM ; e = gf_list_add ( mov -> TopBoxes , mov -> mdat ) ; if ( e ) return e ; } # endif return GF_OK ; }", "target": "<S2SV_ModStart> ) ; } gf_isom_box_del ( a ) ;"}
{"source": "CWE-476 multi_process_incoming_link ( struct multi_context * m , struct multi_instance * instance , const unsigned int mpp_flags ) { struct gc_arena gc = gc_new ( ) ; struct context * c ; struct mroute_addr src , dest ; unsigned int mroute_flags ; struct multi_instance * mi ; bool ret = true ; bool floated = false ; if ( m -> pending ) { return true ; } if ( ! instance ) { # ifdef MULTI_DEBUG_EVENT_LOOP printf ( \"TCP/UDP<S2SV_blank>-><S2SV_blank>TUN<S2SV_blank>[%d]\\\\n\" , BLEN ( & m -> top . c2 . buf ) ) ; # endif multi_set_pending ( m , multi_get_create_instance_udp ( m , & floated ) ) ; } else { multi_set_pending ( m , instance ) ; } if ( m -> pending ) { set_prefix ( m -> pending ) ; c = & m -> pending -> context ; if ( ! instance ) { c -> c2 . buf = m -> top . c2 . buf ; if ( ! floated ) { c -> c2 . from = m -> top . c2 . from ; } } if ( BLEN ( & c -> c2 . buf ) > 0 ) { struct link_socket_info * lsi ; const uint8_t * orig_buf ; perf_push ( PERF_PROC_IN_LINK ) ; lsi = get_link_socket_info ( c ) ; orig_buf = c -> c2 . buf . data ; if ( process_incoming_link_part1 ( c , lsi , floated ) ) { <S2SV_StartBug> if ( floated ) <S2SV_EndBug> { multi_process_float ( m , m -> pending ) ; } process_incoming_link_part2 ( c , lsi , orig_buf ) ; } perf_pop ( ) ; if ( TUNNEL_TYPE ( m -> top . c1 . tuntap ) == DEV_TYPE_TUN ) { mroute_flags = mroute_extract_addr_from_packet ( & src , & dest , NULL , NULL , 0 , & c -> c2 . to_tun , DEV_TYPE_TUN ) ; if ( ! ( mroute_flags & MROUTE_EXTRACT_SUCCEEDED ) ) { c -> c2 . to_tun . len = 0 ; } else if ( multi_get_instance_by_virtual_addr ( m , & src , true ) != m -> pending ) { if ( ( src . type & MR_ADDR_MASK ) == MR_ADDR_IPV6 && IN6_IS_ADDR_LINKLOCAL ( & src . v6 . addr ) ) { } else { msg ( D_MULTI_DROPPED , \"MULTI:<S2SV_blank>bad<S2SV_blank>source<S2SV_blank>address<S2SV_blank>from<S2SV_blank>client<S2SV_blank>[%s],<S2SV_blank>packet<S2SV_blank>dropped\" , mroute_addr_print ( & src , & gc ) ) ; } c -> c2 . to_tun . len = 0 ; } else if ( m -> enable_c2c ) { if ( mroute_flags & MROUTE_EXTRACT_MCAST ) { multi_bcast ( m , & c -> c2 . to_tun , m -> pending , NULL , 0 ) ; } else { ASSERT ( ! ( mroute_flags & MROUTE_EXTRACT_BCAST ) ) ; mi = multi_get_instance_by_virtual_addr ( m , & dest , true ) ; if ( mi ) { # ifdef ENABLE_PF if ( ! pf_c2c_test ( & c -> c2 . pf , c -> c2 . tls_multi , & mi -> context . c2 . pf , mi -> context . c2 . tls_multi , \"tun_c2c\" ) ) { msg ( D_PF_DROPPED , \"PF:<S2SV_blank>client<S2SV_blank>-><S2SV_blank>client[%s]<S2SV_blank>packet<S2SV_blank>dropped<S2SV_blank>by<S2SV_blank>TUN<S2SV_blank>packet<S2SV_blank>filter\" , mi_prefix ( mi ) ) ; } else # endif { multi_unicast ( m , & c -> c2 . to_tun , mi ) ; register_activity ( c , BLEN ( & c -> c2 . to_tun ) ) ; } c -> c2 . to_tun . len = 0 ; } } } # ifdef ENABLE_PF if ( c -> c2 . to_tun . len && ! pf_addr_test ( & c -> c2 . pf , c , & dest , \"tun_dest_addr\" ) ) { msg ( D_PF_DROPPED , \"PF:<S2SV_blank>client<S2SV_blank>-><S2SV_blank>addr[%s]<S2SV_blank>packet<S2SV_blank>dropped<S2SV_blank>by<S2SV_blank>TUN<S2SV_blank>packet<S2SV_blank>filter\" , mroute_addr_print_ex ( & dest , MAPF_SHOW_ARP , & gc ) ) ; c -> c2 . to_tun . len = 0 ; } # endif } else if ( TUNNEL_TYPE ( m -> top . c1 . tuntap ) == DEV_TYPE_TAP ) { uint16_t vid = 0 ; # ifdef ENABLE_PF struct mroute_addr edest ; mroute_addr_reset ( & edest ) ; # endif if ( m -> top . options . vlan_tagging ) { if ( vlan_is_tagged ( & c -> c2 . to_tun ) ) { msg ( D_VLAN_DEBUG , \"dropping<S2SV_blank>incoming<S2SV_blank>VLAN-tagged<S2SV_blank>frame\" ) ; c -> c2 . to_tun . len = 0 ; } else { vid = c -> options . vlan_pvid ; } } mroute_flags = mroute_extract_addr_from_packet ( & src , & dest , NULL , # ifdef ENABLE_PF & edest , # else NULL , # endif vid , & c -> c2 . to_tun , DEV_TYPE_TAP ) ; if ( mroute_flags & MROUTE_EXTRACT_SUCCEEDED ) { if ( multi_learn_addr ( m , m -> pending , & src , 0 ) == m -> pending ) { if ( m -> enable_c2c ) { if ( mroute_flags & ( MROUTE_EXTRACT_BCAST | MROUTE_EXTRACT_MCAST ) ) { multi_bcast ( m , & c -> c2 . to_tun , m -> pending , NULL , vid ) ; } else { mi = multi_get_instance_by_virtual_addr ( m , & dest , false ) ; if ( mi ) { # ifdef ENABLE_PF if ( ! pf_c2c_test ( & c -> c2 . pf , c -> c2 . tls_multi , & mi -> context . c2 . pf , mi -> context . c2 . tls_multi , \"tap_c2c\" ) ) { msg ( D_PF_DROPPED , \"PF:<S2SV_blank>client<S2SV_blank>-><S2SV_blank>client[%s]<S2SV_blank>packet<S2SV_blank>dropped<S2SV_blank>by<S2SV_blank>TAP<S2SV_blank>packet<S2SV_blank>filter\" , mi_prefix ( mi ) ) ; } else # endif { multi_unicast ( m , & c -> c2 . to_tun , mi ) ; register_activity ( c , BLEN ( & c -> c2 . to_tun ) ) ; } c -> c2 . to_tun . len = 0 ; } } } # ifdef ENABLE_PF if ( c -> c2 . to_tun . len && ! pf_addr_test ( & c -> c2 . pf , c , & edest , \"tap_dest_addr\" ) ) { msg ( D_PF_DROPPED , \"PF:<S2SV_blank>client<S2SV_blank>-><S2SV_blank>addr[%s]<S2SV_blank>packet<S2SV_blank>dropped<S2SV_blank>by<S2SV_blank>TAP<S2SV_blank>packet<S2SV_blank>filter\" , mroute_addr_print_ex ( & edest , MAPF_SHOW_ARP , & gc ) ) ; c -> c2 . to_tun . len = 0 ; } # endif } else { msg ( D_MULTI_DROPPED , \"MULTI:<S2SV_blank>bad<S2SV_blank>source<S2SV_blank>address<S2SV_blank>from<S2SV_blank>client<S2SV_blank>[%s],<S2SV_blank>packet<S2SV_blank>dropped\" , mroute_addr_print ( & src , & gc ) ) ; c -> c2 . to_tun . len = 0 ; } } else { c -> c2 . to_tun . len = 0 ; } } } ret = multi_process_post ( m , m -> pending , mpp_flags ) ; clear_prefix ( ) ; } gc_free ( & gc ) ; return ret ; }", "target": "<S2SV_ModStart> if ( floated && c -> c2 . buf . len > 0"}
{"source": "CWE-476 GF_Err MergeTrack ( GF_TrackBox * trak , GF_TrackFragmentBox * traf , GF_MovieFragmentBox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , Bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , DescIndex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; Bool first_samp_in_traf = GF_TRUE ; Bool store_traf_map = GF_FALSE ; u8 * moof_template = NULL ; u32 moof_template_size = 0 ; Bool is_seg_start = GF_FALSE ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; GF_TrackFragmentRunBox * trun ; GF_TrunEntry * ent ; # ifdef GF_ENABLE_CTRN GF_TrackFragmentBox * traf_ref = NULL ; # endif GF_Err stbl_AppendTime ( GF_SampleTableBox * stbl , u32 duration , u32 nb_pack ) ; GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) ; GF_Err stbl_AppendChunk ( GF_SampleTableBox * stbl , u64 offset ) ; GF_Err stbl_AppendSampleToChunk ( GF_SampleTableBox * stbl , u32 DescIndex , u32 samplesInChunk ) ; GF_Err stbl_AppendCTSOffset ( GF_SampleTableBox * stbl , s32 CTSOffset ) ; GF_Err stbl_AppendRAP ( GF_SampleTableBox * stbl , u8 isRap ) ; GF_Err stbl_AppendPadding ( GF_SampleTableBox * stbl , u8 padding ) ; GF_Err stbl_AppendDegradation ( GF_SampleTableBox * stbl , u16 DegradationPriority ) ; if ( trak -> Header -> trackID != traf -> tfhd -> trackID ) return GF_OK ; if ( ! trak -> Media -> information -> sampleTable || ! trak -> Media -> information -> sampleTable -> SampleSize || ! trak -> Media -> information -> sampleTable -> TimeToSample || ! trak -> Media -> information -> sampleTable -> SampleToChunk || ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { return GF_ISOM_INVALID_FILE ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; DescIndex = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DESC ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! DescIndex ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>0,<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\\\n\" ) ) ; DescIndex = 1 ; } else if ( DescIndex > gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>sample<S2SV_blank>description(s),<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\\\n\" , DescIndex , gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) ) ; DescIndex = 1 ; } # ifdef GF_ENABLE_CTRN if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> TrackList ) ; for ( i = 0 ; i < traf_count ; i ++ ) { GF_TrackFragmentBox * atraf = gf_list_get ( moof_box -> TrackList , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackID == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DUR ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_SIZE ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_FLAGS ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & GF_ISOM_TRAF_BASE_OFFSET ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & GF_ISOM_MOOF_BASE_OFFSET ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef GPAC_DISABLE_LOG if ( trak -> moov -> mov -> NextMoofNumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> baseMediaDecodeTime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> baseMediaDecodeTime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Warning:<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>\" LLD \"<S2SV_blank>less<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>\" LLD \"<S2SV_blank>-<S2SV_blank>using<S2SV_blank>tfdt\\\\n\" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>\" LLD \"<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>\" LLD \"<S2SV_blank>(last<S2SV_blank>sample<S2SV_blank>got<S2SV_blank>extended<S2SV_blank>in<S2SV_blank>duration)\\\\n\" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> baseMediaDecodeTime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( GF_Box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = GF_TRUE ; if ( is_first_merge ) { GF_MovieFragmentBox * moof_clone = NULL ; gf_isom_box_freeze_order ( ( GF_Box * ) moof_box ) ; gf_isom_clone_box ( ( GF_Box * ) moof_box , ( GF_Box * * ) & moof_clone ) ; if ( moof_clone ) { GF_BitStream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> TrackList ) ; i ++ ) { GF_TrackFragmentBox * traf_clone = gf_list_get ( moof_clone -> TrackList , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> TrackRuns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroupsDescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = NULL ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = NULL ; } } gf_isom_box_size ( ( GF_Box * ) moof_clone ) ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( GF_Box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( GF_Box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( GF_Box * ) moof_clone , bs ) ; gf_isom_box_del ( ( GF_Box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = GF_TRUE ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = GF_TRUE ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = GF_TRUE ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( GF_TrackFragmentRunBox * ) gf_list_enum ( traf -> TrackRuns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { GF_Err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>enough<S2SV_blank>trun<S2SV_blank>entries<S2SV_blank>(%d)<S2SV_blank>compared<S2SV_blank>to<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>(%d)<S2SV_blank>in<S2SV_blank>run\\\\n\" , traf -> trex -> trackID , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> CTS_Offset ; # ifdef GF_ENABLE_CTRN if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> Duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> Duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xF0 ) { GF_TrunEntry * ref_entry ; if ( ! traf_ref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>to<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>reference<S2SV_blank>traf<S2SV_blank>not<S2SV_blank>found\\\\n\" , traf -> trex -> trackID , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>but<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>reference<S2SV_blank>traf\\\\n\" , traf -> trex -> trackID , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR ) duration = ref_entry -> Duration ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE ) size = ref_entry -> size ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO ) cts_offset = ref_entry -> CTS_Offset ; } } else # endif { if ( trun -> flags & GF_ISOM_TRUN_DURATION ) duration = ent -> Duration ; if ( trun -> flags & GF_ISOM_TRUN_SIZE ) size = ent -> size ; if ( trun -> flags & GF_ISOM_TRUN_FLAGS ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & GF_ISOM_TRUN_FIRST_FLAG ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> Duration = duration ; ent -> flags = flags ; ent -> CTS_Offset = cts_offset ; last_dts += duration ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) { trak -> Media -> information -> sampleTable -> SampleSize = ( GF_SampleSizeBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSZ ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) return GF_OUT_OF_MEM ; } e = stbl_AppendSize ( trak -> Media -> information -> sampleTable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) { trak -> Media -> information -> sampleTable -> TimeToSample = ( GF_TimeToSampleBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STTS ) ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) return GF_OUT_OF_MEM ; } e = stbl_AppendTime ( trak -> Media -> information -> sampleTable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & GF_ISOM_TRUN_DATA_OFFSET ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { trak -> Media -> information -> sampleTable -> ChunkOffset = gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STCO ) ; if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) return GF_OUT_OF_MEM ; } e = stbl_AppendChunk ( trak -> Media -> information -> sampleTable , final_offset ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) { trak -> Media -> information -> sampleTable -> SampleToChunk = ( GF_SampleToChunkBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSC ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) return GF_OUT_OF_MEM ; } e = stbl_AppendSampleToChunk ( trak -> Media -> information -> sampleTable , DescIndex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = GF_FALSE ; e = stbl_AppendTrafMap ( trak -> Media -> information -> sampleTable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = NULL ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_AppendCTSOffset ( trak -> Media -> information -> sampleTable , cts_offset ) ; if ( e ) return e ; sync = GF_ISOM_GET_FRAG_SYNC ( flags ) ; if ( trak -> Media -> information -> sampleTable -> no_sync_found && sync ) { trak -> Media -> information -> sampleTable -> no_sync_found = 0 ; } e = stbl_AppendRAP ( trak -> Media -> information -> sampleTable , sync ) ; if ( e ) return e ; pad = GF_ISOM_GET_FRAG_PAD ( flags ) ; if ( pad ) { e = stbl_AppendPadding ( trak -> Media -> information -> sampleTable , pad ) ; if ( e ) return e ; } degr = GF_ISOM_GET_FRAG_DEG ( flags ) ; if ( degr ) { e = stbl_AppendDegradation ( trak -> Media -> information -> sampleTable , degr ) ; if ( e ) return e ; } e = stbl_AppendDependencyType ( trak -> Media -> information -> sampleTable , GF_ISOM_GET_FRAG_LEAD ( flags ) , GF_ISOM_GET_FRAG_DEPENDS ( flags ) , GF_ISOM_GET_FRAG_DEPENDED ( flags ) , GF_ISOM_GET_FRAG_REDUNDANT ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editBox && trak -> editBox -> editList ) { for ( i = 0 ; i < gf_list_count ( trak -> editBox -> editList -> entryList ) ; i ++ ) { GF_EdtsEntry * edts_e = gf_list_get ( trak -> editBox -> editList -> entryList , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timeScale ; extend_dur /= trak -> Media -> mediaHeader -> timeScale ; edts_e -> segmentDuration += extend_dur ; } else if ( ! edts_e -> segmentDuration ) { edts_e -> was_empty_dur = GF_TRUE ; if ( ( s64 ) traf_duration > edts_e -> mediaTime ) traf_duration -= edts_e -> mediaTime ; else traf_duration = 0 ; edts_e -> segmentDuration = traf_duration ; edts_e -> segmentDuration *= trak -> moov -> mvhd -> timeScale ; edts_e -> segmentDuration /= trak -> Media -> mediaHeader -> timeScale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> sampleGroups ) { GF_List * groups ; GF_List * groupDescs ; Bool is_identical_sgpd = GF_TRUE ; u32 * new_idx = NULL , new_idx_count = 0 ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroups ) trak -> Media -> information -> sampleTable -> sampleGroups = gf_list_new ( ) ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) trak -> Media -> information -> sampleTable -> sampleGroupsDescription = gf_list_new ( ) ; groupDescs = trak -> Media -> information -> sampleTable -> sampleGroupsDescription ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroupsDescription ) ; i ++ ) { GF_SampleGroupDescriptionBox * new_sgdesc = NULL ; GF_SampleGroupDescriptionBox * sgdesc = gf_list_get ( traf -> sampleGroupsDescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupDescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupDescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = NULL ; } if ( ! new_sgdesc ) { gf_list_add ( groupDescs , sgdesc ) ; gf_list_add ( trak -> Media -> information -> sampleTable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> sampleGroupsDescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return GF_OUT_OF_MEM ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; Bool new_entry = GF_TRUE ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = GF_FALSE ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> Media -> information -> sampleTable -> sampleGroups ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroups ) ; i ++ ) { GF_SampleGroupBox * stbl_group = NULL ; GF_SampleGroupBox * frag_group = gf_list_get ( traf -> sampleGroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = NULL ; } if ( ! stbl_group ) { stbl_group = ( GF_SampleGroupBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_SBGP ) ; if ( ! stbl_group ) return GF_OUT_OF_MEM ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0FFFF ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( GF_SampleGroupEntry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[isobmf]<S2SV_blank>corrupted<S2SV_blank>sample<S2SV_blank>group<S2SV_blank>index<S2SV_blank>in<S2SV_blank>fragment<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>fragment\\\\n\" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> Header -> trackID ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , DescIndex ) || traf -> sample_encryption ) { GF_SampleEncryptionBox * senc = NULL ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , DescIndex , NULL , & scheme_type , NULL ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> Media -> information -> sampleTable -> child_boxes ) ; i ++ ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == GF_ISOM_BOX_TYPE_UUID ) && ( ( ( GF_UUIDBox * ) a ) -> internal_4cc == GF_ISOM_BOX_UUID_PSEC ) ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SENC ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( GF_SampleEncryptionBox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , NULL ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> Media -> information -> sampleTable -> child_boxes ) trak -> Media -> information -> sampleTable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; GF_Err e ; Bool is_encrypted ; GF_SampleAuxiliaryInfoOffsetBox * saio = NULL ; GF_SampleAuxiliaryInfoSizeBox * saiz = NULL ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( GF_SampleAuxiliaryInfoOffsetBox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) { <S2SV_StartBug> offset = saio -> offsets [ 0 ] + moof_offset ; <S2SV_EndBug> nb_saio = saio -> entry_count ; break ; } } <S2SV_StartBug> for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { <S2SV_EndBug> saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ; <S2SV_StartBug> } <S2SV_EndBug> } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { GF_CENCSampleAuxInfo * sai ; const u8 * key_info = NULL ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> movieFileMap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , offset ) ; GF_SAFEALLOC ( sai , GF_CENCSampleAuxInfo ) ; if ( ! sai ) return GF_OUT_OF_MEM ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , NULL , NULL , & key_info , & key_info_size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[isobmf]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>cenc<S2SV_blank>info<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d:<S2SV_blank>%s\\\\n\" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return GF_OUT_OF_MEM ; gf_bs_read_data ( trak -> moov -> mov -> movieFileMap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isNotProtected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> Media -> information -> sampleTable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_Parse ( trak -> moov -> mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> AlgorithmID = traf -> sample_encryption -> AlgorithmID ; if ( ! trak -> sample_encryption -> IV_size ) trak -> sample_encryption -> IV_size = traf -> sample_encryption -> IV_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return GF_OK ; }", "target": "<S2SV_ModStart> ) ) { if ( saio -> offsets && saio -> entry_count ) { <S2SV_ModStart> ; } } saio = NULL ; } <S2SV_ModStart> break ; } saiz = NULL ;"}
{"source": "CWE-476 TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteConcatenationParams * > ( node -> builtin_data ) ; int axis = params -> axis ; int num_inputs = node -> inputs -> size ; const TfLiteTensor * t0 ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , 0 , & t0 ) ) ; TfLiteType input_type = t0 -> type ; if ( axis < 0 ) axis += t0 -> dims -> size ; TF_LITE_ENSURE ( context , axis >= 0 ) ; TF_LITE_ENSURE ( context , axis < t0 -> dims -> size ) ; TF_LITE_ENSURE_EQ ( context , params -> activation , kTfLiteActNone ) ; TF_LITE_ENSURE ( context , input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 || input_type == kTfLiteInt8 || input_type == kTfLiteInt16 || input_type == kTfLiteInt32 || input_type == kTfLiteInt64 || input_type == kTfLiteBool ) ; int sum_axis = t0 -> dims -> data [ axis ] ; for ( int i = 1 ; i < num_inputs ; ++ i ) { const TfLiteTensor * t ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , i , & t ) ) ; TF_LITE_ENSURE_EQ ( context , t -> dims -> size , t0 -> dims -> size ) ; TF_LITE_ENSURE_EQ ( context , t -> type , input_type ) ; for ( int d = 0 ; d < t0 -> dims -> size ; ++ d ) { <S2SV_StartBug> if ( d == axis ) { <S2SV_EndBug> sum_axis += t -> dims -> data [ axis ] ; } else { TF_LITE_ENSURE_EQ ( context , t -> dims -> data [ d ] , t0 -> dims -> data [ d ] ) ; } } } TfLiteIntArray * output_size = TfLiteIntArrayCreate ( t0 -> dims -> size ) ; for ( int d = 0 ; d < t0 -> dims -> size ; ++ d ) { output_size -> data [ d ] = ( d == axis ) ? sum_axis : t0 -> dims -> data [ d ] ; } TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , 0 , & output ) ) ; TF_LITE_ENSURE_TYPES_EQ ( context , output -> type , input_type ) ; if ( input_type == kTfLiteInt8 ) { VectorOfTensors < int8_t > all_inputs ( * context , * node -> inputs ) ; for ( int i = 0 ; i < node -> inputs -> size ; ++ i ) { const TfLiteTensor * t ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , i , & t ) ) ; TF_LITE_ENSURE_EQ ( context , t -> params . scale , output -> params . scale ) ; TF_LITE_ENSURE_EQ ( context , t -> params . zero_point , output -> params . zero_point ) ; } } if ( input_type == kTfLiteInt16 ) { for ( int i = 0 ; i < node -> inputs -> size ; ++ i ) { const TfLiteTensor * t = GetInput ( context , node , i ) ; TF_LITE_ENSURE_EQ ( context , t -> params . zero_point , 0 ) ; } TF_LITE_ENSURE_EQ ( context , output -> params . zero_point , 0 ) ; } return context -> ResizeTensor ( context , output , output_size ) ; }", "target": "<S2SV_ModStart> axis ) { TF_LITE_ENSURE ( context , t -> dims -> data [ axis ] >= 0 ) ; TF_LITE_ENSURE ( context , t -> dims -> data [ axis ] <= std : : numeric_limits < int > : : max ( ) - sum_axis ) ;"}
{"source": "CWE-200 Pong ( const std : : string & cookie , const std : : string & server = \"\" ) : ClientProtocol : : Message ( \"PONG\" , ServerInstance -> Config -> GetServerName ( ) ) { <S2SV_StartBug> PushParamRef ( ServerInstance -> Config -> GetServerName ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! server . empty ( ) ) <S2SV_EndBug> PushParamRef ( server ) ; PushParamRef ( cookie ) ; }", "target": "<S2SV_ModStart> ) ) { if ( server . empty ( ) ) <S2SV_ModStart> ) ) ; else PushParam <S2SV_ModEnd> ( server )"}
{"source": "CWE-787 static int cbs_jpeg_split_fragment ( CodedBitstreamContext * ctx , CodedBitstreamFragment * frag , int header ) { AVBufferRef * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , AV_LOG_WARNING , \"Discarding<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>\" \"beginning<S2SV_blank>of<S2SV_blank>image.\\\\n\" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>\" \"no<S2SV_blank>SOI<S2SV_blank>marker<S2SV_blank>found.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; if ( marker != JPEG_MARKER_SOI ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>first<S2SV_blank>\" \"marker<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>SOI.\\\\n\" , marker ) ; return AVERROR_INVALIDDATA ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>\" \"no<S2SV_blank>image<S2SV_blank>content<S2SV_blank>found.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; ; unit ++ ) { if ( marker == JPEG_MARKER_EOI ) { break ; } else if ( marker == JPEG_MARKER_SOS ) { for ( i = start ; i + 1 < frag -> data_size ; i ++ ) { if ( frag -> data [ i ] != 0xff ) continue ; end = i ; for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { if ( frag -> data [ i ] == 0x00 ) continue ; next_marker = frag -> data [ i ] ; next_start = i + 1 ; } break ; } } else { i = start ; if ( i + 2 > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>\" \"truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker.\\\\n\" , marker ) ; return AVERROR_INVALIDDATA ; } length = AV_RB16 ( frag -> data + i ) ; if ( i + length > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>\" \"truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker<S2SV_blank>segment.\\\\n\" , marker ) ; return AVERROR_INVALIDDATA ; } end = start + length ; i = end ; if ( frag -> data [ i ] != 0xff ) { next_marker = - 1 ; } else { for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { next_marker = frag -> data [ i ] ; next_start = i + 1 ; } } } if ( marker == JPEG_MARKER_SOS ) { length = AV_RB16 ( frag -> data + start ) ; <S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug> data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! data ) return AVERROR ( ENOMEM ) ; memcpy ( data , frag -> data + start , length ) ; for ( i = start + length , j = length ; i < end ; i ++ , j ++ ) { if ( frag -> data [ i ] == 0xff ) { while ( frag -> data [ i ] == 0xff ) ++ i ; data [ j ] = 0xff ; } else { data [ j ] = frag -> data [ i ] ; } } data_size = j ; memset ( data + data_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; } else { data = frag -> data + start ; data_size = end - start ; data_ref = frag -> data_ref ; } err = ff_cbs_insert_unit_data ( ctx , frag , unit , marker , data , data_size , data_ref ) ; if ( err < 0 ) { if ( ! data_ref ) av_freep ( & data ) ; return err ; } if ( next_marker == - 1 ) break ; marker = next_marker ; start = next_start ; } return 0 ; }", "target": "<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;"}
{"source": "CWE-787 TfLiteStatus ResizeOutput ( TfLiteContext * context , const TfLiteTensor * input , const TfLiteTensor * axis , TfLiteTensor * output ) { int axis_value ; if ( axis -> type == kTfLiteInt64 ) { axis_value = static_cast < int > ( * GetTensorData < int64_t > ( axis ) ) ; } else { axis_value = * GetTensorData < int > ( axis ) ; } if ( axis_value < 0 ) { axis_value += NumDimensions ( input ) ; <S2SV_StartBug> } <S2SV_EndBug> TfLiteIntArray * output_dims = TfLiteIntArrayCreate ( NumDimensions ( input ) - 1 ) ; int j = 0 ; for ( int i = 0 ; i < NumDimensions ( input ) ; ++ i ) { if ( i != axis_value ) { output_dims -> data [ j ] = SizeOfDimension ( input , i ) ; ++ j ; } } return context -> ResizeTensor ( context , output , output_dims ) ; }", "target": "<S2SV_ModStart> ) ; } TF_LITE_ENSURE ( context , axis_value >= 0 ) ; TF_LITE_ENSURE ( context , axis_value < NumDimensions ( input ) ) ;"}
{"source": "CWE-415 mrb_realloc ( mrb_state * mrb , void * p , size_t len ) { void * p2 ; p2 = mrb_realloc_simple ( mrb , p , len ) ; if ( len == 0 ) return p2 ; if ( p2 == NULL ) { <S2SV_StartBug> mrb_free ( mrb , p ) ; <S2SV_EndBug> mrb -> gc . out_of_memory = TRUE ; mrb_raise_nomemory ( mrb ) ; } else { mrb -> gc . out_of_memory = FALSE ; } return p2 ; }", "target": "<S2SV_ModStart> NULL ) { <S2SV_ModEnd> mrb -> gc"}
{"source": "CWE-125 Status GetFirstDimensionSize ( OpKernelContext * context , INDEX_TYPE * result ) { const Tensor first_partition_tensor = <S2SV_StartBug> context -> input ( kFirstPartitionInputIndex ) ; <S2SV_EndBug> const RowPartitionType first_partition_type = row_partition_types_ [ 0 ] ; switch ( first_partition_type ) { case RowPartitionType : : FIRST_DIM_SIZE : * result = first_partition_tensor . scalar < INDEX_TYPE > ( ) ( ) ; return Status : : OK ( ) ; case RowPartitionType : : VALUE_ROWIDS : return errors : : InvalidArgument ( \"Cannot<S2SV_blank>handle<S2SV_blank>VALUE_ROWIDS<S2SV_blank>in<S2SV_blank>first<S2SV_blank>dimension.\" ) ; case RowPartitionType : : ROW_SPLITS : * result = first_partition_tensor . shape ( ) . dim_size ( 0 ) - 1 ; return Status : : OK ( ) ; default : return errors : : InvalidArgument ( \"Cannot<S2SV_blank>handle<S2SV_blank>type<S2SV_blank>\" , RowPartitionTypeToString ( first_partition_type ) ) ; } }", "target": "<S2SV_ModStart> kFirstPartitionInputIndex ) ; if ( row_partition_types_ . empty ( ) ) { return errors : : InvalidArgument ( \"No<S2SV_blank>row_partition_types<S2SV_blank>given.\" ) ; }"}
{"source": "CWE-787 void Compute ( OpKernelContext * ctx ) override { const Tensor * a_indices , * b_indices , * a_values_t , * b_values_t , * a_shape , * b_shape , * thresh_t ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"a_indices\" , & a_indices ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"b_indices\" , & b_indices ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( a_indices -> shape ( ) ) && TensorShapeUtils : : IsMatrix ( b_indices -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>matrices<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shapes:<S2SV_blank>\" , a_indices -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b_indices -> shape ( ) . DebugString ( ) ) ) ; const int64 a_nnz = a_indices -> dim_size ( 0 ) ; const int64 b_nnz = b_indices -> dim_size ( 0 ) ; <S2SV_StartBug> <S2SV_EndBug> OP_REQUIRES_OK ( ctx , ctx -> input ( \"a_values\" , & a_values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"b_values\" , & b_values_t ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( a_values_t -> shape ( ) ) && TensorShapeUtils : : IsVector ( b_values_t -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>vectors<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shapes:<S2SV_blank>\" , a_values_t -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b_values_t -> shape ( ) . DebugString ( ) ) ) ; auto a_values = ctx -> input ( 1 ) . vec < T > ( ) ; auto b_values = ctx -> input ( 4 ) . vec < T > ( ) ; OP_REQUIRES ( ctx , a_values . size ( ) == a_nnz && b_values . size ( ) == b_nnz , errors : : InvalidArgument ( \"Expected<S2SV_blank>\" , a_nnz , \"<S2SV_blank>and<S2SV_blank>\" , b_nnz , \"<S2SV_blank>non-empty<S2SV_blank>input<S2SV_blank>values,<S2SV_blank>got<S2SV_blank>\" , a_values . size ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b_values . size ( ) ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"a_shape\" , & a_shape ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"b_shape\" , & b_shape ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( a_shape -> shape ( ) ) && TensorShapeUtils : : IsVector ( b_shape -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shapes<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shapes<S2SV_blank>\" , a_shape -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b_shape -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( <S2SV_StartBug> ctx , a_shape -> IsSameSize ( * b_shape ) , <S2SV_EndBug> errors : : InvalidArgument ( \"Operands<S2SV_blank>do<S2SV_blank>not<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>ranks;<S2SV_blank>got<S2SV_blank>shapes:<S2SV_blank>\" , a_shape -> SummarizeValue ( 10 ) , \"<S2SV_blank>and<S2SV_blank>\" , b_shape -> SummarizeValue ( 10 ) ) ) ; const auto a_shape_flat = a_shape -> flat < int64 > ( ) ; const auto b_shape_flat = b_shape -> flat < int64 > ( ) ; for ( int i = 0 ; i < a_shape -> NumElements ( ) ; ++ i ) { OP_REQUIRES ( ctx , a_shape_flat ( i ) == b_shape_flat ( i ) , errors : : InvalidArgument ( \"Operands\\'<S2SV_blank>shapes<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match:<S2SV_blank>got<S2SV_blank>\" , a_shape_flat ( i ) , \"<S2SV_blank>and<S2SV_blank>\" , b_shape_flat ( i ) , \"<S2SV_blank>for<S2SV_blank>dimension<S2SV_blank>\" , i ) ) ; } OP_REQUIRES_OK ( ctx , ctx -> input ( \"thresh\" , & thresh_t ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( thresh_t -> shape ( ) ) , errors : : InvalidArgument ( \"The<S2SV_blank>magnitude<S2SV_blank>threshold<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar:<S2SV_blank>got<S2SV_blank>shape<S2SV_blank>\" , thresh_t -> shape ( ) . DebugString ( ) ) ) ; const Treal thresh = thresh_t -> scalar < Treal > ( ) ( ) ; auto a_indices_mat = a_indices -> matrix < int64 > ( ) ; auto b_indices_mat = b_indices -> matrix < int64 > ( ) ; std : : vector < std : : pair < bool , int64 >> entries_to_copy ; entries_to_copy . reserve ( a_nnz + b_nnz ) ; std : : vector < T > out_values ; <S2SV_StartBug> const int num_dims = a_shape -> dim_size ( 0 ) ; <S2SV_EndBug> OP_REQUIRES ( ctx , num_dims > 0 , errors : : InvalidArgument ( \"Invalid<S2SV_blank>input_a<S2SV_blank>shape.<S2SV_blank>Received:<S2SV_blank>\" , a_shape -> DebugString ( ) ) ) ; int64 i = 0 , j = 0 ; T s ; while ( i < a_nnz && j < b_nnz ) { switch ( sparse : : DimComparator : : cmp ( a_indices_mat , b_indices_mat , i , j , num_dims ) ) { case - 1 : entries_to_copy . emplace_back ( true , i ) ; out_values . push_back ( a_values ( i ) ) ; ++ i ; break ; case 0 : s = a_values ( i ) + b_values ( j ) ; if ( thresh <= std : : abs ( s ) ) { entries_to_copy . emplace_back ( true , i ) ; out_values . push_back ( s ) ; } ++ i ; ++ j ; break ; case 1 : entries_to_copy . emplace_back ( false , j ) ; out_values . push_back ( b_values ( j ) ) ; ++ j ; break ; } } # define HANDLE_LEFTOVERS ( A_OR_B , IDX , IS_A ) while ( IDX < A_OR_B ## _nnz ) { entries_to_copy . emplace_back ( IS_A , IDX ) ; out_values . push_back ( A_OR_B ## _values ( IDX ) ) ; ++ IDX ; } HANDLE_LEFTOVERS ( a , i , true ) ; HANDLE_LEFTOVERS ( b , j , false ) ; # undef HANDLE_LEFTOVERS const int64 sum_nnz = out_values . size ( ) ; Tensor * out_indices_t , * out_values_t ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { sum_nnz , num_dims } ) , & out_indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , TensorShape ( { sum_nnz } ) , & out_values_t ) ) ; auto out_indices_mat = out_indices_t -> matrix < int64 > ( ) ; auto out_values_flat = out_values_t -> vec < T > ( ) ; for ( i = 0 ; i < sum_nnz ; ++ i ) { const bool from_a = entries_to_copy [ i ] . first ; const int64 idx = entries_to_copy [ i ] . second ; out_indices_mat . chip < 0 > ( i ) = from_a ? a_indices_mat . chip < 0 > ( idx ) : b_indices_mat . chip < 0 > ( idx ) ; } if ( sum_nnz > 0 ) { std : : copy_n ( out_values . begin ( ) , sum_nnz , & out_values_flat ( 0 ) ) ; } ctx -> set_output ( 2 , * a_shape ) ; }", "target": "<S2SV_ModStart> 0 ) ; const int num_dims = a_indices -> dim_size ( 1 ) ; OP_REQUIRES ( ctx , b_indices -> dim_size ( 1 ) == num_dims , errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>dimension,<S2SV_blank>got<S2SV_blank>\" , num_dims , \"<S2SV_blank>and<S2SV_blank>\" , b_indices -> dim_size ( 1 ) ) ) ; <S2SV_ModStart> , a_shape -> NumElements ( ) == num_dims , errors : : InvalidArgument ( \"Second<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>a_indices<S2SV_blank>and<S2SV_blank>length<S2SV_blank>of<S2SV_blank>\" \"a_shape<S2SV_blank>must<S2SV_blank>match,<S2SV_blank>got<S2SV_blank>\" , num_dims , \"<S2SV_blank>and<S2SV_blank>\" , a_shape -> NumElements ( ) ) ) ; OP_REQUIRES ( ctx , num_dims > 0 , errors : : InvalidArgument ( \"Tesors<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty\" ) ) ; OP_REQUIRES ( ctx , a_shape -> <S2SV_ModStart> > out_values ; <S2SV_ModEnd> int64 i ="}
{"source": "CWE-787 void Compute ( OpKernelContext * context ) override { const Tensor & image = context -> input ( 0 ) ; OP_REQUIRES ( context , image . dims ( ) == 3 , errors : : InvalidArgument ( \"image<S2SV_blank>must<S2SV_blank>be<S2SV_blank>3-dimensional\" , <S2SV_StartBug> image . shape ( ) . DebugString ( ) ) ) ; <S2SV_EndBug> OP_REQUIRES ( context , FastBoundsCheck ( image . NumElements ( ) , std : : numeric_limits < int32 > : : max ( ) ) , errors : : InvalidArgument ( \"image<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>>=<S2SV_blank>int32<S2SV_blank>max<S2SV_blank>elements\" ) ) ; const int32 height = static_cast < int32 > ( image . dim_size ( 0 ) ) ; const int32 width = static_cast < int32 > ( image . dim_size ( 1 ) ) ; const int32 channels = static_cast < int32 > ( image . dim_size ( 2 ) ) ; const int32 max_row_width = std : : numeric_limits < int32 > : : max ( ) / 2 ; OP_REQUIRES ( context , FastBoundsCheck ( width * channels , max_row_width ) , errors : : InvalidArgument ( \"image<S2SV_blank>too<S2SV_blank>wide<S2SV_blank>to<S2SV_blank>encode\" ) ) ; OP_REQUIRES ( context , channels >= 1 && channels <= 4 , errors : : InvalidArgument ( \"image<S2SV_blank>must<S2SV_blank>have<S2SV_blank>1,<S2SV_blank>2,<S2SV_blank>3,<S2SV_blank>or<S2SV_blank>4<S2SV_blank>channels,<S2SV_blank>got<S2SV_blank>\" , channels ) ) ; Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { } ) , & output ) ) ; if ( desired_channel_bits_ == 8 ) { OP_REQUIRES ( context , png : : WriteImageToBuffer ( image . flat < uint8 > ( ) . data ( ) , width , height , width * channels , channels , desired_channel_bits_ , compression_ , & output -> scalar < tstring > ( ) ( ) , nullptr ) , errors : : Internal ( \"PNG<S2SV_blank>encoding<S2SV_blank>failed\" ) ) ; } else { OP_REQUIRES ( context , png : : WriteImageToBuffer ( image . flat < uint16 > ( ) . data ( ) , width , height , width * channels * 2 , channels , desired_channel_bits_ , compression_ , & output -> scalar < tstring > ( ) ( ) , nullptr ) , errors : : Internal ( \"PNG<S2SV_blank>encoding<S2SV_blank>failed\" ) ) ; } }", "target": "<S2SV_ModStart> DebugString ( ) ) ) ; OP_REQUIRES ( context , image . NumElements ( ) > 0 , errors : : Internal ( \"Invalid<S2SV_blank>image<S2SV_blank>provided.\""}
{"source": "CWE-703 scanner_scan_all ( parser_context_t * context_p , const uint8_t * arg_list_p , const uint8_t * arg_list_end_p , const uint8_t * source_p , const uint8_t * source_end_p ) { scanner_context_t scanner_context ; # if ENABLED ( JERRY_PARSER_DUMP_BYTE_CODE ) if ( context_p -> is_show_opcodes ) { JERRY_DEBUG_MSG ( \"\\\\n---<S2SV_blank>Scanning<S2SV_blank>start<S2SV_blank>---\\\\n\\\\n\" ) ; } # endif scanner_context . context_status_flags = context_p -> status_flags ; scanner_context . status_flags = SCANNER_CONTEXT_NO_FLAGS ; # if ENABLED ( JERRY_DEBUGGER ) if ( JERRY_CONTEXT ( debugger_flags ) & JERRY_DEBUGGER_CONNECTED ) { scanner_context . status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED ; } # endif # if ENABLED ( JERRY_ES2015 ) scanner_context . binding_type = SCANNER_BINDING_NONE ; scanner_context . active_binding_list_p = NULL ; # endif scanner_context . active_literal_pool_p = NULL ; scanner_context . active_switch_statement . last_case_p = NULL ; scanner_context . end_arguments_p = NULL ; # if ENABLED ( JERRY_ES2015 ) scanner_context . async_source_p = NULL ; # endif context_p -> u . scanner_context_p = & scanner_context ; parser_stack_init ( context_p ) ; PARSER_TRY ( context_p -> try_buffer ) { context_p -> line = 1 ; context_p -> column = 1 ; if ( arg_list_p == NULL ) { context_p -> source_p = source_p ; context_p -> source_end_p = source_end_p ; uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL ; if ( context_p -> status_flags & PARSER_IS_STRICT ) { status_flags |= SCANNER_LITERAL_POOL_IS_STRICT ; } scanner_literal_pool_t * literal_pool_p = scanner_push_literal_pool ( context_p , & scanner_context , status_flags ) ; literal_pool_p -> source_p = source_p ; parser_stack_push_uint8 ( context_p , SCAN_STACK_SCRIPT ) ; lexer_next_token ( context_p ) ; scanner_check_directives ( context_p , & scanner_context ) ; } else { context_p -> source_p = arg_list_p ; context_p -> source_end_p = arg_list_end_p ; uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION ; if ( context_p -> status_flags & PARSER_IS_STRICT ) { status_flags |= SCANNER_LITERAL_POOL_IS_STRICT ; } # if ENABLED ( JERRY_ES2015 ) if ( context_p -> status_flags & PARSER_IS_GENERATOR_FUNCTION ) { status_flags |= SCANNER_LITERAL_POOL_GENERATOR ; } # endif scanner_push_literal_pool ( context_p , & scanner_context , status_flags ) ; scanner_context . mode = SCAN_MODE_FUNCTION_ARGUMENTS ; parser_stack_push_uint8 ( context_p , SCAN_STACK_SCRIPT_FUNCTION ) ; context_p -> token . type = LEXER_LEFT_PAREN ; } while ( true ) { lexer_token_type_t type = ( lexer_token_type_t ) context_p -> token . type ; scan_stack_modes_t stack_top = ( scan_stack_modes_t ) context_p -> stack_top_uint8 ; switch ( scanner_context . mode ) { case SCAN_MODE_PRIMARY_EXPRESSION : { if ( type == LEXER_ADD || type == LEXER_SUBTRACT || LEXER_IS_UNARY_OP_TOKEN ( type ) ) { break ; } } case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW : { if ( scanner_scan_primary_expression ( context_p , & scanner_context , type , stack_top ) != SCAN_NEXT_TOKEN ) { continue ; } break ; } # if ENABLED ( JERRY_ES2015 ) case SCAN_MODE_CLASS_DECLARATION : { if ( context_p -> token . type == LEXER_KEYW_EXTENDS ) { parser_stack_push_uint8 ( context_p , SCAN_STACK_CLASS_EXTENDS ) ; scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; break ; } else if ( context_p -> token . type != LEXER_LEFT_BRACE ) { scanner_raise_error ( context_p ) ; } scanner_context . mode = SCAN_MODE_CLASS_METHOD ; } case SCAN_MODE_CLASS_METHOD : { JERRY_ASSERT ( stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR ) ; lexer_skip_empty_statements ( context_p ) ; lexer_scan_identifier ( context_p ) ; if ( context_p -> token . type == LEXER_RIGHT_BRACE ) { scanner_source_start_t source_start ; parser_stack_pop_uint8 ( context_p ) ; if ( stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR ) { parser_stack_pop ( context_p , & source_start , sizeof ( scanner_source_start_t ) ) ; } stack_top = context_p -> stack_top_uint8 ; JERRY_ASSERT ( stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION ) ; if ( stack_top == SCAN_STACK_CLASS_STATEMENT ) { scanner_context . mode = SCAN_MODE_STATEMENT_END ; continue ; } scanner_context . mode = SCAN_MODE_POST_PRIMARY_EXPRESSION ; parser_stack_pop_uint8 ( context_p ) ; break ; } if ( context_p -> token . type == LEXER_LITERAL && LEXER_IS_IDENT_OR_STRING ( context_p -> token . lit_location . type ) && lexer_compare_literal_to_string ( context_p , \"constructor\" , 11 ) ) { if ( stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR ) { scanner_source_start_t source_start ; parser_stack_pop_uint8 ( context_p ) ; parser_stack_pop ( context_p , & source_start , sizeof ( scanner_source_start_t ) ) ; scanner_info_t * info_p = scanner_insert_info ( context_p , source_start . source_p , sizeof ( scanner_info_t ) ) ; info_p -> type = SCANNER_TYPE_CLASS_CONSTRUCTOR ; parser_stack_push_uint8 ( context_p , SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR ) ; } } if ( lexer_token_is_identifier ( context_p , \"static\" , 6 ) ) { lexer_scan_identifier ( context_p ) ; } parser_stack_push_uint8 ( context_p , SCAN_STACK_FUNCTION_PROPERTY ) ; scanner_context . mode = SCAN_MODE_FUNCTION_ARGUMENTS ; uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION ; if ( lexer_token_is_identifier ( context_p , \"get\" , 3 ) || lexer_token_is_identifier ( context_p , \"set\" , 3 ) ) { lexer_scan_identifier ( context_p ) ; if ( context_p -> token . type == LEXER_LEFT_PAREN ) { scanner_push_literal_pool ( context_p , & scanner_context , SCANNER_LITERAL_POOL_FUNCTION ) ; continue ; } } else if ( lexer_token_is_identifier ( context_p , \"async\" , 5 ) ) { lexer_scan_identifier ( context_p ) ; if ( context_p -> token . type == LEXER_LEFT_PAREN ) { scanner_push_literal_pool ( context_p , & scanner_context , SCANNER_LITERAL_POOL_FUNCTION ) ; continue ; } literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC ; if ( context_p -> token . type == LEXER_MULTIPLY ) { lexer_scan_identifier ( context_p ) ; literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR ; } } else if ( context_p -> token . type == LEXER_MULTIPLY ) { lexer_scan_identifier ( context_p ) ; literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR ; } if ( context_p -> token . type == LEXER_LEFT_SQUARE ) { parser_stack_push_uint8 ( context_p , SCANNER_FROM_LITERAL_POOL_TO_COMPUTED ( literal_pool_flags ) ) ; scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; break ; } if ( context_p -> token . type != LEXER_LITERAL ) { scanner_raise_error ( context_p ) ; } if ( literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR ) { context_p -> status_flags |= PARSER_IS_GENERATOR_FUNCTION ; } scanner_push_literal_pool ( context_p , & scanner_context , literal_pool_flags ) ; lexer_next_token ( context_p ) ; continue ; } # endif case SCAN_MODE_POST_PRIMARY_EXPRESSION : { if ( scanner_scan_post_primary_expression ( context_p , & scanner_context , type , stack_top ) ) { break ; } type = ( lexer_token_type_t ) context_p -> token . type ; } case SCAN_MODE_PRIMARY_EXPRESSION_END : { if ( scanner_scan_primary_expression_end ( context_p , & scanner_context , type , stack_top ) != SCAN_NEXT_TOKEN ) { continue ; } break ; } case SCAN_MODE_STATEMENT_OR_TERMINATOR : { if ( type == LEXER_RIGHT_BRACE || type == LEXER_EOS ) { scanner_context . mode = SCAN_MODE_STATEMENT_END ; continue ; } } case SCAN_MODE_STATEMENT : { if ( scanner_scan_statement ( context_p , & scanner_context , type , stack_top ) != SCAN_NEXT_TOKEN ) { continue ; } break ; } case SCAN_MODE_STATEMENT_END : { if ( scanner_scan_statement_end ( context_p , & scanner_context , type ) != SCAN_NEXT_TOKEN ) { continue ; } if ( context_p -> token . type == LEXER_EOS ) { goto scan_completed ; } break ; } case SCAN_MODE_VAR_STATEMENT : { # if ENABLED ( JERRY_ES2015 ) if ( type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE ) { uint8_t binding_type = SCANNER_BINDING_VAR ; if ( stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START ) { binding_type = SCANNER_BINDING_LET ; } else if ( stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START ) { binding_type = SCANNER_BINDING_CONST ; } scanner_push_destructuring_pattern ( context_p , & scanner_context , binding_type , false ) ; if ( type == LEXER_LEFT_SQUARE ) { parser_stack_push_uint8 ( context_p , SCAN_STACK_ARRAY_LITERAL ) ; scanner_context . mode = SCAN_MODE_BINDING ; break ; } parser_stack_push_uint8 ( context_p , SCAN_STACK_OBJECT_LITERAL ) ; scanner_context . mode = SCAN_MODE_PROPERTY_NAME ; continue ; } # endif if ( type != LEXER_LITERAL || context_p -> token . lit_location . type != LEXER_IDENT_LITERAL ) { scanner_raise_error ( context_p ) ; } lexer_lit_location_t * literal_p = scanner_add_literal ( context_p , & scanner_context ) ; # if ENABLED ( JERRY_ES2015 ) if ( stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START ) { scanner_detect_invalid_let ( context_p , literal_p ) ; if ( stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START ) { literal_p -> type |= SCANNER_LITERAL_IS_LET ; } else { JERRY_ASSERT ( stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START ) ; literal_p -> type |= SCANNER_LITERAL_IS_CONST ; } lexer_next_token ( context_p ) ; if ( literal_p -> type & SCANNER_LITERAL_IS_USED ) { literal_p -> type |= SCANNER_LITERAL_EARLY_CREATE ; } else if ( context_p -> token . type == LEXER_ASSIGN ) { scanner_binding_literal_t binding_literal ; binding_literal . literal_p = literal_p ; parser_stack_push ( context_p , & binding_literal , sizeof ( scanner_binding_literal_t ) ) ; parser_stack_push_uint8 ( context_p , SCAN_STACK_BINDING_INIT ) ; } } else { if ( ! ( literal_p -> type & SCANNER_LITERAL_IS_VAR ) ) { scanner_detect_invalid_var ( context_p , & scanner_context , literal_p ) ; literal_p -> type |= SCANNER_LITERAL_IS_VAR ; if ( scanner_context . active_literal_pool_p -> status_flags & SCANNER_LITERAL_POOL_IN_WITH ) { literal_p -> type |= SCANNER_LITERAL_NO_REG ; } } lexer_next_token ( context_p ) ; } # else literal_p -> type |= SCANNER_LITERAL_IS_VAR ; if ( scanner_context . active_literal_pool_p -> status_flags & SCANNER_LITERAL_POOL_IN_WITH ) { literal_p -> type |= SCANNER_LITERAL_NO_REG ; } lexer_next_token ( context_p ) ; # endif # if ENABLED ( JERRY_ES2015_MODULE_SYSTEM ) if ( scanner_context . active_literal_pool_p -> status_flags & SCANNER_LITERAL_POOL_IN_EXPORT ) { literal_p -> type |= SCANNER_LITERAL_NO_REG ; } # endif switch ( context_p -> token . type ) { case LEXER_ASSIGN : { scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; } case LEXER_COMMA : { lexer_next_token ( context_p ) ; continue ; } } if ( SCANNER_IS_FOR_START ( stack_top ) ) { # if ENABLED ( JERRY_ES2015_MODULE_SYSTEM ) JERRY_ASSERT ( ! ( scanner_context . active_literal_pool_p -> status_flags & SCANNER_LITERAL_POOL_IN_EXPORT ) ) ; # endif if ( context_p -> token . type != LEXER_SEMICOLON && context_p -> token . type != LEXER_KEYW_IN && ! SCANNER_IDENTIFIER_IS_OF ( ) ) { scanner_raise_error ( context_p ) ; } scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION_END ; continue ; } # if ENABLED ( JERRY_ES2015 ) JERRY_ASSERT ( stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST ) ; # else JERRY_ASSERT ( stack_top == SCAN_STACK_VAR ) ; # endif # if ENABLED ( JERRY_ES2015_MODULE_SYSTEM ) scanner_context . active_literal_pool_p -> status_flags &= ( uint16_t ) ~ SCANNER_LITERAL_POOL_IN_EXPORT ; # endif scanner_context . mode = SCAN_MODE_STATEMENT_END ; parser_stack_pop_uint8 ( context_p ) ; continue ; } case SCAN_MODE_FUNCTION_ARGUMENTS : { JERRY_ASSERT ( stack_top == SCAN_STACK_SCRIPT_FUNCTION || stack_top == SCAN_STACK_FUNCTION_STATEMENT || stack_top == SCAN_STACK_FUNCTION_EXPRESSION || stack_top == SCAN_STACK_FUNCTION_PROPERTY ) ; scanner_literal_pool_t * literal_pool_p = scanner_context . active_literal_pool_p ; JERRY_ASSERT ( literal_pool_p != NULL && ( literal_pool_p -> status_flags & SCANNER_LITERAL_POOL_FUNCTION ) ) ; literal_pool_p -> source_p = context_p -> source_p ; # if ENABLED ( JERRY_ES2015 ) if ( JERRY_UNLIKELY ( scanner_context . async_source_p != NULL ) ) { literal_pool_p -> status_flags |= SCANNER_LITERAL_POOL_ASYNC ; literal_pool_p -> source_p = scanner_context . async_source_p ; scanner_context . async_source_p = NULL ; } # endif if ( type != LEXER_LEFT_PAREN ) { scanner_raise_error ( context_p ) ; } lexer_next_token ( context_p ) ; # if ENABLED ( JERRY_ES2015 ) } case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS : { # endif if ( context_p -> token . type != LEXER_RIGHT_PAREN && context_p -> token . type != LEXER_EOS ) { # if ENABLED ( JERRY_ES2015 ) lexer_lit_location_t * argument_literal_p ; # endif while ( true ) { # if ENABLED ( JERRY_ES2015 ) if ( context_p -> token . type == LEXER_THREE_DOTS ) { scanner_context . active_literal_pool_p -> status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED ; lexer_next_token ( context_p ) ; } if ( context_p -> token . type == LEXER_LEFT_SQUARE || context_p -> token . type == LEXER_LEFT_BRACE ) { argument_literal_p = NULL ; break ; } # endif if ( context_p -> token . type != LEXER_LITERAL || context_p -> token . lit_location . type != LEXER_IDENT_LITERAL ) { scanner_raise_error ( context_p ) ; } # if ENABLED ( JERRY_ES2015 ) argument_literal_p = scanner_append_argument ( context_p , & scanner_context ) ; # else scanner_append_argument ( context_p , & scanner_context ) ; # endif lexer_next_token ( context_p ) ; if ( context_p -> token . type != LEXER_COMMA ) { break ; } lexer_next_token ( context_p ) ; } # if ENABLED ( JERRY_ES2015 ) if ( argument_literal_p == NULL ) { scanner_context . active_literal_pool_p -> status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED ; parser_stack_push_uint8 ( context_p , SCAN_STACK_FUNCTION_PARAMETERS ) ; scanner_append_hole ( context_p , & scanner_context ) ; scanner_push_destructuring_pattern ( context_p , & scanner_context , SCANNER_BINDING_ARG , false ) ; if ( context_p -> token . type == LEXER_LEFT_SQUARE ) { parser_stack_push_uint8 ( context_p , SCAN_STACK_ARRAY_LITERAL ) ; scanner_context . mode = SCAN_MODE_BINDING ; break ; } parser_stack_push_uint8 ( context_p , SCAN_STACK_OBJECT_LITERAL ) ; scanner_context . mode = SCAN_MODE_PROPERTY_NAME ; continue ; } if ( context_p -> token . type == LEXER_ASSIGN ) { scanner_context . active_literal_pool_p -> status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED ; parser_stack_push_uint8 ( context_p , SCAN_STACK_FUNCTION_PARAMETERS ) ; scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; if ( argument_literal_p -> type & SCANNER_LITERAL_IS_USED ) { JERRY_ASSERT ( argument_literal_p -> type & SCANNER_LITERAL_EARLY_CREATE ) ; break ; } scanner_binding_literal_t binding_literal ; binding_literal . literal_p = argument_literal_p ; parser_stack_push ( context_p , & binding_literal , sizeof ( scanner_binding_literal_t ) ) ; parser_stack_push_uint8 ( context_p , SCAN_STACK_BINDING_INIT ) ; break ; } # endif } if ( context_p -> token . type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION ) { scanner_info_t * scanner_info_p = ( scanner_info_t * ) scanner_malloc ( context_p , sizeof ( scanner_info_t ) ) ; scanner_info_p -> next_p = context_p -> next_scanner_info_p ; scanner_info_p -> source_p = NULL ; scanner_info_p -> type = SCANNER_TYPE_END_ARGUMENTS ; scanner_context . end_arguments_p = scanner_info_p ; context_p -> next_scanner_info_p = scanner_info_p ; context_p -> source_p = source_p ; context_p -> source_end_p = source_end_p ; context_p -> line = 1 ; context_p -> column = 1 ; scanner_filter_arguments ( context_p , & scanner_context ) ; lexer_next_token ( context_p ) ; scanner_check_directives ( context_p , & scanner_context ) ; continue ; } if ( context_p -> token . type != LEXER_RIGHT_PAREN ) { scanner_raise_error ( context_p ) ; } lexer_next_token ( context_p ) ; if ( context_p -> token . type != LEXER_LEFT_BRACE ) { scanner_raise_error ( context_p ) ; } scanner_filter_arguments ( context_p , & scanner_context ) ; lexer_next_token ( context_p ) ; scanner_check_directives ( context_p , & scanner_context ) ; continue ; } case SCAN_MODE_PROPERTY_NAME : { JERRY_ASSERT ( stack_top == SCAN_STACK_OBJECT_LITERAL ) ; if ( lexer_scan_identifier ( context_p ) ) { lexer_check_property_modifier ( context_p ) ; } # if ENABLED ( JERRY_ES2015 ) if ( context_p -> token . type == LEXER_LEFT_SQUARE ) { parser_stack_push_uint8 ( context_p , SCAN_STACK_COMPUTED_PROPERTY ) ; scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; break ; } # endif if ( context_p -> token . type == LEXER_RIGHT_BRACE ) { scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION_END ; continue ; } if ( context_p -> token . type == LEXER_PROPERTY_GETTER # if ENABLED ( JERRY_ES2015 ) || context_p -> token . type == LEXER_KEYW_ASYNC || context_p -> token . type == LEXER_MULTIPLY # endif || context_p -> token . type == LEXER_PROPERTY_SETTER ) { uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION ; # if ENABLED ( JERRY_ES2015 ) if ( context_p -> token . type == LEXER_MULTIPLY ) { literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR ; } else if ( context_p -> token . type == LEXER_KEYW_ASYNC ) { literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC ; if ( lexer_consume_generator ( context_p ) ) { literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR ; } } # endif parser_stack_push_uint8 ( context_p , SCAN_STACK_FUNCTION_PROPERTY ) ; lexer_scan_identifier ( context_p ) ; # if ENABLED ( JERRY_ES2015 ) if ( context_p -> token . type == LEXER_LEFT_SQUARE ) { parser_stack_push_uint8 ( context_p , SCANNER_FROM_LITERAL_POOL_TO_COMPUTED ( literal_pool_flags ) ) ; scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; break ; } # endif if ( context_p -> token . type != LEXER_LITERAL ) { scanner_raise_error ( context_p ) ; } scanner_push_literal_pool ( context_p , & scanner_context , literal_pool_flags ) ; scanner_context . mode = SCAN_MODE_FUNCTION_ARGUMENTS ; break ; } if ( context_p -> token . type != LEXER_LITERAL ) { scanner_raise_error ( context_p ) ; } # if ENABLED ( JERRY_ES2015 ) parser_line_counter_t start_line = context_p -> token . line ; parser_line_counter_t start_column = context_p -> token . column ; bool is_ident = ( context_p -> token . lit_location . type == LEXER_IDENT_LITERAL ) ; # endif lexer_next_token ( context_p ) ; # if ENABLED ( JERRY_ES2015 ) if ( context_p -> token . type == LEXER_LEFT_PAREN ) { scanner_push_literal_pool ( context_p , & scanner_context , SCANNER_LITERAL_POOL_FUNCTION ) ; parser_stack_push_uint8 ( context_p , SCAN_STACK_FUNCTION_PROPERTY ) ; scanner_context . mode = SCAN_MODE_FUNCTION_ARGUMENTS ; continue ; } if ( is_ident && ( context_p -> token . type == LEXER_COMMA || context_p -> token . type == LEXER_RIGHT_BRACE || context_p -> token . type == LEXER_ASSIGN ) ) { context_p -> source_p = context_p -> token . lit_location . char_p ; context_p -> line = start_line ; context_p -> column = start_column ; lexer_next_token ( context_p ) ; JERRY_ASSERT ( context_p -> token . type != LEXER_LITERAL || context_p -> token . lit_location . type == LEXER_IDENT_LITERAL ) ; if ( context_p -> token . type != LEXER_LITERAL ) { scanner_raise_error ( context_p ) ; } if ( scanner_context . binding_type != SCANNER_BINDING_NONE ) { scanner_context . mode = SCAN_MODE_BINDING ; continue ; } scanner_add_reference ( context_p , & scanner_context ) ; lexer_next_token ( context_p ) ; if ( context_p -> token . type == LEXER_ASSIGN ) { scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; break ; } scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION_END ; continue ; } # endif if ( context_p -> token . type != LEXER_COLON ) { scanner_raise_error ( context_p ) ; } scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; # if ENABLED ( JERRY_ES2015 ) if ( scanner_context . binding_type != SCANNER_BINDING_NONE ) { scanner_context . mode = SCAN_MODE_BINDING ; } # endif break ; } # if ENABLED ( JERRY_ES2015 ) case SCAN_MODE_BINDING : { JERRY_ASSERT ( scanner_context . binding_type == SCANNER_BINDING_VAR || scanner_context . binding_type == SCANNER_BINDING_LET || scanner_context . binding_type == SCANNER_BINDING_CATCH || scanner_context . binding_type == SCANNER_BINDING_CONST || scanner_context . binding_type == SCANNER_BINDING_ARG || scanner_context . binding_type == SCANNER_BINDING_ARROW_ARG ) ; if ( type == LEXER_THREE_DOTS ) { lexer_next_token ( context_p ) ; type = ( lexer_token_type_t ) context_p -> token . type ; } if ( type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE ) { scanner_push_destructuring_pattern ( context_p , & scanner_context , scanner_context . binding_type , true ) ; if ( type == LEXER_LEFT_SQUARE ) { parser_stack_push_uint8 ( context_p , SCAN_STACK_ARRAY_LITERAL ) ; break ; } parser_stack_push_uint8 ( context_p , SCAN_STACK_OBJECT_LITERAL ) ; scanner_context . mode = SCAN_MODE_PROPERTY_NAME ; continue ; } if ( type != LEXER_LITERAL || context_p -> token . lit_location . type != LEXER_IDENT_LITERAL ) { scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; continue ; } lexer_lit_location_t * literal_p = scanner_add_literal ( context_p , & scanner_context ) ; scanner_context . mode = SCAN_MODE_POST_PRIMARY_EXPRESSION ; if ( scanner_context . binding_type == SCANNER_BINDING_VAR ) { if ( ! ( literal_p -> type & SCANNER_LITERAL_IS_VAR ) ) { scanner_detect_invalid_var ( context_p , & scanner_context , literal_p ) ; literal_p -> type |= SCANNER_LITERAL_IS_VAR ; if ( scanner_context . active_literal_pool_p -> status_flags & SCANNER_LITERAL_POOL_IN_WITH ) { literal_p -> type |= SCANNER_LITERAL_NO_REG ; } } break ; } if ( scanner_context . binding_type == SCANNER_BINDING_ARROW_ARG ) { literal_p -> type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG ; if ( literal_p -> type & SCANNER_LITERAL_IS_USED ) { literal_p -> type |= SCANNER_LITERAL_EARLY_CREATE ; break ; } } else { scanner_detect_invalid_let ( context_p , literal_p ) ; if ( scanner_context . binding_type <= SCANNER_BINDING_CATCH ) { JERRY_ASSERT ( ( scanner_context . binding_type == SCANNER_BINDING_LET ) || ( scanner_context . binding_type == SCANNER_BINDING_CATCH ) ) ; literal_p -> type |= SCANNER_LITERAL_IS_LET ; } else { literal_p -> type |= SCANNER_LITERAL_IS_CONST ; if ( scanner_context . binding_type == SCANNER_BINDING_ARG ) { literal_p -> type |= SCANNER_LITERAL_IS_ARG ; if ( literal_p -> type & SCANNER_LITERAL_IS_USED ) { literal_p -> type |= SCANNER_LITERAL_EARLY_CREATE ; break ; } } } if ( literal_p -> type & SCANNER_LITERAL_IS_USED ) { literal_p -> type |= SCANNER_LITERAL_EARLY_CREATE ; break ; } } scanner_binding_item_t * binding_item_p ; binding_item_p = ( scanner_binding_item_t * ) scanner_malloc ( context_p , sizeof ( scanner_binding_item_t ) ) ; binding_item_p -> next_p = scanner_context . active_binding_list_p -> items_p ; binding_item_p -> literal_p = literal_p ; scanner_context . active_binding_list_p -> items_p = binding_item_p ; lexer_next_token ( context_p ) ; if ( context_p -> token . type != LEXER_ASSIGN ) { continue ; } scanner_binding_literal_t binding_literal ; binding_literal . literal_p = literal_p ; parser_stack_push ( context_p , & binding_literal , sizeof ( scanner_binding_literal_t ) ) ; parser_stack_push_uint8 ( context_p , SCAN_STACK_BINDING_INIT ) ; scanner_context . mode = SCAN_MODE_PRIMARY_EXPRESSION ; break ; } # endif } lexer_next_token ( context_p ) ; } scan_completed : if ( context_p -> stack_top_uint8 != SCAN_STACK_SCRIPT && context_p -> stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION ) { scanner_raise_error ( context_p ) ; } scanner_pop_literal_pool ( context_p , & scanner_context ) ; # if ENABLED ( JERRY_ES2015 ) JERRY_ASSERT ( scanner_context . active_binding_list_p == NULL ) ; # endif JERRY_ASSERT ( scanner_context . active_literal_pool_p == NULL ) ; # ifndef JERRY_NDEBUG scanner_context . context_status_flags |= PARSER_SCANNING_SUCCESSFUL ; # endif } PARSER_CATCH { <S2SV_StartBug> if ( context_p -> error != PARSER_ERR_OUT_OF_MEMORY ) <S2SV_EndBug> { context_p -> error = PARSER_ERR_NO_ERROR ; <S2SV_StartBug> } <S2SV_EndBug> # if ENABLED ( JERRY_ES2015 ) while ( scanner_context . active_binding_list_p != NULL ) { scanner_pop_binding_list ( & scanner_context ) ; } # endif PARSER_TRY ( context_p -> try_buffer ) { # if ENABLED ( JERRY_ES2015 ) if ( scanner_context . status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION ) { JERRY_ASSERT ( scanner_context . async_source_p != NULL ) ; scanner_info_t * info_p ; info_p = scanner_insert_info ( context_p , scanner_context . async_source_p , sizeof ( scanner_info_t ) ) ; info_p -> type = SCANNER_TYPE_ERR_ASYNC_FUNCTION ; } # endif while ( scanner_context . active_literal_pool_p != NULL ) { scanner_pop_literal_pool ( context_p , & scanner_context ) ; } } PARSER_CATCH { <S2SV_StartBug> JERRY_ASSERT ( context_p -> error == PARSER_ERR_NO_ERROR ) ; <S2SV_EndBug> while ( scanner_context . active_literal_pool_p != NULL ) { scanner_literal_pool_t * literal_pool_p = scanner_context . active_literal_pool_p ; scanner_context . active_literal_pool_p = literal_pool_p -> prev_p ; parser_list_free ( & literal_pool_p -> literal_pool ) ; scanner_free ( literal_pool_p , sizeof ( scanner_literal_pool_t ) ) ; } <S2SV_StartBug> } <S2SV_EndBug> PARSER_TRY_END # if ENABLED ( JERRY_ES2015 ) context_p -> status_flags &= ( uint32_t ) ~ PARSER_IS_GENERATOR_FUNCTION ; # endif } PARSER_TRY_END context_p -> status_flags = scanner_context . context_status_flags ; scanner_reverse_info_list ( context_p ) ; # if ENABLED ( JERRY_PARSER_DUMP_BYTE_CODE ) if ( context_p -> is_show_opcodes ) { scanner_info_t * info_p = context_p -> next_scanner_info_p ; const uint8_t * source_start_p = ( arg_list_p == NULL ) ? source_p : arg_list_p ; while ( info_p -> type != SCANNER_TYPE_END ) { const char * name_p = NULL ; bool print_location = false ; switch ( info_p -> type ) { case SCANNER_TYPE_END_ARGUMENTS : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>END_ARGUMENTS\\\\n\" ) ; source_start_p = source_p ; break ; } case SCANNER_TYPE_FUNCTION : case SCANNER_TYPE_BLOCK : { const uint8_t * prev_source_p = info_p -> source_p - 1 ; const uint8_t * data_p ; if ( info_p -> type == SCANNER_TYPE_FUNCTION ) { data_p = ( const uint8_t * ) ( info_p + 1 ) ; JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>FUNCTION:<S2SV_blank>flags:<S2SV_blank>0x%x<S2SV_blank>declarations:<S2SV_blank>%d\" , ( int ) info_p -> u8_arg , ( int ) info_p -> u16_arg ) ; } else { data_p = ( const uint8_t * ) ( info_p + 1 ) ; JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>BLOCK:\" ) ; } JERRY_DEBUG_MSG ( \"<S2SV_blank>source:%d\\\\n\" , ( int ) ( info_p -> source_p - source_start_p ) ) ; while ( data_p [ 0 ] != SCANNER_STREAM_TYPE_END ) { switch ( data_p [ 0 ] & SCANNER_STREAM_TYPE_MASK ) { case SCANNER_STREAM_TYPE_VAR : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>VAR<S2SV_blank>\" ) ; break ; } # if ENABLED ( JERRY_ES2015 ) case SCANNER_STREAM_TYPE_LET : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>LET<S2SV_blank>\" ) ; break ; } case SCANNER_STREAM_TYPE_CONST : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CONST<S2SV_blank>\" ) ; break ; } case SCANNER_STREAM_TYPE_LOCAL : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>LOCAL<S2SV_blank>\" ) ; break ; } # endif # if ENABLED ( JERRY_ES2015_MODULE_SYSTEM ) case SCANNER_STREAM_TYPE_IMPORT : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IMPORT<S2SV_blank>\" ) ; break ; } # endif case SCANNER_STREAM_TYPE_ARG : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ARG<S2SV_blank>\" ) ; break ; } # if ENABLED ( JERRY_ES2015 ) case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>DESTRUCTURED_ARG<S2SV_blank>\" ) ; break ; } # endif case SCANNER_STREAM_TYPE_ARG_FUNC : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ARG_FUNC<S2SV_blank>\" ) ; break ; } # if ENABLED ( JERRY_ES2015 ) case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>DESTRUCTURED_ARG_FUNC<S2SV_blank>\" ) ; break ; } # endif case SCANNER_STREAM_TYPE_FUNC : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>FUNC<S2SV_blank>\" ) ; break ; } default : { JERRY_ASSERT ( ( data_p [ 0 ] & SCANNER_STREAM_TYPE_MASK ) == SCANNER_STREAM_TYPE_HOLE ) ; JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>HOLE\\\\n\" ) ; data_p ++ ; continue ; } } size_t length ; if ( ! ( data_p [ 0 ] & SCANNER_STREAM_UINT16_DIFF ) ) { if ( data_p [ 2 ] != 0 ) { prev_source_p += data_p [ 2 ] ; length = 2 + 1 ; } else { memcpy ( & prev_source_p , data_p + 2 + 1 , sizeof ( const uint8_t * ) ) ; length = 2 + 1 + sizeof ( const uint8_t * ) ; } } else { int32_t diff = ( ( int32_t ) data_p [ 2 ] ) | ( ( int32_t ) data_p [ 3 ] ) << 8 ; if ( diff <= UINT8_MAX ) { diff = - diff ; } prev_source_p += diff ; length = 2 + 2 ; } # if ENABLED ( JERRY_ES2015 ) if ( data_p [ 0 ] & SCANNER_STREAM_EARLY_CREATE ) { JERRY_ASSERT ( data_p [ 0 ] & SCANNER_STREAM_NO_REG ) ; JERRY_DEBUG_MSG ( \"*\" ) ; } # endif if ( data_p [ 0 ] & SCANNER_STREAM_NO_REG ) { JERRY_DEBUG_MSG ( \"*<S2SV_blank>\" ) ; } JERRY_DEBUG_MSG ( \"\\'%.*s\\'\\\\n\" , data_p [ 1 ] , ( char * ) prev_source_p ) ; prev_source_p += data_p [ 1 ] ; data_p += length ; } break ; } case SCANNER_TYPE_WHILE : { name_p = \"WHILE\" ; print_location = true ; break ; } case SCANNER_TYPE_FOR : { scanner_for_info_t * for_info_p = ( scanner_for_info_t * ) info_p ; JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>FOR:<S2SV_blank>source:%d<S2SV_blank>expression:%d[%d:%d]<S2SV_blank>end:%d[%d:%d]\\\\n\" , ( int ) ( for_info_p -> info . source_p - source_start_p ) , ( int ) ( for_info_p -> expression_location . source_p - source_start_p ) , ( int ) for_info_p -> expression_location . line , ( int ) for_info_p -> expression_location . column , ( int ) ( for_info_p -> end_location . source_p - source_start_p ) , ( int ) for_info_p -> end_location . line , ( int ) for_info_p -> end_location . column ) ; break ; } case SCANNER_TYPE_FOR_IN : { name_p = \"FOR-IN\" ; print_location = true ; break ; } # if ENABLED ( JERRY_ES2015 ) case SCANNER_TYPE_FOR_OF : { name_p = \"FOR-OF\" ; print_location = true ; break ; } # endif case SCANNER_TYPE_SWITCH : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>SWITCH:<S2SV_blank>source:%d\\\\n\" , ( int ) ( info_p -> source_p - source_start_p ) ) ; scanner_case_info_t * current_case_p = ( ( scanner_switch_info_t * ) info_p ) -> case_p ; while ( current_case_p != NULL ) { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CASE:<S2SV_blank>location:%d[%d:%d]\\\\n\" , ( int ) ( current_case_p -> location . source_p - source_start_p ) , ( int ) current_case_p -> location . line , ( int ) current_case_p -> location . column ) ; current_case_p = current_case_p -> next_p ; } break ; } case SCANNER_TYPE_CASE : { name_p = \"CASE\" ; print_location = true ; break ; } # if ENABLED ( JERRY_ES2015 ) case SCANNER_TYPE_INITIALIZER : { name_p = \"INITIALIZER\" ; print_location = true ; break ; } case SCANNER_TYPE_CLASS_CONSTRUCTOR : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>CLASS-CONSTRUCTOR:<S2SV_blank>source:%d\\\\n\" , ( int ) ( info_p -> source_p - source_start_p ) ) ; print_location = false ; break ; } case SCANNER_TYPE_LET_EXPRESSION : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>LET_EXPRESSION:<S2SV_blank>source:%d\\\\n\" , ( int ) ( info_p -> source_p - source_start_p ) ) ; break ; } case SCANNER_TYPE_ERR_REDECLARED : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>ERR_REDECLARED:<S2SV_blank>source:%d\\\\n\" , ( int ) ( info_p -> source_p - source_start_p ) ) ; break ; } case SCANNER_TYPE_ERR_ASYNC_FUNCTION : { JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>ERR_ASYNC_FUNCTION:<S2SV_blank>source:%d\\\\n\" , ( int ) ( info_p -> source_p - source_start_p ) ) ; break ; } # endif } if ( print_location ) { scanner_location_info_t * location_info_p = ( scanner_location_info_t * ) info_p ; JERRY_DEBUG_MSG ( \"<S2SV_blank><S2SV_blank>%s:<S2SV_blank>source:%d<S2SV_blank>location:%d[%d:%d]\\\\n\" , name_p , ( int ) ( location_info_p -> info . source_p - source_start_p ) , ( int ) ( location_info_p -> location . source_p - source_start_p ) , ( int ) location_info_p -> location . line , ( int ) location_info_p -> location . column ) ; } info_p = info_p -> next_p ; } JERRY_DEBUG_MSG ( \"\\\\n---<S2SV_blank>Scanning<S2SV_blank>end<S2SV_blank>---\\\\n\\\\n\" ) ; } # endif parser_stack_free ( context_p ) ; }", "target": "<S2SV_ModStart> } PARSER_CATCH { # if ENABLED ( JERRY_ES2015 ) while ( scanner_context . active_binding_list_p != NULL ) { scanner_pop_binding_list ( & scanner_context ) ; } # endif if ( JERRY_UNLIKELY <S2SV_ModEnd> ( context_p -> <S2SV_ModStart> != PARSER_ERR_OUT_OF_MEMORY ) ) <S2SV_ModStart> = PARSER_ERR_NO_ERROR ; <S2SV_ModEnd> PARSER_TRY ( context_p <S2SV_ModStart> -> error == PARSER_ERR_OUT_OF_MEMORY ) ; } PARSER_TRY_END } JERRY_ASSERT ( context_p -> error == PARSER_ERR_NO_ERROR || context_p -> error == PARSER_ERR_OUT_OF_MEMORY ) ; if ( context_p -> error == PARSER_ERR_OUT_OF_MEMORY ) { <S2SV_ModEnd> while ( scanner_context <S2SV_ModStart> ) ; } parser_stack_free ( context_p ) ; return ; } <S2SV_ModEnd> } PARSER_TRY_END context_p"}
{"source": "CWE-369 TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteSpaceToDepthParams * > ( node -> builtin_data ) ; TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor , & input ) ) ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( input ) , 4 ) ; auto data_type = output -> type ; TF_LITE_ENSURE ( context , data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 || data_type == kTfLiteInt8 || data_type == kTfLiteInt32 || data_type == kTfLiteInt64 ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input -> type , output -> type ) ; const int block_size = params -> block_size ; <S2SV_StartBug> const int input_height = input -> dims -> data [ 1 ] ; <S2SV_EndBug> const int input_width = input -> dims -> data [ 2 ] ; int output_height = input_height / block_size ; int output_width = input_width / block_size ; TF_LITE_ENSURE_EQ ( context , input_height , output_height * block_size ) ; TF_LITE_ENSURE_EQ ( context , input_width , output_width * block_size ) ; TfLiteIntArray * output_size = TfLiteIntArrayCreate ( 4 ) ; output_size -> data [ 0 ] = input -> dims -> data [ 0 ] ; output_size -> data [ 1 ] = output_height ; output_size -> data [ 2 ] = output_width ; output_size -> data [ 3 ] = input -> dims -> data [ 3 ] * block_size * block_size ; return context -> ResizeTensor ( context , output , output_size ) ; }", "target": "<S2SV_ModStart> -> block_size ; TF_LITE_ENSURE ( context , block_size > 0 ) ;"}
{"source": "CWE-476 void gf_isom_cenc_get_default_info_internal ( GF_TrackBox * trak , u32 sampleDescriptionIndex , u32 * container_type , Bool * default_IsEncrypted , u8 * crypt_byte_block , u8 * skip_byte_block , const u8 * * key_info , u32 * key_info_size ) { GF_ProtectionSchemeInfoBox * sinf ; if ( default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ; if ( crypt_byte_block ) * crypt_byte_block = 0 ; if ( skip_byte_block ) * skip_byte_block = 0 ; if ( container_type ) * container_type = 0 ; if ( key_info ) * key_info = NULL ; if ( key_info_size ) * key_info_size = 0 ; sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBCS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_PIFF_SCHEME , NULL ) ; if ( ! sinf ) { u32 i , nb_stsd = gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ; for ( i = 0 ; i < nb_stsd ; i ++ ) { GF_ProtectionSchemeInfoBox * a_sinf ; GF_SampleEntryBox * sentry = NULL ; if ( i + 1 == sampleDescriptionIndex ) continue ; sentry = gf_list_get ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes , i ) ; a_sinf = ( GF_ProtectionSchemeInfoBox * ) gf_isom_box_find_child ( sentry -> child_boxes , GF_ISOM_BOX_TYPE_SINF ) ; if ( ! a_sinf ) continue ; return ; } } if ( sinf && sinf -> info && sinf -> info -> tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = sinf -> info -> tenc -> isProtected ; if ( crypt_byte_block ) * crypt_byte_block = sinf -> info -> tenc -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = sinf -> info -> tenc -> skip_byte_block ; if ( key_info ) * key_info = sinf -> info -> tenc -> key_info ; if ( key_info_size ) { * key_info_size = 20 ; if ( ! sinf -> info -> tenc -> key_info [ 3 ] ) * key_info_size += 1 + sinf -> info -> tenc -> key_info [ 20 ] ; } if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else if ( sinf && sinf -> info && sinf -> info -> piff_tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( key_info ) * key_info = sinf -> info -> piff_tenc -> key_info ; if ( key_info_size ) * key_info_size = 19 ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } else { u32 i , count = 0 ; GF_CENCSampleEncryptionGroupEntry * seig_entry = NULL ; if ( ! trak -> moov -> mov -> is_smooth ) count = gf_list_count ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; for ( i = 0 ; i < count ; i ++ ) { GF_SampleGroupDescriptionBox * sgdesc = ( GF_SampleGroupDescriptionBox * ) gf_list_get ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription , i ) ; if ( sgdesc -> grouping_type != GF_ISOM_SAMPLE_GROUP_SEIG ) continue ; if ( sgdesc -> default_description_index ) seig_entry = gf_list_get ( sgdesc -> group_descriptions , sgdesc -> default_description_index - 1 ) ; else seig_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; <S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug> seig_entry = NULL ; break ; } if ( seig_entry ) { if ( default_IsEncrypted ) * default_IsEncrypted = seig_entry -> IsProtected ; if ( crypt_byte_block ) * crypt_byte_block = seig_entry -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = seig_entry -> skip_byte_block ; if ( key_info ) * key_info = seig_entry -> key_info ; if ( key_info_size ) * key_info_size = seig_entry -> key_info_size ; if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else { if ( ! trak -> moov -> mov -> is_smooth ) { trak -> moov -> mov -> is_smooth = GF_TRUE ; GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>senc<S2SV_blank>box<S2SV_blank>without<S2SV_blank>tenc,<S2SV_blank>assuming<S2SV_blank>MS<S2SV_blank>smooth+piff\\\\n\" ) ) ; } if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } } if ( container_type && trak -> sample_encryption ) { if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_SENC ) * container_type = GF_ISOM_BOX_TYPE_SENC ; else if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_UUID ) * container_type = ( ( GF_UUIDBox * ) trak -> sample_encryption ) -> internal_4cc ; } }", "target": "<S2SV_ModStart> ; if ( seig_entry &&"}
{"source": "CWE-703 inline Status SparseTensor : : Split ( const SparseTensor & input_tensor , const int split_dim , const int num_split , std : : vector < SparseTensor > * result ) { std : : vector < Tensor > output_indices ; std : : vector < Tensor > output_values ; std : : vector < TensorShape > output_shapes ; output_indices . reserve ( num_split ) ; output_values . reserve ( num_split ) ; output_shapes . reserve ( num_split ) ; std : : vector < typename TTypes < int64 > : : Matrix > output_indices_t ; std : : vector < typename TTypes < T > : : Vec > output_values_t ; output_indices_t . reserve ( num_split ) ; output_values_t . reserve ( num_split ) ; auto input_values_t = input_tensor . values ( ) . vec < T > ( ) ; auto input_indices_t = input_tensor . indices ( ) . matrix < int64 > ( ) ; std : : vector < int > num_values ( num_split , 0 ) ; const int num_dim = input_tensor . shape ( ) . size ( ) ; const int split_dim_size = input_tensor . shape ( ) [ split_dim ] ; const int split_size = split_dim_size / num_split ; if ( ! ( num_split > 0 && num_split <= split_dim_size ) ) { return errors : : InvalidArgument ( \"num_split<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>the<S2SV_blank>interval<S2SV_blank>(0,<S2SV_blank>\" , split_dim_size , \"]\" ) ; } if ( ! ( split_dim >= 0 && split_dim < num_dim ) ) { return errors : : InvalidArgument ( \"num_dim<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>the<S2SV_blank>interval<S2SV_blank>[0,<S2SV_blank>\" , num_dim , \")\" ) ; } const int residual = split_dim_size % num_split ; for ( int i = 0 ; i < input_tensor . indices ( ) . dim_size ( 0 ) ; ++ i ) { const int dim = input_tensor . indices ( ) . matrix < int64 > ( ) ( i , split_dim ) ; int slice_index = GetSliceIndex ( dim , split_size , residual ) ; <S2SV_StartBug> num_values [ slice_index ] ++ ; <S2SV_EndBug> } for ( int i = 0 ; i < num_split ; ++ i ) { output_indices . emplace_back ( DT_INT64 , TensorShape ( { num_values [ i ] , num_dim } ) ) ; output_values . emplace_back ( DataTypeToEnum < T > : : v ( ) , TensorShape ( { num_values [ i ] } ) ) ; output_shapes . emplace_back ( input_tensor . shape ( ) ) ; output_indices_t . emplace_back ( output_indices [ i ] . matrix < int64 > ( ) ) ; output_values_t . emplace_back ( output_values [ i ] . vec < T > ( ) ) ; const int size = GetSliceShape ( i , split_size , residual ) ; output_shapes [ i ] . set_dim ( split_dim , size ) ; } std : : vector < int > values_inserted_in_slice ( num_split , 0 ) ; for ( int i = 0 ; i < input_tensor . indices ( ) . dim_size ( 0 ) ; ++ i ) { const int dim = input_indices_t ( i , split_dim ) ; const int slice_index = GetSliceIndex ( dim , split_size , residual ) ; const int slice_dim = values_inserted_in_slice [ slice_index ] ++ ; output_values_t [ slice_index ] ( slice_dim ) = input_values_t ( i ) ; for ( int j = 0 ; j < num_dim ; ++ j ) { const int64 original_dim = input_indices_t ( i , j ) ; output_indices_t [ slice_index ] ( slice_dim , j ) = ( j == split_dim ) ? GetDimensionInSlice ( original_dim , split_size , residual ) : original_dim ; } } result -> clear ( ) ; result -> reserve ( num_split ) ; for ( int i = 0 ; i < num_split ; ++ i ) { SparseTensor tensor ; Status create_status = Create ( output_indices [ i ] , output_values [ i ] , output_shapes [ i ] , & tensor ) ; if ( ! create_status . ok ( ) ) { return create_status ; } result -> push_back ( std : : move ( tensor ) ) ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> residual ) ; if ( slice_index >= num_values . size ( ) ) { return errors : : InvalidArgument ( \"Slice<S2SV_blank>index<S2SV_blank>\" , slice_index , \"<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>num_split.\" ) ; }"}
{"source": "CWE-200 file_continue ( i_ctx_t * i_ctx_p ) { os_ptr op = osp ; es_ptr pscratch = esp - 2 ; file_enum * pfen = r_ptr ( esp - 1 , file_enum ) ; int devlen = esp [ - 3 ] . value . intval ; gx_io_device * iodev = r_ptr ( esp - 4 , gx_io_device ) ; uint len = r_size ( pscratch ) ; uint code ; if ( len < devlen ) return_error ( gs_error_rangecheck ) ; <S2SV_StartBug> memcpy ( ( char * ) pscratch -> value . bytes , iodev -> dname , devlen ) ; <S2SV_EndBug> code = iodev -> procs . enumerate_next ( pfen , ( char * ) pscratch -> value . bytes + devlen , len - devlen ) ; if ( code == ~ ( uint ) 0 ) { esp -= 5 ; return o_pop_estack ; } else if ( code > len ) return_error ( gs_error_rangecheck ) ; <S2SV_StartBug> else { <S2SV_EndBug> push ( 1 ) ; ref_assign ( op , pscratch ) ; r_set_size ( op , code + devlen ) ; push_op_estack ( file_continue ) ; * ++ esp = pscratch [ 2 ] ; return o_push_estack ; } <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> gs_error_rangecheck ) ; do { <S2SV_ModStart> ) ; else if ( iodev != iodev_default ( imemory ) || ( check_file_permissions_reduced ( i_ctx_p , ( char * ) pscratch -> value . bytes , code + devlen , \"PermitFileReading\" ) ) == 0 ) <S2SV_ModStart> ; } } while ( 1 ) ; }"}
{"source": "CWE-190 calculateNumTiles ( int * numTiles , int numLevels , int min , int max , int size , LevelRoundingMode rmode ) { for ( int i = 0 ; i < numLevels ; i ++ ) { <S2SV_StartBug> int l = levelSize ( min , max , i , rmode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( l > std : : numeric_limits < int > : : max ( ) - size + 1 ) <S2SV_EndBug> throw IEX_NAMESPACE : : ArgExc ( \"Invalid<S2SV_blank>size.\" ) ; numTiles [ i ] = ( l + size - 1 ) / size ; } }", "target": "<S2SV_ModStart> ++ ) { Int64 <S2SV_ModEnd> l = levelSize <S2SV_ModStart> rmode ) ; <S2SV_ModEnd> numTiles [ i"}
{"source": "CWE-787 ins_comp_get_next_word_or_line ( buf_T * ins_buf , pos_T * cur_match_pos , int * match_len , int * cont_s_ipos ) { char_u * ptr ; int len ; * match_len = 0 ; ptr = ml_get_buf ( ins_buf , cur_match_pos -> lnum , FALSE ) + cur_match_pos -> col ; if ( ctrl_x_mode_line_or_eval ( ) ) { if ( compl_status_adding ( ) ) { if ( cur_match_pos -> lnum >= ins_buf -> b_ml . ml_line_count ) return NULL ; ptr = ml_get_buf ( ins_buf , cur_match_pos -> lnum + 1 , FALSE ) ; if ( ! p_paste ) ptr = skipwhite ( ptr ) ; } len = ( int ) STRLEN ( ptr ) ; } else { char_u * tmp_ptr = ptr ; <S2SV_StartBug> if ( compl_status_adding ( ) ) <S2SV_EndBug> { tmp_ptr += compl_length ; if ( vim_iswordp ( tmp_ptr ) ) return NULL ; tmp_ptr = find_word_start ( tmp_ptr ) ; } tmp_ptr = find_word_end ( tmp_ptr ) ; len = ( int ) ( tmp_ptr - ptr ) ; if ( compl_status_adding ( ) && len == compl_length ) { if ( cur_match_pos -> lnum < ins_buf -> b_ml . ml_line_count ) { STRNCPY ( IObuff , ptr , len ) ; ptr = ml_get_buf ( ins_buf , cur_match_pos -> lnum + 1 , FALSE ) ; tmp_ptr = ptr = skipwhite ( ptr ) ; tmp_ptr = find_word_start ( tmp_ptr ) ; tmp_ptr = find_word_end ( tmp_ptr ) ; if ( tmp_ptr > ptr ) { if ( * ptr != ')' && IObuff [ len - 1 ] != TAB ) { if ( IObuff [ len - 1 ] != '<S2SV_blank>' ) IObuff [ len ++ ] = '<S2SV_blank>' ; if ( p_js && ( IObuff [ len - 2 ] == '.' || ( vim_strchr ( p_cpo , CPO_JOINSP ) == NULL && ( IObuff [ len - 2 ] == '?' || IObuff [ len - 2 ] == '!' ) ) ) ) IObuff [ len ++ ] = '<S2SV_blank>' ; } if ( tmp_ptr - ptr >= IOSIZE - len ) tmp_ptr = ptr + IOSIZE - len - 1 ; STRNCPY ( IObuff + len , ptr , tmp_ptr - ptr ) ; len += ( int ) ( tmp_ptr - ptr ) ; * cont_s_ipos = TRUE ; } IObuff [ len ] = NUL ; ptr = IObuff ; } if ( len == compl_length ) return NULL ; } } * match_len = len ; return ptr ; }", "target": "<S2SV_ModStart> compl_status_adding ( ) && compl_length <= ( int ) STRLEN ( tmp_ptr )"}
{"source": "CWE-416 nosy_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct client * client = file -> private_data ; spinlock_t * client_list_lock = & client -> lynx -> client_list_lock ; struct nosy_stats stats ; <S2SV_StartBug> <S2SV_EndBug> switch ( cmd ) { case NOSY_IOC_GET_STATS : spin_lock_irq ( client_list_lock ) ; stats . total_packet_count = client -> buffer . total_packet_count ; stats . lost_packet_count = client -> buffer . lost_packet_count ; spin_unlock_irq ( client_list_lock ) ; if ( copy_to_user ( ( void __user * ) arg , & stats , sizeof stats ) ) return - EFAULT ; else return 0 ; case NOSY_IOC_START : <S2SV_StartBug> spin_lock_irq ( client_list_lock ) ; <S2SV_EndBug> list_add_tail ( & client -> link , & client -> lynx -> client_list ) ; <S2SV_StartBug> spin_unlock_irq ( client_list_lock ) ; <S2SV_EndBug> return 0 ; case NOSY_IOC_STOP : spin_lock_irq ( client_list_lock ) ; list_del_init ( & client -> link ) ; spin_unlock_irq ( client_list_lock ) ; return 0 ; case NOSY_IOC_FILTER : spin_lock_irq ( client_list_lock ) ; client -> tcode_mask = arg ; spin_unlock_irq ( client_list_lock ) ; return 0 ; default : return - EINVAL ; } }", "target": "<S2SV_ModStart> nosy_stats stats ; int ret ; <S2SV_ModStart> case NOSY_IOC_START : ret = - EBUSY ; spin_lock_irq ( client_list_lock ) ; if ( list_empty ( & client -> link ) ) { <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> client_list ) ; ret = 0 ; } spin_unlock_irq ( client_list_lock ) ; return ret <S2SV_ModEnd> ; case NOSY_IOC_STOP"}
{"source": "CWE-74 bool ItemStackMetadata : : setString ( const std : : string & name , const std : : string & var ) { <S2SV_StartBug> bool result = Metadata : : setString ( name , var ) ; <S2SV_EndBug> <S2SV_StartBug> if ( name == TOOLCAP_KEY ) <S2SV_EndBug> updateToolCapabilities ( ) ; return result ; }", "target": "<S2SV_ModStart> var ) { std : : string clean_name = name ; std : : string clean_var = var ; sanitize_string ( clean_name ) ; sanitize_string ( clean_var ) ; <S2SV_ModStart> : setString ( clean_name , clean_var <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( clean_name <S2SV_ModEnd> == TOOLCAP_KEY )"}
{"source": "CWE-835 static void unzzip_cat_file ( ZZIP_DIR * disk , char * name , FILE * out ) { ZZIP_FILE * file = zzip_file_open ( disk , name , 0 ) ; if ( file ) { char buffer [ 1024 ] ; int len ; <S2SV_StartBug> while ( ( len = zzip_file_read ( file , buffer , 1024 ) ) ) <S2SV_EndBug> { fwrite ( buffer , 1 , len , out ) ; } zzip_file_close ( file ) ; } }", "target": "<S2SV_ModStart> ; while ( 0 <"}
{"source": "CWE-835 static int dissect_dvb_s2_bb ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) { proto_item * ti ; proto_tree * dvb_s2_bb_tree ; guint8 input8 , matype1 ; guint8 sync_flag = 0 ; guint16 input16 , bb_data_len = 0 , user_packet_length ; int sub_dissected = 0 , flag_is_ms = 0 , new_off = 0 ; static int * const bb_header_bitfields [ ] = { & hf_dvb_s2_bb_matype1_gs , & hf_dvb_s2_bb_matype1_mis , & hf_dvb_s2_bb_matype1_acm , & hf_dvb_s2_bb_matype1_issyi , & hf_dvb_s2_bb_matype1_npd , & hf_dvb_s2_bb_matype1_low_ro , NULL } ; col_append_str ( pinfo -> cinfo , COL_PROTOCOL , \"BB<S2SV_blank>\" ) ; col_append_str ( pinfo -> cinfo , COL_INFO , \"Baseband<S2SV_blank>\" ) ; ti = proto_tree_add_item ( tree , proto_dvb_s2_bb , tvb , 0 , DVB_S2_BB_HEADER_LEN , ENC_NA ) ; dvb_s2_bb_tree = proto_item_add_subtree ( ti , ett_dvb_s2_bb ) ; matype1 = tvb_get_guint8 ( tvb , DVB_S2_BB_OFFS_MATYPE1 ) ; new_off += 1 ; if ( BIT_IS_CLEAR ( matype1 , DVB_S2_BB_MIS_POS ) ) flag_is_ms = 1 ; proto_tree_add_bitmask_with_flags ( dvb_s2_bb_tree , tvb , DVB_S2_BB_OFFS_MATYPE1 , hf_dvb_s2_bb_matype1 , ett_dvb_s2_bb_matype1 , bb_header_bitfields , ENC_BIG_ENDIAN , BMT_NO_FLAGS ) ; input8 = tvb_get_guint8 ( tvb , DVB_S2_BB_OFFS_MATYPE1 ) ; if ( ( pinfo -> fd -> num == 1 ) && ( _use_low_rolloff_value != 0 ) ) { _use_low_rolloff_value = 0 ; } if ( ( ( input8 & 0x03 ) == 3 ) && ! _use_low_rolloff_value ) { _use_low_rolloff_value = 1 ; } if ( _use_low_rolloff_value ) { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype1_low_ro , tvb , DVB_S2_BB_OFFS_MATYPE1 , 1 , ENC_BIG_ENDIAN ) ; } else { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype1_high_ro , tvb , DVB_S2_BB_OFFS_MATYPE1 , 1 , ENC_BIG_ENDIAN ) ; } input8 = tvb_get_guint8 ( tvb , DVB_S2_BB_OFFS_MATYPE2 ) ; new_off += 1 ; if ( flag_is_ms ) { proto_tree_add_uint_format_value ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype2 , tvb , DVB_S2_BB_OFFS_MATYPE2 , 1 , input8 , \"Input<S2SV_blank>Stream<S2SV_blank>Identifier<S2SV_blank>(ISI):<S2SV_blank>%d\" , input8 ) ; } else { proto_tree_add_uint_format_value ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype2 , tvb , DVB_S2_BB_OFFS_MATYPE2 , 1 , input8 , \"reserved\" ) ; } user_packet_length = input16 = tvb_get_ntohs ( tvb , DVB_S2_BB_OFFS_UPL ) ; new_off += 2 ; proto_tree_add_uint_format ( dvb_s2_bb_tree , hf_dvb_s2_bb_upl , tvb , DVB_S2_BB_OFFS_UPL , 2 , input16 , \"User<S2SV_blank>Packet<S2SV_blank>Length:<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>(%d<S2SV_blank>bytes)\" , ( guint16 ) input16 , ( guint16 ) input16 / 8 ) ; bb_data_len = input16 = tvb_get_ntohs ( tvb , DVB_S2_BB_OFFS_DFL ) ; bb_data_len /= 8 ; new_off += 2 ; proto_tree_add_uint_format_value ( dvb_s2_bb_tree , hf_dvb_s2_bb_dfl , tvb , DVB_S2_BB_OFFS_DFL , 2 , input16 , \"%d<S2SV_blank>bits<S2SV_blank>(%d<S2SV_blank>bytes)\" , input16 , input16 / 8 ) ; new_off += 1 ; sync_flag = tvb_get_guint8 ( tvb , DVB_S2_BB_OFFS_SYNC ) ; proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_sync , tvb , DVB_S2_BB_OFFS_SYNC , 1 , ENC_BIG_ENDIAN ) ; new_off += 2 ; proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_syncd , tvb , DVB_S2_BB_OFFS_SYNCD , 2 , ENC_BIG_ENDIAN ) ; new_off += 1 ; proto_tree_add_checksum ( dvb_s2_bb_tree , tvb , DVB_S2_BB_OFFS_CRC , hf_dvb_s2_bb_crc , hf_dvb_s2_bb_crc_status , & ei_dvb_s2_bb_crc , pinfo , compute_crc8 ( tvb , DVB_S2_BB_HEADER_LEN - 1 , 0 ) , ENC_NA , PROTO_CHECKSUM_VERIFY ) ; switch ( matype1 & DVB_S2_BB_TSGS_MASK ) { case DVB_S2_BB_TSGS_GENERIC_CONTINUOUS : if ( BIT_IS_SET ( matype1 , DVB_S2_BB_ISSYI_POS ) ) { expert_add_info ( pinfo , ti , & ei_dvb_s2_bb_issy_invalid ) ; } if ( BIT_IS_SET ( matype1 , DVB_S2_BB_NPD_POS ) ) { expert_add_info ( pinfo , ti , & ei_dvb_s2_bb_npd_invalid ) ; } if ( user_packet_length != 0x0000 ) { expert_add_info_format ( pinfo , ti , & ei_dvb_s2_bb_upl_invalid , \"UPL<S2SV_blank>is<S2SV_blank>0x%04x.<S2SV_blank>It<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0x0000<S2SV_blank>for<S2SV_blank>GSE<S2SV_blank>packets.\" , user_packet_length ) ; } if ( dvb_s2_df_dissection ) { while ( bb_data_len ) { if ( sync_flag == DVB_S2_BB_SYNC_EIP_CRC32 && bb_data_len == DVB_S2_BB_EIP_CRC32_LEN ) { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_eip_crc32 , tvb , new_off , bb_data_len , ENC_NA ) ; bb_data_len = 0 ; new_off += DVB_S2_BB_EIP_CRC32_LEN ; } else { sub_dissected = dissect_dvb_s2_gse ( tvb_new_subset_length ( tvb , new_off , bb_data_len ) , pinfo , tree , NULL ) ; new_off += sub_dissected ; if ( ( sub_dissected <= bb_data_len ) && ( sub_dissected >= DVB_S2_GSE_MINSIZE ) ) { bb_data_len -= sub_dissected ; if ( bb_data_len < DVB_S2_GSE_MINSIZE ) bb_data_len = 0 ; <S2SV_StartBug> } <S2SV_EndBug> } } } else { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_df , tvb , new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; } break ; case DVB_S2_BB_TSGS_GENERIC_PACKETIZED : proto_tree_add_item ( tree , hf_dvb_s2_bb_packetized , tvb , new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; break ; case DVB_S2_BB_TSGS_TRANSPORT_STREAM : proto_tree_add_item ( tree , hf_dvb_s2_bb_transport , tvb , new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; break ; default : proto_tree_add_item ( tree , hf_dvb_s2_bb_reserved , tvb , new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; expert_add_info ( pinfo , ti , & ei_dvb_s2_bb_reserved ) ; break ; } return new_off ; }", "target": "<S2SV_ModStart> 0 ; } else { bb_data_len = 0 ; }"}
{"source": "CWE-476 static void set_error_response ( h2_stream * stream , int http_status ) { <S2SV_StartBug> if ( ! h2_stream_is_ready ( stream ) ) { <S2SV_EndBug> stream -> rtmp -> http_status = http_status ; } }", "target": "<S2SV_ModStart> ( stream ) && stream -> rtmp"}
{"source": "CWE-19 parse_reg_exp ( re_string_t * regexp , regex_t * preg , re_token_t * token , reg_syntax_t syntax , Idx nest , reg_errcode_t * err ) { re_dfa_t * dfa = preg -> buffer ; <S2SV_StartBug> bin_tree_t * tree , * branch = NULL ; <S2SV_EndBug> tree = parse_branch ( regexp , preg , token , syntax , nest , err ) ; if ( BE ( * err != REG_NOERROR && tree == NULL , 0 ) ) return NULL ; while ( token -> type == OP_ALT ) { fetch_token ( token , regexp , syntax | RE_CARET_ANCHORS_HERE ) ; if ( token -> type != OP_ALT && token -> type != END_OF_RE && ( nest == 0 || token -> type != OP_CLOSE_SUBEXP ) ) { <S2SV_StartBug> branch = parse_branch ( regexp , preg , token , syntax , nest , err ) ; <S2SV_EndBug> if ( BE ( * err != REG_NOERROR && branch == NULL , 0 ) ) { if ( tree != NULL ) postorder ( tree , free_tree , NULL ) ; return NULL ; } <S2SV_StartBug> } <S2SV_EndBug> else branch = NULL ; tree = create_tree ( dfa , tree , branch , OP_ALT ) ; if ( BE ( tree == NULL , 0 ) ) { * err = REG_ESPACE ; return NULL ; } } return tree ; }", "target": "<S2SV_ModStart> branch = NULL ; bitset_word_t initial_bkref_map = dfa -> completed_bkref_map <S2SV_ModStart> ) ) { bitset_word_t accumulated_bkref_map = dfa -> completed_bkref_map ; dfa -> completed_bkref_map = initial_bkref_map ; <S2SV_ModStart> NULL ; } dfa -> completed_bkref_map |= accumulated_bkref_map ;"}
{"source": "CWE-200 xmlDocPtr soap_xmlParseFile ( const char * filename TSRMLS_DC ) { xmlParserCtxtPtr ctxt = NULL ; xmlDocPtr ret ; zend_bool old_allow_url_fopen ; old_allow_url_fopen = PG ( allow_url_fopen ) ; PG ( allow_url_fopen ) = 1 ; ctxt = xmlCreateFileParserCtxt ( filename ) ; PG ( allow_url_fopen ) = old_allow_url_fopen ; if ( ctxt ) { zend_bool old ; ctxt -> keepBlanks = 0 ; ctxt -> sax -> ignorableWhitespace = soap_ignorableWhitespace ; ctxt -> sax -> comment = soap_Comment ; ctxt -> sax -> warning = NULL ; ctxt -> sax -> error = NULL ; <S2SV_StartBug> old = php_libxml_disable_entity_loader ( 1 ) ; <S2SV_EndBug> xmlParseDocument ( ctxt ) ; <S2SV_StartBug> php_libxml_disable_entity_loader ( old ) ; <S2SV_EndBug> if ( ctxt -> wellFormed ) { ret = ctxt -> myDoc ; if ( ret -> URL == NULL && ctxt -> directory != NULL ) { ret -> URL = xmlCharStrdup ( ctxt -> directory ) ; } } else { ret = NULL ; xmlFreeDoc ( ctxt -> myDoc ) ; ctxt -> myDoc = NULL ; } xmlFreeParserCtxt ( ctxt ) ; } else { ret = NULL ; } if ( ret ) { cleanup_xml_node ( ( xmlNodePtr ) ret ) ; } return ret ; }", "target": "<S2SV_ModStart> php_libxml_disable_entity_loader ( 1 TSRMLS_CC <S2SV_ModStart> php_libxml_disable_entity_loader ( old TSRMLS_CC"}
{"source": "CWE-200 xmlDocPtr soap_xmlParseMemory ( const void * buf , size_t buf_size ) { xmlParserCtxtPtr ctxt = NULL ; xmlDocPtr ret ; <S2SV_StartBug> ctxt = xmlCreateMemoryParserCtxt ( buf , buf_size ) ; <S2SV_EndBug> if ( ctxt ) { zend_bool old ; ctxt -> sax -> ignorableWhitespace = soap_ignorableWhitespace ; ctxt -> sax -> comment = soap_Comment ; ctxt -> sax -> warning = NULL ; ctxt -> sax -> error = NULL ; # if LIBXML_VERSION >= 20703 ctxt -> options |= XML_PARSE_HUGE ; # endif <S2SV_StartBug> old = php_libxml_disable_entity_loader ( 1 ) ; <S2SV_EndBug> xmlParseDocument ( ctxt ) ; <S2SV_StartBug> php_libxml_disable_entity_loader ( old ) ; <S2SV_EndBug> if ( ctxt -> wellFormed ) { ret = ctxt -> myDoc ; if ( ret -> URL == NULL && ctxt -> directory != NULL ) { ret -> URL = xmlCharStrdup ( ctxt -> directory ) ; } } else { ret = NULL ; xmlFreeDoc ( ctxt -> myDoc ) ; ctxt -> myDoc = NULL ; } xmlFreeParserCtxt ( ctxt ) ; } else { ret = NULL ; } return ret ; }", "target": "<S2SV_ModStart> xmlDocPtr ret ; TSRMLS_FETCH ( ) ; <S2SV_ModStart> php_libxml_disable_entity_loader ( 1 TSRMLS_CC <S2SV_ModStart> php_libxml_disable_entity_loader ( old TSRMLS_CC"}
{"source": "CWE-190 size_t intsetBlobLen ( intset * is ) { <S2SV_StartBug> return sizeof ( intset ) + intrev32ifbe ( is -> length ) * intrev32ifbe ( is -> encoding ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> intset ) + ( size_t )"}
{"source": "CWE-326 static int php_openssl_validate_iv ( char * * piv , size_t * piv_len , size_t iv_required_len , zend_bool * free_iv , EVP_CIPHER_CTX * cipher_ctx , struct php_openssl_cipher_mode * mode ) { char * iv_new ; <S2SV_StartBug> if ( * piv_len == iv_required_len ) { <S2SV_EndBug> return SUCCESS ; } if ( mode -> is_aead ) { if ( EVP_CIPHER_CTX_ctrl ( cipher_ctx , mode -> aead_ivlen_flag , * piv_len , NULL ) != 1 ) { php_error_docref ( NULL , E_WARNING , \"Setting<S2SV_blank>of<S2SV_blank>IV<S2SV_blank>length<S2SV_blank>for<S2SV_blank>AEAD<S2SV_blank>mode<S2SV_blank>failed\" ) ; return FAILURE ; } return SUCCESS ; } <S2SV_StartBug> iv_new = ecalloc ( 1 , iv_required_len + 1 ) ; <S2SV_EndBug> if ( * piv_len == 0 ) { * piv_len = iv_required_len ; * piv = iv_new ; * free_iv = 1 ; return SUCCESS ; } if ( * piv_len < iv_required_len ) { php_error_docref ( NULL , E_WARNING , \"IV<S2SV_blank>passed<S2SV_blank>is<S2SV_blank>only<S2SV_blank>%zd<S2SV_blank>bytes<S2SV_blank>long,<S2SV_blank>cipher<S2SV_blank>expects<S2SV_blank>an<S2SV_blank>IV<S2SV_blank>of<S2SV_blank>precisely<S2SV_blank>%zd<S2SV_blank>bytes,<S2SV_blank>padding<S2SV_blank>with<S2SV_blank>\\\\\\\\0\" , * piv_len , iv_required_len ) ; memcpy ( iv_new , * piv , * piv_len ) ; * piv_len = iv_required_len ; * piv = iv_new ; * free_iv = 1 ; return SUCCESS ; } php_error_docref ( NULL , E_WARNING , \"IV<S2SV_blank>passed<S2SV_blank>is<S2SV_blank>%zd<S2SV_blank>bytes<S2SV_blank>long<S2SV_blank>which<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>the<S2SV_blank>%zd<S2SV_blank>expected<S2SV_blank>by<S2SV_blank>selected<S2SV_blank>cipher,<S2SV_blank>truncating\" , * piv_len , iv_required_len ) ; memcpy ( iv_new , * piv , iv_required_len ) ; * piv_len = iv_required_len ; * piv = iv_new ; * free_iv = 1 ; return SUCCESS ; }", "target": "<S2SV_ModStart> ; if ( <S2SV_ModEnd> mode -> is_aead <S2SV_ModStart> SUCCESS ; } if ( * piv_len == iv_required_len ) { return SUCCESS ; }"}
{"source": "CWE-665 static __latent_entropy struct task_struct * copy_process ( struct pid * pid , int trace , int node , struct kernel_clone_args * args ) { int pidfd = - 1 , retval ; struct task_struct * p ; struct multiprocess_signals delayed ; struct file * pidfile = NULL ; u64 clone_flags = args -> flags ; struct nsproxy * nsp = current -> nsproxy ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; if ( clone_flags & CLONE_THREAD ) { if ( ( clone_flags & ( CLONE_NEWUSER | CLONE_NEWPID ) ) || ( task_active_pid_ns ( current ) != nsp -> pid_ns_for_children ) ) return ERR_PTR ( - EINVAL ) ; } if ( clone_flags & ( CLONE_THREAD | CLONE_VM ) ) { if ( nsp -> time_ns != nsp -> time_ns_for_children ) return ERR_PTR ( - EINVAL ) ; } if ( clone_flags & CLONE_PIDFD ) { if ( clone_flags & ( CLONE_DETACHED | CLONE_THREAD ) ) return ERR_PTR ( - EINVAL ) ; } sigemptyset ( & delayed . signal ) ; INIT_HLIST_NODE ( & delayed . node ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! ( clone_flags & CLONE_THREAD ) ) hlist_add_head ( & delayed . node , & current -> signal -> multiprocess ) ; recalc_sigpending ( ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; retval = - ERESTARTNOINTR ; if ( signal_pending ( current ) ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current , node ) ; if ( ! p ) goto fork_out ; p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? args -> child_tid : NULL ; p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? args -> child_tid : NULL ; ftrace_graph_init_task ( p ) ; rt_mutex_init_task ( p ) ; lockdep_assert_irqs_enabled ( ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= task_rlimit ( p , RLIMIT_NPROC ) ) { if ( p -> real_cred -> user != INIT_USER && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) goto bad_fork_free ; } current -> flags &= ~ PF_NPROC_EXCEEDED ; retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - EAGAIN ; if ( data_race ( nr_threads >= max_threads ) ) goto bad_fork_cleanup_count ; delayacct_tsk_init ( p ) ; p -> flags &= ~ ( PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE ) ; p -> flags |= PF_FORKNOEXEC ; INIT_LIST_HEAD ( & p -> children ) ; INIT_LIST_HEAD ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = p -> stime = p -> gtime = 0 ; # ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME p -> utimescaled = p -> stimescaled = 0 ; # endif prev_cputime_init ( & p -> prev_cputime ) ; # ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN seqcount_init ( & p -> vtime . seqcount ) ; p -> vtime . starttime = 0 ; p -> vtime . state = VTIME_INACTIVE ; # endif # ifdef CONFIG_IO_URING p -> io_uring = NULL ; # endif # if defined ( SPLIT_RSS_COUNTING ) memset ( & p -> rss_stat , 0 , sizeof ( p -> rss_stat ) ) ; # endif p -> default_timer_slack_ns = current -> timer_slack_ns ; # ifdef CONFIG_PSI p -> psi_flags = 0 ; # endif task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cputimers_init ( & p -> posix_cputimers ) ; p -> io_context = NULL ; audit_set_context ( p , NULL ) ; cgroup_fork ( p ) ; # ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( IS_ERR ( p -> mempolicy ) ) { retval = PTR_ERR ( p -> mempolicy ) ; p -> mempolicy = NULL ; goto bad_fork_cleanup_threadgroup_lock ; } # endif # ifdef CONFIG_CPUSETS p -> cpuset_mem_spread_rotor = NUMA_NO_NODE ; p -> cpuset_slab_spread_rotor = NUMA_NO_NODE ; seqcount_spinlock_init ( & p -> mems_allowed_seq , & p -> alloc_lock ) ; # endif # ifdef CONFIG_TRACE_IRQFLAGS memset ( & p -> irqtrace , 0 , sizeof ( p -> irqtrace ) ) ; p -> irqtrace . hardirq_disable_ip = _THIS_IP_ ; p -> irqtrace . softirq_enable_ip = _THIS_IP_ ; p -> softirqs_enabled = 1 ; p -> softirq_context = 0 ; # endif p -> pagefault_disabled = 0 ; # ifdef CONFIG_LOCKDEP lockdep_init_task ( p ) ; # endif # ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; # endif # ifdef CONFIG_BCACHE p -> sequential_io = 0 ; p -> sequential_io_avg = 0 ; # endif retval = sched_fork ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = audit_alloc ( p ) ; if ( retval ) goto bad_fork_cleanup_perf ; shm_init_task ( p ) ; retval = security_task_alloc ( p , clone_flags ) ; if ( retval ) goto bad_fork_cleanup_audit ; retval = copy_semundo ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_security ; retval = copy_files ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_semundo ; retval = copy_fs ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_files ; retval = copy_sighand ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_fs ; retval = copy_signal ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_sighand ; retval = copy_mm ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_signal ; retval = copy_namespaces ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_mm ; retval = copy_io ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , args -> stack , args -> stack_size , p , args -> tls ) ; if ( retval ) goto bad_fork_cleanup_io ; stackleak_task_init ( p ) ; if ( pid != & init_struct_pid ) { pid = alloc_pid ( p -> nsproxy -> pid_ns_for_children , args -> set_tid , args -> set_tid_size ) ; if ( IS_ERR ( pid ) ) { retval = PTR_ERR ( pid ) ; goto bad_fork_cleanup_thread ; } } if ( clone_flags & CLONE_PIDFD ) { retval = get_unused_fd_flags ( O_RDWR | O_CLOEXEC ) ; if ( retval < 0 ) goto bad_fork_free_pid ; pidfd = retval ; pidfile = anon_inode_getfile ( \"[pidfd]\" , & pidfd_fops , pid , O_RDWR | O_CLOEXEC ) ; if ( IS_ERR ( pidfile ) ) { put_unused_fd ( pidfd ) ; retval = PTR_ERR ( pidfile ) ; goto bad_fork_free_pid ; } get_pid ( pid ) ; retval = put_user ( pidfd , args -> pidfd ) ; if ( retval ) goto bad_fork_put_pidfd ; } # ifdef CONFIG_BLOCK p -> plug = NULL ; # endif futex_init_task ( p ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_VFORK ) ) == CLONE_VM ) sas_ss_reset ( p ) ; user_disable_single_step ( p ) ; clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ) ; # ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ) ; # endif clear_tsk_latency_tracing ( p ) ; p -> pid = pid_nr ( pid ) ; if ( clone_flags & CLONE_THREAD ) { <S2SV_StartBug> p -> exit_signal = - 1 ; <S2SV_EndBug> p -> group_leader = current -> group_leader ; p -> tgid = current -> tgid ; } else { <S2SV_StartBug> if ( clone_flags & CLONE_PARENT ) <S2SV_EndBug> p -> exit_signal = current -> group_leader -> exit_signal ; else p -> exit_signal = args -> exit_signal ; p -> group_leader = p ; p -> tgid = p -> pid ; } p -> nr_dirtied = 0 ; p -> nr_dirtied_pause = 128 >> ( PAGE_SHIFT - 10 ) ; p -> dirty_paused_when = 0 ; p -> pdeath_signal = 0 ; INIT_LIST_HEAD ( & p -> thread_group ) ; p -> task_works = NULL ; retval = cgroup_can_fork ( p , args ) ; if ( retval ) goto bad_fork_put_pidfd ; p -> start_time = ktime_get_ns ( ) ; p -> start_boottime = ktime_get_boottime_ns ( ) ; write_lock_irq ( & tasklist_lock ) ; if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; <S2SV_StartBug> } else { <S2SV_EndBug> p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; <S2SV_StartBug> } <S2SV_EndBug> klp_copy_process ( p ) ; spin_lock ( & current -> sighand -> siglock ) ; copy_seccomp ( p ) ; rseq_fork ( p , clone_flags ) ; if ( unlikely ( ! ( ns_of_pid ( pid ) -> pid_allocated & PIDNS_ADDING ) ) ) { retval = - ENOMEM ; goto bad_fork_cancel_cgroup ; } if ( fatal_signal_pending ( current ) ) { retval = - EINTR ; goto bad_fork_cancel_cgroup ; } if ( pidfile ) fd_install ( pidfd , pidfile ) ; init_task_pid_links ( p ) ; if ( likely ( p -> pid ) ) { ptrace_init_task ( p , ( clone_flags & CLONE_PTRACE ) || trace ) ; init_task_pid ( p , PIDTYPE_PID , pid ) ; if ( thread_group_leader ( p ) ) { init_task_pid ( p , PIDTYPE_TGID , pid ) ; init_task_pid ( p , PIDTYPE_PGID , task_pgrp ( current ) ) ; init_task_pid ( p , PIDTYPE_SID , task_session ( current ) ) ; if ( is_child_reaper ( pid ) ) { ns_of_pid ( pid ) -> child_reaper = p ; p -> signal -> flags |= SIGNAL_UNKILLABLE ; } p -> signal -> shared_pending . signal = delayed . signal ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; p -> signal -> has_child_subreaper = p -> real_parent -> signal -> has_child_subreaper || p -> real_parent -> signal -> is_child_subreaper ; list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; attach_pid ( p , PIDTYPE_TGID ) ; attach_pid ( p , PIDTYPE_PGID ) ; attach_pid ( p , PIDTYPE_SID ) ; __this_cpu_inc ( process_counts ) ; } else { current -> signal -> nr_threads ++ ; atomic_inc ( & current -> signal -> live ) ; refcount_inc ( & current -> signal -> sigcnt ) ; task_join_group_stop ( p ) ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; list_add_tail_rcu ( & p -> thread_node , & p -> signal -> thread_head ) ; } attach_pid ( p , PIDTYPE_PID ) ; nr_threads ++ ; } total_forks ++ ; hlist_del_init ( & delayed . node ) ; spin_unlock ( & current -> sighand -> siglock ) ; syscall_tracepoint_update ( p ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; sched_post_fork ( p ) ; cgroup_post_fork ( p , args ) ; perf_event_fork ( p ) ; trace_task_newtask ( p , clone_flags ) ; uprobe_copy_process ( p , clone_flags ) ; copy_oom_score_adj ( clone_flags , p ) ; return p ; bad_fork_cancel_cgroup : spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; cgroup_cancel_fork ( p , args ) ; bad_fork_put_pidfd : if ( clone_flags & CLONE_PIDFD ) { fput ( pidfile ) ; put_unused_fd ( pidfd ) ; } bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_thread : exit_thread ( p ) ; bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ) ; bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) { mm_clear_owner ( p -> mm , p ) ; mmput ( p -> mm ) ; } bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD ) ) free_signal_struct ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_security : security_task_free ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_perf : perf_event_free_task ( p ) ; bad_fork_cleanup_policy : lockdep_free_task ( p ) ; # ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_threadgroup_lock : # endif delayacct_tsk_free ( p ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : p -> state = TASK_DEAD ; put_task_stack ( p ) ; delayed_free_task ( p ) ; fork_out : spin_lock_irq ( & current -> sighand -> siglock ) ; hlist_del_init ( & delayed . node ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return ERR_PTR ( retval ) ; }", "target": "<S2SV_ModStart> { p -> <S2SV_ModEnd> group_leader = current <S2SV_ModStart> } else { <S2SV_ModEnd> p -> group_leader <S2SV_ModStart> -> parent_exec_id ; if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else p -> exit_signal = current -> group_leader -> exit_signal ; <S2SV_ModStart> -> self_exec_id ; p -> exit_signal = args -> exit_signal ;"}
{"source": "CWE-190 UINT rdpgfx_read_rect16 ( wStream * s , RECTANGLE_16 * rect16 ) { if ( Stream_GetRemainingLength ( s ) < 8 ) { WLog_ERR ( TAG , \"not<S2SV_blank>enough<S2SV_blank>data!\" ) ; return ERROR_INVALID_DATA ; } Stream_Read_UINT16 ( s , rect16 -> left ) ; Stream_Read_UINT16 ( s , rect16 -> top ) ; Stream_Read_UINT16 ( s , rect16 -> right ) ; Stream_Read_UINT16 ( s , rect16 -> bottom ) ; <S2SV_StartBug> return CHANNEL_RC_OK ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> bottom ) ; if ( rect16 -> left >= rect16 -> right ) return ERROR_INVALID_DATA ; if ( rect16 -> top >= rect16 -> bottom ) return ERROR_INVALID_DATA ;"}
{"source": "CWE-125 BOOL update_recv ( rdpUpdate * update , wStream * s ) { BOOL rc = FALSE ; UINT16 updateType ; rdpContext * context = update -> context ; if ( Stream_GetRemainingLength ( s ) < 2 ) { WLog_ERR ( TAG , \"Stream_GetRemainingLength(s)<S2SV_blank><<S2SV_blank>2\" ) ; return FALSE ; } Stream_Read_UINT16 ( s , updateType ) ; <S2SV_StartBug> WLog_Print ( update -> log , WLOG_TRACE , \"%s<S2SV_blank>Update<S2SV_blank>Data<S2SV_blank>PDU\" , UPDATE_TYPE_STRINGS [ updateType ] ) ; <S2SV_EndBug> if ( ! update_begin_paint ( update ) ) goto fail ; switch ( updateType ) { case UPDATE_TYPE_ORDERS : rc = update_recv_orders ( update , s ) ; break ; case UPDATE_TYPE_BITMAP : { BITMAP_UPDATE * bitmap_update = update_read_bitmap_update ( update , s ) ; if ( ! bitmap_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_BITMAP<S2SV_blank>-<S2SV_blank>update_read_bitmap_update()<S2SV_blank>failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> BitmapUpdate , context , bitmap_update ) ; free_bitmap_update ( update -> context , bitmap_update ) ; } break ; case UPDATE_TYPE_PALETTE : { PALETTE_UPDATE * palette_update = update_read_palette ( update , s ) ; if ( ! palette_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_PALETTE<S2SV_blank>-<S2SV_blank>update_read_palette()<S2SV_blank>failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> Palette , context , palette_update ) ; free_palette_update ( context , palette_update ) ; } break ; case UPDATE_TYPE_SYNCHRONIZE : if ( ! update_read_synchronize ( update , s ) ) goto fail ; rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ; break ; default : break ; } fail : if ( ! update_end_paint ( update ) ) rc = FALSE ; if ( ! rc ) { WLog_ERR ( TAG , \"UPDATE_TYPE<S2SV_blank>%s<S2SV_blank>[%\" PRIu16 \"]<S2SV_blank>failed\" , update_type_to_string ( updateType ) , updateType ) ; return FALSE ; } return TRUE ; }", "target": "<S2SV_ModStart> , \"%s<S2SV_blank>Update<S2SV_blank>Data<S2SV_blank>PDU\" , update_type_to_string ( updateType ) <S2SV_ModEnd> ) ; if"}
{"source": "CWE-284 <S2SV_StartBug> static int may_create_in_sticky ( struct dentry * const dir , <S2SV_EndBug> struct inode * const inode ) { if ( ( ! sysctl_protected_fifos && S_ISFIFO ( inode -> i_mode ) ) || ( ! sysctl_protected_regular && S_ISREG ( inode -> i_mode ) ) || <S2SV_StartBug> likely ( ! ( dir -> d_inode -> i_mode & S_ISVTX ) ) || <S2SV_EndBug> <S2SV_StartBug> uid_eq ( inode -> i_uid , dir -> d_inode -> i_uid ) || <S2SV_EndBug> uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return 0 ; <S2SV_StartBug> if ( likely ( dir -> d_inode -> i_mode & 0002 ) || <S2SV_EndBug> <S2SV_StartBug> ( dir -> d_inode -> i_mode & 0020 && <S2SV_EndBug> ( ( sysctl_protected_fifos >= 2 && S_ISFIFO ( inode -> i_mode ) ) || ( sysctl_protected_regular >= 2 && S_ISREG ( inode -> i_mode ) ) ) ) ) { const char * operation = S_ISFIFO ( inode -> i_mode ) ? \"sticky_create_fifo\" : \"sticky_create_regular\" ; audit_log_path_denied ( AUDIT_ANOM_CREAT , operation ) ; return - EACCES ; } return 0 ; }", "target": "<S2SV_ModStart> int may_create_in_sticky ( umode_t dir_mode , kuid_t dir_uid <S2SV_ModEnd> , struct inode <S2SV_ModStart> ( ! ( dir_mode <S2SV_ModEnd> & S_ISVTX ) <S2SV_ModStart> -> i_uid , dir_uid <S2SV_ModEnd> ) || uid_eq <S2SV_ModStart> ( likely ( dir_mode <S2SV_ModEnd> & 0002 ) <S2SV_ModStart> ) || ( dir_mode <S2SV_ModEnd> & 0020 &&"}
{"source": "CWE-703 CallResult < HermesValue > Interpreter : : interpretFunction ( Runtime * runtime , InterpreterState & state ) { struct IPSaver { IPSaver ( Runtime * runtime ) : ip_ ( runtime -> getCurrentIP ( ) ) , runtime_ ( runtime ) { } ~ IPSaver ( ) { runtime_ -> setCurrentIP ( ip_ ) ; } private : const Inst * ip_ ; Runtime * runtime_ ; } ; IPSaver ipSaver ( runtime ) ; # ifndef HERMES_ENABLE_DEBUGGER static_assert ( ! SingleStep , \"can\\'t<S2SV_blank>use<S2SV_blank>single-step<S2SV_blank>mode<S2SV_blank>without<S2SV_blank>the<S2SV_blank>debugger\" ) ; # endif static_assert ( HiddenClass : : kDictionaryThreshold <= SegmentedArray : : kValueToSegmentThreshold , \"Cannot<S2SV_blank>avoid<S2SV_blank>branches<S2SV_blank>in<S2SV_blank>cache<S2SV_blank>check<S2SV_blank>if<S2SV_blank>the<S2SV_blank>dictionary<S2SV_blank>\" \"crossover<S2SV_blank>point<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>inline<S2SV_blank>storage\" ) ; CodeBlock * curCodeBlock = state . codeBlock ; const Inst * ip = nullptr ; PinnedHermesValue * frameRegs ; bool strictMode ; PropOpFlags defaultPropOpFlags ; # define CAPTURE_IP_ASSIGN_NO_INVALIDATE ( dst , expr ) runtime -> setCurrentIP ( ip ) ; dst = expr ; ip = runtime -> getCurrentIP ( ) ; # ifdef NDEBUG # define CAPTURE_IP ( expr ) runtime -> setCurrentIP ( ip ) ; ( void ) expr ; ip = runtime -> getCurrentIP ( ) ; # define CAPTURE_IP_ASSIGN ( dst , expr ) CAPTURE_IP_ASSIGN_NO_INVALIDATE ( dst , expr ) # else # define CAPTURE_IP ( expr ) runtime -> setCurrentIP ( ip ) ; ( void ) expr ; ip = runtime -> getCurrentIP ( ) ; runtime -> invalidateCurrentIP ( ) ; # define CAPTURE_IP_ASSIGN ( dst , expr ) runtime -> setCurrentIP ( ip ) ; dst = expr ; ip = runtime -> getCurrentIP ( ) ; runtime -> invalidateCurrentIP ( ) ; <S2SV_StartBug> # endif <S2SV_EndBug> LLVM_DEBUG ( dbgs ( ) << \"interpretFunction()<S2SV_blank>called\\\\n\" ) ; ScopedNativeDepthTracker depthTracker { runtime } ; if ( LLVM_UNLIKELY ( depthTracker . overflowed ( ) ) ) { return runtime -> raiseStackOverflow ( Runtime : : StackOverflowKind : : NativeStack ) ; } if ( ! SingleStep ) { if ( auto jitPtr = runtime -> jitContext_ . compile ( runtime , curCodeBlock ) ) { return ( * jitPtr ) ( runtime ) ; } } GCScope gcScope ( runtime ) ; MutableHandle < > tmpHandle ( runtime ) ; CallResult < HermesValue > res { ExecutionStatus : : EXCEPTION } ; CallResult < PseudoHandle < >> resPH { ExecutionStatus : : EXCEPTION } ; CallResult < Handle < Arguments >> resArgs { ExecutionStatus : : EXCEPTION } ; CallResult < bool > boolRes { ExecutionStatus : : EXCEPTION } ; static constexpr unsigned KEEP_HANDLES = 1 ; assert ( gcScope . getHandleCountDbg ( ) == KEEP_HANDLES && \"scope<S2SV_blank>has<S2SV_blank>unexpected<S2SV_blank>number<S2SV_blank>of<S2SV_blank>handles\" ) ; INIT_OPCODE_PROFILER ; # if ! defined ( HERMESVM_PROFILER_EXTERN ) tailCall : # endif PROFILER_ENTER_FUNCTION ( curCodeBlock ) ; # ifdef HERMES_ENABLE_DEBUGGER runtime -> getDebugger ( ) . willEnterCodeBlock ( curCodeBlock ) ; # endif runtime -> getCodeCoverageProfiler ( ) . markExecuted ( runtime , curCodeBlock ) ; curCodeBlock -> incrementExecutionCount ( ) ; if ( ! SingleStep ) { auto newFrame = runtime -> setCurrentFrameToTopOfStack ( ) ; runtime -> saveCallerIPInStackFrame ( ) ; # ifndef NDEBUG runtime -> invalidateCurrentIP ( ) ; # endif frameRegs = & newFrame . getFirstLocalRef ( ) ; # ifndef NDEBUG LLVM_DEBUG ( dbgs ( ) << \"function<S2SV_blank>entry:<S2SV_blank>stackLevel=\" << runtime -> getStackLevel ( ) << \",<S2SV_blank>argCount=\" << runtime -> getCurrentFrame ( ) . getArgCount ( ) << \",<S2SV_blank>frameSize=\" << curCodeBlock -> getFrameSize ( ) << \"\\\\n\" ) ; LLVM_DEBUG ( dbgs ( ) << \"<S2SV_blank>callee<S2SV_blank>\" << DumpHermesValue ( runtime -> getCurrentFrame ( ) . getCalleeClosureOrCBRef ( ) ) << \"\\\\n\" ) ; LLVM_DEBUG ( dbgs ( ) << \"<S2SV_blank><S2SV_blank><S2SV_blank>this<S2SV_blank>\" << DumpHermesValue ( runtime -> getCurrentFrame ( ) . getThisArgRef ( ) ) << \"\\\\n\" ) ; for ( uint32_t i = 0 ; i != runtime -> getCurrentFrame ( ) -> getArgCount ( ) ; ++ i ) { LLVM_DEBUG ( dbgs ( ) << \"<S2SV_blank><S2SV_blank><S2SV_blank>\" << llvh : : format_decimal ( i , 4 ) << \"<S2SV_blank>\" << DumpHermesValue ( runtime -> getCurrentFrame ( ) . getArgRef ( i ) ) << \"\\\\n\" ) ; } # endif if ( LLVM_UNLIKELY ( ! runtime -> checkAndAllocStack ( curCodeBlock -> getFrameSize ( ) + StackFrameLayout : : CalleeExtraRegistersAtStart , HermesValue : : encodeUndefinedValue ( ) ) ) ) goto stackOverflow ; ip = ( Inst const * ) curCodeBlock -> begin ( ) ; if ( LLVM_UNLIKELY ( curCodeBlock -> getHeaderFlags ( ) . isCallProhibited ( newFrame . isConstructorCall ( ) ) ) ) { if ( ! newFrame . isConstructorCall ( ) ) { CAPTURE_IP ( runtime -> raiseTypeError ( \"Class<S2SV_blank>constructor<S2SV_blank>invoked<S2SV_blank>without<S2SV_blank>new\" ) ) ; } else { CAPTURE_IP ( runtime -> raiseTypeError ( \"Function<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>constructor\" ) ) ; } goto handleExceptionInParent ; } } else { frameRegs = & runtime -> getCurrentFrame ( ) . getFirstLocalRef ( ) ; ip = ( Inst const * ) ( curCodeBlock -> begin ( ) + state . offset ) ; } assert ( ( const uint8_t * ) ip < curCodeBlock -> end ( ) && \"CodeBlock<S2SV_blank>is<S2SV_blank>empty\" ) ; INIT_STATE_FOR_CODEBLOCK ( curCodeBlock ) ; # define BEFORE_OP_CODE { UPDATE_OPCODE_TIME_SPENT ; HERMES_SLOW_ASSERT ( curCodeBlock -> contains ( ip ) && \"curCodeBlock<S2SV_blank>must<S2SV_blank>contain<S2SV_blank>ip\" ) ; HERMES_SLOW_ASSERT ( ( printDebugInfo ( curCodeBlock , frameRegs , ip ) , true ) ) ; HERMES_SLOW_ASSERT ( gcScope . getHandleCountDbg ( ) == KEEP_HANDLES && \"unaccounted<S2SV_blank>handles<S2SV_blank>were<S2SV_blank>created\" ) ; HERMES_SLOW_ASSERT ( tmpHandle -> isUndefined ( ) && \"tmpHandle<S2SV_blank>not<S2SV_blank>cleared\" ) ; RECORD_OPCODE_START_TIME ; INC_OPCODE_COUNT ; } # ifdef HERMESVM_INDIRECT_THREADING static void * opcodeDispatch [ ] = { # define DEFINE_OPCODE ( name ) && case_ ## name , # include \"hermes/BCGen/HBC/BytecodeList.def\" && case__last } ; # define CASE ( name ) case_ ## name : # define DISPATCH BEFORE_OP_CODE ; if ( SingleStep ) { state . codeBlock = curCodeBlock ; state . offset = CUROFFSET ; return HermesValue : : encodeUndefinedValue ( ) ; } goto * opcodeDispatch [ ( unsigned ) ip -> opCode ] # else # define CASE ( name ) case OpCode : : name : # define DISPATCH if ( SingleStep ) { state . codeBlock = curCodeBlock ; state . offset = CUROFFSET ; return HermesValue : : encodeUndefinedValue ( ) ; } continue # endif # define RUN_DEBUGGER_ASYNC_BREAK ( flags ) do { CAPTURE_IP_ASSIGN ( auto dRes , runDebuggerUpdatingState ( ( uint8_t ) ( flags ) & ( uint8_t ) Runtime : : AsyncBreakReasonBits : : DebuggerExplicit ? Debugger : : RunReason : : AsyncBreakExplicit : Debugger : : RunReason : : AsyncBreakImplicit , runtime , curCodeBlock , ip , frameRegs ) ) ; if ( dRes == ExecutionStatus : : EXCEPTION ) goto exception ; } while ( 0 ) for ( ; ; ) { BEFORE_OP_CODE ; # ifdef HERMESVM_INDIRECT_THREADING goto * opcodeDispatch [ ( unsigned ) ip -> opCode ] ; # else switch ( ip -> opCode ) # endif { const Inst * nextIP ; uint32_t idVal ; bool tryProp ; uint32_t callArgCount ; HermesValue : : RawType callNewTarget ; # define CASE_OUTOFLINE ( name ) CASE ( name ) { CAPTURE_IP_ASSIGN ( auto res , case ## name ( runtime , frameRegs , ip ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( name ) ; DISPATCH ; } # define BINOP ( name , oper ) CASE ( name ) { if ( LLVM_LIKELY ( O2REG ( name ) . isNumber ( ) && O3REG ( name ) . isNumber ( ) ) ) { CASE ( name ## N ) { O1REG ( name ) = HermesValue : : encodeDoubleValue ( oper ( O2REG ( name ) . getNumber ( ) , O3REG ( name ) . getNumber ( ) ) ) ; ip = NEXTINST ( name ) ; DISPATCH ; } } CAPTURE_IP_ASSIGN ( res , toNumber_RJS ( runtime , Handle < > ( & O2REG ( name ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) goto exception ; double left = res -> getDouble ( ) ; CAPTURE_IP_ASSIGN ( res , toNumber_RJS ( runtime , Handle < > ( & O3REG ( name ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) goto exception ; O1REG ( name ) = HermesValue : : encodeDoubleValue ( oper ( left , res -> getDouble ( ) ) ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( name ) ; DISPATCH ; } # define SHIFTOP ( name , oper , lConv , lType , returnType ) CASE ( name ) { if ( LLVM_LIKELY ( O2REG ( name ) . isNumber ( ) && O3REG ( name ) . isNumber ( ) ) ) { auto lnum = static_cast < lType > ( hermes : : truncateToInt32 ( O2REG ( name ) . getNumber ( ) ) ) ; auto rnum = static_cast < uint32_t > ( hermes : : truncateToInt32 ( O3REG ( name ) . getNumber ( ) ) ) & 0x1f ; O1REG ( name ) = HermesValue : : encodeDoubleValue ( static_cast < returnType > ( lnum oper rnum ) ) ; ip = NEXTINST ( name ) ; DISPATCH ; } CAPTURE_IP_ASSIGN ( res , lConv ( runtime , Handle < > ( & O2REG ( name ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } auto lnum = static_cast < lType > ( res -> getNumber ( ) ) ; CAPTURE_IP_ASSIGN ( res , toUInt32_RJS ( runtime , Handle < > ( & O3REG ( name ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } auto rnum = static_cast < uint32_t > ( res -> getNumber ( ) ) & 0x1f ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( name ) = HermesValue : : encodeDoubleValue ( static_cast < returnType > ( lnum oper rnum ) ) ; ip = NEXTINST ( name ) ; DISPATCH ; } # define BITWISEBINOP ( name , oper ) CASE ( name ) { if ( LLVM_LIKELY ( O2REG ( name ) . isNumber ( ) && O3REG ( name ) . isNumber ( ) ) ) { O1REG ( name ) = HermesValue : : encodeDoubleValue ( hermes : : truncateToInt32 ( O2REG ( name ) . getNumber ( ) ) oper hermes : : truncateToInt32 ( O3REG ( name ) . getNumber ( ) ) ) ; ip = NEXTINST ( name ) ; DISPATCH ; } CAPTURE_IP_ASSIGN ( res , toInt32_RJS ( runtime , Handle < > ( & O2REG ( name ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } int32_t left = res -> getNumberAs < int32_t > ( ) ; CAPTURE_IP_ASSIGN ( res , toInt32_RJS ( runtime , Handle < > ( & O3REG ( name ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } O1REG ( name ) = HermesValue : : encodeNumberValue ( left oper res -> getNumberAs < int32_t > ( ) ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( name ) ; DISPATCH ; } # define CONDOP ( name , oper , operFuncName ) CASE ( name ) { if ( LLVM_LIKELY ( O2REG ( name ) . isNumber ( ) && O3REG ( name ) . isNumber ( ) ) ) { O1REG ( name ) = HermesValue : : encodeBoolValue ( O2REG ( name ) . getNumber ( ) oper O3REG ( name ) . getNumber ( ) ) ; ip = NEXTINST ( name ) ; DISPATCH ; } CAPTURE_IP_ASSIGN ( boolRes , operFuncName ( runtime , Handle < > ( & O2REG ( name ) ) , Handle < > ( & O3REG ( name ) ) ) ) ; if ( boolRes == ExecutionStatus : : EXCEPTION ) goto exception ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( name ) = HermesValue : : encodeBoolValue ( boolRes . getValue ( ) ) ; ip = NEXTINST ( name ) ; DISPATCH ; } # define JCOND_IMPL ( name , suffix , oper , operFuncName , trueDest , falseDest ) CASE ( name ## suffix ) { if ( LLVM_LIKELY ( O2REG ( name ## suffix ) . isNumber ( ) && O3REG ( name ## suffix ) . isNumber ( ) ) ) { CASE ( name ## N ## suffix ) { if ( O2REG ( name ## N ## suffix ) . getNumber ( ) oper O3REG ( name ## N ## suffix ) . getNumber ( ) ) { ip = trueDest ; DISPATCH ; } ip = falseDest ; DISPATCH ; } } CAPTURE_IP_ASSIGN ( boolRes , operFuncName ( runtime , Handle < > ( & O2REG ( name ## suffix ) ) , Handle < > ( & O3REG ( name ## suffix ) ) ) ) ; if ( boolRes == ExecutionStatus : : EXCEPTION ) goto exception ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; if ( boolRes . getValue ( ) ) { ip = trueDest ; DISPATCH ; } ip = falseDest ; DISPATCH ; } # define JCOND_STRICT_EQ_IMPL ( name , suffix , trueDest , falseDest ) CASE ( name ## suffix ) { if ( strictEqualityTest ( O2REG ( name ## suffix ) , O3REG ( name ## suffix ) ) ) { ip = trueDest ; DISPATCH ; } ip = falseDest ; DISPATCH ; } # define JCOND_EQ_IMPL ( name , suffix , trueDest , falseDest ) CASE ( name ## suffix ) { CAPTURE_IP_ASSIGN ( res , abstractEqualityTest_RJS ( runtime , Handle < > ( & O2REG ( name ## suffix ) ) , Handle < > ( & O3REG ( name ## suffix ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; if ( res -> getBool ( ) ) { ip = trueDest ; DISPATCH ; } ip = falseDest ; DISPATCH ; } # define JCOND ( name , oper , operFuncName ) JCOND_IMPL ( J ## name , , oper , operFuncName , IPADD ( ip -> iJ ## name . op1 ) , NEXTINST ( J ## name ) ) ; JCOND_IMPL ( J ## name , Long , oper , operFuncName , IPADD ( ip -> iJ ## name ## Long . op1 ) , NEXTINST ( J ## name ## Long ) ) ; JCOND_IMPL ( JNot ## name , , oper , operFuncName , NEXTINST ( JNot ## name ) , IPADD ( ip -> iJNot ## name . op1 ) ) ; JCOND_IMPL ( JNot ## name , Long , oper , operFuncName , NEXTINST ( JNot ## name ## Long ) , IPADD ( ip -> iJNot ## name ## Long . op1 ) ) ; # define LOAD_CONST ( name , value ) CASE ( name ) { O1REG ( name ) = value ; ip = NEXTINST ( name ) ; DISPATCH ; } # define LOAD_CONST_CAPTURE_IP ( name , value ) CASE ( name ) { CAPTURE_IP_ASSIGN ( O1REG ( name ) , value ) ; ip = NEXTINST ( name ) ; DISPATCH ; } CASE ( Mov ) { O1REG ( Mov ) = O2REG ( Mov ) ; ip = NEXTINST ( Mov ) ; DISPATCH ; } CASE ( MovLong ) { O1REG ( MovLong ) = O2REG ( MovLong ) ; ip = NEXTINST ( MovLong ) ; DISPATCH ; } CASE ( LoadParam ) { if ( LLVM_LIKELY ( ip -> iLoadParam . op2 <= FRAME . getArgCount ( ) ) ) { O1REG ( LoadParam ) = FRAME . getArgRef ( ( int32_t ) ip -> iLoadParam . op2 - 1 ) ; ip = NEXTINST ( LoadParam ) ; DISPATCH ; } O1REG ( LoadParam ) = HermesValue : : encodeUndefinedValue ( ) ; ip = NEXTINST ( LoadParam ) ; DISPATCH ; } CASE ( LoadParamLong ) { if ( LLVM_LIKELY ( ip -> iLoadParamLong . op2 <= FRAME . getArgCount ( ) ) ) { O1REG ( LoadParamLong ) = FRAME . getArgRef ( ( int32_t ) ip -> iLoadParamLong . op2 - 1 ) ; ip = NEXTINST ( LoadParamLong ) ; DISPATCH ; } O1REG ( LoadParamLong ) = HermesValue : : encodeUndefinedValue ( ) ; ip = NEXTINST ( LoadParamLong ) ; DISPATCH ; } CASE ( CoerceThisNS ) { if ( LLVM_LIKELY ( O2REG ( CoerceThisNS ) . isObject ( ) ) ) { O1REG ( CoerceThisNS ) = O2REG ( CoerceThisNS ) ; } else if ( O2REG ( CoerceThisNS ) . isNull ( ) || O2REG ( CoerceThisNS ) . isUndefined ( ) ) { O1REG ( CoerceThisNS ) = runtime -> global_ ; } else { tmpHandle = O2REG ( CoerceThisNS ) ; nextIP = NEXTINST ( CoerceThisNS ) ; goto coerceThisSlowPath ; } ip = NEXTINST ( CoerceThisNS ) ; DISPATCH ; } CASE ( LoadThisNS ) { if ( LLVM_LIKELY ( FRAME . getThisArgRef ( ) . isObject ( ) ) ) { O1REG ( LoadThisNS ) = FRAME . getThisArgRef ( ) ; } else if ( FRAME . getThisArgRef ( ) . isNull ( ) || FRAME . getThisArgRef ( ) . isUndefined ( ) ) { O1REG ( LoadThisNS ) = runtime -> global_ ; } else { tmpHandle = FRAME . getThisArgRef ( ) ; nextIP = NEXTINST ( LoadThisNS ) ; goto coerceThisSlowPath ; } ip = NEXTINST ( LoadThisNS ) ; DISPATCH ; } coerceThisSlowPath : { CAPTURE_IP_ASSIGN ( res , toObject ( runtime , tmpHandle ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( CoerceThisNS ) = res . getValue ( ) ; tmpHandle . clear ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } CASE ( ConstructLong ) { callArgCount = ( uint32_t ) ip -> iConstructLong . op3 ; nextIP = NEXTINST ( ConstructLong ) ; callNewTarget = O2REG ( ConstructLong ) . getRaw ( ) ; goto doCall ; } CASE ( CallLong ) { callArgCount = ( uint32_t ) ip -> iCallLong . op3 ; nextIP = NEXTINST ( CallLong ) ; callNewTarget = HermesValue : : encodeUndefinedValue ( ) . getRaw ( ) ; goto doCall ; } CASE ( Call1 ) { callArgCount = 1 ; nextIP = NEXTINST ( Call1 ) ; StackFramePtr fr { runtime -> stackPointer_ } ; fr . getArgRefUnsafe ( - 1 ) = O3REG ( Call1 ) ; callNewTarget = HermesValue : : encodeUndefinedValue ( ) . getRaw ( ) ; goto doCall ; } CASE ( Call2 ) { callArgCount = 2 ; nextIP = NEXTINST ( Call2 ) ; StackFramePtr fr { runtime -> stackPointer_ } ; fr . getArgRefUnsafe ( - 1 ) = O3REG ( Call2 ) ; fr . getArgRefUnsafe ( 0 ) = O4REG ( Call2 ) ; callNewTarget = HermesValue : : encodeUndefinedValue ( ) . getRaw ( ) ; goto doCall ; } CASE ( Call3 ) { callArgCount = 3 ; nextIP = NEXTINST ( Call3 ) ; StackFramePtr fr { runtime -> stackPointer_ } ; fr . getArgRefUnsafe ( - 1 ) = O3REG ( Call3 ) ; fr . getArgRefUnsafe ( 0 ) = O4REG ( Call3 ) ; fr . getArgRefUnsafe ( 1 ) = O5REG ( Call3 ) ; callNewTarget = HermesValue : : encodeUndefinedValue ( ) . getRaw ( ) ; goto doCall ; } CASE ( Call4 ) { callArgCount = 4 ; nextIP = NEXTINST ( Call4 ) ; StackFramePtr fr { runtime -> stackPointer_ } ; fr . getArgRefUnsafe ( - 1 ) = O3REG ( Call4 ) ; fr . getArgRefUnsafe ( 0 ) = O4REG ( Call4 ) ; fr . getArgRefUnsafe ( 1 ) = O5REG ( Call4 ) ; fr . getArgRefUnsafe ( 2 ) = O6REG ( Call4 ) ; callNewTarget = HermesValue : : encodeUndefinedValue ( ) . getRaw ( ) ; goto doCall ; } CASE ( Construct ) { callArgCount = ( uint32_t ) ip -> iConstruct . op3 ; nextIP = NEXTINST ( Construct ) ; callNewTarget = O2REG ( Construct ) . getRaw ( ) ; goto doCall ; } CASE ( Call ) { callArgCount = ( uint32_t ) ip -> iCall . op3 ; nextIP = NEXTINST ( Call ) ; callNewTarget = HermesValue : : encodeUndefinedValue ( ) . getRaw ( ) ; } doCall : { # ifdef HERMES_ENABLE_DEBUGGER if ( uint8_t asyncFlags = runtime -> testAndClearDebuggerAsyncBreakRequest ( ) ) { RUN_DEBUGGER_ASYNC_BREAK ( asyncFlags ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; DISPATCH ; } # endif CAPTURE_IP_ASSIGN_NO_INVALIDATE ( auto newFrame , StackFramePtr : : initFrame ( runtime -> stackPointer_ , FRAME , ip , curCodeBlock , callArgCount - 1 , O2REG ( Call ) , HermesValue : : fromRaw ( callNewTarget ) ) ) ; ( void ) newFrame ; SLOW_DEBUG ( dumpCallArguments ( dbgs ( ) , runtime , newFrame ) ) ; if ( auto * func = dyn_vmcast < JSFunction > ( O2REG ( Call ) ) ) { assert ( ! SingleStep && \"can\\'t<S2SV_blank>single-step<S2SV_blank>a<S2SV_blank>call\" ) ; # ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES runtime -> pushCallStack ( curCodeBlock , ip ) ; # endif CodeBlock * calleeBlock = func -> getCodeBlock ( ) ; calleeBlock -> lazyCompile ( runtime ) ; # if defined ( HERMESVM_PROFILER_EXTERN ) CAPTURE_IP_ASSIGN_NO_INVALIDATE ( res , runtime -> interpretFunction ( calleeBlock ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( Call ) = * res ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; # else if ( auto jitPtr = runtime -> jitContext_ . compile ( runtime , calleeBlock ) ) { res = ( * jitPtr ) ( runtime ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) goto exception ; O1REG ( Call ) = * res ; SLOW_DEBUG ( dbgs ( ) << \"JIT<S2SV_blank>return<S2SV_blank>value<S2SV_blank>r\" << ( unsigned ) ip -> iCall . op1 << \"=\" << DumpHermesValue ( O1REG ( Call ) ) << \"\\\\n\" ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } curCodeBlock = calleeBlock ; goto tailCall ; # endif } CAPTURE_IP_ASSIGN_NO_INVALIDATE ( resPH , Interpreter : : handleCallSlowPath ( runtime , & O2REG ( Call ) ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( Call ) = std : : move ( resPH -> get ( ) ) ; SLOW_DEBUG ( dbgs ( ) << \"native<S2SV_blank>return<S2SV_blank>value<S2SV_blank>r\" << ( unsigned ) ip -> iCall . op1 << \"=\" << DumpHermesValue ( O1REG ( Call ) ) << \"\\\\n\" ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } CASE ( CallDirect ) CASE ( CallDirectLongIndex ) { # ifdef HERMES_ENABLE_DEBUGGER if ( uint8_t asyncFlags = runtime -> testAndClearDebuggerAsyncBreakRequest ( ) ) { RUN_DEBUGGER_ASYNC_BREAK ( asyncFlags ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; DISPATCH ; } # endif CAPTURE_IP_ASSIGN ( CodeBlock * calleeBlock , ip -> opCode == OpCode : : CallDirect ? curCodeBlock -> getRuntimeModule ( ) -> getCodeBlockMayAllocate ( ip -> iCallDirect . op3 ) : curCodeBlock -> getRuntimeModule ( ) -> getCodeBlockMayAllocate ( ip -> iCallDirectLongIndex . op3 ) ) ; CAPTURE_IP_ASSIGN_NO_INVALIDATE ( auto newFrame , StackFramePtr : : initFrame ( runtime -> stackPointer_ , FRAME , ip , curCodeBlock , ( uint32_t ) ip -> iCallDirect . op2 - 1 , HermesValue : : encodeNativePointer ( calleeBlock ) , HermesValue : : encodeUndefinedValue ( ) ) ) ; ( void ) newFrame ; LLVM_DEBUG ( dumpCallArguments ( dbgs ( ) , runtime , newFrame ) ) ; assert ( ! SingleStep && \"can\\'t<S2SV_blank>single-step<S2SV_blank>a<S2SV_blank>call\" ) ; calleeBlock -> lazyCompile ( runtime ) ; # if defined ( HERMESVM_PROFILER_EXTERN ) CAPTURE_IP_ASSIGN_NO_INVALIDATE ( res , runtime -> interpretFunction ( calleeBlock ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( CallDirect ) = * res ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = ip -> opCode == OpCode : : CallDirect ? NEXTINST ( CallDirect ) : NEXTINST ( CallDirectLongIndex ) ; DISPATCH ; # else if ( auto jitPtr = runtime -> jitContext_ . compile ( runtime , calleeBlock ) ) { res = ( * jitPtr ) ( runtime ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) goto exception ; O1REG ( CallDirect ) = * res ; LLVM_DEBUG ( dbgs ( ) << \"JIT<S2SV_blank>return<S2SV_blank>value<S2SV_blank>r\" << ( unsigned ) ip -> iCallDirect . op1 << \"=\" << DumpHermesValue ( O1REG ( Call ) ) << \"\\\\n\" ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = ip -> opCode == OpCode : : CallDirect ? NEXTINST ( CallDirect ) : NEXTINST ( CallDirectLongIndex ) ; DISPATCH ; } curCodeBlock = calleeBlock ; goto tailCall ; # endif } CASE ( CallBuiltin ) { NativeFunction * nf = runtime -> getBuiltinNativeFunction ( ip -> iCallBuiltin . op2 ) ; CAPTURE_IP_ASSIGN ( auto newFrame , StackFramePtr : : initFrame ( runtime -> stackPointer_ , FRAME , ip , curCodeBlock , ( uint32_t ) ip -> iCallBuiltin . op3 - 1 , nf , false ) ) ; newFrame . getThisArgRef ( ) = HermesValue : : encodeUndefinedValue ( ) ; SLOW_DEBUG ( dumpCallArguments ( dbgs ( ) , runtime , newFrame ) ) ; CAPTURE_IP_ASSIGN ( resPH , NativeFunction : : _nativeCall ( nf , runtime ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) goto exception ; O1REG ( CallBuiltin ) = std : : move ( resPH -> get ( ) ) ; SLOW_DEBUG ( dbgs ( ) << \"native<S2SV_blank>return<S2SV_blank>value<S2SV_blank>r\" << ( unsigned ) ip -> iCallBuiltin . op1 << \"=\" << DumpHermesValue ( O1REG ( CallBuiltin ) ) << \"\\\\n\" ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( CallBuiltin ) ; DISPATCH ; } CASE ( CompleteGenerator ) { auto * innerFn = vmcast < GeneratorInnerFunction > ( runtime -> getCurrentFrame ( ) . getCalleeClosure ( ) ) ; innerFn -> setState ( GeneratorInnerFunction : : State : : Completed ) ; ip = NEXTINST ( CompleteGenerator ) ; DISPATCH ; } CASE ( SaveGenerator ) { <S2SV_StartBug> nextIP = IPADD ( ip -> iSaveGenerator . op1 ) ; <S2SV_EndBug> goto doSaveGen ; } CASE ( SaveGeneratorLong ) { <S2SV_StartBug> nextIP = IPADD ( ip -> iSaveGeneratorLong . op1 ) ; <S2SV_EndBug> goto doSaveGen ; } doSaveGen : { auto * innerFn = vmcast < GeneratorInnerFunction > ( runtime -> getCurrentFrame ( ) . getCalleeClosure ( ) ) ; innerFn -> saveStack ( runtime ) ; innerFn -> setNextIP ( nextIP ) ; innerFn -> setState ( GeneratorInnerFunction : : State : : SuspendedYield ) ; <S2SV_StartBug> ip = NEXTINST ( SaveGenerator ) ; <S2SV_EndBug> DISPATCH ; } CASE ( StartGenerator ) { auto * innerFn = vmcast < GeneratorInnerFunction > ( runtime -> getCurrentFrame ( ) . getCalleeClosure ( ) ) ; if ( innerFn -> getState ( ) == GeneratorInnerFunction : : State : : SuspendedStart ) { nextIP = NEXTINST ( StartGenerator ) ; } else { nextIP = innerFn -> getNextIP ( ) ; innerFn -> restoreStack ( runtime ) ; } innerFn -> setState ( GeneratorInnerFunction : : State : : Executing ) ; ip = nextIP ; DISPATCH ; } CASE ( ResumeGenerator ) { auto * innerFn = vmcast < GeneratorInnerFunction > ( runtime -> getCurrentFrame ( ) . getCalleeClosure ( ) ) ; O1REG ( ResumeGenerator ) = innerFn -> getResult ( ) ; O2REG ( ResumeGenerator ) = HermesValue : : encodeBoolValue ( innerFn -> getAction ( ) == GeneratorInnerFunction : : Action : : Return ) ; innerFn -> clearResult ( runtime ) ; if ( innerFn -> getAction ( ) == GeneratorInnerFunction : : Action : : Throw ) { runtime -> setThrownValue ( O1REG ( ResumeGenerator ) ) ; goto exception ; } ip = NEXTINST ( ResumeGenerator ) ; DISPATCH ; } CASE ( Ret ) { # ifdef HERMES_ENABLE_DEBUGGER if ( uint8_t asyncFlags = runtime -> testAndClearDebuggerAsyncBreakRequest ( ) ) { RUN_DEBUGGER_ASYNC_BREAK ( asyncFlags ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; DISPATCH ; } # endif PROFILER_EXIT_FUNCTION ( curCodeBlock ) ; # ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES runtime -> popCallStack ( ) ; # endif res = O1REG ( Ret ) ; ip = FRAME . getSavedIP ( ) ; curCodeBlock = FRAME . getSavedCodeBlock ( ) ; frameRegs = & runtime -> restoreStackAndPreviousFrame ( FRAME ) . getFirstLocalRef ( ) ; SLOW_DEBUG ( dbgs ( ) << \"function<S2SV_blank>exit:<S2SV_blank>restored<S2SV_blank>stackLevel=\" << runtime -> getStackLevel ( ) << \"\\\\n\" ) ; if ( ! curCodeBlock ) { SLOW_DEBUG ( dbgs ( ) << \"function<S2SV_blank>exit:<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>native<S2SV_blank>code\\\\n\" ) ; return res ; } # if defined ( HERMESVM_PROFILER_EXTERN ) return res ; # endif INIT_STATE_FOR_CODEBLOCK ( curCodeBlock ) ; O1REG ( Call ) = res . getValue ( ) ; ip = nextInstCall ( ip ) ; DISPATCH ; } CASE ( Catch ) { assert ( ! runtime -> thrownValue_ . isEmpty ( ) && \"Invalid<S2SV_blank>thrown<S2SV_blank>value\" ) ; assert ( ! isUncatchableError ( runtime -> thrownValue_ ) && \"Uncatchable<S2SV_blank>thrown<S2SV_blank>value<S2SV_blank>was<S2SV_blank>caught\" ) ; O1REG ( Catch ) = runtime -> thrownValue_ ; runtime -> clearThrownValue ( ) ; # ifdef HERMES_ENABLE_DEBUGGER runtime -> debugger_ . finishedUnwindingException ( ) ; # endif ip = NEXTINST ( Catch ) ; DISPATCH ; } CASE ( Throw ) { runtime -> thrownValue_ = O1REG ( Throw ) ; SLOW_DEBUG ( dbgs ( ) << \"Exception<S2SV_blank>thrown:<S2SV_blank>\" << DumpHermesValue ( runtime -> thrownValue_ ) << \"\\\\n\" ) ; goto exception ; } CASE ( ThrowIfUndefinedInst ) { if ( LLVM_UNLIKELY ( O1REG ( ThrowIfUndefinedInst ) . isUndefined ( ) ) ) { SLOW_DEBUG ( dbgs ( ) << \"Throwing<S2SV_blank>ReferenceError<S2SV_blank>for<S2SV_blank>undefined<S2SV_blank>variable\" ) ; CAPTURE_IP ( runtime -> raiseReferenceError ( \"accessing<S2SV_blank>an<S2SV_blank>uninitialized<S2SV_blank>variable\" ) ) ; goto exception ; } ip = NEXTINST ( ThrowIfUndefinedInst ) ; DISPATCH ; } CASE ( Debugger ) { SLOW_DEBUG ( dbgs ( ) << \"debugger<S2SV_blank>statement<S2SV_blank>executed\\\\n\" ) ; # ifdef HERMES_ENABLE_DEBUGGER { if ( ! runtime -> debugger_ . isDebugging ( ) ) { CAPTURE_IP_ASSIGN ( auto res , runDebuggerUpdatingState ( Debugger : : RunReason : : Opcode , runtime , curCodeBlock , ip , frameRegs ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } } auto breakpointOpt = runtime -> debugger_ . getBreakpointLocation ( ip ) ; if ( breakpointOpt . hasValue ( ) ) { curCodeBlock -> uninstallBreakpointAtOffset ( CUROFFSET , breakpointOpt -> opCode ) ; if ( ip -> opCode == OpCode : : Debugger ) { ip = NEXTINST ( Debugger ) ; } else { InterpreterState newState { curCodeBlock , ( uint32_t ) CUROFFSET } ; CAPTURE_IP_ASSIGN ( ExecutionStatus status , runtime -> stepFunction ( newState ) ) ; curCodeBlock -> installBreakpointAtOffset ( CUROFFSET ) ; if ( status == ExecutionStatus : : EXCEPTION ) { goto exception ; } curCodeBlock = newState . codeBlock ; ip = newState . codeBlock -> getOffsetPtr ( newState . offset ) ; INIT_STATE_FOR_CODEBLOCK ( curCodeBlock ) ; frameRegs = & runtime -> getCurrentFrame ( ) . getFirstLocalRef ( ) ; } } else if ( ip -> opCode == OpCode : : Debugger ) { ip = NEXTINST ( Debugger ) ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; } DISPATCH ; # else ip = NEXTINST ( Debugger ) ; DISPATCH ; # endif } CASE ( AsyncBreakCheck ) { if ( LLVM_UNLIKELY ( runtime -> hasAsyncBreak ( ) ) ) { # ifdef HERMES_ENABLE_DEBUGGER if ( uint8_t asyncFlags = runtime -> testAndClearDebuggerAsyncBreakRequest ( ) ) { RUN_DEBUGGER_ASYNC_BREAK ( asyncFlags ) ; } # endif if ( runtime -> testAndClearTimeoutAsyncBreakRequest ( ) ) { CAPTURE_IP_ASSIGN ( auto nRes , runtime -> notifyTimeout ( ) ) ; if ( nRes == ExecutionStatus : : EXCEPTION ) { goto exception ; } } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( AsyncBreakCheck ) ; DISPATCH ; } CASE ( ProfilePoint ) { # ifdef HERMESVM_PROFILER_BB auto pointIndex = ip -> iProfilePoint . op1 ; SLOW_DEBUG ( llvh : : dbgs ( ) << \"ProfilePoint:<S2SV_blank>\" << pointIndex << \"\\\\n\" ) ; CAPTURE_IP ( runtime -> getBasicBlockExecutionInfo ( ) . executeBlock ( curCodeBlock , pointIndex ) ) ; # endif ip = NEXTINST ( ProfilePoint ) ; DISPATCH ; } CASE ( Unreachable ) { llvm_unreachable ( \"Hermes<S2SV_blank>bug:<S2SV_blank>unreachable<S2SV_blank>instruction\" ) ; } CASE ( CreateClosure ) { idVal = ip -> iCreateClosure . op3 ; nextIP = NEXTINST ( CreateClosure ) ; goto createClosure ; } CASE ( CreateClosureLongIndex ) { idVal = ip -> iCreateClosureLongIndex . op3 ; nextIP = NEXTINST ( CreateClosureLongIndex ) ; goto createClosure ; } createClosure : { auto * runtimeModule = curCodeBlock -> getRuntimeModule ( ) ; CAPTURE_IP_ASSIGN ( O1REG ( CreateClosure ) , JSFunction : : create ( runtime , runtimeModule -> getDomain ( runtime ) , Handle < JSObject > : : vmcast ( & runtime -> functionPrototype ) , Handle < Environment > : : vmcast ( & O2REG ( CreateClosure ) ) , runtimeModule -> getCodeBlockMayAllocate ( idVal ) ) . getHermesValue ( ) ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } CASE ( CreateGeneratorClosure ) { CAPTURE_IP_ASSIGN ( auto res , createGeneratorClosure ( runtime , curCodeBlock -> getRuntimeModule ( ) , ip -> iCreateClosure . op3 , Handle < Environment > : : vmcast ( & O2REG ( CreateGeneratorClosure ) ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( CreateGeneratorClosure ) = res -> getHermesValue ( ) ; res -> invalidate ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( CreateGeneratorClosure ) ; DISPATCH ; } CASE ( CreateGeneratorClosureLongIndex ) { CAPTURE_IP_ASSIGN ( auto res , createGeneratorClosure ( runtime , curCodeBlock -> getRuntimeModule ( ) , ip -> iCreateClosureLongIndex . op3 , Handle < Environment > : : vmcast ( & O2REG ( CreateGeneratorClosureLongIndex ) ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( CreateGeneratorClosureLongIndex ) = res -> getHermesValue ( ) ; res -> invalidate ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( CreateGeneratorClosureLongIndex ) ; DISPATCH ; } CASE ( CreateGenerator ) { CAPTURE_IP_ASSIGN ( auto res , createGenerator_RJS ( runtime , curCodeBlock -> getRuntimeModule ( ) , ip -> iCreateGenerator . op3 , Handle < Environment > : : vmcast ( & O2REG ( CreateGenerator ) ) , FRAME . getNativeArgs ( ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( CreateGenerator ) = res -> getHermesValue ( ) ; res -> invalidate ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( CreateGenerator ) ; DISPATCH ; } CASE ( CreateGeneratorLongIndex ) { CAPTURE_IP_ASSIGN ( auto res , createGenerator_RJS ( runtime , curCodeBlock -> getRuntimeModule ( ) , ip -> iCreateGeneratorLongIndex . op3 , Handle < Environment > : : vmcast ( & O2REG ( CreateGeneratorLongIndex ) ) , FRAME . getNativeArgs ( ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( CreateGeneratorLongIndex ) = res -> getHermesValue ( ) ; res -> invalidate ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( CreateGeneratorLongIndex ) ; DISPATCH ; } CASE ( GetEnvironment ) { Environment * curEnv = FRAME . getCalleeClosureUnsafe ( ) -> getEnvironment ( runtime ) ; for ( unsigned level = ip -> iGetEnvironment . op2 ; level ; -- level ) { assert ( curEnv && \"invalid<S2SV_blank>environment<S2SV_blank>relative<S2SV_blank>level\" ) ; curEnv = curEnv -> getParentEnvironment ( runtime ) ; } O1REG ( GetEnvironment ) = HermesValue : : encodeObjectValue ( curEnv ) ; ip = NEXTINST ( GetEnvironment ) ; DISPATCH ; } CASE ( CreateEnvironment ) { tmpHandle = HermesValue : : encodeObjectValue ( FRAME . getCalleeClosureUnsafe ( ) -> getEnvironment ( runtime ) ) ; CAPTURE_IP_ASSIGN ( res , Environment : : create ( runtime , tmpHandle -> getPointer ( ) ? Handle < Environment > : : vmcast ( tmpHandle ) : Handle < Environment > : : vmcast_or_null ( & runtime -> nullPointer_ ) , curCodeBlock -> getEnvironmentSize ( ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } O1REG ( CreateEnvironment ) = * res ; # ifdef HERMES_ENABLE_DEBUGGER FRAME . getDebugEnvironmentRef ( ) = * res ; # endif tmpHandle = HermesValue : : encodeUndefinedValue ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( CreateEnvironment ) ; DISPATCH ; } CASE ( StoreToEnvironment ) { vmcast < Environment > ( O1REG ( StoreToEnvironment ) ) -> slot ( ip -> iStoreToEnvironment . op2 ) . set ( O3REG ( StoreToEnvironment ) , & runtime -> getHeap ( ) ) ; ip = NEXTINST ( StoreToEnvironment ) ; DISPATCH ; } CASE ( StoreToEnvironmentL ) { vmcast < Environment > ( O1REG ( StoreToEnvironmentL ) ) -> slot ( ip -> iStoreToEnvironmentL . op2 ) . set ( O3REG ( StoreToEnvironmentL ) , & runtime -> getHeap ( ) ) ; ip = NEXTINST ( StoreToEnvironmentL ) ; DISPATCH ; } CASE ( StoreNPToEnvironment ) { vmcast < Environment > ( O1REG ( StoreNPToEnvironment ) ) -> slot ( ip -> iStoreNPToEnvironment . op2 ) . setNonPtr ( O3REG ( StoreNPToEnvironment ) , & runtime -> getHeap ( ) ) ; ip = NEXTINST ( StoreNPToEnvironment ) ; DISPATCH ; } CASE ( StoreNPToEnvironmentL ) { vmcast < Environment > ( O1REG ( StoreNPToEnvironmentL ) ) -> slot ( ip -> iStoreNPToEnvironmentL . op2 ) . setNonPtr ( O3REG ( StoreNPToEnvironmentL ) , & runtime -> getHeap ( ) ) ; ip = NEXTINST ( StoreNPToEnvironmentL ) ; DISPATCH ; } CASE ( LoadFromEnvironment ) { O1REG ( LoadFromEnvironment ) = vmcast < Environment > ( O2REG ( LoadFromEnvironment ) ) -> slot ( ip -> iLoadFromEnvironment . op3 ) ; ip = NEXTINST ( LoadFromEnvironment ) ; DISPATCH ; } CASE ( LoadFromEnvironmentL ) { O1REG ( LoadFromEnvironmentL ) = vmcast < Environment > ( O2REG ( LoadFromEnvironmentL ) ) -> slot ( ip -> iLoadFromEnvironmentL . op3 ) ; ip = NEXTINST ( LoadFromEnvironmentL ) ; DISPATCH ; } CASE ( GetGlobalObject ) { O1REG ( GetGlobalObject ) = runtime -> global_ ; ip = NEXTINST ( GetGlobalObject ) ; DISPATCH ; } CASE ( GetNewTarget ) { O1REG ( GetNewTarget ) = FRAME . getNewTargetRef ( ) ; ip = NEXTINST ( GetNewTarget ) ; DISPATCH ; } CASE ( DeclareGlobalVar ) { DefinePropertyFlags dpf = DefinePropertyFlags : : getDefaultNewPropertyFlags ( ) ; dpf . configurable = 0 ; dpf . setValue = 0 ; CAPTURE_IP_ASSIGN ( auto res , JSObject : : defineOwnProperty ( runtime -> getGlobal ( ) , runtime , ID ( ip -> iDeclareGlobalVar . op1 ) , dpf , Runtime : : getUndefinedValue ( ) , PropOpFlags ( ) . plusThrowOnError ( ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { assert ( ! runtime -> getGlobal ( ) -> isProxyObject ( ) && \"global<S2SV_blank>can\\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>proxy<S2SV_blank>object\" ) ; NamedPropertyDescriptor desc ; CAPTURE_IP_ASSIGN ( auto res , JSObject : : getOwnNamedDescriptor ( runtime -> getGlobal ( ) , runtime , ID ( ip -> iDeclareGlobalVar . op1 ) , desc ) ) ; if ( ! res ) { goto exception ; } else { runtime -> clearThrownValue ( ) ; } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( DeclareGlobalVar ) ; DISPATCH ; } CASE ( TryGetByIdLong ) { tryProp = true ; idVal = ip -> iTryGetByIdLong . op4 ; nextIP = NEXTINST ( TryGetByIdLong ) ; goto getById ; } CASE ( GetByIdLong ) { tryProp = false ; idVal = ip -> iGetByIdLong . op4 ; nextIP = NEXTINST ( GetByIdLong ) ; goto getById ; } CASE ( GetByIdShort ) { tryProp = false ; idVal = ip -> iGetByIdShort . op4 ; nextIP = NEXTINST ( GetByIdShort ) ; goto getById ; } CASE ( TryGetById ) { tryProp = true ; idVal = ip -> iTryGetById . op4 ; nextIP = NEXTINST ( TryGetById ) ; goto getById ; } CASE ( GetById ) { tryProp = false ; idVal = ip -> iGetById . op4 ; nextIP = NEXTINST ( GetById ) ; } getById : { ++ NumGetById ; CallResult < HermesValue > propRes { ExecutionStatus : : EXCEPTION } ; if ( LLVM_LIKELY ( O2REG ( GetById ) . isObject ( ) ) ) { auto * obj = vmcast < JSObject > ( O2REG ( GetById ) ) ; auto cacheIdx = ip -> iGetById . op3 ; auto * cacheEntry = curCodeBlock -> getReadCacheEntry ( cacheIdx ) ; # ifdef HERMESVM_PROFILER_BB { HERMES_SLOW_ASSERT ( gcScope . getHandleCountDbg ( ) == KEEP_HANDLES && \"unaccounted<S2SV_blank>handles<S2SV_blank>were<S2SV_blank>created\" ) ; auto objHandle = runtime -> makeHandle ( obj ) ; auto cacheHCPtr = vmcast_or_null < HiddenClass > ( static_cast < GCCell * > ( cacheEntry -> clazz . get ( runtime , & runtime -> getHeap ( ) ) ) ) ; CAPTURE_IP ( runtime -> recordHiddenClass ( curCodeBlock , ip , ID ( idVal ) , obj -> getClass ( runtime ) , cacheHCPtr ) ) ; obj = objHandle . get ( ) ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; # endif auto clazzGCPtr = obj -> getClassGCPtr ( ) ; # ifndef NDEBUG if ( clazzGCPtr . get ( runtime ) -> isDictionary ( ) ) ++ NumGetByIdDict ; # else ( void ) NumGetByIdDict ; # endif if ( LLVM_LIKELY ( cacheEntry -> clazz == clazzGCPtr . getStorageType ( ) ) ) { ++ NumGetByIdCacheHits ; CAPTURE_IP_ASSIGN ( O1REG ( GetById ) , JSObject : : getNamedSlotValue < PropStorage : : Inline : : Yes > ( obj , runtime , cacheEntry -> slot ) ) ; ip = nextIP ; DISPATCH ; } auto id = ID ( idVal ) ; NamedPropertyDescriptor desc ; CAPTURE_IP_ASSIGN ( OptValue < bool > fastPathResult , JSObject : : tryGetOwnNamedDescriptorFast ( obj , runtime , id , desc ) ) ; if ( LLVM_LIKELY ( fastPathResult . hasValue ( ) && fastPathResult . getValue ( ) ) && ! desc . flags . accessor ) { ++ NumGetByIdFastPaths ; auto * clazz = clazzGCPtr . getNonNull ( runtime ) ; if ( LLVM_LIKELY ( ! clazz -> isDictionaryNoCache ( ) ) && LLVM_LIKELY ( cacheIdx != hbc : : PROPERTY_CACHING_DISABLED ) ) { # ifdef HERMES_SLOW_DEBUG if ( cacheEntry -> clazz && cacheEntry -> clazz != clazzGCPtr . getStorageType ( ) ) ++ NumGetByIdCacheEvicts ; # else ( void ) NumGetByIdCacheEvicts ; # endif cacheEntry -> clazz = clazzGCPtr . getStorageType ( ) ; cacheEntry -> slot = desc . slot ; } CAPTURE_IP_ASSIGN ( O1REG ( GetById ) , JSObject : : getNamedSlotValue ( obj , runtime , desc ) ) ; ip = nextIP ; DISPATCH ; } if ( fastPathResult . hasValue ( ) && ! fastPathResult . getValue ( ) && ! obj -> isProxyObject ( ) ) { CAPTURE_IP_ASSIGN ( JSObject * parent , obj -> getParent ( runtime ) ) ; if ( parent && cacheEntry -> clazz == parent -> getClassGCPtr ( ) . getStorageType ( ) && LLVM_LIKELY ( ! obj -> isLazy ( ) ) ) { ++ NumGetByIdProtoHits ; CAPTURE_IP_ASSIGN ( O1REG ( GetById ) , JSObject : : getNamedSlotValue ( parent , runtime , cacheEntry -> slot ) ) ; ip = nextIP ; DISPATCH ; } } # ifdef HERMES_SLOW_DEBUG CAPTURE_IP_ASSIGN ( JSObject * propObj , JSObject : : getNamedDescriptor ( Handle < JSObject > : : vmcast ( & O2REG ( GetById ) ) , runtime , id , desc ) ) ; if ( propObj ) { if ( desc . flags . accessor ) ++ NumGetByIdAccessor ; else if ( propObj != vmcast < JSObject > ( O2REG ( GetById ) ) ) ++ NumGetByIdProto ; } else { ++ NumGetByIdNotFound ; } # else ( void ) NumGetByIdAccessor ; ( void ) NumGetByIdProto ; ( void ) NumGetByIdNotFound ; # endif # ifdef HERMES_SLOW_DEBUG auto * savedClass = cacheIdx != hbc : : PROPERTY_CACHING_DISABLED ? cacheEntry -> clazz . get ( runtime , & runtime -> getHeap ( ) ) : nullptr ; # endif ++ NumGetByIdSlow ; CAPTURE_IP_ASSIGN ( resPH , JSObject : : getNamed_RJS ( Handle < JSObject > : : vmcast ( & O2REG ( GetById ) ) , runtime , id , ! tryProp ? defaultPropOpFlags : defaultPropOpFlags . plusMustExist ( ) , cacheIdx != hbc : : PROPERTY_CACHING_DISABLED ? cacheEntry : nullptr ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } # ifdef HERMES_SLOW_DEBUG if ( cacheIdx != hbc : : PROPERTY_CACHING_DISABLED && savedClass && cacheEntry -> clazz . get ( runtime , & runtime -> getHeap ( ) ) != savedClass ) { ++ NumGetByIdCacheEvicts ; } # endif } else { ++ NumGetByIdTransient ; assert ( ! tryProp && \"TryGetById<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>on<S2SV_blank>the<S2SV_blank>global<S2SV_blank>object\" ) ; CAPTURE_IP_ASSIGN ( resPH , Interpreter : : getByIdTransient_RJS ( runtime , Handle < > ( & O2REG ( GetById ) ) , ID ( idVal ) ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } } O1REG ( GetById ) = resPH -> get ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } CASE ( TryPutByIdLong ) { tryProp = true ; idVal = ip -> iTryPutByIdLong . op4 ; nextIP = NEXTINST ( TryPutByIdLong ) ; goto putById ; } CASE ( PutByIdLong ) { tryProp = false ; idVal = ip -> iPutByIdLong . op4 ; nextIP = NEXTINST ( PutByIdLong ) ; goto putById ; } CASE ( TryPutById ) { tryProp = true ; idVal = ip -> iTryPutById . op4 ; nextIP = NEXTINST ( TryPutById ) ; goto putById ; } CASE ( PutById ) { tryProp = false ; idVal = ip -> iPutById . op4 ; nextIP = NEXTINST ( PutById ) ; } putById : { ++ NumPutById ; if ( LLVM_LIKELY ( O1REG ( PutById ) . isObject ( ) ) ) { auto * obj = vmcast < JSObject > ( O1REG ( PutById ) ) ; auto cacheIdx = ip -> iPutById . op3 ; auto * cacheEntry = curCodeBlock -> getWriteCacheEntry ( cacheIdx ) ; # ifdef HERMESVM_PROFILER_BB { HERMES_SLOW_ASSERT ( gcScope . getHandleCountDbg ( ) == KEEP_HANDLES && \"unaccounted<S2SV_blank>handles<S2SV_blank>were<S2SV_blank>created\" ) ; auto objHandle = runtime -> makeHandle ( obj ) ; auto cacheHCPtr = vmcast_or_null < HiddenClass > ( static_cast < GCCell * > ( cacheEntry -> clazz . get ( runtime , & runtime -> getHeap ( ) ) ) ) ; CAPTURE_IP ( runtime -> recordHiddenClass ( curCodeBlock , ip , ID ( idVal ) , obj -> getClass ( runtime ) , cacheHCPtr ) ) ; obj = objHandle . get ( ) ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; # endif auto clazzGCPtr = obj -> getClassGCPtr ( ) ; if ( LLVM_LIKELY ( cacheEntry -> clazz == clazzGCPtr . getStorageType ( ) ) ) { ++ NumPutByIdCacheHits ; CAPTURE_IP ( JSObject : : setNamedSlotValue < PropStorage : : Inline : : Yes > ( obj , runtime , cacheEntry -> slot , O2REG ( PutById ) ) ) ; ip = nextIP ; DISPATCH ; } auto id = ID ( idVal ) ; NamedPropertyDescriptor desc ; CAPTURE_IP_ASSIGN ( OptValue < bool > hasOwnProp , JSObject : : tryGetOwnNamedDescriptorFast ( obj , runtime , id , desc ) ) ; if ( LLVM_LIKELY ( hasOwnProp . hasValue ( ) && hasOwnProp . getValue ( ) ) && ! desc . flags . accessor && desc . flags . writable && ! desc . flags . internalSetter ) { ++ NumPutByIdFastPaths ; auto * clazz = clazzGCPtr . getNonNull ( runtime ) ; if ( LLVM_LIKELY ( ! clazz -> isDictionary ( ) ) && LLVM_LIKELY ( cacheIdx != hbc : : PROPERTY_CACHING_DISABLED ) ) { # ifdef HERMES_SLOW_DEBUG if ( cacheEntry -> clazz && cacheEntry -> clazz != clazzGCPtr . getStorageType ( ) ) ++ NumPutByIdCacheEvicts ; # else ( void ) NumPutByIdCacheEvicts ; # endif cacheEntry -> clazz = clazzGCPtr . getStorageType ( ) ; cacheEntry -> slot = desc . slot ; } CAPTURE_IP ( JSObject : : setNamedSlotValue ( obj , runtime , desc . slot , O2REG ( PutById ) ) ) ; ip = nextIP ; DISPATCH ; } CAPTURE_IP_ASSIGN ( auto putRes , JSObject : : putNamed_RJS ( Handle < JSObject > : : vmcast ( & O1REG ( PutById ) ) , runtime , id , Handle < > ( & O2REG ( PutById ) ) , ! tryProp ? defaultPropOpFlags : defaultPropOpFlags . plusMustExist ( ) ) ) ; if ( LLVM_UNLIKELY ( putRes == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } } else { ++ NumPutByIdTransient ; assert ( ! tryProp && \"TryPutById<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>on<S2SV_blank>the<S2SV_blank>global<S2SV_blank>object\" ) ; CAPTURE_IP_ASSIGN ( auto retStatus , Interpreter : : putByIdTransient_RJS ( runtime , Handle < > ( & O1REG ( PutById ) ) , ID ( idVal ) , Handle < > ( & O2REG ( PutById ) ) , strictMode ) ) ; if ( retStatus == ExecutionStatus : : EXCEPTION ) { goto exception ; } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } CASE ( GetByVal ) { CallResult < HermesValue > propRes { ExecutionStatus : : EXCEPTION } ; if ( LLVM_LIKELY ( O2REG ( GetByVal ) . isObject ( ) ) ) { CAPTURE_IP_ASSIGN ( resPH , JSObject : : getComputed_RJS ( Handle < JSObject > : : vmcast ( & O2REG ( GetByVal ) ) , runtime , Handle < > ( & O3REG ( GetByVal ) ) ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } } else { CAPTURE_IP_ASSIGN ( resPH , Interpreter : : getByValTransient_RJS ( runtime , Handle < > ( & O2REG ( GetByVal ) ) , Handle < > ( & O3REG ( GetByVal ) ) ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( GetByVal ) = resPH -> get ( ) ; ip = NEXTINST ( GetByVal ) ; DISPATCH ; } CASE ( PutByVal ) { if ( LLVM_LIKELY ( O1REG ( PutByVal ) . isObject ( ) ) ) { CAPTURE_IP_ASSIGN ( auto putRes , JSObject : : putComputed_RJS ( Handle < JSObject > : : vmcast ( & O1REG ( PutByVal ) ) , runtime , Handle < > ( & O2REG ( PutByVal ) ) , Handle < > ( & O3REG ( PutByVal ) ) , defaultPropOpFlags ) ) ; if ( LLVM_UNLIKELY ( putRes == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } } else { CAPTURE_IP_ASSIGN ( auto retStatus , Interpreter : : putByValTransient_RJS ( runtime , Handle < > ( & O1REG ( PutByVal ) ) , Handle < > ( & O2REG ( PutByVal ) ) , Handle < > ( & O3REG ( PutByVal ) ) , strictMode ) ) ; if ( LLVM_UNLIKELY ( retStatus == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( PutByVal ) ; DISPATCH ; } CASE ( PutOwnByIndexL ) { nextIP = NEXTINST ( PutOwnByIndexL ) ; idVal = ip -> iPutOwnByIndexL . op3 ; goto putOwnByIndex ; } CASE ( PutOwnByIndex ) { nextIP = NEXTINST ( PutOwnByIndex ) ; idVal = ip -> iPutOwnByIndex . op3 ; } putOwnByIndex : { tmpHandle = HermesValue : : encodeDoubleValue ( idVal ) ; CAPTURE_IP ( JSObject : : defineOwnComputedPrimitive ( Handle < JSObject > : : vmcast ( & O1REG ( PutOwnByIndex ) ) , runtime , tmpHandle , DefinePropertyFlags : : getDefaultNewPropertyFlags ( ) , Handle < > ( & O2REG ( PutOwnByIndex ) ) ) ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; tmpHandle . clear ( ) ; ip = nextIP ; DISPATCH ; } CASE ( GetPNameList ) { CAPTURE_IP_ASSIGN ( auto pRes , handleGetPNameList ( runtime , frameRegs , ip ) ) ; if ( LLVM_UNLIKELY ( pRes == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( GetPNameList ) ; DISPATCH ; } CASE ( GetNextPName ) { { assert ( vmisa < BigStorage > ( O2REG ( GetNextPName ) ) && \"GetNextPName\\'s<S2SV_blank>second<S2SV_blank>op<S2SV_blank>must<S2SV_blank>be<S2SV_blank>BigStorage\" ) ; auto obj = Handle < JSObject > : : vmcast ( & O3REG ( GetNextPName ) ) ; auto arr = Handle < BigStorage > : : vmcast ( & O2REG ( GetNextPName ) ) ; uint32_t idx = O4REG ( GetNextPName ) . getNumber ( ) ; uint32_t size = O5REG ( GetNextPName ) . getNumber ( ) ; MutableHandle < JSObject > propObj { runtime } ; while ( idx < size ) { tmpHandle = arr -> at ( idx ) ; ComputedPropertyDescriptor desc ; CAPTURE_IP ( JSObject : : getComputedPrimitiveDescriptor ( obj , runtime , tmpHandle , propObj , desc ) ) ; if ( LLVM_LIKELY ( propObj ) ) break ; ++ idx ; } if ( idx < size ) { if ( tmpHandle -> isNumber ( ) ) { CAPTURE_IP_ASSIGN ( auto status , toString_RJS ( runtime , tmpHandle ) ) ; assert ( status == ExecutionStatus : : RETURNED && \"toString<S2SV_blank>on<S2SV_blank>number<S2SV_blank>cannot<S2SV_blank>fail\" ) ; tmpHandle = status -> getHermesValue ( ) ; } O1REG ( GetNextPName ) = tmpHandle . get ( ) ; O4REG ( GetNextPName ) = HermesValue : : encodeNumberValue ( idx + 1 ) ; } else { O1REG ( GetNextPName ) = HermesValue : : encodeUndefinedValue ( ) ; } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; tmpHandle . clear ( ) ; ip = NEXTINST ( GetNextPName ) ; DISPATCH ; } CASE ( ToNumber ) { if ( LLVM_LIKELY ( O2REG ( ToNumber ) . isNumber ( ) ) ) { O1REG ( ToNumber ) = O2REG ( ToNumber ) ; ip = NEXTINST ( ToNumber ) ; } else { CAPTURE_IP_ASSIGN ( res , toNumber_RJS ( runtime , Handle < > ( & O2REG ( ToNumber ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) goto exception ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( ToNumber ) = res . getValue ( ) ; ip = NEXTINST ( ToNumber ) ; } DISPATCH ; } CASE ( ToInt32 ) { CAPTURE_IP_ASSIGN ( res , toInt32_RJS ( runtime , Handle < > ( & O2REG ( ToInt32 ) ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) goto exception ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( ToInt32 ) = res . getValue ( ) ; ip = NEXTINST ( ToInt32 ) ; DISPATCH ; } CASE ( AddEmptyString ) { if ( LLVM_LIKELY ( O2REG ( AddEmptyString ) . isString ( ) ) ) { O1REG ( AddEmptyString ) = O2REG ( AddEmptyString ) ; ip = NEXTINST ( AddEmptyString ) ; } else { CAPTURE_IP_ASSIGN ( res , toPrimitive_RJS ( runtime , Handle < > ( & O2REG ( AddEmptyString ) ) , PreferredType : : NONE ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) goto exception ; tmpHandle = res . getValue ( ) ; CAPTURE_IP_ASSIGN ( auto strRes , toString_RJS ( runtime , tmpHandle ) ) ; if ( LLVM_UNLIKELY ( strRes == ExecutionStatus : : EXCEPTION ) ) goto exception ; tmpHandle . clear ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( AddEmptyString ) = strRes -> getHermesValue ( ) ; ip = NEXTINST ( AddEmptyString ) ; } DISPATCH ; } CASE ( Jmp ) { ip = IPADD ( ip -> iJmp . op1 ) ; DISPATCH ; } CASE ( JmpLong ) { ip = IPADD ( ip -> iJmpLong . op1 ) ; DISPATCH ; } CASE ( JmpTrue ) { if ( toBoolean ( O2REG ( JmpTrue ) ) ) ip = IPADD ( ip -> iJmpTrue . op1 ) ; else ip = NEXTINST ( JmpTrue ) ; DISPATCH ; } CASE ( JmpTrueLong ) { if ( toBoolean ( O2REG ( JmpTrueLong ) ) ) ip = IPADD ( ip -> iJmpTrueLong . op1 ) ; else ip = NEXTINST ( JmpTrueLong ) ; DISPATCH ; } CASE ( JmpFalse ) { if ( ! toBoolean ( O2REG ( JmpFalse ) ) ) ip = IPADD ( ip -> iJmpFalse . op1 ) ; else ip = NEXTINST ( JmpFalse ) ; DISPATCH ; } CASE ( JmpFalseLong ) { if ( ! toBoolean ( O2REG ( JmpFalseLong ) ) ) ip = IPADD ( ip -> iJmpFalseLong . op1 ) ; else ip = NEXTINST ( JmpFalseLong ) ; DISPATCH ; } CASE ( JmpUndefined ) { if ( O2REG ( JmpUndefined ) . isUndefined ( ) ) ip = IPADD ( ip -> iJmpUndefined . op1 ) ; else ip = NEXTINST ( JmpUndefined ) ; DISPATCH ; } CASE ( JmpUndefinedLong ) { if ( O2REG ( JmpUndefinedLong ) . isUndefined ( ) ) ip = IPADD ( ip -> iJmpUndefinedLong . op1 ) ; else ip = NEXTINST ( JmpUndefinedLong ) ; DISPATCH ; } CASE ( Add ) { if ( LLVM_LIKELY ( O2REG ( Add ) . isNumber ( ) && O3REG ( Add ) . isNumber ( ) ) ) { CASE ( AddN ) { O1REG ( Add ) = HermesValue : : encodeDoubleValue ( O2REG ( Add ) . getNumber ( ) + O3REG ( Add ) . getNumber ( ) ) ; ip = NEXTINST ( Add ) ; DISPATCH ; } } CAPTURE_IP_ASSIGN ( res , addOp_RJS ( runtime , Handle < > ( & O2REG ( Add ) ) , Handle < > ( & O3REG ( Add ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( Add ) = res . getValue ( ) ; ip = NEXTINST ( Add ) ; DISPATCH ; } CASE ( BitNot ) { if ( LLVM_LIKELY ( O2REG ( BitNot ) . isNumber ( ) ) ) { O1REG ( BitNot ) = HermesValue : : encodeDoubleValue ( ~ hermes : : truncateToInt32 ( O2REG ( BitNot ) . getNumber ( ) ) ) ; ip = NEXTINST ( BitNot ) ; DISPATCH ; } CAPTURE_IP_ASSIGN ( res , toInt32_RJS ( runtime , Handle < > ( & O2REG ( BitNot ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( BitNot ) = HermesValue : : encodeDoubleValue ( ~ static_cast < int32_t > ( res -> getNumber ( ) ) ) ; ip = NEXTINST ( BitNot ) ; DISPATCH ; } CASE ( GetArgumentsLength ) { if ( O2REG ( GetArgumentsLength ) . isUndefined ( ) ) { O1REG ( GetArgumentsLength ) = HermesValue : : encodeNumberValue ( FRAME . getArgCount ( ) ) ; ip = NEXTINST ( GetArgumentsLength ) ; DISPATCH ; } assert ( O2REG ( GetArgumentsLength ) . isObject ( ) && \"arguments<S2SV_blank>lazy<S2SV_blank>register<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>object\" ) ; CAPTURE_IP_ASSIGN ( resPH , JSObject : : getNamed_RJS ( Handle < JSObject > : : vmcast ( & O2REG ( GetArgumentsLength ) ) , runtime , Predefined : : getSymbolID ( Predefined : : length ) ) ) ; if ( resPH == ExecutionStatus : : EXCEPTION ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( GetArgumentsLength ) = resPH -> get ( ) ; ip = NEXTINST ( GetArgumentsLength ) ; DISPATCH ; } CASE ( GetArgumentsPropByVal ) { if ( O3REG ( GetArgumentsPropByVal ) . isUndefined ( ) ) { if ( auto index = toArrayIndexFastPath ( O2REG ( GetArgumentsPropByVal ) ) ) { if ( * index < FRAME . getArgCount ( ) ) { O1REG ( GetArgumentsPropByVal ) = FRAME . getArgRef ( * index ) ; ip = NEXTINST ( GetArgumentsPropByVal ) ; DISPATCH ; } } } CAPTURE_IP_ASSIGN ( auto res , getArgumentsPropByValSlowPath_RJS ( runtime , & O3REG ( GetArgumentsPropByVal ) , & O2REG ( GetArgumentsPropByVal ) , FRAME . getCalleeClosureHandleUnsafe ( ) , strictMode ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( GetArgumentsPropByVal ) = res -> getHermesValue ( ) ; ip = NEXTINST ( GetArgumentsPropByVal ) ; DISPATCH ; } CASE ( ReifyArguments ) { if ( ! O1REG ( ReifyArguments ) . isUndefined ( ) ) { assert ( O1REG ( ReifyArguments ) . isObject ( ) && \"arguments<S2SV_blank>lazy<S2SV_blank>register<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>object\" ) ; ip = NEXTINST ( ReifyArguments ) ; DISPATCH ; } CAPTURE_IP_ASSIGN ( resArgs , reifyArgumentsSlowPath ( runtime , FRAME . getCalleeClosureHandleUnsafe ( ) , strictMode ) ) ; if ( LLVM_UNLIKELY ( resArgs == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( ReifyArguments ) = resArgs -> getHermesValue ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( ReifyArguments ) ; DISPATCH ; } CASE ( NewObject ) { CAPTURE_IP_ASSIGN ( O1REG ( NewObject ) , JSObject : : create ( runtime ) . getHermesValue ( ) ) ; assert ( gcScope . getHandleCountDbg ( ) == KEEP_HANDLES && \"Should<S2SV_blank>not<S2SV_blank>create<S2SV_blank>handles.\" ) ; ip = NEXTINST ( NewObject ) ; DISPATCH ; } CASE ( NewObjectWithParent ) { CAPTURE_IP_ASSIGN ( O1REG ( NewObjectWithParent ) , JSObject : : create ( runtime , O2REG ( NewObjectWithParent ) . isObject ( ) ? Handle < JSObject > : : vmcast ( & O2REG ( NewObjectWithParent ) ) : O2REG ( NewObjectWithParent ) . isNull ( ) ? Runtime : : makeNullHandle < JSObject > ( ) : Handle < JSObject > : : vmcast ( & runtime -> objectPrototype ) ) . getHermesValue ( ) ) ; assert ( gcScope . getHandleCountDbg ( ) == KEEP_HANDLES && \"Should<S2SV_blank>not<S2SV_blank>create<S2SV_blank>handles.\" ) ; ip = NEXTINST ( NewObjectWithParent ) ; DISPATCH ; } CASE ( NewObjectWithBuffer ) { CAPTURE_IP_ASSIGN ( resPH , Interpreter : : createObjectFromBuffer ( runtime , curCodeBlock , ip -> iNewObjectWithBuffer . op3 , ip -> iNewObjectWithBuffer . op4 , ip -> iNewObjectWithBuffer . op5 ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( NewObjectWithBuffer ) = resPH -> get ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( NewObjectWithBuffer ) ; DISPATCH ; } CASE ( NewObjectWithBufferLong ) { CAPTURE_IP_ASSIGN ( resPH , Interpreter : : createObjectFromBuffer ( runtime , curCodeBlock , ip -> iNewObjectWithBufferLong . op3 , ip -> iNewObjectWithBufferLong . op4 , ip -> iNewObjectWithBufferLong . op5 ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( NewObjectWithBufferLong ) = resPH -> get ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( NewObjectWithBufferLong ) ; DISPATCH ; } CASE ( NewArray ) { CAPTURE_IP_ASSIGN ( auto createRes , JSArray : : create ( runtime , ip -> iNewArray . op2 , ip -> iNewArray . op2 ) ) ; if ( createRes == ExecutionStatus : : EXCEPTION ) { goto exception ; } O1REG ( NewArray ) = createRes -> getHermesValue ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( NewArray ) ; DISPATCH ; } CASE ( NewArrayWithBuffer ) { CAPTURE_IP_ASSIGN ( resPH , Interpreter : : createArrayFromBuffer ( runtime , curCodeBlock , ip -> iNewArrayWithBuffer . op2 , ip -> iNewArrayWithBuffer . op3 , ip -> iNewArrayWithBuffer . op4 ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( NewArrayWithBuffer ) = resPH -> get ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; tmpHandle . clear ( ) ; ip = NEXTINST ( NewArrayWithBuffer ) ; DISPATCH ; } CASE ( NewArrayWithBufferLong ) { CAPTURE_IP_ASSIGN ( resPH , Interpreter : : createArrayFromBuffer ( runtime , curCodeBlock , ip -> iNewArrayWithBufferLong . op2 , ip -> iNewArrayWithBufferLong . op3 , ip -> iNewArrayWithBufferLong . op4 ) ) ; if ( LLVM_UNLIKELY ( resPH == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( NewArrayWithBufferLong ) = resPH -> get ( ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; tmpHandle . clear ( ) ; ip = NEXTINST ( NewArrayWithBufferLong ) ; DISPATCH ; } CASE ( CreateThis ) { if ( LLVM_UNLIKELY ( ! vmisa < Callable > ( O3REG ( CreateThis ) ) ) ) { CAPTURE_IP ( runtime -> raiseTypeError ( \"constructor<S2SV_blank>is<S2SV_blank>not<S2SV_blank>callable\" ) ) ; goto exception ; } CAPTURE_IP_ASSIGN ( auto res , Callable : : newObject ( Handle < Callable > : : vmcast ( & O3REG ( CreateThis ) ) , runtime , Handle < JSObject > : : vmcast ( O2REG ( CreateThis ) . isObject ( ) ? & O2REG ( CreateThis ) : & runtime -> objectPrototype ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( CreateThis ) = res -> getHermesValue ( ) ; ip = NEXTINST ( CreateThis ) ; DISPATCH ; } CASE ( SelectObject ) { O1REG ( SelectObject ) = O3REG ( SelectObject ) . isObject ( ) ? O3REG ( SelectObject ) : O2REG ( SelectObject ) ; ip = NEXTINST ( SelectObject ) ; DISPATCH ; } CASE ( Eq ) CASE ( Neq ) { CAPTURE_IP_ASSIGN ( res , abstractEqualityTest_RJS ( runtime , Handle < > ( & O2REG ( Eq ) ) , Handle < > ( & O3REG ( Eq ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( Eq ) = ip -> opCode == OpCode : : Eq ? res . getValue ( ) : HermesValue : : encodeBoolValue ( ! res -> getBool ( ) ) ; ip = NEXTINST ( Eq ) ; DISPATCH ; } CASE ( StrictEq ) { O1REG ( StrictEq ) = HermesValue : : encodeBoolValue ( strictEqualityTest ( O2REG ( StrictEq ) , O3REG ( StrictEq ) ) ) ; ip = NEXTINST ( StrictEq ) ; DISPATCH ; } CASE ( StrictNeq ) { O1REG ( StrictNeq ) = HermesValue : : encodeBoolValue ( ! strictEqualityTest ( O2REG ( StrictNeq ) , O3REG ( StrictNeq ) ) ) ; ip = NEXTINST ( StrictNeq ) ; DISPATCH ; } CASE ( Not ) { O1REG ( Not ) = HermesValue : : encodeBoolValue ( ! toBoolean ( O2REG ( Not ) ) ) ; ip = NEXTINST ( Not ) ; DISPATCH ; } CASE ( Negate ) { if ( LLVM_LIKELY ( O2REG ( Negate ) . isNumber ( ) ) ) { O1REG ( Negate ) = HermesValue : : encodeDoubleValue ( - O2REG ( Negate ) . getNumber ( ) ) ; } else { CAPTURE_IP_ASSIGN ( res , toNumber_RJS ( runtime , Handle < > ( & O2REG ( Negate ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) goto exception ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; O1REG ( Negate ) = HermesValue : : encodeDoubleValue ( - res -> getNumber ( ) ) ; } ip = NEXTINST ( Negate ) ; DISPATCH ; } CASE ( TypeOf ) { CAPTURE_IP_ASSIGN ( O1REG ( TypeOf ) , typeOf ( runtime , Handle < > ( & O2REG ( TypeOf ) ) ) ) ; ip = NEXTINST ( TypeOf ) ; DISPATCH ; } CASE ( Mod ) { if ( LLVM_LIKELY ( O2REG ( Mod ) . isNumber ( ) && O3REG ( Mod ) . isNumber ( ) ) ) { O1REG ( Mod ) = HermesValue : : encodeDoubleValue ( std : : fmod ( O2REG ( Mod ) . getNumber ( ) , O3REG ( Mod ) . getNumber ( ) ) ) ; ip = NEXTINST ( Mod ) ; DISPATCH ; } CAPTURE_IP_ASSIGN ( res , toNumber_RJS ( runtime , Handle < > ( & O2REG ( Mod ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) goto exception ; double left = res -> getDouble ( ) ; CAPTURE_IP_ASSIGN ( res , toNumber_RJS ( runtime , Handle < > ( & O3REG ( Mod ) ) ) ) ; if ( res == ExecutionStatus : : EXCEPTION ) goto exception ; O1REG ( Mod ) = HermesValue : : encodeDoubleValue ( std : : fmod ( left , res -> getDouble ( ) ) ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( Mod ) ; DISPATCH ; } CASE ( InstanceOf ) { CAPTURE_IP_ASSIGN ( auto result , instanceOfOperator_RJS ( runtime , Handle < > ( & O2REG ( InstanceOf ) ) , Handle < > ( & O3REG ( InstanceOf ) ) ) ) ; if ( LLVM_UNLIKELY ( result == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( InstanceOf ) = HermesValue : : encodeBoolValue ( * result ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( InstanceOf ) ; DISPATCH ; } CASE ( IsIn ) { { if ( LLVM_UNLIKELY ( ! O3REG ( IsIn ) . isObject ( ) ) ) { CAPTURE_IP ( runtime -> raiseTypeError ( \"right<S2SV_blank>operand<S2SV_blank>of<S2SV_blank>\\'in\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>object\" ) ) ; goto exception ; } CAPTURE_IP_ASSIGN ( auto cr , JSObject : : hasComputed ( Handle < JSObject > : : vmcast ( & O3REG ( IsIn ) ) , runtime , Handle < > ( & O2REG ( IsIn ) ) ) ) ; if ( cr == ExecutionStatus : : EXCEPTION ) { goto exception ; } O1REG ( IsIn ) = HermesValue : : encodeBoolValue ( * cr ) ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( IsIn ) ; DISPATCH ; } CASE ( PutNewOwnByIdShort ) { nextIP = NEXTINST ( PutNewOwnByIdShort ) ; idVal = ip -> iPutNewOwnByIdShort . op3 ; goto putOwnById ; } CASE ( PutNewOwnNEByIdLong ) CASE ( PutNewOwnByIdLong ) { nextIP = NEXTINST ( PutNewOwnByIdLong ) ; idVal = ip -> iPutNewOwnByIdLong . op3 ; goto putOwnById ; } CASE ( PutNewOwnNEById ) CASE ( PutNewOwnById ) { nextIP = NEXTINST ( PutNewOwnById ) ; idVal = ip -> iPutNewOwnById . op3 ; } putOwnById : { assert ( O1REG ( PutNewOwnById ) . isObject ( ) && \"Object<S2SV_blank>argument<S2SV_blank>of<S2SV_blank>PutNewOwnById<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>object\" ) ; CAPTURE_IP_ASSIGN ( auto res , JSObject : : defineNewOwnProperty ( Handle < JSObject > : : vmcast ( & O1REG ( PutNewOwnById ) ) , runtime , ID ( idVal ) , ip -> opCode <= OpCode : : PutNewOwnByIdLong ? PropertyFlags : : defaultNewNamedPropertyFlags ( ) : PropertyFlags : : nonEnumerablePropertyFlags ( ) , Handle < > ( & O2REG ( PutNewOwnById ) ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } CASE ( DelByIdLong ) { idVal = ip -> iDelByIdLong . op3 ; nextIP = NEXTINST ( DelByIdLong ) ; goto DelById ; } CASE ( DelById ) { idVal = ip -> iDelById . op3 ; nextIP = NEXTINST ( DelById ) ; } DelById : { if ( LLVM_LIKELY ( O2REG ( DelById ) . isObject ( ) ) ) { CAPTURE_IP_ASSIGN ( auto status , JSObject : : deleteNamed ( Handle < JSObject > : : vmcast ( & O2REG ( DelById ) ) , runtime , ID ( idVal ) , defaultPropOpFlags ) ) ; if ( LLVM_UNLIKELY ( status == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( DelById ) = HermesValue : : encodeBoolValue ( status . getValue ( ) ) ; } else { CAPTURE_IP_ASSIGN ( res , toObject ( runtime , Handle < > ( & O2REG ( DelById ) ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { CAPTURE_IP ( amendPropAccessErrorMsgWithPropName ( runtime , Handle < > ( & O2REG ( DelById ) ) , \"delete\" , ID ( idVal ) ) ) ; goto exception ; } tmpHandle = res . getValue ( ) ; CAPTURE_IP_ASSIGN ( auto status , JSObject : : deleteNamed ( Handle < JSObject > : : vmcast ( tmpHandle ) , runtime , ID ( idVal ) , defaultPropOpFlags ) ) ; if ( LLVM_UNLIKELY ( status == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( DelById ) = HermesValue : : encodeBoolValue ( status . getValue ( ) ) ; tmpHandle . clear ( ) ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = nextIP ; DISPATCH ; } CASE ( DelByVal ) { if ( LLVM_LIKELY ( O2REG ( DelByVal ) . isObject ( ) ) ) { CAPTURE_IP_ASSIGN ( auto status , JSObject : : deleteComputed ( Handle < JSObject > : : vmcast ( & O2REG ( DelByVal ) ) , runtime , Handle < > ( & O3REG ( DelByVal ) ) , defaultPropOpFlags ) ) ; if ( LLVM_UNLIKELY ( status == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( DelByVal ) = HermesValue : : encodeBoolValue ( status . getValue ( ) ) ; } else { CAPTURE_IP_ASSIGN ( res , toObject ( runtime , Handle < > ( & O2REG ( DelByVal ) ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } tmpHandle = res . getValue ( ) ; CAPTURE_IP_ASSIGN ( auto status , JSObject : : deleteComputed ( Handle < JSObject > : : vmcast ( tmpHandle ) , runtime , Handle < > ( & O3REG ( DelByVal ) ) , defaultPropOpFlags ) ) ; if ( LLVM_UNLIKELY ( status == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( DelByVal ) = HermesValue : : encodeBoolValue ( status . getValue ( ) ) ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; tmpHandle . clear ( ) ; ip = NEXTINST ( DelByVal ) ; DISPATCH ; } CASE ( CreateRegExp ) { { CAPTURE_IP_ASSIGN ( auto re , JSRegExp : : create ( runtime ) ) ; CAPTURE_IP_ASSIGN ( auto pattern , runtime -> makeHandle ( curCodeBlock -> getRuntimeModule ( ) -> getStringPrimFromStringIDMayAllocate ( ip -> iCreateRegExp . op2 ) ) ) ; CAPTURE_IP_ASSIGN ( auto flags , runtime -> makeHandle ( curCodeBlock -> getRuntimeModule ( ) -> getStringPrimFromStringIDMayAllocate ( ip -> iCreateRegExp . op3 ) ) ) ; CAPTURE_IP_ASSIGN ( auto bytecode , curCodeBlock -> getRuntimeModule ( ) -> getRegExpBytecodeFromRegExpID ( ip -> iCreateRegExp . op4 ) ) ; CAPTURE_IP_ASSIGN ( auto initRes , JSRegExp : : initialize ( re , runtime , pattern , flags , bytecode ) ) ; if ( LLVM_UNLIKELY ( initRes == ExecutionStatus : : EXCEPTION ) ) { goto exception ; } O1REG ( CreateRegExp ) = re . getHermesValue ( ) ; } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; ip = NEXTINST ( CreateRegExp ) ; DISPATCH ; } CASE ( SwitchImm ) { if ( LLVM_LIKELY ( O1REG ( SwitchImm ) . isNumber ( ) ) ) { double numVal = O1REG ( SwitchImm ) . getNumber ( ) ; uint32_t uintVal = ( uint32_t ) numVal ; if ( LLVM_LIKELY ( numVal == uintVal ) && LLVM_LIKELY ( uintVal >= ip -> iSwitchImm . op4 ) && LLVM_LIKELY ( uintVal <= ip -> iSwitchImm . op5 ) ) { const uint8_t * tablestart = ( const uint8_t * ) llvh : : alignAddr ( ( const uint8_t * ) ip + ip -> iSwitchImm . op2 , sizeof ( uint32_t ) ) ; const int32_t * loc = ( const int32_t * ) tablestart + uintVal - ip -> iSwitchImm . op4 ; ip = IPADD ( * loc ) ; DISPATCH ; } } ip = IPADD ( ip -> iSwitchImm . op3 ) ; DISPATCH ; } LOAD_CONST ( LoadConstUInt8 , HermesValue : : encodeDoubleValue ( ip -> iLoadConstUInt8 . op2 ) ) ; LOAD_CONST ( LoadConstInt , HermesValue : : encodeDoubleValue ( ip -> iLoadConstInt . op2 ) ) ; LOAD_CONST ( LoadConstDouble , HermesValue : : encodeDoubleValue ( ip -> iLoadConstDouble . op2 ) ) ; LOAD_CONST_CAPTURE_IP ( LoadConstString , HermesValue : : encodeStringValue ( curCodeBlock -> getRuntimeModule ( ) -> getStringPrimFromStringIDMayAllocate ( ip -> iLoadConstString . op2 ) ) ) ; LOAD_CONST_CAPTURE_IP ( LoadConstStringLongIndex , HermesValue : : encodeStringValue ( curCodeBlock -> getRuntimeModule ( ) -> getStringPrimFromStringIDMayAllocate ( ip -> iLoadConstStringLongIndex . op2 ) ) ) ; LOAD_CONST ( LoadConstUndefined , HermesValue : : encodeUndefinedValue ( ) ) ; LOAD_CONST ( LoadConstNull , HermesValue : : encodeNullValue ( ) ) ; LOAD_CONST ( LoadConstTrue , HermesValue : : encodeBoolValue ( true ) ) ; LOAD_CONST ( LoadConstFalse , HermesValue : : encodeBoolValue ( false ) ) ; LOAD_CONST ( LoadConstZero , HermesValue : : encodeDoubleValue ( 0 ) ) ; BINOP ( Sub , doSub ) ; BINOP ( Mul , doMult ) ; BINOP ( Div , doDiv ) ; BITWISEBINOP ( BitAnd , & ) ; BITWISEBINOP ( BitOr , | ) ; BITWISEBINOP ( BitXor , ^ ) ; SHIFTOP ( LShift , << , toUInt32_RJS , uint32_t , int32_t ) ; SHIFTOP ( RShift , >> , toInt32_RJS , int32_t , int32_t ) ; SHIFTOP ( URshift , >> , toUInt32_RJS , uint32_t , uint32_t ) ; CONDOP ( Less , < , lessOp_RJS ) ; CONDOP ( LessEq , <= , lessEqualOp_RJS ) ; CONDOP ( Greater , > , greaterOp_RJS ) ; CONDOP ( GreaterEq , >= , greaterEqualOp_RJS ) ; JCOND ( Less , < , lessOp_RJS ) ; JCOND ( LessEqual , <= , lessEqualOp_RJS ) ; JCOND ( Greater , > , greaterOp_RJS ) ; JCOND ( GreaterEqual , >= , greaterEqualOp_RJS ) ; JCOND_STRICT_EQ_IMPL ( JStrictEqual , , IPADD ( ip -> iJStrictEqual . op1 ) , NEXTINST ( JStrictEqual ) ) ; JCOND_STRICT_EQ_IMPL ( JStrictEqual , Long , IPADD ( ip -> iJStrictEqualLong . op1 ) , NEXTINST ( JStrictEqualLong ) ) ; JCOND_STRICT_EQ_IMPL ( JStrictNotEqual , , NEXTINST ( JStrictNotEqual ) , IPADD ( ip -> iJStrictNotEqual . op1 ) ) ; JCOND_STRICT_EQ_IMPL ( JStrictNotEqual , Long , NEXTINST ( JStrictNotEqualLong ) , IPADD ( ip -> iJStrictNotEqualLong . op1 ) ) ; JCOND_EQ_IMPL ( JEqual , , IPADD ( ip -> iJEqual . op1 ) , NEXTINST ( JEqual ) ) ; JCOND_EQ_IMPL ( JEqual , Long , IPADD ( ip -> iJEqualLong . op1 ) , NEXTINST ( JEqualLong ) ) ; JCOND_EQ_IMPL ( JNotEqual , , NEXTINST ( JNotEqual ) , IPADD ( ip -> iJNotEqual . op1 ) ) ; JCOND_EQ_IMPL ( JNotEqual , Long , NEXTINST ( JNotEqualLong ) , IPADD ( ip -> iJNotEqualLong . op1 ) ) ; CASE_OUTOFLINE ( PutOwnByVal ) ; CASE_OUTOFLINE ( PutOwnGetterSetterByVal ) ; CASE_OUTOFLINE ( DirectEval ) ; CASE_OUTOFLINE ( IteratorBegin ) ; CASE_OUTOFLINE ( IteratorNext ) ; CASE ( IteratorClose ) { if ( LLVM_UNLIKELY ( O1REG ( IteratorClose ) . isObject ( ) ) ) { CAPTURE_IP_ASSIGN ( auto res , iteratorClose ( runtime , Handle < JSObject > : : vmcast ( & O1REG ( IteratorClose ) ) , Runtime : : getEmptyValue ( ) ) ) ; if ( LLVM_UNLIKELY ( res == ExecutionStatus : : EXCEPTION ) ) { if ( ip -> iIteratorClose . op2 && ! isUncatchableError ( runtime -> thrownValue_ ) ) { runtime -> clearThrownValue ( ) ; } else { goto exception ; } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; } ip = NEXTINST ( IteratorClose ) ; DISPATCH ; } CASE ( _last ) { llvm_unreachable ( \"Invalid<S2SV_blank>opcode<S2SV_blank>_last\" ) ; } } llvm_unreachable ( \"unreachable\" ) ; stackOverflow : CAPTURE_IP ( runtime -> raiseStackOverflow ( Runtime : : StackOverflowKind : : JSRegisterStack ) ) ; handleExceptionInParent : curCodeBlock = FRAME . getSavedCodeBlock ( ) ; ip = FRAME . getSavedIP ( ) ; frameRegs = & runtime -> restoreStackAndPreviousFrame ( FRAME ) . getFirstLocalRef ( ) ; if ( ! curCodeBlock ) return ExecutionStatus : : EXCEPTION ; # ifdef HERMESVM_PROFILER_EXTERN return ExecutionStatus : : EXCEPTION ; # endif exception : UPDATE_OPCODE_TIME_SPENT ; assert ( ! runtime -> thrownValue_ . isEmpty ( ) && \"thrownValue<S2SV_blank>unavailable<S2SV_blank>at<S2SV_blank>exception\" ) ; bool catchable = true ; if ( auto * jsError = dyn_vmcast < JSError > ( runtime -> thrownValue_ ) ) { catchable = jsError -> catchable ( ) ; if ( ! jsError -> getStackTrace ( ) ) { CAPTURE_IP_ASSIGN ( auto errorHandle , runtime -> makeHandle ( vmcast < JSError > ( runtime -> thrownValue_ ) ) ) ; runtime -> clearThrownValue ( ) ; CAPTURE_IP ( JSError : : recordStackTrace ( errorHandle , runtime , false , curCodeBlock , ip ) ) ; runtime -> setThrownValue ( errorHandle . getHermesValue ( ) ) ; } } gcScope . flushToSmallCount ( KEEP_HANDLES ) ; tmpHandle . clear ( ) ; # ifdef HERMES_ENABLE_DEBUGGER if ( SingleStep ) { state . codeBlock = curCodeBlock ; state . offset = CUROFFSET ; return ExecutionStatus : : EXCEPTION ; } using PauseOnThrowMode = facebook : : hermes : : debugger : : PauseOnThrowMode ; auto mode = runtime -> debugger_ . getPauseOnThrowMode ( ) ; if ( mode != PauseOnThrowMode : : None ) { if ( ! runtime -> debugger_ . isDebugging ( ) ) { bool caught = runtime -> debugger_ . findCatchTarget ( InterpreterState ( curCodeBlock , CUROFFSET ) ) . hasValue ( ) ; bool shouldStop = mode == PauseOnThrowMode : : All || ( mode == PauseOnThrowMode : : Uncaught && ! caught ) ; if ( shouldStop ) { InterpreterState tmpState { curCodeBlock , ( uint32_t ) CUROFFSET } ; CAPTURE_IP_ASSIGN ( ExecutionStatus resultStatus , runtime -> debugger_ . runDebugger ( Debugger : : RunReason : : Exception , tmpState ) ) ; ( void ) resultStatus ; assert ( tmpState == InterpreterState ( curCodeBlock , CUROFFSET ) && \"not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>step<S2SV_blank>internally<S2SV_blank>in<S2SV_blank>a<S2SV_blank>pauseOnThrow\" ) ; gcScope . flushToSmallCount ( KEEP_HANDLES ) ; } } } # endif int32_t handlerOffset = 0 ; while ( ( ( handlerOffset = curCodeBlock -> findCatchTargetOffset ( CUROFFSET ) ) == - 1 ) || ! catchable ) { PROFILER_EXIT_FUNCTION ( curCodeBlock ) ; # ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES runtime -> popCallStack ( ) ; # endif curCodeBlock = FRAME . getSavedCodeBlock ( ) ; ip = FRAME . getSavedIP ( ) ; frameRegs = & runtime -> restoreStackAndPreviousFrame ( FRAME ) . getFirstLocalRef ( ) ; SLOW_DEBUG ( dbgs ( ) << \"function<S2SV_blank>exit<S2SV_blank>with<S2SV_blank>exception:<S2SV_blank>restored<S2SV_blank>stackLevel=\" << runtime -> getStackLevel ( ) << \"\\\\n\" ) ; if ( ! curCodeBlock ) { SLOW_DEBUG ( dbgs ( ) << \"function<S2SV_blank>exit<S2SV_blank>with<S2SV_blank>exception:<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>native<S2SV_blank>code\\\\n\" ) ; return ExecutionStatus : : EXCEPTION ; } assert ( isCallType ( ip -> opCode ) && \"return<S2SV_blank>address<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Call-type<S2SV_blank>instruction\" ) ; # ifdef HERMESVM_PROFILER_EXTERN return ExecutionStatus : : EXCEPTION ; # endif } INIT_STATE_FOR_CODEBLOCK ( curCodeBlock ) ; ip = IPADD ( handlerOffset - CUROFFSET ) ; } }", "target": "<S2SV_ModStart> ; # endif # define DONT_CAPTURE_IP ( expr ) do { NoAllocScope noAlloc ( runtime ) ; ( void ) expr ; } while ( false ) <S2SV_ModStart> SaveGenerator ) { DONT_CAPTURE_IP ( saveGenerator ( runtime , frameRegs , <S2SV_ModEnd> IPADD ( ip <S2SV_ModStart> . op1 ) ) ) ; ip = NEXTINST ( SaveGenerator ) ; DISPATCH <S2SV_ModEnd> ; } CASE <S2SV_ModStart> SaveGeneratorLong ) { DONT_CAPTURE_IP ( saveGenerator ( runtime , frameRegs , <S2SV_ModEnd> IPADD ( ip <S2SV_ModStart> . op1 ) ) <S2SV_ModEnd> ) ; ip <S2SV_ModStart> = NEXTINST ( SaveGeneratorLong <S2SV_ModEnd> ) ; DISPATCH"}
{"source": "CWE-369 rfbSendRectEncodingRaw ( rfbClientPtr cl , int x , int y , int w , int h ) { rfbFramebufferUpdateRectHeader rect ; int nlines ; int bytesPerLine = w * ( cl -> format . bitsPerPixel / 8 ) ; char * fbptr = ( cl -> scaledScreen -> frameBuffer + ( cl -> scaledScreen -> paddedWidthInBytes * y ) + ( x * ( cl -> scaledScreen -> bitsPerPixel / 8 ) ) ) ; <S2SV_StartBug> if ( cl -> ublen > 0 ) { <S2SV_EndBug> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ; } rect . r . x = Swap16IfLE ( x ) ; rect . r . y = Swap16IfLE ( y ) ; rect . r . w = Swap16IfLE ( w ) ; rect . r . h = Swap16IfLE ( h ) ; rect . encoding = Swap32IfLE ( rfbEncodingRaw ) ; memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ; cl -> ublen += sz_rfbFramebufferUpdateRectHeader ; rfbStatRecordEncodingSent ( cl , rfbEncodingRaw , sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h , sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h ) ; nlines = ( UPDATE_BUF_SIZE - cl -> ublen ) / bytesPerLine ; while ( TRUE ) { if ( nlines > h ) nlines = h ; ( * cl -> translateFn ) ( cl -> translateLookupTable , & ( cl -> screen -> serverFormat ) , & cl -> format , fbptr , & cl -> updateBuf [ cl -> ublen ] , cl -> scaledScreen -> paddedWidthInBytes , w , nlines ) ; cl -> ublen += nlines * bytesPerLine ; h -= nlines ; if ( h == 0 ) return TRUE ; if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ; fbptr += ( cl -> scaledScreen -> paddedWidthInBytes * nlines ) ; nlines = ( UPDATE_BUF_SIZE - cl -> ublen ) / bytesPerLine ; if ( nlines == 0 ) { rfbErr ( \"rfbSendRectEncodingRaw:<S2SV_blank>send<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>\" \"bytes<S2SV_blank>per<S2SV_blank>line\\\\n\" , bytesPerLine ) ; rfbCloseClient ( cl ) ; return FALSE ; } } }", "target": "<S2SV_ModStart> ; if ( ! h || ! w ) return TRUE ; if ("}
{"source": "CWE-125 pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ; <S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> PIXCMAP * cmap , * cmapd ; PROCNAME ( \"pixFewColorsOctcubeQuantMixed\" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( \"pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp\" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( \"invalid<S2SV_blank>level\" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ; <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( \"too<S2SV_blank>many<S2SV_blank>colors\" , procName , NULL ) ; <S2SV_EndBug> cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }", "target": "<S2SV_ModStart> lined ; PIX * pix1 , <S2SV_ModStart> if ( ( pix1 <S2SV_ModEnd> = pixFewColorsOctcubeQuant1 ( <S2SV_ModStart> procName , NULL ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1"}
{"source": "CWE-787 void rfbScaledScreenUpdateRect ( rfbScreenInfoPtr screen , rfbScreenInfoPtr ptr , int x0 , int y0 , int w0 , int h0 ) { int x , y , w , v , z ; int x1 , y1 , w1 , h1 ; int bitsPerPixel , bytesPerPixel , bytesPerLine , areaX , areaY , area2 ; unsigned char * srcptr , * dstptr ; if ( screen == ptr ) return ; x1 = x0 ; y1 = y0 ; w1 = w0 ; h1 = h0 ; rfbScaledCorrection ( screen , ptr , & x1 , & y1 , & w1 , & h1 , \"rfbScaledScreenUpdateRect\" ) ; x0 = ScaleX ( ptr , screen , x1 ) ; y0 = ScaleY ( ptr , screen , y1 ) ; w0 = ScaleX ( ptr , screen , w1 ) ; h0 = ScaleY ( ptr , screen , h1 ) ; bitsPerPixel = screen -> bitsPerPixel ; bytesPerPixel = bitsPerPixel / 8 ; bytesPerLine = w1 * bytesPerPixel ; srcptr = ( unsigned char * ) ( screen -> frameBuffer + ( y0 * screen -> paddedWidthInBytes + x0 * bytesPerPixel ) ) ; dstptr = ( unsigned char * ) ( ptr -> frameBuffer + ( y1 * ptr -> paddedWidthInBytes + x1 * bytesPerPixel ) ) ; areaX = ScaleX ( ptr , screen , 1 ) ; areaY = ScaleY ( ptr , screen , 1 ) ; area2 = areaX * areaY ; if ( ( x1 + w1 ) > ( ptr -> width ) ) { if ( x1 == 0 ) w1 = ptr -> width ; else x1 = ptr -> width - w1 ; } if ( ( y1 + h1 ) > ( ptr -> height ) ) { if ( y1 == 0 ) h1 = ptr -> height ; else y1 = ptr -> height - h1 ; } if ( screen -> serverFormat . trueColour ) { unsigned char * srcptr2 ; unsigned long pixel_value , red , green , blue ; unsigned int redShift = screen -> serverFormat . redShift ; unsigned int greenShift = screen -> serverFormat . greenShift ; unsigned int blueShift = screen -> serverFormat . blueShift ; unsigned long redMax = screen -> serverFormat . redMax ; unsigned long greenMax = screen -> serverFormat . greenMax ; unsigned long blueMax = screen -> serverFormat . blueMax ; for ( y = 0 ; y < h1 ; y ++ ) { for ( x = 0 ; x < w1 ; x ++ ) { red = green = blue = 0 ; for ( w = 0 ; w < areaX ; w ++ ) { for ( v = 0 ; v < areaY ; v ++ ) { srcptr2 = & srcptr [ ( ( ( x * areaX ) + w ) * bytesPerPixel ) + ( v * screen -> paddedWidthInBytes ) ] ; pixel_value = 0 ; switch ( bytesPerPixel ) { case 4 : pixel_value = * ( ( unsigned int * ) srcptr2 ) ; break ; case 2 : pixel_value = * ( ( unsigned short * ) srcptr2 ) ; break ; case 1 : pixel_value = * ( ( unsigned char * ) srcptr2 ) ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) <S2SV_StartBug> pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ; <S2SV_EndBug> break ; } red += ( ( pixel_value >> redShift ) & redMax ) ; green += ( ( pixel_value >> greenShift ) & greenMax ) ; blue += ( ( pixel_value >> blueShift ) & blueMax ) ; } } red /= area2 ; green /= area2 ; blue /= area2 ; pixel_value = ( ( red & redMax ) << redShift ) | ( ( green & greenMax ) << greenShift ) | ( ( blue & blueMax ) << blueShift ) ; switch ( bytesPerPixel ) { case 4 : * ( ( unsigned int * ) dstptr ) = ( unsigned int ) pixel_value ; break ; case 2 : * ( ( unsigned short * ) dstptr ) = ( unsigned short ) pixel_value ; break ; case 1 : * ( ( unsigned char * ) dstptr ) = ( unsigned char ) pixel_value ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) dstptr [ z ] = ( pixel_value >> ( 8 * z ) ) & 0xff ; break ; } dstptr += bytesPerPixel ; } srcptr += ( screen -> paddedWidthInBytes * areaY ) ; dstptr += ( ptr -> paddedWidthInBytes - bytesPerLine ) ; } } else { for ( y = y1 ; y < ( y1 + h1 ) ; y ++ ) { for ( x = x1 ; x < ( x1 + w1 ) ; x ++ ) memcpy ( & ptr -> frameBuffer [ ( y * ptr -> paddedWidthInBytes ) + ( x * bytesPerPixel ) ] , & screen -> frameBuffer [ ( y * areaY * screen -> paddedWidthInBytes ) + ( x * areaX * bytesPerPixel ) ] , bytesPerPixel ) ; } } }", "target": "<S2SV_ModStart> pixel_value += ( ( unsigned long )"}
{"source": "CWE-125 yaffsfs_istat ( TSK_FS_INFO * fs , TSK_FS_ISTAT_FLAG_ENUM flags , FILE * hFile , TSK_INUM_T inum , TSK_DADDR_T numblock , int32_t sec_skew ) { TSK_FS_META * fs_meta ; TSK_FS_FILE * fs_file ; YAFFSFS_INFO * yfs = ( YAFFSFS_INFO * ) fs ; char ls [ 12 ] ; YAFFSFS_PRINT_ADDR print ; <S2SV_StartBug> char timeBuf [ 32 ] ; <S2SV_EndBug> YaffsCacheObject * obj = NULL ; YaffsCacheVersion * version = NULL ; YaffsHeader * header = NULL ; yaffscache_version_find_by_inode ( yfs , inum , & version , & obj ) ; if ( ( fs_file = tsk_fs_file_open_meta ( fs , NULL , inum ) ) == NULL ) { return 1 ; } fs_meta = fs_file -> meta ; tsk_fprintf ( hFile , \"inode:<S2SV_blank>%\" PRIuINUM \"\\\\n\" , inum ) ; tsk_fprintf ( hFile , \"%sAllocated\\\\n\" , ( fs_meta -> flags & TSK_FS_META_FLAG_ALLOC ) ? \"\" : \"Not<S2SV_blank>\" ) ; if ( fs_meta -> link ) tsk_fprintf ( hFile , \"symbolic<S2SV_blank>link<S2SV_blank>to:<S2SV_blank>%s\\\\n\" , fs_meta -> link ) ; tsk_fprintf ( hFile , \"uid<S2SV_blank>/<S2SV_blank>gid:<S2SV_blank>%\" PRIuUID \"<S2SV_blank>/<S2SV_blank>%\" PRIuGID \"\\\\n\" , fs_meta -> uid , fs_meta -> gid ) ; tsk_fs_meta_make_ls ( fs_meta , ls , sizeof ( ls ) ) ; tsk_fprintf ( hFile , \"mode:<S2SV_blank>%s\\\\n\" , ls ) ; tsk_fprintf ( hFile , \"size:<S2SV_blank>%\" PRIdOFF \"\\\\n\" , fs_meta -> size ) ; tsk_fprintf ( hFile , \"num<S2SV_blank>of<S2SV_blank>links:<S2SV_blank>%d\\\\n\" , fs_meta -> nlink ) ; if ( version != NULL ) { yaffsfs_read_header ( yfs , & header , version -> ycv_header_chunk -> ycc_offset ) ; if ( header != NULL ) { tsk_fprintf ( hFile , \"Name:<S2SV_blank>%s\\\\n\" , header -> name ) ; } } if ( sec_skew != 0 ) { tsk_fprintf ( hFile , \"\\\\nAdjusted<S2SV_blank>Inode<S2SV_blank>Times:\\\\n\" ) ; fs_meta -> mtime -= sec_skew ; fs_meta -> atime -= sec_skew ; fs_meta -> ctime -= sec_skew ; tsk_fprintf ( hFile , \"Accessed:\\\\t%s\\\\n\" , tsk_fs_time_to_str ( fs_meta -> atime , timeBuf ) ) ; tsk_fprintf ( hFile , \"File<S2SV_blank>Modified:\\\\t%s\\\\n\" , tsk_fs_time_to_str ( fs_meta -> mtime , timeBuf ) ) ; tsk_fprintf ( hFile , \"Inode<S2SV_blank>Modified:\\\\t%s\\\\n\" , tsk_fs_time_to_str ( fs_meta -> ctime , timeBuf ) ) ; fs_meta -> mtime += sec_skew ; fs_meta -> atime += sec_skew ; fs_meta -> ctime += sec_skew ; tsk_fprintf ( hFile , \"\\\\nOriginal<S2SV_blank>Inode<S2SV_blank>Times:\\\\n\" ) ; } else { tsk_fprintf ( hFile , \"\\\\nInode<S2SV_blank>Times:\\\\n\" ) ; } tsk_fprintf ( hFile , \"Accessed:\\\\t%s\\\\n\" , tsk_fs_time_to_str ( fs_meta -> atime , timeBuf ) ) ; tsk_fprintf ( hFile , \"File<S2SV_blank>Modified:\\\\t%s\\\\n\" , tsk_fs_time_to_str ( fs_meta -> mtime , timeBuf ) ) ; tsk_fprintf ( hFile , \"Inode<S2SV_blank>Modified:\\\\t%s\\\\n\" , tsk_fs_time_to_str ( fs_meta -> ctime , timeBuf ) ) ; if ( version != NULL ) { tsk_fprintf ( hFile , \"\\\\nHeader<S2SV_blank>Chunk:\\\\n\" ) ; tsk_fprintf ( hFile , \"%\" PRIuDADDR \"\\\\n\" , ( version -> ycv_header_chunk -> ycc_offset / ( yfs -> page_size + yfs -> spare_size ) ) ) ; } if ( numblock > 0 ) { TSK_OFF_T lower_size = numblock * fs -> block_size ; fs_meta -> size = ( lower_size < fs_meta -> size ) ? ( lower_size ) : ( fs_meta -> size ) ; } tsk_fprintf ( hFile , \"\\\\nData<S2SV_blank>Chunks:\\\\n\" ) ; if ( flags & TSK_FS_ISTAT_RUNLIST ) { const TSK_FS_ATTR * fs_attr_default = tsk_fs_file_attr_get_type ( fs_file , TSK_FS_ATTR_TYPE_DEFAULT , 0 , 0 ) ; if ( fs_attr_default && ( fs_attr_default -> flags & TSK_FS_ATTR_NONRES ) ) { if ( tsk_fs_attr_print ( fs_attr_default , hFile ) ) { tsk_fprintf ( hFile , \"\\\\nError<S2SV_blank>creating<S2SV_blank>run<S2SV_blank>lists<S2SV_blank><S2SV_blank>\" ) ; tsk_error_print ( hFile ) ; tsk_error_reset ( ) ; } } } else { print . idx = 0 ; print . hFile = hFile ; if ( tsk_fs_file_walk ( fs_file , TSK_FS_FILE_WALK_FLAG_AONLY , ( TSK_FS_FILE_WALK_CB ) print_addr_act , ( void * ) & print ) ) { tsk_fprintf ( hFile , \"\\\\nError<S2SV_blank>reading<S2SV_blank>file:<S2SV_blank><S2SV_blank>\" ) ; tsk_error_print ( hFile ) ; tsk_error_reset ( ) ; } else if ( print . idx != 0 ) { tsk_fprintf ( hFile , \"\\\\n\" ) ; } } tsk_fs_file_close ( fs_file ) ; return 0 ; }", "target": "<S2SV_ModStart> char timeBuf [ 128 <S2SV_ModEnd> ] ; YaffsCacheObject"}
{"source": "CWE-401 xmlParseBalancedChunkMemoryRecover ( xmlDocPtr doc , xmlSAXHandlerPtr sax , void * user_data , int depth , const xmlChar * string , xmlNodePtr * lst , int recover ) { xmlParserCtxtPtr ctxt ; xmlDocPtr newDoc ; xmlSAXHandlerPtr oldsax = NULL ; xmlNodePtr content , newRoot ; int size ; int ret = 0 ; if ( depth > 40 ) { return ( XML_ERR_ENTITY_LOOP ) ; } if ( lst != NULL ) * lst = NULL ; if ( string == NULL ) return ( - 1 ) ; size = xmlStrlen ( string ) ; ctxt = xmlCreateMemoryParserCtxt ( ( char * ) string , size ) ; if ( ctxt == NULL ) return ( - 1 ) ; ctxt -> userData = ctxt ; if ( sax != NULL ) { oldsax = ctxt -> sax ; ctxt -> sax = sax ; if ( user_data != NULL ) ctxt -> userData = user_data ; } newDoc = xmlNewDoc ( BAD_CAST \"1.0\" ) ; if ( newDoc == NULL ) { xmlFreeParserCtxt ( ctxt ) ; return ( - 1 ) ; } newDoc -> properties = XML_DOC_INTERNAL ; if ( ( doc != NULL ) && ( doc -> dict != NULL ) ) { xmlDictFree ( ctxt -> dict ) ; ctxt -> dict = doc -> dict ; xmlDictReference ( ctxt -> dict ) ; ctxt -> str_xml = xmlDictLookup ( ctxt -> dict , BAD_CAST \"xml\" , 3 ) ; ctxt -> str_xmlns = xmlDictLookup ( ctxt -> dict , BAD_CAST \"xmlns\" , 5 ) ; ctxt -> str_xml_ns = xmlDictLookup ( ctxt -> dict , XML_XML_NAMESPACE , 36 ) ; ctxt -> dictNames = 1 ; } else { xmlCtxtUseOptionsInternal ( ctxt , XML_PARSE_NODICT , NULL ) ; } if ( doc != NULL ) { newDoc -> intSubset = doc -> intSubset ; newDoc -> extSubset = doc -> extSubset ; } newRoot = xmlNewDocNode ( newDoc , NULL , BAD_CAST \"pseudoroot\" , NULL ) ; if ( newRoot == NULL ) { if ( sax != NULL ) ctxt -> sax = oldsax ; xmlFreeParserCtxt ( ctxt ) ; newDoc -> intSubset = NULL ; newDoc -> extSubset = NULL ; xmlFreeDoc ( newDoc ) ; return ( - 1 ) ; } xmlAddChild ( ( xmlNodePtr ) newDoc , newRoot ) ; nodePush ( ctxt , newRoot ) ; if ( doc == NULL ) { ctxt -> myDoc = newDoc ; } else { ctxt -> myDoc = newDoc ; newDoc -> children -> doc = doc ; xmlSearchNsByHref ( doc , ( xmlNodePtr ) doc , XML_XML_NAMESPACE ) ; newDoc -> oldNs = doc -> oldNs ; } ctxt -> instate = XML_PARSER_CONTENT ; ctxt -> input_id = 2 ; ctxt -> depth = depth ; ctxt -> validate = 0 ; ctxt -> loadsubset = 0 ; xmlDetectSAX2 ( ctxt ) ; if ( doc != NULL ) { content = doc -> children ; doc -> children = NULL ; xmlParseContent ( ctxt ) ; doc -> children = content ; } else { xmlParseContent ( ctxt ) ; } if ( ( RAW == '<' ) && ( NXT ( 1 ) == '/' ) ) { xmlFatalErr ( ctxt , XML_ERR_NOT_WELL_BALANCED , NULL ) ; } else if ( RAW != 0 ) { xmlFatalErr ( ctxt , XML_ERR_EXTRA_CONTENT , NULL ) ; } if ( ctxt -> node != newDoc -> children ) { xmlFatalErr ( ctxt , XML_ERR_NOT_WELL_BALANCED , NULL ) ; } if ( ! ctxt -> wellFormed ) { if ( ctxt -> errNo == 0 ) ret = 1 ; else ret = ctxt -> errNo ; } else { ret = 0 ; } if ( ( lst != NULL ) && ( ( ret == 0 ) || ( recover == 1 ) ) ) { xmlNodePtr cur ; cur = newDoc -> children -> children ; * lst = cur ; while ( cur != NULL ) { xmlSetTreeDoc ( cur , doc ) ; cur -> parent = NULL ; cur = cur -> next ; } newDoc -> children -> children = NULL ; } if ( sax != NULL ) ctxt -> sax = oldsax ; xmlFreeParserCtxt ( ctxt ) ; newDoc -> intSubset = NULL ; newDoc -> extSubset = NULL ; <S2SV_StartBug> newDoc -> oldNs = NULL ; <S2SV_EndBug> xmlFreeDoc ( newDoc ) ; return ( ret ) ; }", "target": "<S2SV_ModStart> = NULL ; if ( doc != NULL )"}
{"source": "CWE-416 void * _zend_shared_memdup ( void * source , size_t size , zend_bool free_source TSRMLS_DC ) { void * * old_p , * retval ; if ( zend_hash_index_find ( & xlat_table , ( ulong ) source , ( void * * ) & old_p ) == SUCCESS ) { return * old_p ; } retval = ZCG ( mem ) ; ; ZCG ( mem ) = ( void * ) ( ( ( char * ) ZCG ( mem ) ) + ZEND_ALIGNED_SIZE ( size ) ) ; memcpy ( retval , source , size ) ; <S2SV_StartBug> if ( free_source ) { <S2SV_EndBug> interned_efree ( ( char * ) source ) ; } <S2SV_StartBug> zend_shared_alloc_register_xlat_entry ( source , retval ) ; <S2SV_EndBug> return retval ; }", "target": "<S2SV_ModStart> size ) ; zend_shared_alloc_register_xlat_entry ( source , retval ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> return retval ;"}
{"source": "CWE-787 xmlEncodeEntitiesInternal ( xmlDocPtr doc , const xmlChar * input , int attr ) { const xmlChar * cur = input ; xmlChar * buffer = NULL ; xmlChar * out = NULL ; size_t buffer_size = 0 ; int html = 0 ; if ( input == NULL ) return ( NULL ) ; if ( doc != NULL ) html = ( doc -> type == XML_HTML_DOCUMENT_NODE ) ; buffer_size = 1000 ; buffer = ( xmlChar * ) xmlMalloc ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) { xmlEntitiesErrMemory ( \"xmlEncodeEntities:<S2SV_blank>malloc<S2SV_blank>failed\" ) ; return ( NULL ) ; } out = buffer ; while ( * cur != '\\\\0' ) { size_t indx = out - buffer ; if ( indx + 100 > buffer_size ) { growBufferReentrant ( ) ; out = & buffer [ indx ] ; } if ( * cur == '<' ) { const xmlChar * end ; if ( html && attr && ( cur [ 1 ] == '!' ) && ( cur [ 2 ] == '-' ) && ( cur [ 3 ] == '-' ) && ( ( end = xmlStrstr ( cur , BAD_CAST \"-->\" ) ) != NULL ) ) { while ( cur != end ) { * out ++ = * cur ++ ; indx = out - buffer ; if ( indx + 100 > buffer_size ) { growBufferReentrant ( ) ; out = & buffer [ indx ] ; } } * out ++ = * cur ++ ; * out ++ = * cur ++ ; * out ++ = * cur ++ ; continue ; } * out ++ = '&' ; * out ++ = 'l' ; * out ++ = 't' ; * out ++ = ';' ; } else if ( * cur == '>' ) { * out ++ = '&' ; * out ++ = 'g' ; * out ++ = 't' ; * out ++ = ';' ; } else if ( * cur == '&' ) { if ( html && attr && ( cur [ 1 ] == '{' ) && ( strchr ( ( const char * ) cur , '}' ) ) ) { while ( * cur != '}' ) { * out ++ = * cur ++ ; indx = out - buffer ; if ( indx + 100 > buffer_size ) { growBufferReentrant ( ) ; out = & buffer [ indx ] ; } } * out ++ = * cur ++ ; continue ; } * out ++ = '&' ; * out ++ = 'a' ; * out ++ = 'm' ; * out ++ = 'p' ; * out ++ = ';' ; } else if ( ( ( * cur >= 0x20 ) && ( * cur < 0x80 ) ) || ( * cur == '\\\\n' ) || ( * cur == '\\\\t' ) || ( ( html ) && ( * cur == '\\\\r' ) ) ) { * out ++ = * cur ; } else if ( * cur >= 0x80 ) { if ( ( ( doc != NULL ) && ( doc -> encoding != NULL ) ) || ( html ) ) { * out ++ = * cur ; } else { char buf [ 11 ] , * ptr ; int val = 0 , l = 1 ; <S2SV_StartBug> if ( * cur < 0xC0 ) { <S2SV_EndBug> xmlEntitiesErr ( XML_CHECK_NOT_UTF8 , \"xmlEncodeEntities:<S2SV_blank>input<S2SV_blank>not<S2SV_blank>UTF-8\" ) ; if ( doc != NULL ) doc -> encoding = xmlStrdup ( BAD_CAST \"ISO-8859-1\" ) ; snprintf ( buf , sizeof ( buf ) , \"&#%d;\" , * cur ) ; buf [ sizeof ( buf ) - 1 ] = 0 ; ptr = buf ; while ( * ptr != 0 ) * out ++ = * ptr ++ ; cur ++ ; continue ; } else if ( * cur < 0xE0 ) { val = ( cur [ 0 ] ) & 0x1F ; val <<= 6 ; val |= ( cur [ 1 ] ) & 0x3F ; l = 2 ; } else if ( * cur < 0xF0 ) { val = ( cur [ 0 ] ) & 0x0F ; val <<= 6 ; val |= ( cur [ 1 ] ) & 0x3F ; val <<= 6 ; val |= ( cur [ 2 ] ) & 0x3F ; l = 3 ; } else if ( * cur < 0xF8 ) { val = ( cur [ 0 ] ) & 0x07 ; val <<= 6 ; val |= ( cur [ 1 ] ) & 0x3F ; val <<= 6 ; val |= ( cur [ 2 ] ) & 0x3F ; val <<= 6 ; val |= ( cur [ 3 ] ) & 0x3F ; l = 4 ; } if ( ( l == 1 ) || ( ! IS_CHAR ( val ) ) ) { xmlEntitiesErr ( XML_ERR_INVALID_CHAR , \"xmlEncodeEntities:<S2SV_blank>char<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\\n\" ) ; if ( doc != NULL ) doc -> encoding = xmlStrdup ( BAD_CAST \"ISO-8859-1\" ) ; snprintf ( buf , sizeof ( buf ) , \"&#%d;\" , * cur ) ; buf [ sizeof ( buf ) - 1 ] = 0 ; ptr = buf ; while ( * ptr != 0 ) * out ++ = * ptr ++ ; cur ++ ; continue ; } snprintf ( buf , sizeof ( buf ) , \"&#x%X;\" , val ) ; buf [ sizeof ( buf ) - 1 ] = 0 ; ptr = buf ; while ( * ptr != 0 ) * out ++ = * ptr ++ ; cur += l ; continue ; } } else if ( IS_BYTE_CHAR ( * cur ) ) { char buf [ 11 ] , * ptr ; snprintf ( buf , sizeof ( buf ) , \"&#%d;\" , * cur ) ; buf [ sizeof ( buf ) - 1 ] = 0 ; ptr = buf ; while ( * ptr != 0 ) * out ++ = * ptr ++ ; } cur ++ ; } * out = 0 ; return ( buffer ) ; mem_error : xmlEntitiesErrMemory ( \"xmlEncodeEntities:<S2SV_blank>realloc<S2SV_blank>failed\" ) ; xmlFree ( buffer ) ; return ( NULL ) ; }", "target": "<S2SV_ModStart> ; if ( ( ( cur [ 0 ] & 0xC0 ) != 0xC0 ) || ( ( cur [ 1 ] & 0xC0 ) != 0x80 ) || ( ( ( cur [ 0 ] & 0xE0 ) == 0xE0 ) && ( ( cur [ 2 ] & 0xC0 ) != 0x80 ) ) || ( ( ( cur [ 0 ] & 0xF0 ) == 0xF0 ) && ( ( cur [ 3 ] & 0xC0 ) != 0x80 ) ) || ( ( ( cur [ 0 ] & 0xF8 ) == 0xF8 ) ) <S2SV_ModEnd> ) { xmlEntitiesErr"}
{"source": "CWE-476 sync_create_state_control ( Slapi_Entry * e , LDAPControl * * ctrlp , int type , Sync_Cookie * cookie ) { int rc ; BerElement * ber ; struct berval * bvp ; char * uuid ; <S2SV_StartBug> Slapi_Attr * attr ; <S2SV_EndBug> <S2SV_StartBug> Slapi_Value * val ; <S2SV_EndBug> if ( type == LDAP_SYNC_NONE || ctrlp == NULL || ( ber = der_alloc ( ) ) == NULL ) { return ( LDAP_OPERATIONS_ERROR ) ; } * ctrlp = NULL ; slapi_entry_attr_find ( e , SLAPI_ATTR_UNIQUEID , & attr ) ; <S2SV_StartBug> slapi_attr_first_value ( attr , & val ) ; <S2SV_EndBug> uuid = sync_nsuniqueid2uuid ( slapi_value_get_string ( val ) ) ; if ( ( rc = ber_printf ( ber , \"{eo\" , type , uuid , 16 ) ) != - 1 ) { if ( cookie ) { char * cookiestr = sync_cookie2str ( cookie ) ; rc = ber_printf ( ber , \"s}\" , cookiestr ) ; slapi_ch_free ( ( void * * ) & cookiestr ) ; } else { rc = ber_printf ( ber , \"}\" ) ; } } if ( rc != - 1 ) { rc = ber_flatten ( ber , & bvp ) ; } ber_free ( ber , 1 ) ; slapi_ch_free ( ( void * * ) & uuid ) ; if ( rc == - 1 ) { return ( LDAP_OPERATIONS_ERROR ) ; } * ctrlp = ( LDAPControl * ) slapi_ch_malloc ( sizeof ( LDAPControl ) ) ; ( * ctrlp ) -> ldctl_iscritical = 0 ; ( * ctrlp ) -> ldctl_oid = slapi_ch_strdup ( LDAP_CONTROL_SYNC_STATE ) ; ( * ctrlp ) -> ldctl_value = * bvp ; bvp -> bv_val = NULL ; ber_bvfree ( bvp ) ; return ( LDAP_SUCCESS ) ; }", "target": "<S2SV_ModStart> Slapi_Attr * attr = NULL <S2SV_ModStart> Slapi_Value * val = NULL <S2SV_ModStart> val ) ; if ( ( attr == NULL ) || ( val == NULL ) ) { slapi_log_err ( SLAPI_LOG_ERR , SYNC_PLUGIN_SUBSYSTEM , \"sync_create_state_control<S2SV_blank>-<S2SV_blank>Entries<S2SV_blank>are<S2SV_blank>missing<S2SV_blank>nsuniqueid.<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>proceed.\\\\n\" ) ; return ( LDAP_OPERATIONS_ERROR ) ; }"}
{"source": "CWE-787 static int blosc_c ( struct thread_context * thread_context , int32_t bsize , <S2SV_StartBug> int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes , <S2SV_EndBug> const uint8_t * src , const int32_t offset , uint8_t * dest , uint8_t * tmp , uint8_t * tmp2 ) { blosc2_context * context = thread_context -> parent_context ; int dont_split = ( context -> header_flags & 0x10 ) >> 4 ; int dict_training = context -> use_dict && context -> dict_cdict == NULL ; int32_t j , neblock , nstreams ; int32_t cbytes ; int32_t ctbytes = 0 ; int64_t maxout ; int32_t typesize = context -> typesize ; const char * compname ; int accel ; const uint8_t * _src ; uint8_t * _tmp = tmp , * _tmp2 = tmp2 ; uint8_t * _tmp3 = thread_context -> tmp4 ; int last_filter_index = last_filter ( context -> filters , 'c' ) ; bool memcpyed = context -> header_flags & ( uint8_t ) BLOSC_MEMCPYED ; if ( last_filter_index >= 0 || context -> prefilter != NULL ) { if ( memcpyed && context -> prefilter != NULL ) { _src = pipeline_c ( thread_context , bsize , src , offset , dest , _tmp2 , _tmp3 ) ; if ( _src == NULL ) { return - 9 ; } return bsize ; } _src = pipeline_c ( thread_context , bsize , src , offset , _tmp , _tmp2 , _tmp3 ) ; if ( _src == NULL ) { return - 9 ; } } else { _src = src + offset ; } assert ( context -> clevel > 0 ) ; accel = get_accel ( context ) ; if ( ! dont_split && ! leftoverblock && ! dict_training ) { nstreams = ( int32_t ) typesize ; } else { nstreams = 1 ; } neblock = bsize / nstreams ; for ( j = 0 ; j < nstreams ; j ++ ) { if ( ! dict_training ) { dest += sizeof ( int32_t ) ; ntbytes += sizeof ( int32_t ) ; ctbytes += sizeof ( int32_t ) ; } const uint8_t * ip = ( uint8_t * ) _src + j * neblock ; const uint8_t * ipbound = ( uint8_t * ) _src + ( j + 1 ) * neblock ; if ( get_run ( ip , ipbound ) ) { int32_t value = _src [ j * neblock ] ; <S2SV_StartBug> _sw32 ( dest - 4 , - value ) ; <S2SV_EndBug> continue ; } maxout = neblock ; # if defined ( HAVE_SNAPPY ) if ( context -> compcode == BLOSC_SNAPPY ) { maxout = ( int32_t ) snappy_max_compressed_length ( ( size_t ) neblock ) ; } # endif <S2SV_StartBug> if ( ntbytes + maxout > maxbytes ) { <S2SV_EndBug> <S2SV_StartBug> maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ; <S2SV_EndBug> if ( maxout <= 0 ) { return 0 ; } } if ( dict_training ) { memcpy ( dest , _src + j * neblock , ( unsigned int ) neblock ) ; cbytes = ( int32_t ) neblock ; } else if ( context -> compcode == BLOSC_BLOSCLZ ) { cbytes = blosclz_compress ( context -> clevel , _src + j * neblock , ( int ) neblock , dest , ( int ) maxout ) ; } # if defined ( HAVE_LZ4 ) else if ( context -> compcode == BLOSC_LZ4 ) { void * hash_table = NULL ; # ifdef HAVE_IPP hash_table = ( void * ) thread_context -> lz4_hash_table ; # endif cbytes = lz4_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , accel , hash_table ) ; } else if ( context -> compcode == BLOSC_LZ4HC ) { cbytes = lz4hc_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif # if defined ( HAVE_LIZARD ) else if ( context -> compcode == BLOSC_LIZARD ) { cbytes = lizard_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , accel ) ; } # endif # if defined ( HAVE_SNAPPY ) else if ( context -> compcode == BLOSC_SNAPPY ) { cbytes = snappy_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout ) ; } # endif # if defined ( HAVE_ZLIB ) else if ( context -> compcode == BLOSC_ZLIB ) { cbytes = zlib_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif # if defined ( HAVE_ZSTD ) else if ( context -> compcode == BLOSC_ZSTD ) { cbytes = zstd_wrap_compress ( thread_context , ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif else { blosc_compcode_to_compname ( context -> compcode , & compname ) ; fprintf ( stderr , \"Blosc<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>\\'%s\\'<S2SV_blank>\" , compname ) ; fprintf ( stderr , \"compression<S2SV_blank>support.<S2SV_blank><S2SV_blank>Please<S2SV_blank>use<S2SV_blank>one<S2SV_blank>having<S2SV_blank>it.\" ) ; return - 5 ; } if ( cbytes > maxout ) { return - 1 ; } if ( cbytes < 0 ) { return - 2 ; } if ( ! dict_training ) { if ( cbytes == 0 || cbytes == neblock ) { <S2SV_StartBug> if ( ( ntbytes + neblock ) > maxbytes ) { <S2SV_EndBug> return 0 ; } memcpy ( dest , _src + j * neblock , ( unsigned int ) neblock ) ; cbytes = neblock ; } _sw32 ( dest - 4 , cbytes ) ; } dest += cbytes ; ntbytes += cbytes ; ctbytes += cbytes ; } return ctbytes ; }", "target": "<S2SV_ModStart> ntbytes , int32_t destsize <S2SV_ModEnd> , const uint8_t <S2SV_ModStart> neblock ] ; if ( ntbytes > destsize ) { return - 1 ; } <S2SV_ModStart> + maxout > destsize <S2SV_ModEnd> ) { maxout <S2SV_ModStart> ( int64_t ) destsize <S2SV_ModEnd> - ( int64_t <S2SV_ModStart> neblock ) > destsize <S2SV_ModEnd> ) { return"}
{"source": "CWE-310 copy_ciphersuites ( gnutls_session_t session , gnutls_buffer_st * cdata , int add_scsv ) { int ret ; <S2SV_StartBug> uint8_t cipher_suites [ MAX_CIPHERSUITE_SIZE + 2 ] ; <S2SV_EndBug> int cipher_suites_size ; size_t init_length = cdata -> length ; ret = _gnutls_supported_ciphersuites ( session , cipher_suites , sizeof ( cipher_suites ) - 2 ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; ret = _gnutls_remove_unwanted_ciphersuites ( session , cipher_suites , ret , NULL , 0 ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; if ( ret == 0 ) return gnutls_assert_val ( GNUTLS_E_INSUFFICIENT_CREDENTIALS ) ; cipher_suites_size = ret ; if ( add_scsv ) { cipher_suites [ cipher_suites_size ] = 0x00 ; cipher_suites [ cipher_suites_size + 1 ] = 0xff ; cipher_suites_size += 2 ; ret = _gnutls_ext_sr_send_cs ( session ) ; if ( ret < 0 ) <S2SV_StartBug> return gnutls_assert_val ( ret ) ; <S2SV_EndBug> } ret = _gnutls_buffer_append_data_prefix ( cdata , 16 , cipher_suites , cipher_suites_size ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; ret = cdata -> length - init_length ; return ret ; }", "target": "<S2SV_ModStart> [ MAX_CIPHERSUITE_SIZE + 4 <S2SV_ModEnd> ] ; int <S2SV_ModStart> ( ret ) ; } if ( session -> internals . priorities . fallback ) { cipher_suites [ cipher_suites_size ] = GNUTLS_FALLBACK_SCSV_MAJOR ; cipher_suites [ cipher_suites_size + 1 ] = GNUTLS_FALLBACK_SCSV_MINOR ; cipher_suites_size += 2"}
{"source": "CWE-476 gdImagePtr gdImageCreateFromXpm ( char * filename ) { XpmInfo info ; XpmImage image ; int i , j , k , number ; char buf [ 5 ] ; gdImagePtr im = 0 ; int * pointer ; int red = 0 , green = 0 , blue = 0 ; int * colors ; int ret ; ret = XpmReadFileToXpmImage ( filename , & image , & info ) ; if ( ret != XpmSuccess ) { return 0 ; } <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> if ( ! ( im = gdImageCreate ( image . width , image . height ) ) ) { <S2SV_EndBug> goto done ; } <S2SV_StartBug> number = image . ncolors ; <S2SV_EndBug> colors = ( int * ) safe_emalloc ( number , sizeof ( int ) , 0 ) ; for ( i = 0 ; i < number ; i ++ ) { switch ( strlen ( image . colorTable [ i ] . c_color ) ) { case 4 : buf [ 1 ] = '\\\\0' ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 1 ] ; red = strtol ( buf , NULL , 16 ) ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 2 ] ; green = strtol ( buf , NULL , 16 ) ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 3 ] ; blue = strtol ( buf , NULL , 16 ) ; break ; case 7 : buf [ 2 ] = '\\\\0' ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 1 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 2 ] ; red = strtol ( buf , NULL , 16 ) ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 3 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 4 ] ; green = strtol ( buf , NULL , 16 ) ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 5 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 6 ] ; blue = strtol ( buf , NULL , 16 ) ; break ; case 10 : buf [ 3 ] = '\\\\0' ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 1 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 2 ] ; buf [ 2 ] = image . colorTable [ i ] . c_color [ 3 ] ; red = strtol ( buf , NULL , 16 ) ; red /= 64 ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 4 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 5 ] ; buf [ 2 ] = image . colorTable [ i ] . c_color [ 6 ] ; green = strtol ( buf , NULL , 16 ) ; green /= 64 ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 7 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 8 ] ; buf [ 2 ] = image . colorTable [ i ] . c_color [ 9 ] ; blue = strtol ( buf , NULL , 16 ) ; blue /= 64 ; break ; case 13 : buf [ 4 ] = '\\\\0' ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 1 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 2 ] ; buf [ 2 ] = image . colorTable [ i ] . c_color [ 3 ] ; buf [ 3 ] = image . colorTable [ i ] . c_color [ 4 ] ; red = strtol ( buf , NULL , 16 ) ; red /= 256 ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 5 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 6 ] ; buf [ 2 ] = image . colorTable [ i ] . c_color [ 7 ] ; buf [ 3 ] = image . colorTable [ i ] . c_color [ 8 ] ; green = strtol ( buf , NULL , 16 ) ; green /= 256 ; buf [ 0 ] = image . colorTable [ i ] . c_color [ 9 ] ; buf [ 1 ] = image . colorTable [ i ] . c_color [ 10 ] ; buf [ 2 ] = image . colorTable [ i ] . c_color [ 11 ] ; buf [ 3 ] = image . colorTable [ i ] . c_color [ 12 ] ; blue = strtol ( buf , NULL , 16 ) ; blue /= 256 ; break ; } colors [ i ] = gdImageColorResolve ( im , red , green , blue ) ; } pointer = ( int * ) image . data ; for ( i = 0 ; i < image . height ; i ++ ) { for ( j = 0 ; j < image . width ; j ++ ) { k = * pointer ++ ; gdImageSetPixel ( im , j , i , colors [ k ] ) ; } } gdFree ( colors ) ; done : XpmFreeXpmImage ( & image ) ; XpmFreeXpmInfo ( & info ) ; return im ; }", "target": "<S2SV_ModStart> 0 ; } number = image . ncolors ; for ( i = 0 ; i < number ; i ++ ) { <S2SV_ModStart> if ( ! image . colorTable [ i ] . c_color <S2SV_ModEnd> ) { goto <S2SV_ModStart> done ; } } if ( ! ( im = gdImageCreate ( image . width , image . height ) ) ) { goto done ; } <S2SV_ModEnd> colors = ("}
{"source": "CWE-476 static void ov511_mode_init_regs ( struct sd * sd ) { struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; int hsegs , vsegs , packet_size , fps , needed ; int interlaced = 0 ; struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , \"Couldn\\'t<S2SV_blank>get<S2SV_blank>altsetting\\\\n\" ) ; <S2SV_StartBug> sd -> gspca_dev . usb_err = - EIO ; <S2SV_EndBug> return ; } packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; reg_w ( sd , R51x_FIFO_PSIZE , packet_size >> 5 ) ; reg_w ( sd , R511_CAM_UV_EN , 0x01 ) ; reg_w ( sd , R511_SNAP_UV_EN , 0x01 ) ; reg_w ( sd , R511_SNAP_OPTS , 0x03 ) ; hsegs = ( sd -> gspca_dev . pixfmt . width >> 3 ) - 1 ; vsegs = ( sd -> gspca_dev . pixfmt . height >> 3 ) - 1 ; reg_w ( sd , R511_CAM_PXCNT , hsegs ) ; reg_w ( sd , R511_CAM_LNCNT , vsegs ) ; reg_w ( sd , R511_CAM_PXDIV , 0x00 ) ; reg_w ( sd , R511_CAM_LNDIV , 0x00 ) ; reg_w ( sd , R511_CAM_OPTS , 0x03 ) ; reg_w ( sd , R511_SNAP_PXCNT , hsegs ) ; reg_w ( sd , R511_SNAP_LNCNT , vsegs ) ; reg_w ( sd , R511_SNAP_PXDIV , 0x00 ) ; reg_w ( sd , R511_SNAP_LNDIV , 0x00 ) ; if ( frame_rate > 0 ) sd -> frame_rate = frame_rate ; switch ( sd -> sensor ) { case SEN_OV6620 : sd -> clockdiv = 3 ; break ; case SEN_OV7620 : case SEN_OV7620AE : case SEN_OV7640 : case SEN_OV7648 : case SEN_OV76BE : if ( sd -> gspca_dev . pixfmt . width == 320 ) interlaced = 1 ; case SEN_OV6630 : case SEN_OV7610 : case SEN_OV7670 : switch ( sd -> frame_rate ) { case 30 : case 25 : if ( sd -> gspca_dev . pixfmt . width != 640 ) { sd -> clockdiv = 0 ; break ; } default : sd -> clockdiv = 1 ; break ; case 10 : sd -> clockdiv = 2 ; break ; case 5 : sd -> clockdiv = 5 ; break ; } if ( interlaced ) { sd -> clockdiv = ( sd -> clockdiv + 1 ) * 2 - 1 ; if ( sd -> clockdiv > 10 ) sd -> clockdiv = 10 ; } break ; case SEN_OV8610 : sd -> clockdiv = 0 ; break ; } fps = ( interlaced ? 60 : 30 ) / ( sd -> clockdiv + 1 ) + 1 ; needed = fps * sd -> gspca_dev . pixfmt . width * sd -> gspca_dev . pixfmt . height * 3 / 2 ; if ( needed > 1000 * packet_size ) { reg_w ( sd , R511_COMP_EN , 0x07 ) ; reg_w ( sd , R511_COMP_LUT_EN , 0x03 ) ; } else { reg_w ( sd , R511_COMP_EN , 0x06 ) ; reg_w ( sd , R511_COMP_LUT_EN , 0x00 ) ; } reg_w ( sd , R51x_SYS_RESET , OV511_RESET_OMNICE ) ; reg_w ( sd , R51x_SYS_RESET , 0 ) ; }", "target": "<S2SV_ModStart> = - EIO ; return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV"}
{"source": "CWE-476 static void ov518_mode_init_regs ( struct sd * sd ) { struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; int hsegs , vsegs , packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , \"Couldn\\'t<S2SV_blank>get<S2SV_blank>altsetting\\\\n\" ) ; sd -> gspca_dev . usb_err = - EIO ; return ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> ov518_reg_w32 ( sd , R51x_FIFO_PSIZE , packet_size & ~ 7 , 2 ) ; reg_w ( sd , 0x2b , 0 ) ; reg_w ( sd , 0x2c , 0 ) ; reg_w ( sd , 0x2d , 0 ) ; reg_w ( sd , 0x2e , 0 ) ; reg_w ( sd , 0x3b , 0 ) ; reg_w ( sd , 0x3c , 0 ) ; reg_w ( sd , 0x3d , 0 ) ; reg_w ( sd , 0x3e , 0 ) ; if ( sd -> bridge == BRIDGE_OV518 ) { reg_w_mask ( sd , 0x20 , 0x08 , 0x08 ) ; reg_w_mask ( sd , 0x28 , 0x80 , 0xf0 ) ; reg_w_mask ( sd , 0x38 , 0x80 , 0xf0 ) ; } else { reg_w ( sd , 0x28 , 0x80 ) ; reg_w ( sd , 0x38 , 0x80 ) ; } hsegs = sd -> gspca_dev . pixfmt . width / 16 ; vsegs = sd -> gspca_dev . pixfmt . height / 4 ; reg_w ( sd , 0x29 , hsegs ) ; reg_w ( sd , 0x2a , vsegs ) ; reg_w ( sd , 0x39 , hsegs ) ; reg_w ( sd , 0x3a , vsegs ) ; reg_w ( sd , 0x2f , 0x80 ) ; if ( sd -> bridge == BRIDGE_OV518PLUS && sd -> revision == 0 && sd -> sensor == SEN_OV7620AE ) sd -> clockdiv = 0 ; else sd -> clockdiv = 1 ; reg_w ( sd , 0x51 , 0x04 ) ; reg_w ( sd , 0x22 , 0x18 ) ; reg_w ( sd , 0x23 , 0xff ) ; if ( sd -> bridge == BRIDGE_OV518PLUS ) { switch ( sd -> sensor ) { case SEN_OV7620AE : if ( sd -> revision > 0 && sd -> gspca_dev . pixfmt . width == 640 ) { reg_w ( sd , 0x20 , 0x60 ) ; reg_w ( sd , 0x21 , 0x1f ) ; } else { reg_w ( sd , 0x20 , 0x00 ) ; reg_w ( sd , 0x21 , 0x19 ) ; } break ; case SEN_OV7620 : reg_w ( sd , 0x20 , 0x00 ) ; reg_w ( sd , 0x21 , 0x19 ) ; break ; default : reg_w ( sd , 0x21 , 0x19 ) ; } } else reg_w ( sd , 0x71 , 0x17 ) ; i2c_w ( sd , 0x54 , 0x23 ) ; reg_w ( sd , 0x2f , 0x80 ) ; if ( sd -> bridge == BRIDGE_OV518PLUS ) { reg_w ( sd , 0x24 , 0x94 ) ; reg_w ( sd , 0x25 , 0x90 ) ; ov518_reg_w32 ( sd , 0xc4 , 400 , 2 ) ; ov518_reg_w32 ( sd , 0xc6 , 540 , 2 ) ; ov518_reg_w32 ( sd , 0xc7 , 540 , 2 ) ; ov518_reg_w32 ( sd , 0xc8 , 108 , 2 ) ; ov518_reg_w32 ( sd , 0xca , 131098 , 3 ) ; ov518_reg_w32 ( sd , 0xcb , 532 , 2 ) ; ov518_reg_w32 ( sd , 0xcc , 2400 , 2 ) ; ov518_reg_w32 ( sd , 0xcd , 32 , 2 ) ; ov518_reg_w32 ( sd , 0xce , 608 , 2 ) ; } else { reg_w ( sd , 0x24 , 0x9f ) ; reg_w ( sd , 0x25 , 0x90 ) ; ov518_reg_w32 ( sd , 0xc4 , 400 , 2 ) ; ov518_reg_w32 ( sd , 0xc6 , 381 , 2 ) ; ov518_reg_w32 ( sd , 0xc7 , 381 , 2 ) ; ov518_reg_w32 ( sd , 0xc8 , 128 , 2 ) ; ov518_reg_w32 ( sd , 0xca , 183331 , 3 ) ; ov518_reg_w32 ( sd , 0xcb , 746 , 2 ) ; ov518_reg_w32 ( sd , 0xcc , 1750 , 2 ) ; ov518_reg_w32 ( sd , 0xcd , 45 , 2 ) ; ov518_reg_w32 ( sd , 0xce , 851 , 2 ) ; } reg_w ( sd , 0x2f , 0x80 ) ; }", "target": "<S2SV_ModStart> return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV ; return ; }"}
{"source": "CWE-401 urnParseReply ( const char * inbuf , const HttpRequestMethod & m ) { char * buf = xstrdup ( inbuf ) ; char * token ; url_entry * list ; url_entry * old ; int n = 32 ; int i = 0 ; debugs ( 52 , 3 , \"urnParseReply\" ) ; list = ( url_entry * ) xcalloc ( n + 1 , sizeof ( * list ) ) ; for ( token = strtok ( buf , crlf ) ; token ; token = strtok ( NULL , crlf ) ) { debugs ( 52 , 3 , \"urnParseReply:<S2SV_blank>got<S2SV_blank>\\'\" << token << \"\\'\" ) ; if ( i == n ) { old = list ; n <<= 2 ; list = ( url_entry * ) xcalloc ( n + 1 , sizeof ( * list ) ) ; memcpy ( list , old , i * sizeof ( * list ) ) ; safe_free ( old ) ; } AnyP : : Uri uri ; if ( ! uri . parse ( m , SBuf ( token ) ) || ! * uri . host ( ) ) continue ; # if USE_ICMP list [ i ] . rtt = netdbHostRtt ( uri . host ( ) ) ; if ( 0 == list [ i ] . rtt ) { debugs ( 52 , 3 , \"Pinging<S2SV_blank>\" << uri . host ( ) ) ; netdbPingSite ( uri . host ( ) ) ; } # else list [ i ] . rtt = 0 ; # endif list [ i ] . url = xstrdup ( uri . absolute ( ) . c_str ( ) ) ; list [ i ] . host = xstrdup ( uri . host ( ) ) ; list [ i ] . flags . cached = storeGetPublic ( list [ i ] . url , m ) ? 1 : 0 ; ++ i ; } debugs ( 52 , 3 , \"urnParseReply:<S2SV_blank>Found<S2SV_blank>\" << i << \"<S2SV_blank>URLs\" ) ; <S2SV_StartBug> return list ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> \"<S2SV_blank>URLs\" ) ; xfree ( buf ) ;"}
{"source": "CWE-611 entityValueInitProcessor ( XML_Parser parser , const char * s , const char * end , const char * * nextPtr ) { int tok ; const char * start = s ; const char * next = start ; eventPtr = start ; for ( ; ; ) { tok = XmlPrologTok ( encoding , start , end , & next ) ; eventEndPtr = next ; if ( tok <= 0 ) { if ( ! ps_finalBuffer && tok != XML_TOK_INVALID ) { * nextPtr = s ; return XML_ERROR_NONE ; } switch ( tok ) { case XML_TOK_INVALID : return XML_ERROR_INVALID_TOKEN ; case XML_TOK_PARTIAL : return XML_ERROR_UNCLOSED_TOKEN ; case XML_TOK_PARTIAL_CHAR : return XML_ERROR_PARTIAL_CHAR ; case XML_TOK_NONE : default : break ; } return storeEntityValue ( parser , encoding , s , end ) ; } else if ( tok == XML_TOK_XML_DECL ) { enum XML_Error result ; result = processXmlDecl ( parser , 0 , start , next ) ; if ( result != XML_ERROR_NONE ) return result ; switch ( ps_parsing ) { case XML_SUSPENDED : * nextPtr = next ; return XML_ERROR_NONE ; case XML_FINISHED : return XML_ERROR_ABORTED ; default : * nextPtr = next ; } processor = entityValueProcessor ; return entityValueProcessor ( parser , next , end , nextPtr ) ; } else if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer ) { * nextPtr = next ; return XML_ERROR_NONE ; } <S2SV_StartBug> start = next ; <S2SV_EndBug> eventPtr = start ; } }", "target": "<S2SV_ModStart> XML_ERROR_NONE ; } else if ( tok == XML_TOK_INSTANCE_START ) { * nextPtr = next ; return XML_ERROR_SYNTAX ; }"}
{"source": "CWE-755 int h2_make_htx_request ( struct http_hdr * list , struct htx * htx , unsigned int * msgf , unsigned long long * body_len ) { struct ist phdr_val [ H2_PHDR_NUM_ENTRIES ] ; uint32_t fields ; uint32_t idx ; int ck , lck ; int phdr ; int ret ; int i ; struct htx_sl * sl = NULL ; unsigned int sl_flags = 0 ; const char * ctl ; lck = ck = - 1 ; fields = 0 ; for ( idx = 0 ; list [ idx ] . n . len != 0 ; idx ++ ) { if ( ! list [ idx ] . n . ptr ) { phdr = list [ idx ] . n . len ; } else { phdr = h2_str_to_phdr ( list [ idx ] . n ) ; for ( i = ! ! phdr ; i < list [ idx ] . n . len ; i ++ ) if ( ( uint8_t ) ( list [ idx ] . n . ptr [ i ] - 'A' ) < 'Z' - 'A' || ! HTTP_IS_TOKEN ( list [ idx ] . n . ptr [ i ] ) ) goto fail ; } ctl = ist_find_ctl ( list [ idx ] . v ) ; if ( unlikely ( ctl ) && has_forbidden_char ( list [ idx ] . v , ctl ) ) goto fail ; if ( phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES ) { if ( fields & ( ( 1 << phdr ) | H2_PHDR_FND_NONE ) ) { if ( fields & H2_PHDR_FND_NONE ) { goto fail ; } else { goto fail ; } } fields |= 1 << phdr ; phdr_val [ phdr ] = list [ idx ] . v ; continue ; } else if ( phdr != 0 ) { goto fail ; } if ( unlikely ( ! ( fields & H2_PHDR_FND_NONE ) ) ) { sl = h2_prepare_htx_reqline ( fields , phdr_val , htx , msgf ) ; if ( ! sl ) goto fail ; fields |= H2_PHDR_FND_NONE ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( isteq ( list [ idx ] . n , ist ( \"host\" ) ) ) <S2SV_EndBug> <S2SV_StartBug> fields |= H2_PHDR_FND_HOST ; <S2SV_EndBug> if ( isteq ( list [ idx ] . n , ist ( \"content-length\" ) ) ) { ret = h2_parse_cont_len_header ( msgf , & list [ idx ] . v , body_len ) ; if ( ret < 0 ) goto fail ; sl_flags |= HTX_SL_F_CLEN ; if ( ret == 0 ) continue ; } if ( isteq ( list [ idx ] . n , ist ( \"connection\" ) ) || isteq ( list [ idx ] . n , ist ( \"proxy-connection\" ) ) || isteq ( list [ idx ] . n , ist ( \"keep-alive\" ) ) || isteq ( list [ idx ] . n , ist ( \"upgrade\" ) ) || isteq ( list [ idx ] . n , ist ( \"transfer-encoding\" ) ) ) goto fail ; if ( isteq ( list [ idx ] . n , ist ( \"te\" ) ) && ! isteq ( list [ idx ] . v , ist ( \"trailers\" ) ) ) goto fail ; if ( isteq ( list [ idx ] . n , ist ( \"cookie\" ) ) ) { list [ idx ] . n . len = - 1 ; if ( ck < 0 ) ck = idx ; else list [ lck ] . n . len = idx ; lck = idx ; continue ; } if ( ! htx_add_header ( htx , list [ idx ] . n , list [ idx ] . v ) ) goto fail ; } if ( fields & H2_PHDR_FND_STAT ) goto fail ; if ( ! ( fields & H2_PHDR_FND_NONE ) ) { sl = h2_prepare_htx_reqline ( fields , phdr_val , htx , msgf ) ; if ( ! sl ) goto fail ; } if ( * msgf & H2_MSGF_BODY_TUNNEL ) * msgf &= ~ ( H2_MSGF_BODY | H2_MSGF_BODY_CL ) ; if ( ! ( * msgf & H2_MSGF_BODY ) || ( ( * msgf & H2_MSGF_BODY_CL ) && * body_len == 0 ) || ( * msgf & H2_MSGF_BODY_TUNNEL ) ) { sl_flags |= HTX_SL_F_BODYLESS ; htx -> flags |= HTX_FL_EOM ; } if ( * msgf & H2_MSGF_EXT_CONNECT ) { if ( ! htx_add_header ( htx , ist ( \"upgrade\" ) , phdr_val [ H2_PHDR_IDX_PROT ] ) ) goto fail ; if ( ! htx_add_header ( htx , ist ( \"connection\" ) , ist ( \"upgrade\" ) ) ) goto fail ; sl_flags |= HTX_SL_F_CONN_UPG ; } sl -> flags |= sl_flags ; if ( ( fields & ( H2_PHDR_FND_HOST | H2_PHDR_FND_AUTH ) ) == H2_PHDR_FND_AUTH ) { if ( ! htx_add_header ( htx , ist ( \"host\" ) , phdr_val [ H2_PHDR_IDX_AUTH ] ) ) goto fail ; } if ( ck >= 0 ) { uint32_t fs ; uint32_t bs ; uint32_t vl ; uint32_t tl ; struct htx_blk * blk ; blk = htx_add_header ( htx , ist ( \"cookie\" ) , list [ ck ] . v ) ; if ( ! blk ) goto fail ; tl = list [ ck ] . v . len ; fs = htx_free_data_space ( htx ) ; bs = htx_get_blksz ( blk ) ; fs += tl ; while ( ( ck = list [ ck ] . n . len ) >= 0 ) { vl = list [ ck ] . v . len ; tl += vl + 2 ; if ( tl > fs ) goto fail ; htx_change_blk_value_len ( htx , blk , tl ) ; * ( char * ) ( htx_get_blk_ptr ( htx , blk ) + bs + 0 ) = ';' ; * ( char * ) ( htx_get_blk_ptr ( htx , blk ) + bs + 1 ) = '<S2SV_blank>' ; memcpy ( htx_get_blk_ptr ( htx , blk ) + bs + 2 , list [ ck ] . v . ptr , vl ) ; bs += vl + 2 ; } } if ( ! htx_add_endof ( htx , HTX_BLK_EOH ) ) goto fail ; if ( fields & H2_PHDR_FND_SCHM ) http_scheme_based_normalize ( htx ) ; ret = 1 ; return ret ; fail : return - 1 ; }", "target": "<S2SV_ModStart> |= H2_PHDR_FND_NONE ; if ( fields & H2_PHDR_FND_AUTH ) { if ( ! htx_add_header ( htx <S2SV_ModEnd> , ist ( <S2SV_ModStart> ( \"host\" ) , phdr_val [ H2_PHDR_IDX_AUTH ] ) ) goto fail ; <S2SV_ModEnd> fields |= H2_PHDR_FND_HOST <S2SV_ModStart> |= H2_PHDR_FND_HOST ; } } if ( isteq ( list [ idx ] . n , ist ( \"host\" ) ) ) { if ( fields & H2_PHDR_FND_HOST ) continue ; fields |= H2_PHDR_FND_HOST ; }"}
{"source": "CWE-190 unserialize_uep ( bufinfo_T * bi , int * error , char_u * file_name ) { int i ; u_entry_T * uep ; <S2SV_StartBug> char_u * * array ; <S2SV_EndBug> char_u * line ; int line_len ; uep = ( u_entry_T * ) U_ALLOC_LINE ( sizeof ( u_entry_T ) ) ; if ( uep == NULL ) return NULL ; vim_memset ( uep , 0 , sizeof ( u_entry_T ) ) ; # ifdef U_DEBUG uep -> ue_magic = UE_MAGIC ; # endif uep -> ue_top = undo_read_4c ( bi ) ; uep -> ue_bot = undo_read_4c ( bi ) ; uep -> ue_lcount = undo_read_4c ( bi ) ; uep -> ue_size = undo_read_4c ( bi ) ; if ( uep -> ue_size > 0 ) { <S2SV_StartBug> array = ( char_u * * ) U_ALLOC_LINE ( sizeof ( char_u * ) * uep -> ue_size ) ; <S2SV_EndBug> if ( array == NULL ) { * error = TRUE ; return uep ; } vim_memset ( array , 0 , sizeof ( char_u * ) * uep -> ue_size ) ; } <S2SV_StartBug> else <S2SV_EndBug> array = NULL ; uep -> ue_array = array ; for ( i = 0 ; i < uep -> ue_size ; ++ i ) { line_len = undo_read_4c ( bi ) ; if ( line_len >= 0 ) line = read_string_decrypt ( bi , line_len ) ; else { line = NULL ; corruption_error ( \"line<S2SV_blank>length\" , file_name ) ; } if ( line == NULL ) { * error = TRUE ; return uep ; } array [ i ] = line ; } return uep ; }", "target": "<S2SV_ModStart> * * array = NULL <S2SV_ModStart> 0 ) { if ( uep -> ue_size < LONG_MAX / ( int ) sizeof ( char_u * ) ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> uep -> ue_array"}
{"source": "CWE-200 ares_parse_naptr_reply ( const unsigned char * abuf , int alen , struct ares_naptr_reply * * naptr_out ) { unsigned int qdcount , ancount , i ; const unsigned char * aptr , * vptr ; int status , rr_type , rr_class , rr_len ; long len ; char * hostname = NULL , * rr_name = NULL ; struct ares_naptr_reply * naptr_head = NULL ; struct ares_naptr_reply * naptr_last = NULL ; struct ares_naptr_reply * naptr_curr ; * naptr_out = NULL ; if ( alen < HFIXEDSZ ) return ARES_EBADRESP ; qdcount = DNS_HEADER_QDCOUNT ( abuf ) ; ancount = DNS_HEADER_ANCOUNT ( abuf ) ; if ( qdcount != 1 ) return ARES_EBADRESP ; if ( ancount == 0 ) return ARES_ENODATA ; aptr = abuf + HFIXEDSZ ; status = ares_expand_name ( aptr , abuf , alen , & hostname , & len ) ; if ( status != ARES_SUCCESS ) return status ; if ( aptr + len + QFIXEDSZ > abuf + alen ) { ares_free ( hostname ) ; return ARES_EBADRESP ; } aptr += len + QFIXEDSZ ; for ( i = 0 ; i < ancount ; i ++ ) { status = ares_expand_name ( aptr , abuf , alen , & rr_name , & len ) ; if ( status != ARES_SUCCESS ) { break ; } aptr += len ; if ( aptr + RRFIXEDSZ > abuf + alen ) { status = ARES_EBADRESP ; break ; } rr_type = DNS_RR_TYPE ( aptr ) ; rr_class = DNS_RR_CLASS ( aptr ) ; rr_len = DNS_RR_LEN ( aptr ) ; aptr += RRFIXEDSZ ; <S2SV_StartBug> if ( aptr + rr_len > abuf + alen ) <S2SV_EndBug> { status = ARES_EBADRESP ; break ; } if ( rr_len < 7 ) { status = ARES_EBADRESP ; break ; } if ( rr_class == C_IN && rr_type == T_NAPTR ) { <S2SV_StartBug> naptr_curr = ares_malloc_data ( ARES_DATATYPE_NAPTR_REPLY ) ; <S2SV_EndBug> if ( ! naptr_curr ) { status = ARES_ENOMEM ; break ; } if ( naptr_last ) { naptr_last -> next = naptr_curr ; } else { naptr_head = naptr_curr ; } naptr_last = naptr_curr ; vptr = aptr ; naptr_curr -> order = DNS__16BIT ( vptr ) ; vptr += sizeof ( unsigned short ) ; naptr_curr -> preference = DNS__16BIT ( vptr ) ; vptr += sizeof ( unsigned short ) ; status = ares_expand_string ( vptr , abuf , alen , & naptr_curr -> flags , & len ) ; if ( status != ARES_SUCCESS ) break ; vptr += len ; status = ares_expand_string ( vptr , abuf , alen , & naptr_curr -> service , & len ) ; if ( status != ARES_SUCCESS ) break ; vptr += len ; status = ares_expand_string ( vptr , abuf , alen , & naptr_curr -> regexp , & len ) ; if ( status != ARES_SUCCESS ) break ; vptr += len ; status = ares_expand_name ( vptr , abuf , alen , & naptr_curr -> replacement , & len ) ; if ( status != ARES_SUCCESS ) break ; } ares_free ( rr_name ) ; rr_name = NULL ; aptr += rr_len ; } if ( hostname ) ares_free ( hostname ) ; if ( rr_name ) ares_free ( rr_name ) ; if ( status != ARES_SUCCESS ) { if ( naptr_head ) ares_free_data ( naptr_head ) ; return status ; } * naptr_out = naptr_head ; return ARES_SUCCESS ; }", "target": "<S2SV_ModStart> abuf + alen <S2SV_ModEnd> ) { status <S2SV_ModStart> T_NAPTR ) { if ( rr_len < 7 ) { status = ARES_EBADRESP ; break ; }"}
{"source": "CWE-125 rpmRC hdrblobInit ( const void * uh , size_t uc , rpmTagVal regionTag , int exact_size , struct hdrblob_s * blob , char * * emsg ) { rpmRC rc = RPMRC_FAIL ; memset ( blob , 0 , sizeof ( * blob ) ) ; <S2SV_StartBug> blob -> ei = ( int32_t * ) uh ; <S2SV_EndBug> <S2SV_StartBug> blob -> il = ntohl ( blob -> ei [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> blob -> dl = ntohl ( blob -> ei [ 1 ] ) ; <S2SV_EndBug> blob -> pe = ( entryInfo ) & ( blob -> ei [ 2 ] ) ; blob -> pvlen = sizeof ( blob -> il ) + sizeof ( blob -> dl ) + ( blob -> il * sizeof ( * blob -> pe ) ) + blob -> dl ; blob -> dataStart = ( uint8_t * ) ( blob -> pe + blob -> il ) ; blob -> dataEnd = blob -> dataStart + blob -> dl ; if ( blob -> pvlen >= headerMaxbytes || ( uc && blob -> pvlen != uc ) ) { rasprintf ( emsg , _ ( \"blob<S2SV_blank>size(%d):<S2SV_blank>BAD,<S2SV_blank>8<S2SV_blank>+<S2SV_blank>16<S2SV_blank>*<S2SV_blank>il(%d)<S2SV_blank>+<S2SV_blank>dl(%d)\" ) , blob -> pvlen , blob -> il , blob -> dl ) ; goto exit ; } if ( hdrblobVerifyRegion ( regionTag , exact_size , blob , emsg ) == RPMRC_FAIL ) goto exit ; if ( hdrblobVerifyInfo ( blob , emsg ) ) goto exit ; rc = RPMRC_OK ; exit : return rc ; }", "target": "<S2SV_ModStart> ) ) ; if ( uc && uc < 8 ) { rasprintf ( emsg , _ ( \"hdr<S2SV_blank>length:<S2SV_blank>BAD\" ) ) ; goto exit ; } <S2SV_ModStart> il = ntohl ( ( uint32_t ) <S2SV_ModStart> 0 ] ) ) <S2SV_ModStart> dl = ntohl ( ( uint32_t ) <S2SV_ModStart> 1 ] ) ) ; if ( hdrblobVerifyLengths ( regionTag , blob -> il , blob -> dl , emsg ) != RPMRC_OK ) goto exit ; <S2SV_ModEnd> blob -> pe"}
{"source": "CWE-125 static x3f_huffnode_t * new_node ( x3f_hufftree_t * tree ) <S2SV_StartBug> { <S2SV_EndBug> x3f_huffnode_t * t = & tree -> nodes [ tree -> free_node_index ] ; t -> branch [ 0 ] = NULL ; t -> branch [ 1 ] = NULL ; t -> leaf = UNDEFINED_LEAF ; tree -> free_node_index ++ ; return t ; }", "target": "<S2SV_ModStart> tree ) { if ( tree -> free_node_index >= tree -> total_node_index ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;"}
{"source": "CWE-703 static int rawsock_create ( struct net * net , struct socket * sock , const struct nfc_protocol * nfc_proto , int kern ) { struct sock * sk ; pr_debug ( \"sock=%p\\\\n\" , sock ) ; if ( ( sock -> type != SOCK_SEQPACKET ) && ( sock -> type != SOCK_RAW ) ) return - ESOCKTNOSUPPORT ; <S2SV_StartBug> if ( sock -> type == SOCK_RAW ) <S2SV_EndBug> sock -> ops = & rawsock_raw_ops ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> sock -> ops = & rawsock_ops ; <S2SV_EndBug> sk = sk_alloc ( net , PF_NFC , GFP_ATOMIC , nfc_proto -> proto , kern ) ; if ( ! sk ) return - ENOMEM ; sock_init_data ( sock , sk ) ; sk -> sk_protocol = nfc_proto -> id ; sk -> sk_destruct = rawsock_destruct ; sock -> state = SS_UNCONNECTED ; if ( sock -> type == SOCK_RAW ) nfc_sock_link ( & raw_sk_list , sk ) ; else { INIT_WORK ( & nfc_rawsock ( sk ) -> tx_work , rawsock_tx_work ) ; nfc_rawsock ( sk ) -> tx_work_scheduled = false ; } return 0 ; }", "target": "<S2SV_ModStart> == SOCK_RAW ) { if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ; <S2SV_ModStart> & rawsock_raw_ops ; } else { <S2SV_ModEnd> sock -> ops <S2SV_ModStart> & rawsock_ops ; }"}
{"source": "CWE-125 int LibRaw : : ljpeg_start ( struct jhead * jh , int info_only ) { ushort c , tag , len ; int cnt = 0 ; uchar data [ 0x10000 ] ; const uchar * dp ; memset ( jh , 0 , sizeof * jh ) ; jh -> restart = INT_MAX ; if ( ( fgetc ( ifp ) , fgetc ( ifp ) ) != 0xd8 ) return 0 ; do { if ( feof ( ifp ) ) return 0 ; if ( cnt ++ > 1024 ) return 0 ; if ( ! fread ( data , 2 , 2 , ifp ) ) return 0 ; tag = data [ 0 ] << 8 | data [ 1 ] ; len = ( data [ 2 ] << 8 | data [ 3 ] ) - 2 ; if ( tag <= 0xff00 ) return 0 ; fread ( data , 1 , len , ifp ) ; switch ( tag ) { case 0xffc3 : jh -> sraw = ( ( data [ 7 ] >> 4 ) * ( data [ 7 ] & 15 ) - 1 ) & 3 ; case 0xffc1 : case 0xffc0 : jh -> algo = tag & 0xff ; jh -> bits = data [ 0 ] ; jh -> high = data [ 1 ] << 8 | data [ 2 ] ; jh -> wide = data [ 3 ] << 8 | data [ 4 ] ; jh -> clrs = data [ 5 ] + jh -> sraw ; if ( len == 9 && ! dng_version ) getc ( ifp ) ; break ; case 0xffc4 : if ( info_only ) break ; for ( dp = data ; dp < data + len && ! ( ( c = * dp ++ ) & - 20 ) ; ) jh -> free [ c ] = jh -> huff [ c ] = make_decoder_ref ( & dp ) ; break ; case 0xffda : jh -> psv = data [ 1 + data [ 0 ] * 2 ] ; jh -> bits -= data [ 3 + data [ 0 ] * 2 ] & 15 ; break ; case 0xffdb : FORC ( 64 ) jh -> quant [ c ] = data [ c * 2 + 1 ] << 8 | data [ c * 2 + 2 ] ; break ; case 0xffdd : jh -> restart = data [ 0 ] << 8 | data [ 1 ] ; } } while ( tag != 0xffda ) ; if ( jh -> bits > 16 || jh -> clrs > 6 || ! jh -> bits || ! jh -> high || ! jh -> wide || ! jh -> clrs ) return 0 ; if ( info_only ) return 1 ; if ( ! jh -> huff [ 0 ] ) return 0 ; FORC ( 19 ) if ( ! jh -> huff [ c + 1 ] ) jh -> huff [ c + 1 ] = jh -> huff [ c ] ; if ( jh -> sraw ) { FORC ( 4 ) jh -> huff [ 2 + c ] = jh -> huff [ 1 ] ; FORC ( jh -> sraw ) jh -> huff [ 1 + c ] = jh -> huff [ 0 ] ; } <S2SV_StartBug> jh -> row = ( ushort * ) calloc ( jh -> wide * jh -> clrs , 4 ) ; <S2SV_EndBug> merror ( jh -> row , \"ljpeg_start()\" ) ; return zero_after_ff = 1 ; }", "target": "<S2SV_ModStart> -> clrs , 16 <S2SV_ModEnd> ) ; merror"}
{"source": "CWE-119 unsigned long move_page_tables ( struct vm_area_struct * vma , unsigned long old_addr , struct vm_area_struct * new_vma , unsigned long new_addr , unsigned long len , bool need_rmap_locks ) { unsigned long extent , next , old_end ; struct mmu_notifier_range range ; pmd_t * old_pmd , * new_pmd ; old_end = old_addr + len ; flush_cache_range ( vma , old_addr , old_end ) ; mmu_notifier_range_init ( & range , MMU_NOTIFY_UNMAP , 0 , vma , vma -> vm_mm , old_addr , old_end ) ; mmu_notifier_invalidate_range_start ( & range ) ; for ( ; old_addr < old_end ; old_addr += extent , new_addr += extent ) { cond_resched ( ) ; next = ( old_addr + PMD_SIZE ) & PMD_MASK ; extent = next - old_addr ; if ( extent > old_end - old_addr ) extent = old_end - old_addr ; old_pmd = get_old_pmd ( vma -> vm_mm , old_addr ) ; if ( ! old_pmd ) continue ; new_pmd = alloc_new_pmd ( vma -> vm_mm , vma , new_addr ) ; if ( ! new_pmd ) break ; <S2SV_StartBug> if ( is_swap_pmd ( * old_pmd ) || pmd_trans_huge ( * old_pmd ) ) { <S2SV_EndBug> if ( extent == HPAGE_PMD_SIZE ) { bool moved ; if ( need_rmap_locks ) take_rmap_locks ( vma ) ; moved = move_huge_pmd ( vma , old_addr , new_addr , old_end , old_pmd , new_pmd ) ; if ( need_rmap_locks ) drop_rmap_locks ( vma ) ; if ( moved ) continue ; } split_huge_pmd ( vma , old_pmd , old_addr ) ; if ( pmd_trans_unstable ( old_pmd ) ) continue ; } else if ( extent == PMD_SIZE ) { # ifdef CONFIG_HAVE_MOVE_PMD bool moved ; if ( need_rmap_locks ) take_rmap_locks ( vma ) ; moved = move_normal_pmd ( vma , old_addr , new_addr , old_end , old_pmd , new_pmd ) ; if ( need_rmap_locks ) drop_rmap_locks ( vma ) ; if ( moved ) continue ; # endif } if ( pte_alloc ( new_vma -> vm_mm , new_pmd ) ) break ; next = ( new_addr + PMD_SIZE ) & PMD_MASK ; if ( extent > next - new_addr ) extent = next - new_addr ; move_ptes ( vma , old_pmd , old_addr , old_addr + extent , new_vma , new_pmd , new_addr , need_rmap_locks ) ; } mmu_notifier_invalidate_range_end ( & range ) ; return len + old_addr - old_end ; }", "target": "<S2SV_ModStart> * old_pmd ) || pmd_devmap ( * old_pmd )"}
{"source": "CWE-77 Sfdouble_t sh_strnum ( Shell_t * shp , const char * str , char * * ptr , int mode ) { Sfdouble_t d ; char * last ; if ( * str == 0 ) { <S2SV_StartBug> if ( ptr ) * ptr = ( char * ) str ; <S2SV_EndBug> return 0 ; } errno = 0 ; d = number ( str , & last , shp -> inarith ? 0 : 10 , NULL ) ; <S2SV_StartBug> if ( * last ) { <S2SV_EndBug> if ( * last != '.' || last [ 1 ] != '.' ) { d = strval ( shp , str , & last , arith , mode ) ; Varsubscript = true ; } <S2SV_StartBug> if ( ! ptr && * last && mode > 0 ) errormsg ( SH_DICT , ERROR_exit ( 1 ) , e_lexbadchar , * last , str ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! d && * str == '-' ) { <S2SV_EndBug> d = - 0.0 ; } <S2SV_StartBug> if ( ptr ) * ptr = last ; <S2SV_EndBug> return d ; }", "target": "<S2SV_ModStart> 0 ) { d = 0.0 ; last = ( char * ) str ; } else { <S2SV_ModEnd> d = number <S2SV_ModStart> ( * last && ! shp -> inarith && sh_isstate ( shp , SH_INIT ) ) { d = number ( str , & last , 0 , NULL ) ; } if ( * last ) { if ( sh_isstate ( shp , SH_INIT ) ) { d = 0.0 ; } else <S2SV_ModEnd> { if ( <S2SV_ModStart> > 0 ) { <S2SV_ModStart> ) ; } } } <S2SV_ModStart> else if ( d == 0.0 <S2SV_ModEnd> && * str <S2SV_ModStart> 0.0 ; } }"}
{"source": "CWE-362 <S2SV_StartBug> extern int x11_set_xauth ( char * xauthority , char * cookie , <S2SV_EndBug> char * host , uint16_t display ) { int i = 0 , status ; char * result ; char * * xauth_argv ; xauth_argv = xmalloc ( sizeof ( char * ) * 10 ) ; xauth_argv [ i ++ ] = xstrdup ( \"xauth\" ) ; xauth_argv [ i ++ ] = xstrdup ( \"-v\" ) ; xauth_argv [ i ++ ] = xstrdup ( \"-f\" ) ; xauth_argv [ i ++ ] = xstrdup ( xauthority ) ; <S2SV_StartBug> xauth_argv [ i ++ ] = xstrdup ( \"add\" ) ; <S2SV_EndBug> <S2SV_StartBug> xauth_argv [ i ++ ] = xstrdup_printf ( \"%s/unix:%u\" , host , display ) ; <S2SV_EndBug> xauth_argv [ i ++ ] = xstrdup ( \"MIT-MAGIC-COOKIE-1\" ) ; xauth_argv [ i ++ ] = xstrdup ( cookie ) ; xauth_argv [ i ++ ] = NULL ; xassert ( i < 10 ) ; result = run_command ( \"xauth\" , XAUTH_PATH , xauth_argv , 10000 , 0 , & status ) ; free_command_argv ( xauth_argv ) ; debug2 ( \"%s:<S2SV_blank>result<S2SV_blank>from<S2SV_blank>xauth:<S2SV_blank>%s\" , __func__ , result ) ; xfree ( result ) ; return status ; }", "target": "<S2SV_ModStart> <S2SV_null> extern int x11_delete_xauth <S2SV_ModEnd> ( char * <S2SV_ModStart> * xauthority , <S2SV_ModEnd> char * host <S2SV_ModStart> = xstrdup ( \"remove\" <S2SV_ModEnd> ) ; xauth_argv <S2SV_ModStart> host , display <S2SV_ModEnd> ) ; xauth_argv"}
{"source": "CWE-787 archive_string_append_from_wcs ( struct archive_string * as , const wchar_t * w , size_t len ) { int n , ret_val = 0 ; char * p ; char * end ; # if HAVE_WCRTOMB mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; # else wctomb ( NULL , L'\\\\0' ) ; # endif if ( archive_string_ensure ( as , as -> length + len + 1 ) == NULL ) return ( - 1 ) ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; while ( * w != L'\\\\0' && len > 0 ) { if ( p >= end ) { as -> length = p - as -> s ; as -> s [ as -> length ] = '\\\\0' ; if ( archive_string_ensure ( as , <S2SV_StartBug> as -> length + len * 2 + 1 ) == NULL ) <S2SV_EndBug> return ( - 1 ) ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; } # if HAVE_WCRTOMB n = wcrtomb ( p , * w ++ , & shift_state ) ; # else n = wctomb ( p , * w ++ ) ; # endif if ( n == - 1 ) { if ( errno == EILSEQ ) { * p ++ = '?' ; ret_val = - 1 ; } else { ret_val = - 1 ; break ; } } else p += n ; len -- ; } as -> length = p - as -> s ; as -> s [ as -> length ] = '\\\\0' ; return ( ret_val ) ; }", "target": "<S2SV_ModStart> -> length + max ( <S2SV_ModStart> len * 2 , ( size_t ) MB_CUR_MAX )"}
{"source": "CWE-416 void __do_SAK ( struct tty_struct * tty ) { # ifdef TTY_SOFT_SAK tty_hangup ( tty ) ; # else struct task_struct * g , * p ; struct pid * session ; int i ; <S2SV_StartBug> <S2SV_EndBug> if ( ! tty ) return ; <S2SV_StartBug> session = tty -> session ; <S2SV_EndBug> tty_ldisc_flush ( tty ) ; tty_driver_flush_buffer ( tty ) ; read_lock ( & tasklist_lock ) ; do_each_pid_task ( session , PIDTYPE_SID , p ) { tty_notice ( tty , \"SAK:<S2SV_blank>killed<S2SV_blank>process<S2SV_blank>%d<S2SV_blank>(%s):<S2SV_blank>by<S2SV_blank>session\\\\n\" , task_pid_nr ( p ) , p -> comm ) ; group_send_sig_info ( SIGKILL , SEND_SIG_PRIV , p , PIDTYPE_SID ) ; } while_each_pid_task ( session , PIDTYPE_SID , p ) ; do_each_thread ( g , p ) { if ( p -> signal -> tty == tty ) { tty_notice ( tty , \"SAK:<S2SV_blank>killed<S2SV_blank>process<S2SV_blank>%d<S2SV_blank>(%s):<S2SV_blank>by<S2SV_blank>controlling<S2SV_blank>tty\\\\n\" , task_pid_nr ( p ) , p -> comm ) ; group_send_sig_info ( SIGKILL , SEND_SIG_PRIV , p , PIDTYPE_SID ) ; continue ; } task_lock ( p ) ; i = iterate_fd ( p -> files , 0 , this_tty , tty ) ; if ( i != 0 ) { tty_notice ( tty , \"SAK:<S2SV_blank>killed<S2SV_blank>process<S2SV_blank>%d<S2SV_blank>(%s):<S2SV_blank>by<S2SV_blank>fd#%d\\\\n\" , task_pid_nr ( p ) , p -> comm , i - 1 ) ; group_send_sig_info ( SIGKILL , SEND_SIG_PRIV , p , PIDTYPE_SID ) ; } task_unlock ( p ) ; } while_each_thread ( g , p ) ; read_unlock ( & tasklist_lock ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }", "target": "<S2SV_ModStart> int i ; unsigned long flags ; <S2SV_ModStart> ) return ; spin_lock_irqsave ( & tty -> ctrl_lock , flags ) ; session = get_pid ( tty -> session ) ; spin_unlock_irqrestore ( & tty -> ctrl_lock , flags ) <S2SV_ModEnd> ; tty_ldisc_flush ( <S2SV_ModStart> tasklist_lock ) ; put_pid ( session ) ;"}
{"source": "CWE-125 long uv__idna_toascii ( const char * s , const char * se , char * d , char * de ) { const char * si ; const char * st ; unsigned c ; char * ds ; int rc ; ds = d ; <S2SV_StartBug> for ( si = s ; si < se ; ) { <S2SV_EndBug> st = si ; <S2SV_StartBug> c = uv__utf8_decode1 ( & si , se ) ; <S2SV_EndBug> if ( c != '.' ) if ( c != 0x3002 ) if ( c != 0xFF0E ) if ( c != 0xFF61 ) continue ; rc = uv__idna_toascii_label ( s , st , & d , de ) ; if ( rc < 0 ) return rc ; if ( d < de ) * d ++ = '.' ; s = si ; } if ( s < se ) { rc = uv__idna_toascii_label ( s , se , & d , de ) ; if ( rc < 0 ) return rc ; } if ( d < de ) * d ++ = '\\\\0' ; return d - ds ; }", "target": "<S2SV_ModStart> = d ; si = s ; while ( si < se <S2SV_ModEnd> ) { st <S2SV_ModStart> , se ) ; if ( c == - 1u ) return UV_EINVAL"}
{"source": "CWE-665 static int nf_tables_newset ( struct sk_buff * skb , const struct nfnl_info * info , const struct nlattr * const nla [ ] ) { const struct nfgenmsg * nfmsg = nlmsg_data ( info -> nlh ) ; u32 ktype , dtype , flags , policy , gc_int , objtype ; struct netlink_ext_ack * extack = info -> extack ; u8 genmask = nft_genmask_next ( info -> net ) ; int family = nfmsg -> nfgen_family ; const struct nft_set_ops * ops ; struct nft_expr * expr = NULL ; struct net * net = info -> net ; struct nft_set_desc desc ; struct nft_table * table ; unsigned char * udata ; struct nft_set * set ; struct nft_ctx ctx ; size_t alloc_size ; u64 timeout ; char * name ; int err , i ; u16 udlen ; u64 size ; if ( nla [ NFTA_SET_TABLE ] == NULL || nla [ NFTA_SET_NAME ] == NULL || nla [ NFTA_SET_KEY_LEN ] == NULL || nla [ NFTA_SET_ID ] == NULL ) return - EINVAL ; memset ( & desc , 0 , sizeof ( desc ) ) ; ktype = NFT_DATA_VALUE ; if ( nla [ NFTA_SET_KEY_TYPE ] != NULL ) { ktype = ntohl ( nla_get_be32 ( nla [ NFTA_SET_KEY_TYPE ] ) ) ; if ( ( ktype & NFT_DATA_RESERVED_MASK ) == NFT_DATA_RESERVED_MASK ) return - EINVAL ; } desc . klen = ntohl ( nla_get_be32 ( nla [ NFTA_SET_KEY_LEN ] ) ) ; if ( desc . klen == 0 || desc . klen > NFT_DATA_VALUE_MAXLEN ) return - EINVAL ; flags = 0 ; if ( nla [ NFTA_SET_FLAGS ] != NULL ) { flags = ntohl ( nla_get_be32 ( nla [ NFTA_SET_FLAGS ] ) ) ; if ( flags & ~ ( NFT_SET_ANONYMOUS | NFT_SET_CONSTANT | NFT_SET_INTERVAL | NFT_SET_TIMEOUT | NFT_SET_MAP | NFT_SET_EVAL | NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR ) ) return - EOPNOTSUPP ; if ( ( flags & ( NFT_SET_MAP | NFT_SET_OBJECT ) ) == ( NFT_SET_MAP | NFT_SET_OBJECT ) ) return - EOPNOTSUPP ; if ( ( flags & ( NFT_SET_EVAL | NFT_SET_OBJECT ) ) == ( NFT_SET_EVAL | NFT_SET_OBJECT ) ) return - EOPNOTSUPP ; } dtype = 0 ; if ( nla [ NFTA_SET_DATA_TYPE ] != NULL ) { if ( ! ( flags & NFT_SET_MAP ) ) return - EINVAL ; dtype = ntohl ( nla_get_be32 ( nla [ NFTA_SET_DATA_TYPE ] ) ) ; if ( ( dtype & NFT_DATA_RESERVED_MASK ) == NFT_DATA_RESERVED_MASK && dtype != NFT_DATA_VERDICT ) return - EINVAL ; if ( dtype != NFT_DATA_VERDICT ) { if ( nla [ NFTA_SET_DATA_LEN ] == NULL ) return - EINVAL ; desc . dlen = ntohl ( nla_get_be32 ( nla [ NFTA_SET_DATA_LEN ] ) ) ; if ( desc . dlen == 0 || desc . dlen > NFT_DATA_VALUE_MAXLEN ) return - EINVAL ; } else desc . dlen = sizeof ( struct nft_verdict ) ; } else if ( flags & NFT_SET_MAP ) return - EINVAL ; if ( nla [ NFTA_SET_OBJ_TYPE ] != NULL ) { if ( ! ( flags & NFT_SET_OBJECT ) ) return - EINVAL ; objtype = ntohl ( nla_get_be32 ( nla [ NFTA_SET_OBJ_TYPE ] ) ) ; if ( objtype == NFT_OBJECT_UNSPEC || objtype > NFT_OBJECT_MAX ) return - EOPNOTSUPP ; } else if ( flags & NFT_SET_OBJECT ) return - EINVAL ; else objtype = NFT_OBJECT_UNSPEC ; timeout = 0 ; if ( nla [ NFTA_SET_TIMEOUT ] != NULL ) { if ( ! ( flags & NFT_SET_TIMEOUT ) ) return - EINVAL ; err = nf_msecs_to_jiffies64 ( nla [ NFTA_SET_TIMEOUT ] , & timeout ) ; if ( err ) return err ; } gc_int = 0 ; if ( nla [ NFTA_SET_GC_INTERVAL ] != NULL ) { if ( ! ( flags & NFT_SET_TIMEOUT ) ) return - EINVAL ; gc_int = ntohl ( nla_get_be32 ( nla [ NFTA_SET_GC_INTERVAL ] ) ) ; } policy = NFT_SET_POL_PERFORMANCE ; if ( nla [ NFTA_SET_POLICY ] != NULL ) policy = ntohl ( nla_get_be32 ( nla [ NFTA_SET_POLICY ] ) ) ; if ( nla [ NFTA_SET_DESC ] != NULL ) { err = nf_tables_set_desc_parse ( & desc , nla [ NFTA_SET_DESC ] ) ; if ( err < 0 ) return err ; } if ( nla [ NFTA_SET_EXPR ] || nla [ NFTA_SET_EXPRESSIONS ] ) desc . expr = true ; table = nft_table_lookup ( net , nla [ NFTA_SET_TABLE ] , family , genmask , NETLINK_CB ( skb ) . portid ) ; if ( IS_ERR ( table ) ) { NL_SET_BAD_ATTR ( extack , nla [ NFTA_SET_TABLE ] ) ; return PTR_ERR ( table ) ; } nft_ctx_init ( & ctx , net , skb , info -> nlh , family , table , NULL , nla ) ; set = nft_set_lookup ( table , nla [ NFTA_SET_NAME ] , genmask ) ; if ( IS_ERR ( set ) ) { if ( PTR_ERR ( set ) != - ENOENT ) { NL_SET_BAD_ATTR ( extack , nla [ NFTA_SET_NAME ] ) ; return PTR_ERR ( set ) ; } } else { if ( info -> nlh -> nlmsg_flags & NLM_F_EXCL ) { NL_SET_BAD_ATTR ( extack , nla [ NFTA_SET_NAME ] ) ; return - EEXIST ; } if ( info -> nlh -> nlmsg_flags & NLM_F_REPLACE ) return - EOPNOTSUPP ; return 0 ; } if ( ! ( info -> nlh -> nlmsg_flags & NLM_F_CREATE ) ) return - ENOENT ; ops = nft_select_set_ops ( & ctx , nla , & desc , policy ) ; if ( IS_ERR ( ops ) ) return PTR_ERR ( ops ) ; udlen = 0 ; if ( nla [ NFTA_SET_USERDATA ] ) udlen = nla_len ( nla [ NFTA_SET_USERDATA ] ) ; size = 0 ; if ( ops -> privsize != NULL ) size = ops -> privsize ( nla , & desc ) ; alloc_size = sizeof ( * set ) + size + udlen ; if ( alloc_size < size ) return - ENOMEM ; set = kvzalloc ( alloc_size , GFP_KERNEL ) ; if ( ! set ) return - ENOMEM ; name = nla_strdup ( nla [ NFTA_SET_NAME ] , GFP_KERNEL ) ; if ( ! name ) { err = - ENOMEM ; goto err_set_name ; } err = nf_tables_set_alloc_name ( & ctx , set , name ) ; kfree ( name ) ; if ( err < 0 ) <S2SV_StartBug> goto err_set_alloc_name ; <S2SV_EndBug> if ( nla [ NFTA_SET_EXPR ] ) { expr = nft_set_elem_expr_alloc ( & ctx , set , nla [ NFTA_SET_EXPR ] ) ; if ( IS_ERR ( expr ) ) { err = PTR_ERR ( expr ) ; <S2SV_StartBug> goto err_set_alloc_name ; <S2SV_EndBug> } set -> exprs [ 0 ] = expr ; set -> num_exprs ++ ; } else if ( nla [ NFTA_SET_EXPRESSIONS ] ) { struct nft_expr * expr ; struct nlattr * tmp ; int left ; if ( ! ( flags & NFT_SET_EXPR ) ) { err = - EINVAL ; <S2SV_StartBug> goto err_set_alloc_name ; <S2SV_EndBug> } i = 0 ; nla_for_each_nested ( tmp , nla [ NFTA_SET_EXPRESSIONS ] , left ) { if ( i == NFT_SET_EXPR_MAX ) { err = - E2BIG ; <S2SV_StartBug> goto err_set_init ; <S2SV_EndBug> } if ( nla_type ( tmp ) != NFTA_LIST_ELEM ) { err = - EINVAL ; <S2SV_StartBug> goto err_set_init ; <S2SV_EndBug> } expr = nft_set_elem_expr_alloc ( & ctx , set , tmp ) ; if ( IS_ERR ( expr ) ) { err = PTR_ERR ( expr ) ; <S2SV_StartBug> goto err_set_init ; <S2SV_EndBug> } set -> exprs [ i ++ ] = expr ; set -> num_exprs ++ ; } } <S2SV_StartBug> udata = NULL ; <S2SV_EndBug> if ( udlen ) { udata = set -> data + size ; nla_memcpy ( udata , nla [ NFTA_SET_USERDATA ] , udlen ) ; } INIT_LIST_HEAD ( & set -> bindings ) ; INIT_LIST_HEAD ( & set -> catchall_list ) ; set -> table = table ; write_pnet ( & set -> net , net ) ; set -> ops = ops ; set -> ktype = ktype ; set -> klen = desc . klen ; set -> dtype = dtype ; set -> objtype = objtype ; set -> dlen = desc . dlen ; set -> flags = flags ; set -> size = desc . size ; set -> policy = policy ; set -> udlen = udlen ; set -> udata = udata ; set -> timeout = timeout ; set -> gc_int = gc_int ; set -> handle = nf_tables_alloc_handle ( table ) ; set -> field_count = desc . field_count ; <S2SV_StartBug> for ( i = 0 ; i < desc . field_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> set -> field_len [ i ] = desc . field_len [ i ] ; <S2SV_EndBug> err = ops -> init ( set , & desc , nla ) ; if ( err < 0 ) goto err_set_init ; err = nft_trans_set_add ( & ctx , NFT_MSG_NEWSET , set ) ; if ( err < 0 ) goto err_set_trans ; list_add_tail_rcu ( & set -> list , & table -> sets ) ; table -> use ++ ; return 0 ; err_set_trans : ops -> destroy ( set ) ; err_set_init : <S2SV_StartBug> for ( i = 0 ; i < set -> num_exprs ; i ++ ) <S2SV_EndBug> nft_expr_destroy ( & ctx , set -> exprs [ i ] ) ; err_set_alloc_name : kfree ( set -> name ) ; err_set_name : kvfree ( set ) ; return err ; }", "target": "<S2SV_ModStart> 0 ) goto err_set_name ; udata = NULL ; if ( udlen ) { udata = set -> data + size ; nla_memcpy ( udata , nla [ NFTA_SET_USERDATA ] , udlen ) ; } INIT_LIST_HEAD ( & set -> bindings ) ; INIT_LIST_HEAD ( & set -> catchall_list ) ; set -> table = table ; write_pnet ( & set -> net , net ) ; set -> ops = ops ; set -> ktype = ktype ; set -> klen = desc . klen ; set -> dtype = dtype ; set -> objtype = objtype ; set -> dlen = desc . dlen ; set -> flags = flags ; set -> size = desc . size ; set -> policy = policy ; set -> udlen = udlen ; set -> udata = udata ; set -> timeout = timeout ; set -> gc_int = gc_int ; set -> field_count = desc . field_count ; for ( i = 0 ; i < desc . field_count ; i ++ ) set -> field_len [ i ] = desc . field_len [ i ] ; err = ops -> init ( set , & desc , nla ) ; if ( err < 0 ) goto err_set_init <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; goto err_set_expr_alloc <S2SV_ModEnd> ; } set <S2SV_ModStart> EINVAL ; goto err_set_expr_alloc <S2SV_ModEnd> ; } i <S2SV_ModStart> E2BIG ; goto err_set_expr_alloc <S2SV_ModEnd> ; } if <S2SV_ModStart> EINVAL ; goto err_set_expr_alloc <S2SV_ModEnd> ; } expr <S2SV_ModStart> ) ; goto err_set_expr_alloc <S2SV_ModEnd> ; } set <S2SV_ModStart> ; } } set -> handle = nf_tables_alloc_handle ( table ) ; err = nft_trans_set_add ( & ctx , NFT_MSG_NEWSET , set ) ; if ( err < 0 ) goto err_set_expr_alloc ; list_add_tail_rcu ( & set -> list , & table -> sets ) ; table -> use ++ ; return 0 ; err_set_expr_alloc : <S2SV_ModEnd> for ( i <S2SV_ModStart> ; i < set -> num_exprs <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ ) nft_expr_destroy ( & ctx , set -> exprs <S2SV_ModEnd> [ i ] <S2SV_ModStart> [ i ] ) ; <S2SV_ModEnd> ops -> destroy <S2SV_ModStart> ; err_set_init : <S2SV_ModEnd> kfree ( set"}
{"source": "CWE-787 <S2SV_StartBug> static void scalar32_min_max_or ( struct bpf_reg_state * dst_reg , <S2SV_EndBug> struct bpf_reg_state * src_reg ) { <S2SV_StartBug> bool src_known = tnum_subreg_is_const ( src_reg -> var_off ) ; <S2SV_EndBug> <S2SV_StartBug> bool dst_known = tnum_subreg_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> <S2SV_StartBug> struct tnum var32_off = tnum_subreg ( dst_reg -> var_off ) ; <S2SV_EndBug> s32 smin_val = src_reg -> smin_value ; <S2SV_StartBug> u32 umin_val = src_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> if ( src_known && dst_known ) <S2SV_EndBug> return ; <S2SV_StartBug> dst_reg -> u32_min_value = max ( dst_reg -> u32_min_value , umin_val ) ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> u32_max_value = var32_off . value | var32_off . mask ; <S2SV_EndBug> <S2SV_StartBug> if ( dst_reg -> s32_min_value < 0 || smin_val < 0 ) { <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_min_value = S32_MIN ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_max_value = S32_MAX ; <S2SV_EndBug> } else { <S2SV_StartBug> dst_reg -> s32_min_value = dst_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_max_value = dst_reg -> umax_value ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> <S2SV_null> static void scalar_min_max_or <S2SV_ModEnd> ( struct bpf_reg_state <S2SV_ModStart> bool src_known = tnum_is_const <S2SV_ModEnd> ( src_reg -> <S2SV_ModStart> bool dst_known = tnum_is_const <S2SV_ModEnd> ( dst_reg -> <S2SV_ModStart> var_off ) ; s64 <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> -> smin_value ; u64 <S2SV_ModEnd> umin_val = src_reg <S2SV_ModStart> && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg -> var_off . value ) ; return ; } dst_reg -> umin_value <S2SV_ModEnd> = max ( <S2SV_ModStart> ( dst_reg -> umin_value <S2SV_ModEnd> , umin_val ) <S2SV_ModStart> ; dst_reg -> umax_value = dst_reg -> var_off <S2SV_ModEnd> . value | <S2SV_ModStart> . value | dst_reg -> var_off <S2SV_ModEnd> . mask ; <S2SV_ModStart> ( dst_reg -> smin_value <S2SV_ModEnd> < 0 || <S2SV_ModStart> { dst_reg -> smin_value = S64_MIN <S2SV_ModEnd> ; dst_reg -> <S2SV_ModStart> ; dst_reg -> smax_value = S64_MAX <S2SV_ModEnd> ; } else <S2SV_ModStart> { dst_reg -> smin_value <S2SV_ModEnd> = dst_reg -> <S2SV_ModStart> ; dst_reg -> smax_value <S2SV_ModEnd> = dst_reg -> <S2SV_ModStart> umax_value ; } __update_reg_bounds ( dst_reg ) ;"}
{"source": "CWE-476 slap_modrdn2mods ( Operation * op , SlapReply * rs ) { int a_cnt , d_cnt ; LDAPRDN old_rdn = NULL ; LDAPRDN new_rdn = NULL ; assert ( ! BER_BVISEMPTY ( & op -> oq_modrdn . rs_newrdn ) ) ; if ( BER_BVISEMPTY ( & op -> o_req_dn ) ) op -> orr_deleteoldrdn = 0 ; if ( ldap_bv2rdn_x ( & op -> oq_modrdn . rs_newrdn , & new_rdn , ( char * * ) & rs -> sr_text , LDAP_DN_FORMAT_LDAP , op -> o_tmpmemctx ) ) { Debug ( LDAP_DEBUG_TRACE , \"%s<S2SV_blank>slap_modrdn2mods:<S2SV_blank>can\\'t<S2SV_blank>figure<S2SV_blank>out<S2SV_blank>\" \"type(s)/value(s)<S2SV_blank>of<S2SV_blank>newrdn\\\\n\" , op -> o_log_prefix , 0 , 0 ) ; rs -> sr_err = LDAP_INVALID_DN_SYNTAX ; rs -> sr_text = \"unknown<S2SV_blank>type(s)/value(s)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>RDN\" ; goto done ; } if ( op -> oq_modrdn . rs_deleteoldrdn ) { if ( ldap_bv2rdn_x ( & op -> o_req_dn , & old_rdn , ( char * * ) & rs -> sr_text , LDAP_DN_FORMAT_LDAP , op -> o_tmpmemctx ) ) { Debug ( LDAP_DEBUG_TRACE , \"%s<S2SV_blank>slap_modrdn2mods:<S2SV_blank>can\\'t<S2SV_blank>figure<S2SV_blank>out<S2SV_blank>\" \"type(s)/value(s)<S2SV_blank>of<S2SV_blank>oldrdn\\\\n\" , op -> o_log_prefix , 0 , 0 ) ; rs -> sr_err = LDAP_OTHER ; rs -> sr_text = \"cannot<S2SV_blank>parse<S2SV_blank>RDN<S2SV_blank>from<S2SV_blank>old<S2SV_blank>DN\" ; goto done ; } } rs -> sr_text = NULL ; for ( a_cnt = 0 ; new_rdn [ a_cnt ] ; a_cnt ++ ) { AttributeDescription * desc = NULL ; Modifications * mod_tmp ; rs -> sr_err = slap_bv2ad ( & new_rdn [ a_cnt ] -> la_attr , & desc , & rs -> sr_text ) ; if ( rs -> sr_err != LDAP_SUCCESS ) { Debug ( LDAP_DEBUG_TRACE , \"%s<S2SV_blank>slap_modrdn2mods:<S2SV_blank>%s:<S2SV_blank>%s<S2SV_blank>(new)\\\\n\" , op -> o_log_prefix , rs -> sr_text , new_rdn [ a_cnt ] -> la_attr . bv_val ) ; goto done ; } if ( ! desc -> ad_type -> sat_equality ) { Debug ( LDAP_DEBUG_TRACE , \"%s<S2SV_blank>slap_modrdn2mods:<S2SV_blank>%s:<S2SV_blank>%s<S2SV_blank>(new)\\\\n\" , op -> o_log_prefix , rs -> sr_text , new_rdn [ a_cnt ] -> la_attr . bv_val ) ; rs -> sr_text = \"naming<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>no<S2SV_blank>equality<S2SV_blank>matching<S2SV_blank>rule\" ; rs -> sr_err = LDAP_NAMING_VIOLATION ; goto done ; } mod_tmp = ( Modifications * ) ch_malloc ( sizeof ( Modifications ) ) ; mod_tmp -> sml_desc = desc ; BER_BVZERO ( & mod_tmp -> sml_type ) ; mod_tmp -> sml_numvals = 1 ; mod_tmp -> sml_values = ( BerVarray ) ch_malloc ( 2 * sizeof ( struct berval ) ) ; ber_dupbv ( & mod_tmp -> sml_values [ 0 ] , & new_rdn [ a_cnt ] -> la_value ) ; mod_tmp -> sml_values [ 1 ] . bv_val = NULL ; if ( desc -> ad_type -> sat_equality -> smr_normalize ) { mod_tmp -> sml_nvalues = ( BerVarray ) ch_malloc ( 2 * sizeof ( struct berval ) ) ; rs -> sr_err = desc -> ad_type -> sat_equality -> smr_normalize ( SLAP_MR_EQUALITY | SLAP_MR_VALUE_OF_ASSERTION_SYNTAX , desc -> ad_type -> sat_syntax , desc -> ad_type -> sat_equality , & mod_tmp -> sml_values [ 0 ] , & mod_tmp -> sml_nvalues [ 0 ] , NULL ) ; if ( rs -> sr_err != LDAP_SUCCESS ) { ch_free ( mod_tmp -> sml_nvalues ) ; ch_free ( mod_tmp -> sml_values [ 0 ] . bv_val ) ; ch_free ( mod_tmp -> sml_values ) ; ch_free ( mod_tmp ) ; goto done ; } mod_tmp -> sml_nvalues [ 1 ] . bv_val = NULL ; } else { mod_tmp -> sml_nvalues = NULL ; } mod_tmp -> sml_op = SLAP_MOD_SOFTADD ; mod_tmp -> sml_flags = 0 ; mod_tmp -> sml_next = op -> orr_modlist ; op -> orr_modlist = mod_tmp ; } if ( op -> orr_deleteoldrdn ) { for ( d_cnt = 0 ; old_rdn [ d_cnt ] ; d_cnt ++ ) { AttributeDescription * desc = NULL ; Modifications * mod_tmp ; rs -> sr_err = slap_bv2ad ( & old_rdn [ d_cnt ] -> la_attr , & desc , & rs -> sr_text ) ; if ( rs -> sr_err != LDAP_SUCCESS ) { Debug ( LDAP_DEBUG_TRACE , \"%s<S2SV_blank>slap_modrdn2mods:<S2SV_blank>%s:<S2SV_blank>%s<S2SV_blank>(old)\\\\n\" , op -> o_log_prefix , rs -> sr_text , old_rdn [ d_cnt ] -> la_attr . bv_val ) ; goto done ; } mod_tmp = ( Modifications * ) ch_malloc ( sizeof ( Modifications ) ) ; mod_tmp -> sml_desc = desc ; BER_BVZERO ( & mod_tmp -> sml_type ) ; mod_tmp -> sml_numvals = 1 ; mod_tmp -> sml_values = ( BerVarray ) ch_malloc ( 2 * sizeof ( struct berval ) ) ; ber_dupbv ( & mod_tmp -> sml_values [ 0 ] , & old_rdn [ d_cnt ] -> la_value ) ; mod_tmp -> sml_values [ 1 ] . bv_val = NULL ; <S2SV_StartBug> if ( desc -> ad_type -> sat_equality -> smr_normalize ) { <S2SV_EndBug> mod_tmp -> sml_nvalues = ( BerVarray ) ch_malloc ( 2 * sizeof ( struct berval ) ) ; ( void ) ( * desc -> ad_type -> sat_equality -> smr_normalize ) ( SLAP_MR_EQUALITY | SLAP_MR_VALUE_OF_ASSERTION_SYNTAX , desc -> ad_type -> sat_syntax , desc -> ad_type -> sat_equality , & mod_tmp -> sml_values [ 0 ] , & mod_tmp -> sml_nvalues [ 0 ] , NULL ) ; mod_tmp -> sml_nvalues [ 1 ] . bv_val = NULL ; } else { mod_tmp -> sml_nvalues = NULL ; } mod_tmp -> sml_op = LDAP_MOD_DELETE ; mod_tmp -> sml_flags = 0 ; mod_tmp -> sml_next = op -> orr_modlist ; op -> orr_modlist = mod_tmp ; } } done : if ( rs -> sr_err != LDAP_SUCCESS && op -> orr_modlist != NULL ) { Modifications * tmp ; for ( ; op -> orr_modlist != NULL ; op -> orr_modlist = tmp ) { tmp = op -> orr_modlist -> sml_next ; ch_free ( op -> orr_modlist ) ; } } if ( new_rdn != NULL ) { ldap_rdnfree_x ( new_rdn , op -> o_tmpmemctx ) ; } if ( old_rdn != NULL ) { ldap_rdnfree_x ( old_rdn , op -> o_tmpmemctx ) ; } return rs -> sr_err ; }", "target": "<S2SV_ModStart> ; if ( desc -> ad_type -> sat_equality &&"}
{"source": "CWE-369 MagickExport Image * WaveImage ( const Image * image , const double amplitude , const double wave_length , const PixelInterpolateMethod method , ExceptionInfo * exception ) { # define WaveImageTag \"Wave/Image\" CacheView * canvas_image_view , * wave_view ; float * sine_map ; Image * canvas_image , * wave_image ; MagickBooleanType status ; MagickOffsetType progress ; ssize_t i ; ssize_t y ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; canvas_image = CloneImage ( image , 0 , 0 , MagickTrue , exception ) ; if ( canvas_image == ( Image * ) NULL ) return ( ( Image * ) NULL ) ; if ( ( canvas_image -> alpha_trait == UndefinedPixelTrait ) && ( canvas_image -> background_color . alpha != OpaqueAlpha ) ) ( void ) SetImageAlpha ( canvas_image , OpaqueAlpha , exception ) ; wave_image = CloneImage ( canvas_image , canvas_image -> columns , ( size_t ) ( canvas_image -> rows + 2.0 * fabs ( amplitude ) ) , MagickTrue , exception ) ; if ( wave_image == ( Image * ) NULL ) { canvas_image = DestroyImage ( canvas_image ) ; return ( ( Image * ) NULL ) ; } if ( SetImageStorageClass ( wave_image , DirectClass , exception ) == MagickFalse ) { canvas_image = DestroyImage ( canvas_image ) ; wave_image = DestroyImage ( wave_image ) ; return ( ( Image * ) NULL ) ; } sine_map = ( float * ) AcquireQuantumMemory ( ( size_t ) wave_image -> columns , sizeof ( * sine_map ) ) ; if ( sine_map == ( float * ) NULL ) { canvas_image = DestroyImage ( canvas_image ) ; wave_image = DestroyImage ( wave_image ) ; ThrowImageException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; i < ( ssize_t ) wave_image -> columns ; i ++ ) sine_map [ i ] = ( float ) fabs ( amplitude ) + amplitude * sin ( ( double ) <S2SV_StartBug> ( ( 2.0 * MagickPI * i ) / wave_length ) ) ; <S2SV_EndBug> status = MagickTrue ; progress = 0 ; canvas_image_view = AcquireVirtualCacheView ( canvas_image , exception ) ; wave_view = AcquireAuthenticCacheView ( wave_image , exception ) ; ( void ) SetCacheViewVirtualPixelMethod ( canvas_image_view , BackgroundVirtualPixelMethod ) ; # if defined ( MAGICKCORE_OPENMP_SUPPORT ) # pragma omp parallel for schedule ( static ) shared ( progress , status ) magick_number_threads ( canvas_image , wave_image , wave_image -> rows , 1 ) # endif for ( y = 0 ; y < ( ssize_t ) wave_image -> rows ; y ++ ) { const Quantum * magick_restrict p ; Quantum * magick_restrict q ; ssize_t x ; if ( status == MagickFalse ) continue ; p = GetCacheViewVirtualPixels ( canvas_image_view , 0 , y , canvas_image -> columns , 1 , exception ) ; q = QueueCacheViewAuthenticPixels ( wave_view , 0 , y , wave_image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) { status = MagickFalse ; continue ; } for ( x = 0 ; x < ( ssize_t ) wave_image -> columns ; x ++ ) { status = InterpolatePixelChannels ( canvas_image , canvas_image_view , wave_image , method , ( double ) x , ( double ) ( y - sine_map [ x ] ) , q , exception ) ; if ( status == MagickFalse ) break ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( wave_image ) ; } if ( SyncCacheViewAuthenticPixels ( wave_view , exception ) == MagickFalse ) status = MagickFalse ; if ( image -> progress_monitor != ( MagickProgressMonitor ) NULL ) { MagickBooleanType proceed ; # if defined ( MAGICKCORE_OPENMP_SUPPORT ) # pragma omp atomic # endif progress ++ ; proceed = SetImageProgress ( canvas_image , WaveImageTag , progress , canvas_image -> rows ) ; if ( proceed == MagickFalse ) status = MagickFalse ; } } wave_view = DestroyCacheView ( wave_view ) ; canvas_image_view = DestroyCacheView ( canvas_image_view ) ; canvas_image = DestroyImage ( canvas_image ) ; sine_map = ( float * ) RelinquishMagickMemory ( sine_map ) ; if ( status == MagickFalse ) wave_image = DestroyImage ( wave_image ) ; return ( wave_image ) ; }", "target": "<S2SV_ModStart> * i ) * PerceptibleReciprocal ( wave_length ) <S2SV_ModEnd> ) ) ;"}
{"source": "CWE-787 static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; <S2SV_StartBug> unsigned short macoff , netoff , hdrlen ; <S2SV_EndBug> struct sk_buff * copy_skb = NULL ; struct timespec64 ts ; __u32 ts_status ; bool is_drop_n_account = false ; unsigned int slot_id = 0 ; bool do_vnet = false ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( __packet_rcv_has_room ( po , skb ) == ROOM_NONE ) { atomic_inc ( & po -> tp_drops ) ; goto drop_n_restore ; } if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; if ( po -> has_vnet_hdr ) { netoff += sizeof ( struct virtio_net_hdr ) ; do_vnet = true ; } macoff = netoff - maclen ; } <S2SV_StartBug> if ( po -> tp_version <= TPACKET_V2 ) { <S2SV_EndBug> if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; if ( ( int ) snaplen < 0 ) { snaplen = 0 ; do_vnet = false ; } } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( \"tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\\\n\" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ; do_vnet = false ; } } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { slot_id = po -> rx_ring . head ; if ( test_bit ( slot_id , po -> rx_ring . rx_owner_map ) ) goto drop_n_account ; __set_bit ( slot_id , po -> rx_ring . rx_owner_map ) ; } if ( do_vnet && virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true , 0 ) ) { if ( po -> tp_version == TPACKET_V3 ) prb_clear_blk_fill_status ( & po -> rx_ring ) ; goto drop_n_account ; } if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( atomic_read ( & po -> tp_drops ) ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ; skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) ktime_get_real_ts64 ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; __packet_set_status ( po , h . raw , status ) ; __clear_bit ( slot_id , po -> rx_ring . rx_owner_map ) ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; } else if ( po -> tp_version == TPACKET_V3 ) { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : spin_unlock ( & sk -> sk_receive_queue . lock ) ; atomic_inc ( & po -> tp_drops ) ; is_drop_n_account = true ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }", "target": "<S2SV_ModStart> short macoff , hdrlen ; unsigned int netoff <S2SV_ModEnd> ; struct sk_buff <S2SV_ModStart> } if ( netoff > USHRT_MAX ) { atomic_inc ( & po -> tp_drops ) ; goto drop_n_restore ; } if ("}
{"source": "CWE-125 repodata_schema2id ( Repodata * data , Id * schema , int create ) { int h , len , i ; Id * sp , cid ; Id * schematahash ; if ( ! * schema ) return 0 ; if ( ( schematahash = data -> schematahash ) == 0 ) { data -> schematahash = schematahash = solv_calloc ( 256 , sizeof ( Id ) ) ; for ( i = 1 ; i < data -> nschemata ; i ++ ) { for ( sp = data -> schemadata + data -> schemata [ i ] , h = 0 ; * sp ; ) h = h * 7 + * sp ++ ; h &= 255 ; schematahash [ h ] = i ; } data -> schemadata = solv_extend_resize ( data -> schemadata , data -> schemadatalen , sizeof ( Id ) , SCHEMATADATA_BLOCK ) ; data -> schemata = solv_extend_resize ( data -> schemata , data -> nschemata , sizeof ( Id ) , SCHEMATA_BLOCK ) ; } for ( sp = schema , len = 0 , h = 0 ; * sp ; len ++ ) h = h * 7 + * sp ++ ; h &= 255 ; len ++ ; cid = schematahash [ h ] ; if ( cid ) { <S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> return cid ; for ( cid = 1 ; cid < data -> nschemata ; cid ++ ) <S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> return cid ; } if ( ! create ) return 0 ; data -> schemadata = solv_extend ( data -> schemadata , data -> schemadatalen , len , sizeof ( Id ) , SCHEMATADATA_BLOCK ) ; data -> schemata = solv_extend ( data -> schemata , data -> nschemata , 1 , sizeof ( Id ) , SCHEMATA_BLOCK ) ; memcpy ( data -> schemadata + data -> schemadatalen , schema , len * sizeof ( Id ) ) ; data -> schemata [ data -> nschemata ] = data -> schemadatalen ; data -> schemadatalen += len ; schematahash [ h ] = data -> nschemata ; # if 0 fprintf ( stderr , \"schema2id:<S2SV_blank>new<S2SV_blank>schema\\\\n\" ) ; # endif return data -> nschemata ++ ; }", "target": "<S2SV_ModStart> { if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && <S2SV_ModStart> ) if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) &&"}
{"source": "CWE-787 _decodeStripYCbCr ( Imaging im , ImagingCodecState state , TIFF * tiff ) { INT32 strip_row ; UINT8 * new_data ; UINT32 rows_per_strip , row_byte_size , rows_to_read ; int ret ; TIFFRGBAImage img ; char emsg [ 1024 ] = \"\" ; ret = TIFFGetFieldDefaulted ( tiff , TIFFTAG_ROWSPERSTRIP , & rows_per_strip ) ; if ( ret != 1 ) { rows_per_strip = state -> ysize ; } TRACE ( ( \"RowsPerStrip:<S2SV_blank>%u<S2SV_blank>\\\\n\" , rows_per_strip ) ) ; if ( ! ( TIFFRGBAImageOK ( tiff , emsg ) && TIFFRGBAImageBegin ( & img , tiff , 0 , emsg ) ) ) { TRACE ( ( \"Decode<S2SV_blank>error,<S2SV_blank>msg:<S2SV_blank>%s\" , emsg ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; return - 1 ; } img . req_orientation = ORIENTATION_TOPLEFT ; img . col_offset = 0 ; if ( state -> xsize != img . width || state -> ysize != img . height ) { TRACE ( ( \"Inconsistent<S2SV_blank>Image<S2SV_blank>Error:<S2SV_blank>%d<S2SV_blank>=?<S2SV_blank>%d,<S2SV_blank>%d<S2SV_blank>=?<S2SV_blank>%d\" , state -> xsize , img . width , state -> ysize , img . height ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; goto decodeycbcr_err ; } if ( INT_MAX / 4 < img . width ) { state -> errcode = IMAGING_CODEC_MEMORY ; goto decodeycbcr_err ; } row_byte_size = img . width * 4 ; if ( INT_MAX / row_byte_size < rows_per_strip ) { state -> errcode = IMAGING_CODEC_MEMORY ; goto decodeycbcr_err ; } state -> bytes = rows_per_strip * row_byte_size ; TRACE ( ( \"StripSize:<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> bytes ) ) ; new_data = realloc ( state -> buffer , state -> bytes ) ; if ( ! new_data ) { state -> errcode = IMAGING_CODEC_MEMORY ; goto decodeycbcr_err ; } state -> buffer = new_data ; for ( ; state -> y < state -> ysize ; state -> y += rows_per_strip ) { img . row_offset = state -> y ; rows_to_read = min ( rows_per_strip , img . height - state -> y ) ; <S2SV_StartBug> if ( TIFFRGBAImageGet ( & img , ( UINT32 * ) state -> buffer , img . width , rows_to_read ) == <S2SV_EndBug> - 1 ) { TRACE ( ( \"Decode<S2SV_blank>Error,<S2SV_blank>y:<S2SV_blank>%d\\\\n\" , state -> y ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; goto decodeycbcr_err ; } TRACE ( ( \"Decoded<S2SV_blank>strip<S2SV_blank>for<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> y ) ) ; for ( strip_row = 0 ; strip_row < min ( ( INT32 ) rows_per_strip , state -> ysize - state -> y ) ; strip_row ++ ) { TRACE ( ( \"Writing<S2SV_blank>data<S2SV_blank>into<S2SV_blank>line<S2SV_blank>%d<S2SV_blank>;<S2SV_blank>\\\\n\" , state -> y + strip_row ) ) ; state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff + strip_row ] + state -> xoff * im -> pixelsize , state -> buffer + strip_row * row_byte_size , state -> xsize ) ; } } decodeycbcr_err : TIFFRGBAImageEnd ( & img ) ; if ( state -> errcode != 0 ) { return - 1 ; } return 0 ; }", "target": "<S2SV_ModStart> ; if ( ! <S2SV_ModStart> , rows_to_read ) <S2SV_ModEnd> ) { TRACE"}
{"source": "CWE-665 bool timerqueue_add ( struct timerqueue_head * head , struct timerqueue_node * node ) { <S2SV_StartBug> struct rb_node * * p = & head -> head . rb_node ; <S2SV_EndBug> struct rb_node * parent = NULL ; <S2SV_StartBug> struct timerqueue_node * ptr ; <S2SV_EndBug> WARN_ON_ONCE ( ! RB_EMPTY_NODE ( & node -> node ) ) ; while ( * p ) { parent = * p ; ptr = rb_entry ( parent , struct timerqueue_node , node ) ; <S2SV_StartBug> if ( node -> expires < ptr -> expires ) <S2SV_EndBug> p = & ( * p ) -> rb_left ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> p = & ( * p ) -> rb_right ; <S2SV_EndBug> } rb_link_node ( & node -> node , parent , p ) ; <S2SV_StartBug> rb_insert_color ( & node -> node , & head -> head ) ; <S2SV_EndBug> if ( ! head -> next || node -> expires < head -> next -> expires ) { head -> next = node ; return true ; } return false ; }", "target": "<S2SV_ModStart> & head -> rb_root . rb_root <S2SV_ModEnd> . rb_node ; <S2SV_ModStart> timerqueue_node * ptr ; bool leftmost = true <S2SV_ModStart> -> expires ) { <S2SV_ModStart> -> rb_left ; } else { <S2SV_ModEnd> p = & <S2SV_ModStart> -> rb_right ; leftmost = false ; } <S2SV_ModStart> p ) ; rb_insert_color_cached <S2SV_ModEnd> ( & node <S2SV_ModStart> & head -> rb_root , leftmost ) ; return leftmost <S2SV_ModEnd> ; }"}
{"source": "CWE-835 dissect_dnp3_message ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) { proto_item * ti , * tdl , * tc , * hidden_item ; proto_tree * dnp3_tree , * dl_tree , * field_tree ; int offset = 0 , temp_offset = 0 ; gboolean dl_prm ; guint8 dl_len , dl_ctl , dl_func ; const gchar * func_code_str ; guint16 dl_dst , dl_src , calc_dl_crc ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"DNP<S2SV_blank>3.0\" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; temp_offset += 2 ; dl_len = tvb_get_guint8 ( tvb , temp_offset ) ; temp_offset += 1 ; dl_ctl = tvb_get_guint8 ( tvb , temp_offset ) ; temp_offset += 1 ; dl_dst = tvb_get_letohs ( tvb , temp_offset ) ; temp_offset += 2 ; dl_src = tvb_get_letohs ( tvb , temp_offset ) ; dl_func = dl_ctl & DNP3_CTL_FUNC ; dl_prm = dl_ctl & DNP3_CTL_PRM ; func_code_str = val_to_str ( dl_func , dl_prm ? dnp3_ctl_func_pri_vals : dnp3_ctl_func_sec_vals , \"Unknown<S2SV_blank>function<S2SV_blank>(0x%02x)\" ) ; col_append_fstr ( pinfo -> cinfo , COL_INFO , \"from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u\" , dl_src , dl_dst ) ; col_append_sep_fstr ( pinfo -> cinfo , COL_INFO , NULL , \"len=%u,<S2SV_blank>%s\" , dl_len , func_code_str ) ; ti = proto_tree_add_item ( tree , proto_dnp3 , tvb , offset , - 1 , ENC_NA ) ; dnp3_tree = proto_item_add_subtree ( ti , ett_dnp3 ) ; dl_tree = proto_tree_add_subtree_format ( dnp3_tree , tvb , offset , DNP_HDR_LEN , ett_dnp3_dl , & tdl , \"Data<S2SV_blank>Link<S2SV_blank>Layer,<S2SV_blank>Len:<S2SV_blank>%u,<S2SV_blank>From:<S2SV_blank>%u,<S2SV_blank>To:<S2SV_blank>%u,<S2SV_blank>\" , dl_len , dl_src , dl_dst ) ; if ( dl_prm ) { if ( dl_ctl & DNP3_CTL_DIR ) proto_item_append_text ( tdl , \"DIR,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_PRM ) proto_item_append_text ( tdl , \"PRM,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_FCB ) proto_item_append_text ( tdl , \"FCB,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_FCV ) proto_item_append_text ( tdl , \"FCV,<S2SV_blank>\" ) ; } else { if ( dl_ctl & DNP3_CTL_DIR ) proto_item_append_text ( tdl , \"DIR,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_PRM ) proto_item_append_text ( tdl , \"PRM,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_RES ) proto_item_append_text ( tdl , \"RES,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_DFC ) proto_item_append_text ( tdl , \"DFC,<S2SV_blank>\" ) ; } proto_item_append_text ( tdl , \"%s\" , func_code_str ) ; proto_tree_add_item ( dl_tree , hf_dnp3_start , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; offset += 2 ; proto_tree_add_item ( dl_tree , hf_dnp3_len , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; offset += 1 ; tc = proto_tree_add_uint_format_value ( dl_tree , hf_dnp3_ctl , tvb , offset , 1 , dl_ctl , \"0x%02x<S2SV_blank>(\" , dl_ctl ) ; if ( dl_prm ) { if ( dl_ctl & DNP3_CTL_DIR ) proto_item_append_text ( tc , \"DIR,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_PRM ) proto_item_append_text ( tc , \"PRM,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_FCB ) proto_item_append_text ( tc , \"FCB,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_FCV ) proto_item_append_text ( tc , \"FCV,<S2SV_blank>\" ) ; } else { if ( dl_ctl & DNP3_CTL_DIR ) proto_item_append_text ( tc , \"DIR,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_PRM ) proto_item_append_text ( tc , \"PRM,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_RES ) proto_item_append_text ( tc , \"RES,<S2SV_blank>\" ) ; if ( dl_ctl & DNP3_CTL_DFC ) proto_item_append_text ( tc , \"DFC,<S2SV_blank>\" ) ; } proto_item_append_text ( tc , \"%s)\" , func_code_str ) ; field_tree = proto_item_add_subtree ( tc , ett_dnp3_dl_ctl ) ; if ( dl_prm ) { proto_tree_add_item ( field_tree , hf_dnp3_ctl_dir , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_dnp3_ctl_prm , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_dnp3_ctl_fcb , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_dnp3_ctl_fcv , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_dnp3_ctl_prifunc , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; } else { proto_tree_add_item ( field_tree , hf_dnp3_ctl_dir , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_dnp3_ctl_prm , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_dnp3_ctl_dfc , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( field_tree , hf_dnp3_ctl_secfunc , tvb , offset , 1 , ENC_BIG_ENDIAN ) ; } offset += 1 ; proto_tree_add_item ( dl_tree , hf_dnp3_dst , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; hidden_item = proto_tree_add_item ( dl_tree , hf_dnp3_addr , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; proto_item_set_hidden ( hidden_item ) ; offset += 2 ; proto_tree_add_item ( dl_tree , hf_dnp3_src , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; hidden_item = proto_tree_add_item ( dl_tree , hf_dnp3_addr , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; proto_item_set_hidden ( hidden_item ) ; offset += 2 ; calc_dl_crc = calculateCRCtvb ( tvb , 0 , DNP_HDR_LEN - 2 ) ; proto_tree_add_checksum ( dl_tree , tvb , offset , hf_dnp3_data_hdr_crc , hf_dnp3_data_hdr_crc_status , & ei_dnp3_data_hdr_crc_incorrect , pinfo , calc_dl_crc , ENC_LITTLE_ENDIAN , PROTO_CHECKSUM_VERIFY ) ; offset += 2 ; if ( ( dl_func != DL_FUNC_LINK_STAT ) && ( dl_func != DL_FUNC_STAT_LINK ) && ( dl_func != DL_FUNC_RESET_LINK ) && ( dl_func != DL_FUNC_ACK ) ) { proto_tree * data_tree ; proto_item * data_ti ; guint8 tr_ctl , tr_seq ; gboolean tr_fir , tr_fin ; guint8 * al_buffer , * al_buffer_ptr ; guint8 data_len ; int data_start = offset ; int tl_offset ; gboolean crc_OK = FALSE ; tvbuff_t * next_tvb ; guint i ; static int * const transport_flags [ ] = { & hf_dnp3_tr_fin , & hf_dnp3_tr_fir , & hf_dnp3_tr_seq , NULL } ; tr_ctl = tvb_get_guint8 ( tvb , offset ) ; tr_seq = tr_ctl & DNP3_TR_SEQ ; tr_fir = tr_ctl & DNP3_TR_FIR ; tr_fin = tr_ctl & DNP3_TR_FIN ; tc = proto_tree_add_bitmask ( dnp3_tree , tvb , offset , hf_dnp3_tr_ctl , ett_dnp3_tr_ctl , transport_flags , ENC_BIG_ENDIAN ) ; proto_item_append_text ( tc , \"(\" ) ; if ( tr_fir ) proto_item_append_text ( tc , \"FIR,<S2SV_blank>\" ) ; if ( tr_fin ) proto_item_append_text ( tc , \"FIN,<S2SV_blank>\" ) ; proto_item_append_text ( tc , \"Sequence<S2SV_blank>%u)\" , tr_seq ) ; data_tree = proto_tree_add_subtree ( dnp3_tree , tvb , offset , - 1 , ett_dnp3_dl_data , & data_ti , \"Data<S2SV_blank>Chunks\" ) ; data_len = dl_len - 5 ; al_buffer = ( guint8 * ) wmem_alloc ( pinfo -> pool , data_len ) ; al_buffer_ptr = al_buffer ; i = 0 ; tl_offset = 1 ; while ( data_len > 0 ) { guint8 chk_size ; const guint8 * chk_ptr ; proto_tree * chk_tree ; proto_item * chk_len_ti ; guint16 calc_crc , act_crc ; chk_size = MIN ( data_len , AL_MAX_CHUNK_SIZE ) ; chk_ptr = tvb_get_ptr ( tvb , offset , chk_size ) ; memcpy ( al_buffer_ptr , chk_ptr + tl_offset , chk_size - tl_offset ) ; al_buffer_ptr += chk_size - tl_offset ; chk_tree = proto_tree_add_subtree_format ( data_tree , tvb , offset , chk_size + 2 , ett_dnp3_dl_chunk , NULL , \"Data<S2SV_blank>Chunk:<S2SV_blank>%u\" , i ) ; proto_tree_add_item ( chk_tree , hf_dnp3_data_chunk , tvb , offset , chk_size , ENC_NA ) ; chk_len_ti = proto_tree_add_uint ( chk_tree , hf_dnp3_data_chunk_len , tvb , offset , 0 , chk_size ) ; proto_item_set_generated ( chk_len_ti ) ; offset += chk_size ; calc_crc = calculateCRC ( chk_ptr , chk_size ) ; proto_tree_add_checksum ( chk_tree , tvb , offset , hf_dnp3_data_chunk_crc , hf_dnp3_data_chunk_crc_status , & ei_dnp3_data_chunk_crc_incorrect , pinfo , calc_crc , ENC_LITTLE_ENDIAN , PROTO_CHECKSUM_VERIFY ) ; act_crc = tvb_get_letohs ( tvb , offset ) ; offset += 2 ; crc_OK = calc_crc == act_crc ; if ( ! crc_OK ) { break ; } data_len -= chk_size ; i ++ ; tl_offset = 0 ; } proto_item_set_len ( data_ti , offset - data_start ) ; if ( crc_OK ) { tvbuff_t * al_tvb ; gboolean save_fragmented ; al_tvb = tvb_new_child_real_data ( tvb , al_buffer , ( guint ) ( al_buffer_ptr - al_buffer ) , ( gint ) ( al_buffer_ptr - al_buffer ) ) ; save_fragmented = pinfo -> fragmented ; static guint al_max_fragments = 60 ; static guint al_fragment_aging = 64 ; fragment_head * frag_al = NULL ; pinfo -> fragmented = TRUE ; if ( ! pinfo -> fd -> visited ) { frag_al = fragment_add_seq_single_aging ( & al_reassembly_table , al_tvb , 0 , pinfo , tr_seq , NULL , tvb_reported_length ( al_tvb ) , tr_fir , tr_fin , al_max_fragments , al_fragment_aging ) ; } else { frag_al = fragment_get_reassembled_id ( & al_reassembly_table , pinfo , tr_seq ) ; } next_tvb = process_reassembled_data ( al_tvb , 0 , pinfo , \"Reassembled<S2SV_blank>DNP<S2SV_blank>3.0<S2SV_blank>Application<S2SV_blank>Layer<S2SV_blank>message\" , frag_al , & dnp3_frag_items , NULL , dnp3_tree ) ; if ( frag_al ) { if ( pinfo -> num == frag_al -> reassembled_in && pinfo -> curr_layer_num == frag_al -> reas_in_layer_num ) { dissect_dnp3_al ( next_tvb , pinfo , dnp3_tree ) ; } else { col_set_fence ( pinfo -> cinfo , COL_INFO ) ; col_append_fstr ( pinfo -> cinfo , COL_INFO , \"<S2SV_blank>(Application<S2SV_blank>Layer<S2SV_blank>fragment<S2SV_blank>%u,<S2SV_blank>reassembled<S2SV_blank>in<S2SV_blank>packet<S2SV_blank>%u)\" , tr_seq , frag_al -> reassembled_in ) ; proto_tree_add_item ( dnp3_tree , hf_al_frag_data , al_tvb , 0 , - 1 , ENC_NA ) ; } } else { col_append_fstr ( pinfo -> cinfo , COL_INFO , \"<S2SV_blank>(Application<S2SV_blank>Layer<S2SV_blank>Unreassembled<S2SV_blank>fragment<S2SV_blank>%u)\" , tr_seq ) ; proto_tree_add_item ( dnp3_tree , hf_al_frag_data , al_tvb , 0 , - 1 , ENC_NA ) ; } pinfo -> fragmented = save_fragmented ; } else { <S2SV_StartBug> next_tvb = NULL ; <S2SV_EndBug> } } proto_item_set_len ( ti , offset ) ; return offset ; }", "target": "<S2SV_ModStart> } else { g_free ( al_buffer ) ;"}
{"source": "CWE-416 int do_epoll_ctl ( int epfd , int op , int fd , struct epoll_event * epds , bool nonblock ) { int error ; int full_check = 0 ; struct fd f , tf ; struct eventpoll * ep ; struct epitem * epi ; struct eventpoll * tep = NULL ; error = - EBADF ; f = fdget ( epfd ) ; if ( ! f . file ) goto error_return ; tf = fdget ( fd ) ; if ( ! tf . file ) goto error_fput ; error = - EPERM ; if ( ! file_can_poll ( tf . file ) ) goto error_tgt_fput ; if ( ep_op_has_event ( op ) ) ep_take_care_of_epollwakeup ( epds ) ; error = - EINVAL ; if ( f . file == tf . file || ! is_file_epoll ( f . file ) ) goto error_tgt_fput ; if ( ep_op_has_event ( op ) && ( epds -> events & EPOLLEXCLUSIVE ) ) { if ( op == EPOLL_CTL_MOD ) goto error_tgt_fput ; if ( op == EPOLL_CTL_ADD && ( is_file_epoll ( tf . file ) || ( epds -> events & ~ EPOLLEXCLUSIVE_OK_BITS ) ) ) goto error_tgt_fput ; } ep = f . file -> private_data ; error = epoll_mutex_lock ( & ep -> mtx , 0 , nonblock ) ; if ( error ) goto error_tgt_fput ; if ( op == EPOLL_CTL_ADD ) { if ( ! list_empty ( & f . file -> f_ep_links ) || is_file_epoll ( tf . file ) ) { mutex_unlock ( & ep -> mtx ) ; error = epoll_mutex_lock ( & epmutex , 0 , nonblock ) ; if ( error ) goto error_tgt_fput ; full_check = 1 ; if ( is_file_epoll ( tf . file ) ) { error = - ELOOP ; <S2SV_StartBug> if ( ep_loop_check ( ep , tf . file ) != 0 ) { <S2SV_EndBug> clear_tfile_check_list ( ) ; goto error_tgt_fput ; } } else { get_file ( tf . file ) ; list_add ( & tf . file -> f_tfile_llink , & tfile_check_list ) ; } error = epoll_mutex_lock ( & ep -> mtx , 0 , nonblock ) ; <S2SV_StartBug> if ( error ) { <S2SV_EndBug> out_del : list_del ( & tf . file -> f_tfile_llink ) ; if ( ! is_file_epoll ( tf . file ) ) <S2SV_StartBug> fput ( tf . file ) ; <S2SV_EndBug> goto error_tgt_fput ; } if ( is_file_epoll ( tf . file ) ) { tep = tf . file -> private_data ; error = epoll_mutex_lock ( & tep -> mtx , 1 , nonblock ) ; if ( error ) { mutex_unlock ( & ep -> mtx ) ; <S2SV_StartBug> goto out_del ; <S2SV_EndBug> } } } } epi = ep_find ( ep , tf . file , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds -> events |= EPOLLERR | EPOLLHUP ; error = ep_insert ( ep , epds , tf . file , fd , full_check ) ; } else error = - EEXIST ; <S2SV_StartBug> if ( full_check ) <S2SV_EndBug> clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { if ( ! ( epi -> event . events & EPOLLEXCLUSIVE ) ) { epds -> events |= EPOLLERR | EPOLLHUP ; error = ep_modify ( ep , epi , epds ) ; } } else error = - ENOENT ; break ; } if ( tep != NULL ) mutex_unlock ( & tep -> mtx ) ; mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : <S2SV_StartBug> if ( full_check ) <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & epmutex ) ; <S2SV_EndBug> fdput ( tf ) ; error_fput : fdput ( f ) ; error_return : return error ; }", "target": "<S2SV_ModStart> != 0 ) goto error_tgt_fput ; <S2SV_ModEnd> } else { <S2SV_ModStart> ( error ) goto error_tgt_fput ; if ( <S2SV_ModEnd> is_file_epoll ( tf <S2SV_ModStart> file ) ) <S2SV_ModEnd> { tep = <S2SV_ModStart> ) ; goto error_tgt_fput <S2SV_ModEnd> ; } } <S2SV_ModStart> - EEXIST ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ( full_check ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> epmutex ) ; }"}
{"source": "CWE-119 rb_str_justify ( int argc , VALUE * argv , VALUE str , char jflag ) { rb_encoding * enc ; VALUE w ; long width , len , flen = 1 , fclen = 1 ; VALUE res ; char * p ; const char * f = \"<S2SV_blank>\" ; <S2SV_StartBug> long n , llen , rlen ; <S2SV_EndBug> volatile VALUE pad ; int singlebyte = 1 , cr ; rb_scan_args ( argc , argv , \"11\" , & w , & pad ) ; enc = STR_ENC_GET ( str ) ; width = NUM2LONG ( w ) ; if ( argc == 2 ) { StringValue ( pad ) ; enc = rb_enc_check ( str , pad ) ; f = RSTRING_PTR ( pad ) ; flen = RSTRING_LEN ( pad ) ; fclen = str_strlen ( pad , enc ) ; singlebyte = single_byte_optimizable ( pad ) ; if ( flen == 0 || fclen == 0 ) { rb_raise ( rb_eArgError , \"zero<S2SV_blank>width<S2SV_blank>padding\" ) ; } } len = str_strlen ( str , enc ) ; if ( width < 0 || len >= width ) return rb_str_dup ( str ) ; n = width - len ; llen = ( jflag == 'l' ) ? 0 : ( ( jflag == 'r' ) ? n : n / 2 ) ; rlen = n - llen ; cr = ENC_CODERANGE ( str ) ; <S2SV_StartBug> res = rb_str_new5 ( str , 0 , RSTRING_LEN ( str ) + n * flen / fclen + 2 ) ; <S2SV_EndBug> p = RSTRING_PTR ( res ) ; <S2SV_StartBug> while ( llen ) { <S2SV_EndBug> if ( flen <= 1 ) { <S2SV_StartBug> * p ++ = * f ; <S2SV_EndBug> llen -- ; } <S2SV_StartBug> else if ( llen > fclen ) { <S2SV_EndBug> memcpy ( p , f , flen ) ; p += flen ; llen -= fclen ; } <S2SV_StartBug> else { <S2SV_EndBug> char * fp = str_nth ( f , f + flen , llen , enc , singlebyte ) ; n = fp - f ; <S2SV_StartBug> memcpy ( p , f , n ) ; <S2SV_EndBug> p += n ; break ; } } <S2SV_StartBug> memcpy ( p , RSTRING_PTR ( str ) , RSTRING_LEN ( str ) ) ; <S2SV_EndBug> p += RSTRING_LEN ( str ) ; while ( rlen ) { if ( flen <= 1 ) { <S2SV_StartBug> * p ++ = * f ; <S2SV_EndBug> rlen -- ; } <S2SV_StartBug> else if ( rlen > fclen ) { <S2SV_EndBug> memcpy ( p , f , flen ) ; p += flen ; rlen -= fclen ; } <S2SV_StartBug> else { <S2SV_EndBug> char * fp = str_nth ( f , f + flen , rlen , enc , singlebyte ) ; n = fp - f ; <S2SV_StartBug> memcpy ( p , f , n ) ; <S2SV_EndBug> p += n ; break ; } } * p = '\\\\0' ; STR_SET_LEN ( res , p - RSTRING_PTR ( res ) ) ; OBJ_INFECT ( res , str ) ; if ( ! NIL_P ( pad ) ) OBJ_INFECT ( res , pad ) ; rb_enc_associate ( res , enc ) ; if ( argc == 2 ) cr = ENC_CODERANGE_AND ( cr , ENC_CODERANGE ( pad ) ) ; if ( cr != ENC_CODERANGE_BROKEN ) ENC_CODERANGE_SET ( res , cr ) ; return res ; }", "target": "<S2SV_ModStart> long n , size , llen , rlen , llen2 = 0 , rlen2 = 0 <S2SV_ModEnd> ; volatile VALUE <S2SV_ModStart> str ) ; if ( flen > 1 ) { llen2 = str_offset ( f , f + flen , llen % fclen , enc , singlebyte ) ; rlen2 = str_offset ( f , f + flen , rlen % fclen , enc , singlebyte ) ; } size = RSTRING_LEN ( str ) ; if ( ( len = llen / fclen + rlen / fclen ) >= LONG_MAX / flen || ( len *= flen ) >= LONG_MAX - llen2 - rlen2 || ( len += llen2 + rlen2 ) >= LONG_MAX - size ) { rb_raise ( rb_eArgError , \"argument<S2SV_blank>too<S2SV_blank>big\" ) ; } len += size ; <S2SV_ModStart> , 0 , len <S2SV_ModEnd> ) ; p <S2SV_ModStart> res ) ; <S2SV_ModEnd> if ( flen <S2SV_ModStart> 1 ) { memset ( p , * f , llen ) ; p += llen <S2SV_ModEnd> ; } else <S2SV_ModStart> ; } else { while <S2SV_ModEnd> ( llen > <S2SV_ModStart> fclen ; } if ( llen > 0 ) { <S2SV_ModEnd> memcpy ( p <S2SV_ModStart> , f , llen2 ) ; p += llen2 <S2SV_ModEnd> ; } } <S2SV_ModStart> str ) , size ) ; p += size ; <S2SV_ModEnd> if ( flen <S2SV_ModStart> 1 ) { memset ( p , * f , rlen ) ; p += rlen <S2SV_ModEnd> ; } else <S2SV_ModStart> ; } else { while <S2SV_ModEnd> ( rlen > <S2SV_ModStart> fclen ; } if ( rlen > 0 ) { <S2SV_ModEnd> memcpy ( p <S2SV_ModStart> , f , rlen2 ) ; p += rlen2 <S2SV_ModEnd> ; } }"}
{"source": "CWE-20 static int cmd_handle_untagged ( IMAP_DATA * idata ) { char * s ; char * pn ; unsigned int count ; s = imap_next_word ( idata -> buf ) ; pn = imap_next_word ( s ) ; if ( ( idata -> state >= IMAP_SELECTED ) && isdigit ( ( unsigned char ) * s ) ) { pn = s ; s = imap_next_word ( s ) ; if ( ascii_strncasecmp ( \"EXISTS\" , s , 6 ) == 0 ) { dprint ( 2 , ( debugfile , \"Handling<S2SV_blank>EXISTS\\\\n\" ) ) ; mutt_atoui ( pn , & count ) ; if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) && count < idata -> max_msn ) { dprint ( 1 , ( debugfile , \"Message<S2SV_blank>count<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>sync\" ) ) ; return 0 ; } else if ( count == idata -> max_msn ) dprint ( 3 , ( debugfile , \"cmd_handle_untagged:<S2SV_blank>superfluous<S2SV_blank>EXISTS<S2SV_blank>message.\\\\n\" ) ) ; else { if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) ) { dprint ( 2 , ( debugfile , \"cmd_handle_untagged:<S2SV_blank>New<S2SV_blank>mail<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>total.\\\\n\" , idata -> mailbox , count ) ) ; idata -> reopen |= IMAP_NEWMAIL_PENDING ; } idata -> newMailCount = count ; } } else if ( ascii_strncasecmp ( \"EXPUNGE\" , s , 7 ) == 0 ) cmd_parse_expunge ( idata , pn ) ; else if ( ascii_strncasecmp ( \"FETCH\" , s , 5 ) == 0 ) cmd_parse_fetch ( idata , pn ) ; } else if ( ascii_strncasecmp ( \"CAPABILITY\" , s , 10 ) == 0 ) cmd_parse_capability ( idata , s ) ; else if ( ! ascii_strncasecmp ( \"OK<S2SV_blank>[CAPABILITY\" , s , 14 ) ) cmd_parse_capability ( idata , pn ) ; else if ( ! ascii_strncasecmp ( \"OK<S2SV_blank>[CAPABILITY\" , pn , 14 ) ) cmd_parse_capability ( idata , imap_next_word ( pn ) ) ; else if ( ascii_strncasecmp ( \"LIST\" , s , 4 ) == 0 ) cmd_parse_list ( idata , s ) ; else if ( ascii_strncasecmp ( \"LSUB\" , s , 4 ) == 0 ) cmd_parse_lsub ( idata , s ) ; else if ( ascii_strncasecmp ( \"MYRIGHTS\" , s , 8 ) == 0 ) cmd_parse_myrights ( idata , s ) ; else if ( ascii_strncasecmp ( \"SEARCH\" , s , 6 ) == 0 ) cmd_parse_search ( idata , s ) ; else if ( ascii_strncasecmp ( \"STATUS\" , s , 6 ) == 0 ) cmd_parse_status ( idata , s ) ; else if ( ascii_strncasecmp ( \"ENABLED\" , s , 7 ) == 0 ) cmd_parse_enabled ( idata , s ) ; else if ( ascii_strncasecmp ( \"BYE\" , s , 3 ) == 0 ) { dprint ( 2 , ( debugfile , \"Handling<S2SV_blank>BYE\\\\n\" ) ) ; if ( idata -> status == IMAP_BYE ) return 0 ; s += 3 ; SKIPWS ( s ) ; mutt_error ( \"%s\" , s ) ; mutt_sleep ( 2 ) ; cmd_handle_fatal ( idata ) ; return - 1 ; } else if ( option ( OPTIMAPSERVERNOISE ) && ( ascii_strncasecmp ( \"NO\" , s , 2 ) == 0 ) ) { dprint ( 2 , ( debugfile , \"Handling<S2SV_blank>untagged<S2SV_blank>NO\\\\n\" ) ) ; <S2SV_StartBug> mutt_error ( \"%s\" , s + 3 ) ; <S2SV_EndBug> mutt_sleep ( 2 ) ; } return 0 ; }", "target": "<S2SV_ModStart> , s + 2 <S2SV_ModEnd> ) ; mutt_sleep"}
{"source": "CWE-399 static Image * OptimizeLayerFrames ( const Image * image , const LayerMethod method , ExceptionInfo * exception ) { ExceptionInfo * sans_exception ; Image * prev_image , * dup_image , * bgnd_image , * optimized_image ; RectangleInfo try_bounds , bgnd_bounds , dup_bounds , * bounds ; MagickBooleanType add_frames , try_cleared , cleared ; DisposeType * disposals ; register const Image * curr ; register ssize_t i ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; assert ( method == OptimizeLayer || method == OptimizeImageLayer || method == OptimizePlusLayer ) ; add_frames = method == OptimizePlusLayer ? MagickTrue : MagickFalse ; curr = GetFirstImageInList ( image ) ; for ( ; curr != ( Image * ) NULL ; curr = GetNextImageInList ( curr ) ) { if ( ( curr -> columns != image -> columns ) || ( curr -> rows != image -> rows ) ) ThrowImageException ( OptionError , \"ImagesAreNotTheSameSize\" ) ; if ( ( curr -> page . x != 0 ) || ( curr -> page . y != 0 ) || ( curr -> page . width != image -> page . width ) || ( curr -> page . height != image -> page . height ) ) ThrowImageException ( OptionError , \"ImagePagesAreNotCoalesced\" ) ; } curr = GetFirstImageInList ( image ) ; bounds = ( RectangleInfo * ) AcquireQuantumMemory ( ( size_t ) GetImageListLength ( curr ) , ( add_frames != MagickFalse ? 2UL : 1UL ) * sizeof ( * bounds ) ) ; if ( bounds == ( RectangleInfo * ) NULL ) ThrowImageException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; disposals = ( DisposeType * ) AcquireQuantumMemory ( ( size_t ) GetImageListLength ( image ) , ( add_frames != MagickFalse ? 2UL : 1UL ) * sizeof ( * disposals ) ) ; if ( disposals == ( DisposeType * ) NULL ) { bounds = ( RectangleInfo * ) RelinquishMagickMemory ( bounds ) ; ThrowImageException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } prev_image = CloneImage ( curr , curr -> columns , curr -> rows , MagickTrue , exception ) ; if ( prev_image == ( Image * ) NULL ) { bounds = ( RectangleInfo * ) RelinquishMagickMemory ( bounds ) ; disposals = ( DisposeType * ) RelinquishMagickMemory ( disposals ) ; return ( ( Image * ) NULL ) ; } prev_image -> page = curr -> page ; prev_image -> page . x = 0 ; prev_image -> page . y = 0 ; prev_image -> dispose = NoneDispose ; prev_image -> background_color . alpha_trait = BlendPixelTrait ; prev_image -> background_color . alpha = ( MagickRealType ) TransparentAlpha ; ( void ) SetImageBackgroundColor ( prev_image , exception ) ; # if DEBUG_OPT_FRAME i = 0 ; ( void ) FormatLocaleFile ( stderr , \"frame<S2SV_blank>%.20g<S2SV_blank>:-\\\\n\" , ( double ) i ) ; # endif disposals [ 0 ] = NoneDispose ; bounds [ 0 ] = CompareImagesBounds ( prev_image , curr , CompareAnyLayer , exception ) ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"overlay:<S2SV_blank>%.20gx%.20g%+.20g%+.20g\\\\n\\\\n\" , ( double ) bounds [ i ] . width , ( double ) bounds [ i ] . height , ( double ) bounds [ i ] . x , ( double ) bounds [ i ] . y ) ; # endif i = 1 ; bgnd_image = ( Image * ) NULL ; dup_image = ( Image * ) NULL ; dup_bounds . width = 0 ; dup_bounds . height = 0 ; dup_bounds . x = 0 ; dup_bounds . y = 0 ; curr = GetNextImageInList ( curr ) ; for ( ; curr != ( const Image * ) NULL ; curr = GetNextImageInList ( curr ) ) { # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"frame<S2SV_blank>%.20g<S2SV_blank>:-\\\\n\" , ( double ) i ) ; # endif bounds [ i ] = CompareImagesBounds ( curr -> previous , curr , CompareAnyLayer , exception ) ; cleared = IsBoundsCleared ( curr -> previous , curr , & bounds [ i ] , exception ) ; disposals [ i - 1 ] = NoneDispose ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"overlay:<S2SV_blank>%.20gx%.20g%+.20g%+.20g%s%s\\\\n\" , ( double ) bounds [ i ] . width , ( double ) bounds [ i ] . height , ( double ) bounds [ i ] . x , ( double ) bounds [ i ] . y , bounds [ i ] . x < 0 ? \"<S2SV_blank><S2SV_blank>(unchanged)\" : \"\" , cleared ? \"<S2SV_blank><S2SV_blank>(pixels<S2SV_blank>cleared)\" : \"\" ) ; # endif if ( bounds [ i ] . x < 0 ) { if ( add_frames && i >= 2 ) { disposals [ i - 1 ] = DelDispose ; disposals [ i ] = NoneDispose ; bounds [ i ] = bounds [ i - 1 ] ; i ++ ; continue ; } } else { try_bounds = CompareImagesBounds ( prev_image , curr , CompareAnyLayer , exception ) ; try_cleared = IsBoundsCleared ( prev_image , curr , & try_bounds , exception ) ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"test_prev:<S2SV_blank>%.20gx%.20g%+.20g%+.20g%s\\\\n\" , ( double ) try_bounds . width , ( double ) try_bounds . height , ( double ) try_bounds . x , ( double ) try_bounds . y , try_cleared ? \"<S2SV_blank><S2SV_blank>(pixels<S2SV_blank>were<S2SV_blank>cleared)\" : \"\" ) ; # endif if ( ( ! try_cleared && cleared ) || try_bounds . width * try_bounds . height < bounds [ i ] . width * bounds [ i ] . height ) { cleared = try_cleared ; bounds [ i ] = try_bounds ; disposals [ i - 1 ] = PreviousDispose ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"previous:<S2SV_blank>accepted\\\\n\" ) ; } else { ( void ) FormatLocaleFile ( stderr , \"previous:<S2SV_blank>rejected\\\\n\" ) ; # endif } dup_bounds . width = dup_bounds . height = 0 ; if ( add_frames ) { dup_image = CloneImage ( curr -> previous , 0 , 0 , MagickTrue , exception ) ; if ( dup_image == ( Image * ) NULL ) { bounds = ( RectangleInfo * ) RelinquishMagickMemory ( bounds ) ; disposals = ( DisposeType * ) RelinquishMagickMemory ( disposals ) ; prev_image = DestroyImage ( prev_image ) ; return ( ( Image * ) NULL ) ; } dup_image -> background_color . alpha_trait = BlendPixelTrait ; dup_bounds = CompareImagesBounds ( dup_image , curr , CompareClearLayer , exception ) ; ClearBounds ( dup_image , & dup_bounds , exception ) ; try_bounds = CompareImagesBounds ( dup_image , curr , CompareAnyLayer , exception ) ; if ( cleared || dup_bounds . width * dup_bounds . height + try_bounds . width * try_bounds . height < bounds [ i ] . width * bounds [ i ] . height ) { cleared = MagickFalse ; bounds [ i ] = try_bounds ; disposals [ i - 1 ] = DupDispose ; } else dup_bounds . width = dup_bounds . height = 0 ; } bgnd_image = CloneImage ( curr -> previous , 0 , 0 , MagickTrue , exception ) ; if ( bgnd_image == ( Image * ) NULL ) { bounds = ( RectangleInfo * ) RelinquishMagickMemory ( bounds ) ; disposals = ( DisposeType * ) RelinquishMagickMemory ( disposals ) ; prev_image = DestroyImage ( prev_image ) ; if ( dup_image != ( Image * ) NULL ) dup_image = DestroyImage ( dup_image ) ; return ( ( Image * ) NULL ) ; } bgnd_image -> background_color . alpha_trait = BlendPixelTrait ; bgnd_bounds = bounds [ i - 1 ] ; ClearBounds ( bgnd_image , & bgnd_bounds , exception ) ; try_bounds = CompareImagesBounds ( bgnd_image , curr , CompareAnyLayer , exception ) ; try_cleared = IsBoundsCleared ( bgnd_image , curr , & try_bounds , exception ) ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"background:<S2SV_blank>%s\\\\n\" , try_cleared ? \"(pixels<S2SV_blank>cleared)\" : \"\" ) ; # endif if ( try_cleared ) { try_bounds = CompareImagesBounds ( curr -> previous , curr , CompareClearLayer , exception ) ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"expand_clear:<S2SV_blank>%.20gx%.20g%+.20g%+.20g%s\\\\n\" , ( double ) try_bounds . width , ( double ) try_bounds . height , ( double ) try_bounds . x , ( double ) try_bounds . y , try_bounds . x < 0 ? \"<S2SV_blank><S2SV_blank>(no<S2SV_blank>expand<S2SV_blank>nessary)\" : \"\" ) ; # endif if ( bgnd_bounds . x < 0 ) bgnd_bounds = try_bounds ; else { # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"expand_bgnd:<S2SV_blank>%.20gx%.20g%+.20g%+.20g\\\\n\" , ( double ) bgnd_bounds . width , ( double ) bgnd_bounds . height , ( double ) bgnd_bounds . x , ( double ) bgnd_bounds . y ) ; # endif if ( try_bounds . x < bgnd_bounds . x ) { bgnd_bounds . width += bgnd_bounds . x - try_bounds . x ; if ( bgnd_bounds . width < try_bounds . width ) bgnd_bounds . width = try_bounds . width ; bgnd_bounds . x = try_bounds . x ; } else { try_bounds . width += try_bounds . x - bgnd_bounds . x ; if ( bgnd_bounds . width < try_bounds . width ) bgnd_bounds . width = try_bounds . width ; } if ( try_bounds . y < bgnd_bounds . y ) { bgnd_bounds . height += bgnd_bounds . y - try_bounds . y ; if ( bgnd_bounds . height < try_bounds . height ) bgnd_bounds . height = try_bounds . height ; bgnd_bounds . y = try_bounds . y ; } else { try_bounds . height += try_bounds . y - bgnd_bounds . y ; if ( bgnd_bounds . height < try_bounds . height ) bgnd_bounds . height = try_bounds . height ; } # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>to<S2SV_blank>:<S2SV_blank>%.20gx%.20g%+.20g%+.20g\\\\n\" , ( double ) bgnd_bounds . width , ( double ) bgnd_bounds . height , ( double ) bgnd_bounds . x , ( double ) bgnd_bounds . y ) ; # endif } ClearBounds ( bgnd_image , & bgnd_bounds , exception ) ; # if DEBUG_OPT_FRAME try_bounds = CompareImagesBounds ( bgnd_image , curr , CompareClearLayer , exception ) ; ( void ) FormatLocaleFile ( stderr , \"expand_ctst:<S2SV_blank>%.20gx%.20g%+.20g%+.20g\\\\n\" , ( double ) try_bounds . width , ( double ) try_bounds . height , ( double ) try_bounds . x , ( double ) try_bounds . y ) ; try_bounds = CompareImagesBounds ( bgnd_image , curr , CompareAnyLayer , exception ) ; try_cleared = IsBoundsCleared ( bgnd_image , curr , & try_bounds , exception ) ; ( void ) FormatLocaleFile ( stderr , \"expand_any<S2SV_blank>:<S2SV_blank>%.20gx%.20g%+.20g%+.20g%s\\\\n\" , ( double ) try_bounds . width , ( double ) try_bounds . height , ( double ) try_bounds . x , ( double ) try_bounds . y , try_cleared ? \"<S2SV_blank><S2SV_blank><S2SV_blank>(pixels<S2SV_blank>cleared)\" : \"\" ) ; # endif try_bounds = CompareImagesBounds ( bgnd_image , curr , CompareOverlayLayer , exception ) ; # if DEBUG_OPT_FRAME try_cleared = IsBoundsCleared ( bgnd_image , curr , & try_bounds , exception ) ; ( void ) FormatLocaleFile ( stderr , \"expand_test:<S2SV_blank>%.20gx%.20g%+.20g%+.20g%s\\\\n\" , ( double ) try_bounds . width , ( double ) try_bounds . height , ( double ) try_bounds . x , ( double ) try_bounds . y , try_cleared ? \"<S2SV_blank><S2SV_blank><S2SV_blank>(pixels<S2SV_blank>cleared)\" : \"\" ) ; # endif } if ( cleared || bgnd_bounds . width * bgnd_bounds . height + try_bounds . width * try_bounds . height < bounds [ i - 1 ] . width * bounds [ i - 1 ] . height + dup_bounds . width * dup_bounds . height + bounds [ i ] . width * bounds [ i ] . height ) { cleared = MagickFalse ; bounds [ i - 1 ] = bgnd_bounds ; bounds [ i ] = try_bounds ; if ( disposals [ i - 1 ] == DupDispose ) dup_image = DestroyImage ( dup_image ) ; disposals [ i - 1 ] = BackgroundDispose ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"expand_bgnd:<S2SV_blank>accepted\\\\n\" ) ; } else { ( void ) FormatLocaleFile ( stderr , \"expand_bgnd:<S2SV_blank>reject\\\\n\" ) ; # endif } } if ( disposals [ i - 1 ] == DupDispose ) { if ( bgnd_image != ( Image * ) NULL ) bgnd_image = DestroyImage ( bgnd_image ) ; prev_image = DestroyImage ( prev_image ) ; prev_image = dup_image , dup_image = ( Image * ) NULL ; bounds [ i + 1 ] = bounds [ i ] ; bounds [ i ] = dup_bounds ; disposals [ i - 1 ] = DupDispose ; disposals [ i ] = BackgroundDispose ; i ++ ; } else { if ( dup_image != ( Image * ) NULL ) dup_image = DestroyImage ( dup_image ) ; if ( disposals [ i - 1 ] != PreviousDispose ) prev_image = DestroyImage ( prev_image ) ; if ( disposals [ i - 1 ] == BackgroundDispose ) prev_image = bgnd_image , bgnd_image = ( Image * ) NULL ; if ( bgnd_image != ( Image * ) NULL ) bgnd_image = DestroyImage ( bgnd_image ) ; if ( disposals [ i - 1 ] == NoneDispose ) { prev_image = ReferenceImage ( curr -> previous ) ; if ( prev_image == ( Image * ) NULL ) { bounds = ( RectangleInfo * ) RelinquishMagickMemory ( bounds ) ; disposals = ( DisposeType * ) RelinquishMagickMemory ( disposals ) ; return ( ( Image * ) NULL ) ; } } } assert ( prev_image != ( Image * ) NULL ) ; disposals [ i ] = disposals [ i - 1 ] ; # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"final<S2SV_blank><S2SV_blank><S2SV_blank>%.20g<S2SV_blank>:<S2SV_blank>%s<S2SV_blank><S2SV_blank>%.20gx%.20g%+.20g%+.20g\\\\n\" , ( double ) i - 1 , CommandOptionToMnemonic ( MagickDisposeOptions , disposals [ i - 1 ] ) , ( double ) bounds [ i - 1 ] . width , ( double ) bounds [ i - 1 ] . height , ( double ) bounds [ i - 1 ] . x , ( double ) bounds [ i - 1 ] . y ) ; # endif # if DEBUG_OPT_FRAME ( void ) FormatLocaleFile ( stderr , \"interum<S2SV_blank>%.20g<S2SV_blank>:<S2SV_blank>%s<S2SV_blank><S2SV_blank>%.20gx%.20g%+.20g%+.20g\\\\n\" , ( double ) i , CommandOptionToMnemonic ( MagickDisposeOptions , disposals [ i ] ) , ( double ) bounds [ i ] . width , ( double ) bounds [ i ] . height , ( double ) bounds [ i ] . x , ( double ) bounds [ i ] . y ) ; ( void ) FormatLocaleFile ( stderr , \"\\\\n\" ) ; # endif i ++ ; } prev_image = DestroyImage ( prev_image ) ; sans_exception = AcquireExceptionInfo ( ) ; i = 0 ; curr = GetFirstImageInList ( image ) ; optimized_image = NewImageList ( ) ; while ( curr != ( const Image * ) NULL ) { prev_image = CloneImage ( curr , 0 , 0 , MagickTrue , exception ) ; if ( prev_image == ( Image * ) NULL ) break ; prev_image -> background_color . alpha_trait = BlendPixelTrait ; if ( disposals [ i ] == DelDispose ) { size_t time = 0 ; while ( disposals [ i ] == DelDispose ) { <S2SV_StartBug> time += curr -> delay * 1000 / curr -> ticks_per_second ; <S2SV_EndBug> curr = GetNextImageInList ( curr ) ; i ++ ; } <S2SV_StartBug> time += curr -> delay * 1000 / curr -> ticks_per_second ; <S2SV_EndBug> prev_image -> ticks_per_second = 100L ; prev_image -> delay = time * prev_image -> ticks_per_second / 1000 ; } bgnd_image = CropImage ( prev_image , & bounds [ i ] , sans_exception ) ; prev_image = DestroyImage ( prev_image ) ; if ( bgnd_image == ( Image * ) NULL ) break ; bgnd_image -> dispose = disposals [ i ] ; if ( disposals [ i ] == DupDispose ) { bgnd_image -> delay = 0 ; bgnd_image -> dispose = NoneDispose ; } else curr = GetNextImageInList ( curr ) ; AppendImageToList ( & optimized_image , bgnd_image ) ; i ++ ; } sans_exception = DestroyExceptionInfo ( sans_exception ) ; bounds = ( RectangleInfo * ) RelinquishMagickMemory ( bounds ) ; disposals = ( DisposeType * ) RelinquishMagickMemory ( disposals ) ; if ( curr != ( Image * ) NULL ) { optimized_image = DestroyImageList ( optimized_image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( optimized_image ) ) ; }", "target": "<S2SV_ModStart> { time += ( size_t ) ( <S2SV_ModStart> delay * 1000 * PerceptibleReciprocal ( ( double ) <S2SV_ModEnd> curr -> ticks_per_second <S2SV_ModStart> curr -> ticks_per_second ) ) <S2SV_ModStart> } time += ( size_t ) ( <S2SV_ModStart> delay * 1000 * PerceptibleReciprocal ( ( double ) <S2SV_ModEnd> curr -> ticks_per_second <S2SV_ModStart> curr -> ticks_per_second ) )"}
{"source": "CWE-787 static int io_add_buffers ( struct io_provide_buf * pbuf , struct io_buffer * * head ) { struct io_buffer * buf ; u64 addr = pbuf -> addr ; int i , bid = pbuf -> bid ; for ( i = 0 ; i < pbuf -> nbufs ; i ++ ) { buf = kmalloc ( sizeof ( * buf ) , GFP_KERNEL ) ; if ( ! buf ) break ; buf -> addr = addr ; <S2SV_StartBug> buf -> len = pbuf -> len ; <S2SV_EndBug> buf -> bid = bid ; addr += pbuf -> len ; bid ++ ; if ( ! * head ) { INIT_LIST_HEAD ( & buf -> list ) ; * head = buf ; } else { list_add_tail ( & buf -> list , & ( * head ) -> list ) ; } } return i ? i : - ENOMEM ; }", "target": "<S2SV_ModStart> -> len = min_t ( __u32 , <S2SV_ModStart> pbuf -> len , MAX_RW_COUNT )"}
{"source": "CWE-459 static int fuse_do_getattr ( struct inode * inode , struct kstat * stat , struct file * file ) { int err ; struct fuse_getattr_in inarg ; struct fuse_attr_out outarg ; struct fuse_mount * fm = get_fuse_mount ( inode ) ; FUSE_ARGS ( args ) ; u64 attr_version ; attr_version = fuse_get_attr_version ( fm -> fc ) ; memset ( & inarg , 0 , sizeof ( inarg ) ) ; memset ( & outarg , 0 , sizeof ( outarg ) ) ; if ( file && S_ISREG ( inode -> i_mode ) ) { struct fuse_file * ff = file -> private_data ; inarg . getattr_flags |= FUSE_GETATTR_FH ; inarg . fh = ff -> fh ; } args . opcode = FUSE_GETATTR ; args . nodeid = get_node_id ( inode ) ; args . in_numargs = 1 ; args . in_args [ 0 ] . size = sizeof ( inarg ) ; args . in_args [ 0 ] . value = & inarg ; args . out_numargs = 1 ; args . out_args [ 0 ] . size = sizeof ( outarg ) ; args . out_args [ 0 ] . value = & outarg ; err = fuse_simple_request ( fm , & args ) ; if ( ! err ) { if ( fuse_invalid_attr ( & outarg . attr ) || ( inode -> i_mode ^ outarg . attr . mode ) & S_IFMT ) { <S2SV_StartBug> make_bad_inode ( inode ) ; <S2SV_EndBug> err = - EIO ; } else { fuse_change_attributes ( inode , & outarg . attr , attr_timeout ( & outarg ) , attr_version ) ; if ( stat ) fuse_fillattr ( inode , & outarg . attr , stat ) ; } } return err ; }", "target": "<S2SV_ModStart> S_IFMT ) { fuse_make_bad <S2SV_ModEnd> ( inode )"}
{"source": "CWE-476 static struct kvm_vcpu_hv_synic * synic_get ( struct kvm * kvm , u32 vpidx ) { struct kvm_vcpu * vcpu ; struct kvm_vcpu_hv_synic * synic ; vcpu = get_vcpu_by_vpidx ( kvm , vpidx ) ; <S2SV_StartBug> if ( ! vcpu ) <S2SV_EndBug> return NULL ; synic = to_hv_synic ( vcpu ) ; return ( synic -> active ) ? synic : NULL ; }", "target": "<S2SV_ModStart> ( ! vcpu || ! to_hv_vcpu ( vcpu )"}
{"source": "CWE-476 <S2SV_StartBug> int ssh_buffer_add_data ( struct ssh_buffer_struct * buffer , const void * data , uint32_t len ) <S2SV_EndBug> { <S2SV_StartBug> buffer_verify ( buffer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( data == NULL ) { <S2SV_EndBug> return - 1 ; } if ( buffer -> used + len < len ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( buffer -> allocated < ( buffer -> used + len ) ) { <S2SV_StartBug> if ( buffer -> pos > 0 ) <S2SV_EndBug> <S2SV_StartBug> buffer_shift ( buffer ) ; <S2SV_EndBug> if ( realloc_buffer ( buffer , buffer -> used + len ) < 0 ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } } <S2SV_StartBug> memcpy ( buffer -> data + buffer -> used , data , len ) ; <S2SV_EndBug> buffer -> used += len ; buffer_verify ( buffer ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * ssh_buffer_allocate <S2SV_ModEnd> ( struct ssh_buffer_struct <S2SV_ModStart> ssh_buffer_struct * buffer <S2SV_ModEnd> , uint32_t len <S2SV_ModStart> len ) { void * ptr ; <S2SV_ModStart> buffer ) ; <S2SV_ModEnd> if ( buffer <S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } if <S2SV_ModStart> > 0 ) { <S2SV_ModStart> buffer ) ; } <S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } ptr = <S2SV_ModEnd> buffer -> data <S2SV_ModStart> buffer -> used <S2SV_ModEnd> ; buffer -> <S2SV_ModStart> ) ; return ptr <S2SV_ModEnd> ; }"}
{"source": "CWE-119 static int usb_host_handle_control ( USBHostDevice * s , USBPacket * p ) { struct usbdevfs_urb * urb ; AsyncURB * aurb ; <S2SV_StartBug> int ret , value , index ; <S2SV_EndBug> value = le16_to_cpu ( s -> ctrl . req . wValue ) ; index = le16_to_cpu ( s -> ctrl . req . wIndex ) ; dprintf ( \"husb:<S2SV_blank>ctrl<S2SV_blank>type<S2SV_blank>0x%x<S2SV_blank>req<S2SV_blank>0x%x<S2SV_blank>val<S2SV_blank>0x%x<S2SV_blank>index<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u\\\\n\" , s -> ctrl . req . bRequestType , s -> ctrl . req . bRequest , value , index , s -> ctrl . len ) ; if ( s -> ctrl . req . bRequestType == 0 ) { switch ( s -> ctrl . req . bRequest ) { case USB_REQ_SET_ADDRESS : return usb_host_set_address ( s , value ) ; case USB_REQ_SET_CONFIGURATION : return usb_host_set_config ( s , value & 0xff ) ; } } if ( s -> ctrl . req . bRequestType == 1 && s -> ctrl . req . bRequest == USB_REQ_SET_INTERFACE ) return usb_host_set_interface ( s , index , value ) ; <S2SV_StartBug> aurb = async_alloc ( ) ; <S2SV_EndBug> aurb -> hdev = s ; aurb -> packet = p ; urb = & aurb -> urb ; urb -> type = USBDEVFS_URB_TYPE_CONTROL ; urb -> endpoint = p -> devep ; urb -> buffer = & s -> ctrl . req ; <S2SV_StartBug> urb -> buffer_length = 8 + s -> ctrl . len ; <S2SV_EndBug> urb -> usercontext = s ; ret = ioctl ( s -> fd , USBDEVFS_SUBMITURB , urb ) ; dprintf ( \"husb:<S2SV_blank>submit<S2SV_blank>ctrl.<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>aurb<S2SV_blank>%p\\\\n\" , urb -> buffer_length , aurb ) ; if ( ret < 0 ) { dprintf ( \"husb:<S2SV_blank>submit<S2SV_blank>failed.<S2SV_blank>errno<S2SV_blank>%d\\\\n\" , errno ) ; async_free ( aurb ) ; switch ( errno ) { case ETIMEDOUT : return USB_RET_NAK ; case EPIPE : default : return USB_RET_STALL ; } } usb_defer_packet ( p , async_cancel , aurb ) ; return USB_RET_ASYNC ; }", "target": "<S2SV_ModStart> value , index ; int buffer_len <S2SV_ModStart> value ) ; buffer_len <S2SV_ModEnd> = 8 + <S2SV_ModStart> ctrl . len ; if ( buffer_len > sizeof ( s -> ctrl . buffer ) ) { fprintf ( stderr , \"husb:<S2SV_blank>ctrl<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\\\n\" , buffer_len , sizeof ( s -> ctrl . buffer ) ) ; return USB_RET_STALL ; } aurb = async_alloc ( ) ; aurb -> hdev = s ; aurb -> packet = p ; urb = & aurb -> urb ; urb -> type = USBDEVFS_URB_TYPE_CONTROL ; urb -> endpoint = p -> devep ; urb -> buffer = & s -> ctrl . req ; urb -> buffer_length = buffer_len"}
{"source": "CWE-189 evbuffer_add ( struct evbuffer * buf , const void * data_in , size_t datlen ) { struct evbuffer_chain * chain , * tmp ; const unsigned char * data = data_in ; size_t remain , to_alloc ; int result = - 1 ; EVBUFFER_LOCK ( buf ) ; if ( buf -> freeze_end ) { goto done ; } <S2SV_StartBug> <S2SV_EndBug> chain = buf -> last ; if ( chain == NULL ) { chain = evbuffer_chain_new ( datlen ) ; if ( ! chain ) goto done ; evbuffer_chain_insert ( buf , chain ) ; } if ( ( chain -> flags & EVBUFFER_IMMUTABLE ) == 0 ) { <S2SV_StartBug> remain = ( size_t ) ( chain -> buffer_len - chain -> misalign - chain -> off ) ; <S2SV_EndBug> if ( remain >= datlen ) { memcpy ( chain -> buffer + chain -> misalign + chain -> off , data , datlen ) ; chain -> off += datlen ; buf -> total_len += datlen ; buf -> n_add_for_cb += datlen ; goto out ; } else if ( ! CHAIN_PINNED ( chain ) && evbuffer_chain_should_realign ( chain , datlen ) ) { evbuffer_chain_align ( chain ) ; memcpy ( chain -> buffer + chain -> off , data , datlen ) ; chain -> off += datlen ; buf -> total_len += datlen ; buf -> n_add_for_cb += datlen ; goto out ; } } else { remain = 0 ; } to_alloc = chain -> buffer_len ; if ( to_alloc <= EVBUFFER_CHAIN_MAX_AUTO_SIZE / 2 ) to_alloc <<= 1 ; if ( datlen > to_alloc ) to_alloc = datlen ; tmp = evbuffer_chain_new ( to_alloc ) ; if ( tmp == NULL ) goto done ; if ( remain ) { memcpy ( chain -> buffer + chain -> misalign + chain -> off , data , remain ) ; chain -> off += remain ; buf -> total_len += remain ; buf -> n_add_for_cb += remain ; } data += remain ; datlen -= remain ; memcpy ( tmp -> buffer , data , datlen ) ; tmp -> off = datlen ; evbuffer_chain_insert ( buf , tmp ) ; buf -> n_add_for_cb += datlen ; out : evbuffer_invoke_callbacks ( buf ) ; result = 0 ; done : EVBUFFER_UNLOCK ( buf ) ; return result ; }", "target": "<S2SV_ModStart> done ; } if ( datlen > EV_SIZE_MAX - buf -> total_len ) { goto done ; } <S2SV_ModStart> 0 ) { EVUTIL_ASSERT ( chain -> misalign >= 0 && ( ev_uint64_t ) chain -> misalign <= EVBUFFER_CHAIN_MAX ) ; remain = <S2SV_ModEnd> chain -> buffer_len <S2SV_ModStart> -> buffer_len - ( size_t ) <S2SV_ModStart> chain -> off <S2SV_ModEnd> ; if ("}
{"source": "CWE-125 p11_rpc_buffer_get_byte_array ( p11_buffer * buf , size_t * offset , const unsigned char * * data , size_t * length ) { size_t off = * offset ; uint32_t len ; if ( ! p11_rpc_buffer_get_uint32 ( buf , & off , & len ) ) return false ; if ( len == 0xffffffff ) { * offset = off ; if ( data ) * data = NULL ; if ( length ) * length = 0 ; return true ; } else if ( len >= 0x7fffffff ) { p11_buffer_fail ( buf ) ; return false ; } <S2SV_StartBug> if ( buf -> len < len || * offset > buf -> len - len ) { <S2SV_EndBug> p11_buffer_fail ( buf ) ; return false ; } if ( data ) * data = ( unsigned char * ) buf -> data + off ; if ( length ) * length = len ; * offset = off + len ; return true ; }", "target": "<S2SV_ModStart> < len || off <S2SV_ModEnd> > buf ->"}
{"source": "CWE-125 pixReadFromTiffStream ( TIFF * tif ) { char * text ; l_uint8 * linebuf , * data , * rowptr ; l_uint16 spp , bps , photometry , tiffcomp , orientation , sample_fmt ; l_uint16 * redmap , * greenmap , * bluemap ; l_int32 d , wpl , bpl , comptype , i , j , k , ncolors , rval , gval , bval , aval ; l_int32 xres , yres , tiffbpl , packedbpl , halfsize ; l_uint32 w , h , tiffword , read_oriented ; l_uint32 * line , * ppixel , * tiffdata , * pixdata ; PIX * pix , * pix1 ; PIXCMAP * cmap ; PROCNAME ( \"pixReadFromTiffStream\" ) ; if ( ! tif ) return ( PIX * ) ERROR_PTR ( \"tif<S2SV_blank>not<S2SV_blank>defined\" , procName , NULL ) ; read_oriented = 0 ; TIFFGetFieldDefaulted ( tif , TIFFTAG_SAMPLEFORMAT , & sample_fmt ) ; if ( sample_fmt != SAMPLEFORMAT_UINT ) { L_ERROR ( \"sample<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>uint\\\\n\" , procName , sample_fmt ) ; return NULL ; } if ( TIFFIsTiled ( tif ) ) { L_ERROR ( \"tiled<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\\\n\" , procName ) ; return NULL ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_COMPRESSION , & tiffcomp ) ; if ( tiffcomp == COMPRESSION_OJPEG ) { L_ERROR ( \"old<S2SV_blank>style<S2SV_blank>jpeg<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\\\n\" , procName ) ; return NULL ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( tif , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; if ( bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16 ) { L_ERROR ( \"invalid<S2SV_blank>bps<S2SV_blank>=<S2SV_blank>%d\\\\n\" , procName , bps ) ; return NULL ; } if ( spp == 2 && bps != 8 ) { L_WARNING ( \"for<S2SV_blank>2<S2SV_blank>spp,<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>8<S2SV_blank>bps\\\\n\" , procName ) ; return NULL ; } if ( spp == 1 ) d = bps ; else if ( spp == 2 ) d = 32 ; else if ( spp == 3 || spp == 4 ) d = 32 ; else return ( PIX * ) ERROR_PTR ( \"spp<S2SV_blank>not<S2SV_blank>in<S2SV_blank>set<S2SV_blank>{1,2,3,4}\" , procName , NULL ) ; TIFFGetField ( tif , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( tif , TIFFTAG_IMAGELENGTH , & h ) ; if ( w > MaxTiffWidth ) { L_ERROR ( \"width<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>pixels;<S2SV_blank>too<S2SV_blank>large\\\\n\" , procName , w ) ; return NULL ; } if ( h > MaxTiffHeight ) { L_ERROR ( \"height<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>pixels;<S2SV_blank>too<S2SV_blank>large\\\\n\" , procName , h ) ; return NULL ; } tiffbpl = TIFFScanlineSize ( tif ) ; packedbpl = ( bps * spp * w + 7 ) / 8 ; halfsize = L_ABS ( 2 * tiffbpl - packedbpl ) <= 8 ; # if 0 if ( halfsize ) L_INFO ( \"packedbpl<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>approx.<S2SV_blank>twice<S2SV_blank>tiffbpl<S2SV_blank>=<S2SV_blank>%d\\\\n\" , procName , packedbpl , tiffbpl ) ; # endif if ( tiffbpl != packedbpl && ! halfsize ) { L_ERROR ( \"invalid<S2SV_blank>tiffbpl:<S2SV_blank>tiffbpl<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>packedbpl<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>\" \"bps<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>spp<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>w<S2SV_blank>=<S2SV_blank>%d\\\\n\" , procName , tiffbpl , packedbpl , bps , spp , w ) ; return NULL ; } if ( ( pix = pixCreate ( w , h , d ) ) == NULL ) return ( PIX * ) ERROR_PTR ( \"pix<S2SV_blank>not<S2SV_blank>made\" , procName , NULL ) ; pixSetInputFormat ( pix , IFF_TIFF ) ; data = ( l_uint8 * ) pixGetData ( pix ) ; wpl = pixGetWpl ( pix ) ; bpl = 4 * wpl ; if ( spp == 1 ) { linebuf = ( l_uint8 * ) LEPT_CALLOC ( tiffbpl + 1 , sizeof ( l_uint8 ) ) ; for ( i = 0 ; i < h ; i ++ ) { if ( TIFFReadScanline ( tif , linebuf , i , 0 ) < 0 ) { LEPT_FREE ( linebuf ) ; pixDestroy ( & pix ) ; return ( PIX * ) ERROR_PTR ( \"line<S2SV_blank>read<S2SV_blank>fail\" , procName , NULL ) ; } memcpy ( data , linebuf , tiffbpl ) ; data += bpl ; } if ( bps <= 8 ) pixEndianByteSwap ( pix ) ; else pixEndianTwoByteSwap ( pix ) ; LEPT_FREE ( linebuf ) ; } else if ( spp == 2 && bps == 8 ) { L_INFO ( \"gray+alpha<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>converting<S2SV_blank>to<S2SV_blank>RGBA\\\\n\" , procName ) ; pixSetSpp ( pix , 4 ) ; <S2SV_StartBug> linebuf = ( l_uint8 * ) LEPT_CALLOC ( tiffbpl + 1 , sizeof ( l_uint8 ) ) ; <S2SV_EndBug> pixdata = pixGetData ( pix ) ; for ( i = 0 ; i < h ; i ++ ) { if ( TIFFReadScanline ( tif , linebuf , i , 0 ) < 0 ) { LEPT_FREE ( linebuf ) ; pixDestroy ( & pix ) ; return ( PIX * ) ERROR_PTR ( \"line<S2SV_blank>read<S2SV_blank>fail\" , procName , NULL ) ; } rowptr = linebuf ; ppixel = pixdata + i * wpl ; for ( j = k = 0 ; j < w ; j ++ ) { SET_DATA_BYTE ( ppixel , COLOR_RED , rowptr [ k ] ) ; SET_DATA_BYTE ( ppixel , COLOR_GREEN , rowptr [ k ] ) ; SET_DATA_BYTE ( ppixel , COLOR_BLUE , rowptr [ k ++ ] ) ; SET_DATA_BYTE ( ppixel , L_ALPHA_CHANNEL , rowptr [ k ++ ] ) ; ppixel ++ ; } } LEPT_FREE ( linebuf ) ; } else { if ( ( tiffdata = ( l_uint32 * ) LEPT_CALLOC ( ( size_t ) w * h , sizeof ( l_uint32 ) ) ) == NULL ) { pixDestroy ( & pix ) ; return ( PIX * ) ERROR_PTR ( \"calloc<S2SV_blank>fail<S2SV_blank>for<S2SV_blank>tiffdata\" , procName , NULL ) ; } if ( ! TIFFReadRGBAImageOriented ( tif , w , h , tiffdata , ORIENTATION_TOPLEFT , 0 ) ) { LEPT_FREE ( tiffdata ) ; pixDestroy ( & pix ) ; return ( PIX * ) ERROR_PTR ( \"failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>tiffdata\" , procName , NULL ) ; } else { read_oriented = 1 ; } if ( spp == 4 ) pixSetSpp ( pix , 4 ) ; line = pixGetData ( pix ) ; for ( i = 0 ; i < h ; i ++ , line += wpl ) { for ( j = 0 , ppixel = line ; j < w ; j ++ ) { tiffword = tiffdata [ i * w + j ] ; rval = TIFFGetR ( tiffword ) ; gval = TIFFGetG ( tiffword ) ; bval = TIFFGetB ( tiffword ) ; if ( spp == 3 ) { composeRGBPixel ( rval , gval , bval , ppixel ) ; } else { aval = TIFFGetA ( tiffword ) ; composeRGBAPixel ( rval , gval , bval , aval , ppixel ) ; } ppixel ++ ; } } LEPT_FREE ( tiffdata ) ; } if ( getTiffStreamResolution ( tif , & xres , & yres ) == 0 ) { pixSetXRes ( pix , xres ) ; pixSetYRes ( pix , yres ) ; } comptype = getTiffCompressedFormat ( tiffcomp ) ; pixSetInputFormat ( pix , comptype ) ; if ( TIFFGetField ( tif , TIFFTAG_COLORMAP , & redmap , & greenmap , & bluemap ) ) { if ( bps > 8 ) { pixDestroy ( & pix ) ; return ( PIX * ) ERROR_PTR ( \"colormap<S2SV_blank>size<S2SV_blank>><S2SV_blank>256\" , procName , NULL ) ; } if ( ( cmap = pixcmapCreate ( bps ) ) == NULL ) { pixDestroy ( & pix ) ; return ( PIX * ) ERROR_PTR ( \"colormap<S2SV_blank>not<S2SV_blank>made\" , procName , NULL ) ; } ncolors = 1 << bps ; for ( i = 0 ; i < ncolors ; i ++ ) pixcmapAddColor ( cmap , redmap [ i ] >> 8 , greenmap [ i ] >> 8 , bluemap [ i ] >> 8 ) ; if ( pixSetColormap ( pix , cmap ) ) { pixDestroy ( & pix ) ; return ( PIX * ) ERROR_PTR ( \"invalid<S2SV_blank>colormap\" , procName , NULL ) ; } if ( bps == 1 ) { pix1 = pixRemoveColormap ( pix , REMOVE_CMAP_BASED_ON_SRC ) ; pixDestroy ( & pix ) ; pix = pix1 ; } } else { if ( ! TIFFGetField ( tif , TIFFTAG_PHOTOMETRIC , & photometry ) ) { if ( tiffcomp == COMPRESSION_CCITTFAX3 || tiffcomp == COMPRESSION_CCITTFAX4 || tiffcomp == COMPRESSION_CCITTRLE || tiffcomp == COMPRESSION_CCITTRLEW ) { photometry = PHOTOMETRIC_MINISWHITE ; } else { photometry = PHOTOMETRIC_MINISBLACK ; } } if ( ( d == 1 && photometry == PHOTOMETRIC_MINISBLACK ) || ( d == 8 && photometry == PHOTOMETRIC_MINISWHITE ) ) pixInvert ( pix , pix ) ; } if ( TIFFGetField ( tif , TIFFTAG_ORIENTATION , & orientation ) ) { if ( orientation >= 1 && orientation <= 8 ) { struct tiff_transform * transform = ( read_oriented ) ? & tiff_partial_orientation_transforms [ orientation - 1 ] : & tiff_orientation_transforms [ orientation - 1 ] ; if ( transform -> vflip ) pixFlipTB ( pix , pix ) ; if ( transform -> hflip ) pixFlipLR ( pix , pix ) ; if ( transform -> rotate ) { PIX * oldpix = pix ; pix = pixRotate90 ( oldpix , transform -> rotate ) ; pixDestroy ( & oldpix ) ; } } } text = NULL ; TIFFGetField ( tif , TIFFTAG_IMAGEDESCRIPTION , & text ) ; if ( text ) pixSetText ( pix , text ) ; return pix ; }", "target": "<S2SV_ModStart> ) LEPT_CALLOC ( 2 *"}
{"source": "CWE-703 int input_set_keycode ( struct input_dev * dev , const struct input_keymap_entry * ke ) { unsigned long flags ; unsigned int old_keycode ; int retval ; if ( ke -> keycode > KEY_MAX ) return - EINVAL ; spin_lock_irqsave ( & dev -> event_lock , flags ) ; retval = dev -> setkeycode ( dev , ke , & old_keycode ) ; if ( retval ) goto out ; __clear_bit ( KEY_RESERVED , dev -> keybit ) ; <S2SV_StartBug> if ( test_bit ( EV_KEY , dev -> evbit ) && <S2SV_EndBug> ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) { struct input_value vals [ ] = { { EV_KEY , old_keycode , 0 } , input_value_sync } ; input_pass_values ( dev , vals , ARRAY_SIZE ( vals ) ) ; } out : spin_unlock_irqrestore ( & dev -> event_lock , flags ) ; return retval ; }", "target": "<S2SV_ModStart> keybit ) ; if ( old_keycode > KEY_MAX ) { dev_warn ( dev -> dev . parent ? : & dev -> dev , \"%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\\\n\" , __func__ , old_keycode ) ; } else"}
{"source": "CWE-416 static int kvm_s390_get_cmma ( struct kvm * kvm , struct kvm_s390_cmma_log * args , u8 * res , unsigned long bufsize ) { unsigned long mem_end , cur_gfn , next_gfn , hva , pgstev ; struct kvm_memslots * slots = kvm_memslots ( kvm ) ; <S2SV_StartBug> struct kvm_memory_slot * ms ; <S2SV_EndBug> cur_gfn = kvm_s390_next_dirty_cmma ( slots , args -> start_gfn ) ; ms = gfn_to_memslot ( kvm , cur_gfn ) ; args -> count = 0 ; args -> start_gfn = cur_gfn ; if ( ! ms ) return 0 ; next_gfn = kvm_s390_next_dirty_cmma ( slots , cur_gfn + 1 ) ; mem_end = slots -> memslots [ 0 ] . base_gfn + slots -> memslots [ 0 ] . npages ; while ( args -> count < bufsize ) { hva = gfn_to_hva ( kvm , cur_gfn ) ; if ( kvm_is_error_hva ( hva ) ) return 0 ; if ( test_and_clear_bit ( cur_gfn - ms -> base_gfn , kvm_second_dirty_bitmap ( ms ) ) ) atomic64_dec ( & kvm -> arch . cmma_dirty_pages ) ; if ( get_pgste ( kvm -> mm , hva , & pgstev ) < 0 ) pgstev = 0 ; res [ args -> count ++ ] = ( pgstev >> 24 ) & 0x43 ; if ( next_gfn > cur_gfn + KVM_S390_MAX_BIT_DISTANCE ) return 0 ; if ( cur_gfn == next_gfn ) next_gfn = kvm_s390_next_dirty_cmma ( slots , cur_gfn + 1 ) ; if ( ( next_gfn >= mem_end ) || ( next_gfn - args -> start_gfn >= bufsize ) ) return 0 ; cur_gfn ++ ; if ( cur_gfn - ms -> base_gfn >= ms -> npages ) { ms = gfn_to_memslot ( kvm , cur_gfn ) ; if ( ! ms ) return 0 ; } } return 0 ; }", "target": "<S2SV_ModStart> kvm_memory_slot * ms ; if ( unlikely ( ! slots -> used_slots ) ) return 0"}
{"source": "CWE-416 static inline void kvm_memslot_delete ( struct kvm_memslots * slots , struct kvm_memory_slot * memslot ) { struct kvm_memory_slot * mslots = slots -> memslots ; int i ; if ( WARN_ON ( slots -> id_to_index [ memslot -> id ] == - 1 ) ) return ; <S2SV_StartBug> slots -> used_slots -- ; <S2SV_EndBug> for ( i = slots -> id_to_index [ memslot -> id ] ; i < slots -> used_slots ; i ++ ) { mslots [ i ] = mslots [ i + 1 ] ; slots -> id_to_index [ mslots [ i ] . id ] = i ; } mslots [ i ] = * memslot ; slots -> id_to_index [ memslot -> id ] = - 1 ; }", "target": "<S2SV_ModStart> -> used_slots -- ; if ( atomic_read ( & slots -> lru_slot ) >= slots -> used_slots ) atomic_set ( & slots -> lru_slot , 0 )"}
{"source": "CWE-416 search_memslots ( struct kvm_memslots * slots , gfn_t gfn ) { int start = 0 , end = slots -> used_slots ; int slot = atomic_read ( & slots -> lru_slot ) ; struct kvm_memory_slot * memslots = slots -> memslots ; <S2SV_StartBug> if ( gfn >= memslots [ slot ] . base_gfn && <S2SV_EndBug> gfn < memslots [ slot ] . base_gfn + memslots [ slot ] . npages ) return & memslots [ slot ] ; while ( start < end ) { slot = start + ( end - start ) / 2 ; if ( gfn >= memslots [ slot ] . base_gfn ) end = slot ; else start = slot + 1 ; } if ( gfn >= memslots [ start ] . base_gfn && gfn < memslots [ start ] . base_gfn + memslots [ start ] . npages ) { atomic_set ( & slots -> lru_slot , start ) ; return & memslots [ start ] ; } return NULL ; }", "target": "<S2SV_ModStart> ; if ( unlikely ( ! slots -> used_slots ) ) return NULL ; if ("}
{"source": "CWE-269 static int do_mount ( const char * mnt , char * * typep , mode_t rootmode , int fd , const char * opts , const char * dev , char * * sourcep , char * * mnt_optsp ) { int res ; int flags = MS_NOSUID | MS_NODEV ; char * optbuf ; char * mnt_opts = NULL ; const char * s ; char * d ; char * fsname = NULL ; char * subtype = NULL ; char * source = NULL ; char * type = NULL ; int blkdev = 0 ; optbuf = ( char * ) malloc ( strlen ( opts ) + 128 ) ; if ( ! optbuf ) { fprintf ( stderr , \"%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\\\n\" , progname ) ; return - 1 ; } for ( s = opts , d = optbuf ; * s ; ) { unsigned len ; const char * fsname_str = \"fsname=\" ; const char * subtype_str = \"subtype=\" ; bool escape_ok = begins_with ( s , fsname_str ) || begins_with ( s , subtype_str ) ; for ( len = 0 ; s [ len ] ; len ++ ) { if ( escape_ok && s [ len ] == '\\\\\\\\' && s [ len + 1 ] ) len ++ ; else if ( s [ len ] == ',' ) break ; } if ( begins_with ( s , fsname_str ) ) { if ( ! get_string_opt ( s , len , fsname_str , & fsname ) ) goto err ; } else if ( begins_with ( s , subtype_str ) ) { if ( ! get_string_opt ( s , len , subtype_str , & subtype ) ) goto err ; } else if ( opt_eq ( s , len , \"blkdev\" ) ) { if ( getuid ( ) != 0 ) { fprintf ( stderr , \"%s:<S2SV_blank>option<S2SV_blank>blkdev<S2SV_blank>is<S2SV_blank>privileged\\\\n\" , progname ) ; goto err ; } blkdev = 1 ; } else if ( opt_eq ( s , len , \"auto_unmount\" ) ) { auto_unmount = 1 ; } else if ( ! begins_with ( s , \"fd=\" ) && ! begins_with ( s , \"rootmode=\" ) && ! begins_with ( s , \"user_id=\" ) && ! begins_with ( s , \"group_id=\" ) ) { int on ; int flag ; int skip_option = 0 ; if ( opt_eq ( s , len , \"large_read\" ) ) { struct utsname utsname ; unsigned kmaj , kmin ; res = uname ( & utsname ) ; if ( res == 0 && sscanf ( utsname . release , \"%u.%u\" , & kmaj , & kmin ) == 2 && ( kmaj > 2 || ( kmaj == 2 && kmin > 4 ) ) ) { fprintf ( stderr , \"%s:<S2SV_blank>note:<S2SV_blank>\\'large_read\\'<S2SV_blank>mount<S2SV_blank>option<S2SV_blank>is<S2SV_blank>deprecated<S2SV_blank>for<S2SV_blank>%i.%i<S2SV_blank>kernels\\\\n\" , progname , kmaj , kmin ) ; skip_option = 1 ; } } if ( getuid ( ) != 0 && ! user_allow_other && ( opt_eq ( s , len , \"allow_other\" ) || opt_eq ( s , len , \"allow_root\" ) ) ) { fprintf ( stderr , \"%s:<S2SV_blank>option<S2SV_blank>%.*s<S2SV_blank>only<S2SV_blank>allowed<S2SV_blank>if<S2SV_blank>\\'user_allow_other\\'<S2SV_blank>is<S2SV_blank>set<S2SV_blank>in<S2SV_blank>%s\\\\n\" , progname , len , s , FUSE_CONF ) ; goto err ; } if ( ! skip_option ) { if ( find_mount_flag ( s , len , & on , & flag ) ) { if ( on ) flags |= flag ; else flags &= ~ flag ; <S2SV_StartBug> } else { <S2SV_EndBug> memcpy ( d , s , len ) ; d += len ; <S2SV_StartBug> * d ++ = ',' ; <S2SV_EndBug> } } } s += len ; if ( * s ) s ++ ; } * d = '\\\\0' ; res = get_mnt_opts ( flags , optbuf , & mnt_opts ) ; if ( res == - 1 ) goto err ; sprintf ( d , \"fd=%i,rootmode=%o,user_id=%u,group_id=%u\" , fd , rootmode , getuid ( ) , getgid ( ) ) ; source = malloc ( ( fsname ? strlen ( fsname ) : 0 ) + ( subtype ? strlen ( subtype ) : 0 ) + strlen ( dev ) + 32 ) ; type = malloc ( ( subtype ? strlen ( subtype ) : 0 ) + 32 ) ; if ( ! type || ! source ) { fprintf ( stderr , \"%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\\\n\" , progname ) ; goto err ; } if ( subtype ) sprintf ( type , \"%s.%s\" , blkdev ? \"fuseblk\" : \"fuse\" , subtype ) ; else strcpy ( type , blkdev ? \"fuseblk\" : \"fuse\" ) ; if ( fsname ) strcpy ( source , fsname ) ; else strcpy ( source , subtype ? subtype : dev ) ; res = mount_notrunc ( source , mnt , type , flags , optbuf ) ; if ( res == - 1 && errno == ENODEV && subtype ) { strcpy ( type , blkdev ? \"fuseblk\" : \"fuse\" ) ; if ( fsname ) { if ( ! blkdev ) sprintf ( source , \"%s#%s\" , subtype , fsname ) ; } else { strcpy ( source , type ) ; } res = mount_notrunc ( source , mnt , type , flags , optbuf ) ; } if ( res == - 1 && errno == EINVAL ) { sprintf ( d , \"fd=%i,rootmode=%o,user_id=%u\" , fd , rootmode , getuid ( ) ) ; res = mount_notrunc ( source , mnt , type , flags , optbuf ) ; } if ( res == - 1 ) { int errno_save = errno ; if ( blkdev && errno == ENODEV && ! fuse_mnt_check_fuseblk ( ) ) fprintf ( stderr , \"%s:<S2SV_blank>\\'fuseblk\\'<S2SV_blank>support<S2SV_blank>missing\\\\n\" , progname ) ; else fprintf ( stderr , \"%s:<S2SV_blank>mount<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" , progname , strerror ( errno_save ) ) ; goto err ; } * sourcep = source ; * typep = type ; * mnt_optsp = mnt_opts ; free ( fsname ) ; free ( optbuf ) ; return 0 ; err : free ( fsname ) ; free ( subtype ) ; free ( source ) ; free ( type ) ; free ( mnt_opts ) ; free ( optbuf ) ; return - 1 ; }", "target": "<S2SV_ModStart> ; } else if ( opt_eq ( s , len , \"default_permissions\" ) || opt_eq ( s , len , \"allow_other\" ) || begins_with ( s , \"max_read=\" ) || begins_with ( s , \"blksize=\" ) ) <S2SV_ModStart> ++ = ',' ; } else { fprintf ( stderr , \"%s:<S2SV_blank>unknown<S2SV_blank>option<S2SV_blank>\\'%.*s\\'\\\\n\" , progname , len , s ) ; exit ( 1 )"}
{"source": "CWE-399 xz_decomp ( xz_statep state ) { int ret ; unsigned had ; unsigned long crc , len ; lzma_stream * strm = & ( state -> strm ) ; lzma_action action = LZMA_RUN ; had = strm -> avail_out ; do { if ( strm -> avail_in == 0 && xz_avail ( state ) == - 1 ) return - 1 ; if ( strm -> avail_in == 0 ) { xz_error ( state , LZMA_DATA_ERROR , \"unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file\" ) ; return - 1 ; } if ( state -> eof ) action = LZMA_FINISH ; # ifdef HAVE_ZLIB_H if ( state -> how == GZIP ) { state -> zstrm . avail_in = ( uInt ) state -> strm . avail_in ; state -> zstrm . next_in = ( Bytef * ) state -> strm . next_in ; state -> zstrm . avail_out = ( uInt ) state -> strm . avail_out ; state -> zstrm . next_out = ( Bytef * ) state -> strm . next_out ; ret = inflate ( & state -> zstrm , Z_NO_FLUSH ) ; if ( ret == Z_STREAM_ERROR || ret == Z_NEED_DICT ) { xz_error ( state , Z_STREAM_ERROR , \"internal<S2SV_blank>error:<S2SV_blank>inflate<S2SV_blank>stream<S2SV_blank>corrupt\" ) ; return - 1 ; } if ( ret == Z_MEM_ERROR ) ret = LZMA_MEM_ERROR ; if ( ret == Z_DATA_ERROR ) ret = LZMA_DATA_ERROR ; if ( ret == Z_STREAM_END ) ret = LZMA_STREAM_END ; state -> strm . avail_in = state -> zstrm . avail_in ; state -> strm . next_in = state -> zstrm . next_in ; state -> strm . avail_out = state -> zstrm . avail_out ; state -> strm . next_out = state -> zstrm . next_out ; } else # endif ret = lzma_code ( strm , action ) ; if ( ret == LZMA_MEM_ERROR ) { xz_error ( state , LZMA_MEM_ERROR , \"out<S2SV_blank>of<S2SV_blank>memory\" ) ; return - 1 ; } if ( ret == LZMA_DATA_ERROR ) { <S2SV_StartBug> xz_error ( state , LZMA_DATA_ERROR , \"compressed<S2SV_blank>data<S2SV_blank>error\" ) ; <S2SV_EndBug> return - 1 ; } } while ( strm -> avail_out && ret != LZMA_STREAM_END ) ; state -> have = had - strm -> avail_out ; state -> next = strm -> next_out - state -> have ; # ifdef HAVE_ZLIB_H state -> zstrm . adler = crc32 ( state -> zstrm . adler , state -> next , state -> have ) ; # endif if ( ret == LZMA_STREAM_END ) { # ifdef HAVE_ZLIB_H if ( state -> how == GZIP ) { if ( gz_next4 ( state , & crc ) == - 1 || gz_next4 ( state , & len ) == - 1 ) { xz_error ( state , LZMA_DATA_ERROR , \"unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file\" ) ; return - 1 ; } if ( crc != state -> zstrm . adler ) { xz_error ( state , LZMA_DATA_ERROR , \"incorrect<S2SV_blank>data<S2SV_blank>check\" ) ; return - 1 ; } if ( len != ( state -> zstrm . total_out & 0xffffffffL ) ) { xz_error ( state , LZMA_DATA_ERROR , \"incorrect<S2SV_blank>length<S2SV_blank>check\" ) ; return - 1 ; } state -> strm . avail_in = 0 ; state -> strm . next_in = NULL ; state -> strm . avail_out = 0 ; state -> strm . next_out = NULL ; } else # endif if ( strm -> avail_in != 0 || ! state -> eof ) { xz_error ( state , LZMA_DATA_ERROR , \"trailing<S2SV_blank>garbage\" ) ; return - 1 ; } state -> how = LOOK ; } return 0 ; }", "target": "<S2SV_ModStart> LZMA_DATA_ERROR , \"compressed<S2SV_blank>data<S2SV_blank>error\" ) ; return - 1 ; } if ( ret == LZMA_PROG_ERROR ) { xz_error ( state , LZMA_PROG_ERROR , \"compression<S2SV_blank>error\""}
{"source": "CWE-755 static int selectExpander ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i , j , k ; SrcList * pTabList ; ExprList * pEList ; struct SrcList_item * pFrom ; sqlite3 * db = pParse -> db ; Expr * pE , * pRight , * pExpr ; u16 selFlags = p -> selFlags ; u32 elistFlags = 0 ; p -> selFlags |= SF_Expanded ; if ( db -> mallocFailed ) { return WRC_Abort ; } assert ( p -> pSrc != 0 ) ; if ( ( selFlags & SF_Expanded ) != 0 ) { return WRC_Prune ; } if ( pWalker -> eCode ) { p -> selId = ++ pParse -> nSelect ; } pTabList = p -> pSrc ; pEList = p -> pEList ; sqlite3WithPush ( pParse , p -> pWith , 0 ) ; sqlite3SrcListAssignCursors ( pParse , pTabList ) ; for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab ; assert ( pFrom -> fg . isRecursive == 0 || pFrom -> pTab != 0 ) ; if ( pFrom -> fg . isRecursive ) continue ; assert ( pFrom -> pTab == 0 ) ; # ifndef SQLITE_OMIT_CTE if ( withExpand ( pWalker , pFrom ) ) return WRC_Abort ; if ( pFrom -> pTab ) { } else # endif if ( pFrom -> zName == 0 ) { # ifndef SQLITE_OMIT_SUBQUERY Select * pSel = pFrom -> pSelect ; assert ( pSel != 0 ) ; assert ( pFrom -> pTab == 0 ) ; if ( sqlite3WalkSelect ( pWalker , pSel ) ) return WRC_Abort ; if ( sqlite3ExpandSubquery ( pParse , pFrom ) ) return WRC_Abort ; # endif } else { assert ( pFrom -> pTab == 0 ) ; pFrom -> pTab = pTab = sqlite3LocateTableItem ( pParse , 0 , pFrom ) ; if ( pTab == 0 ) return WRC_Abort ; if ( pTab -> nTabRef >= 0xffff ) { sqlite3ErrorMsg ( pParse , \"too<S2SV_blank>many<S2SV_blank>references<S2SV_blank>to<S2SV_blank>\\\\\"%s\\\\\":<S2SV_blank>max<S2SV_blank>65535\" , pTab -> zName ) ; pFrom -> pTab = 0 ; return WRC_Abort ; } pTab -> nTabRef ++ ; if ( ! IsVirtual ( pTab ) && cannotBeFunction ( pParse , pFrom ) ) { return WRC_Abort ; } # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_VIRTUALTABLE ) if ( IsVirtual ( pTab ) || pTab -> pSelect ) { i16 nCol ; u8 eCodeOrig = pWalker -> eCode ; if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) return WRC_Abort ; assert ( pFrom -> pSelect == 0 ) ; if ( pTab -> pSelect && ( db -> flags & SQLITE_EnableView ) == 0 ) { sqlite3ErrorMsg ( pParse , \"access<S2SV_blank>to<S2SV_blank>view<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>prohibited\" , pTab -> zName ) ; } pFrom -> pSelect = sqlite3SelectDup ( db , pTab -> pSelect , 0 ) ; nCol = pTab -> nCol ; pTab -> nCol = - 1 ; pWalker -> eCode = 1 ; sqlite3WalkSelect ( pWalker , pFrom -> pSelect ) ; pWalker -> eCode = eCodeOrig ; pTab -> nCol = nCol ; } # endif } if ( sqlite3IndexedByLookup ( pParse , pFrom ) ) { return WRC_Abort ; } } <S2SV_StartBug> if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) { <S2SV_EndBug> return WRC_Abort ; } for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { pE = pEList -> a [ k ] . pExpr ; if ( pE -> op == TK_ASTERISK ) break ; assert ( pE -> op != TK_DOT || pE -> pRight != 0 ) ; assert ( pE -> op != TK_DOT || ( pE -> pLeft != 0 && pE -> pLeft -> op == TK_ID ) ) ; if ( pE -> op == TK_DOT && pE -> pRight -> op == TK_ASTERISK ) break ; elistFlags |= pE -> flags ; } if ( k < pEList -> nExpr ) { struct ExprList_item * a = pEList -> a ; ExprList * pNew = 0 ; int flags = pParse -> db -> flags ; int longNames = ( flags & SQLITE_FullColNames ) != 0 && ( flags & SQLITE_ShortColNames ) == 0 ; for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { pE = a [ k ] . pExpr ; elistFlags |= pE -> flags ; pRight = pE -> pRight ; assert ( pE -> op != TK_DOT || pRight != 0 ) ; if ( pE -> op != TK_ASTERISK && ( pE -> op != TK_DOT || pRight -> op != TK_ASTERISK ) ) { pNew = sqlite3ExprListAppend ( pParse , pNew , a [ k ] . pExpr ) ; if ( pNew ) { pNew -> a [ pNew -> nExpr - 1 ] . zName = a [ k ] . zName ; pNew -> a [ pNew -> nExpr - 1 ] . zSpan = a [ k ] . zSpan ; a [ k ] . zName = 0 ; a [ k ] . zSpan = 0 ; } a [ k ] . pExpr = 0 ; } else { int tableSeen = 0 ; char * zTName = 0 ; if ( pE -> op == TK_DOT ) { assert ( pE -> pLeft != 0 ) ; assert ( ! ExprHasProperty ( pE -> pLeft , EP_IntValue ) ) ; zTName = pE -> pLeft -> u . zToken ; } for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab = pFrom -> pTab ; Select * pSub = pFrom -> pSelect ; char * zTabName = pFrom -> zAlias ; const char * zSchemaName = 0 ; int iDb ; if ( zTabName == 0 ) { zTabName = pTab -> zName ; } if ( db -> mallocFailed ) break ; if ( pSub == 0 || ( pSub -> selFlags & SF_NestedFrom ) == 0 ) { pSub = 0 ; if ( zTName && sqlite3StrICmp ( zTName , zTabName ) != 0 ) { continue ; } iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; zSchemaName = iDb >= 0 ? db -> aDb [ iDb ] . zDbSName : \"*\" ; } for ( j = 0 ; j < pTab -> nCol ; j ++ ) { char * zName = pTab -> aCol [ j ] . zName ; char * zColname ; char * zToFree ; Token sColname ; assert ( zName ) ; if ( zTName && pSub && sqlite3MatchSpanName ( pSub -> pEList -> a [ j ] . zSpan , 0 , zTName , 0 ) == 0 ) { continue ; } if ( ( p -> selFlags & SF_IncludeHidden ) == 0 && IsHiddenColumn ( & pTab -> aCol [ j ] ) ) { continue ; } tableSeen = 1 ; if ( i > 0 && zTName == 0 ) { if ( ( pFrom -> fg . jointype & JT_NATURAL ) != 0 && tableAndColumnIndex ( pTabList , i , zName , 0 , 0 ) ) { continue ; } if ( sqlite3IdListIndex ( pFrom -> pUsing , zName ) >= 0 ) { continue ; } } pRight = sqlite3Expr ( db , TK_ID , zName ) ; zColname = zName ; zToFree = 0 ; if ( longNames || pTabList -> nSrc > 1 ) { Expr * pLeft ; pLeft = sqlite3Expr ( db , TK_ID , zTabName ) ; pExpr = sqlite3PExpr ( pParse , TK_DOT , pLeft , pRight ) ; if ( zSchemaName ) { pLeft = sqlite3Expr ( db , TK_ID , zSchemaName ) ; pExpr = sqlite3PExpr ( pParse , TK_DOT , pLeft , pExpr ) ; } if ( longNames ) { zColname = sqlite3MPrintf ( db , \"%s.%s\" , zTabName , zName ) ; zToFree = zColname ; } } else { pExpr = pRight ; } pNew = sqlite3ExprListAppend ( pParse , pNew , pExpr ) ; sqlite3TokenInit ( & sColname , zColname ) ; sqlite3ExprListSetName ( pParse , pNew , & sColname , 0 ) ; if ( pNew && ( p -> selFlags & SF_NestedFrom ) != 0 ) { struct ExprList_item * pX = & pNew -> a [ pNew -> nExpr - 1 ] ; if ( pSub ) { pX -> zSpan = sqlite3DbStrDup ( db , pSub -> pEList -> a [ j ] . zSpan ) ; testcase ( pX -> zSpan == 0 ) ; } else { pX -> zSpan = sqlite3MPrintf ( db , \"%s.%s.%s\" , zSchemaName , zTabName , zColname ) ; testcase ( pX -> zSpan == 0 ) ; } pX -> bSpanIsTab = 1 ; } sqlite3DbFree ( db , zToFree ) ; } } if ( ! tableSeen ) { if ( zTName ) { sqlite3ErrorMsg ( pParse , \"no<S2SV_blank>such<S2SV_blank>table:<S2SV_blank>%s\" , zTName ) ; } else { sqlite3ErrorMsg ( pParse , \"no<S2SV_blank>tables<S2SV_blank>specified\" ) ; } } } } sqlite3ExprListDelete ( db , pEList ) ; p -> pEList = pNew ; } if ( p -> pEList ) { if ( p -> pEList -> nExpr > db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , \"too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>in<S2SV_blank>result<S2SV_blank>set\" ) ; return WRC_Abort ; } if ( ( elistFlags & ( EP_HasFunc | EP_Subquery ) ) != 0 ) { p -> selFlags |= SF_ComplexResult ; } } return WRC_Continue ; }", "target": "<S2SV_ModStart> } if ( pParse -> nErr ||"}
{"source": "CWE-193 sudoers_policy_deserialize_info ( void * v ) <S2SV_StartBug> { <S2SV_EndBug> struct sudoers_open_info * info = v ; <S2SV_StartBug> char * const * cur ; <S2SV_EndBug> const char * p , * errstr , * groups = NULL ; <S2SV_StartBug> const char * remhost = NULL ; <S2SV_EndBug> int flags = 0 ; debug_decl ( sudoers_policy_deserialize_info , SUDOERS_DEBUG_PLUGIN ) ; # define MATCHES ( s , v ) ( strncmp ( ( s ) , ( v ) , sizeof ( v ) - 1 ) == 0 ) <S2SV_StartBug> # define INVALID ( v ) do { sudo_warn ( U_ ( \"invalid<S2SV_blank>%.*s<S2SV_blank>set<S2SV_blank>by<S2SV_blank>sudo<S2SV_blank>front-end\" ) , ( int ) ( sizeof ( v ) - 2 ) , ( v ) ) ; } while ( 0 ) <S2SV_EndBug> <S2SV_StartBug> # define CHECK ( s , v ) do { if ( ( s ) [ sizeof ( v ) - 1 ] == '\\\\0' ) { INVALID ( v ) ; goto bad ; } } while ( 0 ) <S2SV_EndBug> if ( sudo_gettime_real ( & sudo_user . submit_time ) == - 1 ) { sudo_warn ( \"%s\" , U_ ( \"unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>time<S2SV_blank>of<S2SV_blank>day\" ) ) ; goto bad ; } if ( info -> plugin_args != NULL ) { for ( cur = info -> plugin_args ; * cur != NULL ; cur ++ ) { if ( MATCHES ( * cur , \"error_recovery=\" ) ) { int val = sudo_strtobool ( * cur + sizeof ( \"error_recovery=\" ) - 1 ) ; if ( val == - 1 ) { INVALID ( \"error_recovery=\" ) ; } else { sudoers_recovery = val ; } continue ; } if ( MATCHES ( * cur , \"sudoers_file=\" ) ) { CHECK ( * cur , \"sudoers_file=\" ) ; sudoers_file = * cur + sizeof ( \"sudoers_file=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"sudoers_uid=\" ) ) { p = * cur + sizeof ( \"sudoers_uid=\" ) - 1 ; sudoers_uid = ( uid_t ) sudo_strtoid ( p , & errstr ) ; if ( errstr != NULL ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"sudoers_gid=\" ) ) { p = * cur + sizeof ( \"sudoers_gid=\" ) - 1 ; sudoers_gid = ( gid_t ) sudo_strtoid ( p , & errstr ) ; if ( errstr != NULL ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"sudoers_mode=\" ) ) { p = * cur + sizeof ( \"sudoers_mode=\" ) - 1 ; sudoers_mode = sudo_strtomode ( p , & errstr ) ; if ( errstr != NULL ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"ldap_conf=\" ) ) { CHECK ( * cur , \"ldap_conf=\" ) ; path_ldap_conf = * cur + sizeof ( \"ldap_conf=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"ldap_secret=\" ) ) { CHECK ( * cur , \"ldap_secret=\" ) ; path_ldap_secret = * cur + sizeof ( \"ldap_secret=\" ) - 1 ; continue ; } } } user_closefrom = - 1 ; for ( cur = info -> settings ; * cur != NULL ; cur ++ ) { if ( MATCHES ( * cur , \"closefrom=\" ) ) { errno = 0 ; p = * cur + sizeof ( \"closefrom=\" ) - 1 ; user_closefrom = sudo_strtonum ( p , 3 , INT_MAX , & errstr ) ; if ( user_closefrom == 0 ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"cmnd_chroot=\" ) ) { CHECK ( * cur , \"cmnd_chroot=\" ) ; user_runchroot = * cur + sizeof ( \"cmnd_chroot=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"cmnd_cwd=\" ) ) { CHECK ( * cur , \"cmnd_cwd=\" ) ; user_runcwd = * cur + sizeof ( \"cmnd_cwd=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"runas_user=\" ) ) { CHECK ( * cur , \"runas_user=\" ) ; sudo_user . runas_user = * cur + sizeof ( \"runas_user=\" ) - 1 ; SET ( sudo_user . flags , RUNAS_USER_SPECIFIED ) ; continue ; } if ( MATCHES ( * cur , \"runas_group=\" ) ) { CHECK ( * cur , \"runas_group=\" ) ; sudo_user . runas_group = * cur + sizeof ( \"runas_group=\" ) - 1 ; SET ( sudo_user . flags , RUNAS_GROUP_SPECIFIED ) ; continue ; } if ( MATCHES ( * cur , \"prompt=\" ) ) { user_prompt = * cur + sizeof ( \"prompt=\" ) - 1 ; def_passprompt_override = true ; continue ; } if ( MATCHES ( * cur , \"set_home=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"set_home\" ) - 1 , & flags , MODE_RESET_HOME ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"preserve_environment=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"preserve_environment\" ) - 1 , & flags , MODE_PRESERVE_ENV ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"run_shell=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"run_shell\" ) - 1 , & flags , MODE_SHELL ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"login_shell=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"login_shell\" ) - 1 , & flags , MODE_LOGIN_SHELL ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"implied_shell=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"implied_shell\" ) - 1 , & flags , MODE_IMPLIED_SHELL ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"preserve_groups=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"preserve_groups\" ) - 1 , & flags , MODE_PRESERVE_GROUPS ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"ignore_ticket=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"ignore_ticket\" ) - 1 , & flags , MODE_IGNORE_TICKET ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"noninteractive=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"noninteractive\" ) - 1 , & flags , MODE_NONINTERACTIVE ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"sudoedit=\" ) ) { if ( parse_bool ( * cur , sizeof ( \"sudoedit\" ) - 1 , & flags , MODE_EDIT ) == - 1 ) goto bad ; continue ; } if ( MATCHES ( * cur , \"login_class=\" ) ) { CHECK ( * cur , \"login_class=\" ) ; login_class = * cur + sizeof ( \"login_class=\" ) - 1 ; def_use_loginclass = true ; continue ; } # ifdef HAVE_PRIV_SET if ( MATCHES ( * cur , \"runas_privs=\" ) ) { CHECK ( * cur , \"runas_privs=\" ) ; def_privs = * cur + sizeof ( \"runas_privs=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"runas_limitprivs=\" ) ) { CHECK ( * cur , \"runas_limitprivs=\" ) ; def_limitprivs = * cur + sizeof ( \"runas_limitprivs=\" ) - 1 ; continue ; } # endif # ifdef HAVE_SELINUX if ( MATCHES ( * cur , \"selinux_role=\" ) ) { CHECK ( * cur , \"selinux_role=\" ) ; user_role = * cur + sizeof ( \"selinux_role=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"selinux_type=\" ) ) { CHECK ( * cur , \"selinux_type=\" ) ; user_type = * cur + sizeof ( \"selinux_type=\" ) - 1 ; continue ; } # endif # ifdef HAVE_BSD_AUTH_H if ( MATCHES ( * cur , \"bsdauth_type=\" ) ) { CHECK ( * cur , \"login_style=\" ) ; login_style = * cur + sizeof ( \"bsdauth_type=\" ) - 1 ; continue ; } # endif if ( MATCHES ( * cur , \"network_addrs=\" ) ) { interfaces_string = * cur + sizeof ( \"network_addrs=\" ) - 1 ; if ( ! set_interfaces ( interfaces_string ) ) { sudo_warn ( \"%s\" , U_ ( \"unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>network<S2SV_blank>address<S2SV_blank>list\" ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"max_groups=\" ) ) { errno = 0 ; p = * cur + sizeof ( \"max_groups=\" ) - 1 ; sudo_user . max_groups = sudo_strtonum ( p , 1 , INT_MAX , & errstr ) ; if ( sudo_user . max_groups == 0 ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"remote_host=\" ) ) { CHECK ( * cur , \"remote_host=\" ) ; remhost = * cur + sizeof ( \"remote_host=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"timeout=\" ) ) { p = * cur + sizeof ( \"timeout=\" ) - 1 ; user_timeout = parse_timeout ( p ) ; if ( user_timeout == - 1 ) { if ( errno == ERANGE ) sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , p , U_ ( \"timeout<S2SV_blank>value<S2SV_blank>too<S2SV_blank>large\" ) ) ; else sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , p , U_ ( \"invalid<S2SV_blank>timeout<S2SV_blank>value\" ) ) ; goto bad ; } continue ; } # ifdef ENABLE_SUDO_PLUGIN_API if ( MATCHES ( * cur , \"plugin_dir=\" ) ) { CHECK ( * cur , \"plugin_dir=\" ) ; path_plugin_dir = * cur + sizeof ( \"plugin_dir=\" ) - 1 ; continue ; } # endif } <S2SV_StartBug> user_gid = ( gid_t ) - 1 ; <S2SV_EndBug> user_sid = ( pid_t ) - 1 ; user_uid = ( gid_t ) - 1 ; user_umask = ( mode_t ) - 1 ; for ( cur = info -> user_info ; * cur != NULL ; cur ++ ) { if ( MATCHES ( * cur , \"user=\" ) ) { CHECK ( * cur , \"user=\" ) ; if ( ( user_name = strdup ( * cur + sizeof ( \"user=\" ) - 1 ) ) == NULL ) goto oom ; continue ; } if ( MATCHES ( * cur , \"uid=\" ) ) { p = * cur + sizeof ( \"uid=\" ) - 1 ; user_uid = ( uid_t ) sudo_strtoid ( p , & errstr ) ; if ( errstr != NULL ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"gid=\" ) ) { p = * cur + sizeof ( \"gid=\" ) - 1 ; user_gid = ( gid_t ) sudo_strtoid ( p , & errstr ) ; if ( errstr != NULL ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"groups=\" ) ) { CHECK ( * cur , \"groups=\" ) ; groups = * cur + sizeof ( \"groups=\" ) - 1 ; continue ; } if ( MATCHES ( * cur , \"cwd=\" ) ) { CHECK ( * cur , \"cwd=\" ) ; if ( ( user_cwd = strdup ( * cur + sizeof ( \"cwd=\" ) - 1 ) ) == NULL ) goto oom ; continue ; } if ( MATCHES ( * cur , \"tty=\" ) ) { CHECK ( * cur , \"tty=\" ) ; if ( ( user_ttypath = strdup ( * cur + sizeof ( \"tty=\" ) - 1 ) ) == NULL ) goto oom ; user_tty = user_ttypath ; if ( strncmp ( user_tty , _PATH_DEV , sizeof ( _PATH_DEV ) - 1 ) == 0 ) user_tty += sizeof ( _PATH_DEV ) - 1 ; continue ; } if ( MATCHES ( * cur , \"host=\" ) ) { CHECK ( * cur , \"host=\" ) ; if ( ( user_host = strdup ( * cur + sizeof ( \"host=\" ) - 1 ) ) == NULL ) goto oom ; if ( ( p = strchr ( user_host , '.' ) ) != NULL ) { user_shost = strndup ( user_host , ( size_t ) ( p - user_host ) ) ; if ( user_shost == NULL ) goto oom ; } else { user_shost = user_host ; } continue ; } if ( MATCHES ( * cur , \"lines=\" ) ) { errno = 0 ; p = * cur + sizeof ( \"lines=\" ) - 1 ; sudo_user . lines = sudo_strtonum ( p , 1 , INT_MAX , & errstr ) ; if ( sudo_user . lines == 0 ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"cols=\" ) ) { errno = 0 ; p = * cur + sizeof ( \"cols=\" ) - 1 ; sudo_user . cols = sudo_strtonum ( p , 1 , INT_MAX , & errstr ) ; if ( sudo_user . cols == 0 ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"sid=\" ) ) { p = * cur + sizeof ( \"sid=\" ) - 1 ; user_sid = ( pid_t ) sudo_strtoid ( p , & errstr ) ; if ( errstr != NULL ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } if ( MATCHES ( * cur , \"umask=\" ) ) { p = * cur + sizeof ( \"umask=\" ) - 1 ; sudo_user . umask = sudo_strtomode ( p , & errstr ) ; if ( errstr != NULL ) { sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , * cur , U_ ( errstr ) ) ; goto bad ; } continue ; } } if ( user_name == NULL ) { sudo_warnx ( \"%s\" , U_ ( \"user<S2SV_blank>name<S2SV_blank>not<S2SV_blank>set<S2SV_blank>by<S2SV_blank>sudo<S2SV_blank>front-end\" ) ) ; goto bad ; } if ( user_uid == ( uid_t ) - 1 ) { sudo_warnx ( \"%s\" , U_ ( \"user-ID<S2SV_blank>not<S2SV_blank>set<S2SV_blank>by<S2SV_blank>sudo<S2SV_blank>front-end\" ) ) ; goto bad ; } if ( user_gid == ( gid_t ) - 1 ) { sudo_warnx ( \"%s\" , U_ ( \"group-ID<S2SV_blank>not<S2SV_blank>set<S2SV_blank>by<S2SV_blank>sudo<S2SV_blank>front-end\" ) ) ; goto bad ; } if ( user_host == NULL ) { sudo_warnx ( \"%s\" , U_ ( \"host<S2SV_blank>name<S2SV_blank>not<S2SV_blank>set<S2SV_blank>by<S2SV_blank>sudo<S2SV_blank>front-end\" ) ) ; goto bad ; } if ( ( user_runhost = strdup ( remhost ? remhost : user_host ) ) == NULL ) goto oom ; if ( ( p = strchr ( user_runhost , '.' ) ) != NULL ) { user_srunhost = strndup ( user_runhost , ( size_t ) ( p - user_runhost ) ) ; if ( user_srunhost == NULL ) goto oom ; } else { user_srunhost = user_runhost ; } if ( user_cwd == NULL ) { if ( ( user_cwd = strdup ( \"unknown\" ) ) == NULL ) goto oom ; } if ( user_runcwd == NULL ) { if ( ( user_runcwd = strdup ( user_cwd ) ) == NULL ) goto oom ; } if ( user_tty == NULL ) { if ( ( user_tty = strdup ( \"unknown\" ) ) == NULL ) goto oom ; } if ( groups != NULL ) { user_ngids = sudo_parse_gids ( groups , & user_gid , & user_gids ) ; if ( user_ngids == - 1 ) goto bad ; } if ( user_umask == ( mode_t ) - 1 ) { user_umask = umask ( 0 ) ; umask ( user_umask ) ; } if ( ISSET ( flags , MODE_LOGIN_SHELL ) ) def_env_reset = true ; cmnd_fd = - 1 ; for ( cur = info -> settings ; * cur != NULL ; cur ++ ) sudo_debug_printf ( SUDO_DEBUG_INFO , \"settings:<S2SV_blank>%s\" , * cur ) ; for ( cur = info -> user_info ; * cur != NULL ; cur ++ ) sudo_debug_printf ( SUDO_DEBUG_INFO , \"user_info:<S2SV_blank>%s\" , * cur ) ; # undef MATCHES # undef INVALID # undef CHECK debug_return_int ( flags ) ; oom : sudo_warnx ( U_ ( \"%s:<S2SV_blank>%s\" ) , __func__ , U_ ( \"unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\" ) ) ; bad : debug_return_int ( MODE_ERROR ) ; }", "target": "<S2SV_ModStart> v ) { const int edit_mask = MODE_EDIT | MODE_IGNORE_TICKET | MODE_NONINTERACTIVE ; <S2SV_ModStart> = v ; <S2SV_ModEnd> const char * <S2SV_ModStart> remhost = NULL ; char * const * cur <S2SV_ModStart> ) ) ; \\\\\\n} <S2SV_ModEnd> while ( 0 <S2SV_ModStart> bad ; } \\\\\\n} <S2SV_ModEnd> while ( 0 <S2SV_ModStart> # endif } if ( ISSET ( flags , MODE_EDIT ) && ( flags & edit_mask ) != flags ) { sudo_warnx ( U_ ( \"invalid<S2SV_blank>mode<S2SV_blank>flags<S2SV_blank>from<S2SV_blank>sudo<S2SV_blank>front<S2SV_blank>end:<S2SV_blank>0x%x\" ) , flags ) ; goto bad ; }"}
{"source": "CWE-522 int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , \"*<S2SV_blank>OK\" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , \"*<S2SV_blank>OK<S2SV_blank>[CAPABILITY\" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( \"Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?\" ) ) ) == MUTT_ABORT ) { <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , \"STARTTLS\" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( \"Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection\" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } else { if ( imap_exec ( adata , \"CAPABILITY\" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( \"Encrypted<S2SV_blank>connection<S2SV_blank>unavailable\" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } # endif } else if ( mutt_istr_startswith ( adata -> buf , \"*<S2SV_blank>PREAUTH\" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( \"Encrypted<S2SV_blank>connection<S2SV_blank>unavailable\" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( \"imap_open_connection()\" , adata -> buf ) ; goto bail ; } return 0 ; <S2SV_StartBug> # ifdef USE_SSL <S2SV_EndBug> err_close_conn : imap_close_connection ( adata ) ; <S2SV_StartBug> # endif <S2SV_EndBug> bail : FREE ( & adata -> capstr ) ; return - 1 ; }", "target": "<S2SV_ModStart> ) { goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> return 0 ; bail <S2SV_ModEnd> : imap_close_connection ( <S2SV_ModStart> adata ) ; <S2SV_ModEnd> FREE ( &"}
{"source": "CWE-20 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; opj_tcd_marker_info_t * marker_info = NULL ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; if ( total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\\\n\" ) ; return OPJ_FALSE ; } opj_write_bytes ( p_data , J2K_MS_SOD , 2 ) ; l_remaining_data = total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; # ifdef deadcode if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } # endif } * p_data_written = 0 ; if ( p_j2k -> m_specific_param . m_encoder . m_PLT ) { marker_info = opj_tcd_marker_info_create ( p_j2k -> m_specific_param . m_encoder . m_PLT ) ; if ( marker_info == NULL ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot<S2SV_blank>encode<S2SV_blank>tile:<S2SV_blank>opj_tcd_marker_info_create()<S2SV_blank>failed\\\\n\" ) ; return OPJ_FALSE ; } } <S2SV_StartBug> assert ( l_remaining_data > <S2SV_EndBug> <S2SV_StartBug> p_j2k -> m_specific_param . m_encoder . m_reserved_bytes_for_PLT ) ; <S2SV_EndBug> l_remaining_data -= p_j2k -> m_specific_param . m_encoder . m_reserved_bytes_for_PLT ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data + 2 , p_data_written , l_remaining_data , l_cstr_info , marker_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot<S2SV_blank>encode<S2SV_blank>tile\\\\n\" ) ; opj_tcd_marker_info_destroy ( marker_info ) ; return OPJ_FALSE ; } * p_data_written += 2 ; if ( p_j2k -> m_specific_param . m_encoder . m_PLT ) { OPJ_UINT32 l_data_written_PLT = 0 ; OPJ_BYTE * p_PLT_buffer = ( OPJ_BYTE * ) opj_malloc ( p_j2k -> m_specific_param . m_encoder . m_reserved_bytes_for_PLT ) ; if ( ! p_PLT_buffer ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot<S2SV_blank>allocate<S2SV_blank>memory\\\\n\" ) ; opj_tcd_marker_info_destroy ( marker_info ) ; return OPJ_FALSE ; } if ( ! opj_j2k_write_plt_in_memory ( p_j2k , marker_info , p_PLT_buffer , & l_data_written_PLT , p_manager ) ) { opj_tcd_marker_info_destroy ( marker_info ) ; opj_free ( p_PLT_buffer ) ; return OPJ_FALSE ; } assert ( l_data_written_PLT <= p_j2k -> m_specific_param . m_encoder . m_reserved_bytes_for_PLT ) ; memmove ( p_data + l_data_written_PLT , p_data , * p_data_written ) ; memcpy ( p_data , p_PLT_buffer , l_data_written_PLT ) ; opj_free ( p_PLT_buffer ) ; * p_data_written += l_data_written_PLT ; } opj_tcd_marker_info_destroy ( marker_info ) ; return OPJ_TRUE ; }", "target": "<S2SV_ModStart> ; } } if ( l_remaining_data < <S2SV_ModEnd> p_j2k -> m_specific_param <S2SV_ModStart> . m_reserved_bytes_for_PLT ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\\\n\" ) ; opj_tcd_marker_info_destroy ( marker_info ) ; return OPJ_FALSE ; } <S2SV_ModEnd> l_remaining_data -= p_j2k"}
{"source": "CWE-787 p11_rpc_buffer_get_attribute ( p11_buffer * buffer , size_t * offset , CK_ATTRIBUTE * attr ) { <S2SV_StartBug> uint32_t type , length ; <S2SV_EndBug> unsigned char validity ; p11_rpc_attribute_serializer * serializer ; p11_rpc_value_type value_type ; if ( ! p11_rpc_buffer_get_uint32 ( buffer , offset , & type ) ) return false ; if ( ! p11_rpc_buffer_get_byte ( buffer , offset , & validity ) ) return false ; if ( ! validity ) { attr -> ulValueLen = ( ( CK_ULONG ) - 1 ) ; attr -> type = type ; return true ; } if ( ! p11_rpc_buffer_get_uint32 ( buffer , offset , & length ) ) return false ; value_type = map_attribute_to_value_type ( type ) ; assert ( value_type < ELEMS ( p11_rpc_attribute_serializers ) ) ; serializer = & p11_rpc_attribute_serializers [ value_type ] ; assert ( serializer != NULL ) ; if ( ! serializer -> decode ( buffer , offset , attr -> pValue , & attr -> ulValueLen ) ) return false ; if ( ! attr -> pValue ) <S2SV_StartBug> attr -> ulValueLen = length ; <S2SV_EndBug> attr -> type = type ; return true ; }", "target": "<S2SV_ModStart> type , length , decode_length <S2SV_ModStart> -> pValue ) { decode_length = attr -> ulValueLen ; attr -> ulValueLen = length ; if ( decode_length > length ) { return false ; } } <S2SV_ModEnd> attr -> type"}
{"source": "CWE-122 static OPJ_BOOL opj_tcd_code_block_enc_allocate_data ( opj_tcd_cblk_enc_t * p_code_block ) { OPJ_UINT32 l_data_size ; <S2SV_StartBug> l_data_size = 26 + ( OPJ_UINT32 ) ( ( p_code_block -> x1 - p_code_block -> x0 ) * <S2SV_EndBug> ( p_code_block -> y1 - p_code_block -> y0 ) * ( OPJ_INT32 ) sizeof ( OPJ_UINT32 ) ) ; if ( l_data_size > p_code_block -> data_size ) { if ( p_code_block -> data ) { opj_free ( p_code_block -> data - 1 ) ; } p_code_block -> data = ( OPJ_BYTE * ) opj_malloc ( l_data_size + 1 ) ; if ( ! p_code_block -> data ) { p_code_block -> data_size = 0U ; return OPJ_FALSE ; } p_code_block -> data_size = l_data_size ; p_code_block -> data [ 0 ] = 0 ; p_code_block -> data += 1 ; } return OPJ_TRUE ; }", "target": "<S2SV_ModStart> ; l_data_size = 28 <S2SV_ModEnd> + ( OPJ_UINT32"}
{"source": "CWE-284 static int shm_create ( XShmSegmentInfo * shm , XImage * * ximg_ptr , int w , int h , char * name ) { XImage * xim ; static int reported_flip = 0 ; int db = 0 ; shm -> shmid = - 1 ; shm -> shmaddr = ( char * ) - 1 ; * ximg_ptr = NULL ; if ( nofb ) { return 1 ; } X_LOCK ; if ( ! using_shm || xform24to32 || raw_fb ) { xim = XCreateImage_wr ( dpy , default_visual , depth , ZPixmap , 0 , NULL , w , h , raw_fb ? 32 : BitmapPad ( dpy ) , 0 ) ; X_UNLOCK ; if ( xim == NULL ) { rfbErr ( \"XCreateImage(%s)<S2SV_blank>failed.\\\\n\" , name ) ; if ( quiet ) { fprintf ( stderr , \"XCreateImage(%s)<S2SV_blank>failed.\\\\n\" , name ) ; } return 0 ; } if ( db ) fprintf ( stderr , \"shm_create<S2SV_blank>simple<S2SV_blank>%d<S2SV_blank>%d\\\\t%p<S2SV_blank>%s\\\\n\" , w , h , ( void * ) xim , name ) ; xim -> data = ( char * ) malloc ( xim -> bytes_per_line * xim -> height ) ; if ( xim -> data == NULL ) { rfbErr ( \"XCreateImage(%s)<S2SV_blank>data<S2SV_blank>malloc<S2SV_blank>failed.\\\\n\" , name ) ; if ( quiet ) { fprintf ( stderr , \"XCreateImage(%s)<S2SV_blank>data<S2SV_blank>malloc\" \"<S2SV_blank>failed.\\\\n\" , name ) ; } return 0 ; } if ( flip_byte_order ) { char * order = flip_ximage_byte_order ( xim ) ; if ( ! reported_flip && ! quiet ) { rfbLog ( \"Changing<S2SV_blank>XImage<S2SV_blank>byte<S2SV_blank>order\" \"<S2SV_blank>to<S2SV_blank>%s\\\\n\" , order ) ; reported_flip = 1 ; } } * ximg_ptr = xim ; return 1 ; } if ( ! dpy ) { X_UNLOCK ; return 0 ; } xim = XShmCreateImage_wr ( dpy , default_visual , depth , ZPixmap , NULL , shm , w , h ) ; if ( xim == NULL ) { rfbErr ( \"XShmCreateImage(%s)<S2SV_blank>failed.\\\\n\" , name ) ; if ( quiet ) { fprintf ( stderr , \"XShmCreateImage(%s)<S2SV_blank>failed.\\\\n\" , name ) ; } X_UNLOCK ; return 0 ; } * ximg_ptr = xim ; # if HAVE_XSHM shm -> shmid = shmget ( IPC_PRIVATE , <S2SV_StartBug> xim -> bytes_per_line * xim -> height , IPC_CREAT | 0777 ) ; <S2SV_EndBug> if ( shm -> shmid == - 1 ) { rfbErr ( \"shmget(%s)<S2SV_blank>failed.\\\\n\" , name ) ; rfbLogPerror ( \"shmget\" ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; X_UNLOCK ; return 0 ; } shm -> shmaddr = xim -> data = ( char * ) shmat ( shm -> shmid , 0 , 0 ) ; if ( shm -> shmaddr == ( char * ) - 1 ) { rfbErr ( \"shmat(%s)<S2SV_blank>failed.\\\\n\" , name ) ; rfbLogPerror ( \"shmat\" ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; shmctl ( shm -> shmid , IPC_RMID , 0 ) ; shm -> shmid = - 1 ; X_UNLOCK ; return 0 ; } shm -> readOnly = False ; if ( ! XShmAttach_wr ( dpy , shm ) ) { rfbErr ( \"XShmAttach(%s)<S2SV_blank>failed.\\\\n\" , name ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; shmdt ( shm -> shmaddr ) ; shm -> shmaddr = ( char * ) - 1 ; shmctl ( shm -> shmid , IPC_RMID , 0 ) ; shm -> shmid = - 1 ; X_UNLOCK ; return 0 ; } # endif X_UNLOCK ; return 1 ; }", "target": "<S2SV_ModStart> , IPC_CREAT | 0600 <S2SV_ModEnd> ) ; if"}
{"source": "CWE-190 void stralgoLCS ( client * c ) { uint32_t i , j ; long long minmatchlen = 0 ; sds a = NULL , b = NULL ; int getlen = 0 , getidx = 0 , withmatchlen = 0 ; robj * obja = NULL , * objb = NULL ; for ( j = 2 ; j < ( uint32_t ) c -> argc ; j ++ ) { char * opt = c -> argv [ j ] -> ptr ; int moreargs = ( c -> argc - 1 ) - j ; if ( ! strcasecmp ( opt , \"IDX\" ) ) { getidx = 1 ; } else if ( ! strcasecmp ( opt , \"LEN\" ) ) { getlen = 1 ; } else if ( ! strcasecmp ( opt , \"WITHMATCHLEN\" ) ) { withmatchlen = 1 ; } else if ( ! strcasecmp ( opt , \"MINMATCHLEN\" ) && moreargs ) { if ( getLongLongFromObjectOrReply ( c , c -> argv [ j + 1 ] , & minmatchlen , NULL ) != C_OK ) goto cleanup ; if ( minmatchlen < 0 ) minmatchlen = 0 ; j ++ ; } else if ( ! strcasecmp ( opt , \"STRINGS\" ) && moreargs > 1 ) { if ( a != NULL ) { addReplyError ( c , \"Either<S2SV_blank>use<S2SV_blank>STRINGS<S2SV_blank>or<S2SV_blank>KEYS\" ) ; goto cleanup ; } a = c -> argv [ j + 1 ] -> ptr ; b = c -> argv [ j + 2 ] -> ptr ; j += 2 ; } else if ( ! strcasecmp ( opt , \"KEYS\" ) && moreargs > 1 ) { if ( a != NULL ) { addReplyError ( c , \"Either<S2SV_blank>use<S2SV_blank>STRINGS<S2SV_blank>or<S2SV_blank>KEYS\" ) ; goto cleanup ; } obja = lookupKeyRead ( c -> db , c -> argv [ j + 1 ] ) ; objb = lookupKeyRead ( c -> db , c -> argv [ j + 2 ] ) ; if ( ( obja && obja -> type != OBJ_STRING ) || ( objb && objb -> type != OBJ_STRING ) ) { addReplyError ( c , \"The<S2SV_blank>specified<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>contain<S2SV_blank>string<S2SV_blank>values\" ) ; obja = NULL ; objb = NULL ; goto cleanup ; } obja = obja ? getDecodedObject ( obja ) : createStringObject ( \"\" , 0 ) ; objb = objb ? getDecodedObject ( objb ) : createStringObject ( \"\" , 0 ) ; a = obja -> ptr ; b = objb -> ptr ; j += 2 ; } else { addReply ( c , shared . syntaxerr ) ; goto cleanup ; } } if ( a == NULL ) { addReplyError ( c , \"Please<S2SV_blank>specify<S2SV_blank>two<S2SV_blank>strings:<S2SV_blank>\" \"STRINGS<S2SV_blank>or<S2SV_blank>KEYS<S2SV_blank>options<S2SV_blank>are<S2SV_blank>mandatory\" ) ; goto cleanup ; } else if ( getlen && getidx ) { addReplyError ( c , \"If<S2SV_blank>you<S2SV_blank>want<S2SV_blank>both<S2SV_blank>the<S2SV_blank>length<S2SV_blank>and<S2SV_blank>indexes,<S2SV_blank>please<S2SV_blank>\" \"just<S2SV_blank>use<S2SV_blank>IDX.\" ) ; goto cleanup ; } uint32_t alen = sdslen ( a ) ; uint32_t blen = sdslen ( b ) ; <S2SV_StartBug> uint32_t * lcs = zmalloc ( ( alen + 1 ) * ( blen + 1 ) * sizeof ( uint32_t ) ) ; <S2SV_EndBug> # define LCS ( A , B ) lcs [ ( B ) + ( ( A ) * ( blen + 1 ) ) ] for ( uint32_t i = 0 ; i <= alen ; i ++ ) { for ( uint32_t j = 0 ; j <= blen ; j ++ ) { if ( i == 0 || j == 0 ) { LCS ( i , j ) = 0 ; } else if ( a [ i - 1 ] == b [ j - 1 ] ) { LCS ( i , j ) = LCS ( i - 1 , j - 1 ) + 1 ; } else { uint32_t lcs1 = LCS ( i - 1 , j ) ; uint32_t lcs2 = LCS ( i , j - 1 ) ; LCS ( i , j ) = lcs1 > lcs2 ? lcs1 : lcs2 ; } } } uint32_t idx = LCS ( alen , blen ) ; sds result = NULL ; void * arraylenptr = NULL ; uint32_t arange_start = alen , arange_end = 0 , brange_start = 0 , brange_end = 0 ; int computelcs = getidx || ! getlen ; if ( computelcs ) result = sdsnewlen ( SDS_NOINIT , idx ) ; uint32_t arraylen = 0 ; if ( getidx ) { addReplyMapLen ( c , 2 ) ; addReplyBulkCString ( c , \"matches\" ) ; arraylenptr = addReplyDeferredLen ( c ) ; } i = alen , j = blen ; while ( computelcs && i > 0 && j > 0 ) { int emit_range = 0 ; if ( a [ i - 1 ] == b [ j - 1 ] ) { result [ idx - 1 ] = a [ i - 1 ] ; if ( arange_start == alen ) { arange_start = i - 1 ; arange_end = i - 1 ; brange_start = j - 1 ; brange_end = j - 1 ; } else { if ( arange_start == i && brange_start == j ) { arange_start -- ; brange_start -- ; } else { emit_range = 1 ; } } if ( arange_start == 0 || brange_start == 0 ) emit_range = 1 ; idx -- ; i -- ; j -- ; } else { uint32_t lcs1 = LCS ( i - 1 , j ) ; uint32_t lcs2 = LCS ( i , j - 1 ) ; if ( lcs1 > lcs2 ) i -- ; else j -- ; if ( arange_start != alen ) emit_range = 1 ; } uint32_t match_len = arange_end - arange_start + 1 ; if ( emit_range ) { if ( minmatchlen == 0 || match_len >= minmatchlen ) { if ( arraylenptr ) { addReplyArrayLen ( c , 2 + withmatchlen ) ; addReplyArrayLen ( c , 2 ) ; addReplyLongLong ( c , arange_start ) ; addReplyLongLong ( c , arange_end ) ; addReplyArrayLen ( c , 2 ) ; addReplyLongLong ( c , brange_start ) ; addReplyLongLong ( c , brange_end ) ; if ( withmatchlen ) addReplyLongLong ( c , match_len ) ; arraylen ++ ; } } arange_start = alen ; } } if ( arraylenptr ) { addReplyBulkCString ( c , \"len\" ) ; addReplyLongLong ( c , LCS ( alen , blen ) ) ; setDeferredArrayLen ( c , arraylenptr , arraylen ) ; } else if ( getlen ) { addReplyLongLong ( c , LCS ( alen , blen ) ) ; } else { addReplyBulkSds ( c , result ) ; result = NULL ; } sdsfree ( result ) ; zfree ( lcs ) ; cleanup : if ( obja ) decrRefCount ( obja ) ; if ( objb ) decrRefCount ( objb ) ; return ; }", "target": "<S2SV_ModStart> = zmalloc ( ( size_t )"}
{"source": "CWE-119 rleUncompress ( int inLength , int maxLength , const signed char in [ ] , char out [ ] ) { char * outStart = out ; while ( inLength > 0 ) { if ( * in < 0 ) { int count = - ( ( int ) * in ++ ) ; inLength -= count + 1 ; if ( 0 > ( maxLength -= count ) ) return 0 ; if ( inLength < 0 ) return 0 ; memcpy ( out , in , count ) ; out += count ; in += count ; } else { int count = * in ++ ; inLength -= 2 ; if ( 0 > ( maxLength -= count + 1 ) ) return 0 ; <S2SV_StartBug> memset ( out , * ( char * ) in , count + 1 ) ; <S2SV_EndBug> out += count + 1 ; in ++ ; } } return out - outStart ; }", "target": "<S2SV_ModStart> return 0 ; if ( inLength < 0 ) return 0 ;"}
{"source": "CWE-416 static int xdp_umem_reg ( struct xdp_umem * umem , struct xdp_umem_reg * mr ) { bool unaligned_chunks = mr -> flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG ; u32 chunk_size = mr -> chunk_size , headroom = mr -> headroom ; unsigned int chunks , chunks_per_page ; u64 addr = mr -> addr , size = mr -> len ; <S2SV_StartBug> int size_chk , err ; <S2SV_EndBug> if ( chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE ) { return - EINVAL ; } if ( mr -> flags & ~ ( XDP_UMEM_UNALIGNED_CHUNK_FLAG | XDP_UMEM_USES_NEED_WAKEUP ) ) return - EINVAL ; if ( ! unaligned_chunks && ! is_power_of_2 ( chunk_size ) ) return - EINVAL ; if ( ! PAGE_ALIGNED ( addr ) ) { return - EINVAL ; } if ( ( addr + size ) < addr ) return - EINVAL ; chunks = ( unsigned int ) div_u64 ( size , chunk_size ) ; if ( chunks == 0 ) return - EINVAL ; if ( ! unaligned_chunks ) { chunks_per_page = PAGE_SIZE / chunk_size ; if ( chunks < chunks_per_page || chunks % chunks_per_page ) return - EINVAL ; } <S2SV_StartBug> size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ; <S2SV_EndBug> if ( size_chk < 0 ) return - EINVAL ; umem -> address = ( unsigned long ) addr ; umem -> chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK : ~ ( ( u64 ) chunk_size - 1 ) ; umem -> size = size ; umem -> headroom = headroom ; umem -> chunk_size_nohr = chunk_size - headroom ; umem -> npgs = size / PAGE_SIZE ; umem -> pgs = NULL ; umem -> user = NULL ; umem -> flags = mr -> flags ; INIT_LIST_HEAD ( & umem -> xsk_list ) ; spin_lock_init ( & umem -> xsk_list_lock ) ; refcount_set ( & umem -> users , 1 ) ; err = xdp_umem_account_pages ( umem ) ; if ( err ) return err ; err = xdp_umem_pin_pages ( umem ) ; if ( err ) goto out_account ; umem -> pages = kvcalloc ( umem -> npgs , sizeof ( * umem -> pages ) , GFP_KERNEL_ACCOUNT ) ; if ( ! umem -> pages ) { err = - ENOMEM ; goto out_pin ; } err = xdp_umem_map_pages ( umem ) ; if ( ! err ) return 0 ; kvfree ( umem -> pages ) ; out_pin : xdp_umem_unpin_pages ( umem ) ; out_account : xdp_umem_unaccount_pages ( umem ) ; return err ; }", "target": "<S2SV_ModStart> len ; int <S2SV_ModEnd> err ; if <S2SV_ModStart> EINVAL ; } if ( headroom >= chunk_size - XDP_PACKET_HEADROOM <S2SV_ModEnd> ) return -"}
{"source": "CWE-362 void __split_huge_pmd ( struct vm_area_struct * vma , pmd_t * pmd , unsigned long address , bool freeze , struct page * page ) { spinlock_t * ptl ; struct mmu_notifier_range range ; <S2SV_StartBug> <S2SV_EndBug> mmu_notifier_range_init ( & range , MMU_NOTIFY_CLEAR , 0 , vma , vma -> vm_mm , address & HPAGE_PMD_MASK , ( address & HPAGE_PMD_MASK ) + HPAGE_PMD_SIZE ) ; mmu_notifier_invalidate_range_start ( & range ) ; ptl = pmd_lock ( vma -> vm_mm , pmd ) ; VM_BUG_ON ( freeze && ! page ) ; <S2SV_StartBug> if ( page && page != pmd_page ( * pmd ) ) <S2SV_EndBug> goto out ; <S2SV_StartBug> <S2SV_EndBug> if ( pmd_trans_huge ( * pmd ) ) { <S2SV_StartBug> page = pmd_page ( * pmd ) ; <S2SV_EndBug> if ( PageMlocked ( page ) ) clear_page_mlock ( page ) ; } else if ( ! ( pmd_devmap ( * pmd ) || is_pmd_migration_entry ( * pmd ) ) ) goto out ; __split_huge_pmd_locked ( vma , pmd , range . start , freeze ) ; out : spin_unlock ( ptl ) ; <S2SV_StartBug> mmu_notifier_invalidate_range_only_end ( & range ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> mmu_notifier_range range ; bool was_locked = false ; pmd_t _pmd ; <S2SV_ModStart> if ( page ) { VM_WARN_ON_ONCE ( ! PageLocked ( page ) ) ; was_locked = true ; if ( <S2SV_ModEnd> page != pmd_page <S2SV_ModStart> goto out ; } repeat : <S2SV_ModStart> ) ) { if ( ! page ) { <S2SV_ModStart> pmd ) ; if ( unlikely ( ! trylock_page ( page ) ) ) { get_page ( page ) ; _pmd = * pmd ; spin_unlock ( ptl ) ; lock_page ( page ) ; spin_lock ( ptl ) ; if ( unlikely ( ! pmd_same ( * pmd , _pmd ) ) ) { unlock_page ( page ) ; put_page ( page ) ; page = NULL ; goto repeat ; } put_page ( page ) ; } } <S2SV_ModStart> ptl ) ; if ( ! was_locked && page ) unlock_page ( page ) ;"}
{"source": "CWE-674 <S2SV_StartBug> lyxml_parse_elem ( struct ly_ctx * ctx , const char * data , unsigned int * len , struct lyxml_elem * parent , int options ) <S2SV_EndBug> { const char * c = data , * start , * e ; const char * lws ; int uc ; char * str ; char * prefix = NULL ; unsigned int prefix_len = 0 ; struct lyxml_elem * elem = NULL , * child ; struct lyxml_attr * attr ; unsigned int size ; int nons_flag = 0 , closed_flag = 0 ; <S2SV_StartBug> * len = 0 ; <S2SV_EndBug> if ( * c != '<' ) { return NULL ; } c ++ ; e = c ; uc = lyxml_getutf8 ( ctx , e , & size ) ; if ( ! is_xmlnamestartchar ( uc ) ) { LOGVAL ( ctx , LYE_XML_INVAL , LY_VLOG_NONE , NULL , \"NameStartChar<S2SV_blank>of<S2SV_blank>the<S2SV_blank>element\" ) ; return NULL ; } e += size ; uc = lyxml_getutf8 ( ctx , e , & size ) ; while ( is_xmlnamechar ( uc ) ) { if ( * e == ':' ) { if ( prefix_len ) { LOGVAL ( ctx , LYE_XML_INVAL , LY_VLOG_NONE , NULL , \"element<S2SV_blank>name,<S2SV_blank>multiple<S2SV_blank>colons<S2SV_blank>found\" ) ; goto error ; } start = e + 1 ; prefix_len = e - c ; LY_CHECK_ERR_GOTO ( prefix , LOGVAL ( ctx , LYE_XML_INCHAR , LY_VLOG_NONE , NULL , e ) , error ) ; prefix = malloc ( ( prefix_len + 1 ) * sizeof * prefix ) ; LY_CHECK_ERR_GOTO ( ! prefix , LOGMEM ( ctx ) , error ) ; memcpy ( prefix , c , prefix_len ) ; prefix [ prefix_len ] = '\\\\0' ; c = start ; } e += size ; uc = lyxml_getutf8 ( ctx , e , & size ) ; } if ( ! * e ) { LOGVAL ( ctx , LYE_EOF , LY_VLOG_NONE , NULL ) ; free ( prefix ) ; return NULL ; } elem = calloc ( 1 , sizeof * elem ) ; LY_CHECK_ERR_RETURN ( ! elem , free ( prefix ) ; LOGMEM ( ctx ) , NULL ) ; elem -> next = NULL ; elem -> prev = elem ; if ( parent ) { lyxml_add_child ( ctx , parent , elem ) ; } elem -> name = lydict_insert ( ctx , c , e - c ) ; c = e ; process : ign_xmlws ( c ) ; if ( ! strncmp ( \"/>\" , c , 2 ) ) { c += 2 ; elem -> content = lydict_insert ( ctx , \"\" , 0 ) ; closed_flag = 1 ; } else if ( * c == '>' ) { c ++ ; lws = NULL ; while ( * c ) { if ( ! strncmp ( c , \"</\" , 2 ) ) { if ( lws && ! elem -> child ) { goto store_content ; } c += 2 ; e = c ; uc = lyxml_getutf8 ( ctx , e , & size ) ; if ( ! is_xmlnamestartchar ( uc ) ) { LOGVAL ( ctx , LYE_XML_INVAL , LY_VLOG_XML , elem , \"NameStartChar<S2SV_blank>of<S2SV_blank>the<S2SV_blank>element\" ) ; goto error ; } e += size ; uc = lyxml_getutf8 ( ctx , e , & size ) ; while ( is_xmlnamechar ( uc ) ) { if ( * e == ':' ) { start = e + 1 ; if ( ! prefix || memcmp ( prefix , c , e - c ) ) { LOGVAL ( ctx , LYE_SPEC , LY_VLOG_XML , elem , \"Invalid<S2SV_blank>(different<S2SV_blank>namespaces)<S2SV_blank>opening<S2SV_blank>(%s)<S2SV_blank>and<S2SV_blank>closing<S2SV_blank>element<S2SV_blank>tags.\" , elem -> name ) ; goto error ; } c = start ; } e += size ; uc = lyxml_getutf8 ( ctx , e , & size ) ; } if ( ! * e ) { LOGVAL ( ctx , LYE_EOF , LY_VLOG_NONE , NULL ) ; goto error ; } size = e - c ; str = malloc ( ( size + 1 ) * sizeof * str ) ; LY_CHECK_ERR_GOTO ( ! str , LOGMEM ( ctx ) , error ) ; memcpy ( str , c , e - c ) ; str [ e - c ] = '\\\\0' ; if ( size != strlen ( elem -> name ) || memcmp ( str , elem -> name , size ) ) { LOGVAL ( ctx , LYE_SPEC , LY_VLOG_XML , elem , \"Invalid<S2SV_blank>(mixed<S2SV_blank>names)<S2SV_blank>opening<S2SV_blank>(%s)<S2SV_blank>and<S2SV_blank>closing<S2SV_blank>(%s)<S2SV_blank>element<S2SV_blank>tags.\" , elem -> name , str ) ; free ( str ) ; goto error ; } free ( str ) ; c = e ; ign_xmlws ( c ) ; if ( * c != '>' ) { LOGVAL ( ctx , LYE_SPEC , LY_VLOG_XML , elem , \"Data<S2SV_blank>after<S2SV_blank>closing<S2SV_blank>element<S2SV_blank>tag<S2SV_blank>\\\\\"%s\\\\\".\" , elem -> name ) ; goto error ; } c ++ ; if ( ! ( elem -> flags & LYXML_ELEM_MIXED ) && ! elem -> content ) { elem -> content = lydict_insert ( ctx , \"\" , 0 ) ; } closed_flag = 1 ; break ; } else if ( ! strncmp ( c , \"<?\" , 2 ) ) { if ( lws ) { lws = NULL ; } c += 2 ; if ( parse_ignore ( ctx , c , \"?>\" , & size ) ) { goto error ; } c += size ; } else if ( ! strncmp ( c , \"<!--\" , 4 ) ) { if ( lws ) { lws = NULL ; } c += 4 ; if ( parse_ignore ( ctx , c , \"-->\" , & size ) ) { goto error ; } c += size ; } else if ( ! strncmp ( c , \"<![CDATA[\" , 9 ) ) { goto store_content ; } else if ( * c == '<' ) { if ( lws ) { if ( elem -> flags & LYXML_ELEM_MIXED ) { goto store_content ; } else { lws = NULL ; } } if ( elem -> content ) { if ( options & LYXML_PARSE_NOMIXEDCONTENT ) { LOGVAL ( ctx , LYE_XML_INVAL , LY_VLOG_XML , elem , \"XML<S2SV_blank>element<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>content\" ) ; goto error ; } child = calloc ( 1 , sizeof * child ) ; LY_CHECK_ERR_GOTO ( ! child , LOGMEM ( ctx ) , error ) ; child -> content = elem -> content ; elem -> content = NULL ; lyxml_add_child ( ctx , elem , child ) ; elem -> flags |= LYXML_ELEM_MIXED ; } <S2SV_StartBug> child = lyxml_parse_elem ( ctx , c , & size , elem , options ) ; <S2SV_EndBug> if ( ! child ) { goto error ; } c += size ; } else if ( is_xmlws ( * c ) ) { lws = c ; ign_xmlws ( c ) ; } else { store_content : if ( lws ) { c = lws ; lws = NULL ; } str = parse_text ( ctx , c , '<' , & size ) ; if ( ! str && ! size ) { goto error ; } elem -> content = lydict_insert_zc ( ctx , str ) ; c += size ; if ( elem -> child ) { if ( options & LYXML_PARSE_NOMIXEDCONTENT ) { LOGVAL ( ctx , LYE_XML_INVAL , LY_VLOG_XML , elem , \"XML<S2SV_blank>element<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>content\" ) ; goto error ; } child = calloc ( 1 , sizeof * child ) ; LY_CHECK_ERR_GOTO ( ! child , LOGMEM ( ctx ) , error ) ; child -> content = elem -> content ; elem -> content = NULL ; lyxml_add_child ( ctx , elem , child ) ; elem -> flags |= LYXML_ELEM_MIXED ; } } } } else { attr = parse_attr ( ctx , c , & size , elem ) ; if ( ! attr ) { goto error ; } c += size ; if ( attr -> type == LYXML_ATTR_NS ) { if ( ( ! prefix || ! prefix [ 0 ] ) && ! attr -> name ) { if ( attr -> value ) { elem -> ns = ( struct lyxml_ns * ) attr ; } else { nons_flag = 1 ; } } else if ( prefix && prefix [ 0 ] && attr -> name && ! strncmp ( attr -> name , prefix , prefix_len + 1 ) ) { elem -> ns = ( struct lyxml_ns * ) attr ; } } goto process ; } * len = c - data ; if ( ! closed_flag ) { LOGVAL ( ctx , LYE_XML_MISS , LY_VLOG_XML , elem , \"closing<S2SV_blank>element<S2SV_blank>tag\" , elem -> name ) ; goto error ; } LY_TREE_FOR ( elem -> attr , attr ) { if ( attr -> type == LYXML_ATTR_STD_UNRES ) { str = ( char * ) attr -> ns ; attr -> ns = lyxml_get_ns ( elem , str ) ; free ( str ) ; attr -> type = LYXML_ATTR_STD ; } } if ( ! elem -> ns && ! nons_flag && parent ) { elem -> ns = lyxml_get_ns ( parent , prefix_len ? prefix : NULL ) ; } free ( prefix ) ; return elem ; error : lyxml_free ( ctx , elem ) ; free ( prefix ) ; return NULL ; }", "target": "<S2SV_ModStart> , int options , int bt_count <S2SV_ModStart> = 0 ; if ( bt_count > LY_RECURSION_LIMIT ) { LOGVAL ( ctx , LYE_XML_INVAL , LY_VLOG_NONE , NULL , \"Recursion<S2SV_blank>limit<S2SV_blank>%d<S2SV_blank>reached\" , LY_RECURSION_LIMIT ) ; return NULL ; } <S2SV_ModStart> elem , options , bt_count + 1"}
{"source": "CWE-674 lyxml_parse_mem ( struct ly_ctx * ctx , const char * data , int options ) { FUN_IN ; const char * c = data ; unsigned int len ; struct lyxml_elem * root , * first = NULL , * next ; if ( ! ctx ) { LOGARG ; return NULL ; } if ( ! data ) { return NULL ; } repeat : while ( 1 ) { if ( ! * c ) { return first ; } else if ( is_xmlws ( * c ) ) { ign_xmlws ( c ) ; } else if ( ! strncmp ( c , \"<?\" , 2 ) ) { c += 2 ; if ( parse_ignore ( ctx , c , \"?>\" , & len ) ) { goto error ; } c += len ; } else if ( ! strncmp ( c , \"<!--\" , 4 ) ) { c += 2 ; if ( parse_ignore ( ctx , c , \"-->\" , & len ) ) { goto error ; } c += len ; } else if ( ! strncmp ( c , \"<!\" , 2 ) ) { LOGERR ( ctx , LY_EINVAL , \"DOCTYPE<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>XML<S2SV_blank>documents.\" ) ; goto error ; } else if ( * c == '<' ) { break ; } else { LOGVAL ( ctx , LYE_XML_INCHAR , LY_VLOG_NONE , NULL , c ) ; goto error ; } } <S2SV_StartBug> root = lyxml_parse_elem ( ctx , c , & len , NULL , options ) ; <S2SV_EndBug> if ( ! root ) { goto error ; } else if ( ! first ) { first = root ; } else { first -> prev -> next = root ; root -> prev = first -> prev ; first -> prev = root ; } c += len ; ign_xmlws ( c ) ; if ( * c ) { if ( options & LYXML_PARSE_MULTIROOT ) { goto repeat ; } else { LOGWRN ( ctx , \"There<S2SV_blank>are<S2SV_blank>some<S2SV_blank>not<S2SV_blank>parsed<S2SV_blank>data:\\\\n%s\" , c ) ; } } return first ; error : LY_TREE_FOR_SAFE ( first , next , root ) { lyxml_free ( ctx , root ) ; } return NULL ; }", "target": "<S2SV_ModStart> NULL , options , 0"}
{"source": "CWE-787 int mpol_parse_str ( char * str , struct mempolicy * * mpol ) { struct mempolicy * new = NULL ; unsigned short mode_flags ; nodemask_t nodes ; char * nodelist = strchr ( str , ':' ) ; char * flags = strchr ( str , '=' ) ; int err = 1 , mode ; if ( flags ) * flags ++ = '\\\\0' ; if ( nodelist ) { * nodelist ++ = '\\\\0' ; if ( nodelist_parse ( nodelist , nodes ) ) goto out ; if ( ! nodes_subset ( nodes , node_states [ N_MEMORY ] ) ) goto out ; } else nodes_clear ( nodes ) ; mode = match_string ( policy_modes , MPOL_MAX , str ) ; if ( mode < 0 ) goto out ; switch ( mode ) { case MPOL_PREFERRED : if ( nodelist ) { char * rest = nodelist ; while ( isdigit ( * rest ) ) rest ++ ; if ( * rest ) goto out ; <S2SV_StartBug> } <S2SV_EndBug> break ; case MPOL_INTERLEAVE : if ( ! nodelist ) nodes = node_states [ N_MEMORY ] ; break ; case MPOL_LOCAL : if ( nodelist ) goto out ; mode = MPOL_PREFERRED ; break ; case MPOL_DEFAULT : if ( ! nodelist ) err = 0 ; goto out ; case MPOL_BIND : if ( ! nodelist ) goto out ; } mode_flags = 0 ; if ( flags ) { if ( ! strcmp ( flags , \"static\" ) ) mode_flags |= MPOL_F_STATIC_NODES ; else if ( ! strcmp ( flags , \"relative\" ) ) mode_flags |= MPOL_F_RELATIVE_NODES ; else goto out ; } new = mpol_new ( mode , mode_flags , & nodes ) ; if ( IS_ERR ( new ) ) goto out ; if ( mode != MPOL_PREFERRED ) new -> v . nodes = nodes ; else if ( nodelist ) new -> v . preferred_node = first_node ( nodes ) ; else new -> flags |= MPOL_F_LOCAL ; new -> w . user_nodemask = nodes ; err = 0 ; out : if ( nodelist ) * -- nodelist = ':' ; if ( flags ) * -- flags = '=' ; if ( ! err ) * mpol = new ; return err ; }", "target": "<S2SV_ModStart> goto out ; if ( nodes_empty ( nodes ) ) goto out ;"}
{"source": "CWE-190 static void sm501_2d_operation ( SM501State * s ) { int cmd = ( s -> twoD_control >> 16 ) & 0x1F ; int rtl = s -> twoD_control & BIT ( 27 ) ; int format = ( s -> twoD_stretch >> 20 ) & 0x3 ; int rop_mode = ( s -> twoD_control >> 15 ) & 0x1 ; int rop2_source_is_pattern = ( s -> twoD_control >> 14 ) & 0x1 ; int rop = s -> twoD_control & 0xFF ; <S2SV_StartBug> int dst_x = ( s -> twoD_destination >> 16 ) & 0x01FFF ; <S2SV_EndBug> <S2SV_StartBug> int dst_y = s -> twoD_destination & 0xFFFF ; <S2SV_EndBug> <S2SV_StartBug> int width = ( s -> twoD_dimension >> 16 ) & 0x1FFF ; <S2SV_EndBug> <S2SV_StartBug> int height = s -> twoD_dimension & 0xFFFF ; <S2SV_EndBug> uint32_t dst_base = s -> twoD_destination_base & 0x03FFFFFF ; <S2SV_StartBug> uint8_t * dst = s -> local_mem + dst_base ; <S2SV_EndBug> int dst_pitch = ( s -> twoD_pitch >> 16 ) & 0x1FFF ; int crt = ( s -> dc_crt_control & SM501_DC_CRT_CONTROL_SEL ) ? 1 : 0 ; int fb_len = get_width ( s , crt ) * get_height ( s , crt ) * get_bpp ( s , crt ) ; if ( ( s -> twoD_stretch >> 16 ) & 0xF ) { qemu_log_mask ( LOG_UNIMP , \"sm501:<S2SV_blank>only<S2SV_blank>XY<S2SV_blank>addressing<S2SV_blank>is<S2SV_blank>supported.\\\\n\" ) ; return ; } <S2SV_StartBug> if ( rop_mode == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( rop != 0xcc ) { <S2SV_EndBug> <S2SV_StartBug> qemu_log_mask ( LOG_UNIMP , \"sm501:<S2SV_blank>rop3<S2SV_blank>mode<S2SV_blank>with<S2SV_blank>rop<S2SV_blank>%x<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\" <S2SV_EndBug> \"supported.\\\\n\" , rop ) ; } } else { if ( rop2_source_is_pattern && rop != 0x5 ) { qemu_log_mask ( LOG_UNIMP , \"sm501:<S2SV_blank>rop2<S2SV_blank>source<S2SV_blank>being<S2SV_blank>the<S2SV_blank>pattern<S2SV_blank>and<S2SV_blank>\" \"rop<S2SV_blank>%x<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\\\\n\" , rop ) ; } else { if ( rop != 0x5 && rop != 0xc ) { qemu_log_mask ( LOG_UNIMP , \"sm501:<S2SV_blank>rop<S2SV_blank>mode<S2SV_blank>%x<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\" \"supported.\\\\n\" , rop ) ; } } } if ( s -> twoD_source_base & BIT ( 27 ) || s -> twoD_destination_base & BIT ( 27 ) ) { qemu_log_mask ( LOG_UNIMP , \"sm501:<S2SV_blank>only<S2SV_blank>local<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>supported.\\\\n\" ) ; return ; } switch ( cmd ) { case 0x00 : { int src_x = ( s -> twoD_source >> 16 ) & 0x01FFF ; int src_y = s -> twoD_source & 0xFFFF ; uint32_t src_base = s -> twoD_source_base & 0x03FFFFFF ; uint8_t * src = s -> local_mem + src_base ; int src_pitch = s -> twoD_pitch & 0x1FFF ; # define COPY_AREA ( _bpp , _pixel_type , rtl ) { int y , x , index_d , index_s ; for ( y = 0 ; y < height ; y ++ ) { for ( x = 0 ; x < width ; x ++ ) { _pixel_type val ; if ( rtl ) { index_s = ( ( src_y - y ) * src_pitch + src_x - x ) * _bpp ; index_d = ( ( dst_y - y ) * dst_pitch + dst_x - x ) * _bpp ; } else { index_s = ( ( src_y + y ) * src_pitch + src_x + x ) * _bpp ; index_d = ( ( dst_y + y ) * dst_pitch + dst_x + x ) * _bpp ; } if ( rop_mode == 1 && rop == 5 ) { val = ~ * ( _pixel_type * ) & dst [ index_d ] ; } else { val = * ( _pixel_type * ) & src [ index_s ] ; } * ( _pixel_type * ) & dst [ index_d ] = val ; } } } switch ( format ) { case 0 : COPY_AREA ( 1 , uint8_t , rtl ) ; break ; case 1 : COPY_AREA ( 2 , uint16_t , rtl ) ; break ; case 2 : COPY_AREA ( 4 , uint32_t , rtl ) ; break ; } <S2SV_StartBug> break ; <S2SV_EndBug> } case 0x01 : { uint32_t color = s -> twoD_foreground ; <S2SV_StartBug> # define FILL_RECT ( _bpp , _pixel_type ) { int y , x ; for ( y = 0 ; y < height ; y ++ ) { for ( x = 0 ; x < width ; x ++ ) { int index = ( ( dst_y + y ) * dst_pitch + dst_x + x ) * _bpp ; * ( _pixel_type * ) & dst [ index ] = ( _pixel_type ) color ; } } } <S2SV_EndBug> switch ( format ) { case 0 : FILL_RECT ( 1 , uint8_t ) ; break ; case 1 : color = cpu_to_le16 ( color ) ; FILL_RECT ( 2 , uint16_t ) ; break ; case 2 : color = cpu_to_le32 ( color ) ; FILL_RECT ( 4 , uint32_t ) ; break ; } break ; } default : qemu_log_mask ( LOG_UNIMP , \"sm501:<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>2D<S2SV_blank>operation:<S2SV_blank>%d\\\\n\" , cmd ) ; return ; } if ( dst_base >= get_fb_addr ( s , crt ) && dst_base <= get_fb_addr ( s , crt ) + fb_len ) { int dst_len = MIN ( fb_len , ( ( dst_y + height - 1 ) * dst_pitch + dst_x + width ) * ( 1 << format ) ) ; if ( dst_len ) { memory_region_set_dirty ( & s -> local_mem_region , dst_base , dst_len ) ; } } }", "target": "<S2SV_ModStart> & 0xFF ; unsigned <S2SV_ModStart> & 0x01FFF ; unsigned <S2SV_ModStart> & 0xFFFF ; unsigned <S2SV_ModStart> & 0x1FFF ; unsigned <S2SV_ModStart> & 0x03FFFFFF ; unsigned <S2SV_ModEnd> int dst_pitch = <S2SV_ModStart> } if ( s -> twoD_source_base & BIT ( 27 ) || s -> twoD_destination_base & BIT ( 27 ) ) { qemu_log_mask ( LOG_UNIMP , \"sm501:<S2SV_blank>only<S2SV_blank>local<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>supported.\\\\n\" ) ; return ; } if ( ! dst_pitch ) { qemu_log_mask ( LOG_GUEST_ERROR , \"sm501:<S2SV_blank>Zero<S2SV_blank>dest<S2SV_blank>pitch.\\\\n\" ) ; return ; } if ( ! width || ! height ) { qemu_log_mask ( LOG_GUEST_ERROR , \"sm501:<S2SV_blank>Zero<S2SV_blank>size<S2SV_blank>2D<S2SV_blank>op.\\\\n\" ) ; return ; } if ( rtl ) { dst_x -= width - 1 ; dst_y -= height - 1 ; } if ( dst_base >= get_local_mem_size ( s ) || dst_base + ( dst_x + width + ( dst_y + height ) * ( dst_pitch + width ) ) * ( 1 << format ) >= get_local_mem_size ( s ) ) { qemu_log_mask ( LOG_GUEST_ERROR , \"sm501:<S2SV_blank>2D<S2SV_blank>op<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>vram.\\\\n\" ) ; return ; } switch ( cmd ) { case 0 : { unsigned int src_x = ( s -> twoD_source >> 16 ) & 0x01FFF ; unsigned int src_y = s -> twoD_source & 0xFFFF ; uint32_t src_base = s -> twoD_source_base & 0x03FFFFFF ; unsigned int src_pitch = s -> twoD_pitch & 0x1FFF ; if ( ! src_pitch ) { qemu_log_mask ( LOG_GUEST_ERROR , \"sm501:<S2SV_blank>Zero<S2SV_blank>src<S2SV_blank>pitch.\\\\n\" ) ; return ; } if ( rtl ) { src_x -= width - 1 ; src_y -= height - 1 ; } if ( src_base >= get_local_mem_size ( s ) || src_base + ( src_x + width + ( src_y + height ) * ( src_pitch + width ) ) * ( 1 << format ) >= get_local_mem_size ( s ) ) { qemu_log_mask ( LOG_GUEST_ERROR , \"sm501:<S2SV_blank>2D<S2SV_blank>op<S2SV_blank>src<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>vram.\\\\n\" ) ; return ; } if ( ( rop_mode && rop == 0x5 ) || ( ! rop_mode && rop == 0x55 ) ) { unsigned int x , y , i ; uint8_t * d = s -> local_mem + dst_base ; for ( y = 0 ; y < height ; y ++ ) { i = ( dst_x + ( dst_y + y ) * dst_pitch ) * ( 1 << format ) ; for ( x = 0 ; x < width ; x ++ , i += ( 1 << format ) ) { switch ( format ) { case 0 : d [ i ] = ~ d [ i ] ; break ; case 1 : * ( uint16_t * ) & d [ i ] = ~ * ( uint16_t * ) & d [ i ] ; break ; case 2 : * ( uint32_t * ) & d [ i ] = ~ * ( uint32_t * ) & d [ i ] ; break ; } } } } else { if ( ( rop_mode && ( rop != 0xc || rop2_source_is_pattern ) ) || ( ! rop_mode && <S2SV_ModEnd> rop != 0xcc <S2SV_ModStart> != 0xcc ) ) <S2SV_ModStart> ( LOG_UNIMP , \"sm501:<S2SV_blank>rop%d<S2SV_blank>op<S2SV_blank>%x%s<S2SV_blank>not<S2SV_blank>implemented\\\\n\" , ( rop_mode ? 2 : 3 ) , rop , ( rop2_source_is_pattern ? \"<S2SV_blank>with<S2SV_blank>pattern<S2SV_blank>source\" : \"\" ) ) ; } uint32_t sb , se , db , de ; sb = src_base + src_x + src_y * ( width + src_pitch ) ; se = sb + width + height * ( width + src_pitch ) ; db = dst_base + dst_x + dst_y * ( width + dst_pitch ) ; de = db + width + height * ( width + dst_pitch ) ; if ( rtl && ( ( db >= sb && db <= se ) || ( de >= sb && de <= se ) ) ) { int llb = width * ( 1 << format ) ; int tmp_stride = DIV_ROUND_UP ( llb , sizeof ( uint32_t ) ) ; uint32_t * tmp = g_malloc ( tmp_stride * sizeof ( uint32_t ) * height ) ; pixman_blt ( ( uint32_t * ) & s -> local_mem [ src_base ] , tmp , src_pitch * ( 1 << format ) / sizeof ( uint32_t ) , tmp_stride , 8 * ( 1 << format ) , 8 * ( 1 << format ) , src_x , src_y , 0 , 0 , width , height ) ; pixman_blt ( tmp , ( uint32_t * ) & s -> local_mem [ dst_base ] , tmp_stride , dst_pitch * ( 1 << format ) / sizeof ( uint32_t ) , 8 * ( 1 << format ) , 8 * ( 1 << format ) , 0 , 0 , dst_x , dst_y , width , height ) ; g_free ( tmp ) ; } else { pixman_blt ( ( uint32_t * ) & s -> local_mem [ src_base ] , ( uint32_t * ) & s -> local_mem [ dst_base ] , src_pitch * ( 1 << format ) / sizeof ( uint32_t ) , dst_pitch * ( 1 << format ) / sizeof ( uint32_t ) , 8 * ( 1 << format ) , 8 * ( 1 << format ) , src_x , src_y , dst_x , dst_y , width , height ) ; } } <S2SV_ModEnd> break ; } <S2SV_ModStart> break ; } case 1 <S2SV_ModEnd> : { uint32_t <S2SV_ModStart> -> twoD_foreground ; if ( format == 2 ) { color = cpu_to_le32 ( color ) ; } else if ( format == 1 ) { color = cpu_to_le16 ( color ) ; } pixman_fill ( ( uint32_t * ) & s -> local_mem [ dst_base ] , dst_pitch * ( 1 << format ) / sizeof ( uint32_t ) , 8 * ( 1 << format ) , dst_x , dst_y , width , height , color ) ; <S2SV_ModEnd> break ; }"}
{"source": "CWE-125 int MemIo : : seek ( int64 offset , Position pos ) { int64 newIdx = 0 ; switch ( pos ) { case BasicIo : : cur : newIdx = p_ -> idx_ + offset ; break ; case BasicIo : : beg : newIdx = offset ; break ; case BasicIo : : end : newIdx = p_ -> size_ + offset ; break ; } if ( newIdx < 0 ) return 1 ; <S2SV_StartBug> p_ -> idx_ = static_cast < long > ( newIdx ) ; <S2SV_EndBug> p_ -> eof_ = false ; return 0 ; }", "target": "<S2SV_ModStart> return 1 ; if ( static_cast < size_t > ( newIdx ) > p_ -> size_ ) { p_ -> eof_ = true ; return 1 ; } <S2SV_ModStart> = static_cast < size_t <S2SV_ModEnd> > ( newIdx"}
{"source": "CWE-617 BPMDetect : : BPMDetect ( int numChannels , int aSampleRate ) : beat_lpf ( _LPF_coeffs ) { beats . reserve ( 250 ) ; this -> sampleRate = aSampleRate ; this -> channels = numChannels ; decimateSum = 0 ; decimateCount = 0 ; decimateBy = sampleRate / TARGET_SRATE ; <S2SV_StartBug> assert ( decimateBy > 0 ) ; <S2SV_EndBug> assert ( INPUT_BLOCK_SIZE < decimateBy * DECIMATED_BLOCK_SIZE ) ; windowLen = ( 60 * sampleRate ) / ( decimateBy * MIN_BPM ) ; windowStart = ( 60 * sampleRate ) / ( decimateBy * MAX_BPM_RANGE ) ; assert ( windowLen > windowStart ) ; xcorr = new float [ windowLen ] ; memset ( xcorr , 0 , windowLen * sizeof ( float ) ) ; pos = 0 ; peakPos = 0 ; peakVal = 0 ; init_scaler = 1 ; beatcorr_ringbuffpos = 0 ; beatcorr_ringbuff = new float [ windowLen ] ; memset ( beatcorr_ringbuff , 0 , windowLen * sizeof ( float ) ) ; buffer = new FIFOSampleBuffer ( ) ; buffer -> setChannels ( 1 ) ; buffer -> clear ( ) ; hamw = new float [ XCORR_UPDATE_SEQUENCE ] ; hamming ( hamw , XCORR_UPDATE_SEQUENCE ) ; hamw2 = new float [ XCORR_UPDATE_SEQUENCE / 2 ] ; hamming ( hamw2 , XCORR_UPDATE_SEQUENCE / 2 ) ; }", "target": "<S2SV_ModStart> / TARGET_SRATE ; if ( ( decimateBy <= 0 ) || ( decimateBy * DECIMATED_BLOCK_SIZE < INPUT_BLOCK_SIZE ) ) { ST_THROW_RT_ERROR ( \"Too<S2SV_blank>small<S2SV_blank>samplerate\" ) ; } <S2SV_ModEnd> windowLen = ("}
{"source": "CWE-125 hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( \"HIVEX_DEBUG\" ) ; if ( debug && STREQ ( debug , \"1\" ) ) h -> msglvl = 2 ; DEBUG ( 2 , \"created<S2SV_blank>handle<S2SV_blank>%p\" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> unsafe = ! ! ( flags & HIVEX_OPEN_UNSAFE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , \"%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file\" , filename ) ; goto error ; } if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , \"mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p\" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file\" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%\" PRIu32 \"<S2SV_blank>(expected<S2SV_blank>1)\" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , \"%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header\" , filename ) ; goto error ; } for ( int t = 0 ; t < nr_recode_types ; t ++ ) { gl_lock_init ( h -> iconv_cache [ t ] . mutex ) ; h -> iconv_cache [ t ] . handle = NULL ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_recode ( h , utf16le_to_utf8 , h -> hdr -> name , 64 , NULL ) ; fprintf ( stderr , \"hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\\\n\" \"<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%\" PRIu32 \".%\" PRIu32 \"\\\\n\" \"<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%\" PRIu32 \"<S2SV_blank>%\" PRIu32 \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\\\n\" \"<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%\" PRIi64 \"\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\\\n\" \"<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\\\n\" \"<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\\\n\" \"<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\\\n\" \"<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\\\n\" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : \"(conversion<S2SV_blank>failed)\" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , \"root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx\" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { if ( ! h -> unsafe ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>\" \"(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)\" , filename , off , pages ) ; goto error ; } DEBUG ( 2 , \"page<S2SV_blank>not<S2SV_blank>found<S2SV_blank>at<S2SV_blank>expected<S2SV_blank>offset<S2SV_blank>0x%zx,<S2SV_blank>\" \"seeking<S2SV_blank>until<S2SV_blank>one<S2SV_blank>is<S2SV_blank>found<S2SV_blank>or<S2SV_blank>EOF<S2SV_blank>is<S2SV_blank>reached\" , off ) ; int found = 0 ; while ( off < h -> size ) { off += 0x1000 ; if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] == 'h' && page -> magic [ 1 ] == 'b' && page -> magic [ 2 ] == 'i' && page -> magic [ 3 ] == 'n' ) { DEBUG ( 2 , \"found<S2SV_blank>next<S2SV_blank>page<S2SV_blank>by<S2SV_blank>seeking<S2SV_blank>at<S2SV_blank>0x%zx\" , off ) ; found = 1 ; break ; } } if ( ! found ) { DEBUG ( 2 , \"page<S2SV_blank>not<S2SV_blank>found<S2SV_blank>and<S2SV_blank>end<S2SV_blank>of<S2SV_blank>pages<S2SV_blank>section<S2SV_blank>reached\" ) ; break ; } } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , \"page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu\" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry\" , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry\" , filename , page_size , off ) ; goto error ; } size_t page_offset = le32toh ( page -> offset_first ) + 0x1000 ; if ( page_offset != off ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>declared<S2SV_blank>page<S2SV_blank>offset<S2SV_blank>(0x%zx)<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>computed<S2SV_blank>\" \"offset<S2SV_blank>(0x%zx),<S2SV_blank>bad<S2SV_blank>registry\" , filename , page_offset , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; # pragma GCC diagnostic push # pragma GCC diagnostic ignored \"-Wstrict-overflow\" if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { # pragma GCC diagnostic pop if ( is_root || ! h -> unsafe ) { SET_ERRNO ( ENOTSUP , <S2SV_StartBug> \"%s,<S2SV_blank>the<S2SV_blank>block<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>%\" PRIu32 <S2SV_EndBug> \",<S2SV_blank>bad<S2SV_blank>registry\" , filename , blkoff , le32toh ( block -> seg_len ) ) ; goto error ; } else { DEBUG ( 2 , \"%s:<S2SV_blank>block<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>%\" PRIu32 \",<S2SV_blank>skipping\" , filename , blkoff , le32toh ( block -> seg_len ) ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , \"%s:<S2SV_blank>%s:<S2SV_blank>\" \"%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\\\n\" , \"hivex\" , __func__ , used ? \"used\" : \"free\" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? \"<S2SV_blank>(root)\" : \"\" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found\" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , \"%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)\" , filename ) ; goto error ; } DEBUG ( 1 , \"successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\\\n\" \"<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\\\n\" \"<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\\\n\" \"<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\\\n\" \"<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }", "target": "<S2SV_ModStart> ( ENOTSUP , \"%s,<S2SV_blank>the<S2SV_blank>block<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%\" PRIu32 \"<S2SV_blank><=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4,<S2SV_blank>bad<S2SV_blank>registry\" <S2SV_ModEnd> , filename , <S2SV_ModStart> break ; } } if ( blkoff + seg_len > off + page_size ) { SET_ERRNO ( ENOTSUP , \"%s,<S2SV_blank>the<S2SV_blank>block<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%\" PRIu32 \"<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>current<S2SV_blank>page,<S2SV_blank>bad<S2SV_blank>registry\" , filename , blkoff , le32toh ( block -> seg_len ) ) ; goto error ;"}
{"source": "CWE-190 static MSUSB_PIPE_DESCRIPTOR * * msusb_mspipes_read ( wStream * s , UINT32 NumberOfPipes ) { UINT32 pnum ; MSUSB_PIPE_DESCRIPTOR * * MsPipes ; <S2SV_StartBug> if ( Stream_GetRemainingCapacity ( s ) < 12 * NumberOfPipes ) <S2SV_EndBug> return NULL ; MsPipes = ( MSUSB_PIPE_DESCRIPTOR * * ) calloc ( NumberOfPipes , sizeof ( MSUSB_PIPE_DESCRIPTOR * ) ) ; if ( ! MsPipes ) return NULL ; for ( pnum = 0 ; pnum < NumberOfPipes ; pnum ++ ) { MSUSB_PIPE_DESCRIPTOR * MsPipe = msusb_mspipe_new ( ) ; if ( ! MsPipe ) goto out_error ; Stream_Read_UINT16 ( s , MsPipe -> MaximumPacketSize ) ; Stream_Seek ( s , 2 ) ; Stream_Read_UINT32 ( s , MsPipe -> MaximumTransferSize ) ; Stream_Read_UINT32 ( s , MsPipe -> PipeFlags ) ; MsPipes [ pnum ] = MsPipe ; } return MsPipes ; out_error : for ( pnum = 0 ; pnum < NumberOfPipes ; pnum ++ ) free ( MsPipes [ pnum ] ) ; free ( MsPipes ) ; return NULL ; }", "target": "<S2SV_ModStart> ( s ) / 12 < <S2SV_ModEnd> NumberOfPipes ) return"}
{"source": "CWE-369 static MagickBooleanType WriteAnimatedWEBPImage ( const ImageInfo * image_info , Image * image , WebPConfig * configure , WebPMemoryWriter * writer_info , ExceptionInfo * exception ) { Image * first_image ; PictureMemory * current , * head ; size_t effective_delta = 0 , frame_timestamp = 0 ; WebPAnimEncoder * enc ; WebPAnimEncoderOptions enc_options ; WebPData webp_data ; WebPPicture picture ; WebPAnimEncoderOptionsInit ( & enc_options ) ; if ( image_info -> verbose ) enc_options . verbose = 1 ; image = CoalesceImages ( image , exception ) ; first_image = image ; enc = WebPAnimEncoderNew ( ( int ) image -> page . width , ( int ) image -> page . height , & enc_options ) ; head = ( PictureMemory * ) calloc ( sizeof ( * head ) , 1 ) ; current = head ; while ( image != NULL ) { if ( WebPPictureInit ( & picture ) == 0 ) ThrowWriterException ( ResourceLimitError , \"UnableToEncodeImageFile\" ) ; WriteSingleWEBPImage ( image_info , image , & picture , current , exception ) ; <S2SV_StartBug> effective_delta = image -> delay * 1000 / image -> ticks_per_second ; <S2SV_EndBug> if ( effective_delta < 10 ) effective_delta = 100 ; frame_timestamp += effective_delta ; WebPAnimEncoderAdd ( enc , & picture , ( int ) frame_timestamp , configure ) ; image = GetNextImageInList ( image ) ; current -> next = ( PictureMemory * ) calloc ( sizeof ( * head ) , 1 ) ; current = current -> next ; } webp_data . bytes = writer_info -> mem ; webp_data . size = writer_info -> size ; WebPAnimEncoderAssemble ( enc , & webp_data ) ; WebPMemoryWriterClear ( writer_info ) ; writer_info -> size = webp_data . size ; writer_info -> mem = ( unsigned char * ) webp_data . bytes ; WebPAnimEncoderDelete ( enc ) ; DestroyImageList ( first_image ) ; FreePictureMemoryList ( head ) ; return ( MagickTrue ) ; }", "target": "<S2SV_ModStart> delay * 1000 * PerceptibleReciprocal ( <S2SV_ModEnd> image -> ticks_per_second <S2SV_ModStart> image -> ticks_per_second )"}
{"source": "CWE-369 MagickExport double GenerateDifferentialNoise ( RandomInfo * random_info , const Quantum pixel , const NoiseType noise_type , const MagickRealType attenuate ) { # define SigmaUniform ( attenuate * 0.015625 ) # define SigmaGaussian ( attenuate * 0.015625 ) # define SigmaImpulse ( attenuate * 0.1 ) # define SigmaLaplacian ( attenuate * 0.0390625 ) # define SigmaMultiplicativeGaussian ( attenuate * 0.5 ) # define SigmaPoisson ( attenuate * 12.5 ) # define SigmaRandom ( attenuate ) # define TauGaussian ( attenuate * 0.078125 ) double alpha , beta , noise , sigma ; alpha = GetPseudoRandomValue ( random_info ) ; switch ( noise_type ) { case UniformNoise : default : { noise = ( double ) ( pixel + QuantumRange * SigmaUniform * ( alpha - 0.5 ) ) ; break ; } case GaussianNoise : { double gamma , tau ; if ( fabs ( alpha ) < MagickEpsilon ) alpha = 1.0 ; beta = GetPseudoRandomValue ( random_info ) ; gamma = sqrt ( - 2.0 * log ( alpha ) ) ; sigma = gamma * cos ( ( double ) ( 2.0 * MagickPI * beta ) ) ; tau = gamma * sin ( ( double ) ( 2.0 * MagickPI * beta ) ) ; noise = ( double ) ( pixel + sqrt ( ( double ) pixel ) * SigmaGaussian * sigma + QuantumRange * TauGaussian * tau ) ; break ; } case ImpulseNoise : { if ( alpha < ( SigmaImpulse / 2.0 ) ) noise = 0.0 ; else if ( alpha >= ( 1.0 - ( SigmaImpulse / 2.0 ) ) ) noise = ( double ) QuantumRange ; else noise = ( double ) pixel ; break ; } case LaplacianNoise : { if ( alpha <= 0.5 ) { if ( alpha <= MagickEpsilon ) noise = ( double ) ( pixel - QuantumRange ) ; else noise = ( double ) ( pixel + QuantumRange * SigmaLaplacian * log ( 2.0 * alpha ) + 0.5 ) ; break ; } beta = 1.0 - alpha ; if ( beta <= ( 0.5 * MagickEpsilon ) ) noise = ( double ) ( pixel + QuantumRange ) ; else noise = ( double ) ( pixel - QuantumRange * SigmaLaplacian * log ( 2.0 * beta ) + 0.5 ) ; break ; } case MultiplicativeGaussianNoise : { sigma = 1.0 ; if ( alpha > MagickEpsilon ) sigma = sqrt ( - 2.0 * log ( alpha ) ) ; beta = GetPseudoRandomValue ( random_info ) ; noise = ( double ) ( pixel + pixel * SigmaMultiplicativeGaussian * sigma * cos ( ( double ) ( 2.0 * MagickPI * beta ) ) / 2.0 ) ; break ; } case PoissonNoise : { double poisson ; ssize_t i ; poisson = exp ( - SigmaPoisson * QuantumScale * pixel ) ; for ( i = 0 ; alpha > poisson ; i ++ ) { beta = GetPseudoRandomValue ( random_info ) ; alpha *= beta ; } <S2SV_StartBug> noise = ( double ) ( QuantumRange * i / SigmaPoisson ) ; <S2SV_EndBug> break ; } case RandomNoise : { noise = ( double ) ( QuantumRange * SigmaRandom * alpha ) ; break ; } } return ( noise ) ; }", "target": "<S2SV_ModStart> QuantumRange * i * PerceptibleReciprocal ( SigmaPoisson ) <S2SV_ModEnd> ) ; break"}
{"source": "CWE-703 srs_timestamp_check ( srs_t * srs , const char * stamp ) { const char * sp ; char * bp ; int off ; time_t now ; time_t then ; <S2SV_StartBug> <S2SV_EndBug> then = 0 ; for ( sp = stamp ; * sp ; sp ++ ) { bp = strchr ( SRS_TIME_BASECHARS , toupper ( * sp ) ) ; if ( bp == NULL ) return SRS_EBADTIMESTAMPCHAR ; off = bp - SRS_TIME_BASECHARS ; then = ( then << SRS_TIME_BASEBITS ) | off ; } time ( & now ) ; now = ( now / SRS_TIME_PRECISION ) % SRS_TIME_SLOTS ; while ( now < then ) now = now + SRS_TIME_SLOTS ; if ( now <= then + srs -> maxage ) return SRS_SUCCESS ; return SRS_ETIMESTAMPOUTOFDATE ; }", "target": "<S2SV_ModStart> time_t then ; if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE ;"}
{"source": "CWE-772 static rsRetVal qAddDirect ( qqueue_t * pThis , void * pUsr ) { batch_t singleBatch ; <S2SV_StartBug> batch_obj_t batchObj ; <S2SV_EndBug> DEFiRet ; ASSERT ( pThis != NULL ) ; memset ( & batchObj , 0 , sizeof ( batch_obj_t ) ) ; memset ( & singleBatch , 0 , sizeof ( batch_t ) ) ; batchObj . state = BATCH_STATE_RDY ; batchObj . pUsrp = ( obj_t * ) pUsr ; batchObj . bFilterOK = 1 ; singleBatch . nElem = 1 ; singleBatch . pElem = & batchObj ; iRet = pThis -> pConsumer ( pThis -> pUsr , & singleBatch , & pThis -> bShutdownImmediate ) ; <S2SV_StartBug> objDestruct ( pUsr ) ; <S2SV_EndBug> RETiRet ; }", "target": "<S2SV_ModStart> ; batch_obj_t batchObj ; int i <S2SV_ModStart> bShutdownImmediate ) ; for ( i = 0 ; i < CONF_OMOD_NUMSTRINGS_MAXSIZE ; ++ i ) { free ( batchObj . staticActStrings [ i ] ) ; }"}
{"source": "CWE-119 GC_API GC_ATTR_MALLOC void * GC_CALL GC_calloc_explicitly_typed ( size_t n , size_t lb , GC_descr d ) { word * op ; size_t lg ; GC_descr simple_descr ; complex_descriptor * complex_descr ; int descr_type ; struct LeafDescriptor leaf ; GC_ASSERT ( GC_explicit_typing_initialized ) ; descr_type = GC_make_array_descriptor ( ( word ) n , ( word ) lb , d , & simple_descr , & complex_descr , & leaf ) ; <S2SV_StartBug> switch ( descr_type ) { <S2SV_EndBug> case NO_MEM : return ( 0 ) ; <S2SV_StartBug> case SIMPLE : return ( GC_malloc_explicitly_typed ( n * lb , simple_descr ) ) ; <S2SV_EndBug> case LEAF : <S2SV_StartBug> lb *= n ; <S2SV_EndBug> lb += sizeof ( struct LeafDescriptor ) + TYPD_EXTRA_BYTES ; break ; case COMPLEX : <S2SV_StartBug> lb *= n ; <S2SV_EndBug> lb += TYPD_EXTRA_BYTES ; break ; } op = GC_malloc_kind ( lb , GC_array_kind ) ; if ( EXPECT ( NULL == op , FALSE ) ) return NULL ; lg = SMALL_OBJ ( lb ) ? GC_size_map [ lb ] : BYTES_TO_GRANULES ( GC_size ( op ) ) ; if ( descr_type == LEAF ) { volatile struct LeafDescriptor * lp = ( struct LeafDescriptor * ) ( op + GRANULES_TO_WORDS ( lg ) - ( BYTES_TO_WORDS ( sizeof ( struct LeafDescriptor ) ) + 1 ) ) ; lp -> ld_tag = LEAF_TAG ; lp -> ld_size = leaf . ld_size ; lp -> ld_nelements = leaf . ld_nelements ; lp -> ld_descriptor = leaf . ld_descriptor ; ( ( volatile word * ) op ) [ GRANULES_TO_WORDS ( lg ) - 1 ] = ( word ) lp ; } else { # ifndef GC_NO_FINALIZATION size_t lw = GRANULES_TO_WORDS ( lg ) ; op [ lw - 1 ] = ( word ) complex_descr ; if ( EXPECT ( GC_general_register_disappearing_link ( ( void * * ) ( op + lw - 1 ) , op ) == GC_NO_MEMORY , FALSE ) ) # endif { return GC_malloc ( lb ) ; } } return op ; }", "target": "<S2SV_ModStart> leaf ) ; if ( ( lb | n ) > GC_SQRT_SIZE_MAX && lb > 0 && n > GC_SIZE_MAX / lb ) return NULL ; lb *= n ; <S2SV_ModStart> case SIMPLE : return GC_malloc_explicitly_typed ( <S2SV_ModEnd> lb , simple_descr <S2SV_ModStart> lb , simple_descr <S2SV_ModEnd> ) ; case <S2SV_ModStart> LEAF : lb <S2SV_ModEnd> += sizeof ( <S2SV_ModStart> case COMPLEX : <S2SV_ModEnd> lb += TYPD_EXTRA_BYTES"}
{"source": "CWE-476 vmod_append ( VRT_CTX , VCL_HEADER hdr , VCL_STRANDS s ) { struct http * hp ; struct strands st [ 1 ] ; const char * p [ s -> n + 2 ] ; const char * b ; CHECK_OBJ_NOTNULL ( ctx , VRT_CTX_MAGIC ) ; p [ 0 ] = hdr -> what + 1 ; p [ 1 ] = \"<S2SV_blank>\" ; AN ( memcpy ( p + 2 , s -> p , s -> n * sizeof * s -> p ) ) ; st -> n = s -> n + 2 ; st -> p = p ; b = VRT_StrandsWS ( ctx -> ws , NULL , st ) ; <S2SV_StartBug> <S2SV_EndBug> hp = VRT_selecthttp ( ctx , hdr -> where ) ; http_SetHeader ( hp , b ) ; }", "target": "<S2SV_ModStart> st ) ; if ( b == NULL ) { VRT_fail ( ctx , \"vmod_header:<S2SV_blank>workspace<S2SV_blank>allocation<S2SV_blank>failure\" ) ; return ; }"}
{"source": "CWE-476 unsigned long perf_instruction_pointer ( struct pt_regs * regs ) { bool use_siar = regs_use_siar ( regs ) ; unsigned long siar = mfspr ( SPRN_SIAR ) ; <S2SV_StartBug> if ( ppmu -> flags & PPMU_P10_DD1 ) { <S2SV_EndBug> if ( siar ) return siar ; else return regs -> nip ; } else if ( use_siar && siar_valid ( regs ) ) return mfspr ( SPRN_SIAR ) + perf_ip_adjust ( regs ) ; else if ( use_siar ) return 0 ; else return regs -> nip ; }", "target": "<S2SV_ModStart> if ( ppmu && ( ppmu <S2SV_ModStart> flags & PPMU_P10_DD1 )"}
{"source": "CWE-565 SAPI_API SAPI_TREAT_DATA_FUNC ( php_default_treat_data ) { char * res = NULL , * var , * val , * separator = NULL ; const char * c_var ; zval array ; int free_buffer = 0 ; char * strtok_buf = NULL ; zend_long count = 0 ; ZVAL_UNDEF ( & array ) ; switch ( arg ) { case PARSE_POST : case PARSE_GET : case PARSE_COOKIE : array_init ( & array ) ; switch ( arg ) { case PARSE_POST : zval_ptr_dtor ( & PG ( http_globals ) [ TRACK_VARS_POST ] ) ; ZVAL_COPY_VALUE ( & PG ( http_globals ) [ TRACK_VARS_POST ] , & array ) ; break ; case PARSE_GET : zval_ptr_dtor ( & PG ( http_globals ) [ TRACK_VARS_GET ] ) ; ZVAL_COPY_VALUE ( & PG ( http_globals ) [ TRACK_VARS_GET ] , & array ) ; break ; case PARSE_COOKIE : zval_ptr_dtor ( & PG ( http_globals ) [ TRACK_VARS_COOKIE ] ) ; ZVAL_COPY_VALUE ( & PG ( http_globals ) [ TRACK_VARS_COOKIE ] , & array ) ; break ; } break ; default : ZVAL_COPY_VALUE ( & array , destArray ) ; break ; } if ( arg == PARSE_POST ) { sapi_handle_post ( & array ) ; return ; } if ( arg == PARSE_GET ) { c_var = SG ( request_info ) . query_string ; if ( c_var && * c_var ) { res = ( char * ) estrdup ( c_var ) ; free_buffer = 1 ; } else { free_buffer = 0 ; } } else if ( arg == PARSE_COOKIE ) { c_var = SG ( request_info ) . cookie_data ; if ( c_var && * c_var ) { res = ( char * ) estrdup ( c_var ) ; free_buffer = 1 ; } else { free_buffer = 0 ; } } else if ( arg == PARSE_STRING ) { res = str ; free_buffer = 1 ; } if ( ! res ) { return ; } switch ( arg ) { case PARSE_GET : case PARSE_STRING : separator = PG ( arg_separator ) . input ; break ; case PARSE_COOKIE : separator = \";\\\\0\" ; break ; } var = php_strtok_r ( res , separator , & strtok_buf ) ; while ( var ) { val = strchr ( var , '=' ) ; if ( arg == PARSE_COOKIE ) { while ( isspace ( * var ) ) { var ++ ; } if ( var == val || * var == '\\\\0' ) { goto next_cookie ; } } if ( ++ count > PG ( max_input_vars ) ) { php_error_docref ( NULL , E_WARNING , \"Input<S2SV_blank>variables<S2SV_blank>exceeded<S2SV_blank>\" ZEND_LONG_FMT \".<S2SV_blank>To<S2SV_blank>increase<S2SV_blank>the<S2SV_blank>limit<S2SV_blank>change<S2SV_blank>max_input_vars<S2SV_blank>in<S2SV_blank>php.ini.\" , PG ( max_input_vars ) ) ; break ; } if ( val ) { size_t val_len ; size_t new_val_len ; * val ++ = '\\\\0' ; <S2SV_StartBug> php_url_decode ( var , strlen ( var ) ) ; <S2SV_EndBug> val_len = php_url_decode ( val , strlen ( val ) ) ; val = estrndup ( val , val_len ) ; if ( sapi_module . input_filter ( arg , var , & val , val_len , & new_val_len ) ) { php_register_variable_safe ( var , val , new_val_len , & array ) ; } efree ( val ) ; } else { size_t val_len ; size_t new_val_len ; <S2SV_StartBug> php_url_decode ( var , strlen ( var ) ) ; <S2SV_EndBug> val_len = 0 ; val = estrndup ( \"\" , val_len ) ; if ( sapi_module . input_filter ( arg , var , & val , val_len , & new_val_len ) ) { php_register_variable_safe ( var , val , new_val_len , & array ) ; } efree ( val ) ; } next_cookie : var = php_strtok_r ( NULL , separator , & strtok_buf ) ; } if ( free_buffer ) { efree ( res ) ; } }", "target": "<S2SV_ModStart> = '\\\\0' ; if ( arg != PARSE_COOKIE ) { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> size_t new_val_len ; if ( arg != PARSE_COOKIE ) { <S2SV_ModStart> ) ) ; }"}
{"source": "CWE-190 bool do_notify_parent ( struct task_struct * tsk , int sig ) { struct kernel_siginfo info ; unsigned long flags ; struct sighand_struct * psig ; bool autoreap = false ; u64 utime , stime ; BUG_ON ( sig == - 1 ) ; BUG_ON ( task_is_stopped_or_traced ( tsk ) ) ; BUG_ON ( ! tsk -> ptrace && ( tsk -> group_leader != tsk || ! thread_group_empty ( tsk ) ) ) ; do_notify_pidfd ( tsk ) ; if ( sig != SIGCHLD ) { <S2SV_StartBug> if ( tsk -> parent_exec_id != tsk -> parent -> self_exec_id ) <S2SV_EndBug> sig = SIGCHLD ; } clear_siginfo ( & info ) ; info . si_signo = sig ; info . si_errno = 0 ; rcu_read_lock ( ) ; info . si_pid = task_pid_nr_ns ( tsk , task_active_pid_ns ( tsk -> parent ) ) ; info . si_uid = from_kuid_munged ( task_cred_xxx ( tsk -> parent , user_ns ) , task_uid ( tsk ) ) ; rcu_read_unlock ( ) ; task_cputime ( tsk , & utime , & stime ) ; info . si_utime = nsec_to_clock_t ( utime + tsk -> signal -> utime ) ; info . si_stime = nsec_to_clock_t ( stime + tsk -> signal -> stime ) ; info . si_status = tsk -> exit_code & 0x7f ; if ( tsk -> exit_code & 0x80 ) info . si_code = CLD_DUMPED ; else if ( tsk -> exit_code & 0x7f ) info . si_code = CLD_KILLED ; else { info . si_code = CLD_EXITED ; info . si_status = tsk -> exit_code >> 8 ; } psig = tsk -> parent -> sighand ; spin_lock_irqsave ( & psig -> siglock , flags ) ; if ( ! tsk -> ptrace && sig == SIGCHLD && ( psig -> action [ SIGCHLD - 1 ] . sa . sa_handler == SIG_IGN || ( psig -> action [ SIGCHLD - 1 ] . sa . sa_flags & SA_NOCLDWAIT ) ) ) { autoreap = true ; if ( psig -> action [ SIGCHLD - 1 ] . sa . sa_handler == SIG_IGN ) sig = 0 ; } if ( valid_signal ( sig ) && sig ) __group_send_sig_info ( sig , & info , tsk -> parent ) ; __wake_up_parent ( tsk , tsk -> parent ) ; spin_unlock_irqrestore ( & psig -> siglock , flags ) ; return autoreap ; }", "target": "<S2SV_ModStart> -> parent_exec_id != READ_ONCE ( <S2SV_ModStart> parent -> self_exec_id )"}
{"source": "CWE-787 static struct ip * ip_reass ( Slirp * slirp , struct ip * ip , struct ipq * fp ) { register struct mbuf * m = dtom ( slirp , ip ) ; register struct ipasfrag * q ; int hlen = ip -> ip_hl << 2 ; int i , next ; DEBUG_CALL ( \"ip_reass\" ) ; DEBUG_ARG ( \"ip<S2SV_blank>=<S2SV_blank>%p\" , ip ) ; DEBUG_ARG ( \"fp<S2SV_blank>=<S2SV_blank>%p\" , fp ) ; DEBUG_ARG ( \"m<S2SV_blank>=<S2SV_blank>%p\" , m ) ; m -> m_data += hlen ; m -> m_len -= hlen ; if ( fp == NULL ) { struct mbuf * t = m_get ( slirp ) ; if ( t == NULL ) { goto dropfrag ; } fp = mtod ( t , struct ipq * ) ; insque ( & fp -> ip_link , & slirp -> ipq . ip_link ) ; fp -> ipq_ttl = IPFRAGTTL ; fp -> ipq_p = ip -> ip_p ; fp -> ipq_id = ip -> ip_id ; fp -> frag_link . next = fp -> frag_link . prev = & fp -> frag_link ; fp -> ipq_src = ip -> ip_src ; fp -> ipq_dst = ip -> ip_dst ; q = ( struct ipasfrag * ) fp ; goto insert ; } for ( q = fp -> frag_link . next ; q != ( struct ipasfrag * ) & fp -> frag_link ; q = q -> ipf_next ) if ( q -> ipf_off > ip -> ip_off ) break ; if ( q -> ipf_prev != & fp -> frag_link ) { struct ipasfrag * pq = q -> ipf_prev ; i = pq -> ipf_off + pq -> ipf_len - ip -> ip_off ; if ( i > 0 ) { if ( i >= ip -> ip_len ) goto dropfrag ; m_adj ( dtom ( slirp , ip ) , i ) ; ip -> ip_off += i ; ip -> ip_len -= i ; } } while ( q != ( struct ipasfrag * ) & fp -> frag_link && ip -> ip_off + ip -> ip_len > q -> ipf_off ) { i = ( ip -> ip_off + ip -> ip_len ) - q -> ipf_off ; if ( i < q -> ipf_len ) { q -> ipf_len -= i ; q -> ipf_off += i ; m_adj ( dtom ( slirp , q ) , i ) ; break ; } q = q -> ipf_next ; m_free ( dtom ( slirp , q -> ipf_prev ) ) ; ip_deq ( q -> ipf_prev ) ; } insert : ip_enq ( iptofrag ( ip ) , q -> ipf_prev ) ; next = 0 ; for ( q = fp -> frag_link . next ; q != ( struct ipasfrag * ) & fp -> frag_link ; q = q -> ipf_next ) { if ( q -> ipf_off != next ) return NULL ; next += q -> ipf_len ; } if ( ( ( struct ipasfrag * ) ( q -> ipf_prev ) ) -> ipf_tos & 1 ) return NULL ; q = fp -> frag_link . next ; m = dtom ( slirp , q ) ; <S2SV_StartBug> q = ( struct ipasfrag * ) q -> ipf_next ; <S2SV_EndBug> while ( q != ( struct ipasfrag * ) & fp -> frag_link ) { struct mbuf * t = dtom ( slirp , q ) ; q = ( struct ipasfrag * ) q -> ipf_next ; m_cat ( m , t ) ; } q = fp -> frag_link . next ; <S2SV_StartBug> if ( m -> m_flags & M_EXT ) { <S2SV_EndBug> int delta = ( char * ) q - m -> m_dat ; q = ( struct ipasfrag * ) ( m -> m_ext + delta ) ; } ip = fragtoip ( q ) ; ip -> ip_len = next ; ip -> ip_tos &= ~ 1 ; ip -> ip_src = fp -> ipq_src ; ip -> ip_dst = fp -> ipq_dst ; remque ( & fp -> ip_link ) ; ( void ) m_free ( dtom ( slirp , fp ) ) ; m -> m_len += ( ip -> ip_hl << 2 ) ; m -> m_data -= ( ip -> ip_hl << 2 ) ; return ip ; dropfrag : m_free ( m ) ; return NULL ; }", "target": "<S2SV_ModStart> q ) ; int was_ext = m -> m_flags & M_EXT ; <S2SV_ModStart> ; if ( ! was_ext &&"}
{"source": "CWE-706 int url_is_local_not_ssh ( const char * url ) { const char * colon = strchr ( url , ':' ) ; const char * slash = strchr ( url , '/' ) ; return ! colon || ( slash && slash < colon ) || <S2SV_StartBug> has_dos_drive_prefix ( url ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> colon ) || ( <S2SV_ModStart> has_dos_drive_prefix ( url ) && is_valid_path ( url )"}
{"source": "CWE-416 int nested_svm_vmrun ( struct vcpu_svm * svm ) { int ret ; struct vmcb * vmcb12 ; struct vmcb * hsave = svm -> nested . hsave ; struct vmcb * vmcb = svm -> vmcb ; struct kvm_host_map map ; u64 vmcb12_gpa ; if ( is_smm ( & svm -> vcpu ) ) { kvm_queue_exception ( & svm -> vcpu , UD_VECTOR ) ; return 1 ; } vmcb12_gpa = svm -> vmcb -> save . rax ; ret = kvm_vcpu_map ( & svm -> vcpu , gpa_to_gfn ( vmcb12_gpa ) , & map ) ; if ( ret == - EINVAL ) { kvm_inject_gp ( & svm -> vcpu , 0 ) ; return 1 ; } else if ( ret ) { return kvm_skip_emulated_instruction ( & svm -> vcpu ) ; } ret = kvm_skip_emulated_instruction ( & svm -> vcpu ) ; vmcb12 = map . hva ; if ( WARN_ON_ONCE ( ! svm -> nested . initialized ) ) return - EINVAL ; <S2SV_StartBug> if ( ! nested_vmcb_checks ( svm , vmcb12 ) ) { <S2SV_EndBug> vmcb12 -> control . exit_code = SVM_EXIT_ERR ; vmcb12 -> control . exit_code_hi = 0 ; vmcb12 -> control . exit_info_1 = 0 ; vmcb12 -> control . exit_info_2 = 0 ; goto out ; } trace_kvm_nested_vmrun ( svm -> vmcb -> save . rip , vmcb12_gpa , vmcb12 -> save . rip , vmcb12 -> control . int_ctl , vmcb12 -> control . event_inj , vmcb12 -> control . nested_ctl ) ; trace_kvm_nested_intercepts ( vmcb12 -> control . intercepts [ INTERCEPT_CR ] & 0xffff , vmcb12 -> control . intercepts [ INTERCEPT_CR ] >> 16 , vmcb12 -> control . intercepts [ INTERCEPT_EXCEPTION ] , vmcb12 -> control . intercepts [ INTERCEPT_WORD3 ] , vmcb12 -> control . intercepts [ INTERCEPT_WORD4 ] , vmcb12 -> control . intercepts [ INTERCEPT_WORD5 ] ) ; kvm_clear_exception_queue ( & svm -> vcpu ) ; kvm_clear_interrupt_queue ( & svm -> vcpu ) ; hsave -> save . es = vmcb -> save . es ; hsave -> save . cs = vmcb -> save . cs ; hsave -> save . ss = vmcb -> save . ss ; hsave -> save . ds = vmcb -> save . ds ; hsave -> save . gdtr = vmcb -> save . gdtr ; hsave -> save . idtr = vmcb -> save . idtr ; hsave -> save . efer = svm -> vcpu . arch . efer ; hsave -> save . cr0 = kvm_read_cr0 ( & svm -> vcpu ) ; hsave -> save . cr4 = svm -> vcpu . arch . cr4 ; hsave -> save . rflags = kvm_get_rflags ( & svm -> vcpu ) ; hsave -> save . rip = kvm_rip_read ( & svm -> vcpu ) ; hsave -> save . rsp = vmcb -> save . rsp ; hsave -> save . rax = vmcb -> save . rax ; if ( npt_enabled ) hsave -> save . cr3 = vmcb -> save . cr3 ; else hsave -> save . cr3 = kvm_read_cr3 ( & svm -> vcpu ) ; copy_vmcb_control_area ( & hsave -> control , & vmcb -> control ) ; svm -> nested . nested_run_pending = 1 ; if ( enter_svm_guest_mode ( svm , vmcb12_gpa , vmcb12 ) ) goto out_exit_err ; if ( nested_svm_vmrun_msrpm ( svm ) ) goto out ; out_exit_err : svm -> nested . nested_run_pending = 0 ; svm -> vmcb -> control . exit_code = SVM_EXIT_ERR ; svm -> vmcb -> control . exit_code_hi = 0 ; svm -> vmcb -> control . exit_info_1 = 0 ; svm -> vmcb -> control . exit_info_2 = 0 ; nested_svm_vmexit ( svm ) ; out : kvm_vcpu_unmap ( & svm -> vcpu , & map , true ) ; return ret ; }", "target": "<S2SV_ModStart> - EINVAL ; load_nested_vmcb_control ( svm , & vmcb12 -> control ) ; <S2SV_ModStart> if ( ! nested_vmcb_check_save ( svm , vmcb12 ) || ! nested_vmcb_check_controls ( & svm -> nested . ctl <S2SV_ModEnd> ) ) {"}
{"source": "CWE-703 static avifBool avifParseImageGridBox ( avifImageGrid * grid , const uint8_t * raw , size_t rawLen ) { BEGIN_STREAM ( s , raw , rawLen ) ; uint8_t version , flags ; CHECK ( avifROStreamRead ( & s , & version , 1 ) ) ; if ( version != 0 ) { return AVIF_FALSE ; } CHECK ( avifROStreamRead ( & s , & flags , 1 ) ) ; CHECK ( avifROStreamRead ( & s , & grid -> rows , 1 ) ) ; CHECK ( avifROStreamRead ( & s , & grid -> columns , 1 ) ) ; ++ grid -> rows ; ++ grid -> columns ; uint32_t fieldLength = ( ( flags & 1 ) + 1 ) * 16 ; if ( fieldLength == 16 ) { uint16_t outputWidth16 , outputHeight16 ; CHECK ( avifROStreamReadU16 ( & s , & outputWidth16 ) ) ; CHECK ( avifROStreamReadU16 ( & s , & outputHeight16 ) ) ; grid -> outputWidth = outputWidth16 ; grid -> outputHeight = outputHeight16 ; } else { if ( fieldLength != 32 ) { return AVIF_FALSE ; } CHECK ( avifROStreamReadU32 ( & s , & grid -> outputWidth ) ) ; CHECK ( avifROStreamReadU32 ( & s , & grid -> outputHeight ) ) ; } <S2SV_StartBug> return AVIF_TRUE ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ) ; } if ( grid -> outputWidth > AVIF_MAX_IMAGE_SIZE / grid -> outputHeight ) { return AVIF_FALSE ; }"}
{"source": "CWE-755 static int codeCompare ( Parse * pParse , Expr * pLeft , Expr * pRight , int opcode , int in1 , int in2 , int dest , int jumpIfNull , int isCommuted ) { int p5 ; int addr ; CollSeq * p4 ; <S2SV_StartBug> <S2SV_EndBug> if ( isCommuted ) { p4 = sqlite3BinaryCompareCollSeq ( pParse , pRight , pLeft ) ; } else { p4 = sqlite3BinaryCompareCollSeq ( pParse , pLeft , pRight ) ; } p5 = binaryCompareP5 ( pLeft , pRight , jumpIfNull ) ; addr = sqlite3VdbeAddOp4 ( pParse -> pVdbe , opcode , in2 , dest , in1 , ( void * ) p4 , P4_COLLSEQ ) ; sqlite3VdbeChangeP5 ( pParse -> pVdbe , ( u8 ) p5 ) ; return addr ; }", "target": "<S2SV_ModStart> * p4 ; if ( pParse -> nErr ) return 0 ;"}
{"source": "CWE-755 static void vdbeVComment ( Vdbe * p , const char * zFormat , va_list ap ) { assert ( p -> nOp > 0 || p -> aOp == 0 ) ; <S2SV_StartBug> assert ( p -> aOp == 0 || p -> aOp [ p -> nOp - 1 ] . zComment == 0 || p -> db -> mallocFailed ) ; <S2SV_EndBug> if ( p -> nOp ) { assert ( p -> aOp ) ; sqlite3DbFree ( p -> db , p -> aOp [ p -> nOp - 1 ] . zComment ) ; p -> aOp [ p -> nOp - 1 ] . zComment = sqlite3VMPrintf ( p -> db , zFormat , ap ) ; } }", "target": "<S2SV_ModStart> db -> mallocFailed || p -> pParse -> nErr > 0"}
{"source": "CWE-755 int sqlite3WindowRewrite ( Parse * pParse , Select * p ) { int rc = SQLITE_OK ; if ( p -> pWin && p -> pPrior == 0 && ( p -> selFlags & SF_WinRewrite ) == 0 ) { Vdbe * v = sqlite3GetVdbe ( pParse ) ; sqlite3 * db = pParse -> db ; Select * pSub = 0 ; SrcList * pSrc = p -> pSrc ; Expr * pWhere = p -> pWhere ; ExprList * pGroupBy = p -> pGroupBy ; Expr * pHaving = p -> pHaving ; ExprList * pSort = 0 ; ExprList * pSublist = 0 ; Window * pMWin = p -> pWin ; Window * pWin ; Table * pTab ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) { <S2SV_StartBug> return SQLITE_NOMEM ; <S2SV_EndBug> } p -> pSrc = 0 ; p -> pWhere = 0 ; p -> pGroupBy = 0 ; p -> pHaving = 0 ; p -> selFlags &= ~ SF_Aggregate ; p -> selFlags |= SF_WinRewrite ; pSort = sqlite3ExprListDup ( db , pMWin -> pPartition , 0 ) ; pSort = exprListAppendList ( pParse , pSort , pMWin -> pOrderBy , 1 ) ; if ( pSort && p -> pOrderBy && p -> pOrderBy -> nExpr <= pSort -> nExpr ) { int nSave = pSort -> nExpr ; pSort -> nExpr = p -> pOrderBy -> nExpr ; if ( sqlite3ExprListCompare ( pSort , p -> pOrderBy , - 1 ) == 0 ) { sqlite3ExprListDelete ( db , p -> pOrderBy ) ; p -> pOrderBy = 0 ; } pSort -> nExpr = nSave ; } pMWin -> iEphCsr = pParse -> nTab ++ ; pParse -> nTab += 3 ; selectWindowRewriteEList ( pParse , pMWin , pSrc , p -> pEList , pTab , & pSublist ) ; selectWindowRewriteEList ( pParse , pMWin , pSrc , p -> pOrderBy , pTab , & pSublist ) ; pMWin -> nBufferCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pMWin -> pPartition , 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pMWin -> pOrderBy , 0 ) ; for ( pWin = pMWin ; pWin ; pWin = pWin -> pNextWin ) { ExprList * pArgs = pWin -> pOwner -> x . pList ; if ( pWin -> pFunc -> funcFlags & SQLITE_FUNC_SUBTYPE ) { selectWindowRewriteEList ( pParse , pMWin , pSrc , pArgs , pTab , & pSublist ) ; pWin -> iArgCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pWin -> bExprArgs = 1 ; } else { pWin -> iArgCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pArgs , 0 ) ; } if ( pWin -> pFilter ) { Expr * pFilter = sqlite3ExprDup ( db , pWin -> pFilter , 0 ) ; pSublist = sqlite3ExprListAppend ( pParse , pSublist , pFilter ) ; } pWin -> regAccum = ++ pParse -> nMem ; pWin -> regResult = ++ pParse -> nMem ; sqlite3VdbeAddOp2 ( v , OP_Null , 0 , pWin -> regAccum ) ; } if ( pSublist == 0 ) { pSublist = sqlite3ExprListAppend ( pParse , 0 , sqlite3Expr ( db , TK_INTEGER , \"0\" ) ) ; } pSub = sqlite3SelectNew ( pParse , pSublist , pSrc , pWhere , pGroupBy , pHaving , pSort , 0 , 0 ) ; p -> pSrc = sqlite3SrcListAppend ( pParse , 0 , 0 , 0 ) ; if ( p -> pSrc ) { Table * pTab2 ; p -> pSrc -> a [ 0 ] . pSelect = pSub ; sqlite3SrcListAssignCursors ( pParse , p -> pSrc ) ; pSub -> selFlags |= SF_Expanded ; pTab2 = sqlite3ResultSetOfSelect ( pParse , pSub , SQLITE_AFF_NONE ) ; if ( pTab2 == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pTab , pTab2 , sizeof ( Table ) ) ; pTab -> tabFlags |= TF_Ephemeral ; p -> pSrc -> a [ 0 ] . pTab = pTab ; pTab = pTab2 ; } sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pMWin -> iEphCsr , pSublist -> nExpr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 1 , pMWin -> iEphCsr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 2 , pMWin -> iEphCsr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 3 , pMWin -> iEphCsr ) ; } else { sqlite3SelectDelete ( db , pSub ) ; } if ( db -> mallocFailed ) rc = SQLITE_NOMEM ; sqlite3DbFree ( db , pTab ) ; } <S2SV_StartBug> return rc ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ) { return sqlite3ErrorToParser ( db , SQLITE_NOMEM ) <S2SV_ModEnd> ; } p <S2SV_ModStart> ) ; } if ( rc && pParse -> nErr == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ; }"}
{"source": "CWE-119 ansicstr ( string , len , flags , sawc , rlen ) char * string ; int len , flags , * sawc , * rlen ; { int c , temp ; char * ret , * r , * s ; unsigned long v ; if ( string == 0 || * string == '\\\\0' ) return ( ( char * ) NULL ) ; # if defined ( HANDLE_MULTIBYTE ) <S2SV_StartBug> if ( strstr ( string , \"\\\\\\\\U\" ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ret = ( char * ) xmalloc ( 6 * len + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> ret = ( char * ) xmalloc ( 4 * len + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> ret = ( char * ) xmalloc ( 2 * len + 1 ) ; # endif for ( r = ret , s = string ; s && * s ; ) { c = * s ++ ; if ( c != '\\\\\\\\' || * s == '\\\\0' ) * r ++ = c ; else { switch ( c = * s ++ ) { # if defined ( __STDC__ ) case 'a' : c = '\\\\a' ; break ; case 'v' : c = '\\\\v' ; break ; # else case 'a' : c = ( int ) 0x07 ; break ; case 'v' : c = ( int ) 0x0B ; break ; # endif case 'b' : c = '\\\\b' ; break ; case 'e' : case 'E' : c = ESC ; break ; case 'f' : c = '\\\\f' ; break ; case 'n' : c = '\\\\n' ; break ; case 'r' : c = '\\\\r' ; break ; case 't' : c = '\\\\t' ; break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : # if 1 if ( flags & 1 ) { * r ++ = '\\\\\\\\' ; break ; } # endif case '0' : temp = 2 + ( ( flags & 1 ) && ( c == '0' ) ) ; for ( c -= '0' ; ISOCTAL ( * s ) && temp -- ; s ++ ) c = ( c * 8 ) + OCTVALUE ( * s ) ; c &= 0xFF ; break ; case 'x' : if ( ( flags & 2 ) && * s == '{' ) { flags |= 16 ; s ++ ; } for ( temp = 2 , c = 0 ; ISXDIGIT ( ( unsigned char ) * s ) && temp -- ; s ++ ) c = ( c * 16 ) + HEXVALUE ( * s ) ; if ( flags & 16 ) { for ( ; ISXDIGIT ( ( unsigned char ) * s ) ; s ++ ) c = ( c * 16 ) + HEXVALUE ( * s ) ; flags &= ~ 16 ; if ( * s == '}' ) s ++ ; } else if ( temp == 2 ) { * r ++ = '\\\\\\\\' ; c = 'x' ; } c &= 0xFF ; break ; # if defined ( HANDLE_MULTIBYTE ) case 'u' : case 'U' : temp = ( c == 'u' ) ? 4 : 8 ; for ( v = 0 ; ISXDIGIT ( ( unsigned char ) * s ) && temp -- ; s ++ ) v = ( v * 16 ) + HEXVALUE ( * s ) ; if ( temp == ( ( c == 'u' ) ? 4 : 8 ) ) { * r ++ = '\\\\\\\\' ; break ; } else if ( v <= 0x7f ) { c = v ; break ; } else { temp = u32cconv ( v , r ) ; r += temp ; continue ; } # endif case '\\\\\\\\' : break ; case '\\\\'' : case \\'\"\\' : case '?' : if ( flags & 1 ) * r ++ = '\\\\\\\\' ; break ; case 'c' : if ( sawc ) { * sawc = 1 ; * r = '\\\\0' ; if ( rlen ) * rlen = r - ret ; return ret ; } else if ( ( flags & 1 ) == 0 && * s == 0 ) ; else if ( ( flags & 1 ) == 0 && ( c = * s ) ) { s ++ ; if ( ( flags & 2 ) && c == '\\\\\\\\' && c == * s ) s ++ ; c = TOCTRL ( c ) ; break ; } default : if ( ( flags & 4 ) == 0 ) * r ++ = '\\\\\\\\' ; break ; } if ( ( flags & 2 ) && ( c == CTLESC || c == CTLNUL ) ) * r ++ = CTLESC ; * r ++ = c ; } } * r = '\\\\0' ; if ( rlen ) * rlen = r - ret ; return ret ; }", "target": "<S2SV_ModStart> ( HANDLE_MULTIBYTE ) <S2SV_ModEnd> ret = ( <S2SV_ModStart> ) xmalloc ( 4 <S2SV_ModEnd> * len + <S2SV_ModStart> 1 ) ; # <S2SV_ModStart> ) xmalloc ( 2 <S2SV_ModEnd> * len + <S2SV_ModStart> ) ; # <S2SV_ModEnd> endif for ("}
{"source": "CWE-200 get_word_rgb_row ( j_compress_ptr cinfo , cjpeg_source_ptr sinfo ) { ppm_source_ptr source = ( ppm_source_ptr ) sinfo ; register JSAMPROW ptr ; register U_CHAR * bufferptr ; register JSAMPLE * rescale = source -> rescale ; JDIMENSION col ; <S2SV_StartBug> unsigned int maxval = source -> maxval ; <S2SV_EndBug> if ( ! ReadOK ( source -> pub . input_file , source -> iobuffer , source -> buffer_width ) ) ERREXIT ( cinfo , JERR_INPUT_EOF ) ; ptr = source -> pub . buffer [ 0 ] ; bufferptr = source -> iobuffer ; for ( col = cinfo -> image_width ; col > 0 ; col -- ) { register unsigned int temp ; temp = UCH ( * bufferptr ++ ) << 8 ; temp |= UCH ( * bufferptr ++ ) ; if ( temp > maxval ) ERREXIT ( cinfo , JERR_PPM_OUTOFRANGE ) ; <S2SV_StartBug> * ptr ++ = rescale [ temp ] ; <S2SV_EndBug> temp = UCH ( * bufferptr ++ ) << 8 ; temp |= UCH ( * bufferptr ++ ) ; if ( temp > maxval ) ERREXIT ( cinfo , JERR_PPM_OUTOFRANGE ) ; <S2SV_StartBug> * ptr ++ = rescale [ temp ] ; <S2SV_EndBug> temp = UCH ( * bufferptr ++ ) << 8 ; temp |= UCH ( * bufferptr ++ ) ; if ( temp > maxval ) ERREXIT ( cinfo , JERR_PPM_OUTOFRANGE ) ; <S2SV_StartBug> * ptr ++ = rescale [ temp ] ; <S2SV_EndBug> } return 1 ; }", "target": "<S2SV_ModStart> source -> maxval ; register int rindex = rgb_red [ cinfo -> in_color_space ] ; register int gindex = rgb_green [ cinfo -> in_color_space ] ; register int bindex = rgb_blue [ cinfo -> in_color_space ] ; register int aindex = alpha_index [ cinfo -> in_color_space ] ; register int ps = rgb_pixelsize [ cinfo -> in_color_space ] <S2SV_ModStart> JERR_PPM_OUTOFRANGE ) ; ptr [ rindex ] <S2SV_ModEnd> = rescale [ <S2SV_ModStart> JERR_PPM_OUTOFRANGE ) ; ptr [ gindex ] <S2SV_ModEnd> = rescale [ <S2SV_ModStart> JERR_PPM_OUTOFRANGE ) ; ptr [ bindex ] = rescale [ temp ] ; if ( aindex >= 0 ) ptr [ aindex ] = 0xFF ; ptr += ps <S2SV_ModEnd> ; } return"}
{"source": "CWE-125 static int iscsi_if_recv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh , uint32_t * group ) { int err = 0 ; <S2SV_StartBug> u32 portid ; <S2SV_EndBug> struct iscsi_uevent * ev = nlmsg_data ( nlh ) ; struct iscsi_transport * transport = NULL ; struct iscsi_internal * priv ; struct iscsi_cls_session * session ; struct iscsi_cls_conn * conn ; struct iscsi_endpoint * ep = NULL ; if ( ! netlink_capable ( skb , CAP_SYS_ADMIN ) ) return - EPERM ; if ( nlh -> nlmsg_type == ISCSI_UEVENT_PATH_UPDATE ) * group = ISCSI_NL_GRP_UIP ; else * group = ISCSI_NL_GRP_ISCSID ; priv = iscsi_if_transport_lookup ( iscsi_ptr ( ev -> transport_handle ) ) ; if ( ! priv ) return - EINVAL ; transport = priv -> iscsi_transport ; if ( ! try_module_get ( transport -> owner ) ) return - EINVAL ; portid = NETLINK_CB ( skb ) . portid ; switch ( nlh -> nlmsg_type ) { case ISCSI_UEVENT_CREATE_SESSION : err = iscsi_if_create_session ( priv , ep , ev , portid , ev -> u . c_session . initial_cmdsn , ev -> u . c_session . cmds_max , ev -> u . c_session . queue_depth ) ; break ; case ISCSI_UEVENT_CREATE_BOUND_SESSION : ep = iscsi_lookup_endpoint ( ev -> u . c_bound_session . ep_handle ) ; if ( ! ep ) { err = - EINVAL ; break ; } err = iscsi_if_create_session ( priv , ep , ev , portid , ev -> u . c_bound_session . initial_cmdsn , ev -> u . c_bound_session . cmds_max , ev -> u . c_bound_session . queue_depth ) ; break ; case ISCSI_UEVENT_DESTROY_SESSION : session = iscsi_session_lookup ( ev -> u . d_session . sid ) ; if ( ! session ) err = - EINVAL ; else if ( iscsi_session_has_conns ( ev -> u . d_session . sid ) ) err = - EBUSY ; else transport -> destroy_session ( session ) ; break ; case ISCSI_UEVENT_DESTROY_SESSION_ASYNC : session = iscsi_session_lookup ( ev -> u . d_session . sid ) ; if ( ! session ) err = - EINVAL ; else if ( iscsi_session_has_conns ( ev -> u . d_session . sid ) ) err = - EBUSY ; else { unsigned long flags ; spin_lock_irqsave ( & sesslock , flags ) ; list_del_init ( & session -> sess_list ) ; spin_unlock_irqrestore ( & sesslock , flags ) ; queue_work ( iscsi_destroy_workq , & session -> destroy_work ) ; } break ; case ISCSI_UEVENT_UNBIND_SESSION : session = iscsi_session_lookup ( ev -> u . d_session . sid ) ; if ( session ) scsi_queue_work ( iscsi_session_to_shost ( session ) , & session -> unbind_work ) ; else err = - EINVAL ; break ; case ISCSI_UEVENT_CREATE_CONN : err = iscsi_if_create_conn ( transport , ev ) ; break ; case ISCSI_UEVENT_DESTROY_CONN : err = iscsi_if_destroy_conn ( transport , ev ) ; break ; case ISCSI_UEVENT_BIND_CONN : session = iscsi_session_lookup ( ev -> u . b_conn . sid ) ; conn = iscsi_conn_lookup ( ev -> u . b_conn . sid , ev -> u . b_conn . cid ) ; if ( conn && conn -> ep ) iscsi_if_ep_disconnect ( transport , conn -> ep -> id ) ; if ( ! session || ! conn ) { err = - EINVAL ; break ; } mutex_lock ( & conn_mutex ) ; ev -> r . retcode = transport -> bind_conn ( session , conn , ev -> u . b_conn . transport_eph , ev -> u . b_conn . is_leading ) ; mutex_unlock ( & conn_mutex ) ; if ( ev -> r . retcode || ! transport -> ep_connect ) break ; ep = iscsi_lookup_endpoint ( ev -> u . b_conn . transport_eph ) ; if ( ep ) { ep -> conn = conn ; mutex_lock ( & conn -> ep_mutex ) ; conn -> ep = ep ; mutex_unlock ( & conn -> ep_mutex ) ; } else iscsi_cls_conn_printk ( KERN_ERR , conn , \"Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>ep<S2SV_blank>conn<S2SV_blank>\" \"binding\\\\n\" ) ; break ; case ISCSI_UEVENT_SET_PARAM : err = iscsi_set_param ( transport , ev ) ; break ; case ISCSI_UEVENT_START_CONN : conn = iscsi_conn_lookup ( ev -> u . start_conn . sid , ev -> u . start_conn . cid ) ; if ( conn ) { mutex_lock ( & conn_mutex ) ; ev -> r . retcode = transport -> start_conn ( conn ) ; if ( ! ev -> r . retcode ) conn -> state = ISCSI_CONN_UP ; mutex_unlock ( & conn_mutex ) ; } else err = - EINVAL ; break ; case ISCSI_UEVENT_STOP_CONN : conn = iscsi_conn_lookup ( ev -> u . stop_conn . sid , ev -> u . stop_conn . cid ) ; if ( conn ) iscsi_if_stop_conn ( conn , ev -> u . stop_conn . flag ) ; else err = - EINVAL ; break ; case ISCSI_UEVENT_SEND_PDU : <S2SV_StartBug> conn = iscsi_conn_lookup ( ev -> u . send_pdu . sid , ev -> u . send_pdu . cid ) ; <S2SV_EndBug> if ( conn ) { mutex_lock ( & conn_mutex ) ; ev -> r . retcode = transport -> send_pdu ( conn , ( struct iscsi_hdr * ) ( ( char * ) ev + sizeof ( * ev ) ) , ( char * ) ev + sizeof ( * ev ) + ev -> u . send_pdu . hdr_size , ev -> u . send_pdu . data_size ) ; mutex_unlock ( & conn_mutex ) ; } else err = - EINVAL ; break ; case ISCSI_UEVENT_GET_STATS : err = iscsi_if_get_stats ( transport , nlh ) ; break ; case ISCSI_UEVENT_TRANSPORT_EP_CONNECT : case ISCSI_UEVENT_TRANSPORT_EP_POLL : case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT : case ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST : err = iscsi_if_transport_ep ( transport , ev , nlh -> nlmsg_type ) ; break ; case ISCSI_UEVENT_TGT_DSCVR : err = iscsi_tgt_dscvr ( transport , ev ) ; break ; case ISCSI_UEVENT_SET_HOST_PARAM : err = iscsi_set_host_param ( transport , ev ) ; break ; case ISCSI_UEVENT_PATH_UPDATE : err = iscsi_set_path ( transport , ev ) ; break ; case ISCSI_UEVENT_SET_IFACE_PARAMS : err = iscsi_set_iface_params ( transport , ev , nlmsg_attrlen ( nlh , sizeof ( * ev ) ) ) ; break ; case ISCSI_UEVENT_PING : err = iscsi_send_ping ( transport , ev ) ; break ; case ISCSI_UEVENT_GET_CHAP : err = iscsi_get_chap ( transport , nlh ) ; break ; case ISCSI_UEVENT_DELETE_CHAP : err = iscsi_delete_chap ( transport , ev ) ; break ; case ISCSI_UEVENT_SET_FLASHNODE_PARAMS : err = iscsi_set_flashnode_param ( transport , ev , nlmsg_attrlen ( nlh , sizeof ( * ev ) ) ) ; break ; case ISCSI_UEVENT_NEW_FLASHNODE : err = iscsi_new_flashnode ( transport , ev , nlmsg_attrlen ( nlh , sizeof ( * ev ) ) ) ; break ; case ISCSI_UEVENT_DEL_FLASHNODE : err = iscsi_del_flashnode ( transport , ev ) ; break ; case ISCSI_UEVENT_LOGIN_FLASHNODE : err = iscsi_login_flashnode ( transport , ev ) ; break ; case ISCSI_UEVENT_LOGOUT_FLASHNODE : err = iscsi_logout_flashnode ( transport , ev ) ; break ; case ISCSI_UEVENT_LOGOUT_FLASHNODE_SID : err = iscsi_logout_flashnode_sid ( transport , ev ) ; break ; case ISCSI_UEVENT_SET_CHAP : err = iscsi_set_chap ( transport , ev , nlmsg_attrlen ( nlh , sizeof ( * ev ) ) ) ; break ; case ISCSI_UEVENT_GET_HOST_STATS : err = iscsi_get_host_stats ( transport , nlh ) ; break ; default : err = - ENOSYS ; break ; }", "target": "<S2SV_ModStart> ; u32 portid ; u32 pdu_len <S2SV_ModStart> case ISCSI_UEVENT_SEND_PDU : pdu_len = nlh -> nlmsg_len - sizeof ( * nlh ) - sizeof ( * ev ) ; if ( ( ev -> u . send_pdu . hdr_size > pdu_len ) || ( ev -> u . send_pdu . data_size > ( pdu_len - ev -> u . send_pdu . hdr_size ) ) ) { err = - EINVAL ; break ; }"}
{"source": "CWE-476 static struct property * dlpar_parse_cc_property ( struct cc_workarea * ccwa ) { struct property * prop ; char * name ; char * value ; prop = kzalloc ( sizeof ( * prop ) , GFP_KERNEL ) ; if ( ! prop ) return NULL ; name = ( char * ) ccwa + be32_to_cpu ( ccwa -> name_offset ) ; prop -> name = kstrdup ( name , GFP_KERNEL ) ; <S2SV_StartBug> <S2SV_EndBug> prop -> length = be32_to_cpu ( ccwa -> prop_length ) ; value = ( char * ) ccwa + be32_to_cpu ( ccwa -> prop_offset ) ; prop -> value = kmemdup ( value , prop -> length , GFP_KERNEL ) ; if ( ! prop -> value ) { dlpar_free_cc_property ( prop ) ; return NULL ; } return prop ; }", "target": "<S2SV_ModStart> GFP_KERNEL ) ; if ( ! prop -> name ) { dlpar_free_cc_property ( prop ) ; return NULL ; }"}
{"source": "CWE-125 static Image * ReadHEICImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const char * option ; const StringInfo * profile ; heif_item_id exif_id ; Image * image ; int count , stride_y , stride_cb , stride_cr ; MagickBooleanType status ; size_t length ; ssize_t y ; struct heif_context * heif_context ; struct heif_decoding_options * decode_options ; struct heif_error error ; struct heif_image * heif_image ; struct heif_image_handle * image_handle ; const uint8_t * p_y , * p_cb , * p_cr ; void * file_data ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( GetBlobSize ( image ) > ( MagickSizeType ) SSIZE_MAX ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; length = ( size_t ) GetBlobSize ( image ) ; file_data = AcquireMagickMemory ( length ) ; if ( file_data == ( void * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( ReadBlob ( image , length , ( unsigned char * ) file_data ) != ( ssize_t ) length ) { file_data = RelinquishMagickMemory ( file_data ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } heif_context = heif_context_alloc ( ) ; error = heif_context_read_from_memory_without_copy ( heif_context , file_data , length , NULL ) ; if ( IsHeifSuccess ( & error , image ) == MagickFalse ) { heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; return ( DestroyImageList ( image ) ) ; } image_handle = ( struct heif_image_handle * ) NULL ; error = heif_context_get_primary_image_handle ( heif_context , & image_handle ) ; if ( IsHeifSuccess ( & error , image ) == MagickFalse ) { heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; return ( DestroyImageList ( image ) ) ; } # if LIBHEIF_NUMERIC_VERSION >= 0x01040000 length = heif_image_handle_get_raw_color_profile_size ( image_handle ) ; if ( length > 0 ) { unsigned char * color_buffer ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) { heif_image_handle_release ( image_handle ) ; heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } color_buffer = ( unsigned char * ) AcquireMagickMemory ( length ) ; if ( color_buffer != ( unsigned char * ) NULL ) { error = heif_image_handle_get_raw_color_profile ( image_handle , color_buffer ) ; if ( error . code == 0 ) { StringInfo * profile ; profile = BlobToStringInfo ( color_buffer , length ) ; if ( profile != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( image , \"icc\" , profile ) ; profile = DestroyStringInfo ( profile ) ; } } } color_buffer = ( unsigned char * ) RelinquishMagickMemory ( color_buffer ) ; } # endif count = heif_image_handle_get_list_of_metadata_block_IDs ( image_handle , \"Exif\" , & exif_id , 1 ) ; if ( count > 0 ) { size_t exif_size ; unsigned char * exif_buffer ; exif_size = heif_image_handle_get_metadata_size ( image_handle , exif_id ) ; if ( ( MagickSizeType ) exif_size > GetBlobSize ( image ) ) { heif_image_handle_release ( image_handle ) ; heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } exif_buffer = ( unsigned char * ) AcquireMagickMemory ( exif_size ) ; if ( exif_buffer != ( unsigned char * ) NULL ) { error = heif_image_handle_get_metadata ( image_handle , exif_id , exif_buffer ) ; if ( error . code == 0 ) { StringInfo * profile ; profile = ( StringInfo * ) NULL ; if ( exif_size > 8 ) profile = BlobToStringInfo ( exif_buffer + 4 , ( size_t ) exif_size - 4 ) ; if ( profile != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( image , \"exif\" , profile ) ; profile = DestroyStringInfo ( profile ) ; } } } exif_buffer = ( unsigned char * ) RelinquishMagickMemory ( exif_buffer ) ; } image -> depth = 8 ; image -> columns = ( size_t ) heif_image_handle_get_width ( image_handle ) ; image -> rows = ( size_t ) heif_image_handle_get_height ( image_handle ) ; if ( image_info -> ping != MagickFalse ) { image -> colorspace = YCbCrColorspace ; heif_image_handle_release ( image_handle ) ; heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { heif_image_handle_release ( image_handle ) ; heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; return ( DestroyImageList ( image ) ) ; } ( void ) SetImageColorspace ( image , YCbCrColorspace ) ; decode_options = ( struct heif_decoding_options * ) NULL ; option = GetImageOption ( image_info , \"heic:preserve-orientation\" ) ; if ( IsStringTrue ( option ) == MagickTrue ) { decode_options = heif_decoding_options_alloc ( ) ; decode_options -> ignore_transformations = 1 ; } else ( void ) SetImageProperty ( image , \"exif:Orientation\" , \"1\" ) ; error = heif_decode_image ( image_handle , & heif_image , heif_colorspace_YCbCr , <S2SV_StartBug> heif_chroma_420 , NULL ) ; <S2SV_EndBug> if ( IsHeifSuccess ( & error , image ) == MagickFalse ) { heif_image_handle_release ( image_handle ) ; heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_StartBug> if ( decode_options != ( struct heif_decoding_options * ) NULL ) <S2SV_EndBug> { image -> columns = ( size_t ) heif_image_get_width ( heif_image , heif_channel_Y ) ; image -> rows = ( size_t ) heif_image_get_height ( heif_image , heif_channel_Y ) ; <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows ) ; <S2SV_EndBug> heif_decoding_options_free ( decode_options ) ; if ( status == MagickFalse ) { heif_image_release ( heif_image ) ; heif_image_handle_release ( image_handle ) ; heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> } <S2SV_EndBug> } p_y = heif_image_get_plane_readonly ( heif_image , heif_channel_Y , & stride_y ) ; p_cb = heif_image_get_plane_readonly ( heif_image , heif_channel_Cb , & stride_cb ) ; p_cr = heif_image_get_plane_readonly ( heif_image , heif_channel_Cr , & stride_cr ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { PixelPacket * q ; register ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) p_y [ y * stride_y + x ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) p_cb [ ( y / 2 ) * stride_cb + x / 2 ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) p_cr [ ( y / 2 ) * stride_cr + x / 2 ] ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } heif_image_release ( heif_image ) ; heif_image_handle_release ( image_handle ) ; heif_context_free ( heif_context ) ; file_data = RelinquishMagickMemory ( file_data ) ; profile = GetImageProfile ( image , \"icc\" ) ; if ( profile != ( const StringInfo * ) NULL ) ( void ) TransformImageColorspace ( image , sRGBColorspace ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> , heif_chroma_420 , decode_options ) ; if ( decode_options != ( struct heif_decoding_options * ) NULL ) heif_decoding_options_free ( decode_options <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ; } <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> rows <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } p_y ="}
{"source": "CWE-401 video_usercopy ( struct file * file , unsigned int orig_cmd , unsigned long arg , v4l2_kioctl func ) { char sbuf [ 128 ] ; <S2SV_StartBug> void * mbuf = NULL ; <S2SV_EndBug> void * parg = ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; bool always_copy = false ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; unsigned int cmd = video_translate_cmd ( orig_cmd ) ; const size_t ioc_size = _IOC_SIZE ( cmd ) ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( ioc_size <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kvmalloc ( ioc_size , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = video_get_user ( ( void __user * ) arg , parg , cmd , orig_cmd , & always_copy ) ; if ( err ) goto out ; } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { <S2SV_StartBug> mbuf = kvmalloc ( array_size , GFP_KERNEL ) ; <S2SV_EndBug> err = - ENOMEM ; <S2SV_StartBug> if ( NULL == mbuf ) <S2SV_EndBug> goto out_array_args ; err = - EFAULT ; if ( in_compat_syscall ( ) ) <S2SV_StartBug> err = v4l2_compat_get_array_args ( file , mbuf , user_ptr , <S2SV_EndBug> array_size , orig_cmd , parg ) ; else <S2SV_StartBug> err = copy_from_user ( mbuf , user_ptr , array_size ) ? <S2SV_EndBug> - EFAULT : 0 ; if ( err ) goto out_array_args ; <S2SV_StartBug> * kernel_ptr = mbuf ; <S2SV_EndBug> } err = func ( file , cmd , parg ) ; if ( err == - ENOTTY || err == - ENOIOCTLCMD ) { err = - ENOTTY ; goto out ; } if ( err == 0 ) { if ( cmd == VIDIOC_DQBUF ) trace_v4l2_dqbuf ( video_devdata ( file ) -> minor , parg ) ; else if ( cmd == VIDIOC_QBUF ) trace_v4l2_qbuf ( video_devdata ( file ) -> minor , parg ) ; } if ( has_array_args ) { * kernel_ptr = ( void __force * ) user_ptr ; if ( in_compat_syscall ( ) ) { int put_err ; <S2SV_StartBug> put_err = v4l2_compat_put_array_args ( file , user_ptr , mbuf , <S2SV_EndBug> array_size , orig_cmd , parg ) ; if ( put_err ) err = put_err ; <S2SV_StartBug> } else if ( copy_to_user ( user_ptr , mbuf , array_size ) ) { <S2SV_EndBug> err = - EFAULT ; } goto out_array_args ; } if ( err < 0 && ! always_copy ) goto out ; out_array_args : if ( video_put_user ( ( void __user * ) arg , parg , cmd , orig_cmd ) ) err = - EFAULT ; out : <S2SV_StartBug> kvfree ( mbuf ) ; <S2SV_EndBug> return err ; }", "target": "<S2SV_ModStart> mbuf = NULL , * array_buf = NULL <S2SV_ModStart> has_array_args ) { array_buf <S2SV_ModEnd> = kvmalloc ( <S2SV_ModStart> ; if ( array_buf == NULL <S2SV_ModEnd> ) goto out_array_args <S2SV_ModStart> ( file , array_buf , user_ptr , array_size , <S2SV_ModEnd> orig_cmd , parg <S2SV_ModStart> = copy_from_user ( array_buf <S2SV_ModEnd> , user_ptr , <S2SV_ModStart> * kernel_ptr = array_buf <S2SV_ModEnd> ; } err <S2SV_ModStart> , user_ptr , array_buf , array_size , <S2SV_ModEnd> orig_cmd , parg <S2SV_ModStart> ( user_ptr , array_buf <S2SV_ModEnd> , array_size ) <S2SV_ModStart> : kvfree ( array_buf ) ; kvfree ("}
{"source": "CWE-703 int CServer : : SendMsg ( CMsgPacker * pMsg , int Flags , int ClientID ) { CNetChunk Packet ; if ( ! pMsg ) return - 1 ; <S2SV_StartBug> if ( 0 <= ClientID && ClientID < MAX_CLIENTS && GameServer ( ) -> IsClientBot ( ClientID ) ) <S2SV_EndBug> return 0 ; mem_zero ( & Packet , sizeof ( CNetChunk ) ) ; Packet . m_ClientID = ClientID ; Packet . m_pData = pMsg -> Data ( ) ; Packet . m_DataSize = pMsg -> Size ( ) ; if ( Flags & MSGFLAG_VITAL ) Packet . m_Flags |= NETSENDFLAG_VITAL ; if ( Flags & MSGFLAG_FLUSH ) Packet . m_Flags |= NETSENDFLAG_FLUSH ; if ( ! ( Flags & MSGFLAG_NORECORD ) ) m_DemoRecorder . RecordMessage ( pMsg -> Data ( ) , pMsg -> Size ( ) ) ; if ( ! ( Flags & MSGFLAG_NOSEND ) ) { if ( ClientID == - 1 ) { int i ; for ( i = 0 ; i < MAX_CLIENTS ; i ++ ) if ( m_aClients [ i ] . m_State == CClient : : STATE_INGAME && ! m_aClients [ i ] . m_Quitting ) { Packet . m_ClientID = i ; m_NetServer . Send ( & Packet ) ; } } else m_NetServer . Send ( & Packet ) ; } return 0 ; }", "target": "<S2SV_ModStart> ; if ( ClientID != - 1 && ( ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients [ ClientID ] . m_State == CClient : : STATE_EMPTY || m_aClients [ ClientID ] . m_Quitting <S2SV_ModEnd> ) ) return"}
{"source": "CWE-125 static php_iconv_err_t _php_iconv_mime_decode ( smart_str * pretval , const char * str , size_t str_nbytes , const char * enc , const char * * next_pos , int mode ) { php_iconv_err_t err = PHP_ICONV_ERR_SUCCESS ; iconv_t cd = ( iconv_t ) ( - 1 ) , cd_pl = ( iconv_t ) ( - 1 ) ; const char * p1 ; size_t str_left ; unsigned int scan_stat = 0 ; const char * csname = NULL ; size_t csname_len ; const char * encoded_text = NULL ; size_t encoded_text_len = 0 ; const char * encoded_word = NULL ; const char * spaces = NULL ; php_iconv_enc_scheme_t enc_scheme = PHP_ICONV_ENC_SCHEME_BASE64 ; if ( next_pos != NULL ) { * next_pos = NULL ; } cd_pl = iconv_open ( enc , ICONV_ASCII_ENCODING ) ; if ( cd_pl == ( iconv_t ) ( - 1 ) ) { # if ICONV_SUPPORTS_ERRNO if ( errno == EINVAL ) { err = PHP_ICONV_ERR_WRONG_CHARSET ; } else { err = PHP_ICONV_ERR_CONVERTER ; } # else err = PHP_ICONV_ERR_UNKNOWN ; # endif goto out ; } p1 = str ; for ( str_left = str_nbytes ; str_left > 0 ; str_left -- , p1 ++ ) { int eos = 0 ; switch ( scan_stat ) { case 0 : switch ( * p1 ) { case '\\\\r' : scan_stat = 7 ; break ; case '\\\\n' : scan_stat = 8 ; break ; case '=' : encoded_word = p1 ; scan_stat = 1 ; break ; case '<S2SV_blank>' : case '\\\\t' : spaces = p1 ; scan_stat = 11 ; break ; default : err = _php_iconv_appendc ( pretval , * p1 , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { if ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) { err = PHP_ICONV_ERR_SUCCESS ; } else { goto out ; } } encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } break ; } break ; case 1 : if ( * p1 != '?' ) { if ( * p1 == '\\\\r' || * p1 == '\\\\n' ) { -- p1 ; } err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } break ; } csname = p1 + 1 ; scan_stat = 2 ; break ; case 2 : switch ( * p1 ) { case '?' : scan_stat = 3 ; break ; case '*' : scan_stat = 10 ; break ; case '\\\\r' : case '\\\\n' : -- p1 ; _php_iconv_appendc ( pretval , '=' , cd_pl ) ; _php_iconv_appendc ( pretval , '?' , cd_pl ) ; err = _php_iconv_appendl ( pretval , csname , ( size_t ) ( ( p1 + 1 ) - csname ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } csname = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } continue ; } if ( scan_stat != 2 ) { char tmpbuf [ 80 ] ; if ( csname == NULL ) { err = PHP_ICONV_ERR_MALFORMED ; goto out ; } csname_len = ( size_t ) ( p1 - csname ) ; if ( csname_len > sizeof ( tmpbuf ) - 1 ) { if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } break ; } else { err = PHP_ICONV_ERR_MALFORMED ; goto out ; } } memcpy ( tmpbuf , csname , csname_len ) ; tmpbuf [ csname_len ] = '\\\\0' ; if ( cd != ( iconv_t ) ( - 1 ) ) { iconv_close ( cd ) ; } cd = iconv_open ( enc , tmpbuf ) ; if ( cd == ( iconv_t ) ( - 1 ) ) { if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { int qmarks = 2 ; while ( qmarks > 0 && str_left > 1 ) { if ( * ( ++ p1 ) == '?' ) { -- qmarks ; } -- str_left ; } if ( * ( p1 + 1 ) == '=' ) { ++ p1 ; <S2SV_StartBug> -- str_left ; <S2SV_EndBug> } err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } scan_stat = 12 ; break ; } else { # if ICONV_SUPPORTS_ERRNO if ( errno == EINVAL ) { err = PHP_ICONV_ERR_WRONG_CHARSET ; } else { err = PHP_ICONV_ERR_CONVERTER ; } # else err = PHP_ICONV_ERR_UNKNOWN ; # endif goto out ; } } } break ; case 3 : switch ( * p1 ) { case 'b' : case 'B' : enc_scheme = PHP_ICONV_ENC_SCHEME_BASE64 ; scan_stat = 4 ; break ; case 'q' : case 'Q' : enc_scheme = PHP_ICONV_ENC_SCHEME_QPRINT ; scan_stat = 4 ; break ; default : if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } break ; } else { err = PHP_ICONV_ERR_MALFORMED ; goto out ; } } break ; case 4 : if ( * p1 != '?' ) { if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } break ; } else { err = PHP_ICONV_ERR_MALFORMED ; goto out ; } } encoded_text = p1 + 1 ; scan_stat = 5 ; break ; case 5 : if ( * p1 == '?' ) { encoded_text_len = ( size_t ) ( p1 - encoded_text ) ; scan_stat = 6 ; } break ; case 7 : if ( * p1 == '\\\\n' ) { scan_stat = 8 ; } else { _php_iconv_appendc ( pretval , '\\\\r' , cd_pl ) ; _php_iconv_appendc ( pretval , * p1 , cd_pl ) ; scan_stat = 0 ; } break ; case 8 : if ( * p1 != '<S2SV_blank>' && * p1 != '\\\\t' ) { -- p1 ; str_left = 1 ; break ; } if ( encoded_word == NULL ) { _php_iconv_appendc ( pretval , '<S2SV_blank>' , cd_pl ) ; } spaces = NULL ; scan_stat = 11 ; break ; case 6 : if ( * p1 != '=' ) { if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } break ; } else { err = PHP_ICONV_ERR_MALFORMED ; goto out ; } } scan_stat = 9 ; if ( str_left == 1 ) { eos = 1 ; } else { break ; } case 9 : switch ( * p1 ) { default : if ( ! eos ) { if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } scan_stat = 12 ; break ; } } case '\\\\r' : case '\\\\n' : case '<S2SV_blank>' : case '\\\\t' : { zend_string * decoded_text ; switch ( enc_scheme ) { case PHP_ICONV_ENC_SCHEME_BASE64 : decoded_text = php_base64_decode ( ( unsigned char * ) encoded_text , encoded_text_len ) ; break ; case PHP_ICONV_ENC_SCHEME_QPRINT : decoded_text = php_quot_print_decode ( ( unsigned char * ) encoded_text , encoded_text_len , 1 ) ; break ; default : decoded_text = NULL ; break ; } if ( decoded_text == NULL ) { if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( ( p1 + 1 ) - encoded_word ) , cd_pl ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { goto out ; } encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } break ; } else { err = PHP_ICONV_ERR_UNKNOWN ; goto out ; } } err = _php_iconv_appendl ( pretval , ZSTR_VAL ( decoded_text ) , ZSTR_LEN ( decoded_text ) , cd ) ; zend_string_release ( decoded_text ) ; if ( err != PHP_ICONV_ERR_SUCCESS ) { if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { err = _php_iconv_appendl ( pretval , encoded_word , ( size_t ) ( p1 - encoded_word ) , cd_pl ) ; encoded_word = NULL ; if ( err != PHP_ICONV_ERR_SUCCESS ) { break ; } } else { goto out ; } } if ( eos ) { scan_stat = 0 ; break ; } switch ( * p1 ) { case '\\\\r' : scan_stat = 7 ; break ; case '\\\\n' : scan_stat = 8 ; break ; case '=' : scan_stat = 1 ; break ; case '<S2SV_blank>' : case '\\\\t' : spaces = p1 ; scan_stat = 11 ; break ; default : _php_iconv_appendc ( pretval , * p1 , cd_pl ) ; scan_stat = 12 ; break ; } } break ; } break ; case 10 : if ( * p1 == '?' ) { scan_stat = 3 ; } break ; case 11 : switch ( * p1 ) { case '\\\\r' : scan_stat = 7 ; break ; case '\\\\n' : scan_stat = 8 ; break ; case '=' : if ( spaces != NULL && encoded_word == NULL ) { _php_iconv_appendl ( pretval , spaces , ( size_t ) ( p1 - spaces ) , cd_pl ) ; spaces = NULL ; } encoded_word = p1 ; scan_stat = 1 ; break ; case '<S2SV_blank>' : case '\\\\t' : break ; default : if ( spaces != NULL ) { _php_iconv_appendl ( pretval , spaces , ( size_t ) ( p1 - spaces ) , cd_pl ) ; spaces = NULL ; } _php_iconv_appendc ( pretval , * p1 , cd_pl ) ; encoded_word = NULL ; if ( ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { scan_stat = 12 ; } else { scan_stat = 0 ; } break ; } break ; case 12 : switch ( * p1 ) { case '\\\\r' : scan_stat = 7 ; break ; case '\\\\n' : scan_stat = 8 ; break ; case '<S2SV_blank>' : case '\\\\t' : spaces = p1 ; scan_stat = 11 ; break ; case '=' : if ( ! ( mode & PHP_ICONV_MIME_DECODE_STRICT ) ) { encoded_word = p1 ; scan_stat = 1 ; break ; } default : _php_iconv_appendc ( pretval , * p1 , cd_pl ) ; break ; } break ; } } switch ( scan_stat ) { case 0 : case 8 : case 11 : case 12 : break ; default : if ( ( mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR ) ) { if ( scan_stat == 1 ) { _php_iconv_appendc ( pretval , '=' , cd_pl ) ; } err = PHP_ICONV_ERR_SUCCESS ; } else { err = PHP_ICONV_ERR_MALFORMED ; goto out ; } } if ( next_pos != NULL ) { * next_pos = p1 ; } smart_str_0 ( pretval ) ; out : if ( cd != ( iconv_t ) ( - 1 ) ) { iconv_close ( cd ) ; } if ( cd_pl != ( iconv_t ) ( - 1 ) ) { iconv_close ( cd_pl ) ; } return err ; }", "target": "<S2SV_ModStart> ++ p1 ; if ( str_left > 1 ) { <S2SV_ModStart> -- str_left ; }"}
{"source": "CWE-667 static void * gp_worker_main ( void * pvt ) { struct gp_thread * t = ( struct gp_thread * ) pvt ; struct gp_query * q = NULL ; char dummy = 0 ; int ret ; while ( ! t -> pool -> shutdown ) { gp_debug_set_conn_id ( 0 ) ; pthread_mutex_lock ( & t -> cond_mutex ) ; while ( t -> query == NULL ) { pthread_cond_wait ( & t -> cond_wakeup , & t -> cond_mutex ) ; <S2SV_StartBug> if ( t -> pool -> shutdown ) { <S2SV_EndBug> pthread_exit ( NULL ) ; } } q = t -> query ; t -> query = NULL ; pthread_mutex_unlock ( & t -> cond_mutex ) ; gp_debug_set_conn_id ( gp_conn_get_cid ( q -> conn ) ) ; GPDEBUGN ( 3 , \"[status]<S2SV_blank>Handling<S2SV_blank>query<S2SV_blank>input:<S2SV_blank>%p<S2SV_blank>(%zu)\\\\n\" , q -> buffer , q -> buflen ) ; gp_handle_query ( t -> pool , q ) ; GPDEBUGN ( 3 , \"[status]<S2SV_blank>Handling<S2SV_blank>query<S2SV_blank>output:<S2SV_blank>%p<S2SV_blank>(%zu)\\\\n\" , q -> buffer , q -> buflen ) ; pthread_mutex_lock ( & t -> pool -> lock ) ; q -> next = t -> pool -> reply_list ; t -> pool -> reply_list = q ; if ( ! t -> pool -> shutdown ) { LIST_DEL ( t -> pool -> busy_list , t ) ; LIST_ADD ( t -> pool -> free_list , t ) ; } pthread_mutex_unlock ( & t -> pool -> lock ) ; ret = write ( t -> pool -> sig_pipe [ 1 ] , & dummy , 1 ) ; if ( ret == - 1 ) { GPERROR ( \"Failed<S2SV_blank>to<S2SV_blank>signal<S2SV_blank>dispatcher!\" ) ; } } pthread_exit ( NULL ) ; }", "target": "<S2SV_ModStart> shutdown ) { pthread_mutex_unlock ( & t -> cond_mutex ) ;"}
{"source": "CWE-476 static int llcp_sock_bind ( struct socket * sock , struct sockaddr * addr , int alen ) { struct sock * sk = sock -> sk ; struct nfc_llcp_sock * llcp_sock = nfc_llcp_sock ( sk ) ; struct nfc_llcp_local * local ; struct nfc_dev * dev ; struct sockaddr_nfc_llcp llcp_addr ; int len , ret = 0 ; if ( ! addr || alen < offsetofend ( struct sockaddr , sa_family ) || addr -> sa_family != AF_NFC ) return - EINVAL ; pr_debug ( \"sk<S2SV_blank>%p<S2SV_blank>addr<S2SV_blank>%p<S2SV_blank>family<S2SV_blank>%d\\\\n\" , sk , addr , addr -> sa_family ) ; memset ( & llcp_addr , 0 , sizeof ( llcp_addr ) ) ; len = min_t ( unsigned int , sizeof ( llcp_addr ) , alen ) ; memcpy ( & llcp_addr , addr , len ) ; if ( llcp_addr . dsap != 0 ) return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_state != LLCP_CLOSED ) { ret = - EBADFD ; goto error ; } dev = nfc_get_device ( llcp_addr . dev_idx ) ; if ( dev == NULL ) { ret = - ENODEV ; goto error ; } local = nfc_llcp_find_local ( dev ) ; if ( local == NULL ) { ret = - ENODEV ; goto put_dev ; } llcp_sock -> dev = dev ; llcp_sock -> local = nfc_llcp_local_get ( local ) ; llcp_sock -> nfc_protocol = llcp_addr . nfc_protocol ; llcp_sock -> service_name_len = min_t ( unsigned int , llcp_addr . service_name_len , NFC_LLCP_MAX_SERVICE_NAME ) ; llcp_sock -> service_name = kmemdup ( llcp_addr . service_name , llcp_sock -> service_name_len , GFP_KERNEL ) ; if ( ! llcp_sock -> service_name ) { nfc_llcp_local_put ( llcp_sock -> local ) ; llcp_sock -> local = NULL ; <S2SV_StartBug> ret = - ENOMEM ; <S2SV_EndBug> goto put_dev ; } llcp_sock -> ssap = nfc_llcp_get_sdp_ssap ( local , llcp_sock ) ; if ( llcp_sock -> ssap == LLCP_SAP_MAX ) { nfc_llcp_local_put ( llcp_sock -> local ) ; llcp_sock -> local = NULL ; kfree ( llcp_sock -> service_name ) ; llcp_sock -> service_name = NULL ; <S2SV_StartBug> ret = - EADDRINUSE ; <S2SV_EndBug> goto put_dev ; } llcp_sock -> reserved_ssap = llcp_sock -> ssap ; nfc_llcp_sock_link ( & local -> sockets , sk ) ; pr_debug ( \"Socket<S2SV_blank>bound<S2SV_blank>to<S2SV_blank>SAP<S2SV_blank>%d\\\\n\" , llcp_sock -> ssap ) ; sk -> sk_state = LLCP_BOUND ; put_dev : nfc_put_device ( dev ) ; error : release_sock ( sk ) ; return ret ; }", "target": "<S2SV_ModStart> = NULL ; llcp_sock -> dev = NULL ; <S2SV_ModStart> = NULL ; llcp_sock -> dev = NULL ;"}
{"source": "CWE-369 start_input_gif ( j_compress_ptr cinfo , cjpeg_source_ptr sinfo ) { gif_source_ptr source = ( gif_source_ptr ) sinfo ; U_CHAR hdrbuf [ 10 ] ; unsigned int width , height ; int colormaplen , aspectRatio ; int c ; if ( ! ReadOK ( source -> pub . input_file , hdrbuf , 6 ) ) ERREXIT ( cinfo , JERR_GIF_NOT ) ; if ( hdrbuf [ 0 ] != 'G' || hdrbuf [ 1 ] != 'I' || hdrbuf [ 2 ] != 'F' ) ERREXIT ( cinfo , JERR_GIF_NOT ) ; if ( ( hdrbuf [ 3 ] != '8' || hdrbuf [ 4 ] != '7' || hdrbuf [ 5 ] != 'a' ) && ( hdrbuf [ 3 ] != '8' || hdrbuf [ 4 ] != '9' || hdrbuf [ 5 ] != 'a' ) ) TRACEMS3 ( cinfo , 1 , JTRC_GIF_BADVERSION , hdrbuf [ 3 ] , hdrbuf [ 4 ] , hdrbuf [ 5 ] ) ; if ( ! ReadOK ( source -> pub . input_file , hdrbuf , 7 ) ) ERREXIT ( cinfo , JERR_INPUT_EOF ) ; width = LM_to_uint ( hdrbuf , 0 ) ; height = LM_to_uint ( hdrbuf , 2 ) ; <S2SV_StartBug> aspectRatio = UCH ( hdrbuf [ 6 ] ) ; <S2SV_EndBug> if ( aspectRatio != 0 && aspectRatio != 49 ) TRACEMS ( cinfo , 1 , JTRC_GIF_NONSQUARE ) ; source -> colormap = ( * cinfo -> mem -> alloc_sarray ) ( ( j_common_ptr ) cinfo , JPOOL_IMAGE , ( JDIMENSION ) MAXCOLORMAPSIZE , ( JDIMENSION ) NUMCOLORS ) ; colormaplen = 0 ; if ( BitSet ( hdrbuf [ 4 ] , COLORMAPFLAG ) ) { colormaplen = 2 << ( hdrbuf [ 4 ] & 0x07 ) ; ReadColorMap ( source , colormaplen , source -> colormap ) ; } for ( ; ; ) { c = ReadByte ( source ) ; if ( c == ';' ) ERREXIT ( cinfo , JERR_GIF_IMAGENOTFOUND ) ; if ( c == '!' ) { DoExtension ( source ) ; continue ; } if ( c != ',' ) { WARNMS1 ( cinfo , JWRN_GIF_CHAR , c ) ; continue ; } if ( ! ReadOK ( source -> pub . input_file , hdrbuf , 9 ) ) ERREXIT ( cinfo , JERR_INPUT_EOF ) ; width = LM_to_uint ( hdrbuf , 4 ) ; <S2SV_StartBug> height = LM_to_uint ( hdrbuf , 6 ) ; <S2SV_EndBug> source -> is_interlaced = ( BitSet ( hdrbuf [ 8 ] , INTERLACE ) != 0 ) ; if ( BitSet ( hdrbuf [ 8 ] , COLORMAPFLAG ) ) { colormaplen = 2 << ( hdrbuf [ 8 ] & 0x07 ) ; ReadColorMap ( source , colormaplen , source -> colormap ) ; } source -> input_code_size = ReadByte ( source ) ; if ( source -> input_code_size < 2 || source -> input_code_size > 8 ) ERREXIT1 ( cinfo , JERR_GIF_CODESIZE , source -> input_code_size ) ; break ; } source -> symbol_head = ( UINT16 * ) ( * cinfo -> mem -> alloc_large ) ( ( j_common_ptr ) cinfo , JPOOL_IMAGE , LZW_TABLE_SIZE * sizeof ( UINT16 ) ) ; source -> symbol_tail = ( UINT8 * ) ( * cinfo -> mem -> alloc_large ) ( ( j_common_ptr ) cinfo , JPOOL_IMAGE , LZW_TABLE_SIZE * sizeof ( UINT8 ) ) ; source -> symbol_stack = ( UINT8 * ) ( * cinfo -> mem -> alloc_large ) ( ( j_common_ptr ) cinfo , JPOOL_IMAGE , LZW_TABLE_SIZE * sizeof ( UINT8 ) ) ; InitLZWCode ( source ) ; if ( source -> is_interlaced ) { source -> interlaced_image = ( * cinfo -> mem -> request_virt_sarray ) ( ( j_common_ptr ) cinfo , JPOOL_IMAGE , FALSE , ( JDIMENSION ) width , ( JDIMENSION ) height , ( JDIMENSION ) 1 ) ; if ( cinfo -> progress != NULL ) { cd_progress_ptr progress = ( cd_progress_ptr ) cinfo -> progress ; progress -> total_extra_passes ++ ; } source -> pub . get_pixel_rows = load_interlaced_image ; } else { source -> pub . get_pixel_rows = get_pixel_rows ; } source -> pub . buffer = ( * cinfo -> mem -> alloc_sarray ) ( ( j_common_ptr ) cinfo , JPOOL_IMAGE , ( JDIMENSION ) width * NUMCOLORS , ( JDIMENSION ) 1 ) ; source -> pub . buffer_height = 1 ; for ( c = colormaplen ; c < source -> clear_code ; c ++ ) { source -> colormap [ CM_RED ] [ c ] = source -> colormap [ CM_GREEN ] [ c ] = source -> colormap [ CM_BLUE ] [ c ] = CENTERJSAMPLE ; } cinfo -> in_color_space = JCS_RGB ; cinfo -> input_components = NUMCOLORS ; cinfo -> data_precision = BITS_IN_JSAMPLE ; cinfo -> image_width = width ; cinfo -> image_height = height ; TRACEMS3 ( cinfo , 1 , JTRC_GIF , width , height , colormaplen ) ; }", "target": "<S2SV_ModStart> 2 ) ; if ( width == 0 || height == 0 ) ERREXIT ( cinfo , JERR_GIF_EMPTY ) ; <S2SV_ModStart> hdrbuf , 6 ) ; if ( width == 0 || height == 0 ) ERREXIT ( cinfo , JERR_GIF_EMPTY"}
{"source": "CWE-787 exif_entry_get_value ( ExifEntry * e , char * val , unsigned int maxlen ) { unsigned int i , j , k ; ExifShort v_short , v_short2 , v_short3 , v_short4 ; ExifByte v_byte ; ExifRational v_rat ; ExifSRational v_srat ; char b [ 64 ] ; const char * c ; ExifByteOrder o ; double d ; ExifEntry * entry ; static const struct { char label [ 5 ] ; char major , minor ; } versions [ ] = { { \"0110\" , 1 , 1 } , { \"0120\" , 1 , 2 } , { \"0200\" , 2 , 0 } , { \"0210\" , 2 , 1 } , { \"0220\" , 2 , 2 } , { \"0221\" , 2 , 21 } , { \"0230\" , 2 , 3 } , { \"\" , 0 , 0 } } ; ( void ) bindtextdomain ( GETTEXT_PACKAGE , LOCALEDIR ) ; if ( ! e || ! e -> parent || ! e -> parent -> parent || ! maxlen || ! val ) return val ; memset ( val , 0 , maxlen ) ; o = exif_data_get_byte_order ( e -> parent -> parent ) ; if ( e -> size != e -> components * exif_format_get_size ( e -> format ) ) { snprintf ( val , maxlen , _ ( \"Invalid<S2SV_blank>size<S2SV_blank>of<S2SV_blank>entry<S2SV_blank>(%i,<S2SV_blank>\" \"expected<S2SV_blank>%li<S2SV_blank>x<S2SV_blank>%i).\" ) , e -> size , e -> components , exif_format_get_size ( e -> format ) ) ; return val ; } switch ( e -> tag ) { case EXIF_TAG_USER_COMMENT : if ( ( e -> format != EXIF_FORMAT_ASCII ) || ( e -> size <= 8 ) || ( memcmp ( e -> data , \"ASCII\\\\0\\\\0\\\\0\" , 8 ) && memcmp ( e -> data , \"UNICODE\\\\0\" , 8 ) && memcmp ( e -> data , \"JIS\\\\0\\\\0\\\\0\\\\0\\\\0\" , 8 ) && memcmp ( e -> data , \"\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\" , 8 ) ) ) CF ( e , EXIF_FORMAT_UNDEFINED , val , maxlen ) ; if ( ( e -> size >= 8 ) && ! memcmp ( e -> data , \"ASCII\\\\0\\\\0\\\\0\" , 8 ) ) { strncpy ( val , ( char * ) e -> data + 8 , MIN ( e -> size - 8 , maxlen - 1 ) ) ; break ; } if ( ( e -> size >= 8 ) && ! memcmp ( e -> data , \"UNICODE\\\\0\" , 8 ) ) { strncpy ( val , _ ( \"Unsupported<S2SV_blank>UNICODE<S2SV_blank>string\" ) , maxlen - 1 ) ; break ; } if ( ( e -> size >= 8 ) && ! memcmp ( e -> data , \"JIS\\\\0\\\\0\\\\0\\\\0\\\\0\" , 8 ) ) { strncpy ( val , _ ( \"Unsupported<S2SV_blank>JIS<S2SV_blank>string\" ) , maxlen - 1 ) ; break ; } for ( i = 0 ; ( i < e -> size ) && ( ! e -> data [ i ] || ( e -> data [ i ] == '<S2SV_blank>' ) ) ; i ++ ) ; if ( i == e -> size ) break ; exif_entry_log ( e , EXIF_LOG_CODE_DEBUG , _ ( \"Tag<S2SV_blank>UserComment<S2SV_blank>contains<S2SV_blank>data<S2SV_blank>but<S2SV_blank>is<S2SV_blank>\" \"against<S2SV_blank>specification.\" ) ) ; for ( j = 0 ; ( i < e -> size ) && ( j < maxlen - 1 ) ; i ++ , j ++ ) { exif_entry_log ( e , EXIF_LOG_CODE_DEBUG , _ ( \"Byte<S2SV_blank>at<S2SV_blank>position<S2SV_blank>%i:<S2SV_blank>0x%02x\" ) , i , e -> data [ i ] ) ; val [ j ] = isprint ( e -> data [ i ] ) ? e -> data [ i ] : '.' ; } break ; case EXIF_TAG_EXIF_VERSION : CF ( e , EXIF_FORMAT_UNDEFINED , val , maxlen ) ; CC ( e , 4 , val , maxlen ) ; strncpy ( val , _ ( \"Unknown<S2SV_blank>Exif<S2SV_blank>Version\" ) , maxlen - 1 ) ; for ( i = 0 ; * versions [ i ] . label ; i ++ ) { if ( ! memcmp ( e -> data , versions [ i ] . label , 4 ) ) { snprintf ( val , maxlen , _ ( \"Exif<S2SV_blank>Version<S2SV_blank>%d.%d\" ) , versions [ i ] . major , versions [ i ] . minor ) ; break ; } } break ; case EXIF_TAG_FLASH_PIX_VERSION : CF ( e , EXIF_FORMAT_UNDEFINED , val , maxlen ) ; CC ( e , 4 , val , maxlen ) ; if ( ! memcmp ( e -> data , \"0100\" , 4 ) ) strncpy ( val , _ ( \"FlashPix<S2SV_blank>Version<S2SV_blank>1.0\" ) , maxlen - 1 ) ; else if ( ! memcmp ( e -> data , \"0101\" , 4 ) ) strncpy ( val , _ ( \"FlashPix<S2SV_blank>Version<S2SV_blank>1.01\" ) , maxlen - 1 ) ; else strncpy ( val , _ ( \"Unknown<S2SV_blank>FlashPix<S2SV_blank>Version\" ) , maxlen - 1 ) ; break ; case EXIF_TAG_COPYRIGHT : CF ( e , EXIF_FORMAT_ASCII , val , maxlen ) ; if ( e -> size && e -> data && match_repeated_char ( e -> data , '<S2SV_blank>' , e -> size ) ) strncpy ( val , ( char * ) e -> data , MIN ( maxlen - 1 , e -> size ) ) ; else strncpy ( val , _ ( \"[None]\" ) , maxlen - 1 ) ; strncat ( val , \"<S2SV_blank>\" , maxlen - 1 - strlen ( val ) ) ; strncat ( val , _ ( \"(Photographer)\" ) , maxlen - 1 - strlen ( val ) ) ; strncat ( val , \"<S2SV_blank>-<S2SV_blank>\" , maxlen - 1 - strlen ( val ) ) ; k = 0 ; if ( e -> size && e -> data ) { const unsigned char * tagdata = memchr ( e -> data , 0 , e -> size ) ; if ( tagdata ++ ) { unsigned int editor_ofs = tagdata - e -> data ; unsigned int remaining = e -> size - editor_ofs ; if ( match_repeated_char ( tagdata , '<S2SV_blank>' , remaining ) ) { strncat ( val , ( const char * ) tagdata , MIN ( maxlen - 1 - strlen ( val ) , remaining ) ) ; ++ k ; } } } if ( ! k ) strncat ( val , _ ( \"[None]\" ) , maxlen - 1 - strlen ( val ) ) ; strncat ( val , \"<S2SV_blank>\" , maxlen - 1 - strlen ( val ) ) ; strncat ( val , _ ( \"(Editor)\" ) , maxlen - 1 - strlen ( val ) ) ; break ; case EXIF_TAG_FNUMBER : CF ( e , EXIF_FORMAT_RATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_rat = exif_get_rational ( e -> data , o ) ; if ( ! v_rat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_rat . numerator / ( double ) v_rat . denominator ; snprintf ( val , maxlen , \"f/%.01f\" , d ) ; break ; case EXIF_TAG_APERTURE_VALUE : case EXIF_TAG_MAX_APERTURE_VALUE : CF ( e , EXIF_FORMAT_RATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_rat = exif_get_rational ( e -> data , o ) ; if ( ! v_rat . denominator || ( 0x80000000 == v_rat . numerator ) ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_rat . numerator / ( double ) v_rat . denominator ; snprintf ( val , maxlen , _ ( \"%.02f<S2SV_blank>EV\" ) , d ) ; snprintf ( b , sizeof ( b ) , _ ( \"<S2SV_blank>(f/%.01f)\" ) , pow ( 2 , d / 2. ) ) ; strncat ( val , b , maxlen - 1 - strlen ( val ) ) ; break ; case EXIF_TAG_FOCAL_LENGTH : CF ( e , EXIF_FORMAT_RATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_rat = exif_get_rational ( e -> data , o ) ; if ( ! v_rat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = 0. ; entry = exif_content_get_entry ( e -> parent -> parent -> ifd [ EXIF_IFD_0 ] , EXIF_TAG_MAKE ) ; if ( entry && entry -> data && entry -> size >= 7 && ! strncmp ( ( char * ) entry -> data , \"Minolta\" , 7 ) ) { entry = exif_content_get_entry ( e -> parent -> parent -> ifd [ EXIF_IFD_0 ] , EXIF_TAG_MODEL ) ; if ( entry && entry -> data && entry -> size >= 8 ) { if ( ! strncmp ( ( char * ) entry -> data , \"DiMAGE<S2SV_blank>7\" , 8 ) ) d = 3.9 ; else if ( ! strncmp ( ( char * ) entry -> data , \"DiMAGE<S2SV_blank>5\" , 8 ) ) d = 4.9 ; } } if ( d ) snprintf ( b , sizeof ( b ) , _ ( \"<S2SV_blank>(35<S2SV_blank>equivalent:<S2SV_blank>%.0f<S2SV_blank>mm)\" ) , ( d * ( double ) v_rat . numerator / ( double ) v_rat . denominator ) ) ; else b [ 0 ] = 0 ; d = ( double ) v_rat . numerator / ( double ) v_rat . denominator ; snprintf ( val , maxlen , \"%.1f<S2SV_blank>mm\" , d ) ; strncat ( val , b , maxlen - 1 - strlen ( val ) ) ; break ; case EXIF_TAG_SUBJECT_DISTANCE : CF ( e , EXIF_FORMAT_RATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_rat = exif_get_rational ( e -> data , o ) ; if ( ! v_rat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_rat . numerator / ( double ) v_rat . denominator ; snprintf ( val , maxlen , \"%.1f<S2SV_blank>m\" , d ) ; break ; case EXIF_TAG_EXPOSURE_TIME : CF ( e , EXIF_FORMAT_RATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_rat = exif_get_rational ( e -> data , o ) ; if ( ! v_rat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_rat . numerator / ( double ) v_rat . denominator ; if ( d < 1 && d ) snprintf ( val , maxlen , _ ( \"1/%.0f\" ) , 1. / d ) ; else snprintf ( val , maxlen , \"%.0f\" , d ) ; strncat ( val , _ ( \"<S2SV_blank>sec.\" ) , maxlen - 1 - strlen ( val ) ) ; break ; case EXIF_TAG_SHUTTER_SPEED_VALUE : CF ( e , EXIF_FORMAT_SRATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_srat = exif_get_srational ( e -> data , o ) ; if ( ! v_srat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_srat . numerator / ( double ) v_srat . denominator ; snprintf ( val , maxlen , _ ( \"%.02f<S2SV_blank>EV\" ) , d ) ; if ( pow ( 2 , d ) ) d = 1. / pow ( 2 , d ) ; if ( d < 1 && d ) snprintf ( b , sizeof ( b ) , _ ( \"<S2SV_blank>(1/%.0f<S2SV_blank>sec.)\" ) , 1. / d ) ; else snprintf ( b , sizeof ( b ) , _ ( \"<S2SV_blank>(%.0f<S2SV_blank>sec.)\" ) , d ) ; strncat ( val , b , maxlen - 1 - strlen ( val ) ) ; break ; case EXIF_TAG_BRIGHTNESS_VALUE : CF ( e , EXIF_FORMAT_SRATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_srat = exif_get_srational ( e -> data , o ) ; if ( ! v_srat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_srat . numerator / ( double ) v_srat . denominator ; snprintf ( val , maxlen , _ ( \"%.02f<S2SV_blank>EV\" ) , d ) ; snprintf ( b , sizeof ( b ) , _ ( \"<S2SV_blank>(%.02f<S2SV_blank>cd/m^2)\" ) , 1. / ( M_PI * 0.3048 * 0.3048 ) * pow ( 2 , d ) ) ; strncat ( val , b , maxlen - 1 - strlen ( val ) ) ; break ; case EXIF_TAG_FILE_SOURCE : CF ( e , EXIF_FORMAT_UNDEFINED , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_byte = e -> data [ 0 ] ; if ( v_byte == 3 ) strncpy ( val , _ ( \"DSC\" ) , maxlen - 1 ) ; else snprintf ( val , maxlen , _ ( \"Internal<S2SV_blank>error<S2SV_blank>(unknown<S2SV_blank>\" \"value<S2SV_blank>%i)\" ) , v_byte ) ; break ; case EXIF_TAG_COMPONENTS_CONFIGURATION : CF ( e , EXIF_FORMAT_UNDEFINED , val , maxlen ) ; CC ( e , 4 , val , maxlen ) ; for ( i = 0 ; i < 4 ; i ++ ) { switch ( e -> data [ i ] ) { case 0 : c = _ ( \"-\" ) ; break ; case 1 : c = _ ( \"Y\" ) ; break ; case 2 : c = _ ( \"Cb\" ) ; break ; case 3 : c = _ ( \"Cr\" ) ; break ; case 4 : c = _ ( \"R\" ) ; break ; case 5 : c = _ ( \"G\" ) ; break ; case 6 : c = _ ( \"B\" ) ; break ; default : c = _ ( \"Reserved\" ) ; break ; } strncat ( val , c , maxlen - 1 - strlen ( val ) ) ; if ( i < 3 ) strncat ( val , \"<S2SV_blank>\" , maxlen - 1 - strlen ( val ) ) ; } break ; case EXIF_TAG_EXPOSURE_BIAS_VALUE : CF ( e , EXIF_FORMAT_SRATIONAL , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_srat = exif_get_srational ( e -> data , o ) ; if ( ! v_srat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_srat . numerator / ( double ) v_srat . denominator ; snprintf ( val , maxlen , _ ( \"%.02f<S2SV_blank>EV\" ) , d ) ; break ; case EXIF_TAG_SCENE_TYPE : CF ( e , EXIF_FORMAT_UNDEFINED , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_byte = e -> data [ 0 ] ; if ( v_byte == 1 ) strncpy ( val , _ ( \"Directly<S2SV_blank>photographed\" ) , maxlen - 1 ) ; else snprintf ( val , maxlen , _ ( \"Internal<S2SV_blank>error<S2SV_blank>(unknown<S2SV_blank>\" \"value<S2SV_blank>%i)\" ) , v_byte ) ; break ; case EXIF_TAG_YCBCR_SUB_SAMPLING : CF ( e , EXIF_FORMAT_SHORT , val , maxlen ) ; CC ( e , 2 , val , maxlen ) ; v_short = exif_get_short ( e -> data , o ) ; v_short2 = exif_get_short ( e -> data + exif_format_get_size ( e -> format ) , o ) ; if ( ( v_short == 2 ) && ( v_short2 == 1 ) ) strncpy ( val , _ ( \"YCbCr4:2:2\" ) , maxlen - 1 ) ; else if ( ( v_short == 2 ) && ( v_short2 == 2 ) ) strncpy ( val , _ ( \"YCbCr4:2:0\" ) , maxlen - 1 ) ; else snprintf ( val , maxlen , \"%u,<S2SV_blank>%u\" , v_short , v_short2 ) ; break ; case EXIF_TAG_SUBJECT_AREA : CF ( e , EXIF_FORMAT_SHORT , val , maxlen ) ; switch ( e -> components ) { case 2 : v_short = exif_get_short ( e -> data , o ) ; v_short2 = exif_get_short ( e -> data + 2 , o ) ; snprintf ( val , maxlen , \"(x,y)<S2SV_blank>=<S2SV_blank>(%i,%i)\" , v_short , v_short2 ) ; break ; case 3 : v_short = exif_get_short ( e -> data , o ) ; v_short2 = exif_get_short ( e -> data + 2 , o ) ; v_short3 = exif_get_short ( e -> data + 4 , o ) ; snprintf ( val , maxlen , _ ( \"Within<S2SV_blank>distance<S2SV_blank>%i<S2SV_blank>of<S2SV_blank>\" \"(x,y)<S2SV_blank>=<S2SV_blank>(%i,%i)\" ) , v_short3 , v_short , v_short2 ) ; break ; case 4 : v_short = exif_get_short ( e -> data , o ) ; v_short2 = exif_get_short ( e -> data + 2 , o ) ; v_short3 = exif_get_short ( e -> data + 4 , o ) ; v_short4 = exif_get_short ( e -> data + 6 , o ) ; snprintf ( val , maxlen , _ ( \"Within<S2SV_blank>rectangle<S2SV_blank>\" \"(width<S2SV_blank>%i,<S2SV_blank>height<S2SV_blank>%i)<S2SV_blank>around<S2SV_blank>\" \"(x,y)<S2SV_blank>=<S2SV_blank>(%i,%i)\" ) , v_short3 , v_short4 , v_short , v_short2 ) ; break ; default : snprintf ( val , maxlen , _ ( \"Unexpected<S2SV_blank>number<S2SV_blank>\" \"of<S2SV_blank>components<S2SV_blank>(%li,<S2SV_blank>expected<S2SV_blank>2,<S2SV_blank>3,<S2SV_blank>or<S2SV_blank>4).\" ) , e -> components ) ; } break ; case EXIF_TAG_GPS_VERSION_ID : CF ( e , EXIF_FORMAT_BYTE , val , maxlen ) ; CC ( e , 4 , val , maxlen ) ; v_byte = e -> data [ 0 ] ; snprintf ( val , maxlen , \"%u\" , v_byte ) ; for ( i = 1 ; i < e -> components ; i ++ ) { v_byte = e -> data [ i ] ; snprintf ( b , sizeof ( b ) , \".%u\" , v_byte ) ; strncat ( val , b , maxlen - 1 - strlen ( val ) ) ; } break ; case EXIF_TAG_INTEROPERABILITY_VERSION : if ( e -> format == EXIF_FORMAT_UNDEFINED ) { strncpy ( val , ( char * ) e -> data , MIN ( maxlen - 1 , e -> size ) ) ; break ; } exif_entry_format_value ( e , val , maxlen ) ; break ; case EXIF_TAG_GPS_ALTITUDE_REF : CF ( e , EXIF_FORMAT_BYTE , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_byte = e -> data [ 0 ] ; if ( v_byte == 0 ) strncpy ( val , _ ( \"Sea<S2SV_blank>level\" ) , maxlen - 1 ) ; else if ( v_byte == 1 ) strncpy ( val , _ ( \"Sea<S2SV_blank>level<S2SV_blank>reference\" ) , maxlen - 1 ) ; else snprintf ( val , maxlen , _ ( \"Internal<S2SV_blank>error<S2SV_blank>(unknown<S2SV_blank>\" \"value<S2SV_blank>%i)\" ) , v_byte ) ; break ; case EXIF_TAG_GPS_TIME_STAMP : CF ( e , EXIF_FORMAT_RATIONAL , val , maxlen ) ; CC ( e , 3 , val , maxlen ) ; v_rat = exif_get_rational ( e -> data , o ) ; if ( ! v_rat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } i = v_rat . numerator / v_rat . denominator ; v_rat = exif_get_rational ( e -> data + exif_format_get_size ( e -> format ) , o ) ; if ( ! v_rat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } j = v_rat . numerator / v_rat . denominator ; v_rat = exif_get_rational ( e -> data + 2 * exif_format_get_size ( e -> format ) , o ) ; if ( ! v_rat . denominator ) { exif_entry_format_value ( e , val , maxlen ) ; break ; } d = ( double ) v_rat . numerator / ( double ) v_rat . denominator ; snprintf ( val , maxlen , \"%02u:%02u:%05.2f\" , i , j , d ) ; break ; case EXIF_TAG_METERING_MODE : case EXIF_TAG_COMPRESSION : case EXIF_TAG_LIGHT_SOURCE : case EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT : case EXIF_TAG_RESOLUTION_UNIT : case EXIF_TAG_EXPOSURE_PROGRAM : case EXIF_TAG_FLASH : case EXIF_TAG_SUBJECT_DISTANCE_RANGE : case EXIF_TAG_COLOR_SPACE : CF ( e , EXIF_FORMAT_SHORT , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_short = exif_get_short ( e -> data , o ) ; for ( i = 0 ; list2 [ i ] . tag && ( list2 [ i ] . tag != e -> tag ) ; i ++ ) ; if ( ! list2 [ i ] . tag ) { snprintf ( val , maxlen , _ ( \"Internal<S2SV_blank>error<S2SV_blank>(unknown<S2SV_blank>\" \"value<S2SV_blank>%i)\" ) , v_short ) ; break ; } for ( j = 0 ; list2 [ i ] . elem [ j ] . values [ 0 ] && ( list2 [ i ] . elem [ j ] . index < v_short ) ; j ++ ) ; if ( list2 [ i ] . elem [ j ] . index != v_short ) { snprintf ( val , maxlen , _ ( \"Internal<S2SV_blank>error<S2SV_blank>(unknown<S2SV_blank>\" \"value<S2SV_blank>%i)\" ) , v_short ) ; break ; } memset ( val , 0 , maxlen ) ; for ( k = 0 ; list2 [ i ] . elem [ j ] . values [ k ] ; k ++ ) { size_t l = strlen ( _ ( list2 [ i ] . elem [ j ] . values [ k ] ) ) ; if ( ( maxlen > l ) && ( strlen ( val ) < l ) ) strncpy ( val , _ ( list2 [ i ] . elem [ j ] . values [ k ] ) , maxlen - 1 ) ; } if ( ! val [ 0 ] ) snprintf ( val , maxlen , \"%i\" , v_short ) ; break ; case EXIF_TAG_PLANAR_CONFIGURATION : case EXIF_TAG_SENSING_METHOD : case EXIF_TAG_ORIENTATION : case EXIF_TAG_YCBCR_POSITIONING : case EXIF_TAG_PHOTOMETRIC_INTERPRETATION : case EXIF_TAG_CUSTOM_RENDERED : case EXIF_TAG_EXPOSURE_MODE : case EXIF_TAG_WHITE_BALANCE : case EXIF_TAG_SCENE_CAPTURE_TYPE : case EXIF_TAG_GAIN_CONTROL : case EXIF_TAG_SATURATION : case EXIF_TAG_CONTRAST : case EXIF_TAG_SHARPNESS : CF ( e , EXIF_FORMAT_SHORT , val , maxlen ) ; CC ( e , 1 , val , maxlen ) ; v_short = exif_get_short ( e -> data , o ) ; for ( i = 0 ; list [ i ] . tag && ( list [ i ] . tag != e -> tag ) ; i ++ ) ; if ( ! list [ i ] . tag ) { snprintf ( val , maxlen , _ ( \"Internal<S2SV_blank>error<S2SV_blank>(unknown<S2SV_blank>\" \"value<S2SV_blank>%i)\" ) , v_short ) ; break ; } for ( j = 0 ; list [ i ] . strings [ j ] && ( j < v_short ) ; j ++ ) ; if ( ! list [ i ] . strings [ j ] ) snprintf ( val , maxlen , \"%i\" , v_short ) ; else if ( ! * list [ i ] . strings [ j ] ) snprintf ( val , maxlen , _ ( \"Unknown<S2SV_blank>value<S2SV_blank>%i\" ) , v_short ) ; else strncpy ( val , _ ( list [ i ] . strings [ j ] ) , maxlen - 1 ) ; break ; case EXIF_TAG_XP_TITLE : case EXIF_TAG_XP_COMMENT : case EXIF_TAG_XP_AUTHOR : case EXIF_TAG_XP_KEYWORDS : case EXIF_TAG_XP_SUBJECT : { unsigned char * utf16 ; <S2SV_StartBug> if ( e -> size + sizeof ( uint16_t ) + 1 < e -> size ) break ; <S2SV_EndBug> utf16 = exif_mem_alloc ( e -> priv -> mem , e -> size + sizeof ( uint16_t ) + 1 ) ; if ( ! utf16 ) break ; memcpy ( utf16 , e -> data , e -> size ) ; utf16 [ e -> size ] = 0 ; utf16 [ e -> size + 1 ] = 0 ; utf16 [ e -> size + 2 ] = 0 ; exif_convert_utf16_to_utf8 ( val , utf16 , maxlen ) ; exif_mem_free ( e -> priv -> mem , utf16 ) ; break ; } default : exif_entry_format_value ( e , val , maxlen ) ; } return val ; }", "target": "<S2SV_ModStart> e -> size >= 65536 - <S2SV_ModEnd> sizeof ( uint16_t <S2SV_ModStart> ( uint16_t ) * 2 <S2SV_ModEnd> ) break ;"}
{"source": "CWE-401 static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = DIV_ROUND_UP ( size , PAGE_SIZE ) ; table = kcalloc ( nents , sizeof ( * table ) , GFP_KERNEL ) ; if ( ! table ) return NULL ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( GFP_KERNEL ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> } alloc_size = min_t ( int , size , PAGE_SIZE ) ; size -= PAGE_SIZE ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }", "target": "<S2SV_ModStart> ) ; } kfree ( table ) ;"}
{"source": "CWE-400 size_t recv_body ( char * buf , size_t max ) override { auto & message = parser . get ( ) ; auto & body_remaining = message . body ( ) ; body_remaining . data = buf ; body_remaining . size = max ; while ( body_remaining . size && ! parser . is_done ( ) ) { boost : : system : : error_code ec ; http : : async_read_some ( stream , buffer , parser , yield [ ec ] ) ; <S2SV_StartBug> if ( ec == http : : error : : partial_message || <S2SV_EndBug> ec == http : : error : : need_buffer ) { break ; } if ( ec ) { ldout ( cct , 4 ) << \"failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>body:<S2SV_blank>\" << ec . message ( ) << dendl ; throw rgw : : io : : Exception ( ec . value ( ) , std : : system_category ( ) ) ; } } return max - body_remaining . size ; }", "target": "<S2SV_ModStart> error : : <S2SV_ModEnd> need_buffer ) {"}
{"source": "CWE-354 dissect_tcp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) { guint8 th_off_x2 ; guint16 th_sum ; guint32 th_urp ; proto_tree * tcp_tree = NULL , * field_tree = NULL ; proto_item * ti = NULL , * tf , * hidden_item ; proto_item * options_item ; proto_tree * options_tree ; int offset = 0 ; const char * flags_str , * flags_str_first_letter ; guint optlen ; guint32 nxtseq = 0 ; guint reported_len ; vec_t cksum_vec [ 4 ] ; guint32 phdr [ 2 ] ; guint16 computed_cksum ; guint16 real_window ; guint captured_length_remaining ; gboolean desegment_ok ; struct tcpinfo tcpinfo ; struct tcpheader * tcph ; proto_item * tf_syn = NULL , * tf_fin = NULL , * tf_rst = NULL , * scaled_pi ; conversation_t * conv = NULL , * other_conv ; guint32 save_last_frame = 0 ; struct tcp_analysis * tcpd = NULL ; struct tcp_per_packet_data_t * tcppd = NULL ; proto_item * item ; proto_tree * checksum_tree ; gboolean icmp_ip = FALSE ; tcph = wmem_new0 ( wmem_packet_scope ( ) , struct tcpheader ) ; tcph -> th_sport = tvb_get_ntohs ( tvb , offset ) ; tcph -> th_dport = tvb_get_ntohs ( tvb , offset + 2 ) ; copy_address_shallow ( & tcph -> ip_src , & pinfo -> src ) ; copy_address_shallow ( & tcph -> ip_dst , & pinfo -> dst ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"TCP\" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; col_append_ports ( pinfo -> cinfo , COL_INFO , PT_TCP , tcph -> th_sport , tcph -> th_dport ) ; if ( tree ) { ti = proto_tree_add_item ( tree , proto_tcp , tvb , 0 , - 1 , ENC_NA ) ; if ( tcp_summary_in_tree ) { proto_item_append_text ( ti , \",<S2SV_blank>Src<S2SV_blank>Port:<S2SV_blank>%s,<S2SV_blank>Dst<S2SV_blank>Port:<S2SV_blank>%s\" , port_with_resolution_to_str ( wmem_packet_scope ( ) , PT_TCP , tcph -> th_sport ) , port_with_resolution_to_str ( wmem_packet_scope ( ) , PT_TCP , tcph -> th_dport ) ) ; } tcp_tree = proto_item_add_subtree ( ti , ett_tcp ) ; p_add_proto_data ( pinfo -> pool , pinfo , proto_tcp , pinfo -> curr_layer_num , tcp_tree ) ; proto_tree_add_item ( tcp_tree , hf_tcp_srcport , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; proto_tree_add_item ( tcp_tree , hf_tcp_dstport , tvb , offset + 2 , 2 , ENC_BIG_ENDIAN ) ; hidden_item = proto_tree_add_item ( tcp_tree , hf_tcp_port , tvb , offset , 2 , ENC_BIG_ENDIAN ) ; PROTO_ITEM_SET_HIDDEN ( hidden_item ) ; hidden_item = proto_tree_add_item ( tcp_tree , hf_tcp_port , tvb , offset + 2 , 2 , ENC_BIG_ENDIAN ) ; PROTO_ITEM_SET_HIDDEN ( hidden_item ) ; { wmem_list_frame_t * frame ; frame = wmem_list_frame_prev ( wmem_list_tail ( pinfo -> layers ) ) ; if ( proto_ip == ( gint ) GPOINTER_TO_UINT ( wmem_list_frame_data ( frame ) ) ) { frame = wmem_list_frame_prev ( frame ) ; if ( proto_icmp == ( gint ) GPOINTER_TO_UINT ( wmem_list_frame_data ( frame ) ) ) { proto_tree_add_item ( tcp_tree , hf_tcp_seq , tvb , offset + 4 , 4 , ENC_BIG_ENDIAN ) ; icmp_ip = TRUE ; } } } } pinfo -> ptype = PT_TCP ; pinfo -> srcport = tcph -> th_sport ; pinfo -> destport = tcph -> th_dport ; p_add_proto_data ( pinfo -> pool , pinfo , hf_tcp_srcport , pinfo -> curr_layer_num , GUINT_TO_POINTER ( tcph -> th_sport ) ) ; p_add_proto_data ( pinfo -> pool , pinfo , hf_tcp_dstport , pinfo -> curr_layer_num , GUINT_TO_POINTER ( tcph -> th_dport ) ) ; tcph -> th_rawseq = tvb_get_ntohl ( tvb , offset + 4 ) ; tcph -> th_seq = tcph -> th_rawseq ; tcph -> th_ack = tvb_get_ntohl ( tvb , offset + 8 ) ; th_off_x2 = tvb_get_guint8 ( tvb , offset + 12 ) ; tcpinfo . flags = tcph -> th_flags = tvb_get_ntohs ( tvb , offset + 12 ) & TH_MASK ; tcph -> th_win = tvb_get_ntohs ( tvb , offset + 14 ) ; real_window = tcph -> th_win ; tcph -> th_hlen = hi_nibble ( th_off_x2 ) * 4 ; if ( ( conv = find_conversation_pinfo ( pinfo , 0 ) ) != NULL ) { if ( pinfo -> num > conv -> last_frame ) { save_last_frame = conv -> last_frame ; conv -> last_frame = pinfo -> num ; } } else { conv = conversation_new ( pinfo -> num , & pinfo -> src , & pinfo -> dst , ENDPOINT_TCP , pinfo -> srcport , pinfo -> destport , 0 ) ; } tcpd = get_tcp_conversation_data ( conv , pinfo ) ; if ( tcpd && ( ( tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == TH_SYN ) && ( tcpd -> fwd -> static_flags & TCP_S_BASE_SEQ_SET ) && ( tcph -> th_seq != tcpd -> fwd -> base_seq ) ) { if ( ! ( pinfo -> fd -> visited ) ) { if ( save_last_frame > 0 ) conv -> last_frame = save_last_frame ; conv = conversation_new ( pinfo -> num , & pinfo -> src , & pinfo -> dst , ENDPOINT_TCP , pinfo -> srcport , pinfo -> destport , 0 ) ; tcpd = get_tcp_conversation_data ( conv , pinfo ) ; } if ( ! tcpd -> ta ) tcp_analyze_get_acked_struct ( pinfo -> num , tcph -> th_seq , tcph -> th_ack , TRUE , tcpd ) ; tcpd -> ta -> flags |= TCP_A_REUSED_PORTS ; } if ( tcpd && ( ( tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) && ( tcpd -> fwd -> static_flags & TCP_S_BASE_SEQ_SET ) && ( tcph -> th_seq != tcpd -> fwd -> base_seq ) ) { if ( ! ( pinfo -> fd -> visited ) ) { if ( save_last_frame > 0 ) conv -> last_frame = save_last_frame ; } other_conv = find_conversation ( pinfo -> num , & pinfo -> dst , & pinfo -> src , ENDPOINT_TCP , pinfo -> destport , pinfo -> srcport , 0 ) ; if ( other_conv != NULL ) { conv = other_conv ; tcpd = get_tcp_conversation_data ( conv , pinfo ) ; } if ( ! tcpd -> ta ) tcp_analyze_get_acked_struct ( pinfo -> num , tcph -> th_seq , tcph -> th_ack , TRUE , tcpd ) ; tcpd -> ta -> flags |= TCP_A_REUSED_PORTS ; } if ( tcpd ) { item = proto_tree_add_uint ( tcp_tree , hf_tcp_stream , tvb , offset , 0 , tcpd -> stream ) ; PROTO_ITEM_SET_GENERATED ( item ) ; tcph -> th_stream = tcpd -> stream ; } if ( tcp_calculate_ts ) { tcppd = ( struct tcp_per_packet_data_t * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_tcp , pinfo -> curr_layer_num ) ; if ( ! ( pinfo -> fd -> visited ) ) tcp_calculate_timestamps ( pinfo , tcpd , tcppd ) ; } reported_len = tvb_reported_length ( tvb ) ; if ( ! pinfo -> fragmented && ! pinfo -> flags . in_error_pkt ) { if ( reported_len < tcph -> th_hlen ) { proto_tree_add_expert_format ( tcp_tree , pinfo , & ei_tcp_short_segment , tvb , offset , 0 , \"Short<S2SV_blank>segment.<S2SV_blank>Segment/fragment<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>full<S2SV_blank>TCP<S2SV_blank>header\" \"<S2SV_blank>(might<S2SV_blank>be<S2SV_blank>NMAP<S2SV_blank>or<S2SV_blank>someone<S2SV_blank>else<S2SV_blank>deliberately<S2SV_blank>sending<S2SV_blank>unusual<S2SV_blank>packets)\" ) ; tcph -> th_have_seglen = FALSE ; } else { proto_item * pi ; tcph -> th_seglen = reported_len - tcph -> th_hlen ; tcph -> th_have_seglen = TRUE ; pi = proto_tree_add_uint ( ti , hf_tcp_len , tvb , offset + 12 , 1 , tcph -> th_seglen ) ; PROTO_ITEM_SET_GENERATED ( pi ) ; if ( tcp_analyze_seq ) { if ( ! ( pinfo -> fd -> visited ) ) { tcp_analyze_sequence_number ( pinfo , tcph -> th_seq , tcph -> th_ack , tcph -> th_seglen , tcph -> th_flags , tcph -> th_win , tcpd ) ; } if ( tcpd && tcp_relative_seq ) { ( tcph -> th_seq ) -= tcpd -> fwd -> base_seq ; if ( tcph -> th_flags & TH_ACK ) { ( tcph -> th_ack ) -= tcpd -> rev -> base_seq ; } } } if ( ! ( tcph -> th_flags & TH_SYN ) ) { if ( tcpd && ( tcpd -> fwd -> win_scale >= 0 ) ) { ( tcph -> th_win ) <<= tcpd -> fwd -> win_scale ; } else { if ( tcp_default_window_scaling >= 0 ) { ( tcph -> th_win ) <<= tcp_default_window_scaling ; } } } nxtseq = tcph -> th_seq + tcph -> th_seglen ; if ( ( tcph -> th_flags & ( TH_SYN | TH_FIN ) ) && ( tcph -> th_seglen > 0 ) ) { nxtseq += 1 ; } } } else tcph -> th_have_seglen = FALSE ; flags_str = tcp_flags_to_str ( wmem_packet_scope ( ) , tcph ) ; flags_str_first_letter = tcp_flags_to_str_first_letter ( tcph ) ; col_append_lstr ( pinfo -> cinfo , COL_INFO , \"<S2SV_blank>[\" , flags_str , \"]\" , COL_ADD_LSTR_TERMINATOR ) ; tcp_info_append_uint ( pinfo , \"Seq\" , tcph -> th_seq ) ; if ( tcph -> th_flags & TH_ACK ) tcp_info_append_uint ( pinfo , \"Ack\" , tcph -> th_ack ) ; tcp_info_append_uint ( pinfo , \"Win\" , tcph -> th_win ) ; if ( tcp_summary_in_tree ) { proto_item_append_text ( ti , \",<S2SV_blank>Seq:<S2SV_blank>%u\" , tcph -> th_seq ) ; } if ( ! icmp_ip ) { if ( tcp_relative_seq && tcp_analyze_seq ) { proto_tree_add_uint_format_value ( tcp_tree , hf_tcp_seq , tvb , offset + 4 , 4 , tcph -> th_seq , \"%u<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(relative<S2SV_blank>sequence<S2SV_blank>number)\" , tcph -> th_seq ) ; } else { proto_tree_add_uint ( tcp_tree , hf_tcp_seq , tvb , offset + 4 , 4 , tcph -> th_seq ) ; } } if ( tcph -> th_hlen < TCPH_MIN_LEN ) { col_append_fstr ( pinfo -> cinfo , COL_INFO , \",<S2SV_blank>bogus<S2SV_blank>TCP<S2SV_blank>header<S2SV_blank>length<S2SV_blank>(%u,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>at<S2SV_blank>least<S2SV_blank>%u)\" , tcph -> th_hlen , TCPH_MIN_LEN ) ; if ( tree ) { tf = proto_tree_add_uint_bits_format_value ( tcp_tree , hf_tcp_hdr_len , tvb , ( offset + 12 ) << 3 , 4 , tcph -> th_hlen , \"%u<S2SV_blank>bytes<S2SV_blank>(%u)\" , tcph -> th_hlen , tcph -> th_hlen >> 2 ) ; expert_add_info_format ( pinfo , tf , & ei_tcp_bogus_header_length , \"Bogus<S2SV_blank>TCP<S2SV_blank>header<S2SV_blank>length<S2SV_blank>(%u,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>at<S2SV_blank>least<S2SV_blank>%u)\" , tcph -> th_hlen , TCPH_MIN_LEN ) ; } return offset + 12 ; } if ( tcp_summary_in_tree ) { if ( tcph -> th_flags & TH_ACK ) { proto_item_append_text ( ti , \",<S2SV_blank>Ack:<S2SV_blank>%u\" , tcph -> th_ack ) ; } if ( tcph -> th_have_seglen ) proto_item_append_text ( ti , \",<S2SV_blank>Len:<S2SV_blank>%u\" , tcph -> th_seglen ) ; } proto_item_set_len ( ti , tcph -> th_hlen ) ; if ( tcph -> th_have_seglen ) { if ( tcp_relative_seq && tcp_analyze_seq ) { tf = proto_tree_add_uint_format_value ( tcp_tree , hf_tcp_nxtseq , tvb , offset , 0 , nxtseq , \"%u<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(relative<S2SV_blank>sequence<S2SV_blank>number)\" , nxtseq ) ; } else { tf = proto_tree_add_uint ( tcp_tree , hf_tcp_nxtseq , tvb , offset , 0 , nxtseq ) ; } PROTO_ITEM_SET_GENERATED ( tf ) ; } tf = proto_tree_add_uint ( tcp_tree , hf_tcp_ack , tvb , offset + 8 , 4 , tcph -> th_ack ) ; if ( tcph -> th_flags & TH_ACK ) { if ( tcp_relative_seq && tcp_analyze_seq ) { proto_item_append_text ( tf , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(relative<S2SV_blank>ack<S2SV_blank>number)\" ) ; } } else { if ( tvb_get_ntohl ( tvb , offset + 8 ) != 0 ) { expert_add_info ( pinfo , tf , & ei_tcp_ack_nonzero ) ; } } if ( tree ) { proto_tree_add_uint_bits_format_value ( tcp_tree , hf_tcp_hdr_len , tvb , ( offset + 12 ) << 3 , 4 , tcph -> th_hlen , \"%u<S2SV_blank>bytes<S2SV_blank>(%u)\" , tcph -> th_hlen , tcph -> th_hlen >> 2 ) ; tf = proto_tree_add_uint_format ( tcp_tree , hf_tcp_flags , tvb , offset + 12 , 2 , tcph -> th_flags , \"Flags:<S2SV_blank>0x%03x<S2SV_blank>(%s)\" , tcph -> th_flags , flags_str ) ; field_tree = proto_item_add_subtree ( tf , ett_tcp_flags ) ; proto_tree_add_boolean ( field_tree , hf_tcp_flags_res , tvb , offset + 12 , 1 , tcph -> th_flags ) ; proto_tree_add_boolean ( field_tree , hf_tcp_flags_ns , tvb , offset + 12 , 1 , tcph -> th_flags ) ; proto_tree_add_boolean ( field_tree , hf_tcp_flags_cwr , tvb , offset + 13 , 1 , tcph -> th_flags ) ; proto_tree_add_boolean ( field_tree , hf_tcp_flags_ecn , tvb , offset + 13 , 1 , tcph -> th_flags ) ; proto_tree_add_boolean ( field_tree , hf_tcp_flags_urg , tvb , offset + 13 , 1 , tcph -> th_flags ) ; proto_tree_add_boolean ( field_tree , hf_tcp_flags_ack , tvb , offset + 13 , 1 , tcph -> th_flags ) ; proto_tree_add_boolean ( field_tree , hf_tcp_flags_push , tvb , offset + 13 , 1 , tcph -> th_flags ) ; tf_rst = proto_tree_add_boolean ( field_tree , hf_tcp_flags_reset , tvb , offset + 13 , 1 , tcph -> th_flags ) ; tf_syn = proto_tree_add_boolean ( field_tree , hf_tcp_flags_syn , tvb , offset + 13 , 1 , tcph -> th_flags ) ; tf_fin = proto_tree_add_boolean ( field_tree , hf_tcp_flags_fin , tvb , offset + 13 , 1 , tcph -> th_flags ) ; tf = proto_tree_add_string ( field_tree , hf_tcp_flags_str , tvb , offset + 12 , 2 , flags_str_first_letter ) ; PROTO_ITEM_SET_GENERATED ( tf ) ; proto_tree_add_uint ( tcp_tree , hf_tcp_window_size_value , tvb , offset + 14 , 2 , real_window ) ; scaled_pi = proto_tree_add_uint ( tcp_tree , hf_tcp_window_size , tvb , offset + 14 , 2 , tcph -> th_win ) ; PROTO_ITEM_SET_GENERATED ( scaled_pi ) ; if ( ! ( tcph -> th_flags & TH_SYN ) && tcpd ) { switch ( tcpd -> fwd -> win_scale ) { case - 1 : { gint16 win_scale = tcpd -> fwd -> win_scale ; gboolean override_with_pref = FALSE ; if ( tcp_default_window_scaling != WindowScaling_NotKnown ) { win_scale = tcp_default_window_scaling ; override_with_pref = TRUE ; } scaled_pi = proto_tree_add_int_format_value ( tcp_tree , hf_tcp_window_size_scalefactor , tvb , offset + 14 , 2 , win_scale , \"%d<S2SV_blank>(%s)\" , win_scale , ( override_with_pref ) ? \"missing<S2SV_blank>-<S2SV_blank>taken<S2SV_blank>from<S2SV_blank>preference\" : \"unknown\" ) ; PROTO_ITEM_SET_GENERATED ( scaled_pi ) ; } break ; case - 2 : scaled_pi = proto_tree_add_int_format_value ( tcp_tree , hf_tcp_window_size_scalefactor , tvb , offset + 14 , 2 , tcpd -> fwd -> win_scale , \"%d<S2SV_blank>(no<S2SV_blank>window<S2SV_blank>scaling<S2SV_blank>used)\" , tcpd -> fwd -> win_scale ) ; PROTO_ITEM_SET_GENERATED ( scaled_pi ) ; break ; default : scaled_pi = proto_tree_add_int_format_value ( tcp_tree , hf_tcp_window_size_scalefactor , tvb , offset + 14 , 2 , 1 << tcpd -> fwd -> win_scale , \"%d\" , 1 << tcpd -> fwd -> win_scale ) ; PROTO_ITEM_SET_GENERATED ( scaled_pi ) ; } } } if ( tcph -> th_flags & TH_SYN ) { if ( tcph -> th_flags & TH_ACK ) { expert_add_info_format ( pinfo , tf_syn , & ei_tcp_connection_sack , \"Connection<S2SV_blank>establish<S2SV_blank>acknowledge<S2SV_blank>(SYN+ACK):<S2SV_blank>server<S2SV_blank>port<S2SV_blank>%u\" , tcph -> th_sport ) ; tcpd -> server_port = tcph -> th_sport ; } else { expert_add_info_format ( pinfo , tf_syn , & ei_tcp_connection_syn , \"Connection<S2SV_blank>establish<S2SV_blank>request<S2SV_blank>(SYN):<S2SV_blank>server<S2SV_blank>port<S2SV_blank>%u\" , tcph -> th_dport ) ; tcpd -> server_port = tcph -> th_dport ; tcpd -> ts_mru_syn = pinfo -> abs_ts ; } if ( tcp_desegment && tcp_reassemble_out_of_order && tcpd && ! PINFO_FD_VISITED ( pinfo ) ) { if ( tcpd -> fwd -> maxnextseq == 0 ) { tcpd -> fwd -> maxnextseq = tcph -> th_seq + 1 ; } } } if ( tcph -> th_flags & TH_FIN ) { expert_add_info ( pinfo , tf_fin , & ei_tcp_connection_fin ) ; } if ( tcph -> th_flags & TH_RST ) expert_add_info ( pinfo , tf_rst , & ei_tcp_connection_rst ) ; if ( tcp_analyze_seq && ( tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == TH_ACK && ! nstime_is_zero ( & tcpd -> ts_mru_syn ) && nstime_is_zero ( & tcpd -> ts_first_rtt ) ) { nstime_delta ( & ( tcpd -> ts_first_rtt ) , & ( pinfo -> abs_ts ) , & ( tcpd -> ts_mru_syn ) ) ; } tcpinfo . seq = tcph -> th_seq ; tcpinfo . nxtseq = nxtseq ; tcpinfo . lastackseq = tcph -> th_ack ; tcpinfo . is_reassembled = FALSE ; pinfo -> can_desegment = 0 ; th_sum = tvb_get_ntohs ( tvb , offset + 16 ) ; if ( ! pinfo -> fragmented && tvb_bytes_exist ( tvb , 0 , reported_len ) ) { if ( tcp_check_checksum ) { SET_CKSUM_VEC_PTR ( cksum_vec [ 0 ] , ( const guint8 * ) pinfo -> src . data , pinfo -> src . len ) ; SET_CKSUM_VEC_PTR ( cksum_vec [ 1 ] , ( const guint8 * ) pinfo -> dst . data , pinfo -> dst . len ) ; switch ( pinfo -> src . type ) { case AT_IPv4 : phdr [ 0 ] = g_htonl ( ( IP_PROTO_TCP << 16 ) + reported_len ) ; SET_CKSUM_VEC_PTR ( cksum_vec [ 2 ] , ( const guint8 * ) phdr , 4 ) ; break ; case AT_IPv6 : phdr [ 0 ] = g_htonl ( reported_len ) ; phdr [ 1 ] = g_htonl ( IP_PROTO_TCP ) ; SET_CKSUM_VEC_PTR ( cksum_vec [ 2 ] , ( const guint8 * ) phdr , 8 ) ; break ; default : DISSECTOR_ASSERT_NOT_REACHED ( ) ; break ; } SET_CKSUM_VEC_TVB ( cksum_vec [ 3 ] , tvb , offset , reported_len ) ; computed_cksum = in_cksum ( cksum_vec , 4 ) ; if ( computed_cksum == 0 && th_sum == 0xffff ) { item = proto_tree_add_uint_format_value ( tcp_tree , hf_tcp_checksum , tvb , offset + 16 , 2 , th_sum , \"0x%04x<S2SV_blank>[should<S2SV_blank>be<S2SV_blank>0x0000<S2SV_blank>(see<S2SV_blank>RFC<S2SV_blank>1624)]\" , th_sum ) ; checksum_tree = proto_item_add_subtree ( item , ett_tcp_checksum ) ; item = proto_tree_add_uint ( checksum_tree , hf_tcp_checksum_calculated , tvb , offset + 16 , 2 , 0x0000 ) ; PROTO_ITEM_SET_GENERATED ( item ) ; item = proto_tree_add_uint ( checksum_tree , hf_tcp_checksum_status , tvb , <S2SV_StartBug> offset + 16 , 0 , 4 ) ; <S2SV_EndBug> PROTO_ITEM_SET_GENERATED ( item ) ; expert_add_info ( pinfo , item , & ei_tcp_checksum_ffff ) ; col_append_str ( pinfo -> cinfo , COL_INFO , \"<S2SV_blank>[TCP<S2SV_blank>CHECKSUM<S2SV_blank>0xFFFF]\" ) ; desegment_ok = TRUE ; } else { proto_item * calc_item ; item = proto_tree_add_checksum ( tcp_tree , tvb , offset + 16 , hf_tcp_checksum , hf_tcp_checksum_status , & ei_tcp_checksum_bad , pinfo , computed_cksum , ENC_BIG_ENDIAN , PROTO_CHECKSUM_VERIFY | PROTO_CHECKSUM_IN_CKSUM ) ; calc_item = proto_tree_add_uint ( tcp_tree , hf_tcp_checksum_calculated , tvb , offset + 16 , 2 , in_cksum_shouldbe ( th_sum , computed_cksum ) ) ; PROTO_ITEM_SET_GENERATED ( calc_item ) ; if ( computed_cksum == 0 ) { desegment_ok = TRUE ; } else { proto_item_append_text ( item , \"(maybe<S2SV_blank>caused<S2SV_blank>by<S2SV_blank>\\\\\"TCP<S2SV_blank>checksum<S2SV_blank>offload\\\\\"?)\" ) ; desegment_ok = FALSE ; pinfo -> noreassembly_reason = \"<S2SV_blank>[incorrect<S2SV_blank>TCP<S2SV_blank>checksum]\" ; col_append_str ( pinfo -> cinfo , COL_INFO , \"<S2SV_blank>[TCP<S2SV_blank>CHECKSUM<S2SV_blank>INCORRECT]\" ) ; } } } else { proto_tree_add_checksum ( tcp_tree , tvb , offset + 16 , hf_tcp_checksum , hf_tcp_checksum_status , & ei_tcp_checksum_bad , pinfo , 0 , ENC_BIG_ENDIAN , PROTO_CHECKSUM_NO_FLAGS ) ; desegment_ok = TRUE ; } } else { proto_tree_add_checksum ( tcp_tree , tvb , offset + 16 , hf_tcp_checksum , hf_tcp_checksum_status , & ei_tcp_checksum_bad , pinfo , 0 , ENC_BIG_ENDIAN , PROTO_CHECKSUM_NO_FLAGS ) ; desegment_ok = FALSE ; } if ( desegment_ok ) { if ( tcp_desegment ) { if ( ! pinfo -> flags . in_error_pkt ) { pinfo -> can_desegment = 2 ; } } } item = proto_tree_add_item_ret_uint ( tcp_tree , hf_tcp_urgent_pointer , tvb , offset + 18 , 2 , ENC_BIG_ENDIAN , & th_urp ) ; if ( IS_TH_URG ( tcph -> th_flags ) ) { tcpinfo . urgent_pointer = ( guint16 ) th_urp ; tcp_info_append_uint ( pinfo , \"Urg\" , th_urp ) ; } else { if ( th_urp ) { expert_add_info ( pinfo , item , & ei_tcp_urgent_pointer_non_zero ) ; } } if ( tcph -> th_have_seglen ) tcp_info_append_uint ( pinfo , \"Len\" , tcph -> th_seglen ) ; optlen = tcph -> th_hlen - TCPH_MIN_LEN ; options_item = NULL ; options_tree = NULL ; if ( optlen != 0 ) { guint bc = ( guint ) tvb_captured_length_remaining ( tvb , offset + 20 ) ; if ( tcp_tree != NULL ) { options_item = proto_tree_add_item ( tcp_tree , hf_tcp_options , tvb , offset + 20 , bc < optlen ? bc : optlen , ENC_NA ) ; proto_item_set_text ( options_item , \"Options:<S2SV_blank>(%u<S2SV_blank>bytes)\" , optlen ) ; options_tree = proto_item_add_subtree ( options_item , ett_tcp_options ) ; } } tcph -> num_sack_ranges = 0 ; if ( tcp_analyze_seq ) { guint32 use_seq = tcph -> th_seq ; guint32 use_ack = tcph -> th_ack ; if ( tcp_relative_seq ) { use_seq += tcpd -> fwd -> base_seq ; if ( tcph -> th_flags & TH_ACK ) { use_ack += tcpd -> rev -> base_seq ; } } tcp_print_sequence_number_analysis ( pinfo , tvb , tcp_tree , tcpd , use_seq , use_ack ) ; } if ( tcp_calculate_ts ) { tcp_print_timestamps ( pinfo , tvb , tcp_tree , tcpd , tcppd ) ; } if ( optlen ) { rvbd_option_data * option_data ; tcp_dissect_options ( tvb , offset + 20 , optlen , TCPOPT_EOL , pinfo , options_tree , options_item , tcph ) ; option_data = ( rvbd_option_data * ) p_get_proto_data ( pinfo -> pool , pinfo , proto_tcp_option_rvbd_probe , pinfo -> curr_layer_num ) ; if ( option_data != NULL ) { if ( option_data -> valid ) { col_prepend_fstr ( pinfo -> cinfo , COL_INFO , \"S%s,<S2SV_blank>\" , option_data -> type == PROBE_TRACE ? \"#\" : ( option_data -> probe_flags & RVBD_FLAGS_PROBE_NCFE ) ? \"+*\" : \"+\" ) ; } } } if ( ! pinfo -> fd -> visited ) { if ( ( tcph -> th_flags & TH_SYN ) == TH_SYN ) { verify_tcp_window_scaling ( ( tcph -> th_flags & TH_ACK ) == TH_ACK , tcpd ) ; } if ( ( tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) { if ( tcpd && ( ( tcpd -> rev -> scps_capable ) || ( tcpd -> fwd -> scps_capable ) ) ) { verify_scps ( pinfo , tf_syn , tcpd ) ; } } } if ( tcph -> th_mptcp ) { if ( tcp_analyze_mptcp ) { mptcp_add_analysis_subtree ( pinfo , tvb , tcp_tree , tcpd , tcpd -> mptcp_analysis , tcph ) ; } } offset += tcph -> th_hlen ; captured_length_remaining = tvb_captured_length_remaining ( tvb , offset ) ; if ( tcph -> th_have_seglen ) { if ( have_tap_listener ( tcp_follow_tap ) ) { tcp_follow_tap_data_t * follow_data = wmem_new0 ( wmem_packet_scope ( ) , tcp_follow_tap_data_t ) ; follow_data -> tvb = tvb_new_subset_remaining ( tvb , offset ) ; follow_data -> tcph = tcph ; follow_data -> tcpd = tcpd ; tap_queue_packet ( tcp_follow_tap , pinfo , follow_data ) ; } } tap_queue_packet ( tcp_tap , pinfo , tcph ) ; if ( tcpd -> mptcp_analysis ) { tap_queue_packet ( mptcp_tap , pinfo , tcpd ) ; } if ( tcph -> th_have_seglen && tcpd && ( tcph -> th_flags & TH_FIN ) && ( tcpd -> fwd -> flags & TCP_FLOW_REASSEMBLE_UNTIL_FIN ) ) { struct tcp_multisegment_pdu * msp ; if ( tcpd -> fwd -> fin == 0 || tcpd -> fwd -> fin == pinfo -> num ) { tcpd -> fwd -> fin = pinfo -> num ; msp = ( struct tcp_multisegment_pdu * ) wmem_tree_lookup32_le ( tcpd -> fwd -> multisegment_pdus , tcph -> th_seq - 1 ) ; if ( msp ) { fragment_head * ipfd_head ; ipfd_head = fragment_add ( & tcp_reassembly_table , tvb , offset , pinfo , msp -> first_frame , NULL , tcph -> th_seq - msp -> seq , tcph -> th_seglen , FALSE ) ; if ( ipfd_head ) { tvbuff_t * next_tvb ; next_tvb = tvb_new_chain ( tvb , ipfd_head -> tvb_data ) ; add_new_data_source ( pinfo , next_tvb , \"Reassembled<S2SV_blank>TCP\" ) ; print_tcp_fragment_tree ( ipfd_head , tree , tcp_tree , pinfo , next_tvb ) ; pinfo -> can_desegment = 0 ; process_tcp_payload ( next_tvb , 0 , pinfo , tree , tcp_tree , tcph -> th_sport , tcph -> th_dport , tcph -> th_seq , nxtseq , FALSE , tcpd , & tcpinfo ) ; return tvb_captured_length ( tvb ) ; } } } else { proto_tree_add_uint ( tcp_tree , hf_tcp_fin_retransmission , tvb , 0 , 0 , tcpd -> fwd -> fin ) ; } } if ( tcp_display_process_info && tcpd && ( ( tcpd -> fwd && tcpd -> fwd -> process_info && tcpd -> fwd -> process_info -> command ) || ( tcpd -> rev && tcpd -> rev -> process_info && tcpd -> rev -> process_info -> command ) ) ) { field_tree = proto_tree_add_subtree ( tcp_tree , tvb , offset , 0 , ett_tcp_process_info , & ti , \"Process<S2SV_blank>Information\" ) ; PROTO_ITEM_SET_GENERATED ( ti ) ; if ( tcpd -> fwd && tcpd -> fwd -> process_info && tcpd -> fwd -> process_info -> command ) { proto_tree_add_uint ( field_tree , hf_tcp_proc_dst_uid , tvb , 0 , 0 , tcpd -> fwd -> process_info -> process_uid ) ; proto_tree_add_uint ( field_tree , hf_tcp_proc_dst_pid , tvb , 0 , 0 , tcpd -> fwd -> process_info -> process_pid ) ; proto_tree_add_string ( field_tree , hf_tcp_proc_dst_uname , tvb , 0 , 0 , tcpd -> fwd -> process_info -> username ) ; proto_tree_add_string ( field_tree , hf_tcp_proc_dst_cmd , tvb , 0 , 0 , tcpd -> fwd -> process_info -> command ) ; } if ( tcpd -> rev && tcpd -> rev -> process_info && tcpd -> rev -> process_info -> command ) { proto_tree_add_uint ( field_tree , hf_tcp_proc_src_uid , tvb , 0 , 0 , tcpd -> rev -> process_info -> process_uid ) ; proto_tree_add_uint ( field_tree , hf_tcp_proc_src_pid , tvb , 0 , 0 , tcpd -> rev -> process_info -> process_pid ) ; proto_tree_add_string ( field_tree , hf_tcp_proc_src_uname , tvb , 0 , 0 , tcpd -> rev -> process_info -> username ) ; proto_tree_add_string ( field_tree , hf_tcp_proc_src_cmd , tvb , 0 , 0 , tcpd -> rev -> process_info -> command ) ; } } if ( captured_length_remaining != 0 ) { if ( tcph -> th_flags & TH_RST ) { proto_tree_add_item ( tcp_tree , hf_tcp_reset_cause , tvb , offset , captured_length_remaining , ENC_NA | ENC_ASCII ) ; } else { if ( ( tcph -> th_flags & ( TH_FIN | TH_SYN ) ) && ( tcph -> th_seglen > 0 ) ) { nxtseq -= 1 ; } dissect_tcp_payload ( tvb , pinfo , offset , tcph -> th_seq , nxtseq , tcph -> th_sport , tcph -> th_dport , tree , tcp_tree , tcpd , & tcpinfo ) ; } } return tvb_captured_length ( tvb ) ; }", "target": "<S2SV_ModStart> , 0 , PROTO_CHECKSUM_E_BAD <S2SV_ModEnd> ) ; PROTO_ITEM_SET_GENERATED"}
{"source": "CWE-401 static void umd_cleanup ( struct subprocess_info * info ) { struct umd_info * umd_info = info -> data ; <S2SV_StartBug> if ( info -> retval ) { <S2SV_EndBug> fput ( umd_info -> pipe_to_umh ) ; fput ( umd_info -> pipe_from_umh ) ; put_pid ( umd_info -> tgid ) ; umd_info -> tgid = NULL ; } }", "target": "<S2SV_ModStart> -> retval ) umd_cleanup_helper ( umd_info ) ; <S2SV_ModEnd> }  <S2SV_null>"}
{"source": "CWE-416 static int xmlXPathCompOpEvalPositionalPredicate ( xmlXPathParserContextPtr ctxt , xmlXPathStepOpPtr op , xmlNodeSetPtr set , int contextSize , int minPos , int maxPos , int hasNsNodes ) { if ( op -> ch1 != - 1 ) { xmlXPathCompExprPtr comp = ctxt -> comp ; if ( comp -> steps [ op -> ch1 ] . op != XPATH_OP_PREDICATE ) { } contextSize = xmlXPathCompOpEvalPredicate ( ctxt , & comp -> steps [ op -> ch1 ] , set , contextSize , hasNsNodes ) ; CHECK_ERROR0 ; if ( contextSize <= 0 ) return ( 0 ) ; } if ( contextSize < minPos ) { xmlXPathNodeSetClear ( set , hasNsNodes ) ; return ( 0 ) ; } if ( op -> ch2 == - 1 ) { return ( contextSize ) ; } else { xmlDocPtr oldContextDoc ; int i , pos = 0 , newContextSize = 0 , contextPos = 0 , res ; xmlXPathStepOpPtr exprOp ; xmlXPathObjectPtr contextObj = NULL , exprRes = NULL ; xmlNodePtr oldContextNode , contextNode = NULL ; xmlXPathContextPtr xpctxt = ctxt -> context ; int frame ; # ifdef LIBXML_XPTR_ENABLED # endif oldContextNode = xpctxt -> node ; oldContextDoc = xpctxt -> doc ; exprOp = & ctxt -> comp -> steps [ op -> ch2 ] ; for ( i = 0 ; i < set -> nodeNr ; i ++ ) { xmlXPathObjectPtr tmp ; if ( set -> nodeTab [ i ] == NULL ) continue ; contextNode = set -> nodeTab [ i ] ; xpctxt -> node = contextNode ; xpctxt -> contextSize = contextSize ; xpctxt -> proximityPosition = ++ contextPos ; if ( ( contextNode -> type != XML_NAMESPACE_DECL ) && ( contextNode -> doc != NULL ) ) xpctxt -> doc = contextNode -> doc ; if ( contextObj == NULL ) contextObj = xmlXPathCacheNewNodeSet ( xpctxt , contextNode ) ; else { if ( xmlXPathNodeSetAddUnique ( contextObj -> nodesetval , contextNode ) < 0 ) { ctxt -> error = XPATH_MEMORY_ERROR ; goto evaluation_exit ; } } <S2SV_StartBug> frame = xmlXPathSetFrame ( ctxt ) ; <S2SV_EndBug> <S2SV_StartBug> valuePush ( ctxt , contextObj ) ; <S2SV_EndBug> res = xmlXPathCompOpEvalToBoolean ( ctxt , exprOp , 1 ) ; <S2SV_StartBug> tmp = valuePop ( ctxt ) ; <S2SV_EndBug> xmlXPathPopFrame ( ctxt , frame ) ; if ( ( ctxt -> error != XPATH_EXPRESSION_OK ) || ( res == - 1 ) ) { while ( tmp != contextObj ) { xmlXPathReleaseObject ( xpctxt , tmp ) ; tmp = valuePop ( ctxt ) ; } goto evaluation_error ; } valuePush ( ctxt , tmp ) ; if ( res ) pos ++ ; if ( res && ( pos >= minPos ) && ( pos <= maxPos ) ) { newContextSize ++ ; if ( minPos == maxPos ) { if ( contextNode -> type == XML_NAMESPACE_DECL ) { set -> nodeTab [ i ] = NULL ; } xmlXPathNodeSetClear ( set , hasNsNodes ) ; set -> nodeNr = 1 ; set -> nodeTab [ 0 ] = contextNode ; goto evaluation_exit ; } if ( pos == maxPos ) { xmlXPathNodeSetClearFromPos ( set , i + 1 , hasNsNodes ) ; goto evaluation_exit ; } } else { set -> nodeTab [ i ] = NULL ; if ( contextNode -> type == XML_NAMESPACE_DECL ) xmlXPathNodeSetFreeNs ( ( xmlNsPtr ) contextNode ) ; } if ( exprRes != NULL ) { xmlXPathReleaseObject ( ctxt -> context , exprRes ) ; exprRes = NULL ; } if ( ctxt -> value == contextObj ) { valuePop ( ctxt ) ; xmlXPathNodeSetClear ( contextObj -> nodesetval , hasNsNodes ) ; } else { contextObj = NULL ; } } goto evaluation_exit ; evaluation_error : xmlXPathNodeSetClear ( set , hasNsNodes ) ; newContextSize = 0 ; evaluation_exit : if ( contextObj != NULL ) { if ( ctxt -> value == contextObj ) valuePop ( ctxt ) ; xmlXPathReleaseObject ( xpctxt , contextObj ) ; } if ( exprRes != NULL ) xmlXPathReleaseObject ( ctxt -> context , exprRes ) ; xpctxt -> node = oldContextNode ; xpctxt -> doc = oldContextDoc ; xpctxt -> contextSize = - 1 ; xpctxt -> proximityPosition = - 1 ; return ( newContextSize ) ; }", "target": "<S2SV_ModStart> ; } } valuePush ( ctxt , contextObj ) ; <S2SV_ModStart> ctxt ) ; <S2SV_ModEnd> res = xmlXPathCompOpEvalToBoolean <S2SV_ModStart> 1 ) ; xmlXPathPopFrame ( ctxt , frame ) ; <S2SV_ModStart> valuePop ( ctxt <S2SV_ModEnd> ) ; if"}
{"source": "CWE-119 <S2SV_StartBug> void Utf8DecoderBase : : WriteUtf16Slow ( const uint8_t * stream , <S2SV_EndBug> uint16_t * data , unsigned data_length ) { while ( data_length != 0 ) { unsigned cursor = 0 ; <S2SV_StartBug> uint32_t character = Utf8 : : ValueOf ( stream , Utf8 : : kMaxEncodedSize , & cursor ) ; <S2SV_EndBug> <S2SV_StartBug> stream += cursor ; <S2SV_EndBug> if ( character > unibrow : : Utf16 : : kMaxNonSurrogateCharCode ) { * data ++ = Utf16 : : LeadSurrogate ( character ) ; * data ++ = Utf16 : : TrailSurrogate ( character ) ; DCHECK ( data_length > 1 ) ; data_length -= 2 ; } else { * data ++ = character ; data_length -= 1 ; } } <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> uint8_t * stream , unsigned stream_length <S2SV_ModStart> ( stream , stream_length <S2SV_ModEnd> , & cursor <S2SV_ModStart> ; stream += cursor ; stream_length -= <S2SV_ModStart> ; } } DCHECK ( stream_length >= 0 ) ;"}
{"source": "CWE-369 MagickExport Image * WaveImage ( const Image * image , const double amplitude , const double wave_length , ExceptionInfo * exception ) { # define WaveImageTag \"Wave/Image\" CacheView * image_view , * wave_view ; float * sine_map ; Image * wave_image ; MagickBooleanType status ; MagickOffsetType progress ; MagickPixelPacket zero ; ssize_t i ; ssize_t y ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; wave_image = CloneImage ( image , image -> columns , ( size_t ) ( image -> rows + 2.0 * fabs ( amplitude ) ) , MagickTrue , exception ) ; if ( wave_image == ( Image * ) NULL ) return ( ( Image * ) NULL ) ; if ( SetImageStorageClass ( wave_image , DirectClass ) == MagickFalse ) { InheritException ( exception , & wave_image -> exception ) ; wave_image = DestroyImage ( wave_image ) ; return ( ( Image * ) NULL ) ; } if ( wave_image -> background_color . opacity != OpaqueOpacity ) wave_image -> matte = MagickTrue ; sine_map = ( float * ) AcquireQuantumMemory ( ( size_t ) wave_image -> columns , sizeof ( * sine_map ) ) ; if ( sine_map == ( float * ) NULL ) { wave_image = DestroyImage ( wave_image ) ; ThrowImageException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } for ( i = 0 ; i < ( ssize_t ) wave_image -> columns ; i ++ ) sine_map [ i ] = ( float ) fabs ( amplitude ) + amplitude * sin ( ( double ) <S2SV_StartBug> ( ( 2.0 * MagickPI * i ) / wave_length ) ) ; <S2SV_EndBug> status = MagickTrue ; progress = 0 ; GetMagickPixelPacket ( wave_image , & zero ) ; image_view = AcquireVirtualCacheView ( image , exception ) ; wave_view = AcquireAuthenticCacheView ( wave_image , exception ) ; ( void ) SetCacheViewVirtualPixelMethod ( image_view , BackgroundVirtualPixelMethod ) ; # if defined ( MAGICKCORE_OPENMP_SUPPORT ) # pragma omp parallel for schedule ( static ) shared ( progress , status ) magick_number_threads ( image , wave_image , wave_image -> rows , 1 ) # endif for ( y = 0 ; y < ( ssize_t ) wave_image -> rows ; y ++ ) { MagickPixelPacket pixel ; IndexPacket * magick_restrict indexes ; PixelPacket * magick_restrict q ; ssize_t x ; if ( status == MagickFalse ) continue ; q = QueueCacheViewAuthenticPixels ( wave_view , 0 , y , wave_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } indexes = GetCacheViewAuthenticIndexQueue ( wave_view ) ; pixel = zero ; for ( x = 0 ; x < ( ssize_t ) wave_image -> columns ; x ++ ) { status = InterpolateMagickPixelPacket ( image , image_view , UndefinedInterpolatePixel , ( double ) x , ( double ) ( y - sine_map [ x ] ) , & pixel , exception ) ; if ( status == MagickFalse ) break ; SetPixelPacket ( wave_image , & pixel , q , indexes + x ) ; q ++ ; } if ( SyncCacheViewAuthenticPixels ( wave_view , exception ) == MagickFalse ) status = MagickFalse ; if ( image -> progress_monitor != ( MagickProgressMonitor ) NULL ) { MagickBooleanType proceed ; # if defined ( MAGICKCORE_OPENMP_SUPPORT ) # pragma omp atomic # endif progress ++ ; proceed = SetImageProgress ( image , WaveImageTag , progress , image -> rows ) ; if ( proceed == MagickFalse ) status = MagickFalse ; } } wave_view = DestroyCacheView ( wave_view ) ; image_view = DestroyCacheView ( image_view ) ; sine_map = ( float * ) RelinquishMagickMemory ( sine_map ) ; if ( status == MagickFalse ) wave_image = DestroyImage ( wave_image ) ; return ( wave_image ) ; }", "target": "<S2SV_ModStart> * i ) * PerceptibleReciprocal ( wave_length ) <S2SV_ModEnd> ) ) ;"}
{"source": "CWE-200 static int route4_change ( struct net * net , struct sk_buff * in_skb , struct tcf_proto * tp , unsigned long base , u32 handle , struct nlattr * * tca , void * * arg , bool ovr , bool rtnl_held , struct netlink_ext_ack * extack ) { struct route4_head * head = rtnl_dereference ( tp -> root ) ; struct route4_filter __rcu * * fp ; struct route4_filter * fold , * f1 , * pfp , * f = NULL ; struct route4_bucket * b ; struct nlattr * opt = tca [ TCA_OPTIONS ] ; struct nlattr * tb [ TCA_ROUTE4_MAX + 1 ] ; unsigned int h , th ; int err ; bool new = true ; if ( opt == NULL ) return handle ? - EINVAL : 0 ; err = nla_parse_nested_deprecated ( tb , TCA_ROUTE4_MAX , opt , route4_policy , NULL ) ; if ( err < 0 ) return err ; fold = * arg ; if ( fold && handle && fold -> handle != handle ) return - EINVAL ; err = - ENOBUFS ; f = kzalloc ( sizeof ( struct route4_filter ) , GFP_KERNEL ) ; if ( ! f ) goto errout ; err = tcf_exts_init ( & f -> exts , net , TCA_ROUTE4_ACT , TCA_ROUTE4_POLICE ) ; if ( err < 0 ) goto errout ; if ( fold ) { f -> id = fold -> id ; f -> iif = fold -> iif ; f -> res = fold -> res ; f -> handle = fold -> handle ; f -> tp = fold -> tp ; f -> bkt = fold -> bkt ; new = false ; } err = route4_set_parms ( net , tp , base , f , handle , head , tb , tca [ TCA_RATE ] , new , ovr , extack ) ; if ( err < 0 ) goto errout ; h = from_hash ( f -> handle >> 16 ) ; fp = & f -> bkt -> ht [ h ] ; for ( pfp = rtnl_dereference ( * fp ) ; ( f1 = rtnl_dereference ( * fp ) ) != NULL ; fp = & f1 -> next ) if ( f -> handle < f1 -> handle ) break ; tcf_block_netif_keep_dst ( tp -> chain -> block ) ; rcu_assign_pointer ( f -> next , f1 ) ; rcu_assign_pointer ( * fp , f ) ; if ( fold && fold -> handle && f -> handle != fold -> handle ) { th = to_hash ( fold -> handle ) ; h = from_hash ( fold -> handle >> 16 ) ; b = rtnl_dereference ( head -> table [ th ] ) ; if ( b ) { fp = & b -> ht [ h ] ; for ( pfp = rtnl_dereference ( * fp ) ; pfp ; fp = & pfp -> next , pfp = rtnl_dereference ( * fp ) ) { <S2SV_StartBug> if ( pfp == f ) { <S2SV_EndBug> * fp = f -> next ; break ; } } } } route4_reset_fastmap ( head ) ; * arg = f ; if ( fold ) { tcf_unbind_filter ( tp , & fold -> res ) ; tcf_exts_get_net ( & fold -> exts ) ; tcf_queue_work ( & fold -> rwork , route4_delete_filter_work ) ; } return 0 ; errout : if ( f ) tcf_exts_destroy ( & f -> exts ) ; kfree ( f ) ; return err ; }", "target": "<S2SV_ModStart> ( pfp == fold ) { rcu_assign_pointer ( * fp , fold -> next ) <S2SV_ModEnd> ; break ;"}
{"source": "CWE-416 static int rtsx_usb_ms_drv_remove ( struct platform_device * pdev ) { struct rtsx_usb_ms * host = platform_get_drvdata ( pdev ) ; struct memstick_host * msh = host -> msh ; int err ; host -> eject = true ; cancel_work_sync ( & host -> handle_req ) ; mutex_lock ( & host -> host_mutex ) ; if ( host -> req ) { dev_dbg ( ms_dev ( host ) , \"%s:<S2SV_blank>Controller<S2SV_blank>removed<S2SV_blank>during<S2SV_blank>transfer\\\\n\" , dev_name ( & msh -> dev ) ) ; host -> req -> error = - ENOMEDIUM ; do { err = memstick_next_req ( msh , & host -> req ) ; if ( ! err ) host -> req -> error = - ENOMEDIUM ; } while ( ! err ) ; } mutex_unlock ( & host -> host_mutex ) ; <S2SV_StartBug> memstick_remove_host ( msh ) ; <S2SV_EndBug> <S2SV_StartBug> memstick_free_host ( msh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pm_runtime_active ( ms_dev ( host ) ) ) <S2SV_EndBug> pm_runtime_put ( ms_dev ( host ) ) ; pm_runtime_disable ( ms_dev ( host ) ) ; <S2SV_StartBug> platform_set_drvdata ( pdev , NULL ) ; <S2SV_EndBug> dev_dbg ( ms_dev ( host ) , \":<S2SV_blank>Realtek<S2SV_blank>USB<S2SV_blank>Memstick<S2SV_blank>controller<S2SV_blank>has<S2SV_blank>been<S2SV_blank>removed\\\\n\" ) ; return 0 ; }", "target": "<S2SV_ModStart> host_mutex ) ; if ( pm_runtime_active ( ms_dev ( host ) ) ) pm_runtime_put ( ms_dev ( host ) ) ; pm_runtime_disable ( ms_dev ( host ) ) ; <S2SV_ModStart> msh ) ; dev_dbg ( ms_dev ( host ) , \":<S2SV_blank>Realtek<S2SV_blank>USB<S2SV_blank>Memstick<S2SV_blank>controller<S2SV_blank>has<S2SV_blank>been<S2SV_blank>removed\\\\n\" ) ; <S2SV_ModStart> msh ) ; <S2SV_ModEnd> platform_set_drvdata ( pdev <S2SV_ModStart> pdev , NULL <S2SV_ModEnd> ) ; return"}
{"source": "CWE-862 static ssize_t acpi_table_aml_write ( struct config_item * cfg , const void * data , size_t size ) { const struct acpi_table_header * header = data ; struct acpi_table * table ; <S2SV_StartBug> int ret ; <S2SV_EndBug> table = container_of ( cfg , struct acpi_table , cfg ) ; if ( table -> header ) { pr_err ( \"table<S2SV_blank>already<S2SV_blank>loaded\\\\n\" ) ; return - EBUSY ; } if ( header -> length != size ) { pr_err ( \"invalid<S2SV_blank>table<S2SV_blank>length\\\\n\" ) ; return - EINVAL ; } if ( memcmp ( header -> signature , ACPI_SIG_SSDT , 4 ) ) { pr_err ( \"invalid<S2SV_blank>table<S2SV_blank>signature\\\\n\" ) ; return - EINVAL ; } table = container_of ( cfg , struct acpi_table , cfg ) ; table -> header = kmemdup ( header , header -> length , GFP_KERNEL ) ; if ( ! table -> header ) return - ENOMEM ; ret = acpi_load_table ( table -> header , & table -> index ) ; if ( ret ) { kfree ( table -> header ) ; table -> header = NULL ; } return ret ; }", "target": "<S2SV_ModStart> ; int ret = security_locked_down ( LOCKDOWN_ACPI_TABLES ) ; if ( ret ) return ret"}
{"source": "CWE-476 void get_cmdln_options ( int argc , char * argv [ ] ) { int o ; # if CONFIG_FILE && HAVE_GETPWUID static struct passwd * pwd_entry ; char * str ; # endif # ifdef LONG_OPTIONS int option_index = 0 ; static struct option long_options [ ] = { { \"timeout\" , 1 , 0 , 't' } , # ifdef PROC_NET_DEV { \"procfile\" , 1 , 0 , 'f' } , # endif # ifdef PROC_DISKSTATS { \"diskstatsfile\" , 1 , 0 , 1000 } , { \"partitionsfile\" , 1 , 0 , 1001 } , # endif # if NETSTAT && ALLOW_NETSTATPATH { \"netstat\" , 1 , 0 , 'n' } , # endif # if IOSERVICE_IN { \"longdisknames\" , 0 , 0 , 1002 } , # endif { \"input\" , 1 , 0 , 'i' } , { \"dynamic\" , 1 , 0 , 'd' } , { \"help\" , 0 , 0 , 'h' } , { \"version\" , 0 , 0 , 'V' } , { \"allif\" , 1 , 0 , 'a' } , { \"unit\" , 1 , 0 , 'u' } , { \"ansiout\" , 0 , 0 , 'N' } , # if EXTENDED_STATS { \"type\" , 1 , 0 , 'T' } , { \"avglength\" , 1 , 0 , 'A' } , # endif { \"interfaces\" , 1 , 0 , 'I' } , { \"sumhidden\" , 1 , 0 , 'S' } , { \"output\" , 1 , 0 , 'o' } , # ifdef CSV { \"csvchar\" , 1 , 0 , 'C' } , { \"csvfile\" , 1 , 0 , 'F' } , # endif { \"count\" , 1 , 0 , 'c' } , { \"daemon\" , 1 , 0 , 'D' } , # ifdef HTML { \"htmlrefresh\" , 1 , 0 , 'R' } , { \"htmlheader\" , 1 , 0 , 'H' } , # endif { 0 , 0 , 0 , 0 } } ; # endif # ifdef CONFIG_FILE opterr = 0 ; while ( 1 ) { # ifdef LONG_OPTIONS o = getopt_long ( argc , argv , SHORT_OPTIONS , long_options , & option_index ) ; # else o = getopt ( argc , argv , SHORT_OPTIONS ) ; # endif if ( o == - 1 ) break ; } opterr = 1 ; if ( optind < argc ) { read_config ( argv [ optind ] ) ; } else { read_config ( \"/etc/bwm-ng.conf\" ) ; # ifdef HAVE_GETPWUID pwd_entry = getpwuid ( getuid ( ) ) ; if ( pwd_entry != NULL ) { <S2SV_StartBug> str = ( char * ) malloc ( strlen ( pwd_entry -> pw_dir ) + 14 ) ; <S2SV_EndBug> snprintf ( str , strlen ( pwd_entry -> pw_dir ) + 14 , \"%s/.bwm-ng.conf\" , pwd_entry -> pw_dir ) ; read_config ( str ) ; free ( str ) ; } # endif } optind = 1 ; # endif while ( 1 ) { # ifdef LONG_OPTIONS o = getopt_long ( argc , argv , SHORT_OPTIONS , long_options , & option_index ) ; # else o = getopt ( argc , argv , SHORT_OPTIONS ) ; # endif if ( o == - 1 ) break ; switch ( o ) { case '?' : printf ( \"unknown<S2SV_blank>option:<S2SV_blank>%s\\\\n\" , argv [ optind - 1 ] ) ; exit ( EXIT_FAILURE ) ; break ; case ':' : if ( ! strcmp ( argv [ optind - 1 ] , \"-a\" ) || ! strcasecmp ( argv [ optind - 1 ] , \"--allif\" ) ) show_all_if = 1 ; else if ( ! strcmp ( argv [ optind - 1 ] , \"-d\" ) || ! strcasecmp ( argv [ optind - 1 ] , \"--dynamic\" ) ) dynamic = 1 ; else if ( ! strcmp ( argv [ optind - 1 ] , \"-D\" ) || ! strcasecmp ( argv [ optind - 1 ] , \"--daemon\" ) ) daemonize = 1 ; # ifdef HTML else if ( ! strcmp ( argv [ optind - 1 ] , \"-H\" ) || ! strcasecmp ( argv [ optind - 1 ] , \"--htmlheader\" ) ) html_header = 1 ; # endif else if ( ! strcmp ( argv [ optind - 1 ] , \"-S\" ) || ! strcasecmp ( argv [ optind - 1 ] , \"--sumhidden\" ) ) sumhidden = 1 ; else { printf ( \"%s<S2SV_blank>requires<S2SV_blank>an<S2SV_blank>argument!\\\\n\" , argv [ optind - 1 ] ) ; exit ( EXIT_FAILURE ) ; } break ; # ifdef PROC_DISKSTATS case 1000 : if ( strlen ( optarg ) < PATH_MAX ) strcpy ( PROC_DISKSTATS_FILE , optarg ) ; break ; case 1001 : if ( strlen ( optarg ) < PATH_MAX ) strcpy ( PROC_PARTITIONS_FILE , optarg ) ; break ; # endif # if IOSERVICE_IN case 1002 : long_darwin_disk_names = ! long_darwin_disk_names ; break ; # endif case 'D' : if ( optarg ) daemonize = atoi ( optarg ) ; break ; # ifdef HTML case 'R' : if ( ( optarg ) && atol ( optarg ) > 0 ) { html_refresh = atol ( optarg ) ; } break ; case 'H' : if ( optarg ) html_header = atoi ( optarg ) ; break ; # endif case 'c' : if ( optarg ) output_count = atol ( optarg ) ; break ; # if CSV || HTML case 'F' : if ( optarg ) { if ( out_file ) fclose ( out_file ) ; out_file = fopen ( optarg , \"a\" ) ; if ( ! out_file ) deinit ( 1 , \"failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>outfile\\\\n\" ) ; if ( out_file_path ) free ( out_file_path ) ; out_file_path = ( char * ) strdup ( optarg ) ; } break ; # endif # ifdef CSV case 'C' : if ( optarg ) csv_char = optarg [ 0 ] ; break ; # endif case 'h' : cmdln_printhelp ( ) ; break ; # ifdef PROC_NET_DEV case 'f' : if ( optarg && ( strlen ( optarg ) < PATH_MAX ) ) strcpy ( PROC_FILE , optarg ) ; break ; # endif case 'i' : if ( optarg ) { input_method = str2in_method ( optarg ) ; } break ; case 'I' : if ( optarg ) iface_list = ( char * ) strdup ( optarg ) ; break ; case 'S' : if ( optarg ) sumhidden = atoi ( optarg ) ; break ; case 'o' : if ( optarg ) { output_method = str2out_method ( optarg ) ; } break ; case 'N' : ansi_output = ! ansi_output ; case 'a' : if ( optarg ) show_all_if = atoi ( optarg ) ; break ; case 't' : if ( ( optarg ) && atol ( optarg ) > 0 ) { delay = atol ( optarg ) ; } break ; # if EXTENDED_STATS case 'T' : output_type = str2output_type ( optarg ) ; break ; case 'A' : if ( optarg ) avg_length = atoi ( optarg ) * 1000 ; break ; # endif case 'd' : if ( optarg ) dynamic = atoi ( optarg ) ; break ; case 'u' : output_unit = str2output_unit ( optarg ) ; break ; # if NETSTAT && ALLOW_NETSTATPATH case 'n' : if ( optarg && ( strlen ( optarg ) < PATH_MAX ) ) strcpy ( NETSTAT_FILE , optarg ) ; break ; # endif case 'V' : print_version ; exit ( EXIT_SUCCESS ) ; break ; } } if ( iface_list == NULL && show_all_if == 1 ) show_all_if = 2 ; # if EXTENDED_STATS if ( avg_length == 0 ) { if ( delay < AVG_LENGTH / 2 ) avg_length = AVG_LENGTH ; else avg_length = ( delay * 2 ) + 1 ; } else if ( delay * 2 >= avg_length ) deinit ( 1 , \"avglength<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>least<S2SV_blank>twice<S2SV_blank>the<S2SV_blank>value<S2SV_blank>of<S2SV_blank>timeout\\\\n\" ) ; # endif if ( ( output_unit == ERRORS_OUT && ! net_input_method ( input_method ) ) || ( output_unit == PACKETS_OUT && input_method == LIBSTATDISK_IN ) ) output_unit = BYTES_OUT ; return ; }", "target": "<S2SV_ModStart> 14 ) ; if ( ! str ) { printf ( \"Fatal:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%zu<S2SV_blank>bytes.\\\\n\" , strlen ( pwd_entry -> pw_dir ) + 14 ) ; exit ( EXIT_FAILURE ) ; }"}
{"source": "CWE-125 UINT cliprdr_read_format_list ( wStream * s , CLIPRDR_FORMAT_LIST * formatList , BOOL useLongFormatNames ) { UINT32 index ; size_t position ; BOOL asciiNames ; int formatNameLength ; char * szFormatName ; WCHAR * wszFormatName ; <S2SV_StartBug> UINT32 dataLen = formatList -> dataLen ; <S2SV_EndBug> CLIPRDR_FORMAT * formats = NULL ; UINT error = CHANNEL_RC_OK ; asciiNames = ( formatList -> msgFlags & CB_ASCII_NAMES ) ? TRUE : FALSE ; index = 0 ; <S2SV_StartBug> formatList -> numFormats = 0 ; <S2SV_EndBug> <S2SV_StartBug> position = Stream_GetPosition ( s ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! formatList -> dataLen ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> formatList -> formats = NULL ; formatList -> numFormats = 0 ; } else if ( ! useLongFormatNames ) { <S2SV_StartBug> formatList -> numFormats = ( dataLen / 36 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( formatList -> numFormats * 36 ) != dataLen ) <S2SV_EndBug> { <S2SV_StartBug> WLog_ERR ( TAG , \"Invalid<S2SV_blank>short<S2SV_blank>format<S2SV_blank>list<S2SV_blank>length:<S2SV_blank>%\" PRIu32 \"\" , dataLen ) ; <S2SV_EndBug> return ERROR_INTERNAL_ERROR ; } if ( formatList -> numFormats ) formats = ( CLIPRDR_FORMAT * ) calloc ( formatList -> numFormats , sizeof ( CLIPRDR_FORMAT ) ) ; if ( ! formats ) { WLog_ERR ( TAG , \"calloc<S2SV_blank>failed!\" ) ; return CHANNEL_RC_NO_MEMORY ; } formatList -> formats = formats ; <S2SV_StartBug> while ( dataLen ) <S2SV_EndBug> { <S2SV_StartBug> Stream_Read_UINT32 ( s , formats [ index ] . formatId ) ; <S2SV_EndBug> <S2SV_StartBug> dataLen -= 4 ; <S2SV_EndBug> formats [ index ] . formatName = NULL ; <S2SV_StartBug> if ( asciiNames ) <S2SV_EndBug> { <S2SV_StartBug> szFormatName = ( char * ) Stream_Pointer ( s ) ; <S2SV_EndBug> if ( szFormatName [ 0 ] ) { formats [ index ] . formatName = ( char * ) malloc ( 32 + 1 ) ; if ( ! formats [ index ] . formatName ) { WLog_ERR ( TAG , \"malloc<S2SV_blank>failed!\" ) ; error = CHANNEL_RC_NO_MEMORY ; goto error_out ; } CopyMemory ( formats [ index ] . formatName , szFormatName , 32 ) ; formats [ index ] . formatName [ 32 ] = '\\\\0' ; } } else { <S2SV_StartBug> wszFormatName = ( WCHAR * ) Stream_Pointer ( s ) ; <S2SV_EndBug> if ( wszFormatName [ 0 ] ) { if ( ConvertFromUnicode ( CP_UTF8 , 0 , wszFormatName , 16 , & ( formats [ index ] . formatName ) , 0 , NULL , NULL ) < 1 ) { WLog_ERR ( TAG , \"failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>short<S2SV_blank>clipboard<S2SV_blank>format<S2SV_blank>name\" ) ; error = ERROR_INTERNAL_ERROR ; goto error_out ; } } } <S2SV_StartBug> Stream_Seek ( s , 32 ) ; <S2SV_EndBug> dataLen -= 32 ; index ++ ; } } else { <S2SV_StartBug> while ( dataLen ) <S2SV_EndBug> { <S2SV_StartBug> Stream_Seek ( s , 4 ) ; <S2SV_EndBug> dataLen -= 4 ; <S2SV_StartBug> wszFormatName = ( WCHAR * ) Stream_Pointer ( s ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! wszFormatName [ 0 ] ) <S2SV_EndBug> formatNameLength = 0 ; else formatNameLength = _wcslen ( wszFormatName ) ; <S2SV_StartBug> Stream_Seek ( s , ( formatNameLength + 1 ) * 2 ) ; <S2SV_EndBug> <S2SV_StartBug> dataLen -= ( ( formatNameLength + 1 ) * 2 ) ; <S2SV_EndBug> formatList -> numFormats ++ ; } dataLen = formatList -> dataLen ; Stream_SetPosition ( s , position ) ; if ( formatList -> numFormats ) formats = ( CLIPRDR_FORMAT * ) calloc ( formatList -> numFormats , sizeof ( CLIPRDR_FORMAT ) ) ; if ( ! formats ) { WLog_ERR ( TAG , \"calloc<S2SV_blank>failed!\" ) ; return CHANNEL_RC_NO_MEMORY ; } formatList -> formats = formats ; while ( dataLen ) { Stream_Read_UINT32 ( s , formats [ index ] . formatId ) ; dataLen -= 4 ; <S2SV_StartBug> formats [ index ] . formatName = NULL ; <S2SV_EndBug> wszFormatName = ( WCHAR * ) Stream_Pointer ( s ) ; if ( ! wszFormatName [ 0 ] ) formatNameLength = 0 ; else formatNameLength = _wcslen ( wszFormatName ) ; if ( formatNameLength ) { if ( ConvertFromUnicode ( CP_UTF8 , 0 , wszFormatName , - 1 , & ( formats [ index ] . formatName ) , 0 , NULL , NULL ) < 1 ) { WLog_ERR ( TAG , \"failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>long<S2SV_blank>clipboard<S2SV_blank>format<S2SV_blank>name\" ) ; error = ERROR_INTERNAL_ERROR ; goto error_out ; } } <S2SV_StartBug> Stream_Seek ( s , ( formatNameLength + 1 ) * 2 ) ; <S2SV_EndBug> dataLen -= ( ( formatNameLength + 1 ) * 2 ) ; index ++ ; } } return error ; error_out : cliprdr_free_format_list ( formatList ) ; return error ; }", "target": "<S2SV_ModStart> * wszFormatName ; wStream sub1 , sub2 <S2SV_ModEnd> ; CLIPRDR_FORMAT * <S2SV_ModStart> ; formatList -> formats = NULL ; formatList -> <S2SV_ModStart> = 0 ; Stream_StaticInit ( & sub1 , Stream_Pointer <S2SV_ModEnd> ( s ) <S2SV_ModStart> ( s ) , formatList -> dataLen ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! Stream_SafeSeek ( s , <S2SV_ModStart> -> dataLen ) ) return ERROR_INVALID_DATA ; if ( ! formatList -> dataLen ) { <S2SV_ModEnd> } else if <S2SV_ModStart> useLongFormatNames ) { const size_t cap = Stream_Capacity ( & sub1 ) ; <S2SV_ModStart> numFormats = ( cap <S2SV_ModEnd> / 36 ) <S2SV_ModStart> 36 ) != cap <S2SV_ModEnd> ) { WLog_ERR <S2SV_ModStart> TAG , \"Invalid<S2SV_blank>short<S2SV_blank>format<S2SV_blank>list<S2SV_blank>length:<S2SV_blank>%\" PRIuz \"\" , cap <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; while ( Stream_GetRemainingLength ( & sub1 ) >= 4 <S2SV_ModEnd> ) { Stream_Read_UINT32 <S2SV_ModStart> { Stream_Read_UINT32 ( & sub1 <S2SV_ModEnd> , formats [ <S2SV_ModStart> formatId ) ; <S2SV_ModEnd> formats [ index <S2SV_ModStart> = NULL ; szFormatName = ( char * ) Stream_Pointer ( & sub1 ) ; wszFormatName = ( WCHAR * ) Stream_Pointer ( & sub1 ) ; if ( ! Stream_SafeSeek ( & sub1 , 32 ) ) goto error_out ; <S2SV_ModStart> asciiNames ) { <S2SV_ModEnd> if ( szFormatName <S2SV_ModStart> } else { <S2SV_ModEnd> if ( wszFormatName <S2SV_ModStart> } } } <S2SV_ModEnd> index ++ ; <S2SV_ModStart> } else { sub2 = sub1 ; while ( Stream_GetRemainingLength ( & sub1 ) > 0 ) { size_t rest ; if ( ! Stream_SafeSeek ( & sub1 <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 4 ) ) goto error_out <S2SV_ModEnd> ; wszFormatName = <S2SV_ModStart> ) Stream_Pointer ( & sub1 ) ; rest = Stream_GetRemainingLength ( & sub1 ) ; formatNameLength = _wcsnlen ( wszFormatName , rest / sizeof ( WCHAR ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! Stream_SafeSeek ( & sub1 <S2SV_ModEnd> , ( formatNameLength <S2SV_ModStart> 1 ) * sizeof ( WCHAR ) ) ) goto error_out ; formatList -> numFormats ++ ; } if ( formatList -> numFormats ) formats = ( CLIPRDR_FORMAT * ) calloc ( formatList -> numFormats , sizeof ( CLIPRDR_FORMAT ) ) ; if ( ! formats ) { WLog_ERR ( TAG , \"calloc<S2SV_blank>failed!\" ) ; return CHANNEL_RC_NO_MEMORY ; } formatList -> formats = formats ; while ( Stream_GetRemainingLength ( & sub2 ) >= 4 ) { size_t rest ; Stream_Read_UINT32 ( & sub2 , formats [ index ] . formatId ) ; formats [ index ] . formatName = NULL ; wszFormatName = ( WCHAR * ) Stream_Pointer ( & sub2 ) ; rest = Stream_GetRemainingLength ( & sub2 ) ; formatNameLength = _wcsnlen ( wszFormatName , rest / sizeof ( WCHAR ) ) ; if ( ! Stream_SafeSeek ( & sub2 , <S2SV_ModEnd> ( formatNameLength + <S2SV_ModStart> 1 ) * sizeof ( WCHAR ) ) ) goto error_out ; if ( formatNameLength ) { if ( ConvertFromUnicode ( CP_UTF8 , 0 , wszFormatName , formatNameLength , & ( <S2SV_ModEnd> formats [ index <S2SV_ModStart> ] . formatName ) , <S2SV_ModEnd> 0 , NULL <S2SV_ModStart> ; } } <S2SV_ModEnd> index ++ ;"}
{"source": "CWE-787 static int identity_count ( void * v , const char * key , const char * val ) { int * count = v ; <S2SV_StartBug> * count += strlen ( key ) * 3 + strlen ( val ) * 3 + 1 ; <S2SV_EndBug> return 1 ; }", "target": "<S2SV_ModStart> * 3 + 2 <S2SV_ModEnd> ; return 1"}
{"source": "CWE-772 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"enter\" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( strncmp ( MATLAB_HDR . identific , \"MATLAB\" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c\" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"IM\" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"MI\" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , \"MATLAB\" , 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; break ; default : ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.StructureClass<S2SV_blank>%d\" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.CellType:<S2SV_blank>%.20g\" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , \"IncompatibleSizeOfDouble\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"return\" ) ; <S2SV_StartBug> if ( image == NULL ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; return ( image ) ; }", "target": "<S2SV_ModStart> ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( image == NULL ) <S2SV_ModEnd> ThrowReaderException ( CorruptImageError"}
{"source": "CWE-416 static void gprinter_free ( struct usb_function * f ) { struct printer_dev * dev = func_to_printer ( f ) ; struct f_printer_opts * opts ; opts = container_of ( f -> fi , struct f_printer_opts , func_inst ) ; <S2SV_StartBug> kfree ( dev ) ; <S2SV_EndBug> mutex_lock ( & opts -> lock ) ; -- opts -> refcnt ; mutex_unlock ( & opts -> lock ) ; }", "target": "<S2SV_ModStart> func_inst ) ; kref_put ( & dev -> kref , printer_dev_free <S2SV_ModEnd> ) ; mutex_lock"}
{"source": "CWE-787 tiff12_print_page ( gx_device_printer * pdev , gp_file * file ) { gx_device_tiff * const tfdev = ( gx_device_tiff * ) pdev ; int code ; if ( gdev_prn_file_is_new ( pdev ) ) { tfdev -> tif = tiff_from_filep ( pdev , pdev -> dname , file , tfdev -> BigEndian , tfdev -> UseBigTIFF ) ; if ( ! tfdev -> tif ) return_error ( gs_error_invalidfileaccess ) ; } code = gdev_tiff_begin_page ( tfdev , file ) ; if ( code < 0 ) return code ; TIFFSetField ( tfdev -> tif , TIFFTAG_BITSPERSAMPLE , 4 ) ; tiff_set_rgb_fields ( tfdev ) ; TIFFCheckpointDirectory ( tfdev -> tif ) ; { int y ; int size = gdev_prn_raster ( pdev ) ; <S2SV_StartBug> byte * data = gs_alloc_bytes ( pdev -> memory , size , \"tiff12_print_page\" ) ; <S2SV_EndBug> if ( data == 0 ) return_error ( gs_error_VMerror ) ; <S2SV_StartBug> memset ( data , 0 , size ) ; <S2SV_EndBug> for ( y = 0 ; y < pdev -> height ; ++ y ) { const byte * src ; byte * dest ; int x ; code = gdev_prn_copy_scan_lines ( pdev , y , data , size ) ; if ( code < 0 ) break ; for ( src = data , dest = data , x = 0 ; x < size ; src += 6 , dest += 3 , x += 6 ) { dest [ 0 ] = ( src [ 0 ] & 0xf0 ) | ( src [ 1 ] >> 4 ) ; dest [ 1 ] = ( src [ 2 ] & 0xf0 ) | ( src [ 3 ] >> 4 ) ; dest [ 2 ] = ( src [ 4 ] & 0xf0 ) | ( src [ 5 ] >> 4 ) ; } TIFFWriteScanline ( tfdev -> tif , data , y , 0 ) ; } gs_free_object ( pdev -> memory , data , \"tiff12_print_page\" ) ; TIFFWriteDirectory ( tfdev -> tif ) ; } return code ; }", "target": "<S2SV_ModStart> pdev ) ; int size_alloc = size + 5 ; <S2SV_ModStart> -> memory , size_alloc <S2SV_ModEnd> , \"tiff12_print_page\" ) <S2SV_ModStart> , 0 , size_alloc <S2SV_ModEnd> ) ; for"}
{"source": "CWE-125 static int xar_hash_check ( int hash , const void * result , const void * expected ) { int len ; if ( ! result || ! expected ) return 1 ; switch ( hash ) { case XAR_CKSUM_SHA1 : <S2SV_StartBug> len = SHA1_HASH_SIZE ; <S2SV_EndBug> break ; case XAR_CKSUM_MD5 : <S2SV_StartBug> len = CLI_HASH_MD5 ; <S2SV_EndBug> break ; case XAR_CKSUM_OTHER : case XAR_CKSUM_NONE : default : return 1 ; } return memcmp ( result , expected , len ) ; }", "target": "<S2SV_ModStart> : len = CLI_HASHLEN_SHA1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> : len = CLI_HASHLEN_MD5 <S2SV_ModEnd> ; break ;"}
{"source": "CWE-787 void CLASS kodak_65000_load_raw ( ) { short buf [ 256 ] ; int row , col , len , pred [ 2 ] , ret , i ; for ( row = 0 ; row < height ; row ++ ) { # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( col = 0 ; col < width ; col += 256 ) { pred [ 0 ] = pred [ 1 ] = 0 ; len = MIN ( 256 , width - col ) ; ret = kodak_65000_decode ( buf , len ) ; for ( i = 0 ; i < len ; i ++ ) <S2SV_StartBug> if ( ( RAW ( row , col + i ) = curve [ ret ? buf [ i ] : <S2SV_EndBug> <S2SV_StartBug> ( pred [ i & 1 ] += buf [ i ] ) ] ) >> 12 ) derror ( ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug> }", "target": "<S2SV_ModStart> i ++ ) { int idx = <S2SV_ModEnd> ret ? buf <S2SV_ModStart> i ] ) ; if ( idx >= 0 && idx <= 0xffff ) { if ( ( RAW ( row , col + i ) = curve [ idx <S2SV_ModStart> ) ; } else derror ( ) ; } }"}
{"source": "CWE-125 static int propagateConstantExprRewrite ( Walker * pWalker , Expr * pExpr ) { int i ; WhereConst * pConst ; if ( pExpr -> op != TK_COLUMN ) return WRC_Continue ; <S2SV_StartBug> if ( ExprHasProperty ( pExpr , EP_FixedCol ) ) return WRC_Continue ; <S2SV_EndBug> pConst = pWalker -> u . pConst ; for ( i = 0 ; i < pConst -> nConst ; i ++ ) { Expr * pColumn = pConst -> apExpr [ i * 2 ] ; if ( pColumn == pExpr ) continue ; if ( pColumn -> iTable != pExpr -> iTable ) continue ; if ( pColumn -> iColumn != pExpr -> iColumn ) continue ; pConst -> nChng ++ ; ExprClearProperty ( pExpr , EP_Leaf ) ; ExprSetProperty ( pExpr , EP_FixedCol ) ; assert ( pExpr -> pLeft == 0 ) ; pExpr -> pLeft = sqlite3ExprDup ( pConst -> pParse -> db , pConst -> apExpr [ i * 2 + 1 ] , 0 ) ; break ; } return WRC_Prune ; }", "target": "<S2SV_ModStart> pExpr , EP_FixedCol | EP_FromJoin"}
{"source": "CWE-22 prepare_repo_download_targets ( LrHandle * handle , LrYumRepo * repo , LrYumRepoMd * repomd , LrMetadataTarget * mdtarget , GSList * * targets , GSList * * cbdata_list , GError * * err ) { char * destdir ; destdir = handle -> destdir ; assert ( destdir ) ; assert ( strlen ( destdir ) ) ; assert ( ! err || * err == NULL ) ; if ( handle -> cachedir ) { lr_yum_switch_to_zchunk ( handle , repomd ) ; repo -> use_zchunk = TRUE ; } else { g_debug ( \"%s:<S2SV_blank>Cache<S2SV_blank>directory<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>disabling<S2SV_blank>zchunk\" , __func__ ) ; repo -> use_zchunk = FALSE ; } for ( GSList * elem = repomd -> records ; elem ; elem = g_slist_next ( elem ) ) { int fd ; char * path ; LrDownloadTarget * target ; LrYumRepoMdRecord * record = elem -> data ; CbData * cbdata = NULL ; void * user_cbdata = NULL ; LrEndCb endcb = NULL ; if ( mdtarget != NULL ) { user_cbdata = mdtarget -> cbdata ; endcb = mdtarget -> endcb ; } assert ( record ) ; if ( ! lr_yum_repomd_record_enabled ( handle , record -> type , repomd -> records ) ) continue ; char * location_href = record -> location_href ; <S2SV_StartBug> gboolean is_zchunk = FALSE ; <S2SV_EndBug> # ifdef WITH_ZCHUNK if ( handle -> cachedir && record -> header_checksum ) is_zchunk = TRUE ; # endif GSList * checksums = NULL ; if ( is_zchunk ) { # ifdef WITH_ZCHUNK if ( ! prepare_repo_download_zck_target ( handle , record , & path , & fd , & checksums , targets , err ) ) return FALSE ; # endif } else { if ( ! prepare_repo_download_std_target ( handle , record , & path , & fd , & checksums , targets , err ) ) return FALSE ; } if ( handle -> user_cb || handle -> hmfcb ) { cbdata = cbdata_new ( handle -> user_data , user_cbdata , handle -> user_cb , handle -> hmfcb , record -> type ) ; * cbdata_list = g_slist_append ( * cbdata_list , cbdata ) ; } target = lr_downloadtarget_new ( handle , location_href , record -> location_base , fd , NULL , checksums , 0 , 0 , NULL , cbdata , endcb , NULL , NULL , 0 , 0 , NULL , FALSE , is_zchunk ) ; if ( is_zchunk ) { # ifdef WITH_ZCHUNK target -> expectedsize = record -> size_header ; target -> zck_header_size = record -> size_header ; # endif } if ( mdtarget != NULL ) mdtarget -> repomd_records_to_download ++ ; * targets = g_slist_append ( * targets , target ) ; lr_yum_repo_update ( repo , record -> type , path ) ; lr_free ( path ) ; } return TRUE ; }", "target": "<S2SV_ModStart> -> location_href ; char * dest_dir = realpath ( handle -> destdir , NULL ) ; path = lr_pathconcat ( handle -> destdir , record -> location_href , NULL ) ; char * requested_dir = realpath ( dirname ( path ) , NULL ) ; lr_free ( path ) ; if ( ! g_str_has_prefix ( requested_dir , dest_dir ) ) { g_debug ( \"%s:<S2SV_blank>Invalid<S2SV_blank>path:<S2SV_blank>%s\" , __func__ , location_href ) ; g_set_error ( err , LR_YUM_ERROR , LRE_IO , \"Invalid<S2SV_blank>path:<S2SV_blank>%s\" , location_href ) ; g_slist_free_full ( * targets , ( GDestroyNotify ) lr_downloadtarget_free ) ; free ( requested_dir ) ; free ( dest_dir ) ; return FALSE ; } free ( requested_dir ) ; free ( dest_dir ) ;"}
{"source": "CWE-617 static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; size_t size ; size_t num_samples ; <S2SV_StartBug> size_t num_samples_delta ; <S2SV_EndBug> size_t tile_samples ; if ( ! jas_safe_size_mul ( siz -> tilewidth , siz -> tileheight , & tile_samples ) || ( dec -> max_samples > 0 && tile_samples > dec -> max_samples ) ) { jas_eprintf ( \"tile<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; return - 1 ; } dec -> xstart = siz -> xoff ; dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } num_samples = 0 ; for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) ; cmpt -> height = JPC_CEILDIV ( dec -> yend , cmpt -> vstep ) - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) ; cmpt -> hsubstep = 0 ; cmpt -> vsubstep = 0 ; if ( ! jas_safe_size_mul ( cmpt -> width , cmpt -> height , & num_samples_delta ) ) { jas_eprintf ( \"image<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; return - 1 ; } if ( ! jas_safe_size_add ( num_samples , num_samples_delta , & num_samples ) ) { jas_eprintf ( \"image<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; return - 1 ; } } if ( dec -> max_samples > 0 && num_samples > dec -> max_samples ) { jas_eprintf ( \"maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>samples<S2SV_blank>exceeded<S2SV_blank>(%zu<S2SV_blank>><S2SV_blank>%zu)\\\\n\" , num_samples , dec -> max_samples ) ; return - 1 ; } dec -> image = 0 ; dec -> numhtiles = JPC_CEILDIV ( dec -> xend - dec -> tilexoff , dec -> tilewidth ) ; dec -> numvtiles = JPC_CEILDIV ( dec -> yend - dec -> tileyoff , dec -> tileheight ) ; assert ( dec -> numhtiles >= 0 ) ; assert ( dec -> numvtiles >= 0 ) ; if ( ! jas_safe_size_mul ( dec -> numhtiles , dec -> numvtiles , & size ) || size > INT_MAX ) { return - 1 ; } if ( dec -> max_samples > 0 && size > dec -> max_samples / 16 / 16 ) { return - 1 ; } if ( dec -> max_samples > 0 && size > dec -> max_samples / dec -> numcomps / 16 ) { return - 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( \"numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\\\n\" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , ++ tile ) { tile -> state = JPC_TILE_DONE ; } for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , ++ tile ) { htileno = tileno % dec -> numhtiles ; vtileno = tileno / dec -> numhtiles ; tile -> realmode = 0 ; tile -> state = JPC_TILE_INIT ; tile -> xstart = JAS_MAX ( dec -> tilexoff + htileno * dec -> tilewidth , dec -> xstart ) ; tile -> ystart = JAS_MAX ( dec -> tileyoff + vtileno * dec -> tileheight , dec -> ystart ) ; tile -> xend = JAS_MIN ( dec -> tilexoff + ( htileno + 1 ) * dec -> tilewidth , dec -> xend ) ; tile -> yend = JAS_MIN ( dec -> tileyoff + ( vtileno + 1 ) * dec -> tileheight , dec -> yend ) ; tile -> numparts = 0 ; tile -> partno = 0 ; tile -> pkthdrstream = 0 ; tile -> pkthdrstreampos = 0 ; tile -> pptstab = 0 ; tile -> cp = 0 ; tile -> pi = 0 ; if ( ! ( tile -> tcomps = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_tcomp_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ cmpt , ++ tcomp ) { tcomp -> rlvls = 0 ; tcomp -> numrlvls = 0 ; tcomp -> data = 0 ; tcomp -> xstart = JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) ; tcomp -> ystart = JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) ; tcomp -> xend = JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) ; tcomp -> yend = JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ; tcomp -> tsfb = 0 ; } } dec -> pkthdrstreams = 0 ; dec -> state = JPC_MH ; return 0 ; }", "target": "<S2SV_ModStart> size_t num_samples_delta ; size_t total_samples ; if ( ! jas_safe_size_mul ( siz -> width , siz -> height , & total_samples ) || ( dec -> max_samples > 0 && total_samples > dec -> max_samples ) ) { jas_eprintf ( \"image<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; return - 1 ; }"}
{"source": "CWE-125 void LibRaw : : parseSonySRF ( unsigned len ) { if ( ( len > 0xfffff ) || ( len == 0 ) ) return ; INT64 save = ftell ( ifp ) ; INT64 offset = 0x0310c0 - save ; if ( len < offset || offset < 0 ) return ; INT64 decrypt_len = offset >> 2 ; unsigned i , nWB ; unsigned MasterKey , SRF2Key , RawDataKey ; INT64 srf_offset , tag_offset , tag_data , tag_dataoffset ; int tag_dataunitlen ; uchar * srf_buf ; <S2SV_StartBug> short entries ; <S2SV_EndBug> unsigned tag_id , tag_type , tag_datalen ; <S2SV_StartBug> srf_buf = ( uchar * ) malloc ( len ) ; <S2SV_EndBug> fread ( srf_buf , len , 1 , ifp ) ; offset += srf_buf [ offset ] << 2 ; # define CHECKBUFFER_SGET4 ( offset ) do { if ( ( ( ( offset ) + 4 ) > len ) || ( ( offset ) < 0 ) ) goto restore_after_parseSonySRF ; } while ( 0 ) # define CHECKBUFFER_SGET2 ( offset ) do { if ( ( ( offset + 2 ) > len ) || ( ( offset ) < 0 ) ) goto restore_after_parseSonySRF ; } while ( 0 ) CHECKBUFFER_SGET4 ( offset ) ; MasterKey = ( ( unsigned ) srf_buf [ offset ] << 24 ) | ( ( unsigned ) srf_buf [ offset + 1 ] << 16 ) | ( ( unsigned ) srf_buf [ offset + 2 ] << 8 ) | ( unsigned ) srf_buf [ offset + 3 ] ; srf_offset = 0 ; CHECKBUFFER_SGET2 ( srf_offset ) ; entries = sget2 ( srf_buf + srf_offset ) ; if ( entries > 1000 ) goto restore_after_parseSonySRF ; offset = srf_offset + 2 ; CHECKBUFFER_SGET4 ( offset ) ; CHECKBUFFER_SGET4 ( offset + 12 * entries ) ; srf_offset = sget4 ( srf_buf + offset + 12 * entries ) - save ; if ( srf_offset < 0 || decrypt_len < srf_offset / 4 ) goto restore_after_parseSonySRF ; sony_decrypt ( ( unsigned * ) ( srf_buf + srf_offset ) , decrypt_len - srf_offset / 4 , 1 , MasterKey ) ; CHECKBUFFER_SGET2 ( srf_offset ) ; entries = sget2 ( srf_buf + srf_offset ) ; if ( entries > 1000 ) goto restore_after_parseSonySRF ; offset = srf_offset + 2 ; tag_offset = offset ; while ( entries -- ) { if ( tiff_sget ( save , srf_buf , len , & tag_offset , & tag_id , & tag_type , & tag_dataoffset , & tag_datalen , & tag_dataunitlen ) == 0 ) { if ( tag_id == 0x0000 ) { <S2SV_StartBug> SRF2Key = sget4 ( srf_buf + tag_dataoffset ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( tag_id == 0x0001 ) { <S2SV_EndBug> RawDataKey = sget4 ( srf_buf + tag_dataoffset ) ; } } else goto restore_after_parseSonySRF ; } offset = tag_offset ; CHECKBUFFER_SGET4 ( offset ) ; srf_offset = sget4 ( srf_buf + offset ) - save ; if ( srf_offset < 0 || decrypt_len < srf_offset / 4 ) goto restore_after_parseSonySRF ; sony_decrypt ( ( unsigned * ) ( srf_buf + srf_offset ) , decrypt_len - srf_offset / 4 , 1 , SRF2Key ) ; CHECKBUFFER_SGET2 ( srf_offset ) ; entries = sget2 ( srf_buf + srf_offset ) ; if ( entries > 1000 ) goto restore_after_parseSonySRF ; offset = srf_offset + 2 ; tag_offset = offset ; while ( entries -- ) { if ( tiff_sget ( save , srf_buf , len , & tag_offset , & tag_id , & tag_type , & tag_dataoffset , & tag_datalen , & tag_dataunitlen ) == 0 ) { if ( ( tag_id >= 0x00c0 ) && ( tag_id <= 0x00ce ) ) { i = ( tag_id - 0x00c0 ) % 3 ; nWB = ( tag_id - 0x00c0 ) / 3 ; <S2SV_StartBug> icWBC [ Sony_SRF_wb_list [ nWB ] ] [ i ] = sget4 ( srf_buf + tag_dataoffset ) ; <S2SV_EndBug> if ( i == 1 ) { icWBC [ Sony_SRF_wb_list [ nWB ] ] [ 3 ] = icWBC [ Sony_SRF_wb_list [ nWB ] ] [ i ] ; } } else if ( ( tag_id >= 0x00d0 ) && ( tag_id <= 0x00d2 ) ) { i = ( tag_id - 0x00d0 ) % 3 ; <S2SV_StartBug> cam_mul [ i ] = sget4 ( srf_buf + tag_dataoffset ) ; <S2SV_EndBug> if ( i == 1 ) { cam_mul [ 3 ] = cam_mul [ i ] ; } } else switch ( tag_id ) { case 0x0043 : <S2SV_StartBug> ilm . MaxAp4MaxFocal = sgetreal ( tag_type , srf_buf + tag_dataoffset ) ; <S2SV_EndBug> break ; case 0x0044 : <S2SV_StartBug> ilm . MaxAp4MinFocal = sgetreal ( tag_type , srf_buf + tag_dataoffset ) ; <S2SV_EndBug> break ; case 0x0045 : <S2SV_StartBug> ilm . MinFocal = sgetreal ( tag_type , srf_buf + tag_dataoffset ) ; <S2SV_EndBug> break ; case 0x0046 : <S2SV_StartBug> ilm . MaxFocal = sgetreal ( tag_type , srf_buf + tag_dataoffset ) ; <S2SV_EndBug> break ; } } else goto restore_after_parseSonySRF ; } offset = tag_offset ; restore_after_parseSonySRF : free ( srf_buf ) ; fseek ( ifp , save , SEEK_SET ) ; # undef CHECKBUFFER_SGET4 # undef CHECKBUFFER_SGET2 }", "target": "<S2SV_ModStart> * srf_buf ; ushort <S2SV_ModEnd> entries ; unsigned <S2SV_ModStart> malloc ( len + 64 <S2SV_ModStart> 0x0000 ) { CHECKBUFFER_SGET4 ( tag_dataoffset ) ; <S2SV_ModStart> 0x0001 ) { CHECKBUFFER_SGET4 ( tag_dataoffset ) ; <S2SV_ModStart> / 3 ; CHECKBUFFER_SGET4 ( tag_dataoffset ) ; <S2SV_ModStart> % 3 ; CHECKBUFFER_SGET4 ( tag_dataoffset ) ; <S2SV_ModStart> case 0x0043 : CHECKBUFFER_SGET4 ( tag_dataoffset ) ; <S2SV_ModStart> case 0x0044 : CHECKBUFFER_SGET4 ( tag_dataoffset ) ; <S2SV_ModStart> case 0x0045 : CHECKBUFFER_SGET4 ( tag_dataoffset ) ; <S2SV_ModStart> case 0x0046 : CHECKBUFFER_SGET4 ( tag_dataoffset ) ;"}
{"source": "CWE-120 ctnetlink_parse_tuple_filter ( const struct nlattr * const cda [ ] , struct nf_conntrack_tuple * tuple , u32 type , u_int8_t l3num , struct nf_conntrack_zone * zone , u_int32_t flags ) { struct nlattr * tb [ CTA_TUPLE_MAX + 1 ] ; int err ; memset ( tuple , 0 , sizeof ( * tuple ) ) ; err = nla_parse_nested_deprecated ( tb , CTA_TUPLE_MAX , cda [ type ] , tuple_nla_policy , NULL ) ; if ( err < 0 ) return err ; <S2SV_StartBug> <S2SV_EndBug> tuple -> src . l3num = l3num ; if ( flags & CTA_FILTER_FLAG ( CTA_IP_DST ) || flags & CTA_FILTER_FLAG ( CTA_IP_SRC ) ) { if ( ! tb [ CTA_TUPLE_IP ] ) return - EINVAL ; err = ctnetlink_parse_tuple_ip ( tb [ CTA_TUPLE_IP ] , tuple , flags ) ; if ( err < 0 ) return err ; } if ( flags & CTA_FILTER_FLAG ( CTA_PROTO_NUM ) ) { if ( ! tb [ CTA_TUPLE_PROTO ] ) return - EINVAL ; err = ctnetlink_parse_tuple_proto ( tb [ CTA_TUPLE_PROTO ] , tuple , flags ) ; if ( err < 0 ) return err ; } else if ( flags & CTA_FILTER_FLAG ( ALL_CTA_PROTO ) ) { return - EINVAL ; } if ( ( flags & CTA_FILTER_FLAG ( CTA_TUPLE_ZONE ) ) && tb [ CTA_TUPLE_ZONE ] ) { if ( ! zone ) return - EINVAL ; err = ctnetlink_parse_tuple_zone ( tb [ CTA_TUPLE_ZONE ] , type , zone ) ; if ( err < 0 ) return err ; } if ( type == CTA_TUPLE_REPLY ) tuple -> dst . dir = IP_CT_DIR_REPLY ; else tuple -> dst . dir = IP_CT_DIR_ORIGINAL ; return 0 ; }", "target": "<S2SV_ModStart> return err ; if ( l3num != NFPROTO_IPV4 && l3num != NFPROTO_IPV6 ) return - EOPNOTSUPP ;"}
{"source": "CWE-125 <S2SV_StartBug> LJ_NOINLINE void lj_err_run ( lua_State * L ) <S2SV_EndBug> { ptrdiff_t ef = finderrfunc ( L ) ; if ( ef ) { TValue * errfunc = restorestack ( L , ef ) ; TValue * top = L -> top ; lj_trace_abort ( G ( L ) ) ; if ( ! tvisfunc ( errfunc ) || L -> status == LUA_ERRERR ) { setstrV ( L , top - 1 , lj_err_str ( L , LJ_ERR_ERRERR ) ) ; lj_err_throw ( L , LUA_ERRERR ) ; } L -> status = LUA_ERRERR ; copyTV ( L , top , top - 1 ) ; copyTV ( L , top - 1 , errfunc ) ; L -> top = top + 1 ; lj_vm_call ( L , top , 1 + 1 ) ; } lj_err_throw ( L , LUA_ERRRUN ) ; }", "target": "<S2SV_ModStart> <S2SV_null> LJ_NOINLINE void LJ_FASTCALL"}
{"source": "CWE-787 void LibRaw : : parse_exif ( int base ) { unsigned entries , tag , type , len , save , c ; double expo , ape ; unsigned kodak = ! strncmp ( make , \"EASTMAN\" , 7 ) && tiff_nifds < 3 ; entries = get2 ( ) ; if ( ! strncmp ( make , \"Hasselblad\" , 10 ) && ( tiff_nifds > 3 ) && ( entries > 512 ) ) return ; INT64 fsize = ifp -> size ( ) ; while ( entries -- ) { tiff_get ( base , & tag , & type , & len , & save ) ; INT64 savepos = ftell ( ifp ) ; if ( len > 8 && savepos + len > fsize * 2 ) { fseek ( ifp , save , SEEK_SET ) ; continue ; } if ( callbacks . exif_cb ) { callbacks . exif_cb ( callbacks . exifparser_data , tag , type , len , order , ifp , base ) ; fseek ( ifp , savepos , SEEK_SET ) ; } switch ( tag ) { case 0xA005 : fseek ( ifp , get4 ( ) + base , SEEK_SET ) ; parse_exif_interop ( base ) ; break ; case 0xA001 : c = get2 ( ) ; if ( c == 1 && imgdata . color . ExifColorSpace == LIBRAW_COLORSPACE_Unknown ) imgdata . color . ExifColorSpace = LIBRAW_COLORSPACE_sRGB ; else if ( c == 2 ) imgdata . color . ExifColorSpace = LIBRAW_COLORSPACE_AdobeRGB ; break ; case 0x9400 : imCommon . exifAmbientTemperature = getreal ( type ) ; if ( ( imCommon . CameraTemperature > - 273.15f ) && ( ( OlyID == OlyID_TG_5 ) || ( OlyID == OlyID_TG_6 ) ) ) imCommon . CameraTemperature += imCommon . exifAmbientTemperature ; break ; case 0x9401 : imCommon . exifHumidity = getreal ( type ) ; break ; case 0x9402 : imCommon . exifPressure = getreal ( type ) ; break ; case 0x9403 : imCommon . exifWaterDepth = getreal ( type ) ; break ; case 0x9404 : imCommon . exifAcceleration = getreal ( type ) ; break ; case 0x9405 : imCommon . exifCameraElevationAngle = getreal ( type ) ; break ; case 0xa405 : imgdata . lens . FocalLengthIn35mmFormat = get2 ( ) ; break ; case 0xa431 : stmread ( imgdata . shootinginfo . BodySerial , len , ifp ) ; break ; case 0xa432 : imgdata . lens . MinFocal = getreal ( type ) ; imgdata . lens . MaxFocal = getreal ( type ) ; imgdata . lens . MaxAp4MinFocal = getreal ( type ) ; imgdata . lens . MaxAp4MaxFocal = getreal ( type ) ; break ; case 0xa435 : stmread ( imgdata . lens . LensSerial , len , ifp ) ; if ( ! strncmp ( imgdata . lens . LensSerial , \"----\" , 4 ) ) imgdata . lens . LensSerial [ 0 ] = '\\\\0' ; break ; case 0xa420 : stmread ( imgdata . color . ImageUniqueID , len , ifp ) ; break ; case 0xc65d : imgdata . color . RawDataUniqueID [ 16 ] = 0 ; fread ( imgdata . color . RawDataUniqueID , 1 , 16 , ifp ) ; break ; case 0xc630 : imgdata . lens . dng . MinFocal = getreal ( type ) ; imgdata . lens . dng . MaxFocal = getreal ( type ) ; imgdata . lens . dng . MaxAp4MinFocal = getreal ( type ) ; imgdata . lens . dng . MaxAp4MaxFocal = getreal ( type ) ; break ; case 0xc68b : stmread ( imgdata . color . OriginalRawFileName , len , ifp ) ; break ; case 0xa433 : stmread ( imgdata . lens . LensMake , len , ifp ) ; break ; case 0xa434 : stmread ( imgdata . lens . Lens , len , ifp ) ; if ( ! strncmp ( imgdata . lens . Lens , \"----\" , 4 ) ) imgdata . lens . Lens [ 0 ] = '\\\\0' ; break ; case 0x9205 : imgdata . lens . EXIF_MaxAp = libraw_powf64l ( 2.0f , ( getreal ( type ) / 2.0f ) ) ; break ; case 0x829a : <S2SV_StartBug> tiff_ifd [ tiff_nifds - 1 ] . t_shutter = shutter = getreal ( type ) ; <S2SV_EndBug> break ; case 0x829d : aperture = getreal ( type ) ; break ; case 0x8827 : iso_speed = get2 ( ) ; break ; case 0x8831 : if ( iso_speed == 0xffff && ! strncasecmp ( make , \"FUJI\" , 4 ) ) iso_speed = getreal ( type ) ; break ; case 0x8832 : if ( iso_speed == 0xffff && ( ! strncasecmp ( make , \"SONY\" , 4 ) || ! strncasecmp ( make , \"CANON\" , 5 ) ) ) iso_speed = getreal ( type ) ; break ; case 0x9003 : case 0x9004 : get_timestamp ( 0 ) ; break ; case 0x9201 : if ( ( expo = - getreal ( type ) ) < 128 && shutter == 0. ) <S2SV_StartBug> tiff_ifd [ tiff_nifds - 1 ] . t_shutter = shutter = <S2SV_EndBug> libraw_powf64l ( 2.0 , expo ) ; break ; case 0x9202 : if ( ( fabs ( ape = getreal ( type ) ) < 256.0 ) && ( ! aperture ) ) aperture = libraw_powf64l ( 2.0 , ape / 2 ) ; break ; case 0x9209 : flash_used = getreal ( type ) ; break ; case 0x920a : focal_len = getreal ( type ) ; break ; case 0x927c : if ( ( ( make [ 0 ] == '\\\\0' ) && ! strncmp ( model , \"ov5647\" , 6 ) ) || ( ! strncmp ( make , \"RaspberryPi\" , 11 ) && ( ! strncmp ( model , \"RP_OV5647\" , 9 ) || ! strncmp ( model , \"RP_imx219\" , 9 ) ) ) ) { char mn_text [ 512 ] ; char * pos ; char ccms [ 512 ] ; ushort l ; float num ; fgets ( mn_text , MIN ( len , 511 ) , ifp ) ; mn_text [ 511 ] = 0 ; pos = strstr ( mn_text , \"gain_r=\" ) ; if ( pos ) cam_mul [ 0 ] = atof ( pos + 7 ) ; pos = strstr ( mn_text , \"gain_b=\" ) ; if ( pos ) cam_mul [ 2 ] = atof ( pos + 7 ) ; if ( ( cam_mul [ 0 ] > 0.001f ) && ( cam_mul [ 2 ] > 0.001f ) ) cam_mul [ 1 ] = cam_mul [ 3 ] = 1.0f ; else cam_mul [ 0 ] = cam_mul [ 2 ] = 0.0f ; pos = strstr ( mn_text , \"ccm=\" ) ; if ( pos ) { pos += 4 ; char * pos2 = strstr ( pos , \"<S2SV_blank>\" ) ; if ( pos2 ) { l = pos2 - pos ; memcpy ( ccms , pos , l ) ; ccms [ l ] = '\\\\0' ; # ifdef LIBRAW_WIN32_CALLS pos = strtok ( ccms , \",\" ) ; # else char * last = 0 ; pos = strtok_r ( ccms , \",\" , & last ) ; # endif if ( pos ) { for ( l = 0 ; l < 4 ; l ++ ) { num = 0.0 ; for ( c = 0 ; c < 3 ; c ++ ) { imgdata . color . ccm [ l ] [ c ] = ( float ) atoi ( pos ) ; num += imgdata . color . ccm [ l ] [ c ] ; # ifdef LIBRAW_WIN32_CALLS pos = strtok ( NULL , \",\" ) ; # else pos = strtok_r ( NULL , \",\" , & last ) ; # endif if ( ! pos ) goto end ; } if ( num > 0.01 ) FORC3 imgdata . color . ccm [ l ] [ c ] = imgdata . color . ccm [ l ] [ c ] / num ; } } } } end : ; } else if ( ! strncmp ( make , \"SONY\" , 4 ) && ( ! strncmp ( model , \"DSC-V3\" , 6 ) || ! strncmp ( model , \"DSC-F828\" , 8 ) ) ) { parseSonySRF ( len ) ; break ; } else if ( ( len == 1 ) && ! strncmp ( make , \"NIKON\" , 5 ) ) { c = get4 ( ) ; if ( c ) fseek ( ifp , c , SEEK_SET ) ; is_NikonTransfer = 1 ; } parse_makernote ( base , 0 ) ; break ; case 0xa002 : if ( kodak ) raw_width = get4 ( ) ; break ; case 0xa003 : if ( kodak ) raw_height = get4 ( ) ; break ; case 0xa302 : if ( get4 ( ) == 0x20002 ) for ( exif_cfa = c = 0 ; c < 8 ; c += 2 ) exif_cfa |= fgetc ( ifp ) * 0x01010101U << c ; } fseek ( ifp , save , SEEK_SET ) ; } }", "target": "<S2SV_ModStart> case 0x829a : shutter = getreal ( type ) ; if ( tiff_nifds > 0 && tiff_nifds <= LIBRAW_IFD_MAXCOUNT ) <S2SV_ModStart> t_shutter = shutter <S2SV_ModEnd> ; break ; <S2SV_ModStart> == 0. ) { shutter = libraw_powf64l ( 2.0 , expo ) ; if ( tiff_nifds > 0 && tiff_nifds <= LIBRAW_IFD_MAXCOUNT ) <S2SV_ModStart> t_shutter = shutter ; } <S2SV_ModEnd> break ; case"}
{"source": "CWE-401 static Image * ReadDPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const char * client_name ; Display * display ; float pixels_per_point ; Image * image ; int sans , status ; Pixmap pixmap ; register IndexPacket * indexes ; register ssize_t i ; register PixelPacket * q ; register size_t pixel ; Screen * screen ; ssize_t x , y ; XColor * colors ; XImage * dps_image ; XRectangle page , bits_per_pixel ; XResourceInfo resource_info ; XrmDatabase resource_database ; XStandardColormap * map_info ; XVisualInfo * visual_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; display = XOpenDisplay ( image_info -> server_name ) ; if ( display == ( Display * ) NULL ) return ( ( Image * ) NULL ) ; ( void ) XSetErrorHandler ( XError ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) <S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> client_name = GetClientName ( ) ; resource_database = XGetResourceDatabase ( display , client_name ) ; XGetResourceInfo ( image_info , resource_database , client_name , & resource_info ) ; map_info = XAllocStandardColormap ( ) ; visual_info = ( XVisualInfo * ) NULL ; if ( map_info == ( XStandardColormap * ) NULL ) ThrowReaderException ( ResourceLimitError , \"UnableToCreateStandardColormap\" ) else { ( void ) CloneString ( & resource_info . visual_type , \"default\" ) ; visual_info = XBestVisualInfo ( display , map_info , & resource_info ) ; map_info -> colormap = ( Colormap ) NULL ; } if ( ( map_info == ( XStandardColormap * ) NULL ) || ( visual_info == ( XVisualInfo * ) NULL ) ) { image = DestroyImage ( image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; return ( ( Image * ) NULL ) ; } screen = ScreenOfDisplay ( display , visual_info -> screen ) ; pixels_per_point = XDPSPixelsPerPoint ( screen ) ; if ( ( image -> x_resolution != 0.0 ) && ( image -> y_resolution != 0.0 ) ) pixels_per_point = MagickMin ( image -> x_resolution , image -> y_resolution ) / DefaultResolution ; status = XDPSCreatePixmapForEPSF ( ( DPSContext ) NULL , screen , GetBlobFileHandle ( image ) , visual_info -> depth , pixels_per_point , & pixmap , & bits_per_pixel , & page ) ; if ( ( status == dps_status_failure ) || ( status == dps_status_no_extension ) ) { image = DestroyImage ( image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; return ( ( Image * ) NULL ) ; } status = XDPSImageFileIntoDrawable ( ( DPSContext ) NULL , screen , pixmap , GetBlobFileHandle ( image ) , ( int ) bits_per_pixel . height , visual_info -> depth , & page , - page . x , - page . y , pixels_per_point , MagickTrue , MagickFalse , MagickTrue , & sans ) ; if ( status != dps_status_success ) { image = DestroyImage ( image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; return ( ( Image * ) NULL ) ; } dps_image = XGetImage ( display , pixmap , 0 , 0 , bits_per_pixel . width , bits_per_pixel . height , AllPlanes , ZPixmap ) ; ( void ) XFreePixmap ( display , pixmap ) ; if ( dps_image == ( XImage * ) NULL ) { image = DestroyImage ( image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; return ( ( Image * ) NULL ) ; } colors = ( XColor * ) AcquireQuantumMemory ( visual_info -> colormap_size , sizeof ( * colors ) ) ; if ( colors == ( XColor * ) NULL ) { image = DestroyImage ( image ) ; XDestroyImage ( dps_image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; return ( ( Image * ) NULL ) ; } if ( ( visual_info -> klass != DirectColor ) && ( visual_info -> klass != TrueColor ) ) for ( i = 0 ; i < visual_info -> colormap_size ; i ++ ) { colors [ i ] . pixel = ( size_t ) i ; colors [ i ] . pad = 0 ; } else { size_t blue , blue_bit , green , green_bit , red , red_bit ; red = 0 ; green = 0 ; blue = 0 ; red_bit = visual_info -> red_mask & ( ~ ( visual_info -> red_mask ) + 1 ) ; green_bit = visual_info -> green_mask & ( ~ ( visual_info -> green_mask ) + 1 ) ; blue_bit = visual_info -> blue_mask & ( ~ ( visual_info -> blue_mask ) + 1 ) ; for ( i = 0 ; i < visual_info -> colormap_size ; i ++ ) { colors [ i ] . pixel = red | green | blue ; colors [ i ] . pad = 0 ; red += red_bit ; if ( red > visual_info -> red_mask ) red = 0 ; green += green_bit ; if ( green > visual_info -> green_mask ) green = 0 ; blue += blue_bit ; if ( blue > visual_info -> blue_mask ) blue = 0 ; } } ( void ) XQueryColors ( display , XDefaultColormap ( display , visual_info -> screen ) , colors , visual_info -> colormap_size ) ; if ( ( visual_info -> klass != TrueColor ) && ( visual_info -> klass != DirectColor ) ) image -> storage_class = PseudoClass ; image -> columns = ( size_t ) dps_image -> width ; image -> rows = ( size_t ) dps_image -> height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; colors = ( XColor * ) RelinquishMagickMemory ( colors ) ; XDestroyImage ( dps_image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { colors = ( XColor * ) RelinquishMagickMemory ( colors ) ; XDestroyImage ( dps_image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } switch ( image -> storage_class ) { case DirectClass : default : { register size_t color , index ; size_t blue_mask , blue_shift , green_mask , green_shift , red_mask , red_shift ; red_mask = visual_info -> red_mask ; red_shift = 0 ; while ( ( red_mask != 0 ) && ( ( red_mask & 0x01 ) == 0 ) ) { red_mask >>= 1 ; red_shift ++ ; } green_mask = visual_info -> green_mask ; green_shift = 0 ; while ( ( green_mask != 0 ) && ( ( green_mask & 0x01 ) == 0 ) ) { green_mask >>= 1 ; green_shift ++ ; } blue_mask = visual_info -> blue_mask ; blue_shift = 0 ; while ( ( blue_mask != 0 ) && ( ( blue_mask & 0x01 ) == 0 ) ) { blue_mask >>= 1 ; blue_shift ++ ; } if ( ( visual_info -> colormap_size > 0 ) && ( visual_info -> klass == DirectColor ) ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = XGetPixel ( dps_image , x , y ) ; index = ( pixel >> red_shift ) & red_mask ; SetPixelRed ( q , ScaleShortToQuantum ( colors [ index ] . red ) ) ; index = ( pixel >> green_shift ) & green_mask ; SetPixelGreen ( q , ScaleShortToQuantum ( colors [ index ] . green ) ) ; index = ( pixel >> blue_shift ) & blue_mask ; SetPixelBlue ( q , ScaleShortToQuantum ( colors [ index ] . blue ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = XGetPixel ( dps_image , x , y ) ; color = ( pixel >> red_shift ) & red_mask ; color = ( color * 65535L ) / red_mask ; SetPixelRed ( q , ScaleShortToQuantum ( ( unsigned short ) color ) ) ; color = ( pixel >> green_shift ) & green_mask ; color = ( color * 65535L ) / green_mask ; SetPixelGreen ( q , ScaleShortToQuantum ( ( unsigned short ) color ) ) ; color = ( pixel >> blue_shift ) & blue_mask ; color = ( color * 65535L ) / blue_mask ; SetPixelBlue ( q , ScaleShortToQuantum ( ( unsigned short ) color ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } break ; } case PseudoClass : { if ( AcquireImageColormap ( image , ( size_t ) visual_info -> colormap_size ) == MagickFalse ) { image = DestroyImage ( image ) ; colors = ( XColor * ) RelinquishMagickMemory ( colors ) ; XDestroyImage ( dps_image ) ; XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; return ( ( Image * ) NULL ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ colors [ i ] . pixel ] . red = ScaleShortToQuantum ( colors [ i ] . red ) ; image -> colormap [ colors [ i ] . pixel ] . green = ScaleShortToQuantum ( colors [ i ] . green ) ; image -> colormap [ colors [ i ] . pixel ] . blue = ScaleShortToQuantum ( colors [ i ] . blue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , ( unsigned short ) XGetPixel ( dps_image , x , y ) ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } break ; } } colors = ( XColor * ) RelinquishMagickMemory ( colors ) ; XDestroyImage ( dps_image ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ; status = XDPSCreatePixmapForEPSF ( ( DPSContext ) NULL , screen , GetBlobFileHandle ( image ) , 1 , pixels_per_point , & pixmap , & bits_per_pixel , & page ) ; if ( ( status != dps_status_failure ) && ( status != dps_status_no_extension ) ) { status = XDPSImageFileIntoDrawable ( ( DPSContext ) NULL , screen , pixmap , GetBlobFileHandle ( image ) , ( int ) bits_per_pixel . height , 1 , & page , - page . x , - page . y , pixels_per_point , MagickTrue , MagickTrue , MagickTrue , & sans ) ; if ( status == dps_status_success ) { XImage * matte_image ; matte_image = XGetImage ( display , pixmap , 0 , 0 , bits_per_pixel . width , bits_per_pixel . height , AllPlanes , ZPixmap ) ; ( void ) XFreePixmap ( display , pixmap ) ; if ( matte_image != ( XImage * ) NULL ) { image -> storage_class = DirectClass ; image -> matte = MagickTrue ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelOpacity ( q , OpaqueOpacity ) ; if ( XGetPixel ( matte_image , x , y ) == 0 ) SetPixelOpacity ( q , TransparentOpacity ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } XDestroyImage ( matte_image ) ; } } } XFreeResources ( display , visual_info , map_info , ( XPixelInfo * ) NULL , ( XFontStruct * ) NULL , & resource_info , ( XWindowInfo * ) NULL ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> == MagickFalse ) { image = DestroyImageList ( image ) ; <S2SV_ModStart> NULL ) ; }"}
{"source": "CWE-120 ipmi_get_session_info ( struct ipmi_intf * intf , Ipmi_Session_Request_Type session_request_type , uint32_t id_or_handle ) { int i , retval = 0 ; struct ipmi_rs * rsp ; struct ipmi_rq req ; uint8_t rqdata [ 5 ] ; struct get_session_info_rsp session_info ; memset ( & req , 0 , sizeof ( req ) ) ; memset ( & session_info , 0 , sizeof ( session_info ) ) ; req . msg . netfn = IPMI_NETFN_APP ; req . msg . cmd = IPMI_GET_SESSION_INFO ; req . msg . data = rqdata ; switch ( session_request_type ) { case IPMI_SESSION_REQUEST_CURRENT : case IPMI_SESSION_REQUEST_BY_ID : case IPMI_SESSION_REQUEST_BY_HANDLE : switch ( session_request_type ) { case IPMI_SESSION_REQUEST_CURRENT : rqdata [ 0 ] = 0x00 ; req . msg . data_len = 1 ; break ; case IPMI_SESSION_REQUEST_BY_ID : rqdata [ 0 ] = 0xFF ; rqdata [ 1 ] = id_or_handle & 0x000000FF ; rqdata [ 2 ] = ( id_or_handle >> 8 ) & 0x000000FF ; rqdata [ 3 ] = ( id_or_handle >> 16 ) & 0x000000FF ; rqdata [ 4 ] = ( id_or_handle >> 24 ) & 0x000000FF ; req . msg . data_len = 5 ; break ; case IPMI_SESSION_REQUEST_BY_HANDLE : rqdata [ 0 ] = 0xFE ; rqdata [ 1 ] = ( uint8_t ) id_or_handle ; req . msg . data_len = 2 ; break ; case IPMI_SESSION_REQUEST_ALL : break ; } rsp = intf -> sendrecv ( intf , & req ) ; if ( ! rsp ) { lprintf ( LOG_ERR , \"Get<S2SV_blank>Session<S2SV_blank>Info<S2SV_blank>command<S2SV_blank>failed\" ) ; retval = - 1 ; } else if ( rsp -> ccode ) { lprintf ( LOG_ERR , \"Get<S2SV_blank>Session<S2SV_blank>Info<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\" , val2str ( rsp -> ccode , completion_code_vals ) ) ; retval = - 1 ; } if ( retval < 0 ) { if ( ( session_request_type == IPMI_SESSION_REQUEST_CURRENT ) && ( strncmp ( intf -> name , \"lan\" , 3 ) != 0 ) ) lprintf ( LOG_ERR , \"It<S2SV_blank>is<S2SV_blank>likely<S2SV_blank>that<S2SV_blank>the<S2SV_blank>channel<S2SV_blank>in<S2SV_blank>use<S2SV_blank>\" \"does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>sessions\" ) ; } else { <S2SV_StartBug> memcpy ( & session_info , rsp -> data , rsp -> data_len ) ; <S2SV_EndBug> <S2SV_StartBug> print_session_info ( & session_info , rsp -> data_len ) ; <S2SV_EndBug> } break ; case IPMI_SESSION_REQUEST_ALL : req . msg . data_len = 1 ; i = 1 ; do { rqdata [ 0 ] = i ++ ; rsp = intf -> sendrecv ( intf , & req ) ; if ( ! rsp ) { lprintf ( LOG_ERR , \"Get<S2SV_blank>Session<S2SV_blank>Info<S2SV_blank>command<S2SV_blank>failed\" ) ; retval = - 1 ; break ; } else if ( rsp -> ccode && rsp -> ccode != 0xCC && rsp -> ccode != 0xCB ) { lprintf ( LOG_ERR , \"Get<S2SV_blank>Session<S2SV_blank>Info<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\" , val2str ( rsp -> ccode , completion_code_vals ) ) ; retval = - 1 ; break ; } else if ( rsp -> data_len < 3 ) { retval = - 1 ; break ; } <S2SV_StartBug> memcpy ( & session_info , rsp -> data , rsp -> data_len ) ; <S2SV_EndBug> <S2SV_StartBug> print_session_info ( & session_info , rsp -> data_len ) ; <S2SV_EndBug> } while ( i <= session_info . session_slot_count ) ; break ; } return retval ; }", "target": "<S2SV_ModStart> -> data , __min ( rsp -> data_len , sizeof ( session_info ) ) <S2SV_ModEnd> ) ; print_session_info <S2SV_ModStart> & session_info , __min ( rsp -> data_len , sizeof ( session_info ) ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> data , __min ( rsp -> data_len , sizeof ( session_info ) ) <S2SV_ModEnd> ) ; print_session_info <S2SV_ModStart> & session_info , __min ( rsp -> data_len , sizeof ( session_info ) ) <S2SV_ModEnd> ) ; }"}
{"source": "CWE-362 static void sctp_destroy_sock ( struct sock * sk ) { struct sctp_sock * sp ; pr_debug ( \"%s:<S2SV_blank>sk:%p\\\\n\" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; if ( sp -> ep == NULL ) return ; if ( sp -> do_auto_asconf ) { sp -> do_auto_asconf = 0 ; <S2SV_StartBug> list_del ( & sp -> auto_asconf_list ) ; <S2SV_EndBug> } sctp_endpoint_free ( sp -> ep ) ; local_bh_disable ( ) ; sk_sockets_allocated_dec ( sk ) ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; local_bh_enable ( ) ; }", "target": "<S2SV_ModStart> = 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> sp -> auto_asconf_list ) ; spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock"}
{"source": "CWE-416 static void mcba_usb_disconnect ( struct usb_interface * intf ) { struct mcba_priv * priv = usb_get_intfdata ( intf ) ; usb_set_intfdata ( intf , NULL ) ; netdev_info ( priv -> netdev , \"device<S2SV_blank>disconnected\\\\n\" ) ; unregister_candev ( priv -> netdev ) ; <S2SV_StartBug> free_candev ( priv -> netdev ) ; <S2SV_EndBug> <S2SV_StartBug> mcba_urb_unlink ( priv ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> netdev ) ; mcba_urb_unlink ( priv ) ; <S2SV_ModStart> netdev ) ; <S2SV_ModEnd> }  <S2SV_null>"}
{"source": "CWE-125 BOOL license_read_new_or_upgrade_license_packet ( rdpLicense * license , wStream * s ) { UINT32 os_major ; UINT32 os_minor ; UINT32 cbScope , cbCompanyName , cbProductId , cbLicenseInfo ; wStream * licenseStream = NULL ; BOOL ret = FALSE ; BYTE computedMac [ 16 ] ; LICENSE_BLOB * calBlob ; DEBUG_LICENSE ( \"Receiving<S2SV_blank>Server<S2SV_blank>New/Upgrade<S2SV_blank>License<S2SV_blank>Packet\" ) ; calBlob = license_new_binary_blob ( BB_DATA_BLOB ) ; if ( ! calBlob ) return FALSE ; if ( ! license_read_encrypted_blob ( license , s , calBlob ) ) goto out_free_blob ; if ( Stream_GetRemainingLength ( s ) < 16 ) goto out_free_blob ; if ( ! security_mac_data ( license -> MacSaltKey , calBlob -> data , calBlob -> length , computedMac ) ) goto out_free_blob ; if ( memcmp ( computedMac , Stream_Pointer ( s ) , sizeof ( computedMac ) ) != 0 ) { WLog_ERR ( TAG , \"new<S2SV_blank>or<S2SV_blank>upgrade<S2SV_blank>license<S2SV_blank>MAC<S2SV_blank>mismatch\" ) ; goto out_free_blob ; } if ( ! Stream_SafeSeek ( s , 16 ) ) goto out_free_blob ; licenseStream = Stream_New ( calBlob -> data , calBlob -> length ) ; if ( ! licenseStream ) goto out_free_blob ; <S2SV_StartBug> Stream_Read_UINT16 ( licenseStream , os_minor ) ; <S2SV_EndBug> Stream_Read_UINT16 ( licenseStream , os_major ) ; Stream_Read_UINT32 ( licenseStream , cbScope ) ; if ( Stream_GetRemainingLength ( licenseStream ) < cbScope ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , \"Scope:\" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbScope ) ; # endif Stream_Seek ( licenseStream , cbScope ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbCompanyName ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbCompanyName ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , \"Company<S2SV_blank>name:\" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbCompanyName ) ; # endif Stream_Seek ( licenseStream , cbCompanyName ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbProductId ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbProductId ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , \"Product<S2SV_blank>id:\" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbProductId ) ; # endif Stream_Seek ( licenseStream , cbProductId ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbLicenseInfo ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbLicenseInfo ) goto out_free_stream ; license -> state = LICENSE_STATE_COMPLETED ; ret = TRUE ; if ( ! license -> rdp -> settings -> OldLicenseBehaviour ) ret = saveCal ( license -> rdp -> settings , Stream_Pointer ( licenseStream ) , cbLicenseInfo , license -> rdp -> settings -> ClientHostname ) ; out_free_stream : Stream_Free ( licenseStream , FALSE ) ; out_free_blob : license_free_binary_blob ( calBlob ) ; return ret ; }", "target": "<S2SV_ModStart> goto out_free_blob ; if ( Stream_GetRemainingLength ( licenseStream ) < 8 ) goto out_free_stream ; <S2SV_ModStart> cbScope ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbCompanyName ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbProductId ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ;"}
{"source": "CWE-125 int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; <S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }", "target": "<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\\\0'"}
{"source": "CWE-665 virtio_dev_rx_batch_packed ( struct virtio_net * dev , struct vhost_virtqueue * vq , struct rte_mbuf * * pkts ) { bool wrap_counter = vq -> avail_wrap_counter ; struct vring_packed_desc * descs = vq -> desc_packed ; uint16_t avail_idx = vq -> last_avail_idx ; uint64_t desc_addrs [ PACKED_BATCH_SIZE ] ; struct virtio_net_hdr_mrg_rxbuf * hdrs [ PACKED_BATCH_SIZE ] ; uint32_t buf_offset = dev -> vhost_hlen ; uint64_t lens [ PACKED_BATCH_SIZE ] ; uint16_t ids [ PACKED_BATCH_SIZE ] ; uint16_t i ; if ( unlikely ( avail_idx & PACKED_BATCH_MASK ) ) return - 1 ; if ( unlikely ( ( avail_idx + PACKED_BATCH_SIZE ) > vq -> size ) ) return - 1 ; vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) { if ( unlikely ( pkts [ i ] -> next != NULL ) ) return - 1 ; if ( unlikely ( ! desc_is_avail ( & descs [ avail_idx + i ] , wrap_counter ) ) ) return - 1 ; } rte_smp_rmb ( ) ; vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) lens [ i ] = descs [ avail_idx + i ] . len ; vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) { if ( unlikely ( pkts [ i ] -> pkt_len > ( lens [ i ] - buf_offset ) ) ) return - 1 ; } vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) desc_addrs [ i ] = vhost_iova_to_vva ( dev , vq , descs [ avail_idx + i ] . addr , & lens [ i ] , VHOST_ACCESS_RW ) ; vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) { <S2SV_StartBug> if ( unlikely ( lens [ i ] != descs [ avail_idx + i ] . len ) ) <S2SV_EndBug> return - 1 ; } vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) { rte_prefetch0 ( ( void * ) ( uintptr_t ) desc_addrs [ i ] ) ; hdrs [ i ] = ( struct virtio_net_hdr_mrg_rxbuf * ) ( uintptr_t ) desc_addrs [ i ] ; lens [ i ] = pkts [ i ] -> pkt_len + dev -> vhost_hlen ; } vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) virtio_enqueue_offload ( pkts [ i ] , & hdrs [ i ] -> hdr ) ; vq_inc_last_avail_packed ( vq , PACKED_BATCH_SIZE ) ; vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) { rte_memcpy ( ( void * ) ( uintptr_t ) ( desc_addrs [ i ] + buf_offset ) , rte_pktmbuf_mtod_offset ( pkts [ i ] , void * , 0 ) , pkts [ i ] -> pkt_len ) ; } vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) vhost_log_cache_write_iova ( dev , vq , descs [ avail_idx + i ] . addr , lens [ i ] ) ; vhost_for_each_try_unroll ( i , 0 , PACKED_BATCH_SIZE ) ids [ i ] = descs [ avail_idx + i ] . id ; vhost_flush_enqueue_batch_packed ( dev , vq , lens , ids ) ; return 0 ; }", "target": "<S2SV_ModStart> ( unlikely ( ! desc_addrs [ i ] ) ) return - 1 ; if ( unlikely ("}
{"source": "CWE-399 parse_key_constraints ( struct sshbuf * m , struct sshkey * k , time_t * deathp , u_int * secondsp , int * confirmp , char * * sk_providerp ) { u_char ctype ; int r ; u_int seconds , maxsign = 0 ; <S2SV_StartBug> char * ext_name = NULL ; <S2SV_EndBug> struct sshbuf * b = NULL ; while ( sshbuf_len ( m ) ) { if ( ( r = sshbuf_get_u8 ( m , & ctype ) ) != 0 ) { error_fr ( r , \"parse<S2SV_blank>constraint<S2SV_blank>type\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } switch ( ctype ) { case SSH_AGENT_CONSTRAIN_LIFETIME : if ( * deathp != 0 ) { error_f ( \"lifetime<S2SV_blank>already<S2SV_blank>set\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } if ( ( r = sshbuf_get_u32 ( m , & seconds ) ) != 0 ) { error_fr ( r , \"parse<S2SV_blank>lifetime<S2SV_blank>constraint\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } * deathp = monotime ( ) + seconds ; * secondsp = seconds ; break ; case SSH_AGENT_CONSTRAIN_CONFIRM : if ( * confirmp != 0 ) { error_f ( \"confirm<S2SV_blank>already<S2SV_blank>set\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } * confirmp = 1 ; break ; case SSH_AGENT_CONSTRAIN_MAXSIGN : if ( k == NULL ) { error_f ( \"maxsign<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } if ( maxsign != 0 ) { error_f ( \"maxsign<S2SV_blank>already<S2SV_blank>set\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } if ( ( r = sshbuf_get_u32 ( m , & maxsign ) ) != 0 ) { error_fr ( r , \"parse<S2SV_blank>maxsign<S2SV_blank>constraint\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } if ( ( r = sshkey_enable_maxsign ( k , maxsign ) ) != 0 ) { error_fr ( r , \"enable<S2SV_blank>maxsign\" ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } break ; case SSH_AGENT_CONSTRAIN_EXTENSION : <S2SV_StartBug> if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) { <S2SV_EndBug> error_fr ( r , \"parse<S2SV_blank>constraint<S2SV_blank>extension\" ) ; goto err ; } debug_f ( \"constraint<S2SV_blank>ext<S2SV_blank>%s\" , ext_name ) ; if ( strcmp ( ext_name , \"sk-provider@openssh.com\" ) == 0 ) { if ( sk_providerp == NULL ) { error_f ( \"%s<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here\" , ext_name ) ; goto err ; } if ( * sk_providerp != NULL ) { error_f ( \"%s<S2SV_blank>already<S2SV_blank>set\" , ext_name ) ; goto err ; } if ( ( r = sshbuf_get_cstring ( m , sk_providerp , NULL ) ) != 0 ) { error_fr ( r , \"parse<S2SV_blank>%s\" , ext_name ) ; goto err ; } } else { error_f ( \"unsupported<S2SV_blank>constraint<S2SV_blank>\\\\\"%s\\\\\"\" , ext_name ) ; goto err ; } free ( ext_name ) ; break ; default : error_f ( \"Unknown<S2SV_blank>constraint<S2SV_blank>%d\" , ctype ) ; <S2SV_StartBug> err : <S2SV_EndBug> free ( ext_name ) ; sshbuf_free ( b ) ; return - 1 ; } } return 0 ; }", "target": "<S2SV_ModStart> = 0 ; <S2SV_ModEnd> while ( sshbuf_len <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } switch <S2SV_ModStart> \"lifetime<S2SV_blank>already<S2SV_blank>set\" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> \"confirm<S2SV_blank>already<S2SV_blank>set\" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> \"maxsign<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here\" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> \"maxsign<S2SV_blank>already<S2SV_blank>set\" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } break <S2SV_ModStart> ( r = parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ; break ; default : error_f ( <S2SV_ModEnd> \"Unknown<S2SV_blank>constraint<S2SV_blank>%d\" , ctype <S2SV_ModStart> ctype ) ; r = SSH_ERR_FEATURE_UNSUPPORTED ; goto out ; } } r = 0 ; out : return r <S2SV_ModEnd> ; }"}
{"source": "CWE-704 z_jbig2decode ( i_ctx_t * i_ctx_p ) { os_ptr op = osp ; ref * sop = NULL ; s_jbig2_global_data_t * gref ; stream_jbig2decode_state state ; s_jbig2decode_set_global_data ( ( stream_state * ) & state , NULL ) ; if ( r_has_type ( op , t_dictionary ) ) { check_dict_read ( * op ) ; if ( dict_find_string ( op , \".jbig2globalctx\" , & sop ) > 0 ) { <S2SV_StartBug> gref = r_ptr ( sop , s_jbig2_global_data_t ) ; <S2SV_EndBug> s_jbig2decode_set_global_data ( ( stream_state * ) & state , gref ) ; } } return filter_read ( i_ctx_p , 0 , & s_jbig2decode_template , ( stream_state * ) & state , ( sop ? r_space ( sop ) : 0 ) ) ; }", "target": "<S2SV_ModStart> 0 ) { if ( ! r_is_struct ( sop ) || ! r_has_stype ( sop , imemory , st_jbig2_global_data_t ) ) return_error ( gs_error_typecheck ) ;"}
{"source": "CWE-703 ReadFromRFBServer ( rfbClient * client , char * out , unsigned int n ) <S2SV_StartBug> { <S2SV_EndBug> # undef DEBUG_READ_EXACT # ifdef DEBUG_READ_EXACT char * oout = out ; unsigned int nn = n ; rfbClientLog ( \"ReadFromRFBServer<S2SV_blank>%d<S2SV_blank>bytes\\\\n\" , n ) ; # endif if ( ! out ) return FALSE ; if ( client -> serverPort == - 1 ) { rfbVNCRec * rec = client -> vncRec ; struct timeval tv ; if ( rec -> readTimestamp ) { rec -> readTimestamp = FALSE ; if ( ! fread ( & tv , sizeof ( struct timeval ) , 1 , rec -> file ) ) return FALSE ; tv . tv_sec = rfbClientSwap32IfLE ( tv . tv_sec ) ; tv . tv_usec = rfbClientSwap32IfLE ( tv . tv_usec ) ; if ( rec -> tv . tv_sec != 0 && ! rec -> doNotSleep ) { struct timeval diff ; diff . tv_sec = tv . tv_sec - rec -> tv . tv_sec ; diff . tv_usec = tv . tv_usec - rec -> tv . tv_usec ; if ( diff . tv_usec < 0 ) { diff . tv_sec -- ; diff . tv_usec += 1000000 ; } # ifndef WIN32 sleep ( diff . tv_sec ) ; usleep ( diff . tv_usec ) ; # else Sleep ( diff . tv_sec * 1000 + diff . tv_usec / 1000 ) ; # endif } rec -> tv = tv ; } return ( fread ( out , 1 , n , rec -> file ) != n ? FALSE : TRUE ) ; } if ( n <= client -> buffered ) { memcpy ( out , client -> bufoutptr , n ) ; client -> bufoutptr += n ; client -> buffered -= n ; # ifdef DEBUG_READ_EXACT goto hexdump ; # endif return TRUE ; } memcpy ( out , client -> bufoutptr , client -> buffered ) ; out += client -> buffered ; n -= client -> buffered ; client -> bufoutptr = client -> buf ; client -> buffered = 0 ; if ( n <= RFB_BUF_SIZE ) { while ( client -> buffered < n ) { int i ; if ( client -> tlsSession ) i = ReadFromTLS ( client , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ; else # ifdef LIBVNCSERVER_HAVE_SASL if ( client -> saslconn ) i = ReadFromSASL ( client , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ; else { # endif i = read ( client -> sock , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ; # ifdef WIN32 if ( i < 0 ) errno = WSAGetLastError ( ) ; # endif # ifdef LIBVNCSERVER_HAVE_SASL } # endif if ( i <= 0 ) { if ( i < 0 ) { if ( errno == EWOULDBLOCK || errno == EAGAIN ) { <S2SV_StartBug> WaitForMessage ( client , 100000 ) ; <S2SV_EndBug> i = 0 ; } else { rfbClientErr ( \"read<S2SV_blank>(%d:<S2SV_blank>%s)\\\\n\" , errno , strerror ( errno ) ) ; return FALSE ; } } else { if ( errorMessageOnReadFailure ) { rfbClientLog ( \"VNC<S2SV_blank>server<S2SV_blank>closed<S2SV_blank>connection\\\\n\" ) ; } return FALSE ; } } client -> buffered += i ; } memcpy ( out , client -> bufoutptr , n ) ; client -> bufoutptr += n ; client -> buffered -= n ; } else { while ( n > 0 ) { int i ; if ( client -> tlsSession ) i = ReadFromTLS ( client , out , n ) ; else # ifdef LIBVNCSERVER_HAVE_SASL if ( client -> saslconn ) i = ReadFromSASL ( client , out , n ) ; else # endif i = read ( client -> sock , out , n ) ; if ( i <= 0 ) { if ( i < 0 ) { # ifdef WIN32 errno = WSAGetLastError ( ) ; # endif if ( errno == EWOULDBLOCK || errno == EAGAIN ) { <S2SV_StartBug> WaitForMessage ( client , 100000 ) ; <S2SV_EndBug> i = 0 ; } else { rfbClientErr ( \"read<S2SV_blank>(%s)\\\\n\" , strerror ( errno ) ) ; return FALSE ; } } else { if ( errorMessageOnReadFailure ) { rfbClientLog ( \"VNC<S2SV_blank>server<S2SV_blank>closed<S2SV_blank>connection\\\\n\" ) ; } return FALSE ; } } out += i ; n -= i ; } } # ifdef DEBUG_READ_EXACT hexdump : { unsigned int ii ; for ( ii = 0 ; ii < nn ; ii ++ ) fprintf ( stderr , \"%02x<S2SV_blank>\" , ( unsigned char ) oout [ ii ] ) ; fprintf ( stderr , \"\\\\n\" ) ; } # endif return TRUE ; }", "target": "<S2SV_ModStart> n ) { const int USECS_WAIT_PER_RETRY = 100000 ; int retries = 0 ; <S2SV_ModStart> EAGAIN ) { if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( \"Connection<S2SV_blank>timed<S2SV_blank>out\\\\n\" ) ; return FALSE ; } <S2SV_ModStart> ( client , USECS_WAIT_PER_RETRY <S2SV_ModEnd> ) ; i <S2SV_ModStart> EAGAIN ) { if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( \"Connection<S2SV_blank>timed<S2SV_blank>out\\\\n\" ) ; return FALSE ; } <S2SV_ModStart> ( client , USECS_WAIT_PER_RETRY <S2SV_ModEnd> ) ; i"}
{"source": "CWE-125 static INLINE BOOL RLEDECOMPRESS ( const BYTE * pbSrcBuffer , UINT32 cbSrcBuffer , BYTE * pbDestBuffer , UINT32 rowDelta , UINT32 width , UINT32 height ) { const BYTE * pbSrc = pbSrcBuffer ; const BYTE * pbEnd ; const BYTE * pbDestEnd ; BYTE * pbDest = pbDestBuffer ; PIXEL temp ; PIXEL fgPel = WHITE_PIXEL ; BOOL fInsertFgPel = FALSE ; BOOL fFirstLine = TRUE ; BYTE bitmask ; PIXEL pixelA , pixelB ; UINT32 runLength ; UINT32 code ; UINT32 advance ; RLEEXTRA if ( ( rowDelta == 0 ) || ( rowDelta < width ) ) return FALSE ; if ( ! pbSrcBuffer || ! pbDestBuffer ) return FALSE ; pbEnd = pbSrcBuffer + cbSrcBuffer ; pbDestEnd = pbDestBuffer + rowDelta * height ; while ( pbSrc < pbEnd ) { if ( fFirstLine ) { if ( ( UINT32 ) ( pbDest - pbDestBuffer ) >= rowDelta ) { fFirstLine = FALSE ; fInsertFgPel = FALSE ; } } code = ExtractCodeId ( * pbSrc ) ; if ( code == REGULAR_BG_RUN || code == MEGA_MEGA_BG_RUN ) { runLength = ExtractRunLength ( code , pbSrc , & advance ) ; pbSrc = pbSrc + advance ; if ( fFirstLine ) { if ( fInsertFgPel ) { if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , 1 ) ) return FALSE ; DESTWRITEPIXEL ( pbDest , fgPel ) ; DESTNEXTPIXEL ( pbDest ) ; runLength = runLength - 1 ; } if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , runLength ) ) return FALSE ; UNROLL ( runLength , { DESTWRITEPIXEL ( pbDest , BLACK_PIXEL ) ; DESTNEXTPIXEL ( pbDest ) ; } ) ; } else { if ( fInsertFgPel ) { DESTREADPIXEL ( temp , pbDest - rowDelta ) ; if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , 1 ) ) return FALSE ; DESTWRITEPIXEL ( pbDest , temp ^ fgPel ) ; DESTNEXTPIXEL ( pbDest ) ; runLength -- ; } if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , runLength ) ) return FALSE ; UNROLL ( runLength , { DESTREADPIXEL ( temp , pbDest - rowDelta ) ; DESTWRITEPIXEL ( pbDest , temp ) ; DESTNEXTPIXEL ( pbDest ) ; } ) ; } fInsertFgPel = TRUE ; continue ; } fInsertFgPel = FALSE ; switch ( code ) { case REGULAR_FG_RUN : case MEGA_MEGA_FG_RUN : case LITE_SET_FG_FG_RUN : case MEGA_MEGA_SET_FG_RUN : runLength = ExtractRunLength ( code , pbSrc , & advance ) ; pbSrc = pbSrc + advance ; if ( code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN ) { <S2SV_StartBug> SRCREADPIXEL ( fgPel , pbSrc ) ; <S2SV_EndBug> SRCNEXTPIXEL ( pbSrc ) ; } if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , runLength ) ) return FALSE ; if ( fFirstLine ) { UNROLL ( runLength , { DESTWRITEPIXEL ( pbDest , fgPel ) ; DESTNEXTPIXEL ( pbDest ) ; } ) ; } else { UNROLL ( runLength , { DESTREADPIXEL ( temp , pbDest - rowDelta ) ; DESTWRITEPIXEL ( pbDest , temp ^ fgPel ) ; DESTNEXTPIXEL ( pbDest ) ; } ) ; } break ; case LITE_DITHERED_RUN : case MEGA_MEGA_DITHERED_RUN : runLength = ExtractRunLength ( code , pbSrc , & advance ) ; pbSrc = pbSrc + advance ; <S2SV_StartBug> SRCREADPIXEL ( pixelA , pbSrc ) ; <S2SV_EndBug> <S2SV_StartBug> SRCNEXTPIXEL ( pbSrc ) ; <S2SV_EndBug> SRCREADPIXEL ( pixelB , pbSrc ) ; SRCNEXTPIXEL ( pbSrc ) ; if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , runLength * 2 ) ) return FALSE ; UNROLL ( runLength , { DESTWRITEPIXEL ( pbDest , pixelA ) ; DESTNEXTPIXEL ( pbDest ) ; DESTWRITEPIXEL ( pbDest , pixelB ) ; DESTNEXTPIXEL ( pbDest ) ; } ) ; break ; case REGULAR_COLOR_RUN : case MEGA_MEGA_COLOR_RUN : runLength = ExtractRunLength ( code , pbSrc , & advance ) ; pbSrc = pbSrc + advance ; <S2SV_StartBug> SRCREADPIXEL ( pixelA , pbSrc ) ; <S2SV_EndBug> SRCNEXTPIXEL ( pbSrc ) ; if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , runLength ) ) return FALSE ; UNROLL ( runLength , { DESTWRITEPIXEL ( pbDest , pixelA ) ; DESTNEXTPIXEL ( pbDest ) ; } ) ; break ; case REGULAR_FGBG_IMAGE : case MEGA_MEGA_FGBG_IMAGE : case LITE_SET_FG_FGBG_IMAGE : case MEGA_MEGA_SET_FGBG_IMAGE : runLength = ExtractRunLength ( code , pbSrc , & advance ) ; pbSrc = pbSrc + advance ; <S2SV_StartBug> <S2SV_EndBug> if ( code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE ) { SRCREADPIXEL ( fgPel , pbSrc ) ; SRCNEXTPIXEL ( pbSrc ) ; } if ( fFirstLine ) { while ( runLength > 8 ) { bitmask = * pbSrc ; pbSrc = pbSrc + 1 ; pbDest = WRITEFIRSTLINEFGBGIMAGE ( pbDest , pbDestEnd , bitmask , fgPel , 8 ) ; if ( ! pbDest ) return FALSE ; runLength = runLength - 8 ; } } else { while ( runLength > 8 ) { bitmask = * pbSrc ; pbSrc = pbSrc + 1 ; pbDest = WRITEFGBGIMAGE ( pbDest , pbDestEnd , rowDelta , bitmask , fgPel , 8 ) ; if ( ! pbDest ) return FALSE ; runLength = runLength - 8 ; } } if ( runLength > 0 ) { bitmask = * pbSrc ; pbSrc = pbSrc + 1 ; if ( fFirstLine ) { pbDest = WRITEFIRSTLINEFGBGIMAGE ( pbDest , pbDestEnd , bitmask , fgPel , runLength ) ; } else { pbDest = WRITEFGBGIMAGE ( pbDest , pbDestEnd , rowDelta , bitmask , fgPel , runLength ) ; } if ( ! pbDest ) return FALSE ; } break ; case REGULAR_COLOR_IMAGE : case MEGA_MEGA_COLOR_IMAGE : runLength = ExtractRunLength ( code , pbSrc , & advance ) ; pbSrc = pbSrc + advance ; if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , runLength ) ) return FALSE ; UNROLL ( runLength , { <S2SV_StartBug> SRCREADPIXEL ( temp , pbSrc ) ; <S2SV_EndBug> SRCNEXTPIXEL ( pbSrc ) ; DESTWRITEPIXEL ( pbDest , temp ) ; DESTNEXTPIXEL ( pbDest ) ; } ) ; break ; case SPECIAL_FGBG_1 : pbSrc = pbSrc + 1 ; if ( fFirstLine ) { pbDest = WRITEFIRSTLINEFGBGIMAGE ( pbDest , pbDestEnd , g_MaskSpecialFgBg1 , fgPel , 8 ) ; } else { pbDest = WRITEFGBGIMAGE ( pbDest , pbDestEnd , rowDelta , g_MaskSpecialFgBg1 , fgPel , 8 ) ; } if ( ! pbDest ) return FALSE ; break ; case SPECIAL_FGBG_2 : pbSrc = pbSrc + 1 ; if ( fFirstLine ) { pbDest = WRITEFIRSTLINEFGBGIMAGE ( pbDest , pbDestEnd , g_MaskSpecialFgBg2 , fgPel , 8 ) ; } else { pbDest = WRITEFGBGIMAGE ( pbDest , pbDestEnd , rowDelta , g_MaskSpecialFgBg2 , fgPel , 8 ) ; } if ( ! pbDest ) return FALSE ; break ; case SPECIAL_WHITE : pbSrc = pbSrc + 1 ; if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , 1 ) ) return FALSE ; DESTWRITEPIXEL ( pbDest , WHITE_PIXEL ) ; DESTNEXTPIXEL ( pbDest ) ; break ; case SPECIAL_BLACK : pbSrc = pbSrc + 1 ; if ( ! ENSURE_CAPACITY ( pbDest , pbDestEnd , 1 ) ) return FALSE ; DESTWRITEPIXEL ( pbDest , BLACK_PIXEL ) ; DESTNEXTPIXEL ( pbDest ) ; break ; default : return FALSE ; } } return TRUE ; }", "target": "<S2SV_ModStart> MEGA_MEGA_SET_FG_RUN ) { if ( pbSrc >= pbEnd ) return FALSE ; <S2SV_ModStart> + advance ; if ( pbSrc >= pbEnd ) return FALSE ; <S2SV_ModStart> ( pbSrc ) ; if ( pbSrc >= pbEnd ) return FALSE <S2SV_ModStart> + advance ; if ( pbSrc >= pbEnd ) return FALSE ; <S2SV_ModStart> + advance ; if ( pbSrc >= pbEnd ) return FALSE ; <S2SV_ModStart> runLength , { if ( pbSrc >= pbEnd ) return FALSE ;"}
{"source": "CWE-787 static int vcf_parse_format ( kstring_t * s , const bcf_hdr_t * h , bcf1_t * v , char * p , char * q ) { if ( ! bcf_hdr_nsamples ( h ) ) return 0 ; static int extreme_val_warned = 0 ; char * r , * t ; int j , l , m , g , overflow = 0 ; khint_t k ; ks_tokaux_t aux1 ; vdict_t * d = ( vdict_t * ) h -> dict [ BCF_DT_ID ] ; kstring_t * mem = ( kstring_t * ) & h -> mem ; fmt_aux_t fmt [ MAX_N_FMT ] ; mem -> l = 0 ; char * end = s -> s + s -> l ; if ( q >= end ) { hts_log_error ( \"FORMAT<S2SV_blank>column<S2SV_blank>with<S2SV_blank>no<S2SV_blank>sample<S2SV_blank>columns<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"\" , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_NCOLS ; return - 1 ; } v -> n_fmt = 0 ; if ( p [ 0 ] == '.' && p [ 1 ] == 0 ) { v -> n_sample = bcf_hdr_nsamples ( h ) ; return 0 ; } for ( j = 0 , t = kstrtok ( p , \":\" , & aux1 ) ; t ; t = kstrtok ( 0 , 0 , & aux1 ) , ++ j ) { if ( j >= MAX_N_FMT ) { v -> errcode |= BCF_ERR_LIMITS ; hts_log_error ( \"FORMAT<S2SV_blank>column<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"<S2SV_blank>lists<S2SV_blank>more<S2SV_blank>identifiers<S2SV_blank>than<S2SV_blank>htslib<S2SV_blank>can<S2SV_blank>handle\" , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; return - 1 ; } * ( char * ) aux1 . p = 0 ; k = kh_get ( vdict , d , t ) ; if ( k == kh_end ( d ) || kh_val ( d , k ) . info [ BCF_HL_FMT ] == 15 ) { if ( t [ 0 ] == '.' && t [ 1 ] == 0 ) { hts_log_error ( \"Invalid<S2SV_blank>FORMAT<S2SV_blank>tag<S2SV_blank>name<S2SV_blank>\\'.\\'<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_TAG_INVALID ; return - 1 ; } hts_log_warning ( \"FORMAT<S2SV_blank>\\'%s\\'<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"<S2SV_blank>is<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>in<S2SV_blank>the<S2SV_blank>header,<S2SV_blank>assuming<S2SV_blank>Type=String\" , t , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; kstring_t tmp = { 0 , 0 , 0 } ; int l ; ksprintf ( & tmp , \"##FORMAT=<ID=%s,Number=1,Type=String,Description=\\\\\"Dummy\\\\\">\" , t ) ; bcf_hrec_t * hrec = bcf_hdr_parse_line ( h , tmp . s , & l ) ; free ( tmp . s ) ; int res = hrec ? bcf_hdr_add_hrec ( ( bcf_hdr_t * ) h , hrec ) : - 1 ; if ( res < 0 ) bcf_hrec_destroy ( hrec ) ; if ( res > 0 ) res = bcf_hdr_sync ( ( bcf_hdr_t * ) h ) ; k = kh_get ( vdict , d , t ) ; v -> errcode = BCF_ERR_TAG_UNDEF ; if ( res || k == kh_end ( d ) ) { hts_log_error ( \"Could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>dummy<S2SV_blank>header<S2SV_blank>for<S2SV_blank>FORMAT<S2SV_blank>\\'%s\\'<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , t , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_TAG_INVALID ; return - 1 ; } } fmt [ j ] . max_l = fmt [ j ] . max_m = fmt [ j ] . max_g = 0 ; fmt [ j ] . key = kh_val ( d , k ) . id ; fmt [ j ] . is_gt = ! strcmp ( t , \"GT\" ) ; fmt [ j ] . y = h -> id [ 0 ] [ fmt [ j ] . key ] . val -> info [ BCF_HL_FMT ] ; v -> n_fmt ++ ; } int n_sample_ori = - 1 ; r = q + 1 ; l = 0 , m = g = 1 , v -> n_sample = 0 ; while ( r < end ) { if ( h -> keep_samples ) { n_sample_ori ++ ; if ( ! bit_array_test ( h -> keep_samples , n_sample_ori ) ) { while ( * r != '\\\\t' && r < end ) r ++ ; if ( * r == '\\\\t' ) { * r = 0 ; r ++ ; } continue ; } } j = 0 ; fmt_aux_t * f = fmt ; for ( ; ; ) { switch ( * r ) { case ',' : m ++ ; break ; case '|' : case '/' : if ( f -> is_gt ) g ++ ; break ; case '\\\\t' : * r = 0 ; case '\\\\0' : case ':' : if ( f -> max_m < m ) f -> max_m = m ; if ( f -> max_l < l ) f -> max_l = l ; if ( f -> is_gt && f -> max_g < g ) f -> max_g = g ; l = 0 , m = g = 1 ; if ( * r == ':' ) { j ++ ; f ++ ; if ( j >= v -> n_fmt ) { hts_log_error ( \"Incorrect<S2SV_blank>number<S2SV_blank>of<S2SV_blank>FORMAT<S2SV_blank>fields<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"\" , h -> id [ BCF_DT_CTG ] [ v -> rid ] . key , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_NCOLS ; return - 1 ; } } else goto end_for ; break ; } if ( r >= end ) break ; r ++ ; l ++ ; } end_for : v -> n_sample ++ ; if ( v -> n_sample == bcf_hdr_nsamples ( h ) ) break ; r ++ ; } for ( j = 0 ; j < v -> n_fmt ; ++ j ) { fmt_aux_t * f = & fmt [ j ] ; if ( ! f -> max_m ) f -> max_m = 1 ; if ( ( f -> y >> 4 & 0xf ) == BCF_HT_STR ) { f -> size = f -> is_gt ? f -> max_g << 2 : f -> max_l ; } else if ( ( f -> y >> 4 & 0xf ) == BCF_HT_REAL || ( f -> y >> 4 & 0xf ) == BCF_HT_INT ) { f -> size = f -> max_m << 2 ; } else { hts_log_error ( \"The<S2SV_blank>format<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"<S2SV_blank>is<S2SV_blank>currently<S2SV_blank>not<S2SV_blank>supported\" , f -> y >> 4 & 0xf , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_TAG_INVALID ; return - 1 ; } if ( align_mem ( mem ) < 0 ) { hts_log_error ( \"Memory<S2SV_blank>allocation<S2SV_blank>failure<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_LIMITS ; return - 1 ; } <S2SV_StartBug> f -> offset = mem -> l ; <S2SV_EndBug> if ( v -> n_sample * ( uint64_t ) f -> size > INT_MAX ) { hts_log_error ( \"Excessive<S2SV_blank>memory<S2SV_blank>required<S2SV_blank>by<S2SV_blank>FORMAT<S2SV_blank>fields<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_LIMITS ; return - 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ks_resize ( mem , mem -> l + v -> n_sample * ( size_t ) f -> size ) < 0 ) { hts_log_error ( \"Memory<S2SV_blank>allocation<S2SV_blank>failure<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_LIMITS ; return - 1 ; } mem -> l += v -> n_sample * f -> size ; } for ( j = 0 ; j < v -> n_fmt ; ++ j ) fmt [ j ] . buf = ( uint8_t * ) mem -> s + fmt [ j ] . offset ; n_sample_ori = - 1 ; t = q + 1 ; m = 0 ; while ( t < end ) { if ( h -> keep_samples ) { n_sample_ori ++ ; if ( ! bit_array_test ( h -> keep_samples , n_sample_ori ) ) { while ( * t && t < end ) t ++ ; t ++ ; continue ; } } if ( m == bcf_hdr_nsamples ( h ) ) break ; j = 0 ; while ( t < end ) { fmt_aux_t * z = & fmt [ j ++ ] ; if ( ! z -> buf ) { hts_log_error ( \"Memory<S2SV_blank>allocation<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>FORMAT<S2SV_blank>field<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , z -> y >> 4 & 0xf , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_LIMITS ; return - 1 ; } if ( ( z -> y >> 4 & 0xf ) == BCF_HT_STR ) { if ( z -> is_gt ) { int32_t is_phased = 0 ; uint32_t * x = ( uint32_t * ) ( z -> buf + z -> size * ( size_t ) m ) ; uint32_t unreadable = 0 ; uint32_t max = 0 ; overflow = 0 ; for ( l = 0 ; ; ++ t ) { if ( * t == '.' ) { ++ t , x [ l ++ ] = is_phased ; } else { char * tt = t ; uint32_t val = hts_str2uint ( t , & t , sizeof ( val ) * CHAR_MAX - 2 , & overflow ) ; unreadable |= tt == t ; if ( max < val ) max = val ; x [ l ++ ] = ( val + 1 ) << 1 | is_phased ; } is_phased = ( * t == '|' ) ; if ( * t != '|' && * t != '/' ) break ; } if ( overflow || max > ( INT32_MAX >> 1 ) - 1 ) { hts_log_error ( \"Couldn\\'t<S2SV_blank>read<S2SV_blank>GT<S2SV_blank>data:<S2SV_blank>value<S2SV_blank>too<S2SV_blank>large<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; return - 1 ; } if ( unreadable ) { hts_log_error ( \"Couldn\\'t<S2SV_blank>read<S2SV_blank>GT<S2SV_blank>data:<S2SV_blank>value<S2SV_blank>not<S2SV_blank>a<S2SV_blank>number<S2SV_blank>or<S2SV_blank>\\'.\\'<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; return - 1 ; } if ( ! l ) x [ l ++ ] = 0 ; for ( ; l < z -> size >> 2 ; ++ l ) x [ l ] = bcf_int32_vector_end ; } else { char * x = ( char * ) z -> buf + z -> size * ( size_t ) m ; for ( r = t , l = 0 ; * t != ':' && * t ; ++ t ) x [ l ++ ] = * t ; for ( ; l < z -> size ; ++ l ) x [ l ] = 0 ; } } else if ( ( z -> y >> 4 & 0xf ) == BCF_HT_INT ) { int32_t * x = ( int32_t * ) ( z -> buf + z -> size * ( size_t ) m ) ; for ( l = 0 ; ; ++ t ) { if ( * t == '.' ) { x [ l ++ ] = bcf_int32_missing , ++ t ; } else { overflow = 0 ; char * te ; long int tmp_val = hts_str2int ( t , & te , sizeof ( tmp_val ) * CHAR_BIT , & overflow ) ; if ( te == t || overflow || tmp_val < BCF_MIN_BT_INT32 || tmp_val > BCF_MAX_BT_INT32 ) { if ( ! extreme_val_warned ) { hts_log_warning ( \"Extreme<S2SV_blank>FORMAT/%s<S2SV_blank>value<S2SV_blank>encountered<S2SV_blank>and<S2SV_blank>set<S2SV_blank>to<S2SV_blank>missing<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , h -> id [ BCF_DT_ID ] [ fmt [ j - 1 ] . key ] . key , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; extreme_val_warned = 1 ; } tmp_val = bcf_int32_missing ; } x [ l ++ ] = tmp_val ; t = te ; } if ( * t != ',' ) break ; } if ( ! l ) x [ l ++ ] = bcf_int32_missing ; for ( ; l < z -> size >> 2 ; ++ l ) x [ l ] = bcf_int32_vector_end ; } else if ( ( z -> y >> 4 & 0xf ) == BCF_HT_REAL ) { float * x = ( float * ) ( z -> buf + z -> size * ( size_t ) m ) ; for ( l = 0 ; ; ++ t ) { if ( * t == '.' && ! isdigit_c ( t [ 1 ] ) ) { bcf_float_set_missing ( x [ l ++ ] ) , ++ t ; } else { overflow = 0 ; char * te ; float tmp_val = hts_str2dbl ( t , & te , & overflow ) ; if ( ( te == t || overflow ) && ! extreme_val_warned ) { hts_log_warning ( \"Extreme<S2SV_blank>FORMAT/%s<S2SV_blank>value<S2SV_blank>encountered<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , h -> id [ BCF_DT_ID ] [ fmt [ j - 1 ] . key ] . key , bcf_seqname ( h , v ) , v -> pos + 1 ) ; extreme_val_warned = 1 ; } x [ l ++ ] = tmp_val ; t = te ; } if ( * t != ',' ) break ; } if ( ! l ) bcf_float_set_missing ( x [ l ++ ] ) ; for ( ; l < z -> size >> 2 ; ++ l ) bcf_float_set_vector_end ( x [ l ] ) ; } else { hts_log_error ( \"Unknown<S2SV_blank>FORMAT<S2SV_blank>field<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , z -> y >> 4 & 0xf , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_TAG_INVALID ; return - 1 ; } if ( * t == '\\\\0' ) { break ; } else if ( * t == ':' ) { t ++ ; } else { char buffer [ 8 ] ; hts_log_error ( \"Invalid<S2SV_blank>character<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>\\'%s\\'<S2SV_blank>FORMAT<S2SV_blank>field<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"\" , hts_strprint ( buffer , sizeof buffer , '\\\\'' , t , 1 ) , h -> id [ BCF_DT_ID ] [ z -> key ] . key , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_CHAR ; return - 1 ; } } for ( ; j < v -> n_fmt ; ++ j ) { fmt_aux_t * z = & fmt [ j ] ; if ( ( z -> y >> 4 & 0xf ) == BCF_HT_STR ) { if ( z -> is_gt ) { int32_t * x = ( int32_t * ) ( z -> buf + z -> size * ( size_t ) m ) ; if ( z -> size ) x [ 0 ] = bcf_int32_missing ; for ( l = 1 ; l < z -> size >> 2 ; ++ l ) x [ l ] = bcf_int32_vector_end ; } else { char * x = ( char * ) z -> buf + z -> size * ( size_t ) m ; if ( z -> size ) x [ 0 ] = '.' ; for ( l = 1 ; l < z -> size ; ++ l ) x [ l ] = 0 ; } } else if ( ( z -> y >> 4 & 0xf ) == BCF_HT_INT ) { int32_t * x = ( int32_t * ) ( z -> buf + z -> size * ( size_t ) m ) ; x [ 0 ] = bcf_int32_missing ; for ( l = 1 ; l < z -> size >> 2 ; ++ l ) x [ l ] = bcf_int32_vector_end ; } else if ( ( z -> y >> 4 & 0xf ) == BCF_HT_REAL ) { float * x = ( float * ) ( z -> buf + z -> size * ( size_t ) m ) ; bcf_float_set_missing ( x [ 0 ] ) ; for ( l = 1 ; l < z -> size >> 2 ; ++ l ) bcf_float_set_vector_end ( x [ l ] ) ; } } m ++ ; t ++ ; } kstring_t * str = & v -> indiv ; int i ; if ( v -> n_sample > 0 ) { for ( i = 0 ; i < v -> n_fmt ; ++ i ) { fmt_aux_t * z = & fmt [ i ] ; bcf_enc_int1 ( str , z -> key ) ; if ( ( z -> y >> 4 & 0xf ) == BCF_HT_STR && ! z -> is_gt ) { bcf_enc_size ( str , z -> size , BCF_BT_CHAR ) ; kputsn ( ( char * ) z -> buf , z -> size * ( size_t ) v -> n_sample , str ) ; } else if ( ( z -> y >> 4 & 0xf ) == BCF_HT_INT || z -> is_gt ) { bcf_enc_vint ( str , ( z -> size >> 2 ) * v -> n_sample , ( int32_t * ) z -> buf , z -> size >> 2 ) ; } else { bcf_enc_size ( str , z -> size >> 2 , BCF_BT_FLOAT ) ; if ( serialize_float_array ( str , ( z -> size >> 2 ) * ( size_t ) v -> n_sample , ( float * ) z -> buf ) != 0 ) { v -> errcode |= BCF_ERR_LIMITS ; hts_log_error ( \"Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; return - 1 ; } } } } if ( v -> n_sample != bcf_hdr_nsamples ( h ) ) { hts_log_error ( \"Number<S2SV_blank>of<S2SV_blank>columns<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>samples<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%d)\" , bcf_seqname_safe ( h , v ) , v -> pos + 1 , v -> n_sample , bcf_hdr_nsamples ( h ) ) ; v -> errcode |= BCF_ERR_NCOLS ; return - 1 ; } if ( v -> indiv . l > 0xffffffff ) { hts_log_error ( \"The<S2SV_blank>FORMAT<S2SV_blank>at<S2SV_blank>%s:%\" PRIhts_pos \"<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\" , bcf_seqname_safe ( h , v ) , v -> pos + 1 ) ; v -> errcode |= BCF_ERR_LIMITS ; v -> n_fmt = 0 ; return - 1 ; } return 0 ; }", "target": "<S2SV_ModStart> 1 ; } if ( ( uint64_t ) <S2SV_ModEnd> mem -> l <S2SV_ModStart> mem -> l + <S2SV_ModEnd> v -> n_sample <S2SV_ModStart> 1 ; } f -> offset = mem -> l ;"}
{"source": "CWE-362 int hci_req_sync ( struct hci_dev * hdev , int ( * req ) ( struct hci_request * req , unsigned long opt ) , unsigned long opt , u32 timeout , u8 * hci_status ) { int ret ; <S2SV_StartBug> if ( ! test_bit ( HCI_UP , & hdev -> flags ) ) <S2SV_EndBug> <S2SV_StartBug> return - ENETDOWN ; <S2SV_EndBug> hci_req_sync_lock ( hdev ) ; ret = __hci_req_sync ( hdev , req , opt , timeout , hci_status ) ; <S2SV_StartBug> hci_req_sync_unlock ( hdev ) ; <S2SV_EndBug> return ret ; }", "target": "<S2SV_ModStart> int ret ; hci_req_sync_lock ( hdev ) ; if ( <S2SV_ModEnd> test_bit ( HCI_UP <S2SV_ModStart> flags ) ) <S2SV_ModEnd> ret = __hci_req_sync <S2SV_ModStart> hci_status ) ; else ret = - ENETDOWN ;"}
{"source": "CWE-415 static UINT parallel_process_irp_create ( PARALLEL_DEVICE * parallel , IRP * irp ) { char * path = NULL ; int status ; <S2SV_StartBug> UINT32 PathLength ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 28 ) ; <S2SV_EndBug> Stream_Read_UINT32 ( irp -> input , PathLength ) ; <S2SV_StartBug> status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 , <S2SV_EndBug> & path , 0 , NULL , NULL ) ; if ( status < 1 ) if ( ! ( path = ( char * ) calloc ( 1 , 1 ) ) ) { WLog_ERR ( TAG , \"calloc<S2SV_blank>failed!\" ) ; return CHANNEL_RC_NO_MEMORY ; } parallel -> id = irp -> devman -> id_sequence ++ ; parallel -> file = open ( parallel -> path , O_RDWR ) ; if ( parallel -> file < 0 ) { irp -> IoStatus = STATUS_ACCESS_DENIED ; parallel -> id = 0 ; } else { if ( fcntl ( parallel -> file , F_SETFL , O_NONBLOCK ) == - 1 ) { } } Stream_Write_UINT32 ( irp -> output , parallel -> id ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; free ( path ) ; return irp -> Complete ( irp ) ; }", "target": "<S2SV_ModStart> int status ; WCHAR * ptr ; <S2SV_ModStart> UINT32 PathLength ; if ( ! Stream_SafeSeek <S2SV_ModEnd> ( irp -> <S2SV_ModStart> , 28 ) ) return ERROR_INVALID_DATA ; if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA <S2SV_ModStart> PathLength ) ; ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> , 0 , ptr <S2SV_ModEnd> , PathLength /"}
{"source": "CWE-190 exif_data_load_data_thumbnail ( ExifData * data , const unsigned char * d , unsigned int ds , ExifLong o , ExifLong s ) { if ( o >= ds ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u).\" , o ) ; return ; } <S2SV_StartBug> if ( s > ds - o ) { <S2SV_EndBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Bogus<S2SV_blank>thumbnail<S2SV_blank>size<S2SV_blank>(%u),<S2SV_blank>max<S2SV_blank>would<S2SV_blank>be<S2SV_blank>%u.\" , s , ds - o ) ; return ; } if ( data -> data ) exif_mem_free ( data -> priv -> mem , data -> data ) ; if ( ! ( data -> data = exif_data_alloc ( data , s ) ) ) { EXIF_LOG_NO_MEMORY ( data -> priv -> log , \"ExifData\" , s ) ; data -> size = 0 ; return ; } data -> size = s ; memcpy ( data -> data , d + o , s ) ; }", "target": "<S2SV_ModStart> } if ( CHECKOVERFLOW ( o , ds , s ) <S2SV_ModEnd> ) { exif_log"}
{"source": "CWE-119 static int hva_to_pfn_remapped ( struct vm_area_struct * vma , unsigned long addr , bool * async , bool write_fault , bool * writable , kvm_pfn_t * p_pfn ) { kvm_pfn_t pfn ; pte_t * ptep ; spinlock_t * ptl ; int r ; r = follow_pte ( vma -> vm_mm , addr , & ptep , & ptl ) ; if ( r ) { bool unlocked = false ; r = fixup_user_fault ( current -> mm , addr , ( write_fault ? FAULT_FLAG_WRITE : 0 ) , & unlocked ) ; if ( unlocked ) return - EAGAIN ; if ( r ) return r ; r = follow_pte ( vma -> vm_mm , addr , & ptep , & ptl ) ; if ( r ) return r ; } if ( write_fault && ! pte_write ( * ptep ) ) { pfn = KVM_PFN_ERR_RO_FAULT ; goto out ; } if ( writable ) * writable = pte_write ( * ptep ) ; pfn = pte_pfn ( * ptep ) ; <S2SV_StartBug> kvm_get_pfn ( pfn ) ; <S2SV_EndBug> out : pte_unmap_unlock ( ptep , ptl ) ; * p_pfn = pfn ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ptep ) ; if ( ! kvm_try_get_pfn ( pfn ) ) r = - EFAULT <S2SV_ModEnd> ; out : <S2SV_ModStart> = pfn ; return r <S2SV_ModEnd> ; }"}
{"source": "CWE-415 file_rlookup ( const char * filename ) { int i ; cache_t * wc ; for ( i = web_files , wc = web_cache ; i > 0 ; i -- , wc ++ ) <S2SV_StartBug> if ( ! strcmp ( wc -> name , filename ) ) <S2SV_EndBug> <S2SV_StartBug> return ( wc -> url ) ; <S2SV_EndBug> return ( filename ) ; }", "target": "<S2SV_ModStart> wc ++ ) { <S2SV_ModStart> filename ) ) { if ( ! strncmp ( wc -> url , \"data:\" , 5 ) ) return ( \"data<S2SV_blank>URL\" ) ; else <S2SV_ModStart> url ) ; } }"}
{"source": "CWE-476 static Image * ReadSVGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] ; const char * option ; FILE * file ; Image * image , * next ; int status , unique_file ; ssize_t n ; SVGInfo * svg_info ; unsigned char message [ MagickPathExtent ] ; xmlSAXHandler sax_modules ; xmlSAXHandlerPtr sax_handler ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ( fabs ( image -> resolution . x ) < MagickEpsilon ) || ( fabs ( image -> resolution . y ) < MagickEpsilon ) ) { GeometryInfo geometry_info ; int flags ; flags = ParseGeometry ( SVGDensityGeometry , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } if ( LocaleCompare ( image_info -> magick , \"MSVG\" ) != 0 ) { Image * svg_image ; svg_image = RenderSVGImage ( image_info , image , exception ) ; if ( svg_image != ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( svg_image ) ; } { # if defined ( MAGICKCORE_RSVG_DELEGATE ) # if defined ( MAGICKCORE_CAIRO_DELEGATE ) cairo_surface_t * cairo_surface ; cairo_t * cairo_image ; MagickBooleanType apply_density ; MemoryInfo * pixel_info ; register unsigned char * p ; RsvgDimensionData dimension_info ; unsigned char * pixels ; # else GdkPixbuf * pixel_buffer ; register const guchar * p ; # endif GError * error ; PixelInfo fill_color ; register ssize_t x ; register Quantum * q ; RsvgHandle * svg_handle ; ssize_t y ; unsigned char * buffer ; buffer = ( unsigned char * ) AcquireQuantumMemory ( MagickMaxBufferExtent , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; # if LIBRSVG_CHECK_VERSION ( 2 , 40 , 3 ) option = GetImageOption ( image_info , \"svg:xml-parse-huge\" ) ; if ( ( option != ( char * ) NULL ) && ( IsStringTrue ( option ) != MagickFalse ) ) svg_handle = rsvg_handle_new_with_flags ( RSVG_HANDLE_FLAG_UNLIMITED ) ; else # endif svg_handle = rsvg_handle_new ( ) ; if ( svg_handle == ( RsvgHandle * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } rsvg_handle_set_base_uri ( svg_handle , image_info -> filename ) ; if ( ( fabs ( image -> resolution . x ) > MagickEpsilon ) && ( fabs ( image -> resolution . y ) > MagickEpsilon ) ) rsvg_handle_set_dpi_x_y ( svg_handle , image -> resolution . x , image -> resolution . y ) ; while ( ( n = ReadBlob ( image , MagickMaxBufferExtent - 1 , buffer ) ) != 0 ) { buffer [ n ] = '\\\\0' ; error = ( GError * ) NULL ; ( void ) rsvg_handle_write ( svg_handle , buffer , n , & error ) ; if ( error != ( GError * ) NULL ) g_error_free ( error ) ; } buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; error = ( GError * ) NULL ; rsvg_handle_close ( svg_handle , & error ) ; if ( error != ( GError * ) NULL ) g_error_free ( error ) ; # if defined ( MAGICKCORE_CAIRO_DELEGATE ) apply_density = MagickTrue ; rsvg_handle_get_dimensions ( svg_handle , & dimension_info ) ; if ( ( image -> resolution . x > 0.0 ) && ( image -> resolution . y > 0.0 ) ) { RsvgDimensionData dpi_dimension_info ; rsvg_handle_set_dpi_x_y ( svg_handle , image -> resolution . x * 256 , image -> resolution . y * 256 ) ; rsvg_handle_get_dimensions ( svg_handle , & dpi_dimension_info ) ; if ( ( dpi_dimension_info . width != dimension_info . width ) || ( dpi_dimension_info . height != dimension_info . height ) ) apply_density = MagickFalse ; rsvg_handle_set_dpi_x_y ( svg_handle , image -> resolution . x , image -> resolution . y ) ; } if ( image_info -> size != ( char * ) NULL ) { ( void ) GetGeometry ( image_info -> size , ( ssize_t * ) NULL , ( ssize_t * ) NULL , & image -> columns , & image -> rows ) ; if ( ( image -> columns != 0 ) || ( image -> rows != 0 ) ) { image -> resolution . x = DefaultSVGDensity * image -> columns / dimension_info . width ; image -> resolution . y = DefaultSVGDensity * image -> rows / dimension_info . height ; if ( fabs ( image -> resolution . x ) < MagickEpsilon ) image -> resolution . x = image -> resolution . y ; else if ( fabs ( image -> resolution . y ) < MagickEpsilon ) image -> resolution . y = image -> resolution . x ; else image -> resolution . x = image -> resolution . y = MagickMin ( image -> resolution . x , image -> resolution . y ) ; apply_density = MagickTrue ; } } if ( apply_density != MagickFalse ) { image -> columns = image -> resolution . x * dimension_info . width / DefaultSVGDensity ; image -> rows = image -> resolution . y * dimension_info . height / DefaultSVGDensity ; } else { image -> columns = dimension_info . width ; image -> rows = dimension_info . height ; } pixel_info = ( MemoryInfo * ) NULL ; # else pixel_buffer = rsvg_handle_get_pixbuf ( svg_handle ) ; rsvg_handle_free ( svg_handle ) ; image -> columns = gdk_pixbuf_get_width ( pixel_buffer ) ; image -> rows = gdk_pixbuf_get_height ( pixel_buffer ) ; # endif image -> alpha_trait = BlendPixelTrait ; if ( image_info -> ping == MagickFalse ) { # if defined ( MAGICKCORE_CAIRO_DELEGATE ) size_t stride ; # endif status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { # if ! defined ( MAGICKCORE_CAIRO_DELEGATE ) g_object_unref ( G_OBJECT ( pixel_buffer ) ) ; # endif g_object_unref ( svg_handle ) ; ThrowReaderException ( MissingDelegateError , \"NoDecodeDelegateForThisImageFormat\" ) ; } # if defined ( MAGICKCORE_CAIRO_DELEGATE ) stride = 4 * image -> columns ; # if defined ( MAGICKCORE_PANGOCAIRO_DELEGATE ) stride = ( size_t ) cairo_format_stride_for_width ( CAIRO_FORMAT_ARGB32 , ( int ) image -> columns ) ; # endif pixel_info = AcquireVirtualMemory ( stride , image -> rows * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) { g_object_unref ( svg_handle ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; # endif ( void ) SetImageBackgroundColor ( image , exception ) ; # if defined ( MAGICKCORE_CAIRO_DELEGATE ) cairo_surface = cairo_image_surface_create_for_data ( pixels , CAIRO_FORMAT_ARGB32 , ( int ) image -> columns , ( int ) image -> rows , ( int ) stride ) ; if ( ( cairo_surface == ( cairo_surface_t * ) NULL ) || ( cairo_surface_status ( cairo_surface ) != CAIRO_STATUS_SUCCESS ) ) { if ( cairo_surface != ( cairo_surface_t * ) NULL ) cairo_surface_destroy ( cairo_surface ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; g_object_unref ( svg_handle ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } cairo_image = cairo_create ( cairo_surface ) ; cairo_set_operator ( cairo_image , CAIRO_OPERATOR_CLEAR ) ; cairo_paint ( cairo_image ) ; cairo_set_operator ( cairo_image , CAIRO_OPERATOR_OVER ) ; if ( apply_density != MagickFalse ) cairo_scale ( cairo_image , image -> resolution . x / DefaultSVGDensity , image -> resolution . y / DefaultSVGDensity ) ; rsvg_handle_render_cairo ( svg_handle , cairo_image ) ; cairo_destroy ( cairo_image ) ; cairo_surface_destroy ( cairo_surface ) ; g_object_unref ( svg_handle ) ; p = pixels ; # else p = gdk_pixbuf_get_pixels ( pixel_buffer ) ; # endif GetPixelInfo ( image , & fill_color ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { # if defined ( MAGICKCORE_CAIRO_DELEGATE ) fill_color . blue = ScaleCharToQuantum ( * p ++ ) ; fill_color . green = ScaleCharToQuantum ( * p ++ ) ; fill_color . red = ScaleCharToQuantum ( * p ++ ) ; # else fill_color . red = ScaleCharToQuantum ( * p ++ ) ; fill_color . green = ScaleCharToQuantum ( * p ++ ) ; fill_color . blue = ScaleCharToQuantum ( * p ++ ) ; # endif fill_color . alpha = ScaleCharToQuantum ( * p ++ ) ; # if defined ( MAGICKCORE_CAIRO_DELEGATE ) { double gamma ; gamma = QuantumScale * fill_color . alpha ; gamma = PerceptibleReciprocal ( gamma ) ; fill_color . blue *= gamma ; fill_color . green *= gamma ; fill_color . red *= gamma ; } # endif CompositePixelOver ( image , & fill_color , fill_color . alpha , q , ( double ) GetPixelAlpha ( image , q ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } # if defined ( MAGICKCORE_CAIRO_DELEGATE ) if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; # else g_object_unref ( G_OBJECT ( pixel_buffer ) ) ; # endif ( void ) CloseBlob ( image ) ; for ( next = GetFirstImageInList ( image ) ; next != ( Image * ) NULL ; ) { ( void ) CopyMagickString ( next -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickString ( next -> magick , image -> magick , MaxTextExtent ) ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( image ) ) ; # endif } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , \"w\" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) CopyMagickString ( image -> filename , filename , MagickPathExtent ) ; ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } svg_info = AcquireSVGInfo ( ) ; if ( svg_info == ( SVGInfo * ) NULL ) { ( void ) fclose ( file ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } svg_info -> file = file ; svg_info -> exception = exception ; svg_info -> image = image ; svg_info -> image_info = image_info ; svg_info -> bounds . width = image -> columns ; svg_info -> bounds . height = image -> rows ; svg_info -> svgDepth = 0 ; if ( image_info -> size != ( char * ) NULL ) ( void ) CloneString ( & svg_info -> size , image_info -> size ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"begin<S2SV_blank>SAX\" ) ; xmlInitParser ( ) ; ( void ) xmlSubstituteEntitiesDefault ( 1 ) ; ( void ) memset ( & sax_modules , 0 , sizeof ( sax_modules ) ) ; sax_modules . internalSubset = SVGInternalSubset ; sax_modules . isStandalone = SVGIsStandalone ; sax_modules . hasInternalSubset = SVGHasInternalSubset ; sax_modules . hasExternalSubset = SVGHasExternalSubset ; sax_modules . resolveEntity = SVGResolveEntity ; sax_modules . getEntity = SVGGetEntity ; sax_modules . entityDecl = SVGEntityDeclaration ; sax_modules . notationDecl = SVGNotationDeclaration ; sax_modules . attributeDecl = SVGAttributeDeclaration ; sax_modules . elementDecl = SVGElementDeclaration ; sax_modules . unparsedEntityDecl = SVGUnparsedEntityDeclaration ; sax_modules . setDocumentLocator = SVGSetDocumentLocator ; sax_modules . startDocument = SVGStartDocument ; sax_modules . endDocument = SVGEndDocument ; sax_modules . startElement = SVGStartElement ; sax_modules . endElement = SVGEndElement ; sax_modules . reference = SVGReference ; sax_modules . characters = SVGCharacters ; sax_modules . ignorableWhitespace = SVGIgnorableWhitespace ; sax_modules . processingInstruction = SVGProcessingInstructions ; sax_modules . comment = SVGComment ; sax_modules . warning = SVGWarning ; sax_modules . error = SVGError ; sax_modules . fatalError = SVGError ; sax_modules . getParameterEntity = SVGGetParameterEntity ; sax_modules . cdataBlock = SVGCDataBlock ; sax_modules . externalSubset = SVGExternalSubset ; sax_handler = ( & sax_modules ) ; n = ReadBlob ( image , MagickPathExtent - 1 , message ) ; message [ n ] = '\\\\0' ; if ( n > 0 ) { svg_info -> parser = xmlCreatePushParserCtxt ( sax_handler , svg_info , ( char * ) message , n , image -> filename ) ; <S2SV_StartBug> option = GetImageOption ( image_info , \"svg:xml-parse-huge\" ) ; <S2SV_EndBug> if ( ( option != ( char * ) NULL ) && ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) xmlCtxtUseOptions ( svg_info -> parser , XML_PARSE_HUGE ) ; while ( ( n = ReadBlob ( image , MagickPathExtent - 1 , message ) ) != 0 ) { message [ n ] = '\\\\0' ; status = xmlParseChunk ( svg_info -> parser , ( char * ) message , ( int ) n , 0 ) ; if ( status != 0 ) break ; } } <S2SV_StartBug> ( void ) xmlParseChunk ( svg_info -> parser , ( char * ) message , 0 , 1 ) ; <S2SV_EndBug> SVGEndDocument ( svg_info ) ; if ( svg_info -> parser -> myDoc != ( xmlDocPtr ) NULL ) xmlFreeDoc ( svg_info -> parser -> myDoc ) ; xmlFreeParserCtxt ( svg_info -> parser ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"end<S2SV_blank>SAX\" ) ; ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image -> columns = svg_info -> width ; image -> rows = svg_info -> height ; if ( exception -> severity >= ErrorException ) { svg_info = DestroySVGInfo ( svg_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } if ( image_info -> ping == MagickFalse ) { ImageInfo * read_info ; image = DestroyImage ( image ) ; image = ( Image * ) NULL ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , \"mvg:%s\" , filename ) ; image = ReadImage ( read_info , exception ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image != ( Image * ) NULL ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; } if ( image != ( Image * ) NULL ) { if ( svg_info -> title != ( char * ) NULL ) ( void ) SetImageProperty ( image , \"svg:title\" , svg_info -> title , exception ) ; if ( svg_info -> comment != ( char * ) NULL ) ( void ) SetImageProperty ( image , \"svg:comment\" , svg_info -> comment , exception ) ; } for ( next = GetFirstImageInList ( image ) ; next != ( Image * ) NULL ; ) { ( void ) CopyMagickString ( next -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickString ( next -> magick , image -> magick , MaxTextExtent ) ; next = GetNextImageInList ( next ) ; } svg_info = DestroySVGInfo ( svg_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> filename ) ; if ( svg_info -> parser != ( xmlParserCtxtPtr ) NULL ) { <S2SV_ModStart> ; } } } if ( svg_info -> parser == ( xmlParserCtxtPtr ) NULL ) { svg_info = DestroySVGInfo ( svg_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; }"}
{"source": "CWE-120 convert ( Imaging imOut , Imaging imIn , const char * mode , ImagingPalette palette , int dither ) { ImagingSectionCookie cookie ; ImagingShuffler convert ; int y ; if ( ! imIn ) { return ( Imaging ) ImagingError_ModeError ( ) ; } if ( ! mode ) { if ( ! imIn -> palette ) { return ( Imaging ) ImagingError_ModeError ( ) ; } mode = imIn -> palette -> mode ; } else { if ( ! strcmp ( imIn -> mode , mode ) ) { return ImagingCopy2 ( imOut , imIn ) ; } } if ( strcmp ( imIn -> mode , \"P\" ) == 0 || strcmp ( imIn -> mode , \"PA\" ) == 0 ) { return frompalette ( imOut , imIn , mode ) ; } if ( strcmp ( mode , \"P\" ) == 0 || strcmp ( mode , \"PA\" ) == 0 ) { return topalette ( imOut , imIn , mode , palette , dither ) ; } if ( dither && strcmp ( mode , \"1\" ) == 0 ) { return tobilevel ( imOut , imIn , dither ) ; } convert = NULL ; for ( y = 0 ; converters [ y ] . from ; y ++ ) { if ( ! strcmp ( imIn -> mode , converters [ y ] . from ) && ! strcmp ( mode , converters [ y ] . to ) ) { convert = converters [ y ] . convert ; break ; } } if ( ! convert ) { # ifdef notdef return ( Imaging ) ImagingError_ValueError ( \"conversion<S2SV_blank>not<S2SV_blank>supported\" ) ; # else static char buf [ 100 ] ; <S2SV_StartBug> sprintf ( buf , \"conversion<S2SV_blank>from<S2SV_blank>%.10s<S2SV_blank>to<S2SV_blank>%.10s<S2SV_blank>not<S2SV_blank>supported\" , imIn -> mode , mode ) ; <S2SV_EndBug> return ( Imaging ) ImagingError_ValueError ( buf ) ; # endif } imOut = ImagingNew2Dirty ( mode , imOut , imIn ) ; if ( ! imOut ) { return NULL ; } ImagingSectionEnter ( & cookie ) ; for ( y = 0 ; y < imIn -> ysize ; y ++ ) { ( * convert ) ( ( UINT8 * ) imOut -> image [ y ] , ( UINT8 * ) imIn -> image [ y ] , imIn -> xsize ) ; } ImagingSectionLeave ( & cookie ) ; return imOut ; }", "target": "<S2SV_ModStart> 100 ] ; snprintf ( buf , 100 <S2SV_ModEnd> , \"conversion<S2SV_blank>from<S2SV_blank>%.10s<S2SV_blank>to<S2SV_blank>%.10s<S2SV_blank>not<S2SV_blank>supported\" ,"}
{"source": "CWE-369 MagickExport void ScaleResampleFilter ( ResampleFilter * resample_filter , const double dux , const double duy , const double dvx , const double dvy ) { double A , B , C , F ; assert ( resample_filter != ( ResampleFilter * ) NULL ) ; assert ( resample_filter -> signature == MagickCoreSignature ) ; resample_filter -> limit_reached = MagickFalse ; if ( resample_filter -> filter == PointFilter ) return ; # if DEBUG_ELLIPSE ( void ) FormatLocaleFile ( stderr , \"#<S2SV_blank>-----\\\\n\" ) ; ( void ) FormatLocaleFile ( stderr , \"dux=%lf;<S2SV_blank>dvx=%lf;<S2SV_blank><S2SV_blank><S2SV_blank>duy=%lf;<S2SV_blank>dvy=%lf;\\\\n\" , dux , dvx , duy , dvy ) ; # endif # if EWA # if EWA_CLAMP { double major_mag , minor_mag , major_x , major_y , minor_x , minor_y ; ClampUpAxes ( dux , dvx , duy , dvy , & major_mag , & minor_mag , & major_x , & major_y , & minor_x , & minor_y ) ; major_x *= major_mag ; major_y *= major_mag ; minor_x *= minor_mag ; minor_y *= minor_mag ; # if DEBUG_ELLIPSE ( void ) FormatLocaleFile ( stderr , \"major_x=%lf;<S2SV_blank>major_y=%lf;<S2SV_blank><S2SV_blank>minor_x=%lf;<S2SV_blank>minor_y=%lf;\\\\n\" , major_x , major_y , minor_x , minor_y ) ; # endif A = major_y * major_y + minor_y * minor_y ; B = - 2.0 * ( major_x * major_y + minor_x * minor_y ) ; C = major_x * major_x + minor_x * minor_x ; F = major_mag * minor_mag ; F *= F ; } # else A = dvx * dvx + dvy * dvy ; B = - 2.0 * ( dux * dvx + duy * dvy ) ; C = dux * dux + duy * duy ; F = dux * dvy - duy * dvx ; F *= F ; # endif # else A = dvx * dvx + dvy * dvy + 1 ; B = - 2.0 * ( dux * dvx + duy * dvy ) ; C = dux * dux + duy * duy + 1 ; F = A * C - B * B / 4 ; # endif # if DEBUG_ELLIPSE ( void ) FormatLocaleFile ( stderr , \"A=%lf;<S2SV_blank>B=%lf;<S2SV_blank>C=%lf;<S2SV_blank>F=%lf\\\\n\" , A , B , C , F ) ; { double alpha , beta , gamma , Major , Minor ; double Eccentricity , Ellipse_Area , Ellipse_Angle ; alpha = A + C ; beta = A - C ; gamma = sqrt ( beta * beta + B * B ) ; if ( alpha - gamma <= MagickEpsilon ) Major = MagickMaximumValue ; else Major = sqrt ( 2 * F / ( alpha - gamma ) ) ; Minor = sqrt ( 2 * F / ( alpha + gamma ) ) ; ( void ) FormatLocaleFile ( stderr , \"#<S2SV_blank>Major=%lf;<S2SV_blank>Minor=%lf\\\\n\" , Major , Minor ) ; Eccentricity = Major / Minor ; Ellipse_Area = MagickPI * Major * Minor ; Ellipse_Angle = atan2 ( B , A - C ) ; ( void ) FormatLocaleFile ( stderr , \"#<S2SV_blank>Angle=%lf<S2SV_blank><S2SV_blank><S2SV_blank>Area=%lf\\\\n\" , ( double ) RadiansToDegrees ( Ellipse_Angle ) , Ellipse_Area ) ; } # endif if ( ( 4 * A * C - B * B ) > MagickMaximumValue ) { resample_filter -> limit_reached = MagickTrue ; return ; } F *= resample_filter -> support ; F *= resample_filter -> support ; resample_filter -> Ulimit = sqrt ( C * F / ( A * C - 0.25 * B * B ) ) ; resample_filter -> Vlimit = sqrt ( A * F / ( A * C - 0.25 * B * B ) ) ; resample_filter -> Uwidth = sqrt ( F / A ) ; resample_filter -> slope = - B / ( 2.0 * A ) ; # if DEBUG_ELLIPSE ( void ) FormatLocaleFile ( stderr , \"Ulimit=%lf;<S2SV_blank>Vlimit=%lf;<S2SV_blank>UWidth=%lf;<S2SV_blank>Slope=%lf;\\\\n\" , resample_filter -> Ulimit , resample_filter -> Vlimit , resample_filter -> Uwidth , resample_filter -> slope ) ; # endif if ( ( resample_filter -> Uwidth * resample_filter -> Vlimit ) > ( 4.0 * resample_filter -> image_area ) ) { resample_filter -> limit_reached = MagickTrue ; return ; } { double scale ; # if FILTER_LUT <S2SV_StartBug> scale = ( double ) WLUT_WIDTH / F ; <S2SV_EndBug> # else <S2SV_StartBug> scale = resample_filter -> F / F ; <S2SV_EndBug> # endif resample_filter -> A = A * scale ; resample_filter -> B = B * scale ; resample_filter -> C = C * scale ; } }", "target": "<S2SV_ModStart> double ) WLUT_WIDTH * PerceptibleReciprocal ( F ) <S2SV_ModEnd> ; # else <S2SV_ModStart> resample_filter -> F * PerceptibleReciprocal ( F ) <S2SV_ModEnd> ; # endif"}
{"source": "CWE-74 handle_spawn ( PortalFlatpak * object , GDBusMethodInvocation * invocation , GUnixFDList * fd_list , const gchar * arg_cwd_path , const gchar * const * arg_argv , GVariant * arg_fds , GVariant * arg_envs , guint arg_flags , GVariant * arg_options ) { g_autoptr ( GError ) error = NULL ; ChildSetupData child_setup_data = { NULL } ; GPid pid ; PidData * pid_data ; InstanceIdReadData * instance_id_read_data = NULL ; gsize i , j , n_fds , n_envs ; const gint * fds = NULL ; gint fds_len = 0 ; g_autofree FdMapEntry * fd_map = NULL ; gchar * * env ; gint32 max_fd ; GKeyFile * app_info ; g_autoptr ( GPtrArray ) flatpak_argv = g_ptr_array_new_with_free_func ( g_free ) ; g_autofree char * app_id = NULL ; g_autofree char * branch = NULL ; g_autofree char * arch = NULL ; g_autofree char * app_commit = NULL ; g_autofree char * runtime_ref = NULL ; g_auto ( GStrv ) runtime_parts = NULL ; g_autofree char * runtime_commit = NULL ; g_autofree char * instance_path = NULL ; g_auto ( GStrv ) extra_args = NULL ; g_auto ( GStrv ) shares = NULL ; g_auto ( GStrv ) sockets = NULL ; g_auto ( GStrv ) devices = NULL ; g_auto ( GStrv ) sandbox_expose = NULL ; g_auto ( GStrv ) sandbox_expose_ro = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd_ro = NULL ; g_autoptr ( GOutputStream ) instance_id_out_stream = NULL ; guint sandbox_flags = 0 ; gboolean sandboxed ; gboolean expose_pids ; gboolean share_pids ; gboolean notify_start ; gboolean devel ; g_autoptr ( GString ) env_string = g_string_new ( \"\" ) ; child_setup_data . instance_id_fd = - 1 ; child_setup_data . env_fd = - 1 ; if ( fd_list != NULL ) fds = g_unix_fd_list_peek_fds ( fd_list , & fds_len ) ; app_info = g_object_get_data ( G_OBJECT ( invocation ) , \"app-info\" ) ; g_assert ( app_info != NULL ) ; app_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_NAME , NULL ) ; g_assert ( app_id != NULL ) ; g_debug ( \"spawn()<S2SV_blank>called<S2SV_blank>from<S2SV_blank>app:<S2SV_blank>\\'%s\\'\" , app_id ) ; if ( * app_id == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"org.freedesktop.portal.Flatpak.Spawn<S2SV_blank>only<S2SV_blank>works<S2SV_blank>in<S2SV_blank>a<S2SV_blank>flatpak\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( * arg_cwd_path == 0 ) arg_cwd_path = NULL ; if ( arg_argv == NULL || * arg_argv == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"No<S2SV_blank>command<S2SV_blank>given\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( ( arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"Unsupported<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x\" , arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_ref = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_RUNTIME , NULL ) ; if ( runtime_ref == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"No<S2SV_blank>runtime<S2SV_blank>found\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_parts = g_strsplit ( runtime_ref , \"/\" , - 1 ) ; branch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_BRANCH , NULL ) ; instance_path = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_PATH , NULL ) ; arch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_ARCH , NULL ) ; extra_args = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_EXTRA_ARGS , NULL , NULL ) ; app_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_APP_COMMIT , NULL ) ; runtime_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_RUNTIME_COMMIT , NULL ) ; shares = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SHARED , NULL , NULL ) ; sockets = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SOCKETS , NULL , NULL ) ; devices = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_DEVICES , NULL , NULL ) ; devel = g_key_file_get_boolean ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_DEVEL , NULL ) ; g_variant_lookup ( arg_options , \"sandbox-expose\" , \"^as\" , & sandbox_expose ) ; g_variant_lookup ( arg_options , \"sandbox-expose-ro\" , \"^as\" , & sandbox_expose_ro ) ; g_variant_lookup ( arg_options , \"sandbox-flags\" , \"u\" , & sandbox_flags ) ; sandbox_expose_fd = g_variant_lookup_value ( arg_options , \"sandbox-expose-fd\" , G_VARIANT_TYPE ( \"ah\" ) ) ; sandbox_expose_fd_ro = g_variant_lookup_value ( arg_options , \"sandbox-expose-fd-ro\" , G_VARIANT_TYPE ( \"ah\" ) ) ; if ( ( sandbox_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"Unsupported<S2SV_blank>sandbox<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x\" , arg_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_path == NULL && ( ( sandbox_expose != NULL && sandbox_expose [ 0 ] != NULL ) || ( sandbox_expose_ro != NULL && sandbox_expose_ro [ 0 ] != NULL ) ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"Invalid<S2SV_blank>sandbox<S2SV_blank>expose,<S2SV_blank>caller<S2SV_blank>has<S2SV_blank>no<S2SV_blank>instance<S2SV_blank>path\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose [ i ] ; g_debug ( \"exposing<S2SV_blank>%s\" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( \"exposing<S2SV_blank>%s\" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } g_debug ( \"Running<S2SV_blank>spawn<S2SV_blank>command<S2SV_blank>%s\" , arg_argv [ 0 ] ) ; n_fds = 0 ; if ( fds != NULL ) n_fds = g_variant_n_children ( arg_fds ) ; fd_map = g_new0 ( FdMapEntry , n_fds ) ; child_setup_data . fd_map = fd_map ; child_setup_data . fd_map_len = n_fds ; max_fd = - 1 ; for ( i = 0 ; i < n_fds ; i ++ ) { gint32 handle , dest_fd ; int handle_fd ; g_variant_get_child ( arg_fds , i , \"{uh}\" , & dest_fd , & handle ) ; if ( handle >= fds_len || handle < 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d\" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } handle_fd = fds [ handle ] ; fd_map [ i ] . to = dest_fd ; fd_map [ i ] . from = handle_fd ; fd_map [ i ] . final = fd_map [ i ] . to ; if ( ( dest_fd == 0 || dest_fd == 1 || dest_fd == 2 ) && ! child_setup_data . set_tty && isatty ( handle_fd ) ) { child_setup_data . set_tty = TRUE ; child_setup_data . tty = handle_fd ; } max_fd = MAX ( max_fd , fd_map [ i ] . to ) ; max_fd = MAX ( max_fd , fd_map [ i ] . from ) ; } for ( i = 0 ; i < n_fds ; i ++ ) { int to_fd = fd_map [ i ] . to ; gboolean conflict = FALSE ; for ( j = i + 1 ; j < n_fds ; j ++ ) { int from_fd = fd_map [ j ] . from ; if ( from_fd == to_fd ) { conflict = TRUE ; break ; } } if ( conflict ) fd_map [ i ] . to = ++ max_fd ; } if ( arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV ) { char * empty [ ] = { NULL } ; env = g_strdupv ( empty ) ; } else env = g_get_environ ( ) ; n_envs = g_variant_n_children ( arg_envs ) ; for ( i = 0 ; i < n_envs ; i ++ ) { const char * var = NULL ; const char * val = NULL ; g_variant_get_child ( arg_envs , i , \"{&s&s}\" , & var , & val ) ; <S2SV_StartBug> env = g_environ_setenv ( env , var , val , TRUE ) ; <S2SV_EndBug> } g_ptr_array_add ( flatpak_argv , g_strdup ( \"flatpak\" ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup ( \"run\" ) ) ; sandboxed = ( arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX ) != 0 ; if ( sandboxed ) { g_ptr_array_add ( flatpak_argv , g_strdup ( \"--sandbox\" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , \"wayland\" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--socket=wayland\" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , \"fallback-x11\" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--socket=fallback-x11\" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , \"x11\" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--socket=x11\" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , \"ipc\" ) && sockets != NULL && ( g_strv_contains ( ( const char * const * ) sockets , \"fallback-x11\" ) || g_strv_contains ( ( const char * const * ) sockets , \"x11\" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--share=ipc\" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , \"pulseaudio\" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--socket=pulseaudio\" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU ) { if ( devices != NULL && ( g_strv_contains ( ( const char * const * ) devices , \"dri\" ) || g_strv_contains ( ( const char * const * ) devices , \"all\" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--device=dri\" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--session-bus\" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--a11y-bus\" ) ) ; } else { for ( i = 0 ; extra_args != NULL && extra_args [ i ] != NULL ; i ++ ) { if ( g_str_has_prefix ( extra_args [ i ] , \"--env=\" ) ) { const char * var_val = extra_args [ i ] + strlen ( \"--env=\" ) ; if ( var_val [ 0 ] == '\\\\0' || var_val [ 0 ] == '=' ) { g_warning ( \"Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>empty<S2SV_blank>name\" ) ; continue ; } if ( strchr ( var_val , '=' ) == NULL ) { g_warning ( \"Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value\" ) ; continue ; } g_string_append ( env_string , var_val ) ; g_string_append_c ( env_string , '\\\\0' ) ; } else { g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ; } } } if ( env_string -> len > 0 ) { g_auto ( GLnxTmpfile ) env_tmpf = { 0 , } ; if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , \"environ\" , env_string -> str , env_string -> len , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--env-fd=%d\" , child_setup_data . env_fd ) ) ; } expose_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS ) != 0 ; share_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS ) != 0 ; if ( expose_pids || share_pids ) { g_autofree char * instance_id = NULL ; int sender_pid1 = 0 ; if ( ! ( supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_NOT_SUPPORTED , \"Expose<S2SV_blank>pids<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>setuid<S2SV_blank>bwrap\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } instance_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_ID , NULL ) ; if ( instance_id ) { g_autoptr ( FlatpakInstance ) instance = flatpak_instance_new_for_id ( instance_id ) ; sender_pid1 = flatpak_instance_get_child_pid ( instance ) ; } if ( sender_pid1 == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>requesting<S2SV_blank>pid\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--parent-pid=%d\" , sender_pid1 ) ) ; if ( share_pids ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--parent-share-pids\" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( \"--parent-expose-pids\" ) ) ; } notify_start = ( arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START ) != 0 ; if ( notify_start ) { int pipe_fds [ 2 ] ; if ( pipe ( pipe_fds ) == - 1 ) { int errsv = errno ; g_dbus_method_invocation_return_error ( invocation , G_IO_ERROR , g_io_error_from_errno ( errsv ) , \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>instance<S2SV_blank>ID<S2SV_blank>pipe:<S2SV_blank>%s\" , g_strerror ( errsv ) ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } GInputStream * in_stream = G_INPUT_STREAM ( g_unix_input_stream_new ( pipe_fds [ 0 ] , TRUE ) ) ; instance_id_out_stream = G_OUTPUT_STREAM ( g_unix_output_stream_new ( pipe_fds [ 1 ] , TRUE ) ) ; instance_id_read_data = g_new0 ( InstanceIdReadData , 1 ) ; g_input_stream_read_async ( in_stream , instance_id_read_data -> buffer , INSTANCE_ID_BUFFER_SIZE - 1 , G_PRIORITY_DEFAULT , NULL , instance_id_read_finish , instance_id_read_data ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--instance-id-fd=%d\" , pipe_fds [ 1 ] ) ) ; child_setup_data . instance_id_fd = pipe_fds [ 1 ] ; } if ( devel ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--devel\" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , \"network\" ) && ! ( arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( \"--share=network\" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( \"--unshare=network\" ) ) ; if ( instance_path ) { for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose [ i ] , FALSE ) ) ; for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose_ro [ i ] , TRUE ) ) ; } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( \"exposing<S2SV_blank>%s\" , expose ) ; } if ( sandbox_expose_fd != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd , i , \"h\" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , ! writable ) ) ; } else { g_debug ( \"unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s\" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d\" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } if ( sandbox_expose_fd_ro != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd_ro ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd_ro , i , \"h\" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , TRUE ) ) ; } else { g_debug ( \"unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s\" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d\" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--runtime=%s\" , runtime_parts [ 1 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--runtime-version=%s\" , runtime_parts [ 3 ] ) ) ; if ( ( arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION ) == 0 ) { if ( app_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--commit=%s\" , app_commit ) ) ; if ( runtime_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--runtime-commit=%s\" , runtime_commit ) ) ; } if ( arg_cwd_path != NULL ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--cwd=%s\" , arg_cwd_path ) ) ; if ( arg_argv [ 0 ] [ 0 ] != 0 ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"--command=%s\" , arg_argv [ 0 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( \"%s/%s/%s\" , app_id , arch ? arch : \"\" , branch ? branch : \"\" ) ) ; for ( i = 1 ; arg_argv [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , g_strdup ( arg_argv [ i ] ) ) ; g_ptr_array_add ( flatpak_argv , NULL ) ; if ( opt_verbose ) { g_autoptr ( GString ) cmd = g_string_new ( \"\" ) ; for ( i = 0 ; flatpak_argv -> pdata [ i ] != NULL ; i ++ ) { if ( i > 0 ) g_string_append ( cmd , \"<S2SV_blank>\" ) ; g_string_append ( cmd , flatpak_argv -> pdata [ i ] ) ; } g_debug ( \"Starting:<S2SV_blank>%s\\\\n\" , cmd -> str ) ; } if ( ! g_spawn_async_with_pipes ( NULL , ( char * * ) flatpak_argv -> pdata , env , G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN , child_setup_func , & child_setup_data , & pid , NULL , NULL , NULL , & error ) ) { gint code = G_DBUS_ERROR_FAILED ; if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_ACCES ) ) code = G_DBUS_ERROR_ACCESS_DENIED ; else if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_NOENT ) ) code = G_DBUS_ERROR_FILE_NOT_FOUND ; g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , code , \"Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>command:<S2SV_blank>%s\" , error -> message ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_id_read_data ) instance_id_read_data -> pid = pid ; pid_data = g_new0 ( PidData , 1 ) ; pid_data -> pid = pid ; pid_data -> client = g_strdup ( g_dbus_method_invocation_get_sender ( invocation ) ) ; pid_data -> watch_bus = ( arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS ) != 0 ; pid_data -> expose_or_share_pids = ( expose_pids || share_pids ) ; pid_data -> child_watch = g_child_watch_add_full ( G_PRIORITY_DEFAULT , pid , child_watch_died , pid_data , NULL ) ; g_debug ( \"Client<S2SV_blank>Pid<S2SV_blank>is<S2SV_blank>%d\" , pid_data -> pid ) ; g_hash_table_replace ( client_pid_data_hash , GUINT_TO_POINTER ( pid_data -> pid ) , pid_data ) ; portal_flatpak_complete_spawn ( object , invocation , NULL , pid ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; }", "target": "<S2SV_ModStart> val ) ; if ( var [ 0 ] == '\\\\0' ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( strchr ( var , '=' ) != NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , \"Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\'=\\'\" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_string_append ( env_string , var ) ; g_string_append_c ( env_string , '=' ) ; g_string_append ( env_string , val ) ; g_string_append_c ( env_string , '\\\\0' <S2SV_ModEnd> ) ; }"}
{"source": "CWE-835 static void msf2_dma_tx ( MSF2EmacState * s ) { NetClientState * nc = qemu_get_queue ( s -> nic ) ; hwaddr desc = s -> regs [ R_DMA_TX_DESC ] ; uint8_t buf [ MAX_PKT_SIZE ] ; EmacDesc d ; int size ; uint8_t pktcnt ; uint32_t status ; if ( ! ( s -> regs [ R_CFG1 ] & R_CFG1_TX_EN_MASK ) ) { return ; } while ( 1 ) { emac_load_desc ( s , & d , desc ) ; if ( d . pktsize & EMPTY_MASK ) { break ; } size = d . pktsize & PKT_SIZE ; address_space_read ( & s -> dma_as , d . pktaddr , MEMTXATTRS_UNSPECIFIED , buf , size ) ; if ( s -> regs [ R_CFG1 ] & R_CFG1_LB_EN_MASK ) { <S2SV_StartBug> nc -> info -> receive ( nc , buf , size ) ; <S2SV_EndBug> } else { qemu_send_packet ( nc , buf , size ) ; } d . pktsize |= EMPTY_MASK ; emac_store_desc ( s , & d , desc ) ; status = s -> regs [ R_DMA_TX_STATUS ] ; pktcnt = FIELD_EX32 ( status , DMA_TX_STATUS , PKTCNT ) ; pktcnt ++ ; s -> regs [ R_DMA_TX_STATUS ] = FIELD_DP32 ( status , DMA_TX_STATUS , PKTCNT , pktcnt ) ; s -> regs [ R_DMA_TX_STATUS ] |= R_DMA_TX_STATUS_PKT_SENT_MASK ; desc = d . next ; } s -> regs [ R_DMA_TX_STATUS ] |= R_DMA_TX_STATUS_UNDERRUN_MASK ; s -> regs [ R_DMA_TX_CTL ] &= ~ R_DMA_TX_CTL_EN_MASK ; }", "target": "<S2SV_ModStart> R_CFG1_LB_EN_MASK ) { qemu_receive_packet <S2SV_ModEnd> ( nc ,"}
{"source": "CWE-401 static int ca8210_probe ( struct spi_device * spi_device ) { struct ca8210_priv * priv ; struct ieee802154_hw * hw ; struct ca8210_platform_data * pdata ; int ret ; dev_info ( & spi_device -> dev , \"Inserting<S2SV_blank>ca8210\\\\n\" ) ; hw = ieee802154_alloc_hw ( sizeof ( struct ca8210_priv ) , & ca8210_phy_ops ) ; if ( ! hw ) { dev_crit ( & spi_device -> dev , \"ieee802154_alloc_hw<S2SV_blank>failed\\\\n\" ) ; ret = - ENOMEM ; goto error ; } priv = hw -> priv ; priv -> hw = hw ; priv -> spi = spi_device ; hw -> parent = & spi_device -> dev ; spin_lock_init ( & priv -> lock ) ; priv -> async_tx_pending = false ; priv -> hw_registered = false ; priv -> sync_up = 0 ; priv -> sync_down = 0 ; priv -> promiscuous = false ; priv -> retries = 0 ; init_completion ( & priv -> ca8210_is_awake ) ; init_completion ( & priv -> spi_transfer_complete ) ; init_completion ( & priv -> sync_exchange_complete ) ; spi_set_drvdata ( priv -> spi , priv ) ; if ( IS_ENABLED ( CONFIG_IEEE802154_CA8210_DEBUGFS ) ) { cascoda_api_upstream = ca8210_test_int_driver_write ; ca8210_test_interface_init ( priv ) ; } else { cascoda_api_upstream = NULL ; } ca8210_hw_setup ( hw ) ; ieee802154_random_extended_addr ( & hw -> phy -> perm_extended_addr ) ; pdata = kmalloc ( sizeof ( * pdata ) , GFP_KERNEL ) ; if ( ! pdata ) { ret = - ENOMEM ; goto error ; } <S2SV_StartBug> ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; <S2SV_EndBug> if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_get_platform_data<S2SV_blank>failed\\\\n\" ) ; goto error ; } priv -> spi -> dev . platform_data = pdata ; <S2SV_StartBug> <S2SV_EndBug> ret = ca8210_dev_com_init ( priv ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_dev_com_init<S2SV_blank>failed\\\\n\" ) ; goto error ; } ret = ca8210_reset_init ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_reset_init<S2SV_blank>failed\\\\n\" ) ; goto error ; } ret = ca8210_interrupt_init ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_interrupt_init<S2SV_blank>failed\\\\n\" ) ; goto error ; } msleep ( 100 ) ; ca8210_reset_send ( priv -> spi , 1 ) ; ret = tdme_chipinit ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"tdme_chipinit<S2SV_blank>failed\\\\n\" ) ; goto error ; } if ( pdata -> extclockenable ) { ret = ca8210_config_extern_clk ( pdata , priv -> spi , 1 ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_config_extern_clk<S2SV_blank>failed\\\\n\" ) ; goto error ; } ret = ca8210_register_ext_clock ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_register_ext_clock<S2SV_blank>failed\\\\n\" ) ; goto error ; } } ret = ieee802154_register_hw ( hw ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ieee802154_register_hw<S2SV_blank>failed\\\\n\" ) ; goto error ; } priv -> hw_registered = true ; return 0 ; error : msleep ( 100 ) ; ca8210_remove ( spi_device ) ; return link_to_linux_err ( ret ) ; }", "target": "<S2SV_ModStart> error ; } <S2SV_ModEnd> priv -> spi <S2SV_ModStart> = pdata ; ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_get_platform_data<S2SV_blank>failed\\\\n\" ) ; goto error ; }"}
{"source": "CWE-703 void Jp2Image : : encodeJp2Header ( const DataBuf & boxBuf , DataBuf & outBuf ) { DataBuf output ( boxBuf . size_ + iccProfile_ . size_ + 100 ) ; <S2SV_StartBug> int outlen = sizeof ( Jp2BoxHeader ) ; <S2SV_EndBug> int inlen = sizeof ( Jp2BoxHeader ) ; Jp2BoxHeader * pBox = ( Jp2BoxHeader * ) boxBuf . pData_ ; <S2SV_StartBug> int32_t length = getLong ( ( byte * ) & pBox -> length , bigEndian ) ; <S2SV_EndBug> <S2SV_StartBug> int32_t count = sizeof ( Jp2BoxHeader ) ; <S2SV_EndBug> char * p = ( char * ) boxBuf . pData_ ; bool bWroteColor = false ; while ( count < length || ! bWroteColor ) { Jp2BoxHeader * pSubBox = ( Jp2BoxHeader * ) ( p + count ) ; Jp2BoxHeader subBox ; memcpy ( & subBox , pSubBox , sizeof ( subBox ) ) ; Jp2BoxHeader newBox = subBox ; if ( count < length ) { subBox . length = getLong ( ( byte * ) & subBox . length , bigEndian ) ; subBox . type = getLong ( ( byte * ) & subBox . type , bigEndian ) ; # ifdef EXIV2_DEBUG_MESSAGES std : : cout << \"Jp2Image::encodeJp2Header<S2SV_blank>subbox:<S2SV_blank>\" << toAscii ( subBox . type ) << \"<S2SV_blank>length<S2SV_blank>=<S2SV_blank>\" << subBox . length << std : : endl ; # endif <S2SV_StartBug> count += subBox . length ; <S2SV_EndBug> newBox . type = subBox . type ; } else { subBox . length = 0 ; newBox . type = kJp2BoxTypeColorHeader ; count = length ; } <S2SV_StartBug> int32_t newlen = subBox . length ; <S2SV_EndBug> if ( newBox . type == kJp2BoxTypeColorHeader ) { bWroteColor = true ; if ( ! iccProfileDefined ( ) ) { const char * pad = \"\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10\\\\x00\\\\x00\\\\x05\\\\x1cuuid\" ; uint32_t psize = 15 ; <S2SV_StartBug> newlen = sizeof ( newBox ) + psize ; <S2SV_EndBug> ul2Data ( ( byte * ) & newBox . length , psize , bigEndian ) ; ul2Data ( ( byte * ) & newBox . type , newBox . type , bigEndian ) ; : : memcpy ( output . pData_ + outlen , & newBox , sizeof ( newBox ) ) ; : : memcpy ( output . pData_ + outlen + sizeof ( newBox ) , pad , psize ) ; } else { const char * pad = \"\\\\x02\\\\x00\\\\x00\" ; uint32_t psize = 3 ; newlen = sizeof ( newBox ) + psize + iccProfile_ . size_ ; <S2SV_StartBug> ul2Data ( ( byte * ) & newBox . length , newlen , bigEndian ) ; <S2SV_EndBug> ul2Data ( ( byte * ) & newBox . type , newBox . type , bigEndian ) ; : : memcpy ( output . pData_ + outlen , & newBox , sizeof ( newBox ) ) ; : : memcpy ( output . pData_ + outlen + sizeof ( newBox ) , pad , psize ) ; : : memcpy ( output . pData_ + outlen + sizeof ( newBox ) + psize , iccProfile_ . pData_ , iccProfile_ . size_ ) ; } } else { <S2SV_StartBug> : : memcpy ( output . pData_ + outlen , boxBuf . pData_ + inlen , subBox . length ) ; <S2SV_EndBug> } outlen += newlen ; inlen += subBox . length ; } outBuf . alloc ( outlen ) ; : : memcpy ( outBuf . pData_ , output . pData_ , outlen ) ; pBox = ( Jp2BoxHeader * ) outBuf . pData_ ; ul2Data ( ( byte * ) & pBox -> type , kJp2BoxTypeJp2Header , bigEndian ) ; ul2Data ( ( byte * ) & pBox -> length , outlen , bigEndian ) ; }", "target": "<S2SV_ModStart> 100 ) ; long outlen = sizeof ( Jp2BoxHeader ) ; long <S2SV_ModEnd> inlen = sizeof <S2SV_ModStart> . pData_ ; uint32_t <S2SV_ModEnd> length = getLong <S2SV_ModStart> bigEndian ) ; uint32_t <S2SV_ModEnd> count = sizeof <S2SV_ModStart> ; # endif enforce ( subBox . length <= length - count , Exiv2 : : kerCorruptedMetadata ) ; <S2SV_ModStart> length ; } uint32_t <S2SV_ModEnd> newlen = subBox <S2SV_ModStart> ) + psize ; enforce ( newlen <= output . size_ - outlen , Exiv2 : : kerCorruptedMetadata ) <S2SV_ModStart> . size_ ; enforce ( newlen <= output . size_ - outlen , Exiv2 : : kerCorruptedMetadata ) ; <S2SV_ModStart> } else { enforce ( newlen <= output . size_ - outlen , Exiv2 : : kerCorruptedMetadata ) ;"}
{"source": "CWE-703 exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; <S2SV_StartBug> size_t i , tcount , o , datao ; <S2SV_EndBug> if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Short<S2SV_blank>MakerNote\" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\'%s\\')...\" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)\" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Invalid<S2SV_blank>zero-length<S2SV_blank>tag<S2SV_blank>size\" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteCanon\" , \"Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)\" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , \"ExifMnoteCanon\" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } <S2SV_StartBug> ++ tcount ; <S2SV_EndBug> } n -> count = tcount ; }", "target": "<S2SV_ModStart> o , datao ; long failsafe_size = 0 <S2SV_ModStart> ) ; } failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ; if ( failsafe_size > FAILSAFE_SIZE_MAX ) { exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ; exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteCanon\" , \"Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)\" , failsafe_size , FAILSAFE_SIZE_MAX ) ; break ; }"}
{"source": "CWE-787 Int32 BZ2_decompress ( DState * s ) { UChar uc ; Int32 retVal ; Int32 minLen , maxLen ; bz_stream * strm = s -> strm ; Int32 i ; Int32 j ; Int32 t ; Int32 alphaSize ; Int32 nGroups ; Int32 nSelectors ; Int32 EOB ; Int32 groupNo ; Int32 groupPos ; Int32 nextSym ; Int32 nblockMAX ; Int32 nblock ; Int32 es ; Int32 N ; Int32 curr ; Int32 zt ; Int32 zn ; Int32 zvec ; Int32 zj ; Int32 gSel ; Int32 gMinlen ; Int32 * gLimit ; Int32 * gBase ; Int32 * gPerm ; if ( s -> state == BZ_X_MAGIC_1 ) { s -> save_i = 0 ; s -> save_j = 0 ; s -> save_t = 0 ; s -> save_alphaSize = 0 ; s -> save_nGroups = 0 ; s -> save_nSelectors = 0 ; s -> save_EOB = 0 ; s -> save_groupNo = 0 ; s -> save_groupPos = 0 ; s -> save_nextSym = 0 ; s -> save_nblockMAX = 0 ; s -> save_nblock = 0 ; s -> save_es = 0 ; s -> save_N = 0 ; s -> save_curr = 0 ; s -> save_zt = 0 ; s -> save_zn = 0 ; s -> save_zvec = 0 ; s -> save_zj = 0 ; s -> save_gSel = 0 ; s -> save_gMinlen = 0 ; s -> save_gLimit = NULL ; s -> save_gBase = NULL ; s -> save_gPerm = NULL ; } i = s -> save_i ; j = s -> save_j ; t = s -> save_t ; alphaSize = s -> save_alphaSize ; nGroups = s -> save_nGroups ; nSelectors = s -> save_nSelectors ; EOB = s -> save_EOB ; groupNo = s -> save_groupNo ; groupPos = s -> save_groupPos ; nextSym = s -> save_nextSym ; nblockMAX = s -> save_nblockMAX ; nblock = s -> save_nblock ; es = s -> save_es ; N = s -> save_N ; curr = s -> save_curr ; zt = s -> save_zt ; zn = s -> save_zn ; zvec = s -> save_zvec ; zj = s -> save_zj ; gSel = s -> save_gSel ; gMinlen = s -> save_gMinlen ; gLimit = s -> save_gLimit ; gBase = s -> save_gBase ; gPerm = s -> save_gPerm ; retVal = BZ_OK ; switch ( s -> state ) { GET_UCHAR ( BZ_X_MAGIC_1 , uc ) ; if ( uc != BZ_HDR_B ) RETURN ( BZ_DATA_ERROR_MAGIC ) ; GET_UCHAR ( BZ_X_MAGIC_2 , uc ) ; if ( uc != BZ_HDR_Z ) RETURN ( BZ_DATA_ERROR_MAGIC ) ; GET_UCHAR ( BZ_X_MAGIC_3 , uc ) if ( uc != BZ_HDR_h ) RETURN ( BZ_DATA_ERROR_MAGIC ) ; GET_BITS ( BZ_X_MAGIC_4 , s -> blockSize100k , 8 ) if ( s -> blockSize100k < ( BZ_HDR_0 + 1 ) || s -> blockSize100k > ( BZ_HDR_0 + 9 ) ) RETURN ( BZ_DATA_ERROR_MAGIC ) ; s -> blockSize100k -= BZ_HDR_0 ; if ( s -> smallDecompress ) { s -> ll16 = BZALLOC ( s -> blockSize100k * 100000 * sizeof ( UInt16 ) ) ; s -> ll4 = BZALLOC ( ( ( 1 + s -> blockSize100k * 100000 ) >> 1 ) * sizeof ( UChar ) ) ; if ( s -> ll16 == NULL || s -> ll4 == NULL ) RETURN ( BZ_MEM_ERROR ) ; } else { s -> tt = BZALLOC ( s -> blockSize100k * 100000 * sizeof ( Int32 ) ) ; if ( s -> tt == NULL ) RETURN ( BZ_MEM_ERROR ) ; } GET_UCHAR ( BZ_X_BLKHDR_1 , uc ) ; if ( uc == 0x17 ) goto endhdr_2 ; if ( uc != 0x31 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_BLKHDR_2 , uc ) ; if ( uc != 0x41 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_BLKHDR_3 , uc ) ; if ( uc != 0x59 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_BLKHDR_4 , uc ) ; if ( uc != 0x26 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_BLKHDR_5 , uc ) ; if ( uc != 0x53 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_BLKHDR_6 , uc ) ; if ( uc != 0x59 ) RETURN ( BZ_DATA_ERROR ) ; s -> currBlockNo ++ ; if ( s -> verbosity >= 2 ) VPrintf1 ( \"\\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[%d:<S2SV_blank>huff+mtf<S2SV_blank>\" , s -> currBlockNo ) ; s -> storedBlockCRC = 0 ; GET_UCHAR ( BZ_X_BCRC_1 , uc ) ; s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc ) ; GET_UCHAR ( BZ_X_BCRC_2 , uc ) ; s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc ) ; GET_UCHAR ( BZ_X_BCRC_3 , uc ) ; s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc ) ; GET_UCHAR ( BZ_X_BCRC_4 , uc ) ; s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc ) ; GET_BITS ( BZ_X_RANDBIT , s -> blockRandomised , 1 ) ; s -> origPtr = 0 ; GET_UCHAR ( BZ_X_ORIGPTR_1 , uc ) ; s -> origPtr = ( s -> origPtr << 8 ) | ( ( Int32 ) uc ) ; GET_UCHAR ( BZ_X_ORIGPTR_2 , uc ) ; s -> origPtr = ( s -> origPtr << 8 ) | ( ( Int32 ) uc ) ; GET_UCHAR ( BZ_X_ORIGPTR_3 , uc ) ; s -> origPtr = ( s -> origPtr << 8 ) | ( ( Int32 ) uc ) ; if ( s -> origPtr < 0 ) RETURN ( BZ_DATA_ERROR ) ; if ( s -> origPtr > 10 + 100000 * s -> blockSize100k ) RETURN ( BZ_DATA_ERROR ) ; for ( i = 0 ; i < 16 ; i ++ ) { GET_BIT ( BZ_X_MAPPING_1 , uc ) ; if ( uc == 1 ) s -> inUse16 [ i ] = True ; else s -> inUse16 [ i ] = False ; } for ( i = 0 ; i < 256 ; i ++ ) s -> inUse [ i ] = False ; for ( i = 0 ; i < 16 ; i ++ ) if ( s -> inUse16 [ i ] ) for ( j = 0 ; j < 16 ; j ++ ) { GET_BIT ( BZ_X_MAPPING_2 , uc ) ; if ( uc == 1 ) s -> inUse [ i * 16 + j ] = True ; } makeMaps_d ( s ) ; if ( s -> nInUse == 0 ) RETURN ( BZ_DATA_ERROR ) ; alphaSize = s -> nInUse + 2 ; GET_BITS ( BZ_X_SELECTOR_1 , nGroups , 3 ) ; if ( nGroups < 2 || nGroups > 6 ) RETURN ( BZ_DATA_ERROR ) ; GET_BITS ( BZ_X_SELECTOR_2 , nSelectors , 15 ) ; <S2SV_StartBug> if ( nSelectors < 1 ) RETURN ( BZ_DATA_ERROR ) ; <S2SV_EndBug> for ( i = 0 ; i < nSelectors ; i ++ ) { j = 0 ; while ( True ) { GET_BIT ( BZ_X_SELECTOR_3 , uc ) ; if ( uc == 0 ) break ; j ++ ; if ( j >= nGroups ) RETURN ( BZ_DATA_ERROR ) ; } s -> selectorMtf [ i ] = j ; } { UChar pos [ BZ_N_GROUPS ] , tmp , v ; for ( v = 0 ; v < nGroups ; v ++ ) pos [ v ] = v ; for ( i = 0 ; i < nSelectors ; i ++ ) { v = s -> selectorMtf [ i ] ; tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; s -> selector [ i ] = tmp ; } } for ( t = 0 ; t < nGroups ; t ++ ) { GET_BITS ( BZ_X_CODING_1 , curr , 5 ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( True ) { if ( curr < 1 || curr > 20 ) RETURN ( BZ_DATA_ERROR ) ; GET_BIT ( BZ_X_CODING_2 , uc ) ; if ( uc == 0 ) break ; GET_BIT ( BZ_X_CODING_3 , uc ) ; if ( uc == 0 ) curr ++ ; else curr -- ; } s -> len [ t ] [ i ] = curr ; } } for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( s -> len [ t ] [ i ] > maxLen ) maxLen = s -> len [ t ] [ i ] ; if ( s -> len [ t ] [ i ] < minLen ) minLen = s -> len [ t ] [ i ] ; } BZ2_hbCreateDecodeTables ( & ( s -> limit [ t ] [ 0 ] ) , & ( s -> base [ t ] [ 0 ] ) , & ( s -> perm [ t ] [ 0 ] ) , & ( s -> len [ t ] [ 0 ] ) , minLen , maxLen , alphaSize ) ; s -> minLens [ t ] = minLen ; } EOB = s -> nInUse + 1 ; nblockMAX = 100000 * s -> blockSize100k ; groupNo = - 1 ; groupPos = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) s -> unzftab [ i ] = 0 ; { Int32 ii , jj , kk ; kk = MTFA_SIZE - 1 ; for ( ii = 256 / MTFL_SIZE - 1 ; ii >= 0 ; ii -- ) { for ( jj = MTFL_SIZE - 1 ; jj >= 0 ; jj -- ) { s -> mtfa [ kk ] = ( UChar ) ( ii * MTFL_SIZE + jj ) ; kk -- ; } s -> mtfbase [ ii ] = kk + 1 ; } } nblock = 0 ; GET_MTF_VAL ( BZ_X_MTF_1 , BZ_X_MTF_2 , nextSym ) ; while ( True ) { if ( nextSym == EOB ) break ; if ( nextSym == BZ_RUNA || nextSym == BZ_RUNB ) { es = - 1 ; N = 1 ; do { if ( N >= 2 * 1024 * 1024 ) RETURN ( BZ_DATA_ERROR ) ; if ( nextSym == BZ_RUNA ) es = es + ( 0 + 1 ) * N ; else if ( nextSym == BZ_RUNB ) es = es + ( 1 + 1 ) * N ; N = N * 2 ; GET_MTF_VAL ( BZ_X_MTF_3 , BZ_X_MTF_4 , nextSym ) ; } while ( nextSym == BZ_RUNA || nextSym == BZ_RUNB ) ; es ++ ; uc = s -> seqToUnseq [ s -> mtfa [ s -> mtfbase [ 0 ] ] ] ; s -> unzftab [ uc ] += es ; if ( s -> smallDecompress ) while ( es > 0 ) { if ( nblock >= nblockMAX ) RETURN ( BZ_DATA_ERROR ) ; s -> ll16 [ nblock ] = ( UInt16 ) uc ; nblock ++ ; es -- ; } else while ( es > 0 ) { if ( nblock >= nblockMAX ) RETURN ( BZ_DATA_ERROR ) ; s -> tt [ nblock ] = ( UInt32 ) uc ; nblock ++ ; es -- ; } ; continue ; } else { if ( nblock >= nblockMAX ) RETURN ( BZ_DATA_ERROR ) ; { Int32 ii , jj , kk , pp , lno , off ; UInt32 nn ; nn = ( UInt32 ) ( nextSym - 1 ) ; if ( nn < MTFL_SIZE ) { pp = s -> mtfbase [ 0 ] ; uc = s -> mtfa [ pp + nn ] ; while ( nn > 3 ) { Int32 z = pp + nn ; s -> mtfa [ ( z ) ] = s -> mtfa [ ( z ) - 1 ] ; s -> mtfa [ ( z ) - 1 ] = s -> mtfa [ ( z ) - 2 ] ; s -> mtfa [ ( z ) - 2 ] = s -> mtfa [ ( z ) - 3 ] ; s -> mtfa [ ( z ) - 3 ] = s -> mtfa [ ( z ) - 4 ] ; nn -= 4 ; } while ( nn > 0 ) { s -> mtfa [ ( pp + nn ) ] = s -> mtfa [ ( pp + nn ) - 1 ] ; nn -- ; } ; s -> mtfa [ pp ] = uc ; } else { lno = nn / MTFL_SIZE ; off = nn % MTFL_SIZE ; pp = s -> mtfbase [ lno ] + off ; uc = s -> mtfa [ pp ] ; while ( pp > s -> mtfbase [ lno ] ) { s -> mtfa [ pp ] = s -> mtfa [ pp - 1 ] ; pp -- ; } ; s -> mtfbase [ lno ] ++ ; while ( lno > 0 ) { s -> mtfbase [ lno ] -- ; s -> mtfa [ s -> mtfbase [ lno ] ] = s -> mtfa [ s -> mtfbase [ lno - 1 ] + MTFL_SIZE - 1 ] ; lno -- ; } s -> mtfbase [ 0 ] -- ; s -> mtfa [ s -> mtfbase [ 0 ] ] = uc ; if ( s -> mtfbase [ 0 ] == 0 ) { kk = MTFA_SIZE - 1 ; for ( ii = 256 / MTFL_SIZE - 1 ; ii >= 0 ; ii -- ) { for ( jj = MTFL_SIZE - 1 ; jj >= 0 ; jj -- ) { s -> mtfa [ kk ] = s -> mtfa [ s -> mtfbase [ ii ] + jj ] ; kk -- ; } s -> mtfbase [ ii ] = kk + 1 ; } } } } s -> unzftab [ s -> seqToUnseq [ uc ] ] ++ ; if ( s -> smallDecompress ) s -> ll16 [ nblock ] = ( UInt16 ) ( s -> seqToUnseq [ uc ] ) ; else s -> tt [ nblock ] = ( UInt32 ) ( s -> seqToUnseq [ uc ] ) ; nblock ++ ; GET_MTF_VAL ( BZ_X_MTF_5 , BZ_X_MTF_6 , nextSym ) ; continue ; } } if ( s -> origPtr < 0 || s -> origPtr >= nblock ) RETURN ( BZ_DATA_ERROR ) ; for ( i = 0 ; i <= 255 ; i ++ ) { if ( s -> unzftab [ i ] < 0 || s -> unzftab [ i ] > nblock ) RETURN ( BZ_DATA_ERROR ) ; } s -> cftab [ 0 ] = 0 ; for ( i = 1 ; i <= 256 ; i ++ ) s -> cftab [ i ] = s -> unzftab [ i - 1 ] ; for ( i = 1 ; i <= 256 ; i ++ ) s -> cftab [ i ] += s -> cftab [ i - 1 ] ; for ( i = 0 ; i <= 256 ; i ++ ) { if ( s -> cftab [ i ] < 0 || s -> cftab [ i ] > nblock ) { RETURN ( BZ_DATA_ERROR ) ; } } for ( i = 1 ; i <= 256 ; i ++ ) { if ( s -> cftab [ i - 1 ] > s -> cftab [ i ] ) { RETURN ( BZ_DATA_ERROR ) ; } } s -> state_out_len = 0 ; s -> state_out_ch = 0 ; BZ_INITIALISE_CRC ( s -> calculatedBlockCRC ) ; s -> state = BZ_X_OUTPUT ; if ( s -> verbosity >= 2 ) VPrintf0 ( \"rt+rld\" ) ; if ( s -> smallDecompress ) { for ( i = 0 ; i <= 256 ; i ++ ) s -> cftabCopy [ i ] = s -> cftab [ i ] ; for ( i = 0 ; i < nblock ; i ++ ) { uc = ( UChar ) ( s -> ll16 [ i ] ) ; SET_LL ( i , s -> cftabCopy [ uc ] ) ; s -> cftabCopy [ uc ] ++ ; } i = s -> origPtr ; j = GET_LL ( i ) ; do { Int32 tmp = GET_LL ( j ) ; SET_LL ( j , i ) ; i = j ; j = tmp ; } while ( i != s -> origPtr ) ; s -> tPos = s -> origPtr ; s -> nblock_used = 0 ; if ( s -> blockRandomised ) { BZ_RAND_INIT_MASK ; BZ_GET_SMALL ( s -> k0 ) ; s -> nblock_used ++ ; BZ_RAND_UPD_MASK ; s -> k0 ^= BZ_RAND_MASK ; } else { BZ_GET_SMALL ( s -> k0 ) ; s -> nblock_used ++ ; } } else { for ( i = 0 ; i < nblock ; i ++ ) { uc = ( UChar ) ( s -> tt [ i ] & 0xff ) ; s -> tt [ s -> cftab [ uc ] ] |= ( i << 8 ) ; s -> cftab [ uc ] ++ ; } s -> tPos = s -> tt [ s -> origPtr ] >> 8 ; s -> nblock_used = 0 ; if ( s -> blockRandomised ) { BZ_RAND_INIT_MASK ; BZ_GET_FAST ( s -> k0 ) ; s -> nblock_used ++ ; BZ_RAND_UPD_MASK ; s -> k0 ^= BZ_RAND_MASK ; } else { BZ_GET_FAST ( s -> k0 ) ; s -> nblock_used ++ ; } } RETURN ( BZ_OK ) ; endhdr_2 : GET_UCHAR ( BZ_X_ENDHDR_2 , uc ) ; if ( uc != 0x72 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_ENDHDR_3 , uc ) ; if ( uc != 0x45 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_ENDHDR_4 , uc ) ; if ( uc != 0x38 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_ENDHDR_5 , uc ) ; if ( uc != 0x50 ) RETURN ( BZ_DATA_ERROR ) ; GET_UCHAR ( BZ_X_ENDHDR_6 , uc ) ; if ( uc != 0x90 ) RETURN ( BZ_DATA_ERROR ) ; s -> storedCombinedCRC = 0 ; GET_UCHAR ( BZ_X_CCRC_1 , uc ) ; s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc ) ; GET_UCHAR ( BZ_X_CCRC_2 , uc ) ; s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc ) ; GET_UCHAR ( BZ_X_CCRC_3 , uc ) ; s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc ) ; GET_UCHAR ( BZ_X_CCRC_4 , uc ) ; s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc ) ; s -> state = BZ_X_IDLE ; RETURN ( BZ_STREAM_END ) ; default : AssertH ( False , 4001 ) ; } AssertH ( False , 4002 ) ; save_state_and_return : s -> save_i = i ; s -> save_j = j ; s -> save_t = t ; s -> save_alphaSize = alphaSize ; s -> save_nGroups = nGroups ; s -> save_nSelectors = nSelectors ; s -> save_EOB = EOB ; s -> save_groupNo = groupNo ; s -> save_groupPos = groupPos ; s -> save_nextSym = nextSym ; s -> save_nblockMAX = nblockMAX ; s -> save_nblock = nblock ; s -> save_es = es ; s -> save_N = N ; s -> save_curr = curr ; s -> save_zt = zt ; s -> save_zn = zn ; s -> save_zvec = zvec ; s -> save_zj = zj ; s -> save_gSel = gSel ; s -> save_gMinlen = gMinlen ; s -> save_gLimit = gLimit ; s -> save_gBase = gBase ; s -> save_gPerm = gPerm ; return retVal ; }", "target": "<S2SV_ModStart> nSelectors < 1 || nSelectors > BZ_MAX_SELECTORS"}
{"source": "CWE-269 static int uvc_scan_chain_forward ( struct uvc_video_chain * chain , struct uvc_entity * entity , struct uvc_entity * prev ) { struct uvc_entity * forward ; int found ; forward = NULL ; found = 0 ; while ( 1 ) { forward = uvc_entity_by_reference ( chain -> dev , entity -> id , forward ) ; if ( forward == NULL ) break ; if ( forward == prev ) continue ; <S2SV_StartBug> <S2SV_EndBug> switch ( UVC_ENTITY_TYPE ( forward ) ) { case UVC_VC_EXTENSION_UNIT : if ( forward -> bNrInPins != 1 ) { uvc_trace ( UVC_TRACE_DESCR , \"Extension<S2SV_blank>unit<S2SV_blank>%d<S2SV_blank>\" \"has<S2SV_blank>more<S2SV_blank>than<S2SV_blank>1<S2SV_blank>input<S2SV_blank>pin.\\\\n\" , entity -> id ) ; return - EINVAL ; } list_add_tail ( & forward -> chain , & chain -> entities ) ; if ( uvc_trace_param & UVC_TRACE_PROBE ) { if ( ! found ) printk ( KERN_CONT \"<S2SV_blank>(->\" ) ; printk ( KERN_CONT \"<S2SV_blank>XU<S2SV_blank>%d\" , forward -> id ) ; found = 1 ; } break ; case UVC_OTT_VENDOR_SPECIFIC : case UVC_OTT_DISPLAY : case UVC_OTT_MEDIA_TRANSPORT_OUTPUT : case UVC_TT_STREAMING : if ( UVC_ENTITY_IS_ITERM ( forward ) ) { uvc_trace ( UVC_TRACE_DESCR , \"Unsupported<S2SV_blank>input<S2SV_blank>\" \"terminal<S2SV_blank>%u.\\\\n\" , forward -> id ) ; return - EINVAL ; } list_add_tail ( & forward -> chain , & chain -> entities ) ; if ( uvc_trace_param & UVC_TRACE_PROBE ) { if ( ! found ) printk ( KERN_CONT \"<S2SV_blank>(->\" ) ; printk ( KERN_CONT \"<S2SV_blank>OT<S2SV_blank>%d\" , forward -> id ) ; found = 1 ; } break ; } } if ( found ) printk ( KERN_CONT \")\" ) ; return 0 ; }", "target": "<S2SV_ModStart> ) continue ; if ( forward -> chain . next || forward -> chain . prev ) { uvc_trace ( UVC_TRACE_DESCR , \"Found<S2SV_blank>reference<S2SV_blank>to<S2SV_blank>\" \"entity<S2SV_blank>%d<S2SV_blank>already<S2SV_blank>in<S2SV_blank>chain.\\\\n\" , forward -> id ) ; return - EINVAL ; }"}
{"source": "CWE-125 static BOOL rdp_read_font_capability_set ( wStream * s , UINT16 length , rdpSettings * settings ) { WINPR_UNUSED ( settings ) ; <S2SV_StartBug> if ( length > 4 ) <S2SV_EndBug> Stream_Seek_UINT16 ( s ) ; <S2SV_StartBug> if ( length > 6 ) <S2SV_EndBug> Stream_Seek_UINT16 ( s ) ; return TRUE ; }", "target": "<S2SV_ModStart> ( length > 5 <S2SV_ModEnd> ) Stream_Seek_UINT16 ( <S2SV_ModStart> ( length > 7 <S2SV_ModEnd> ) Stream_Seek_UINT16 ("}
{"source": "CWE-125 delete_buff_tail ( buffheader_T * buf , int slen ) { <S2SV_StartBug> int len = ( int ) STRLEN ( buf -> bh_curr -> b_str ) ; <S2SV_EndBug> if ( len >= slen ) { buf -> bh_curr -> b_str [ len - slen ] = NUL ; buf -> bh_space += slen ; } }", "target": "<S2SV_ModStart> { int len ; if ( buf -> bh_curr == NULL || buf -> bh_curr -> b_str == NULL ) return ; len"}
{"source": "CWE-703 static int is_fuse_usermount ( struct libmnt_context * cxt , int * errsv ) { struct libmnt_ns * ns_old ; const char * type = mnt_fs_get_fstype ( cxt -> fs ) ; const char * optstr ; <S2SV_StartBug> char * user_id = NULL ; <S2SV_EndBug> size_t sz ; uid_t uid ; char uidstr [ sizeof ( stringify_value ( ULONG_MAX ) ) ] ; * errsv = 0 ; if ( ! type ) return 0 ; if ( strcmp ( type , \"fuse\" ) != 0 && strcmp ( type , \"fuseblk\" ) != 0 && strncmp ( type , \"fuse.\" , 5 ) != 0 && strncmp ( type , \"fuseblk.\" , 8 ) != 0 ) return 0 ; optstr = mnt_fs_get_fs_options ( cxt -> fs ) ; if ( ! optstr ) return 0 ; <S2SV_StartBug> if ( mnt_optstr_get_option ( optstr , \"user_id\" , & user_id , & sz ) != 0 ) <S2SV_EndBug> return 0 ; if ( sz == 0 || user_id == NULL ) return 0 ; ns_old = mnt_context_switch_origin_ns ( cxt ) ; if ( ! ns_old ) { * errsv = - MNT_ERR_NAMESPACE ; return 0 ; } uid = getuid ( ) ; if ( ! mnt_context_switch_ns ( cxt , ns_old ) ) { * errsv = - MNT_ERR_NAMESPACE ; return 0 ; } <S2SV_StartBug> snprintf ( uidstr , sizeof ( uidstr ) , \"%lu\" , ( unsigned long ) uid ) ; <S2SV_EndBug> return strncmp ( user_id , uidstr , sz ) == 0 ; }", "target": "<S2SV_ModStart> * optstr ; uid_t uid , entry_uid <S2SV_ModEnd> ; * errsv <S2SV_ModStart> return 0 ; if ( mnt_optstr_get_uid <S2SV_ModEnd> ( optstr , <S2SV_ModStart> \"user_id\" , & entry_uid ) != 0 <S2SV_ModEnd> ) return 0 <S2SV_ModStart> 0 ; } return uid == entry_uid <S2SV_ModEnd> ; }"}
{"source": "CWE-269 static inline void tcp_check_send_head ( struct sock * sk , struct sk_buff * skb_unlinked ) { if ( sk -> sk_send_head == skb_unlinked ) sk -> sk_send_head = NULL ; <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> = NULL ; if ( tcp_sk ( sk ) -> highest_sack == skb_unlinked ) tcp_sk ( sk ) -> highest_sack = NULL ;"}
{"source": "CWE-787 static INLINE BOOL ensure_capacity ( const BYTE * start , const BYTE * end , size_t size , size_t base ) { const size_t available = ( uintptr_t ) end - ( uintptr_t ) start ; const BOOL rc = available >= size * base ; <S2SV_StartBug> return rc ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ; return rc && ( start <= end )"}
{"source": "CWE-284 parserule ( struct scanner * s , struct environment * env ) { struct rule * r ; char * var ; struct evalstring * val ; bool hascommand = false , hasrspfile = false , hasrspcontent = false ; r = mkrule ( scanname ( s ) ) ; scannewline ( s ) ; while ( scanindent ( s ) ) { var = scanname ( s ) ; parselet ( s , & val ) ; <S2SV_StartBug> ruleaddvar ( r , var , val ) ; <S2SV_EndBug> if ( strcmp ( var , \"command\" ) == 0 ) hascommand = true ; else if ( strcmp ( var , \"rspfile\" ) == 0 ) hasrspfile = true ; else if ( strcmp ( var , \"rspfile_content\" ) == 0 ) hasrspcontent = true ; } if ( ! hascommand ) fatal ( \"rule<S2SV_blank>\\'%s\\'<S2SV_blank>has<S2SV_blank>no<S2SV_blank>command\" , r -> name ) ; if ( hasrspfile != hasrspcontent ) fatal ( \"rule<S2SV_blank>\\'%s\\'<S2SV_blank>has<S2SV_blank>rspfile<S2SV_blank>and<S2SV_blank>no<S2SV_blank>rspfile_content<S2SV_blank>or<S2SV_blank>vice<S2SV_blank>versa\" , r -> name ) ; envaddrule ( env , r ) ; }", "target": "<S2SV_ModStart> , val ) ; if ( ! val ) continue"}
{"source": "CWE-787 handle_add_command ( GraphicsManager * self , const GraphicsCommand * g , const uint8_t * payload , bool * is_dirty , uint32_t iid ) { # define ABRT ( code , ... ) { set_add_response ( # code , __VA_ARGS__ ) ; self -> loading_image = 0 ; if ( img ) img -> data_loaded = false ; return NULL ; } # define MAX_DATA_SZ ( 4u * 100000000u ) has_add_respose = false ; bool existing , init_img = true ; Image * img = NULL ; unsigned char tt = g -> transmission_type ? g -> transmission_type : 'd' ; enum FORMATS { RGB = 24 , RGBA = 32 , PNG = 100 } ; uint32_t fmt = g -> format ? g -> format : RGBA ; if ( tt == 'd' && self -> loading_image ) init_img = false ; if ( init_img ) { self -> last_init_graphics_command = * g ; self -> last_init_graphics_command . id = iid ; self -> loading_image = 0 ; if ( g -> data_width > 10000 || g -> data_height > 10000 ) ABRT ( EINVAL , \"Image<S2SV_blank>too<S2SV_blank>large\" ) ; remove_images ( self , add_trim_predicate , 0 ) ; img = find_or_create_image ( self , iid , & existing ) ; if ( existing ) { free_load_data ( & img -> load_data ) ; img -> data_loaded = false ; free_refs_data ( img ) ; * is_dirty = true ; self -> layers_dirty = true ; } else { img -> internal_id = internal_id_counter ++ ; img -> client_id = iid ; } img -> atime = monotonic ( ) ; img -> used_storage = 0 ; img -> width = g -> data_width ; img -> height = g -> data_height ; switch ( fmt ) { case PNG : if ( g -> data_sz > MAX_DATA_SZ ) ABRT ( EINVAL , \"PNG<S2SV_blank>data<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\" ) ; img -> load_data . is_4byte_aligned = true ; img -> load_data . is_opaque = false ; img -> load_data . data_sz = g -> data_sz ? g -> data_sz : 1024 * 100 ; break ; case RGB : case RGBA : img -> load_data . data_sz = ( size_t ) g -> data_width * g -> data_height * ( fmt / 8 ) ; if ( ! img -> load_data . data_sz ) ABRT ( EINVAL , \"Zero<S2SV_blank>width/height<S2SV_blank>not<S2SV_blank>allowed\" ) ; img -> load_data . is_4byte_aligned = fmt == RGBA || ( img -> width % 4 == 0 ) ; img -> load_data . is_opaque = fmt == RGB ; break ; default : ABRT ( EINVAL , \"Unknown<S2SV_blank>image<S2SV_blank>format:<S2SV_blank>%u\" , fmt ) ; } if ( tt == 'd' ) { if ( g -> more ) self -> loading_image = img -> internal_id ; img -> load_data . buf_capacity = img -> load_data . data_sz + ( g -> compressed ? 1024 : 10 ) ; img -> load_data . buf = malloc ( img -> load_data . buf_capacity ) ; img -> load_data . buf_used = 0 ; if ( img -> load_data . buf == NULL ) { ABRT ( ENOMEM , \"Out<S2SV_blank>of<S2SV_blank>memory\" ) ; img -> load_data . buf_capacity = 0 ; img -> load_data . buf_used = 0 ; } } } else { self -> last_init_graphics_command . more = g -> more ; self -> last_init_graphics_command . payload_sz = g -> payload_sz ; g = & self -> last_init_graphics_command ; tt = g -> transmission_type ? g -> transmission_type : 'd' ; fmt = g -> format ? g -> format : RGBA ; img = img_by_internal_id ( self , self -> loading_image ) ; if ( img == NULL ) { self -> loading_image = 0 ; ABRT ( EILSEQ , \"More<S2SV_blank>payload<S2SV_blank>loading<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>image\" ) ; } } int fd ; static char fname [ 2056 ] = { 0 } ; switch ( tt ) { case 'd' : if ( img -> load_data . buf_capacity - img -> load_data . buf_used < g -> payload_sz ) { if ( img -> load_data . buf_used + g -> payload_sz > MAX_DATA_SZ || fmt != PNG ) ABRT ( EFBIG , \"Too<S2SV_blank>much<S2SV_blank>data\" ) ; img -> load_data . buf_capacity = MIN ( 2 * img -> load_data . buf_capacity , MAX_DATA_SZ ) ; img -> load_data . buf = realloc ( img -> load_data . buf , img -> load_data . buf_capacity ) ; if ( img -> load_data . buf == NULL ) { ABRT ( ENOMEM , \"Out<S2SV_blank>of<S2SV_blank>memory\" ) ; img -> load_data . buf_capacity = 0 ; img -> load_data . buf_used = 0 ; } } memcpy ( img -> load_data . buf + img -> load_data . buf_used , payload , g -> payload_sz ) ; img -> load_data . buf_used += g -> payload_sz ; if ( ! g -> more ) { img -> data_loaded = true ; self -> loading_image = 0 ; } break ; case 'f' : case 't' : case 's' : if ( g -> payload_sz > 2048 ) ABRT ( EINVAL , \"Filename<S2SV_blank>too<S2SV_blank>long\" ) ; snprintf ( fname , sizeof ( fname ) / sizeof ( fname [ 0 ] ) , \"%.*s\" , ( int ) g -> payload_sz , payload ) ; if ( tt == 's' ) fd = shm_open ( fname , O_RDONLY , 0 ) ; else fd = open ( fname , O_CLOEXEC | O_RDONLY ) ; <S2SV_StartBug> if ( fd == - 1 ) ABRT ( EBADF , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>graphics<S2SV_blank>transmission<S2SV_blank>with<S2SV_blank>error:<S2SV_blank>[%d]<S2SV_blank>%s\" , fname , errno , strerror ( errno ) ) ; <S2SV_EndBug> img -> data_loaded = mmap_img_file ( self , img , fd , g -> data_sz , g -> data_offset ) ; safe_close ( fd , __FILE__ , __LINE__ ) ; if ( tt == 't' ) { if ( global_state . boss ) { call_boss ( safe_delete_temp_file , \"s\" , fname ) ; } else unlink ( fname ) ; } else if ( tt == 's' ) shm_unlink ( fname ) ; break ; default : ABRT ( EINVAL , \"Unknown<S2SV_blank>transmission<S2SV_blank>type:<S2SV_blank>%c\" , g -> transmission_type ) ; } if ( ! img -> data_loaded ) return NULL ; self -> loading_image = 0 ; bool needs_processing = g -> compressed || fmt == PNG ; if ( needs_processing ) { uint8_t * buf ; size_t bufsz ; # define IB { if ( img -> load_data . buf ) { buf = img -> load_data . buf ; bufsz = img -> load_data . buf_used ; } else { buf = img -> load_data . mapped_file ; bufsz = img -> load_data . mapped_file_sz ; } } switch ( g -> compressed ) { case 'z' : IB ; if ( ! inflate_zlib ( self , img , buf , bufsz ) ) { img -> data_loaded = false ; return NULL ; } break ; case 0 : break ; default : ABRT ( EINVAL , \"Unknown<S2SV_blank>image<S2SV_blank>compression:<S2SV_blank>%c\" , g -> compressed ) ; } switch ( fmt ) { case PNG : IB ; if ( ! inflate_png ( self , img , buf , bufsz ) ) { img -> data_loaded = false ; return NULL ; } break ; default : break ; } # undef IB img -> load_data . data = img -> load_data . buf ; if ( img -> load_data . buf_used < img -> load_data . data_sz ) { ABRT ( ENODATA , \"Insufficient<S2SV_blank>image<S2SV_blank>data:<S2SV_blank>%zu<S2SV_blank><<S2SV_blank>%zu\" , img -> load_data . buf_used , img -> load_data . data_sz ) ; } if ( img -> load_data . mapped_file ) { munmap ( img -> load_data . mapped_file , img -> load_data . mapped_file_sz ) ; img -> load_data . mapped_file = NULL ; img -> load_data . mapped_file_sz = 0 ; } } else { if ( tt == 'd' ) { if ( img -> load_data . buf_used < img -> load_data . data_sz ) { ABRT ( ENODATA , \"Insufficient<S2SV_blank>image<S2SV_blank>data:<S2SV_blank>%zu<S2SV_blank><<S2SV_blank>%zu\" , img -> load_data . buf_used , img -> load_data . data_sz ) ; } else img -> load_data . data = img -> load_data . buf ; } else { if ( img -> load_data . mapped_file_sz < img -> load_data . data_sz ) { ABRT ( ENODATA , \"Insufficient<S2SV_blank>image<S2SV_blank>data:<S2SV_blank>%zu<S2SV_blank><<S2SV_blank>%zu\" , img -> load_data . mapped_file_sz , img -> load_data . data_sz ) ; } else img -> load_data . data = img -> load_data . mapped_file ; } } size_t required_sz = ( size_t ) ( img -> load_data . is_opaque ? 3 : 4 ) * img -> width * img -> height ; if ( img -> load_data . data_sz != required_sz ) ABRT ( EINVAL , \"Image<S2SV_blank>dimensions:<S2SV_blank>%ux%u<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%zu,<S2SV_blank>expected<S2SV_blank>size:<S2SV_blank>%zu\" , img -> width , img -> height , img -> load_data . data_sz , required_sz ) ; if ( LIKELY ( img -> data_loaded && send_to_gpu ) ) { send_image_to_gpu ( & img -> texture_id , img -> load_data . data , img -> width , img -> height , img -> load_data . is_opaque , img -> load_data . is_4byte_aligned , false , REPEAT_CLAMP ) ; free_load_data ( & img -> load_data ) ; self -> used_storage += required_sz ; img -> used_storage = required_sz ; } return img ; # undef MAX_DATA_SZ # undef ABRT }", "target": "<S2SV_ModStart> ( EBADF , \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>for<S2SV_blank>graphics<S2SV_blank>transmission<S2SV_blank>with<S2SV_blank>error:<S2SV_blank>[%d]<S2SV_blank>%s\" <S2SV_ModEnd> , errno ,"}
{"source": "CWE-770 HRESULT Http : : HrReadHeaders ( ) { HRESULT hr ; std : : string strBuffer ; ULONG n = 0 ; <S2SV_StartBug> std : : map < std : : string , std : : string > : : iterator iHeader = mapHeaders . end ( ) ; <S2SV_EndBug> ec_log_debug ( \"Receiving<S2SV_blank>headers:\" ) ; do { hr = m_lpChannel -> HrReadLine ( strBuffer ) ; if ( hr != hrSuccess ) return hr ; if ( strBuffer . empty ( ) ) <S2SV_StartBug> break ; <S2SV_EndBug> if ( n == 0 ) { m_strAction = strBuffer ; } else { auto pos = strBuffer . find ( ':' ) ; size_t start = 0 ; if ( strBuffer [ 0 ] == '<S2SV_blank>' || strBuffer [ 0 ] == '\\\\t' ) { if ( iHeader == mapHeaders . end ( ) ) continue ; while ( strBuffer [ start ] == '<S2SV_blank>' || strBuffer [ start ] == '\\\\t' ) ++ start ; iHeader -> second += strBuffer . substr ( start ) ; } else { auto r = mapHeaders . emplace ( strBuffer . substr ( 0 , pos ) , strBuffer . substr ( pos + 2 ) ) ; iHeader = r . first ; } } if ( strBuffer . find ( \"Authorization\" ) != std : : string : : npos ) ec_log_debug ( \"<<S2SV_blank>Authorization:<S2SV_blank><value<S2SV_blank>hidden>\" ) ; else ec_log_debug ( \"<<S2SV_blank>\" + strBuffer ) ; ++ n ; } while ( hr == hrSuccess ) ; hr = HrParseHeaders ( ) ; if ( hr != hrSuccess ) hr_ldebug ( hr , \"parsing<S2SV_blank>headers<S2SV_blank>failed\" ) ; return hr ; }", "target": "<S2SV_ModStart> end ( ) ; static constexpr std : : size_t MAX_HEADER_LENGTH = 65536 ; std : : size_t numOfBytesRead = 0 <S2SV_ModStart> ) break ; numOfBytesRead += strBuffer . size ( ) ; if ( numOfBytesRead > MAX_HEADER_LENGTH ) { return MAPI_E_TOO_BIG ; }"}
{"source": "CWE-125 ImagingLibTiffDecode ( Imaging im , ImagingCodecState state , UINT8 * buffer , Py_ssize_t bytes ) { TIFFSTATE * clientstate = ( TIFFSTATE * ) state -> context ; char * filename = \"tempfile.tif\" ; char * mode = \"r\" ; TIFF * tiff ; uint16 photometric = 0 ; int isYCbCr = 0 ; TRACE ( ( \"in<S2SV_blank>decoder:<S2SV_blank>bytes<S2SV_blank>%d\\\\n\" , bytes ) ) ; TRACE ( ( \"State:<S2SV_blank>count<S2SV_blank>%d,<S2SV_blank>state<S2SV_blank>%d,<S2SV_blank>x<S2SV_blank>%d,<S2SV_blank>y<S2SV_blank>%d,<S2SV_blank>ystep<S2SV_blank>%d\\\\n\" , state -> count , state -> state , state -> x , state -> y , state -> ystep ) ) ; TRACE ( ( \"State:<S2SV_blank>xsize<S2SV_blank>%d,<S2SV_blank>ysize<S2SV_blank>%d,<S2SV_blank>xoff<S2SV_blank>%d,<S2SV_blank>yoff<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> xsize , state -> ysize , state -> xoff , state -> yoff ) ) ; TRACE ( ( \"State:<S2SV_blank>bits<S2SV_blank>%d,<S2SV_blank>bytes<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> bits , state -> bytes ) ) ; TRACE ( ( \"Buffer:<S2SV_blank>%p:<S2SV_blank>%c%c%c%c\\\\n\" , buffer , ( char ) buffer [ 0 ] , ( char ) buffer [ 1 ] , ( char ) buffer [ 2 ] , ( char ) buffer [ 3 ] ) ) ; TRACE ( ( \"State->Buffer:<S2SV_blank>%c%c%c%c\\\\n\" , ( char ) state -> buffer [ 0 ] , ( char ) state -> buffer [ 1 ] , ( char ) state -> buffer [ 2 ] , ( char ) state -> buffer [ 3 ] ) ) ; TRACE ( ( \"Image:<S2SV_blank>mode<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>bands:<S2SV_blank>%d,<S2SV_blank>xsize<S2SV_blank>%d,<S2SV_blank>ysize<S2SV_blank>%d<S2SV_blank>\\\\n\" , im -> mode , im -> type , im -> bands , im -> xsize , im -> ysize ) ) ; TRACE ( ( \"Image:<S2SV_blank>image8<S2SV_blank>%p,<S2SV_blank>image32<S2SV_blank>%p,<S2SV_blank>image<S2SV_blank>%p,<S2SV_blank>block<S2SV_blank>%p<S2SV_blank>\\\\n\" , im -> image8 , im -> image32 , im -> image , im -> block ) ) ; TRACE ( ( \"Image:<S2SV_blank>pixelsize:<S2SV_blank>%d,<S2SV_blank>linesize<S2SV_blank>%d<S2SV_blank>\\\\n\" , im -> pixelsize , im -> linesize ) ) ; dump_state ( clientstate ) ; clientstate -> size = bytes ; clientstate -> eof = clientstate -> size ; clientstate -> loc = 0 ; clientstate -> data = ( tdata_t ) buffer ; clientstate -> flrealloc = 0 ; dump_state ( clientstate ) ; TIFFSetWarningHandler ( NULL ) ; TIFFSetWarningHandlerExt ( NULL ) ; if ( clientstate -> fp ) { TRACE ( ( \"Opening<S2SV_blank>using<S2SV_blank>fd:<S2SV_blank>%d\\\\n\" , clientstate -> fp ) ) ; lseek ( clientstate -> fp , 0 , SEEK_SET ) ; tiff = TIFFFdOpen ( fd_to_tiff_fd ( clientstate -> fp ) , filename , mode ) ; } else { TRACE ( ( \"Opening<S2SV_blank>from<S2SV_blank>string\\\\n\" ) ) ; tiff = TIFFClientOpen ( filename , mode , ( thandle_t ) clientstate , _tiffReadProc , _tiffWriteProc , _tiffSeekProc , _tiffCloseProc , _tiffSizeProc , _tiffMapProc , _tiffUnmapProc ) ; } if ( ! tiff ) { TRACE ( ( \"Error,<S2SV_blank>didn\\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>tiff\\\\n\" ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; return - 1 ; } if ( clientstate -> ifd ) { int rv ; uint32 ifdoffset = clientstate -> ifd ; TRACE ( ( \"reading<S2SV_blank>tiff<S2SV_blank>ifd<S2SV_blank>%u\\\\n\" , ifdoffset ) ) ; rv = TIFFSetSubDirectory ( tiff , ifdoffset ) ; if ( ! rv ) { TRACE ( ( \"error<S2SV_blank>in<S2SV_blank>TIFFSetSubDirectory\" ) ) ; goto decode_err ; } } TIFFGetField ( tiff , TIFFTAG_PHOTOMETRIC , & photometric ) ; isYCbCr = photometric == PHOTOMETRIC_YCBCR ; if ( TIFFIsTiled ( tiff ) ) { INT32 x , y , tile_y ; UINT32 tile_width , tile_length , current_tile_length , current_line , current_tile_width , row_byte_size ; UINT8 * new_data ; TIFFGetField ( tiff , TIFFTAG_TILEWIDTH , & tile_width ) ; TIFFGetField ( tiff , TIFFTAG_TILELENGTH , & tile_length ) ; if ( ( UINT32 ) INT_MAX / state -> bits < tile_width ) { state -> errcode = IMAGING_CODEC_MEMORY ; goto decode_err ; } if ( isYCbCr ) { row_byte_size = tile_width * 4 ; if ( im -> pixelsize != 4 ) { state -> errcode = IMAGING_CODEC_BROKEN ; goto decode_err ; } } else { row_byte_size = ( tile_width * state -> bits + 7 ) / 8 ; } if ( INT_MAX / row_byte_size < tile_length ) { state -> errcode = IMAGING_CODEC_MEMORY ; goto decode_err ; } state -> bytes = row_byte_size * tile_length ; if ( TIFFTileSize ( tiff ) > state -> bytes ) { state -> errcode = IMAGING_CODEC_MEMORY ; goto decode_err ; } new_data = realloc ( state -> buffer , state -> bytes ) ; if ( ! new_data ) { state -> errcode = IMAGING_CODEC_MEMORY ; goto decode_err ; } state -> buffer = new_data ; TRACE ( ( \"TIFFTileSize:<S2SV_blank>%d\\\\n\" , state -> bytes ) ) ; for ( y = state -> yoff ; y < state -> ysize ; y += tile_length ) { for ( x = state -> xoff ; x < state -> xsize ; x += tile_width ) { <S2SV_StartBug> if ( isYCbCr ) { <S2SV_EndBug> if ( ! TIFFReadRGBATile ( tiff , x , y , ( UINT32 * ) state -> buffer ) ) { TRACE ( ( \"Decode<S2SV_blank>Error,<S2SV_blank>Tile<S2SV_blank>at<S2SV_blank>%dx%d\\\\n\" , x , y ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; goto decode_err ; } } else { if ( TIFFReadTile ( tiff , ( tdata_t ) state -> buffer , x , y , 0 , 0 ) == - 1 ) { TRACE ( ( \"Decode<S2SV_blank>Error,<S2SV_blank>Tile<S2SV_blank>at<S2SV_blank>%dx%d\\\\n\" , x , y ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; goto decode_err ; } } TRACE ( ( \"Read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%dx%d;<S2SV_blank>\\\\n\\\\n\" , x , y ) ) ; current_tile_width = min ( ( INT32 ) tile_width , state -> xsize - x ) ; current_tile_length = min ( ( INT32 ) tile_length , state -> ysize - y ) ; for ( tile_y = 0 ; tile_y < current_tile_length ; tile_y ++ ) { TRACE ( ( \"Writing<S2SV_blank>tile<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%dx%d<S2SV_blank>using<S2SV_blank>tile_width:<S2SV_blank>%d;<S2SV_blank>\\\\n\" , tile_y + y , x , current_tile_width ) ) ; if ( isYCbCr ) { current_line = tile_length - tile_y - 1 ; } else { current_line = tile_y ; } state -> shuffle ( ( UINT8 * ) im -> image [ tile_y + y ] + x * im -> pixelsize , state -> buffer + current_line * row_byte_size , current_tile_width ) ; } } } } else { if ( ! isYCbCr ) { _decodeStrip ( im , state , tiff ) ; } else { _decodeStripYCbCr ( im , state , tiff ) ; } } decode_err : TIFFClose ( tiff ) ; TRACE ( ( \"Done<S2SV_blank>Decoding,<S2SV_blank>Returning<S2SV_blank>\\\\n\" ) ) ; return - 1 ; }", "target": "<S2SV_ModStart> { if ( ! TIFFCheckTile ( tiff , x , y , 0 , 0 ) ) { TRACE ( ( \"Check<S2SV_blank>Tile<S2SV_blank>Error,<S2SV_blank>Tile<S2SV_blank>at<S2SV_blank>%dx%d\\\\n\" , x , y ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; goto decode_err ; } if ("}
{"source": "CWE-787 mt76_add_fragment ( struct mt76_dev * dev , struct mt76_queue * q , void * data , int len , bool more ) { struct page * page = virt_to_head_page ( data ) ; int offset = data - page_address ( page ) ; struct sk_buff * skb = q -> rx_head ; <S2SV_StartBug> <S2SV_EndBug> offset += q -> buf_offset ; <S2SV_StartBug> skb_add_rx_frag ( skb , skb_shinfo ( skb ) -> nr_frags , page , offset , len , <S2SV_EndBug> <S2SV_StartBug> q -> buf_size ) ; <S2SV_EndBug> if ( more ) return ; q -> rx_head = NULL ; dev -> drv -> rx_skb ( dev , q - dev -> q_rx , skb ) ; }", "target": "<S2SV_ModStart> -> rx_head ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; if ( shinfo -> nr_frags < ARRAY_SIZE ( shinfo -> frags ) ) { <S2SV_ModStart> ( skb , shinfo <S2SV_ModEnd> -> nr_frags , <S2SV_ModStart> buf_size ) ; }"}
{"source": "CWE-252 ext_get_plugin ( const char * name , const char * module , const char * revision ) { uint16_t u ; assert ( name ) ; assert ( module ) ; for ( u = 0 ; u < ext_plugins_count ; u ++ ) { if ( ! strcmp ( name , ext_plugins [ u ] . name ) && ! strcmp ( module , ext_plugins [ u ] . module ) && <S2SV_StartBug> ( ! ext_plugins [ u ] . revision || ! strcmp ( revision , ext_plugins [ u ] . revision ) ) ) { <S2SV_EndBug> return ext_plugins [ u ] . plugin ; } } return NULL ; }", "target": "<S2SV_ModStart> ) && ( ( ! revision && <S2SV_ModStart> ] . revision ) || ( revision && <S2SV_ModEnd> ! strcmp ( <S2SV_ModStart> ] . revision )"}
{"source": "CWE-190 FastHufDecoder : : FastHufDecoder ( const char * & table , int numBytes , int minSymbol , int maxSymbol , int rleSymbol ) : _rleSymbol ( rleSymbol ) , _numSymbols ( 0 ) , _minCodeLength ( 255 ) , _maxCodeLength ( 0 ) , _idToSymbol ( 0 ) { std : : vector < Int64 > symbols ; Int64 base [ MAX_CODE_LEN + 1 ] ; Int64 offset [ MAX_CODE_LEN + 1 ] ; size_t codeCount [ MAX_CODE_LEN + 1 ] ; for ( int i = 0 ; i <= MAX_CODE_LEN ; ++ i ) { codeCount [ i ] = 0 ; base [ i ] = 0xffffffffffffffffULL ; offset [ i ] = 0 ; } const char * currByte = table ; Int64 currBits = 0 ; int currBitCount = 0 ; const int SHORT_ZEROCODE_RUN = 59 ; const int LONG_ZEROCODE_RUN = 63 ; const int SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN ; for ( Int64 symbol = static_cast < Int64 > ( minSymbol ) ; symbol <= static_cast < Int64 > ( maxSymbol ) ; symbol ++ ) { if ( currByte - table > numBytes ) { throw IEX_NAMESPACE : : InputExc ( \"Error<S2SV_blank>decoding<S2SV_blank>Huffman<S2SV_blank>table<S2SV_blank>\" \"(Truncated<S2SV_blank>table<S2SV_blank>data).\" ) ; } Int64 codeLen = readBits ( 6 , currBits , currBitCount , currByte ) ; if ( codeLen == ( Int64 ) LONG_ZEROCODE_RUN ) { if ( currByte - table > numBytes ) { throw IEX_NAMESPACE : : InputExc ( \"Error<S2SV_blank>decoding<S2SV_blank>Huffman<S2SV_blank>table<S2SV_blank>\" \"(Truncated<S2SV_blank>table<S2SV_blank>data).\" ) ; } int runLen = readBits ( 8 , currBits , currBitCount , currByte ) + SHORTEST_LONG_RUN ; if ( symbol + runLen > static_cast < Int64 > ( maxSymbol + 1 ) ) { throw IEX_NAMESPACE : : InputExc ( \"Error<S2SV_blank>decoding<S2SV_blank>Huffman<S2SV_blank>table<S2SV_blank>\" \"(Run<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>table).\" ) ; } symbol += runLen - 1 ; } else if ( codeLen >= static_cast < Int64 > ( SHORT_ZEROCODE_RUN ) ) { int runLen = codeLen - SHORT_ZEROCODE_RUN + 2 ; if ( symbol + runLen > static_cast < Int64 > ( maxSymbol + 1 ) ) { throw IEX_NAMESPACE : : InputExc ( \"Error<S2SV_blank>decoding<S2SV_blank>Huffman<S2SV_blank>table<S2SV_blank>\" \"(Run<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>table).\" ) ; } symbol += runLen - 1 ; } else if ( codeLen != 0 ) { symbols . push_back ( ( symbol << 6 ) | ( codeLen & 63 ) ) ; if ( codeLen < _minCodeLength ) _minCodeLength = codeLen ; if ( codeLen > _maxCodeLength ) _maxCodeLength = codeLen ; codeCount [ codeLen ] ++ ; } } for ( int i = 0 ; i < MAX_CODE_LEN ; ++ i ) _numSymbols += codeCount [ i ] ; table = currByte ; { double * countTmp = new double [ _maxCodeLength + 1 ] ; for ( int l = _minCodeLength ; l <= _maxCodeLength ; ++ l ) { countTmp [ l ] = ( double ) codeCount [ l ] * <S2SV_StartBug> ( double ) ( 2 << ( _maxCodeLength - l ) ) ; <S2SV_EndBug> } for ( int l = _minCodeLength ; l <= _maxCodeLength ; ++ l ) { double tmp = 0 ; for ( int k = l + 1 ; k <= _maxCodeLength ; ++ k ) tmp += countTmp [ k ] ; <S2SV_StartBug> tmp /= ( double ) ( 2 << ( _maxCodeLength - l ) ) ; <S2SV_EndBug> base [ l ] = ( Int64 ) ceil ( tmp ) ; } delete [ ] countTmp ; } offset [ _maxCodeLength ] = 0 ; for ( int i = _maxCodeLength - 1 ; i >= _minCodeLength ; i -- ) offset [ i ] = offset [ i + 1 ] + codeCount [ i + 1 ] ; _idToSymbol = new int [ _numSymbols ] ; Int64 mapping [ MAX_CODE_LEN + 1 ] ; for ( int i = 0 ; i < MAX_CODE_LEN + 1 ; ++ i ) mapping [ i ] = - 1 ; for ( int i = _minCodeLength ; i <= _maxCodeLength ; ++ i ) mapping [ i ] = offset [ i ] ; for ( std : : vector < Int64 > : : const_iterator i = symbols . begin ( ) ; i != symbols . end ( ) ; ++ i ) { int codeLen = * i & 63 ; int symbol = * i >> 6 ; if ( mapping [ codeLen ] >= static_cast < Int64 > ( _numSymbols ) ) { delete [ ] _idToSymbol ; _idToSymbol = NULL ; throw IEX_NAMESPACE : : InputExc ( \"Huffman<S2SV_blank>decode<S2SV_blank>error<S2SV_blank>\" \"(Invalid<S2SV_blank>symbol<S2SV_blank>in<S2SV_blank>header).\" ) ; } _idToSymbol [ mapping [ codeLen ] ] = symbol ; mapping [ codeLen ] ++ ; } try { buildTables ( base , offset ) ; } catch ( ... ) { delete [ ] _idToSymbol ; _idToSymbol = NULL ; throw ; } }", "target": "<S2SV_ModStart> double ) ( 2ll <S2SV_ModEnd> << ( _maxCodeLength <S2SV_ModStart> double ) ( 2ll <S2SV_ModEnd> << ( _maxCodeLength"}
{"source": "CWE-416 static zval * phar_rename_archive ( phar_archive_data * phar , char * ext , zend_bool compress TSRMLS_DC ) { const char * oldname = NULL ; char * oldpath = NULL ; char * basename = NULL , * basepath = NULL ; char * newname = NULL , * newpath = NULL ; zval * ret , arg1 ; zend_class_entry * ce ; char * error ; const char * pcr_error ; int ext_len = ext ? strlen ( ext ) : 0 ; int oldname_len ; phar_archive_data * * pphar = NULL ; php_stream_statbuf ssb ; if ( ! ext ) { if ( phar -> is_zip ) { if ( phar -> is_data ) { ext = \"zip\" ; } else { ext = \"phar.zip\" ; } } else if ( phar -> is_tar ) { switch ( phar -> flags ) { case PHAR_FILE_COMPRESSED_GZ : if ( phar -> is_data ) { ext = \"tar.gz\" ; } else { ext = \"phar.tar.gz\" ; } break ; case PHAR_FILE_COMPRESSED_BZ2 : if ( phar -> is_data ) { ext = \"tar.bz2\" ; } else { ext = \"phar.tar.bz2\" ; } break ; default : if ( phar -> is_data ) { ext = \"tar\" ; } else { ext = \"phar.tar\" ; } } } else { switch ( phar -> flags ) { case PHAR_FILE_COMPRESSED_GZ : ext = \"phar.gz\" ; break ; case PHAR_FILE_COMPRESSED_BZ2 : ext = \"phar.bz2\" ; break ; default : ext = \"phar\" ; } } } else if ( phar_path_check ( & ext , & ext_len , & pcr_error ) > pcr_is_ok ) { if ( phar -> is_data ) { zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"data<S2SV_blank>phar<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>extension<S2SV_blank>%s\" , phar -> fname , ext ) ; } else { zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"phar<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>extension<S2SV_blank>%s\" , phar -> fname , ext ) ; } return NULL ; } if ( ext [ 0 ] == '.' ) { ++ ext ; } oldpath = estrndup ( phar -> fname , phar -> fname_len ) ; oldname = zend_memrchr ( phar -> fname , '/' , phar -> fname_len ) ; ++ oldname ; oldname_len = strlen ( oldname ) ; basename = estrndup ( oldname , oldname_len ) ; spprintf ( & newname , 0 , \"%s.%s\" , strtok ( basename , \".\" ) , ext ) ; efree ( basename ) ; basepath = estrndup ( oldpath , ( strlen ( oldpath ) - oldname_len ) ) ; phar -> fname_len = spprintf ( & newpath , 0 , \"%s%s\" , basepath , newname ) ; phar -> fname = newpath ; phar -> ext = newpath + phar -> fname_len - strlen ( ext ) - 1 ; efree ( basepath ) ; efree ( newname ) ; if ( PHAR_G ( manifest_cached ) && SUCCESS == zend_hash_find ( & cached_phars , newpath , phar -> fname_len , ( void * * ) & pphar ) ) { efree ( oldpath ) ; zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>newly<S2SV_blank>converted<S2SV_blank>phar<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>to<S2SV_blank>the<S2SV_blank>list<S2SV_blank>of<S2SV_blank>phars,<S2SV_blank>new<S2SV_blank>phar<S2SV_blank>name<S2SV_blank>is<S2SV_blank>in<S2SV_blank>phar.cache_list\" , phar -> fname ) ; return NULL ; } if ( SUCCESS == zend_hash_find ( & ( PHAR_GLOBALS -> phar_fname_map ) , newpath , phar -> fname_len , ( void * * ) & pphar ) ) { if ( ( * pphar ) -> fname_len == phar -> fname_len && ! memcmp ( ( * pphar ) -> fname , phar -> fname , phar -> fname_len ) ) { if ( ! zend_hash_num_elements ( & phar -> manifest ) ) { ( * pphar ) -> is_tar = phar -> is_tar ; ( * pphar ) -> is_zip = phar -> is_zip ; ( * pphar ) -> is_data = phar -> is_data ; ( * pphar ) -> flags = phar -> flags ; ( * pphar ) -> fp = phar -> fp ; phar -> fp = NULL ; phar_destroy_phar_data ( phar TSRMLS_CC ) ; phar = * pphar ; phar -> refcount ++ ; newpath = oldpath ; goto its_ok ; } } efree ( oldpath ) ; zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>newly<S2SV_blank>converted<S2SV_blank>phar<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>to<S2SV_blank>the<S2SV_blank>list<S2SV_blank>of<S2SV_blank>phars,<S2SV_blank>a<S2SV_blank>phar<S2SV_blank>with<S2SV_blank>that<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists\" , phar -> fname ) ; return NULL ; } its_ok : if ( SUCCESS == php_stream_stat_path ( newpath , & ssb ) ) { <S2SV_StartBug> efree ( oldpath ) ; <S2SV_EndBug> zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"phar<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>exists<S2SV_blank>and<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unlinked<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>conversion\" , newpath ) ; return NULL ; } if ( ! phar -> is_data ) { if ( SUCCESS != phar_detect_phar_fname_ext ( newpath , phar -> fname_len , ( const char * * ) & ( phar -> ext ) , & ( phar -> ext_len ) , 1 , 1 , 1 TSRMLS_CC ) ) { efree ( oldpath ) ; zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"phar<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>extension<S2SV_blank>%s\" , phar -> fname , ext ) ; return NULL ; } if ( phar -> alias ) { if ( phar -> is_temporary_alias ) { phar -> alias = NULL ; phar -> alias_len = 0 ; } else { phar -> alias = estrndup ( newpath , strlen ( newpath ) ) ; phar -> alias_len = strlen ( newpath ) ; phar -> is_temporary_alias = 1 ; zend_hash_update ( & ( PHAR_GLOBALS -> phar_alias_map ) , newpath , phar -> fname_len , ( void * ) & phar , sizeof ( phar_archive_data * ) , NULL ) ; } } } else { if ( SUCCESS != phar_detect_phar_fname_ext ( newpath , phar -> fname_len , ( const char * * ) & ( phar -> ext ) , & ( phar -> ext_len ) , 0 , 1 , 1 TSRMLS_CC ) ) { efree ( oldpath ) ; zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"data<S2SV_blank>phar<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>extension<S2SV_blank>%s\" , phar -> fname , ext ) ; return NULL ; } phar -> alias = NULL ; phar -> alias_len = 0 ; } if ( ( ! pphar || phar == * pphar ) && SUCCESS != zend_hash_update ( & ( PHAR_GLOBALS -> phar_fname_map ) , newpath , phar -> fname_len , ( void * ) & phar , sizeof ( phar_archive_data * ) , NULL ) ) { efree ( oldpath ) ; zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>newly<S2SV_blank>converted<S2SV_blank>phar<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>to<S2SV_blank>the<S2SV_blank>list<S2SV_blank>of<S2SV_blank>phars\" , phar -> fname ) ; return NULL ; } phar_flush ( phar , 0 , 0 , 1 , & error TSRMLS_CC ) ; if ( error ) { zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"%s\" , error ) ; efree ( error ) ; efree ( oldpath ) ; return NULL ; } efree ( oldpath ) ; if ( phar -> is_data ) { ce = phar_ce_data ; } else { ce = phar_ce_archive ; } MAKE_STD_ZVAL ( ret ) ; if ( SUCCESS != object_init_ex ( ret , ce ) ) { zval_dtor ( ret ) ; zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"Unable<S2SV_blank>to<S2SV_blank>instantiate<S2SV_blank>phar<S2SV_blank>object<S2SV_blank>when<S2SV_blank>converting<S2SV_blank>archive<S2SV_blank>\\\\\"%s\\\\\"\" , phar -> fname ) ; return NULL ; } INIT_PZVAL ( & arg1 ) ; ZVAL_STRINGL ( & arg1 , phar -> fname , phar -> fname_len , 0 ) ; zend_call_method_with_1_params ( & ret , ce , & ce -> constructor , \"__construct\" , NULL , & arg1 ) ; return ret ; }", "target": "<S2SV_ModStart> ) ) { zend_throw_exception_ex ( spl_ce_BadMethodCallException , 0 TSRMLS_CC , \"phar<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>exists<S2SV_blank>and<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unlinked<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>conversion\" , newpath ) ; <S2SV_ModStart> efree ( oldpath <S2SV_ModEnd> ) ; return"}
{"source": "CWE-79 <S2SV_StartBug> rndr_quote ( struct buf * ob , const struct buf * text , void * opaque ) <S2SV_EndBug> { if ( ! text || ! text -> size ) return 0 ; <S2SV_StartBug> BUFPUTSL ( ob , \"<q>\" ) ; <S2SV_EndBug> bufput ( ob , text -> data , text -> size ) ; <S2SV_StartBug> BUFPUTSL ( ob , \"</q>\" ) ; <S2SV_EndBug> return 1 ; }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> rndr_underline <S2SV_ModEnd> ( struct buf <S2SV_ModStart> ( ob , \"<u>\" <S2SV_ModEnd> ) ; bufput <S2SV_ModStart> ( ob , \"</u>\" <S2SV_ModEnd> ) ; return"}
{"source": "CWE-189 ppm_load_read_header ( FILE * fp , pnm_struct * img ) { gchar * ptr ; gchar header [ MAX_CHARS_IN_ROW ] ; gint maxval ; fgets ( header , MAX_CHARS_IN_ROW , fp ) ; if ( header [ 0 ] != ASCII_P || ( header [ 1 ] != PIXMAP_ASCII && header [ 1 ] != PIXMAP_RAW ) ) { g_warning ( \"Image<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>portable<S2SV_blank>pixmap\" ) ; return FALSE ; } img -> type = header [ 1 ] ; fgets ( header , MAX_CHARS_IN_ROW , fp ) ; while ( header [ 0 ] == '#' ) { fgets ( header , MAX_CHARS_IN_ROW , fp ) ; } <S2SV_StartBug> img -> width = strtol ( header , & ptr , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> img -> height = atoi ( ptr ) ; <S2SV_EndBug> fgets ( header , MAX_CHARS_IN_ROW , fp ) ; <S2SV_StartBug> maxval = strtol ( header , & ptr , 0 ) ; <S2SV_EndBug> if ( ( maxval != 255 ) && ( maxval != 65535 ) ) { g_warning ( \"Image<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>8-bit<S2SV_blank>or<S2SV_blank>16-bit<S2SV_blank>portable<S2SV_blank>pixmap\" ) ; return FALSE ; } switch ( maxval ) { case 255 : img -> bpc = sizeof ( guchar ) ; break ; case 65535 : img -> bpc = sizeof ( gushort ) ; break ; default : g_warning ( \"%s:<S2SV_blank>Programmer<S2SV_blank>stupidity<S2SV_blank>error\" , G_STRLOC ) ; } if ( ! img -> width || ! img -> height || G_MAXSIZE / img -> width / img -> height / CHANNEL_COUNT < img -> bpc ) { g_warning ( \"Illegal<S2SV_blank>width/height:<S2SV_blank>%ld/%ld\" , img -> width , img -> height ) ; return FALSE ; } img -> numsamples = img -> width * img -> height * CHANNEL_COUNT ; return TRUE ; }", "target": "<S2SV_ModStart> ) ; } errno = 0 ; <S2SV_ModStart> & ptr , 10 ) ; if ( errno ) { g_warning ( \"Error<S2SV_blank>reading<S2SV_blank>width:<S2SV_blank>%s\" , strerror ( errno ) ) ; return FALSE ; } else if ( img -> width < 0 ) { g_warning ( \"Error:<S2SV_blank>width<S2SV_blank>is<S2SV_blank>negative\" ) ; return FALSE ; } <S2SV_ModEnd> img -> height <S2SV_ModStart> -> height = strtol ( ptr <S2SV_ModEnd> , & ptr <S2SV_ModStart> & ptr , 10 ) ; if ( errno ) { g_warning ( \"Error<S2SV_blank>reading<S2SV_blank>height:<S2SV_blank>%s\" , strerror ( errno ) ) ; return FALSE ; } else if ( img -> width < 0 ) { g_warning ( \"Error:<S2SV_blank>height<S2SV_blank>is<S2SV_blank>negative\" ) ; return FALSE ; } fgets ( header , MAX_CHARS_IN_ROW , fp ) ; maxval = strtol ( header , & ptr , 10 <S2SV_ModEnd> ) ; if"}
{"source": "CWE-119 enum_func_status php_mysqlnd_rowp_read_text_protocol_aux ( MYSQLND_MEMORY_POOL_CHUNK * row_buffer , zval * * fields , unsigned int field_count , const MYSQLND_FIELD * fields_metadata , zend_bool as_int_or_float , zend_bool copy_data , MYSQLND_STATS * stats TSRMLS_DC ) { unsigned int i ; zend_bool last_field_was_string = FALSE ; zval * * current_field , * * end_field , * * start_field ; zend_uchar * p = row_buffer -> ptr ; size_t data_size = row_buffer -> app ; zend_uchar * bit_area = ( zend_uchar * ) row_buffer -> ptr + data_size + 1 ; <S2SV_StartBug> <S2SV_EndBug> DBG_ENTER ( \"php_mysqlnd_rowp_read_text_protocol_aux\" ) ; if ( ! fields ) { DBG_RETURN ( FAIL ) ; } end_field = ( start_field = fields ) + field_count ; for ( i = 0 , current_field = start_field ; current_field < end_field ; current_field ++ , i ++ ) { DBG_INF ( \"Directly<S2SV_blank>creating<S2SV_blank>zval\" ) ; MAKE_STD_ZVAL ( * current_field ) ; if ( ! * current_field ) { DBG_RETURN ( FAIL ) ; } } for ( i = 0 , current_field = start_field ; current_field < end_field ; current_field ++ , i ++ ) { zend_uchar * this_field_len_pos = p ; <S2SV_StartBug> unsigned long len = php_mysqlnd_net_field_length ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> <S2SV_EndBug> if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) { * this_field_len_pos = '\\\\0' ; } if ( len == MYSQLND_NULL_LENGTH ) { ZVAL_NULL ( * current_field ) ; last_field_was_string = FALSE ; } else { # if defined ( MYSQLND_STRING_TO_INT_CONVERSION ) struct st_mysqlnd_perm_bind perm_bind = mysqlnd_ps_fetch_functions [ fields_metadata [ i ] . type ] ; # endif if ( MYSQLND_G ( collect_statistics ) ) { enum_mysqlnd_collected_stats statistic ; switch ( fields_metadata [ i ] . type ) { case MYSQL_TYPE_DECIMAL : statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL ; break ; case MYSQL_TYPE_TINY : statistic = STAT_TEXT_TYPE_FETCHED_INT8 ; break ; case MYSQL_TYPE_SHORT : statistic = STAT_TEXT_TYPE_FETCHED_INT16 ; break ; case MYSQL_TYPE_LONG : statistic = STAT_TEXT_TYPE_FETCHED_INT32 ; break ; case MYSQL_TYPE_FLOAT : statistic = STAT_TEXT_TYPE_FETCHED_FLOAT ; break ; case MYSQL_TYPE_DOUBLE : statistic = STAT_TEXT_TYPE_FETCHED_DOUBLE ; break ; case MYSQL_TYPE_NULL : statistic = STAT_TEXT_TYPE_FETCHED_NULL ; break ; case MYSQL_TYPE_TIMESTAMP : statistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP ; break ; case MYSQL_TYPE_LONGLONG : statistic = STAT_TEXT_TYPE_FETCHED_INT64 ; break ; case MYSQL_TYPE_INT24 : statistic = STAT_TEXT_TYPE_FETCHED_INT24 ; break ; case MYSQL_TYPE_DATE : statistic = STAT_TEXT_TYPE_FETCHED_DATE ; break ; case MYSQL_TYPE_TIME : statistic = STAT_TEXT_TYPE_FETCHED_TIME ; break ; case MYSQL_TYPE_DATETIME : statistic = STAT_TEXT_TYPE_FETCHED_DATETIME ; break ; case MYSQL_TYPE_YEAR : statistic = STAT_TEXT_TYPE_FETCHED_YEAR ; break ; case MYSQL_TYPE_NEWDATE : statistic = STAT_TEXT_TYPE_FETCHED_DATE ; break ; case MYSQL_TYPE_VARCHAR : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; case MYSQL_TYPE_BIT : statistic = STAT_TEXT_TYPE_FETCHED_BIT ; break ; case MYSQL_TYPE_NEWDECIMAL : statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL ; break ; case MYSQL_TYPE_ENUM : statistic = STAT_TEXT_TYPE_FETCHED_ENUM ; break ; case MYSQL_TYPE_SET : statistic = STAT_TEXT_TYPE_FETCHED_SET ; break ; case MYSQL_TYPE_JSON : statistic = STAT_TEXT_TYPE_FETCHED_JSON ; break ; case MYSQL_TYPE_TINY_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_MEDIUM_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_LONG_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_VAR_STRING : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; case MYSQL_TYPE_STRING : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; case MYSQL_TYPE_GEOMETRY : statistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY ; break ; default : statistic = STAT_TEXT_TYPE_FETCHED_OTHER ; break ; } MYSQLND_INC_CONN_STATISTIC_W_VALUE2 ( stats , statistic , 1 , STAT_BYTES_RECEIVED_PURE_DATA_TEXT , len ) ; } # ifdef MYSQLND_STRING_TO_INT_CONVERSION if ( as_int_or_float && perm_bind . php_type == IS_LONG ) { zend_uchar save = * ( p + len ) ; * ( p + len ) = '\\\\0' ; if ( perm_bind . pack_len < SIZEOF_LONG ) { int64_t v = # ifndef PHP_WIN32 atoll ( ( char * ) p ) ; # else _atoi64 ( ( char * ) p ) ; # endif ZVAL_LONG ( * current_field , ( long ) v ) ; } else { uint64_t v = # ifndef PHP_WIN32 ( uint64_t ) atoll ( ( char * ) p ) ; # else ( uint64_t ) _atoi64 ( ( char * ) p ) ; # endif zend_bool uns = fields_metadata [ i ] . flags & UNSIGNED_FLAG ? TRUE : FALSE ; # if SIZEOF_LONG == 8 if ( uns == TRUE && v > 9223372036854775807L ) # elif SIZEOF_LONG == 4 if ( ( uns == TRUE && v > L64 ( 2147483647 ) ) || ( uns == FALSE && ( ( L64 ( 2147483647 ) < ( int64_t ) v ) || ( L64 ( - 2147483648 ) > ( int64_t ) v ) ) ) ) # else # error Need fix for this architecture # endif { ZVAL_STRINGL ( * current_field , ( char * ) p , len , 0 ) ; } else { ZVAL_LONG ( * current_field , ( long ) v ) ; } } * ( p + len ) = save ; } else if ( as_int_or_float && perm_bind . php_type == IS_DOUBLE ) { zend_uchar save = * ( p + len ) ; * ( p + len ) = '\\\\0' ; ZVAL_DOUBLE ( * current_field , atof ( ( char * ) p ) ) ; * ( p + len ) = save ; } else # endif if ( fields_metadata [ i ] . type == MYSQL_TYPE_BIT ) { zend_uchar * start = bit_area ; ps_fetch_from_1_to_8_bytes ( * current_field , & ( fields_metadata [ i ] ) , 0 , & p , len TSRMLS_CC ) ; p -= len ; if ( Z_TYPE_PP ( current_field ) == IS_LONG ) { bit_area += 1 + sprintf ( ( char * ) start , \"%ld\" , Z_LVAL_PP ( current_field ) ) ; ZVAL_STRINGL ( * current_field , ( char * ) start , bit_area - start - 1 , copy_data ) ; } else if ( Z_TYPE_PP ( current_field ) == IS_STRING ) { memcpy ( bit_area , Z_STRVAL_PP ( current_field ) , Z_STRLEN_PP ( current_field ) ) ; bit_area += Z_STRLEN_PP ( current_field ) ; * bit_area ++ = '\\\\0' ; zval_dtor ( * current_field ) ; ZVAL_STRINGL ( * current_field , ( char * ) start , bit_area - start - 1 , copy_data ) ; } } else { ZVAL_STRINGL ( * current_field , ( char * ) p , len , copy_data ) ; } p += len ; last_field_was_string = TRUE ; } } if ( copy_data == FALSE && last_field_was_string ) { row_buffer -> ptr [ data_size ] = '\\\\0' ; } DBG_RETURN ( PASS ) ;", "target": "<S2SV_ModStart> + 1 ; const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> = p ; const <S2SV_ModStart> p ) ; if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , \"Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>\" MYSQLND_SZ_T_SPEC \"<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet\" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; }"}
{"source": "CWE-416 <S2SV_StartBug> static void cil_reset_classperms_set ( struct cil_classperms_set * cp_set ) <S2SV_EndBug> { cil_reset_classpermission ( cp_set -> set ) ; }", "target": "<S2SV_ModStart> <S2SV_null> static void cil_reset_classpermissionset ( struct cil_classpermissionset * cps ) { cil_reset_classperms_list ( cps -> classperms <S2SV_ModEnd> ) ; }"}
{"source": "CWE-787 void APar_ExtractDetails ( FILE * isofile , uint8_t optional_output ) { <S2SV_StartBug> char uint32_buffer [ 5 ] ; <S2SV_EndBug> Trackage track = { 0 } ; AtomicInfo * mvhdAtom = APar_FindAtom ( \"moov.mvhd\" , false , VERSIONED_ATOM , 0 ) ; if ( mvhdAtom != NULL ) { APar_ExtractMovieDetails ( uint32_buffer , isofile , mvhdAtom ) ; fprintf ( stdout , \"Movie<S2SV_blank>duration:<S2SV_blank>%.3lf<S2SV_blank>seconds<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>%.2lf*<S2SV_blank>kbp/sec<S2SV_blank>bitrate<S2SV_blank>\" \"(*=approximate)\\\\n\" , movie_info . seconds , secsTOtime ( movie_info . seconds ) , movie_info . simple_bitrate_calc ) ; if ( optional_output & SHOW_DATE_INFO ) { fprintf ( stdout , \"<S2SV_blank><S2SV_blank>Presentation<S2SV_blank>Creation<S2SV_blank>Date<S2SV_blank>(UTC):<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , APar_extract_UTC ( movie_info . creation_time ) ) ; fprintf ( stdout , \"<S2SV_blank><S2SV_blank>Presentation<S2SV_blank>Modification<S2SV_blank>Date<S2SV_blank>(UTC):<S2SV_blank>%s\\\\n\" , APar_extract_UTC ( movie_info . modified_time ) ) ; } } AtomicInfo * iodsAtom = APar_FindAtom ( \"moov.iods\" , false , VERSIONED_ATOM , 0 ) ; if ( iodsAtom != NULL ) { movie_info . contains_iods = true ; APar_Extract_iods_Info ( isofile , iodsAtom ) ; } if ( optional_output & SHOW_TRACK_INFO ) { APar_TrackLevelInfo ( & track , NULL ) ; fprintf ( stdout , \"Low-level<S2SV_blank>details.<S2SV_blank>Total<S2SV_blank>tracks:<S2SV_blank>%u\\\\n\" , track . total_tracks ) ; fprintf ( stdout , \"Trk<S2SV_blank><S2SV_blank>Type<S2SV_blank><S2SV_blank>Handler<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Kind<S2SV_blank><S2SV_blank>Lang<S2SV_blank><S2SV_blank>Bytes\\\\n\" ) ; if ( track . total_tracks > 0 ) { while ( track . total_tracks > track . track_num ) { track . track_num += 1 ; TrackInfo track_info = { 0 } ; APar_ExtractTrackDetails ( uint32_buffer , isofile , & track , & track_info ) ; uint16_t more_whitespace = purge_extraneous_characters ( track_info . track_hdlr_name ) ; if ( strlen ( track_info . track_hdlr_name ) == 0 ) { memcpy ( track_info . track_hdlr_name , \"[none<S2SV_blank>listed]\" , 13 ) ; } fprintf ( stdout , \"%u<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>%s\" , track . track_num , uint32tochar4 ( track_info . track_type , uint32_buffer ) , track_info . track_hdlr_name ) ; uint16_t handler_len = strlen ( track_info . track_hdlr_name ) ; if ( handler_len < 25 + more_whitespace ) { for ( uint16_t i = handler_len ; i < 25 + more_whitespace ; i ++ ) { fprintf ( stdout , \"<S2SV_blank>\" ) ; } } fprintf ( stdout , \"<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank><S2SV_blank>%\" PRIu64 , uint32tochar4 ( track_info . track_codec , uint32_buffer ) , track_info . unpacked_lang , track_info . sample_aggregate ) ; if ( track_info . encoder_name [ 0 ] != 0 && track_info . contains_esds ) { purge_extraneous_characters ( track_info . encoder_name ) ; fprintf ( stdout , \"<S2SV_blank><S2SV_blank><S2SV_blank>Encoder:<S2SV_blank>%s\" , track_info . encoder_name ) ; } if ( track_info . type_of_track & DRM_PROTECTED_TRACK ) { fprintf ( stdout , \"<S2SV_blank>(protected<S2SV_blank>%s)\" , uint32tochar4 ( track_info . protected_codec , uint32_buffer ) ) ; } fprintf ( stdout , \"\\\\n\" ) ; if ( track_info . type_of_track & VIDEO_TRACK || track_info . type_of_track & AUDIO_TRACK ) { APar_Print_TrackDetails ( & track_info ) ; } if ( optional_output & SHOW_DATE_INFO ) { fprintf ( stdout , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Creation<S2SV_blank>Date<S2SV_blank>(UTC):<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\\n\" , APar_extract_UTC ( track_info . creation_time ) ) ; fprintf ( stdout , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Modification<S2SV_blank>Date<S2SV_blank>(UTC):<S2SV_blank>%s\\\\n\" , APar_extract_UTC ( track_info . modified_time ) ) ; } } } } }", "target": "<S2SV_ModStart> char uint32_buffer [ 8 <S2SV_ModEnd> ] ; Trackage"}
{"source": "CWE-189 _gnutls_ciphertext2compressed ( gnutls_session_t session , opaque * compress_data , int compress_size , gnutls_datum_t ciphertext , uint8_t type ) { uint8_t MAC [ MAX_HASH_SIZE ] ; uint16_t c_length ; uint8_t pad ; int length ; digest_hd_st td ; uint16_t blocksize ; int ret , i , pad_failed = 0 ; uint8_t major , minor ; gnutls_protocol_t ver ; int hash_size = _gnutls_hash_get_algo_len ( session -> security_parameters . read_mac_algorithm ) ; ver = gnutls_protocol_get_version ( session ) ; minor = _gnutls_version_get_minor ( ver ) ; major = _gnutls_version_get_major ( ver ) ; blocksize = _gnutls_cipher_get_block_size ( session -> security_parameters . read_bulk_cipher_algorithm ) ; ret = mac_init ( & td , session -> security_parameters . read_mac_algorithm , session -> connection_state . read_mac_secret . data , session -> connection_state . read_mac_secret . size , ver ) ; if ( ret < 0 && session -> security_parameters . read_mac_algorithm != GNUTLS_MAC_NULL ) { gnutls_assert ( ) ; return GNUTLS_E_INTERNAL_ERROR ; } <S2SV_StartBug> if ( ciphertext . size < ( unsigned ) blocksize + hash_size ) <S2SV_EndBug> { _gnutls_record_log ( \"REC[%x]:<S2SV_blank>Short<S2SV_blank>record<S2SV_blank>length<S2SV_blank>%d<S2SV_blank><<S2SV_blank>%d<S2SV_blank>+<S2SV_blank>%d<S2SV_blank>(under<S2SV_blank>attack?)\\\\n\" , session , ciphertext . size , blocksize , hash_size ) ; gnutls_assert ( ) ; return GNUTLS_E_DECRYPTION_FAILED ; } switch ( _gnutls_cipher_is_block ( session -> security_parameters . read_bulk_cipher_algorithm ) ) { case CIPHER_STREAM : if ( ( ret = _gnutls_cipher_decrypt ( & session -> connection_state . read_cipher_state , ciphertext . data , ciphertext . size ) ) < 0 ) { gnutls_assert ( ) ; return ret ; } length = ciphertext . size - hash_size ; break ; case CIPHER_BLOCK : if ( ( ciphertext . size < blocksize ) || ( ciphertext . size % blocksize != 0 ) ) { gnutls_assert ( ) ; return GNUTLS_E_DECRYPTION_FAILED ; } if ( ( ret = _gnutls_cipher_decrypt ( & session -> connection_state . read_cipher_state , ciphertext . data , ciphertext . size ) ) < 0 ) { gnutls_assert ( ) ; return ret ; } if ( session -> security_parameters . version >= GNUTLS_TLS1_1 ) { ciphertext . size -= blocksize ; ciphertext . data += blocksize ; if ( ciphertext . size == 0 ) { gnutls_assert ( ) ; return GNUTLS_E_DECRYPTION_FAILED ; } } pad = ciphertext . data [ ciphertext . size - 1 ] + 1 ; if ( ( int ) pad > ( int ) ciphertext . size - hash_size ) { <S2SV_StartBug> gnutls_assert ( ) ; <S2SV_EndBug> pad_failed = GNUTLS_E_DECRYPTION_FAILED ; } length = ciphertext . size - hash_size - pad ; if ( ver >= GNUTLS_TLS1 && pad_failed == 0 ) for ( i = 2 ; i < pad ; i ++ ) { if ( ciphertext . data [ ciphertext . size - i ] != ciphertext . data [ ciphertext . size - 1 ] ) pad_failed = GNUTLS_E_DECRYPTION_FAILED ; } break ; default : gnutls_assert ( ) ; return GNUTLS_E_INTERNAL_ERROR ; } if ( length < 0 ) length = 0 ; c_length = _gnutls_conv_uint16 ( ( uint16_t ) length ) ; if ( session -> security_parameters . read_mac_algorithm != GNUTLS_MAC_NULL ) { _gnutls_hmac ( & td , UINT64DATA ( session -> connection_state . read_sequence_number ) , 8 ) ; _gnutls_hmac ( & td , & type , 1 ) ; if ( ver >= GNUTLS_TLS1 ) { _gnutls_hmac ( & td , & major , 1 ) ; _gnutls_hmac ( & td , & minor , 1 ) ; } _gnutls_hmac ( & td , & c_length , 2 ) ; if ( length > 0 ) _gnutls_hmac ( & td , ciphertext . data , length ) ; mac_deinit ( & td , MAC , ver ) ; } if ( pad_failed != 0 ) return pad_failed ; if ( memcmp ( MAC , & ciphertext . data [ length ] , hash_size ) != 0 ) { gnutls_assert ( ) ; return GNUTLS_E_DECRYPTION_FAILED ; } if ( compress_size < length ) { gnutls_assert ( ) ; return GNUTLS_E_DECOMPRESSION_FAILED ; } memcpy ( compress_data , ciphertext . data , length ) ; return length ; }", "target": "<S2SV_ModStart> GNUTLS_E_INTERNAL_ERROR ; } <S2SV_ModEnd> switch ( _gnutls_cipher_is_block <S2SV_ModStart> { gnutls_assert ( ) ; _gnutls_record_log ( \"REC[%x]:<S2SV_blank>Short<S2SV_blank>record<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>(under<S2SV_blank>attack?)\\\\n\" , session , pad , ciphertext . size , hash_size"}
{"source": "CWE-416 bool SFD_GetFontMetaData ( FILE * sfd , char * tok , SplineFont * sf , SFD_GetFontMetaDataData * d ) { int ch ; int i ; KernClass * kc = 0 ; int old ; char val [ 2000 ] ; static SFD_GetFontMetaDataData my_static_d ; static int my_static_d_is_virgin = 1 ; if ( ! d ) { if ( my_static_d_is_virgin ) { my_static_d_is_virgin = 0 ; SFD_GetFontMetaDataData_Init ( & my_static_d ) ; } d = & my_static_d ; } if ( strmatch ( tok , \"FontName:\" ) == 0 ) { geteol ( sfd , val ) ; sf -> fontname = copy ( val ) ; } else if ( strmatch ( tok , \"FullName:\" ) == 0 ) { geteol ( sfd , val ) ; sf -> fullname = copy ( val ) ; } else if ( strmatch ( tok , \"FamilyName:\" ) == 0 ) { geteol ( sfd , val ) ; sf -> familyname = copy ( val ) ; } else if ( strmatch ( tok , \"DefaultBaseFilename:\" ) == 0 ) { geteol ( sfd , val ) ; sf -> defbasefilename = copy ( val ) ; } else if ( strmatch ( tok , \"Weight:\" ) == 0 ) { getprotectedname ( sfd , val ) ; sf -> weight = copy ( val ) ; } else if ( strmatch ( tok , \"Copyright:\" ) == 0 ) { sf -> copyright = getquotedeol ( sfd ) ; } else if ( strmatch ( tok , \"Comments:\" ) == 0 ) { char * temp = getquotedeol ( sfd ) ; sf -> comments = latin1_2_utf8_copy ( temp ) ; free ( temp ) ; } else if ( strmatch ( tok , \"UComments:\" ) == 0 ) { sf -> comments = SFDReadUTF7Str ( sfd ) ; } else if ( strmatch ( tok , \"FontLog:\" ) == 0 ) { sf -> fontlog = SFDReadUTF7Str ( sfd ) ; } else if ( strmatch ( tok , \"Version:\" ) == 0 ) { geteol ( sfd , val ) ; sf -> version = copy ( val ) ; } else if ( strmatch ( tok , \"StyleMapFamilyName:\" ) == 0 ) { sf -> styleMapFamilyName = SFDReadUTF7Str ( sfd ) ; } else if ( strmatch ( tok , \"OS2FamilyName:\" ) == 0 ) { if ( sf -> styleMapFamilyName == NULL ) sf -> styleMapFamilyName = SFDReadUTF7Str ( sfd ) ; } else if ( strmatch ( tok , \"FONDName:\" ) == 0 ) { geteol ( sfd , val ) ; sf -> fondname = copy ( val ) ; } else if ( strmatch ( tok , \"ItalicAngle:\" ) == 0 ) { getreal ( sfd , & sf -> italicangle ) ; } else if ( strmatch ( tok , \"StrokeWidth:\" ) == 0 ) { getreal ( sfd , & sf -> strokewidth ) ; } else if ( strmatch ( tok , \"UnderlinePosition:\" ) == 0 ) { getreal ( sfd , & sf -> upos ) ; } else if ( strmatch ( tok , \"UnderlineWidth:\" ) == 0 ) { getreal ( sfd , & sf -> uwidth ) ; } else if ( strmatch ( tok , \"ModificationTime:\" ) == 0 ) { getlonglong ( sfd , & sf -> modificationtime ) ; } else if ( strmatch ( tok , \"CreationTime:\" ) == 0 ) { getlonglong ( sfd , & sf -> creationtime ) ; d -> hadtimes = true ; } else if ( strmatch ( tok , \"PfmFamily:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . pfmfamily = temp ; sf -> pfminfo . pfmset = true ; } else if ( strmatch ( tok , \"LangName:\" ) == 0 ) { sf -> names = SFDGetLangName ( sfd , sf -> names ) ; } else if ( strmatch ( tok , \"GaspTable:\" ) == 0 ) { SFDGetGasp ( sfd , sf ) ; } else if ( strmatch ( tok , \"DesignSize:\" ) == 0 ) { SFDGetDesignSize ( sfd , sf ) ; } else if ( strmatch ( tok , \"OtfFeatName:\" ) == 0 ) { SFDGetOtfFeatName ( sfd , sf ) ; } else if ( strmatch ( tok , \"PfmWeight:\" ) == 0 || strmatch ( tok , \"TTFWeight:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . weight ) ; sf -> pfminfo . pfmset = true ; } else if ( strmatch ( tok , \"TTFWidth:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . width ) ; sf -> pfminfo . pfmset = true ; } else if ( strmatch ( tok , \"Panose:\" ) == 0 ) { int temp , i ; for ( i = 0 ; i < 10 ; ++ i ) { getint ( sfd , & temp ) ; sf -> pfminfo . panose [ i ] = temp ; } sf -> pfminfo . panose_set = true ; } else if ( strmatch ( tok , \"LineGap:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . linegap ) ; sf -> pfminfo . pfmset = true ; } else if ( strmatch ( tok , \"VLineGap:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . vlinegap ) ; sf -> pfminfo . pfmset = true ; } else if ( strmatch ( tok , \"HheadAscent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . hhead_ascent ) ; } else if ( strmatch ( tok , \"HheadAOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . hheadascent_add = temp ; } else if ( strmatch ( tok , \"HheadDescent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . hhead_descent ) ; } else if ( strmatch ( tok , \"HheadDOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . hheaddescent_add = temp ; } else if ( strmatch ( tok , \"OS2TypoLinegap:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_typolinegap ) ; } else if ( strmatch ( tok , \"OS2TypoAscent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_typoascent ) ; } else if ( strmatch ( tok , \"OS2TypoAOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . typoascent_add = temp ; } else if ( strmatch ( tok , \"OS2TypoDescent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_typodescent ) ; } else if ( strmatch ( tok , \"OS2TypoDOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . typodescent_add = temp ; } else if ( strmatch ( tok , \"OS2WinAscent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_winascent ) ; } else if ( strmatch ( tok , \"OS2WinDescent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_windescent ) ; } else if ( strmatch ( tok , \"OS2WinAOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . winascent_add = temp ; } else if ( strmatch ( tok , \"OS2WinDOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . windescent_add = temp ; } else if ( strmatch ( tok , \"HHeadAscent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . hhead_ascent ) ; } else if ( strmatch ( tok , \"HHeadDescent:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . hhead_descent ) ; } else if ( strmatch ( tok , \"HHeadAOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . hheadascent_add = temp ; } else if ( strmatch ( tok , \"HHeadDOffset:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> pfminfo . hheaddescent_add = temp ; } else if ( strmatch ( tok , \"MacStyle:\" ) == 0 ) { getsint ( sfd , & sf -> macstyle ) ; } else if ( strmatch ( tok , \"OS2SubXSize:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_subxsize ) ; sf -> pfminfo . subsuper_set = true ; } else if ( strmatch ( tok , \"OS2SubYSize:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_subysize ) ; } else if ( strmatch ( tok , \"OS2SubXOff:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_subxoff ) ; } else if ( strmatch ( tok , \"OS2SubYOff:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_subyoff ) ; } else if ( strmatch ( tok , \"OS2SupXSize:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_supxsize ) ; } else if ( strmatch ( tok , \"OS2SupYSize:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_supysize ) ; } else if ( strmatch ( tok , \"OS2SupXOff:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_supxoff ) ; } else if ( strmatch ( tok , \"OS2SupYOff:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_supyoff ) ; } else if ( strmatch ( tok , \"OS2StrikeYSize:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_strikeysize ) ; } else if ( strmatch ( tok , \"OS2StrikeYPos:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_strikeypos ) ; } else if ( strmatch ( tok , \"OS2CapHeight:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_capheight ) ; } else if ( strmatch ( tok , \"OS2XHeight:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_xheight ) ; } else if ( strmatch ( tok , \"OS2FamilyClass:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . os2_family_class ) ; } else if ( strmatch ( tok , \"OS2Vendor:\" ) == 0 ) { while ( isspace ( nlgetc ( sfd ) ) ) ; sf -> pfminfo . os2_vendor [ 0 ] = nlgetc ( sfd ) ; sf -> pfminfo . os2_vendor [ 1 ] = nlgetc ( sfd ) ; sf -> pfminfo . os2_vendor [ 2 ] = nlgetc ( sfd ) ; sf -> pfminfo . os2_vendor [ 3 ] = nlgetc ( sfd ) ; ( void ) nlgetc ( sfd ) ; } else if ( strmatch ( tok , \"OS2CodePages:\" ) == 0 ) { gethexints ( sfd , sf -> pfminfo . codepages , 2 ) ; sf -> pfminfo . hascodepages = true ; } else if ( strmatch ( tok , \"OS2UnicodeRanges:\" ) == 0 ) { gethexints ( sfd , sf -> pfminfo . unicoderanges , 4 ) ; sf -> pfminfo . hasunicoderanges = true ; } else if ( strmatch ( tok , \"TopEncoding:\" ) == 0 ) { getint ( sfd , & sf -> top_enc ) ; } else if ( strmatch ( tok , \"Ascent:\" ) == 0 ) { getint ( sfd , & sf -> ascent ) ; } else if ( strmatch ( tok , \"Descent:\" ) == 0 ) { getint ( sfd , & sf -> descent ) ; } else if ( strmatch ( tok , \"InvalidEm:\" ) == 0 ) { getint ( sfd , & sf -> invalidem ) ; } else if ( strmatch ( tok , \"woffMajor:\" ) == 0 ) { getint ( sfd , & sf -> woffMajor ) ; } else if ( strmatch ( tok , \"woffMinor:\" ) == 0 ) { getint ( sfd , & sf -> woffMinor ) ; } else if ( strmatch ( tok , \"woffMetadata:\" ) == 0 ) { sf -> woffMetadata = SFDReadUTF7Str ( sfd ) ; } else if ( strmatch ( tok , \"UFOAscent:\" ) == 0 ) { getreal ( sfd , & sf -> ufo_ascent ) ; } else if ( strmatch ( tok , \"UFODescent:\" ) == 0 ) { getreal ( sfd , & sf -> ufo_descent ) ; } else if ( strmatch ( tok , \"sfntRevision:\" ) == 0 ) { gethex ( sfd , ( uint32 * ) & sf -> sfntRevision ) ; } else if ( strmatch ( tok , \"LayerCount:\" ) == 0 ) { d -> had_layer_cnt = true ; <S2SV_StartBug> getint ( sfd , & sf -> layer_cnt ) ; <S2SV_EndBug> if ( sf -> layer_cnt > 2 ) { sf -> layers = realloc ( sf -> layers , sf -> layer_cnt * sizeof ( LayerInfo ) ) ; <S2SV_StartBug> memset ( sf -> layers + 2 , 0 , ( sf -> layer_cnt - 2 ) * sizeof ( LayerInfo ) ) ; <S2SV_EndBug> } } else if ( strmatch ( tok , \"Layer:\" ) == 0 ) { int layer , o2 , bk ; getint ( sfd , & layer ) ; if ( layer >= sf -> layer_cnt ) { sf -> layers = realloc ( sf -> layers , ( layer + 1 ) * sizeof ( LayerInfo ) ) ; memset ( sf -> layers + sf -> layer_cnt , 0 , ( ( layer + 1 ) - sf -> layer_cnt ) * sizeof ( LayerInfo ) ) ; sf -> layer_cnt = layer + 1 ; } getint ( sfd , & o2 ) ; sf -> layers [ layer ] . order2 = o2 ; sf -> layers [ layer ] . background = layer == ly_back ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; if ( ch != \\'\"\\' ) { getint ( sfd , & bk ) ; sf -> layers [ layer ] . background = bk ; } sf -> layers [ layer ] . name = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; if ( ch != '\\\\n' ) { getint ( sfd , & bk ) ; sf -> layers [ layer ] . background = bk ; } while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; if ( ch != '\\\\n' ) { sf -> layers [ layer ] . ufo_path = SFDReadUTF7Str ( sfd ) ; } } else if ( strmatch ( tok , \"PreferredKerning:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> preferred_kerning = temp ; } else if ( strmatch ( tok , \"StrokedFont:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> strokedfont = temp ; } else if ( strmatch ( tok , \"MultiLayer:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> multilayer = temp ; } else if ( strmatch ( tok , \"NeedsXUIDChange:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> changed_since_xuidchanged = temp ; } else if ( strmatch ( tok , \"VerticalOrigin:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> hasvmetrics = true ; } else if ( strmatch ( tok , \"HasVMetrics:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> hasvmetrics = temp ; } else if ( strmatch ( tok , \"Justify:\" ) == 0 ) { SFDParseJustify ( sfd , sf , tok ) ; } else if ( strmatch ( tok , \"BaseHoriz:\" ) == 0 ) { sf -> horiz_base = SFDParseBase ( sfd ) ; d -> last_base = sf -> horiz_base ; d -> last_base_script = NULL ; } else if ( strmatch ( tok , \"BaseVert:\" ) == 0 ) { sf -> vert_base = SFDParseBase ( sfd ) ; d -> last_base = sf -> vert_base ; d -> last_base_script = NULL ; } else if ( strmatch ( tok , \"BaseScript:\" ) == 0 ) { struct basescript * bs = SFDParseBaseScript ( sfd , d -> last_base ) ; if ( d -> last_base == NULL ) { BaseScriptFree ( bs ) ; bs = NULL ; } else if ( d -> last_base_script != NULL ) d -> last_base_script -> next = bs ; else d -> last_base -> scripts = bs ; d -> last_base_script = bs ; } else if ( strmatch ( tok , \"StyleMap:\" ) == 0 ) { gethex ( sfd , ( uint32 * ) & sf -> pfminfo . stylemap ) ; } else if ( strmatch ( tok , \"OS2StyleName:\" ) == 0 ) { char * sname = SFDReadUTF7Str ( sfd ) ; if ( sf -> pfminfo . stylemap == - 1 ) { if ( strcmp ( sname , \"bold<S2SV_blank>italic\" ) == 0 ) sf -> pfminfo . stylemap = 0x21 ; else if ( strcmp ( sname , \"bold\" ) == 0 ) sf -> pfminfo . stylemap = 0x20 ; else if ( strcmp ( sname , \"italic\" ) == 0 ) sf -> pfminfo . stylemap = 0x01 ; else if ( strcmp ( sname , \"regular\" ) == 0 ) sf -> pfminfo . stylemap = 0x40 ; } free ( sname ) ; } else if ( strmatch ( tok , \"FSType:\" ) == 0 ) { getsint ( sfd , & sf -> pfminfo . fstype ) ; } else if ( strmatch ( tok , \"OS2Version:\" ) == 0 ) { getsint ( sfd , & sf -> os2_version ) ; } else if ( strmatch ( tok , \"OS2_WeightWidthSlopeOnly:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> weight_width_slope_only = temp ; } else if ( strmatch ( tok , \"OS2_UseTypoMetrics:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> use_typo_metrics = temp ; } else if ( strmatch ( tok , \"UseUniqueID:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> use_uniqueid = temp ; } else if ( strmatch ( tok , \"UseXUID:\" ) == 0 ) { int temp ; getint ( sfd , & temp ) ; sf -> use_xuid = temp ; } else if ( strmatch ( tok , \"UniqueID:\" ) == 0 ) { getint ( sfd , & sf -> uniqueid ) ; } else if ( strmatch ( tok , \"XUID:\" ) == 0 ) { geteol ( sfd , tok ) ; sf -> xuid = copy ( tok ) ; } else if ( strmatch ( tok , \"Lookup:\" ) == 0 ) { OTLookup * otl ; int temp ; if ( sf -> sfd_version < 2 ) { IError ( \"Lookups<S2SV_blank>should<S2SV_blank>not<S2SV_blank>happen<S2SV_blank>in<S2SV_blank>version<S2SV_blank>1<S2SV_blank>sfd<S2SV_blank>files.\" ) ; exit ( 1 ) ; } otl = chunkalloc ( sizeof ( OTLookup ) ) ; getint ( sfd , & temp ) ; otl -> lookup_type = temp ; getint ( sfd , & temp ) ; otl -> lookup_flags = temp ; getint ( sfd , & temp ) ; otl -> store_in_afm = temp ; otl -> lookup_name = SFDReadUTF7Str ( sfd ) ; if ( otl -> lookup_type < gpos_single ) { if ( d -> lastsotl == NULL ) sf -> gsub_lookups = otl ; else d -> lastsotl -> next = otl ; d -> lastsotl = otl ; } else { if ( d -> lastpotl == NULL ) sf -> gpos_lookups = otl ; else d -> lastpotl -> next = otl ; d -> lastpotl = otl ; } SFDParseLookup ( sfd , otl ) ; } else if ( strmatch ( tok , \"MarkAttachClasses:\" ) == 0 ) { getint ( sfd , & sf -> mark_class_cnt ) ; sf -> mark_classes = malloc ( sf -> mark_class_cnt * sizeof ( char * ) ) ; sf -> mark_class_names = malloc ( sf -> mark_class_cnt * sizeof ( char * ) ) ; sf -> mark_classes [ 0 ] = NULL ; sf -> mark_class_names [ 0 ] = NULL ; for ( i = 1 ; i < sf -> mark_class_cnt ; ++ i ) { int temp ; while ( ( temp = nlgetc ( sfd ) ) == '\\\\n' || temp == '\\\\r' ) ; ungetc ( temp , sfd ) ; sf -> mark_class_names [ i ] = SFDReadUTF7Str ( sfd ) ; getint ( sfd , & temp ) ; sf -> mark_classes [ i ] = malloc ( temp + 1 ) ; sf -> mark_classes [ i ] [ temp ] = '\\\\0' ; nlgetc ( sfd ) ; fread ( sf -> mark_classes [ i ] , 1 , temp , sfd ) ; } } else if ( strmatch ( tok , \"MarkAttachSets:\" ) == 0 ) { getint ( sfd , & sf -> mark_set_cnt ) ; sf -> mark_sets = malloc ( sf -> mark_set_cnt * sizeof ( char * ) ) ; sf -> mark_set_names = malloc ( sf -> mark_set_cnt * sizeof ( char * ) ) ; for ( i = 0 ; i < sf -> mark_set_cnt ; ++ i ) { int temp ; while ( ( temp = nlgetc ( sfd ) ) == '\\\\n' || temp == '\\\\r' ) ; ungetc ( temp , sfd ) ; sf -> mark_set_names [ i ] = SFDReadUTF7Str ( sfd ) ; getint ( sfd , & temp ) ; sf -> mark_sets [ i ] = malloc ( temp + 1 ) ; sf -> mark_sets [ i ] [ temp ] = '\\\\0' ; nlgetc ( sfd ) ; fread ( sf -> mark_sets [ i ] , 1 , temp , sfd ) ; } } else if ( strmatch ( tok , \"KernClass2:\" ) == 0 || strmatch ( tok , \"VKernClass2:\" ) == 0 || strmatch ( tok , \"KernClass:\" ) == 0 || strmatch ( tok , \"VKernClass:\" ) == 0 || strmatch ( tok , \"KernClass3:\" ) == 0 || strmatch ( tok , \"VKernClass3:\" ) == 0 ) { int kernclassversion = 0 ; int isv = tok [ 0 ] == 'V' ; int kcvoffset = ( isv ? 10 : 9 ) ; if ( isdigit ( tok [ kcvoffset ] ) ) kernclassversion = tok [ kcvoffset ] - '0' ; int temp , classstart = 1 ; int old = ( kernclassversion == 0 ) ; if ( ( sf -> sfd_version < 2 ) != old ) { IError ( \"Version<S2SV_blank>mixup<S2SV_blank>in<S2SV_blank>Kerning<S2SV_blank>Classes<S2SV_blank>of<S2SV_blank>sfd<S2SV_blank>file.\" ) ; exit ( 1 ) ; } kc = chunkalloc ( old ? sizeof ( KernClass1 ) : sizeof ( KernClass ) ) ; getint ( sfd , & kc -> first_cnt ) ; ch = nlgetc ( sfd ) ; if ( ch == '+' ) classstart = 0 ; else ungetc ( ch , sfd ) ; getint ( sfd , & kc -> second_cnt ) ; if ( old ) { getint ( sfd , & temp ) ; ( ( KernClass1 * ) kc ) -> sli = temp ; getint ( sfd , & temp ) ; ( ( KernClass1 * ) kc ) -> flags = temp ; } else { kc -> subtable = SFFindLookupSubtableAndFreeName ( sf , SFDReadUTF7Str ( sfd ) ) ; if ( kc -> subtable != NULL && kc -> subtable -> kc == NULL ) kc -> subtable -> kc = kc ; else { if ( kc -> subtable == NULL ) LogError ( _ ( \"Bad<S2SV_blank>SFD<S2SV_blank>file,<S2SV_blank>missing<S2SV_blank>subtable<S2SV_blank>in<S2SV_blank>kernclass<S2SV_blank>defn.\\\\n\" ) ) ; else LogError ( _ ( \"Bad<S2SV_blank>SFD<S2SV_blank>file,<S2SV_blank>two<S2SV_blank>kerning<S2SV_blank>classes<S2SV_blank>assigned<S2SV_blank>to<S2SV_blank>the<S2SV_blank>same<S2SV_blank>subtable:<S2SV_blank>%s\\\\n\" ) , kc -> subtable -> subtable_name ) ; kc -> subtable = NULL ; } } kc -> firsts = calloc ( kc -> first_cnt , sizeof ( char * ) ) ; kc -> seconds = calloc ( kc -> second_cnt , sizeof ( char * ) ) ; kc -> offsets = calloc ( kc -> first_cnt * kc -> second_cnt , sizeof ( int16 ) ) ; kc -> adjusts = calloc ( kc -> first_cnt * kc -> second_cnt , sizeof ( DeviceTable ) ) ; if ( kernclassversion >= 3 ) { kc -> firsts_flags = calloc ( kc -> first_cnt , sizeof ( int ) ) ; kc -> seconds_flags = calloc ( kc -> second_cnt , sizeof ( int ) ) ; kc -> offsets_flags = calloc ( kc -> first_cnt * kc -> second_cnt , sizeof ( int ) ) ; kc -> firsts_names = calloc ( kc -> first_cnt , sizeof ( char * ) ) ; kc -> seconds_names = calloc ( kc -> second_cnt , sizeof ( char * ) ) ; } kc -> firsts [ 0 ] = NULL ; for ( i = classstart ; i < kc -> first_cnt ; ++ i ) { if ( kernclassversion < 3 ) { getint ( sfd , & temp ) ; kc -> firsts [ i ] = malloc ( temp + 1 ) ; kc -> firsts [ i ] [ temp ] = '\\\\0' ; nlgetc ( sfd ) ; fread ( kc -> firsts [ i ] , 1 , temp , sfd ) ; } else { getint ( sfd , & kc -> firsts_flags [ i ] ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; if ( ch == '\\\\n' || ch == EOF ) continue ; kc -> firsts_names [ i ] = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; if ( ch == '\\\\n' || ch == EOF ) continue ; kc -> firsts [ i ] = SFDReadUTF7Str ( sfd ) ; if ( kc -> firsts [ i ] == NULL ) kc -> firsts [ i ] = copy ( \"\" ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' || ch == '\\\\n' ) ; ungetc ( ch , sfd ) ; } } kc -> seconds [ 0 ] = NULL ; for ( i = 1 ; i < kc -> second_cnt ; ++ i ) { if ( kernclassversion < 3 ) { getint ( sfd , & temp ) ; kc -> seconds [ i ] = malloc ( temp + 1 ) ; kc -> seconds [ i ] [ temp ] = '\\\\0' ; nlgetc ( sfd ) ; fread ( kc -> seconds [ i ] , 1 , temp , sfd ) ; } else { getint ( sfd , & temp ) ; kc -> seconds_flags [ i ] = temp ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; if ( ch == '\\\\n' || ch == EOF ) continue ; kc -> seconds_names [ i ] = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; if ( ch == '\\\\n' || ch == EOF ) continue ; kc -> seconds [ i ] = SFDReadUTF7Str ( sfd ) ; if ( kc -> seconds [ i ] == NULL ) kc -> seconds [ i ] = copy ( \"\" ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' || ch == '\\\\n' ) ; ungetc ( ch , sfd ) ; } } for ( i = 0 ; i < kc -> first_cnt * kc -> second_cnt ; ++ i ) { if ( kernclassversion >= 3 ) { getint ( sfd , & temp ) ; kc -> offsets_flags [ i ] = temp ; } getint ( sfd , & temp ) ; kc -> offsets [ i ] = temp ; SFDReadDeviceTable ( sfd , & kc -> adjusts [ i ] ) ; } if ( ! old && kc -> subtable == NULL ) { ; } else if ( ! isv ) { if ( d -> lastkc == NULL ) sf -> kerns = kc ; else d -> lastkc -> next = kc ; d -> lastkc = kc ; } else { if ( d -> lastvkc == NULL ) sf -> vkerns = kc ; else d -> lastvkc -> next = kc ; d -> lastvkc = kc ; } } else if ( strmatch ( tok , \"ContextPos2:\" ) == 0 || strmatch ( tok , \"ContextSub2:\" ) == 0 || strmatch ( tok , \"ChainPos2:\" ) == 0 || strmatch ( tok , \"ChainSub2:\" ) == 0 || strmatch ( tok , \"ReverseChain2:\" ) == 0 || strmatch ( tok , \"ContextPos:\" ) == 0 || strmatch ( tok , \"ContextSub:\" ) == 0 || strmatch ( tok , \"ChainPos:\" ) == 0 || strmatch ( tok , \"ChainSub:\" ) == 0 || strmatch ( tok , \"ReverseChain:\" ) == 0 ) { FPST * fpst ; int old ; if ( strchr ( tok , '2' ) != NULL ) { old = false ; fpst = chunkalloc ( sizeof ( FPST ) ) ; } else { old = true ; fpst = chunkalloc ( sizeof ( FPST1 ) ) ; } if ( ( sf -> sfd_version < 2 ) != old ) { IError ( \"Version<S2SV_blank>mixup<S2SV_blank>in<S2SV_blank>FPST<S2SV_blank>of<S2SV_blank>sfd<S2SV_blank>file.\" ) ; exit ( 1 ) ; } if ( d -> lastfp == NULL ) sf -> possub = fpst ; else d -> lastfp -> next = fpst ; d -> lastfp = fpst ; SFDParseChainContext ( sfd , sf , fpst , tok , old ) ; } else if ( strmatch ( tok , \"Group:\" ) == 0 ) { struct ff_glyphclasses * grouptmp = calloc ( 1 , sizeof ( struct ff_glyphclasses ) ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; grouptmp -> classname = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; grouptmp -> glyphs = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' || ch == '\\\\n' ) ; ungetc ( ch , sfd ) ; if ( d -> lastgroup != NULL ) d -> lastgroup -> next = grouptmp ; else sf -> groups = grouptmp ; d -> lastgroup = grouptmp ; } else if ( strmatch ( tok , \"GroupKern:\" ) == 0 ) { int temp = 0 ; struct ff_rawoffsets * kerntmp = calloc ( 1 , sizeof ( struct ff_rawoffsets ) ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; kerntmp -> left = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; kerntmp -> right = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; getint ( sfd , & temp ) ; kerntmp -> offset = temp ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' || ch == '\\\\n' ) ; ungetc ( ch , sfd ) ; if ( d -> lastgroupkern != NULL ) d -> lastgroupkern -> next = kerntmp ; else sf -> groupkerns = kerntmp ; d -> lastgroupkern = kerntmp ; } else if ( strmatch ( tok , \"GroupVKern:\" ) == 0 ) { int temp = 0 ; struct ff_rawoffsets * kerntmp = calloc ( 1 , sizeof ( struct ff_rawoffsets ) ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; kerntmp -> left = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; kerntmp -> right = SFDReadUTF7Str ( sfd ) ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' ) ; ungetc ( ch , sfd ) ; getint ( sfd , & temp ) ; kerntmp -> offset = temp ; while ( ( ch = nlgetc ( sfd ) ) == '<S2SV_blank>' || ch == '\\\\n' ) ; ungetc ( ch , sfd ) ; if ( d -> lastgroupvkern != NULL ) d -> lastgroupvkern -> next = kerntmp ; else sf -> groupvkerns = kerntmp ; d -> lastgroupvkern = kerntmp ; } else if ( strmatch ( tok , \"MacIndic2:\" ) == 0 || strmatch ( tok , \"MacContext2:\" ) == 0 || strmatch ( tok , \"MacLigature2:\" ) == 0 || strmatch ( tok , \"MacSimple2:\" ) == 0 || strmatch ( tok , \"MacKern2:\" ) == 0 || strmatch ( tok , \"MacInsert2:\" ) == 0 || strmatch ( tok , \"MacIndic:\" ) == 0 || strmatch ( tok , \"MacContext:\" ) == 0 || strmatch ( tok , \"MacLigature:\" ) == 0 || strmatch ( tok , \"MacSimple:\" ) == 0 || strmatch ( tok , \"MacKern:\" ) == 0 || strmatch ( tok , \"MacInsert:\" ) == 0 ) { ASM * sm ; if ( strchr ( tok , '2' ) != NULL ) { old = false ; sm = chunkalloc ( sizeof ( ASM ) ) ; } else { old = true ; sm = chunkalloc ( sizeof ( ASM1 ) ) ; } if ( ( sf -> sfd_version < 2 ) != old ) { IError ( \"Version<S2SV_blank>mixup<S2SV_blank>in<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>of<S2SV_blank>sfd<S2SV_blank>file.\" ) ; exit ( 1 ) ; } if ( d -> lastsm == NULL ) sf -> sm = sm ; else d -> lastsm -> next = sm ; d -> lastsm = sm ; SFDParseStateMachine ( sfd , sf , sm , tok , old ) ; } else if ( strmatch ( tok , \"MacFeat:\" ) == 0 ) { sf -> features = SFDParseMacFeatures ( sfd , tok ) ; } else if ( strmatch ( tok , \"TtfTable:\" ) == 0 ) { SFDGetTtfTable ( sfd , sf , d -> lastttf ) ; } else if ( strmatch ( tok , \"TtTable:\" ) == 0 ) { SFDGetTtTable ( sfd , sf , d -> lastttf ) ; } else if ( strmatch ( tok , \"ShortTable:\" ) == 0 ) { SFDGetShortTable ( sfd , sf , d -> lastttf ) ; } else { return false ; } return true ; }", "target": "<S2SV_ModStart> = true ; int layer_cnt_tmp ; <S2SV_ModStart> sfd , & layer_cnt_tmp ) ; if ( layer_cnt_tmp <S2SV_ModEnd> > 2 ) <S2SV_ModStart> LayerInfo ) ) ; sf -> layer_cnt = layer_cnt_tmp"}
{"source": "CWE-787 int flb_gzip_compress ( void * in_data , size_t in_len , void * * out_data , size_t * out_len ) { int flush ; int status ; int footer_start ; uint8_t * pb ; size_t out_size ; void * out_buf ; z_stream strm ; mz_ulong crc ; <S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> out_buf = flb_malloc ( out_size ) ; if ( ! out_buf ) { flb_errno ( ) ; flb_error ( \"[gzip]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>outgoing<S2SV_blank>buffer\" ) ; return - 1 ; } memset ( & strm , '\\\\0' , sizeof ( strm ) ) ; strm . zalloc = Z_NULL ; strm . zfree = Z_NULL ; strm . opaque = Z_NULL ; strm . next_in = in_data ; strm . avail_in = in_len ; strm . total_out = 0 ; deflateInit2 ( & strm , Z_DEFAULT_COMPRESSION , Z_DEFLATED , - Z_DEFAULT_WINDOW_BITS , 9 , Z_DEFAULT_STRATEGY ) ; gzip_header ( out_buf ) ; pb = ( uint8_t * ) out_buf + FLB_GZIP_HEADER_OFFSET ; flush = Z_NO_FLUSH ; while ( 1 ) { strm . next_out = pb + strm . total_out ; strm . avail_out = out_size - ( pb - ( uint8_t * ) out_buf ) ; if ( strm . avail_in == 0 ) { flush = Z_FINISH ; } status = deflate ( & strm , flush ) ; if ( status == Z_STREAM_END ) { break ; } else if ( status != Z_OK ) { deflateEnd ( & strm ) ; return - 1 ; } } if ( deflateEnd ( & strm ) != Z_OK ) { flb_free ( out_buf ) ; return - 1 ; } * out_len = strm . total_out ; footer_start = FLB_GZIP_HEADER_OFFSET + * out_len ; pb = ( uint8_t * ) out_buf + footer_start ; crc = mz_crc32 ( MZ_CRC32_INIT , in_data , in_len ) ; * pb ++ = crc & 0xFF ; * pb ++ = ( crc >> 8 ) & 0xFF ; * pb ++ = ( crc >> 16 ) & 0xFF ; * pb ++ = ( crc >> 24 ) & 0xFF ; * pb ++ = in_len & 0xFF ; * pb ++ = ( in_len >> 8 ) & 0xFF ; * pb ++ = ( in_len >> 16 ) & 0xFF ; * pb ++ = ( in_len >> 24 ) & 0xFF ; * out_len += FLB_GZIP_HEADER_OFFSET + 8 ; * out_data = out_buf ; return 0 ; }", "target": "<S2SV_ModStart> mz_ulong crc ; int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> ; out_buf ="}
{"source": "CWE-476 filter_session_io ( struct io * io , int evt , void * arg ) { struct filter_session * fs = arg ; char * line = NULL ; ssize_t len ; log_trace ( TRACE_IO , \"filter<S2SV_blank>session:<S2SV_blank>%p:<S2SV_blank>%s<S2SV_blank>%s\" , fs , io_strevent ( evt ) , io_strio ( io ) ) ; switch ( evt ) { case IO_DATAIN : nextline : line = io_getline ( fs -> io , & len ) ; if ( line == NULL ) return ; filter_data ( fs -> id , line ) ; goto nextline ; <S2SV_StartBug> case IO_DISCONNECTED : <S2SV_EndBug> io_free ( fs -> io ) ; fs -> io = NULL ; break ; } }", "target": "<S2SV_ModStart> goto nextline ; <S2SV_ModEnd> } }"}
{"source": "CWE-120 ipmi_lan_alert_set ( struct ipmi_intf * intf , uint8_t chan , uint8_t alert , int argc , char * * argv ) { struct lan_param * p ; uint8_t data [ 32 ] , temp [ 32 ] ; int rc = 0 ; if ( argc < 2 ) { print_lan_alert_set_usage ( ) ; return ( - 1 ) ; } if ( strncmp ( argv [ 0 ] , \"help\" , 4 ) == 0 || strncmp ( argv [ 1 ] , \"help\" , 4 ) == 0 ) { print_lan_alert_set_usage ( ) ; return 0 ; } memset ( data , 0 , sizeof ( data ) ) ; memset ( temp , 0 , sizeof ( temp ) ) ; if ( strncasecmp ( argv [ 0 ] , \"ipaddr\" , 6 ) == 0 && ( get_cmdline_ipaddr ( argv [ 1 ] , temp ) == 0 ) ) { p = get_lan_param_select ( intf , chan , IPMI_LANP_DEST_ADDR , alert ) ; if ( ! p ) { return ( - 1 ) ; } <S2SV_StartBug> memcpy ( data , p -> data , p -> data_len ) ; <S2SV_EndBug> memcpy ( data + 3 , temp , 4 ) ; printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>IP<S2SV_blank>Address<S2SV_blank>to<S2SV_blank>%d.%d.%d.%d\\\\n\" , alert , data [ 3 ] , data [ 4 ] , data [ 5 ] , data [ 6 ] ) ; rc = set_lan_param_nowait ( intf , chan , IPMI_LANP_DEST_ADDR , data , p -> data_len ) ; } else if ( strncasecmp ( argv [ 0 ] , \"macaddr\" , 7 ) == 0 && ( str2mac ( argv [ 1 ] , temp ) == 0 ) ) { p = get_lan_param_select ( intf , chan , IPMI_LANP_DEST_ADDR , alert ) ; if ( ! p ) { return ( - 1 ) ; } <S2SV_StartBug> memcpy ( data , p -> data , p -> data_len ) ; <S2SV_EndBug> memcpy ( data + 7 , temp , 6 ) ; printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>MAC<S2SV_blank>Address<S2SV_blank>to<S2SV_blank>\" \"%s\\\\n\" , alert , mac2str ( & data [ 7 ] ) ) ; rc = set_lan_param_nowait ( intf , chan , IPMI_LANP_DEST_ADDR , data , p -> data_len ) ; } else if ( strncasecmp ( argv [ 0 ] , \"gateway\" , 7 ) == 0 ) { p = get_lan_param_select ( intf , chan , IPMI_LANP_DEST_ADDR , alert ) ; if ( ! p ) { return ( - 1 ) ; } <S2SV_StartBug> memcpy ( data , p -> data , p -> data_len ) ; <S2SV_EndBug> if ( strncasecmp ( argv [ 1 ] , \"def\" , 3 ) == 0 || strncasecmp ( argv [ 1 ] , \"default\" , 7 ) == 0 ) { printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>use<S2SV_blank>Default<S2SV_blank>Gateway\\\\n\" , alert ) ; data [ 2 ] = 0 ; } else if ( strncasecmp ( argv [ 1 ] , \"bak\" , 3 ) == 0 || strncasecmp ( argv [ 1 ] , \"backup\" , 6 ) == 0 ) { printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>use<S2SV_blank>Backup<S2SV_blank>Gateway\\\\n\" , alert ) ; data [ 2 ] = 1 ; } else { print_lan_alert_set_usage ( ) ; return - 1 ; } rc = set_lan_param_nowait ( intf , chan , IPMI_LANP_DEST_ADDR , data , p -> data_len ) ; } else if ( strncasecmp ( argv [ 0 ] , \"ack\" , 3 ) == 0 ) { p = get_lan_param_select ( intf , chan , IPMI_LANP_DEST_TYPE , alert ) ; if ( ! p ) { return ( - 1 ) ; } <S2SV_StartBug> memcpy ( data , p -> data , p -> data_len ) ; <S2SV_EndBug> if ( strncasecmp ( argv [ 1 ] , \"on\" , 2 ) == 0 || strncasecmp ( argv [ 1 ] , \"yes\" , 3 ) == 0 ) { printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>Acknowledged\\\\n\" , alert ) ; data [ 1 ] |= 0x80 ; } else if ( strncasecmp ( argv [ 1 ] , \"off\" , 3 ) == 0 || strncasecmp ( argv [ 1 ] , \"no\" , 2 ) == 0 ) { printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>Unacknowledged\\\\n\" , alert ) ; data [ 1 ] &= ~ 0x80 ; } else { print_lan_alert_set_usage ( ) ; return - 1 ; } rc = set_lan_param_nowait ( intf , chan , IPMI_LANP_DEST_TYPE , data , p -> data_len ) ; } else if ( strncasecmp ( argv [ 0 ] , \"type\" , 4 ) == 0 ) { p = get_lan_param_select ( intf , chan , IPMI_LANP_DEST_TYPE , alert ) ; if ( ! p ) { return ( - 1 ) ; } <S2SV_StartBug> memcpy ( data , p -> data , p -> data_len ) ; <S2SV_EndBug> if ( strncasecmp ( argv [ 1 ] , \"pet\" , 3 ) == 0 ) { printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>destination<S2SV_blank>to<S2SV_blank>PET<S2SV_blank>Trap\\\\n\" , alert ) ; data [ 1 ] &= ~ 0x07 ; } else if ( strncasecmp ( argv [ 1 ] , \"oem1\" , 4 ) == 0 ) { printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>destination<S2SV_blank>to<S2SV_blank>OEM<S2SV_blank>1\\\\n\" , alert ) ; data [ 1 ] &= ~ 0x07 ; data [ 1 ] |= 0x06 ; } else if ( strncasecmp ( argv [ 1 ] , \"oem2\" , 4 ) == 0 ) { printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>destination<S2SV_blank>to<S2SV_blank>OEM<S2SV_blank>2\\\\n\" , alert ) ; data [ 1 ] |= 0x07 ; } else { print_lan_alert_set_usage ( ) ; return - 1 ; } rc = set_lan_param_nowait ( intf , chan , IPMI_LANP_DEST_TYPE , data , p -> data_len ) ; } else if ( strncasecmp ( argv [ 0 ] , \"time\" , 4 ) == 0 ) { p = get_lan_param_select ( intf , chan , IPMI_LANP_DEST_TYPE , alert ) ; if ( ! p ) { return ( - 1 ) ; } <S2SV_StartBug> memcpy ( data , p -> data , p -> data_len ) ; <S2SV_EndBug> if ( str2uchar ( argv [ 1 ] , & data [ 2 ] ) != 0 ) { lprintf ( LOG_ERR , \"Invalid<S2SV_blank>time:<S2SV_blank>%s\" , argv [ 1 ] ) ; return ( - 1 ) ; } printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>timeout/retry<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>seconds\\\\n\" , alert , data [ 2 ] ) ; rc = set_lan_param_nowait ( intf , chan , IPMI_LANP_DEST_TYPE , data , p -> data_len ) ; } else if ( strncasecmp ( argv [ 0 ] , \"retry\" , 5 ) == 0 ) { p = get_lan_param_select ( intf , chan , IPMI_LANP_DEST_TYPE , alert ) ; if ( ! p ) { return ( - 1 ) ; } <S2SV_StartBug> memcpy ( data , p -> data , p -> data_len ) ; <S2SV_EndBug> if ( str2uchar ( argv [ 1 ] , & data [ 3 ] ) != 0 ) { lprintf ( LOG_ERR , \"Invalid<S2SV_blank>retry:<S2SV_blank>%s\" , argv [ 1 ] ) ; return ( - 1 ) ; } data [ 3 ] = data [ 3 ] & 0x7 ; printf ( \"Setting<S2SV_blank>LAN<S2SV_blank>Alert<S2SV_blank>%d<S2SV_blank>number<S2SV_blank>of<S2SV_blank>retries<S2SV_blank>to<S2SV_blank>%d\\\\n\" , alert , data [ 3 ] ) ; rc = set_lan_param_nowait ( intf , chan , IPMI_LANP_DEST_TYPE , data , p -> data_len ) ; } else { print_lan_alert_set_usage ( ) ; return - 1 ; } return rc ; }", "target": "<S2SV_ModStart> -> data , __min ( <S2SV_ModStart> p -> data_len , sizeof ( data ) ) <S2SV_ModStart> -> data , __min ( <S2SV_ModStart> p -> data_len , sizeof ( data ) ) <S2SV_ModStart> -> data , __min ( <S2SV_ModStart> p -> data_len , sizeof ( data ) ) <S2SV_ModStart> -> data , __min ( <S2SV_ModStart> p -> data_len , sizeof ( data ) ) <S2SV_ModStart> -> data , __min ( <S2SV_ModStart> p -> data_len , sizeof ( data ) ) <S2SV_ModStart> -> data , __min ( <S2SV_ModStart> p -> data_len , sizeof ( data ) ) <S2SV_ModStart> -> data , __min ( <S2SV_ModStart> p -> data_len , sizeof ( data ) )"}
{"source": "CWE-20 CairoFont * CairoFont : : create ( GfxFont * gfxFont , XRef * xref , FT_Library lib , GBool useCIDs ) { Ref embRef ; Object refObj , strObj ; GooString * tmpFileName , * fileName , * tmpFileName2 ; DisplayFontParam * dfp ; FILE * tmpFile ; int c , i , n ; GfxFontType fontType ; char * * enc ; char * name ; FoFiTrueType * ff ; FoFiType1C * ff1c ; Ref ref ; static cairo_user_data_key_t cairo_font_face_key ; cairo_font_face_t * cairo_font_face ; FT_Face face ; Gushort * codeToGID ; int codeToGIDLen ; dfp = NULL ; codeToGID = NULL ; codeToGIDLen = 0 ; cairo_font_face = NULL ; ref = * gfxFont -> getID ( ) ; fontType = gfxFont -> getType ( ) ; tmpFileName = NULL ; if ( gfxFont -> getEmbeddedFontID ( & embRef ) ) { if ( ! openTempFile ( & tmpFileName , & tmpFile , \"wb\" , NULL ) ) { error ( - 1 , \"Couldn\\'t<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>font<S2SV_blank>file\" ) ; goto err2 ; } refObj . initRef ( embRef . num , embRef . gen ) ; refObj . fetch ( xref , & strObj ) ; <S2SV_StartBug> refObj . free ( ) ; <S2SV_EndBug> strObj . streamReset ( ) ; while ( ( c = strObj . streamGetChar ( ) ) != EOF ) { fputc ( c , tmpFile ) ; } strObj . streamClose ( ) ; strObj . free ( ) ; fclose ( tmpFile ) ; fileName = tmpFileName ; } else if ( ! ( fileName = gfxFont -> getExtFontFile ( ) ) ) { dfp = NULL ; if ( gfxFont -> getName ( ) ) { dfp = globalParams -> getDisplayFont ( gfxFont ) ; } if ( ! dfp ) { error ( - 1 , \"Couldn\\'t<S2SV_blank>find<S2SV_blank>a<S2SV_blank>font<S2SV_blank>for<S2SV_blank>\\'%s\\'\" , gfxFont -> getName ( ) ? gfxFont -> getName ( ) -> getCString ( ) : \"(unnamed)\" ) ; goto err2 ; } switch ( dfp -> kind ) { case displayFontT1 : fileName = dfp -> t1 . fileName ; fontType = gfxFont -> isCIDFont ( ) ? fontCIDType0 : fontType1 ; break ; case displayFontTT : fileName = dfp -> tt . fileName ; fontType = gfxFont -> isCIDFont ( ) ? fontCIDType2 : fontTrueType ; break ; } } switch ( fontType ) { case fontType1 : case fontType1C : if ( FT_New_Face ( lib , fileName -> getCString ( ) , 0 , & face ) ) { error ( - 1 , \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>type1<S2SV_blank>face\" ) ; goto err2 ; } enc = ( ( Gfx8BitFont * ) gfxFont ) -> getEncoding ( ) ; codeToGID = ( Gushort * ) gmallocn ( 256 , sizeof ( int ) ) ; codeToGIDLen = 256 ; for ( i = 0 ; i < 256 ; ++ i ) { codeToGID [ i ] = 0 ; if ( ( name = enc [ i ] ) ) { codeToGID [ i ] = ( Gushort ) FT_Get_Name_Index ( face , name ) ; } } break ; case fontCIDType2 : codeToGID = NULL ; n = 0 ; if ( ( ( GfxCIDFont * ) gfxFont ) -> getCIDToGID ( ) ) { n = ( ( GfxCIDFont * ) gfxFont ) -> getCIDToGIDLen ( ) ; if ( n ) { codeToGID = ( Gushort * ) gmallocn ( n , sizeof ( Gushort ) ) ; memcpy ( codeToGID , ( ( GfxCIDFont * ) gfxFont ) -> getCIDToGID ( ) , n * sizeof ( Gushort ) ) ; } } else { ff = FoFiTrueType : : load ( fileName -> getCString ( ) ) ; if ( ! ff ) goto err2 ; codeToGID = ( ( GfxCIDFont * ) gfxFont ) -> getCodeToGIDMap ( ff , & n ) ; delete ff ; } codeToGIDLen = n ; case fontTrueType : if ( ! ( ff = FoFiTrueType : : load ( fileName -> getCString ( ) ) ) ) { error ( - 1 , \"failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>truetype<S2SV_blank>font\\\\n\" ) ; goto err2 ; } if ( fontType == fontTrueType ) { codeToGID = ( ( Gfx8BitFont * ) gfxFont ) -> getCodeToGIDMap ( ff ) ; codeToGIDLen = 256 ; } if ( ! openTempFile ( & tmpFileName2 , & tmpFile , \"wb\" , NULL ) ) { delete ff ; error ( - 1 , \"failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>truetype<S2SV_blank>tempfile\\\\n\" ) ; goto err2 ; } ff -> writeTTF ( & fileWrite , tmpFile ) ; fclose ( tmpFile ) ; delete ff ; if ( FT_New_Face ( lib , tmpFileName2 -> getCString ( ) , 0 , & face ) ) { error ( - 1 , \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>truetype<S2SV_blank>face\\\\n\" ) ; goto err2 ; } unlink ( tmpFileName2 -> getCString ( ) ) ; delete tmpFileName2 ; break ; case fontCIDType0 : case fontCIDType0C : codeToGID = NULL ; codeToGIDLen = 0 ; if ( ! useCIDs ) { if ( ( ff1c = FoFiType1C : : load ( fileName -> getCString ( ) ) ) ) { codeToGID = ff1c -> getCIDToGIDMap ( & codeToGIDLen ) ; delete ff1c ; } } if ( FT_New_Face ( lib , fileName -> getCString ( ) , 0 , & face ) ) { gfree ( codeToGID ) ; codeToGID = NULL ; error ( - 1 , \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cid<S2SV_blank>face\\\\n\" ) ; goto err2 ; } break ; default : printf ( \"font<S2SV_blank>type<S2SV_blank>not<S2SV_blank>handled\\\\n\" ) ; goto err2 ; break ; } if ( fileName == tmpFileName ) { unlink ( fileName -> getCString ( ) ) ; delete tmpFileName ; } cairo_font_face = cairo_ft_font_face_create_for_ft_face ( face , FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP ) ; if ( cairo_font_face == NULL ) { error ( - 1 , \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cairo<S2SV_blank>font\\\\n\" ) ; goto err2 ; } { CairoFont * ret = new CairoFont ( ref , cairo_font_face , face , codeToGID , codeToGIDLen ) ; cairo_font_face_set_user_data ( cairo_font_face , & cairo_font_face_key , ret , cairo_font_face_destroy ) ; return ret ; } err2 : printf ( \"some<S2SV_blank>font<S2SV_blank>thing<S2SV_blank>failed\\\\n\" ) ; return NULL ; }", "target": "<S2SV_ModStart> ( ) ; if ( ! strObj . isStream ( ) ) { error ( - 1 , \"Embedded<S2SV_blank>font<S2SV_blank>object<S2SV_blank>is<S2SV_blank>wrong<S2SV_blank>type\" ) ; strObj . free ( ) ; fclose ( tmpFile ) ; goto err2 ; }"}
{"source": "CWE-862 ExecAlterObjectDependsStmt ( AlterObjectDependsStmt * stmt , ObjectAddress * refAddress ) { ObjectAddress address ; ObjectAddress refAddr ; Relation rel ; address = get_object_address_rv ( stmt -> objectType , stmt -> relation , ( List * ) stmt -> object , <S2SV_StartBug> & rel , AccessExclusiveLock , false ) ; <S2SV_EndBug> if ( rel ) table_close ( rel , NoLock ) ; refAddr = get_object_address ( OBJECT_EXTENSION , ( Node * ) stmt -> extname , & rel , AccessExclusiveLock , false ) ; Assert ( rel == NULL ) ; if ( refAddress ) * refAddress = refAddr ; recordDependencyOn ( & address , & refAddr , DEPENDENCY_AUTO_EXTENSION ) ; return address ; }", "target": "<S2SV_ModStart> AccessExclusiveLock , false ) ; check_object_ownership ( GetUserId ( ) , stmt -> objectType , address , stmt -> object , rel"}
{"source": "CWE-787 static Image * ReadXPMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * grey , key [ MaxTextExtent ] , target [ MaxTextExtent ] , * xpm_buffer ; Image * image ; MagickBooleanType active , status ; register char * next , * p , * q ; register IndexPacket * indexes ; register PixelPacket * r ; register ssize_t x ; size_t length ; SplayTreeInfo * xpm_colors ; ssize_t count , j , y ; unsigned long colors , columns , rows , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MaxTextExtent ; xpm_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length , sizeof ( * xpm_buffer ) ) ; if ( xpm_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; * xpm_buffer = '\\\\0' ; p = xpm_buffer ; while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == xpm_buffer ) || ( * ( p - 1 ) == '\\\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - xpm_buffer + MaxTextExtent ) < length ) continue ; length <<= 1 ; xpm_buffer = ( char * ) ResizeQuantumMemory ( xpm_buffer , length + MaxTextExtent , sizeof ( * xpm_buffer ) ) ; if ( xpm_buffer == ( char * ) NULL ) break ; p = xpm_buffer + strlen ( xpm_buffer ) ; } if ( xpm_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = 0 ; width = 0 ; for ( p = xpm_buffer ; * p != '\\\\0' ; p ++ ) { if ( * p != \\'\"\\' ) continue ; count = ( ssize_t ) sscanf ( p + 1 , \"%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu\" , & columns , & rows , & colors , & width ) ; image -> columns = columns ; image -> rows = rows ; image -> colors = colors ; if ( count == 4 ) break ; } if ( ( count != 4 ) || ( width == 0 ) || ( width > 3 ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( image -> colors == 0 ) || ( image -> colors > MaxColormapSize ) ) { xpm_buffer = DestroyString ( xpm_buffer ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } active = MagickFalse ; for ( q = xpm_buffer ; * p != '\\\\0' ; ) { if ( * p ++ == \\'\"\\' ) { if ( active != MagickFalse ) * q ++ = '\\\\n' ; active = active != MagickFalse ? MagickFalse : MagickTrue ; } if ( active != MagickFalse ) * q ++ = ( * p ) ; } * q = '\\\\0' ; if ( active != MagickFalse ) { xpm_buffer = DestroyString ( xpm_buffer ) ; ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; } xpm_colors = NewSplayTree ( CompareXPMColor , RelinquishMagickMemory , ( void * ( * ) ( void * ) ) NULL ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { xpm_colors = DestroySplayTree ( xpm_colors ) ; xpm_buffer = DestroyString ( xpm_buffer ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } image -> depth = 1 ; next = NextXPMLine ( xpm_buffer ) ; for ( j = 0 ; ( j < ( ssize_t ) image -> colors ) && ( next != ( char * ) NULL ) ; j ++ ) { char symbolic [ MagickPathExtent ] ; MagickPixelPacket pixel ; p = next ; next = NextXPMLine ( p ) ; if ( next == ( char * ) NULL ) break ; length = MagickMin ( ( size_t ) width , MagickPathExtent - 1 ) ; if ( CopyXPMColor ( key , p , length ) != ( ssize_t ) length ) break ; status = AddValueToSplayTree ( xpm_colors , ConstantString ( key ) , ( void * ) j ) ; <S2SV_StartBug> ( void ) CopyMagickString ( target , \"gray\" , MaxTextExtent ) ; <S2SV_EndBug> q = ( char * ) NULL ; if ( strlen ( p ) > width ) <S2SV_StartBug> q = ParseXPMColor ( p + width , MagickTrue ) ; <S2SV_EndBug> * symbolic = '\\\\0' ; if ( q != ( char * ) NULL ) { while ( ( isspace ( ( int ) ( ( unsigned char ) * q ) ) == 0 ) && ( * q != '\\\\0' ) ) q ++ ; if ( ( next - q ) < 0 ) break ; if ( next != ( char * ) NULL ) ( void ) CopyXPMColor ( target , q , MagickMin ( ( size_t ) ( next - q ) , MaxTextExtent - 1 ) ) ; else ( void ) CopyMagickString ( target , q , MaxTextExtent ) ; q = ParseXPMColor ( target , MagickFalse ) ; ( void ) CopyXPMColor ( symbolic , q , MagickMin ( ( size_t ) ( next - q ) , MagickPathExtent - 1 ) ) ; if ( q != ( char * ) NULL ) * q = '\\\\0' ; } StripString ( target ) ; if ( * symbolic != '\\\\0' ) ( void ) AddValueToSplayTree ( xpm_symbolic , ConstantString ( target ) , ConstantString ( symbolic ) ) ; grey = strstr ( target , \"grey\" ) ; if ( grey != ( char * ) NULL ) grey [ 2 ] = 'a' ; if ( LocaleCompare ( target , \"none\" ) == 0 ) { image -> storage_class = DirectClass ; image -> matte = MagickTrue ; } status = QueryColorCompliance ( target , XPMCompliance , & image -> colormap [ j ] , exception ) ; if ( status == MagickFalse ) break ; ( void ) QueryMagickColorCompliance ( target , XPMCompliance , & pixel , exception ) ; if ( image -> depth < pixel . depth ) image -> depth = pixel . depth ; } if ( j < ( ssize_t ) image -> colors ) { xpm_colors = DestroySplayTree ( xpm_colors ) ; xpm_buffer = DestroyString ( xpm_buffer ) ; ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; xpm_colors = DestroySplayTree ( xpm_colors ) ; xpm_buffer = DestroyString ( xpm_buffer ) ; return ( DestroyImageList ( image ) ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = NextXPMLine ( p ) ; if ( p == ( char * ) NULL ) break ; r = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( r == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ssize_t count ; count = CopyXPMColor ( key , p , MagickMin ( width , MaxTextExtent - 1 ) ) ; if ( count != ( ssize_t ) width ) break ; j = ( ssize_t ) GetValueFromSplayTree ( xpm_colors , key ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x , j ) ; * r = image -> colormap [ j ] ; p += count ; r ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { xpm_colors = DestroySplayTree ( xpm_colors ) ; xpm_buffer = DestroyString ( xpm_buffer ) ; ThrowReaderException ( CorruptImageError , \"NotEnoughPixelData\" ) ; } } xpm_colors = DestroySplayTree ( xpm_colors ) ; xpm_buffer = DestroyString ( xpm_buffer ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> ( void ) memset ( target , 0 , sizeof ( target ) ) ; ( void ) <S2SV_ModStart> width , MagickTrue ) ; ( void ) memset ( symbolic , 0 , sizeof ( symbolic )"}
{"source": "CWE-125 static int ntlm_read_ntlm_v2_client_challenge ( wStream * s , NTLMv2_CLIENT_CHALLENGE * challenge ) { <S2SV_StartBug> size_t size ; <S2SV_EndBug> Stream_Read_UINT8 ( s , challenge -> RespType ) ; Stream_Read_UINT8 ( s , challenge -> HiRespType ) ; Stream_Read_UINT16 ( s , challenge -> Reserved1 ) ; Stream_Read_UINT32 ( s , challenge -> Reserved2 ) ; Stream_Read ( s , challenge -> Timestamp , 8 ) ; Stream_Read ( s , challenge -> ClientChallenge , 8 ) ; Stream_Read_UINT32 ( s , challenge -> Reserved3 ) ; size = Stream_Length ( s ) - Stream_GetPosition ( s ) ; if ( size > UINT32_MAX ) return - 1 ; challenge -> cbAvPairs = size ; challenge -> AvPairs = ( NTLM_AV_PAIR * ) malloc ( challenge -> cbAvPairs ) ; if ( ! challenge -> AvPairs ) return - 1 ; Stream_Read ( s , challenge -> AvPairs , size ) ; return 1 ; }", "target": "<S2SV_ModStart> size_t size ; if ( Stream_GetRemainingLength ( s ) < 28 ) return - 1 ;"}
{"source": "CWE-476 sftp_client_message sftp_get_client_message ( sftp_session sftp ) { ssh_session session = sftp -> session ; sftp_packet packet ; sftp_client_message msg ; ssh_buffer payload ; int rc ; msg = malloc ( sizeof ( struct sftp_client_message_struct ) ) ; if ( msg == NULL ) { ssh_set_error_oom ( session ) ; return NULL ; } ZERO_STRUCTP ( msg ) ; packet = sftp_packet_read ( sftp ) ; if ( packet == NULL ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } payload = packet -> payload ; msg -> type = packet -> type ; msg -> sftp = sftp ; msg -> complete_message = ssh_buffer_new ( ) ; if ( msg -> complete_message == NULL ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } <S2SV_StartBug> ssh_buffer_add_data ( msg -> complete_message , <S2SV_EndBug> ssh_buffer_get ( payload ) , <S2SV_StartBug> ssh_buffer_get_len ( payload ) ) ; <S2SV_EndBug> ssh_buffer_get_u32 ( payload , & msg -> id ) ; switch ( msg -> type ) { case SSH_FXP_CLOSE : case SSH_FXP_READDIR : msg -> handle = ssh_buffer_get_ssh_string ( payload ) ; if ( msg -> handle == NULL ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_READ : rc = ssh_buffer_unpack ( payload , \"Sqd\" , & msg -> handle , & msg -> offset , & msg -> len ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_WRITE : rc = ssh_buffer_unpack ( payload , \"SqS\" , & msg -> handle , & msg -> offset , & msg -> data ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_REMOVE : case SSH_FXP_RMDIR : case SSH_FXP_OPENDIR : case SSH_FXP_READLINK : case SSH_FXP_REALPATH : rc = ssh_buffer_unpack ( payload , \"s\" , & msg -> filename ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_RENAME : case SSH_FXP_SYMLINK : rc = ssh_buffer_unpack ( payload , \"sS\" , & msg -> filename , & msg -> data ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_MKDIR : case SSH_FXP_SETSTAT : rc = ssh_buffer_unpack ( payload , \"s\" , & msg -> filename ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } msg -> attr = sftp_parse_attr ( sftp , payload , 0 ) ; if ( msg -> attr == NULL ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_FSETSTAT : msg -> handle = ssh_buffer_get_ssh_string ( payload ) ; if ( msg -> handle == NULL ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } msg -> attr = sftp_parse_attr ( sftp , payload , 0 ) ; if ( msg -> attr == NULL ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_LSTAT : case SSH_FXP_STAT : rc = ssh_buffer_unpack ( payload , \"s\" , & msg -> filename ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } if ( sftp -> version > 3 ) { ssh_buffer_unpack ( payload , \"d\" , & msg -> flags ) ; } break ; case SSH_FXP_OPEN : rc = ssh_buffer_unpack ( payload , \"sd\" , & msg -> filename , & msg -> flags ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } msg -> attr = sftp_parse_attr ( sftp , payload , 0 ) ; if ( msg -> attr == NULL ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_FSTAT : rc = ssh_buffer_unpack ( payload , \"S\" , & msg -> handle ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } break ; case SSH_FXP_EXTENDED : rc = ssh_buffer_unpack ( payload , \"s\" , & msg -> submessage ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } if ( strcmp ( msg -> submessage , \"hardlink@openssh.com\" ) == 0 || strcmp ( msg -> submessage , \"posix-rename@openssh.com\" ) == 0 ) { rc = ssh_buffer_unpack ( payload , \"sS\" , & msg -> filename , & msg -> data ) ; if ( rc != SSH_OK ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; } } break ; default : ssh_set_error ( sftp -> session , SSH_FATAL , \"Received<S2SV_blank>unhandled<S2SV_blank>sftp<S2SV_blank>message<S2SV_blank>%d\" , msg -> type ) ; sftp_client_message_free ( msg ) ; return NULL ; } return msg ; }", "target": "<S2SV_ModStart> NULL ; } rc = <S2SV_ModStart> ) ) ; if ( rc < 0 ) { ssh_set_error_oom ( session ) ; sftp_client_message_free ( msg ) ; return NULL ; }"}
{"source": "CWE-787 <S2SV_StartBug> static int changedline ( const Proto * p , int oldpc , int newpc ) { <S2SV_EndBug> while ( oldpc ++ < newpc ) { if ( p -> lineinfo [ oldpc ] != 0 ) return ( luaG_getfuncline ( p , oldpc - 1 ) != luaG_getfuncline ( p , newpc ) ) ; } return 0 ; }", "target": "<S2SV_ModStart> newpc ) { if ( p -> lineinfo == NULL ) return 0 ;"}
{"source": "CWE-824 int init_aliases ( void ) { FILE * fp ; char alias [ MAXALIASLEN + 1U ] ; char dir [ PATH_MAX + 1U ] ; if ( ( fp = fopen ( ALIASES_FILE , \"r\" ) ) == NULL ) { return 0 ; } while ( fgets ( alias , sizeof alias , fp ) != NULL ) { if ( * alias == '#' || * alias == '\\\\n' || * alias == 0 ) { continue ; } { char * const z = alias + strlen ( alias ) - 1U ; if ( * z != '\\\\n' ) { goto bad ; } * z = 0 ; } do { if ( fgets ( dir , sizeof dir , fp ) == NULL || * dir == 0 ) { goto bad ; } { char * const z = dir + strlen ( dir ) - 1U ; if ( * z == '\\\\n' ) { * z = 0 ; } } } while ( * dir == '#' || * dir == 0 ) ; if ( head == NULL ) { if ( ( head = tail = malloc ( sizeof * head ) ) == NULL || ( tail -> alias = strdup ( alias ) ) == NULL || ( tail -> dir = strdup ( dir ) ) == NULL ) { die_mem ( ) ; } <S2SV_StartBug> tail -> next = NULL ; <S2SV_EndBug> } else { DirAlias * curr ; if ( ( curr = malloc ( sizeof * curr ) ) == NULL || ( curr -> alias = strdup ( alias ) ) == NULL || ( curr -> dir = strdup ( dir ) ) == NULL ) { die_mem ( ) ; } <S2SV_StartBug> tail -> next = curr ; <S2SV_EndBug> tail = curr ; } } fclose ( fp ) ; aliases_up ++ ; return 0 ; bad : fclose ( fp ) ; logfile ( LOG_ERR , MSG_ALIASES_BROKEN_FILE \"<S2SV_blank>[\" ALIASES_FILE \"]\" ) ; return - 1 ; }", "target": "<S2SV_ModStart> ) ; } } else { DirAlias * curr ; if ( ( curr = malloc ( sizeof * curr ) ) == NULL || ( curr -> alias = strdup ( alias ) ) == NULL || ( curr -> dir = strdup ( dir ) ) == NULL ) { die_mem ( ) ; } <S2SV_ModStart> -> next = curr ; tail = curr <S2SV_ModEnd> ; } tail <S2SV_ModStart> -> next = NULL ; <S2SV_ModEnd> } fclose ("}
{"source": "CWE-119 PHP_FUNCTION ( enchant_broker_request_dict ) { zval * broker ; enchant_broker * pbroker ; enchant_dict * dict ; EnchantDict * d ; char * tag ; int taglen ; int pos ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"rs\" , & broker , & tag , & taglen ) == FAILURE ) { RETURN_FALSE ; } PHP_ENCHANT_GET_BROKER ; if ( taglen == 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Tag<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>empty\" ) ; RETURN_FALSE ; } d = enchant_broker_request_dict ( pbroker -> pbroker , ( const char * ) tag ) ; if ( d ) { <S2SV_StartBug> if ( pbroker -> dictcnt ) { <S2SV_EndBug> pbroker -> dict = ( enchant_dict * * ) erealloc ( pbroker -> dict , sizeof ( enchant_dict * ) * pbroker -> dictcnt ) ; pos = pbroker -> dictcnt ++ ; <S2SV_StartBug> } else { <S2SV_EndBug> pbroker -> dict = ( enchant_dict * * ) emalloc ( sizeof ( enchant_dict * ) ) ; <S2SV_StartBug> pos = 0 ; <S2SV_EndBug> pbroker -> dictcnt ++ ; } dict = pbroker -> dict [ pos ] = ( enchant_dict * ) emalloc ( sizeof ( enchant_dict ) ) ; dict -> id = pos ; dict -> pbroker = pbroker ; dict -> pdict = d ; dict -> prev = pos ? pbroker -> dict [ pos - 1 ] : NULL ; dict -> next = NULL ; pbroker -> dict [ pos ] = dict ; if ( pos ) { pbroker -> dict [ pos - 1 ] -> next = dict ; } dict -> rsrc_id = ZEND_REGISTER_RESOURCE ( return_value , dict , le_enchant_dict ) ; zend_list_addref ( pbroker -> rsrc_id ) ; } else { RETURN_FALSE ; } }", "target": "<S2SV_ModStart> d ) { <S2SV_ModEnd> pos = pbroker <S2SV_ModStart> dictcnt ++ ; if ( pbroker -> dictcnt ) { pbroker -> dict = ( enchant_dict * * ) erealloc ( pbroker -> dict , sizeof ( enchant_dict * ) * pbroker -> dictcnt ) ; <S2SV_ModStart> pos = 0 <S2SV_ModEnd> ; } dict"}
{"source": "CWE-22 check_tty ( const char * tty ) { if ( ( tty == NULL ) || ( strlen ( tty ) == 0 ) ) { return NULL ; } if ( strchr ( tty , '/' ) != NULL ) { if ( strncmp ( tty , \"/dev/\" , 5 ) != 0 ) { return NULL ; } tty = strrchr ( tty , '/' ) + 1 ; } <S2SV_StartBug> if ( strlen ( tty ) == 0 ) { <S2SV_EndBug> return NULL ; } return tty ; }", "target": "<S2SV_ModStart> } if ( ! <S2SV_ModStart> ( tty ) || ! strcmp ( tty , \".\" ) || ! strcmp ( tty , \"..\" ) <S2SV_ModEnd> ) { return"}
{"source": "CWE-22 get_ruser ( pam_handle_t * pamh , char * ruserbuf , size_t ruserbuflen ) { const void * ruser ; struct passwd * pwd ; if ( ruserbuf == NULL || ruserbuflen < 1 ) return - 2 ; if ( pam_get_item ( pamh , PAM_RUSER , & ruser ) != PAM_SUCCESS ) { ruser = NULL ; } if ( ( ruser == NULL ) || ( strlen ( ruser ) == 0 ) ) { pwd = pam_modutil_getpwuid ( pamh , getuid ( ) ) ; if ( pwd != NULL ) { ruser = pwd -> pw_name ; } <S2SV_StartBug> } <S2SV_EndBug> if ( ruser == NULL || strlen ( ruser ) >= ruserbuflen ) { * ruserbuf = '\\\\0' ; return - 1 ; } strcpy ( ruserbuf , ruser ) ; return 0 ; }", "target": "<S2SV_ModStart> ; } } else { if ( ! strcmp ( ruser , \".\" ) || ! strcmp ( ruser , \"..\" ) || strchr ( ruser , '/' ) ) { ruser = NULL ; } }"}
{"source": "CWE-20 int ma_read_ok_packet ( MYSQL * mysql , uchar * pos , ulong length ) { <S2SV_StartBug> size_t item_len ; <S2SV_EndBug> mysql -> affected_rows = net_field_length_ll ( & pos ) ; mysql -> insert_id = net_field_length_ll ( & pos ) ; mysql -> server_status = uint2korr ( pos ) ; pos += 2 ; mysql -> warning_count = uint2korr ( pos ) ; pos += 2 ; <S2SV_StartBug> if ( pos < mysql -> net . read_pos + length ) <S2SV_EndBug> { if ( ( item_len = net_field_length ( & pos ) ) ) <S2SV_StartBug> mysql -> info = ( char * ) pos ; <S2SV_EndBug> if ( mysql -> server_capabilities & CLIENT_SESSION_TRACKING ) { ma_clear_session_state ( mysql ) ; pos += item_len ; if ( mysql -> server_status & SERVER_SESSION_STATE_CHANGED ) { int i ; <S2SV_StartBug> if ( pos < mysql -> net . read_pos + length ) <S2SV_EndBug> { LIST * session_item ; MYSQL_LEX_STRING * str = NULL ; enum enum_session_state_type si_type ; uchar * old_pos = pos ; <S2SV_StartBug> size_t item_len = net_field_length ( & pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mysql -> info ) <S2SV_EndBug> * old_pos = 0 ; while ( item_len > 0 ) { size_t plen ; <S2SV_StartBug> char * data ; <S2SV_EndBug> old_pos = pos ; si_type = ( enum enum_session_state_type ) net_field_length ( & pos ) ; switch ( si_type ) { case SESSION_TRACK_SCHEMA : case SESSION_TRACK_STATE_CHANGE : case SESSION_TRACK_TRANSACTION_CHARACTERISTICS : case SESSION_TRACK_SYSTEM_VARIABLES : if ( si_type != SESSION_TRACK_STATE_CHANGE ) net_field_length ( & pos ) ; plen = net_field_length ( & pos ) ; <S2SV_StartBug> if ( ! ( session_item = ma_multi_malloc ( 0 , <S2SV_EndBug> & session_item , sizeof ( LIST ) , & str , sizeof ( MYSQL_LEX_STRING ) , & data , plen , NULL ) ) ) <S2SV_StartBug> { <S2SV_EndBug> ma_clear_session_state ( mysql ) ; SET_CLIENT_ERROR ( mysql , CR_OUT_OF_MEMORY , SQLSTATE_UNKNOWN , 0 ) ; return - 1 ; <S2SV_StartBug> } <S2SV_EndBug> str -> length = plen ; str -> str = data ; memcpy ( str -> str , ( char * ) pos , plen ) ; pos += plen ; session_item -> data = str ; mysql -> extension -> session_state [ si_type ] . list = list_add ( mysql -> extension -> session_state [ si_type ] . list , session_item ) ; if ( si_type == SESSION_TRACK_SCHEMA ) { free ( mysql -> db ) ; mysql -> db = malloc ( plen + 1 ) ; memcpy ( mysql -> db , str -> str , plen ) ; mysql -> db [ plen ] = 0 ; } else if ( si_type == SESSION_TRACK_SYSTEM_VARIABLES ) { my_bool set_charset = 0 ; if ( ! strncmp ( str -> str , \"character_set_client\" , str -> length ) ) set_charset = 1 ; plen = net_field_length ( & pos ) ; if ( ! ( session_item = ma_multi_malloc ( 0 , & session_item , sizeof ( LIST ) , & str , sizeof ( MYSQL_LEX_STRING ) , & data , plen , NULL ) ) ) { ma_clear_session_state ( mysql ) ; <S2SV_StartBug> SET_CLIENT_ERROR ( mysql , CR_OUT_OF_MEMORY , SQLSTATE_UNKNOWN , 0 ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> str -> length = plen ; <S2SV_EndBug> str -> str = data ; memcpy ( str -> str , ( char * ) pos , plen ) ; pos += plen ; session_item -> data = str ; mysql -> extension -> session_state [ si_type ] . list = list_add ( mysql -> extension -> session_state [ si_type ] . list , session_item ) ; if ( set_charset && strncmp ( mysql -> charset -> csname , str -> str , str -> length ) != 0 ) { char cs_name [ 64 ] ; MARIADB_CHARSET_INFO * cs_info ; memcpy ( cs_name , str -> str , str -> length ) ; cs_name [ str -> length ] = 0 ; if ( ( cs_info = ( MARIADB_CHARSET_INFO * ) mysql_find_charset_name ( cs_name ) ) ) mysql -> charset = cs_info ; } } break ; default : plen = net_field_length ( & pos ) ; pos += plen ; break ; } item_len -= ( pos - old_pos ) ; } } for ( i = SESSION_TRACK_BEGIN ; i <= SESSION_TRACK_END ; i ++ ) { mysql -> extension -> session_state [ i ] . list = list_reverse ( mysql -> extension -> session_state [ i ] . list ) ; mysql -> extension -> session_state [ i ] . current = mysql -> extension -> session_state [ i ] . list ; } } } } else if ( mysql -> server_capabilities & CLIENT_SESSION_TRACKING ) ma_clear_session_state ( mysql ) ; return ( 0 ) ; }", "target": "<S2SV_ModStart> length ) { uchar * end = <S2SV_ModEnd> mysql -> net <S2SV_ModStart> read_pos + length ; size_t item_len ; mysql -> affected_rows = net_field_length_ll ( & pos ) ; mysql -> insert_id = net_field_length_ll ( & pos ) ; mysql -> server_status = uint2korr ( pos ) ; pos += 2 ; mysql -> warning_count = uint2korr ( pos ) ; pos += 2 ; if ( pos > end ) goto corrupted ; if ( pos < end ) { if ( ( item_len <S2SV_ModEnd> = net_field_length ( <S2SV_ModStart> * ) pos ; if ( pos + item_len > end ) goto corrupted <S2SV_ModStart> ( pos < end <S2SV_ModEnd> ) { LIST <S2SV_ModStart> = pos ; <S2SV_ModEnd> item_len = net_field_length <S2SV_ModStart> pos ) ; if ( pos + item_len > end ) goto corrupted ; end = pos + item_len ; if ( mysql -> info ) * old_pos = 0 ; while ( pos < end <S2SV_ModEnd> ) { size_t <S2SV_ModStart> char * data <S2SV_ModEnd> ; si_type = <S2SV_ModStart> ; if ( pos + plen > end ) goto corrupted ; if ( <S2SV_ModStart> ) ) ) goto oom ; str -> length = plen ; str -> str = data ; memcpy ( str -> str , ( char * ) pos , plen ) ; pos += plen ; session_item -> data = str ; mysql -> extension -> session_state [ si_type ] . list = list_add ( mysql -> extension -> session_state [ si_type ] . list , session_item ) ; if ( si_type == SESSION_TRACK_SCHEMA ) { free ( mysql -> db ) ; mysql -> db = malloc ( plen + 1 ) ; memcpy ( mysql -> db , str -> str , plen ) ; mysql -> db [ plen ] = 0 ; } else if ( si_type == SESSION_TRACK_SYSTEM_VARIABLES ) { my_bool set_charset = 0 ; if ( ! strncmp ( str -> str , \"character_set_client\" , str -> length ) ) set_charset = 1 ; plen = net_field_length ( & pos ) ; if ( pos + plen > end ) goto corrupted ; if ( ! ( session_item = ma_multi_malloc ( 0 , & session_item , sizeof ( LIST ) , & str , sizeof ( MYSQL_LEX_STRING ) , & data , plen , NULL ) ) ) goto oom ; str -> length = plen ; str -> str = data ; memcpy ( str -> str , ( char * ) pos , plen ) ; pos += plen ; session_item -> data = str ; mysql -> extension -> session_state [ si_type ] . list = list_add ( mysql -> extension -> session_state [ si_type ] . list , session_item ) ; if ( set_charset && str -> length < CHARSET_NAME_LEN && strncmp ( mysql -> charset -> csname , str -> str , str -> length ) != 0 ) { char cs_name [ CHARSET_NAME_LEN ] ; const MARIADB_CHARSET_INFO * cs_info ; memcpy ( cs_name , str -> str , str -> length ) ; cs_name [ str -> length ] = 0 ; if ( ( cs_info = mysql_find_charset_name ( cs_name ) ) ) mysql -> charset = cs_info ; } } break ; default : plen = net_field_length ( & pos ) ; if ( pos + plen > end ) goto corrupted ; pos += plen ; break ; } } } for ( i = SESSION_TRACK_BEGIN ; i <= SESSION_TRACK_END ; i ++ ) { mysql -> extension -> session_state [ i ] . list = list_reverse ( mysql -> extension -> session_state [ i ] . list ) ; mysql -> extension -> session_state [ i ] . current = mysql -> extension -> session_state [ i ] . list ; } } } } else if ( mysql -> server_capabilities & CLIENT_SESSION_TRACKING ) ma_clear_session_state ( mysql ) ; return ( 0 ) ; oom : <S2SV_ModEnd> ma_clear_session_state ( mysql <S2SV_ModStart> - 1 ; corrupted : <S2SV_ModEnd> ma_clear_session_state ( mysql <S2SV_ModStart> ( mysql , CR_MALFORMED_PACKET <S2SV_ModEnd> , SQLSTATE_UNKNOWN , <S2SV_ModStart> 1 ; } <S2SV_ModEnd>  <S2SV_null> <S2SV_null>"}
{"source": "CWE-190 UnicodeString : : doAppend ( const UChar * srcChars , int32_t srcStart , int32_t srcLength ) { if ( ! isWritable ( ) || srcLength == 0 || srcChars == NULL ) { return * this ; } srcChars += srcStart ; if ( srcLength < 0 ) { if ( ( srcLength = u_strlen ( srcChars ) ) == 0 ) { return * this ; } } int32_t oldLength = length ( ) ; <S2SV_StartBug> int32_t newLength = oldLength + srcLength ; <S2SV_EndBug> const UChar * oldArray = getArrayStart ( ) ; if ( isBufferWritable ( ) && oldArray < srcChars + srcLength && srcChars < oldArray + oldLength ) { UnicodeString copy ( srcChars , srcLength ) ; if ( copy . isBogus ( ) ) { setToBogus ( ) ; return * this ; } return doAppend ( copy . getArrayStart ( ) , 0 , srcLength ) ; } if ( ( newLength <= getCapacity ( ) && isBufferWritable ( ) ) || cloneArrayIfNeeded ( newLength , getGrowCapacity ( newLength ) ) ) { UChar * newArray = getArrayStart ( ) ; if ( srcChars != newArray + oldLength ) { us_arrayCopy ( srcChars , 0 , newArray , oldLength , srcLength ) ; } setLength ( newLength ) ; } return * this ; }", "target": "<S2SV_ModStart> ; int32_t newLength ; if ( uprv_add32_overflow ( oldLength , srcLength , & newLength ) ) { setToBogus ( ) ; return * this ; } <S2SV_ModEnd> const UChar *"}
{"source": "CWE-787 static int decode_attr_security_label ( struct xdr_stream * xdr , uint32_t * bitmap , struct nfs4_label * label ) { uint32_t pi = 0 ; uint32_t lfs = 0 ; __u32 len ; __be32 * p ; int status = 0 ; if ( unlikely ( bitmap [ 2 ] & ( FATTR4_WORD2_SECURITY_LABEL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 2 ] & FATTR4_WORD2_SECURITY_LABEL ) ) { p = xdr_inline_decode ( xdr , 4 ) ; if ( unlikely ( ! p ) ) return - EIO ; lfs = be32_to_cpup ( p ++ ) ; p = xdr_inline_decode ( xdr , 4 ) ; if ( unlikely ( ! p ) ) return - EIO ; pi = be32_to_cpup ( p ++ ) ; p = xdr_inline_decode ( xdr , 4 ) ; if ( unlikely ( ! p ) ) return - EIO ; len = be32_to_cpup ( p ++ ) ; p = xdr_inline_decode ( xdr , len ) ; if ( unlikely ( ! p ) ) return - EIO ; if ( len < NFS4_MAXLABELLEN ) { if ( label ) { <S2SV_StartBug> memcpy ( label -> label , p , len ) ; <S2SV_EndBug> label -> len = len ; label -> pi = pi ; label -> lfs = lfs ; status = NFS_ATTR_FATTR_V4_SECURITY_LABEL ; } bitmap [ 2 ] &= ~ FATTR4_WORD2_SECURITY_LABEL ; } else printk ( KERN_WARNING \"%s:<S2SV_blank>label<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u)!\\\\n\" , __func__ , len ) ; } if ( label && label -> label ) dprintk ( \"%s:<S2SV_blank>label=%s,<S2SV_blank>len=%d,<S2SV_blank>PI=%d,<S2SV_blank>LFS=%d\\\\n\" , __func__ , ( char * ) label -> label , label -> len , label -> pi , label -> lfs ) ; return status ; }", "target": "<S2SV_ModStart> label ) { if ( label -> len ) { if ( label -> len < len ) return - ERANGE ; <S2SV_ModStart> len ) ; }"}
{"source": "CWE-125 static void hci_extended_inquiry_result_evt ( struct hci_dev * hdev , struct sk_buff * skb ) { struct inquiry_data data ; struct extended_inquiry_info * info = ( void * ) ( skb -> data + 1 ) ; int num_rsp = * ( ( __u8 * ) skb -> data ) ; size_t eir_len ; BT_DBG ( \"%s<S2SV_blank>num_rsp<S2SV_blank>%d\" , hdev -> name , num_rsp ) ; <S2SV_StartBug> if ( ! num_rsp ) <S2SV_EndBug> return ; if ( hci_dev_test_flag ( hdev , HCI_PERIODIC_INQ ) ) return ; hci_dev_lock ( hdev ) ; for ( ; num_rsp ; num_rsp -- , info ++ ) { u32 flags ; bool name_known ; bacpy ( & data . bdaddr , & info -> bdaddr ) ; data . pscan_rep_mode = info -> pscan_rep_mode ; data . pscan_period_mode = info -> pscan_period_mode ; data . pscan_mode = 0x00 ; memcpy ( data . dev_class , info -> dev_class , 3 ) ; data . clock_offset = info -> clock_offset ; data . rssi = info -> rssi ; data . ssp_mode = 0x01 ; if ( hci_dev_test_flag ( hdev , HCI_MGMT ) ) name_known = eir_get_data ( info -> data , sizeof ( info -> data ) , EIR_NAME_COMPLETE , NULL ) ; else name_known = true ; flags = hci_inquiry_cache_update ( hdev , & data , name_known ) ; eir_len = eir_get_length ( info -> data , sizeof ( info -> data ) ) ; mgmt_device_found ( hdev , & info -> bdaddr , ACL_LINK , 0x00 , info -> dev_class , info -> rssi , flags , info -> data , eir_len , NULL , 0 ) ; } hci_dev_unlock ( hdev ) ; }", "target": "<S2SV_ModStart> ( ! num_rsp || skb -> len < num_rsp * sizeof ( * info ) + 1"}
{"source": "CWE-401 static int svm_cpu_init ( int cpu ) { <S2SV_StartBug> struct svm_cpu_data * sd ; <S2SV_EndBug> int r ; sd = kzalloc ( sizeof ( struct svm_cpu_data ) , GFP_KERNEL ) ; if ( ! sd ) return - ENOMEM ; sd -> cpu = cpu ; <S2SV_StartBug> r = - ENOMEM ; <S2SV_EndBug> sd -> save_area = alloc_page ( GFP_KERNEL ) ; if ( ! sd -> save_area ) <S2SV_StartBug> goto err_1 ; <S2SV_EndBug> if ( svm_sev_enabled ( ) ) { <S2SV_StartBug> r = - ENOMEM ; <S2SV_EndBug> sd -> sev_vmcbs = kmalloc_array ( max_sev_asid + 1 , sizeof ( void * ) , GFP_KERNEL ) ; if ( ! sd -> sev_vmcbs ) <S2SV_StartBug> goto err_1 ; <S2SV_EndBug> } per_cpu ( svm_data , cpu ) = sd ; return 0 ; <S2SV_StartBug> err_1 : <S2SV_EndBug> kfree ( sd ) ; <S2SV_StartBug> return r ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> svm_cpu_data * sd <S2SV_ModEnd> ; sd = <S2SV_ModStart> = cpu ; <S2SV_ModEnd> sd -> save_area <S2SV_ModStart> save_area ) goto free_cpu_data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> sd -> sev_vmcbs <S2SV_ModStart> sev_vmcbs ) goto free_save_area <S2SV_ModEnd> ; } per_cpu <S2SV_ModStart> return 0 ; free_save_area : __free_page ( sd -> save_area ) ; free_cpu_data <S2SV_ModEnd> : kfree ( <S2SV_ModStart> ) ; return - ENOMEM <S2SV_ModEnd> ; }"}
{"source": "CWE-703 BOOL glyph_cache_put ( rdpGlyphCache * glyphCache , UINT32 id , UINT32 index , rdpGlyph * glyph ) { rdpGlyph * prevGlyph ; if ( id > 9 ) { WLog_ERR ( TAG , \"invalid<S2SV_blank>glyph<S2SV_blank>cache<S2SV_blank>id:<S2SV_blank>%\" PRIu32 \"\" , id ) ; return FALSE ; } <S2SV_StartBug> if ( index > glyphCache -> glyphCache [ id ] . number ) <S2SV_EndBug> { WLog_ERR ( TAG , \"invalid<S2SV_blank>glyph<S2SV_blank>cache<S2SV_blank>index:<S2SV_blank>%\" PRIu32 \"<S2SV_blank>in<S2SV_blank>cache<S2SV_blank>id:<S2SV_blank>%\" PRIu32 \"\" , index , id ) ; return FALSE ; } WLog_Print ( glyphCache -> log , WLOG_DEBUG , \"GlyphCachePut:<S2SV_blank>id:<S2SV_blank>%\" PRIu32 \"<S2SV_blank>index:<S2SV_blank>%\" PRIu32 \"\" , id , index ) ; prevGlyph = glyphCache -> glyphCache [ id ] . entries [ index ] ; if ( prevGlyph ) prevGlyph -> Free ( glyphCache -> context , prevGlyph ) ; glyphCache -> glyphCache [ id ] . entries [ index ] = glyph ; return TRUE ; }", "target": "<S2SV_ModStart> if ( index >= <S2SV_ModEnd> glyphCache -> glyphCache"}
{"source": "CWE-125 static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; <S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , \"received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU\" ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }", "target": "<S2SV_ModStart> , \"received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU\" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1"}
{"source": "CWE-125 static PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf ( jit_arguments * args , PCRE2_SPTR cc ) { PCRE2_SPTR start_subject = args -> begin ; PCRE2_SPTR end_subject = args -> end ; int lgb , rgb , ricount ; PCRE2_SPTR bptr ; uint32_t c ; <S2SV_StartBug> GETCHARINC ( c , cc ) ; <S2SV_EndBug> lgb = UCD_GRAPHBREAK ( c ) ; while ( cc < end_subject ) { c = * cc ; rgb = UCD_GRAPHBREAK ( c ) ; if ( ( PRIV ( ucp_gbtable ) [ lgb ] & ( 1 << rgb ) ) == 0 ) break ; if ( lgb == ucp_gbRegionalIndicator && rgb == ucp_gbRegionalIndicator ) { ricount = 0 ; bptr = cc - 1 ; while ( bptr > start_subject ) { bptr -- ; c = * bptr ; if ( UCD_GRAPHBREAK ( c ) != ucp_gbRegionalIndicator ) break ; ricount ++ ; } if ( ( ricount & 1 ) != 0 ) break ; } if ( ( rgb != ucp_gbExtend && rgb != ucp_gbZWJ ) || lgb != ucp_gbExtended_Pictographic ) lgb = rgb ; cc ++ ; } return cc ; }", "target": "<S2SV_ModStart> uint32_t c ; c = * cc ++ <S2SV_ModEnd> ; lgb ="}
{"source": "CWE-400 static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , \"NotAVIFFImage\" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; if ( count != 512 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; viff_info . comment [ 511 ] = '\\\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , \"comment\" , viff_info . comment ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ; <S2SV_EndBug> image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_StartBug> ( void ) SetImageBackgroundColor ( image ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , \"ImageColumnOrRowSizeIsNotSupported\" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , \"DataStorageTypeIsNotSupported\" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , \"DataEncodingSchemeIsNotSupported\" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , \"MapStorageTypeIsNotSupported\" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , \"ColorspaceModelIsNotSupported\" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , \"LocationTypeIsNotSupported\" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , \"NumberOfImagesIsNotSupported\" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( ( MagickSizeType ) ( viff_info . map_rows * image -> colors ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( ( MagickSizeType ) viff_info . map_rows > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ( MagickSizeType ) viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , \"ColormapTypeNotSupported\" ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { image -> colors = 2 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; image -> colorspace = GRAYColorspace ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( HeapOverflowSanityCheck ( ( size_t ) number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } if ( ( MagickSizeType ) ( bytes_per_pixel * max_packets ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( pixels , 0 , MagickMax ( number_pixels , max_packets ) * bytes_per_pixel * sizeof ( * pixels ) ) ; ( void ) ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( MagickRealType ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( MagickRealType ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( image -> storage_class != PseudoClass ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * ( p + number_pixels ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index ) ] . red ) ; index = ( ssize_t ) GetPixelGreen ( q ) ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index ) ] . green ) ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index ) ] . blue ) ; } SetPixelOpacity ( q , image -> matte != MagickFalse ? QuantumRange - ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueOpacity ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> CorruptImageError , \"UnexpectedEndOfFile\" ) ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( number_pixels > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , \"ImageColumnOrRowSizeIsNotSupported\" <S2SV_ModStart> SetImageBackgroundColor ( image <S2SV_ModEnd> ) ; if"}
{"source": "CWE-665 MagickExport Image * AcquireImage ( const ImageInfo * image_info ) { const char * option ; Image * image ; MagickStatusType flags ; ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"...\" ) ; image = ( Image * ) AcquireCriticalMemory ( sizeof ( * image ) ) ; ( void ) memset ( image , 0 , sizeof ( * image ) ) ; ( void ) CopyMagickString ( image -> magick , \"MIFF\" , MaxTextExtent ) ; image -> storage_class = DirectClass ; image -> depth = MAGICKCORE_QUANTUM_DEPTH ; image -> colorspace = sRGBColorspace ; image -> rendering_intent = PerceptualIntent ; image -> gamma = 1.000f / 2.200f ; image -> chromaticity . red_primary . x = 0.6400f ; image -> chromaticity . red_primary . y = 0.3300f ; image -> chromaticity . red_primary . z = 0.0300f ; image -> chromaticity . green_primary . x = 0.3000f ; image -> chromaticity . green_primary . y = 0.6000f ; image -> chromaticity . green_primary . z = 0.1000f ; image -> chromaticity . blue_primary . x = 0.1500f ; image -> chromaticity . blue_primary . y = 0.0600f ; image -> chromaticity . blue_primary . z = 0.7900f ; image -> chromaticity . white_point . x = 0.3127f ; image -> chromaticity . white_point . y = 0.3290f ; image -> chromaticity . white_point . z = 0.3583f ; image -> interlace = NoInterlace ; image -> ticks_per_second = UndefinedTicksPerSecond ; image -> compose = OverCompositeOp ; image -> blur = 1.0 ; InitializeExceptionInfo ( & image -> exception ) ; ( void ) QueryColorDatabase ( BackgroundColor , & image -> background_color , & image -> exception ) ; ( void ) QueryColorDatabase ( BorderColor , & image -> border_color , & image -> exception ) ; ( void ) QueryColorDatabase ( MatteColor , & image -> matte_color , & image -> exception ) ; ( void ) QueryColorDatabase ( TransparentColor , & image -> transparent_color , & image -> exception ) ; GetTimerInfo ( & image -> timer ) ; image -> ping = MagickFalse ; image -> cache = AcquirePixelCache ( 0 ) ; image -> blob = CloneBlobInfo ( ( BlobInfo * ) NULL ) ; image -> timestamp = time ( ( time_t * ) NULL ) ; image -> debug = IsEventLogging ( ) ; image -> reference_count = 1 ; image -> semaphore = AllocateSemaphoreInfo ( ) ; image -> signature = MagickCoreSignature ; if ( image_info == ( ImageInfo * ) NULL ) return ( image ) ; SetBlobExempt ( image , image_info -> file != ( FILE * ) NULL ? MagickTrue : MagickFalse ) ; ( void ) CopyMagickString ( image -> filename , image_info -> filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image -> magick , image_info -> magick , MaxTextExtent ) ; if ( image_info -> size != ( char * ) NULL ) { ( void ) ParseAbsoluteGeometry ( image_info -> size , & image -> extract_info ) ; image -> columns = image -> extract_info . width ; image -> rows = image -> extract_info . height ; image -> offset = image -> extract_info . x ; image -> extract_info . x = 0 ; image -> extract_info . y = 0 ; } if ( image_info -> extract != ( char * ) NULL ) { RectangleInfo geometry ; ( void ) memset ( & geometry , 0 , sizeof ( geometry ) ) ; flags = ParseAbsoluteGeometry ( image_info -> extract , & geometry ) ; if ( ( ( flags & XValue ) != 0 ) || ( ( flags & YValue ) != 0 ) ) { image -> extract_info = geometry ; Swap ( image -> columns , image -> extract_info . width ) ; Swap ( image -> rows , image -> extract_info . height ) ; } } image -> compression = image_info -> compression ; image -> quality = image_info -> quality ; image -> endian = image_info -> endian ; image -> interlace = image_info -> interlace ; image -> units = image_info -> units ; if ( image_info -> density != ( char * ) NULL ) { GeometryInfo geometry_info ; flags = ParseGeometry ( image_info -> density , & geometry_info ) ; <S2SV_StartBug> image -> x_resolution = geometry_info . rho ; <S2SV_EndBug> <S2SV_StartBug> image -> y_resolution = geometry_info . sigma ; <S2SV_EndBug> if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> page != ( char * ) NULL ) { char * geometry ; image -> page = image -> extract_info ; geometry = GetPageGeometry ( image_info -> page ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; } if ( image_info -> depth != 0 ) image -> depth = image_info -> depth ; image -> dither = image_info -> dither ; image -> background_color = image_info -> background_color ; image -> border_color = image_info -> border_color ; image -> matte_color = image_info -> matte_color ; image -> transparent_color = image_info -> transparent_color ; image -> ping = image_info -> ping ; image -> progress_monitor = image_info -> progress_monitor ; image -> client_data = image_info -> client_data ; if ( image_info -> cache != ( void * ) NULL ) ClonePixelCacheMethods ( image -> cache , image_info -> cache ) ; ( void ) SyncImageSettings ( image_info , image ) ; option = GetImageOption ( image_info , \"delay\" ) ; if ( option != ( const char * ) NULL ) { GeometryInfo geometry_info ; flags = ParseGeometry ( option , & geometry_info ) ; if ( ( flags & GreaterValue ) != 0 ) { if ( image -> delay > ( size_t ) floor ( geometry_info . rho + 0.5 ) ) image -> delay = ( size_t ) floor ( geometry_info . rho + 0.5 ) ; } else if ( ( flags & LessValue ) != 0 ) { if ( image -> delay < ( size_t ) floor ( geometry_info . rho + 0.5 ) ) image -> ticks_per_second = ( ssize_t ) floor ( geometry_info . sigma + 0.5 ) ; } else image -> delay = ( size_t ) floor ( geometry_info . rho + 0.5 ) ; if ( ( flags & SigmaValue ) != 0 ) image -> ticks_per_second = ( ssize_t ) floor ( geometry_info . sigma + 0.5 ) ; } option = GetImageOption ( image_info , \"dispose\" ) ; if ( option != ( const char * ) NULL ) image -> dispose = ( DisposeType ) ParseCommandOption ( MagickDisposeOptions , MagickFalse , option ) ; return ( image ) ; }", "target": "<S2SV_ModStart> geometry_info ) ; if ( ( flags & RhoValue ) != 0 ) <S2SV_ModStart> -> y_resolution = image -> x_resolution ; if ( ( flags & SigmaValue ) != 0 ) image -> y_resolution = <S2SV_ModStart> geometry_info . sigma <S2SV_ModEnd> ; } if"}
{"source": "CWE-401 bfad_im_get_stats ( struct Scsi_Host * shost ) { struct bfad_im_port_s * im_port = ( struct bfad_im_port_s * ) shost -> hostdata [ 0 ] ; struct bfad_s * bfad = im_port -> bfad ; struct bfad_hal_comp fcomp ; union bfa_port_stats_u * fcstats ; struct fc_host_statistics * hstats ; bfa_status_t rc ; unsigned long flags ; fcstats = kzalloc ( sizeof ( union bfa_port_stats_u ) , GFP_KERNEL ) ; if ( fcstats == NULL ) return NULL ; hstats = & bfad -> link_stats ; init_completion ( & fcomp . comp ) ; spin_lock_irqsave ( & bfad -> bfad_lock , flags ) ; memset ( hstats , 0 , sizeof ( struct fc_host_statistics ) ) ; rc = bfa_port_get_stats ( BFA_FCPORT ( & bfad -> bfa ) , fcstats , bfad_hcb_comp , & fcomp ) ; spin_unlock_irqrestore ( & bfad -> bfad_lock , flags ) ; <S2SV_StartBug> if ( rc != BFA_STATUS_OK ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> <S2SV_EndBug> wait_for_completion ( & fcomp . comp ) ; hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ; hstats -> tx_frames = fcstats -> fc . tx_frames ; hstats -> tx_words = fcstats -> fc . tx_words ; hstats -> rx_frames = fcstats -> fc . rx_frames ; hstats -> rx_words = fcstats -> fc . rx_words ; hstats -> lip_count = fcstats -> fc . lip_count ; hstats -> nos_count = fcstats -> fc . nos_count ; hstats -> error_frames = fcstats -> fc . error_frames ; hstats -> dumped_frames = fcstats -> fc . dropped_frames ; hstats -> link_failure_count = fcstats -> fc . link_failures ; hstats -> loss_of_sync_count = fcstats -> fc . loss_of_syncs ; hstats -> loss_of_signal_count = fcstats -> fc . loss_of_signals ; hstats -> prim_seq_protocol_err_count = fcstats -> fc . primseq_errs ; hstats -> invalid_crc_count = fcstats -> fc . invalid_crcs ; kfree ( fcstats ) ; return hstats ; }", "target": "<S2SV_ModStart> != BFA_STATUS_OK ) { kfree ( fcstats ) ; <S2SV_ModStart> return NULL ; }"}
{"source": "CWE-125 ldns_rr_new_frm_str_internal ( ldns_rr * * newrr , const char * str , uint32_t default_ttl , const ldns_rdf * origin , ldns_rdf * * prev , bool question ) { ldns_rr * new ; const ldns_rr_descriptor * desc ; ldns_rr_type rr_type ; ldns_buffer * rr_buf = NULL ; ldns_buffer * rd_buf = NULL ; uint32_t ttl_val ; char * owner = NULL ; char * ttl = NULL ; ldns_rr_class clas_val ; char * clas = NULL ; char * type = NULL ; size_t type_sz ; char * rdata = NULL ; char * rd = NULL ; char * xtok = NULL ; size_t rd_strlen ; const char * delimiters ; ssize_t c ; ldns_rdf * owner_dname ; const char * endptr ; int was_unknown_rr_format = 0 ; ldns_status status = LDNS_STATUS_OK ; bool done ; bool quoted ; ldns_rdf * r = NULL ; uint16_t r_cnt ; uint16_t r_min ; uint16_t r_max ; size_t pre_data_pos ; uint16_t hex_data_size ; char * hex_data_str = NULL ; uint16_t cur_hex_data_size ; size_t hex_pos = 0 ; uint8_t * hex_data = NULL ; new = ldns_rr_new ( ) ; owner = LDNS_XMALLOC ( char , LDNS_MAX_DOMAINLEN + 1 ) ; ttl = LDNS_XMALLOC ( char , LDNS_TTL_DATALEN ) ; clas = LDNS_XMALLOC ( char , LDNS_SYNTAX_DATALEN ) ; rdata = LDNS_XMALLOC ( char , LDNS_MAX_PACKETLEN + 1 ) ; rr_buf = LDNS_MALLOC ( ldns_buffer ) ; rd_buf = LDNS_MALLOC ( ldns_buffer ) ; rd = LDNS_XMALLOC ( char , LDNS_MAX_RDFLEN ) ; xtok = LDNS_XMALLOC ( char , LDNS_MAX_RDFLEN ) ; if ( rr_buf ) { rr_buf -> _data = NULL ; } if ( rd_buf ) { rd_buf -> _data = NULL ; } if ( ! new || ! owner || ! ttl || ! clas || ! rdata || ! rr_buf || ! rd_buf || ! rd || ! xtok ) { goto memerror ; } ldns_buffer_new_frm_data ( rr_buf , ( char * ) str , strlen ( str ) ) ; if ( ldns_bget_token ( rr_buf , owner , \"\\\\t\\\\n<S2SV_blank>\" , LDNS_MAX_DOMAINLEN ) == - 1 ) { status = LDNS_STATUS_SYNTAX_ERR ; goto error ; } if ( ldns_bget_token ( rr_buf , ttl , \"\\\\t\\\\n<S2SV_blank>\" , LDNS_TTL_DATALEN ) == - 1 ) { status = LDNS_STATUS_SYNTAX_TTL_ERR ; goto error ; } ttl_val = ( uint32_t ) ldns_str2period ( ttl , & endptr ) ; if ( strlen ( ttl ) > 0 && ! isdigit ( ( int ) ttl [ 0 ] ) ) { if ( default_ttl == 0 ) { ttl_val = LDNS_DEFAULT_TTL ; } else { ttl_val = default_ttl ; } clas_val = ldns_get_rr_class_by_name ( ttl ) ; if ( clas_val == 0 ) { clas_val = LDNS_RR_CLASS_IN ; type_sz = strlen ( ttl ) + 1 ; type = LDNS_XMALLOC ( char , type_sz ) ; if ( ! type ) { goto memerror ; } strlcpy ( type , ttl , type_sz ) ; } } else { if ( - 1 == ldns_bget_token ( rr_buf , clas , \"\\\\t\\\\n<S2SV_blank>\" , LDNS_SYNTAX_DATALEN ) ) { status = LDNS_STATUS_SYNTAX_CLASS_ERR ; goto error ; } clas_val = ldns_get_rr_class_by_name ( clas ) ; if ( clas_val == 0 ) { clas_val = LDNS_RR_CLASS_IN ; type_sz = strlen ( clas ) + 1 ; type = LDNS_XMALLOC ( char , type_sz ) ; if ( ! type ) { goto memerror ; } strlcpy ( type , clas , type_sz ) ; } } if ( ! type ) { type = LDNS_XMALLOC ( char , LDNS_SYNTAX_DATALEN ) ; if ( ! type ) { goto memerror ; } if ( - 1 == ldns_bget_token ( rr_buf , type , \"\\\\t\\\\n<S2SV_blank>\" , LDNS_SYNTAX_DATALEN ) ) { status = LDNS_STATUS_SYNTAX_TYPE_ERR ; goto error ; } } if ( ldns_bget_token ( rr_buf , rdata , \"\\\\0\" , LDNS_MAX_PACKETLEN ) == - 1 ) { } ldns_buffer_new_frm_data ( rd_buf , rdata , strlen ( rdata ) ) ; if ( strlen ( owner ) <= 1 && strncmp ( owner , \"@\" , 1 ) == 0 ) { if ( origin ) { ldns_rr_set_owner ( new , ldns_rdf_clone ( origin ) ) ; } else if ( prev && * prev ) { ldns_rr_set_owner ( new , ldns_rdf_clone ( * prev ) ) ; } else { ldns_rr_set_owner ( new , ldns_dname_new_frm_str ( \".\" ) ) ; } if ( prev ) { ldns_rdf_deep_free ( * prev ) ; * prev = ldns_rdf_clone ( ldns_rr_owner ( new ) ) ; if ( ! * prev ) { goto memerror ; } } } else { if ( strlen ( owner ) == 0 ) { if ( prev && * prev ) { ldns_rr_set_owner ( new , ldns_rdf_clone ( * prev ) ) ; } else if ( origin ) { ldns_rr_set_owner ( new , ldns_rdf_clone ( origin ) ) ; } else { ldns_rr_set_owner ( new , ldns_dname_new_frm_str ( \".\" ) ) ; } if ( ! ldns_rr_owner ( new ) ) { goto memerror ; } } else { owner_dname = ldns_dname_new_frm_str ( owner ) ; if ( ! owner_dname ) { status = LDNS_STATUS_SYNTAX_ERR ; goto error ; } ldns_rr_set_owner ( new , owner_dname ) ; if ( ! ldns_dname_str_absolute ( owner ) && origin ) { if ( ldns_dname_cat ( ldns_rr_owner ( new ) , origin ) != LDNS_STATUS_OK ) { status = LDNS_STATUS_SYNTAX_ERR ; goto error ; } } if ( prev ) { ldns_rdf_deep_free ( * prev ) ; * prev = ldns_rdf_clone ( ldns_rr_owner ( new ) ) ; if ( ! * prev ) { goto error ; } } } } LDNS_FREE ( owner ) ; ldns_rr_set_question ( new , question ) ; ldns_rr_set_ttl ( new , ttl_val ) ; LDNS_FREE ( ttl ) ; ldns_rr_set_class ( new , clas_val ) ; LDNS_FREE ( clas ) ; rr_type = ldns_get_rr_type_by_name ( type ) ; LDNS_FREE ( type ) ; desc = ldns_rr_descript ( ( uint16_t ) rr_type ) ; ldns_rr_set_type ( new , rr_type ) ; if ( desc ) { r_max = ldns_rr_descriptor_maximum ( desc ) ; r_min = ldns_rr_descriptor_minimum ( desc ) ; } else { r_min = 0 ; r_max = 1 ; } for ( done = false , r_cnt = 0 ; ! done && r_cnt < r_max ; r_cnt ++ ) { quoted = false ; switch ( ldns_rr_descriptor_field_type ( desc , r_cnt ) ) { case LDNS_RDF_TYPE_B64 : case LDNS_RDF_TYPE_HEX : case LDNS_RDF_TYPE_LOC : case LDNS_RDF_TYPE_WKS : case LDNS_RDF_TYPE_IPSECKEY : case LDNS_RDF_TYPE_AMTRELAY : case LDNS_RDF_TYPE_NSEC : if ( r_cnt == r_max - 1 ) { delimiters = \"\\\\n\" ; break ; } default : delimiters = \"\\\\n\\\\t<S2SV_blank>\" ; } if ( ldns_rdf_type_maybe_quoted ( ldns_rr_descriptor_field_type ( desc , r_cnt ) ) && ldns_buffer_remaining ( rd_buf ) > 0 ) { <S2SV_StartBug> while ( * ( ldns_buffer_current ( rd_buf ) ) == '<S2SV_blank>' ) { <S2SV_EndBug> ldns_buffer_skip ( rd_buf , 1 ) ; } <S2SV_StartBug> if ( * ( ldns_buffer_current ( rd_buf ) ) == \\'\\\\\"\\' ) { <S2SV_EndBug> delimiters = \"\\\\\"\\\\0\" ; ldns_buffer_skip ( rd_buf , 1 ) ; quoted = true ; <S2SV_StartBug> } else if ( ldns_rr_descriptor_field_type ( desc , r_cnt ) <S2SV_EndBug> == LDNS_RDF_TYPE_LONG_STR ) { status = LDNS_STATUS_SYNTAX_RDATA_ERR ; goto error ; } } while ( ldns_buffer_position ( rd_buf ) < ldns_buffer_limit ( rd_buf ) && * ( ldns_buffer_current ( rd_buf ) ) == '<S2SV_blank>' && ! quoted ) { ldns_buffer_skip ( rd_buf , 1 ) ; } pre_data_pos = ldns_buffer_position ( rd_buf ) ; if ( - 1 == ( c = ldns_bget_token ( rd_buf , rd , delimiters , LDNS_MAX_RDFLEN ) ) ) { done = true ; ( void ) done ; break ; } rd_strlen = strlen ( rd ) ; if ( strncmp ( rd , \"\\\\\\\\#\" , 2 ) == 0 && ! quoted && ( rd_strlen == 2 || rd [ 2 ] == '<S2SV_blank>' ) ) { was_unknown_rr_format = 1 ; ldns_buffer_set_position ( rd_buf , pre_data_pos ) ; delimiters = \"\\\\n\\\\t<S2SV_blank>\" ; ( void ) ldns_bget_token ( rd_buf , rd , delimiters , LDNS_MAX_RDFLEN ) ; c = ldns_bget_token ( rd_buf , rd , delimiters , LDNS_MAX_RDFLEN ) ; if ( c == - 1 ) { status = LDNS_STATUS_SYNTAX_RDATA_ERR ; goto error ; } hex_data_size = ( uint16_t ) atoi ( rd ) ; hex_data_str = LDNS_XMALLOC ( char , 2 * hex_data_size + 1 ) ; if ( ! hex_data_str ) { goto memerror ; } cur_hex_data_size = 0 ; while ( cur_hex_data_size < 2 * hex_data_size ) { c = ldns_bget_token ( rd_buf , rd , delimiters , LDNS_MAX_RDFLEN ) ; if ( c == - 1 ) { status = LDNS_STATUS_SYNTAX_RDATA_ERR ; goto error ; } rd_strlen = strlen ( rd ) ; if ( ( size_t ) cur_hex_data_size + rd_strlen > 2 * ( size_t ) hex_data_size ) { status = LDNS_STATUS_SYNTAX_RDATA_ERR ; goto error ; } strlcpy ( hex_data_str + cur_hex_data_size , rd , rd_strlen + 1 ) ; cur_hex_data_size += rd_strlen ; } hex_data_str [ cur_hex_data_size ] = '\\\\0' ; if ( desc ) { hex_pos = 0 ; hex_data = LDNS_XMALLOC ( uint8_t , hex_data_size + 2 ) ; if ( ! hex_data ) { goto memerror ; } ldns_write_uint16 ( hex_data , hex_data_size ) ; ldns_hexstring_to_data ( hex_data + 2 , hex_data_str ) ; status = ldns_wire2rdf ( new , hex_data , hex_data_size + 2 , & hex_pos ) ; if ( status != LDNS_STATUS_OK ) { goto error ; } LDNS_FREE ( hex_data ) ; } else { r = ldns_rdf_new_frm_str ( LDNS_RDF_TYPE_HEX , hex_data_str ) ; if ( ! r ) { goto memerror ; } ldns_rdf_set_type ( r , LDNS_RDF_TYPE_UNKNOWN ) ; if ( ! ldns_rr_push_rdf ( new , r ) ) { goto memerror ; } } LDNS_FREE ( hex_data_str ) ; } else if ( rd_strlen > 0 || quoted ) { switch ( ldns_rr_descriptor_field_type ( desc , r_cnt ) ) { case LDNS_RDF_TYPE_HEX : case LDNS_RDF_TYPE_B64 : if ( r_cnt == r_max - 1 ) { c = ldns_bget_token ( rd_buf , xtok , \"\\\\n\" , LDNS_MAX_RDFLEN ) ; if ( c != - 1 ) { ( void ) strncat ( rd , xtok , LDNS_MAX_RDFLEN - strlen ( rd ) - 1 ) ; } } r = ldns_rdf_new_frm_str ( ldns_rr_descriptor_field_type ( desc , r_cnt ) , rd ) ; break ; case LDNS_RDF_TYPE_HIP : do { if ( ldns_bget_token ( rd_buf , xtok , delimiters , LDNS_MAX_RDFLEN ) == - 1 ) break ; ( void ) strncat ( rd , \"<S2SV_blank>\" , LDNS_MAX_RDFLEN - strlen ( rd ) - 1 ) ; ( void ) strncat ( rd , xtok , LDNS_MAX_RDFLEN - strlen ( rd ) - 1 ) ; if ( ldns_bget_token ( rd_buf , xtok , delimiters , LDNS_MAX_RDFLEN ) == - 1 ) break ; ( void ) strncat ( rd , \"<S2SV_blank>\" , LDNS_MAX_RDFLEN - strlen ( rd ) - 1 ) ; ( void ) strncat ( rd , xtok , LDNS_MAX_RDFLEN - strlen ( rd ) - 1 ) ; } while ( false ) ; r = ldns_rdf_new_frm_str ( ldns_rr_descriptor_field_type ( desc , r_cnt ) , rd ) ; break ; case LDNS_RDF_TYPE_DNAME : r = ldns_rdf_new_frm_str ( ldns_rr_descriptor_field_type ( desc , r_cnt ) , rd ) ; if ( r && ldns_rdf_size ( r ) > 1 && ldns_rdf_data ( r ) [ 0 ] == 1 && ldns_rdf_data ( r ) [ 1 ] == '@' ) { ldns_rdf_deep_free ( r ) ; r = origin ? ldns_rdf_clone ( origin ) : ( rr_type == LDNS_RR_TYPE_SOA ? ldns_rdf_clone ( ldns_rr_owner ( new ) ) : ldns_rdf_new_frm_str ( LDNS_RDF_TYPE_DNAME , \".\" ) ) ; } else if ( r && rd_strlen >= 1 && origin && ! ldns_dname_str_absolute ( rd ) ) { status = ldns_dname_cat ( r , origin ) ; if ( status != LDNS_STATUS_OK ) { goto error ; } } break ; default : r = ldns_rdf_new_frm_str ( ldns_rr_descriptor_field_type ( desc , r_cnt ) , rd ) ; break ; } if ( ! r ) { status = LDNS_STATUS_SYNTAX_RDATA_ERR ; goto error ; } ldns_rr_push_rdf ( new , r ) ; } if ( quoted ) { if ( ldns_buffer_available ( rd_buf , 1 ) ) { ldns_buffer_skip ( rd_buf , 1 ) ; } else { done = true ; } } } LDNS_FREE ( rd ) ; LDNS_FREE ( xtok ) ; ldns_buffer_free ( rr_buf ) ; LDNS_FREE ( rdata ) ; if ( ldns_buffer_remaining ( rd_buf ) > 0 ) { ldns_buffer_free ( rd_buf ) ; ldns_rr_free ( new ) ; return LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR ; } ldns_buffer_free ( rd_buf ) ; if ( ! question && desc && ! was_unknown_rr_format && ldns_rr_rd_count ( new ) < r_min ) { ldns_rr_free ( new ) ; return LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR ; } if ( newrr ) { * newrr = new ; } else { ldns_rr_free ( new ) ; } return LDNS_STATUS_OK ; memerror : status = LDNS_STATUS_MEM_ERR ; error : if ( rd_buf && rd_buf -> _data ) { ldns_buffer_free ( rd_buf ) ; } else { LDNS_FREE ( rd_buf ) ; } if ( rr_buf && rr_buf -> _data ) { ldns_buffer_free ( rr_buf ) ; } else { LDNS_FREE ( rr_buf ) ; } LDNS_FREE ( type ) ; LDNS_FREE ( owner ) ; LDNS_FREE ( ttl ) ; LDNS_FREE ( clas ) ; LDNS_FREE ( hex_data ) ; LDNS_FREE ( hex_data_str ) ; LDNS_FREE ( xtok ) ; LDNS_FREE ( rd ) ; LDNS_FREE ( rdata ) ; ldns_rr_free ( new ) ; return status ; }", "target": "<S2SV_ModStart> { while ( sldns_buffer_remaining ( strbuf ) > 0 && <S2SV_ModStart> } if ( sldns_buffer_remaining ( strbuf ) > 0 && <S2SV_ModStart> true ; } if ( ! quoted && <S2SV_ModEnd> ldns_rr_descriptor_field_type ( desc"}
{"source": "CWE-476 static int multiSelect ( Parse * pParse , Select * p , SelectDest * pDest ) { int rc = SQLITE_OK ; Select * pPrior ; Vdbe * v ; SelectDest dest ; Select * pDelete = 0 ; sqlite3 * db ; assert ( p && p -> pPrior ) ; assert ( ( p -> selFlags & SF_Recursive ) == 0 || p -> op == TK_ALL || p -> op == TK_UNION ) ; assert ( p -> selFlags & SF_Compound ) ; db = pParse -> db ; pPrior = p -> pPrior ; dest = * pDest ; if ( pPrior -> pOrderBy || pPrior -> pLimit ) { sqlite3ErrorMsg ( pParse , \"%s<S2SV_blank>clause<S2SV_blank>should<S2SV_blank>come<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>before\" , pPrior -> pOrderBy != 0 ? \"ORDER<S2SV_blank>BY\" : \"LIMIT\" , selectOpName ( p -> op ) ) ; rc = 1 ; goto multi_select_end ; } v = sqlite3GetVdbe ( pParse ) ; assert ( v != 0 ) ; if ( dest . eDest == SRT_EphemTab ) { assert ( p -> pEList ) ; sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , dest . iSDParm , p -> pEList -> nExpr ) ; dest . eDest = SRT_Table ; } if ( p -> selFlags & SF_MultiValue ) { rc = multiSelectValues ( pParse , p , & dest ) ; if ( rc >= 0 ) goto multi_select_end ; rc = SQLITE_OK ; } assert ( p -> pEList && pPrior -> pEList ) ; assert ( p -> pEList -> nExpr == pPrior -> pEList -> nExpr ) ; # ifndef SQLITE_OMIT_CTE if ( p -> selFlags & SF_Recursive ) { generateWithRecursiveQuery ( pParse , p , & dest ) ; } else # endif if ( p -> pOrderBy ) { return multiSelectOrderBy ( pParse , p , pDest ) ; } else { # ifndef SQLITE_OMIT_EXPLAIN if ( pPrior -> pPrior == 0 ) { ExplainQueryPlan ( ( pParse , 1 , \"COMPOUND<S2SV_blank>QUERY\" ) ) ; ExplainQueryPlan ( ( pParse , 1 , \"LEFT-MOST<S2SV_blank>SUBQUERY\" ) ) ; } # endif switch ( p -> op ) { case TK_ALL : { int addr = 0 ; int nLimit ; assert ( ! pPrior -> pLimit ) ; pPrior -> iLimit = p -> iLimit ; pPrior -> iOffset = p -> iOffset ; pPrior -> pLimit = p -> pLimit ; rc = sqlite3Select ( pParse , pPrior , & dest ) ; p -> pLimit = 0 ; if ( rc ) { goto multi_select_end ; } p -> pPrior = 0 ; p -> iLimit = pPrior -> iLimit ; p -> iOffset = pPrior -> iOffset ; if ( p -> iLimit ) { addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , \"Jump<S2SV_blank>ahead<S2SV_blank>if<S2SV_blank>LIMIT<S2SV_blank>reached\" ) ) ; if ( p -> iOffset ) { sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , p -> iLimit , p -> iOffset + 1 , p -> iOffset ) ; } } ExplainQueryPlan ( ( pParse , 1 , \"UNION<S2SV_blank>ALL\" ) ) ; rc = sqlite3Select ( pParse , p , & dest ) ; testcase ( rc != SQLITE_OK ) ; pDelete = p -> pPrior ; p -> pPrior = pPrior ; p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ) ; if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) ) { p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ) ; } if ( addr ) { sqlite3VdbeJumpHere ( v , addr ) ; } break ; } case TK_EXCEPT : case TK_UNION : { int unionTab ; u8 op = 0 ; int priorOp ; Expr * pLimit ; int addr ; SelectDest uniondest ; testcase ( p -> op == TK_EXCEPT ) ; testcase ( p -> op == TK_UNION ) ; priorOp = SRT_Union ; if ( dest . eDest == priorOp ) { assert ( p -> pLimit == 0 ) ; unionTab = dest . iSDParm ; } else { unionTab = pParse -> nTab ++ ; assert ( p -> pOrderBy == 0 ) ; addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ) ; assert ( p -> addrOpenEphm [ 0 ] == - 1 ) ; p -> addrOpenEphm [ 0 ] = addr ; findRightmost ( p ) -> selFlags |= SF_UsesEphemeral ; assert ( p -> pEList ) ; } assert ( ! pPrior -> pOrderBy ) ; sqlite3SelectDestInit ( & uniondest , priorOp , unionTab ) ; rc = sqlite3Select ( pParse , pPrior , & uniondest ) ; if ( rc ) { goto multi_select_end ; } if ( p -> op == TK_EXCEPT ) { op = SRT_Except ; } else { assert ( p -> op == TK_UNION ) ; op = SRT_Union ; } p -> pPrior = 0 ; pLimit = p -> pLimit ; p -> pLimit = 0 ; uniondest . eDest = op ; ExplainQueryPlan ( ( pParse , 1 , \"%s<S2SV_blank>USING<S2SV_blank>TEMP<S2SV_blank>B-TREE\" , selectOpName ( p -> op ) ) ) ; rc = sqlite3Select ( pParse , p , & uniondest ) ; testcase ( rc != SQLITE_OK ) ; sqlite3ExprListDelete ( db , p -> pOrderBy ) ; pDelete = p -> pPrior ; p -> pPrior = pPrior ; p -> pOrderBy = 0 ; if ( p -> op == TK_UNION ) { p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ) ; } sqlite3ExprDelete ( db , p -> pLimit ) ; p -> pLimit = pLimit ; p -> iLimit = 0 ; p -> iOffset = 0 ; assert ( unionTab == dest . iSDParm || dest . eDest != priorOp ) ; if ( dest . eDest != priorOp ) { int iCont , iBreak , iStart ; assert ( p -> pEList ) ; iBreak = sqlite3VdbeMakeLabel ( pParse ) ; iCont = sqlite3VdbeMakeLabel ( pParse ) ; computeLimitRegisters ( pParse , p , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Rewind , unionTab , iBreak ) ; VdbeCoverage ( v ) ; iStart = sqlite3VdbeCurrentAddr ( v ) ; selectInnerLoop ( pParse , p , unionTab , 0 , 0 , & dest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp2 ( v , OP_Next , unionTab , iStart ) ; VdbeCoverage ( v ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Close , unionTab , 0 ) ; } break ; } default : assert ( p -> op == TK_INTERSECT ) ; { int tab1 , tab2 ; int iCont , iBreak , iStart ; Expr * pLimit ; int addr ; SelectDest intersectdest ; int r1 ; tab1 = pParse -> nTab ++ ; tab2 = pParse -> nTab ++ ; assert ( p -> pOrderBy == 0 ) ; addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab1 , 0 ) ; assert ( p -> addrOpenEphm [ 0 ] == - 1 ) ; p -> addrOpenEphm [ 0 ] = addr ; findRightmost ( p ) -> selFlags |= SF_UsesEphemeral ; assert ( p -> pEList ) ; sqlite3SelectDestInit ( & intersectdest , SRT_Union , tab1 ) ; rc = sqlite3Select ( pParse , pPrior , & intersectdest ) ; if ( rc ) { goto multi_select_end ; } addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab2 , 0 ) ; assert ( p -> addrOpenEphm [ 1 ] == - 1 ) ; p -> addrOpenEphm [ 1 ] = addr ; p -> pPrior = 0 ; pLimit = p -> pLimit ; p -> pLimit = 0 ; intersectdest . iSDParm = tab2 ; ExplainQueryPlan ( ( pParse , 1 , \"%s<S2SV_blank>USING<S2SV_blank>TEMP<S2SV_blank>B-TREE\" , selectOpName ( p -> op ) ) ) ; rc = sqlite3Select ( pParse , p , & intersectdest ) ; testcase ( rc != SQLITE_OK ) ; pDelete = p -> pPrior ; p -> pPrior = pPrior ; if ( p -> nSelectRow > pPrior -> nSelectRow ) { p -> nSelectRow = pPrior -> nSelectRow ; } sqlite3ExprDelete ( db , p -> pLimit ) ; p -> pLimit = pLimit ; assert ( p -> pEList ) ; iBreak = sqlite3VdbeMakeLabel ( pParse ) ; iCont = sqlite3VdbeMakeLabel ( pParse ) ; computeLimitRegisters ( pParse , p , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Rewind , tab1 , iBreak ) ; VdbeCoverage ( v ) ; r1 = sqlite3GetTempReg ( pParse ) ; iStart = sqlite3VdbeAddOp2 ( v , OP_RowData , tab1 , r1 ) ; sqlite3VdbeAddOp4Int ( v , OP_NotFound , tab2 , iCont , r1 , 0 ) ; VdbeCoverage ( v ) ; sqlite3ReleaseTempReg ( pParse , r1 ) ; selectInnerLoop ( pParse , p , tab1 , 0 , 0 , & dest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp2 ( v , OP_Next , tab1 , iStart ) ; VdbeCoverage ( v ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Close , tab2 , 0 ) ; sqlite3VdbeAddOp2 ( v , OP_Close , tab1 , 0 ) ; break ; } } # ifndef SQLITE_OMIT_EXPLAIN if ( p -> pNext == 0 ) { ExplainQueryPlanPop ( pParse ) ; } # endif } <S2SV_StartBug> <S2SV_EndBug> if ( p -> selFlags & SF_UsesEphemeral ) { int i ; KeyInfo * pKeyInfo ; Select * pLoop ; CollSeq * * apColl ; int nCol ; assert ( p -> pNext == 0 ) ; nCol = p -> pEList -> nExpr ; pKeyInfo = sqlite3KeyInfoAlloc ( db , nCol , 1 ) ; if ( ! pKeyInfo ) { rc = SQLITE_NOMEM_BKPT ; goto multi_select_end ; } for ( i = 0 , apColl = pKeyInfo -> aColl ; i < nCol ; i ++ , apColl ++ ) { * apColl = multiSelectCollSeq ( pParse , p , i ) ; if ( 0 == * apColl ) { * apColl = db -> pDfltColl ; } } for ( pLoop = p ; pLoop ; pLoop = pLoop -> pPrior ) { for ( i = 0 ; i < 2 ; i ++ ) { int addr = pLoop -> addrOpenEphm [ i ] ; if ( addr < 0 ) { assert ( pLoop -> addrOpenEphm [ 1 ] < 0 ) ; break ; } sqlite3VdbeChangeP2 ( v , addr , nCol ) ; sqlite3VdbeChangeP4 ( v , addr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ) ; pLoop -> addrOpenEphm [ i ] = - 1 ; } } sqlite3KeyInfoUnref ( pKeyInfo ) ; } multi_select_end : pDest -> iSdst = dest . iSdst ; pDest -> nSdst = dest . nSdst ; sqlite3SelectDelete ( db , pDelete ) ; return rc ; }", "target": "<S2SV_ModStart> # endif } if ( pParse -> nErr ) goto multi_select_end ;"}
{"source": "CWE-362 static ssize_t usbip_sockfd_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) { struct stub_device * sdev = dev_get_drvdata ( dev ) ; int sockfd = 0 ; struct socket * socket ; <S2SV_StartBug> int rv ; <S2SV_EndBug> if ( ! sdev ) { dev_err ( dev , \"sdev<S2SV_blank>is<S2SV_blank>null\\\\n\" ) ; return - ENODEV ; } rv = sscanf ( buf , \"%d\" , & sockfd ) ; if ( rv != 1 ) return - EINVAL ; if ( sockfd != - 1 ) { int err ; dev_info ( dev , \"stub<S2SV_blank>up\\\\n\" ) ; spin_lock_irq ( & sdev -> ud . lock ) ; if ( sdev -> ud . status != SDEV_ST_AVAILABLE ) { dev_err ( dev , \"not<S2SV_blank>ready\\\\n\" ) ; goto err ; } socket = sockfd_lookup ( sockfd , & err ) ; if ( ! socket ) { dev_err ( dev , \"failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>sock\" ) ; goto err ; } if ( socket -> type != SOCK_STREAM ) { dev_err ( dev , \"Expecting<S2SV_blank>SOCK_STREAM<S2SV_blank>-<S2SV_blank>found<S2SV_blank>%d\" , socket -> type ) ; goto sock_err ; } <S2SV_StartBug> sdev -> ud . tcp_socket = socket ; <S2SV_EndBug> sdev -> ud . sockfd = sockfd ; <S2SV_StartBug> <S2SV_EndBug> spin_unlock_irq ( & sdev -> ud . lock ) ; <S2SV_StartBug> sdev -> ud . tcp_rx = kthread_get_run ( stub_rx_loop , & sdev -> ud , <S2SV_EndBug> \"stub_rx\" ) ; sdev -> ud . tcp_tx = kthread_get_run ( stub_tx_loop , & sdev -> ud , \"stub_tx\" ) ; spin_lock_irq ( & sdev -> ud . lock ) ; sdev -> ud . status = SDEV_ST_USED ; spin_unlock_irq ( & sdev -> ud . lock ) ; } else { dev_info ( dev , \"stub<S2SV_blank>down\\\\n\" ) ; spin_lock_irq ( & sdev -> ud . lock ) ; if ( sdev -> ud . status != SDEV_ST_USED ) goto err ; spin_unlock_irq ( & sdev -> ud . lock ) ; usbip_event_add ( & sdev -> ud , SDEV_EVENT_DOWN ) ; } return count ; sock_err : sockfd_put ( socket ) ; err : spin_unlock_irq ( & sdev -> ud . lock ) ; return - EINVAL ; }", "target": "<S2SV_ModStart> ; int rv ; struct task_struct * tcp_rx = NULL ; struct task_struct * tcp_tx = NULL <S2SV_ModStart> sock_err ; } spin_unlock_irq ( & sdev -> ud . lock ) ; tcp_rx = kthread_create ( stub_rx_loop , & sdev -> ud , \"stub_rx\" ) ; if ( IS_ERR ( tcp_rx ) ) { sockfd_put ( socket ) ; return - EINVAL ; } tcp_tx = kthread_create ( stub_tx_loop , & sdev -> ud , \"stub_tx\" ) ; if ( IS_ERR ( tcp_tx ) ) { kthread_stop ( tcp_rx ) ; sockfd_put ( socket ) ; return - EINVAL ; } get_task_struct ( tcp_rx ) ; get_task_struct ( tcp_tx ) ; spin_lock_irq ( & sdev -> ud . lock ) ; <S2SV_ModStart> = sockfd ; sdev -> ud . tcp_rx = tcp_rx ; sdev -> ud . tcp_tx = tcp_tx ; sdev -> ud . status = SDEV_ST_USED ; <S2SV_ModStart> lock ) ; wake_up_process ( sdev -> ud . tcp_rx ) ; wake_up_process ( sdev -> ud . tcp_tx <S2SV_ModEnd> ) ; }"}
{"source": "CWE-787 static struct socket * get_raw_socket ( int fd ) { <S2SV_StartBug> struct { <S2SV_EndBug> struct sockaddr_ll sa ; char buf [ MAX_ADDR_LEN ] ; } uaddr ; int r ; struct socket * sock = sockfd_lookup ( fd , & r ) ; if ( ! sock ) return ERR_PTR ( - ENOTSOCK ) ; if ( sock -> sk -> sk_type != SOCK_RAW ) { r = - ESOCKTNOSUPPORT ; goto err ; } <S2SV_StartBug> r = sock -> ops -> getname ( sock , ( struct sockaddr * ) & uaddr . sa , 0 ) ; <S2SV_EndBug> if ( r < 0 ) goto err ; if ( uaddr . sa . sll_family != AF_PACKET ) { r = - EPFNOSUPPORT ; goto err ; } return sock ; err : sockfd_put ( sock ) ; return ERR_PTR ( r ) ; }", "target": "<S2SV_ModStart> fd ) { <S2SV_ModEnd> int r ; <S2SV_ModStart> err ; } if ( sock -> sk -> sk_family <S2SV_ModEnd> != AF_PACKET )"}
{"source": "CWE-787 mwifiex_cmd_802_11_ad_hoc_start ( struct mwifiex_private * priv , struct host_cmd_ds_command * cmd , struct cfg80211_ssid * req_ssid ) { int rsn_ie_len = 0 ; struct mwifiex_adapter * adapter = priv -> adapter ; struct host_cmd_ds_802_11_ad_hoc_start * adhoc_start = & cmd -> params . adhoc_start ; struct mwifiex_bssdescriptor * bss_desc ; u32 cmd_append_size = 0 ; u32 i ; u16 tmp_cap ; struct mwifiex_ie_types_chan_list_param_set * chan_tlv ; u8 radio_type ; struct mwifiex_ie_types_htcap * ht_cap ; struct mwifiex_ie_types_htinfo * ht_info ; u8 * pos = ( u8 * ) adhoc_start + sizeof ( struct host_cmd_ds_802_11_ad_hoc_start ) ; if ( ! adapter ) return - 1 ; cmd -> command = cpu_to_le16 ( HostCmd_CMD_802_11_AD_HOC_START ) ; bss_desc = & priv -> curr_bss_params . bss_descriptor ; priv -> attempted_bss_desc = bss_desc ; memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; <S2SV_StartBug> <S2SV_EndBug> memcpy ( adhoc_start -> ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ; mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>SSID<S2SV_blank>=<S2SV_blank>%s\\\\n\" , adhoc_start -> ssid ) ; memset ( bss_desc -> ssid . ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; memcpy ( bss_desc -> ssid . ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ; bss_desc -> ssid . ssid_len = req_ssid -> ssid_len ; adhoc_start -> bss_mode = HostCmd_BSS_MODE_IBSS ; bss_desc -> bss_mode = NL80211_IFTYPE_ADHOC ; adhoc_start -> beacon_period = cpu_to_le16 ( priv -> beacon_period ) ; bss_desc -> beacon_period = priv -> beacon_period ; # define DS_PARA_IE_ID 3 # define DS_PARA_IE_LEN 1 adhoc_start -> phy_param_set . ds_param_set . element_id = DS_PARA_IE_ID ; adhoc_start -> phy_param_set . ds_param_set . len = DS_PARA_IE_LEN ; if ( ! mwifiex_get_cfp ( priv , adapter -> adhoc_start_band , ( u16 ) priv -> adhoc_channel , 0 ) ) { struct mwifiex_chan_freq_power * cfp ; cfp = mwifiex_get_cfp ( priv , adapter -> adhoc_start_band , FIRST_VALID_CHANNEL , 0 ) ; if ( cfp ) priv -> adhoc_channel = ( u8 ) cfp -> channel ; } if ( ! priv -> adhoc_channel ) { mwifiex_dbg ( adapter , ERROR , \"ADHOC_S_CMD:<S2SV_blank>adhoc_channel<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>0\\\\n\" ) ; return - 1 ; } mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>creating<S2SV_blank>ADHOC<S2SV_blank>on<S2SV_blank>channel<S2SV_blank>%d\\\\n\" , priv -> adhoc_channel ) ; priv -> curr_bss_params . bss_descriptor . channel = priv -> adhoc_channel ; priv -> curr_bss_params . band = adapter -> adhoc_start_band ; bss_desc -> channel = priv -> adhoc_channel ; adhoc_start -> phy_param_set . ds_param_set . current_chan = priv -> adhoc_channel ; memcpy ( & bss_desc -> phy_param_set , & adhoc_start -> phy_param_set , sizeof ( union ieee_types_phy_param_set ) ) ; # define IBSS_PARA_IE_ID 6 # define IBSS_PARA_IE_LEN 2 adhoc_start -> ss_param_set . ibss_param_set . element_id = IBSS_PARA_IE_ID ; adhoc_start -> ss_param_set . ibss_param_set . len = IBSS_PARA_IE_LEN ; adhoc_start -> ss_param_set . ibss_param_set . atim_window = cpu_to_le16 ( priv -> atim_window ) ; memcpy ( & bss_desc -> ss_param_set , & adhoc_start -> ss_param_set , sizeof ( union ieee_types_ss_param_set ) ) ; bss_desc -> cap_info_bitmap |= WLAN_CAPABILITY_IBSS ; tmp_cap = WLAN_CAPABILITY_IBSS ; if ( priv -> sec_info . encryption_mode ) { mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>wep_status<S2SV_blank>set<S2SV_blank>privacy<S2SV_blank>to<S2SV_blank>WEP\\\\n\" ) ; bss_desc -> privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP ; tmp_cap |= WLAN_CAPABILITY_PRIVACY ; } else { mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>wep_status<S2SV_blank>NOT<S2SV_blank>set,\\\\t\" \"setting<S2SV_blank>privacy<S2SV_blank>to<S2SV_blank>ACCEPT<S2SV_blank>ALL\\\\n\" ) ; bss_desc -> privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL ; } memset ( adhoc_start -> data_rate , 0 , sizeof ( adhoc_start -> data_rate ) ) ; mwifiex_get_active_data_rates ( priv , adhoc_start -> data_rate ) ; if ( ( adapter -> adhoc_start_band & BAND_G ) && ( priv -> curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON ) ) { if ( mwifiex_send_cmd ( priv , HostCmd_CMD_MAC_CONTROL , HostCmd_ACT_GEN_SET , 0 , & priv -> curr_pkt_filter , false ) ) { mwifiex_dbg ( adapter , ERROR , \"ADHOC_S_CMD:<S2SV_blank>G<S2SV_blank>Protection<S2SV_blank>config<S2SV_blank>failed\\\\n\" ) ; return - 1 ; } } for ( i = 0 ; i < sizeof ( adhoc_start -> data_rate ) ; i ++ ) if ( ! adhoc_start -> data_rate [ i ] ) break ; priv -> curr_bss_params . num_of_rates = i ; memcpy ( & priv -> curr_bss_params . data_rates , & adhoc_start -> data_rate , priv -> curr_bss_params . num_of_rates ) ; mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>rates=%4ph\\\\n\" , adhoc_start -> data_rate ) ; mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>AD-HOC<S2SV_blank>Start<S2SV_blank>command<S2SV_blank>is<S2SV_blank>ready\\\\n\" ) ; if ( IS_SUPPORT_MULTI_BANDS ( adapter ) ) { chan_tlv = ( struct mwifiex_ie_types_chan_list_param_set * ) pos ; chan_tlv -> header . type = cpu_to_le16 ( TLV_TYPE_CHANLIST ) ; chan_tlv -> header . len = cpu_to_le16 ( sizeof ( struct mwifiex_chan_scan_param_set ) ) ; memset ( chan_tlv -> chan_scan_param , 0x00 , sizeof ( struct mwifiex_chan_scan_param_set ) ) ; chan_tlv -> chan_scan_param [ 0 ] . chan_number = ( u8 ) priv -> curr_bss_params . bss_descriptor . channel ; mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>TLV<S2SV_blank>Chan<S2SV_blank>=<S2SV_blank>%d\\\\n\" , chan_tlv -> chan_scan_param [ 0 ] . chan_number ) ; chan_tlv -> chan_scan_param [ 0 ] . radio_type = mwifiex_band_to_radio_type ( priv -> curr_bss_params . band ) ; if ( adapter -> adhoc_start_band & BAND_GN || adapter -> adhoc_start_band & BAND_AN ) { if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_ABOVE ) chan_tlv -> chan_scan_param [ 0 ] . radio_type |= ( IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4 ) ; else if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_BELOW ) chan_tlv -> chan_scan_param [ 0 ] . radio_type |= ( IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4 ) ; } mwifiex_dbg ( adapter , INFO , \"info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>TLV<S2SV_blank>Band<S2SV_blank>=<S2SV_blank>%d\\\\n\" , chan_tlv -> chan_scan_param [ 0 ] . radio_type ) ; pos += sizeof ( chan_tlv -> header ) + sizeof ( struct mwifiex_chan_scan_param_set ) ; cmd_append_size += sizeof ( chan_tlv -> header ) + sizeof ( struct mwifiex_chan_scan_param_set ) ; } cmd_append_size += mwifiex_cmd_append_vsie_tlv ( priv , MWIFIEX_VSIE_MASK_ADHOC , & pos ) ; if ( priv -> sec_info . wpa_enabled ) { rsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2 ( priv , & pos ) ; if ( rsn_ie_len == - 1 ) return - 1 ; cmd_append_size += rsn_ie_len ; } if ( adapter -> adhoc_11n_enabled ) { ht_cap = ( struct mwifiex_ie_types_htcap * ) pos ; memset ( ht_cap , 0 , sizeof ( struct mwifiex_ie_types_htcap ) ) ; ht_cap -> header . type = cpu_to_le16 ( WLAN_EID_HT_CAPABILITY ) ; ht_cap -> header . len = cpu_to_le16 ( sizeof ( struct ieee80211_ht_cap ) ) ; radio_type = mwifiex_band_to_radio_type ( priv -> adapter -> config_bands ) ; mwifiex_fill_cap_info ( priv , radio_type , & ht_cap -> ht_cap ) ; if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_NONE ) { u16 tmp_ht_cap ; tmp_ht_cap = le16_to_cpu ( ht_cap -> ht_cap . cap_info ) ; tmp_ht_cap &= ~ IEEE80211_HT_CAP_SUP_WIDTH_20_40 ; tmp_ht_cap &= ~ IEEE80211_HT_CAP_SGI_40 ; ht_cap -> ht_cap . cap_info = cpu_to_le16 ( tmp_ht_cap ) ; } pos += sizeof ( struct mwifiex_ie_types_htcap ) ; cmd_append_size += sizeof ( struct mwifiex_ie_types_htcap ) ; ht_info = ( struct mwifiex_ie_types_htinfo * ) pos ; memset ( ht_info , 0 , sizeof ( struct mwifiex_ie_types_htinfo ) ) ; ht_info -> header . type = cpu_to_le16 ( WLAN_EID_HT_OPERATION ) ; ht_info -> header . len = cpu_to_le16 ( sizeof ( struct ieee80211_ht_operation ) ) ; ht_info -> ht_oper . primary_chan = ( u8 ) priv -> curr_bss_params . bss_descriptor . channel ; if ( adapter -> sec_chan_offset ) { ht_info -> ht_oper . ht_param = adapter -> sec_chan_offset ; ht_info -> ht_oper . ht_param |= IEEE80211_HT_PARAM_CHAN_WIDTH_ANY ; } ht_info -> ht_oper . operation_mode = cpu_to_le16 ( IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT ) ; ht_info -> ht_oper . basic_set [ 0 ] = 0xff ; pos += sizeof ( struct mwifiex_ie_types_htinfo ) ; cmd_append_size += sizeof ( struct mwifiex_ie_types_htinfo ) ; } cmd -> size = cpu_to_le16 ( ( u16 ) ( sizeof ( struct host_cmd_ds_802_11_ad_hoc_start ) + S_DS_GEN + cmd_append_size ) ) ; if ( adapter -> adhoc_start_band == BAND_B ) tmp_cap &= ~ WLAN_CAPABILITY_SHORT_SLOT_TIME ; else tmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME ; adhoc_start -> cap_info_bitmap = cpu_to_le16 ( tmp_cap ) ; return 0 ; }", "target": "<S2SV_ModStart> IEEE80211_MAX_SSID_LEN ) ; if ( req_ssid -> ssid_len > IEEE80211_MAX_SSID_LEN ) req_ssid -> ssid_len = IEEE80211_MAX_SSID_LEN ;"}
{"source": "CWE-416 gst_matroska_demux_add_wvpk_header ( GstElement * element , GstMatroskaTrackContext * stream , GstBuffer * * buf ) { GstMatroskaTrackAudioContext * audiocontext = ( GstMatroskaTrackAudioContext * ) stream ; GstBuffer * newbuf = NULL ; GstMapInfo map , outmap ; guint8 * buf_data , * data ; Wavpack4Header wvh ; wvh . ck_id [ 0 ] = 'w' ; wvh . ck_id [ 1 ] = 'v' ; wvh . ck_id [ 2 ] = 'p' ; wvh . ck_id [ 3 ] = 'k' ; wvh . version = GST_READ_UINT16_LE ( stream -> codec_priv ) ; wvh . track_no = 0 ; wvh . index_no = 0 ; wvh . total_samples = - 1 ; wvh . block_index = audiocontext -> wvpk_block_index ; if ( audiocontext -> channels <= 2 ) { guint32 block_samples , tmp ; gsize size = gst_buffer_get_size ( * buf ) ; <S2SV_StartBug> gst_buffer_extract ( * buf , 0 , & tmp , sizeof ( guint32 ) ) ; <S2SV_EndBug> block_samples = GUINT32_FROM_LE ( tmp ) ; <S2SV_StartBug> wvh . ck_size = size + sizeof ( Wavpack4Header ) - 20 ; <S2SV_EndBug> <S2SV_StartBug> newbuf = gst_buffer_new_allocate ( NULL , sizeof ( Wavpack4Header ) - 12 , NULL ) ; <S2SV_EndBug> gst_buffer_map ( newbuf , & outmap , GST_MAP_WRITE ) ; data = outmap . data ; data [ 0 ] = 'w' ; data [ 1 ] = 'v' ; data [ 2 ] = 'p' ; data [ 3 ] = 'k' ; GST_WRITE_UINT32_LE ( data + 4 , wvh . ck_size ) ; GST_WRITE_UINT16_LE ( data + 8 , wvh . version ) ; GST_WRITE_UINT8 ( data + 10 , wvh . track_no ) ; GST_WRITE_UINT8 ( data + 11 , wvh . index_no ) ; GST_WRITE_UINT32_LE ( data + 12 , wvh . total_samples ) ; GST_WRITE_UINT32_LE ( data + 16 , wvh . block_index ) ; gst_buffer_unmap ( newbuf , & outmap ) ; gst_buffer_copy_into ( newbuf , * buf , GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_MEMORY , 0 , size ) ; gst_buffer_unref ( * buf ) ; * buf = newbuf ; audiocontext -> wvpk_block_index += block_samples ; } else { guint8 * outdata = NULL ; <S2SV_StartBug> guint outpos = 0 ; <S2SV_EndBug> <S2SV_StartBug> gsize buf_size , size , out_size = 0 ; <S2SV_EndBug> guint32 block_samples , flags , crc , blocksize ; <S2SV_StartBug> <S2SV_EndBug> gst_buffer_map ( * buf , & map , GST_MAP_READ ) ; buf_data = map . data ; buf_size = map . size ; if ( buf_size < 4 ) { GST_ERROR_OBJECT ( element , \"Too<S2SV_blank>small<S2SV_blank>wavpack<S2SV_blank>buffer\" ) ; <S2SV_StartBug> gst_buffer_unmap ( * buf , & map ) ; <S2SV_EndBug> return GST_FLOW_ERROR ; } data = buf_data ; size = buf_size ; block_samples = GST_READ_UINT32_LE ( data ) ; data += 4 ; size -= 4 ; while ( size > 12 ) { flags = GST_READ_UINT32_LE ( data ) ; data += 4 ; size -= 4 ; crc = GST_READ_UINT32_LE ( data ) ; data += 4 ; size -= 4 ; blocksize = GST_READ_UINT32_LE ( data ) ; data += 4 ; size -= 4 ; if ( blocksize == 0 || size < blocksize ) <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> g_assert ( ( newbuf == NULL ) == ( outdata == NULL ) ) ; <S2SV_EndBug> if ( newbuf == NULL ) { out_size = sizeof ( Wavpack4Header ) + blocksize ; newbuf = gst_buffer_new_allocate ( NULL , out_size , NULL ) ; gst_buffer_copy_into ( newbuf , * buf , GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS , 0 , - 1 ) ; <S2SV_StartBug> outpos = 0 ; <S2SV_EndBug> gst_buffer_map ( newbuf , & outmap , GST_MAP_WRITE ) ; outdata = outmap . data ; } else { gst_buffer_unmap ( newbuf , & outmap ) ; out_size += sizeof ( Wavpack4Header ) + blocksize ; gst_buffer_set_size ( newbuf , out_size ) ; gst_buffer_map ( newbuf , & outmap , GST_MAP_WRITE ) ; outdata = outmap . data ; } outdata [ outpos ] = 'w' ; outdata [ outpos + 1 ] = 'v' ; outdata [ outpos + 2 ] = 'p' ; outdata [ outpos + 3 ] = 'k' ; outpos += 4 ; GST_WRITE_UINT32_LE ( outdata + outpos , blocksize + sizeof ( Wavpack4Header ) - 8 ) ; GST_WRITE_UINT16_LE ( outdata + outpos + 4 , wvh . version ) ; GST_WRITE_UINT8 ( outdata + outpos + 6 , wvh . track_no ) ; GST_WRITE_UINT8 ( outdata + outpos + 7 , wvh . index_no ) ; GST_WRITE_UINT32_LE ( outdata + outpos + 8 , wvh . total_samples ) ; GST_WRITE_UINT32_LE ( outdata + outpos + 12 , wvh . block_index ) ; GST_WRITE_UINT32_LE ( outdata + outpos + 16 , block_samples ) ; GST_WRITE_UINT32_LE ( outdata + outpos + 20 , flags ) ; GST_WRITE_UINT32_LE ( outdata + outpos + 24 , crc ) ; outpos += 28 ; memmove ( outdata + outpos , data , blocksize ) ; outpos += blocksize ; data += blocksize ; size -= blocksize ; } gst_buffer_unmap ( * buf , & map ) ; gst_buffer_unref ( * buf ) ; <S2SV_StartBug> if ( newbuf ) <S2SV_EndBug> gst_buffer_unmap ( newbuf , & outmap ) ; * buf = newbuf ; audiocontext -> wvpk_block_index += block_samples ; } return GST_FLOW_OK ; }", "target": "<S2SV_ModStart> buf ) ; if ( size < 4 ) { GST_ERROR_OBJECT ( element , \"Too<S2SV_blank>small<S2SV_blank>wavpack<S2SV_blank>buffer\" ) ; gst_buffer_unmap ( * buf , & map ) ; return GST_FLOW_ERROR ; } <S2SV_ModStart> = size + WAVPACK4_HEADER_SIZE <S2SV_ModEnd> - 20 ; <S2SV_ModStart> ( NULL , WAVPACK4_HEADER_SIZE <S2SV_ModEnd> - 12 , <S2SV_ModStart> = NULL ; <S2SV_ModEnd> gsize buf_size , <S2SV_ModStart> buf_size , size <S2SV_ModEnd> ; guint32 block_samples <S2SV_ModStart> , blocksize ; GstAdapter * adapter ; adapter = gst_adapter_new ( ) ; <S2SV_ModStart> , & map ) ; g_object_unref ( adapter <S2SV_ModStart> < blocksize ) { GST_ERROR_OBJECT ( element , \"Too<S2SV_blank>small<S2SV_blank>wavpack<S2SV_blank>buffer\" ) ; gst_buffer_unmap ( * buf , & map ) ; g_object_unref ( adapter ) ; return GST_FLOW_ERROR ; } g_assert <S2SV_ModEnd> ( newbuf == <S2SV_ModStart> == NULL ) ; newbuf = gst_buffer_new_allocate ( NULL , WAVPACK4_HEADER_SIZE + blocksize , NULL ) ; gst_buffer_map ( newbuf , & outmap , GST_MAP_WRITE ) ; outdata = outmap . data ; outdata [ 0 ] = 'w' ; outdata [ 1 ] = 'v' ; outdata [ 2 ] = 'p' ; outdata [ 3 ] = 'k' ; outdata += 4 ; GST_WRITE_UINT32_LE ( outdata , blocksize + WAVPACK4_HEADER_SIZE - 8 ) ; GST_WRITE_UINT16_LE ( outdata + 4 , wvh . version ) ; GST_WRITE_UINT8 ( outdata + 6 , wvh . track_no ) ; GST_WRITE_UINT8 ( outdata + 7 , wvh . index_no ) ; GST_WRITE_UINT32_LE ( outdata + 8 , wvh . total_samples ) ; GST_WRITE_UINT32_LE ( outdata + 12 , wvh . block_index ) ; GST_WRITE_UINT32_LE ( outdata + 16 , block_samples ) ; GST_WRITE_UINT32_LE ( outdata + 20 , flags ) ; GST_WRITE_UINT32_LE ( outdata + 24 , crc ) ; outdata += 28 ; memcpy ( outdata , data , blocksize ) ; gst_buffer_unmap ( newbuf , & outmap ) ; gst_adapter_push ( adapter , newbuf ) ; newbuf = NULL ; data += blocksize ; size -= blocksize ; } gst_buffer_unmap ( * buf , & map ) ; newbuf = gst_adapter_take_buffer ( adapter , gst_adapter_available ( adapter ) ) ; g_object_unref ( adapter <S2SV_ModEnd> ) ; gst_buffer_copy_into <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> gst_buffer_unref ( * <S2SV_ModStart> buf ) ; * buf = newbuf ; <S2SV_ModEnd> audiocontext -> wvpk_block_index"}
{"source": "CWE-415 allocate_trace_buffer ( struct trace_array * tr , struct trace_buffer * buf , int size ) { enum ring_buffer_flags rb_flags ; rb_flags = tr -> trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0 ; buf -> tr = tr ; buf -> buffer = ring_buffer_alloc ( size , rb_flags ) ; if ( ! buf -> buffer ) return - ENOMEM ; buf -> data = alloc_percpu ( struct trace_array_cpu ) ; if ( ! buf -> data ) { ring_buffer_free ( buf -> buffer ) ; <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> } set_buffer_entries ( & tr -> trace_buffer , ring_buffer_size ( tr -> trace_buffer . buffer , 0 ) ) ; return 0 ; }", "target": "<S2SV_ModStart> buffer ) ; buf -> buffer = NULL ;"}
{"source": "CWE-770 void ScanLineInputFile : : initialize ( const Header & header ) { _data -> header = header ; _data -> lineOrder = _data -> header . lineOrder ( ) ; const Box2i & dataWindow = _data -> header . dataWindow ( ) ; _data -> minX = dataWindow . min . x ; _data -> maxX = dataWindow . max . x ; _data -> minY = dataWindow . min . y ; _data -> maxY = dataWindow . max . y ; Compression comp = _data -> header . compression ( ) ; _data -> linesInBuffer = numLinesInBuffer ( comp ) ; int lineOffsetSize = ( dataWindow . max . y - dataWindow . min . y + _data -> linesInBuffer ) / _data -> linesInBuffer ; <S2SV_StartBug> if ( lineOffsetSize > gLargeChunkTableSize ) <S2SV_EndBug> { Int64 pos = _streamData -> is -> tellg ( ) ; _streamData -> is -> seekg ( pos + ( lineOffsetSize - 1 ) * sizeof ( Int64 ) ) ; Int64 temp ; OPENEXR_IMF_INTERNAL_NAMESPACE : : Xdr : : read < OPENEXR_IMF_INTERNAL_NAMESPACE : : StreamIO > ( * _streamData -> is , temp ) ; _streamData -> is -> seekg ( pos ) ; } size_t maxBytesPerLine = bytesPerLineTable ( _data -> header , _data -> bytesPerLine ) ; if ( maxBytesPerLine * numLinesInBuffer ( comp ) > INT_MAX ) { throw IEX_NAMESPACE : : InputExc ( \"maximum<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scanline<S2SV_blank>exceeds<S2SV_blank>maximum<S2SV_blank>permissible<S2SV_blank>size\" ) ; } for ( size_t i = 0 ; i < _data -> lineBuffers . size ( ) ; i ++ ) { _data -> lineBuffers [ i ] = new LineBuffer ( newCompressor ( comp , maxBytesPerLine , _data -> header ) ) ; } _data -> lineBufferSize = maxBytesPerLine * _data -> linesInBuffer ; if ( ! _streamData -> is -> isMemoryMapped ( ) ) { for ( size_t i = 0 ; i < _data -> lineBuffers . size ( ) ; i ++ ) { _data -> lineBuffers [ i ] -> buffer = ( char * ) EXRAllocAligned ( _data -> lineBufferSize * sizeof ( char ) , 16 ) ; if ( ! _data -> lineBuffers [ i ] -> buffer ) { throw IEX_NAMESPACE : : LogicExc ( \"Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>scanline<S2SV_blank>buffers\" ) ; } } } _data -> nextLineBufferMinY = _data -> minY - 1 ; offsetInLineBufferTable ( _data -> bytesPerLine , _data -> linesInBuffer , _data -> offsetInLineBuffer ) ; _data -> lineOffsets . resize ( lineOffsetSize ) ; }", "target": "<S2SV_ModStart> if ( lineOffsetSize * _data -> linesInBuffer"}
{"source": "CWE-362 static struct kobject * cdev_get ( struct cdev * p ) { struct module * owner = p -> owner ; struct kobject * kobj ; if ( owner && ! try_module_get ( owner ) ) return NULL ; <S2SV_StartBug> kobj = kobject_get ( & p -> kobj ) ; <S2SV_EndBug> if ( ! kobj ) module_put ( owner ) ; return kobj ; }", "target": "<S2SV_ModStart> ; kobj = kobject_get_unless_zero <S2SV_ModEnd> ( & p"}
{"source": "CWE-703 static Image * ReadTIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowTIFFException ( severity , message ) { if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; TIFFClose ( tiff ) ; ThrowReaderException ( severity , message ) ; } <S2SV_EndBug> const char * option ; float * chromaticity , x_position , y_position , x_resolution , y_resolution ; Image * image ; int tiff_status ; MagickBooleanType more_frames , status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info = ( MemoryInfo * ) NULL ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t pad ; ssize_t y ; TIFF * tiff ; TIFFMethodType method ; uint16 compress_tag , bits_per_sample , endian , extra_samples , interlace , max_sample_value , min_sample_value , orientation , pages , photometric , * sample_info , sample_format , samples_per_pixel , units , value ; uint32 height , rows_per_strip , width ; unsigned char * pixels ; void * sans [ 2 ] = { NULL , NULL } ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) SetMagickThreadValue ( tiff_exception , exception ) ; tiff = TIFFClientOpen ( image -> filename , \"rb\" , ( thandle_t ) image , TIFFReadBlob , TIFFWriteBlob , TIFFSeekBlob , TIFFCloseBlob , TIFFGetBlobSize , TIFFMapBlob , TIFFUnmapBlob ) ; if ( tiff == ( TIFF * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( exception -> severity > ErrorException ) { TIFFClose ( tiff ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image_info -> number_scenes != 0 ) { if ( image_info -> scene < ( size_t ) TIFFNumberOfDirectories ( tiff ) ) { for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { status = TIFFReadDirectory ( tiff ) != 0 ? MagickTrue : MagickFalse ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { TIFFClose ( tiff ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } } } more_frames = MagickTrue ; do { photometric = PHOTOMETRIC_RGB ; if ( ( TIFFGetField ( tiff , TIFFTAG_IMAGEWIDTH , & width ) != 1 ) || ( TIFFGetField ( tiff , TIFFTAG_IMAGELENGTH , & height ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_PHOTOMETRIC , & photometric , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_COMPRESSION , & compress_tag , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_FILLORDER , & endian , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_PLANARCONFIG , & interlace , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_SAMPLESPERPIXEL , & samples_per_pixel , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_BITSPERSAMPLE , & bits_per_sample , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_SAMPLEFORMAT , & sample_format , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_MINSAMPLEVALUE , & min_sample_value , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_MAXSAMPLEVALUE , & max_sample_value , sans ) != 1 ) ) { TIFFClose ( tiff ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } if ( ( ( sample_format != SAMPLEFORMAT_IEEEFP ) || ( bits_per_sample != 64 ) ) && ( ( bits_per_sample <= 0 ) || ( bits_per_sample > 32 ) ) ) { TIFFClose ( tiff ) ; ThrowReaderException ( CorruptImageError , \"UnsupportedBitsPerPixel\" ) ; } if ( sample_format == SAMPLEFORMAT_IEEEFP ) ( void ) SetImageProperty ( image , \"quantum:format\" , \"floating-point\" , exception ) ; switch ( photometric ) { case PHOTOMETRIC_MINISBLACK : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"min-is-black\" , exception ) ; break ; } case PHOTOMETRIC_MINISWHITE : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"min-is-white\" , exception ) ; break ; } case PHOTOMETRIC_PALETTE : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"palette\" , exception ) ; break ; } case PHOTOMETRIC_RGB : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"RGB\" , exception ) ; break ; } case PHOTOMETRIC_CIELAB : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"CIELAB\" , exception ) ; break ; } case PHOTOMETRIC_LOGL : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"CIE<S2SV_blank>Log2(L)\" , exception ) ; break ; } case PHOTOMETRIC_LOGLUV : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"LOGLUV\" , exception ) ; break ; } # if defined ( PHOTOMETRIC_MASK ) case PHOTOMETRIC_MASK : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"MASK\" , exception ) ; break ; } # endif case PHOTOMETRIC_SEPARATED : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"separated\" , exception ) ; break ; } case PHOTOMETRIC_YCBCR : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"YCBCR\" , exception ) ; break ; } default : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"unknown\" , exception ) ; break ; } } if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Geometry:<S2SV_blank>%ux%u\" , ( unsigned int ) width , ( unsigned int ) height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Interlace:<S2SV_blank>%u\" , interlace ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Bits<S2SV_blank>per<S2SV_blank>sample:<S2SV_blank>%u\" , bits_per_sample ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Min<S2SV_blank>sample<S2SV_blank>value:<S2SV_blank>%u\" , min_sample_value ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Max<S2SV_blank>sample<S2SV_blank>value:<S2SV_blank>%u\" , max_sample_value ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Photometric<S2SV_blank>\" \"interpretation:<S2SV_blank>%s\" , GetImageProperty ( image , \"tiff:photometric\" , exception ) ) ; } image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = ( size_t ) bits_per_sample ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Image<S2SV_blank>depth:<S2SV_blank>%.20g\" , ( double ) image -> depth ) ; image -> endian = MSBEndian ; if ( endian == FILLORDER_LSB2MSB ) image -> endian = LSBEndian ; # if defined ( MAGICKCORE_HAVE_TIFFISBIGENDIAN ) if ( TIFFIsBigEndian ( tiff ) == 0 ) { ( void ) SetImageProperty ( image , \"tiff:endian\" , \"lsb\" , exception ) ; image -> endian = LSBEndian ; } else { ( void ) SetImageProperty ( image , \"tiff:endian\" , \"msb\" , exception ) ; image -> endian = MSBEndian ; } # endif if ( ( photometric == PHOTOMETRIC_MINISBLACK ) || ( photometric == PHOTOMETRIC_MINISWHITE ) ) image -> colorspace = GRAYColorspace ; if ( photometric == PHOTOMETRIC_SEPARATED ) image -> colorspace = CMYKColorspace ; if ( photometric == PHOTOMETRIC_CIELAB ) image -> colorspace = LabColorspace ; if ( ( photometric == PHOTOMETRIC_YCBCR ) && ( compress_tag != COMPRESSION_JPEG ) ) image -> colorspace = YCbCrColorspace ; status = TIFFGetProfiles ( tiff , image , exception ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; return ( DestroyImageList ( image ) ) ; } status = TIFFGetProperties ( tiff , image , exception ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; return ( DestroyImageList ( image ) ) ; } option = GetImageOption ( image_info , \"tiff:exif-properties\" ) ; if ( IsStringFalse ( option ) == MagickFalse ) TIFFGetEXIFProperties ( tiff , image , exception ) ; if ( ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_XRESOLUTION , & x_resolution , sans ) == 1 ) && ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_YRESOLUTION , & y_resolution , sans ) == 1 ) ) { image -> resolution . x = x_resolution ; image -> resolution . y = y_resolution ; } if ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_RESOLUTIONUNIT , & units , sans , sans ) == 1 ) { if ( units == RESUNIT_INCH ) image -> units = PixelsPerInchResolution ; if ( units == RESUNIT_CENTIMETER ) image -> units = PixelsPerCentimeterResolution ; } if ( ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_XPOSITION , & x_position , sans ) == 1 ) && ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_YPOSITION , & y_position , sans ) == 1 ) ) { image -> page . x = ( ssize_t ) ceil ( x_position * image -> resolution . x - 0.5 ) ; image -> page . y = ( ssize_t ) ceil ( y_position * image -> resolution . y - 0.5 ) ; } if ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_ORIENTATION , & orientation , sans ) == 1 ) image -> orientation = ( OrientationType ) orientation ; if ( TIFFGetField ( tiff , TIFFTAG_WHITEPOINT , & chromaticity ) == 1 ) { if ( ( chromaticity != ( float * ) NULL ) && ( * chromaticity != 0.0 ) ) { image -> chromaticity . white_point . x = chromaticity [ 0 ] ; image -> chromaticity . white_point . y = chromaticity [ 1 ] ; } } if ( TIFFGetField ( tiff , TIFFTAG_PRIMARYCHROMATICITIES , & chromaticity ) == 1 ) { if ( ( chromaticity != ( float * ) NULL ) && ( * chromaticity != 0.0 ) ) { image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; } } # if defined ( MAGICKCORE_HAVE_TIFFISCODECCONFIGURED ) || ( TIFFLIB_VERSION > 20040919 ) if ( ( compress_tag != COMPRESSION_NONE ) && ( TIFFIsCODECConfigured ( compress_tag ) == 0 ) ) { TIFFClose ( tiff ) ; ThrowReaderException ( CoderError , \"CompressNotSupported\" ) ; } # endif switch ( compress_tag ) { case COMPRESSION_NONE : image -> compression = NoCompression ; break ; case COMPRESSION_CCITTFAX3 : image -> compression = FaxCompression ; break ; case COMPRESSION_CCITTFAX4 : image -> compression = Group4Compression ; break ; case COMPRESSION_JPEG : { image -> compression = JPEGCompression ; # if defined ( JPEG_SUPPORT ) { char sampling_factor [ MagickPathExtent ] ; uint16 horizontal , vertical ; tiff_status = TIFFGetField ( tiff , TIFFTAG_YCBCRSUBSAMPLING , & horizontal , & vertical ) ; if ( tiff_status == 1 ) { ( void ) FormatLocaleString ( sampling_factor , MagickPathExtent , \"%dx%d\" , horizontal , vertical ) ; ( void ) SetImageProperty ( image , \"jpeg:sampling-factor\" , sampling_factor , exception ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Sampling<S2SV_blank>Factors:<S2SV_blank>%s\" , sampling_factor ) ; } } # endif break ; } case COMPRESSION_OJPEG : image -> compression = JPEGCompression ; break ; # if defined ( COMPRESSION_LZMA ) case COMPRESSION_LZMA : image -> compression = LZMACompression ; break ; # endif case COMPRESSION_LZW : image -> compression = LZWCompression ; break ; case COMPRESSION_DEFLATE : image -> compression = ZipCompression ; break ; case COMPRESSION_ADOBE_DEFLATE : image -> compression = ZipCompression ; break ; # if defined ( COMPRESSION_WEBP ) case COMPRESSION_WEBP : image -> compression = WebPCompression ; break ; # endif # if defined ( COMPRESSION_ZSTD ) case COMPRESSION_ZSTD : image -> compression = ZstdCompression ; break ; # endif default : image -> compression = RLECompression ; break ; } quantum_info = ( QuantumInfo * ) NULL ; if ( ( photometric == PHOTOMETRIC_PALETTE ) && ( pow ( 2.0 , 1.0 * bits_per_sample ) <= MaxColormapSize ) ) { size_t colors ; colors = ( size_t ) GetQuantumRange ( bits_per_sample ) + 1 ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) { TIFFClose ( tiff ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } } value = ( unsigned short ) image -> scene ; if ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_PAGENUMBER , & value , & pages , sans ) == 1 ) image -> scene = value ; if ( image -> storage_class == PseudoClass ) { size_t range ; uint16 * blue_colormap , * green_colormap , * red_colormap ; tiff_status = TIFFGetField ( tiff , TIFFTAG_COLORMAP , & red_colormap , & green_colormap , & blue_colormap ) ; if ( tiff_status == 1 ) { if ( ( red_colormap != ( uint16 * ) NULL ) && ( green_colormap != ( uint16 * ) NULL ) && ( blue_colormap != ( uint16 * ) NULL ) ) { range = 255 ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( ( red_colormap [ i ] >= 256 ) || ( green_colormap [ i ] >= 256 ) || ( blue_colormap [ i ] >= 256 ) ) { range = 65535 ; break ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) QuantumRange * red_colormap [ i ] ) / range ) ; image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) QuantumRange * green_colormap [ i ] ) / range ) ; image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) QuantumRange * blue_colormap [ i ] ) / range ) ; } } } } if ( image_info -> ping != MagickFalse ) { if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; goto next_tiff_frame ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; return ( DestroyImageList ( image ) ) ; } status = SetImageColorspace ( image , image -> colorspace , exception ) ; status &= ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( sample_format == SAMPLEFORMAT_UINT ) status = SetQuantumFormat ( image , quantum_info , UnsignedQuantumFormat ) ; if ( sample_format == SAMPLEFORMAT_INT ) status = SetQuantumFormat ( image , quantum_info , SignedQuantumFormat ) ; if ( sample_format == SAMPLEFORMAT_IEEEFP ) status = SetQuantumFormat ( image , quantum_info , FloatingPointQuantumFormat ) ; if ( status == MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; status = MagickTrue ; switch ( photometric ) { case PHOTOMETRIC_MINISBLACK : { quantum_info -> min_is_white = MagickFalse ; break ; } case PHOTOMETRIC_MINISWHITE : { quantum_info -> min_is_white = MagickTrue ; break ; } default : break ; } extra_samples = 0 ; tiff_status = TIFFGetFieldDefaulted ( tiff , TIFFTAG_EXTRASAMPLES , & extra_samples , & sample_info , sans ) ; if ( tiff_status == 1 ) { ( void ) SetImageProperty ( image , \"tiff:alpha\" , \"unspecified\" , exception ) ; if ( extra_samples == 0 ) { if ( ( samples_per_pixel == 4 ) && ( photometric == PHOTOMETRIC_RGB ) ) image -> alpha_trait = BlendPixelTrait ; } else for ( i = 0 ; i < extra_samples ; i ++ ) { image -> alpha_trait = BlendPixelTrait ; if ( sample_info [ i ] == EXTRASAMPLE_ASSOCALPHA ) { SetQuantumAlphaType ( quantum_info , AssociatedQuantumAlpha ) ; ( void ) SetImageProperty ( image , \"tiff:alpha\" , \"associated\" , exception ) ; } else if ( sample_info [ i ] == EXTRASAMPLE_UNASSALPHA ) { SetQuantumAlphaType ( quantum_info , DisassociatedQuantumAlpha ) ; ( void ) SetImageProperty ( image , \"tiff:alpha\" , \"unassociated\" , exception ) ; } } } if ( image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlphaChannel ( image , OpaqueAlphaChannel , exception ) ; if ( samples_per_pixel > MaxPixelChannels ) { TIFFClose ( tiff ) ; ThrowReaderException ( CorruptImageError , \"MaximumChannelsExceeded\" ) ; } method = ReadGenericMethod ; rows_per_strip = ( uint32 ) image -> rows ; if ( TIFFGetField ( tiff , TIFFTAG_ROWSPERSTRIP , & rows_per_strip ) == 1 ) { char buffer [ MagickPathExtent ] ; ( void ) FormatLocaleString ( buffer , MagickPathExtent , \"%u\" , ( unsigned int ) rows_per_strip ) ; ( void ) SetImageProperty ( image , \"tiff:rows-per-strip\" , buffer , exception ) ; method = ReadStripMethod ; if ( rows_per_strip > ( uint32 ) image -> rows ) rows_per_strip = ( uint32 ) image -> rows ; } if ( TIFFIsTiled ( tiff ) != MagickFalse ) { uint32 columns , rows ; if ( ( TIFFGetField ( tiff , TIFFTAG_TILEWIDTH , & columns ) != 1 ) || ( TIFFGetField ( tiff , TIFFTAG_TILELENGTH , & rows ) != 1 ) ) ThrowTIFFException ( CoderError , \"ImageIsNotTiled\" ) ; if ( ( AcquireMagickResource ( WidthResource , columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , rows ) == MagickFalse ) ) ThrowTIFFException ( ImageError , \"WidthOrHeightExceedsLimit\" ) ; method = ReadTileMethod ; } if ( image -> compression == JPEGCompression ) method = GetJPEGMethod ( image , tiff , photometric , bits_per_sample , samples_per_pixel ) ; if ( photometric == PHOTOMETRIC_LOGLUV ) method = ReadGenericMethod ; quantum_info -> endian = LSBEndian ; quantum_type = RGBQuantum ; if ( TIFFScanlineSize ( tiff ) <= 0 ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( ( 1.0 * TIFFScanlineSize ( tiff ) ) > ( 2.53 * GetBlobSize ( image ) ) ) ThrowTIFFException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; number_pixels = MagickMax ( TIFFScanlineSize ( tiff ) , MagickMax ( ( ssize_t ) image -> columns * samples_per_pixel * pow ( 2.0 , ceil ( log ( bits_per_sample ) / log ( 2.0 ) ) ) , image -> columns * rows_per_strip ) ) ; pixel_info = AcquireVirtualMemory ( number_pixels , sizeof ( uint32 ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) memset ( pixels , 0 , number_pixels * sizeof ( uint32 ) ) ; quantum_type = IndexQuantum ; pad = ( size_t ) MagickMax ( ( ssize_t ) samples_per_pixel - 1 , 0 ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { if ( image -> storage_class == PseudoClass ) quantum_type = IndexAlphaQuantum ; else quantum_type = samples_per_pixel == 1 ? AlphaQuantum : GrayAlphaQuantum ; } else if ( image -> storage_class != PseudoClass ) quantum_type = GrayQuantum ; if ( ( samples_per_pixel > 2 ) && ( interlace != PLANARCONFIG_SEPARATE ) ) { pad = ( size_t ) MagickMax ( ( size_t ) samples_per_pixel - 3 , 0 ) ; quantum_type = RGBQuantum ; if ( image -> alpha_trait != UndefinedPixelTrait ) { quantum_type = RGBAQuantum ; pad = ( size_t ) MagickMax ( ( size_t ) samples_per_pixel - 4 , 0 ) ; } if ( image -> colorspace == CMYKColorspace ) { pad = ( size_t ) MagickMax ( ( size_t ) samples_per_pixel - 4 , 0 ) ; quantum_type = CMYKQuantum ; if ( image -> alpha_trait != UndefinedPixelTrait ) { quantum_type = CMYKAQuantum ; pad = ( size_t ) MagickMax ( ( size_t ) samples_per_pixel - 5 , 0 ) ; } } status = SetQuantumPad ( image , quantum_info , pad * ( ( bits_per_sample + 7 ) >> 3 ) ) ; if ( status == MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } switch ( method ) { case ReadYCCKMethod : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; register ssize_t x ; unsigned char * p ; tiff_status = TIFFReadPixels ( tiff , 0 , y , ( char * ) pixels ) ; if ( tiff_status == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; p = pixels ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelCyan ( image , ScaleCharToQuantum ( ClampYCC ( ( double ) * p + ( 1.402 * ( double ) * ( p + 2 ) ) - 179.456 ) ) , q ) ; SetPixelMagenta ( image , ScaleCharToQuantum ( ClampYCC ( ( double ) * p - ( 0.34414 * ( double ) * ( p + 1 ) ) - ( 0.71414 * ( double ) * ( p + 2 ) ) + 135.45984 ) ) , q ) ; SetPixelYellow ( image , ScaleCharToQuantum ( ClampYCC ( ( double ) * p + ( 1.772 * ( double ) * ( p + 1 ) ) - 226.816 ) ) , q ) ; SetPixelBlack ( image , ScaleCharToQuantum ( ( unsigned char ) * ( p + 3 ) ) , q ) ; q += GetPixelChannels ( image ) ; p += 4 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case ReadStripMethod : { register unsigned char * p ; size_t extent ; ssize_t stride , strip_id ; tsize_t strip_size ; unsigned char * strip_pixels ; extent = TIFFStripSize ( tiff ) ; # if defined ( TIFF_VERSION_BIG ) extent += image -> columns * sizeof ( uint64 ) ; # else extent += image -> columns * sizeof ( uint32 ) ; # endif strip_pixels = ( unsigned char * ) AcquireQuantumMemory ( extent , <S2SV_StartBug> sizeof ( * strip_pixels ) ) ; <S2SV_EndBug> if ( strip_pixels == ( unsigned char * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( strip_pixels , 0 , extent * sizeof ( * strip_pixels ) ) ; stride = TIFFVStripSize ( tiff , 1 ) ; strip_id = 0 ; p = strip_pixels ; for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { size_t rows_remaining ; switch ( i ) { case 0 : break ; case 1 : quantum_type = GreenQuantum ; break ; case 2 : quantum_type = BlueQuantum ; break ; case 3 : { if ( image -> colorspace == CMYKColorspace ) quantum_type = BlackQuantum ; break ; } case 4 : quantum_type = AlphaQuantum ; break ; } rows_remaining = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( rows_remaining == 0 ) { strip_size = TIFFReadEncodedStrip ( tiff , strip_id , strip_pixels , TIFFStripSize ( tiff ) ) ; if ( strip_size == - 1 ) break ; rows_remaining = rows_per_strip ; if ( ( y + rows_per_strip ) > image -> rows ) rows_remaining = ( rows_per_strip - ( y + rows_per_strip - image -> rows ) ) ; p = strip_pixels ; strip_id ++ ; } ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , p , exception ) ; p += stride ; rows_remaining -- ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( ( samples_per_pixel > 1 ) && ( interlace != PLANARCONFIG_SEPARATE ) ) break ; } strip_pixels = ( unsigned char * ) RelinquishMagickMemory ( strip_pixels ) ; break ; } case ReadTileMethod : { register unsigned char * p ; size_t extent ; uint32 columns , rows ; unsigned char * tile_pixels ; if ( ( TIFFGetField ( tiff , TIFFTAG_TILEWIDTH , & columns ) != 1 ) || ( TIFFGetField ( tiff , TIFFTAG_TILELENGTH , & rows ) != 1 ) ) ThrowTIFFException ( CoderError , \"ImageIsNotTiled\" ) ; number_pixels = ( MagickSizeType ) columns * rows ; if ( HeapOverflowSanityCheck ( rows , sizeof ( * tile_pixels ) ) != MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; extent = TIFFTileSize ( tiff ) ; # if defined ( TIFF_VERSION_BIG ) extent += columns * sizeof ( uint64 ) ; # else extent += columns * sizeof ( uint32 ) ; # endif tile_pixels = ( unsigned char * ) AcquireQuantumMemory ( extent , sizeof ( * tile_pixels ) ) ; if ( tile_pixels == ( unsigned char * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( tile_pixels , 0 , extent * sizeof ( * tile_pixels ) ) ; for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { switch ( i ) { case 0 : break ; case 1 : quantum_type = GreenQuantum ; break ; case 2 : quantum_type = BlueQuantum ; break ; case 3 : { if ( image -> colorspace == CMYKColorspace ) quantum_type = BlackQuantum ; break ; } case 4 : quantum_type = AlphaQuantum ; break ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += rows ) { register ssize_t x ; size_t rows_remaining ; rows_remaining = image -> rows - y ; if ( ( ssize_t ) ( y + rows ) < ( ssize_t ) image -> rows ) rows_remaining = rows ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += columns ) { size_t columns_remaining , row ; columns_remaining = image -> columns - x ; if ( ( ssize_t ) ( x + columns ) < ( ssize_t ) image -> columns ) columns_remaining = columns ; if ( TIFFReadTile ( tiff , tile_pixels , ( uint32 ) x , ( uint32 ) y , 0 , i ) == 0 ) break ; p = tile_pixels ; for ( row = 0 ; row < rows_remaining ; row ++ ) { register Quantum * magick_restrict q ; q = GetAuthenticPixels ( image , x , y + row , columns_remaining , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , p , exception ) ; p += TIFFTileRowSize ( tiff ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } } if ( ( samples_per_pixel > 1 ) && ( interlace != PLANARCONFIG_SEPARATE ) ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) i , samples_per_pixel ) ; if ( status == MagickFalse ) break ; } } tile_pixels = ( unsigned char * ) RelinquishMagickMemory ( tile_pixels ) ; break ; } case ReadGenericMethod : default : { MemoryInfo * generic_info = ( MemoryInfo * ) NULL ; register uint32 * p ; uint32 * pixels ; if ( HeapOverflowSanityCheck ( image -> rows , sizeof ( * pixels ) ) != MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_pixels += image -> columns * sizeof ( uint32 ) ; generic_info = AcquireVirtualMemory ( number_pixels , sizeof ( uint32 ) ) ; if ( generic_info == ( MemoryInfo * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( uint32 * ) GetVirtualMemoryBlob ( generic_info ) ; ( void ) TIFFReadRGBAImage ( tiff , ( uint32 ) image -> columns , ( uint32 ) image -> rows , ( uint32 * ) pixels , 0 ) ; p = pixels + ( image -> columns * image -> rows ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register ssize_t x ; register Quantum * magick_restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; q += GetPixelChannels ( image ) * ( image -> columns - 1 ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) TIFFGetR ( * p ) ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) TIFFGetG ( * p ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) TIFFGetB ( * p ) ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) TIFFGetA ( * p ) ) , q ) ; p -- ; q -= GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } generic_info = RelinquishVirtualMemory ( generic_info ) ; break ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; SetQuantumImageType ( image , quantum_type ) ; next_tiff_frame : if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( photometric == PHOTOMETRIC_CIELAB ) DecodeLabImage ( image , exception ) ; if ( ( photometric == PHOTOMETRIC_LOGL ) || ( photometric == PHOTOMETRIC_MINISBLACK ) || ( photometric == PHOTOMETRIC_MINISWHITE ) ) { image -> type = GrayscaleType ; if ( bits_per_sample == 1 ) image -> type = BilevelType ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; more_frames = TIFFReadDirectory ( tiff ) != 0 ? MagickTrue : MagickFalse ; if ( more_frames != MagickFalse ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } } while ( ( status != MagickFalse ) && ( more_frames != MagickFalse ) ) ; TIFFClose ( tiff ) ; if ( status != MagickFalse ) TIFFReadPhotoshopLayers ( image_info , image , exception ) ; if ( ( image_info -> number_scenes != 0 ) && ( image_info -> scene >= GetImageListLength ( image ) ) ) status = MagickFalse ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( pixel_info <S2SV_ModStart> message ) ; \\\\\\n} <S2SV_ModEnd> const char * <S2SV_ModStart> ( extent , 2 *"}
{"source": "CWE-601 static apr_byte_t oidc_validate_post_logout_url ( request_rec * r , const char * url , char * * err_str , char * * err_desc ) { apr_uri_t uri ; const char * c_host = NULL ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { * err_str = apr_pstrdup ( r -> pool , \"Malformed<S2SV_blank>URL\" ) ; * err_desc = apr_psprintf ( r -> pool , \"Logout<S2SV_blank>URL<S2SV_blank>malformed:<S2SV_blank>%s\" , url ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; } c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { * err_str = apr_pstrdup ( r -> pool , \"Invalid<S2SV_blank>Request\" ) ; * err_desc = apr_psprintf ( r -> pool , \"logout<S2SV_blank>value<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>the<S2SV_blank>hostname<S2SV_blank>of<S2SV_blank>the<S2SV_blank>current<S2SV_blank>request<S2SV_blank>\\\\\"%s\\\\\"\" , apr_uri_unparse ( r -> pool , & uri , 0 ) , c_host ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; <S2SV_StartBug> } else if ( strstr ( url , \"/\" ) != url ) { <S2SV_EndBug> * err_str = apr_pstrdup ( r -> pool , \"Malformed<S2SV_blank>URL\" ) ; * err_desc = apr_psprintf ( r -> pool , \"No<S2SV_blank>hostname<S2SV_blank>was<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>seem<S2SV_blank>to<S2SV_blank>be<S2SV_blank>relative,<S2SV_blank>i.e<S2SV_blank>starting<S2SV_blank>with<S2SV_blank>\\'/\\':<S2SV_blank>%s\" , url ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; } if ( ( ( strstr ( url , \"\\\\n\" ) != NULL ) || strstr ( url , \"\\\\r\" ) != NULL ) ) { * err_str = apr_pstrdup ( r -> pool , \"Invalid<S2SV_blank>Request\" ) ; * err_desc = apr_psprintf ( r -> pool , \"logout<S2SV_blank>value<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>contains<S2SV_blank>illegal<S2SV_blank>\\\\\"\\\\n\\\\\"<S2SV_blank>or<S2SV_blank>\\\\\"\\\\r\\\\\"<S2SV_blank>character(s)\" , url ) ; oidc_error ( r , \"%s:<S2SV_blank>%s\" , * err_str , * err_desc ) ; return FALSE ; } return TRUE ; }", "target": "<S2SV_ModStart> else if ( ( uri . hostname == NULL ) && ( <S2SV_ModStart> != url ) )"}
{"source": "CWE-125 int jp2_encode ( jas_image_t * image , jas_stream_t * out , const char * optstr ) { jp2_box_t * box ; jp2_ftyp_t * ftyp ; jp2_ihdr_t * ihdr ; jas_stream_t * tmpstream ; int allcmptssame ; jp2_bpcc_t * bpcc ; long len ; uint_fast16_t cmptno ; jp2_colr_t * colr ; char buf [ 4096 ] ; uint_fast32_t overhead ; jp2_cdefchan_t * cdefchanent ; jp2_cdef_t * cdef ; int i ; uint_fast32_t typeasoc ; jas_iccprof_t * iccprof ; jas_stream_t * iccstream ; int pos ; int needcdef ; int prec ; int sgnd ; box = 0 ; tmpstream = 0 ; iccstream = 0 ; iccprof = 0 ; if ( jas_image_numcmpts ( image ) < 1 ) { jas_eprintf ( \"image<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>component\\\\n\" ) ; goto error ; } allcmptssame = 1 ; sgnd = jas_image_cmptsgnd ( image , 0 ) ; prec = jas_image_cmptprec ( image , 0 ) ; for ( i = 1 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_cmptsgnd ( image , i ) != sgnd || jas_image_cmptprec ( image , i ) != prec ) { allcmptssame = 0 ; break ; } } if ( ! ( box = jp2_box_create ( JP2_BOX_JP ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>JP<S2SV_blank>box\\\\n\" ) ; goto error ; } box -> data . jp . magic = JP2_JP_MAGIC ; if ( jp2_box_put ( box , out ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>JP<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_create ( JP2_BOX_FTYP ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>FTYP<S2SV_blank>box\\\\n\" ) ; goto error ; } ftyp = & box -> data . ftyp ; ftyp -> majver = JP2_FTYP_MAJVER ; ftyp -> minver = JP2_FTYP_MINVER ; ftyp -> numcompatcodes = 1 ; ftyp -> compatcodes [ 0 ] = JP2_FTYP_COMPATCODE ; if ( jp2_box_put ( box , out ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>FTYP<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>stream\\\\n\" ) ; goto error ; } if ( ! ( box = jp2_box_create ( JP2_BOX_IHDR ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>IHDR<S2SV_blank>box\\\\n\" ) ; goto error ; } ihdr = & box -> data . ihdr ; ihdr -> width = jas_image_width ( image ) ; ihdr -> height = jas_image_height ( image ) ; ihdr -> numcmpts = jas_image_numcmpts ( image ) ; ihdr -> bpc = allcmptssame ? JP2_SPTOBPC ( jas_image_cmptsgnd ( image , 0 ) , jas_image_cmptprec ( image , 0 ) ) : JP2_IHDR_BPCNULL ; ihdr -> comptype = JP2_IHDR_COMPTYPE ; ihdr -> csunk = 0 ; ihdr -> ipr = 0 ; if ( jp2_box_put ( box , tmpstream ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>IHDR<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! allcmptssame ) { if ( ! ( box = jp2_box_create ( JP2_BOX_BPCC ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>BPCC<S2SV_blank>box\\\\n\" ) ; goto error ; } bpcc = & box -> data . bpcc ; bpcc -> numcmpts = jas_image_numcmpts ( image ) ; if ( ! ( bpcc -> bpcs = jas_alloc2 ( bpcc -> numcmpts , sizeof ( uint_fast8_t ) ) ) ) { jas_eprintf ( \"memory<S2SV_blank>allocation<S2SV_blank>failed\\\\n\" ) ; goto error ; } for ( cmptno = 0 ; cmptno < bpcc -> numcmpts ; ++ cmptno ) { bpcc -> bpcs [ cmptno ] = JP2_SPTOBPC ( jas_image_cmptsgnd ( image , cmptno ) , jas_image_cmptprec ( image , cmptno ) ) ; } if ( jp2_box_put ( box , tmpstream ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>BPCC<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; } if ( ! ( box = jp2_box_create ( JP2_BOX_COLR ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>COLR<S2SV_blank>box\\\\n\" ) ; goto error ; } colr = & box -> data . colr ; switch ( jas_image_clrspc ( image ) ) { case JAS_CLRSPC_SRGB : case JAS_CLRSPC_SYCBCR : case JAS_CLRSPC_SGRAY : colr -> method = JP2_COLR_ENUM ; colr -> csid = clrspctojp2 ( jas_image_clrspc ( image ) ) ; colr -> pri = JP2_COLR_PRI ; colr -> approx = 0 ; break ; default : colr -> method = JP2_COLR_ICC ; colr -> pri = JP2_COLR_PRI ; colr -> approx = 0 ; if ( ! jas_image_cmprof ( image ) ) { jas_eprintf ( \"CM<S2SV_blank>profile<S2SV_blank>is<S2SV_blank>null\\\\n\" ) ; goto error ; } if ( ! ( iccprof = jas_iccprof_createfromcmprof ( jas_image_cmprof ( image ) ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>ICC<S2SV_blank>profile\\\\n\" ) ; goto error ; } if ( ! ( iccstream = jas_stream_memopen ( 0 , 0 ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>stream\\\\n\" ) ; goto error ; } if ( jas_iccprof_save ( iccprof , iccstream ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>ICC<S2SV_blank>profile\\\\n\" ) ; goto error ; } if ( ( pos = jas_stream_tell ( iccstream ) ) < 0 ) { jas_eprintf ( \"cannot<S2SV_blank>get<S2SV_blank>stream<S2SV_blank>position\\\\n\" ) ; goto error ; } colr -> iccplen = pos ; if ( ! ( colr -> iccp = jas_malloc ( pos ) ) ) { jas_eprintf ( \"memory<S2SV_blank>allocation<S2SV_blank>failed\\\\n\" ) ; goto error ; } jas_stream_rewind ( iccstream ) ; if ( jas_stream_read ( iccstream , colr -> iccp , colr -> iccplen ) != colr -> iccplen ) { jas_eprintf ( \"cannot<S2SV_blank>read<S2SV_blank>temporary<S2SV_blank>stream\\\\n\" ) ; goto error ; } jas_stream_close ( iccstream ) ; iccstream = 0 ; jas_iccprof_destroy ( iccprof ) ; iccprof = 0 ; break ; } if ( jp2_box_put ( box , tmpstream ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; needcdef = 1 ; switch ( jas_clrspc_fam ( jas_image_clrspc ( image ) ) ) { case JAS_CLRSPC_FAM_RGB : <S2SV_StartBug> if ( jas_image_cmpttype ( image , 0 ) == <S2SV_EndBug> JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) && jas_image_cmpttype ( image , 1 ) == JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) && jas_image_cmpttype ( image , 2 ) == JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) needcdef = 0 ; break ; case JAS_CLRSPC_FAM_YCBCR : <S2SV_StartBug> if ( jas_image_cmpttype ( image , 0 ) == <S2SV_EndBug> JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_YCBCR_Y ) && jas_image_cmpttype ( image , 1 ) == JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_YCBCR_CB ) && jas_image_cmpttype ( image , 2 ) == JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_YCBCR_CR ) ) needcdef = 0 ; break ; case JAS_CLRSPC_FAM_GRAY : <S2SV_StartBug> if ( jas_image_cmpttype ( image , 0 ) == <S2SV_EndBug> JAS_IMAGE_CT_COLOR ( JAS_IMAGE_CT_GRAY_Y ) ) needcdef = 0 ; break ; default : abort ( ) ; break ; } if ( needcdef ) { if ( ! ( box = jp2_box_create ( JP2_BOX_CDEF ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>CDEF<S2SV_blank>box\\\\n\" ) ; goto error ; } cdef = & box -> data . cdef ; cdef -> numchans = jas_image_numcmpts ( image ) ; cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ; for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { cdefchanent = & cdef -> ents [ i ] ; cdefchanent -> channo = i ; typeasoc = jp2_gettypeasoc ( jas_image_clrspc ( image ) , jas_image_cmpttype ( image , i ) ) ; cdefchanent -> type = typeasoc >> 16 ; cdefchanent -> assoc = typeasoc & 0x7fff ; } if ( jp2_box_put ( box , tmpstream ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>CDEF<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; } len = jas_stream_tell ( tmpstream ) ; jas_stream_rewind ( tmpstream ) ; if ( ! ( box = jp2_box_create ( JP2_BOX_JP2H ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>JP2H<S2SV_blank>box\\\\n\" ) ; goto error ; } box -> len = len + JP2_BOX_HDRLEN ( false ) ; if ( jp2_box_put ( box , out ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>JP2H<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( jas_stream_copy ( out , tmpstream , len ) ) { jas_eprintf ( \"cannot<S2SV_blank>copy<S2SV_blank>stream\\\\n\" ) ; goto error ; } jas_stream_close ( tmpstream ) ; tmpstream = 0 ; if ( ! ( box = jp2_box_create ( JP2_BOX_JP2C ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>create<S2SV_blank>JP2C<S2SV_blank>box\\\\n\" ) ; goto error ; } box -> len = 0 ; if ( jp2_box_put ( box , out ) ) { jas_eprintf ( \"cannot<S2SV_blank>write<S2SV_blank>JP2C<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; overhead = jas_stream_getrwcount ( out ) ; sprintf ( buf , \"%s\\\\n_jp2overhead=%lu\\\\n\" , ( optstr ? optstr : \"\" ) , ( unsigned long ) overhead ) ; if ( jpc_encode ( image , out , buf ) ) { jas_eprintf ( \"jpc_encode<S2SV_blank>failed\\\\n\" ) ; goto error ; } return 0 ; error : if ( iccprof ) { jas_iccprof_destroy ( iccprof ) ; } if ( iccstream ) { jas_stream_close ( iccstream ) ; } if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return - 1 ; }", "target": "<S2SV_ModStart> : if ( jas_image_numcmpts ( image ) >= 3 && <S2SV_ModStart> : if ( jas_image_numcmpts ( image ) >= 3 && <S2SV_ModStart> : if ( jas_image_numcmpts ( image ) >= 1 &&"}
{"source": "CWE-125 static BOOL clear_decompress_subcode_rlex ( wStream * s , UINT32 bitmapDataByteCount , UINT32 width , UINT32 height , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStep , UINT32 nXDstRel , UINT32 nYDstRel , UINT32 nDstWidth , UINT32 nDstHeight ) { UINT32 x = 0 , y = 0 ; UINT32 i ; UINT32 pixelCount ; UINT32 bitmapDataOffset ; <S2SV_StartBug> UINT32 pixelIndex ; <S2SV_EndBug> UINT32 numBits ; BYTE startIndex ; BYTE stopIndex ; BYTE suiteIndex ; BYTE suiteDepth ; BYTE paletteCount ; UINT32 palette [ 128 ] = { 0 } ; if ( Stream_GetRemainingLength ( s ) < bitmapDataByteCount ) { WLog_ERR ( TAG , \"stream<S2SV_blank>short<S2SV_blank>%\" PRIuz \"<S2SV_blank>[%\" PRIu32 \"<S2SV_blank>expected]\" , Stream_GetRemainingLength ( s ) , bitmapDataByteCount ) ; return FALSE ; } <S2SV_StartBug> Stream_Read_UINT8 ( s , paletteCount ) ; <S2SV_EndBug> bitmapDataOffset = 1 + ( paletteCount * 3 ) ; if ( ( paletteCount > 127 ) || ( paletteCount < 1 ) ) { WLog_ERR ( TAG , \"paletteCount<S2SV_blank>%\" PRIu8 \"\" , paletteCount ) ; return FALSE ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < paletteCount ; i ++ ) { BYTE r , g , b ; Stream_Read_UINT8 ( s , b ) ; Stream_Read_UINT8 ( s , g ) ; Stream_Read_UINT8 ( s , r ) ; palette [ i ] = FreeRDPGetColor ( DstFormat , r , g , b , 0xFF ) ; } pixelIndex = 0 ; pixelCount = width * height ; numBits = CLEAR_LOG2_FLOOR [ paletteCount - 1 ] + 1 ; while ( bitmapDataOffset < bitmapDataByteCount ) { UINT32 tmp ; UINT32 color ; UINT32 runLengthFactor ; if ( Stream_GetRemainingLength ( s ) < 2 ) { WLog_ERR ( TAG , \"stream<S2SV_blank>short<S2SV_blank>%\" PRIuz \"<S2SV_blank>[2<S2SV_blank>expected]\" , Stream_GetRemainingLength ( s ) ) ; return FALSE ; } Stream_Read_UINT8 ( s , tmp ) ; Stream_Read_UINT8 ( s , runLengthFactor ) ; bitmapDataOffset += 2 ; suiteDepth = ( tmp >> numBits ) & CLEAR_8BIT_MASKS [ ( 8 - numBits ) ] ; stopIndex = tmp & CLEAR_8BIT_MASKS [ numBits ] ; startIndex = stopIndex - suiteDepth ; if ( runLengthFactor >= 0xFF ) { if ( Stream_GetRemainingLength ( s ) < 2 ) { WLog_ERR ( TAG , \"stream<S2SV_blank>short<S2SV_blank>%\" PRIuz \"<S2SV_blank>[2<S2SV_blank>expected]\" , Stream_GetRemainingLength ( s ) ) ; return FALSE ; } Stream_Read_UINT16 ( s , runLengthFactor ) ; bitmapDataOffset += 2 ; if ( runLengthFactor >= 0xFFFF ) { if ( Stream_GetRemainingLength ( s ) < 4 ) { WLog_ERR ( TAG , \"stream<S2SV_blank>short<S2SV_blank>%\" PRIuz \"<S2SV_blank>[4<S2SV_blank>expected]\" , Stream_GetRemainingLength ( s ) ) ; return FALSE ; } Stream_Read_UINT32 ( s , runLengthFactor ) ; bitmapDataOffset += 4 ; } } if ( startIndex >= paletteCount ) { WLog_ERR ( TAG , \"startIndex<S2SV_blank>%\" PRIu8 \"<S2SV_blank>><S2SV_blank>paletteCount<S2SV_blank>%\" PRIu8 \"]\" , startIndex , paletteCount ) ; return FALSE ; } if ( stopIndex >= paletteCount ) { WLog_ERR ( TAG , \"stopIndex<S2SV_blank>%\" PRIu8 \"<S2SV_blank>><S2SV_blank>paletteCount<S2SV_blank>%\" PRIu8 \"]\" , stopIndex , paletteCount ) ; return FALSE ; } suiteIndex = startIndex ; if ( suiteIndex > 127 ) { WLog_ERR ( TAG , \"suiteIndex<S2SV_blank>%\" PRIu8 \"<S2SV_blank>><S2SV_blank>127]\" , suiteIndex ) ; return FALSE ; } color = palette [ suiteIndex ] ; if ( ( pixelIndex + runLengthFactor ) > pixelCount ) { WLog_ERR ( TAG , \"pixelIndex<S2SV_blank>%\" PRIu32 \"<S2SV_blank>+<S2SV_blank>runLengthFactor<S2SV_blank>%\" PRIu32 \"<S2SV_blank>><S2SV_blank>pixelCount<S2SV_blank>%\" PRIu32 \"\" , pixelIndex , runLengthFactor , pixelCount ) ; return FALSE ; } for ( i = 0 ; i < runLengthFactor ; i ++ ) { BYTE * pTmpData = & pDstData [ ( nXDstRel + x ) * GetBytesPerPixel ( DstFormat ) + ( nYDstRel + y ) * nDstStep ] ; if ( ( nXDstRel + x < nDstWidth ) && ( nYDstRel + y < nDstHeight ) ) WriteColor ( pTmpData , DstFormat , color ) ; if ( ++ x >= width ) { y ++ ; x = 0 ; } } pixelIndex += runLengthFactor ; if ( ( pixelIndex + ( suiteDepth + 1 ) ) > pixelCount ) { WLog_ERR ( TAG , \"pixelIndex<S2SV_blank>%\" PRIu32 \"<S2SV_blank>+<S2SV_blank>suiteDepth<S2SV_blank>%\" PRIu8 \"<S2SV_blank>+<S2SV_blank>1<S2SV_blank>><S2SV_blank>pixelCount<S2SV_blank>%\" PRIu32 \"\" , pixelIndex , suiteDepth , pixelCount ) ; return FALSE ; } for ( i = 0 ; i <= suiteDepth ; i ++ ) { BYTE * pTmpData = & pDstData [ ( nXDstRel + x ) * GetBytesPerPixel ( DstFormat ) + ( nYDstRel + y ) * nDstStep ] ; UINT32 color = palette [ suiteIndex ] ; if ( suiteIndex > 127 ) { WLog_ERR ( TAG , \"suiteIndex<S2SV_blank>%\" PRIu8 \"<S2SV_blank>><S2SV_blank>127\" , suiteIndex ) ; return FALSE ; } suiteIndex ++ ; if ( ( nXDstRel + x < nDstWidth ) && ( nYDstRel + y < nDstHeight ) ) WriteColor ( pTmpData , DstFormat , color ) ; if ( ++ x >= width ) { y ++ ; x = 0 ; } } pixelIndex += ( suiteDepth + 1 ) ; } if ( pixelIndex != pixelCount ) { <S2SV_StartBug> WLog_ERR ( TAG , \"pixelIndex<S2SV_blank>%\" PRIu32 \"<S2SV_blank>!=<S2SV_blank>pixelCount<S2SV_blank>%\" PRIu32 \"\" , pixelIndex , pixelCount ) ; <S2SV_EndBug> return FALSE ; } return TRUE ; }", "target": "<S2SV_ModStart> UINT32 bitmapDataOffset ; size_t <S2SV_ModEnd> pixelIndex ; UINT32 <S2SV_ModStart> FALSE ; } if ( Stream_GetRemainingLength ( s ) < 1 ) return FALSE ; <S2SV_ModStart> FALSE ; } if ( Stream_GetRemainingLength ( s ) < 3ULL * paletteCount ) return FALSE ; <S2SV_ModStart> TAG , \"pixelIndex<S2SV_blank>%\" PRIdz <S2SV_ModEnd> \"<S2SV_blank>!=<S2SV_blank>pixelCount<S2SV_blank>%\" PRIu32 \"\""}
{"source": "CWE-787 ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , Py_ssize_t bytes ) { UINT8 * ptr ; int framesize ; int c , chunks , advance ; int l , lines ; int i , j , x = 0 , y , ymax ; if ( bytes < 4 ) return 0 ; ptr = buf ; framesize = I32 ( ptr ) ; if ( framesize < I32 ( ptr ) ) return 0 ; <S2SV_StartBug> <S2SV_EndBug> if ( I16 ( ptr + 4 ) != 0xF1FA ) { state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } chunks = I16 ( ptr + 6 ) ; ptr += 16 ; bytes -= 16 ; for ( c = 0 ; c < chunks ; c ++ ) { UINT8 * data ; if ( bytes < 10 ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } data = ptr + 6 ; switch ( I16 ( ptr + 4 ) ) { case 4 : case 11 : break ; case 7 : lines = I16 ( data ) ; data += 2 ; for ( l = y = 0 ; l < lines && y < state -> ysize ; l ++ , y ++ ) { UINT8 * buf = ( UINT8 * ) im -> image [ y ] ; int p , packets ; packets = I16 ( data ) ; data += 2 ; while ( packets & 0x8000 ) { if ( packets & 0x4000 ) { y += 65536 - packets ; if ( y >= state -> ysize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } buf = ( UINT8 * ) im -> image [ y ] ; } else { buf [ state -> xsize - 1 ] = ( UINT8 ) packets ; } packets = I16 ( data ) ; data += 2 ; } for ( p = x = 0 ; p < packets ; p ++ ) { x += data [ 0 ] ; if ( data [ 1 ] >= 128 ) { i = 256 - data [ 1 ] ; if ( x + i + i > state -> xsize ) break ; for ( j = 0 ; j < i ; j ++ ) { buf [ x ++ ] = data [ 2 ] ; buf [ x ++ ] = data [ 3 ] ; } data += 2 + 2 ; } else { i = 2 * ( int ) data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( buf + x , data + 2 , i ) ; data += 2 + i ; x += i ; } } if ( p < packets ) break ; } if ( l < lines ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 12 : y = I16 ( data ) ; ymax = y + I16 ( data + 2 ) ; data += 4 ; for ( ; y < ymax && y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; int p , packets = * data ++ ; for ( p = x = 0 ; p < packets ; p ++ , x += i ) { x += data [ 0 ] ; if ( data [ 1 ] & 0x80 ) { i = 256 - data [ 1 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 2 ] , i ) ; data += 3 ; } else { i = data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 2 , i ) ; data += i + 2 ; } } if ( p < packets ) break ; } if ( y < ymax ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 13 : for ( y = 0 ; y < state -> ysize ; y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ; break ; case 15 : for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; data += 1 ; for ( x = 0 ; x < state -> xsize ; x += i ) { if ( data [ 0 ] & 0x80 ) { i = 256 - data [ 0 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 1 , i ) ; data += i + 1 ; } else { i = data [ 0 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 1 ] , i ) ; data += 2 ; } } if ( x != state -> xsize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } } break ; case 16 : for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * buf = ( UINT8 * ) im -> image [ y ] ; memcpy ( buf , data , state -> xsize ) ; data += state -> xsize ; } break ; case 18 : break ; default : state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } advance = I32 ( ptr ) ; ptr += advance ; bytes -= advance ; } return - 1 ; }", "target": "<S2SV_ModStart> return 0 ; if ( bytes < 8 ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; }"}
{"source": "CWE-617 bool RGWSwiftWebsiteHandler : : is_web_dir ( ) const { std : : string subdir_name = url_decode ( s -> object . name ) ; if ( subdir_name . empty ( ) ) { return false ; } else if ( subdir_name . back ( ) == '/' ) { <S2SV_StartBug> subdir_name . pop_back ( ) ; <S2SV_EndBug> } rgw_obj obj ( s -> bucket , std : : move ( subdir_name ) ) ; RGWObjectCtx & obj_ctx = * static_cast < RGWObjectCtx * > ( s -> obj_ctx ) ; obj_ctx . set_atomic ( obj ) ; obj_ctx . set_prefetch_data ( obj ) ; RGWObjState * state = nullptr ; if ( store -> get_obj_state ( & obj_ctx , s -> bucket_info , obj , & state , false ) < 0 ) { return false ; } if ( ! state -> exists ) { return false ; } std : : string content_type ; get_contype_from_attrs ( state -> attrset , content_type ) ; const auto & ws_conf = s -> bucket_info . website_conf ; const std : : string subdir_marker = ws_conf . subdir_marker . empty ( ) ? \"application/directory\" : ws_conf . subdir_marker ; return subdir_marker == content_type && state -> size <= 1 ; }", "target": "<S2SV_ModStart> ( ) ; if ( subdir_name . empty ( ) ) { return false ; }"}
{"source": "CWE-200 PJ_DEF ( pj_status_t ) pjmedia_sdp_neg_modify_local_offer2 ( pj_pool_t * pool , pjmedia_sdp_neg * neg , unsigned flags , const pjmedia_sdp_session * local ) { pjmedia_sdp_session * new_offer ; <S2SV_StartBug> pjmedia_sdp_session * old_offer ; <S2SV_EndBug> char media_used [ PJMEDIA_MAX_SDP_MEDIA ] ; unsigned oi ; pj_status_t status ; PJ_ASSERT_RETURN ( pool && neg && local , PJ_EINVAL ) ; PJ_ASSERT_RETURN ( neg -> state == PJMEDIA_SDP_NEG_STATE_DONE , PJMEDIA_SDPNEG_EINSTATE ) ; status = pjmedia_sdp_validate ( local ) ; if ( status != PJ_SUCCESS ) return status ; neg -> state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER ; <S2SV_StartBug> pj_bzero ( media_used , sizeof ( media_used ) ) ; <S2SV_EndBug> old_offer = neg -> active_local_sdp ; new_offer = pjmedia_sdp_session_clone ( pool , local ) ; pj_strdup ( pool , & new_offer -> origin . user , & old_offer -> origin . user ) ; new_offer -> origin . id = old_offer -> origin . id ; pj_strdup ( pool , & new_offer -> origin . net_type , & old_offer -> origin . net_type ) ; pj_strdup ( pool , & new_offer -> origin . addr_type , & old_offer -> origin . addr_type ) ; pj_strdup ( pool , & new_offer -> origin . addr , & old_offer -> origin . addr ) ; if ( ( flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE ) == 0 ) { for ( oi = 0 ; oi < old_offer -> media_count ; ++ oi ) { pjmedia_sdp_media * om ; pjmedia_sdp_media * nm ; unsigned ni ; pj_bool_t found = PJ_FALSE ; om = old_offer -> media [ oi ] ; for ( ni = oi ; ni < new_offer -> media_count ; ++ ni ) { nm = new_offer -> media [ ni ] ; if ( pj_strcmp ( & nm -> desc . media , & om -> desc . media ) == 0 ) { if ( ni != oi ) { pj_array_insert ( new_offer -> media , sizeof ( new_offer -> media [ 0 ] ) , ni , oi , & nm ) ; } found = PJ_TRUE ; break ; } } if ( ! found ) { pjmedia_sdp_media * m ; m = sdp_media_clone_deactivate ( pool , om , om , local ) ; pj_array_insert ( new_offer -> media , sizeof ( new_offer -> media [ 0 ] ) , new_offer -> media_count ++ , oi , & m ) ; } } } else { for ( oi = new_offer -> media_count ; oi < old_offer -> media_count ; ++ oi ) { pjmedia_sdp_media * m ; m = sdp_media_clone_deactivate ( pool , old_offer -> media [ oi ] , old_offer -> media [ oi ] , local ) ; pj_array_insert ( new_offer -> media , sizeof ( new_offer -> media [ 0 ] ) , new_offer -> media_count ++ , oi , & m ) ; } } # if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION new_offer -> origin . version = old_offer -> origin . version ; if ( pjmedia_sdp_session_cmp ( new_offer , neg -> initial_sdp , 0 ) != PJ_SUCCESS ) { ++ new_offer -> origin . version ; } # else new_offer -> origin . version = old_offer -> origin . version + 1 ; # endif neg -> initial_sdp_tmp = neg -> initial_sdp ; neg -> initial_sdp = new_offer ; neg -> neg_local_sdp = pjmedia_sdp_session_clone ( pool , new_offer ) ; return PJ_SUCCESS ; }", "target": "<S2SV_ModStart> pjmedia_sdp_session * old_offer <S2SV_ModEnd> ; unsigned oi <S2SV_ModStart> = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER ; if ( ! neg -> active_local_sdp ) { neg -> initial_sdp_tmp = NULL ; neg -> initial_sdp = pjmedia_sdp_session_clone ( pool , local ) ; neg -> neg_local_sdp = pjmedia_sdp_session_clone ( pool , local ) ; return PJ_SUCCESS ; } <S2SV_ModEnd> old_offer = neg"}
{"source": "CWE-787 static int __init lp_setup ( char * str ) { static int parport_ptr ; int x ; if ( get_option ( & str , & x ) ) { if ( x == 0 ) { parport_nr [ 0 ] = LP_PARPORT_OFF ; } else { printk ( KERN_WARNING \"warning:<S2SV_blank>\\'lp=0x%x\\'<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>ignored\\\\n\" , x ) ; return 0 ; } } else if ( ! strncmp ( str , \"parport\" , 7 ) ) { int n = simple_strtoul ( str + 7 , NULL , 10 ) ; if ( parport_ptr < LP_NO ) parport_nr [ parport_ptr ++ ] = n ; else printk ( KERN_INFO \"lp:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>ports,<S2SV_blank>%s<S2SV_blank>ignored.\\\\n\" , str ) ; } else if ( ! strcmp ( str , \"auto\" ) ) { parport_nr [ 0 ] = LP_PARPORT_AUTO ; } else if ( ! strcmp ( str , \"none\" ) ) { <S2SV_StartBug> parport_nr [ parport_ptr ++ ] = LP_PARPORT_NONE ; <S2SV_EndBug> } else if ( ! strcmp ( str , \"reset\" ) ) { reset = 1 ; } return 1 ; }", "target": "<S2SV_ModStart> ) ) { if ( parport_ptr < LP_NO ) <S2SV_ModStart> ] = LP_PARPORT_NONE ; else printk ( KERN_INFO \"lp:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>ports,<S2SV_blank>%s<S2SV_blank>ignored.\\\\n\" , str )"}
{"source": "CWE-125 static struct ext4_dir_entry_2 * do_split ( handle_t * handle , struct inode * dir , struct buffer_head * * bh , struct dx_frame * frame , struct dx_hash_info * hinfo ) { unsigned blocksize = dir -> i_sb -> s_blocksize ; unsigned count , continued ; struct buffer_head * bh2 ; ext4_lblk_t newblock ; u32 hash2 ; struct dx_map_entry * map ; char * data1 = ( * bh ) -> b_data , * data2 ; unsigned split , move , size ; struct ext4_dir_entry_2 * de = NULL , * de2 ; int csum_size = 0 ; int err = 0 , i ; if ( ext4_has_metadata_csum ( dir -> i_sb ) ) csum_size = sizeof ( struct ext4_dir_entry_tail ) ; bh2 = ext4_append ( handle , dir , & newblock ) ; if ( IS_ERR ( bh2 ) ) { brelse ( * bh ) ; * bh = NULL ; return ( struct ext4_dir_entry_2 * ) bh2 ; } BUFFER_TRACE ( * bh , \"get_write_access\" ) ; err = ext4_journal_get_write_access ( handle , * bh ) ; if ( err ) goto journal_error ; BUFFER_TRACE ( frame -> bh , \"get_write_access\" ) ; err = ext4_journal_get_write_access ( handle , frame -> bh ) ; if ( err ) goto journal_error ; data2 = bh2 -> b_data ; map = ( struct dx_map_entry * ) ( data2 + blocksize ) ; count = dx_make_map ( dir , ( struct ext4_dir_entry_2 * ) data1 , blocksize , hinfo , map ) ; map -= count ; dx_sort_map ( map , count ) ; size = 0 ; move = 0 ; for ( i = count - 1 ; i >= 0 ; i -- ) { if ( size + map [ i ] . size / 2 > blocksize / 2 ) break ; size += map [ i ] . size ; move ++ ; } <S2SV_StartBug> split = count - move ; <S2SV_EndBug> hash2 = map [ split ] . hash ; continued = hash2 == map [ split - 1 ] . hash ; dxtrace ( printk ( KERN_INFO \"Split<S2SV_blank>block<S2SV_blank>%lu<S2SV_blank>at<S2SV_blank>%x,<S2SV_blank>%i/%i\\\\n\" , ( unsigned long ) dx_get_block ( frame -> at ) , hash2 , split , count - split ) ) ; de2 = dx_move_dirents ( data1 , data2 , map + split , count - split , blocksize ) ; de = dx_pack_dirents ( data1 , blocksize ) ; de -> rec_len = ext4_rec_len_to_disk ( data1 + ( blocksize - csum_size ) - ( char * ) de , blocksize ) ; de2 -> rec_len = ext4_rec_len_to_disk ( data2 + ( blocksize - csum_size ) - ( char * ) de2 , blocksize ) ; if ( csum_size ) { ext4_initialize_dirent_tail ( * bh , blocksize ) ; ext4_initialize_dirent_tail ( bh2 , blocksize ) ; } dxtrace ( dx_show_leaf ( dir , hinfo , ( struct ext4_dir_entry_2 * ) data1 , blocksize , 1 ) ) ; dxtrace ( dx_show_leaf ( dir , hinfo , ( struct ext4_dir_entry_2 * ) data2 , blocksize , 1 ) ) ; if ( hinfo -> hash >= hash2 ) { swap ( * bh , bh2 ) ; de = de2 ; } dx_insert_block ( frame , hash2 + continued , newblock ) ; err = ext4_handle_dirty_dirblock ( handle , dir , bh2 ) ; if ( err ) goto journal_error ; err = ext4_handle_dirty_dx_node ( handle , dir , frame -> bh ) ; if ( err ) goto journal_error ; brelse ( bh2 ) ; dxtrace ( dx_show_index ( \"frame\" , frame -> entries ) ) ; return de ; journal_error : brelse ( * bh ) ; brelse ( bh2 ) ; * bh = NULL ; ext4_std_error ( dir -> i_sb , err ) ; return ERR_PTR ( err ) ; }", "target": "<S2SV_ModStart> ++ ; } if ( i > 0 ) <S2SV_ModStart> - move ; else split = count / 2 ;"}
{"source": "CWE-787 int ImagingLibTiffDecode ( Imaging im , ImagingCodecState state , UINT8 * buffer , Py_ssize_t bytes ) { TIFFSTATE * clientstate = ( TIFFSTATE * ) state -> context ; char * filename = \"tempfile.tif\" ; char * mode = \"r\" ; TIFF * tiff ; TRACE ( ( \"in<S2SV_blank>decoder:<S2SV_blank>bytes<S2SV_blank>%d\\\\n\" , bytes ) ) ; TRACE ( ( \"State:<S2SV_blank>count<S2SV_blank>%d,<S2SV_blank>state<S2SV_blank>%d,<S2SV_blank>x<S2SV_blank>%d,<S2SV_blank>y<S2SV_blank>%d,<S2SV_blank>ystep<S2SV_blank>%d\\\\n\" , state -> count , state -> state , state -> x , state -> y , state -> ystep ) ) ; TRACE ( ( \"State:<S2SV_blank>xsize<S2SV_blank>%d,<S2SV_blank>ysize<S2SV_blank>%d,<S2SV_blank>xoff<S2SV_blank>%d,<S2SV_blank>yoff<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> xsize , state -> ysize , state -> xoff , state -> yoff ) ) ; TRACE ( ( \"State:<S2SV_blank>bits<S2SV_blank>%d,<S2SV_blank>bytes<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> bits , state -> bytes ) ) ; TRACE ( ( \"Buffer:<S2SV_blank>%p:<S2SV_blank>%c%c%c%c\\\\n\" , buffer , ( char ) buffer [ 0 ] , ( char ) buffer [ 1 ] , ( char ) buffer [ 2 ] , ( char ) buffer [ 3 ] ) ) ; TRACE ( ( \"State->Buffer:<S2SV_blank>%c%c%c%c\\\\n\" , ( char ) state -> buffer [ 0 ] , ( char ) state -> buffer [ 1 ] , ( char ) state -> buffer [ 2 ] , ( char ) state -> buffer [ 3 ] ) ) ; TRACE ( ( \"Image:<S2SV_blank>mode<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>bands:<S2SV_blank>%d,<S2SV_blank>xsize<S2SV_blank>%d,<S2SV_blank>ysize<S2SV_blank>%d<S2SV_blank>\\\\n\" , im -> mode , im -> type , im -> bands , im -> xsize , im -> ysize ) ) ; TRACE ( ( \"Image:<S2SV_blank>image8<S2SV_blank>%p,<S2SV_blank>image32<S2SV_blank>%p,<S2SV_blank>image<S2SV_blank>%p,<S2SV_blank>block<S2SV_blank>%p<S2SV_blank>\\\\n\" , im -> image8 , im -> image32 , im -> image , im -> block ) ) ; TRACE ( ( \"Image:<S2SV_blank>pixelsize:<S2SV_blank>%d,<S2SV_blank>linesize<S2SV_blank>%d<S2SV_blank>\\\\n\" , im -> pixelsize , im -> linesize ) ) ; dump_state ( clientstate ) ; clientstate -> size = bytes ; clientstate -> eof = clientstate -> size ; clientstate -> loc = 0 ; clientstate -> data = ( tdata_t ) buffer ; clientstate -> flrealloc = 0 ; dump_state ( clientstate ) ; TIFFSetWarningHandler ( NULL ) ; TIFFSetWarningHandlerExt ( NULL ) ; if ( clientstate -> fp ) { TRACE ( ( \"Opening<S2SV_blank>using<S2SV_blank>fd:<S2SV_blank>%d\\\\n\" , clientstate -> fp ) ) ; lseek ( clientstate -> fp , 0 , SEEK_SET ) ; tiff = TIFFFdOpen ( clientstate -> fp , filename , mode ) ; } else { TRACE ( ( \"Opening<S2SV_blank>from<S2SV_blank>string\\\\n\" ) ) ; tiff = TIFFClientOpen ( filename , mode , ( thandle_t ) clientstate , _tiffReadProc , _tiffWriteProc , _tiffSeekProc , _tiffCloseProc , _tiffSizeProc , _tiffMapProc , _tiffUnmapProc ) ; } if ( ! tiff ) { TRACE ( ( \"Error,<S2SV_blank>didn\\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>tiff\\\\n\" ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; return - 1 ; } if ( clientstate -> ifd ) { int rv ; uint32 ifdoffset = clientstate -> ifd ; TRACE ( ( \"reading<S2SV_blank>tiff<S2SV_blank>ifd<S2SV_blank>%u\\\\n\" , ifdoffset ) ) ; rv = TIFFSetSubDirectory ( tiff , ifdoffset ) ; if ( ! rv ) { TRACE ( ( \"error<S2SV_blank>in<S2SV_blank>TIFFSetSubDirectory\" ) ) ; return - 1 ; } } if ( TIFFIsTiled ( tiff ) ) { UINT32 x , y , tile_y , row_byte_size ; UINT32 tile_width , tile_length , current_tile_width ; UINT8 * new_data ; TIFFGetField ( tiff , TIFFTAG_TILEWIDTH , & tile_width ) ; TIFFGetField ( tiff , TIFFTAG_TILELENGTH , & tile_length ) ; row_byte_size = ( tile_width * state -> bits + 7 ) / 8 ; <S2SV_StartBug> state -> bytes = row_byte_size * tile_length ; <S2SV_EndBug> if ( state -> bytes > INT_MAX - 1 ) { state -> errcode = IMAGING_CODEC_MEMORY ; TIFFClose ( tiff ) ; return - 1 ; <S2SV_StartBug> } <S2SV_EndBug> new_data = realloc ( state -> buffer , state -> bytes ) ; if ( ! new_data ) { state -> errcode = IMAGING_CODEC_MEMORY ; TIFFClose ( tiff ) ; return - 1 ; } state -> buffer = new_data ; TRACE ( ( \"TIFFTileSize:<S2SV_blank>%d\\\\n\" , state -> bytes ) ) ; for ( y = state -> yoff ; y < state -> ysize ; y += tile_length ) { for ( x = state -> xoff ; x < state -> xsize ; x += tile_width ) { if ( ReadTile ( tiff , x , y , ( UINT32 * ) state -> buffer ) == - 1 ) { TRACE ( ( \"Decode<S2SV_blank>Error,<S2SV_blank>Tile<S2SV_blank>at<S2SV_blank>%dx%d\\\\n\" , x , y ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; TIFFClose ( tiff ) ; return - 1 ; } TRACE ( ( \"Read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%dx%d;<S2SV_blank>\\\\n\\\\n\" , x , y ) ) ; current_tile_width = min ( tile_width , state -> xsize - x ) ; for ( tile_y = 0 ; tile_y < min ( tile_length , state -> ysize - y ) ; tile_y ++ ) { TRACE ( ( \"Writing<S2SV_blank>tile<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%dx%d<S2SV_blank>using<S2SV_blank>tile_width:<S2SV_blank>%d;<S2SV_blank>\\\\n\" , tile_y + y , x , current_tile_width ) ) ; state -> shuffle ( ( UINT8 * ) im -> image [ tile_y + y ] + x * im -> pixelsize , state -> buffer + tile_y * row_byte_size , current_tile_width ) ; } } } } else { UINT32 strip_row , row_byte_size ; UINT8 * new_data ; UINT32 rows_per_strip ; int ret ; ret = TIFFGetField ( tiff , TIFFTAG_ROWSPERSTRIP , & rows_per_strip ) ; if ( ret != 1 ) { rows_per_strip = state -> ysize ; } TRACE ( ( \"RowsPerStrip:<S2SV_blank>%u<S2SV_blank>\\\\n\" , rows_per_strip ) ) ; <S2SV_StartBug> row_byte_size = ( state -> xsize * state -> bits + 7 ) / 8 ; <S2SV_EndBug> state -> bytes = rows_per_strip * row_byte_size ; TRACE ( ( \"StripSize:<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> bytes ) ) ; new_data = realloc ( state -> buffer , state -> bytes ) ; if ( ! new_data ) { state -> errcode = IMAGING_CODEC_MEMORY ; TIFFClose ( tiff ) ; return - 1 ; } state -> buffer = new_data ; for ( ; state -> y < state -> ysize ; state -> y += rows_per_strip ) { if ( ReadStrip ( tiff , state -> y , ( UINT32 * ) state -> buffer ) == - 1 ) { TRACE ( ( \"Decode<S2SV_blank>Error,<S2SV_blank>strip<S2SV_blank>%d\\\\n\" , TIFFComputeStrip ( tiff , state -> y , 0 ) ) ) ; state -> errcode = IMAGING_CODEC_BROKEN ; TIFFClose ( tiff ) ; return - 1 ; } TRACE ( ( \"Decoded<S2SV_blank>strip<S2SV_blank>for<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>\\\\n\" , state -> y ) ) ; for ( strip_row = 0 ; strip_row < min ( rows_per_strip , state -> ysize - state -> y ) ; strip_row ++ ) { TRACE ( ( \"Writing<S2SV_blank>data<S2SV_blank>into<S2SV_blank>line<S2SV_blank>%d<S2SV_blank>;<S2SV_blank>\\\\n\" , state -> y + strip_row ) ) ; state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff + strip_row ] + state -> xoff * im -> pixelsize , state -> buffer + strip_row * row_byte_size , state -> xsize ) ; } } } TIFFClose ( tiff ) ; TRACE ( ( \"Done<S2SV_blank>Decoding,<S2SV_blank>Returning<S2SV_blank>\\\\n\" ) ) ; return - 1 ; }", "target": "<S2SV_ModStart> / 8 ; if ( INT_MAX / row_byte_size < tile_length <S2SV_ModEnd> ) { state <S2SV_ModStart> 1 ; } state -> bytes = row_byte_size * tile_length ; <S2SV_ModStart> / 8 ; if ( INT_MAX / row_byte_size < rows_per_strip ) { state -> errcode = IMAGING_CODEC_MEMORY ; TIFFClose ( tiff ) ; return - 1 ; }"}
{"source": "CWE-416 <S2SV_StartBug> static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) <S2SV_EndBug> { <S2SV_StartBug> struct bfq_data * bfqd = bfqq -> bfqd ; <S2SV_EndBug> enum bfqq_expiration reason ; unsigned long flags ; <S2SV_StartBug> spin_lock_irqsave ( & bfqd -> lock , flags ) ; <S2SV_EndBug> bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ;", "target": "<S2SV_ModStart> void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , <S2SV_ModStart> bfqq ) { <S2SV_ModEnd> enum bfqq_expiration reason <S2SV_ModStart> lock , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> return ; } bfq_clear_bfqq_wait_request ( bfqq ) ;"}
{"source": "CWE-284 crypt_pw_cmp ( const char * userpwd , const char * dbpwd ) { <S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> char * cp ; <S2SV_EndBug> struct crypt_data data ; data . initialized = 0 ; <S2SV_StartBug> cp = crypt_r ( userpwd , dbpwd , & data ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cp ) { <S2SV_EndBug> <S2SV_StartBug> rc = slapi_ct_memcmp ( dbpwd , cp , strlen ( dbpwd ) ) ; <S2SV_EndBug> } else { rc = - 1 ; } return rc ; }", "target": "<S2SV_ModStart> { int rc = - 1 <S2SV_ModStart> char * cp = NULL ; size_t dbpwd_len = strlen ( dbpwd ) <S2SV_ModStart> = 0 ; if ( dbpwd_len >= 3 ) { <S2SV_ModStart> data ) ; } <S2SV_ModStart> if ( cp && dbpwd_len == strlen ( cp ) <S2SV_ModStart> , cp , dbpwd_len <S2SV_ModEnd> ) ; }"}
{"source": "CWE-787 static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , \"TCOS3:%d<S2SV_blank>PKCS1:%d\\\\n\" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; <S2SV_StartBug> memcpy ( sbuf + 1 , crgram , crgram_len ) ; <S2SV_EndBug> r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , \"APDU<S2SV_blank>transmit<S2SV_blank>failed\" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }", "target": "<S2SV_ModStart> 0x02 ) ; if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ;"}
{"source": "CWE-787 void luaD_callnoyield ( lua_State * L , StkId func , int nResults ) { incXCcalls ( L ) ; <S2SV_StartBug> if ( getCcalls ( L ) <= CSTACKERR ) <S2SV_EndBug> <S2SV_StartBug> luaE_freeCI ( L ) ; <S2SV_EndBug> luaD_call ( L , func , nResults ) ; decXCcalls ( L ) ; }", "target": "<S2SV_ModStart> <= CSTACKERR ) { luaE_exitCcall <S2SV_ModEnd> ( L ) <S2SV_ModStart> L ) ; luaE_enterCcall ( L ) ; }"}
{"source": "CWE-617 static int jpc_dec_decodepkt ( jpc_dec_t * dec , jas_stream_t * pkthdrstream , jas_stream_t * in , int compno , int rlvlno , int prcno , int lyrno ) { jpc_bitstream_t * inb ; jpc_dec_tcomp_t * tcomp ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; jpc_dec_cblk_t * cblk ; int n ; int m ; int i ; jpc_tagtreenode_t * leaf ; int included ; int ret ; int numnewpasses ; jpc_dec_seg_t * seg ; int len ; int present ; int savenumnewpasses ; int mycounter ; jpc_ms_t * ms ; jpc_dec_tile_t * tile ; jpc_dec_ccp_t * ccp ; jpc_dec_cp_t * cp ; int bandno ; jpc_dec_prc_t * prc ; int usedcblkcnt ; int cblkno ; uint_fast32_t bodylen ; bool discard ; int passno ; int maxpasses ; int hdrlen ; int hdroffstart ; int hdroffend ; bodylen = 0 ; discard = ( lyrno >= dec -> maxlyrs ) ; tile = dec -> curtile ; cp = tile -> cp ; ccp = & cp -> ccps [ compno ] ; if ( cp -> csty & JPC_COD_SOP ) { if ( jpc_dec_lookahead ( in ) == JPC_MS_SOP ) { if ( ! ( ms = jpc_getms ( in , dec -> cstate ) ) ) { return - 1 ; } if ( jpc_ms_gettype ( ms ) != JPC_MS_SOP ) { jpc_ms_destroy ( ms ) ; jas_eprintf ( \"missing<S2SV_blank>SOP<S2SV_blank>marker<S2SV_blank>segment\\\\n\" ) ; return - 1 ; } jpc_ms_destroy ( ms ) ; } } hdroffstart = jas_stream_getrwcount ( pkthdrstream ) ; if ( ! ( inb = jpc_bitstream_sopen ( pkthdrstream , \"r\" ) ) ) { return - 1 ; } if ( ( present = jpc_bitstream_getbit ( inb ) ) < 0 ) { jpc_bitstream_close ( inb ) ; return 1 ; } JAS_DBGLOG ( 10 , ( \"\\\\n\" , present ) ) ; JAS_DBGLOG ( 10 , ( \"present=%d<S2SV_blank>\" , present ) ) ; if ( present ) { tcomp = & tile -> tcomps [ compno ] ; rlvl = & tcomp -> rlvls [ rlvlno ] ; bodylen = 0 ; for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { if ( ! band -> data ) { continue ; } prc = & band -> prcs [ prcno ] ; if ( ! prc -> cblks ) { continue ; } usedcblkcnt = 0 ; for ( cblkno = 0 , cblk = prc -> cblks ; cblkno < prc -> numcblks ; ++ cblkno , ++ cblk ) { ++ usedcblkcnt ; if ( ! cblk -> numpasses ) { leaf = jpc_tagtree_getleaf ( prc -> incltagtree , usedcblkcnt - 1 ) ; if ( ( included = jpc_tagtree_decode ( prc -> incltagtree , leaf , lyrno + 1 , inb ) ) < 0 ) { jpc_bitstream_close ( inb ) ; return - 1 ; } } else { if ( ( included = jpc_bitstream_getbit ( inb ) ) < 0 ) { jpc_bitstream_close ( inb ) ; return - 1 ; } } JAS_DBGLOG ( 10 , ( \"\\\\n\" ) ) ; JAS_DBGLOG ( 10 , ( \"included=%d<S2SV_blank>\" , included ) ) ; if ( ! included ) { continue ; } if ( ! cblk -> numpasses ) { i = 1 ; leaf = jpc_tagtree_getleaf ( prc -> numimsbstagtree , usedcblkcnt - 1 ) ; for ( ; ; ) { if ( ( ret = jpc_tagtree_decode ( prc -> numimsbstagtree , leaf , i , inb ) ) < 0 ) { jpc_bitstream_close ( inb ) ; return - 1 ; } if ( ret ) { break ; } ++ i ; } cblk -> numimsbs = i - 1 ; cblk -> firstpassno = cblk -> numimsbs * 3 ; } if ( ( numnewpasses = jpc_getnumnewpasses ( inb ) ) < 0 ) { jpc_bitstream_close ( inb ) ; return - 1 ; } JAS_DBGLOG ( 10 , ( \"numnewpasses=%d<S2SV_blank>\" , numnewpasses ) ) ; seg = cblk -> curseg ; savenumnewpasses = numnewpasses ; mycounter = 0 ; if ( numnewpasses > 0 ) { <S2SV_StartBug> if ( ( m = jpc_getcommacode ( inb ) ) < 0 ) { <S2SV_EndBug> jpc_bitstream_close ( inb ) ; return - 1 ; } cblk -> numlenbits += m ; JAS_DBGLOG ( 10 , ( \"increment=%d<S2SV_blank>\" , m ) ) ; while ( numnewpasses > 0 ) { passno = cblk -> firstpassno + cblk -> numpasses + mycounter ; maxpasses = JPC_SEGPASSCNT ( passno , cblk -> firstpassno , 10000 , ( ccp -> cblkctx & JPC_COX_LAZY ) != 0 , ( ccp -> cblkctx & JPC_COX_TERMALL ) != 0 ) ; if ( ! discard && ! seg ) { if ( ! ( seg = jpc_seg_alloc ( ) ) ) { jpc_bitstream_close ( inb ) ; return - 1 ; } jpc_seglist_insert ( & cblk -> segs , cblk -> segs . tail , seg ) ; if ( ! cblk -> curseg ) { cblk -> curseg = seg ; } seg -> passno = passno ; seg -> type = JPC_SEGTYPE ( seg -> passno , cblk -> firstpassno , ( ccp -> cblkctx & JPC_COX_LAZY ) != 0 ) ; seg -> maxpasses = maxpasses ; } n = JAS_MIN ( numnewpasses , maxpasses ) ; mycounter += n ; numnewpasses -= n ; if ( ( len = jpc_bitstream_getbits ( inb , cblk -> numlenbits + jpc_floorlog2 ( n ) ) ) < 0 ) { jpc_bitstream_close ( inb ) ; return - 1 ; } JAS_DBGLOG ( 10 , ( \"len=%d<S2SV_blank>\" , len ) ) ; if ( ! discard ) { seg -> lyrno = lyrno ; seg -> numpasses += n ; seg -> cnt = len ; seg = seg -> next ; } bodylen += len ; } } cblk -> numpasses += savenumnewpasses ; } } jpc_bitstream_inalign ( inb , 0 , 0 ) ; } else { if ( jpc_bitstream_inalign ( inb , 0x7f , 0 ) ) { jas_eprintf ( \"alignment<S2SV_blank>failed\\\\n\" ) ; jpc_bitstream_close ( inb ) ; return - 1 ; } } jpc_bitstream_close ( inb ) ; hdroffend = jas_stream_getrwcount ( pkthdrstream ) ; hdrlen = hdroffend - hdroffstart ; if ( jas_getdbglevel ( ) >= 5 ) { jas_eprintf ( \"hdrlen=%lu<S2SV_blank>bodylen=%lu<S2SV_blank>\\\\n\" , ( unsigned long ) hdrlen , ( unsigned long ) bodylen ) ; } if ( cp -> csty & JPC_COD_EPH ) { if ( jpc_dec_lookahead ( pkthdrstream ) == JPC_MS_EPH ) { if ( ! ( ms = jpc_getms ( pkthdrstream , dec -> cstate ) ) ) { jas_eprintf ( \"cannot<S2SV_blank>get<S2SV_blank>(EPH)<S2SV_blank>marker<S2SV_blank>segment\\\\n\" ) ; return - 1 ; } if ( jpc_ms_gettype ( ms ) != JPC_MS_EPH ) { jpc_ms_destroy ( ms ) ; jas_eprintf ( \"missing<S2SV_blank>EPH<S2SV_blank>marker<S2SV_blank>segment\\\\n\" ) ; return - 1 ; } jpc_ms_destroy ( ms ) ; } } if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( \"packet<S2SV_blank>body<S2SV_blank>offset=%06ld\\\\n\" , ( long ) jas_stream_getrwcount ( in ) ) ; } if ( ! discard ) { tcomp = & tile -> tcomps [ compno ] ; rlvl = & tcomp -> rlvls [ rlvlno ] ; for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { if ( ! band -> data ) { continue ; } prc = & band -> prcs [ prcno ] ; if ( ! prc -> cblks ) { continue ; } for ( cblkno = 0 , cblk = prc -> cblks ; cblkno < prc -> numcblks ; ++ cblkno , ++ cblk ) { seg = cblk -> curseg ; while ( seg ) { if ( ! seg -> stream ) { if ( ! ( seg -> stream = jas_stream_memopen ( 0 , 0 ) ) ) { return - 1 ; } } # if 0 jas_eprintf ( \"lyrno=%02d,<S2SV_blank>compno=%02d,<S2SV_blank>lvlno=%02d,<S2SV_blank>prcno=%02d,<S2SV_blank>bandno=%02d,<S2SV_blank>cblkno=%02d,<S2SV_blank>passno=%02d<S2SV_blank>numpasses=%02d<S2SV_blank>cnt=%d<S2SV_blank>numbps=%d,<S2SV_blank>numimsbs=%d\\\\n\" , lyrno , compno , rlvlno , prcno , band - rlvl -> bands , cblk - prc -> cblks , seg -> passno , seg -> numpasses , seg -> cnt , band -> numbps , cblk -> numimsbs ) ; # endif if ( seg -> cnt > 0 ) { if ( jpc_getdata ( in , seg -> stream , seg -> cnt ) < 0 ) { return - 1 ; } seg -> cnt = 0 ; } if ( seg -> numpasses >= seg -> maxpasses ) { cblk -> curseg = seg -> next ; } seg = seg -> next ; } } } } else { if ( jas_stream_gobble ( in , bodylen ) != JAS_CAST ( int , bodylen ) ) { return - 1 ; } } return 0 ; }", "target": "<S2SV_ModStart> { if ( cblk -> firstpassno > 10000 ) { jpc_bitstream_close ( inb ) ; return - 1 ; } if ("}
{"source": "CWE-77 wsrep_cb_status_t wsrep_sst_donate_cb ( void * app_ctx , void * recv_ctx , const void * msg , size_t msg_len , const wsrep_gtid_t * current_gtid , const char * state , size_t state_len , bool bypass ) { <S2SV_StartBug> local_status . set ( WSREP_MEMBER_DONOR ) ; <S2SV_EndBug> const char * method = ( char * ) msg ; <S2SV_StartBug> size_t method_len = strlen ( method ) ; <S2SV_EndBug> const char * data = method + method_len + 1 ; <S2SV_StartBug> char uuid_str [ 37 ] ; <S2SV_EndBug> <S2SV_StartBug> wsrep_uuid_print ( & current_gtid -> uuid , uuid_str , sizeof ( uuid_str ) ) ; <S2SV_EndBug> wsp : : env env ( NULL ) ; if ( env . error ( ) ) { WSREP_ERROR ( \"wsrep_sst_donate_cb():<S2SV_blank>env<S2SV_blank>var<S2SV_blank>ctor<S2SV_blank>failed:<S2SV_blank>%d\" , - env . error ( ) ) ; return WSREP_CB_FAILURE ; } int ret ; if ( ( ret = sst_append_auth_env ( env , sst_auth_real ) ) ) { WSREP_ERROR ( \"wsrep_sst_donate_cb():<S2SV_blank>appending<S2SV_blank>auth<S2SV_blank>env<S2SV_blank>failed:<S2SV_blank>%d\" , ret ) ; return WSREP_CB_FAILURE ; } if ( ! strcmp ( WSREP_SST_MYSQLDUMP , method ) ) { ret = sst_donate_mysqldump ( data , & current_gtid -> uuid , uuid_str , current_gtid -> seqno , bypass , env ( ) ) ; } else { ret = sst_donate_other ( method , data , uuid_str , current_gtid -> seqno , bypass , env ( ) ) ; } return ( ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE ) ; }", "target": "<S2SV_ModStart> bypass ) { <S2SV_ModEnd> const char * <S2SV_ModStart> method ) ; if ( check_request_str ( method , filename_char ) ) { WSREP_ERROR ( \"Bad<S2SV_blank>SST<S2SV_blank>method<S2SV_blank>name.<S2SV_blank>SST<S2SV_blank>canceled.\" ) ; return WSREP_CB_FAILURE ; } <S2SV_ModStart> + 1 ; if ( check_request_str ( data , address_char ) ) { WSREP_ERROR ( \"Bad<S2SV_blank>SST<S2SV_blank>address<S2SV_blank>string.<S2SV_blank>SST<S2SV_blank>canceled.\" ) ; return WSREP_CB_FAILURE ; } <S2SV_ModStart> ( uuid_str ) ) ; local_status . set ( WSREP_MEMBER_DONOR"}
{"source": "CWE-125 FLAC__bool FLAC__bitreader_read_rice_signed_block ( FLAC__BitReader * br , int vals [ ] , uint32_t nvals , uint32_t parameter ) { uint32_t cwords , words , lsbs , msbs , x , y ; uint32_t ucbits ; brword b ; int * val , * end ; FLAC__ASSERT ( 0 != br ) ; FLAC__ASSERT ( 0 != br -> buffer ) ; FLAC__ASSERT ( FLAC__BITS_PER_WORD >= 32 ) ; FLAC__ASSERT ( parameter < 32 ) ; val = vals ; end = vals + nvals ; if ( parameter == 0 ) { while ( val < end ) { if ( ! FLAC__bitreader_read_unary_unsigned ( br , & msbs ) ) return false ; * val ++ = ( int ) ( msbs >> 1 ) ^ - ( int ) ( msbs & 1 ) ; } return true ; } FLAC__ASSERT ( parameter > 0 ) ; cwords = br -> consumed_words ; words = br -> words ; if ( cwords >= words ) { x = 0 ; goto process_tail ; } ucbits = FLAC__BITS_PER_WORD - br -> consumed_bits ; b = br -> buffer [ cwords ] << br -> consumed_bits ; while ( val < end ) { x = y = COUNT_ZERO_MSBS2 ( b ) ; if ( x == FLAC__BITS_PER_WORD ) { x = ucbits ; do { cwords ++ ; if ( cwords >= words ) goto incomplete_msbs ; b = br -> buffer [ cwords ] ; y = COUNT_ZERO_MSBS2 ( b ) ; x += y ; } while ( y == FLAC__BITS_PER_WORD ) ; } b <<= y ; b <<= 1 ; ucbits = ( ucbits - x - 1 ) % FLAC__BITS_PER_WORD ; msbs = x ; x = ( FLAC__uint32 ) ( b >> ( FLAC__BITS_PER_WORD - parameter ) ) ; if ( parameter <= ucbits ) { ucbits -= parameter ; b <<= parameter ; } else { cwords ++ ; if ( cwords >= words ) goto incomplete_lsbs ; b = br -> buffer [ cwords ] ; ucbits += FLAC__BITS_PER_WORD - parameter ; x |= ( FLAC__uint32 ) ( b >> ucbits ) ; b <<= FLAC__BITS_PER_WORD - ucbits ; } lsbs = x ; x = ( msbs << parameter ) | lsbs ; * val ++ = ( int ) ( x >> 1 ) ^ - ( int ) ( x & 1 ) ; continue ; process_tail : do { if ( 0 ) { incomplete_msbs : br -> consumed_bits = 0 ; br -> consumed_words = cwords ; } if ( ! FLAC__bitreader_read_unary_unsigned ( br , & msbs ) ) return false ; msbs += x ; x = ucbits = 0 ; if ( 0 ) { incomplete_lsbs : br -> consumed_bits = 0 ; br -> consumed_words = cwords ; } if ( ! FLAC__bitreader_read_raw_uint32 ( br , & lsbs , parameter - ucbits ) ) return false ; lsbs = x | lsbs ; x = ( msbs << parameter ) | lsbs ; * val ++ = ( int ) ( x >> 1 ) ^ - ( int ) ( x & 1 ) ; x = 0 ; cwords = br -> consumed_words ; words = br -> words ; ucbits = FLAC__BITS_PER_WORD - br -> consumed_bits ; <S2SV_StartBug> b = br -> buffer [ cwords ] << br -> consumed_bits ; <S2SV_EndBug> } while ( cwords >= words && val < end ) ; } if ( ucbits == 0 && cwords < words ) { cwords ++ ; ucbits = FLAC__BITS_PER_WORD ; } br -> consumed_bits = FLAC__BITS_PER_WORD - ucbits ; br -> consumed_words = cwords ; return true ; }", "target": "<S2SV_ModStart> ; b = cwords < br -> capacity ? <S2SV_ModStart> br -> consumed_bits : 0"}
{"source": "CWE-190 void stralgoLCS ( client * c ) { uint32_t i , j ; long long minmatchlen = 0 ; sds a = NULL , b = NULL ; int getlen = 0 , getidx = 0 , withmatchlen = 0 ; robj * obja = NULL , * objb = NULL ; for ( j = 2 ; j < ( uint32_t ) c -> argc ; j ++ ) { char * opt = c -> argv [ j ] -> ptr ; int moreargs = ( c -> argc - 1 ) - j ; if ( ! strcasecmp ( opt , \"IDX\" ) ) { getidx = 1 ; } else if ( ! strcasecmp ( opt , \"LEN\" ) ) { getlen = 1 ; } else if ( ! strcasecmp ( opt , \"WITHMATCHLEN\" ) ) { withmatchlen = 1 ; } else if ( ! strcasecmp ( opt , \"MINMATCHLEN\" ) && moreargs ) { if ( getLongLongFromObjectOrReply ( c , c -> argv [ j + 1 ] , & minmatchlen , NULL ) != C_OK ) goto cleanup ; if ( minmatchlen < 0 ) minmatchlen = 0 ; j ++ ; } else if ( ! strcasecmp ( opt , \"STRINGS\" ) && moreargs > 1 ) { if ( a != NULL ) { addReplyError ( c , \"Either<S2SV_blank>use<S2SV_blank>STRINGS<S2SV_blank>or<S2SV_blank>KEYS\" ) ; goto cleanup ; } a = c -> argv [ j + 1 ] -> ptr ; b = c -> argv [ j + 2 ] -> ptr ; j += 2 ; } else if ( ! strcasecmp ( opt , \"KEYS\" ) && moreargs > 1 ) { if ( a != NULL ) { addReplyError ( c , \"Either<S2SV_blank>use<S2SV_blank>STRINGS<S2SV_blank>or<S2SV_blank>KEYS\" ) ; goto cleanup ; } obja = lookupKeyRead ( c -> db , c -> argv [ j + 1 ] ) ; objb = lookupKeyRead ( c -> db , c -> argv [ j + 2 ] ) ; if ( ( obja && obja -> type != OBJ_STRING ) || ( objb && objb -> type != OBJ_STRING ) ) { addReplyError ( c , \"The<S2SV_blank>specified<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>contain<S2SV_blank>string<S2SV_blank>values\" ) ; obja = NULL ; objb = NULL ; goto cleanup ; } obja = obja ? getDecodedObject ( obja ) : createStringObject ( \"\" , 0 ) ; objb = objb ? getDecodedObject ( objb ) : createStringObject ( \"\" , 0 ) ; a = obja -> ptr ; b = objb -> ptr ; j += 2 ; } else { addReplyErrorObject ( c , shared . syntaxerr ) ; goto cleanup ; } } if ( a == NULL ) { addReplyError ( c , \"Please<S2SV_blank>specify<S2SV_blank>two<S2SV_blank>strings:<S2SV_blank>\" \"STRINGS<S2SV_blank>or<S2SV_blank>KEYS<S2SV_blank>options<S2SV_blank>are<S2SV_blank>mandatory\" ) ; goto cleanup ; } else if ( getlen && getidx ) { addReplyError ( c , \"If<S2SV_blank>you<S2SV_blank>want<S2SV_blank>both<S2SV_blank>the<S2SV_blank>length<S2SV_blank>and<S2SV_blank>indexes,<S2SV_blank>please<S2SV_blank>\" \"just<S2SV_blank>use<S2SV_blank>IDX.\" ) ; goto cleanup ; } uint32_t alen = sdslen ( a ) ; uint32_t blen = sdslen ( b ) ; <S2SV_StartBug> uint32_t * lcs = zmalloc ( ( alen + 1 ) * ( blen + 1 ) * sizeof ( uint32_t ) ) ; <S2SV_EndBug> # define LCS ( A , B ) lcs [ ( B ) + ( ( A ) * ( blen + 1 ) ) ] for ( uint32_t i = 0 ; i <= alen ; i ++ ) { for ( uint32_t j = 0 ; j <= blen ; j ++ ) { if ( i == 0 || j == 0 ) { LCS ( i , j ) = 0 ; } else if ( a [ i - 1 ] == b [ j - 1 ] ) { LCS ( i , j ) = LCS ( i - 1 , j - 1 ) + 1 ; } else { uint32_t lcs1 = LCS ( i - 1 , j ) ; uint32_t lcs2 = LCS ( i , j - 1 ) ; LCS ( i , j ) = lcs1 > lcs2 ? lcs1 : lcs2 ; } } } uint32_t idx = LCS ( alen , blen ) ; sds result = NULL ; void * arraylenptr = NULL ; uint32_t arange_start = alen , arange_end = 0 , brange_start = 0 , brange_end = 0 ; int computelcs = getidx || ! getlen ; if ( computelcs ) result = sdsnewlen ( SDS_NOINIT , idx ) ; uint32_t arraylen = 0 ; if ( getidx ) { addReplyMapLen ( c , 2 ) ; addReplyBulkCString ( c , \"matches\" ) ; arraylenptr = addReplyDeferredLen ( c ) ; } i = alen , j = blen ; while ( computelcs && i > 0 && j > 0 ) { int emit_range = 0 ; if ( a [ i - 1 ] == b [ j - 1 ] ) { result [ idx - 1 ] = a [ i - 1 ] ; if ( arange_start == alen ) { arange_start = i - 1 ; arange_end = i - 1 ; brange_start = j - 1 ; brange_end = j - 1 ; } else { if ( arange_start == i && brange_start == j ) { arange_start -- ; brange_start -- ; } else { emit_range = 1 ; } } if ( arange_start == 0 || brange_start == 0 ) emit_range = 1 ; idx -- ; i -- ; j -- ; } else { uint32_t lcs1 = LCS ( i - 1 , j ) ; uint32_t lcs2 = LCS ( i , j - 1 ) ; if ( lcs1 > lcs2 ) i -- ; else j -- ; if ( arange_start != alen ) emit_range = 1 ; } uint32_t match_len = arange_end - arange_start + 1 ; if ( emit_range ) { if ( minmatchlen == 0 || match_len >= minmatchlen ) { if ( arraylenptr ) { addReplyArrayLen ( c , 2 + withmatchlen ) ; addReplyArrayLen ( c , 2 ) ; addReplyLongLong ( c , arange_start ) ; addReplyLongLong ( c , arange_end ) ; addReplyArrayLen ( c , 2 ) ; addReplyLongLong ( c , brange_start ) ; addReplyLongLong ( c , brange_end ) ; if ( withmatchlen ) addReplyLongLong ( c , match_len ) ; arraylen ++ ; } } arange_start = alen ; } } if ( arraylenptr ) { addReplyBulkCString ( c , \"len\" ) ; addReplyLongLong ( c , LCS ( alen , blen ) ) ; setDeferredArrayLen ( c , arraylenptr , arraylen ) ; } else if ( getlen ) { addReplyLongLong ( c , LCS ( alen , blen ) ) ; } else { addReplyBulkSds ( c , result ) ; result = NULL ; } sdsfree ( result ) ; zfree ( lcs ) ; cleanup : if ( obja ) decrRefCount ( obja ) ; if ( objb ) decrRefCount ( objb ) ; return ; }", "target": "<S2SV_ModStart> = zmalloc ( ( size_t )"}
{"source": "CWE-79 int RGWGetObj_ObjStore_S3 : : send_response_data ( bufferlist & bl , off_t bl_ofs , off_t bl_len ) { const char * content_type = NULL ; string content_type_str ; map < string , string > response_attrs ; map < string , string > : : iterator riter ; bufferlist metadata_bl ; if ( sent_header ) goto send_data ; if ( custom_http_ret ) { set_req_state_err ( s , 0 ) ; dump_errno ( s , custom_http_ret ) ; } else { set_req_state_err ( s , ( partial_content && ! op_ret ) ? STATUS_PARTIAL_CONTENT : op_ret ) ; dump_errno ( s ) ; } if ( op_ret ) goto done ; if ( range_str ) dump_range ( s , start , end , s -> obj_size ) ; if ( s -> system_request && s -> info . args . exists ( RGW_SYS_PARAM_PREFIX \"prepend-metadata\" ) ) { dump_header ( s , \"Rgwx-Object-Size\" , ( long long ) total_len ) ; if ( rgwx_stat ) { total_len = 0 ; } JSONFormatter jf ; jf . open_object_section ( \"obj_metadata\" ) ; encode_json ( \"attrs\" , attrs , & jf ) ; utime_t ut ( lastmod ) ; encode_json ( \"mtime\" , ut , & jf ) ; jf . close_section ( ) ; stringstream ss ; jf . flush ( ss ) ; metadata_bl . append ( ss . str ( ) ) ; dump_header ( s , \"Rgwx-Embedded-Metadata-Len\" , metadata_bl . length ( ) ) ; total_len += metadata_bl . length ( ) ; } if ( s -> system_request && ! real_clock : : is_zero ( lastmod ) ) { dump_epoch_header ( s , \"Rgwx-Mtime\" , lastmod ) ; uint64_t pg_ver = 0 ; int r = decode_attr_bl_single_value ( attrs , RGW_ATTR_PG_VER , & pg_ver , ( uint64_t ) 0 ) ; if ( r < 0 ) { ldout ( s -> cct , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>pg<S2SV_blank>ver<S2SV_blank>attr,<S2SV_blank>ignoring\" << dendl ; } dump_header ( s , \"Rgwx-Obj-PG-Ver\" , pg_ver ) ; uint32_t source_zone_short_id = 0 ; r = decode_attr_bl_single_value ( attrs , RGW_ATTR_SOURCE_ZONE , & source_zone_short_id , ( uint32_t ) 0 ) ; if ( r < 0 ) { ldout ( s -> cct , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>pg<S2SV_blank>ver<S2SV_blank>attr,<S2SV_blank>ignoring\" << dendl ; } if ( source_zone_short_id != 0 ) { dump_header ( s , \"Rgwx-Source-Zone-Short-Id\" , source_zone_short_id ) ; } } for ( auto & it : crypt_http_responses ) dump_header ( s , it . first , it . second ) ; dump_content_length ( s , total_len ) ; dump_last_modified ( s , lastmod ) ; dump_header_if_nonempty ( s , \"x-amz-version-id\" , version_id ) ; if ( attrs . find ( RGW_ATTR_APPEND_PART_NUM ) != attrs . end ( ) ) { dump_header ( s , \"x-rgw-object-type\" , \"Appendable\" ) ; dump_header ( s , \"x-rgw-next-append-position\" , s -> obj_size ) ; } else { dump_header ( s , \"x-rgw-object-type\" , \"Normal\" ) ; } if ( ! op_ret ) { if ( ! lo_etag . empty ( ) ) { dump_etag ( s , lo_etag ) ; } else { auto iter = attrs . find ( RGW_ATTR_ETAG ) ; if ( iter != attrs . end ( ) ) { dump_etag ( s , iter -> second . to_str ( ) ) ; } } for ( struct response_attr_param * p = resp_attr_params ; p -> param ; p ++ ) { bool exists ; string val = s -> info . args . get ( p -> param , & exists ) ; if ( exists ) { if ( s -> auth . identity -> is_anonymous ( ) ) { return - ERR_INVALID_REQUEST ; <S2SV_StartBug> } <S2SV_EndBug> if ( strcmp ( p -> param , \"response-content-type\" ) != 0 ) { response_attrs [ p -> http_attr ] = val ; } else { content_type_str = val ; content_type = content_type_str . c_str ( ) ; } } } for ( auto iter = attrs . begin ( ) ; iter != attrs . end ( ) ; ++ iter ) { const char * name = iter -> first . c_str ( ) ; map < string , string > : : iterator aiter = rgw_to_http_attrs . find ( name ) ; if ( aiter != rgw_to_http_attrs . end ( ) ) { if ( response_attrs . count ( aiter -> second ) == 0 ) { size_t len = iter -> second . length ( ) ; string s ( iter -> second . c_str ( ) , len ) ; while ( len && ! s [ len - 1 ] ) { -- len ; s . resize ( len ) ; } response_attrs [ aiter -> second ] = s ; } } else if ( iter -> first . compare ( RGW_ATTR_CONTENT_TYPE ) == 0 ) { if ( ! content_type ) { content_type_str = rgw_bl_str ( iter -> second ) ; content_type = content_type_str . c_str ( ) ; } } else if ( strcmp ( name , RGW_ATTR_SLO_UINDICATOR ) == 0 ) { dump_header ( s , \"X-Object-Meta-Static-Large-Object\" , \"True\" ) ; } else if ( strncmp ( name , RGW_ATTR_META_PREFIX , sizeof ( RGW_ATTR_META_PREFIX ) - 1 ) == 0 ) { name += sizeof ( RGW_ATTR_PREFIX ) - 1 ; dump_header ( s , name , iter -> second ) ; } else if ( iter -> first . compare ( RGW_ATTR_TAGS ) == 0 ) { RGWObjTags obj_tags ; try { auto it = iter -> second . cbegin ( ) ; obj_tags . decode ( it ) ; } catch ( buffer : : error & err ) { ldout ( s -> cct , 0 ) << \"Error<S2SV_blank>caught<S2SV_blank>buffer::error<S2SV_blank>couldn\\'t<S2SV_blank>decode<S2SV_blank>TagSet<S2SV_blank>\" << dendl ; } dump_header ( s , RGW_AMZ_TAG_COUNT , obj_tags . count ( ) ) ; } else if ( iter -> first . compare ( RGW_ATTR_OBJECT_RETENTION ) == 0 && get_retention ) { RGWObjectRetention retention ; try { decode ( retention , iter -> second ) ; dump_header ( s , \"x-amz-object-lock-mode\" , retention . get_mode ( ) ) ; dump_time_header ( s , \"x-amz-object-lock-retain-until-date\" , retention . get_retain_until_date ( ) ) ; } catch ( buffer : : error & err ) { ldpp_dout ( this , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>RGWObjectRetention\" << dendl ; } } else if ( iter -> first . compare ( RGW_ATTR_OBJECT_LEGAL_HOLD ) == 0 && get_legal_hold ) { RGWObjectLegalHold legal_hold ; try { decode ( legal_hold , iter -> second ) ; dump_header ( s , \"x-amz-object-lock-legal-hold\" , legal_hold . get_status ( ) ) ; } catch ( buffer : : error & err ) { ldpp_dout ( this , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>RGWObjectLegalHold\" << dendl ; } } } } done : for ( riter = response_attrs . begin ( ) ; riter != response_attrs . end ( ) ; ++ riter ) { dump_header ( s , riter -> first , riter -> second ) ; } if ( op_ret == - ERR_NOT_MODIFIED ) { end_header ( s , this ) ; } else { if ( ! content_type ) content_type = \"binary/octet-stream\" ; end_header ( s , this , content_type ) ; } if ( metadata_bl . length ( ) ) { dump_body ( s , metadata_bl ) ; } sent_header = true ; send_data : if ( get_data && ! op_ret ) { int r = dump_body ( s , bl . c_str ( ) + bl_ofs , bl_len ) ; if ( r < 0 ) return r ; } return 0 ; }", "target": "<S2SV_ModStart> ERR_INVALID_REQUEST ; } if ( str_has_cntrl ( val ) ) { return - ERR_INVALID_REQUEST ; }"}
{"source": "CWE-190 gtTileContig ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileContigRoutine put = img -> put . contig ; uint32 col , row , y , rowstoread ; tmsize_t pos ; uint32 tw , th ; unsigned char * buf = NULL ; int32 fromskew , toskew ; uint32 nrow ; int ret = 1 , flip ; uint32 this_tw , tocol ; int32 this_toskew , leftmost_toskew ; int32 leftmost_fromskew ; uint32 leftmost_tw ; tmsize_t bufsize ; bufsize = TIFFTileSize ( tif ) ; if ( bufsize == 0 ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , \"%s\" , \"No<S2SV_blank>space<S2SV_blank>for<S2SV_blank>tile<S2SV_blank>buffer\" ) ; return ( 0 ) ; } TIFFGetField ( tif , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( tif , TIFFTAG_TILELENGTH , & th ) ; flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { <S2SV_StartBug> y = h - 1 ; <S2SV_EndBug> toskew = - ( int32 ) ( tw + w ) ; } <S2SV_StartBug> else { <S2SV_EndBug> y = 0 ; toskew = - ( int32 ) ( tw - w ) ; } leftmost_fromskew = img -> col_offset % tw ; leftmost_tw = tw - leftmost_fromskew ; leftmost_toskew = toskew + leftmost_fromskew ; for ( row = 0 ; ret != 0 && row < h ; row += nrow ) { rowstoread = th - ( row + img -> row_offset ) % th ; nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; fromskew = leftmost_fromskew ; this_tw = leftmost_tw ; this_toskew = leftmost_toskew ; tocol = 0 ; col = img -> col_offset ; while ( tocol < w ) { if ( _TIFFReadTileAndAllocBuffer ( tif , ( void * * ) & buf , bufsize , col , row + img -> row_offset , 0 , 0 ) == ( tmsize_t ) ( - 1 ) && ( buf == NULL || img -> stoponerr ) ) { ret = 0 ; break ; } pos = ( ( row + img -> row_offset ) % th ) * TIFFTileRowSize ( tif ) + ( ( tmsize_t ) fromskew * img -> samplesperpixel ) ; if ( tocol + this_tw > w ) { fromskew = tw - ( w - tocol ) ; this_tw = tw - fromskew ; this_toskew = toskew + fromskew ; } ( * put ) ( img , raster + y * w + tocol , tocol , y , this_tw , nrow , fromskew , this_toskew , buf + pos ) ; tocol += this_tw ; col += this_tw ; fromskew = 0 ; this_tw = tw ; this_toskew = toskew ; } y += ( ( flip & FLIP_VERTICALLY ) ? - ( int32 ) nrow : ( int32 ) nrow ) ; } _TIFFfree ( buf ) ; if ( flip & FLIP_HORIZONTALLY ) { uint32 line ; for ( line = 0 ; line < h ; line ++ ) { uint32 * left = raster + ( line * w ) ; uint32 * right = left + w - 1 ; while ( left < right ) { uint32 temp = * left ; * left = * right ; * right = temp ; left ++ ; right -- ; } } } return ( ret ) ; }", "target": "<S2SV_ModStart> FLIP_VERTICALLY ) { if ( ( tw + w ) > INT_MAX ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , \"%s\" , \"unsupported<S2SV_blank>tile<S2SV_blank>size<S2SV_blank>(too<S2SV_blank>wide)\" ) ; return ( 0 ) ; } <S2SV_ModStart> } else { if ( tw > ( INT_MAX + w ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , \"%s\" , \"unsupported<S2SV_blank>tile<S2SV_blank>size<S2SV_blank>(too<S2SV_blank>wide)\" ) ; return ( 0 ) ; }"}
{"source": "CWE-416 static void io_async_task_func ( struct callback_head * cb ) { struct io_kiocb * req = container_of ( cb , struct io_kiocb , task_work ) ; struct async_poll * apoll = req -> apoll ; struct io_ring_ctx * ctx = req -> ctx ; trace_io_uring_task_run ( req -> ctx , req -> opcode , req -> user_data ) ; if ( io_poll_rewait ( req , & apoll -> poll ) ) { spin_unlock_irq ( & ctx -> completion_lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } if ( hash_hashed ( & req -> hash_node ) ) hash_del ( & req -> hash_node ) ; io_poll_remove_double ( req , apoll -> double_poll ) ; spin_unlock_irq ( & ctx -> completion_lock ) ; if ( ! READ_ONCE ( apoll -> poll . canceled ) ) __io_req_task_submit ( req ) ; else __io_req_task_cancel ( req , - ECANCELED ) ; <S2SV_StartBug> kfree ( apoll -> double_poll ) ; <S2SV_EndBug> kfree ( apoll ) ; }", "target": "<S2SV_ModStart> completion_lock ) ; percpu_ref_put ( & ctx -> refs ) ; <S2SV_ModStart> ECANCELED ) ; percpu_ref_put ( & ctx -> refs ) ;"}
{"source": "CWE-20 private int mget ( struct magic_set * ms , const unsigned char * s , struct magic * m , size_t nbytes , size_t o , unsigned int cont_level , int mode , int text , int flip , int recursion_level , int * printed_something , int * need_separator , int * returnval ) { uint32_t soffset , offset = ms -> offset ; uint32_t count = m -> str_range ; int rv , oneed_separator ; char * sbuf , * rbuf ; union VALUETYPE * p = & ms -> ms_value ; struct mlist ml ; if ( recursion_level >= 20 ) { file_error ( ms , 0 , \"recursion<S2SV_blank>nesting<S2SV_blank>exceeded\" ) ; return - 1 ; } if ( mcopy ( ms , p , m -> type , m -> flag & INDIR , s , ( uint32_t ) ( offset + o ) , ( uint32_t ) nbytes , count ) == - 1 ) return - 1 ; if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) { fprintf ( stderr , \"mget(type=%d,<S2SV_blank>flag=%x,<S2SV_blank>offset=%u,<S2SV_blank>o=%zu,<S2SV_blank>\" \"nbytes=%zu,<S2SV_blank>count=%u)\\\\n\" , m -> type , m -> flag , offset , o , nbytes , count ) ; mdebug ( offset , ( char * ) ( void * ) p , sizeof ( union VALUETYPE ) ) ; } if ( m -> flag & INDIR ) { int off = m -> in_offset ; if ( m -> in_op & FILE_OPINDIRECT ) { const union VALUETYPE * q = CAST ( const union VALUETYPE * , ( ( const void * ) ( s + offset + off ) ) ) ; switch ( cvt_flip ( m -> in_type , flip ) ) { case FILE_BYTE : off = q -> b ; break ; case FILE_SHORT : off = q -> h ; break ; case FILE_BESHORT : off = ( short ) ( ( q -> hs [ 0 ] << 8 ) | ( q -> hs [ 1 ] ) ) ; break ; case FILE_LESHORT : off = ( short ) ( ( q -> hs [ 1 ] << 8 ) | ( q -> hs [ 0 ] ) ) ; break ; case FILE_LONG : off = q -> l ; break ; case FILE_BELONG : case FILE_BEID3 : off = ( int32_t ) ( ( q -> hl [ 0 ] << 24 ) | ( q -> hl [ 1 ] << 16 ) | ( q -> hl [ 2 ] << 8 ) | ( q -> hl [ 3 ] ) ) ; break ; case FILE_LEID3 : case FILE_LELONG : off = ( int32_t ) ( ( q -> hl [ 3 ] << 24 ) | ( q -> hl [ 2 ] << 16 ) | ( q -> hl [ 1 ] << 8 ) | ( q -> hl [ 0 ] ) ) ; break ; case FILE_MELONG : off = ( int32_t ) ( ( q -> hl [ 1 ] << 24 ) | ( q -> hl [ 0 ] << 16 ) | ( q -> hl [ 3 ] << 8 ) | ( q -> hl [ 2 ] ) ) ; break ; } if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) fprintf ( stderr , \"indirect<S2SV_blank>offs=%u\\\\n\" , off ) ; } switch ( cvt_flip ( m -> in_type , flip ) ) { case FILE_BYTE : if ( nbytes < ( offset + 1 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = p -> b & off ; break ; case FILE_OPOR : offset = p -> b | off ; break ; case FILE_OPXOR : offset = p -> b ^ off ; break ; case FILE_OPADD : offset = p -> b + off ; break ; case FILE_OPMINUS : offset = p -> b - off ; break ; case FILE_OPMULTIPLY : offset = p -> b * off ; break ; case FILE_OPDIVIDE : offset = p -> b / off ; break ; case FILE_OPMODULO : offset = p -> b % off ; break ; } } else offset = p -> b ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; case FILE_BESHORT : if ( nbytes < ( offset + 2 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) & off ; break ; case FILE_OPOR : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) | off ; break ; case FILE_OPXOR : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) ^ off ; break ; case FILE_OPADD : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) + off ; break ; case FILE_OPMINUS : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) - off ; break ; case FILE_OPMULTIPLY : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) * off ; break ; case FILE_OPDIVIDE : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) / off ; break ; case FILE_OPMODULO : offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) % off ; break ; } } else offset = ( short ) ( ( p -> hs [ 0 ] << 8 ) | ( p -> hs [ 1 ] ) ) ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; case FILE_LESHORT : if ( nbytes < ( offset + 2 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) & off ; break ; case FILE_OPOR : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) | off ; break ; case FILE_OPXOR : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) ^ off ; break ; case FILE_OPADD : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) + off ; break ; case FILE_OPMINUS : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) - off ; break ; case FILE_OPMULTIPLY : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) * off ; break ; case FILE_OPDIVIDE : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) / off ; break ; case FILE_OPMODULO : offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) % off ; break ; } } else offset = ( short ) ( ( p -> hs [ 1 ] << 8 ) | ( p -> hs [ 0 ] ) ) ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; case FILE_SHORT : if ( nbytes < ( offset + 2 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = p -> h & off ; break ; case FILE_OPOR : offset = p -> h | off ; break ; case FILE_OPXOR : offset = p -> h ^ off ; break ; case FILE_OPADD : offset = p -> h + off ; break ; case FILE_OPMINUS : offset = p -> h - off ; break ; case FILE_OPMULTIPLY : offset = p -> h * off ; break ; case FILE_OPDIVIDE : offset = p -> h / off ; break ; case FILE_OPMODULO : offset = p -> h % off ; break ; } } else offset = p -> h ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; case FILE_BELONG : case FILE_BEID3 : if ( nbytes < ( offset + 4 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) & off ; break ; case FILE_OPOR : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) | off ; break ; case FILE_OPXOR : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) ^ off ; break ; case FILE_OPADD : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) + off ; break ; case FILE_OPMINUS : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) - off ; break ; case FILE_OPMULTIPLY : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) * off ; break ; case FILE_OPDIVIDE : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) / off ; break ; case FILE_OPMODULO : offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) % off ; break ; } } else offset = ( int32_t ) ( ( p -> hl [ 0 ] << 24 ) | ( p -> hl [ 1 ] << 16 ) | ( p -> hl [ 2 ] << 8 ) | ( p -> hl [ 3 ] ) ) ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; case FILE_LELONG : case FILE_LEID3 : if ( nbytes < ( offset + 4 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) & off ; break ; case FILE_OPOR : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) | off ; break ; case FILE_OPXOR : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) ^ off ; break ; case FILE_OPADD : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) + off ; break ; case FILE_OPMINUS : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) - off ; break ; case FILE_OPMULTIPLY : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) * off ; break ; case FILE_OPDIVIDE : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) / off ; break ; case FILE_OPMODULO : offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) % off ; break ; } } else offset = ( int32_t ) ( ( p -> hl [ 3 ] << 24 ) | ( p -> hl [ 2 ] << 16 ) | ( p -> hl [ 1 ] << 8 ) | ( p -> hl [ 0 ] ) ) ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; case FILE_MELONG : if ( nbytes < ( offset + 4 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) & off ; break ; case FILE_OPOR : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) | off ; break ; case FILE_OPXOR : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) ^ off ; break ; case FILE_OPADD : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) + off ; break ; case FILE_OPMINUS : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) - off ; break ; case FILE_OPMULTIPLY : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) * off ; break ; case FILE_OPDIVIDE : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) / off ; break ; case FILE_OPMODULO : offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) % off ; break ; } } else offset = ( int32_t ) ( ( p -> hl [ 1 ] << 24 ) | ( p -> hl [ 0 ] << 16 ) | ( p -> hl [ 3 ] << 8 ) | ( p -> hl [ 2 ] ) ) ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; case FILE_LONG : if ( nbytes < ( offset + 4 ) ) return 0 ; if ( off ) { switch ( m -> in_op & FILE_OPS_MASK ) { case FILE_OPAND : offset = p -> l & off ; break ; case FILE_OPOR : offset = p -> l | off ; break ; case FILE_OPXOR : offset = p -> l ^ off ; break ; case FILE_OPADD : offset = p -> l + off ; break ; case FILE_OPMINUS : offset = p -> l - off ; break ; case FILE_OPMULTIPLY : offset = p -> l * off ; break ; case FILE_OPDIVIDE : offset = p -> l / off ; break ; case FILE_OPMODULO : offset = p -> l % off ; break ; } } else offset = p -> l ; if ( m -> in_op & FILE_OPINVERSE ) offset = ~ offset ; break ; } switch ( cvt_flip ( m -> in_type , flip ) ) { case FILE_LEID3 : case FILE_BEID3 : offset = ( ( ( ( offset >> 0 ) & 0x7f ) << 0 ) | ( ( ( offset >> 8 ) & 0x7f ) << 7 ) | ( ( ( offset >> 16 ) & 0x7f ) << 14 ) | ( ( ( offset >> 24 ) & 0x7f ) << 21 ) ) + 10 ; break ; default : break ; } if ( m -> flag & INDIROFFADD ) { offset += ms -> c . li [ cont_level - 1 ] . off ; if ( offset == 0 ) { if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) fprintf ( stderr , \"indirect<S2SV_blank>*zero*<S2SV_blank>offset\\\\n\" ) ; return 0 ; } if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) fprintf ( stderr , \"indirect<S2SV_blank>+offs=%u\\\\n\" , offset ) ; } if ( mcopy ( ms , p , m -> type , 0 , s , offset , nbytes , count ) == - 1 ) return - 1 ; ms -> offset = offset ; if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) { mdebug ( offset , ( char * ) ( void * ) p , sizeof ( union VALUETYPE ) ) ; } } switch ( m -> type ) { case FILE_BYTE : if ( nbytes < ( offset + 1 ) ) return 0 ; break ; case FILE_SHORT : case FILE_BESHORT : case FILE_LESHORT : if ( nbytes < ( offset + 2 ) ) return 0 ; break ; case FILE_LONG : case FILE_BELONG : case FILE_LELONG : case FILE_MELONG : case FILE_DATE : case FILE_BEDATE : case FILE_LEDATE : case FILE_MEDATE : case FILE_LDATE : case FILE_BELDATE : case FILE_LELDATE : case FILE_MELDATE : case FILE_FLOAT : case FILE_BEFLOAT : case FILE_LEFLOAT : if ( nbytes < ( offset + 4 ) ) return 0 ; break ; case FILE_DOUBLE : case FILE_BEDOUBLE : case FILE_LEDOUBLE : if ( nbytes < ( offset + 8 ) ) return 0 ; break ; case FILE_STRING : case FILE_PSTRING : case FILE_SEARCH : if ( nbytes < ( offset + m -> vallen ) ) return 0 ; break ; case FILE_REGEX : if ( nbytes < offset ) return 0 ; break ; case FILE_INDIRECT : if ( nbytes < offset ) return 0 ; sbuf = ms -> o . buf ; soffset = ms -> offset ; ms -> o . buf = NULL ; ms -> offset = 0 ; rv = file_softmagic ( ms , s + offset , nbytes - offset , BINTEST , text ) ; if ( ( ms -> flags & MAGIC_DEBUG ) != 0 ) fprintf ( stderr , \"indirect<S2SV_blank>@offs=%u[%d]\\\\n\" , offset , rv ) ; rbuf = ms -> o . buf ; ms -> o . buf = sbuf ; ms -> offset = soffset ; if ( rv == 1 ) { if ( ( ms -> flags & ( MAGIC_MIME | MAGIC_APPLE ) ) == 0 && file_printf ( ms , m -> desc , offset ) == - 1 ) return - 1 ; if ( file_printf ( ms , \"%s\" , rbuf ) == - 1 ) return - 1 ; <S2SV_StartBug> free ( rbuf ) ; <S2SV_EndBug> } return rv ; case FILE_USE : if ( nbytes < offset ) return 0 ; sbuf = m -> value . s ; if ( * sbuf == '^' ) { sbuf ++ ; flip = ! flip ; } if ( file_magicfind ( ms , sbuf , & ml ) == - 1 ) { file_error ( ms , 0 , \"cannot<S2SV_blank>find<S2SV_blank>entry<S2SV_blank>`%s\\'\" , sbuf ) ; return - 1 ; } oneed_separator = * need_separator ; if ( m -> flag & NOSPACE ) * need_separator = 0 ; rv = match ( ms , ml . magic , ml . nmagic , s , nbytes , offset + o , mode , text , flip , recursion_level , printed_something , need_separator , returnval ) ; if ( rv != 1 ) * need_separator = oneed_separator ; return rv ; case FILE_NAME : if ( file_printf ( ms , \"%s\" , m -> desc ) == - 1 ) return - 1 ; return 1 ; case FILE_DEFAULT : default : break ; } if ( ! mconvert ( ms , m , flip ) ) return 0 ;", "target": "<S2SV_ModStart> - 1 ; efree <S2SV_ModEnd> ( rbuf )"}
{"source": "CWE-835 ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , Py_ssize_t bytes ) { UINT8 * ptr ; int framesize ; int c , chunks , advance ; int l , lines ; int i , j , x = 0 , y , ymax ; if ( bytes < 4 ) { return 0 ; } ptr = buf ; framesize = I32 ( ptr ) ; if ( framesize < I32 ( ptr ) ) { return 0 ; } if ( bytes < 8 ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } if ( I16 ( ptr + 4 ) != 0xF1FA ) { state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } chunks = I16 ( ptr + 6 ) ; ptr += 16 ; bytes -= 16 ; for ( c = 0 ; c < chunks ; c ++ ) { UINT8 * data ; if ( bytes < 10 ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } data = ptr + 6 ; switch ( I16 ( ptr + 4 ) ) { case 4 : case 11 : break ; case 7 : lines = I16 ( data ) ; data += 2 ; for ( l = y = 0 ; l < lines && y < state -> ysize ; l ++ , y ++ ) { UINT8 * local_buf = ( UINT8 * ) im -> image [ y ] ; int p , packets ; ERR_IF_DATA_OOB ( 2 ) packets = I16 ( data ) ; data += 2 ; while ( packets & 0x8000 ) { if ( packets & 0x4000 ) { y += 65536 - packets ; if ( y >= state -> ysize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } local_buf = ( UINT8 * ) im -> image [ y ] ; } else { local_buf [ state -> xsize - 1 ] = ( UINT8 ) packets ; } ERR_IF_DATA_OOB ( 2 ) packets = I16 ( data ) ; data += 2 ; } for ( p = x = 0 ; p < packets ; p ++ ) { ERR_IF_DATA_OOB ( 2 ) x += data [ 0 ] ; if ( data [ 1 ] >= 128 ) { ERR_IF_DATA_OOB ( 4 ) i = 256 - data [ 1 ] ; if ( x + i + i > state -> xsize ) { break ; } for ( j = 0 ; j < i ; j ++ ) { local_buf [ x ++ ] = data [ 2 ] ; local_buf [ x ++ ] = data [ 3 ] ; } data += 2 + 2 ; } else { i = 2 * ( int ) data [ 1 ] ; if ( x + i > state -> xsize ) { break ; } ERR_IF_DATA_OOB ( 2 + i ) memcpy ( local_buf + x , data + 2 , i ) ; data += 2 + i ; x += i ; } } if ( p < packets ) { break ; } } if ( l < lines ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 12 : y = I16 ( data ) ; ymax = y + I16 ( data + 2 ) ; data += 4 ; for ( ; y < ymax && y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; ERR_IF_DATA_OOB ( 1 ) int p , packets = * data ++ ; for ( p = x = 0 ; p < packets ; p ++ , x += i ) { ERR_IF_DATA_OOB ( 2 ) x += data [ 0 ] ; if ( data [ 1 ] & 0x80 ) { i = 256 - data [ 1 ] ; if ( x + i > state -> xsize ) { break ; } ERR_IF_DATA_OOB ( 3 ) memset ( out + x , data [ 2 ] , i ) ; data += 3 ; } else { i = data [ 1 ] ; if ( x + i > state -> xsize ) { break ; } ERR_IF_DATA_OOB ( 2 + i ) memcpy ( out + x , data + 2 , i ) ; data += i + 2 ; } } if ( p < packets ) { break ; } } if ( y < ymax ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 13 : for ( y = 0 ; y < state -> ysize ; y ++ ) { memset ( im -> image [ y ] , 0 , state -> xsize ) ; } break ; case 15 : for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; data += 1 ; for ( x = 0 ; x < state -> xsize ; x += i ) { ERR_IF_DATA_OOB ( 2 ) if ( data [ 0 ] & 0x80 ) { i = 256 - data [ 0 ] ; if ( x + i > state -> xsize ) { break ; } ERR_IF_DATA_OOB ( i + 1 ) memcpy ( out + x , data + 1 , i ) ; data += i + 1 ; } else { i = data [ 0 ] ; if ( x + i > state -> xsize ) { break ; } memset ( out + x , data [ 1 ] , i ) ; data += 2 ; } } if ( x != state -> xsize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } } break ; case 16 : if ( state -> xsize > bytes / state -> ysize ) { return ptr - buf ; } for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * local_buf = ( UINT8 * ) im -> image [ y ] ; memcpy ( local_buf , data , state -> xsize ) ; data += state -> xsize ; } break ; case 18 : break ; default : state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } advance = I32 ( ptr ) ; <S2SV_StartBug> if ( advance < 0 || advance > bytes ) { <S2SV_EndBug> state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } ptr += advance ; bytes -= advance ; } return - 1 ; }", "target": "<S2SV_ModStart> if ( advance == 0 ) { state -> errcode = IMAGING_CODEC_BROKEN ; return - 1 ; } if ( advance"}
{"source": "CWE-703 int vt_ioctl ( struct tty_struct * tty , unsigned int cmd , unsigned long arg ) { struct vc_data * vc = tty -> driver_data ; struct console_font_op op ; unsigned int console ; unsigned char ucval ; unsigned int uival ; void __user * up = ( void __user * ) arg ; int i , perm ; int ret = 0 ; console = vc -> vc_num ; if ( ! vc_cons_allocated ( console ) ) { ret = - ENOIOCTLCMD ; goto out ; } perm = 0 ; if ( current -> signal -> tty == tty || capable ( CAP_SYS_TTY_CONFIG ) ) perm = 1 ; switch ( cmd ) { case TIOCLINUX : ret = tioclinux ( tty , arg ) ; break ; case KIOCSOUND : if ( ! perm ) return - EPERM ; if ( arg ) arg = PIT_TICK_RATE / arg ; kd_mksound ( arg , 0 ) ; break ; case KDMKTONE : if ( ! perm ) return - EPERM ; { unsigned int ticks , count ; ticks = msecs_to_jiffies ( ( arg >> 16 ) & 0xffff ) ; count = ticks ? ( arg & 0xffff ) : 0 ; if ( count ) count = PIT_TICK_RATE / count ; kd_mksound ( count , ticks ) ; break ; } case KDGKBTYPE : ucval = KB_101 ; ret = put_user ( ucval , ( char __user * ) arg ) ; break ; # ifdef CONFIG_X86 case KDADDIO : case KDDELIO : if ( arg < GPFIRST || arg > GPLAST ) { ret = - EINVAL ; break ; } ret = ksys_ioperm ( arg , 1 , ( cmd == KDADDIO ) ) ? - ENXIO : 0 ; break ; case KDENABIO : case KDDISABIO : ret = ksys_ioperm ( GPFIRST , GPNUM , ( cmd == KDENABIO ) ) ? - ENXIO : 0 ; break ; # endif case KDKBDREP : { struct kbd_repeat kbrep ; if ( ! capable ( CAP_SYS_TTY_CONFIG ) ) return - EPERM ; if ( copy_from_user ( & kbrep , up , sizeof ( struct kbd_repeat ) ) ) { ret = - EFAULT ; break ; } ret = kbd_rate ( & kbrep ) ; if ( ret ) break ; if ( copy_to_user ( up , & kbrep , sizeof ( struct kbd_repeat ) ) ) ret = - EFAULT ; break ; } case KDSETMODE : if ( ! perm ) return - EPERM ; switch ( arg ) { case KD_GRAPHICS : break ; case KD_TEXT0 : case KD_TEXT1 : arg = KD_TEXT ; case KD_TEXT : break ; default : ret = - EINVAL ; goto out ; } if ( vc -> vc_mode == ( unsigned char ) arg ) break ; vc -> vc_mode = ( unsigned char ) arg ; if ( console != fg_console ) break ; console_lock ( ) ; if ( arg == KD_TEXT ) do_unblank_screen ( 1 ) ; else do_blank_screen ( 1 ) ; console_unlock ( ) ; break ; case KDGETMODE : uival = vc -> vc_mode ; goto setint ; case KDMAPDISP : case KDUNMAPDISP : ret = - EINVAL ; break ; case KDSKBMODE : if ( ! perm ) return - EPERM ; ret = vt_do_kdskbmode ( console , arg ) ; if ( ret == 0 ) tty_ldisc_flush ( tty ) ; break ; case KDGKBMODE : uival = vt_do_kdgkbmode ( console ) ; ret = put_user ( uival , ( int __user * ) arg ) ; break ; case KDSKBMETA : ret = vt_do_kdskbmeta ( console , arg ) ; break ; case KDGKBMETA : uival = vt_do_kdgkbmeta ( console ) ; setint : ret = put_user ( uival , ( int __user * ) arg ) ; break ; case KDGETKEYCODE : case KDSETKEYCODE : if ( ! capable ( CAP_SYS_TTY_CONFIG ) ) perm = 0 ; ret = vt_do_kbkeycode_ioctl ( cmd , up , perm ) ; break ; case KDGKBENT : case KDSKBENT : ret = vt_do_kdsk_ioctl ( cmd , up , perm , console ) ; break ; case KDGKBSENT : case KDSKBSENT : ret = vt_do_kdgkb_ioctl ( cmd , up , perm ) ; break ; case KDGKBDIACR : case KDGKBDIACRUC : case KDSKBDIACR : case KDSKBDIACRUC : ret = vt_do_diacrit ( cmd , up , perm ) ; break ; case KDGKBLED : case KDSKBLED : case KDGETLED : case KDSETLED : ret = vt_do_kdskled ( console , cmd , arg , perm ) ; break ; case KDSIGACCEPT : { if ( ! perm || ! capable ( CAP_KILL ) ) return - EPERM ; if ( ! valid_signal ( arg ) || arg < 1 || arg == SIGKILL ) ret = - EINVAL ; else { spin_lock_irq ( & vt_spawn_con . lock ) ; put_pid ( vt_spawn_con . pid ) ; vt_spawn_con . pid = get_pid ( task_pid ( current ) ) ; vt_spawn_con . sig = arg ; spin_unlock_irq ( & vt_spawn_con . lock ) ; } break ; } case VT_SETMODE : { struct vt_mode tmp ; if ( ! perm ) return - EPERM ; if ( copy_from_user ( & tmp , up , sizeof ( struct vt_mode ) ) ) { ret = - EFAULT ; goto out ; } if ( tmp . mode != VT_AUTO && tmp . mode != VT_PROCESS ) { ret = - EINVAL ; goto out ; } console_lock ( ) ; vc -> vt_mode = tmp ; vc -> vt_mode . frsig = 0 ; put_pid ( vc -> vt_pid ) ; vc -> vt_pid = get_pid ( task_pid ( current ) ) ; vc -> vt_newvt = - 1 ; console_unlock ( ) ; break ; } case VT_GETMODE : { struct vt_mode tmp ; int rc ; console_lock ( ) ; memcpy ( & tmp , & vc -> vt_mode , sizeof ( struct vt_mode ) ) ; console_unlock ( ) ; rc = copy_to_user ( up , & tmp , sizeof ( struct vt_mode ) ) ; if ( rc ) ret = - EFAULT ; break ; } case VT_GETSTATE : { struct vt_stat __user * vtstat = up ; unsigned short state , mask ; if ( put_user ( fg_console + 1 , & vtstat -> v_active ) ) ret = - EFAULT ; else { state = 1 ; for ( i = 0 , mask = 2 ; i < MAX_NR_CONSOLES && mask ; ++ i , mask <<= 1 ) if ( VT_IS_IN_USE ( i ) ) state |= mask ; ret = put_user ( state , & vtstat -> v_state ) ; } break ; } case VT_OPENQRY : for ( i = 0 ; i < MAX_NR_CONSOLES ; ++ i ) if ( ! VT_IS_IN_USE ( i ) ) break ; uival = i < MAX_NR_CONSOLES ? ( i + 1 ) : - 1 ; goto setint ; case VT_ACTIVATE : if ( ! perm ) return - EPERM ; if ( arg == 0 || arg > MAX_NR_CONSOLES ) ret = - ENXIO ; else { arg -- ; console_lock ( ) ; ret = vc_allocate ( arg ) ; console_unlock ( ) ; if ( ret ) break ; set_console ( arg ) ; } break ; case VT_SETACTIVATE : { struct vt_setactivate vsa ; if ( ! perm ) return - EPERM ; if ( copy_from_user ( & vsa , ( struct vt_setactivate __user * ) arg , sizeof ( struct vt_setactivate ) ) ) { ret = - EFAULT ; goto out ; } if ( vsa . console == 0 || vsa . console > MAX_NR_CONSOLES ) ret = - ENXIO ; else { vsa . console = array_index_nospec ( vsa . console , MAX_NR_CONSOLES + 1 ) ; vsa . console -- ; console_lock ( ) ; ret = vc_allocate ( vsa . console ) ; if ( ret == 0 ) { struct vc_data * nvc ; nvc = vc_cons [ vsa . console ] . d ; nvc -> vt_mode = vsa . mode ; nvc -> vt_mode . frsig = 0 ; put_pid ( nvc -> vt_pid ) ; nvc -> vt_pid = get_pid ( task_pid ( current ) ) ; } console_unlock ( ) ; if ( ret ) break ; set_console ( vsa . console ) ; } break ; } case VT_WAITACTIVE : if ( ! perm ) return - EPERM ; if ( arg == 0 || arg > MAX_NR_CONSOLES ) ret = - ENXIO ; else ret = vt_waitactive ( arg ) ; break ; case VT_RELDISP : if ( ! perm ) return - EPERM ; console_lock ( ) ; if ( vc -> vt_mode . mode != VT_PROCESS ) { console_unlock ( ) ; ret = - EINVAL ; break ; } if ( vc -> vt_newvt >= 0 ) { if ( arg == 0 ) vc -> vt_newvt = - 1 ; else { int newvt ; newvt = vc -> vt_newvt ; vc -> vt_newvt = - 1 ; ret = vc_allocate ( newvt ) ; if ( ret ) { console_unlock ( ) ; break ; } complete_change_console ( vc_cons [ newvt ] . d ) ; } } else { if ( arg != VT_ACKACQ ) ret = - EINVAL ; } console_unlock ( ) ; break ; case VT_DISALLOCATE : if ( arg > MAX_NR_CONSOLES ) { ret = - ENXIO ; break ; } if ( arg == 0 ) vt_disallocate_all ( ) ; else ret = vt_disallocate ( -- arg ) ; break ; case VT_RESIZE : { struct vt_sizes __user * vtsizes = up ; struct vc_data * vc ; ushort ll , cc ; if ( ! perm ) return - EPERM ; if ( get_user ( ll , & vtsizes -> v_rows ) || get_user ( cc , & vtsizes -> v_cols ) ) ret = - EFAULT ; else { console_lock ( ) ; for ( i = 0 ; i < MAX_NR_CONSOLES ; i ++ ) { vc = vc_cons [ i ] . d ; if ( vc ) { vc -> vc_resize_user = 1 ; vc_resize ( vc_cons [ i ] . d , cc , ll ) ; } } console_unlock ( ) ; } break ; } case VT_RESIZEX : { struct vt_consize v ; if ( ! perm ) return - EPERM ; if ( copy_from_user ( & v , up , sizeof ( struct vt_consize ) ) ) return - EFAULT ; if ( ! v . v_vlin ) v . v_vlin = vc -> vc_scan_lines ; if ( v . v_clin ) { int rows = v . v_vlin / v . v_clin ; if ( v . v_rows != rows ) { if ( v . v_rows ) return - EINVAL ; v . v_rows = rows ; } } if ( v . v_vcol && v . v_ccol ) { int cols = v . v_vcol / v . v_ccol ; if ( v . v_cols != cols ) { if ( v . v_cols ) return - EINVAL ; v . v_cols = cols ; } } if ( v . v_clin > 32 ) return - EINVAL ; for ( i = 0 ; i < MAX_NR_CONSOLES ; i ++ ) { <S2SV_StartBug> if ( ! vc_cons [ i ] . d ) <S2SV_EndBug> continue ; console_lock ( ) ; <S2SV_StartBug> if ( v . v_vlin ) <S2SV_EndBug> <S2SV_StartBug> vc_cons [ i ] . d -> vc_scan_lines = v . v_vlin ; <S2SV_EndBug> if ( v . v_clin ) <S2SV_StartBug> vc_cons [ i ] . d -> vc_font . height = v . v_clin ; <S2SV_EndBug> <S2SV_StartBug> vc_cons [ i ] . d -> vc_resize_user = 1 ; <S2SV_EndBug> <S2SV_StartBug> vc_resize ( vc_cons [ i ] . d , v . v_cols , v . v_rows ) ; <S2SV_EndBug> console_unlock ( ) ; } break ; } case PIO_FONT : { if ( ! perm ) return - EPERM ; op . op = KD_FONT_OP_SET ; op . flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC ; op . width = 8 ; op . height = 0 ; op . charcount = 256 ; op . data = up ; ret = con_font_op ( vc_cons [ fg_console ] . d , & op ) ; break ; } case GIO_FONT : { op . op = KD_FONT_OP_GET ; op . flags = KD_FONT_FLAG_OLD ; op . width = 8 ; op . height = 32 ; op . charcount = 256 ; op . data = up ; ret = con_font_op ( vc_cons [ fg_console ] . d , & op ) ; break ; } case PIO_CMAP : if ( ! perm ) ret = - EPERM ; else ret = con_set_cmap ( up ) ; break ; case GIO_CMAP : ret = con_get_cmap ( up ) ; break ; case PIO_FONTX : case GIO_FONTX : ret = do_fontx_ioctl ( cmd , up , perm , & op ) ; break ; case PIO_FONTRESET : { if ( ! perm ) return - EPERM ; # ifdef BROKEN_GRAPHICS_PROGRAMS ret = - ENOSYS ; break ; # else { op . op = KD_FONT_OP_SET_DEFAULT ; op . data = NULL ; ret = con_font_op ( vc_cons [ fg_console ] . d , & op ) ; if ( ret ) break ; console_lock ( ) ; con_set_default_unimap ( vc_cons [ fg_console ] . d ) ; console_unlock ( ) ; break ; } # endif } case KDFONTOP : { if ( copy_from_user ( & op , up , sizeof ( op ) ) ) { ret = - EFAULT ; break ; } if ( ! perm && op . op != KD_FONT_OP_GET ) return - EPERM ; ret = con_font_op ( vc , & op ) ; if ( ret ) break ; if ( copy_to_user ( up , & op , sizeof ( op ) ) ) ret = - EFAULT ; break ; } case PIO_SCRNMAP : if ( ! perm ) ret = - EPERM ; else ret = con_set_trans_old ( up ) ; break ; case GIO_SCRNMAP : ret = con_get_trans_old ( up ) ; break ; case PIO_UNISCRNMAP : if ( ! perm ) ret = - EPERM ; else ret = con_set_trans_new ( up ) ; break ; case GIO_UNISCRNMAP : ret = con_get_trans_new ( up ) ; break ; case PIO_UNIMAPCLR : if ( ! perm ) return - EPERM ; con_clear_unimap ( vc ) ; break ; case PIO_UNIMAP : case GIO_UNIMAP : ret = do_unimap_ioctl ( cmd , up , perm , vc ) ; break ; case VT_LOCKSWITCH : if ( ! capable ( CAP_SYS_TTY_CONFIG ) ) return - EPERM ; vt_dont_switch = 1 ; break ; case VT_UNLOCKSWITCH : if ( ! capable ( CAP_SYS_TTY_CONFIG ) ) return - EPERM ; vt_dont_switch = 0 ; break ; case VT_GETHIFONTMASK : ret = put_user ( vc -> vc_hi_font_mask , ( unsigned short __user * ) arg ) ; break ; case VT_WAITEVENT : ret = vt_event_wait_ioctl ( ( struct vt_event __user * ) arg ) ; break ; default : ret = - ENOIOCTLCMD ; } out : return ret ; }", "target": "<S2SV_ModStart> ++ ) { struct vc_data * vcp ; <S2SV_ModStart> ( ) ; vcp = <S2SV_ModEnd> vc_cons [ i <S2SV_ModStart> ] . d ; if ( vcp ) { if ( v . v_vlin ) vcp <S2SV_ModStart> . v_clin ) vcp <S2SV_ModEnd> -> vc_font . <S2SV_ModStart> . v_clin ; vcp <S2SV_ModEnd> -> vc_resize_user = <S2SV_ModStart> ; vc_resize ( vcp <S2SV_ModEnd> , v . <S2SV_ModStart> v_rows ) ; }"}
{"source": "CWE-787 Pl_ASCIIHexDecoder : : flush ( ) { if ( this -> pos == 0 ) { QTC : : TC ( \"libtests\" , \"Pl_ASCIIHexDecoder<S2SV_blank>no-op<S2SV_blank>flush\" ) ; return ; } int b [ 2 ] ; for ( int i = 0 ; i < 2 ; ++ i ) { if ( this -> inbuf [ i ] >= 'A' ) { b [ i ] = this -> inbuf [ i ] - 'A' + 10 ; } else { b [ i ] = this -> inbuf [ i ] - '0' ; } } unsigned char ch = static_cast < unsigned char > ( ( b [ 0 ] << 4 ) + b [ 1 ] ) ; QTC : : TC ( \"libtests\" , \"Pl_ASCIIHexDecoder<S2SV_blank>partial<S2SV_blank>flush\" , ( this -> pos == 2 ) ? 0 : 1 ) ; <S2SV_StartBug> getNext ( ) -> write ( & ch , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> this -> pos = 0 ; <S2SV_EndBug> this -> inbuf [ 0 ] = '0' ; this -> inbuf [ 1 ] = '0' ; this -> inbuf [ 2 ] = '\\\\0' ; }", "target": "<S2SV_ModStart> 1 ) ; this -> pos = 0 ; this -> inbuf [ 0 ] = '0' ; this -> inbuf [ 1 ] = '0' ; this -> inbuf [ 2 ] = '\\\\0' ; <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> }  <S2SV_null>"}
{"source": "CWE-787 Pl_AES_PDF : : flush ( bool strip_padding ) { assert ( this -> offset == this -> buf_size ) ; if ( first ) { first = false ; bool return_after_init = false ; if ( this -> cbc_mode ) { if ( encrypt ) { initializeVector ( ) ; if ( ! ( this -> use_zero_iv || this -> use_specified_iv ) ) { getNext ( ) -> write ( this -> cbc_block , this -> buf_size ) ; } } else if ( this -> use_zero_iv || this -> use_specified_iv ) { initializeVector ( ) ; } else { memcpy ( this -> cbc_block , this -> inbuf , this -> buf_size ) ; this -> offset = 0 ; return_after_init = true ; } } this -> crypto -> rijndael_init ( encrypt , this -> key . get ( ) , key_bytes , this -> cbc_mode , this -> cbc_block ) ; if ( return_after_init ) { return ; } } if ( this -> encrypt ) { this -> crypto -> rijndael_process ( this -> inbuf , this -> outbuf ) ; } else { this -> crypto -> rijndael_process ( this -> inbuf , this -> outbuf ) ; } unsigned int bytes = this -> buf_size ; if ( strip_padding ) { unsigned char last = this -> outbuf [ this -> buf_size - 1 ] ; if ( last <= this -> buf_size ) { bool strip = true ; for ( unsigned int i = 1 ; i <= last ; ++ i ) { if ( this -> outbuf [ this -> buf_size - i ] != last ) { strip = false ; break ; } } if ( strip ) { bytes -= last ; } } } <S2SV_StartBug> getNext ( ) -> write ( this -> outbuf , bytes ) ; <S2SV_EndBug> <S2SV_StartBug> this -> offset = 0 ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> } } } this -> offset = 0 ; <S2SV_ModStart> bytes ) ; <S2SV_ModEnd> }  <S2SV_null>"}
{"source": "CWE-787 Pl_ASCII85Decoder : : flush ( ) { if ( this -> pos == 0 ) { QTC : : TC ( \"libtests\" , \"Pl_ASCII85Decoder<S2SV_blank>no-op<S2SV_blank>flush\" ) ; return ; } unsigned long lval = 0 ; for ( int i = 0 ; i < 5 ; ++ i ) { lval *= 85 ; lval += ( this -> inbuf [ i ] - 33U ) ; } unsigned char outbuf [ 4 ] ; memset ( outbuf , 0 , 4 ) ; for ( int i = 3 ; i >= 0 ; -- i ) { outbuf [ i ] = lval & 0xff ; lval >>= 8 ; } QTC : : TC ( \"libtests\" , \"Pl_ASCII85Decoder<S2SV_blank>partial<S2SV_blank>flush\" , ( this -> pos == 5 ) ? 0 : 1 ) ; <S2SV_StartBug> getNext ( ) -> write ( outbuf , this -> pos - 1 ) ; <S2SV_EndBug> this -> pos = 0 ; memset ( this -> inbuf , 117 , 5 ) ; <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> 1 ) ; auto t = <S2SV_ModEnd> this -> pos <S2SV_ModStart> pos - 1 ; <S2SV_ModEnd> this -> pos <S2SV_ModStart> 5 ) ; getNext ( ) -> write ( outbuf , t ) ;"}
{"source": "CWE-787 Pl_Count : : write ( unsigned char * buf , size_t len ) { if ( len ) { this -> m -> count += QIntC : : to_offset ( len ) ; <S2SV_StartBug> getNext ( ) -> write ( buf , len ) ; <S2SV_EndBug> this -> m -> last_char = buf [ len - 1 ] ; <S2SV_StartBug> } <S2SV_EndBug> }", "target": "<S2SV_ModStart> len ) ; <S2SV_ModEnd> this -> m <S2SV_ModStart> 1 ] ; getNext ( ) -> write ( buf , len ) ;"}
{"source": "CWE-787 static int mt_touch_input_mapping ( struct hid_device * hdev , struct hid_input * hi , struct hid_field * field , struct hid_usage * usage , unsigned long * * bit , int * max , struct mt_application * app ) { struct mt_device * td = hid_get_drvdata ( hdev ) ; struct mt_class * cls = & td -> mtclass ; int code ; struct hid_usage * prev_usage = NULL ; if ( field -> application == HID_DG_TOUCHSCREEN && ( usage -> hid & HID_USAGE_PAGE ) == HID_UP_BUTTON ) { app -> mt_flags |= INPUT_MT_POINTER ; td -> inputmode_value = MT_INPUTMODE_TOUCHPAD ; } if ( ( usage -> hid & HID_USAGE_PAGE ) == HID_UP_BUTTON ) app -> buttons_count ++ ; if ( usage -> usage_index ) prev_usage = & field -> usage [ usage -> usage_index - 1 ] ; switch ( usage -> hid & HID_USAGE_PAGE ) { case HID_UP_GENDESK : switch ( usage -> hid ) { case HID_GD_X : if ( prev_usage && ( prev_usage -> hid == usage -> hid ) ) { code = ABS_MT_TOOL_X ; MT_STORE_FIELD ( cx ) ; } else { code = ABS_MT_POSITION_X ; MT_STORE_FIELD ( x ) ; } set_abs ( hi -> input , code , field , cls -> sn_move ) ; if ( field -> application == HID_GD_SYSTEM_MULTIAXIS ) { __set_bit ( INPUT_PROP_DIRECT , hi -> input -> propbit ) ; input_set_abs_params ( hi -> input , ABS_MT_TOOL_TYPE , MT_TOOL_DIAL , MT_TOOL_DIAL , 0 , 0 ) ; } return 1 ; case HID_GD_Y : if ( prev_usage && ( prev_usage -> hid == usage -> hid ) ) { code = ABS_MT_TOOL_Y ; MT_STORE_FIELD ( cy ) ; } else { code = ABS_MT_POSITION_Y ; MT_STORE_FIELD ( y ) ; } set_abs ( hi -> input , code , field , cls -> sn_move ) ; return 1 ; } return 0 ; case HID_UP_DIGITIZER : switch ( usage -> hid ) { case HID_DG_INRANGE : if ( app -> quirks & MT_QUIRK_HOVERING ) { input_set_abs_params ( hi -> input , ABS_MT_DISTANCE , 0 , 1 , 0 , 0 ) ; } MT_STORE_FIELD ( inrange_state ) ; return 1 ; case HID_DG_CONFIDENCE : if ( cls -> name == MT_CLS_WIN_8 && ( field -> application == HID_DG_TOUCHPAD || field -> application == HID_DG_TOUCHSCREEN ) ) app -> quirks |= MT_QUIRK_CONFIDENCE ; if ( app -> quirks & MT_QUIRK_CONFIDENCE ) input_set_abs_params ( hi -> input , ABS_MT_TOOL_TYPE , MT_TOOL_FINGER , MT_TOOL_PALM , 0 , 0 ) ; MT_STORE_FIELD ( confidence_state ) ; return 1 ; case HID_DG_TIPSWITCH : if ( field -> application != HID_GD_SYSTEM_MULTIAXIS ) input_set_capability ( hi -> input , EV_KEY , BTN_TOUCH ) ; MT_STORE_FIELD ( tip_state ) ; return 1 ; case HID_DG_CONTACTID : MT_STORE_FIELD ( contactid ) ; app -> touches_by_report ++ ; return 1 ; case HID_DG_WIDTH : if ( ! ( app -> quirks & MT_QUIRK_NO_AREA ) ) set_abs ( hi -> input , ABS_MT_TOUCH_MAJOR , field , cls -> sn_width ) ; MT_STORE_FIELD ( w ) ; return 1 ; case HID_DG_HEIGHT : if ( ! ( app -> quirks & MT_QUIRK_NO_AREA ) ) { set_abs ( hi -> input , ABS_MT_TOUCH_MINOR , field , cls -> sn_height ) ; if ( ! test_bit ( ABS_MT_ORIENTATION , hi -> input -> absbit ) ) input_set_abs_params ( hi -> input , ABS_MT_ORIENTATION , 0 , 1 , 0 , 0 ) ; } MT_STORE_FIELD ( h ) ; return 1 ; case HID_DG_TIPPRESSURE : set_abs ( hi -> input , ABS_MT_PRESSURE , field , cls -> sn_pressure ) ; MT_STORE_FIELD ( p ) ; return 1 ; case HID_DG_SCANTIME : input_set_capability ( hi -> input , EV_MSC , MSC_TIMESTAMP ) ; app -> scantime = & field -> value [ usage -> usage_index ] ; app -> scantime_logical_max = field -> logical_maximum ; return 1 ; case HID_DG_CONTACTCOUNT : app -> have_contact_count = true ; app -> raw_cc = & field -> value [ usage -> usage_index ] ; return 1 ; case HID_DG_AZIMUTH : input_set_abs_params ( hi -> input , ABS_MT_ORIENTATION , - field -> logical_maximum / 4 , field -> logical_maximum / 4 , cls -> sn_move ? field -> logical_maximum / cls -> sn_move : 0 , 0 ) ; MT_STORE_FIELD ( a ) ; return 1 ; case HID_DG_CONTACTMAX : return - 1 ; case HID_DG_TOUCH : return - 1 ; } return 0 ; case HID_UP_BUTTON : code = BTN_MOUSE + ( ( usage -> hid - 1 ) & HID_USAGE ) ; if ( ( app -> quirks & MT_QUIRK_WIN8_PTP_BUTTONS ) && field -> application == HID_DG_TOUCHPAD && ( usage -> hid & HID_USAGE ) > 1 ) code -- ; if ( field -> application == HID_GD_SYSTEM_MULTIAXIS ) code = BTN_0 + ( ( usage -> hid - 1 ) & HID_USAGE ) ; hid_map_usage ( hi , usage , bit , max , EV_KEY , code ) ; <S2SV_StartBug> input_set_capability ( hi -> input , EV_KEY , code ) ; <S2SV_EndBug> return 1 ; case 0xff000000 : return - 1 ; } return 0 ; }", "target": "<S2SV_ModStart> code ) ; if ( ! * bit ) return - 1 ;"}
{"source": "CWE-200 ecc_decrypt_raw ( gcry_sexp_t * r_plain , gcry_sexp_t s_data , gcry_sexp_t keyparms ) { unsigned int nbits ; gpg_err_code_t rc ; struct pk_encoding_ctx ctx ; gcry_sexp_t l1 = NULL ; gcry_mpi_t data_e = NULL ; ECC_secret_key sk ; gcry_mpi_t mpi_g = NULL ; char * curvename = NULL ; mpi_ec_t ec = NULL ; mpi_point_struct kG ; mpi_point_struct R ; gcry_mpi_t r = NULL ; int flags = 0 ; memset ( & sk , 0 , sizeof sk ) ; point_init ( & kG ) ; point_init ( & R ) ; _gcry_pk_util_init_encoding_ctx ( & ctx , PUBKEY_OP_DECRYPT , ( nbits = ecc_get_nbits ( keyparms ) ) ) ; l1 = sexp_find_token ( keyparms , \"flags\" , 0 ) ; if ( l1 ) { rc = _gcry_pk_util_parse_flaglist ( l1 , & flags , NULL ) ; if ( rc ) goto leave ; } sexp_release ( l1 ) ; l1 = NULL ; rc = _gcry_pk_util_preparse_encval ( s_data , ecc_names , & l1 , & ctx ) ; if ( rc ) goto leave ; rc = sexp_extract_param ( l1 , NULL , \"e\" , & data_e , NULL ) ; if ( rc ) goto leave ; if ( DBG_CIPHER ) log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank>d_e\" , data_e ) ; if ( mpi_is_opaque ( data_e ) ) { rc = GPG_ERR_INV_DATA ; goto leave ; } rc = sexp_extract_param ( keyparms , NULL , \"-p?a?b?g?n?h?+d\" , & sk . E . p , & sk . E . a , & sk . E . b , & mpi_g , & sk . E . n , & sk . E . h , & sk . d , NULL ) ; if ( rc ) goto leave ; if ( mpi_g ) { point_init ( & sk . E . G ) ; rc = _gcry_ecc_os2ec ( & sk . E . G , mpi_g ) ; if ( rc ) goto leave ; } sexp_release ( l1 ) ; l1 = sexp_find_token ( keyparms , \"curve\" , 5 ) ; if ( l1 ) { curvename = sexp_nth_string ( l1 , 1 ) ; if ( curvename ) { rc = _gcry_ecc_fill_in_curve ( 0 , curvename , & sk . E , NULL ) ; if ( rc ) goto leave ; } } if ( ! curvename ) { sk . E . model = MPI_EC_WEIERSTRASS ; sk . E . dialect = ECC_DIALECT_STANDARD ; if ( ! sk . E . h ) sk . E . h = mpi_const ( MPI_C_ONE ) ; } if ( DBG_CIPHER ) { log_debug ( \"ecc_decrypt<S2SV_blank>info:<S2SV_blank>%s/%s\\\\n\" , _gcry_ecc_model2str ( sk . E . model ) , _gcry_ecc_dialect2str ( sk . E . dialect ) ) ; if ( sk . E . name ) log_debug ( \"ecc_decrypt<S2SV_blank>name:<S2SV_blank>%s\\\\n\" , sk . E . name ) ; log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>p\" , sk . E . p ) ; log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>a\" , sk . E . a ) ; log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>b\" , sk . E . b ) ; log_printpnt ( \"ecc_decrypt<S2SV_blank><S2SV_blank>g\" , & sk . E . G , NULL ) ; log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>n\" , sk . E . n ) ; log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>h\" , sk . E . h ) ; if ( ! fips_mode ( ) ) log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>d\" , sk . d ) ; } if ( ! sk . E . p || ! sk . E . a || ! sk . E . b || ! sk . E . G . x || ! sk . E . n || ! sk . E . h || ! sk . d ) { rc = GPG_ERR_NO_OBJ ; goto leave ; } ec = _gcry_mpi_ec_p_internal_new ( sk . E . model , sk . E . dialect , flags , sk . E . p , sk . E . a , sk . E . b ) ; if ( ec -> model == MPI_EC_MONTGOMERY ) rc = _gcry_ecc_mont_decodepoint ( data_e , ec , & kG ) ; else rc = _gcry_ecc_os2ec ( & kG , data_e ) ; if ( rc ) goto leave ; if ( DBG_CIPHER ) log_printpnt ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>kG\" , & kG , NULL ) ; <S2SV_StartBug> if ( ! ( flags & PUBKEY_FLAG_DJB_TWEAK ) <S2SV_EndBug> <S2SV_StartBug> && ! _gcry_mpi_ec_curve_point ( & kG , ec ) ) <S2SV_EndBug> { rc = GPG_ERR_INV_DATA ; goto leave ; } _gcry_mpi_ec_mul_point ( & R , sk . d , & kG , ec ) ; { gcry_mpi_t x , y ; x = mpi_new ( 0 ) ; if ( ec -> model == MPI_EC_MONTGOMERY ) y = NULL ; else y = mpi_new ( 0 ) ; if ( _gcry_mpi_ec_get_affine ( x , y , & R , ec ) ) { rc = GPG_ERR_INV_DATA ; goto leave ; } if ( y ) r = _gcry_ecc_ec2os ( x , y , sk . E . p ) ; else { unsigned char * rawmpi ; unsigned int rawmpilen ; rawmpi = _gcry_mpi_get_buffer_extra ( x , nbits / 8 , - 1 , & rawmpilen , NULL ) ; if ( ! rawmpi ) { rc = gpg_err_code_from_syserror ( ) ; goto leave ; } else { rawmpi [ 0 ] = 0x40 ; rawmpilen ++ ; r = mpi_new ( 0 ) ; mpi_set_opaque ( r , rawmpi , rawmpilen * 8 ) ; } } if ( ! r ) rc = gpg_err_code_from_syserror ( ) ; else rc = 0 ; mpi_free ( x ) ; mpi_free ( y ) ; } if ( DBG_CIPHER ) log_printmpi ( \"ecc_decrypt<S2SV_blank><S2SV_blank>res\" , r ) ; if ( ! rc ) rc = sexp_build ( r_plain , NULL , \"(value<S2SV_blank>%m)\" , r ) ; leave : point_free ( & R ) ; point_free ( & kG ) ; _gcry_mpi_release ( r ) ; _gcry_mpi_release ( sk . E . p ) ; _gcry_mpi_release ( sk . E . a ) ; _gcry_mpi_release ( sk . E . b ) ; _gcry_mpi_release ( mpi_g ) ; point_free ( & sk . E . G ) ; _gcry_mpi_release ( sk . E . n ) ; _gcry_mpi_release ( sk . E . h ) ; _gcry_mpi_release ( sk . d ) ; _gcry_mpi_release ( data_e ) ; xfree ( curvename ) ; sexp_release ( l1 ) ; _gcry_mpi_ec_free ( ec ) ; _gcry_pk_util_free_encoding_ctx ( & ctx ) ; if ( DBG_CIPHER ) log_debug ( \"ecc_decrypt<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=><S2SV_blank>%s\\\\n\" , gpg_strerror ( rc ) ) ; return rc ; }", "target": "<S2SV_ModStart> ; if ( <S2SV_ModEnd> ( flags & <S2SV_ModStart> & PUBKEY_FLAG_DJB_TWEAK ) ) { if ( _gcry_mpi_ec_bad_point ( & kG , ec ) ) { rc = GPG_ERR_INV_DATA ; goto leave ; } } else if ( <S2SV_ModEnd> ! _gcry_mpi_ec_curve_point ("}
{"source": "CWE-125 static MagickBooleanType ReadHEICImageByID ( const ImageInfo * image_info , Image * image , struct heif_context * heif_context , heif_item_id image_id , ExceptionInfo * exception ) { const char * option ; int stride_y , stride_cb , stride_cr ; MagickBooleanType status ; ssize_t y ; struct heif_decoding_options * decode_options ; struct heif_error error ; struct heif_image * heif_image ; struct heif_image_handle * image_handle ; const uint8_t * p_y , * p_cb , * p_cr ; error = heif_context_get_image_handle ( heif_context , image_id , & image_handle ) ; if ( IsHeifSuccess ( & error , image , exception ) == MagickFalse ) return ( MagickFalse ) ; if ( ReadHEICColorProfile ( image , image_handle , exception ) == MagickFalse ) { heif_image_handle_release ( image_handle ) ; return ( MagickFalse ) ; } if ( ReadHEICExifProfile ( image , image_handle , exception ) == MagickFalse ) { heif_image_handle_release ( image_handle ) ; return ( MagickFalse ) ; } image -> depth = 8 ; image -> columns = ( size_t ) heif_image_handle_get_width ( image_handle ) ; image -> rows = ( size_t ) heif_image_handle_get_height ( image_handle ) ; if ( image_info -> ping != MagickFalse ) { image -> colorspace = YCbCrColorspace ; heif_image_handle_release ( image_handle ) ; return ( MagickTrue ) ; } if ( HEICSkipImage ( image_info , image ) != MagickFalse ) { heif_image_handle_release ( image_handle ) ; return ( MagickTrue ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { heif_image_handle_release ( image_handle ) ; return ( MagickFalse ) ; } ( void ) SetImageColorspace ( image , YCbCrColorspace , exception ) ; decode_options = ( struct heif_decoding_options * ) NULL ; option = GetImageOption ( image_info , \"heic:preserve-orientation\" ) ; if ( IsStringTrue ( option ) == MagickTrue ) { decode_options = heif_decoding_options_alloc ( ) ; decode_options -> ignore_transformations = 1 ; } else ( void ) SetImageProperty ( image , \"exif:Orientation\" , \"1\" , exception ) ; error = heif_decode_image ( image_handle , & heif_image , heif_colorspace_YCbCr , heif_chroma_420 , decode_options ) ; <S2SV_StartBug> if ( IsHeifSuccess ( & error , image , exception ) == MagickFalse ) <S2SV_EndBug> { heif_image_handle_release ( image_handle ) ; return ( MagickFalse ) ; } <S2SV_StartBug> if ( decode_options != ( struct heif_decoding_options * ) NULL ) <S2SV_EndBug> { image -> columns = ( size_t ) heif_image_get_width ( heif_image , heif_channel_Y ) ; image -> rows = ( size_t ) heif_image_get_height ( heif_image , heif_channel_Y ) ; <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> heif_decoding_options_free ( decode_options ) ; if ( status == MagickFalse ) { heif_image_release ( heif_image ) ; heif_image_handle_release ( image_handle ) ; return ( MagickFalse ) ; <S2SV_StartBug> } <S2SV_EndBug> } p_y = heif_image_get_plane_readonly ( heif_image , heif_channel_Y , & stride_y ) ; p_cb = heif_image_get_plane_readonly ( heif_image , heif_channel_Cb , & stride_cb ) ; p_cr = heif_image_get_plane_readonly ( heif_image , heif_channel_Cr , & stride_cr ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { Quantum * q ; register ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) p_y [ y * stride_y + x ] ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) p_cb [ ( y / 2 ) * stride_cb + x / 2 ] ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) p_cr [ ( y / 2 ) * stride_cr + x / 2 ] ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } heif_image_release ( heif_image ) ; heif_image_handle_release ( image_handle ) ; return ( MagickTrue ) ; }", "target": "<S2SV_ModStart> ; if ( decode_options != ( struct heif_decoding_options * ) NULL ) heif_decoding_options_free ( decode_options ) ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> image -> columns <S2SV_ModStart> rows , exception <S2SV_ModEnd> ) ; if <S2SV_ModStart> MagickFalse ) ; <S2SV_ModEnd> } p_y ="}
{"source": "CWE-125 static MagickBooleanType TIFFGetProfiles ( TIFF * tiff , Image * image , ExceptionInfo * exception ) { MagickBooleanType status ; uint32 length = 0 ; unsigned char * profile = ( unsigned char * ) NULL ; status = MagickTrue ; # if defined ( TIFFTAG_ICCPROFILE ) if ( ( TIFFGetField ( tiff , TIFFTAG_ICCPROFILE , & length , & profile ) == 1 ) && ( profile != ( unsigned char * ) NULL ) ) status = ReadProfile ( image , \"icc\" , profile , ( ssize_t ) length , exception ) ; # endif # if defined ( TIFFTAG_PHOTOSHOP ) if ( ( TIFFGetField ( tiff , TIFFTAG_PHOTOSHOP , & length , & profile ) == 1 ) && ( profile != ( unsigned char * ) NULL ) ) status = ReadProfile ( image , \"8bim\" , profile , ( ssize_t ) length , exception ) ; # endif # if defined ( TIFFTAG_RICHTIFFIPTC ) if ( ( TIFFGetField ( tiff , TIFFTAG_RICHTIFFIPTC , & length , & profile ) == 1 ) && ( profile != ( unsigned char * ) NULL ) ) { <S2SV_StartBug> if ( TIFFIsByteSwapped ( tiff ) != 0 ) <S2SV_EndBug> TIFFSwabArrayOfLong ( ( uint32 * ) profile , ( size_t ) length ) ; <S2SV_StartBug> status = ReadProfile ( image , \"iptc\" , profile , 4L * length , exception ) ; <S2SV_EndBug> } # endif # if defined ( TIFFTAG_XMLPACKET ) if ( ( TIFFGetField ( tiff , TIFFTAG_XMLPACKET , & length , & profile ) == 1 ) && ( profile != ( unsigned char * ) NULL ) ) { StringInfo * dng ; status = ReadProfile ( image , \"xmp\" , profile , ( ssize_t ) length , exception ) ; dng = BlobToStringInfo ( profile , length ) ; if ( dng != ( StringInfo * ) NULL ) { const char * target = \"dc:format=\\\\\"image/dng\\\\\"\" ; if ( strstr ( ( char * ) GetStringInfoDatum ( dng ) , target ) != ( char * ) NULL ) ( void ) CopyMagickString ( image -> magick , \"DNG\" , MagickPathExtent ) ; dng = DestroyStringInfo ( dng ) ; } } # endif if ( ( TIFFGetField ( tiff , 34118 , & length , & profile ) == 1 ) && ( profile != ( unsigned char * ) NULL ) ) status = ReadProfile ( image , \"tiff:34118\" , profile , ( ssize_t ) length , exception ) ; if ( ( TIFFGetField ( tiff , 37724 , & length , & profile ) == 1 ) && ( profile != ( unsigned char * ) NULL ) ) status = ReadProfile ( image , \"tiff:37724\" , profile , ( ssize_t ) length , exception ) ; return ( status ) ; }", "target": "<S2SV_ModStart> ) ) { const TIFFField * field ; <S2SV_ModStart> length ) ; field = TIFFFieldWithTag ( tiff , TIFFTAG_RICHTIFFIPTC ) ; if ( TIFFFieldDataType ( field ) == TIFF_LONG ) <S2SV_ModStart> , 4L * length , exception ) ; else status = ReadProfile ( image , \"iptc\" , profile ,"}
{"source": "CWE-668 readfile ( char_u * fname , char_u * sfname , linenr_T from , linenr_T lines_to_skip , linenr_T lines_to_read , exarg_T * eap , int flags ) { int fd = 0 ; int newfile = ( flags & READ_NEW ) ; int check_readonly ; int filtering = ( flags & READ_FILTER ) ; int read_stdin = ( flags & READ_STDIN ) ; int read_buffer = ( flags & READ_BUFFER ) ; int read_fifo = ( flags & READ_FIFO ) ; int set_options = newfile || read_buffer || ( eap != NULL && eap -> read_edit ) ; linenr_T read_buf_lnum = 1 ; colnr_T read_buf_col = 0 ; char_u c ; linenr_T lnum = from ; char_u * ptr = NULL ; char_u * buffer = NULL ; char_u * new_buffer = NULL ; char_u * line_start = NULL ; int wasempty ; colnr_T len ; long size = 0 ; char_u * p ; off_T filesize = 0 ; int skip_read = FALSE ; # ifdef FEAT_CRYPT char_u * cryptkey = NULL ; int did_ask_for_key = FALSE ; # endif # ifdef FEAT_PERSISTENT_UNDO context_sha256_T sha_ctx ; int read_undo_file = FALSE ; # endif int split = 0 ; # define UNKNOWN 0x0fffffff linenr_T linecnt ; int error = FALSE ; int ff_error = EOL_UNKNOWN ; long linerest = 0 ; # ifdef UNIX int perm = 0 ; int swap_mode = - 1 ; # else int perm ; # endif int fileformat = 0 ; int keep_fileformat = FALSE ; stat_T st ; int file_readonly ; linenr_T skip_count = 0 ; linenr_T read_count = 0 ; int msg_save = msg_scroll ; linenr_T read_no_eol_lnum = 0 ; int try_mac ; int try_dos ; int try_unix ; int file_rewind = FALSE ; # ifdef FEAT_MBYTE int can_retry ; linenr_T conv_error = 0 ; linenr_T illegal_byte = 0 ; int keep_dest_enc = FALSE ; int bad_char_behavior = BAD_REPLACE ; char_u * tmpname = NULL ; int fio_flags = 0 ; char_u * fenc ; int fenc_alloced ; char_u * fenc_next = NULL ; int advance_fenc = FALSE ; long real_size = 0 ; # ifdef USE_ICONV iconv_t iconv_fd = ( iconv_t ) - 1 ; # ifdef FEAT_EVAL int did_iconv = FALSE ; # endif # endif int converted = FALSE ; int notconverted = FALSE ; char_u conv_rest [ CONV_RESTLEN ] ; int conv_restlen = 0 ; # endif # ifdef FEAT_AUTOCMD buf_T * old_curbuf ; char_u * old_b_ffname ; char_u * old_b_fname ; int using_b_ffname ; int using_b_fname ; # endif # ifdef FEAT_AUTOCMD au_did_filetype = FALSE ; # endif curbuf -> b_no_eol_lnum = 0 ; if ( curbuf -> b_ffname == NULL && ! filtering && fname != NULL && vim_strchr ( p_cpo , CPO_FNAMER ) != NULL && ! ( flags & READ_DUMMY ) ) { if ( set_rw_fname ( fname , sfname ) == FAIL ) return FAIL ; } # ifdef FEAT_AUTOCMD old_curbuf = curbuf ; old_b_ffname = curbuf -> b_ffname ; old_b_fname = curbuf -> b_fname ; using_b_ffname = ( fname == curbuf -> b_ffname ) || ( sfname == curbuf -> b_ffname ) ; using_b_fname = ( fname == curbuf -> b_fname ) || ( sfname == curbuf -> b_fname ) ; # endif ex_no_reprint = TRUE ; need_fileinfo = FALSE ; if ( sfname == NULL ) sfname = fname ; # if defined ( UNIX ) fname = sfname ; # endif # ifdef FEAT_AUTOCMD if ( ! filtering && ! read_stdin && ! read_buffer ) { pos_T pos ; pos = curbuf -> b_op_start ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; if ( newfile ) { if ( apply_autocmds_exarg ( EVENT_BUFREADCMD , NULL , sfname , FALSE , curbuf , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif } else if ( apply_autocmds_exarg ( EVENT_FILEREADCMD , sfname , sfname , FALSE , NULL , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif curbuf -> b_op_start = pos ; } # endif if ( ( shortmess ( SHM_OVER ) || curbuf -> b_help ) && p_verbose == 0 ) msg_scroll = FALSE ; else msg_scroll = TRUE ; if ( fname != NULL && * fname != NUL ) { p = fname + STRLEN ( fname ) ; if ( after_pathsep ( fname , p ) || STRLEN ( fname ) >= MAXPATHL ) { filemess ( curbuf , fname , ( char_u * ) _ ( \"Illegal<S2SV_blank>file<S2SV_blank>name\" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } } if ( ! read_stdin && ! read_buffer && ! read_fifo ) { # ifdef UNIX perm = mch_getperm ( fname ) ; if ( perm >= 0 && ! S_ISREG ( perm ) # ifdef S_ISFIFO && ! S_ISFIFO ( perm ) # endif # ifdef S_ISSOCK && ! S_ISSOCK ( perm ) # endif # ifdef OPEN_CHR_FILES && ! ( S_ISCHR ( perm ) && is_dev_fd_file ( fname ) ) # endif ) { int retval = FAIL ; if ( S_ISDIR ( perm ) ) { filemess ( curbuf , fname , ( char_u * ) _ ( \"is<S2SV_blank>a<S2SV_blank>directory\" ) , 0 ) ; retval = NOTDONE ; } else filemess ( curbuf , fname , ( char_u * ) _ ( \"is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>file\" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return retval ; } # endif # if defined ( MSWIN ) if ( ! p_odev && mch_nodetype ( fname ) == NODE_WRITABLE ) { filemess ( curbuf , fname , ( char_u * ) _ ( \"is<S2SV_blank>a<S2SV_blank>device<S2SV_blank>(disabled<S2SV_blank>with<S2SV_blank>\\'opendevice\\'<S2SV_blank>option)\" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } # endif } set_file_options ( set_options , eap ) ; check_readonly = ( newfile && ( curbuf -> b_flags & BF_CHECK_RO ) ) ; if ( check_readonly && ! readonlymode ) curbuf -> b_p_ro = FALSE ; if ( newfile && ! read_stdin && ! read_buffer && ! read_fifo ) { if ( mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; # ifdef UNIX swap_mode = ( st . st_mode & 0644 ) | 0600 ; # endif # ifdef FEAT_CW_EDITOR ( void ) GetFSSpecFromPath ( curbuf -> b_ffname , & curbuf -> b_FSSpec ) ; # endif # ifdef VMS curbuf -> b_fab_rfm = st . st_fab_rfm ; curbuf -> b_fab_rat = st . st_fab_rat ; curbuf -> b_fab_mrs = st . st_fab_mrs ; # endif } else { curbuf -> b_mtime = 0 ; curbuf -> b_mtime_read = 0 ; curbuf -> b_orig_size = 0 ; curbuf -> b_orig_mode = 0 ; } curbuf -> b_flags &= ~ ( BF_NEW | BF_NEW_W ) ; } file_readonly = FALSE ; if ( read_stdin ) { # if defined ( MSWIN ) setmode ( 0 , O_BINARY ) ; # endif } else if ( ! read_buffer ) { # ifdef USE_MCH_ACCESS if ( # ifdef UNIX ! ( perm & 0222 ) || # endif mch_access ( ( char * ) fname , W_OK ) ) file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; # else if ( ! newfile || readonlymode || ( fd = mch_open ( ( char * ) fname , O_RDWR | O_EXTRA , 0 ) ) < 0 ) { file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; } # endif } if ( fd < 0 ) { # ifndef UNIX int isdir_f ; # endif msg_scroll = msg_save ; # ifndef UNIX isdir_f = ( mch_isdir ( fname ) ) ; perm = mch_getperm ( fname ) ; if ( isdir_f ) { filemess ( curbuf , sfname , ( char_u * ) _ ( \"is<S2SV_blank>a<S2SV_blank>directory\" ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } else # endif if ( newfile ) { if ( perm < 0 # ifdef ENOENT && errno == ENOENT # endif ) { curbuf -> b_flags |= BF_NEW ; # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; return FAIL ; } # endif } if ( dir_of_file_exists ( fname ) ) filemess ( curbuf , sfname , ( char_u * ) _ ( \"[New<S2SV_blank>File]\" ) , 0 ) ; else filemess ( curbuf , sfname , ( char_u * ) _ ( \"[New<S2SV_blank>DIRECTORY]\" ) , 0 ) ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif # ifdef FEAT_MBYTE if ( eap != NULL ) set_forced_fenc ( eap ) ; # endif # ifdef FEAT_AUTOCMD apply_autocmds_exarg ( EVENT_BUFNEWFILE , sfname , sfname , FALSE , curbuf , eap ) ; # endif save_file_ff ( curbuf ) ; # if defined ( FEAT_AUTOCMD ) && defined ( FEAT_EVAL ) if ( aborting ( ) ) return FAIL ; # endif return OK ; } else { filemess ( curbuf , sfname , ( char_u * ) ( # ifdef EFBIG ( errno == EFBIG ) ? _ ( \"[File<S2SV_blank>too<S2SV_blank>big]\" ) : # endif # ifdef EOVERFLOW ( errno == EOVERFLOW ) ? _ ( \"[File<S2SV_blank>too<S2SV_blank>big]\" ) : # endif _ ( \"[Permission<S2SV_blank>Denied]\" ) ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } } return FAIL ; } if ( ( check_readonly && file_readonly ) || curbuf -> b_help ) curbuf -> b_p_ro = TRUE ; if ( set_options ) { if ( ! read_buffer ) { curbuf -> b_p_eol = TRUE ; curbuf -> b_start_eol = TRUE ; } # ifdef FEAT_MBYTE curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; # endif } # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; if ( ! read_buffer ) close ( fd ) ; return FAIL ; } # endif # ifdef UNIX if ( swap_mode > 0 && curbuf -> b_ml . ml_mfp != NULL && curbuf -> b_ml . ml_mfp -> mf_fname != NULL ) <S2SV_StartBug> ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ; <S2SV_EndBug> # endif } # if defined ( HAS_SWAP_EXISTS_ACTION ) if ( swap_exists_action == SEA_QUIT ) { if ( ! read_buffer && ! read_stdin ) close ( fd ) ; return FAIL ; } # endif ++ no_wait_return ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; # ifdef FEAT_AUTOCMD if ( ! read_buffer ) { int m = msg_scroll ; int n = msg_scrolled ; if ( ! read_stdin ) close ( fd ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( read_stdin ) apply_autocmds_exarg ( EVENT_STDINREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile ) apply_autocmds_exarg ( EVENT_BUFREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else apply_autocmds_exarg ( EVENT_FILEREADPRE , sfname , sfname , FALSE , NULL , eap ) ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) { -- no_wait_return ; msg_scroll = msg_save ; curbuf -> b_p_ro = TRUE ; return FAIL ; } # endif if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) || ( fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ) < 0 ) ) { -- no_wait_return ; msg_scroll = msg_save ; if ( fd < 0 ) EMSG ( _ ( \"E200:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>made<S2SV_blank>the<S2SV_blank>file<S2SV_blank>unreadable\" ) ) ; else EMSG ( _ ( \"E201:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>must<S2SV_blank>not<S2SV_blank>change<S2SV_blank>current<S2SV_blank>buffer\" ) ) ; curbuf -> b_p_ro = TRUE ; return FAIL ; } } # endif wasempty = ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ; if ( ! recoverymode && ! filtering && ! ( flags & READ_DUMMY ) ) { if ( read_stdin ) { # ifndef ALWAYS_USE_GUI mch_msg ( _ ( \"Vim:<S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin...\\\\n\" ) ) ; # endif # ifdef FEAT_GUI if ( gui . in_use && ! gui . dying && ! gui . starting ) { p = ( char_u * ) _ ( \"Reading<S2SV_blank>from<S2SV_blank>stdin...\" ) ; gui_write ( p , ( int ) STRLEN ( p ) ) ; } # endif } else if ( ! read_buffer ) filemess ( curbuf , sfname , ( char_u * ) \"\" , 0 ) ; } msg_scroll = FALSE ; linecnt = curbuf -> b_ml . ml_line_count ; # ifdef FEAT_MBYTE if ( eap != NULL && eap -> bad_char != 0 ) { bad_char_behavior = eap -> bad_char ; if ( set_options ) curbuf -> b_bad_char = eap -> bad_char ; } else curbuf -> b_bad_char = 0 ; if ( eap != NULL && eap -> force_enc != 0 ) { fenc = enc_canonize ( eap -> cmd + eap -> force_enc ) ; fenc_alloced = TRUE ; keep_dest_enc = TRUE ; } else if ( curbuf -> b_p_bin ) { fenc = ( char_u * ) \"\" ; fenc_alloced = FALSE ; } else if ( curbuf -> b_help ) { char_u firstline [ 80 ] ; int fc ; fenc = ( char_u * ) \"latin1\" ; c = enc_utf8 ; if ( ! c && ! read_stdin ) { fc = fname [ STRLEN ( fname ) - 1 ] ; if ( TOLOWER_ASC ( fc ) == 'x' ) { len = read_eintr ( fd , firstline , 80 ) ; vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) ; for ( p = firstline ; p < firstline + len ; ++ p ) if ( * p >= 0x80 ) { c = TRUE ; break ; } } } if ( c ) { fenc_next = fenc ; fenc = ( char_u * ) \"utf-8\" ; if ( ! enc_utf8 ) keep_dest_enc = TRUE ; } fenc_alloced = FALSE ; } else if ( * p_fencs == NUL ) { fenc = curbuf -> b_p_fenc ; fenc_alloced = FALSE ; } else { fenc_next = p_fencs ; fenc = next_fenc ( & fenc_next ) ; fenc_alloced = TRUE ; } # endif retry : if ( file_rewind ) { if ( read_buffer ) { read_buf_lnum = 1 ; read_buf_col = 0 ; } else if ( read_stdin || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) != 0 ) { error = TRUE ; goto failed ; } while ( lnum > from ) ml_delete ( lnum -- , FALSE ) ; file_rewind = FALSE ; # ifdef FEAT_MBYTE if ( set_options ) { curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; } conv_error = 0 ; # endif } if ( keep_fileformat ) keep_fileformat = FALSE ; else { if ( eap != NULL && eap -> force_ff != 0 ) { fileformat = get_fileformat_force ( curbuf , eap ) ; try_unix = try_dos = try_mac = FALSE ; } else if ( curbuf -> b_p_bin ) fileformat = EOL_UNIX ; else if ( * p_ffs == NUL ) fileformat = get_fileformat ( curbuf ) ; else fileformat = EOL_UNKNOWN ; } # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif if ( advance_fenc ) { advance_fenc = FALSE ; if ( eap != NULL && eap -> force_enc != 0 ) { notconverted = TRUE ; conv_error = 0 ; if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ( char_u * ) \"\" ; fenc_alloced = FALSE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; if ( fenc_next != NULL ) { fenc = next_fenc ( & fenc_next ) ; fenc_alloced = ( fenc_next != NULL ) ; } else { fenc = ( char_u * ) \"\" ; fenc_alloced = FALSE ; } } if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; tmpname = NULL ; } } fio_flags = 0 ; converted = need_conversion ( fenc ) ; if ( converted ) { if ( STRCMP ( fenc , ENC_UCSBOM ) == 0 ) fio_flags = FIO_UCSBOM ; else if ( enc_utf8 || STRCMP ( p_enc , \"latin1\" ) == 0 ) fio_flags = get_fio_flags ( fenc ) ; # ifdef WIN3264 if ( fio_flags == 0 ) fio_flags = get_win_fio_flags ( fenc ) ; # endif # ifdef MACOS_CONVERT if ( fio_flags == 0 ) fio_flags = get_mac_fio_flags ( fenc ) ; # endif # ifdef USE_ICONV if ( fio_flags == 0 # ifdef FEAT_EVAL && ! did_iconv # endif ) iconv_fd = ( iconv_t ) my_iconv_open ( enc_utf8 ? ( char_u * ) \"utf-8\" : p_enc , fenc ) ; # endif # ifdef FEAT_EVAL if ( fio_flags == 0 && ! read_stdin && ! read_buffer && * p_ccv != NUL && ! read_fifo # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { # ifdef USE_ICONV did_iconv = FALSE ; # endif if ( tmpname == NULL ) { tmpname = readfile_charconvert ( fname , fenc , & fd ) ; if ( tmpname == NULL ) { advance_fenc = TRUE ; if ( fd < 0 ) { EMSG ( _ ( \"E202:<S2SV_blank>Conversion<S2SV_blank>made<S2SV_blank>file<S2SV_blank>unreadable!\" ) ) ; error = TRUE ; goto failed ; } goto retry ; } } } else # endif { if ( fio_flags == 0 # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { advance_fenc = TRUE ; goto retry ; } } } can_retry = ( * fenc != NUL && ! read_stdin && ! read_fifo && ! keep_dest_enc ) ; # endif if ( ! skip_read ) { linerest = 0 ; filesize = 0 ; skip_count = lines_to_skip ; read_count = lines_to_read ; # ifdef FEAT_MBYTE conv_restlen = 0 ; # endif # ifdef FEAT_PERSISTENT_UNDO read_undo_file = ( newfile && ( flags & READ_KEEP_UNDO ) == 0 && curbuf -> b_ffname != NULL && curbuf -> b_p_udf && ! filtering && ! read_fifo && ! read_stdin && ! read_buffer ) ; if ( read_undo_file ) sha256_start ( & sha_ctx ) ; # endif # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } # endif } while ( ! error && ! got_int ) { # if VIM_SIZEOF_INT <= 2 if ( linerest >= 0x7ff0 ) { ++ split ; * ptr = NL ; size = 1 ; } else # endif { if ( ! skip_read ) { # if VIM_SIZEOF_INT > 2 # if defined ( SSIZE_MAX ) && ( SSIZE_MAX < 0x10000L ) size = SSIZE_MAX ; # else size = 0x10000L ; # endif # else size = 0x7ff0L - linerest ; # endif for ( ; size >= 10 ; size = ( long ) ( ( long_u ) size >> 1 ) ) { if ( ( new_buffer = lalloc ( ( long_u ) ( size + linerest + 1 ) , FALSE ) ) != NULL ) break ; } if ( new_buffer == NULL ) { do_outofmem_msg ( ( long_u ) ( size * 2 + linerest + 1 ) ) ; error = TRUE ; break ; } if ( linerest ) mch_memmove ( new_buffer , ptr - linerest , ( size_t ) linerest ) ; vim_free ( buffer ) ; buffer = new_buffer ; ptr = buffer + linerest ; line_start = buffer ; # ifdef FEAT_MBYTE real_size = ( int ) size ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) size = size / ICONV_MULT ; else # endif if ( fio_flags & FIO_LATIN1 ) size = size / 2 ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) size = ( size * 2 / 3 ) & ~ 1 ; else if ( fio_flags & FIO_UCS4 ) size = ( size * 2 / 3 ) & ~ 3 ; else if ( fio_flags == FIO_UCSBOM ) size = size / ICONV_MULT ; # ifdef WIN3264 else if ( fio_flags & FIO_CODEPAGE ) size = size / ICONV_MULT ; # endif # ifdef MACOS_CONVERT else if ( fio_flags & FIO_MACROMAN ) size = size / ICONV_MULT ; # endif # endif # ifdef FEAT_MBYTE if ( conv_restlen > 0 ) { mch_memmove ( ptr , conv_rest , conv_restlen ) ; ptr += conv_restlen ; size -= conv_restlen ; } # endif if ( read_buffer ) { if ( read_buf_lnum > from ) size = 0 ; else { int n , ni ; long tlen ; tlen = 0 ; for ( ; ; ) { p = ml_get ( read_buf_lnum ) + read_buf_col ; n = ( int ) STRLEN ( p ) ; if ( ( int ) tlen + n + 1 > size ) { n = ( int ) ( size - tlen ) ; for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } read_buf_col += n ; break ; } else { for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } ptr [ tlen ++ ] = NL ; read_buf_col = 0 ; if ( ++ read_buf_lnum > from ) { if ( ! curbuf -> b_p_eol ) -- tlen ; size = tlen ; break ; } } } } } else { size = read_eintr ( fd , ptr , size ) ; } # ifdef FEAT_CRYPT if ( filesize == 0 && size > 0 ) cryptkey = check_for_cryptkey ( cryptkey , ptr , & size , & filesize , newfile , sfname , & did_ask_for_key ) ; if ( cryptkey != NULL && curbuf -> b_cryptstate != NULL && size > 0 ) { if ( crypt_works_inplace ( curbuf -> b_cryptstate ) ) { crypt_decode_inplace ( curbuf -> b_cryptstate , ptr , size ) ; } else { char_u * newptr = NULL ; int decrypted_size ; decrypted_size = crypt_decode_alloc ( curbuf -> b_cryptstate , ptr , size , & newptr ) ; if ( size > 0 && decrypted_size == 0 ) continue ; if ( linerest == 0 ) { new_buffer = newptr ; } else { long_u new_size ; new_size = ( long_u ) ( decrypted_size + linerest + 1 ) ; new_buffer = lalloc ( new_size , FALSE ) ; if ( new_buffer == NULL ) { do_outofmem_msg ( new_size ) ; error = TRUE ; break ; } mch_memmove ( new_buffer , buffer , linerest ) ; if ( newptr != NULL ) mch_memmove ( new_buffer + linerest , newptr , decrypted_size ) ; } if ( new_buffer != NULL ) { vim_free ( buffer ) ; buffer = new_buffer ; new_buffer = NULL ; line_start = buffer ; ptr = buffer + linerest ; } size = decrypted_size ; } } # endif if ( size <= 0 ) { if ( size < 0 ) error = TRUE ; # ifdef FEAT_MBYTE else if ( conv_restlen > 0 ) { if ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = curbuf -> b_ml . ml_line_count - linecnt + 1 ; } else if ( illegal_byte == 0 ) illegal_byte = curbuf -> b_ml . ml_line_count - linecnt + 1 ; if ( bad_char_behavior == BAD_DROP ) { * ( ptr - conv_restlen ) = NUL ; conv_restlen = 0 ; } else { if ( bad_char_behavior != BAD_KEEP && ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) ) { while ( conv_restlen > 0 ) { * ( -- ptr ) = bad_char_behavior ; -- conv_restlen ; } } fio_flags = 0 ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif } } # endif } } skip_read = FALSE ; # ifdef FEAT_MBYTE if ( ( filesize == 0 # ifdef FEAT_CRYPT || ( cryptkey != NULL && filesize == crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) # endif ) && ( fio_flags == FIO_UCSBOM || ( ! curbuf -> b_p_bomb && tmpname == NULL && ( * fenc == 'u' || ( * fenc == NUL && enc_utf8 ) ) ) ) ) { char_u * ccname ; int blen ; if ( size < 2 || curbuf -> b_p_bin ) ccname = NULL ; else ccname = check_for_bom ( ptr , size , & blen , fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags ( fenc ) ) ; if ( ccname != NULL ) { filesize += blen ; size -= blen ; mch_memmove ( ptr , ptr + blen , ( size_t ) size ) ; if ( set_options ) { curbuf -> b_p_bomb = TRUE ; curbuf -> b_start_bomb = TRUE ; } } if ( fio_flags == FIO_UCSBOM ) { if ( ccname == NULL ) { advance_fenc = TRUE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ccname ; fenc_alloced = FALSE ; } skip_read = TRUE ; goto retry ; } } ptr -= conv_restlen ; size += conv_restlen ; conv_restlen = 0 ; # endif if ( size <= 0 ) break ; # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { const char * fromp ; char * top ; size_t from_size ; size_t to_size ; fromp = ( char * ) ptr ; from_size = size ; ptr += size ; top = ( char * ) ptr ; to_size = real_size - size ; while ( ( iconv ( iconv_fd , ( void * ) & fromp , & from_size , & top , & to_size ) == ( size_t ) - 1 && ICONV_ERRNO != ICONV_EINVAL ) || from_size > CONV_RESTLEN ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , ( char_u * ) top ) ; ++ fromp ; -- from_size ; if ( bad_char_behavior == BAD_KEEP ) { * top ++ = * ( fromp - 1 ) ; -- to_size ; } else if ( bad_char_behavior != BAD_DROP ) { * top ++ = bad_char_behavior ; -- to_size ; } } if ( from_size > 0 ) { mch_memmove ( conv_rest , ( char_u * ) fromp , from_size ) ; conv_restlen = ( int ) from_size ; } line_start = ptr - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( char_u * ) top - ptr ) ; } # endif # ifdef WIN3264 if ( fio_flags & FIO_CODEPAGE ) { char_u * src , * dst ; WCHAR ucs2buf [ 3 ] ; int ucs2len ; int codepage = FIO_GET_CP ( fio_flags ) ; int bytelen ; int found_bad ; char replstr [ 2 ] ; if ( bad_char_behavior > 0 ) replstr [ 0 ] = bad_char_behavior ; else replstr [ 0 ] = '?' ; replstr [ 1 ] = NUL ; src = ptr + real_size - size ; mch_memmove ( src , ptr , size ) ; dst = ptr ; size = size ; while ( size > 0 ) { found_bad = FALSE ; # ifdef CP_UTF8 if ( codepage == CP_UTF8 ) { bytelen = ( int ) utf_ptr2len_len ( src , size ) ; if ( bytelen > size ) { if ( bytelen <= CONV_RESTLEN ) break ; bytelen = size ; found_bad = TRUE ; } else { int u8c = utf_ptr2char ( src ) ; if ( u8c > 0xffff || ( * src >= 0x80 && bytelen == 1 ) ) found_bad = TRUE ; ucs2buf [ 0 ] = u8c ; ucs2len = 1 ; } } else # endif { for ( bytelen = 1 ; bytelen <= size && bytelen <= 3 ; ++ bytelen ) { ucs2len = MultiByteToWideChar ( codepage , MB_ERR_INVALID_CHARS , ( LPCSTR ) src , bytelen , ucs2buf , 3 ) ; if ( ucs2len > 0 ) break ; } if ( ucs2len == 0 ) { if ( size == 1 ) break ; found_bad = TRUE ; bytelen = 1 ; } } if ( ! found_bad ) { int i ; if ( enc_utf8 ) { for ( i = 0 ; i < ucs2len ; ++ i ) dst += utf_char2bytes ( ucs2buf [ i ] , dst ) ; } else { BOOL bad = FALSE ; int dstlen ; dstlen = WideCharToMultiByte ( enc_codepage , 0 , ( LPCWSTR ) ucs2buf , ucs2len , ( LPSTR ) dst , ( int ) ( src - dst ) , replstr , & bad ) ; if ( bad ) found_bad = TRUE ; else dst += dstlen ; } } if ( found_bad ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , dst ) ; if ( bad_char_behavior != BAD_DROP ) { if ( bad_char_behavior == BAD_KEEP ) { mch_memmove ( dst , src , bytelen ) ; dst += bytelen ; } else * dst ++ = bad_char_behavior ; } } src += bytelen ; size -= bytelen ; } if ( size > 0 ) { mch_memmove ( conv_rest , src , size ) ; conv_restlen = size ; } size = ( long ) ( dst - ptr ) ; } else # endif # ifdef MACOS_CONVERT if ( fio_flags & FIO_MACROMAN ) { if ( macroman2enc ( ptr , & size , real_size ) == FAIL ) goto rewind_retry ; } else # endif if ( fio_flags != 0 ) { int u8c ; char_u * dest ; char_u * tail = NULL ; dest = ptr + real_size ; if ( fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8 ) { p = ptr + size ; if ( fio_flags == FIO_UTF8 ) { tail = ptr + size - 1 ; while ( tail > ptr && ( * tail & 0xc0 ) == 0x80 ) -- tail ; if ( tail + utf_byte2len ( * tail ) <= ptr + size ) tail = NULL ; else p = tail ; } } else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { p = ptr + ( size & ~ 1 ) ; if ( size & 1 ) tail = p ; if ( ( fio_flags & FIO_UTF16 ) && p > ptr ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( u8c >= 0xd800 && u8c <= 0xdbff ) tail = p ; else p += 2 ; } } else { p = ptr + ( size & ~ 3 ) ; if ( size & 3 ) tail = p ; } if ( tail != NULL ) { conv_restlen = ( int ) ( ( ptr + size ) - tail ) ; mch_memmove ( conv_rest , ( char_u * ) tail , conv_restlen ) ; size -= conv_restlen ; } while ( p > ptr ) { if ( fio_flags & FIO_LATIN1 ) u8c = * -- p ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( ( fio_flags & FIO_UTF16 ) && u8c >= 0xdc00 && u8c <= 0xdfff ) { int u16c ; if ( p == ptr ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } if ( fio_flags & FIO_ENDIAN_L ) { u16c = ( * -- p << 8 ) ; u16c += * -- p ; } else { u16c = * -- p ; u16c += ( * -- p << 8 ) ; } u8c = 0x10000 + ( ( u16c & 0x3ff ) << 10 ) + ( u8c & 0x3ff ) ; if ( u16c < 0xd800 || u16c > 0xdbff ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } else if ( fio_flags & FIO_UCS4 ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( unsigned ) * -- p << 24 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 8 ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( unsigned ) * -- p << 8 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 24 ; } } else { if ( * -- p < 0x80 ) u8c = * p ; else { len = utf_head_off ( ptr , p ) ; p -= len ; u8c = utf_ptr2char ( p ) ; if ( len == 0 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } if ( enc_utf8 ) { dest -= utf_char2len ( u8c ) ; ( void ) utf_char2bytes ( u8c , dest ) ; } else { -- dest ; if ( u8c >= 0x100 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) ++ dest ; else if ( bad_char_behavior == BAD_KEEP ) * dest = u8c ; else if ( eap != NULL && eap -> bad_char != 0 ) * dest = bad_char_behavior ; else * dest = 0xBF ; } else * dest = u8c ; } } line_start = dest - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( ptr + real_size ) - dest ) ; ptr = dest ; } else if ( enc_utf8 && ! curbuf -> b_p_bin ) { int incomplete_tail = FALSE ; for ( p = ptr ; ; ++ p ) { int todo = ( int ) ( ( ptr + size ) - p ) ; int l ; if ( todo <= 0 ) break ; if ( * p >= 0x80 ) { l = utf_ptr2len_len ( p , todo ) ; if ( l > todo && ! incomplete_tail ) { if ( p > ptr || filesize > 0 ) incomplete_tail = TRUE ; if ( p > ptr ) { conv_restlen = todo ; mch_memmove ( conv_rest , p , conv_restlen ) ; size -= conv_restlen ; break ; } } if ( l == 1 || l > todo ) { if ( can_retry && ! incomplete_tail ) break ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 && conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; # endif if ( conv_error == 0 && illegal_byte == 0 ) illegal_byte = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) { mch_memmove ( p , p + 1 , todo - 1 ) ; -- p ; -- size ; } else if ( bad_char_behavior != BAD_KEEP ) * p = bad_char_behavior ; } else p += l - 1 ; } } if ( p < ptr + size && ! incomplete_tail ) { rewind_retry : # if defined ( FEAT_EVAL ) && defined ( USE_ICONV ) if ( * p_ccv != NUL && iconv_fd != ( iconv_t ) - 1 ) did_iconv = TRUE ; else # endif advance_fenc = TRUE ; file_rewind = TRUE ; goto retry ; } } # endif filesize += size ; if ( fileformat == EOL_UNKNOWN ) { if ( try_dos || try_unix ) { if ( try_mac ) try_mac = 1 ; for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) { if ( ! try_unix || ( try_dos && p > ptr && p [ - 1 ] == CAR ) ) fileformat = EOL_DOS ; else fileformat = EOL_UNIX ; break ; } else if ( * p == CAR && try_mac ) try_mac ++ ; } if ( fileformat == EOL_UNIX && try_mac ) { try_mac = 1 ; try_unix = 1 ; for ( ; p >= ptr && * p != CAR ; p -- ) ; if ( p >= ptr ) { for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) try_unix ++ ; else if ( * p == CAR ) try_mac ++ ; } if ( try_mac > try_unix ) fileformat = EOL_MAC ; } } else if ( fileformat == EOL_UNKNOWN && try_mac == 1 ) fileformat = default_fileformat ( ) ; } if ( fileformat == EOL_UNKNOWN && try_mac ) fileformat = EOL_MAC ; if ( fileformat == EOL_UNKNOWN ) fileformat = default_fileformat ( ) ; if ( set_options ) set_fileformat ( fileformat , OPT_LOCAL ) ; } } if ( fileformat == EOL_MAC ) { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != CAR && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else if ( c == NL ) * ptr = CAR ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } else { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( fileformat == EOL_DOS ) { if ( ptr > line_start && ptr [ - 1 ] == CAR ) { ptr [ - 1 ] = NUL ; -- len ; } else if ( ff_error != EOL_DOS ) { if ( try_unix && ! read_stdin && ( read_buffer || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) == 0 ) ) { fileformat = EOL_UNIX ; if ( set_options ) set_fileformat ( EOL_UNIX , OPT_LOCAL ) ; file_rewind = TRUE ; keep_fileformat = TRUE ; goto retry ; } ff_error = EOL_DOS ; } } if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } linerest = ( long ) ( ptr - line_start ) ; ui_breakcheck ( ) ; } failed : if ( error && read_count == 0 ) error = FALSE ; if ( ! error && ! got_int && linerest != 0 && ! ( ! curbuf -> b_p_bin && fileformat == EOL_DOS && * line_start == Ctrl_Z && ptr == line_start + 1 ) ) { if ( set_options ) curbuf -> b_p_eol = FALSE ; * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) error = TRUE ; else { # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif read_no_eol_lnum = ++ lnum ; } } if ( set_options ) save_file_ff ( curbuf ) ; # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } if ( cryptkey != NULL && cryptkey != curbuf -> b_p_key ) crypt_free_key ( cryptkey ) ; # endif # ifdef FEAT_MBYTE if ( set_options ) set_string_option_direct ( ( char_u * ) \"fenc\" , - 1 , fenc , OPT_FREE | OPT_LOCAL , 0 ) ; if ( fenc_alloced ) vim_free ( fenc ) ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif # endif if ( ! read_buffer && ! read_stdin ) close ( fd ) ; # ifdef HAVE_FD_CLOEXEC else { int fdflags = fcntl ( fd , F_GETFD ) ; if ( fdflags >= 0 && ( fdflags & FD_CLOEXEC ) == 0 ) ( void ) fcntl ( fd , F_SETFD , fdflags | FD_CLOEXEC ) ; } # endif vim_free ( buffer ) ; # ifdef HAVE_DUP if ( read_stdin ) { close ( 0 ) ; ignored = dup ( 2 ) ; } # endif # ifdef FEAT_MBYTE if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; } # endif -- no_wait_return ; if ( ! recoverymode ) { if ( newfile && wasempty && ! ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ) { # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 0 ; # endif ml_delete ( curbuf -> b_ml . ml_line_count , FALSE ) ; # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 1 ; # endif -- linecnt ; } linecnt = curbuf -> b_ml . ml_line_count - linecnt ; if ( filesize == 0 ) linecnt = 0 ; if ( newfile || read_buffer ) { redraw_curbuf_later ( NOT_VALID ) ; # ifdef FEAT_DIFF diff_invalidate ( curbuf ) ; # endif # ifdef FEAT_FOLDING foldUpdateAll ( curwin ) ; # endif } else if ( linecnt ) appended_lines_mark ( from , linecnt ) ; # ifndef ALWAYS_USE_GUI if ( read_stdin ) { settmode ( TMODE_RAW ) ; starttermcap ( ) ; screenclear ( ) ; } # endif if ( got_int ) { if ( ! ( flags & READ_DUMMY ) ) { filemess ( curbuf , sfname , ( char_u * ) _ ( e_interr ) , 0 ) ; if ( newfile ) curbuf -> b_p_ro = TRUE ; } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif return OK ; } if ( ! filtering && ! ( flags & READ_DUMMY ) ) { msg_add_fname ( curbuf , sfname ) ; c = FALSE ; # ifdef UNIX # ifdef S_ISFIFO if ( S_ISFIFO ( perm ) ) { STRCAT ( IObuff , _ ( \"[fifo/socket]\" ) ) ; c = TRUE ; } # else # ifdef S_IFIFO if ( ( perm & S_IFMT ) == S_IFIFO ) { STRCAT ( IObuff , _ ( \"[fifo]\" ) ) ; c = TRUE ; } # endif # ifdef S_IFSOCK if ( ( perm & S_IFMT ) == S_IFSOCK ) { STRCAT ( IObuff , _ ( \"[socket]\" ) ) ; c = TRUE ; } # endif # endif # ifdef OPEN_CHR_FILES if ( S_ISCHR ( perm ) ) { STRCAT ( IObuff , _ ( \"[character<S2SV_blank>special]\" ) ) ; c = TRUE ; } # endif # endif if ( curbuf -> b_p_ro ) { STRCAT ( IObuff , shortmess ( SHM_RO ) ? _ ( \"[RO]\" ) : _ ( \"[readonly]\" ) ) ; c = TRUE ; } if ( read_no_eol_lnum ) { msg_add_eol ( ) ; c = TRUE ; } if ( ff_error == EOL_DOS ) { STRCAT ( IObuff , _ ( \"[CR<S2SV_blank>missing]\" ) ) ; c = TRUE ; } if ( split ) { STRCAT ( IObuff , _ ( \"[long<S2SV_blank>lines<S2SV_blank>split]\" ) ) ; c = TRUE ; } # ifdef FEAT_MBYTE if ( notconverted ) { STRCAT ( IObuff , _ ( \"[NOT<S2SV_blank>converted]\" ) ) ; c = TRUE ; } else if ( converted ) { STRCAT ( IObuff , _ ( \"[converted]\" ) ) ; c = TRUE ; } # endif # ifdef FEAT_CRYPT if ( cryptkey != NULL ) { crypt_append_msg ( curbuf ) ; c = TRUE ; } # endif # ifdef FEAT_MBYTE if ( conv_error != 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( \"[CONVERSION<S2SV_blank>ERROR<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]\" ) , ( long ) conv_error ) ; c = TRUE ; } else if ( illegal_byte > 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( \"[ILLEGAL<S2SV_blank>BYTE<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]\" ) , ( long ) illegal_byte ) ; c = TRUE ; } else # endif if ( error ) { STRCAT ( IObuff , _ ( \"[READ<S2SV_blank>ERRORS]\" ) ) ; c = TRUE ; } if ( msg_add_fileformat ( fileformat ) ) c = TRUE ; # ifdef FEAT_CRYPT if ( cryptkey != NULL ) msg_add_lines ( c , ( long ) linecnt , filesize - crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) ; else # endif msg_add_lines ( c , ( long ) linecnt , filesize ) ; vim_free ( keep_msg ) ; keep_msg = NULL ; msg_scrolled_ign = TRUE ; # ifdef ALWAYS_USE_GUI if ( read_stdin || read_buffer ) p = msg_may_trunc ( FALSE , IObuff ) ; else # endif p = msg_trunc_attr ( IObuff , FALSE , 0 ) ; if ( read_stdin || read_buffer || restart_edit != 0 || ( msg_scrolled != 0 && ! need_wait_return ) ) set_keep_msg ( p , 0 ) ; msg_scrolled_ign = FALSE ; } if ( newfile && ( error # ifdef FEAT_MBYTE || conv_error != 0 || ( illegal_byte > 0 && bad_char_behavior != BAD_KEEP ) # endif ) ) curbuf -> b_p_ro = TRUE ; u_clearline ( ) ; if ( exmode_active ) curwin -> w_cursor . lnum = from + linecnt ; else curwin -> w_cursor . lnum = from + 1 ; check_cursor_lnum ( ) ; beginline ( BL_WHITE | BL_FIX ) ; curbuf -> b_op_start . lnum = from + 1 ; curbuf -> b_op_start . col = 0 ; curbuf -> b_op_end . lnum = from + linecnt ; curbuf -> b_op_end . col = 0 ; # ifdef WIN32 if ( newfile && ! read_stdin && ! read_buffer && mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; } # endif } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif curbuf -> b_no_eol_lnum = read_no_eol_lnum ; if ( flags & READ_KEEP_UNDO ) u_find_first_changed ( ) ; # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) { char_u hash [ UNDO_HASH_SIZE ] ; sha256_finish ( & sha_ctx , hash ) ; u_read_undo ( NULL , hash , fname ) ; } # endif # ifdef FEAT_AUTOCMD if ( ! read_stdin && ! read_fifo && ( ! read_buffer || sfname != NULL ) ) { int m = msg_scroll ; int n = msg_scrolled ; if ( set_options ) save_file_ff ( curbuf ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile || ( read_buffer && sfname != NULL ) ) { apply_autocmds_exarg ( EVENT_BUFREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; if ( ! au_did_filetype && * curbuf -> b_p_ft != NUL ) apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } else apply_autocmds_exarg ( EVENT_FILEREADPOST , sfname , sfname , FALSE , NULL , eap ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) return FAIL ; # endif } # endif if ( recoverymode && error ) return FAIL ; return OK ; }", "target": "<S2SV_ModStart> != NULL ) { char_u * swap_fname = <S2SV_ModEnd> curbuf -> b_ml <S2SV_ModStart> ml_mfp -> mf_fname ; if ( ( swap_mode & 044 ) == 040 ) { stat_T swap_st ; if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ; } ( void ) mch_setperm ( swap_fname <S2SV_ModStart> swap_mode ) ; }"}
{"source": "CWE-77 static int do_jit ( struct bpf_prog * bpf_prog , int * addrs , u8 * image , int oldproglen , struct jit_context * ctx , bool jmp_padding ) { bool tail_call_reachable = bpf_prog -> aux -> tail_call_reachable ; struct bpf_insn * insn = bpf_prog -> insnsi ; bool callee_regs_used [ 4 ] = { } ; int insn_cnt = bpf_prog -> len ; bool tail_call_seen = false ; bool seen_exit = false ; u8 temp [ BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY ] ; int i , cnt = 0 , excnt = 0 ; int ilen , proglen = 0 ; u8 * prog = temp ; int err ; detect_reg_usage ( insn , insn_cnt , callee_regs_used , & tail_call_seen ) ; tail_call_reachable |= tail_call_seen ; emit_prologue ( & prog , bpf_prog -> aux -> stack_depth , bpf_prog_was_classic ( bpf_prog ) , tail_call_reachable , bpf_prog -> aux -> func_idx != 0 ) ; push_callee_regs ( & prog , callee_regs_used ) ; ilen = prog - temp ; if ( image ) memcpy ( image + proglen , temp , ilen ) ; proglen += ilen ; addrs [ 0 ] = proglen ; prog = temp ; for ( i = 1 ; i <= insn_cnt ; i ++ , insn ++ ) { const s32 imm32 = insn -> imm ; u32 dst_reg = insn -> dst_reg ; u32 src_reg = insn -> src_reg ; u8 b2 = 0 , b3 = 0 ; u8 * start_of_ldx ; s64 jmp_offset ; u8 jmp_cond ; u8 * func ; int nops ; switch ( insn -> code ) { case BPF_ALU | BPF_ADD | BPF_X : case BPF_ALU | BPF_SUB | BPF_X : case BPF_ALU | BPF_AND | BPF_X : case BPF_ALU | BPF_OR | BPF_X : case BPF_ALU | BPF_XOR | BPF_X : case BPF_ALU64 | BPF_ADD | BPF_X : case BPF_ALU64 | BPF_SUB | BPF_X : case BPF_ALU64 | BPF_AND | BPF_X : case BPF_ALU64 | BPF_OR | BPF_X : case BPF_ALU64 | BPF_XOR | BPF_X : maybe_emit_mod ( & prog , dst_reg , src_reg , BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ; b2 = simple_alu_opcodes [ BPF_OP ( insn -> code ) ] ; EMIT2 ( b2 , add_2reg ( 0xC0 , dst_reg , src_reg ) ) ; break ; case BPF_ALU64 | BPF_MOV | BPF_X : case BPF_ALU | BPF_MOV | BPF_X : emit_mov_reg ( & prog , BPF_CLASS ( insn -> code ) == BPF_ALU64 , dst_reg , src_reg ) ; break ; case BPF_ALU | BPF_NEG : case BPF_ALU64 | BPF_NEG : if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) EMIT1 ( add_1mod ( 0x48 , dst_reg ) ) ; else if ( is_ereg ( dst_reg ) ) EMIT1 ( add_1mod ( 0x40 , dst_reg ) ) ; EMIT2 ( 0xF7 , add_1reg ( 0xD8 , dst_reg ) ) ; break ; case BPF_ALU | BPF_ADD | BPF_K : case BPF_ALU | BPF_SUB | BPF_K : case BPF_ALU | BPF_AND | BPF_K : case BPF_ALU | BPF_OR | BPF_K : case BPF_ALU | BPF_XOR | BPF_K : case BPF_ALU64 | BPF_ADD | BPF_K : case BPF_ALU64 | BPF_SUB | BPF_K : case BPF_ALU64 | BPF_AND | BPF_K : case BPF_ALU64 | BPF_OR | BPF_K : case BPF_ALU64 | BPF_XOR | BPF_K : if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) EMIT1 ( add_1mod ( 0x48 , dst_reg ) ) ; else if ( is_ereg ( dst_reg ) ) EMIT1 ( add_1mod ( 0x40 , dst_reg ) ) ; switch ( BPF_OP ( insn -> code ) ) { case BPF_ADD : b3 = 0xC0 ; b2 = 0x05 ; break ; case BPF_SUB : b3 = 0xE8 ; b2 = 0x2D ; break ; case BPF_AND : b3 = 0xE0 ; b2 = 0x25 ; break ; case BPF_OR : b3 = 0xC8 ; b2 = 0x0D ; break ; case BPF_XOR : b3 = 0xF0 ; b2 = 0x35 ; break ; } if ( is_imm8 ( imm32 ) ) EMIT3 ( 0x83 , add_1reg ( b3 , dst_reg ) , imm32 ) ; else if ( is_axreg ( dst_reg ) ) EMIT1_off32 ( b2 , imm32 ) ; else EMIT2_off32 ( 0x81 , add_1reg ( b3 , dst_reg ) , imm32 ) ; break ; case BPF_ALU64 | BPF_MOV | BPF_K : case BPF_ALU | BPF_MOV | BPF_K : emit_mov_imm32 ( & prog , BPF_CLASS ( insn -> code ) == BPF_ALU64 , dst_reg , imm32 ) ; break ; case BPF_LD | BPF_IMM | BPF_DW : emit_mov_imm64 ( & prog , dst_reg , insn [ 1 ] . imm , insn [ 0 ] . imm ) ; insn ++ ; i ++ ; break ; case BPF_ALU | BPF_MOD | BPF_X : case BPF_ALU | BPF_DIV | BPF_X : case BPF_ALU | BPF_MOD | BPF_K : case BPF_ALU | BPF_DIV | BPF_K : case BPF_ALU64 | BPF_MOD | BPF_X : case BPF_ALU64 | BPF_DIV | BPF_X : case BPF_ALU64 | BPF_MOD | BPF_K : case BPF_ALU64 | BPF_DIV | BPF_K : EMIT1 ( 0x50 ) ; EMIT1 ( 0x52 ) ; if ( BPF_SRC ( insn -> code ) == BPF_X ) EMIT_mov ( AUX_REG , src_reg ) ; else EMIT3_off32 ( 0x49 , 0xC7 , 0xC3 , imm32 ) ; EMIT_mov ( BPF_REG_0 , dst_reg ) ; EMIT2 ( 0x31 , 0xd2 ) ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) EMIT3 ( 0x49 , 0xF7 , 0xF3 ) ; else EMIT3 ( 0x41 , 0xF7 , 0xF3 ) ; if ( BPF_OP ( insn -> code ) == BPF_MOD ) EMIT3 ( 0x49 , 0x89 , 0xD3 ) ; else EMIT3 ( 0x49 , 0x89 , 0xC3 ) ; EMIT1 ( 0x5A ) ; EMIT1 ( 0x58 ) ; EMIT_mov ( dst_reg , AUX_REG ) ; break ; case BPF_ALU | BPF_MUL | BPF_K : case BPF_ALU | BPF_MUL | BPF_X : case BPF_ALU64 | BPF_MUL | BPF_K : case BPF_ALU64 | BPF_MUL | BPF_X : { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; if ( dst_reg != BPF_REG_0 ) EMIT1 ( 0x50 ) ; if ( dst_reg != BPF_REG_3 ) EMIT1 ( 0x52 ) ; EMIT_mov ( AUX_REG , dst_reg ) ; if ( BPF_SRC ( insn -> code ) == BPF_X ) emit_mov_reg ( & prog , is64 , BPF_REG_0 , src_reg ) ; else emit_mov_imm32 ( & prog , is64 , BPF_REG_0 , imm32 ) ; if ( is64 ) EMIT1 ( add_1mod ( 0x48 , AUX_REG ) ) ; else if ( is_ereg ( AUX_REG ) ) EMIT1 ( add_1mod ( 0x40 , AUX_REG ) ) ; EMIT2 ( 0xF7 , add_1reg ( 0xE0 , AUX_REG ) ) ; if ( dst_reg != BPF_REG_3 ) EMIT1 ( 0x5A ) ; if ( dst_reg != BPF_REG_0 ) { EMIT_mov ( dst_reg , BPF_REG_0 ) ; EMIT1 ( 0x58 ) ; } break ; } case BPF_ALU | BPF_LSH | BPF_K : case BPF_ALU | BPF_RSH | BPF_K : case BPF_ALU | BPF_ARSH | BPF_K : case BPF_ALU64 | BPF_LSH | BPF_K : case BPF_ALU64 | BPF_RSH | BPF_K : case BPF_ALU64 | BPF_ARSH | BPF_K : if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) EMIT1 ( add_1mod ( 0x48 , dst_reg ) ) ; else if ( is_ereg ( dst_reg ) ) EMIT1 ( add_1mod ( 0x40 , dst_reg ) ) ; b3 = simple_alu_opcodes [ BPF_OP ( insn -> code ) ] ; if ( imm32 == 1 ) EMIT2 ( 0xD1 , add_1reg ( b3 , dst_reg ) ) ; else EMIT3 ( 0xC1 , add_1reg ( b3 , dst_reg ) , imm32 ) ; break ; case BPF_ALU | BPF_LSH | BPF_X : case BPF_ALU | BPF_RSH | BPF_X : case BPF_ALU | BPF_ARSH | BPF_X : case BPF_ALU64 | BPF_LSH | BPF_X : case BPF_ALU64 | BPF_RSH | BPF_X : case BPF_ALU64 | BPF_ARSH | BPF_X : if ( dst_reg == BPF_REG_4 ) { EMIT_mov ( AUX_REG , dst_reg ) ; dst_reg = AUX_REG ; } if ( src_reg != BPF_REG_4 ) { EMIT1 ( 0x51 ) ; EMIT_mov ( BPF_REG_4 , src_reg ) ; } if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) EMIT1 ( add_1mod ( 0x48 , dst_reg ) ) ; else if ( is_ereg ( dst_reg ) ) EMIT1 ( add_1mod ( 0x40 , dst_reg ) ) ; b3 = simple_alu_opcodes [ BPF_OP ( insn -> code ) ] ; EMIT2 ( 0xD3 , add_1reg ( b3 , dst_reg ) ) ; if ( src_reg != BPF_REG_4 ) EMIT1 ( 0x59 ) ; if ( insn -> dst_reg == BPF_REG_4 ) EMIT_mov ( insn -> dst_reg , AUX_REG ) ; break ; case BPF_ALU | BPF_END | BPF_FROM_BE : switch ( imm32 ) { case 16 : EMIT1 ( 0x66 ) ; if ( is_ereg ( dst_reg ) ) EMIT1 ( 0x41 ) ; EMIT3 ( 0xC1 , add_1reg ( 0xC8 , dst_reg ) , 8 ) ; if ( is_ereg ( dst_reg ) ) EMIT3 ( 0x45 , 0x0F , 0xB7 ) ; else EMIT2 ( 0x0F , 0xB7 ) ; EMIT1 ( add_2reg ( 0xC0 , dst_reg , dst_reg ) ) ; break ; case 32 : if ( is_ereg ( dst_reg ) ) EMIT2 ( 0x41 , 0x0F ) ; else EMIT1 ( 0x0F ) ; EMIT1 ( add_1reg ( 0xC8 , dst_reg ) ) ; break ; case 64 : EMIT3 ( add_1mod ( 0x48 , dst_reg ) , 0x0F , add_1reg ( 0xC8 , dst_reg ) ) ; break ; } break ; case BPF_ALU | BPF_END | BPF_FROM_LE : switch ( imm32 ) { case 16 : if ( is_ereg ( dst_reg ) ) EMIT3 ( 0x45 , 0x0F , 0xB7 ) ; else EMIT2 ( 0x0F , 0xB7 ) ; EMIT1 ( add_2reg ( 0xC0 , dst_reg , dst_reg ) ) ; break ; case 32 : if ( is_ereg ( dst_reg ) ) EMIT1 ( 0x45 ) ; EMIT2 ( 0x89 , add_2reg ( 0xC0 , dst_reg , dst_reg ) ) ; break ; case 64 : break ; } break ; case BPF_ST | BPF_MEM | BPF_B : if ( is_ereg ( dst_reg ) ) EMIT2 ( 0x41 , 0xC6 ) ; else EMIT1 ( 0xC6 ) ; goto st ; case BPF_ST | BPF_MEM | BPF_H : if ( is_ereg ( dst_reg ) ) EMIT3 ( 0x66 , 0x41 , 0xC7 ) ; else EMIT2 ( 0x66 , 0xC7 ) ; goto st ; case BPF_ST | BPF_MEM | BPF_W : if ( is_ereg ( dst_reg ) ) EMIT2 ( 0x41 , 0xC7 ) ; else EMIT1 ( 0xC7 ) ; goto st ; case BPF_ST | BPF_MEM | BPF_DW : EMIT2 ( add_1mod ( 0x48 , dst_reg ) , 0xC7 ) ; st : if ( is_imm8 ( insn -> off ) ) EMIT2 ( add_1reg ( 0x40 , dst_reg ) , insn -> off ) ; else EMIT1_off32 ( add_1reg ( 0x80 , dst_reg ) , insn -> off ) ; EMIT ( imm32 , bpf_size_to_x86_bytes ( BPF_SIZE ( insn -> code ) ) ) ; break ; case BPF_STX | BPF_MEM | BPF_B : case BPF_STX | BPF_MEM | BPF_H : case BPF_STX | BPF_MEM | BPF_W : case BPF_STX | BPF_MEM | BPF_DW : emit_stx ( & prog , BPF_SIZE ( insn -> code ) , dst_reg , src_reg , insn -> off ) ; break ; case BPF_LDX | BPF_MEM | BPF_B : case BPF_LDX | BPF_PROBE_MEM | BPF_B : case BPF_LDX | BPF_MEM | BPF_H : case BPF_LDX | BPF_PROBE_MEM | BPF_H : case BPF_LDX | BPF_MEM | BPF_W : case BPF_LDX | BPF_PROBE_MEM | BPF_W : case BPF_LDX | BPF_MEM | BPF_DW : case BPF_LDX | BPF_PROBE_MEM | BPF_DW : if ( BPF_MODE ( insn -> code ) == BPF_PROBE_MEM ) { maybe_emit_mod ( & prog , src_reg , src_reg , true ) ; EMIT2 ( 0x85 , add_2reg ( 0xC0 , src_reg , src_reg ) ) ; EMIT2 ( X86_JNE , 0 ) ; emit_mov_imm32 ( & prog , false , dst_reg , 0 ) ; EMIT2 ( 0xEB , 0 ) ; temp [ 4 ] = prog - temp - 5 ; start_of_ldx = prog ; } emit_ldx ( & prog , BPF_SIZE ( insn -> code ) , dst_reg , src_reg , insn -> off ) ; if ( BPF_MODE ( insn -> code ) == BPF_PROBE_MEM ) { struct exception_table_entry * ex ; u8 * _insn = image + proglen ; s64 delta ; start_of_ldx [ - 1 ] = prog - start_of_ldx ; if ( ! bpf_prog -> aux -> extable ) break ; if ( excnt >= bpf_prog -> aux -> num_exentries ) { pr_err ( \"ex<S2SV_blank>gen<S2SV_blank>bug\\\\n\" ) ; return - EFAULT ; } ex = & bpf_prog -> aux -> extable [ excnt ++ ] ; delta = _insn - ( u8 * ) & ex -> insn ; if ( ! is_simm32 ( delta ) ) { pr_err ( \"extable->insn<S2SV_blank>doesn\\'t<S2SV_blank>fit<S2SV_blank>into<S2SV_blank>32-bit\\\\n\" ) ; return - EFAULT ; } ex -> insn = delta ; delta = ( u8 * ) ex_handler_bpf - ( u8 * ) & ex -> handler ; if ( ! is_simm32 ( delta ) ) { pr_err ( \"extable->handler<S2SV_blank>doesn\\'t<S2SV_blank>fit<S2SV_blank>into<S2SV_blank>32-bit\\\\n\" ) ; return - EFAULT ; } ex -> handler = delta ; if ( dst_reg > BPF_REG_9 ) { pr_err ( \"verifier<S2SV_blank>error\\\\n\" ) ; return - EFAULT ; } ex -> fixup = ( prog - temp ) | ( reg2pt_regs [ dst_reg ] << 8 ) ; } break ; case BPF_STX | BPF_ATOMIC | BPF_W : case BPF_STX | BPF_ATOMIC | BPF_DW : if ( insn -> imm == ( BPF_AND | BPF_FETCH ) || insn -> imm == ( BPF_OR | BPF_FETCH ) || insn -> imm == ( BPF_XOR | BPF_FETCH ) ) { u8 * branch_target ; bool is64 = BPF_SIZE ( insn -> code ) == BPF_DW ; u32 real_src_reg = src_reg ; emit_mov_reg ( & prog , true , BPF_REG_AX , BPF_REG_0 ) ; if ( src_reg == BPF_REG_0 ) real_src_reg = BPF_REG_AX ; branch_target = prog ; emit_ldx ( & prog , BPF_SIZE ( insn -> code ) , BPF_REG_0 , dst_reg , insn -> off ) ; emit_mov_reg ( & prog , is64 , AUX_REG , BPF_REG_0 ) ; maybe_emit_mod ( & prog , AUX_REG , real_src_reg , is64 ) ; EMIT2 ( simple_alu_opcodes [ BPF_OP ( insn -> imm ) ] , add_2reg ( 0xC0 , AUX_REG , real_src_reg ) ) ; err = emit_atomic ( & prog , BPF_CMPXCHG , dst_reg , AUX_REG , insn -> off , BPF_SIZE ( insn -> code ) ) ; if ( WARN_ON ( err ) ) return err ; EMIT2 ( X86_JNE , - ( prog - branch_target ) - 2 ) ; emit_mov_reg ( & prog , is64 , real_src_reg , BPF_REG_0 ) ; emit_mov_reg ( & prog , true , BPF_REG_0 , BPF_REG_AX ) ; break ; } err = emit_atomic ( & prog , insn -> imm , dst_reg , src_reg , insn -> off , BPF_SIZE ( insn -> code ) ) ; if ( err ) return err ; break ; case BPF_JMP | BPF_CALL : func = ( u8 * ) __bpf_call_base + imm32 ; if ( tail_call_reachable ) { EMIT3_off32 ( 0x48 , 0x8B , 0x85 , - ( bpf_prog -> aux -> stack_depth + 8 ) ) ; if ( ! imm32 || emit_call ( & prog , func , image + addrs [ i - 1 ] + 7 ) ) return - EINVAL ; } else { if ( ! imm32 || emit_call ( & prog , func , image + addrs [ i - 1 ] ) ) return - EINVAL ; } break ; case BPF_JMP | BPF_TAIL_CALL : if ( imm32 ) emit_bpf_tail_call_direct ( & bpf_prog -> aux -> poke_tab [ imm32 - 1 ] , & prog , addrs [ i ] , image , callee_regs_used , bpf_prog -> aux -> stack_depth ) ; else emit_bpf_tail_call_indirect ( & prog , callee_regs_used , bpf_prog -> aux -> stack_depth ) ; break ; case BPF_JMP | BPF_JEQ | BPF_X : case BPF_JMP | BPF_JNE | BPF_X : case BPF_JMP | BPF_JGT | BPF_X : case BPF_JMP | BPF_JLT | BPF_X : case BPF_JMP | BPF_JGE | BPF_X : case BPF_JMP | BPF_JLE | BPF_X : case BPF_JMP | BPF_JSGT | BPF_X : case BPF_JMP | BPF_JSLT | BPF_X : case BPF_JMP | BPF_JSGE | BPF_X : case BPF_JMP | BPF_JSLE | BPF_X : case BPF_JMP32 | BPF_JEQ | BPF_X : case BPF_JMP32 | BPF_JNE | BPF_X : case BPF_JMP32 | BPF_JGT | BPF_X : case BPF_JMP32 | BPF_JLT | BPF_X : case BPF_JMP32 | BPF_JGE | BPF_X : case BPF_JMP32 | BPF_JLE | BPF_X : case BPF_JMP32 | BPF_JSGT | BPF_X : case BPF_JMP32 | BPF_JSLT | BPF_X : case BPF_JMP32 | BPF_JSGE | BPF_X : case BPF_JMP32 | BPF_JSLE | BPF_X : maybe_emit_mod ( & prog , dst_reg , src_reg , BPF_CLASS ( insn -> code ) == BPF_JMP ) ; EMIT2 ( 0x39 , add_2reg ( 0xC0 , dst_reg , src_reg ) ) ; goto emit_cond_jmp ; case BPF_JMP | BPF_JSET | BPF_X : case BPF_JMP32 | BPF_JSET | BPF_X : maybe_emit_mod ( & prog , dst_reg , src_reg , BPF_CLASS ( insn -> code ) == BPF_JMP ) ; EMIT2 ( 0x85 , add_2reg ( 0xC0 , dst_reg , src_reg ) ) ; goto emit_cond_jmp ; case BPF_JMP | BPF_JSET | BPF_K : case BPF_JMP32 | BPF_JSET | BPF_K : if ( BPF_CLASS ( insn -> code ) == BPF_JMP ) EMIT1 ( add_1mod ( 0x48 , dst_reg ) ) ; else if ( is_ereg ( dst_reg ) ) EMIT1 ( add_1mod ( 0x40 , dst_reg ) ) ; EMIT2_off32 ( 0xF7 , add_1reg ( 0xC0 , dst_reg ) , imm32 ) ; goto emit_cond_jmp ; case BPF_JMP | BPF_JEQ | BPF_K : case BPF_JMP | BPF_JNE | BPF_K : case BPF_JMP | BPF_JGT | BPF_K : case BPF_JMP | BPF_JLT | BPF_K : case BPF_JMP | BPF_JGE | BPF_K : case BPF_JMP | BPF_JLE | BPF_K : case BPF_JMP | BPF_JSGT | BPF_K : case BPF_JMP | BPF_JSLT | BPF_K : case BPF_JMP | BPF_JSGE | BPF_K : case BPF_JMP | BPF_JSLE | BPF_K : case BPF_JMP32 | BPF_JEQ | BPF_K : case BPF_JMP32 | BPF_JNE | BPF_K : case BPF_JMP32 | BPF_JGT | BPF_K : case BPF_JMP32 | BPF_JLT | BPF_K : case BPF_JMP32 | BPF_JGE | BPF_K : case BPF_JMP32 | BPF_JLE | BPF_K : case BPF_JMP32 | BPF_JSGT | BPF_K : case BPF_JMP32 | BPF_JSLT | BPF_K : case BPF_JMP32 | BPF_JSGE | BPF_K : case BPF_JMP32 | BPF_JSLE | BPF_K : if ( imm32 == 0 ) { maybe_emit_mod ( & prog , dst_reg , dst_reg , BPF_CLASS ( insn -> code ) == BPF_JMP ) ; EMIT2 ( 0x85 , add_2reg ( 0xC0 , dst_reg , dst_reg ) ) ; goto emit_cond_jmp ; } if ( BPF_CLASS ( insn -> code ) == BPF_JMP ) EMIT1 ( add_1mod ( 0x48 , dst_reg ) ) ; else if ( is_ereg ( dst_reg ) ) EMIT1 ( add_1mod ( 0x40 , dst_reg ) ) ; if ( is_imm8 ( imm32 ) ) EMIT3 ( 0x83 , add_1reg ( 0xF8 , dst_reg ) , imm32 ) ; else EMIT2_off32 ( 0x81 , add_1reg ( 0xF8 , dst_reg ) , imm32 ) ; emit_cond_jmp : switch ( BPF_OP ( insn -> code ) ) { case BPF_JEQ : jmp_cond = X86_JE ; break ; case BPF_JSET : case BPF_JNE : jmp_cond = X86_JNE ; break ; case BPF_JGT : jmp_cond = X86_JA ; break ; case BPF_JLT : jmp_cond = X86_JB ; break ; case BPF_JGE : jmp_cond = X86_JAE ; break ; case BPF_JLE : jmp_cond = X86_JBE ; break ; case BPF_JSGT : jmp_cond = X86_JG ; break ; case BPF_JSLT : jmp_cond = X86_JL ; break ; case BPF_JSGE : jmp_cond = X86_JGE ; break ; case BPF_JSLE : jmp_cond = X86_JLE ; break ; default : return - EFAULT ; } jmp_offset = addrs [ i + insn -> off ] - addrs [ i ] ; if ( is_imm8 ( jmp_offset ) ) { if ( jmp_padding ) { nops = INSN_SZ_DIFF - 2 ; if ( nops != 0 && nops != 4 ) { pr_err ( \"unexpected<S2SV_blank>jmp_cond<S2SV_blank>padding:<S2SV_blank>%d<S2SV_blank>bytes\\\\n\" , nops ) ; return - EFAULT ; } cnt += emit_nops ( & prog , nops ) ; } EMIT2 ( jmp_cond , jmp_offset ) ; } else if ( is_simm32 ( jmp_offset ) ) { EMIT2_off32 ( 0x0F , jmp_cond + 0x10 , jmp_offset ) ; } else { pr_err ( \"cond_jmp<S2SV_blank>gen<S2SV_blank>bug<S2SV_blank>%llx\\\\n\" , jmp_offset ) ; return - EFAULT ; } break ; case BPF_JMP | BPF_JA : if ( insn -> off == - 1 ) jmp_offset = - 2 ; else jmp_offset = addrs [ i + insn -> off ] - addrs [ i ] ; if ( ! jmp_offset ) { if ( jmp_padding ) { nops = INSN_SZ_DIFF ; if ( nops != 0 && nops != 2 && nops != 5 ) { pr_err ( \"unexpected<S2SV_blank>nop<S2SV_blank>jump<S2SV_blank>padding:<S2SV_blank>%d<S2SV_blank>bytes\\\\n\" , nops ) ; return - EFAULT ; } cnt += emit_nops ( & prog , nops ) ; } break ; } emit_jmp : if ( is_imm8 ( jmp_offset ) ) { if ( jmp_padding ) { nops = INSN_SZ_DIFF - 2 ; if ( nops != 0 && nops != 3 ) { pr_err ( \"unexpected<S2SV_blank>jump<S2SV_blank>padding:<S2SV_blank>%d<S2SV_blank>bytes\\\\n\" , nops ) ; return - EFAULT ; } cnt += emit_nops ( & prog , INSN_SZ_DIFF - 2 ) ; } EMIT2 ( 0xEB , jmp_offset ) ; } else if ( is_simm32 ( jmp_offset ) ) { EMIT1_off32 ( 0xE9 , jmp_offset ) ; } else { pr_err ( \"jmp<S2SV_blank>gen<S2SV_blank>bug<S2SV_blank>%llx\\\\n\" , jmp_offset ) ; return - EFAULT ; } break ; case BPF_JMP | BPF_EXIT : if ( seen_exit ) { jmp_offset = ctx -> cleanup_addr - addrs [ i ] ; goto emit_jmp ; } seen_exit = true ; ctx -> cleanup_addr = proglen ; pop_callee_regs ( & prog , callee_regs_used ) ; EMIT1 ( 0xC9 ) ; EMIT1 ( 0xC3 ) ; break ; default : pr_err ( \"bpf_jit:<S2SV_blank>unknown<S2SV_blank>opcode<S2SV_blank>%02x\\\\n\" , insn -> code ) ; return - EINVAL ; } ilen = prog - temp ; if ( ilen > BPF_MAX_INSN_SIZE ) { pr_err ( \"bpf_jit:<S2SV_blank>fatal<S2SV_blank>insn<S2SV_blank>size<S2SV_blank>error\\\\n\" ) ; return - EFAULT ; } if ( image ) { <S2SV_StartBug> if ( unlikely ( proglen + ilen > oldproglen ) ) { <S2SV_EndBug> pr_err ( \"bpf_jit:<S2SV_blank>fatal<S2SV_blank>error\\\\n\" ) ; return - EFAULT ; } memcpy ( image + proglen , temp , ilen ) ; } proglen += ilen ; addrs [ i ] = proglen ; prog = temp ; } if ( image && excnt != bpf_prog -> aux -> num_exentries ) { pr_err ( \"extable<S2SV_blank>is<S2SV_blank>not<S2SV_blank>populated\\\\n\" ) ; return - EFAULT ; } return proglen ; }", "target": "<S2SV_ModStart> ilen > oldproglen || proglen + ilen != addrs [ i ]"}
{"source": "CWE-416 void rsi_mac80211_detach ( struct rsi_hw * adapter ) { struct ieee80211_hw * hw = adapter -> hw ; enum nl80211_band band ; if ( hw ) { ieee80211_stop_queues ( hw ) ; ieee80211_unregister_hw ( hw ) ; <S2SV_StartBug> ieee80211_free_hw ( hw ) ; <S2SV_EndBug> } for ( band = 0 ; band < NUM_NL80211_BANDS ; band ++ ) { struct ieee80211_supported_band * sband = & adapter -> sbands [ band ] ; kfree ( sband -> channels ) ; } # ifdef CONFIG_RSI_DEBUGFS rsi_remove_dbgfs ( adapter ) ; kfree ( adapter -> dfsentry ) ; # endif }", "target": "<S2SV_ModStart> ( hw ) ; adapter -> hw = NULL"}
{"source": "CWE-119 PHP_FUNCTION ( msgfmt_parse_message ) { UChar * spattern = NULL ; int spattern_len = 0 ; char * pattern = NULL ; size_t pattern_len = 0 ; const char * slocale = NULL ; size_t slocale_len = 0 ; char * source = NULL ; size_t src_len = 0 ; MessageFormatter_object mf ; MessageFormatter_object * mfo = & mf ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , \"sss\" , & slocale , & slocale_len , & pattern , & pattern_len , & source , & src_len ) == FAILURE ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"msgfmt_parse_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params\" , 0 ) ; RETURN_FALSE ; } <S2SV_StartBug> <S2SV_EndBug> memset ( mfo , 0 , sizeof ( * mfo ) ) ; msgformat_data_init ( & mfo -> mf_data ) ; if ( pattern && pattern_len ) { intl_convert_utf8_to_utf16 ( & spattern , & spattern_len , pattern , pattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( U_FAILURE ( INTL_DATA_ERROR_CODE ( ( mfo ) ) ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"msgfmt_parse_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>UTF-16\" , 0 ) ; RETURN_FALSE ; } } else { spattern_len = 0 ; spattern = NULL ; } if ( slocale_len == 0 ) { slocale = intl_locale_get_default ( ) ; } # ifdef MSG_FORMAT_QUOTE_APOS if ( msgformat_fix_quotes ( & spattern , & spattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) != SUCCESS ) { intl_error_set ( NULL , U_INVALID_FORMAT_ERROR , \"msgfmt_parse_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>quote-friendly<S2SV_blank>format\" , 0 ) ; RETURN_FALSE ; } # endif MSG_FORMAT_OBJECT ( mfo ) = umsg_open ( spattern , spattern_len , slocale , NULL , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( spattern && spattern_len ) { efree ( spattern ) ; } INTL_METHOD_CHECK_STATUS ( mfo , \"Creating<S2SV_blank>message<S2SV_blank>formatter<S2SV_blank>failed\" ) ; msgfmt_do_parse ( mfo , source , src_len , return_value ) ; msgformat_data_free ( & mfo -> mf_data ) ; }", "target": "<S2SV_ModStart> RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;"}
{"source": "CWE-59 writepid ( const char * pidfile , pid_t pid ) { <S2SV_StartBug> FILE * f ; <S2SV_EndBug> <S2SV_StartBug> if ( ( f = fopen ( pidfile , \"w\" ) ) == NULL ) { <S2SV_EndBug> log_err ( \"cannot<S2SV_blank>open<S2SV_blank>pidfile<S2SV_blank>%s:<S2SV_blank>%s\" , pidfile , strerror ( errno ) ) ; return ; } <S2SV_StartBug> if ( fprintf ( f , \"%lu\\\\n\" , ( unsigned long ) pid ) < 0 ) { <S2SV_EndBug> log_err ( \"cannot<S2SV_blank>write<S2SV_blank>to<S2SV_blank>pidfile<S2SV_blank>%s:<S2SV_blank>%s\" , pidfile , strerror ( errno ) ) ; <S2SV_StartBug> } <S2SV_EndBug> fclose ( f ) ; }", "target": "<S2SV_ModStart> pid ) { int fd ; char pidbuf [ 32 ] ; size_t count = 0 ; snprintf ( pidbuf , sizeof ( pidbuf ) , \"%lu\\\\n\" , ( unsigned long ) pid ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ( fd = open <S2SV_ModEnd> ( pidfile , <S2SV_ModStart> ( pidfile , O_WRONLY | O_CREAT | O_TRUNC # ifdef O_NOFOLLOW | O_NOFOLLOW # endif , 0644 <S2SV_ModEnd> ) ) == <S2SV_ModStart> ) ) == - 1 <S2SV_ModEnd> ) { log_err <S2SV_ModStart> return ; } while ( count < strlen ( pidbuf ) ) { ssize_t r = write ( fd , pidbuf + count , strlen ( pidbuf ) - count ) ; if ( r == - 1 ) { if ( errno == EAGAIN || errno == EINTR ) continue ; <S2SV_ModEnd> log_err ( \"cannot<S2SV_blank>write<S2SV_blank>to<S2SV_blank>pidfile<S2SV_blank>%s:<S2SV_blank>%s\" <S2SV_ModStart> ) ) ; break ; } count += r ; } close ( fd <S2SV_ModEnd> ) ; }"}
{"source": "CWE-662 static int dw_spi_transfer_one ( struct spi_controller * master , struct spi_device * spi , struct spi_transfer * transfer ) { struct dw_spi * dws = spi_controller_get_devdata ( master ) ; struct chip_data * chip = spi_get_ctldata ( spi ) ; <S2SV_StartBug> u8 imask = 0 ; <S2SV_EndBug> u16 txlevel = 0 ; u32 cr0 ; int ret ; dws -> dma_mapped = 0 ; <S2SV_StartBug> <S2SV_EndBug> dws -> tx = ( void * ) transfer -> tx_buf ; dws -> tx_end = dws -> tx + transfer -> len ; dws -> rx = transfer -> rx_buf ; dws -> rx_end = dws -> rx + transfer -> len ; <S2SV_StartBug> dws -> len = transfer -> len ; <S2SV_EndBug> spi_enable_chip ( dws , 0 ) ; if ( transfer -> speed_hz != dws -> current_freq ) { if ( transfer -> speed_hz != chip -> speed_hz ) { chip -> clk_div = ( DIV_ROUND_UP ( dws -> max_freq , transfer -> speed_hz ) + 1 ) & 0xfffe ; chip -> speed_hz = transfer -> speed_hz ; } dws -> current_freq = transfer -> speed_hz ; spi_set_clk ( dws , chip -> clk_div ) ; } dws -> n_bytes = DIV_ROUND_UP ( transfer -> bits_per_word , BITS_PER_BYTE ) ; dws -> dma_width = DIV_ROUND_UP ( transfer -> bits_per_word , BITS_PER_BYTE ) ; cr0 = ( transfer -> bits_per_word - 1 ) | ( chip -> type << SPI_FRF_OFFSET ) | ( ( ( ( spi -> mode & SPI_CPOL ) ? 1 : 0 ) << SPI_SCOL_OFFSET ) | ( ( ( spi -> mode & SPI_CPHA ) ? 1 : 0 ) << SPI_SCPH_OFFSET ) ) | ( chip -> tmode << SPI_TMOD_OFFSET ) ; if ( chip -> cs_control ) { if ( dws -> rx && dws -> tx ) chip -> tmode = SPI_TMOD_TR ; else if ( dws -> rx ) chip -> tmode = SPI_TMOD_RO ; else chip -> tmode = SPI_TMOD_TO ; cr0 &= ~ SPI_TMOD_MASK ; cr0 |= ( chip -> tmode << SPI_TMOD_OFFSET ) ; } dw_writel ( dws , DW_SPI_CTRL0 , cr0 ) ; if ( master -> can_dma && master -> can_dma ( master , spi , transfer ) ) dws -> dma_mapped = master -> cur_msg_mapped ; spi_mask_intr ( dws , 0xff ) ; if ( dws -> dma_mapped ) { ret = dws -> dma_ops -> dma_setup ( dws , transfer ) ; if ( ret < 0 ) { spi_enable_chip ( dws , 1 ) ; return ret ; } } else if ( ! chip -> poll_mode ) { txlevel = min_t ( u16 , dws -> fifo_len / 2 , dws -> len / dws -> n_bytes ) ; dw_writel ( dws , DW_SPI_TXFLTR , txlevel ) ; imask |= SPI_INT_TXEI | SPI_INT_TXOI | SPI_INT_RXUI | SPI_INT_RXOI ; spi_umask_intr ( dws , imask ) ; dws -> transfer_handler = interrupt_transfer ; } spi_enable_chip ( dws , 1 ) ; if ( dws -> dma_mapped ) { ret = dws -> dma_ops -> dma_transfer ( dws , transfer ) ; if ( ret < 0 ) return ret ; } if ( chip -> poll_mode ) return poll_transfer ( dws ) ; return 1 ; }", "target": "<S2SV_ModStart> spi ) ; unsigned long flags ; <S2SV_ModStart> = 0 ; spin_lock_irqsave ( & dws -> buf_lock , flags ) ; <S2SV_ModStart> transfer -> len ; spin_unlock_irqrestore ( & dws -> buf_lock , flags )"}
{"source": "CWE-190 <S2SV_StartBug> INLINE void gdi_RectToCRgn ( const HGDI_RECT rect , INT32 * x , INT32 * y , INT32 * w , INT32 * h ) <S2SV_EndBug> { * x = rect -> left ; <S2SV_StartBug> * y = rect -> top ; <S2SV_EndBug> <S2SV_StartBug> * w = rect -> right - rect -> left + 1 ; <S2SV_EndBug> <S2SV_StartBug> * h = rect -> bottom - rect -> top + 1 ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> <S2SV_null> INLINE void gdi_RectToRgn ( <S2SV_ModEnd> HGDI_RECT rect , <S2SV_ModStart> HGDI_RECT rect , HGDI_RGN rgn ) { rgn -> <S2SV_ModEnd> x = rect <S2SV_ModStart> -> left ; rgn -> <S2SV_ModEnd> y = rect <S2SV_ModStart> -> top ; rgn -> <S2SV_ModEnd> w = rect <S2SV_ModStart> + 1 ; rgn -> <S2SV_ModEnd> h = rect"}
{"source": "CWE-476 static const char * GetMagickPropertyLetter ( const ImageInfo * image_info , Image * image , const char letter ) { <S2SV_StartBug> char <S2SV_EndBug> value [ MaxTextExtent ] ; const char * string ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image -> filename ) ; * value = '\\\\0' ; string = ( char * ) NULL ; switch ( letter ) { case 'b' : { ( void ) FormatMagickSize ( image -> extent , MagickFalse , value ) ; if ( image -> extent == 0 ) ( void ) FormatMagickSize ( GetBlobSize ( image ) , MagickFalse , value ) ; break ; } case 'c' : { string = GetImageProperty ( image , \"comment\" ) ; if ( string == ( const char * ) NULL ) string = \"\" ; break ; } case 'd' : { GetPathComponent ( image -> magick_filename , HeadPath , value ) ; if ( * value == '\\\\0' ) string = \"\" ; break ; } case 'e' : { GetPathComponent ( image -> magick_filename , ExtensionPath , value ) ; if ( * value == '\\\\0' ) string = \"\" ; break ; } case 'f' : { GetPathComponent ( image -> magick_filename , TailPath , value ) ; if ( * value == '\\\\0' ) string = \"\" ; break ; } case 'g' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20gx%.20g%+.20g%+.20g\" , ( double ) image -> page . width , ( double ) image -> page . height , ( double ) image -> page . x , ( double ) image -> page . y ) ; break ; } case 'h' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) ( image -> rows != 0 ? image -> rows : image -> magick_rows ) ) ; break ; } case 'i' : { string = image -> filename ; break ; } case 'k' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) GetNumberColors ( image , ( FILE * ) NULL , & image -> exception ) ) ; break ; } case 'l' : { string = GetImageProperty ( image , \"label\" ) ; if ( string == ( const char * ) NULL ) string = \"\" ; break ; } case 'm' : { string = image -> magick ; break ; } case 'n' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) GetImageListLength ( image ) ) ; break ; } case 'o' : <S2SV_StartBug> { <S2SV_EndBug> string = image_info -> filename ; break ; } case 'p' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) GetImageIndexInList ( image ) ) ; break ; } case 'q' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) MAGICKCORE_QUANTUM_DEPTH ) ; break ; } case 'r' : { ColorspaceType colorspace ; colorspace = image -> colorspace ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) && ( SetImageGray ( image , & image -> exception ) != MagickFalse ) ) colorspace = GRAYColorspace ; ( void ) FormatLocaleString ( value , MaxTextExtent , \"%s<S2SV_blank>%s<S2SV_blank>%s\" , CommandOptionToMnemonic ( MagickClassOptions , ( ssize_t ) image -> storage_class ) , CommandOptionToMnemonic ( MagickColorspaceOptions , ( ssize_t ) colorspace ) , image -> matte != MagickFalse ? \"Matte\" : \"\" ) ; break ; } case 's' : { <S2SV_StartBug> if ( image_info -> number_scenes != 0 ) <S2SV_EndBug> ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image_info -> scene ) ; else ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image -> scene ) ; break ; } case 't' : { GetPathComponent ( image -> magick_filename , BasePath , value ) ; break ; } case 'u' : <S2SV_StartBug> { <S2SV_EndBug> string = image_info -> unique ; break ; } case 'w' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) ( image -> columns != 0 ? image -> columns : image -> magick_columns ) ) ; break ; } case 'x' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , fabs ( image -> x_resolution ) > MagickEpsilon ? image -> x_resolution : 72.0 ) ; break ; } case 'y' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , fabs ( image -> y_resolution ) > MagickEpsilon ? image -> y_resolution : 72.0 ) ; break ; } case 'z' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image -> depth ) ; break ; } case 'A' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%s\" , CommandOptionToMnemonic ( MagickBooleanOptions , ( ssize_t ) image -> matte ) ) ; break ; } case 'B' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image -> extent ) ; if ( image -> extent == 0 ) ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) GetBlobSize ( image ) ) ; break ; } case 'C' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%s\" , CommandOptionToMnemonic ( MagickCompressOptions , ( ssize_t ) image -> compression ) ) ; break ; } case 'D' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%s\" , CommandOptionToMnemonic ( MagickDisposeOptions , ( ssize_t ) image -> dispose ) ) ; break ; } case 'F' : { const char * q ; register char * p ; static char whitelist [ ] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789<S2SV_blank>\" \"$-_.+!*\\'(),{}|\\\\\\\\^~[]`\\\\\"><#%;/?:@&=\" ; ( void ) CopyMagickString ( value , image -> magick_filename , MaxTextExtent ) ; p = value ; q = value + strlen ( value ) ; for ( p += strspn ( p , whitelist ) ; p != q ; p += strspn ( p , whitelist ) ) * p = '_' ; break ; } case 'G' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20gx%.20g\" , ( double ) image -> magick_columns , ( double ) image -> magick_rows ) ; break ; } case 'H' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image -> page . height ) ; break ; } case 'M' : { string = image -> magick_filename ; break ; } case 'O' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%+ld%+ld\" , ( long ) image -> page . x , ( long ) image -> page . y ) ; break ; } case 'P' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20gx%.20g\" , ( double ) image -> page . width , ( double ) image -> page . height ) ; break ; } case 'Q' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) ( image -> quality == 0 ? 92 : image -> quality ) ) ; break ; } case 'S' : { <S2SV_StartBug> if ( image_info -> number_scenes == 0 ) <S2SV_EndBug> string = \"2147483647\" ; else ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image_info -> scene + image_info -> number_scenes ) ; break ; } case 'T' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image -> delay ) ; break ; } case 'U' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%s\" , CommandOptionToMnemonic ( MagickResolutionOptions , ( ssize_t ) image -> units ) ) ; break ; } case 'W' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20g\" , ( double ) image -> page . width ) ; break ; } case 'X' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%+.20g\" , ( double ) image -> page . x ) ; break ; } case 'Y' : { ( void ) FormatLocaleString ( value , MaxTextExtent , \"%+.20g\" , ( double ) image -> page . y ) ; break ; } case 'Z' : { <S2SV_StartBug> string = image_info -> zero ; <S2SV_EndBug> break ; } case '@' : { RectangleInfo page ; page = GetImageBoundingBox ( image , & image -> exception ) ; ( void ) FormatLocaleString ( value , MaxTextExtent , \"%.20gx%.20g%+.20g%+.20g\" , ( double ) page . width , ( double ) page . height , ( double ) page . x , ( double ) page . y ) ; break ; } case '#' : { if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) ( void ) SignatureImage ( image ) ; string = GetImageProperty ( image , \"signature\" ) ; break ; } case '%' : { string = \"%\" ; break ; } } if ( * value != '\\\\0' ) string = value ; if ( string != ( char * ) NULL ) { ( void ) SetImageArtifact ( image , \"get-property\" , string ) ; return ( GetImageArtifact ( image , \"get-property\" ) ) ; } return ( ( char * ) NULL ) ; }", "target": "<S2SV_ModStart> letter ) { # define WarnNoImageInfoReturn ( format , arg ) if ( image_info == ( ImageInfo * ) NULL ) { ( void ) ThrowMagickException ( & image -> exception , GetMagickModule ( ) , OptionWarning , \"NoImageInfoForProperty\" , format , arg ) ; return ( ( const char * ) NULL ) ; } <S2SV_ModStart> 'o' : { WarnNoImageInfoReturn ( \"\\\\\"%%%c\\\\\"\" , letter ) ; <S2SV_ModStart> 's' : { WarnNoImageInfoReturn ( \"\\\\\"%%%c\\\\\"\" , letter ) ; <S2SV_ModStart> 'u' : { WarnNoImageInfoReturn ( \"\\\\\"%%%c\\\\\"\" , letter ) ; <S2SV_ModStart> 'S' : { WarnNoImageInfoReturn ( \"\\\\\"%%%c\\\\\"\" , letter ) ; <S2SV_ModStart> 'Z' : { WarnNoImageInfoReturn ( \"\\\\\"%%%c\\\\\"\" , letter ) ;"}
{"source": "CWE-476 formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : <S2SV_StartBug> if ( spos >= buf -> currentLine -> len || spos < 0 ) <S2SV_EndBug> break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '<S2SV_blank>' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) { if ( rows > 1 ) { pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }", "target": "<S2SV_ModStart> : if ( buf -> currentLine == NULL ||"}
{"source": "CWE-125 static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR ) { for ( j = 1 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( \"Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\\\n\" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; while ( ( npages - i ) >= HPAGE_PMD_NR ) { struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 1 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( \"Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\\\n\" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }", "target": "<S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages [ <S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages ["}
{"source": "CWE-310 ciphertext_to_compressed ( gnutls_session_t session , gnutls_datum_t * ciphertext , uint8_t * compress_data , int compress_size , uint8_t type , record_parameters_st * params , uint64 * sequence ) { uint8_t tag [ MAX_HASH_SIZE ] ; uint8_t pad ; int length , length_to_decrypt ; uint16_t blocksize ; int ret , i , pad_failed = 0 ; uint8_t preamble [ MAX_PREAMBLE_SIZE ] ; unsigned int preamble_size ; unsigned int ver = gnutls_protocol_get_version ( session ) ; unsigned int tag_size = _gnutls_auth_cipher_tag_len ( & params -> read . cipher_state ) ; unsigned int explicit_iv = _gnutls_version_has_explicit_iv ( session -> security_parameters . version ) ; blocksize = gnutls_cipher_get_block_size ( params -> cipher_algorithm ) ; switch ( _gnutls_cipher_is_block ( params -> cipher_algorithm ) ) { case CIPHER_STREAM : if ( explicit_iv && _gnutls_auth_cipher_is_aead ( & params -> read . cipher_state ) ) { uint8_t nonce [ blocksize ] ; if ( params -> read . IV . data == NULL || params -> read . IV . size != 4 ) return gnutls_assert_val ( GNUTLS_E_INTERNAL_ERROR ) ; if ( ciphertext -> size < tag_size + AEAD_EXPLICIT_DATA_SIZE ) return gnutls_assert_val ( GNUTLS_E_UNEXPECTED_PACKET_LENGTH ) ; memcpy ( nonce , params -> read . IV . data , AEAD_IMPLICIT_DATA_SIZE ) ; memcpy ( & nonce [ AEAD_IMPLICIT_DATA_SIZE ] , ciphertext -> data , AEAD_EXPLICIT_DATA_SIZE ) ; _gnutls_auth_cipher_setiv ( & params -> read . cipher_state , nonce , AEAD_EXPLICIT_DATA_SIZE + AEAD_IMPLICIT_DATA_SIZE ) ; ciphertext -> data += AEAD_EXPLICIT_DATA_SIZE ; ciphertext -> size -= AEAD_EXPLICIT_DATA_SIZE ; length_to_decrypt = ciphertext -> size - tag_size ; } else { if ( ciphertext -> size < tag_size ) return gnutls_assert_val ( GNUTLS_E_UNEXPECTED_PACKET_LENGTH ) ; length_to_decrypt = ciphertext -> size ; } length = ciphertext -> size - tag_size ; preamble_size = make_preamble ( UINT64DATA ( * sequence ) , type , length , ver , preamble ) ; ret = _gnutls_auth_cipher_add_auth ( & params -> read . cipher_state , preamble , preamble_size ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; if ( ( ret = _gnutls_auth_cipher_decrypt2 ( & params -> read . cipher_state , ciphertext -> data , length_to_decrypt , ciphertext -> data , ciphertext -> size ) ) < 0 ) return gnutls_assert_val ( ret ) ; break ; case CIPHER_BLOCK : <S2SV_StartBug> if ( ciphertext -> size < MAX ( blocksize , tag_size ) || ( ciphertext -> size % blocksize != 0 ) ) <S2SV_EndBug> return gnutls_assert_val ( GNUTLS_E_UNEXPECTED_PACKET_LENGTH ) ; if ( explicit_iv ) { _gnutls_auth_cipher_setiv ( & params -> read . cipher_state , ciphertext -> data , blocksize ) ; ciphertext -> size -= blocksize ; ciphertext -> data += blocksize ; <S2SV_StartBug> if ( ciphertext -> size == 0 ) <S2SV_EndBug> { gnutls_assert ( ) ; return GNUTLS_E_DECRYPTION_FAILED ; } } if ( ( ret = _gnutls_cipher_decrypt ( & params -> read . cipher_state . cipher , ciphertext -> data , ciphertext -> size ) ) < 0 ) return gnutls_assert_val ( ret ) ; pad = ciphertext -> data [ ciphertext -> size - 1 ] + 1 ; if ( ( int ) pad > ( int ) ciphertext -> size - tag_size ) { gnutls_assert ( ) ; _gnutls_record_log ( \"REC[%p]:<S2SV_blank>Short<S2SV_blank>record<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>(under<S2SV_blank>attack?)\\\\n\" , session , pad , ciphertext -> size , tag_size ) ; pad_failed = GNUTLS_E_DECRYPTION_FAILED ; pad %= blocksize ; } length = ciphertext -> size - tag_size - pad ; if ( ver != GNUTLS_SSL3 ) for ( i = 2 ; i < pad ; i ++ ) { if ( ciphertext -> data [ ciphertext -> size - i ] != ciphertext -> data [ ciphertext -> size - 1 ] ) pad_failed = GNUTLS_E_DECRYPTION_FAILED ; } if ( length < 0 ) { length = ciphertext -> size - tag_size ; } preamble_size = make_preamble ( UINT64DATA ( * sequence ) , type , length , ver , preamble ) ; ret = _gnutls_auth_cipher_add_auth ( & params -> read . cipher_state , preamble , preamble_size ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; ret = _gnutls_auth_cipher_add_auth ( & params -> read . cipher_state , ciphertext -> data , length ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; break ; default : return gnutls_assert_val ( GNUTLS_E_INTERNAL_ERROR ) ; } ret = _gnutls_auth_cipher_tag ( & params -> read . cipher_state , tag , tag_size ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; if ( memcmp ( tag , & ciphertext -> data [ length ] , tag_size ) != 0 || pad_failed != 0 ) return gnutls_assert_val ( GNUTLS_E_DECRYPTION_FAILED ) ; if ( compress_size < length ) return gnutls_assert_val ( GNUTLS_E_DECOMPRESSION_FAILED ) ; if ( compress_data != ciphertext -> data ) memcpy ( compress_data , ciphertext -> data , length ) ; return length ; }", "target": "<S2SV_ModStart> -> size < blocksize <S2SV_ModEnd> || ( ciphertext <S2SV_ModStart> += blocksize ; } if ( ciphertext -> size < tag_size ) return gnutls_assert_val ( GNUTLS_E_DECRYPTION_FAILED ) ; <S2SV_ModEnd> if ( ("}
{"source": "CWE-401 table_regex_match ( const char * string , const char * pattern ) { regex_t preg ; <S2SV_StartBug> int cflags = REG_EXTENDED | REG_NOSUB ; <S2SV_EndBug> if ( strncmp ( pattern , \"(?i)\" , 4 ) == 0 ) { cflags |= REG_ICASE ; pattern += 4 ; } if ( regcomp ( & preg , pattern , cflags ) != 0 ) return ( 0 ) ; <S2SV_StartBug> if ( regexec ( & preg , string , 0 , NULL , 0 ) != 0 ) <S2SV_EndBug> return ( 0 ) ; return ( 1 ) ; }", "target": "<S2SV_ModStart> REG_EXTENDED | REG_NOSUB ; int ret <S2SV_ModStart> 0 ) ; ret = <S2SV_ModEnd> regexec ( & <S2SV_ModStart> , 0 ) ; regfree ( & preg ) ; if ( ret"}
{"source": "CWE-362 static int __ip_append_data ( struct sock * sk , struct flowi4 * fl4 , struct sk_buff_head * queue , struct inet_cork * cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; struct ip_options * opt = cork -> opt ; int hh_len ; int exthdrlen ; int mtu ; int copy ; int err ; int offset = 0 ; unsigned int maxfraglen , fragheaderlen , maxnonfragsize ; int csummode = CHECKSUM_NONE ; struct rtable * rt = ( struct rtable * ) cork -> dst ; u32 tskey = 0 ; skb = skb_peek_tail ( queue ) ; exthdrlen = ! skb ? rt -> dst . header_len : 0 ; mtu = cork -> fragsize ; if ( cork -> tx_flags & SKBTX_ANY_SW_TSTAMP && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) tskey = sk -> sk_tskey ++ ; hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen ; maxnonfragsize = ip_sk_ignore_df ( sk ) ? 0xFFFF : mtu ; if ( cork -> length + length > maxnonfragsize - fragheaderlen ) { ip_local_error ( sk , EMSGSIZE , fl4 -> daddr , inet -> inet_dport , mtu - ( opt ? opt -> optlen : 0 ) ) ; return - EMSGSIZE ; } if ( transhdrlen && length + fragheaderlen <= mtu && rt -> dst . dev -> features & ( NETIF_F_HW_CSUM | NETIF_F_IP_CSUM ) && ! ( flags & MSG_MORE ) && ! exthdrlen ) csummode = CHECKSUM_PARTIAL ; cork -> length += length ; <S2SV_StartBug> if ( ( ( ( length + ( skb ? skb -> len : fragheaderlen ) ) > mtu ) || <S2SV_EndBug> ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && <S2SV_StartBug> ( sk -> sk_type == SOCK_DGRAM ) && ! sk -> sk_no_check_tx ) { <S2SV_EndBug> err = ip_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , maxfraglen , flags ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = mtu - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; struct sk_buff * skb_prev ; alloc_new_skb : skb_prev = skb ; if ( skb_prev ) fraggap = skb_prev -> len - maxfraglen ; else fraggap = 0 ; datalen = length + fraggap ; if ( datalen > mtu - fragheaderlen ) datalen = maxfraglen - fragheaderlen ; fraglen = datalen + fragheaderlen ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = fraglen ; alloclen += exthdrlen ; if ( datalen == length + fraggap ) alloclen += rt -> dst . trailer_len ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len + 15 , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( refcount_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len + 15 , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - ENOBUFS ; } if ( ! skb ) goto error ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len ) ; skb_shinfo ( skb ) -> tx_flags = cork -> tx_flags ; cork -> tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen + exthdrlen ) ; skb_set_network_header ( skb , exthdrlen ) ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; data += fragheaderlen + exthdrlen ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; csummode = CHECKSUM_NONE ; if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; refcount_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP_INC_STATS ( sock_net ( sk ) , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }", "target": "<S2SV_ModStart> if ( ( skb && skb_is_gso ( skb ) ) || ( <S2SV_ModStart> > mtu ) && ( skb_queue_len ( queue ) <= 1 <S2SV_ModEnd> ) && ( <S2SV_ModStart> -> sk_no_check_tx ) )"}
{"source": "CWE-787 static int crypto_rsa_common ( const BYTE * input , int length , UINT32 key_length , const BYTE * modulus , const BYTE * exponent , int exponent_size , BYTE * output ) { <S2SV_StartBug> BN_CTX * ctx ; <S2SV_EndBug> int output_length = - 1 ; <S2SV_StartBug> BYTE * input_reverse ; <S2SV_EndBug> <S2SV_StartBug> BYTE * modulus_reverse ; <S2SV_EndBug> <S2SV_StartBug> BYTE * exponent_reverse ; <S2SV_EndBug> <S2SV_StartBug> BIGNUM * mod , * exp , * x , * y ; <S2SV_EndBug> <S2SV_StartBug> input_reverse = ( BYTE * ) malloc ( 2 * key_length + exponent_size ) ; <S2SV_EndBug> if ( ! input_reverse ) return - 1 ; <S2SV_StartBug> modulus_reverse = input_reverse + key_length ; <S2SV_EndBug> exponent_reverse = modulus_reverse + key_length ; memcpy ( modulus_reverse , modulus , key_length ) ; crypto_reverse ( modulus_reverse , key_length ) ; memcpy ( exponent_reverse , exponent , exponent_size ) ; crypto_reverse ( exponent_reverse , exponent_size ) ; memcpy ( input_reverse , input , length ) ; crypto_reverse ( input_reverse , length ) ; if ( ! ( ctx = BN_CTX_new ( ) ) ) goto fail_bn_ctx ; if ( ! ( mod = BN_new ( ) ) ) goto fail_bn_mod ; if ( ! ( exp = BN_new ( ) ) ) goto fail_bn_exp ; if ( ! ( x = BN_new ( ) ) ) goto fail_bn_x ; if ( ! ( y = BN_new ( ) ) ) goto fail_bn_y ; <S2SV_StartBug> BN_bin2bn ( modulus_reverse , key_length , mod ) ; <S2SV_EndBug> <S2SV_StartBug> BN_bin2bn ( exponent_reverse , exponent_size , exp ) ; <S2SV_EndBug> <S2SV_StartBug> BN_bin2bn ( input_reverse , length , x ) ; <S2SV_EndBug> <S2SV_StartBug> BN_mod_exp ( y , x , exp , mod , ctx ) ; <S2SV_EndBug> output_length = BN_bn2bin ( y , output ) ; <S2SV_StartBug> crypto_reverse ( output , output_length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output_length < ( int ) key_length ) <S2SV_EndBug> memset ( output + output_length , 0 , key_length - output_length ) ; <S2SV_StartBug> BN_free ( y ) ; <S2SV_EndBug> fail_bn_y : BN_clear_free ( x ) ; fail_bn_x : BN_free ( exp ) ; fail_bn_exp : BN_free ( mod ) ; fail_bn_mod : BN_CTX_free ( ctx ) ; fail_bn_ctx : free ( input_reverse ) ; return output_length ; }", "target": "<S2SV_ModStart> BN_CTX * ctx = NULL <S2SV_ModStart> BYTE * input_reverse = NULL <S2SV_ModStart> BYTE * modulus_reverse = NULL <S2SV_ModStart> BYTE * exponent_reverse = NULL <S2SV_ModStart> BIGNUM * mod = NULL ; BIGNUM * exp = NULL ; BIGNUM * x = NULL ; BIGNUM * y = NULL ; size_t bufferSize = <S2SV_ModEnd> 2 * key_length <S2SV_ModStart> key_length + exponent_size ; if ( ! input || ( length < 0 ) || ( exponent_size < 0 ) || ! modulus || ! exponent || ! output <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; if ( length > bufferSize ) bufferSize = length ; input_reverse = ( BYTE * ) calloc ( bufferSize , 1 ) ; if ( ! input_reverse ) return - 1 ; <S2SV_ModStart> goto fail_bn_y ; if ( ! <S2SV_ModStart> , mod ) ) goto fail ; if ( ! <S2SV_ModEnd> BN_bin2bn ( exponent_reverse <S2SV_ModStart> , exp ) ) goto fail ; if ( ! <S2SV_ModEnd> BN_bin2bn ( input_reverse <S2SV_ModStart> , x ) ) goto fail ; if ( <S2SV_ModEnd> BN_mod_exp ( y <S2SV_ModStart> , ctx ) != 1 ) goto fail <S2SV_ModStart> output ) ; if ( output_length < 0 ) goto fail ; <S2SV_ModStart> ( output_length < <S2SV_ModEnd> key_length ) memset <S2SV_ModStart> output_length ) ; fail :"}
{"source": "CWE-476 open_ssl_connection ( rfbClient * client , int sockfd , rfbBool anonTLS , rfbCredential * cred ) { SSL_CTX * ssl_ctx = NULL ; SSL * ssl = NULL ; int n , finished = 0 ; X509_VERIFY_PARAM * param ; <S2SV_StartBug> uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ; <S2SV_EndBug> if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) { rfbClientLog ( \"Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>context.\\\\n\" ) ; return NULL ; } param = X509_VERIFY_PARAM_new ( ) ; if ( ! anonTLS ) <S2SV_StartBug> { <S2SV_EndBug> if ( cred -> x509Credential . x509CACertFile ) { if ( ! SSL_CTX_load_verify_locations ( ssl_ctx , cred -> x509Credential . x509CACertFile , NULL ) ) { rfbClientLog ( \"Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>from<S2SV_blank>%s.\\\\n\" , cred -> x509Credential . x509CACertFile ) ; goto error_free_ctx ; } } else { rfbClientLog ( \"Using<S2SV_blank>default<S2SV_blank>paths<S2SV_blank>for<S2SV_blank>certificate<S2SV_blank>verification.\\\\n\" ) ; SSL_CTX_set_default_verify_paths ( ssl_ctx ) ; } if ( cred -> x509Credential . x509CACrlFile ) { if ( ! load_crls_from_file ( cred -> x509Credential . x509CACrlFile , ssl_ctx ) ) { rfbClientLog ( \"CRLs<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\\\n\" ) ; goto error_free_ctx ; } if ( verify_crls == rfbX509CrlVerifyNone ) verify_crls = rfbX509CrlVerifyAll ; } if ( cred -> x509Credential . x509ClientCertFile && cred -> x509Credential . x509ClientKeyFile ) { if ( SSL_CTX_use_certificate_chain_file ( ssl_ctx , cred -> x509Credential . x509ClientCertFile ) != 1 ) { rfbClientLog ( \"Client<S2SV_blank>certificate<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\\\n\" ) ; goto error_free_ctx ; } if ( SSL_CTX_use_PrivateKey_file ( ssl_ctx , cred -> x509Credential . x509ClientKeyFile , SSL_FILETYPE_PEM ) != 1 ) { rfbClientLog ( \"Client<S2SV_blank>private<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\\\n\" ) ; goto error_free_ctx ; } if ( SSL_CTX_check_private_key ( ssl_ctx ) == 0 ) { rfbClientLog ( \"Client<S2SV_blank>certificate<S2SV_blank>and<S2SV_blank>private<S2SV_blank>key<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.\\\\n\" ) ; goto error_free_ctx ; } } SSL_CTX_set_verify ( ssl_ctx , SSL_VERIFY_PEER , NULL ) ; if ( verify_crls == rfbX509CrlVerifyClient ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK ) ; else if ( verify_crls == rfbX509CrlVerifyAll ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL ) ; if ( ! X509_VERIFY_PARAM_set1_host ( param , client -> serverHost , strlen ( client -> serverHost ) ) ) { rfbClientLog ( \"Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>server<S2SV_blank>name<S2SV_blank>for<S2SV_blank>verification.\\\\n\" ) ; goto error_free_ctx ; } SSL_CTX_set1_param ( ssl_ctx , param ) ; } if ( ! ( ssl = SSL_new ( ssl_ctx ) ) ) { rfbClientLog ( \"Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>session.\\\\n\" ) ; goto error_free_ctx ; } SSL_set_cipher_list ( ssl , \"ALL\" ) ; SSL_set_fd ( ssl , sockfd ) ; SSL_CTX_set_app_data ( ssl_ctx , client ) ; do { n = SSL_connect ( ssl ) ; if ( n != 1 ) { if ( wait_for_data ( ssl , n , 1 ) != 1 ) { finished = 1 ; SSL_shutdown ( ssl ) ; goto error_free_ssl ; } } } while ( n != 1 && finished != 1 ) ; X509_VERIFY_PARAM_free ( param ) ; return ssl ; error_free_ssl : SSL_free ( ssl ) ; error_free_ctx : X509_VERIFY_PARAM_free ( param ) ; SSL_CTX_free ( ssl_ctx ) ; return NULL ; }", "target": "<S2SV_ModStart> ; uint8_t verify_crls <S2SV_ModEnd> ; if ( <S2SV_ModStart> anonTLS ) { verify_crls = cred -> x509Credential . x509CrlVerifyMode ;"}
{"source": "CWE-835 static int dissect_dvb_s2_bb ( tvbuff_t * tvb , int cur_off , proto_tree * tree , packet_info * pinfo ) { proto_item * ti ; proto_tree * dvb_s2_bb_tree ; guint8 input8 , matype1 ; guint8 sync_flag = 0 ; guint16 input16 , bb_data_len = 0 , user_packet_length ; int sub_dissected = 0 , flag_is_ms = 0 , new_off = 0 ; static int * const bb_header_bitfields [ ] = { & hf_dvb_s2_bb_matype1_gs , & hf_dvb_s2_bb_matype1_mis , & hf_dvb_s2_bb_matype1_acm , & hf_dvb_s2_bb_matype1_issyi , & hf_dvb_s2_bb_matype1_npd , & hf_dvb_s2_bb_matype1_low_ro , NULL } ; col_append_str ( pinfo -> cinfo , COL_PROTOCOL , \"BB<S2SV_blank>\" ) ; col_append_str ( pinfo -> cinfo , COL_INFO , \"Baseband<S2SV_blank>\" ) ; ti = proto_tree_add_item ( tree , proto_dvb_s2_bb , tvb , cur_off , DVB_S2_BB_HEADER_LEN , ENC_NA ) ; dvb_s2_bb_tree = proto_item_add_subtree ( ti , ett_dvb_s2_bb ) ; matype1 = tvb_get_guint8 ( tvb , cur_off + DVB_S2_BB_OFFS_MATYPE1 ) ; new_off += 1 ; if ( BIT_IS_CLEAR ( matype1 , DVB_S2_BB_MIS_POS ) ) flag_is_ms = 1 ; proto_tree_add_bitmask_with_flags ( dvb_s2_bb_tree , tvb , cur_off + DVB_S2_BB_OFFS_MATYPE1 , hf_dvb_s2_bb_matype1 , ett_dvb_s2_bb_matype1 , bb_header_bitfields , ENC_BIG_ENDIAN , BMT_NO_FLAGS ) ; input8 = tvb_get_guint8 ( tvb , cur_off + DVB_S2_BB_OFFS_MATYPE1 ) ; if ( ( pinfo -> fd -> num == 1 ) && ( _use_low_rolloff_value != 0 ) ) { _use_low_rolloff_value = 0 ; } if ( ( ( input8 & 0x03 ) == 3 ) && ! _use_low_rolloff_value ) { _use_low_rolloff_value = 1 ; } if ( _use_low_rolloff_value ) { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype1_low_ro , tvb , cur_off + DVB_S2_BB_OFFS_MATYPE1 , 1 , ENC_BIG_ENDIAN ) ; } else { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype1_high_ro , tvb , cur_off + DVB_S2_BB_OFFS_MATYPE1 , 1 , ENC_BIG_ENDIAN ) ; } input8 = tvb_get_guint8 ( tvb , cur_off + DVB_S2_BB_OFFS_MATYPE2 ) ; new_off += 1 ; if ( flag_is_ms ) { proto_tree_add_uint_format_value ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype2 , tvb , cur_off + DVB_S2_BB_OFFS_MATYPE2 , 1 , input8 , \"Input<S2SV_blank>Stream<S2SV_blank>Identifier<S2SV_blank>(ISI):<S2SV_blank>%d\" , input8 ) ; } else { proto_tree_add_uint_format_value ( dvb_s2_bb_tree , hf_dvb_s2_bb_matype2 , tvb , cur_off + DVB_S2_BB_OFFS_MATYPE2 , 1 , input8 , \"reserved\" ) ; } user_packet_length = input16 = tvb_get_ntohs ( tvb , cur_off + DVB_S2_BB_OFFS_UPL ) ; new_off += 2 ; proto_tree_add_uint_format ( dvb_s2_bb_tree , hf_dvb_s2_bb_upl , tvb , cur_off + DVB_S2_BB_OFFS_UPL , 2 , input16 , \"User<S2SV_blank>Packet<S2SV_blank>Length:<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>(%d<S2SV_blank>bytes)\" , ( guint16 ) input16 , ( guint16 ) input16 / 8 ) ; bb_data_len = input16 = tvb_get_ntohs ( tvb , cur_off + DVB_S2_BB_OFFS_DFL ) ; bb_data_len /= 8 ; new_off += 2 ; proto_tree_add_uint_format_value ( dvb_s2_bb_tree , hf_dvb_s2_bb_dfl , tvb , cur_off + DVB_S2_BB_OFFS_DFL , 2 , input16 , \"%d<S2SV_blank>bits<S2SV_blank>(%d<S2SV_blank>bytes)\" , input16 , input16 / 8 ) ; new_off += 1 ; sync_flag = tvb_get_guint8 ( tvb , cur_off + DVB_S2_BB_OFFS_SYNC ) ; proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_sync , tvb , cur_off + DVB_S2_BB_OFFS_SYNC , 1 , ENC_BIG_ENDIAN ) ; new_off += 2 ; proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_syncd , tvb , cur_off + DVB_S2_BB_OFFS_SYNCD , 2 , ENC_BIG_ENDIAN ) ; new_off += 1 ; proto_tree_add_checksum ( dvb_s2_bb_tree , tvb , cur_off + DVB_S2_BB_OFFS_CRC , hf_dvb_s2_bb_crc , hf_dvb_s2_bb_crc_status , & ei_dvb_s2_bb_crc , pinfo , compute_crc8 ( tvb , DVB_S2_BB_HEADER_LEN - 1 , cur_off ) , ENC_NA , PROTO_CHECKSUM_VERIFY ) ; switch ( matype1 & DVB_S2_BB_TSGS_MASK ) { case DVB_S2_BB_TSGS_GENERIC_CONTINUOUS : if ( BIT_IS_SET ( matype1 , DVB_S2_BB_ISSYI_POS ) ) { expert_add_info ( pinfo , ti , & ei_dvb_s2_bb_issy_invalid ) ; } if ( BIT_IS_SET ( matype1 , DVB_S2_BB_NPD_POS ) ) { expert_add_info ( pinfo , ti , & ei_dvb_s2_bb_npd_invalid ) ; } if ( user_packet_length != 0x0000 ) { expert_add_info_format ( pinfo , ti , & ei_dvb_s2_bb_upl_invalid , \"UPL<S2SV_blank>is<S2SV_blank>0x%04x.<S2SV_blank>It<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0x0000<S2SV_blank>for<S2SV_blank>GSE<S2SV_blank>packets.\" , user_packet_length ) ; } if ( dvb_s2_df_dissection ) { while ( bb_data_len ) { if ( sync_flag == DVB_S2_BB_SYNC_EIP_CRC32 && bb_data_len == DVB_S2_BB_EIP_CRC32_LEN ) { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_eip_crc32 , tvb , cur_off + new_off , bb_data_len , ENC_NA ) ; bb_data_len = 0 ; new_off += DVB_S2_BB_EIP_CRC32_LEN ; } else { sub_dissected = dissect_dvb_s2_gse ( tvb , cur_off + new_off , tree , pinfo , bb_data_len ) ; new_off += sub_dissected ; if ( ( sub_dissected <= bb_data_len ) && ( sub_dissected >= DVB_S2_GSE_MINSIZE ) ) { bb_data_len -= sub_dissected ; if ( bb_data_len < DVB_S2_GSE_MINSIZE ) bb_data_len = 0 ; <S2SV_StartBug> } <S2SV_EndBug> } } } else { proto_tree_add_item ( dvb_s2_bb_tree , hf_dvb_s2_bb_df , tvb , cur_off + new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; } break ; case DVB_S2_BB_TSGS_GENERIC_PACKETIZED : proto_tree_add_item ( tree , hf_dvb_s2_bb_packetized , tvb , cur_off + new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; break ; case DVB_S2_BB_TSGS_TRANSPORT_STREAM : proto_tree_add_item ( tree , hf_dvb_s2_bb_transport , tvb , cur_off + new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; break ; default : proto_tree_add_item ( tree , hf_dvb_s2_bb_reserved , tvb , cur_off + new_off , bb_data_len , ENC_NA ) ; new_off += bb_data_len ; expert_add_info ( pinfo , ti , & ei_dvb_s2_bb_reserved ) ; break ; } return new_off ; }", "target": "<S2SV_ModStart> 0 ; } else { bb_data_len = 0 ; }"}
{"source": "CWE-369 static void inline ConvertXYZToJzazbz ( const double X , const double Y , const double Z , const double white_luminance , double * Jz , double * az , double * bz ) { # define Jzazbz_b 1.15 # define Jzazbz_g 0.66 # define Jzazbz_c1 ( 3424.0 / 4096.0 ) # define Jzazbz_c2 ( 2413.0 / 128.0 ) # define Jzazbz_c3 ( 2392.0 / 128.0 ) # define Jzazbz_n ( 2610.0 / 16384.0 ) # define Jzazbz_p ( 1.7 * 2523.0 / 32.0 ) # define Jzazbz_d ( - 0.56 ) # define Jzazbz_d0 ( 1.6295499532821566e-11 ) double gamma , Iz , L , Lp , M , Mp , S , Sp , Xp , Yp , Zp ; Xp = ( Jzazbz_b * X - Z * ( Jzazbz_b - 1 ) ) ; Yp = ( Jzazbz_g * Y - X * ( Jzazbz_g - 1 ) ) ; Zp = Z ; L = 0.41478972 * Xp + 0.579999 * Yp + 0.0146480 * Zp ; M = ( - 0.2015100 ) * Xp + 1.120649 * Yp + 0.0531008 * Zp ; S = ( - 0.0166008 ) * Xp + 0.264800 * Yp + 0.6684799 * Zp ; <S2SV_StartBug> gamma = pow ( L / white_luminance , Jzazbz_n ) ; <S2SV_EndBug> Lp = pow ( ( Jzazbz_c1 + Jzazbz_c2 * gamma ) / ( 1.0 + Jzazbz_c3 * gamma ) , Jzazbz_p ) ; <S2SV_StartBug> gamma = pow ( M / white_luminance , Jzazbz_n ) ; <S2SV_EndBug> Mp = pow ( ( Jzazbz_c1 + Jzazbz_c2 * gamma ) / ( 1.0 + Jzazbz_c3 * gamma ) , Jzazbz_p ) ; <S2SV_StartBug> gamma = pow ( S / white_luminance , Jzazbz_n ) ; <S2SV_EndBug> Sp = pow ( ( Jzazbz_c1 + Jzazbz_c2 * gamma ) / ( 1.0 + Jzazbz_c3 * gamma ) , Jzazbz_p ) ; Iz = 0.5 * Lp + 0.5 * Mp ; * az = 3.52400 * Lp - 4.066708 * Mp + 0.542708 * Sp + 0.5 ; * bz = 0.199076 * Lp + 1.096799 * Mp - 1.295875 * Sp + 0.5 ; * Jz = ( ( Jzazbz_d + 1.0 ) * Iz ) / ( Jzazbz_d * Iz + 1.0 ) - Jzazbz_d0 ; }", "target": "<S2SV_ModStart> pow ( L * PerceptibleReciprocal ( white_luminance ) <S2SV_ModEnd> , Jzazbz_n ) <S2SV_ModStart> pow ( M * PerceptibleReciprocal ( white_luminance ) <S2SV_ModEnd> , Jzazbz_n ) <S2SV_ModStart> pow ( S * PerceptibleReciprocal ( white_luminance ) <S2SV_ModEnd> , Jzazbz_n )"}
{"source": "CWE-835 static void dp8393x_do_transmit_packets ( dp8393xState * s ) { NetClientState * nc = qemu_get_queue ( s -> nic ) ; int width , size ; int tx_len , len ; uint16_t i ; width = ( s -> regs [ SONIC_DCR ] & SONIC_DCR_DW ) ? 2 : 1 ; while ( 1 ) { size = sizeof ( uint16_t ) * 6 * width ; s -> regs [ SONIC_TTDA ] = s -> regs [ SONIC_CTDA ] ; DPRINTF ( \"Transmit<S2SV_blank>packet<S2SV_blank>at<S2SV_blank>%08x\\\\n\" , dp8393x_ttda ( s ) ) ; address_space_read ( & s -> as , dp8393x_ttda ( s ) + sizeof ( uint16_t ) * width , MEMTXATTRS_UNSPECIFIED , s -> data , size ) ; tx_len = 0 ; s -> regs [ SONIC_TCR ] = dp8393x_get ( s , width , 0 ) & 0xf000 ; s -> regs [ SONIC_TPS ] = dp8393x_get ( s , width , 1 ) ; s -> regs [ SONIC_TFC ] = dp8393x_get ( s , width , 2 ) ; s -> regs [ SONIC_TSA0 ] = dp8393x_get ( s , width , 3 ) ; s -> regs [ SONIC_TSA1 ] = dp8393x_get ( s , width , 4 ) ; s -> regs [ SONIC_TFS ] = dp8393x_get ( s , width , 5 ) ; if ( s -> regs [ SONIC_TCR ] & SONIC_TCR_PINT ) { s -> regs [ SONIC_ISR ] |= SONIC_ISR_PINT ; } else { s -> regs [ SONIC_ISR ] &= ~ SONIC_ISR_PINT ; } for ( i = 0 ; i < s -> regs [ SONIC_TFC ] ; ) { len = s -> regs [ SONIC_TFS ] ; if ( tx_len + len > sizeof ( s -> tx_buffer ) ) { len = sizeof ( s -> tx_buffer ) - tx_len ; } address_space_read ( & s -> as , dp8393x_tsa ( s ) , MEMTXATTRS_UNSPECIFIED , & s -> tx_buffer [ tx_len ] , len ) ; tx_len += len ; i ++ ; if ( i != s -> regs [ SONIC_TFC ] ) { size = sizeof ( uint16_t ) * 3 * width ; address_space_read ( & s -> as , dp8393x_ttda ( s ) + sizeof ( uint16_t ) * width * ( 4 + 3 * i ) , MEMTXATTRS_UNSPECIFIED , s -> data , size ) ; s -> regs [ SONIC_TSA0 ] = dp8393x_get ( s , width , 0 ) ; s -> regs [ SONIC_TSA1 ] = dp8393x_get ( s , width , 1 ) ; s -> regs [ SONIC_TFS ] = dp8393x_get ( s , width , 2 ) ; } } if ( ! ( s -> regs [ SONIC_TCR ] & SONIC_TCR_CRCI ) ) { } else { tx_len -= 4 ; if ( tx_len < 0 ) { SONIC_ERROR ( \"tx_len<S2SV_blank>is<S2SV_blank>%d\\\\n\" , tx_len ) ; break ; } } if ( s -> regs [ SONIC_RCR ] & ( SONIC_RCR_LB1 | SONIC_RCR_LB0 ) ) { s -> regs [ SONIC_TCR ] |= SONIC_TCR_CRSL ; if ( nc -> info -> can_receive ( nc ) ) { s -> loopback_packet = 1 ; <S2SV_StartBug> nc -> info -> receive ( nc , s -> tx_buffer , tx_len ) ; <S2SV_EndBug> } } else { qemu_send_packet ( nc , s -> tx_buffer , tx_len ) ; } s -> regs [ SONIC_TCR ] |= SONIC_TCR_PTX ; dp8393x_put ( s , width , 0 , s -> regs [ SONIC_TCR ] & 0x0fff ) ; size = sizeof ( uint16_t ) * width ; address_space_write ( & s -> as , dp8393x_ttda ( s ) , MEMTXATTRS_UNSPECIFIED , s -> data , size ) ; if ( ! ( s -> regs [ SONIC_CR ] & SONIC_CR_HTX ) ) { size = sizeof ( uint16_t ) * width ; address_space_read ( & s -> as , dp8393x_ttda ( s ) + sizeof ( uint16_t ) * width * ( 4 + 3 * s -> regs [ SONIC_TFC ] ) , MEMTXATTRS_UNSPECIFIED , s -> data , size ) ; s -> regs [ SONIC_CTDA ] = dp8393x_get ( s , width , 0 ) ; if ( s -> regs [ SONIC_CTDA ] & SONIC_DESC_EOL ) { break ; } } } s -> regs [ SONIC_CR ] &= ~ SONIC_CR_TXP ; s -> regs [ SONIC_ISR ] |= SONIC_ISR_TXDN ; dp8393x_update_irq ( s ) ; }", "target": "<S2SV_ModStart> = 1 ; qemu_receive_packet <S2SV_ModEnd> ( nc ,"}
{"source": "CWE-295 int main ( int argc , char * * argv , char * * envp ) { # ifdef DYNLOAD if ( ! uc_dyn_load ( NULL , 0 ) ) { printf ( \"Error<S2SV_blank>dynamically<S2SV_blank>loading<S2SV_blank>shared<S2SV_blank>library.\\\\n\" ) ; printf ( \"Please<S2SV_blank>check<S2SV_blank>that<S2SV_blank>unicorn.dll/unicorn.so<S2SV_blank>is<S2SV_blank>available<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as\\\\n\" ) ; printf ( \"any<S2SV_blank>other<S2SV_blank>dependent<S2SV_blank>dll/so<S2SV_blank>files.\\\\n\" ) ; printf ( \"The<S2SV_blank>easiest<S2SV_blank>way<S2SV_blank>is<S2SV_blank>to<S2SV_blank>place<S2SV_blank>them<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>directory<S2SV_blank>as<S2SV_blank>this<S2SV_blank>app.\\\\n\" ) ; return 1 ; } # endif test_arm ( ) ; printf ( \"==========================\\\\n\" ) ; test_thumb ( ) ; <S2SV_StartBug> <S2SV_EndBug> # ifdef DYNLOAD uc_dyn_free ( ) ; # endif return 0 ; }", "target": "<S2SV_ModStart> ( ) ; printf ( \"==========================\\\\n\" ) ; test_thumb_ite ( ) ;"}
{"source": "CWE-327 static bool l2cap_check_enc_key_size ( struct hci_conn * hcon ) { return ( ! test_bit ( HCI_CONN_ENCRYPT , & hcon -> flags ) || <S2SV_StartBug> hcon -> enc_key_size > HCI_MIN_ENC_KEY_SIZE ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> hcon -> enc_key_size >= <S2SV_ModEnd> HCI_MIN_ENC_KEY_SIZE ) ;"}
{"source": "CWE-190 spell_read_tree ( FILE * fd , char_u * * bytsp , idx_T * * idxsp , int prefixtree , int prefixcnt ) { int len ; int idx ; char_u * bp ; idx_T * ip ; len = get4c ( fd ) ; if ( len < 0 ) <S2SV_StartBug> return SP_TRUNCERROR ; <S2SV_EndBug> if ( len > 0 ) { bp = lalloc ( ( long_u ) len , TRUE ) ; if ( bp == NULL ) return SP_OTHERERROR ; * bytsp = bp ; ip = ( idx_T * ) lalloc_clear ( ( long_u ) ( len * sizeof ( int ) ) , TRUE ) ; if ( ip == NULL ) return SP_OTHERERROR ; * idxsp = ip ; idx = read_tree_node ( fd , bp , ip , len , 0 , prefixtree , prefixcnt ) ; if ( idx < 0 ) return idx ; } return 0 ; }", "target": "<S2SV_ModStart> ) return SP_TRUNCERROR ; if ( len >= 0x3ffffff ) return SP_FORMERROR"}
{"source": "CWE-310 static void host_callback ( void * arg , int status , int timeouts , unsigned char * abuf , int alen ) { struct host_query * hquery = ( struct host_query * ) arg ; int addinfostatus = ARES_SUCCESS ; hquery -> timeouts += timeouts ; hquery -> remaining -- ; if ( status == ARES_SUCCESS ) { addinfostatus = ares__parse_into_addrinfo ( abuf , alen , hquery -> ai ) ; } else if ( status == ARES_EDESTRUCTION ) { end_hquery ( hquery , status ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! hquery -> remaining ) { if ( addinfostatus != ARES_SUCCESS ) { end_hquery ( hquery , addinfostatus ) ; } else if ( hquery -> ai -> nodes ) { end_hquery ( hquery , ARES_SUCCESS ) ; } else if ( status == ARES_ENOTFOUND ) { next_lookup ( hquery , status ) ; } else { end_hquery ( hquery , status ) ; } } }", "target": "<S2SV_ModStart> status ) ; return ;"}
{"source": "CWE-787 opj_image_t * pngtoimage ( const char * read_idf , opj_cparameters_t * params ) { png_structp png = NULL ; png_infop info = NULL ; double gamma ; int bit_depth , interlace_type , compression_type , filter_type ; OPJ_UINT32 i ; png_uint_32 width , height = 0U ; int color_type ; FILE * reader = NULL ; OPJ_BYTE * * rows = NULL ; OPJ_INT32 * row32s = NULL ; opj_image_t * image = NULL ; opj_image_cmptparm_t cmptparm [ 4 ] ; OPJ_UINT32 nr_comp ; OPJ_BYTE sigbuf [ 8 ] ; convert_XXx32s_C1R cvtXXTo32s = NULL ; convert_32s_CXPX cvtCxToPx = NULL ; OPJ_INT32 * planes [ 4 ] ; if ( ( reader = fopen ( read_idf , \"rb\" ) ) == NULL ) { fprintf ( stderr , \"pngtoimage:<S2SV_blank>can<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%s\\\\n\" , read_idf ) ; return NULL ; } if ( fread ( sigbuf , 1 , MAGIC_SIZE , reader ) != MAGIC_SIZE || memcmp ( sigbuf , PNG_MAGIC , MAGIC_SIZE ) != 0 ) { fprintf ( stderr , \"pngtoimage:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>no<S2SV_blank>valid<S2SV_blank>PNG<S2SV_blank>file\\\\n\" , read_idf ) ; goto fin ; } if ( ( png = png_create_read_struct ( PNG_LIBPNG_VER_STRING , NULL , NULL , NULL ) ) == NULL ) { goto fin ; } if ( ( info = png_create_info_struct ( png ) ) == NULL ) { goto fin ; } if ( setjmp ( png_jmpbuf ( png ) ) ) { goto fin ; } png_init_io ( png , reader ) ; png_set_sig_bytes ( png , MAGIC_SIZE ) ; png_read_info ( png , info ) ; if ( png_get_IHDR ( png , info , & width , & height , & bit_depth , & color_type , & interlace_type , & compression_type , & filter_type ) == 0 ) { goto fin ; } if ( color_type == PNG_COLOR_TYPE_PALETTE ) { png_set_expand ( png ) ; } if ( png_get_valid ( png , info , PNG_INFO_tRNS ) ) { png_set_expand ( png ) ; } if ( ! png_get_gAMA ( png , info , & gamma ) ) { gamma = 1.0 ; } png_set_gamma ( png , 1.0 , gamma ) ; png_read_update_info ( png , info ) ; color_type = png_get_color_type ( png , info ) ; switch ( color_type ) { case PNG_COLOR_TYPE_GRAY : nr_comp = 1 ; break ; case PNG_COLOR_TYPE_GRAY_ALPHA : nr_comp = 2 ; break ; case PNG_COLOR_TYPE_RGB : nr_comp = 3 ; break ; case PNG_COLOR_TYPE_RGB_ALPHA : nr_comp = 4 ; break ; default : fprintf ( stderr , \"pngtoimage:<S2SV_blank>colortype<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\\\n\" , color_type ) ; goto fin ; } cvtCxToPx = convert_32s_CXPX_LUT [ nr_comp ] ; bit_depth = png_get_bit_depth ( png , info ) ; switch ( bit_depth ) { case 1 : case 2 : case 4 : case 8 : cvtXXTo32s = convert_XXu32s_C1R_LUT [ bit_depth ] ; break ; case 16 : cvtXXTo32s = convert_16u32s_C1R ; break ; default : fprintf ( stderr , \"pngtoimage:<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\\\n\" , bit_depth ) ; goto fin ; } rows = ( OPJ_BYTE * * ) calloc ( height + 1 , sizeof ( OPJ_BYTE * ) ) ; if ( rows == NULL ) { fprintf ( stderr , \"pngtoimage:<S2SV_blank>memory<S2SV_blank>out\\\\n\" ) ; goto fin ; } for ( i = 0 ; i < height ; ++ i ) { rows [ i ] = ( OPJ_BYTE * ) malloc ( png_get_rowbytes ( png , info ) ) ; if ( rows [ i ] == NULL ) { fprintf ( stderr , \"pngtoimage:<S2SV_blank>memory<S2SV_blank>out\\\\n\" ) ; goto fin ; } } png_read_image ( png , rows ) ; memset ( cmptparm , 0 , sizeof ( cmptparm ) ) ; for ( i = 0 ; i < nr_comp ; ++ i ) { cmptparm [ i ] . prec = ( OPJ_UINT32 ) bit_depth ; cmptparm [ i ] . bpp = ( OPJ_UINT32 ) bit_depth ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) params -> subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) params -> subsampling_dy ; cmptparm [ i ] . w = ( OPJ_UINT32 ) width ; cmptparm [ i ] . h = ( OPJ_UINT32 ) height ; } image = opj_image_create ( nr_comp , & cmptparm [ 0 ] , ( nr_comp > 2U ) ? OPJ_CLRSPC_SRGB : OPJ_CLRSPC_GRAY ) ; if ( image == NULL ) { goto fin ; } image -> x0 = ( OPJ_UINT32 ) params -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) params -> image_offset_y0 ; image -> x1 = ( OPJ_UINT32 ) ( image -> x0 + ( width - 1 ) * ( OPJ_UINT32 ) <S2SV_StartBug> params -> subsampling_dx + 1 + image -> x0 ) ; <S2SV_EndBug> image -> y1 = ( OPJ_UINT32 ) ( image -> y0 + ( height - 1 ) * ( OPJ_UINT32 ) <S2SV_StartBug> params -> subsampling_dy + 1 + image -> y0 ) ; <S2SV_EndBug> row32s = ( OPJ_INT32 * ) malloc ( ( size_t ) width * nr_comp * sizeof ( OPJ_INT32 ) ) ; if ( row32s == NULL ) { goto fin ; } image -> comps [ nr_comp - 1U ] . alpha = 1U - ( nr_comp & 1U ) ; for ( i = 0 ; i < nr_comp ; i ++ ) { planes [ i ] = image -> comps [ i ] . data ; } for ( i = 0 ; i < height ; ++ i ) { cvtXXTo32s ( rows [ i ] , row32s , ( OPJ_SIZE_T ) width * nr_comp ) ; cvtCxToPx ( row32s , planes , width ) ; planes [ 0 ] += width ; planes [ 1 ] += width ; planes [ 2 ] += width ; planes [ 3 ] += width ; } fin : if ( rows ) { for ( i = 0 ; i < height ; ++ i ) if ( rows [ i ] ) { free ( rows [ i ] ) ; } free ( rows ) ; } if ( row32s ) { free ( row32s ) ; } if ( png ) { png_destroy_read_struct ( & png , & info , NULL ) ; } fclose ( reader ) ; return image ; }", "target": "<S2SV_ModStart> subsampling_dx + 1 <S2SV_ModEnd> ) ; image <S2SV_ModStart> subsampling_dy + 1 <S2SV_ModEnd> ) ; row32s"}
{"source": "CWE-200 static void slc_bump ( struct slcan * sl ) { struct sk_buff * skb ; struct can_frame cf ; int i , tmp ; u32 tmpid ; char * cmd = sl -> rbuff ; <S2SV_StartBug> cf . can_id = 0 ; <S2SV_EndBug> switch ( * cmd ) { case 'r' : cf . can_id = CAN_RTR_FLAG ; case 't' : cf . can_dlc = sl -> rbuff [ SLC_CMD_LEN + SLC_SFF_ID_LEN ] ; sl -> rbuff [ SLC_CMD_LEN + SLC_SFF_ID_LEN ] = 0 ; cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1 ; break ; case 'R' : cf . can_id = CAN_RTR_FLAG ; case 'T' : cf . can_id |= CAN_EFF_FLAG ; cf . can_dlc = sl -> rbuff [ SLC_CMD_LEN + SLC_EFF_ID_LEN ] ; sl -> rbuff [ SLC_CMD_LEN + SLC_EFF_ID_LEN ] = 0 ; cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1 ; break ; default : return ; } if ( kstrtou32 ( sl -> rbuff + SLC_CMD_LEN , 16 , & tmpid ) ) return ; cf . can_id |= tmpid ; if ( cf . can_dlc >= '0' && cf . can_dlc < '9' ) cf . can_dlc -= '0' ; else return ; <S2SV_StartBug> * ( u64 * ) ( & cf . data ) = 0 ; <S2SV_EndBug> if ( ! ( cf . can_id & CAN_RTR_FLAG ) ) { for ( i = 0 ; i < cf . can_dlc ; i ++ ) { tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] = ( tmp << 4 ) ; tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] |= tmp ; } } skb = dev_alloc_skb ( sizeof ( struct can_frame ) + sizeof ( struct can_skb_priv ) ) ; if ( ! skb ) return ; skb -> dev = sl -> dev ; skb -> protocol = htons ( ETH_P_CAN ) ; skb -> pkt_type = PACKET_BROADCAST ; skb -> ip_summed = CHECKSUM_UNNECESSARY ; can_skb_reserve ( skb ) ; can_skb_prv ( skb ) -> ifindex = sl -> dev -> ifindex ; can_skb_prv ( skb ) -> skbcnt = 0 ; skb_put_data ( skb , & cf , sizeof ( struct can_frame ) ) ; sl -> dev -> stats . rx_packets ++ ; sl -> dev -> stats . rx_bytes += cf . can_dlc ; netif_rx_ni ( skb ) ; }", "target": "<S2SV_ModStart> -> rbuff ; memset ( & cf , 0 , sizeof ( cf ) ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> else return ; <S2SV_ModEnd> if ( !"}
{"source": "CWE-787 static unsigned int xdr_set_page_base ( struct xdr_stream * xdr , unsigned int base , unsigned int len ) { unsigned int pgnr ; unsigned int maxlen ; unsigned int pgoff ; unsigned int pgend ; void * kaddr ; maxlen = xdr -> buf -> page_len ; <S2SV_StartBug> if ( base >= maxlen ) { <S2SV_EndBug> base = maxlen ; maxlen = 0 ; } else maxlen -= base ; if ( len > maxlen ) len = maxlen ; xdr_stream_page_set_pos ( xdr , base ) ; base += xdr -> buf -> page_base ; pgnr = base >> PAGE_SHIFT ; xdr -> page_ptr = & xdr -> buf -> pages [ pgnr ] ; kaddr = page_address ( * xdr -> page_ptr ) ; pgoff = base & ~ PAGE_MASK ; xdr -> p = ( __be32 * ) ( kaddr + pgoff ) ; pgend = pgoff + len ; if ( pgend > PAGE_SIZE ) pgend = PAGE_SIZE ; xdr -> end = ( __be32 * ) ( kaddr + pgend ) ; xdr -> iov = NULL ; return len ; }", "target": "<S2SV_ModStart> >= maxlen ) return 0 ; <S2SV_ModEnd> else maxlen -="}
{"source": "CWE-200 static void suboption ( struct Curl_easy * data ) { struct curl_slist * v ; unsigned char temp [ 2048 ] ; ssize_t bytes_written ; size_t len ; int err ; char varname [ 128 ] = \"\" ; char varval [ 128 ] = \"\" ; struct TELNET * tn = data -> req . p . telnet ; struct connectdata * conn = data -> conn ; printsub ( data , '<' , ( unsigned char * ) tn -> subbuffer , CURL_SB_LEN ( tn ) + 2 ) ; switch ( CURL_SB_GET ( tn ) ) { case CURL_TELOPT_TTYPE : len = strlen ( tn -> subopt_ttype ) + 4 + 2 ; msnprintf ( ( char * ) temp , sizeof ( temp ) , \"%c%c%c%c%s%c%c\" , CURL_IAC , CURL_SB , CURL_TELOPT_TTYPE , CURL_TELQUAL_IS , tn -> subopt_ttype , CURL_IAC , CURL_SE ) ; bytes_written = swrite ( conn -> sock [ FIRSTSOCKET ] , temp , len ) ; if ( bytes_written < 0 ) { err = SOCKERRNO ; failf ( data , \"Sending<S2SV_blank>data<S2SV_blank>failed<S2SV_blank>(%d)\" , err ) ; } printsub ( data , '>' , & temp [ 2 ] , len - 2 ) ; break ; case CURL_TELOPT_XDISPLOC : len = strlen ( tn -> subopt_xdisploc ) + 4 + 2 ; msnprintf ( ( char * ) temp , sizeof ( temp ) , \"%c%c%c%c%s%c%c\" , CURL_IAC , CURL_SB , CURL_TELOPT_XDISPLOC , CURL_TELQUAL_IS , tn -> subopt_xdisploc , CURL_IAC , CURL_SE ) ; bytes_written = swrite ( conn -> sock [ FIRSTSOCKET ] , temp , len ) ; if ( bytes_written < 0 ) { err = SOCKERRNO ; failf ( data , \"Sending<S2SV_blank>data<S2SV_blank>failed<S2SV_blank>(%d)\" , err ) ; } printsub ( data , '>' , & temp [ 2 ] , len - 2 ) ; break ; case CURL_TELOPT_NEW_ENVIRON : msnprintf ( ( char * ) temp , sizeof ( temp ) , \"%c%c%c%c\" , CURL_IAC , CURL_SB , CURL_TELOPT_NEW_ENVIRON , CURL_TELQUAL_IS ) ; len = 4 ; for ( v = tn -> telnet_vars ; v ; v = v -> next ) { size_t tmplen = ( strlen ( v -> data ) + 1 ) ; if ( len + tmplen < ( int ) sizeof ( temp ) - 6 ) { <S2SV_StartBug> if ( sscanf ( v -> data , \"%127[^,],%127s\" , varname , varval ) ) { <S2SV_EndBug> msnprintf ( ( char * ) & temp [ len ] , sizeof ( temp ) - len , \"%c%s%c%s\" , CURL_NEW_ENV_VAR , varname , CURL_NEW_ENV_VALUE , varval ) ; len += tmplen ; } } } msnprintf ( ( char * ) & temp [ len ] , sizeof ( temp ) - len , \"%c%c\" , CURL_IAC , CURL_SE ) ; len += 2 ; bytes_written = swrite ( conn -> sock [ FIRSTSOCKET ] , temp , len ) ; if ( bytes_written < 0 ) { err = SOCKERRNO ; failf ( data , \"Sending<S2SV_blank>data<S2SV_blank>failed<S2SV_blank>(%d)\" , err ) ; } printsub ( data , '>' , & temp [ 2 ] , len - 2 ) ; break ; } return ; }", "target": "<S2SV_ModStart> , varval ) == 2"}
{"source": "CWE-787 void LibRaw : : identify_process_dng_fields ( ) { if ( ! dng_version ) return ; int c ; { int iifd = find_ifd_by_offset ( data_offset ) ; int pifd = find_ifd_by_offset ( thumb_offset ) ; # define CFAROUND ( value , filters ) filters ? ( filters >= 1000 ? ( ( value + 1 ) / 2 ) * 2 : ( ( value + 5 ) / 6 ) * 6 ) : value # define IFDCOLORINDEX ( ifd , subset , bit ) ( tiff_ifd [ ifd ] . dng_color [ subset ] . parsedfields & bit ) ? ifd : ( ( tiff_ifd [ 0 ] . dng_color [ subset ] . parsedfields & bit ) ? 0 : - 1 ) # define IFDLEVELINDEX ( ifd , bit ) ( tiff_ifd [ ifd ] . dng_levels . parsedfields & bit ) ? ifd : ( ( tiff_ifd [ 0 ] . dng_levels . parsedfields & bit ) ? 0 : - 1 ) # define COPYARR ( to , from ) memmove ( & to , & from , sizeof ( from ) ) if ( iifd < ( int ) tiff_nifds && iifd >= 0 ) { int sidx ; if ( ! ( imgdata . params . raw_processing_options & LIBRAW_PROCESSING_DONT_CHECK_DNG_ILLUMINANT ) ) { int illidx [ 2 ] , cmidx [ 2 ] , calidx [ 2 ] , abidx ; for ( int i = 0 ; i < 2 ; i ++ ) { illidx [ i ] = IFDCOLORINDEX ( iifd , i , LIBRAW_DNGFM_ILLUMINANT ) ; cmidx [ i ] = IFDCOLORINDEX ( iifd , i , LIBRAW_DNGFM_COLORMATRIX ) ; calidx [ i ] = IFDCOLORINDEX ( iifd , i , LIBRAW_DNGFM_CALIBRATION ) ; } abidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_ANALOGBALANCE ) ; if ( illidx [ 0 ] >= 0 && illidx [ 0 ] < ( int ) tiff_nifds && illidx [ 0 ] == illidx [ 1 ] && illidx [ 0 ] == cmidx [ 0 ] && illidx [ 0 ] == cmidx [ 1 ] && tiff_ifd [ illidx [ 0 ] ] . dng_color [ 0 ] . illuminant > 0 && tiff_ifd [ illidx [ 0 ] ] . dng_color [ 1 ] . illuminant > 0 ) { sidx = illidx [ 0 ] ; double cc [ 4 ] [ 4 ] , cm [ 4 ] [ 3 ] , cam_xyz [ 4 ] [ 3 ] ; for ( int j = 0 ; j < 4 ; j ++ ) for ( int i = 0 ; i < 4 ; i ++ ) cc [ j ] [ i ] = i == j ; int colidx = - 1 ; for ( int i = 0 ; i < 2 ; i ++ ) { if ( tiff_ifd [ sidx ] . dng_color [ i ] . illuminant == LIBRAW_WBI_D65 ) { colidx = i ; break ; } } if ( colidx < 0 ) for ( int i = 0 ; i < 2 ; i ++ ) { int ill = tiff_ifd [ sidx ] . dng_color [ i ] . illuminant ; if ( ill == LIBRAW_WBI_Daylight || ill == LIBRAW_WBI_D55 || ill == LIBRAW_WBI_D75 || ill == LIBRAW_WBI_D50 || ill == LIBRAW_WBI_Flash ) { colidx = i ; break ; } } if ( colidx >= 0 ) { FORCC for ( int j = 0 ; j < 3 ; j ++ ) cm [ c ] [ j ] = tiff_ifd [ sidx ] . dng_color [ colidx ] . colormatrix [ c ] [ j ] ; if ( calidx [ colidx ] == sidx ) { <S2SV_StartBug> for ( int i = 0 ; i < colors ; i ++ ) <S2SV_EndBug> FORCC cc [ i ] [ c ] = tiff_ifd [ sidx ] . dng_color [ colidx ] . calibration [ i ] [ c ] ; } if ( abidx == sidx ) <S2SV_StartBug> for ( int i = 0 ; i < colors ; i ++ ) <S2SV_EndBug> FORCC cc [ i ] [ c ] *= tiff_ifd [ sidx ] . dng_levels . analogbalance [ i ] ; int j ; FORCC for ( int i = 0 ; i < 3 ; i ++ ) for ( cam_xyz [ c ] [ i ] = j = 0 ; <S2SV_StartBug> j < colors ; j ++ ) <S2SV_EndBug> cam_xyz [ c ] [ i ] += cc [ c ] [ j ] * cm [ j ] [ i ] ; cam_xyz_coeff ( cmatrix , cam_xyz ) ; } } } bool noFujiDNGCrop = makeIs ( LIBRAW_CAMERAMAKER_Fujifilm ) && ( ! strcmp ( normalized_model , \"S3Pro\" ) || ! strcmp ( normalized_model , \"S5Pro\" ) || ! strcmp ( normalized_model , \"S2Pro\" ) ) ; if ( ! noFujiDNGCrop && ( imgdata . params . raw_processing_options & LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP ) ) { sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_CROPORIGIN ) ; int sidx2 = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_CROPSIZE ) ; if ( sidx >= 0 && sidx == sidx2 && tiff_ifd [ sidx ] . dng_levels . default_crop [ 2 ] > 0 && tiff_ifd [ sidx ] . dng_levels . default_crop [ 3 ] > 0 ) { int lm = tiff_ifd [ sidx ] . dng_levels . default_crop [ 0 ] ; int lmm = CFAROUND ( lm , filters ) ; int tm = tiff_ifd [ sidx ] . dng_levels . default_crop [ 1 ] ; int tmm = CFAROUND ( tm , filters ) ; int ww = tiff_ifd [ sidx ] . dng_levels . default_crop [ 2 ] ; int hh = tiff_ifd [ sidx ] . dng_levels . default_crop [ 3 ] ; if ( lmm > lm ) ww -= ( lmm - lm ) ; if ( tmm > tm ) hh -= ( tmm - tm ) ; if ( left_margin + lm + ww <= raw_width && top_margin + tm + hh <= raw_height ) { left_margin += lmm ; top_margin += tmm ; width = ww ; height = hh ; } } } if ( ! ( imgdata . color . dng_color [ 0 ] . parsedfields & LIBRAW_DNGFM_FORWARDMATRIX ) ) { sidx = IFDCOLORINDEX ( iifd , 0 , LIBRAW_DNGFM_FORWARDMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ 0 ] . forwardmatrix , tiff_ifd [ sidx ] . dng_color [ 0 ] . forwardmatrix ) ; } if ( ! ( imgdata . color . dng_color [ 1 ] . parsedfields & LIBRAW_DNGFM_FORWARDMATRIX ) ) { sidx = IFDCOLORINDEX ( iifd , 1 , LIBRAW_DNGFM_FORWARDMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ 1 ] . forwardmatrix , tiff_ifd [ sidx ] . dng_color [ 1 ] . forwardmatrix ) ; } for ( int ss = 0 ; ss < 2 ; ss ++ ) { sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_COLORMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ ss ] . colormatrix , tiff_ifd [ sidx ] . dng_color [ ss ] . colormatrix ) ; sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_CALIBRATION ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ ss ] . calibration , tiff_ifd [ sidx ] . dng_color [ ss ] . calibration ) ; sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_ILLUMINANT ) ; if ( sidx >= 0 ) imgdata . color . dng_color [ ss ] . illuminant = tiff_ifd [ sidx ] . dng_color [ ss ] . illuminant ; } sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_ANALOGBALANCE ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_levels . analogbalance , tiff_ifd [ sidx ] . dng_levels . analogbalance ) ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_BASELINEEXPOSURE ) ; if ( sidx >= 0 ) imgdata . color . dng_levels . baseline_exposure = tiff_ifd [ sidx ] . dng_levels . baseline_exposure ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_WHITE ) ; if ( sidx >= 0 && tiff_ifd [ sidx ] . dng_levels . dng_whitelevel [ 0 ] ) COPYARR ( imgdata . color . dng_levels . dng_whitelevel , tiff_ifd [ sidx ] . dng_levels . dng_whitelevel ) ; else if ( tiff_ifd [ iifd ] . sample_format <= 2 && tiff_ifd [ iifd ] . bps > 0 && tiff_ifd [ iifd ] . bps < 32 ) FORC4 imgdata . color . dng_levels . dng_whitelevel [ c ] = ( 1 << tiff_ifd [ iifd ] . bps ) - 1 ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_ASSHOTNEUTRAL ) ; if ( sidx >= 0 ) { COPYARR ( imgdata . color . dng_levels . asshotneutral , tiff_ifd [ sidx ] . dng_levels . asshotneutral ) ; if ( imgdata . color . dng_levels . asshotneutral [ 0 ] ) { cam_mul [ 3 ] = 0 ; FORCC if ( fabs ( imgdata . color . dng_levels . asshotneutral [ c ] ) > 0.0001 ) cam_mul [ c ] = 1 / imgdata . color . dng_levels . asshotneutral [ c ] ; } } sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_BLACK ) ; if ( sidx >= 0 ) { imgdata . color . dng_levels . dng_fblack = tiff_ifd [ sidx ] . dng_levels . dng_fblack ; imgdata . color . dng_levels . dng_black = tiff_ifd [ sidx ] . dng_levels . dng_black ; COPYARR ( imgdata . color . dng_levels . dng_cblack , tiff_ifd [ sidx ] . dng_levels . dng_cblack ) ; COPYARR ( imgdata . color . dng_levels . dng_fcblack , tiff_ifd [ sidx ] . dng_levels . dng_fcblack ) ; } if ( pifd >= 0 ) { sidx = IFDLEVELINDEX ( pifd , LIBRAW_DNGFM_PREVIEWCS ) ; if ( sidx >= 0 ) imgdata . color . dng_levels . preview_colorspace = tiff_ifd [ sidx ] . dng_levels . preview_colorspace ; } sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_OPCODE2 ) ; if ( sidx >= 0 ) meta_offset = tiff_ifd [ sidx ] . opcode2_offset ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_LINTABLE ) ; INT64 linoff = - 1 ; int linlen = 0 ; if ( sidx >= 0 ) { linoff = tiff_ifd [ sidx ] . lineartable_offset ; linlen = tiff_ifd [ sidx ] . lineartable_len ; } if ( linoff >= 0 && linlen > 0 ) { INT64 pos = ftell ( ifp ) ; fseek ( ifp , linoff , SEEK_SET ) ; linear_table ( linlen ) ; fseek ( ifp , pos , SEEK_SET ) ; } } if ( load_raw == & LibRaw : : lossy_dng_load_raw ) { maximum = 0xffff ; FORC4 imgdata . color . linear_max [ c ] = imgdata . color . dng_levels . dng_whitelevel [ c ] = 0xffff ; } else { maximum = imgdata . color . dng_levels . dng_whitelevel [ 0 ] ; } black = imgdata . color . dng_levels . dng_black ; if ( tiff_samples == 2 && imgdata . color . dng_levels . dng_cblack [ 4 ] * imgdata . color . dng_levels . dng_cblack [ 5 ] * tiff_samples == imgdata . color . dng_levels . dng_cblack [ LIBRAW_CBLACK_SIZE - 1 ] ) { unsigned ff = filters ; if ( filters > 999 && colors == 3 ) filters |= ( ( filters >> 2 & 0x22222222 ) | ( filters << 2 & 0x88888888 ) ) & filters << 1 ; int csum [ 4 ] = { 0 , 0 , 0 , 0 } , ccount [ 4 ] = { 0 , 0 , 0 , 0 } ; int i = 6 + shot_select ; for ( unsigned row = 0 ; row < imgdata . color . dng_levels . dng_cblack [ 4 ] ; row ++ ) for ( unsigned col = 0 ; col < imgdata . color . dng_levels . dng_cblack [ 5 ] ; col ++ ) { csum [ FC ( row , col ) ] += imgdata . color . dng_levels . dng_cblack [ i ] ; ccount [ FC ( row , col ) ] ++ ; i += tiff_samples ; } for ( int c = 0 ; c < 4 ; c ++ ) if ( ccount [ c ] ) imgdata . color . dng_levels . dng_cblack [ c ] += csum [ c ] / ccount [ c ] ; imgdata . color . dng_levels . dng_cblack [ 4 ] = imgdata . color . dng_levels . dng_cblack [ 5 ] = 0 ; filters = ff ; } else if ( tiff_samples > 2 && tiff_samples <= 4 && imgdata . color . dng_levels . dng_cblack [ 4 ] * imgdata . color . dng_levels . dng_cblack [ 5 ] * tiff_samples == imgdata . color . dng_levels . dng_cblack [ LIBRAW_CBLACK_SIZE - 1 ] ) { int csum [ 4 ] = { 0 , 0 , 0 , 0 } , ccount [ 4 ] = { 0 , 0 , 0 , 0 } ; int i = 6 ; for ( unsigned row = 0 ; row < imgdata . color . dng_levels . dng_cblack [ 4 ] ; row ++ ) for ( unsigned col = 0 ; col < imgdata . color . dng_levels . dng_cblack [ 5 ] ; col ++ ) <S2SV_StartBug> for ( unsigned c = 0 ; c < tiff_samples ; c ++ ) <S2SV_EndBug> { csum [ c ] += imgdata . color . dng_levels . dng_cblack [ i ] ; ccount [ c ] ++ ; i ++ ; } for ( int c = 0 ; c < 4 ; c ++ ) if ( ccount [ c ] ) imgdata . color . dng_levels . dng_cblack [ c ] += csum [ c ] / ccount [ c ] ; imgdata . color . dng_levels . dng_cblack [ 4 ] = imgdata . color . dng_levels . dng_cblack [ 5 ] = 0 ; } memmove ( cblack , imgdata . color . dng_levels . dng_cblack , sizeof ( cblack ) ) ; if ( iifd < ( int ) tiff_nifds && iifd >= 0 ) { int sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_LINEARRESPONSELIMIT ) ; if ( sidx >= 0 ) { imgdata . color . dng_levels . LinearResponseLimit = tiff_ifd [ sidx ] . dng_levels . LinearResponseLimit ; if ( imgdata . color . dng_levels . LinearResponseLimit > 0.1 && imgdata . color . dng_levels . LinearResponseLimit <= 1.0 ) { int bl4 = 0 , bl64 = 0 ; for ( int chan = 0 ; chan < colors && chan < 4 ; chan ++ ) bl4 += cblack [ chan ] ; bl4 /= LIM ( colors , 1 , 4 ) ; if ( cblack [ 4 ] * cblack [ 5 ] > 0 ) { unsigned cnt = 0 ; for ( unsigned c = 0 ; c < 4096 && c < cblack [ 4 ] * cblack [ 5 ] ; c ++ ) { bl64 += cblack [ c + 6 ] ; cnt ++ ; } bl64 /= LIM ( cnt , 1 , 4096 ) ; } int rblack = black + bl4 + bl64 ; for ( int chan = 0 ; chan < colors && chan < 4 ; chan ++ ) imgdata . color . linear_max [ chan ] = ( maximum - rblack ) * imgdata . color . dng_levels . LinearResponseLimit + rblack ; } } } } }", "target": "<S2SV_ModStart> i < colors && i < 4 <S2SV_ModStart> i < colors && i < 4 <S2SV_ModStart> j < colors && j < 4 <S2SV_ModStart> c < tiff_samples && c < 4"}
{"source": "CWE-703 struct clock_source * dce100_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }", "target": "<S2SV_ModStart> base ; } kfree ( clk_src ) ;"}
{"source": "CWE-703 <S2SV_StartBug> struct clock_source * dce80_clock_source_create ( <S2SV_EndBug> struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }", "target": "<S2SV_ModStart> struct clock_source * dce100_clock_source_create <S2SV_ModEnd> ( struct dc_context <S2SV_ModStart> base ; } kfree ( clk_src ) ;"}
{"source": "CWE-703 <S2SV_StartBug> struct clock_source * dcn10_clock_source_create ( <S2SV_EndBug> struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; <S2SV_StartBug> if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , <S2SV_EndBug> regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }", "target": "<S2SV_ModStart> struct clock_source * dce100_clock_source_create <S2SV_ModEnd> ( struct dc_context <S2SV_ModStart> ; if ( dce110_clk_src_construct <S2SV_ModEnd> ( clk_src , <S2SV_ModStart> base ; } kfree ( clk_src ) ;"}
{"source": "CWE-703 <S2SV_StartBug> struct clock_source * dce112_clock_source_create ( <S2SV_EndBug> struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; <S2SV_StartBug> if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , <S2SV_EndBug> regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }", "target": "<S2SV_ModStart> struct clock_source * dce100_clock_source_create <S2SV_ModEnd> ( struct dc_context <S2SV_ModStart> ; if ( dce110_clk_src_construct <S2SV_ModEnd> ( clk_src , <S2SV_ModStart> base ; } kfree ( clk_src ) ;"}
{"source": "CWE-703 <S2SV_StartBug> struct clock_source * dce110_clock_source_create ( <S2SV_EndBug> struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }", "target": "<S2SV_ModStart> struct clock_source * dce100_clock_source_create <S2SV_ModEnd> ( struct dc_context <S2SV_ModStart> base ; } kfree ( clk_src ) ;"}
{"source": "CWE-703 <S2SV_StartBug> struct clock_source * dcn20_clock_source_create ( <S2SV_EndBug> struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; <S2SV_StartBug> if ( dcn20_clk_src_construct ( clk_src , ctx , bios , id , <S2SV_EndBug> regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }", "target": "<S2SV_ModStart> struct clock_source * dcn10_clock_source_create <S2SV_ModEnd> ( struct dc_context <S2SV_ModStart> ; if ( dce112_clk_src_construct <S2SV_ModEnd> ( clk_src , <S2SV_ModStart> base ; } kfree ( clk_src ) ;"}
{"source": "CWE-703 static struct clock_source * dce120_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( * clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }", "target": "<S2SV_ModStart> base ; } kfree ( clk_src ) ;"}
{"source": "CWE-703 static void get_over ( struct SYMBOL * s ) { struct VOICE_S * p_voice , * p_voice2 , * p_voice3 ; int range , voice , voice2 , voice3 ; static char tx_wrong_dur [ ] = \"Wrong<S2SV_blank>duration<S2SV_blank>in<S2SV_blank>voice<S2SV_blank>overlay\" ; static char txt_no_note [ ] = \"No<S2SV_blank>note<S2SV_blank>in<S2SV_blank>voice<S2SV_blank>overlay\" ; p_voice = curvoice ; if ( p_voice -> ignore ) return ; if ( s -> abc_type == ABC_T_BAR || s -> u . v_over . type == V_OVER_E ) { if ( ! p_voice -> last_sym ) { error ( 1 , s , txt_no_note ) ; return ; } p_voice -> last_sym -> sflags |= S_BEAM_END ; over_bar = 0 ; if ( over_time < 0 ) { error ( 1 , s , \"Erroneous<S2SV_blank>end<S2SV_blank>of<S2SV_blank>voice<S2SV_blank>overlap\" ) ; return ; } <S2SV_StartBug> if ( p_voice -> time != over_mxtime ) <S2SV_EndBug> error ( 1 , s , tx_wrong_dur ) ; <S2SV_StartBug> curvoice = & voice_tb [ over_voice ] ; <S2SV_EndBug> over_mxtime = 0 ; over_voice = - 1 ; over_time = - 1 ; return ; } if ( s -> u . v_over . type == V_OVER_S ) { over_voice = p_voice - voice_tb ; over_time = p_voice -> time ; return ; } if ( ! p_voice -> last_sym ) { error ( 1 , s , txt_no_note ) ; return ; } p_voice -> last_sym -> sflags |= S_BEAM_END ; voice2 = s -> u . v_over . voice ; p_voice2 = & voice_tb [ voice2 ] ; if ( parsys -> voice [ voice2 ] . range < 0 ) { int clone ; if ( cfmt . abc2pscompat ) { error ( 1 , s , \"Cannot<S2SV_blank>have<S2SV_blank>%%%%abc2pscompat\" ) ; cfmt . abc2pscompat = 0 ; } clone = p_voice -> clone >= 0 ; p_voice2 -> id [ 0 ] = '&' ; p_voice2 -> id [ 1 ] = '\\\\0' ; p_voice2 -> second = 1 ; parsys -> voice [ voice2 ] . second = 1 ; p_voice2 -> scale = p_voice -> scale ; p_voice2 -> octave = p_voice -> octave ; p_voice2 -> transpose = p_voice -> transpose ; memcpy ( & p_voice2 -> key , & p_voice -> key , sizeof p_voice2 -> key ) ; memcpy ( & p_voice2 -> ckey , & p_voice -> ckey , sizeof p_voice2 -> ckey ) ; memcpy ( & p_voice2 -> okey , & p_voice -> okey , sizeof p_voice2 -> okey ) ; p_voice2 -> posit = p_voice -> posit ; p_voice2 -> staff = p_voice -> staff ; p_voice2 -> cstaff = p_voice -> cstaff ; p_voice2 -> color = p_voice -> color ; p_voice2 -> map_name = p_voice -> map_name ; range = parsys -> voice [ p_voice - voice_tb ] . range ; for ( voice = 0 ; voice < MAXVOICE ; voice ++ ) { if ( parsys -> voice [ voice ] . range > range ) parsys -> voice [ voice ] . range += clone + 1 ; } parsys -> voice [ voice2 ] . range = range + 1 ; voice_link ( p_voice2 ) ; if ( clone ) { for ( voice3 = MAXVOICE ; -- voice3 >= 0 ; ) { if ( parsys -> voice [ voice3 ] . range < 0 ) break ; } if ( voice3 > 0 ) { p_voice3 = & voice_tb [ voice3 ] ; strcpy ( p_voice3 -> id , p_voice2 -> id ) ; p_voice3 -> second = 1 ; parsys -> voice [ voice3 ] . second = 1 ; p_voice3 -> scale = voice_tb [ p_voice -> clone ] . scale ; parsys -> voice [ voice3 ] . range = range + 2 ; voice_link ( p_voice3 ) ; p_voice2 -> clone = voice3 ; } else { error ( 1 , s , \"Too<S2SV_blank>many<S2SV_blank>voices<S2SV_blank>for<S2SV_blank>overlay<S2SV_blank>cloning\" ) ; } } } voice = p_voice - voice_tb ; if ( over_time < 0 ) { int time ; over_bar = 1 ; over_mxtime = p_voice -> time ; over_voice = voice ; time = p_voice2 -> time ; for ( s = p_voice -> last_sym ; ; s = s -> prev ) { if ( s -> type == BAR || s -> time <= time ) break ; } over_time = s -> time ; } else { if ( over_mxtime == 0 ) over_mxtime = p_voice -> time ; else if ( p_voice -> time != over_mxtime ) error ( 1 , s , tx_wrong_dur ) ; } p_voice2 -> time = over_time ; curvoice = p_voice2 ; }", "target": "<S2SV_ModStart> return ; } curvoice = & voice_tb [ over_voice ] ; <S2SV_ModStart> != over_mxtime ) { <S2SV_ModStart> tx_wrong_dur ) ; if ( p_voice -> time > over_mxtime ) curvoice -> time = p_voice -> time ; else p_voice -> time = curvoice -> time ; } <S2SV_ModEnd> over_mxtime = 0"}
{"source": "CWE-125 static int exif_process_IFD_in_MAKERNOTE ( image_info_type * ImageInfo , char * value_ptr , int value_len , char * offset_base , size_t IFDlength , size_t displacement TSRMLS_DC ) { int de , i = 0 , section_index = SECTION_MAKERNOTE ; int NumDirEntries , old_motorola_intel , offset_diff ; const maker_note_type * maker_note ; char * dir_start ; <S2SV_StartBug> <S2SV_EndBug> for ( i = 0 ; i <= sizeof ( maker_note_array ) / sizeof ( maker_note_type ) ; i ++ ) { if ( i == sizeof ( maker_note_array ) / sizeof ( maker_note_type ) ) { # ifdef EXIF_DEBUG exif_error_docref ( NULL EXIFERR_CC , ImageInfo , E_NOTICE , \"No<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>data<S2SV_blank>found.<S2SV_blank>Detected<S2SV_blank>maker:<S2SV_blank>%s<S2SV_blank>(length<S2SV_blank>=<S2SV_blank>%d)\" , ImageInfo -> make , strlen ( ImageInfo -> make ) ) ; # endif return TRUE ; } maker_note = maker_note_array + i ; if ( maker_note -> make && ( ! ImageInfo -> make || strcmp ( maker_note -> make , ImageInfo -> make ) ) ) continue ; if ( maker_note -> model && ( ! ImageInfo -> model || strcmp ( maker_note -> model , ImageInfo -> model ) ) ) continue ; if ( maker_note -> id_string && strncmp ( maker_note -> id_string , value_ptr , maker_note -> id_string_len ) ) continue ; break ; } if ( maker_note -> offset >= value_len ) { exif_error_docref ( \"exif_read_data#error_ifd\" EXIFERR_CC , ImageInfo , E_WARNING , \"IFD<S2SV_blank>data<S2SV_blank>too<S2SV_blank>short:<S2SV_blank>0x%04X<S2SV_blank>offset<S2SV_blank>0x%04X\" , value_len , maker_note -> offset ) ; return FALSE ; } dir_start = value_ptr + maker_note -> offset ; # ifdef EXIF_DEBUG exif_error_docref ( NULL EXIFERR_CC , ImageInfo , E_NOTICE , \"Process<S2SV_blank>%s<S2SV_blank>@x%04X<S2SV_blank>+<S2SV_blank>0x%04X=%d:<S2SV_blank>%s\" , exif_get_sectionname ( section_index ) , ( int ) dir_start - ( int ) offset_base + maker_note -> offset + displacement , value_len , value_len , exif_char_dump ( value_ptr , value_len , ( int ) dir_start - ( int ) offset_base + maker_note -> offset + displacement ) ) ; # endif ImageInfo -> sections_found |= FOUND_MAKERNOTE ; old_motorola_intel = ImageInfo -> motorola_intel ; switch ( maker_note -> byte_order ) { case MN_ORDER_INTEL : ImageInfo -> motorola_intel = 0 ; break ; case MN_ORDER_MOTOROLA : ImageInfo -> motorola_intel = 1 ; break ; default : case MN_ORDER_NORMAL : break ; } NumDirEntries = php_ifd_get16u ( dir_start , ImageInfo -> motorola_intel ) ; switch ( maker_note -> offset_mode ) { case MN_OFFSET_MAKER : <S2SV_StartBug> offset_base = value_ptr ; <S2SV_EndBug> break ; case MN_OFFSET_GUESS : if ( maker_note -> offset + 10 + 4 >= value_len ) { exif_error_docref ( \"exif_read_data#error_ifd\" EXIFERR_CC , ImageInfo , E_WARNING , \"IFD<S2SV_blank>data<S2SV_blank>too<S2SV_blank>short:<S2SV_blank>0x%04X\" , value_len ) ; return FALSE ; } offset_diff = 2 + NumDirEntries * 12 + 4 - php_ifd_get32u ( dir_start + 10 , ImageInfo -> motorola_intel ) ; # ifdef EXIF_DEBUG exif_error_docref ( NULL EXIFERR_CC , ImageInfo , E_NOTICE , \"Using<S2SV_blank>automatic<S2SV_blank>offset<S2SV_blank>correction:<S2SV_blank>0x%04X\" , ( ( int ) dir_start - ( int ) offset_base + maker_note -> offset + displacement ) + offset_diff ) ; # endif if ( offset_diff < 0 || offset_diff >= value_len ) { exif_error_docref ( \"exif_read_data#error_ifd\" EXIFERR_CC , ImageInfo , E_WARNING , \"IFD<S2SV_blank>data<S2SV_blank>bad<S2SV_blank>offset:<S2SV_blank>0x%04X<S2SV_blank>length<S2SV_blank>0x%04X\" , offset_diff , value_len ) ; return FALSE ; } offset_base = value_ptr + offset_diff ; <S2SV_StartBug> break ; <S2SV_EndBug> default : case MN_OFFSET_NORMAL : break ; } if ( ( 2 + NumDirEntries * 12 ) > value_len ) { exif_error_docref ( \"exif_read_data#error_ifd\" EXIFERR_CC , ImageInfo , E_WARNING , \"Illegal<S2SV_blank>IFD<S2SV_blank>size:<S2SV_blank>2<S2SV_blank>+<S2SV_blank>0x%04X*12<S2SV_blank>=<S2SV_blank>0x%04X<S2SV_blank>><S2SV_blank>0x%04X\" , NumDirEntries , 2 + NumDirEntries * 12 , value_len ) ; return FALSE ; } for ( de = 0 ; de < NumDirEntries ; de ++ ) { if ( ! exif_process_IFD_TAG ( ImageInfo , dir_start + 2 + 12 * de , <S2SV_StartBug> offset_base , IFDlength , displacement , section_index , 0 , maker_note -> tag_table TSRMLS_CC ) ) { <S2SV_EndBug> return FALSE ; } } ImageInfo -> motorola_intel = old_motorola_intel ; # ifdef EXIF_DEBUG exif_error_docref ( NULL EXIFERR_CC , ImageInfo , E_NOTICE , \"Subsection<S2SV_blank>%s<S2SV_blank>done\" , exif_get_sectionname ( SECTION_MAKERNOTE ) ) ; # endif return TRUE ; }", "target": "<S2SV_ModStart> * dir_start ; int data_len ; <S2SV_ModStart> offset_base = value_ptr ; data_len = value_len <S2SV_ModStart> + offset_diff ; data_len = value_len - offset_diff ; <S2SV_ModStart> , offset_base , data_len <S2SV_ModEnd> , displacement ,"}
{"source": "CWE-189 gdImagePtr gdImageCrop ( gdImagePtr src , const gdRectPtr crop ) { gdImagePtr dst ; int y ; <S2SV_StartBug> if ( crop -> width <= 0 || crop -> height <= 0 ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> if ( src -> trueColor ) { <S2SV_EndBug> dst = gdImageCreateTrueColor ( crop -> width , crop -> height ) ; gdImageSaveAlpha ( dst , 1 ) ; } else { dst = gdImageCreate ( crop -> width , crop -> height ) ; <S2SV_StartBug> gdImagePaletteCopy ( dst , src ) ; <S2SV_EndBug> } if ( dst == NULL ) { <S2SV_StartBug> return NULL ; <S2SV_EndBug> } dst -> transparent = src -> transparent ; if ( crop -> x < 0 || crop -> x >= src -> sx || crop -> y < 0 || crop -> y >= src -> sy ) { return dst ; } if ( ( src -> sx - crop -> width ) < crop -> x ) { crop -> width = src -> sx - crop -> x ; } if ( ( src -> sy - crop -> height ) < crop -> y ) { crop -> height = src -> sy - crop -> y ; } # if 0 printf ( \"rect->x:<S2SV_blank>%i\\\\nrect->y:<S2SV_blank>%i\\\\nrect->width:<S2SV_blank>%i\\\\nrect->height:<S2SV_blank>%i\\\\n\" , crop -> x , crop -> y , crop -> width , crop -> height ) ; # endif y = crop -> y ; if ( src -> trueColor ) { unsigned int dst_y = 0 ; while ( y < ( crop -> y + ( crop -> height - 1 ) ) ) { memcpy ( dst -> tpixels [ dst_y ++ ] , src -> tpixels [ y ++ ] + crop -> x , crop -> width * 4 ) ; } } else { int x ; for ( y = crop -> y ; y < ( crop -> y + ( crop -> height - 1 ) ) ; y ++ ) { for ( x = crop -> x ; x < ( crop -> x + ( crop -> width - 1 ) ) ; x ++ ) { dst -> pixels [ y - crop -> y ] [ x - crop -> x ] = src -> pixels [ y ] [ x ] ; } } } return dst ; }", "target": "<S2SV_ModStart> ; if ( src -> trueColor ) { dst = gdImageCreateTrueColor ( crop -> width , crop -> height ) ; if ( dst == NULL <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> gdImageSaveAlpha ( dst <S2SV_ModStart> height ) ; <S2SV_ModEnd> if ( dst <S2SV_ModStart> { return NULL ; } gdImagePaletteCopy ( dst , src )"}
{"source": "CWE-119 isdn_net_setcfg ( isdn_net_ioctl_cfg * cfg ) { isdn_net_dev * p = isdn_net_findif ( cfg -> name ) ; ulong features ; int i ; int drvidx ; int chidx ; char drvid [ 25 ] ; if ( p ) { isdn_net_local * lp = p -> local ; features = ( ( 1 << cfg -> l2_proto ) << ISDN_FEATURE_L2_SHIFT ) | ( ( 1 << cfg -> l3_proto ) << ISDN_FEATURE_L3_SHIFT ) ; for ( i = 0 ; i < ISDN_MAX_DRIVERS ; i ++ ) if ( dev -> drv [ i ] ) if ( ( dev -> drv [ i ] -> interface -> features & features ) == features ) break ; if ( i == ISDN_MAX_DRIVERS ) { printk ( KERN_WARNING \"isdn_net:<S2SV_blank>No<S2SV_blank>driver<S2SV_blank>with<S2SV_blank>selected<S2SV_blank>features\\\\n\" ) ; return - ENODEV ; } if ( lp -> p_encap != cfg -> p_encap ) { # ifdef CONFIG_ISDN_X25 struct concap_proto * cprot = p -> cprot ; # endif if ( isdn_net_device_started ( p ) ) { printk ( KERN_WARNING \"%s:<S2SV_blank>cannot<S2SV_blank>change<S2SV_blank>encap<S2SV_blank>when<S2SV_blank>if<S2SV_blank>is<S2SV_blank>up\\\\n\" , p -> dev -> name ) ; return - EBUSY ; } # ifdef CONFIG_ISDN_X25 if ( cprot && cprot -> pops ) cprot -> pops -> proto_del ( cprot ) ; p -> cprot = NULL ; lp -> dops = NULL ; switch ( cfg -> p_encap ) { case ISDN_NET_ENCAP_X25IFACE : lp -> dops = & isdn_concap_reliable_dl_dops ; } p -> cprot = isdn_concap_new ( cfg -> p_encap ) ; # endif } switch ( cfg -> p_encap ) { case ISDN_NET_ENCAP_SYNCPPP : # ifndef CONFIG_ISDN_PPP printk ( KERN_WARNING \"%s:<S2SV_blank>SyncPPP<S2SV_blank>support<S2SV_blank>not<S2SV_blank>configured\\\\n\" , p -> dev -> name ) ; return - EINVAL ; # else p -> dev -> type = ARPHRD_PPP ; p -> dev -> addr_len = 0 ; p -> dev -> do_ioctl = isdn_ppp_dev_ioctl ; # endif break ; case ISDN_NET_ENCAP_X25IFACE : # ifndef CONFIG_ISDN_X25 printk ( KERN_WARNING \"%s:<S2SV_blank>isdn-x25<S2SV_blank>support<S2SV_blank>not<S2SV_blank>configured\\\\n\" , p -> dev -> name ) ; return - EINVAL ; # else p -> dev -> type = ARPHRD_X25 ; p -> dev -> addr_len = 0 ; # endif break ; case ISDN_NET_ENCAP_CISCOHDLCK : p -> dev -> do_ioctl = isdn_ciscohdlck_dev_ioctl ; break ; default : if ( cfg -> p_encap >= 0 && cfg -> p_encap <= ISDN_NET_ENCAP_MAX_ENCAP ) break ; printk ( KERN_WARNING \"%s:<S2SV_blank>encapsulation<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>supported\\\\n\" , p -> dev -> name , cfg -> p_encap ) ; return - EINVAL ; } if ( strlen ( cfg -> drvid ) ) { char * c , * e ; drvidx = - 1 ; chidx = - 1 ; strcpy ( drvid , cfg -> drvid ) ; if ( ( c = strchr ( drvid , ',' ) ) ) { chidx = ( int ) simple_strtoul ( c + 1 , & e , 10 ) ; if ( e == c ) chidx = - 1 ; * c = '\\\\0' ; } for ( i = 0 ; i < ISDN_MAX_DRIVERS ; i ++ ) if ( ! ( strcmp ( dev -> drvid [ i ] , drvid ) ) ) { drvidx = i ; break ; } if ( ( drvidx == - 1 ) || ( chidx == - 1 ) ) return - ENODEV ; } else { drvidx = lp -> pre_device ; chidx = lp -> pre_channel ; } if ( cfg -> exclusive > 0 ) { unsigned long flags ; spin_lock_irqsave ( & dev -> lock , flags ) ; if ( ( i = isdn_get_free_channel ( ISDN_USAGE_NET , lp -> l2_proto , lp -> l3_proto , drvidx , chidx , lp -> msn ) ) < 0 ) { lp -> exclusive = - 1 ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; return - EBUSY ; } dev -> usage [ i ] = ISDN_USAGE_EXCLUSIVE ; isdn_info_update ( ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; lp -> exclusive = i ; } else { lp -> exclusive = - 1 ; if ( ( lp -> pre_device != - 1 ) && ( cfg -> exclusive == - 1 ) ) { isdn_unexclusive_channel ( lp -> pre_device , lp -> pre_channel ) ; isdn_free_channel ( lp -> pre_device , lp -> pre_channel , ISDN_USAGE_NET ) ; drvidx = - 1 ; chidx = - 1 ; } } <S2SV_StartBug> strcpy ( lp -> msn , cfg -> eaz ) ; <S2SV_EndBug> lp -> pre_device = drvidx ; lp -> pre_channel = chidx ; lp -> onhtime = cfg -> onhtime ; lp -> charge = cfg -> charge ; lp -> l2_proto = cfg -> l2_proto ; lp -> l3_proto = cfg -> l3_proto ; lp -> cbdelay = cfg -> cbdelay ; lp -> dialmax = cfg -> dialmax ; lp -> triggercps = cfg -> triggercps ; lp -> slavedelay = cfg -> slavedelay * HZ ; lp -> pppbind = cfg -> pppbind ; lp -> dialtimeout = cfg -> dialtimeout >= 0 ? cfg -> dialtimeout * HZ : - 1 ; lp -> dialwait = cfg -> dialwait * HZ ; if ( cfg -> secure ) lp -> flags |= ISDN_NET_SECURE ; else lp -> flags &= ~ ISDN_NET_SECURE ; if ( cfg -> cbhup ) lp -> flags |= ISDN_NET_CBHUP ; else lp -> flags &= ~ ISDN_NET_CBHUP ; switch ( cfg -> callback ) { case 0 : lp -> flags &= ~ ( ISDN_NET_CALLBACK | ISDN_NET_CBOUT ) ; break ; case 1 : lp -> flags |= ISDN_NET_CALLBACK ; lp -> flags &= ~ ISDN_NET_CBOUT ; break ; case 2 : lp -> flags |= ISDN_NET_CBOUT ; lp -> flags &= ~ ISDN_NET_CALLBACK ; break ; } lp -> flags &= ~ ISDN_NET_DIALMODE_MASK ; if ( cfg -> dialmode && ! ( cfg -> dialmode & ISDN_NET_DIALMODE_MASK ) ) { printk ( KERN_WARNING \"Old<S2SV_blank>isdnctrl<S2SV_blank>version<S2SV_blank>detected!<S2SV_blank>Please<S2SV_blank>update.\\\\n\" ) ; lp -> flags |= ISDN_NET_DM_OFF ; } else { lp -> flags |= cfg -> dialmode ; } if ( cfg -> chargehup ) lp -> hupflags |= ISDN_CHARGEHUP ; else lp -> hupflags &= ~ ISDN_CHARGEHUP ; if ( cfg -> ihup ) lp -> hupflags |= ISDN_INHUP ; else lp -> hupflags &= ~ ISDN_INHUP ; if ( cfg -> chargeint > 10 ) { lp -> hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE ; lp -> chargeint = cfg -> chargeint * HZ ; } if ( cfg -> p_encap != lp -> p_encap ) { if ( cfg -> p_encap == ISDN_NET_ENCAP_RAWIP ) { p -> dev -> header_ops = NULL ; p -> dev -> flags = IFF_NOARP | IFF_POINTOPOINT ; } else { p -> dev -> header_ops = & isdn_header_ops ; if ( cfg -> p_encap == ISDN_NET_ENCAP_ETHER ) p -> dev -> flags = IFF_BROADCAST | IFF_MULTICAST ; else p -> dev -> flags = IFF_NOARP | IFF_POINTOPOINT ; } } lp -> p_encap = cfg -> p_encap ; return 0 ; } return - ENODEV ; }", "target": "<S2SV_ModStart> ; } } strlcpy <S2SV_ModEnd> ( lp -> <S2SV_ModStart> cfg -> eaz , sizeof ( lp -> msn )"}
{"source": "CWE-189 static int dccp_setsockopt_change ( struct sock * sk , int type , struct dccp_so_feat __user * optval ) { struct dccp_so_feat opt ; u8 * val ; int rc ; if ( copy_from_user ( & opt , optval , sizeof ( opt ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> val = kmalloc ( opt . dccpsf_len , GFP_KERNEL ) ; if ( ! val ) return - ENOMEM ; if ( copy_from_user ( val , opt . dccpsf_val , opt . dccpsf_len ) ) { rc = - EFAULT ; goto out_free_val ; } rc = dccp_feat_change ( dccp_msk ( sk ) , type , opt . dccpsf_feat , val , opt . dccpsf_len , GFP_KERNEL ) ; if ( rc ) goto out_free_val ; out : return rc ; out_free_val : kfree ( val ) ; goto out ; }", "target": "<S2SV_ModStart> return - EFAULT ; if ( opt . dccpsf_len < 1 ) return - EINVAL"}
{"source": "CWE-264 sbni_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct net_local * nl = ( struct net_local * ) dev -> priv ; struct sbni_flags flags ; int error = 0 ; # ifdef CONFIG_SBNI_MULTILINE struct net_device * slave_dev ; char slave_name [ 8 ] ; # endif switch ( cmd ) { case SIOCDEVGETINSTATS : if ( copy_to_user ( ifr -> ifr_data , & nl -> in_stats , sizeof ( struct sbni_in_stats ) ) ) error = - EFAULT ; break ; case SIOCDEVRESINSTATS : <S2SV_StartBug> if ( current -> euid != 0 ) <S2SV_EndBug> return - EPERM ; memset ( & nl -> in_stats , 0 , sizeof ( struct sbni_in_stats ) ) ; break ; case SIOCDEVGHWSTATE : flags . mac_addr = * ( u32 * ) ( dev -> dev_addr + 3 ) ; flags . rate = nl -> csr1 . rate ; flags . slow_mode = ( nl -> state & FL_SLOW_MODE ) != 0 ; flags . rxl = nl -> cur_rxl_index ; flags . fixed_rxl = nl -> delta_rxl == 0 ; if ( copy_to_user ( ifr -> ifr_data , & flags , sizeof flags ) ) error = - EFAULT ; break ; case SIOCDEVSHWSTATE : <S2SV_StartBug> if ( current -> euid != 0 ) <S2SV_EndBug> return - EPERM ; spin_lock ( & nl -> lock ) ; flags = * ( struct sbni_flags * ) & ifr -> ifr_ifru ; if ( flags . fixed_rxl ) nl -> delta_rxl = 0 , nl -> cur_rxl_index = flags . rxl ; else nl -> delta_rxl = DEF_RXL_DELTA , nl -> cur_rxl_index = DEF_RXL ; nl -> csr1 . rxl = rxl_tab [ nl -> cur_rxl_index ] ; nl -> csr1 . rate = flags . rate ; outb ( * ( u8 * ) & nl -> csr1 | PR_RES , dev -> base_addr + CSR1 ) ; spin_unlock ( & nl -> lock ) ; break ; # ifdef CONFIG_SBNI_MULTILINE case SIOCDEVENSLAVE : <S2SV_StartBug> if ( current -> euid != 0 ) <S2SV_EndBug> return - EPERM ; if ( copy_from_user ( slave_name , ifr -> ifr_data , sizeof slave_name ) ) return - EFAULT ; slave_dev = dev_get_by_name ( & init_net , slave_name ) ; if ( ! slave_dev || ! ( slave_dev -> flags & IFF_UP ) ) { printk ( KERN_ERR \"%s:<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>enslave<S2SV_blank>non-active<S2SV_blank>\" \"device<S2SV_blank>%s\\\\n\" , dev -> name , slave_name ) ; return - EPERM ; } return enslave ( dev , slave_dev ) ; case SIOCDEVEMANSIPATE : <S2SV_StartBug> if ( current -> euid != 0 ) <S2SV_EndBug> return - EPERM ; return emancipate ( dev ) ; # endif default : return - EOPNOTSUPP ; } return error ; }", "target": "<S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return - <S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return - <S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return - <S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return -"}
{"source": "CWE-399 static int svc_listen ( struct socket * sock , int backlog ) { DEFINE_WAIT ( wait ) ; struct sock * sk = sock -> sk ; struct atm_vcc * vcc = ATM_SD ( sock ) ; int error ; pr_debug ( \"svc_listen<S2SV_blank>%p\\\\n\" , vcc ) ; lock_sock ( sk ) ; if ( test_bit ( ATM_VF_SESSION , & vcc -> flags ) ) { error = - EINVAL ; goto out ; } <S2SV_StartBug> vcc_insert_socket ( sk ) ; <S2SV_EndBug> set_bit ( ATM_VF_WAITING , & vcc -> flags ) ; prepare_to_wait ( sk -> sk_sleep , & wait , TASK_UNINTERRUPTIBLE ) ; sigd_enq ( vcc , as_listen , NULL , NULL , & vcc -> local ) ; while ( test_bit ( ATM_VF_WAITING , & vcc -> flags ) && sigd ) { schedule ( ) ; prepare_to_wait ( sk -> sk_sleep , & wait , TASK_UNINTERRUPTIBLE ) ; } finish_wait ( sk -> sk_sleep , & wait ) ; if ( ! sigd ) { error = - EUNATCH ; goto out ; } <S2SV_StartBug> set_bit ( ATM_VF_LISTEN , & vcc -> flags ) ; <S2SV_EndBug> sk -> sk_max_ack_backlog = backlog > 0 ? backlog : ATM_BACKLOG_DEFAULT ; error = - sk -> sk_err ; out : release_sock ( sk ) ; return error ; }", "target": "<S2SV_ModStart> out ; } if ( test_bit ( ATM_VF_LISTEN , & vcc -> flags ) ) { error = - EADDRINUSE ; goto out ; } <S2SV_ModEnd> set_bit ( ATM_VF_WAITING <S2SV_ModStart> vcc -> flags ) ; vcc_insert_socket ( sk"}
{"source": "CWE-20 int ext4_group_add ( struct super_block * sb , struct ext4_new_group_data * input ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_super_block * es = sbi -> s_es ; int reserved_gdb = ext4_bg_has_super ( sb , input -> group ) ? le16_to_cpu ( es -> s_reserved_gdt_blocks ) : 0 ; struct buffer_head * primary = NULL ; struct ext4_group_desc * gdp ; struct inode * inode = NULL ; handle_t * handle ; int gdb_off , gdb_num ; int num_grp_locked = 0 ; int err , err2 ; gdb_num = input -> group / EXT4_DESC_PER_BLOCK ( sb ) ; gdb_off = input -> group % EXT4_DESC_PER_BLOCK ( sb ) ; if ( gdb_off == 0 && ! EXT4_HAS_RO_COMPAT_FEATURE ( sb , EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER ) ) { ext4_warning ( sb , __func__ , \"Can\\'t<S2SV_blank>resize<S2SV_blank>non-sparse<S2SV_blank>filesystem<S2SV_blank>further\" ) ; return - EPERM ; } if ( ext4_blocks_count ( es ) + input -> blocks_count < ext4_blocks_count ( es ) ) { ext4_warning ( sb , __func__ , \"blocks_count<S2SV_blank>overflow\" ) ; return - EINVAL ; } if ( le32_to_cpu ( es -> s_inodes_count ) + EXT4_INODES_PER_GROUP ( sb ) < le32_to_cpu ( es -> s_inodes_count ) ) { ext4_warning ( sb , __func__ , \"inodes_count<S2SV_blank>overflow\" ) ; return - EINVAL ; } if ( reserved_gdb || gdb_off == 0 ) { if ( ! EXT4_HAS_COMPAT_FEATURE ( sb , EXT4_FEATURE_COMPAT_RESIZE_INODE ) || ! le16_to_cpu ( es -> s_reserved_gdt_blocks ) ) { ext4_warning ( sb , __func__ , \"No<S2SV_blank>reserved<S2SV_blank>GDT<S2SV_blank>blocks,<S2SV_blank>can\\'t<S2SV_blank>resize\" ) ; return - EPERM ; } inode = ext4_iget ( sb , EXT4_RESIZE_INO ) ; if ( IS_ERR ( inode ) ) { ext4_warning ( sb , __func__ , \"Error<S2SV_blank>opening<S2SV_blank>resize<S2SV_blank>inode\" ) ; return PTR_ERR ( inode ) ; } } if ( ( err = verify_group_input ( sb , input ) ) ) goto exit_put ; if ( ( err = setup_new_group_blocks ( sb , input ) ) ) goto exit_put ; handle = ext4_journal_start_sb ( sb , ext4_bg_has_super ( sb , input -> group ) ? 3 + reserved_gdb : 4 ) ; if ( IS_ERR ( handle ) ) { err = PTR_ERR ( handle ) ; goto exit_put ; } lock_super ( sb ) ; if ( input -> group != sbi -> s_groups_count ) { ext4_warning ( sb , __func__ , \"multiple<S2SV_blank>resizers<S2SV_blank>run<S2SV_blank>on<S2SV_blank>filesystem!\" ) ; err = - EBUSY ; goto exit_journal ; } if ( ( err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ) ) goto exit_journal ; if ( gdb_off ) { primary = sbi -> s_group_desc [ gdb_num ] ; if ( ( err = ext4_journal_get_write_access ( handle , primary ) ) ) goto exit_journal ; if ( reserved_gdb && ext4_bg_num_gdb ( sb , input -> group ) && ( err = reserve_backup_gdb ( handle , inode , input ) ) ) goto exit_journal ; } else if ( ( err = add_new_gdb ( handle , inode , input , & primary ) ) ) goto exit_journal ; num_grp_locked = ext4_mb_get_buddy_cache_lock ( sb , input -> group ) ; gdp = ( struct ext4_group_desc * ) ( ( char * ) primary -> b_data + gdb_off * EXT4_DESC_SIZE ( sb ) ) ; <S2SV_StartBug> ext4_block_bitmap_set ( sb , gdp , input -> block_bitmap ) ; <S2SV_EndBug> ext4_inode_bitmap_set ( sb , gdp , input -> inode_bitmap ) ; ext4_inode_table_set ( sb , gdp , input -> inode_table ) ; ext4_free_blks_set ( sb , gdp , input -> free_blocks_count ) ; ext4_free_inodes_set ( sb , gdp , EXT4_INODES_PER_GROUP ( sb ) ) ; <S2SV_StartBug> gdp -> bg_flags |= cpu_to_le16 ( EXT4_BG_INODE_ZEROED ) ; <S2SV_EndBug> gdp -> bg_checksum = ext4_group_desc_csum ( sbi , input -> group , gdp ) ; err = ext4_mb_add_groupinfo ( sb , input -> group , gdp ) ; if ( err ) { ext4_mb_put_buddy_cache_lock ( sb , input -> group , num_grp_locked ) ; goto exit_journal ; } ext4_blocks_count_set ( es , ext4_blocks_count ( es ) + input -> blocks_count ) ; le32_add_cpu ( & es -> s_inodes_count , EXT4_INODES_PER_GROUP ( sb ) ) ; smp_wmb ( ) ; sbi -> s_groups_count ++ ; ext4_mb_put_buddy_cache_lock ( sb , input -> group , num_grp_locked ) ; ext4_handle_dirty_metadata ( handle , NULL , primary ) ; ext4_r_blocks_count_set ( es , ext4_r_blocks_count ( es ) + input -> reserved_blocks ) ; percpu_counter_add ( & sbi -> s_freeblocks_counter , input -> free_blocks_count ) ; percpu_counter_add ( & sbi -> s_freeinodes_counter , EXT4_INODES_PER_GROUP ( sb ) ) ; if ( EXT4_HAS_INCOMPAT_FEATURE ( sb , EXT4_FEATURE_INCOMPAT_FLEX_BG ) ) { ext4_group_t flex_group ; flex_group = ext4_flex_group ( sbi , input -> group ) ; sbi -> s_flex_groups [ flex_group ] . free_blocks += input -> free_blocks_count ; sbi -> s_flex_groups [ flex_group ] . free_inodes += EXT4_INODES_PER_GROUP ( sb ) ; } ext4_handle_dirty_metadata ( handle , NULL , sbi -> s_sbh ) ; sb -> s_dirt = 1 ; exit_journal : unlock_super ( sb ) ; if ( ( err2 = ext4_journal_stop ( handle ) ) && ! err ) err = err2 ; if ( ! err ) { update_backups ( sb , sbi -> s_sbh -> b_blocknr , ( char * ) es , sizeof ( struct ext4_super_block ) ) ; update_backups ( sb , primary -> b_blocknr , primary -> b_data , primary -> b_size ) ; } exit_put : iput ( inode ) ; return err ; }", "target": "<S2SV_ModStart> ) ) ; memset ( gdp , 0 , EXT4_DESC_SIZE ( sb ) ) ; <S2SV_ModStart> gdp -> bg_flags = <S2SV_ModEnd> cpu_to_le16 ( EXT4_BG_INODE_ZEROED"}
{"source": "CWE-189 <S2SV_StartBug> ecryptfs_write_metadata_to_contents ( struct ecryptfs_crypt_stat * crypt_stat , <S2SV_EndBug> struct dentry * ecryptfs_dentry , <S2SV_StartBug> char * virt ) <S2SV_EndBug> { int rc ; rc = ecryptfs_write_lower ( ecryptfs_dentry -> d_inode , virt , <S2SV_StartBug> 0 , crypt_stat -> num_header_bytes_at_front ) ; <S2SV_EndBug> if ( rc ) printk ( KERN_ERR \"%s:<S2SV_blank>Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>write<S2SV_blank>header<S2SV_blank>\" \"information<S2SV_blank>to<S2SV_blank>lower<S2SV_blank>file;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\\\n\" , __func__ , rc ) ; return rc ; }", "target": "<S2SV_ModStart> <S2SV_null> ecryptfs_write_metadata_to_contents ( <S2SV_ModEnd> struct dentry * <S2SV_ModStart> char * virt , size_t virt_len <S2SV_ModStart> , 0 , virt_len <S2SV_ModEnd> ) ; if"}
{"source": "CWE-120 size_t util_path_encode ( char * s , size_t len ) { <S2SV_StartBug> char t [ ( len * 3 ) + 1 ] ; <S2SV_EndBug> size_t i , j ; for ( i = 0 , j = 0 ; s [ i ] != '\\\\0' ; i ++ ) { if ( s [ i ] == '/' ) { memcpy ( & t [ j ] , \"\\\\\\\\x2f\" , 4 ) ; j += 4 ; } else if ( s [ i ] == '\\\\\\\\' ) { memcpy ( & t [ j ] , \"\\\\\\\\x5c\" , 4 ) ; j += 4 ; } else { t [ j ] = s [ i ] ; j ++ ; } } if ( len == 0 ) return j ; i = ( j < len - 1 ) ? j : len - 1 ; memcpy ( s , t , i ) ; s [ i ] = '\\\\0' ; return j ; }", "target": "<S2SV_ModStart> ( len * 4 <S2SV_ModEnd> ) + 1"}
{"source": "CWE-476 long keyctl_session_to_parent ( void ) { # ifdef TIF_NOTIFY_RESUME struct task_struct * me , * parent ; const struct cred * mycred , * pcred ; struct cred * cred , * oldcred ; key_ref_t keyring_r ; int ret ; keyring_r = lookup_user_key ( KEY_SPEC_SESSION_KEYRING , 0 , KEY_LINK ) ; if ( IS_ERR ( keyring_r ) ) return PTR_ERR ( keyring_r ) ; ret = - ENOMEM ; cred = cred_alloc_blank ( ) ; if ( ! cred ) goto error_keyring ; cred -> tgcred -> session_keyring = key_ref_to_ptr ( keyring_r ) ; keyring_r = NULL ; me = current ; rcu_read_lock ( ) ; write_lock_irq ( & tasklist_lock ) ; parent = me -> real_parent ; ret = - EPERM ; if ( parent -> pid <= 1 || ! parent -> mm ) goto not_permitted ; if ( ! thread_group_empty ( parent ) ) goto not_permitted ; mycred = current_cred ( ) ; pcred = __task_cred ( parent ) ; if ( mycred == pcred || mycred -> tgcred -> session_keyring == pcred -> tgcred -> session_keyring ) goto already_same ; if ( pcred -> uid != mycred -> euid || pcred -> euid != mycred -> euid || pcred -> suid != mycred -> euid || pcred -> gid != mycred -> egid || pcred -> egid != mycred -> egid || pcred -> sgid != mycred -> egid ) goto not_permitted ; <S2SV_StartBug> if ( pcred -> tgcred -> session_keyring -> uid != mycred -> euid || <S2SV_EndBug> mycred -> tgcred -> session_keyring -> uid != mycred -> euid ) goto not_permitted ; oldcred = parent -> replacement_session_keyring ; parent -> replacement_session_keyring = cred ; cred = NULL ; set_ti_thread_flag ( task_thread_info ( parent ) , TIF_NOTIFY_RESUME ) ; write_unlock_irq ( & tasklist_lock ) ; rcu_read_unlock ( ) ; if ( oldcred ) put_cred ( oldcred ) ; return 0 ; already_same : ret = 0 ; not_permitted : write_unlock_irq ( & tasklist_lock ) ; rcu_read_unlock ( ) ; put_cred ( cred ) ; return ret ; error_keyring : key_ref_put ( keyring_r ) ; return ret ; # else # warning TIF_NOTIFY_RESUME not implemented return - EOPNOTSUPP ; # endif }", "target": "<S2SV_ModStart> ; if ( ( pcred -> tgcred -> session_keyring && <S2SV_ModStart> mycred -> euid )"}
{"source": "CWE-189 grep ( int fd , char const * file , struct stats * stats ) { <S2SV_StartBug> int nlines , i ; <S2SV_EndBug> int not_text ; size_t residue , save ; char oldc ; char * beg ; char * lim ; char eol = eolbyte ; if ( ! reset ( fd , file , stats ) ) return 0 ; if ( file && directories == RECURSE_DIRECTORIES && S_ISDIR ( stats -> stat . st_mode ) ) { if ( close ( fd ) != 0 ) suppressible_error ( file , errno ) ; return grepdir ( file , stats ) - 2 ; } totalcc = 0 ; lastout = 0 ; totalnl = 0 ; outleft = max_count ; after_last_match = 0 ; pending = 0 ; nlines = 0 ; residue = 0 ; save = 0 ; if ( ! fillbuf ( save , stats ) ) { suppressible_error ( filename , errno ) ; return 0 ; } not_text = ( ( ( binary_files == BINARY_BINARY_FILES && ! out_quiet ) || binary_files == WITHOUT_MATCH_BINARY_FILES ) && memchr ( bufbeg , eol ? '\\\\0' : '\\\\200' , buflim - bufbeg ) ) ; if ( not_text && binary_files == WITHOUT_MATCH_BINARY_FILES ) return 0 ; done_on_match += not_text ; out_quiet += not_text ; for ( ; ; ) { lastnl = bufbeg ; if ( lastout ) lastout = bufbeg ; beg = bufbeg + save ; if ( beg == buflim ) break ; oldc = beg [ - 1 ] ; beg [ - 1 ] = eol ; for ( lim = buflim ; lim [ - 1 ] != eol ; lim -- ) continue ; beg [ - 1 ] = oldc ; if ( lim == beg ) lim = beg - residue ; beg -= residue ; residue = buflim - lim ; if ( beg < lim ) { if ( outleft ) nlines += grepbuf ( beg , lim ) ; if ( pending ) prpending ( lim ) ; if ( ( ! outleft && ! pending ) || ( nlines && done_on_match && ! out_invert ) ) goto finish_grep ; } i = 0 ; beg = lim ; while ( i < out_before && beg > bufbeg && beg != lastout ) { ++ i ; do -- beg ; while ( beg [ - 1 ] != eol ) ; } if ( beg != lastout ) lastout = 0 ; save = residue + lim - beg ; if ( out_byte ) totalcc = add_count ( totalcc , buflim - bufbeg - save ) ; if ( out_line ) nlscan ( beg ) ; if ( ! fillbuf ( save , stats ) ) { suppressible_error ( filename , errno ) ; goto finish_grep ; } } if ( residue ) { * buflim ++ = eol ; if ( outleft ) nlines += grepbuf ( bufbeg + save - residue , buflim ) ; if ( pending ) prpending ( buflim ) ; } finish_grep : done_on_match -= not_text ; out_quiet -= not_text ; if ( ( not_text & ~ out_quiet ) && nlines != 0 ) printf ( _ ( \"Binary<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>matches\\\\n\" ) , filename ) ; return nlines ; }", "target": "<S2SV_ModStart> stats ) { intmax_t <S2SV_ModEnd> nlines , i"}
{"source": "CWE-264 translate_hierarchy_event ( ClutterBackendX11 * backend_x11 , ClutterDeviceManagerXI2 * manager_xi2 , XIHierarchyEvent * ev ) { int i ; for ( i = 0 ; i < ev -> num_info ; i ++ ) { if ( ev -> info [ i ] . flags & XIDeviceEnabled ) { XIDeviceInfo * info ; int n_devices ; CLUTTER_NOTE ( EVENT , \"Hierarchy<S2SV_blank>event:<S2SV_blank>device<S2SV_blank>enabled\" ) ; <S2SV_StartBug> info = XIQueryDevice ( backend_x11 -> xdpy , <S2SV_EndBug> ev -> info [ i ] . deviceid , & n_devices ) ; <S2SV_StartBug> add_device ( manager_xi2 , backend_x11 , & info [ 0 ] , FALSE ) ; <S2SV_EndBug> } else if ( ev -> info [ i ] . flags & XIDeviceDisabled ) { CLUTTER_NOTE ( EVENT , \"Hierarchy<S2SV_blank>event:<S2SV_blank>device<S2SV_blank>disabled\" ) ; remove_device ( manager_xi2 , ev -> info [ i ] . deviceid ) ; } else if ( ( ev -> info [ i ] . flags & XISlaveAttached ) || ( ev -> info [ i ] . flags & XISlaveDetached ) ) { ClutterInputDevice * master , * slave ; XIDeviceInfo * info ; int n_devices ; gboolean send_changed = FALSE ; CLUTTER_NOTE ( EVENT , \"Hierarchy<S2SV_blank>event:<S2SV_blank>slave<S2SV_blank>%s\" , ( ev -> info [ i ] . flags & XISlaveAttached ) ? \"attached\" : \"detached\" ) ; slave = g_hash_table_lookup ( manager_xi2 -> devices_by_id , GINT_TO_POINTER ( ev -> info [ i ] . deviceid ) ) ; master = clutter_input_device_get_associated_device ( slave ) ; if ( master != NULL ) { _clutter_input_device_remove_slave ( master , slave ) ; _clutter_input_device_set_associated_device ( slave , NULL ) ; send_changed = TRUE ; } if ( ev -> info [ i ] . flags & XISlaveAttached ) { <S2SV_StartBug> info = XIQueryDevice ( backend_x11 -> xdpy , <S2SV_EndBug> ev -> info [ i ] . deviceid , & n_devices ) ; <S2SV_StartBug> master = g_hash_table_lookup ( manager_xi2 -> devices_by_id , <S2SV_EndBug> GINT_TO_POINTER ( info -> attachment ) ) ; <S2SV_StartBug> _clutter_input_device_set_associated_device ( slave , master ) ; <S2SV_EndBug> _clutter_input_device_add_slave ( master , slave ) ; send_changed = TRUE ; <S2SV_StartBug> XIFreeDeviceInfo ( info ) ; <S2SV_EndBug> } if ( send_changed ) { ClutterStage * stage = _clutter_input_device_get_stage ( master ) ; if ( stage != NULL ) _clutter_stage_x11_events_device_changed ( CLUTTER_STAGE_X11 ( _clutter_stage_get_window ( stage ) ) , master , CLUTTER_DEVICE_MANAGER ( manager_xi2 ) ) ; } } } }", "target": "<S2SV_ModStart> \"Hierarchy<S2SV_blank>event:<S2SV_blank>device<S2SV_blank>enabled\" ) ; clutter_x11_trap_x_errors ( ) ; <S2SV_ModStart> n_devices ) ; clutter_x11_untrap_x_errors ( ) ; if ( info != NULL ) { <S2SV_ModStart> FALSE ) ; XIFreeDeviceInfo ( info ) ; } <S2SV_ModStart> XISlaveAttached ) { clutter_x11_trap_x_errors ( ) ; <S2SV_ModStart> n_devices ) ; clutter_x11_untrap_x_errors ( ) ; if ( info != NULL ) { <S2SV_ModStart> ) ) ; if ( master != NULL ) { <S2SV_ModStart> = TRUE ; } <S2SV_ModStart> info ) ; }"}
{"source": "CWE-119 ms_escher_get_data ( MSEscherState * state , gint offset , gint num_bytes , gboolean * needs_free ) { BiffQuery * q = state -> q ; guint8 * res ; g_return_val_if_fail ( offset >= state -> start_offset , NULL ) ; while ( offset >= state -> end_offset ) { if ( ! ms_biff_query_next ( q ) ) { g_warning ( \"unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>stream;\" ) ; return NULL ; } if ( q -> opcode != BIFF_MS_O_DRAWING && q -> opcode != BIFF_MS_O_DRAWING_GROUP && q -> opcode != BIFF_MS_O_DRAWING_SELECTION && q -> opcode != BIFF_CHART_gelframe && q -> opcode != BIFF_CONTINUE ) { g_warning ( \"Unexpected<S2SV_blank>record<S2SV_blank>type<S2SV_blank>0x%x<S2SV_blank>len=0x%x<S2SV_blank>@<S2SV_blank>0x%lx;\" , q -> opcode , q -> length , ( long ) q -> streamPos ) ; return NULL ; } d ( 1 , g_printerr ( \"Target<S2SV_blank>is<S2SV_blank>0x%x<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>0x%x,<S2SV_blank>current<S2SV_blank>=<S2SV_blank>0x%x..0x%x;\\\\n\" \"Adding<S2SV_blank>biff-0x%x<S2SV_blank>of<S2SV_blank>length<S2SV_blank>0x%x;\\\\n\" , num_bytes , offset , state -> start_offset , state -> end_offset , q -> opcode , q -> length ) ; ) ; state -> start_offset = state -> end_offset ; state -> end_offset += q -> length ; state -> segment_len = q -> length ; } g_return_val_if_fail ( offset >= state -> start_offset , NULL ) ; g_return_val_if_fail ( ( size_t ) ( offset - state -> start_offset ) < q -> length , NULL ) ; res = q -> data + offset - state -> start_offset ; if ( ( * needs_free = ( ( offset + num_bytes ) > state -> end_offset ) ) ) { guint8 * buffer = g_malloc ( num_bytes ) ; guint8 * tmp = buffer ; int len = q -> length - ( res - q -> data ) ; int counter = 0 ; <S2SV_StartBug> d ( 1 , g_printerr ( \"MERGE<S2SV_blank>needed<S2SV_blank>(%d)<S2SV_blank>which<S2SV_blank>is<S2SV_blank>>=<S2SV_blank>%d<S2SV_blank>+<S2SV_blank>%d;\\\\n\" , <S2SV_EndBug> num_bytes , offset , state -> end_offset ) ; ) ; <S2SV_StartBug> do { <S2SV_EndBug> d ( 1 , g_printerr ( \"record<S2SV_blank>%d)<S2SV_blank>add<S2SV_blank>%d<S2SV_blank>bytes;\\\\n\" , ++ counter , len ) ; ) ; memcpy ( tmp , res , len ) ; tmp += len ; if ( ! ms_biff_query_next ( q ) ) { g_warning ( \"unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>stream;\" ) ; return NULL ; } if ( q -> opcode != BIFF_MS_O_DRAWING && q -> opcode != BIFF_MS_O_DRAWING_GROUP && q -> opcode != BIFF_MS_O_DRAWING_SELECTION && q -> opcode != BIFF_CHART_gelframe && q -> opcode != BIFF_CONTINUE ) { g_warning ( \"Unexpected<S2SV_blank>record<S2SV_blank>type<S2SV_blank>0x%x<S2SV_blank>@<S2SV_blank>0x%lx;\" , q -> opcode , ( long ) q -> streamPos ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } state -> start_offset = state -> end_offset ; state -> end_offset += q -> length ; state -> segment_len = q -> length ; res = q -> data ; len = q -> length ; } while ( ( num_bytes - ( tmp - buffer ) ) > len ) ; memcpy ( tmp , res , num_bytes - ( tmp - buffer ) ) ; d ( 1 , g_printerr ( \"record<S2SV_blank>%d)<S2SV_blank>add<S2SV_blank>%d<S2SV_blank>bytes;\\\\n\" , ++ counter , num_bytes - ( int ) ( tmp - buffer ) ) ; ) ; return buffer ; } return res ; }", "target": "<S2SV_ModStart> , g_printerr ( \"MERGE<S2SV_blank>needed<S2SV_blank>(%d)<S2SV_blank>which<S2SV_blank>is<S2SV_blank>>=<S2SV_blank>-%d<S2SV_blank>+<S2SV_blank>%d;\\\\n\" <S2SV_ModEnd> , num_bytes , <S2SV_ModStart> ; do { int maxlen = ( buffer + num_bytes ) - tmp ; len = MIN ( len , maxlen ) ; <S2SV_ModStart> streamPos ) ; g_free ( buffer ) ;"}
{"source": "CWE-310 int ssh_bind_accept_fd ( ssh_bind sshbind , ssh_session session , socket_t fd ) { int i , rc ; if ( session == NULL ) { ssh_set_error ( sshbind , SSH_FATAL , \"session<S2SV_blank>is<S2SV_blank>null\" ) ; return SSH_ERROR ; } session -> server = 1 ; session -> version = 2 ; for ( i = 0 ; i < 10 ; ++ i ) { if ( sshbind -> wanted_methods [ i ] ) { session -> opts . wanted_methods [ i ] = strdup ( sshbind -> wanted_methods [ i ] ) ; if ( session -> opts . wanted_methods [ i ] == NULL ) { return SSH_ERROR ; } } } if ( sshbind -> bindaddr == NULL ) session -> opts . bindaddr = NULL ; else { SAFE_FREE ( session -> opts . bindaddr ) ; session -> opts . bindaddr = strdup ( sshbind -> bindaddr ) ; if ( session -> opts . bindaddr == NULL ) { return SSH_ERROR ; } } session -> common . log_verbosity = sshbind -> common . log_verbosity ; if ( sshbind -> banner != NULL ) session -> opts . custombanner = strdup ( sshbind -> banner ) ; ssh_socket_free ( session -> socket ) ; session -> socket = ssh_socket_new ( session ) ; if ( session -> socket == NULL ) { ssh_set_error_oom ( sshbind ) ; return SSH_ERROR ; } ssh_socket_set_fd ( session -> socket , fd ) ; ssh_socket_get_poll_handle_out ( session -> socket ) ; rc = ssh_bind_import_keys ( sshbind ) ; if ( rc != SSH_OK ) { return SSH_ERROR ; } # ifdef HAVE_ECC if ( sshbind -> ecdsa ) { session -> srv . ecdsa_key = ssh_key_dup ( sshbind -> ecdsa ) ; if ( session -> srv . ecdsa_key == NULL ) { ssh_set_error_oom ( sshbind ) ; return SSH_ERROR ; } } # endif if ( sshbind -> dsa ) { session -> srv . dsa_key = ssh_key_dup ( sshbind -> dsa ) ; if ( session -> srv . dsa_key == NULL ) { ssh_set_error_oom ( sshbind ) ; return SSH_ERROR ; } } if ( sshbind -> rsa ) { session -> srv . rsa_key = ssh_key_dup ( sshbind -> rsa ) ; if ( session -> srv . rsa_key == NULL ) { ssh_set_error_oom ( sshbind ) ; return SSH_ERROR ; } } <S2SV_StartBug> return SSH_OK ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ; } } ssh_reseed ( ) ;"}
{"source": "CWE-125 load_image ( const gchar * filename , GError * * error ) { FILE * fp ; tga_info info ; guchar header [ 18 ] ; guchar footer [ 26 ] ; guchar extension [ 495 ] ; long offset ; gint32 image_ID = - 1 ; fp = g_fopen ( filename , \"rb\" ) ; if ( ! fp ) { g_set_error ( error , G_FILE_ERROR , g_file_error_from_errno ( errno ) , _ ( \"Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>\\'%s\\'<S2SV_blank>for<S2SV_blank>reading:<S2SV_blank>%s\" ) , gimp_filename_to_utf8 ( filename ) , g_strerror ( errno ) ) ; return - 1 ; } gimp_progress_init_printf ( _ ( \"Opening<S2SV_blank>\\'%s\\'\" ) , gimp_filename_to_utf8 ( filename ) ) ; if ( ! fseek ( fp , - 26L , SEEK_END ) ) { if ( fread ( footer , sizeof ( footer ) , 1 , fp ) != 1 ) { g_message ( _ ( \"Cannot<S2SV_blank>read<S2SV_blank>footer<S2SV_blank>from<S2SV_blank>\\'%s\\'\" ) , gimp_filename_to_utf8 ( filename ) ) ; return - 1 ; } else if ( memcmp ( footer + 8 , magic , sizeof ( magic ) ) == 0 ) { offset = ( footer [ 0 ] + footer [ 1 ] * 256L + footer [ 2 ] * 65536L + footer [ 3 ] * 16777216L ) ; if ( offset != 0 ) { if ( fseek ( fp , offset , SEEK_SET ) || fread ( extension , sizeof ( extension ) , 1 , fp ) != 1 ) { g_message ( _ ( \"Cannot<S2SV_blank>read<S2SV_blank>extension<S2SV_blank>from<S2SV_blank>\\'%s\\'\" ) , gimp_filename_to_utf8 ( filename ) ) ; return - 1 ; } } } } if ( fseek ( fp , 0 , SEEK_SET ) || fread ( header , sizeof ( header ) , 1 , fp ) != 1 ) { g_message ( _ ( \"Cannot<S2SV_blank>read<S2SV_blank>header<S2SV_blank>from<S2SV_blank>\\'%s\\'\" ) , gimp_filename_to_utf8 ( filename ) ) ; return - 1 ; } switch ( header [ 2 ] ) { case 1 : info . imageType = TGA_TYPE_MAPPED ; info . imageCompression = TGA_COMP_NONE ; break ; case 2 : info . imageType = TGA_TYPE_COLOR ; info . imageCompression = TGA_COMP_NONE ; break ; case 3 : info . imageType = TGA_TYPE_GRAY ; info . imageCompression = TGA_COMP_NONE ; break ; case 9 : info . imageType = TGA_TYPE_MAPPED ; info . imageCompression = TGA_COMP_RLE ; break ; case 10 : info . imageType = TGA_TYPE_COLOR ; info . imageCompression = TGA_COMP_RLE ; break ; case 11 : info . imageType = TGA_TYPE_GRAY ; info . imageCompression = TGA_COMP_RLE ; break ; default : info . imageType = 0 ; } info . idLength = header [ 0 ] ; info . colorMapType = header [ 1 ] ; info . colorMapIndex = header [ 3 ] + header [ 4 ] * 256 ; info . colorMapLength = header [ 5 ] + header [ 6 ] * 256 ; info . colorMapSize = header [ 7 ] ; info . xOrigin = header [ 8 ] + header [ 9 ] * 256 ; info . yOrigin = header [ 10 ] + header [ 11 ] * 256 ; info . width = header [ 12 ] + header [ 13 ] * 256 ; info . height = header [ 14 ] + header [ 15 ] * 256 ; info . bpp = header [ 16 ] ; info . bytes = ( info . bpp + 7 ) / 8 ; info . alphaBits = header [ 17 ] & 0x0f ; info . flipHoriz = ( header [ 17 ] & 0x10 ) ? 1 : 0 ; info . flipVert = ( header [ 17 ] & 0x20 ) ? 0 : 1 ; if ( info . alphaBits == info . bpp ) info . alphaBits = 0 ; if ( info . alphaBits == 0 ) { if ( info . imageType == TGA_TYPE_COLOR && info . bpp == 32 ) info . alphaBits = 8 ; if ( info . imageType == TGA_TYPE_GRAY && info . bpp == 16 ) info . alphaBits = 8 ; } switch ( info . imageType ) { case TGA_TYPE_MAPPED : if ( info . bpp != 8 ) { g_message ( \"Unhandled<S2SV_blank>sub-format<S2SV_blank>in<S2SV_blank>\\'%s\\'<S2SV_blank>(type<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>bpp<S2SV_blank>=<S2SV_blank>%u)\" , gimp_filename_to_utf8 ( filename ) , info . imageType , info . bpp ) ; return - 1 ; } break ; case TGA_TYPE_COLOR : if ( ( info . bpp != 15 && info . bpp != 16 && info . bpp != 24 && info . bpp != 32 ) || ( ( info . bpp == 15 || info . bpp == 24 ) && info . alphaBits != 0 ) || <S2SV_StartBug> ( info . bpp == 16 && info . alphaBits != 1 ) || <S2SV_EndBug> ( info . bpp == 32 && info . alphaBits != 8 ) ) { g_message ( \"Unhandled<S2SV_blank>sub-format<S2SV_blank>in<S2SV_blank>\\'%s\\'<S2SV_blank>(type<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>bpp<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>alpha<S2SV_blank>=<S2SV_blank>%u)\" , gimp_filename_to_utf8 ( filename ) , info . imageType , info . bpp , info . alphaBits ) ; return - 1 ; } break ; case TGA_TYPE_GRAY : if ( info . bpp != 8 && ( info . alphaBits != 8 || ( info . bpp != 16 && info . bpp != 15 ) ) ) { g_message ( \"Unhandled<S2SV_blank>sub-format<S2SV_blank>in<S2SV_blank>\\'%s\\'<S2SV_blank>(type<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>bpp<S2SV_blank>=<S2SV_blank>%u)\" , gimp_filename_to_utf8 ( filename ) , info . imageType , info . bpp ) ; return - 1 ; } break ; default : g_message ( \"Unknown<S2SV_blank>image<S2SV_blank>type<S2SV_blank>%u<S2SV_blank>for<S2SV_blank>\\'%s\\'\" , info . imageType , gimp_filename_to_utf8 ( filename ) ) ; return - 1 ; } if ( info . bytes * 8 != info . bpp && info . bpp != 15 ) { g_message ( \"Unhandled<S2SV_blank>sub-format<S2SV_blank>in<S2SV_blank>\\'%s\\'<S2SV_blank>(type<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>bpp<S2SV_blank>=<S2SV_blank>%u)\" , gimp_filename_to_utf8 ( filename ) , info . imageType , info . bpp ) ; return - 1 ; } if ( info . imageType == TGA_TYPE_MAPPED && info . colorMapType != 1 ) { g_message ( \"Indexed<S2SV_blank>image<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>map<S2SV_blank>type<S2SV_blank>%u\" , info . colorMapType ) ; return - 1 ; } else if ( info . imageType != TGA_TYPE_MAPPED && info . colorMapType != 0 ) { g_message ( \"Non-indexed<S2SV_blank>image<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>map<S2SV_blank>type<S2SV_blank>%u\" , info . colorMapType ) ; return - 1 ; } if ( info . idLength && fseek ( fp , info . idLength , SEEK_CUR ) ) { g_message ( \"File<S2SV_blank>\\'%s\\'<S2SV_blank>is<S2SV_blank>truncated<S2SV_blank>or<S2SV_blank>corrupted\" , gimp_filename_to_utf8 ( filename ) ) ; return - 1 ; } image_ID = ReadImage ( fp , & info , filename ) ; fclose ( fp ) ; return image_ID ; }", "target": "<S2SV_ModStart> alphaBits != 1 && info . alphaBits != 0"}
{"source": "CWE-78 do_ed_script ( char const * inname , char const * outname , bool * outname_needs_removal , FILE * ofp ) { static char const editor_program [ ] = EDITOR_PROGRAM ; file_offset beginning_of_this_line ; size_t chars_read ; FILE * tmpfp = 0 ; char const * tmpname ; int tmpfd ; pid_t pid ; if ( ! dry_run && ! skip_rest_of_patch ) { tmpfd = make_tempfile ( & tmpname , 'e' , NULL , O_RDWR | O_BINARY , 0 ) ; if ( tmpfd == - 1 ) pfatal ( \"Can\\'t<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>file<S2SV_blank>%s\" , quotearg ( tmpname ) ) ; tmpfp = fdopen ( tmpfd , \"w+b\" ) ; if ( ! tmpfp ) pfatal ( \"Can\\'t<S2SV_blank>open<S2SV_blank>stream<S2SV_blank>for<S2SV_blank>file<S2SV_blank>%s\" , quotearg ( tmpname ) ) ; } for ( ; ; ) { char ed_command_letter ; beginning_of_this_line = file_tell ( pfp ) ; chars_read = get_line ( ) ; if ( ! chars_read ) { next_intuit_at ( beginning_of_this_line , p_input_line ) ; break ; } ed_command_letter = get_ed_command_letter ( buf ) ; if ( ed_command_letter ) { if ( tmpfp ) if ( ! fwrite ( buf , sizeof * buf , chars_read , tmpfp ) ) write_fatal ( ) ; if ( ed_command_letter != 'd' && ed_command_letter != 's' ) { p_pass_comments_through = true ; while ( ( chars_read = get_line ( ) ) != 0 ) { if ( tmpfp ) if ( ! fwrite ( buf , sizeof * buf , chars_read , tmpfp ) ) write_fatal ( ) ; if ( chars_read == 2 && strEQ ( buf , \".\\\\n\" ) ) break ; } p_pass_comments_through = false ; } } else { next_intuit_at ( beginning_of_this_line , p_input_line ) ; break ; } } if ( ! tmpfp ) return ; if ( fwrite ( \"w\\\\nq\\\\n\" , sizeof ( char ) , ( size_t ) 4 , tmpfp ) == 0 || fflush ( tmpfp ) != 0 ) write_fatal ( ) ; if ( lseek ( tmpfd , 0 , SEEK_SET ) == - 1 ) pfatal ( \"Can\\'t<S2SV_blank>rewind<S2SV_blank>to<S2SV_blank>the<S2SV_blank>beginning<S2SV_blank>of<S2SV_blank>file<S2SV_blank>%s\" , quotearg ( tmpname ) ) ; if ( ! dry_run && ! skip_rest_of_patch ) { int exclusive = * outname_needs_removal ? 0 : O_EXCL ; * outname_needs_removal = true ; if ( inerrno != ENOENT ) { * outname_needs_removal = true ; copy_file ( inname , outname , 0 , exclusive , instat . st_mode , true ) ; } <S2SV_StartBug> sprintf ( buf , \"%s<S2SV_blank>%s%s\" , editor_program , <S2SV_EndBug> verbosity == VERBOSE ? \"\" : \"-<S2SV_blank>\" , outname ) ; fflush ( stdout ) ; pid = fork ( ) ; if ( pid == - 1 ) pfatal ( \"Can\\'t<S2SV_blank>fork\" ) ; else if ( pid == 0 ) { dup2 ( tmpfd , 0 ) ; <S2SV_StartBug> execl ( \"/bin/sh\" , \"sh\" , \"-c\" , buf , ( char * ) 0 ) ; <S2SV_EndBug> _exit ( 2 ) ; } else { int wstatus ; if ( waitpid ( pid , & wstatus , 0 ) == - 1 || ! WIFEXITED ( wstatus ) || WEXITSTATUS ( wstatus ) != 0 ) fatal ( \"%s<S2SV_blank>FAILED\" , editor_program ) ; } } fclose ( tmpfp ) ; safe_unlink ( tmpname ) ; if ( ofp ) { FILE * ifp = fopen ( outname , binary_transput ? \"rb\" : \"r\" ) ; int c ; if ( ! ifp ) pfatal ( \"can\\'t<S2SV_blank>open<S2SV_blank>\\'%s\\'\" , outname ) ; while ( ( c = getc ( ifp ) ) != EOF ) if ( putc ( c , ofp ) == EOF ) write_fatal ( ) ; if ( ferror ( ifp ) || fclose ( ifp ) != 0 ) read_fatal ( ) ; } }", "target": "<S2SV_ModStart> ) ; } <S2SV_ModEnd> fflush ( stdout <S2SV_ModStart> 0 ) ; assert ( outname [ 0 ] != '!' && outname [ 0 ] != '-' ) ; execlp ( editor_program , editor_program , \"-\" , outname <S2SV_ModEnd> , ( char <S2SV_ModStart> char * ) NULL <S2SV_ModEnd> ) ; _exit"}
{"source": "CWE-787 _eddsa_hash ( const struct ecc_modulo * m , mp_limb_t * rp , size_t digest_size , const uint8_t * digest ) { mp_size_t nlimbs = ( 8 * digest_size + GMP_NUMB_BITS - 1 ) / GMP_NUMB_BITS ; <S2SV_StartBug> <S2SV_EndBug> mpn_set_base256_le ( rp , nlimbs , digest , digest_size ) ; if ( nlimbs > 2 * m -> size ) { mp_limb_t hi = rp [ 2 * m -> size ] ; assert ( nlimbs == 2 * m -> size + 1 ) ; hi = mpn_addmul_1 ( rp + m -> size , m -> B , m -> size , hi ) ; assert ( hi <= 1 ) ; hi = mpn_cnd_add_n ( hi , rp + m -> size , rp + m -> size , m -> B , m -> size ) ; assert ( hi == 0 ) ; } <S2SV_StartBug> m -> mod ( m , rp , rp ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> / GMP_NUMB_BITS ; mp_limb_t cy ; <S2SV_ModStart> m , rp + m -> size , rp ) ; cy = mpn_sub_n ( rp , rp + m -> size , m -> m , m -> size ) ; cnd_copy ( cy , rp , rp + m -> size , m -> size <S2SV_ModEnd> ) ; }"}
{"source": "CWE-190 ds_fgetstr ( FILE * f , dynamic_string * s , char eos ) { <S2SV_StartBug> int insize ; <S2SV_EndBug> int strsize ; int next_ch ; insize = 0 ; <S2SV_StartBug> strsize = s -> ds_length ; <S2SV_EndBug> <S2SV_StartBug> next_ch = getc ( f ) ; <S2SV_EndBug> while ( next_ch != eos && next_ch != EOF ) { <S2SV_StartBug> if ( insize >= strsize - 1 ) <S2SV_EndBug> { <S2SV_StartBug> ds_resize ( s , strsize * 2 + 2 ) ; <S2SV_EndBug> strsize = s -> ds_length ; } <S2SV_StartBug> s -> ds_string [ insize ++ ] = next_ch ; <S2SV_EndBug> <S2SV_StartBug> next_ch = getc ( f ) ; <S2SV_EndBug> } <S2SV_StartBug> s -> ds_string [ insize ++ ] = '\\\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( insize == 1 && next_ch == EOF ) <S2SV_EndBug> return NULL ; else return s -> ds_string ; }", "target": "<S2SV_ModStart> ) { int next_ch ; s -> ds_idx <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; while ( ( <S2SV_ModEnd> next_ch = getc <S2SV_ModStart> ( f ) ) <S2SV_ModEnd> != eos && <S2SV_ModStart> EOF ) { <S2SV_ModEnd> ds_resize ( s <S2SV_ModStart> ds_resize ( s ) ; <S2SV_ModEnd> s -> ds_string <S2SV_ModStart> -> ds_string [ s -> ds_idx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> = next_ch ; } ds_resize ( s ) ; <S2SV_ModEnd> s -> ds_string <S2SV_ModStart> -> ds_string [ s -> ds_idx <S2SV_ModEnd> ] = '\\\\0' <S2SV_ModStart> ; if ( s -> ds_idx == 0 <S2SV_ModEnd> && next_ch =="}
{"source": "CWE-310 unsigned int get_random_int ( void ) { <S2SV_StartBug> return secure_ip_id ( ( __force __be32 ) ( current -> pid + jiffies ) ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> void ) { struct keydata * keyptr ; __u32 * hash = get_cpu_var ( get_random_int_hash ) ; int ret ; keyptr = get_keyptr ( ) ; hash [ 0 ] += <S2SV_ModEnd> current -> pid <S2SV_ModStart> pid + jiffies + get_cycles ( ) + ( int ) ( long ) & ret ; ret = half_md4_transform ( hash , keyptr -> secret ) ; put_cpu_var ( get_random_int_hash ) ; return ret <S2SV_ModEnd> ; }"}
{"source": "CWE-476 int ssl3_send_client_key_exchange ( SSL * s ) { unsigned char * p , * d ; int n ; unsigned long l ; # ifndef OPENSSL_NO_RSA unsigned char * q ; EVP_PKEY * pkey = NULL ; # endif # ifndef OPENSSL_NO_KRB5 KSSL_ERR kssl_err ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * clnt_ecdh = NULL ; const EC_POINT * srvr_ecpoint = NULL ; EVP_PKEY * srvr_pub_pkey = NULL ; unsigned char * encodedPoint = NULL ; int encoded_pt_len = 0 ; BN_CTX * bn_ctx = NULL ; # endif if ( s -> state == SSL3_ST_CW_KEY_EXCH_A ) { d = ( unsigned char * ) s -> init_buf -> data ; p = & ( d [ 4 ] ) ; l = s -> s3 -> tmp . new_cipher -> algorithms ; if ( 0 ) { } # ifndef OPENSSL_NO_RSA else if ( l & SSL_kRSA ) { RSA * rsa ; unsigned char tmp_buf [ SSL_MAX_MASTER_KEY_LENGTH ] ; if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) rsa = s -> session -> sess_cert -> peer_rsa_tmp ; else { pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; if ( ( pkey == NULL ) || ( pkey -> type != EVP_PKEY_RSA ) || ( pkey -> pkey . rsa == NULL ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } rsa = pkey -> pkey . rsa ; EVP_PKEY_free ( pkey ) ; } tmp_buf [ 0 ] = s -> client_version >> 8 ; tmp_buf [ 1 ] = s -> client_version & 0xff ; if ( RAND_bytes ( & ( tmp_buf [ 2 ] ) , sizeof tmp_buf - 2 ) <= 0 ) goto err ; s -> session -> master_key_length = sizeof tmp_buf ; q = p ; if ( s -> version > SSL3_VERSION ) p += 2 ; n = RSA_public_encrypt ( sizeof tmp_buf , tmp_buf , p , rsa , RSA_PKCS1_PADDING ) ; # ifdef PKCS1_CHECK if ( s -> options & SSL_OP_PKCS1_CHECK_1 ) p [ 1 ] ++ ; if ( s -> options & SSL_OP_PKCS1_CHECK_2 ) tmp_buf [ 0 ] = 0x70 ; # endif if ( n <= 0 ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_BAD_RSA_ENCRYPT ) ; goto err ; } if ( s -> version > SSL3_VERSION ) { s2n ( n , q ) ; n += 2 ; } s -> session -> master_key_length = s -> method -> ssl3_enc -> generate_master_secret ( s , s -> session -> master_key , tmp_buf , sizeof tmp_buf ) ; OPENSSL_cleanse ( tmp_buf , sizeof tmp_buf ) ; } # endif # ifndef OPENSSL_NO_KRB5 else if ( l & SSL_kKRB5 ) { krb5_error_code krb5rc ; KSSL_CTX * kssl_ctx = s -> kssl_ctx ; krb5_data * enc_ticket ; krb5_data authenticator , * authp = NULL ; EVP_CIPHER_CTX ciph_ctx ; EVP_CIPHER * enc = NULL ; unsigned char iv [ EVP_MAX_IV_LENGTH ] ; unsigned char tmp_buf [ SSL_MAX_MASTER_KEY_LENGTH ] ; unsigned char epms [ SSL_MAX_MASTER_KEY_LENGTH + EVP_MAX_IV_LENGTH ] ; int padl , outl = sizeof ( epms ) ; EVP_CIPHER_CTX_init ( & ciph_ctx ) ; # ifdef KSSL_DEBUG printf ( \"ssl3_send_client_key_exchange(%lx<S2SV_blank>&<S2SV_blank>%lx)\\\\n\" , l , SSL_kKRB5 ) ; # endif authp = NULL ; # ifdef KRB5SENDAUTH if ( KRB5SENDAUTH ) authp = & authenticator ; # endif krb5rc = kssl_cget_tkt ( kssl_ctx , & enc_ticket , authp , & kssl_err ) ; enc = kssl_map_enc ( kssl_ctx -> enctype ) ; if ( enc == NULL ) goto err ; # ifdef KSSL_DEBUG { printf ( \"kssl_cget_tkt<S2SV_blank>rtn<S2SV_blank>%d\\\\n\" , krb5rc ) ; if ( krb5rc && kssl_err . text ) printf ( \"kssl_cget_tkt<S2SV_blank>kssl_err=%s\\\\n\" , kssl_err . text ) ; } # endif if ( krb5rc ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , kssl_err . reason ) ; goto err ; } s2n ( enc_ticket -> length , p ) ; memcpy ( p , enc_ticket -> data , enc_ticket -> length ) ; p += enc_ticket -> length ; n = enc_ticket -> length + 2 ; if ( authp && authp -> length ) { s2n ( authp -> length , p ) ; memcpy ( p , authp -> data , authp -> length ) ; p += authp -> length ; n += authp -> length + 2 ; free ( authp -> data ) ; authp -> data = NULL ; authp -> length = 0 ; } else { s2n ( 0 , p ) ; n += 2 ; } tmp_buf [ 0 ] = s -> client_version >> 8 ; tmp_buf [ 1 ] = s -> client_version & 0xff ; if ( RAND_bytes ( & ( tmp_buf [ 2 ] ) , sizeof tmp_buf - 2 ) <= 0 ) goto err ; memset ( iv , 0 , sizeof iv ) ; EVP_EncryptInit_ex ( & ciph_ctx , enc , NULL , kssl_ctx -> key , iv ) ; EVP_EncryptUpdate ( & ciph_ctx , epms , & outl , tmp_buf , sizeof tmp_buf ) ; EVP_EncryptFinal_ex ( & ciph_ctx , & ( epms [ outl ] ) , & padl ) ; outl += padl ; if ( outl > sizeof epms ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } EVP_CIPHER_CTX_cleanup ( & ciph_ctx ) ; s2n ( outl , p ) ; memcpy ( p , epms , outl ) ; p += outl ; n += outl + 2 ; s -> session -> master_key_length = s -> method -> ssl3_enc -> generate_master_secret ( s , s -> session -> master_key , tmp_buf , sizeof tmp_buf ) ; OPENSSL_cleanse ( tmp_buf , sizeof tmp_buf ) ; OPENSSL_cleanse ( epms , outl ) ; } # endif # ifndef OPENSSL_NO_DH else if ( l & ( SSL_kEDH | SSL_kDHr | SSL_kDHd ) ) { DH * dh_srvr , * dh_clnt ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; } if ( s -> session -> sess_cert -> peer_dh_tmp != NULL ) dh_srvr = s -> session -> sess_cert -> peer_dh_tmp ; else { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNABLE_TO_FIND_DH_PARAMETERS ) ; goto err ; } if ( ( dh_clnt = DHparams_dup ( dh_srvr ) ) == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_DH_LIB ) ; goto err ; } if ( ! DH_generate_key ( dh_clnt ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_DH_LIB ) ; goto err ; } n = DH_compute_key ( p , dh_srvr -> pub_key , dh_clnt ) ; if ( n <= 0 ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_DH_LIB ) ; goto err ; } s -> session -> master_key_length = s -> method -> ssl3_enc -> generate_master_secret ( s , s -> session -> master_key , p , n ) ; memset ( p , 0 , n ) ; n = BN_num_bytes ( dh_clnt -> pub_key ) ; s2n ( n , p ) ; BN_bn2bin ( dh_clnt -> pub_key , p ) ; n += 2 ; DH_free ( dh_clnt ) ; } # endif # ifndef OPENSSL_NO_ECDH else if ( ( l & SSL_kECDH ) || ( l & SSL_kECDHE ) ) { const EC_GROUP * srvr_group = NULL ; EC_KEY * tkey ; int ecdh_clnt_cert = 0 ; int field_size = 0 ; <S2SV_StartBug> if ( ( l & SSL_kECDH ) && ( s -> cert != NULL ) ) <S2SV_EndBug> { } if ( s -> session -> sess_cert -> peer_ecdh_tmp != NULL ) { tkey = s -> session -> sess_cert -> peer_ecdh_tmp ; } else { srvr_pub_pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_ECC ] . x509 ) ; if ( ( srvr_pub_pkey == NULL ) || ( srvr_pub_pkey -> type != EVP_PKEY_EC ) || ( srvr_pub_pkey -> pkey . ec == NULL ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } tkey = srvr_pub_pkey -> pkey . ec ; } srvr_group = EC_KEY_get0_group ( tkey ) ; srvr_ecpoint = EC_KEY_get0_public_key ( tkey ) ; if ( ( srvr_group == NULL ) || ( srvr_ecpoint == NULL ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( ( clnt_ecdh = EC_KEY_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } if ( ! EC_KEY_set_group ( clnt_ecdh , srvr_group ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } if ( ecdh_clnt_cert ) { const BIGNUM * priv_key ; tkey = s -> cert -> key -> privatekey -> pkey . ec ; priv_key = EC_KEY_get0_private_key ( tkey ) ; if ( priv_key == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } if ( ! EC_KEY_set_private_key ( clnt_ecdh , priv_key ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } } else { if ( ! ( EC_KEY_generate_key ( clnt_ecdh ) ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_ECDH_LIB ) ; goto err ; } } field_size = EC_GROUP_get_degree ( srvr_group ) ; if ( field_size <= 0 ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_ECDH_LIB ) ; goto err ; } n = ECDH_compute_key ( p , ( field_size + 7 ) / 8 , srvr_ecpoint , clnt_ecdh , NULL ) ; if ( n <= 0 ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_ECDH_LIB ) ; goto err ; } s -> session -> master_key_length = s -> method -> ssl3_enc -> generate_master_secret ( s , s -> session -> master_key , p , n ) ; memset ( p , 0 , n ) ; if ( ecdh_clnt_cert ) { n = 0 ; } else { encoded_pt_len = EC_POINT_point2oct ( srvr_group , EC_KEY_get0_public_key ( clnt_ecdh ) , POINT_CONVERSION_UNCOMPRESSED , NULL , 0 , NULL ) ; encodedPoint = ( unsigned char * ) OPENSSL_malloc ( encoded_pt_len * sizeof ( unsigned char ) ) ; bn_ctx = BN_CTX_new ( ) ; if ( ( encodedPoint == NULL ) || ( bn_ctx == NULL ) ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } n = EC_POINT_point2oct ( srvr_group , EC_KEY_get0_public_key ( clnt_ecdh ) , POINT_CONVERSION_UNCOMPRESSED , encodedPoint , encoded_pt_len , bn_ctx ) ; * p = n ; p += 1 ; memcpy ( ( unsigned char * ) p , encodedPoint , n ) ; n += 1 ; } BN_CTX_free ( bn_ctx ) ; if ( encodedPoint != NULL ) OPENSSL_free ( encodedPoint ) ; if ( clnt_ecdh != NULL ) EC_KEY_free ( clnt_ecdh ) ; EVP_PKEY_free ( srvr_pub_pkey ) ; } # endif else { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } * ( d ++ ) = SSL3_MT_CLIENT_KEY_EXCHANGE ; l2n3 ( n , d ) ; s -> state = SSL3_ST_CW_KEY_EXCH_B ; s -> init_num = n + 4 ; s -> init_off = 0 ; } return ( ssl3_do_write ( s , SSL3_RT_HANDSHAKE ) ) ; err : # ifndef OPENSSL_NO_ECDH BN_CTX_free ( bn_ctx ) ; if ( encodedPoint != NULL ) OPENSSL_free ( encodedPoint ) ; if ( clnt_ecdh != NULL ) EC_KEY_free ( clnt_ecdh ) ; EVP_PKEY_free ( srvr_pub_pkey ) ; # endif return ( - 1 ) ; }", "target": "<S2SV_ModStart> ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; } if ("}
{"source": "CWE-254 int X509_verify_cert ( X509_STORE_CTX * ctx ) { X509 * x , * xtmp , * xtmp2 , * chain_ss = NULL ; int bad_chain = 0 ; X509_VERIFY_PARAM * param = ctx -> param ; int depth , i , ok = 0 ; int num , j , retry ; int ( * cb ) ( int xok , X509_STORE_CTX * xctx ) ; STACK_OF ( X509 ) * sktmp = NULL ; if ( ctx -> cert == NULL ) { X509err ( X509_F_X509_VERIFY_CERT , X509_R_NO_CERT_SET_FOR_US_TO_VERIFY ) ; return - 1 ; } if ( ctx -> chain != NULL ) { X509err ( X509_F_X509_VERIFY_CERT , ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED ) ; return - 1 ; } cb = ctx -> verify_cb ; if ( ( ( ctx -> chain = sk_X509_new_null ( ) ) == NULL ) || ( ! sk_X509_push ( ctx -> chain , ctx -> cert ) ) ) { X509err ( X509_F_X509_VERIFY_CERT , ERR_R_MALLOC_FAILURE ) ; goto end ; } CRYPTO_add ( & ctx -> cert -> references , 1 , CRYPTO_LOCK_X509 ) ; ctx -> last_untrusted = 1 ; if ( ctx -> untrusted != NULL && ( sktmp = sk_X509_dup ( ctx -> untrusted ) ) == NULL ) { X509err ( X509_F_X509_VERIFY_CERT , ERR_R_MALLOC_FAILURE ) ; goto end ; } num = sk_X509_num ( ctx -> chain ) ; x = sk_X509_value ( ctx -> chain , num - 1 ) ; depth = param -> depth ; for ( ; ; ) { if ( depth < num ) break ; if ( ctx -> check_issued ( ctx , x , x ) ) break ; if ( ctx -> untrusted != NULL ) { xtmp = find_issuer ( ctx , sktmp , x ) ; if ( xtmp != NULL ) { if ( ! sk_X509_push ( ctx -> chain , xtmp ) ) { X509err ( X509_F_X509_VERIFY_CERT , ERR_R_MALLOC_FAILURE ) ; goto end ; } CRYPTO_add ( & xtmp -> references , 1 , CRYPTO_LOCK_X509 ) ; ( void ) sk_X509_delete_ptr ( sktmp , xtmp ) ; ctx -> last_untrusted ++ ; x = xtmp ; num ++ ; continue ; } } break ; } j = num ; do { i = sk_X509_num ( ctx -> chain ) ; x = sk_X509_value ( ctx -> chain , i - 1 ) ; if ( ctx -> check_issued ( ctx , x , x ) ) { if ( sk_X509_num ( ctx -> chain ) == 1 ) { ok = ctx -> get_issuer ( & xtmp , ctx , x ) ; if ( ( ok <= 0 ) || X509_cmp ( x , xtmp ) ) { ctx -> error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT ; ctx -> current_cert = x ; ctx -> error_depth = i - 1 ; if ( ok == 1 ) X509_free ( xtmp ) ; bad_chain = 1 ; ok = cb ( 0 , ctx ) ; if ( ! ok ) goto end ; } else { X509_free ( x ) ; x = xtmp ; ( void ) sk_X509_set ( ctx -> chain , i - 1 , x ) ; ctx -> last_untrusted = 0 ; } } else { chain_ss = sk_X509_pop ( ctx -> chain ) ; ctx -> last_untrusted -- ; num -- ; j -- ; x = sk_X509_value ( ctx -> chain , num - 1 ) ; } } for ( ; ; ) { if ( depth < num ) break ; if ( ctx -> check_issued ( ctx , x , x ) ) break ; ok = ctx -> get_issuer ( & xtmp , ctx , x ) ; if ( ok < 0 ) return ok ; if ( ok == 0 ) break ; x = xtmp ; if ( ! sk_X509_push ( ctx -> chain , x ) ) { X509_free ( xtmp ) ; X509err ( X509_F_X509_VERIFY_CERT , ERR_R_MALLOC_FAILURE ) ; return 0 ; } num ++ ; } retry = 0 ; <S2SV_StartBug> if ( j == ctx -> last_untrusted && <S2SV_EndBug> ! ( ctx -> param -> flags & X509_V_FLAG_NO_ALT_CHAINS ) ) { while ( j -- > 1 ) { xtmp2 = sk_X509_value ( ctx -> chain , j - 1 ) ; ok = ctx -> get_issuer ( & xtmp , ctx , xtmp2 ) ; if ( ok < 0 ) goto end ; if ( ok > 0 ) { X509_free ( xtmp ) ; while ( num > j ) { xtmp = sk_X509_pop ( ctx -> chain ) ; X509_free ( xtmp ) ; num -- ; } ctx -> last_untrusted = sk_X509_num ( ctx -> chain ) ; retry = 1 ; break ; } } } } while ( retry ) ; if ( ! ctx -> check_issued ( ctx , x , x ) ) { if ( ( chain_ss == NULL ) || ! ctx -> check_issued ( ctx , x , chain_ss ) ) { if ( ctx -> last_untrusted >= num ) ctx -> error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY ; else ctx -> error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT ; ctx -> current_cert = x ; } else { sk_X509_push ( ctx -> chain , chain_ss ) ; num ++ ; ctx -> last_untrusted = num ; ctx -> current_cert = chain_ss ; ctx -> error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN ; chain_ss = NULL ; } ctx -> error_depth = num - 1 ; bad_chain = 1 ; ok = cb ( 0 , ctx ) ; if ( ! ok ) goto end ; } ok = check_chain_extensions ( ctx ) ; if ( ! ok ) goto end ; ok = check_name_constraints ( ctx ) ; if ( ! ok ) goto end ; if ( param -> trust > 0 ) ok = check_trust ( ctx ) ; if ( ! ok ) goto end ; X509_get_pubkey_parameters ( NULL , ctx -> chain ) ; ok = ctx -> check_revocation ( ctx ) ; if ( ! ok ) goto end ; if ( ctx -> verify != NULL ) ok = ctx -> verify ( ctx ) ; else ok = internal_verify ( ctx ) ; if ( ! ok ) goto end ; # ifndef OPENSSL_NO_RFC3779 ok = v3_asid_validate_path ( ctx ) ; if ( ! ok ) goto end ; ok = v3_addr_validate_path ( ctx ) ; if ( ! ok ) goto end ; # endif if ( ! bad_chain && ( ctx -> param -> flags & X509_V_FLAG_POLICY_CHECK ) ) ok = ctx -> check_policy ( ctx ) ; if ( ! ok ) goto end ; if ( 0 ) { end : X509_get_pubkey_parameters ( NULL , ctx -> chain ) ; } if ( sktmp != NULL ) sk_X509_free ( sktmp ) ; if ( chain_ss != NULL ) X509_free ( chain_ss ) ; return ok ; }", "target": "<S2SV_ModStart> ; if ( num <S2SV_ModEnd> == ctx ->"}
{"source": "CWE-20 int ssl3_read_bytes ( SSL * s , int type , int * recvd_type , unsigned char * buf , int len , int peek ) { int al , i , j , ret ; unsigned int n , curr_rec , num_recs , read_bytes ; SSL3_RECORD * rr ; SSL3_BUFFER * rbuf ; void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ; rbuf = & s -> rlayer . rbuf ; if ( ! SSL3_BUFFER_is_initialised ( rbuf ) ) { if ( ! ssl3_setup_read_buffer ( s ) ) return ( - 1 ) ; } if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) { SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ( type == SSL3_RT_HANDSHAKE ) && ( s -> rlayer . handshake_fragment_len > 0 ) ) { unsigned char * src = s -> rlayer . handshake_fragment ; unsigned char * dst = buf ; unsigned int k ; n = 0 ; while ( ( len > 0 ) && ( s -> rlayer . handshake_fragment_len > 0 ) ) { * dst ++ = * src ++ ; len -- ; s -> rlayer . handshake_fragment_len -- ; n ++ ; } for ( k = 0 ; k < s -> rlayer . handshake_fragment_len ; k ++ ) s -> rlayer . handshake_fragment [ k ] = * src ++ ; if ( recvd_type != NULL ) * recvd_type = SSL3_RT_HANDSHAKE ; return n ; } if ( ! ossl_statem_get_in_handshake ( s ) && SSL_in_init ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } } start : s -> rwstate = SSL_NOTHING ; rr = s -> rlayer . rrec ; num_recs = RECORD_LAYER_get_numrpipes ( & s -> rlayer ) ; do { if ( num_recs == 0 ) { ret = ssl3_get_record ( s ) ; if ( ret <= 0 ) return ( ret ) ; num_recs = RECORD_LAYER_get_numrpipes ( & s -> rlayer ) ; if ( num_recs == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; } } for ( curr_rec = 0 ; curr_rec < num_recs && SSL3_RECORD_is_read ( & rr [ curr_rec ] ) ; curr_rec ++ ) ; if ( curr_rec == num_recs ) { RECORD_LAYER_set_numrpipes ( & s -> rlayer , 0 ) ; num_recs = 0 ; curr_rec = 0 ; } } while ( num_recs == 0 ) ; rr = & rr [ curr_rec ] ; if ( SSL3_RECORD_get_type ( rr ) != SSL3_RT_ALERT && SSL3_RECORD_get_length ( rr ) != 0 ) s -> rlayer . alert_count = 0 ; if ( s -> s3 -> change_cipher_spec && ( SSL3_RECORD_get_type ( rr ) != SSL3_RT_HANDSHAKE ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_DATA_BETWEEN_CCS_AND_FINISHED ) ; goto f_err ; } if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) { SSL3_RECORD_set_length ( rr , 0 ) ; s -> rwstate = SSL_NOTHING ; return ( 0 ) ; } if ( type == SSL3_RECORD_get_type ( rr ) || ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && type == SSL3_RT_HANDSHAKE && recvd_type != NULL ) ) { if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ; goto f_err ; } if ( type == SSL3_RT_HANDSHAKE && SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && s -> rlayer . handshake_fragment_len > 0 ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } if ( recvd_type != NULL ) * recvd_type = SSL3_RECORD_get_type ( rr ) ; if ( len <= 0 ) return ( len ) ; read_bytes = 0 ; do { if ( ( unsigned int ) len - read_bytes > SSL3_RECORD_get_length ( rr ) ) n = SSL3_RECORD_get_length ( rr ) ; else n = ( unsigned int ) len - read_bytes ; memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ; buf += n ; <S2SV_StartBug> if ( ! peek ) { <S2SV_EndBug> SSL3_RECORD_sub_length ( rr , n ) ; SSL3_RECORD_add_off ( rr , n ) ; if ( SSL3_RECORD_get_length ( rr ) == 0 ) { s -> rlayer . rstate = SSL_ST_READ_HEADER ; SSL3_RECORD_set_off ( rr , 0 ) ; SSL3_RECORD_set_read ( rr ) ; } } if ( SSL3_RECORD_get_length ( rr ) == 0 || ( peek && n == SSL3_RECORD_get_length ( rr ) ) ) { curr_rec ++ ; rr ++ ; } read_bytes += n ; } while ( type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < ( unsigned int ) len ) ; if ( read_bytes == 0 ) { goto start ; } if ( ! peek && curr_rec == num_recs && ( s -> mode & SSL_MODE_RELEASE_BUFFERS ) && SSL3_BUFFER_get_left ( rbuf ) == 0 ) ssl3_release_read_buffer ( s ) ; return read_bytes ; } if ( rr -> rec_version == SSL2_VERSION ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; } if ( s -> method -> version == TLS_ANY_VERSION && ( s -> server || rr -> type != SSL3_RT_ALERT ) ) { s -> version = rr -> rec_version ; al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } { unsigned int dest_maxlen = 0 ; unsigned char * dest = NULL ; unsigned int * dest_len = NULL ; if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_HANDSHAKE ) { dest_maxlen = sizeof s -> rlayer . handshake_fragment ; dest = s -> rlayer . handshake_fragment ; dest_len = & s -> rlayer . handshake_fragment_len ; } else if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_ALERT ) { dest_maxlen = sizeof s -> rlayer . alert_fragment ; dest = s -> rlayer . alert_fragment ; dest_len = & s -> rlayer . alert_fragment_len ; } if ( dest_maxlen > 0 ) { n = dest_maxlen - * dest_len ; if ( SSL3_RECORD_get_length ( rr ) < n ) n = SSL3_RECORD_get_length ( rr ) ; while ( n -- > 0 ) { dest [ ( * dest_len ) ++ ] = SSL3_RECORD_get_data ( rr ) [ SSL3_RECORD_get_off ( rr ) ] ; SSL3_RECORD_add_off ( rr , 1 ) ; SSL3_RECORD_add_length ( rr , - 1 ) ; } if ( * dest_len < dest_maxlen ) { SSL3_RECORD_set_read ( rr ) ; goto start ; } } } if ( ( ! s -> server ) && ( s -> rlayer . handshake_fragment_len >= 4 ) && ( s -> rlayer . handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) { s -> rlayer . handshake_fragment_len = 0 ; if ( ( s -> rlayer . handshake_fragment [ 1 ] != 0 ) || ( s -> rlayer . handshake_fragment [ 2 ] != 0 ) || ( s -> rlayer . handshake_fragment [ 3 ] != 0 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ; goto f_err ; } if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> rlayer . handshake_fragment , 4 , s , s -> msg_callback_arg ) ; if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) { ssl3_renegotiate ( s ) ; if ( ssl3_renegotiate_check ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( SSL3_BUFFER_get_left ( rbuf ) == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } } } goto start ; } if ( s -> server && SSL_is_init_finished ( s ) && ! s -> s3 -> send_connection_binding && ( s -> version > SSL3_VERSION ) && ( s -> rlayer . handshake_fragment_len >= 4 ) && ( s -> rlayer . handshake_fragment [ 0 ] == SSL3_MT_CLIENT_HELLO ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) && ! ( s -> ctx -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { SSL3_RECORD_set_length ( rr , 0 ) ; SSL3_RECORD_set_read ( rr ) ; ssl3_send_alert ( s , SSL3_AL_WARNING , SSL_AD_NO_RENEGOTIATION ) ; goto start ; } if ( s -> rlayer . alert_fragment_len >= 2 ) { int alert_level = s -> rlayer . alert_fragment [ 0 ] ; int alert_descr = s -> rlayer . alert_fragment [ 1 ] ; s -> rlayer . alert_fragment_len = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> rlayer . alert_fragment , 2 , s , s -> msg_callback_arg ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; if ( cb != NULL ) { j = ( alert_level << 8 ) | alert_descr ; cb ( s , SSL_CB_READ_ALERT , j ) ; } if ( alert_level == SSL3_AL_WARNING ) { s -> s3 -> warn_alert = alert_descr ; SSL3_RECORD_set_read ( rr ) ; s -> rlayer . alert_count ++ ; if ( s -> rlayer . alert_count == MAX_WARN_ALERT_COUNT ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_TOO_MANY_WARN_ALERTS ) ; goto f_err ; } if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) { s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } else if ( alert_descr == SSL_AD_NO_RENEGOTIATION ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_NO_RENEGOTIATION ) ; goto f_err ; } # ifdef SSL_AD_MISSING_SRP_USERNAME else if ( alert_descr == SSL_AD_MISSING_SRP_USERNAME ) return ( 0 ) ; # endif } else if ( alert_level == SSL3_AL_FATAL ) { char tmp [ 16 ] ; s -> rwstate = SSL_NOTHING ; s -> s3 -> fatal_alert = alert_descr ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ; BIO_snprintf ( tmp , sizeof tmp , \"%d\" , alert_descr ) ; ERR_add_error_data ( 2 , \"SSL<S2SV_blank>alert<S2SV_blank>number<S2SV_blank>\" , tmp ) ; s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; SSL3_RECORD_set_read ( rr ) ; SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; return ( 0 ) ; } else { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ; goto f_err ; } goto start ; } if ( s -> shutdown & SSL_SENT_SHUTDOWN ) { s -> rwstate = SSL_NOTHING ; SSL3_RECORD_set_length ( rr , 0 ) ; SSL3_RECORD_set_read ( rr ) ; return ( 0 ) ; } if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } if ( ( s -> rlayer . handshake_fragment_len >= 4 ) && ! ossl_statem_get_in_handshake ( s ) ) { if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) { ossl_statem_set_in_init ( s , 1 ) ; s -> renegotiate = 1 ; s -> new_session = 1 ; } i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( SSL3_BUFFER_get_left ( rbuf ) == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } goto start ; } switch ( SSL3_RECORD_get_type ( rr ) ) { default : if ( s -> version >= TLS1_VERSION && s -> version <= TLS1_1_VERSION ) { SSL3_RECORD_set_length ( rr , 0 ) ; SSL3_RECORD_set_read ( rr ) ; goto start ; } al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; case SSL3_RT_APPLICATION_DATA : if ( ossl_statem_app_data_allowed ( s ) ) { s -> s3 -> in_read_app_data = 2 ; return ( - 1 ) ; } else { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } } f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; return ( - 1 ) ; }", "target": "<S2SV_ModStart> ; if ( peek ) { if ( SSL3_RECORD_get_length ( rr ) == 0 ) SSL3_RECORD_set_read ( rr ) ; } else <S2SV_ModEnd> { SSL3_RECORD_sub_length ("}
{"source": "CWE-772 void auth_client_request_abort ( struct auth_client_request * * _request ) { struct auth_client_request * request = * _request ; * _request = NULL ; auth_client_send_cancel ( request -> conn -> client , request -> id ) ; call_callback ( request , AUTH_REQUEST_STATUS_ABORT , NULL , NULL ) ; <S2SV_StartBug> pool_unref ( & request -> pool ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> NULL ) ; auth_server_connection_remove_request ( request -> conn , request -> id ) ;"}
{"source": "CWE-203 ECDSA_SIG * ossl_ecdsa_sign_sig ( const unsigned char * dgst , int dgst_len , const BIGNUM * in_kinv , const BIGNUM * in_r , EC_KEY * eckey ) { int ok = 0 , i ; <S2SV_StartBug> BIGNUM * kinv = NULL , * s , * m = NULL , * tmp = NULL ; <S2SV_EndBug> const BIGNUM * order , * ckinv ; BN_CTX * ctx = NULL ; const EC_GROUP * group ; ECDSA_SIG * ret ; const BIGNUM * priv_key ; group = EC_KEY_get0_group ( eckey ) ; priv_key = EC_KEY_get0_private_key ( eckey ) ; if ( group == NULL || priv_key == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_PASSED_NULL_PARAMETER ) ; return NULL ; } if ( ! EC_KEY_can_sign ( eckey ) ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING ) ; return NULL ; } ret = ECDSA_SIG_new ( ) ; if ( ret == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_MALLOC_FAILURE ) ; return NULL ; } ret -> r = BN_new ( ) ; ret -> s = BN_new ( ) ; if ( ret -> r == NULL || ret -> s == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_MALLOC_FAILURE ) ; goto err ; } s = ret -> s ; <S2SV_StartBug> if ( ( ctx = BN_CTX_new ( ) ) == NULL || <S2SV_EndBug> ( tmp = BN_new ( ) ) == NULL || ( m = BN_new ( ) ) == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_MALLOC_FAILURE ) ; goto err ; } order = EC_GROUP_get0_order ( group ) ; if ( order == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_EC_LIB ) ; goto err ; } i = BN_num_bits ( order ) ; if ( 8 * dgst_len > i ) dgst_len = ( i + 7 ) / 8 ; if ( ! BN_bin2bn ( dgst , dgst_len , m ) ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } if ( ( 8 * dgst_len > i ) && ! BN_rshift ( m , m , 8 - ( i & 0x7 ) ) ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } do { if ( in_kinv == NULL || in_r == NULL ) { if ( ! ecdsa_sign_setup ( eckey , ctx , & kinv , & ret -> r , dgst , dgst_len ) ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_ECDSA_LIB ) ; goto err ; } ckinv = kinv ; } else { ckinv = in_kinv ; if ( BN_copy ( ret -> r , in_r ) == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_MALLOC_FAILURE ) ; goto err ; } } <S2SV_StartBug> if ( ! BN_mod_mul ( tmp , priv_key , ret -> r , order , ctx ) ) { <S2SV_EndBug> ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } <S2SV_StartBug> if ( ! BN_mod_add_quick ( s , tmp , m , order ) ) { <S2SV_EndBug> ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } <S2SV_StartBug> if ( ! BN_mod_mul ( s , s , ckinv , order , ctx ) ) { <S2SV_EndBug> ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } if ( BN_is_zero ( s ) ) { if ( in_kinv != NULL && in_r != NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , EC_R_NEED_NEW_SETUP_VALUES ) ; goto err ; } } else break ; } while ( 1 ) ; ok = 1 ; err : if ( ! ok ) { ECDSA_SIG_free ( ret ) ; ret = NULL ; } <S2SV_StartBug> BN_CTX_free ( ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_clear_free ( m ) ; <S2SV_EndBug> BN_clear_free ( tmp ) ; BN_clear_free ( kinv ) ; return ret ; }", "target": "<S2SV_ModStart> tmp = NULL , * blind = NULL ; BIGNUM * blindm = NULL <S2SV_ModStart> -> s ; ctx = BN_CTX_secure_new ( ) ; if ( ctx == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_MALLOC_FAILURE ) ; goto err ; } BN_CTX_start ( ctx ) ; tmp = BN_CTX_get ( ctx ) ; m = BN_CTX_get ( ctx ) ; blind = BN_CTX_get ( ctx ) ; blindm = BN_CTX_get ( ctx ) ; if ( blindm <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ; } } do { if ( ! BN_rand ( blind , BN_num_bits ( order ) - 1 , BN_RAND_TOP_ANY , BN_RAND_BOTTOM_ANY ) ) goto err ; } while ( BN_is_zero ( blind ) ) ; BN_set_flags ( blind , BN_FLG_CONSTTIME ) ; BN_set_flags ( blindm , BN_FLG_CONSTTIME ) ; BN_set_flags ( tmp , BN_FLG_CONSTTIME ) ; <S2SV_ModStart> ( tmp , blind , priv_key , order , ctx ) ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } if ( ! BN_mod_mul ( tmp , tmp <S2SV_ModEnd> , ret -> <S2SV_ModStart> err ; } if ( ! BN_mod_mul ( blindm , blind , m , order , ctx ) ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } <S2SV_ModStart> , tmp , blindm <S2SV_ModEnd> , order ) <S2SV_ModStart> err ; } if ( BN_mod_inverse ( blind , blind , order , ctx ) == NULL ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } <S2SV_ModStart> , s , blind , order , ctx ) ) { ECerr ( EC_F_OSSL_ECDSA_SIGN_SIG , ERR_R_BN_LIB ) ; goto err ; } if ( ! BN_mod_mul ( s , s , <S2SV_ModStart> NULL ; } BN_CTX_end ( ctx ) ; <S2SV_ModStart> ; BN_clear_free ( <S2SV_ModEnd> kinv ) ;"}
{"source": "CWE-476 <S2SV_StartBug> Agraph_t * agroot ( void * obj ) <S2SV_EndBug> { switch ( AGTYPE ( obj ) ) { case AGINEDGE : case AGOUTEDGE : return ( ( Agedge_t * ) obj ) -> node -> root ; case AGNODE : return ( ( Agnode_t * ) obj ) -> root ; case AGRAPH : <S2SV_StartBug> return ( ( Agraph_t * ) obj ) -> root ; <S2SV_EndBug> default : <S2SV_StartBug> agerr ( AGERR , \"agroot<S2SV_blank>of<S2SV_blank>a<S2SV_blank>bad<S2SV_blank>object\" ) ; <S2SV_EndBug> return NILgraph ; } }", "target": "<S2SV_ModStart> <S2SV_null> Agraph_t * agraphof <S2SV_ModEnd> ( void * <S2SV_ModStart> : return ( <S2SV_ModEnd> Agraph_t * ) <S2SV_ModStart> * ) obj <S2SV_ModEnd> ; default : <S2SV_ModStart> ( AGERR , \"agraphof<S2SV_blank>a<S2SV_blank>bad<S2SV_blank>object\" <S2SV_ModEnd> ) ; return"}
{"source": "CWE-125 static bool ntlmssp_check_buffer ( const struct ntlmssp_buffer * buffer , size_t data_size , const char * * error ) { uint32_t offset = read_le32 ( & buffer -> offset ) ; uint16_t length = read_le16 ( & buffer -> length ) ; uint16_t space = read_le16 ( & buffer -> space ) ; if ( length == 0 && space == 0 ) return TRUE ; <S2SV_StartBug> if ( offset >= data_size ) { <S2SV_EndBug> * error = \"buffer<S2SV_blank>offset<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\" ; return FALSE ; } if ( offset + space > data_size ) { * error = \"buffer<S2SV_blank>end<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\" ; return FALSE ; } return TRUE ; }", "target": "<S2SV_ModStart> ; if ( length > data_size ) { * error = \"buffer<S2SV_blank>length<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\" ; return FALSE ; } if ("}
{"source": "CWE-415 print_set_output ( char * name , TBOOLEAN datablock , TBOOLEAN append_p ) { if ( print_out && print_out != stderr && print_out != stdout ) { # ifdef PIPES if ( print_out_name [ 0 ] == '|' ) { if ( 0 > pclose ( print_out ) ) perror ( print_out_name ) ; } else # endif if ( 0 > fclose ( print_out ) ) <S2SV_StartBug> perror ( print_out_name ) ; <S2SV_EndBug> } free ( print_out_name ) ; print_out_name = NULL ; print_out_var = NULL ; if ( ! name ) { print_out = stderr ; return ; } if ( strcmp ( name , \"-\" ) == 0 ) { print_out = stdout ; return ; } # ifdef PIPES if ( name [ 0 ] == '|' ) { restrict_popen ( ) ; print_out = popen ( name + 1 , \"w\" ) ; if ( ! print_out ) perror ( name ) ; else print_out_name = name ; return ; } # endif if ( ! datablock ) { print_out = fopen ( name , append_p ? \"a\" : \"w\" ) ; if ( ! print_out ) { perror ( name ) ; return ; } } else { print_out_var = add_udv_by_name ( name ) ; if ( ! append_p ) gpfree_datablock ( & print_out_var -> udv_value ) ; if ( print_out_var -> udv_value . type != DATABLOCK ) { free_value ( & print_out_var -> udv_value ) ; print_out_var -> udv_value . type = DATABLOCK ; print_out_var -> udv_value . v . data_array = NULL ; } } print_out_name = name ; }", "target": "<S2SV_ModStart> ( print_out_name ) ; print_out = stderr"}
{"source": "CWE-787 enhanced_recursion ( const char * p , TBOOLEAN brace , char * fontname , double fontsize , double base , TBOOLEAN widthflag , TBOOLEAN showflag , int overprint ) { TBOOLEAN wasitalic , wasbold ; wasitalic = ( strstr ( fontname , \":Italic\" ) != NULL ) ; wasbold = ( strstr ( fontname , \":Bold\" ) != NULL ) ; FPRINTF ( ( stderr , \"RECURSE<S2SV_blank>WITH<S2SV_blank>\\\\\"%s\\\\\",<S2SV_blank>%d<S2SV_blank>%s<S2SV_blank>%.1f<S2SV_blank>%.1f<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\" , p , brace , fontname , fontsize , base , widthflag , showflag , overprint ) ) ; ( term -> enhanced_flush ) ( ) ; if ( base + fontsize > enhanced_max_height ) { enhanced_max_height = base + fontsize ; ENH_DEBUG ( ( \"Setting<S2SV_blank>max<S2SV_blank>height<S2SV_blank>to<S2SV_blank>%.1f\\\\n\" , enhanced_max_height ) ) ; } if ( base < enhanced_min_height ) { enhanced_min_height = base ; ENH_DEBUG ( ( \"Setting<S2SV_blank>min<S2SV_blank>height<S2SV_blank>to<S2SV_blank>%.1f\\\\n\" , enhanced_min_height ) ) ; } while ( * p ) { double shift ; if ( ( * p & 0x80 ) && ( encoding == S_ENC_DEFAULT || encoding == S_ENC_UTF8 ) ) { unsigned long utf8char ; const char * nextchar = p ; ( term -> enhanced_open ) ( fontname , fontsize , base , widthflag , showflag , overprint ) ; if ( utf8toulong ( & utf8char , & nextchar ) ) { while ( p < nextchar ) ( term -> enhanced_writec ) ( * p ++ ) ; p -- ; } else { ( term -> enhanced_writec ) ( * p ) ; } } else if ( ( * p & 0x80 ) && ( encoding == S_ENC_SJIS ) ) { ( term -> enhanced_open ) ( fontname , fontsize , base , widthflag , showflag , overprint ) ; ( term -> enhanced_writec ) ( * ( p ++ ) ) ; ( term -> enhanced_writec ) ( * p ) ; } else switch ( * p ) { case '}' : if ( brace ) return ( p ) ; int_warn ( NO_CARET , \"enhanced<S2SV_blank>text<S2SV_blank>parser<S2SV_blank>-<S2SV_blank>spurious<S2SV_blank>}\" ) ; break ; case '_' : case '^' : shift = ( * p == '^' ) ? 0.5 : - 0.3 ; ( term -> enhanced_flush ) ( ) ; p = enhanced_recursion ( p + 1 , FALSE , fontname , fontsize * 0.8 , base + shift * fontsize , widthflag , showflag , overprint ) ; break ; case '{' : { TBOOLEAN isitalic = FALSE , isbold = FALSE , isnormal = FALSE ; const char * start_of_fontname = NULL ; const char * end_of_fontname = NULL ; char * localfontname = NULL ; char ch ; double f = fontsize , ovp ; char * styledfontname = NULL ; ENH_DEBUG ( ( \"Dealing<S2SV_blank>with<S2SV_blank>{\\\\n\" ) ) ; ++ p ; if ( overprint == 2 ) { char * end ; ovp = strtod ( p , & end ) ; p = end ; if ( term -> flags & TERM_IS_POSTSCRIPT ) base = ovp * f ; else base += ovp * f ; } -- p ; if ( * ++ p == '/' ) { while ( * ++ p == '<S2SV_blank>' ) ; if ( * p == '-' ) { while ( * ++ p == '<S2SV_blank>' ) ; } start_of_fontname = p ; if ( * p == '\\\\'' || * p == \\'\"\\' ) { ++ p ; while ( * p != '\\\\0' && * p != '}' && * p != * start_of_fontname ) ++ p ; if ( * p != * start_of_fontname ) { int_warn ( NO_CARET , \"cannot<S2SV_blank>interpret<S2SV_blank>font<S2SV_blank>name<S2SV_blank>%s\" , start_of_fontname ) ; <S2SV_StartBug> p = start_of_fontname ; <S2SV_EndBug> } start_of_fontname ++ ; end_of_fontname = p ++ ; ch = * p ; } else { while ( ( ch = * p ) > '<S2SV_blank>' && ch != '=' && ch != '*' && ch != '}' && ch != ':' ) ++ p ; end_of_fontname = p ; } do { if ( ch == '=' ) { char * end ; p ++ ; ENH_DEBUG ( ( \"Calling<S2SV_blank>strtod(\\\\\"%s\\\\\")<S2SV_blank>...\" , p ) ) ; f = strtod ( p , & end ) ; p = end ; ENH_DEBUG ( ( \"Returned<S2SV_blank>%.1f<S2SV_blank>and<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , f , p ) ) ; if ( f == 0 ) f = fontsize ; else f *= enhanced_fontscale ; ENH_DEBUG ( ( \"Font<S2SV_blank>size<S2SV_blank>%.1f\\\\n\" , f ) ) ; } else if ( ch == '*' ) { char * end ; p ++ ; ENH_DEBUG ( ( \"Calling<S2SV_blank>strtod(\\\\\"%s\\\\\")<S2SV_blank>...\" , p ) ) ; f = strtod ( p , & end ) ; p = end ; ENH_DEBUG ( ( \"Returned<S2SV_blank>%.1f<S2SV_blank>and<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , f , p ) ) ; if ( f ) f *= fontsize ; else f = fontsize ; ENH_DEBUG ( ( \"Font<S2SV_blank>size<S2SV_blank>%.1f\\\\n\" , f ) ) ; } else if ( ch == ':' ) { p ++ ; if ( ! strncmp ( p , \"Bold\" , 4 ) ) isbold = TRUE ; if ( ! strncmp ( p , \"Italic\" , 6 ) ) isitalic = TRUE ; if ( ! strncmp ( p , \"Normal\" , 6 ) ) isnormal = TRUE ; while ( isalpha ( ( unsigned char ) * p ) ) { p ++ ; } } } while ( ( ( ch = * p ) == '=' ) || ( ch == ':' ) || ( ch == '*' ) ) ; if ( ch == '}' ) int_warn ( NO_CARET , \"bad<S2SV_blank>syntax<S2SV_blank>in<S2SV_blank>enhanced<S2SV_blank>text<S2SV_blank>string\" ) ; if ( * p == '<S2SV_blank>' ) ++ p ; if ( ! start_of_fontname || ( start_of_fontname == end_of_fontname ) ) { localfontname = gp_strdup ( fontname ) ; } else { int len = end_of_fontname - start_of_fontname ; localfontname = gp_alloc ( len + 1 , \"localfontname\" ) ; strncpy ( localfontname , start_of_fontname , len ) ; localfontname [ len ] = '\\\\0' ; } } isitalic = ( wasitalic || isitalic ) && ! isnormal ; isbold = ( wasbold || isbold ) && ! isnormal ; styledfontname = stylefont ( localfontname ? localfontname : fontname , isbold , isitalic ) ; p = enhanced_recursion ( p , TRUE , styledfontname , f , base , widthflag , showflag , overprint ) ; ( term -> enhanced_flush ) ( ) ; free ( styledfontname ) ; free ( localfontname ) ; break ; } case '@' : ( term -> enhanced_flush ) ( ) ; ( term -> enhanced_open ) ( fontname , fontsize , base , widthflag , showflag , 3 ) ; p = enhanced_recursion ( ++ p , FALSE , fontname , fontsize , base , widthflag , showflag , overprint ) ; ( term -> enhanced_open ) ( fontname , fontsize , base , widthflag , showflag , 4 ) ; break ; case '&' : ( term -> enhanced_flush ) ( ) ; p = enhanced_recursion ( ++ p , FALSE , fontname , fontsize , base , widthflag , FALSE , overprint ) ; break ; case '~' : ( term -> enhanced_flush ) ( ) ; p = enhanced_recursion ( ++ p , FALSE , fontname , fontsize , base , widthflag , showflag , 1 ) ; ( term -> enhanced_flush ) ( ) ; if ( ! * p ) break ; p = enhanced_recursion ( ++ p , FALSE , fontname , fontsize , base , FALSE , showflag , 2 ) ; overprint = 0 ; break ; case '(' : case ')' : ( term -> enhanced_open ) ( fontname , fontsize , base , widthflag , showflag , overprint ) ; if ( term -> flags & TERM_IS_POSTSCRIPT ) ( term -> enhanced_writec ) ( '\\\\\\\\' ) ; ( term -> enhanced_writec ) ( * p ) ; break ; case '\\\\\\\\' : ( term -> enhanced_open ) ( fontname , fontsize , base , widthflag , showflag , overprint ) ; if ( p [ 1 ] == 'U' && p [ 2 ] == '+' ) { if ( encoding == S_ENC_UTF8 ) { uint32_t codepoint ; unsigned char utf8char [ 8 ] ; int i , length ; sscanf ( & ( p [ 3 ] ) , \"%5x\" , & codepoint ) ; length = ucs4toutf8 ( codepoint , utf8char ) ; p += ( codepoint > 0xFFFF ) ? 7 : 6 ; for ( i = 0 ; i < length ; i ++ ) ( term -> enhanced_writec ) ( utf8char [ i ] ) ; break ; } ( term -> enhanced_writec ) ( p [ 0 ] ) ; break ; } if ( p [ 1 ] >= '0' && p [ 1 ] <= '7' ) { char * e , escape [ 16 ] , octal [ 4 ] = { '\\\\0' , '\\\\0' , '\\\\0' , '\\\\0' } ; octal [ 0 ] = * ( ++ p ) ; if ( p [ 1 ] >= '0' && p [ 1 ] <= '7' ) { octal [ 1 ] = * ( ++ p ) ; if ( p [ 1 ] >= '0' && p [ 1 ] <= '7' ) octal [ 2 ] = * ( ++ p ) ; } sprintf ( escape , enhanced_escape_format , strtol ( octal , NULL , 8 ) ) ; for ( e = escape ; * e ; e ++ ) { ( term -> enhanced_writec ) ( * e ) ; } break ; } if ( term -> flags & TERM_IS_POSTSCRIPT ) { if ( p [ 1 ] == '\\\\\\\\' || p [ 1 ] == '(' || p [ 1 ] == ')' ) { ( term -> enhanced_writec ) ( '\\\\\\\\' ) ; } else if ( strchr ( \"^_@&~{}\" , p [ 1 ] ) == NULL ) { ( term -> enhanced_writec ) ( '\\\\\\\\' ) ; ( term -> enhanced_writec ) ( '\\\\\\\\' ) ; break ; } } ++ p ; if ( * p == '\\\\0' ) { int_warn ( NO_CARET , \"enhanced<S2SV_blank>text<S2SV_blank>parser<S2SV_blank>--<S2SV_blank>spurious<S2SV_blank>backslash\" ) ; break ; } if ( * p == '&' && encoding == S_ENC_DEFAULT && ! strcmp ( term -> name , \"svg\" ) ) { ( term -> enhanced_writec ) ( '\\\\376' ) ; break ; } ( term -> enhanced_writec ) ( * p ) ; break ; default : ( term -> enhanced_open ) ( fontname , fontsize , base , widthflag , showflag , overprint ) ; ( term -> enhanced_writec ) ( * p ) ; } if ( ! brace ) { ( term -> enhanced_flush ) ( ) ; return ( p ) ; } if ( * p ) ++ p ; } ( term -> enhanced_flush ) ( ) ; return p ; }", "target": "<S2SV_ModStart> p = start_of_fontname + 1"}
{"source": "CWE-617 <S2SV_StartBug> bool const_item ( ) const { return used_tables ( ) == 0 ; } <S2SV_EndBug>", "target": "<S2SV_ModStart> const { return true <S2SV_ModEnd> ; }"}
{"source": "CWE-416 int setup_conds ( THD * thd , TABLE_LIST * tables , List < TABLE_LIST > & leaves , COND * * conds ) { SELECT_LEX * select_lex = thd -> lex -> current_select ; TABLE_LIST * table = NULL ; bool it_is_update = ( select_lex == thd -> lex -> first_select_lex ( ) ) && thd -> lex -> which_check_option_applicable ( ) ; bool save_is_item_list_lookup = select_lex -> is_item_list_lookup ; TABLE_LIST * derived = select_lex -> master_unit ( ) -> derived ; <S2SV_StartBug> DBUG_ENTER ( \"setup_conds\" ) ; <S2SV_EndBug> <S2SV_StartBug> select_lex -> is_item_list_lookup = 0 ; <S2SV_EndBug> thd -> column_usage = MARK_COLUMNS_READ ; DBUG_PRINT ( \"info\" , ( \"thd->column_usage:<S2SV_blank>%d\" , thd -> column_usage ) ) ; select_lex -> cond_count = 0 ; select_lex -> between_count = 0 ; select_lex -> max_equal_elems = 0 ; for ( table = tables ; table ; table = table -> next_local ) { if ( select_lex == thd -> lex -> first_select_lex ( ) && select_lex -> first_cond_optimization && table -> merged_for_insert && table -> prepare_where ( thd , conds , FALSE ) ) goto err_no_arena ; } if ( * conds ) { thd -> where = \"where<S2SV_blank>clause\" ; DBUG_EXECUTE ( \"where\" , print_where ( * conds , \"WHERE<S2SV_blank>in<S2SV_blank>setup_conds\" , QT_ORDINARY ) ; ) ; if ( ( * conds ) -> type ( ) == Item : : FIELD_ITEM && ! derived ) wrap_ident ( thd , conds ) ; ( * conds ) -> mark_as_condition_AND_part ( NO_JOIN_NEST ) ; if ( ( * conds ) -> fix_fields_if_needed_for_bool ( thd , conds ) ) goto err_no_arena ; } if ( setup_on_expr ( thd , tables , it_is_update ) ) goto err_no_arena ; if ( ! thd -> stmt_arena -> is_conventional ( ) ) { select_lex -> where = * conds ; } thd -> lex -> current_select -> is_item_list_lookup = save_is_item_list_lookup ; <S2SV_StartBug> DBUG_RETURN ( thd -> is_error ( ) ) ; <S2SV_EndBug> err_no_arena : select_lex -> is_item_list_lookup = save_is_item_list_lookup ; DBUG_RETURN ( 1 ) ; }", "target": "<S2SV_ModStart> -> derived ; bool save_resolve_in_select_list = select_lex -> context . resolve_in_select_list ; <S2SV_ModStart> is_item_list_lookup = 0 ; select_lex -> context . resolve_in_select_list = false <S2SV_ModStart> = save_is_item_list_lookup ; select_lex -> context . resolve_in_select_list = save_resolve_in_select_list ;"}
{"source": "CWE-908 <S2SV_StartBug> address_space_translate_for_iotlb ( CPUState * cpu , int asidx , hwaddr addr , <S2SV_EndBug> hwaddr * xlat , hwaddr * plen , MemTxAttrs attrs , int * prot ) { MemoryRegionSection * section ; IOMMUMemoryRegion * iommu_mr ; IOMMUMemoryRegionClass * imrc ; IOMMUTLBEntry iotlb ; <S2SV_StartBug> int iommu_idx ; <S2SV_EndBug> AddressSpaceDispatch * d = qatomic_rcu_read ( & cpu -> cpu_ases [ asidx ] . memory_dispatch ) ; for ( ; ; ) { section = address_space_translate_internal ( d , addr , & addr , plen , false ) ; iommu_mr = memory_region_get_iommu ( section -> mr ) ; if ( ! iommu_mr ) { break ; } imrc = memory_region_get_iommu_class_nocheck ( iommu_mr ) ; iommu_idx = imrc -> attrs_to_index ( iommu_mr , attrs ) ; tcg_register_iommu_notifier ( cpu , iommu_mr , iommu_idx ) ; iotlb = imrc -> translate ( iommu_mr , addr , IOMMU_NONE , iommu_idx ) ; addr = ( ( iotlb . translated_addr & ~ iotlb . addr_mask ) | ( addr & iotlb . addr_mask ) ) ; if ( ! ( iotlb . perm & IOMMU_RO ) ) { * prot &= ~ ( PAGE_READ | PAGE_EXEC ) ; } if ( ! ( iotlb . perm & IOMMU_WO ) ) { * prot &= ~ PAGE_WRITE ; } if ( ! * prot ) { goto translate_fail ; } d = flatview_to_dispatch ( address_space_to_flatview ( iotlb . target_as ) ) ; } assert ( ! memory_region_is_iommu ( section -> mr ) ) ; * xlat = addr ; return section ; translate_fail : <S2SV_StartBug> return & d -> map . sections [ PHYS_SECTION_UNASSIGNED ] ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> asidx , hwaddr orig_addr <S2SV_ModEnd> , hwaddr * <S2SV_ModStart> ; int iommu_idx ; hwaddr addr = orig_addr <S2SV_ModStart> ; translate_fail : assert ( ( orig_addr & ~ TARGET_PAGE_MASK ) == 0 ) ; * xlat = orig_addr ;"}
{"source": "CWE-20 int lazy_bdecode ( char const * start , char const * end , lazy_entry & ret , error_code & ec , int * error_pos , int depth_limit , int item_limit ) { char const * const orig_start = start ; ret . clear ( ) ; if ( start == end ) return 0 ; std : : vector < lazy_entry * > stack ; stack . push_back ( & ret ) ; while ( start <= end ) { if ( stack . empty ( ) ) break ; lazy_entry * top = stack . back ( ) ; if ( int ( stack . size ( ) ) > depth_limit ) TORRENT_FAIL_BDECODE ( bdecode_errors : : depth_exceeded ) ; if ( start >= end ) TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ; char t = * start ; ++ start ; if ( start >= end && t != 'e' ) TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ; switch ( top -> type ( ) ) { case lazy_entry : : dict_t : { if ( t == 'e' ) { top -> set_end ( start ) ; stack . pop_back ( ) ; continue ; } if ( ! numeric ( t ) ) TORRENT_FAIL_BDECODE ( bdecode_errors : : expected_string ) ; boost : : int64_t len = t - '0' ; bdecode_errors : : error_code_enum e = bdecode_errors : : no_error ; start = parse_int ( start , end , ':' , len , e ) ; if ( e ) TORRENT_FAIL_BDECODE ( e ) ; <S2SV_StartBug> if ( start + len + 1 > end ) <S2SV_EndBug> TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ; if ( len < 0 ) TORRENT_FAIL_BDECODE ( bdecode_errors : : overflow ) ; ++ start ; if ( start == end ) TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ; lazy_entry * ent = top -> dict_append ( start ) ; if ( ent == 0 ) TORRENT_FAIL_BDECODE ( boost : : system : : errc : : not_enough_memory ) ; start += len ; if ( start >= end ) TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ; stack . push_back ( ent ) ; t = * start ; ++ start ; break ; } case lazy_entry : : list_t : { if ( t == 'e' ) { top -> set_end ( start ) ; stack . pop_back ( ) ; continue ; } lazy_entry * ent = top -> list_append ( ) ; if ( ent == 0 ) TORRENT_FAIL_BDECODE ( boost : : system : : errc : : not_enough_memory ) ; stack . push_back ( ent ) ; break ; } default : break ; } -- item_limit ; if ( item_limit <= 0 ) TORRENT_FAIL_BDECODE ( bdecode_errors : : limit_exceeded ) ; top = stack . back ( ) ; switch ( t ) { case 'd' : top -> construct_dict ( start - 1 ) ; continue ; case 'l' : top -> construct_list ( start - 1 ) ; continue ; case 'i' : { char const * int_start = start ; start = find_char ( start , end , 'e' ) ; top -> construct_int ( int_start , start - int_start ) ; if ( start == end ) TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ; TORRENT_ASSERT ( * start == 'e' ) ; ++ start ; stack . pop_back ( ) ; continue ; } default : { if ( ! numeric ( t ) ) TORRENT_FAIL_BDECODE ( bdecode_errors : : expected_value ) ; boost : : int64_t len = t - '0' ; bdecode_errors : : error_code_enum e = bdecode_errors : : no_error ; start = parse_int ( start , end , ':' , len , e ) ; if ( e ) TORRENT_FAIL_BDECODE ( e ) ; <S2SV_StartBug> if ( start + len + 1 > end ) <S2SV_EndBug> TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ; if ( len < 0 ) TORRENT_FAIL_BDECODE ( bdecode_errors : : overflow ) ; ++ start ; <S2SV_StartBug> top -> construct_string ( start , int ( len ) ) ; <S2SV_EndBug> stack . pop_back ( ) ; start += len ; continue ; } } return 0 ; } return 0 ; }", "target": "<S2SV_ModStart> e ) ; const ptrdiff_t buff_size = end - start - 1 ; if ( len > buff_size <S2SV_ModEnd> ) TORRENT_FAIL_BDECODE ( <S2SV_ModStart> e ) ; const ptrdiff_t buff_size = end - start - 1 ; if ( len > buff_size <S2SV_ModEnd> ) TORRENT_FAIL_BDECODE ( <S2SV_ModStart> ++ start ; if ( start == end ) TORRENT_FAIL_BDECODE ( bdecode_errors : : unexpected_eof ) ;"}
{"source": "CWE-119 GetCode_ ( gdIOCtx * fd , CODE_STATIC_DATA * scd , int code_size , int flag , int * ZeroDataBlockP ) { int i , j , ret ; unsigned char count ; if ( flag ) { scd -> curbit = 0 ; scd -> lastbit = 0 ; scd -> last_byte = 0 ; scd -> done = FALSE ; return 0 ; } if ( ( scd -> curbit + code_size ) >= scd -> lastbit ) { if ( scd -> done ) { if ( scd -> curbit >= scd -> lastbit ) { } return - 1 ; } scd -> buf [ 0 ] = scd -> buf [ scd -> last_byte - 2 ] ; scd -> buf [ 1 ] = scd -> buf [ scd -> last_byte - 1 ] ; if ( ( count = GetDataBlock ( fd , & scd -> buf [ 2 ] , ZeroDataBlockP ) ) <= 0 ) { scd -> done = TRUE ; } scd -> last_byte = 2 + count ; scd -> curbit = ( scd -> curbit - scd -> lastbit ) + 16 ; scd -> lastbit = ( 2 + count ) * 8 ; } ret = 0 ; for ( i = scd -> curbit , j = 0 ; j < code_size ; ++ i , ++ j ) { <S2SV_StartBug> ret |= ( ( scd -> buf [ i / 8 ] & ( 1 << ( i % 8 ) ) ) != 0 ) << j ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> scd -> curbit += code_size ; return ret ; }", "target": "<S2SV_ModStart> j ) { if ( i < CSD_BUF_SIZE * 8 ) { <S2SV_ModStart> j ; } else { ret = - 1 ; break ; } }"}
{"source": "CWE-787 <S2SV_StartBug> void ocall_malloc ( size_t size , uint8_t * * ret ) { <S2SV_EndBug> * ret = static_cast < uint8_t * > ( malloc ( size ) ) ; }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> void unsafe_ocall_malloc <S2SV_ModEnd> ( size_t size"}
{"source": "CWE-200 int data_on_connection ( int fd , callback_remove_handler remove ) { int nread ; char * network_packet ; char network_line [ 8192 ] ; char * p ; unsigned long id ; char string [ 1024 ] ; unsigned long msg_id = UINT32_MAX ; enum network_protocol version = network_client_get_version ( fd ) ; ioctl ( fd , FIONREAD , & nread ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"new<S2SV_blank>connection<S2SV_blank>data<S2SV_blank>=<S2SV_blank>%d\\\\n\" , nread ) ; if ( nread == 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , \"%d<S2SV_blank>failed,<S2SV_blank>got<S2SV_blank>0<S2SV_blank>close<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>listener<S2SV_blank>\" , fd ) ; close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; network_client_dump ( ) ; return 0 ; } if ( nread >= 8192 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ERROR , \"%d<S2SV_blank>failed,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>8192<S2SV_blank>close<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>listener<S2SV_blank>\" , fd ) ; close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; return 0 ; } network_packet = malloc ( ( nread + 1 ) * sizeof ( char ) ) ; read ( fd , network_packet , nread ) ; network_packet [ nread ] = '\\\\0' ; memset ( network_line , 0 , 8192 ) ; p = network_packet ; p_sem ( sem_id ) ; while ( get_network_line ( p , network_line ) ) { if ( strlen ( network_line ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"line<S2SV_blank>=<S2SV_blank>[%s]\" , network_line ) ; } if ( ! strncmp ( network_line , \"MSGID:<S2SV_blank>\" , strlen ( \"MSGID:<S2SV_blank>\" ) ) ) { msg_id = strtoul ( & ( network_line [ strlen ( \"MSGID:<S2SV_blank>\" ) ] ) , NULL , 10 ) ; p += strlen ( network_line ) ; } else if ( ! strncmp ( network_line , \"Version:<S2SV_blank>\" , strlen ( \"Version:<S2SV_blank>\" ) ) ) { char * head = network_line , * end ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"RECV:<S2SV_blank>VERSION\" ) ; version = strtoul ( head + 9 , & end , 10 ) ; if ( ! head [ 9 ] || * end ) goto failed ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"VERSION=%d\" , version ) ; if ( version < network_procotol_version ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , \"Forbidden<S2SV_blank>VERSION=%d<S2SV_blank><<S2SV_blank>%d,<S2SV_blank>close<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>listener\" , version , network_procotol_version ) ; goto close ; } else if ( version >= PROTOCOL_LAST ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , \"Future<S2SV_blank>VERSION=%d\" , version ) ; version = PROTOCOL_LAST - 1 ; } network_client_set_version ( fd , version ) ; msg_id = UINT32_MAX ; p += strlen ( network_line ) ; } else if ( ! strncmp ( network_line , \"Capabilities:<S2SV_blank>\" , strlen ( \"Capabilities:<S2SV_blank>\" ) ) ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"RECV:<S2SV_blank>Capabilities\" ) ; if ( version > PROTOCOL_UNKNOWN ) { memset ( string , 0 , sizeof ( string ) ) ; snprintf ( string , sizeof ( string ) , \"Version:<S2SV_blank>%d\\\\nCapabilities:<S2SV_blank>\\\\n\\\\n\" , version ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"SEND:<S2SV_blank>%s\" , string ) ; write ( fd , string , strlen ( string ) ) ; } else { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"Capabilities<S2SV_blank>recv,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>version<S2SV_blank>line\" ) ; } p += strlen ( network_line ) ; <S2SV_StartBug> } else if ( ! strncmp ( network_line , \"GET_DN<S2SV_blank>\" , strlen ( \"GET_DN<S2SV_blank>\" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { <S2SV_EndBug> univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"RECV:<S2SV_blank>GET_DN\" ) ; id = strtoul ( & ( network_line [ strlen ( \"GET_DN<S2SV_blank>\" ) ] ) , NULL , 10 ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"id:<S2SV_blank>%ld\" , id ) ; if ( id <= notify_last_id . id ) { char * dn_string = NULL ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"try<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%ld<S2SV_blank>from<S2SV_blank>cache\" , id ) ; if ( ( dn_string = notifier_cache_get ( id ) ) == NULL ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"%ld<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>cache\" , id ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"%ld<S2SV_blank>get<S2SV_blank>one<S2SV_blank>dn\" , id ) ; if ( ( dn_string = notify_transcation_get_one_dn ( id ) ) == NULL ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"%ld<S2SV_blank>failed<S2SV_blank>\" , id ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ERROR , \"%d<S2SV_blank>failed,<S2SV_blank>close<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>listener<S2SV_blank>\" , fd ) ; close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; return 0 ; } } if ( dn_string != NULL ) { snprintf ( string , sizeof ( string ) , \"MSGID:<S2SV_blank>%ld\\\\n%s\\\\n\\\\n\" , msg_id , dn_string ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"--><S2SV_blank>%d:<S2SV_blank>[%s]\" , fd , string ) ; write ( fd , string , strlen ( string ) ) ; free ( dn_string ) ; } } else { network_client_set_next_id ( fd , id ) ; network_client_set_msg_id ( fd , msg_id ) ; } p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( p , \"WAIT_ID<S2SV_blank>\" , 8 ) && msg_id != UINT32_MAX && version >= PROTOCOL_3 ) { char * head = network_line , * end ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"RECV:<S2SV_blank>WAIT_ID\" ) ; id = strtoul ( head + 8 , & end , 10 ) ; if ( ! head [ 8 ] || * end ) goto failed ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"id:<S2SV_blank>%ld\" , id ) ; if ( id <= notify_last_id . id ) { snprintf ( string , sizeof ( string ) , \"MSGID:<S2SV_blank>%ld\\\\n%ld\\\\n\\\\n\" , msg_id , notify_last_id . id ) ; write ( fd , string , strlen ( string ) ) ; } else { network_client_set_next_id ( fd , id ) ; network_client_set_msg_id ( fd , msg_id ) ; } p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( network_line , \"GET_ID\" , strlen ( \"GET_ID\" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"RECV:<S2SV_blank>GET_ID\" ) ; memset ( string , 0 , sizeof ( string ) ) ; snprintf ( string , sizeof ( string ) , \"MSGID:<S2SV_blank>%ld\\\\n%ld\\\\n\\\\n\" , msg_id , notify_last_id . id ) ; write ( fd , string , strlen ( string ) ) ; p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( network_line , \"GET_SCHEMA_ID\" , strlen ( \"GET_SCHEMA_ID\" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"RECV:<S2SV_blank>GET_SCHEMA_ID\" ) ; memset ( string , 0 , sizeof ( string ) ) ; snprintf ( string , sizeof ( string ) , \"MSGID:<S2SV_blank>%ld\\\\n%ld\\\\n\\\\n\" , msg_id , SCHEMA_ID ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"--><S2SV_blank>%d:<S2SV_blank>[%s]\" , fd , string ) ; write ( fd , string , strlen ( string ) ) ; p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( network_line , \"ALIVE\" , strlen ( \"ALIVE\" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"RECV:<S2SV_blank>ALIVE\" ) ; snprintf ( string , sizeof ( string ) , \"MSGID:<S2SV_blank>%ld\\\\nOKAY\\\\n\\\\n\" , msg_id ) ; write ( fd , string , strlen ( string ) ) ; p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else { p += strlen ( network_line ) ; if ( strlen ( network_line ) == 0 ) { p += 1 ; } else { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ERROR , \"Drop<S2SV_blank>package<S2SV_blank>[%s]\" , network_line ) ; } } } v_sem ( sem_id ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , \"END<S2SV_blank>Package\" ) ; network_client_dump ( ) ; return 0 ; failed : univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , \"Failed<S2SV_blank>parsing<S2SV_blank>[%s]\" , p ) ; close : close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; return 0 ; }", "target": "<S2SV_ModStart> != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3 <S2SV_ModEnd> ) { univention_debug"}
{"source": "CWE-120 static bool MR_primality_test ( UnsignedBigInteger n , const Vector < UnsignedBigInteger , 256 > & tests ) { ASSERT ( ! ( n < 4 ) ) ; auto predecessor = n . minus ( { 1 } ) ; auto d = predecessor ; size_t r = 0 ; { auto div_result = d . divided_by ( 2 ) ; while ( div_result . remainder == 0 ) { d = div_result . quotient ; div_result = d . divided_by ( 2 ) ; ++ r ; } } if ( r == 0 ) { return n == 2 ; } <S2SV_StartBug> for ( auto a : tests ) { <S2SV_EndBug> ASSERT ( a < n ) ; auto x = ModularPower ( a , d , n ) ; if ( x == 1 || x == predecessor ) continue ; bool skip_this_witness = false ; for ( size_t i = 0 ; i < r - 1 ; ++ i ) { x = ModularPower ( x , 2 , n ) ; if ( x == predecessor ) { skip_this_witness = true ; break ; } } if ( skip_this_witness ) continue ; return false ; } return true ; }", "target": "<S2SV_ModStart> for ( auto &"}
{"source": "CWE-120 String UTF16BEDecoder : : to_utf8 ( const StringView & input ) { StringBuilder builder ( input . length ( ) / 2 ) ; <S2SV_StartBug> for ( size_t i = 0 ; i < input . length ( ) ; i += 2 ) { <S2SV_EndBug> u16 code_point = ( input [ i ] << 8 ) | input [ i + 1 ] ; builder . append_code_point ( code_point ) ; } return builder . to_string ( ) ; }", "target": "<S2SV_ModStart> 2 ) ; size_t utf16_length = input . length ( ) - ( input . length ( ) % 2 ) ; <S2SV_ModStart> ; i < utf16_length <S2SV_ModEnd> ; i +="}
{"source": "CWE-120 bool read ( ReadonlyBytes buffer ) { auto fields_size = sizeof ( CentralDirectoryRecord ) - ( sizeof ( u8 * ) * 3 ) ; <S2SV_StartBug> if ( buffer . size ( ) < fields_size ) <S2SV_EndBug> return false ; if ( memcmp ( buffer . data ( ) , central_directory_record_signature , sizeof ( central_directory_record_signature ) ) != 0 ) return false ; memcpy ( reinterpret_cast < void * > ( & made_by_version ) , buffer . data ( ) + sizeof ( central_directory_record_signature ) , fields_size ) ; <S2SV_StartBug> name = buffer . data ( ) + sizeof ( central_directory_record_signature ) + fields_size ; <S2SV_EndBug> extra_data = name + name_length ; comment = extra_data + extra_data_length ; return true ; }", "target": "<S2SV_ModStart> ( ) < sizeof ( central_directory_record_signature ) + <S2SV_ModStart> fields_size ) ; if ( buffer . size ( ) < sizeof ( end_of_central_directory_signature ) + fields_size + comment_length + name_length + extra_data_length ) return false ;"}
{"source": "CWE-120 bool read ( ReadonlyBytes buffer ) { auto fields_size = sizeof ( LocalFileHeader ) - ( sizeof ( u8 * ) * 3 ) ; <S2SV_StartBug> if ( buffer . size ( ) < fields_size ) <S2SV_EndBug> return false ; if ( memcmp ( buffer . data ( ) , local_file_header_signature , sizeof ( local_file_header_signature ) ) != 0 ) return false ; memcpy ( reinterpret_cast < void * > ( & minimum_version ) , buffer . data ( ) + sizeof ( local_file_header_signature ) , fields_size ) ; <S2SV_StartBug> name = buffer . data ( ) + sizeof ( local_file_header_signature ) + fields_size ; <S2SV_EndBug> extra_data = name + name_length ; compressed_data = extra_data + extra_data_length ; return true ; }", "target": "<S2SV_ModStart> ( ) < sizeof ( local_file_header_signature ) + <S2SV_ModStart> fields_size ) ; if ( buffer . size ( ) < sizeof ( end_of_central_directory_signature ) + fields_size + name_length + extra_data_length + compressed_size ) return false ;"}
{"source": "CWE-120 bool read ( ReadonlyBytes buffer ) { auto fields_size = sizeof ( EndOfCentralDirectory ) - sizeof ( u8 * ) ; <S2SV_StartBug> if ( buffer . size ( ) < fields_size ) <S2SV_EndBug> return false ; if ( memcmp ( buffer . data ( ) , end_of_central_directory_signature , sizeof ( end_of_central_directory_signature ) ) != 0 ) return false ; memcpy ( reinterpret_cast < void * > ( & disk_number ) , buffer . data ( ) + sizeof ( end_of_central_directory_signature ) , fields_size ) ; <S2SV_StartBug> comment = buffer . data ( ) + sizeof ( end_of_central_directory_signature ) + fields_size ; <S2SV_EndBug> return true ; }", "target": "<S2SV_ModStart> ( ) < sizeof ( end_of_central_directory_signature ) + <S2SV_ModStart> fields_size ) ; if ( buffer . size ( ) < sizeof ( end_of_central_directory_signature ) + fields_size + comment_length ) return false ;"}
{"source": "CWE-401 static int8_t sn_coap_parser_options_parse ( struct coap_s * handle , uint8_t * * packet_data_pptr , sn_coap_hdr_s * dst_coap_msg_ptr , uint8_t * packet_data_start_ptr , uint16_t packet_len ) { uint8_t previous_option_number = 0 ; int8_t ret_status = 0 ; uint16_t message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; dst_coap_msg_ptr -> token_len = * packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK ; if ( dst_coap_msg_ptr -> token_len ) { int8_t ptr_check_result ; if ( ( dst_coap_msg_ptr -> token_len > 8 ) || dst_coap_msg_ptr -> token_ptr ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>token<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; if ( 0 != ptr_check_result ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!\" ) ; return - 1 ; } dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ; if ( dst_coap_msg_ptr -> token_ptr == NULL ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!\" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; } while ( message_left && ( * * packet_data_pptr != 0xff ) ) { uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ; uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ; message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; int8_t option_parse_result ; option_parse_result = parse_ext_option ( & option_number , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } <S2SV_StartBug> option_number += previous_option_number ; <S2SV_EndBug> option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } previous_option_number = option_number ; switch ( option_number ) { case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>options!\" ) ; return - 1 ; } break ; } if ( message_left < option_len ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>would<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>parsing<S2SV_blank>options!\" ) ; return - 1 ; } switch ( option_number ) { case COAP_OPTION_CONTENT_FORMAT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> content_format != COAP_CT_NONE ) ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_CONTENT_FORMAT<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> content_format = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_MAX_AGE : if ( option_len > 4 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_MAX_AGE<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> max_age = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_PROXY_URI : if ( ( option_len > 1034 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr == NULL ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>allocation<S2SV_blank>failed!\" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_ETAG : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , <S2SV_EndBug> message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ; if ( ret_status < 0 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } break ; case COAP_OPTION_URI_HOST : if ( ( option_len > 255 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_host_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr == NULL ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>allocation<S2SV_blank>failed!\" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_LOCATION_PATH : if ( dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>exists!\" ) ; return - 1 ; } ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_path_len , COAP_OPTION_LOCATION_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PORT : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_port != COAP_OPTION_URI_PORT_NONE ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PORT<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_port = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_LOCATION_QUERY : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PATH : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } break ; case COAP_OPTION_OBSERVE : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> observe != COAP_OBSERVE_NONE ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_OBSERVE<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> observe = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_URI_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_len , COAP_OPTION_URI_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_QUERY<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } break ; case COAP_OPTION_BLOCK2 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block2 != COAP_OPTION_BLOCK_NONE ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK2<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_BLOCK1 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block1 != COAP_OPTION_BLOCK_NONE ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK1<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_ACCEPT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> options_list_ptr -> accept != COAP_CT_NONE ) ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ACCEPT<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> accept = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE1 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size1 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE1<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size1 = true ; dst_coap_msg_ptr -> options_list_ptr -> size1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE2 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size2 ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE2<S2SV_blank>not<S2SV_blank>valid!\" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size2 = true ; dst_coap_msg_ptr -> options_list_ptr -> size2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; default : tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>option!\" ) ; return - 1 ; } if ( ( * packet_data_pptr - packet_data_start_ptr ) > packet_len ) { return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; } return 0 ; }", "target": "<S2SV_ModStart> 1 ; } if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> option_parse_result = parse_ext_option <S2SV_ModStart> case COAP_OPTION_ETAG : if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!\" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_LOCATION_QUERY : if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!\" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_URI_PATH : if ( dst_coap_msg_ptr -> uri_path_ptr ) { tr_error ( \"sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!\" ) ; return - 1 ; }"}
{"source": "CWE-276 int PasswdMgr : : updatePasswdSpecialFile ( const std : : string & userName , const std : : string & newUserName ) { phosphor : : user : : shadow : : Lock lock ( ) ; size_t bytesWritten = 0 ; size_t inBytesLen = 0 ; size_t isUsrFound = false ; const EVP_CIPHER * cipher = EVP_aes_128_cbc ( ) ; std : : vector < uint8_t > dataBuf ; if ( readPasswdFileData ( dataBuf ) != 0 ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>reading<S2SV_blank>the<S2SV_blank>encrypted<S2SV_blank>pass<S2SV_blank>file\" ) ; return - EIO ; } if ( dataBuf . size ( ) != 0 ) { inBytesLen = dataBuf . size ( ) + newUserName . size ( ) + EVP_CIPHER_block_size ( cipher ) ; } std : : vector < uint8_t > inBytes ( inBytesLen ) ; if ( inBytesLen != 0 ) { char * outPtr = reinterpret_cast < char * > ( dataBuf . data ( ) ) ; char * nToken = NULL ; char * linePtr = strtok_r ( outPtr , \"\\\\n\" , & nToken ) ; while ( linePtr != NULL ) { size_t userEPos = 0 ; std : : string lineStr ( linePtr ) ; if ( ( userEPos = lineStr . find ( \":\" ) ) != std : : string : : npos ) { if ( userName . compare ( lineStr . substr ( 0 , userEPos ) ) == 0 ) { isUsrFound = true ; if ( ! newUserName . empty ( ) ) { bytesWritten += std : : snprintf ( reinterpret_cast < char * > ( & inBytes [ 0 ] ) + bytesWritten , ( inBytesLen - bytesWritten ) , \"%s%s\\\\n\" , newUserName . c_str ( ) , lineStr . substr ( userEPos , lineStr . size ( ) ) . data ( ) ) ; } } else { bytesWritten += std : : snprintf ( reinterpret_cast < char * > ( & inBytes [ 0 ] ) + bytesWritten , ( inBytesLen - bytesWritten ) , \"%s\\\\n\" , lineStr . data ( ) ) ; } } linePtr = strtok_r ( NULL , \"\\\\n\" , & nToken ) ; } inBytesLen = bytesWritten ; } if ( ! isUsrFound ) { log < level : : DEBUG > ( \"User<S2SV_blank>doesn\\'t<S2SV_blank>exist\" ) ; return 0 ; } std : : array < uint8_t , maxKeySize > keyBuff ; std : : ifstream keyFile ( encryptKeyFileName , std : : ios : : in | std : : ios : : binary ) ; if ( ! keyFile . good ( ) ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>encryption<S2SV_blank>key<S2SV_blank>file\" ) ; return - EIO ; } keyFile . read ( reinterpret_cast < char * > ( keyBuff . data ( ) ) , keyBuff . size ( ) ) ; if ( keyFile . fail ( ) ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>reading<S2SV_blank>encryption<S2SV_blank>key<S2SV_blank>file\" ) ; return - EIO ; } keyFile . close ( ) ; struct stat st = { } ; if ( stat ( passwdFileName , & st ) != 0 ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>getting<S2SV_blank>password<S2SV_blank>file<S2SV_blank>fstat()\" ) ; return - EIO ; } std : : string pwdFile ( passwdFileName ) ; std : : vector < char > tempFileName ( pwdFile . begin ( ) , pwdFile . end ( ) ) ; std : : vector < char > fileTemplate = { '_' , '_' , 'X' , 'X' , 'X' , 'X' , 'X' , 'X' , '\\\\0' } ; tempFileName . insert ( tempFileName . end ( ) , fileTemplate . begin ( ) , fileTemplate . end ( ) ) ; int fd = mkstemp ( ( char * ) tempFileName . data ( ) ) ; if ( fd == - 1 ) { log < level : : DEBUG > ( \"Error<S2SV_blank>creating<S2SV_blank>temp<S2SV_blank>file\" ) ; return - EIO ; } std : : string strTempFileName ( tempFileName . data ( ) ) ; phosphor : : user : : File temp ( fd , strTempFileName , \"w\" , true ) ; if ( ( temp ) ( ) == NULL ) { close ( fd ) ; log < level : : DEBUG > ( \"Error<S2SV_blank>creating<S2SV_blank>temp<S2SV_blank>file\" ) ; return - EIO ; } <S2SV_StartBug> if ( fchmod ( fileno ( ( temp ) ( ) ) , st . st_mode ) < 0 ) <S2SV_EndBug> { log < level : : DEBUG > ( \"Error<S2SV_blank>setting<S2SV_blank>fchmod<S2SV_blank>for<S2SV_blank>temp<S2SV_blank>file\" ) ; return - EIO ; } const EVP_MD * digest = EVP_sha256 ( ) ; size_t hashLen = EVP_MD_block_size ( digest ) ; std : : vector < uint8_t > hash ( hashLen ) ; size_t ivLen = EVP_CIPHER_iv_length ( cipher ) ; std : : vector < uint8_t > iv ( ivLen ) ; std : : array < uint8_t , EVP_MAX_KEY_LENGTH > key ; size_t keyLen = key . size ( ) ; std : : array < uint8_t , EVP_MAX_MD_SIZE > mac ; size_t macLen = mac . size ( ) ; if ( RAND_bytes ( hash . data ( ) , hashLen ) != 1 ) { log < level : : DEBUG > ( \"Hash<S2SV_blank>genertion<S2SV_blank>failed,<S2SV_blank>bailing<S2SV_blank>out\" ) ; return - EIO ; } if ( NULL == HMAC ( digest , keyBuff . data ( ) , keyBuff . size ( ) , hash . data ( ) , hashLen , key . data ( ) , reinterpret_cast < unsigned int * > ( & keyLen ) ) ) { log < level : : DEBUG > ( \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>MAC<S2SV_blank>for<S2SV_blank>authentication\" ) ; return - EIO ; } if ( RAND_bytes ( iv . data ( ) , ivLen ) != 1 ) { log < level : : DEBUG > ( \"UV<S2SV_blank>genertion<S2SV_blank>failed,<S2SV_blank>bailing<S2SV_blank>out\" ) ; return - EIO ; } std : : vector < uint8_t > outBytes ( inBytesLen + EVP_MAX_BLOCK_LENGTH ) ; size_t outBytesLen = 0 ; if ( inBytesLen != 0 ) { if ( encryptDecryptData ( true , EVP_aes_128_cbc ( ) , key . data ( ) , keyLen , iv . data ( ) , ivLen , inBytes . data ( ) , inBytesLen , mac . data ( ) , & macLen , outBytes . data ( ) , & outBytesLen ) != 0 ) { log < level : : DEBUG > ( \"Error<S2SV_blank>while<S2SV_blank>encrypting<S2SV_blank>the<S2SV_blank>data\" ) ; return - EIO ; } outBytes [ outBytesLen ] = 0 ; } OPENSSL_cleanse ( key . data ( ) , keyLen ) ; MetaPassStruct metaData = { META_PASSWD_SIG , { 0 , 0 } , 0 , 0 , 0 , 0 , 0 } ; metaData . hashSize = hashLen ; metaData . ivSize = ivLen ; metaData . dataSize = bytesWritten ; metaData . padSize = outBytesLen - bytesWritten ; metaData . macSize = macLen ; if ( fwrite ( & metaData , 1 , sizeof ( metaData ) , ( temp ) ( ) ) != sizeof ( metaData ) ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>meta<S2SV_blank>data\" ) ; return - EIO ; } if ( fwrite ( & hash [ 0 ] , 1 , hashLen , ( temp ) ( ) ) != hashLen ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>hash<S2SV_blank>data\" ) ; return - EIO ; } if ( fwrite ( & iv [ 0 ] , 1 , ivLen , ( temp ) ( ) ) != ivLen ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>IV<S2SV_blank>data\" ) ; return - EIO ; } if ( fwrite ( & outBytes [ 0 ] , 1 , outBytesLen , ( temp ) ( ) ) != outBytesLen ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>encrypted<S2SV_blank>data\" ) ; return - EIO ; } if ( fwrite ( & mac [ 0 ] , 1 , macLen , ( temp ) ( ) ) != macLen ) { log < level : : DEBUG > ( \"Error<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>MAC<S2SV_blank>data\" ) ; return - EIO ; } if ( fflush ( ( temp ) ( ) ) ) { log < level : : DEBUG > ( \"File<S2SV_blank>fflush<S2SV_blank>error<S2SV_blank>while<S2SV_blank>writing<S2SV_blank>entries<S2SV_blank>to<S2SV_blank>special<S2SV_blank>file\" ) ; return - EIO ; } OPENSSL_cleanse ( iv . data ( ) , ivLen ) ; if ( std : : rename ( strTempFileName . data ( ) , passwdFileName ) != 0 ) { log < level : : DEBUG > ( \"Failed<S2SV_blank>to<S2SV_blank>rename<S2SV_blank>tmp<S2SV_blank>file<S2SV_blank>to<S2SV_blank>ipmi-pass\" ) ; return - EIO ; } return 0 ; }", "target": "<S2SV_ModStart> ) ) , S_IRUSR | S_IWUSR <S2SV_ModEnd> ) < 0"}
{"source": "CWE-787 static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , \"s#nO!s#s#\" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , \"expecting<S2SV_blank>tuple\" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , \"expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3\" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength || <S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , \"corrupt<S2SV_blank>patch<S2SV_blank>(overflow)\" ) ; return NULL ; } <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , \"corrupt<S2SV_blank>patch<S2SV_blank>(underflow)\" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }", "target": "<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , \"corrupt<S2SV_blank>patch<S2SV_blank>(overflow)\" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData"}
{"source": "CWE-120 static int src_parser_trans_stage_1_2_3 ( const int tmp_fd , const char * src , const struct trans_config cfg ) { struct parser_buf pbuf = { . f_indx = 0 , . tmp_indx = 0 , . f_read_size = 0 } ; int write_count = 0 ; int src_fd ; int p_state = P_STATE_CODE ; src_fd = open ( src , O_RDONLY ) ; if ( src_fd == - 1 ) { fprintf ( stderr , \"**Error:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>source<S2SV_blank>file:<S2SV_blank>%s.\\\\n\" , src ) ; return - 1 ; } while ( p_buf_refill ( & pbuf , src_fd ) > 0 ) { while ( PBUF_F_REMD ( pbuf ) ) { switch ( p_state ) { case P_STATE_COMMENT_C : switch ( PBUF_F_CHAR ( pbuf ) ) { case '*' : p_buf_push_tmp_char ( & pbuf , '*' ) ; continue ; case '/' : if ( pbuf . tmp_indx && ( PBUF_TMP_PREV_CHAR ( pbuf ) == '*' ) ) { pbuf . tmp_indx -- ; p_state = P_STATE_CODE ; } break ; default : if ( pbuf . tmp_indx && ( PBUF_TMP_PREV_CHAR ( pbuf ) == '*' ) ) pbuf . tmp_indx -- ; break ; } pbuf . f_indx ++ ; case P_STATE_CODE : default : switch ( PBUF_F_CHAR ( pbuf ) ) { case '<S2SV_blank>' : case '\\\\t' : if ( pbuf . tmp_indx && ( PBUF_TMP_PREV_CHAR ( pbuf ) == '<S2SV_blank>' || PBUF_TMP_PREV_CHAR ( pbuf ) == '\\\\t' || PBUF_TMP_PREV_CHAR ( pbuf ) == '\\\\n' ) ) pbuf . f_indx ++ ; else p_buf_push_tmp_char ( & pbuf , '<S2SV_blank>' ) ; continue ; case '\\\\r' : case '\\\\n' : if ( pbuf . tmp_indx && ( PBUF_TMP_PREV_CHAR ( pbuf ) == '<S2SV_blank>' || PBUF_TMP_PREV_CHAR ( pbuf ) == '\\\\t' || PBUF_TMP_PREV_CHAR ( pbuf ) == '\\\\n' ) ) { pbuf . f_indx ++ ; } else if ( pbuf . tmp_indx && ( PBUF_TMP_PREV_CHAR ( pbuf ) == '\\\\\\\\' ) ) { pbuf . tmp_indx -- ; pbuf . f_indx ++ ; } else { p_buf_push_tmp_char ( & pbuf , '\\\\n' ) ; } continue ; case '\\\\\\\\' : <S2SV_StartBug> p_buf_push_tmp_char ( & pbuf , '\\\\\\\\' ) ; <S2SV_EndBug> continue ; <S2SV_StartBug> case '/' : <S2SV_EndBug> p_buf_push_tmp_char ( & pbuf , '/' ) ; continue ; case '*' : if ( pbuf . tmp_indx && ( PBUF_TMP_PREV_CHAR ( pbuf ) == '/' ) ) { pbuf . tmp_indx -- ; pbuf . f_indx ++ ; p_state = P_STATE_COMMENT_C ; continue ; } default : break ; } p_buf_write_tmp ( & pbuf , tmp_fd ) ; p_buf_write_f_char ( & pbuf , tmp_fd ) ; } } } p_buf_write_tmp ( & pbuf , tmp_fd ) ; return 0 ; }", "target": "<S2SV_ModStart> case '\\\\\\\\' : p_buf_write_tmp ( & pbuf , tmp_fd ) ; <S2SV_ModStart> case '/' : p_buf_write_tmp ( & pbuf , tmp_fd ) ;"}
{"source": "CWE-416 static XMLSharedNodeList * find_impl ( xmlXPathContext * ctxt , const string & xpath ) { xmlXPathObject * result = xmlXPathEval ( ( const xmlChar * ) xpath . c_str ( ) , ctxt ) ; if ( ! result ) { <S2SV_StartBug> xmlXPathFreeContext ( ctxt ) ; <S2SV_EndBug> xmlFreeDoc ( ctxt -> doc ) ; throw XMLException ( \"Invalid<S2SV_blank>XPath:<S2SV_blank>\" + xpath ) ; } if ( result -> type != XPATH_NODESET ) { xmlXPathFreeObject ( result ) ; <S2SV_StartBug> xmlXPathFreeContext ( ctxt ) ; <S2SV_EndBug> xmlFreeDoc ( ctxt -> doc ) ; throw XMLException ( \"Only<S2SV_blank>nodeset<S2SV_blank>result<S2SV_blank>types<S2SV_blank>are<S2SV_blank>supported.\" ) ; } xmlNodeSet * nodeset = result -> nodesetval ; XMLSharedNodeList * nodes = new XMLSharedNodeList ( ) ; if ( nodeset ) { for ( int i = 0 ; i < nodeset -> nodeNr ; ++ i ) { XMLNode * node = readnode ( nodeset -> nodeTab [ i ] ) ; nodes -> push_back ( boost : : shared_ptr < XMLNode > ( node ) ) ; } } else { } xmlXPathFreeObject ( result ) ; return nodes ; }", "target": "<S2SV_ModStart> result ) { xmlFreeDoc ( ctxt -> doc ) ; <S2SV_ModStart> xmlXPathFreeContext ( ctxt <S2SV_ModEnd> ) ; throw <S2SV_ModStart> result ) ; xmlFreeDoc ( ctxt -> doc ) ; <S2SV_ModStart> xmlXPathFreeContext ( ctxt <S2SV_ModEnd> ) ; throw"}
{"source": "CWE-190 int Jsi_ObjArraySizer ( Jsi_Interp * interp , Jsi_Obj * obj , uint len ) { <S2SV_StartBug> int nsiz = len + 1 , mod = ALLOC_MOD_SIZE ; <S2SV_EndBug> assert ( obj -> isarrlist ) ; if ( mod > 1 ) nsiz = nsiz + ( ( mod - 1 ) - ( nsiz + mod - 1 ) % mod ) ; <S2SV_StartBug> if ( nsiz > MAX_ARRAY_LIST ) { <S2SV_EndBug> <S2SV_StartBug> Jsi_LogError ( \"array<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\" ) ; <S2SV_EndBug> return 0 ; } if ( len >= obj -> arrMaxSize ) { int oldsz = ( nsiz - obj -> arrMaxSize ) ; obj -> arr = ( Jsi_Value * * ) Jsi_Realloc ( obj -> arr , nsiz * sizeof ( Jsi_Value * ) ) ; memset ( obj -> arr + obj -> arrMaxSize , 0 , oldsz * sizeof ( Jsi_Value * ) ) ; obj -> arrMaxSize = nsiz ; } if ( len > obj -> arrCnt ) obj -> arrCnt = len ; return nsiz ; }", "target": "<S2SV_ModStart> len ) { uint <S2SV_ModEnd> nsiz = len <S2SV_ModStart> ; if ( len >= interp -> maxArrayList || nsiz > interp -> maxArrayList <S2SV_ModEnd> ) { Jsi_LogError <S2SV_ModStart> { Jsi_LogError ( \"array<S2SV_blank>size<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%u<S2SV_blank>>=<S2SV_blank>%u\" , len , interp -> maxArrayList <S2SV_ModEnd> ) ; return"}
{"source": "CWE-287 ngx_http_auth_spnego_handler ( ngx_http_request_t * r ) { ngx_int_t ret = NGX_DECLINED ; ngx_http_auth_spnego_ctx_t * ctx ; ngx_http_auth_spnego_loc_conf_t * alcf ; alcf = ngx_http_get_module_loc_conf ( r , ngx_http_auth_spnego_module ) ; if ( alcf -> protect == 0 ) { return NGX_DECLINED ; } ctx = ngx_http_get_module_ctx ( r , ngx_http_auth_spnego_module ) ; if ( NULL == ctx ) { ctx = ngx_palloc ( r -> pool , sizeof ( ngx_http_auth_spnego_ctx_t ) ) ; if ( NULL == ctx ) { return NGX_HTTP_INTERNAL_SERVER_ERROR ; } ctx -> token . len = 0 ; ctx -> token . data = NULL ; ctx -> head = 0 ; ctx -> ret = NGX_HTTP_UNAUTHORIZED ; ngx_http_set_ctx ( r , ctx , ngx_http_auth_spnego_module ) ; } spnego_debug3 ( \"SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>IN:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d\" , ctx -> token . len , ctx -> head , ctx -> ret ) ; if ( ctx -> token . len && ctx -> head ) { spnego_debug1 ( \"Found<S2SV_blank>token<S2SV_blank>and<S2SV_blank>head,<S2SV_blank>returning<S2SV_blank>%d\" , ctx -> ret ) ; return ctx -> ret ; } if ( NULL != r -> headers_in . user . data ) { spnego_debug0 ( \"User<S2SV_blank>header<S2SV_blank>set\" ) ; return NGX_OK ; } spnego_debug0 ( \"Begin<S2SV_blank>auth\" ) ; if ( alcf -> allow_basic ) { spnego_debug0 ( \"Detect<S2SV_blank>basic<S2SV_blank>auth\" ) ; ret = ngx_http_auth_basic_user ( r ) ; if ( NGX_OK == ret ) { spnego_debug0 ( \"Basic<S2SV_blank>auth<S2SV_blank>credentials<S2SV_blank>supplied<S2SV_blank>by<S2SV_blank>client\" ) ; <S2SV_StartBug> if ( NGX_DECLINED == ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) { <S2SV_EndBug> spnego_debug0 ( \"Basic<S2SV_blank>auth<S2SV_blank>failed\" ) ; if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( \"Error<S2SV_blank>setting<S2SV_blank>headers\" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( \"User<S2SV_blank>not<S2SV_blank>authorized\" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( \"Basic<S2SV_blank>auth<S2SV_blank>succeeded\" ) ; return ( ctx -> ret = NGX_OK ) ; } } spnego_debug0 ( \"Detect<S2SV_blank>SPNEGO<S2SV_blank>token\" ) ; ret = ngx_http_auth_spnego_token ( r , ctx ) ; if ( NGX_OK == ret ) { spnego_debug0 ( \"Client<S2SV_blank>sent<S2SV_blank>a<S2SV_blank>reasonable<S2SV_blank>Negotiate<S2SV_blank>header\" ) ; ret = ngx_http_auth_spnego_auth_user_gss ( r , ctx , alcf ) ; if ( NGX_ERROR == ret ) { spnego_debug0 ( \"GSSAPI<S2SV_blank>failed\" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } if ( NGX_DECLINED == ret ) { spnego_debug0 ( \"GSSAPI<S2SV_blank>failed\" ) ; if ( ! alcf -> allow_basic ) { return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( \"Error<S2SV_blank>setting<S2SV_blank>headers\" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( \"User<S2SV_blank>not<S2SV_blank>authorized\" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( \"GSSAPI<S2SV_blank>auth<S2SV_blank>succeeded\" ) ; } ngx_str_t * token_out_b64 = NULL ; switch ( ret ) { case NGX_DECLINED : ctx -> ret = NGX_HTTP_UNAUTHORIZED ; break ; case NGX_OK : ctx -> ret = NGX_OK ; token_out_b64 = & ctx -> token_out_b64 ; break ; case NGX_ERROR : default : ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; break ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers ( r , ctx , token_out_b64 , alcf ) ) { spnego_debug0 ( \"Error<S2SV_blank>setting<S2SV_blank>headers\" ) ; ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; } spnego_debug3 ( \"SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>OUT:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d\" , ctx -> token . len , ctx -> head , ctx -> ret ) ; return ctx -> ret ; }", "target": "<S2SV_ModStart> ; if ( NGX_OK != <S2SV_ModEnd> ngx_http_auth_spnego_basic ( r"}
{"source": "CWE-681 static uint64_t unpack_timestamp ( const struct efi_time * timestamp ) { uint64_t val = 0 ; <S2SV_StartBug> uint16_t year = le32_to_cpu ( timestamp -> year ) ; <S2SV_EndBug> val |= ( ( uint64_t ) timestamp -> pad1 & 0xFF ) << 0 ; val |= ( ( uint64_t ) timestamp -> second & 0xFF ) << ( 1 * 8 ) ; val |= ( ( uint64_t ) timestamp -> minute & 0xFF ) << ( 2 * 8 ) ; val |= ( ( uint64_t ) timestamp -> hour & 0xFF ) << ( 3 * 8 ) ; val |= ( ( uint64_t ) timestamp -> day & 0xFF ) << ( 4 * 8 ) ; val |= ( ( uint64_t ) timestamp -> month & 0xFF ) << ( 5 * 8 ) ; val |= ( ( uint64_t ) year ) << ( 6 * 8 ) ; return val ; }", "target": "<S2SV_ModStart> uint16_t year = le16_to_cpu <S2SV_ModEnd> ( timestamp ->"}
