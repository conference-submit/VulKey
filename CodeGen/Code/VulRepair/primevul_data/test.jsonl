{"source": "CWE-704 static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER \"\\\\n\" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005 <S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MaxTextExtent - length , format \",<S2SV_blank>\" , arg ) ; if ( length >= ( MaxTextExtent - 1 ) ) length = MaxTextExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MaxTextExtent - length , format \",<S2SV_blank>\" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MaxTextExtent - 1 ) ) length = MaxTextExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char description [ 36 ] ; } TagInfo ; static const TagInfo EXIFTag [ ] = { { 0x001 , \"exif:InteroperabilityIndex\" } , { 0x002 , \"exif:InteroperabilityVersion\" } , { 0x100 , \"exif:ImageWidth\" } , { 0x101 , \"exif:ImageLength\" } , { 0x102 , \"exif:BitsPerSample\" } , { 0x103 , \"exif:Compression\" } , { 0x106 , \"exif:PhotometricInterpretation\" } , { 0x10a , \"exif:FillOrder\" } , { 0x10d , \"exif:DocumentName\" } , { 0x10e , \"exif:ImageDescription\" } , { 0x10f , \"exif:Make\" } , { 0x110 , \"exif:Model\" } , { 0x111 , \"exif:StripOffsets\" } , { 0x112 , \"exif:Orientation\" } , { 0x115 , \"exif:SamplesPerPixel\" } , { 0x116 , \"exif:RowsPerStrip\" } , { 0x117 , \"exif:StripByteCounts\" } , { 0x11a , \"exif:XResolution\" } , { 0x11b , \"exif:YResolution\" } , { 0x11c , \"exif:PlanarConfiguration\" } , { 0x11d , \"exif:PageName\" } , { 0x11e , \"exif:XPosition\" } , { 0x11f , \"exif:YPosition\" } , { 0x118 , \"exif:MinSampleValue\" } , { 0x119 , \"exif:MaxSampleValue\" } , { 0x120 , \"exif:FreeOffsets\" } , { 0x121 , \"exif:FreeByteCounts\" } , { 0x122 , \"exif:GrayResponseUnit\" } , { 0x123 , \"exif:GrayResponseCurve\" } , { 0x124 , \"exif:T4Options\" } , { 0x125 , \"exif:T6Options\" } , { 0x128 , \"exif:ResolutionUnit\" } , { 0x12d , \"exif:TransferFunction\" } , { 0x131 , \"exif:Software\" } , { 0x132 , \"exif:DateTime\" } , { 0x13b , \"exif:Artist\" } , { 0x13e , \"exif:WhitePoint\" } , { 0x13f , \"exif:PrimaryChromaticities\" } , { 0x140 , \"exif:ColorMap\" } , { 0x141 , \"exif:HalfToneHints\" } , { 0x142 , \"exif:TileWidth\" } , { 0x143 , \"exif:TileLength\" } , { 0x144 , \"exif:TileOffsets\" } , { 0x145 , \"exif:TileByteCounts\" } , { 0x14a , \"exif:SubIFD\" } , { 0x14c , \"exif:InkSet\" } , { 0x14d , \"exif:InkNames\" } , { 0x14e , \"exif:NumberOfInks\" } , { 0x150 , \"exif:DotRange\" } , { 0x151 , \"exif:TargetPrinter\" } , { 0x152 , \"exif:ExtraSample\" } , { 0x153 , \"exif:SampleFormat\" } , { 0x154 , \"exif:SMinSampleValue\" } , { 0x155 , \"exif:SMaxSampleValue\" } , { 0x156 , \"exif:TransferRange\" } , { 0x157 , \"exif:ClipPath\" } , { 0x158 , \"exif:XClipPathUnits\" } , { 0x159 , \"exif:YClipPathUnits\" } , { 0x15a , \"exif:Indexed\" } , { 0x15b , \"exif:JPEGTables\" } , { 0x15f , \"exif:OPIProxy\" } , { 0x200 , \"exif:JPEGProc\" } , { 0x201 , \"exif:JPEGInterchangeFormat\" } , { 0x202 , \"exif:JPEGInterchangeFormatLength\" } , { 0x203 , \"exif:JPEGRestartInterval\" } , { 0x205 , \"exif:JPEGLosslessPredictors\" } , { 0x206 , \"exif:JPEGPointTransforms\" } , { 0x207 , \"exif:JPEGQTables\" } , { 0x208 , \"exif:JPEGDCTables\" } , { 0x209 , \"exif:JPEGACTables\" } , { 0x211 , \"exif:YCbCrCoefficients\" } , { 0x212 , \"exif:YCbCrSubSampling\" } , { 0x213 , \"exif:YCbCrPositioning\" } , { 0x214 , \"exif:ReferenceBlackWhite\" } , { 0x2bc , \"exif:ExtensibleMetadataPlatform\" } , { 0x301 , \"exif:Gamma\" } , { 0x302 , \"exif:ICCProfileDescriptor\" } , { 0x303 , \"exif:SRGBRenderingIntent\" } , { 0x320 , \"exif:ImageTitle\" } , { 0x5001 , \"exif:ResolutionXUnit\" } , { 0x5002 , \"exif:ResolutionYUnit\" } , { 0x5003 , \"exif:ResolutionXLengthUnit\" } , { 0x5004 , \"exif:ResolutionYLengthUnit\" } , { 0x5005 , \"exif:PrintFlags\" } , { 0x5006 , \"exif:PrintFlagsVersion\" } , { 0x5007 , \"exif:PrintFlagsCrop\" } , { 0x5008 , \"exif:PrintFlagsBleedWidth\" } , { 0x5009 , \"exif:PrintFlagsBleedWidthScale\" } , { 0x500A , \"exif:HalftoneLPI\" } , { 0x500B , \"exif:HalftoneLPIUnit\" } , { 0x500C , \"exif:HalftoneDegree\" } , { 0x500D , \"exif:HalftoneShape\" } , { 0x500E , \"exif:HalftoneMisc\" } , { 0x500F , \"exif:HalftoneScreen\" } , { 0x5010 , \"exif:JPEGQuality\" } , { 0x5011 , \"exif:GridSize\" } , { 0x5012 , \"exif:ThumbnailFormat\" } , { 0x5013 , \"exif:ThumbnailWidth\" } , { 0x5014 , \"exif:ThumbnailHeight\" } , { 0x5015 , \"exif:ThumbnailColorDepth\" } , { 0x5016 , \"exif:ThumbnailPlanes\" } , { 0x5017 , \"exif:ThumbnailRawBytes\" } , { 0x5018 , \"exif:ThumbnailSize\" } , { 0x5019 , \"exif:ThumbnailCompressedSize\" } , { 0x501a , \"exif:ColorTransferFunction\" } , { 0x501b , \"exif:ThumbnailData\" } , { 0x5020 , \"exif:ThumbnailImageWidth\" } , { 0x5021 , \"exif:ThumbnailImageHeight\" } , { 0x5022 , \"exif:ThumbnailBitsPerSample\" } , { 0x5023 , \"exif:ThumbnailCompression\" } , { 0x5024 , \"exif:ThumbnailPhotometricInterp\" } , { 0x5025 , \"exif:ThumbnailImageDescription\" } , { 0x5026 , \"exif:ThumbnailEquipMake\" } , { 0x5027 , \"exif:ThumbnailEquipModel\" } , { 0x5028 , \"exif:ThumbnailStripOffsets\" } , { 0x5029 , \"exif:ThumbnailOrientation\" } , { 0x502a , \"exif:ThumbnailSamplesPerPixel\" } , { 0x502b , \"exif:ThumbnailRowsPerStrip\" } , { 0x502c , \"exif:ThumbnailStripBytesCount\" } , { 0x502d , \"exif:ThumbnailResolutionX\" } , { 0x502e , \"exif:ThumbnailResolutionY\" } , { 0x502f , \"exif:ThumbnailPlanarConfig\" } , { 0x5030 , \"exif:ThumbnailResolutionUnit\" } , { 0x5031 , \"exif:ThumbnailTransferFunction\" } , { 0x5032 , \"exif:ThumbnailSoftwareUsed\" } , { 0x5033 , \"exif:ThumbnailDateTime\" } , { 0x5034 , \"exif:ThumbnailArtist\" } , { 0x5035 , \"exif:ThumbnailWhitePoint\" } , { 0x5036 , \"exif:ThumbnailPrimaryChromaticities\" } , { 0x5037 , \"exif:ThumbnailYCbCrCoefficients\" } , { 0x5038 , \"exif:ThumbnailYCbCrSubsampling\" } , { 0x5039 , \"exif:ThumbnailYCbCrPositioning\" } , { 0x503A , \"exif:ThumbnailRefBlackWhite\" } , { 0x503B , \"exif:ThumbnailCopyRight\" } , { 0x5090 , \"exif:LuminanceTable\" } , { 0x5091 , \"exif:ChrominanceTable\" } , { 0x5100 , \"exif:FrameDelay\" } , { 0x5101 , \"exif:LoopCount\" } , { 0x5110 , \"exif:PixelUnit\" } , { 0x5111 , \"exif:PixelPerUnitX\" } , { 0x5112 , \"exif:PixelPerUnitY\" } , { 0x5113 , \"exif:PaletteHistogram\" } , { 0x1000 , \"exif:RelatedImageFileFormat\" } , { 0x1001 , \"exif:RelatedImageLength\" } , { 0x1002 , \"exif:RelatedImageWidth\" } , { 0x800d , \"exif:ImageID\" } , { 0x80e3 , \"exif:Matteing\" } , { 0x80e4 , \"exif:DataType\" } , { 0x80e5 , \"exif:ImageDepth\" } , { 0x80e6 , \"exif:TileDepth\" } , { 0x828d , \"exif:CFARepeatPatternDim\" } , { 0x828e , \"exif:CFAPattern2\" } , { 0x828f , \"exif:BatteryLevel\" } , { 0x8298 , \"exif:Copyright\" } , { 0x829a , \"exif:ExposureTime\" } , { 0x829d , \"exif:FNumber\" } , { 0x83bb , \"exif:IPTC/NAA\" } , { 0x84e3 , \"exif:IT8RasterPadding\" } , { 0x84e5 , \"exif:IT8ColorTable\" } , { 0x8649 , \"exif:ImageResourceInformation\" } , { 0x8769 , \"exif:ExifOffset\" } , { 0x8773 , \"exif:InterColorProfile\" } , { 0x8822 , \"exif:ExposureProgram\" } , { 0x8824 , \"exif:SpectralSensitivity\" } , { 0x8825 , \"exif:GPSInfo\" } , { 0x8827 , \"exif:PhotographicSensitivity\" } , { 0x8828 , \"exif:OECF\" } , { 0x8829 , \"exif:Interlace\" } , { 0x882a , \"exif:TimeZoneOffset\" } , { 0x882b , \"exif:SelfTimerMode\" } , { 0x8830 , \"exif:SensitivityType\" } , { 0x8831 , \"exif:StandardOutputSensitivity\" } , { 0x8832 , \"exif:RecommendedExposureIndex\" } , { 0x8833 , \"exif:ISOSpeed\" } , { 0x8834 , \"exif:ISOSpeedLatitudeyyy\" } , { 0x8835 , \"exif:ISOSpeedLatitudezzz\" } , { 0x9000 , \"exif:ExifVersion\" } , { 0x9003 , \"exif:DateTimeOriginal\" } , { 0x9004 , \"exif:DateTimeDigitized\" } , { 0x9010 , \"exif:OffsetTime\" } , { 0x9011 , \"exif:OffsetTimeOriginal\" } , { 0x9012 , \"exif:OffsetTimeDigitized\" } , { 0x9101 , \"exif:ComponentsConfiguration\" } , { 0x9102 , \"exif:CompressedBitsPerPixel\" } , { 0x9201 , \"exif:ShutterSpeedValue\" } , { 0x9202 , \"exif:ApertureValue\" } , { 0x9203 , \"exif:BrightnessValue\" } , { 0x9204 , \"exif:ExposureBiasValue\" } , { 0x9205 , \"exif:MaxApertureValue\" } , { 0x9206 , \"exif:SubjectDistance\" } , { 0x9207 , \"exif:MeteringMode\" } , { 0x9208 , \"exif:LightSource\" } , { 0x9209 , \"exif:Flash\" } , { 0x920a , \"exif:FocalLength\" } , { 0x920b , \"exif:FlashEnergy\" } , { 0x920c , \"exif:SpatialFrequencyResponse\" } , { 0x920d , \"exif:Noise\" } , { 0x9214 , \"exif:SubjectArea\" } , { 0x9290 , \"exif:SubSecTime\" } , { 0x9291 , \"exif:SubSecTimeOriginal\" } , { 0x9292 , \"exif:SubSecTimeDigitized\" } , { 0x9211 , \"exif:ImageNumber\" } , { 0x9212 , \"exif:SecurityClassification\" } , { 0x9213 , \"exif:ImageHistory\" } , { 0x9214 , \"exif:SubjectArea\" } , { 0x9215 , \"exif:ExposureIndex\" } , { 0x9216 , \"exif:TIFF-EPStandardID\" } , { 0x927c , \"exif:MakerNote\" } , { 0x9286 , \"exif:UserComment\" } , { 0x9290 , \"exif:SubSecTime\" } , { 0x9291 , \"exif:SubSecTimeOriginal\" } , { 0x9292 , \"exif:SubSecTimeDigitized\" } , { 0x9400 , \"exif:Temperature\" } , { 0x9401 , \"exif:Humidity\" } , { 0x9402 , \"exif:Pressure\" } , { 0x9403 , \"exif:WaterDepth\" } , { 0x9404 , \"exif:Acceleration\" } , { 0x9405 , \"exif:CameraElevationAngle\" } , { 0x9C9b , \"exif:WinXP-Title\" } , { 0x9C9c , \"exif:WinXP-Comments\" } , { 0x9C9d , \"exif:WinXP-Author\" } , { 0x9C9e , \"exif:WinXP-Keywords\" } , { 0x9C9f , \"exif:WinXP-Subject\" } , { 0xa000 , \"exif:FlashPixVersion\" } , { 0xa001 , \"exif:ColorSpace\" } , { 0xa002 , \"exif:PixelXDimension\" } , { 0xa003 , \"exif:PixelYDimension\" } , { 0xa004 , \"exif:RelatedSoundFile\" } , { 0xa005 , \"exif:InteroperabilityOffset\" } , { 0xa20b , \"exif:FlashEnergy\" } , { 0xa20c , \"exif:SpatialFrequencyResponse\" } , { 0xa20d , \"exif:Noise\" } , { 0xa20e , \"exif:FocalPlaneXResolution\" } , { 0xa20f , \"exif:FocalPlaneYResolution\" } , { 0xa210 , \"exif:FocalPlaneResolutionUnit\" } , { 0xa214 , \"exif:SubjectLocation\" } , { 0xa215 , \"exif:ExposureIndex\" } , { 0xa216 , \"exif:TIFF/EPStandardID\" } , { 0xa217 , \"exif:SensingMethod\" } , { 0xa300 , \"exif:FileSource\" } , { 0xa301 , \"exif:SceneType\" } , { 0xa302 , \"exif:CFAPattern\" } , { 0xa401 , \"exif:CustomRendered\" } , { 0xa402 , \"exif:ExposureMode\" } , { 0xa403 , \"exif:WhiteBalance\" } , { 0xa404 , \"exif:DigitalZoomRatio\" } , { 0xa405 , \"exif:FocalLengthIn35mmFilm\" } , { 0xa406 , \"exif:SceneCaptureType\" } , { 0xa407 , \"exif:GainControl\" } , { 0xa408 , \"exif:Contrast\" } , { 0xa409 , \"exif:Saturation\" } , { 0xa40a , \"exif:Sharpness\" } , { 0xa40b , \"exif:DeviceSettingDescription\" } , { 0xa40c , \"exif:SubjectDistanceRange\" } , { 0xa420 , \"exif:ImageUniqueID\" } , { 0xa430 , \"exif:CameraOwnerName\" } , { 0xa431 , \"exif:BodySerialNumber\" } , { 0xa432 , \"exif:LensSpecification\" } , { 0xa433 , \"exif:LensMake\" } , { 0xa434 , \"exif:LensModel\" } , { 0xa435 , \"exif:LensSerialNumber\" } , { 0xc4a5 , \"exif:PrintImageMatching\" } , { 0xa500 , \"exif:Gamma\" } , { 0xc640 , \"exif:CR2Slice\" } , { 0x10000 , \"exif:GPSVersionID\" } , { 0x10001 , \"exif:GPSLatitudeRef\" } , { 0x10002 , \"exif:GPSLatitude\" } , { 0x10003 , \"exif:GPSLongitudeRef\" } , { 0x10004 , \"exif:GPSLongitude\" } , { 0x10005 , \"exif:GPSAltitudeRef\" } , { 0x10006 , \"exif:GPSAltitude\" } , { 0x10007 , \"exif:GPSTimeStamp\" } , { 0x10008 , \"exif:GPSSatellites\" } , { 0x10009 , \"exif:GPSStatus\" } , { 0x1000a , \"exif:GPSMeasureMode\" } , { 0x1000b , \"exif:GPSDop\" } , { 0x1000c , \"exif:GPSSpeedRef\" } , { 0x1000d , \"exif:GPSSpeed\" } , { 0x1000e , \"exif:GPSTrackRef\" } , { 0x1000f , \"exif:GPSTrack\" } , { 0x10010 , \"exif:GPSImgDirectionRef\" } , { 0x10011 , \"exif:GPSImgDirection\" } , { 0x10012 , \"exif:GPSMapDatum\" } , { 0x10013 , \"exif:GPSDestLatitudeRef\" } , { 0x10014 , \"exif:GPSDestLatitude\" } , { 0x10015 , \"exif:GPSDestLongitudeRef\" } , { 0x10016 , \"exif:GPSDestLongitude\" } , { 0x10017 , \"exif:GPSDestBearingRef\" } , { 0x10018 , \"exif:GPSDestBearing\" } , { 0x10019 , \"exif:GPSDestDistanceRef\" } , { 0x1001a , \"exif:GPSDestDistance\" } , { 0x1001b , \"exif:GPSProcessingMethod\" } , { 0x1001c , \"exif:GPSAreaInformation\" } , { 0x1001d , \"exif:GPSDateStamp\" } , { 0x1001e , \"exif:GPSDifferential\" } , { 0x1001f , \"exif:GPSHPositioningError\" } , { 0x00000 , \"\" } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , \"exif\" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; if ( length < 6 ) return ( MagickFalse ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ; if ( q > ( exif + length - 12 ) ) break ; if ( GetValueFromSplayTree ( exif_resources , q ) == q ) break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ; if ( format == 0 ) break ; components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; if ( components < 0 ) break ; number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t dir_offset ; dir_offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( dir_offset < 0 ) || ( size_t ) dir_offset >= length ) continue ; if ( ( ( size_t ) dir_offset + number_bytes ) < ( size_t ) dir_offset ) continue ; if ( ( ( size_t ) dir_offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + dir_offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MaxTextExtent ] , * value ; if ( ( p < exif ) || ( p > ( exif + length - tag_bytes [ format ] ) ) ) break ; value = ( char * ) NULL ; * buffer = '\\\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( isprint ( ( int ) p [ i ] ) != 0 ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\\\0' ; } break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , \"%.20g\" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , \"%hd\" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , \"%hu\" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , \"%.20g\" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , \"%.20g\" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , \"%.20g/%.20g\" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , \"%.20g/%.20g\" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { <S2SV_StartBug> EXIFMultipleValues ( 4 , \"%f\" , ( double ) * ( float * ) p1 ) ; <S2SV_EndBug> break ; } case EXIF_FMT_DOUBLE : { <S2SV_StartBug> EXIFMultipleValues ( 8 , \"%f\" , * ( double * ) p1 ) ; <S2SV_EndBug> break ; } case EXIF_FMT_STRING : default : { if ( ( p < exif ) || ( p > ( exif + length - number_bytes ) ) ) break ; value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; ssize_t i ; description = \"unknown\" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MaxTextExtent , \"%s\" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , \"exif:\" , \"exif:thumbnail:\" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MaxTextExtent , \"#%04lx\" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MaxTextExtent , \"@%04lx\" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MaxTextExtent , \"unknown\" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , \"exif:\" , \"exif:thumbnail:\" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; for ( i = 0 ; i < level ; i ++ ) if ( directory_stack [ i ] . directory == ( exif + tag_offset1 ) ) break ; if ( i < level ) break ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) + 4 ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }", "target": "<S2SV_ModStart> , arg ) \\\\\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\\\\n} <S2SV_ModEnd> # define EXIFMultipleFractions <S2SV_ModStart> , arg2 ) \\\\\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\\\\n} <S2SV_ModEnd> typedef struct _DirectoryInfo <S2SV_ModStart> ( 4 , \"%.20g\" <S2SV_ModEnd> , ( double <S2SV_ModStart> ( double ) ReadPropertySignedLong ( endian , p1 ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( 8 , \"%.20g\" , ( double ) ReadPropertySignedLong ( endian , p1 ) <S2SV_ModEnd> ) ; break"}
{"source": "CWE-190 static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const ssize_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; const unsigned char * p ; IndexPacket * indexes ; PixelPacket * q ; ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; indexes = GetAuthenticIndexQueue ( image ) ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else if ( packet_size == 2 ) { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } else { MagickFloatType nibble ; p = PushFloatPixel ( MSBEndian , p , & nibble ) ; pixel = ClampToQuantum ( ( MagickRealType ) QuantumRange * nibble ) ; } if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , indexes , x ) ; q ++ ; } else { ssize_t bit , number_bits ; number_bits = ( ssize_t ) image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { <S2SV_StartBug> SetPSDPixel ( image , channels , type , packet_size , ( ( ( unsigned char ) pixel ) <S2SV_EndBug> & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : QuantumRange , q ++ , indexes , x ++ ) ; } if ( x != ( ssize_t ) image -> columns ) x -- ; continue ; } } return ( SyncAuthenticPixels ( image , exception ) ) ; }", "target": "<S2SV_ModStart> unsigned char ) ( ( ssize_t ) pixel ) ) <S2SV_ModEnd> & ( 0x01"}
{"source": "CWE-401 Status ImmutableExecutorState : : Initialize ( const Graph & graph ) { TF_RETURN_IF_ERROR ( gview_ . Initialize ( & graph ) ) ; ControlFlowInfo cf_info ; TF_RETURN_IF_ERROR ( BuildControlFlowInfo ( & graph , & cf_info ) ) ; for ( auto & it : cf_info . unique_frame_names ) { EnsureFrameInfo ( it ) -> nodes = absl : : make_unique < std : : vector < const NodeItem * >> ( ) ; } root_frame_info_ = frame_info_ [ \"\" ] . get ( ) ; pending_ids_ . resize ( gview_ . num_nodes ( ) ) ; requires_control_flow_ = false ; for ( const Node * n : graph . nodes ( ) ) { if ( IsSink ( n ) ) continue ; if ( IsSwitch ( n ) || IsMerge ( n ) || IsEnter ( n ) || IsExit ( n ) ) { requires_control_flow_ = true ; } else if ( IsRecv ( n ) ) { string send_device ; string recv_device ; TF_RETURN_IF_ERROR ( GetNodeAttr ( n -> attrs ( ) , \"send_device\" , & send_device ) ) ; TF_RETURN_IF_ERROR ( GetNodeAttr ( n -> attrs ( ) , \"recv_device\" , & recv_device ) ) ; if ( send_device != recv_device ) { requires_control_flow_ = true ; } } const int id = n -> id ( ) ; const string & frame_name = cf_info . frame_names [ id ] ; FrameInfo * frame_info = EnsureFrameInfo ( frame_name ) ; NodeItem * item = gview_ . node ( id ) ; item -> node_id = id ; item -> input_start = frame_info -> total_inputs ; frame_info -> total_inputs += n -> num_inputs ( ) ; Status s = params_ . create_kernel ( n -> properties ( ) , & item -> kernel ) ; <S2SV_StartBug> if ( ! s . ok ( ) ) { <S2SV_EndBug> item -> kernel = nullptr ; s = AttachDef ( s , * n ) ; return s ; } CHECK ( item -> kernel ) ; item -> kernel_is_async = ( item -> kernel -> AsAsync ( ) != nullptr ) ; item -> is_merge = IsMerge ( n ) ; item -> is_any_consumer_merge_or_control_trigger = false ; for ( const Node * consumer : n -> out_nodes ( ) ) { if ( IsMerge ( consumer ) || IsControlTrigger ( consumer ) ) { item -> is_any_consumer_merge_or_control_trigger = true ; break ; } } const Tensor * const_tensor = item -> kernel -> const_tensor ( ) ; if ( const_tensor ) { const_tensors_ . emplace_back ( * const_tensor ) ; } item -> const_tensor = const_tensor ; item -> is_noop = ( item -> kernel -> type_string_view ( ) == \"NoOp\" ) ; item -> is_enter = IsEnter ( n ) ; if ( item -> is_enter ) { bool is_constant_enter ; TF_RETURN_IF_ERROR ( GetNodeAttr ( n -> attrs ( ) , \"is_constant\" , & is_constant_enter ) ) ; item -> is_constant_enter = is_constant_enter ; string frame_name ; TF_RETURN_IF_ERROR ( GetNodeAttr ( n -> attrs ( ) , \"frame_name\" , & frame_name ) ) ; FrameInfo * frame_info = frame_info_ [ frame_name ] . get ( ) ; int parallel_iterations ; TF_RETURN_IF_ERROR ( GetNodeAttr ( n -> attrs ( ) , \"parallel_iterations\" , & parallel_iterations ) ) ; if ( frame_info -> parallel_iterations == - 1 ) { frame_info -> parallel_iterations = parallel_iterations ; } else if ( frame_info -> parallel_iterations != parallel_iterations ) { LOG ( WARNING ) << \"Loop<S2SV_blank>frame<S2SV_blank>\\\\\"\" << frame_name << \"\\\\\"<S2SV_blank>had<S2SV_blank>two<S2SV_blank>different<S2SV_blank>values<S2SV_blank>for<S2SV_blank>parallel_iterations:<S2SV_blank>\" << frame_info -> parallel_iterations << \"<S2SV_blank>vs.<S2SV_blank>\" << parallel_iterations << \".\" ; } if ( enter_frame_info_ . size ( ) <= id ) { enter_frame_info_ . resize ( id + 1 ) ; } enter_frame_info_ [ id ] = frame_info ; } else { item -> is_constant_enter = false ; } item -> is_exit = IsExit ( n ) ; item -> is_control_trigger = IsControlTrigger ( n ) ; item -> is_source = IsSource ( n ) ; item -> is_enter_exit_or_next_iter = ( IsEnter ( n ) || IsExit ( n ) || IsNextIteration ( n ) ) ; item -> is_transfer_node = IsTransferNode ( n ) ; item -> is_initialization_op = IsInitializationOp ( n ) ; item -> is_recv_or_switch = IsRecv ( n ) || IsSwitch ( n ) ; item -> is_next_iteration = IsNextIteration ( n ) ; item -> is_distributed_communication = IsDistributedCommunication ( n ) ; size_t max_pending , max_dead ; GetMaxPendingCounts ( n , & max_pending , & max_dead ) ; pending_ids_ [ id ] = frame_info -> pending_counts_layout . CreateHandle ( max_pending , max_dead ) ; if ( n -> in_edges ( ) . empty ( ) ) { root_nodes_ . push_back ( item ) ; } frame_info -> nodes -> push_back ( item ) ; if ( item -> is_enter ) { string enter_name ; TF_RETURN_IF_ERROR ( GetNodeAttr ( n -> attrs ( ) , \"frame_name\" , & enter_name ) ) ; EnsureFrameInfo ( enter_name ) -> input_count ++ ; } std : : unique_ptr < bool [ ] > outputs_required ( new bool [ n -> num_outputs ( ) ] ) ; std : : fill ( & outputs_required [ 0 ] , & outputs_required [ n -> num_outputs ( ) ] , false ) ; int32_t unused_outputs = n -> num_outputs ( ) ; for ( const Edge * e : n -> out_edges ( ) ) { if ( IsSink ( e -> dst ( ) ) ) continue ; if ( e -> src_output ( ) >= 0 ) { if ( ! outputs_required [ e -> src_output ( ) ] ) { -- unused_outputs ; outputs_required [ e -> src_output ( ) ] = true ; } } } if ( unused_outputs > 0 ) { for ( int i = 0 ; i < n -> num_outputs ( ) ; ++ i ) { if ( ! outputs_required [ i ] ) { metrics : : RecordUnusedOutput ( n -> type_string ( ) ) ; } } item -> outputs_required = std : : move ( outputs_required ) ; } } for ( const Node * n : graph . nodes ( ) ) { if ( IsSink ( n ) ) continue ; const int id = n -> id ( ) ; NodeItem * item = gview_ . node ( id ) ; for ( EdgeInfo & e : item -> mutable_output_edges ( ) ) { const int dst_id = e . dst_id ; NodeItem * dst_item = gview_ . node ( dst_id ) ; e . input_slot += dst_item -> input_start ; } } InitializePending ( & graph , cf_info ) ; return gview_ . SetAllocAttrs ( & graph , params_ . device ) ; }", "target": "<S2SV_ModStart> ) ) { params_ . delete_kernel ( item -> kernel ) ;"}
{"source": "CWE-476 Status GetInitOp ( const string & export_dir , const MetaGraphDef & meta_graph_def , string * init_op_name ) { const auto & sig_def_map = meta_graph_def . signature_def ( ) ; const auto & init_op_sig_it = meta_graph_def . signature_def ( ) . find ( kSavedModelInitOpSignatureKey ) ; if ( init_op_sig_it != sig_def_map . end ( ) ) { <S2SV_StartBug> * init_op_name = init_op_sig_it -> second . outputs ( ) <S2SV_EndBug> . find ( kSavedModelInitOpSignatureKey ) -> second . name ( ) ; return Status : : OK ( ) ; } const auto & collection_def_map = meta_graph_def . collection_def ( ) ; string init_op_collection_key ; if ( collection_def_map . find ( kSavedModelMainOpKey ) != collection_def_map . end ( ) ) { init_op_collection_key = kSavedModelMainOpKey ; } else { init_op_collection_key = kSavedModelLegacyInitOpKey ; } const auto init_op_it = collection_def_map . find ( init_op_collection_key ) ; if ( init_op_it != collection_def_map . end ( ) ) { if ( init_op_it -> second . node_list ( ) . value_size ( ) != 1 ) { return errors : : FailedPrecondition ( strings : : StrCat ( \"Expected<S2SV_blank>exactly<S2SV_blank>one<S2SV_blank>main<S2SV_blank>op<S2SV_blank>in<S2SV_blank>:<S2SV_blank>\" , export_dir ) ) ; } * init_op_name = init_op_it -> second . node_list ( ) . value ( 0 ) ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ) ) { const auto & sig_def_outputs = init_op_sig_it -> second . outputs ( ) ; const auto & sig_def_outputs_it = sig_def_outputs . find ( kSavedModelInitOpSignatureKey ) ; if ( sig_def_outputs_it == sig_def_outputs . end ( ) ) { return errors : : FailedPrecondition ( \"Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>output<S2SV_blank>\" , kSavedModelInitOpSignatureKey ) ; } <S2SV_ModStart> * init_op_name = sig_def_outputs_it <S2SV_ModEnd> -> second ."}
{"source": "CWE-617 Status ConstantFolding : : IsSimplifiableReshape ( const NodeDef & node , const GraphProperties & properties ) const { if ( ! IsReshape ( node ) ) { return errors : : Internal ( \"Node<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Reshape<S2SV_blank>node\" ) ; } if ( 2 > node . input_size ( ) ) { return errors : : Internal ( \"Node<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>most<S2SV_blank>2<S2SV_blank>inputs<S2SV_blank>but<S2SV_blank>has<S2SV_blank>\" , node . input_size ( ) ) ; } const NodeDef * new_shape = node_map_ -> GetNode ( node . input ( 1 ) ) ; if ( ! IsReallyConstant ( * new_shape ) ) { return errors : : Internal ( \"Node<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>has<S2SV_blank>shape<S2SV_blank>\" , new_shape -> DebugString ( ) , \"<S2SV_blank>which<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>constant\" ) ; } TensorVector outputs ; auto outputs_cleanup = gtl : : MakeCleanup ( [ & outputs ] { for ( const auto & output : outputs ) { delete output . tensor ; } } ) ; Status s = EvaluateNode ( * new_shape , TensorVector ( ) , & outputs ) ; if ( ! s . ok ( ) ) { return errors : : Internal ( \"Could<S2SV_blank>not<S2SV_blank>evaluate<S2SV_blank>node<S2SV_blank>\" , node . name ( ) ) ; } if ( outputs . size ( ) != 1 ) { return errors : : Internal ( \"Node<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>must<S2SV_blank>have<S2SV_blank>exactly<S2SV_blank>1<S2SV_blank>output<S2SV_blank>but<S2SV_blank>has<S2SV_blank>\" , outputs . size ( ) ) ; } const std : : vector < OpInfo : : TensorProperties > & props = properties . GetInputProperties ( node . name ( ) ) ; if ( props . empty ( ) ) { return errors : : Internal ( \"Node<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>has<S2SV_blank>no<S2SV_blank>properties\" ) ; } const OpInfo : : TensorProperties & prop = props [ 0 ] ; if ( prop . dtype ( ) == DT_INVALID ) { return errors : : Internal ( \"Node<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>has<S2SV_blank>property<S2SV_blank>\" , prop . DebugString ( ) , \"<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>dtype\" ) ; } const PartialTensorShape shape ( prop . shape ( ) ) ; if ( ! shape . IsFullyDefined ( ) ) { return errors : : Internal ( \"Node<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>has<S2SV_blank>property<S2SV_blank>\" , prop . DebugString ( ) , \"<S2SV_blank>with<S2SV_blank>shape<S2SV_blank>\" , shape . DebugString ( ) , \"<S2SV_blank>which<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>defined\" ) ; } PartialTensorShape new_dims ; if ( outputs [ 0 ] -> dtype ( ) == DT_INT32 ) { std : : vector < int32 > shp ; for ( int i = 0 ; i < outputs [ 0 ] -> NumElements ( ) ; ++ i ) { int32_t dim = outputs [ 0 ] -> flat < int32 > ( ) ( i ) ; shp . push_back ( dim ) ; } <S2SV_StartBug> TF_CHECK_OK ( TensorShapeUtils : : MakeShape ( shp , & new_dims ) ) ; <S2SV_EndBug> } else { std : : vector < int64_t > shp ; for ( int i = 0 ; i < outputs [ 0 ] -> NumElements ( ) ; ++ i ) { int64_t dim = outputs [ 0 ] -> flat < int64_t > ( ) ( i ) ; shp . push_back ( dim ) ; } <S2SV_StartBug> TF_CHECK_OK ( TensorShapeUtils : : MakeShape ( shp , & new_dims ) ) ; <S2SV_EndBug> } if ( ! shape . IsCompatibleWith ( new_dims ) ) { return errors : : Internal ( \"Expected<S2SV_blank>shape<S2SV_blank>\" , shape . DebugString ( ) , \"to<S2SV_blank>be<S2SV_blank>compatible<S2SV_blank>with<S2SV_blank>\" , new_dims . DebugString ( ) ) ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ) ; } s = <S2SV_ModEnd> TensorShapeUtils : : <S2SV_ModStart> & new_dims ) ; if ( ! s . ok ( ) ) return s <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ; } s = <S2SV_ModEnd> TensorShapeUtils : : <S2SV_ModStart> & new_dims ) ; if ( ! s . ok ( ) ) return s <S2SV_ModEnd> ; } if"}
{"source": "CWE-476 u32 GetHintFormat ( GF_TrackBox * trak ) { GF_HintMediaHeaderBox * hmhd = ( GF_HintMediaHeaderBox * ) trak -> Media -> information -> InfoHeader ; <S2SV_StartBug> if ( hmhd -> type != GF_ISOM_BOX_TYPE_HMHD ) <S2SV_EndBug> return 0 ; if ( ! hmhd || ! hmhd -> subType ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes , 0 ) ; if ( ! hmhd ) return a ? a -> type : 0 ; if ( a ) hmhd -> subType = a -> type ; return hmhd -> subType ; } return hmhd -> subType ; }", "target": "<S2SV_ModStart> ; if ( ! hmhd || ( <S2SV_ModStart> type != GF_ISOM_BOX_TYPE_HMHD )"}
{"source": "CWE-617 Status ConstantFolding : : EvaluateOneFoldable ( const NodeDef & node , std : : vector < NodeDef > * outputs , bool * result_too_large ) { TensorVector inputs ; TensorVector output_tensors ; auto inputs_cleanup = gtl : : MakeCleanup ( [ & inputs , & output_tensors ] { for ( const auto & input : inputs ) { delete input . tensor ; } for ( const auto & output : output_tensors ) { if ( output . tensor ) { delete output . tensor ; } } } ) ; size_t total_inputs_size = 0 ; for ( const auto & input : node . input ( ) ) { const TensorId input_tensor = ParseTensorName ( input ) ; if ( input_tensor . index ( ) < 0 ) { break ; } const NodeDef * input_node = node_map_ -> GetNode ( input ) ; if ( ! IsReallyConstant ( * input_node ) ) { return Status ( error : : INVALID_ARGUMENT , strings : : StrCat ( \"Can\\'t<S2SV_blank>fold<S2SV_blank>\" , node . name ( ) , \",<S2SV_blank>its<S2SV_blank>\" , input , \"<S2SV_blank>isn\\'t<S2SV_blank>constant\" ) ) ; } TF_RETURN_IF_ERROR ( CheckAttrExists ( * input_node , \"value\" ) ) ; const TensorProto & raw_val = input_node -> attr ( ) . at ( \"value\" ) . tensor ( ) ; if ( raw_val . dtype ( ) == DT_INVALID ) { return Status ( error : : INVALID_ARGUMENT , strings : : StrCat ( \"A<S2SV_blank>tensor<S2SV_blank>in<S2SV_blank>the<S2SV_blank>input<S2SV_blank>node,<S2SV_blank>with<S2SV_blank>TensorId<S2SV_blank>of<S2SV_blank>\" , input_tensor . ToString ( ) , \"<S2SV_blank>has<S2SV_blank>a<S2SV_blank>dtype<S2SV_blank>of<S2SV_blank>DT_INVALID.\" ) ) ; } <S2SV_StartBug> Tensor * value = new Tensor ( raw_val . dtype ( ) , raw_val . tensor_shape ( ) ) ; <S2SV_EndBug> if ( ! value -> FromProto ( raw_val ) ) { delete ( value ) ; return errors : : InvalidArgument ( \"Unable<S2SV_blank>to<S2SV_blank>make<S2SV_blank>Tensor<S2SV_blank>from<S2SV_blank>proto<S2SV_blank>for<S2SV_blank>\" , node . name ( ) , \"<S2SV_blank>with<S2SV_blank>shape<S2SV_blank>\" , raw_val . tensor_shape ( ) . DebugString ( ) ) ; } inputs . emplace_back ( value ) ; total_inputs_size += value -> TotalBytes ( ) ; } TF_RETURN_IF_ERROR ( EvaluateNode ( node , inputs , & output_tensors ) ) ; if ( output_tensors . empty ( ) ) { return Status ( error : : INVALID_ARGUMENT , \"Expected<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>output.\" ) ; } outputs -> resize ( output_tensors . size ( ) ) ; for ( size_t i = 0 ; i < output_tensors . size ( ) ; i ++ ) { string node_name = OptimizedNodeName ( node , \"-folded\" ) ; if ( output_tensors . size ( ) > 1 ) { node_name = strings : : StrCat ( node_name , \"-\" , i ) ; } if ( output_tensors [ i ] . tensor ) { Status s = CreateNodeDef ( node_name , output_tensors [ i ] , & outputs -> at ( i ) , total_inputs_size ) ; if ( ! s . ok ( ) ) { * result_too_large = true ; return s ; } } else { outputs -> at ( i ) = NodeDef ( ) ; } } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ) ; } if ( IsRefType ( raw_val . dtype ( ) ) ) { return errors : : InvalidArgument ( \"Not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>construct<S2SV_blank>a<S2SV_blank>tensor<S2SV_blank>with<S2SV_blank>reference<S2SV_blank>dtype,<S2SV_blank>got<S2SV_blank>\" , DataTypeString ( raw_val . dtype ( ) ) ) ; }"}
{"source": "CWE-287 int callback_glewlwyd_user_auth ( const struct _u_request * request , struct _u_response * response , void * user_data ) { struct config_elements * config = ( struct config_elements * ) user_data ; json_t * j_param = ulfius_get_json_body_request ( request , NULL ) , * j_result = NULL ; const char * ip_source = get_ip_source ( request ) ; char * issued_for = get_client_hostname ( request ) ; char * session_uid , expires [ 129 ] ; time_t now ; struct tm ts ; time ( & now ) ; now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE ; gmtime_r ( & now , & ts ) ; strftime ( expires , 128 , \"%a,<S2SV_blank>%d<S2SV_blank>%b<S2SV_blank>%Y<S2SV_blank>%T<S2SV_blank>%Z\" , & ts ) ; if ( j_param != NULL ) { if ( json_string_length ( json_object_get ( j_param , \"username\" ) ) ) { if ( json_object_get ( j_param , \"scheme_type\" ) == NULL || 0 == o_strcmp ( json_string_value ( json_object_get ( j_param , \"scheme_type\" ) ) , \"password\" ) ) { if ( json_string_length ( json_object_get ( j_param , \"password\" ) ) ) { j_result = auth_check_user_credentials ( config , json_string_value ( json_object_get ( j_param , \"username\" ) ) , json_string_value ( json_object_get ( j_param , \"password\" ) ) ) ; if ( check_result_value ( j_result , G_OK ) ) { if ( ( session_uid = get_session_id ( config , request ) ) == NULL ) { session_uid = generate_session_id ( ) ; } if ( user_session_update ( config , session_uid , u_map_get_case ( request -> map_header , \"user-agent\" ) , issued_for , json_string_value ( json_object_get ( j_param , \"username\" ) ) , NULL , 1 ) != G_OK ) { y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>user_session_update<S2SV_blank>(1)\" ) ; response -> status = 500 ; } else { ulfius_add_cookie_to_response ( response , config -> session_key , session_uid , expires , 0 , config -> cookie_domain , \"/\" , config -> cookie_secure , 0 ) ; y_log_message ( Y_LOG_LEVEL_INFO , \"Event<S2SV_blank>-<S2SV_blank>User<S2SV_blank>\\'%s\\'<S2SV_blank>authenticated<S2SV_blank>with<S2SV_blank>password\" , json_string_value ( json_object_get ( j_param , \"username\" ) ) ) ; } o_free ( session_uid ) ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_VALID , 1 , NULL ) ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_VALID_SCHEME , 1 , \"scheme_type\" , \"password\" , NULL ) ; } else { if ( check_result_value ( j_result , G_ERROR_UNAUTHORIZED ) ) { y_log_message ( Y_LOG_LEVEL_WARNING , \"Security<S2SV_blank>-<S2SV_blank>Authorization<S2SV_blank>invalid<S2SV_blank>for<S2SV_blank>username<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>IP<S2SV_blank>Address<S2SV_blank>%s\" , json_string_value ( json_object_get ( j_param , \"username\" ) ) , ip_source ) ; } <S2SV_StartBug> if ( ( session_uid = get_session_id ( config , request ) ) != NULL && user_session_update ( config , session_uid , u_map_get_case ( request -> map_header , \"user-agent\" ) , issued_for , json_string_value ( json_object_get ( j_param , \"username\" ) ) , NULL , 1 ) != G_OK ) { <S2SV_EndBug> y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>user_session_update<S2SV_blank>(2)\" ) ; } o_free ( session_uid ) ; response -> status = 401 ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_INVALID , 1 , NULL ) ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_INVALID_SCHEME , 1 , \"scheme_type\" , \"password\" , NULL ) ; } json_decref ( j_result ) ; } else if ( json_object_get ( j_param , \"password\" ) != NULL && ! json_is_string ( json_object_get ( j_param , \"password\" ) ) ) { ulfius_set_string_body_response ( response , 400 , \"password<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>string\" ) ; } else { session_uid = get_session_id ( config , request ) ; j_result = get_users_for_session ( config , session_uid ) ; if ( check_result_value ( j_result , G_OK ) ) { if ( user_session_update ( config , u_map_get ( request -> map_cookie , config -> session_key ) , u_map_get_case ( request -> map_header , \"user-agent\" ) , issued_for , json_string_value ( json_object_get ( j_param , \"username\" ) ) , NULL , 0 ) != G_OK ) { y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>user_session_update<S2SV_blank>(3)\" ) ; response -> status = 500 ; } else { ulfius_add_cookie_to_response ( response , config -> session_key , session_uid , expires , 0 , config -> cookie_domain , \"/\" , config -> cookie_secure , 0 ) ; } } else if ( check_result_value ( j_result , G_ERROR_NOT_FOUND ) ) { response -> status = 401 ; } else { y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>get_users_for_session\" ) ; response -> status = 500 ; } o_free ( session_uid ) ; json_decref ( j_result ) ; } } else { if ( json_string_length ( json_object_get ( j_param , \"scheme_type\" ) ) && json_string_length ( json_object_get ( j_param , \"scheme_name\" ) ) && json_is_object ( json_object_get ( j_param , \"value\" ) ) ) { j_result = auth_check_user_scheme ( config , json_string_value ( json_object_get ( j_param , \"scheme_type\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) , json_string_value ( json_object_get ( j_param , \"username\" ) ) , json_object_get ( j_param , \"value\" ) , request ) ; if ( check_result_value ( j_result , G_ERROR_PARAM ) ) { ulfius_set_string_body_response ( response , 400 , \"bad<S2SV_blank>scheme<S2SV_blank>response\" ) ; } else if ( check_result_value ( j_result , G_ERROR_UNAUTHORIZED ) ) { y_log_message ( Y_LOG_LEVEL_WARNING , \"Security<S2SV_blank>-<S2SV_blank>Authorization<S2SV_blank>invalid<S2SV_blank>for<S2SV_blank>username<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>IP<S2SV_blank>Address<S2SV_blank>%s\" , json_string_value ( json_object_get ( j_param , \"username\" ) ) , ip_source ) ; response -> status = 401 ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_INVALID , 1 , NULL ) ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_INVALID_SCHEME , 1 , \"scheme_type\" , json_string_value ( json_object_get ( j_param , \"scheme_type\" ) ) , \"scheme_name\" , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) , NULL ) ; } else if ( check_result_value ( j_result , G_ERROR_NOT_FOUND ) ) { response -> status = 404 ; } else if ( check_result_value ( j_result , G_OK ) ) { if ( ( session_uid = get_session_id ( config , request ) ) == NULL ) { session_uid = generate_session_id ( ) ; } if ( user_session_update ( config , session_uid , u_map_get_case ( request -> map_header , \"user-agent\" ) , issued_for , json_string_value ( json_object_get ( j_param , \"username\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) , 1 ) != G_OK ) { y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>user_session_update<S2SV_blank>(4)\" ) ; response -> status = 500 ; } else { ulfius_add_cookie_to_response ( response , config -> session_key , session_uid , expires , 0 , config -> cookie_domain , \"/\" , config -> cookie_secure , 0 ) ; y_log_message ( Y_LOG_LEVEL_INFO , \"Event<S2SV_blank>-<S2SV_blank>User<S2SV_blank>\\'%s\\'<S2SV_blank>authenticated<S2SV_blank>with<S2SV_blank>scheme<S2SV_blank>\\'%s/%s\\'\" , json_string_value ( json_object_get ( j_param , \"username\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_type\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) ) ; } o_free ( session_uid ) ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_VALID , 1 , NULL ) ; glewlwyd_metrics_increment_counter_va ( config , GLWD_METRICS_AUTH_USER_VALID_SCHEME , 1 , \"scheme_type\" , json_string_value ( json_object_get ( j_param , \"scheme_type\" ) ) , \"scheme_name\" , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) , NULL ) ; } else { y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>auth_check_user_scheme\" ) ; response -> status = 500 ; } json_decref ( j_result ) ; } else { ulfius_set_string_body_response ( response , 400 , \"scheme_type,<S2SV_blank>scheme_name<S2SV_blank>and<S2SV_blank>value<S2SV_blank>are<S2SV_blank>mandatory\" ) ; } } } else { if ( json_string_length ( json_object_get ( j_param , \"scheme_type\" ) ) && json_string_length ( json_object_get ( j_param , \"scheme_name\" ) ) && json_is_object ( json_object_get ( j_param , \"value\" ) ) ) { j_result = auth_check_identify_scheme ( config , json_string_value ( json_object_get ( j_param , \"scheme_type\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) , json_object_get ( j_param , \"value\" ) , request ) ; if ( check_result_value ( j_result , G_ERROR_PARAM ) ) { ulfius_set_string_body_response ( response , 400 , \"bad<S2SV_blank>scheme<S2SV_blank>response\" ) ; } else if ( check_result_value ( j_result , G_ERROR_UNAUTHORIZED ) ) { y_log_message ( Y_LOG_LEVEL_WARNING , \"Security<S2SV_blank>-<S2SV_blank>Authorization<S2SV_blank>invalid<S2SV_blank>for<S2SV_blank>username<S2SV_blank><UNKNOWN><S2SV_blank>at<S2SV_blank>IP<S2SV_blank>Address<S2SV_blank>%s\" , ip_source ) ; response -> status = 401 ; } else if ( check_result_value ( j_result , G_ERROR_NOT_FOUND ) ) { response -> status = 404 ; } else if ( check_result_value ( j_result , G_OK ) ) { if ( ( session_uid = get_session_id ( config , request ) ) == NULL ) { session_uid = generate_session_id ( ) ; } if ( user_session_update ( config , session_uid , u_map_get_case ( request -> map_header , \"user-agent\" ) , issued_for , json_string_value ( json_object_get ( j_result , \"username\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) , 1 ) != G_OK ) { y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>user_session_update<S2SV_blank>(4)\" ) ; response -> status = 500 ; } else { ulfius_add_cookie_to_response ( response , config -> session_key , session_uid , expires , 0 , config -> cookie_domain , \"/\" , config -> cookie_secure , 0 ) ; y_log_message ( Y_LOG_LEVEL_INFO , \"Event<S2SV_blank>-<S2SV_blank>User<S2SV_blank>\\'%s\\'<S2SV_blank>authenticated<S2SV_blank>with<S2SV_blank>scheme<S2SV_blank>\\'%s/%s\\'\" , json_string_value ( json_object_get ( j_result , \"username\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_type\" ) ) , json_string_value ( json_object_get ( j_param , \"scheme_name\" ) ) ) ; } o_free ( session_uid ) ; } else { y_log_message ( Y_LOG_LEVEL_ERROR , \"callback_glewlwyd_user_auth<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>auth_check_user_scheme\" ) ; response -> status = 500 ; } json_decref ( j_result ) ; } else { ulfius_set_string_body_response ( response , 400 , \"username<S2SV_blank>is<S2SV_blank>mandatory\" ) ; } } } else { ulfius_set_string_body_response ( response , 400 , \"Input<S2SV_blank>parameters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>JSON<S2SV_blank>format\" ) ; } json_decref ( j_param ) ; o_free ( issued_for ) ; return U_CALLBACK_CONTINUE ; }", "target": "<S2SV_ModStart> ) ; } <S2SV_ModEnd> response -> status"}
{"source": "CWE-190 void Compute ( OpKernelContext * context ) override { const Tensor * input_indices ; const Tensor * input_values ; const Tensor * input_shape ; SparseTensorsMap * map ; OP_REQUIRES_OK ( context , context -> input ( \"sparse_indices\" , & input_indices ) ) ; OP_REQUIRES_OK ( context , context -> input ( \"sparse_values\" , & input_values ) ) ; OP_REQUIRES_OK ( context , context -> input ( \"sparse_shape\" , & input_shape ) ) ; OP_REQUIRES_OK ( context , GetMap ( context , true , & map ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsMatrix ( input_indices -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_indices -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( input_values -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_values -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( input_shape -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_shape -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , input_values -> shape ( ) . dim_size ( 0 ) == input_indices -> shape ( ) . dim_size ( 0 ) , errors : : InvalidArgument ( \"Number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>must<S2SV_blank>match<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices.<S2SV_blank>\" , \"Got<S2SV_blank>\" , input_values -> shape ( ) . dim_size ( 0 ) , \"<S2SV_blank>values,<S2SV_blank>indices<S2SV_blank>shape:<S2SV_blank>\" , input_indices -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , input_shape -> shape ( ) . dim_size ( 0 ) == input_indices -> shape ( ) . dim_size ( 1 ) , errors : : InvalidArgument ( \"Number<S2SV_blank>of<S2SV_blank>dimensions<S2SV_blank>must<S2SV_blank>match<S2SV_blank>second<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices.<S2SV_blank>\" , \"Got<S2SV_blank>\" , input_shape -> shape ( ) . dim_size ( 0 ) , \"<S2SV_blank>dimensions,<S2SV_blank>indices<S2SV_blank>shape:<S2SV_blank>\" , input_indices -> shape ( ) . DebugString ( ) ) ) ; int rank = input_shape -> NumElements ( ) ; OP_REQUIRES ( context , rank > 1 , errors : : InvalidArgument ( \"Rank<S2SV_blank>of<S2SV_blank>input<S2SV_blank>SparseTensor<S2SV_blank>should<S2SV_blank>be<S2SV_blank>><S2SV_blank>1,<S2SV_blank>but<S2SV_blank>saw<S2SV_blank>rank:<S2SV_blank>\" , rank ) ) ; auto input_shape_vec = input_shape -> vec < int64_t > ( ) ; <S2SV_StartBug> int new_num_elements = 1 ; <S2SV_EndBug> bool overflow_ocurred = false ; for ( int i = 0 ; i < input_shape_vec . size ( ) ; i ++ ) { new_num_elements = MultiplyWithoutOverflow ( new_num_elements , input_shape_vec ( i ) ) ; if ( new_num_elements < 0 ) { overflow_ocurred = true ; break ; } } OP_REQUIRES ( context , ! overflow_ocurred , errors : : Internal ( \"Encountered<S2SV_blank>overflow<S2SV_blank>from<S2SV_blank>large<S2SV_blank>input<S2SV_blank>shape.\" ) ) ; TensorShape tensor_input_shape ( input_shape_vec ) ; gtl : : InlinedVector < int64_t , 8 > std_order ( rank ) ; std : : iota ( std_order . begin ( ) , std_order . end ( ) , 0 ) ; SparseTensor input_st ; OP_REQUIRES_OK ( context , SparseTensor : : Create ( * input_indices , * input_values , tensor_input_shape , std_order , & input_st ) ) ; const int64_t N = input_shape_vec ( 0 ) ; Tensor sparse_handles ( DT_INT64 , TensorShape ( { N } ) ) ; auto sparse_handles_t = sparse_handles . vec < int64_t > ( ) ; OP_REQUIRES_OK ( context , input_st . IndicesValid ( ) ) ; TensorShape output_shape ; OP_REQUIRES_OK ( context , TensorShapeUtils : : MakeShape ( input_shape_vec . data ( ) + 1 , input_shape -> NumElements ( ) - 1 , & output_shape ) ) ; std : : unordered_set < int64_t > visited ; sparse : : GroupIterable minibatch = input_st . group ( { 0 } ) ; for ( const auto & subset : minibatch ) { const int64_t b = subset . group ( ) [ 0 ] ; visited . insert ( b ) ; OP_REQUIRES ( context , b > - 1 && b < N , errors : : InvalidArgument ( \"Received<S2SV_blank>unexpected<S2SV_blank>column<S2SV_blank>0<S2SV_blank>value<S2SV_blank>in<S2SV_blank>input<S2SV_blank>SparseTensor:<S2SV_blank>\" , b , \"<S2SV_blank><<S2SV_blank>0<S2SV_blank>or<S2SV_blank>>=<S2SV_blank>N<S2SV_blank>(=<S2SV_blank>\" , N , \")\" ) ) ; const auto indices = subset . indices ( ) ; const auto values = subset . values < T > ( ) ; const int64_t num_entries = values . size ( ) ; Tensor output_indices = Tensor ( DT_INT64 , { num_entries , rank - 1 } ) ; Tensor output_values = Tensor ( DataTypeToEnum < T > : : value , { num_entries } ) ; auto output_indices_t = output_indices . matrix < int64_t > ( ) ; auto output_values_t = output_values . vec < T > ( ) ; for ( int i = 0 ; i < num_entries ; ++ i ) { for ( int d = 1 ; d < rank ; ++ d ) { output_indices_t ( i , d - 1 ) = indices ( i , d ) ; } output_values_t ( i ) = values ( i ) ; } SparseTensor st_i ; OP_REQUIRES_OK ( context , SparseTensor : : Create ( output_indices , output_values , output_shape , & st_i ) ) ; int64_t handle ; OP_REQUIRES_OK ( context , map -> AddSparseTensor ( context , st_i , & handle ) ) ; sparse_handles_t ( b ) = handle ; } if ( visited . size ( ) < N ) { Tensor empty_indices ( DT_INT64 , { 0 , rank - 1 } ) ; Tensor empty_values ( DataTypeToEnum < T > : : value , { 0 } ) ; SparseTensor empty_st ; OP_REQUIRES_OK ( context , SparseTensor : : Create ( empty_indices , empty_values , output_shape , & empty_st ) ) ; for ( int64_t b = 0 ; b < N ; ++ b ) { if ( visited . find ( b ) == visited . end ( ) ) { int64_t handle ; OP_REQUIRES_OK ( context , map -> AddSparseTensor ( context , empty_st , & handle ) ) ; sparse_handles_t ( b ) = handle ; } } } context -> set_output ( 0 , sparse_handles ) ; }", "target": "<S2SV_ModStart> ( ) ; TensorShape tensor_input_shape ; OP_REQUIRES_OK ( context , TensorShape : : BuildTensorShape ( input_shape_vec , & tensor_input_shape ) <S2SV_ModEnd> ) ; gtl"}
{"source": "CWE-909 nfs4_file_open ( struct inode * inode , struct file * filp ) { struct nfs_open_context * ctx ; struct dentry * dentry = file_dentry ( filp ) ; struct dentry * parent = NULL ; struct inode * dir ; unsigned openflags = filp -> f_flags ; struct iattr attr ; int err ; dprintk ( \"NFS:<S2SV_blank>open<S2SV_blank>file(%pd2)\\\\n\" , dentry ) ; err = nfs_check_flags ( openflags ) ; if ( err ) return err ; if ( ( openflags & O_ACCMODE ) == 3 ) <S2SV_StartBug> return nfs_open ( inode , filp ) ; <S2SV_EndBug> openflags &= ~ ( O_CREAT | O_EXCL ) ; parent = dget_parent ( dentry ) ; dir = d_inode ( parent ) ; ctx = alloc_nfs_open_context ( file_dentry ( filp ) , filp -> f_mode , filp ) ; err = PTR_ERR ( ctx ) ; if ( IS_ERR ( ctx ) ) goto out ; attr . ia_valid = ATTR_OPEN ; if ( openflags & O_TRUNC ) { attr . ia_valid |= ATTR_SIZE ; attr . ia_size = 0 ; filemap_write_and_wait ( inode -> i_mapping ) ; } inode = NFS_PROTO ( dir ) -> open_context ( dir , ctx , openflags , & attr , NULL ) ; if ( IS_ERR ( inode ) ) { err = PTR_ERR ( inode ) ; switch ( err ) { default : goto out_put_ctx ; case - ENOENT : case - ESTALE : case - EISDIR : case - ENOTDIR : case - ELOOP : goto out_drop ; } } if ( inode != d_inode ( dentry ) ) goto out_drop ; nfs_file_set_open_context ( filp , ctx ) ; nfs_fscache_open_file ( inode , filp ) ; err = 0 ; out_put_ctx : put_nfs_open_context ( ctx ) ; out : dput ( parent ) ; return err ; out_drop : d_drop ( dentry ) ; err = - EOPENSTALE ; goto out_put_ctx ; }", "target": "<S2SV_ModStart> == 3 ) openflags -- <S2SV_ModEnd> ; openflags &="}
{"source": "CWE-401 void DecodePngV2 ( OpKernelContext * context , StringPiece input ) { int channel_bits = ( data_type_ == DataType : : DT_UINT8 ) ? 8 : 16 ; png : : DecodeContext decode ; OP_REQUIRES ( context , png : : CommonInitDecode ( input , channels_ , channel_bits , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG.<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ) ; <S2SV_StartBug> const int width = static_cast < int > ( decode . width ) ; <S2SV_EndBug> const int height = static_cast < int > ( decode . height ) ; const int64_t total_size = static_cast < int64_t > ( width ) * static_cast < int64_t > ( height ) ; if ( width != static_cast < int64_t > ( decode . width ) || width <= 0 || width >= ( 1LL << 27 ) || height != static_cast < int64_t > ( decode . height ) || height <= 0 || height >= ( 1LL << 27 ) || total_size >= ( 1LL << 29 ) ) { OP_REQUIRES ( context , false , errors : : InvalidArgument ( \"PNG<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>int:<S2SV_blank>\" , decode . width , \"<S2SV_blank>by<S2SV_blank>\" , decode . height ) ) ; } Tensor * output = nullptr ; if ( op_type_ == \"DecodeGif\" ) { OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { 1 , height , width , decode . channels } ) , & output ) ) ; } else { OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { height , width , decode . channels } ) , & output ) ) ; } if ( op_type_ == \"DecodeBmp\" ) { OP_REQUIRES ( context , false , errors : : InvalidArgument ( \"Trying<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PNG<S2SV_blank>format<S2SV_blank>using<S2SV_blank>DecodeBmp<S2SV_blank>op.<S2SV_blank>Use<S2SV_blank>\" \"`decode_png`<S2SV_blank>or<S2SV_blank>`decode_image`<S2SV_blank>instead.\" ) ) ; } else if ( op_type_ == \"DecodeAndCropJpeg\" ) { OP_REQUIRES ( context , false , errors : : InvalidArgument ( \"DecodeAndCropJpeg<S2SV_blank>operation<S2SV_blank>can<S2SV_blank>run<S2SV_blank>on<S2SV_blank>JPEG<S2SV_blank>only,<S2SV_blank>but<S2SV_blank>\" \"detected<S2SV_blank>PNG.\" ) ) ; } if ( data_type_ == DataType : : DT_UINT8 ) { OP_REQUIRES ( context , png : : CommonFinishDecode ( reinterpret_cast < png_bytep > ( output -> flat < uint8 > ( ) . data ( ) ) , decode . channels * width * sizeof ( uint8 ) , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG<S2SV_blank>data,<S2SV_blank>size<S2SV_blank>\" , input . size ( ) ) ) ; } else if ( data_type_ == DataType : : DT_UINT16 ) { OP_REQUIRES ( context , png : : CommonFinishDecode ( reinterpret_cast < png_bytep > ( output -> flat < uint16 > ( ) . data ( ) ) , decode . channels * width * sizeof ( uint16 ) , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG<S2SV_blank>data,<S2SV_blank>size<S2SV_blank>\" , input . size ( ) ) ) ; } else if ( data_type_ == DataType : : DT_FLOAT ) { std : : unique_ptr < uint16 [ ] > buffer ( new uint16 [ height * width * decode . channels ] ) ; OP_REQUIRES ( context , png : : CommonFinishDecode ( reinterpret_cast < png_bytep > ( buffer . get ( ) ) , decode . channels * width * sizeof ( uint16 ) , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG<S2SV_blank>data,<S2SV_blank>size<S2SV_blank>\" , input . size ( ) ) ) ; const auto & device = context -> eigen_device < Eigen : : ThreadPoolDevice > ( ) ; TTypes < uint16 , 3 > : : UnalignedConstTensor buf ( buffer . get ( ) , height , width , decode . channels ) ; float scale = 1. / std : : numeric_limits < uint16 > : : max ( ) ; output -> tensor < float , 3 > ( ) . device ( device ) = buf . cast < float > ( ) * scale ; } }", "target": "<S2SV_ModStart> ) ) ; auto cleanup = gtl : : MakeCleanup ( [ & decode ] ( ) { std : : cerr << \"Cleanup<S2SV_blank>called...\\\\n\" ; png : : CommonFreeDecode ( & decode ) ; } ) ;"}
{"source": "CWE-125 void Node : : RunForwardTypeInference ( ) { VLOG ( 4 ) << \"Forward<S2SV_blank>type<S2SV_blank>inference:<S2SV_blank>\" << props_ -> node_def . DebugString ( ) ; if ( props_ -> fwd_type_fn == nullptr ) { return ; } std : : vector < Node * > input_nodes ( props_ -> input_types . size ( ) , nullptr ) ; std : : vector < int > input_idx ( props_ -> input_types . size ( ) , 0 ) ; for ( const auto & edge : in_edges_ ) { if ( edge -> IsControlEdge ( ) ) { continue ; } DCHECK ( edge -> dst_input ( ) < input_nodes . size ( ) ) << DebugString ( ) ; int i = edge -> dst_input ( ) ; input_nodes . at ( i ) = edge -> src ( ) ; input_idx . at ( i ) = edge -> src_output ( ) ; } for ( const auto * node : input_nodes ) { if ( node == nullptr ) { ClearTypeInfo ( ) ; return ; } } static FullTypeDef * no_type = new FullTypeDef ( ) ; std : : vector < std : : reference_wrapper < const FullTypeDef >> input_types ; for ( int i = 0 ; i < input_nodes . size ( ) ; i ++ ) { const auto * node = input_nodes [ i ] ; if ( node -> def ( ) . has_experimental_type ( ) ) { const auto & node_t = node -> def ( ) . experimental_type ( ) ; if ( node_t . type_id ( ) != TFT_UNSET ) { int ix = input_idx [ i ] ; <S2SV_StartBug> DCHECK ( ix < node_t . args_size ( ) ) <S2SV_EndBug> <S2SV_StartBug> << \"input<S2SV_blank>\" << i << \"<S2SV_blank>should<S2SV_blank>have<S2SV_blank>an<S2SV_blank>output<S2SV_blank>\" << ix <S2SV_EndBug> << \"<S2SV_blank>but<S2SV_blank>instead<S2SV_blank>only<S2SV_blank>has<S2SV_blank>\" << node_t . args_size ( ) <S2SV_StartBug> << \"<S2SV_blank>outputs:<S2SV_blank>\" << node_t . DebugString ( ) ; <S2SV_EndBug> input_types . emplace_back ( node_t . args ( ix ) ) ; } else { input_types . emplace_back ( * no_type ) ; } } else { ClearTypeInfo ( ) ; return ; } } const auto infer_type = props_ -> fwd_type_fn ( input_types ) ; const FullTypeDef infer_typedef = infer_type . ValueOrDie ( ) ; if ( infer_typedef . type_id ( ) != TFT_UNSET ) { MaybeCopyOnWrite ( ) ; * ( props_ -> node_def . mutable_experimental_type ( ) ) = infer_typedef ; } }", "target": "<S2SV_ModStart> i ] ; if ( ix >= <S2SV_ModEnd> node_t . args_size <S2SV_ModStart> ( ) ) { LOG ( WARNING ) << name ( ) << \"<S2SV_blank>has<S2SV_blank>bad<S2SV_blank>type<S2SV_blank>information:<S2SV_blank>input<S2SV_blank>\" << i <S2SV_ModEnd> << \"<S2SV_blank>should<S2SV_blank>have<S2SV_blank>an<S2SV_blank>output<S2SV_blank>\" << <S2SV_ModStart> DebugString ( ) << \"\\\\nThis<S2SV_blank>indicates<S2SV_blank>either<S2SV_blank>\" \"a<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>op<S2SV_blank>registration<S2SV_blank>or<S2SV_blank>a<S2SV_blank>corrupted<S2SV_blank>graph.\" ; ClearTypeInfo ( ) ; return ; } <S2SV_ModEnd> input_types . emplace_back"}
{"source": "CWE-476 mrb_ary_shift_m ( mrb_state * mrb , mrb_value self ) { <S2SV_StartBug> struct RArray * a = mrb_ary_ptr ( self ) ; <S2SV_EndBug> mrb_int len = ARY_LEN ( a ) ; <S2SV_StartBug> mrb_int n ; <S2SV_EndBug> mrb_value val ; <S2SV_StartBug> if ( mrb_get_args ( mrb , \"|i\" , & n ) == 0 ) { <S2SV_EndBug> return mrb_ary_shift ( mrb , self ) ; } ; ary_modify_check ( mrb , a ) ; if ( len == 0 || n == 0 ) return mrb_ary_new ( mrb ) ; if ( n < 0 ) mrb_raise ( mrb , E_ARGUMENT_ERROR , \"negative<S2SV_blank>array<S2SV_blank>shift\" ) ; if ( n > len ) n = len ; val = mrb_ary_new_from_values ( mrb , n , ARY_PTR ( a ) ) ; if ( ARY_SHARED_P ( a ) ) { L_SHIFT : a -> as . heap . ptr += n ; a -> as . heap . len -= n ; return val ; } if ( len > ARY_SHIFT_SHARED_MIN ) { ary_make_shared ( mrb , a ) ; goto L_SHIFT ; } else if ( len == n ) { ARY_SET_LEN ( a , 0 ) ; } else { mrb_value * ptr = ARY_PTR ( a ) ; mrb_int size = len - n ; while ( size -- ) { * ptr = * ( ptr + n ) ; ++ ptr ; } ARY_SET_LEN ( a , len - n ) ; } return val ; }", "target": "<S2SV_ModStart> self ) { mrb_int n ; if ( mrb_get_args ( mrb , \"|i\" , & n ) == 0 ) { return mrb_ary_shift ( mrb , self ) ; } <S2SV_ModStart> a ) ; <S2SV_ModEnd> mrb_value val ; <S2SV_ModStart> mrb_value val ; <S2SV_ModEnd> ary_modify_check ( mrb"}
{"source": "CWE-354 void operator ( ) ( OpKernelContext * ctx , const Tensor & input , const Tensor & filter , int row_stride , int col_stride , int row_dilation , int col_dilation , const Padding & padding , const std : : vector < int64_t > & explicit_paddings , Tensor * output , TensorFormat data_format ) { DCHECK ( data_format == FORMAT_NHWC ) << \"Grouped<S2SV_blank>conv<S2SV_blank>implementation<S2SV_blank>only<S2SV_blank>\" \"supports<S2SV_blank>NHWC<S2SV_blank>tensor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>now.\" ; const int64_t in_depth = input . dim_size ( 3 ) ; const int64_t patch_depth = filter . dim_size ( 2 ) ; const int64_t num_groups = in_depth / patch_depth ; std : : array < int64_t , 5 > shuffle ( { 3 , 0 , 1 , 2 , 4 } ) ; auto pre_shuffle = [ & ] ( const Tensor & tensor ) -> std : : array < int64 , 5 > { return { tensor . dim_size ( 0 ) , tensor . dim_size ( 1 ) , tensor . dim_size ( 2 ) , num_groups , tensor . dim_size ( 3 ) / num_groups } ; } ; auto post_shuffle = [ & ] ( const Tensor & tensor ) -> std : : array < int64 , 5 > { return { num_groups , tensor . dim_size ( 0 ) , tensor . dim_size ( 1 ) , tensor . dim_size ( 2 ) , tensor . dim_size ( 3 ) / num_groups } ; } ; auto & device = ctx -> eigen_device < CPUDevice > ( ) ; absl : : BlockingCounter shuffles_completed ( 2 ) ; auto on_shuffled = [ & ] ( ) { shuffles_completed . DecrementCount ( ) ; } ; <S2SV_StartBug> Tensor input_shuffled ( input . dtype ( ) , TensorShape ( post_shuffle ( input ) ) ) ; <S2SV_EndBug> input_shuffled . tensor < T , 5 > ( ) . device ( device , on_shuffled ) = input . shaped < T , 5 > ( pre_shuffle ( input ) ) . shuffle ( shuffle ) ; <S2SV_StartBug> Tensor filter_shuffled ( filter . dtype ( ) , TensorShape ( post_shuffle ( filter ) ) ) ; <S2SV_EndBug> filter_shuffled . tensor < T , 5 > ( ) . device ( device , on_shuffled ) = filter . shaped < T , 5 > ( pre_shuffle ( filter ) ) . shuffle ( shuffle ) ; shuffles_completed . Wait ( ) ; <S2SV_StartBug> Tensor output_shuffled ( output -> dtype ( ) , TensorShape ( post_shuffle ( * output ) ) ) ; <S2SV_EndBug> for ( int64_t i = 0 ; i < num_groups ; ++ i ) { auto input_slice = input_shuffled . tensor < T , 5 > ( ) . template chip < 0 > ( i ) ; auto filter_slice = filter_shuffled . tensor < T , 5 > ( ) . template chip < 0 > ( i ) ; auto output_slice = output_shuffled . tensor < T , 5 > ( ) . template chip < 0 > ( i ) ; if ( padding == EXPLICIT ) { functor : : SpatialConvolution < CPUDevice , T > ( ) ( ctx -> eigen_device < CPUDevice > ( ) , output_slice , input_slice , filter_slice , row_stride , col_stride , row_dilation , col_dilation , static_cast < int > ( explicit_paddings [ 2 ] ) , static_cast < int > ( explicit_paddings [ 3 ] ) , static_cast < int > ( explicit_paddings [ 4 ] ) , static_cast < int > ( explicit_paddings [ 5 ] ) ) ; } else { functor : : SpatialConvolution < CPUDevice , T > ( ) ( ctx -> eigen_device < CPUDevice > ( ) , output_slice , input_slice , filter_slice , row_stride , col_stride , row_dilation , col_dilation , BrainPadding2EigenPadding ( padding ) ) ; } } std : : array < int64_t , 5 > rev_shuffle ( { 1 , 2 , 3 , 0 , 4 } ) ; output -> shaped < T , 5 > ( pre_shuffle ( * output ) ) . device ( device ) = output_shuffled . tensor < T , 5 > ( ) . shuffle ( rev_shuffle ) ; }", "target": "<S2SV_ModStart> ; Tensor input_shuffled ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp <S2SV_ModStart> ( input ) ) , & input_shuffled <S2SV_ModStart> ; Tensor filter_shuffled ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp <S2SV_ModStart> ( filter ) ) , & filter_shuffled <S2SV_ModStart> ; Tensor output_shuffled ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp <S2SV_ModStart> * output ) ) , & output_shuffled"}
{"source": "CWE-476 Status BuildXlaCompilationCache ( DeviceBase * device , FunctionLibraryRuntime * flr , const XlaPlatformInfo & platform_info , XlaCompilationCache * * cache ) { if ( platform_info . xla_device_metadata ( ) ) { * cache = new XlaCompilationCache ( platform_info . xla_device_metadata ( ) -> client ( ) , platform_info . xla_device_metadata ( ) -> jit_device_type ( ) ) ; return Status : : OK ( ) ; } auto platform = se : : MultiPlatformManager : : PlatformWithId ( platform_info . platform_id ( ) ) ; if ( ! platform . ok ( ) ) { return platform . status ( ) ; } StatusOr < xla : : Compiler * > compiler_for_platform = xla : : Compiler : : GetForPlatform ( platform . ValueOrDie ( ) ) ; if ( ! compiler_for_platform . ok ( ) ) { const Status & status = compiler_for_platform . status ( ) ; if ( status . code ( ) == error : : NOT_FOUND ) { return errors : : Unimplemented ( \"Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>compiler<S2SV_blank>for<S2SV_blank>platform<S2SV_blank>\" , platform . ValueOrDie ( ) -> Name ( ) , \":<S2SV_blank>\" , status . ToString ( ) ) ; } } xla : : LocalClientOptions client_options ; client_options . set_platform ( platform . ValueOrDie ( ) ) ; client_options . set_intra_op_parallelism_threads ( device -> tensorflow_cpu_worker_threads ( ) -> num_threads ) ; <S2SV_StartBug> <S2SV_EndBug> string allowed_gpus = flr -> config_proto ( ) -> gpu_options ( ) . visible_device_list ( ) ; TF_ASSIGN_OR_RETURN ( absl : : optional < std : : set < int >> gpu_ids , ParseVisibleDeviceList ( allowed_gpus ) ) ; client_options . set_allowed_devices ( gpu_ids ) ; <S2SV_StartBug> <S2SV_EndBug> auto client = xla : : ClientLibrary : : GetOrCreateLocalClient ( client_options ) ; if ( ! client . ok ( ) ) { return client . status ( ) ; } const XlaOpRegistry : : DeviceRegistration * registration ; if ( ! XlaOpRegistry : : GetCompilationDevice ( platform_info . device_type ( ) . type ( ) , & registration ) ) { return errors : : InvalidArgument ( \"No<S2SV_blank>JIT<S2SV_blank>device<S2SV_blank>registered<S2SV_blank>for<S2SV_blank>\" , platform_info . device_type ( ) . type ( ) ) ; } * cache = new XlaCompilationCache ( client . ValueOrDie ( ) , DeviceType ( registration -> compilation_device_name ) ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> num_threads ) ; if ( flr -> config_proto ( ) ) { <S2SV_ModStart> gpu_ids ) ; }"}
{"source": "CWE-787 void Compute ( OpKernelContext * context ) override { <S2SV_StartBug> const Tensor & indices = context -> input ( 0 ) ; <S2SV_EndBug> const Tensor & values = context -> input ( 1 ) ; <S2SV_StartBug> const Tensor & shape = context -> input ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> const Tensor & weights = context -> input ( 3 ) ; <S2SV_EndBug> bool use_weights = weights . NumElements ( ) > 0 ; <S2SV_StartBug> OP_REQUIRES ( context , TensorShapeUtils : : IsMatrix ( indices . shape ( ) ) , <S2SV_EndBug> errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>2-dimensional<S2SV_blank>tensor.<S2SV_blank>Got:<S2SV_blank>\" , indices . shape ( ) . DebugString ( ) ) ) ; if ( use_weights ) { OP_REQUIRES ( context , weights . shape ( ) == values . shape ( ) , errors : : InvalidArgument ( \"Weights<S2SV_blank>and<S2SV_blank>values<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>shape.<S2SV_blank>Weight<S2SV_blank>shape:<S2SV_blank>\" , weights . shape ( ) . DebugString ( ) , \";<S2SV_blank>values<S2SV_blank>shape:<S2SV_blank>\" , values . shape ( ) . DebugString ( ) ) ) ; } <S2SV_StartBug> OP_REQUIRES ( context , shape . NumElements ( ) != 0 , <S2SV_EndBug> errors : : InvalidArgument ( \"The<S2SV_blank>shape<S2SV_blank>argument<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>element.\" ) ) ; bool is_1d = shape . NumElements ( ) == 1 ; <S2SV_StartBug> auto shape_vector = shape . flat < int64_t > ( ) ; <S2SV_EndBug> <S2SV_StartBug> int num_batches = is_1d ? 1 : shape_vector ( 0 ) ; <S2SV_EndBug> int num_values = values . NumElements ( ) ; <S2SV_StartBug> for ( int b = 0 ; b < shape_vector . size ( ) ; b ++ ) { <S2SV_EndBug> OP_REQUIRES ( context , shape_vector ( b ) >= 0 , errors : : InvalidArgument ( <S2SV_StartBug> \"Elements<S2SV_blank>in<S2SV_blank>dense_shape<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>0.<S2SV_blank>Instead<S2SV_blank>got:\" , <S2SV_EndBug> shape . DebugString ( ) ) ) ; } <S2SV_StartBug> OP_REQUIRES ( context , num_values == indices . shape ( ) . dim_size ( 0 ) , <S2SV_EndBug> errors : : InvalidArgument ( <S2SV_StartBug> \"Number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>must<S2SV_blank>match<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices.\" , <S2SV_EndBug> \"Got<S2SV_blank>\" , num_values , \"<S2SV_blank>values,<S2SV_blank>indices<S2SV_blank>shape:<S2SV_blank>\" , indices . shape ( ) . DebugString ( ) ) ) ; const auto indices_values = indices . matrix < int64_t > ( ) ; const auto values_values = values . flat < T > ( ) ; const auto weight_values = weights . flat < W > ( ) ; auto per_batch_counts = BatchedMap < W > ( num_batches ) ; T max_value = 0 ; <S2SV_StartBug> OP_REQUIRES ( context , num_values <= indices . shape ( ) . dim_size ( 0 ) , <S2SV_EndBug> errors : : InvalidArgument ( \"The<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices<S2SV_blank>must<S2SV_blank>be<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>or<S2SV_blank>\" \"greather<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values.<S2SV_blank>(<S2SV_blank>\" , indices . shape ( ) . dim_size ( 0 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , num_values , \"<S2SV_blank>)\" ) ) ; OP_REQUIRES ( context , indices . shape ( ) . dim_size ( 1 ) > 0 , errors : : InvalidArgument ( \"The<S2SV_blank>second<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices<S2SV_blank>must<S2SV_blank>\" \"be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0.<S2SV_blank>Received:<S2SV_blank>\" , indices . shape ( ) . dim_size ( 1 ) ) ) ; for ( int idx = 0 ; idx < num_values ; ++ idx ) { <S2SV_StartBug> int batch = is_1d ? 0 : indices_values ( idx , 0 ) ; <S2SV_EndBug> if ( batch >= num_batches ) { OP_REQUIRES ( context , batch < num_batches , errors : : InvalidArgument ( \"Indices<S2SV_blank>value<S2SV_blank>along<S2SV_blank>the<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\" , \"lower<S2SV_blank>than<S2SV_blank>the<S2SV_blank>first<S2SV_blank>index<S2SV_blank>of<S2SV_blank>the<S2SV_blank>shape.\" , \"Got<S2SV_blank>\" , batch , \"<S2SV_blank>as<S2SV_blank>batch<S2SV_blank>and<S2SV_blank>\" , num_batches , \"<S2SV_blank>as<S2SV_blank>the<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>the<S2SV_blank>shape.\" ) ) ; } const auto & value = values_values ( idx ) ; if ( value >= 0 && ( maxlength_ <= 0 || value < maxlength_ ) ) { if ( binary_output_ ) { <S2SV_StartBug> per_batch_counts [ batch ] [ value ] = 1 ; <S2SV_EndBug> } else if ( use_weights ) { <S2SV_StartBug> per_batch_counts [ batch ] [ value ] += weight_values ( idx ) ; <S2SV_EndBug> } else { <S2SV_StartBug> per_batch_counts [ batch ] [ value ] ++ ; <S2SV_EndBug> } if ( value > max_value ) { max_value = value ; } } } int num_output_values = GetOutputSize ( max_value , maxlength_ , minlength_ ) ; OP_REQUIRES_OK ( context , OutputSparse < W > ( per_batch_counts , num_output_values , is_1d , context ) ) ; }", "target": "<S2SV_ModStart> const Tensor & splits <S2SV_ModEnd> = context -> <S2SV_ModStart> const Tensor & weights <S2SV_ModEnd> = context -> <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> bool use_weights = <S2SV_ModStart> > 0 ; bool is_1d = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } const auto splits_values = splits <S2SV_ModEnd> . flat < <S2SV_ModStart> flat < int64_t > ( ) ; const auto values_values = values . flat < T > ( ) ; const auto weight_values = weights . flat < W <S2SV_ModStart> int num_batches = splits . NumElements ( ) - 1 <S2SV_ModEnd> ; int num_values <S2SV_ModStart> ( ) ; OP_REQUIRES ( context , num_batches > <S2SV_ModEnd> 0 , errors <S2SV_ModStart> : InvalidArgument ( \"Must<S2SV_blank>provide<S2SV_blank>at<S2SV_blank>least<S2SV_blank>2<S2SV_blank>elements<S2SV_blank>for<S2SV_blank>the<S2SV_blank>splits<S2SV_blank>argument\" ) ) ; <S2SV_ModEnd> OP_REQUIRES ( context <S2SV_ModStart> ( context , splits_values ( 0 ) == 0 , errors : : InvalidArgument ( \"Splits<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>0,<S2SV_blank>not<S2SV_blank>with<S2SV_blank>\" , splits_values ( 0 ) ) ) ; OP_REQUIRES ( context , splits_values ( num_batches ) == num_values <S2SV_ModEnd> , errors : <S2SV_ModStart> : InvalidArgument ( \"Splits<S2SV_blank>must<S2SV_blank>end<S2SV_blank>with<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values,<S2SV_blank>got<S2SV_blank>\" , splits_values ( num_batches ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>\" , num_values ) <S2SV_ModEnd> ) ; auto <S2SV_ModStart> = 0 ; int batch_idx = 0 ; for ( int idx = 0 ; idx < num_values <S2SV_ModEnd> ; ++ idx <S2SV_ModStart> idx ) { while ( idx >= splits_values ( batch_idx ) ) { batch_idx ++ <S2SV_ModEnd> ; } const <S2SV_ModStart> { per_batch_counts [ batch_idx - 1 <S2SV_ModEnd> ] [ value <S2SV_ModStart> { per_batch_counts [ batch_idx - 1 <S2SV_ModEnd> ] [ value <S2SV_ModStart> { per_batch_counts [ batch_idx - 1 <S2SV_ModEnd> ] [ value"}
{"source": "CWE-369 inline void BiasAndClamp ( float clamp_min , float clamp_max , int bias_size , const float * bias_data , int array_size , float * array_data ) { <S2SV_StartBug> TFLITE_DCHECK_EQ ( ( array_size % bias_size ) , 0 ) ; <S2SV_EndBug> # ifdef USE_NEON float * array_ptr = array_data ; float * array_end_ptr = array_ptr + array_size ; const auto clamp_min_vec = vdupq_n_f32 ( clamp_min ) ; const auto clamp_max_vec = vdupq_n_f32 ( clamp_max ) ; for ( ; array_ptr != array_end_ptr ; array_ptr += bias_size ) { int i = 0 ; for ( ; i <= bias_size - 16 ; i += 16 ) { auto b0 = vld1q_f32 ( bias_data + i ) ; auto b1 = vld1q_f32 ( bias_data + i + 4 ) ; auto b2 = vld1q_f32 ( bias_data + i + 8 ) ; auto b3 = vld1q_f32 ( bias_data + i + 12 ) ; auto a0 = vld1q_f32 ( array_ptr + i ) ; auto a1 = vld1q_f32 ( array_ptr + i + 4 ) ; auto a2 = vld1q_f32 ( array_ptr + i + 8 ) ; auto a3 = vld1q_f32 ( array_ptr + i + 12 ) ; auto x0 = vaddq_f32 ( a0 , b0 ) ; auto x1 = vaddq_f32 ( a1 , b1 ) ; auto x2 = vaddq_f32 ( a2 , b2 ) ; auto x3 = vaddq_f32 ( a3 , b3 ) ; x0 = vmaxq_f32 ( clamp_min_vec , x0 ) ; x1 = vmaxq_f32 ( clamp_min_vec , x1 ) ; x2 = vmaxq_f32 ( clamp_min_vec , x2 ) ; x3 = vmaxq_f32 ( clamp_min_vec , x3 ) ; x0 = vminq_f32 ( clamp_max_vec , x0 ) ; x1 = vminq_f32 ( clamp_max_vec , x1 ) ; x2 = vminq_f32 ( clamp_max_vec , x2 ) ; x3 = vminq_f32 ( clamp_max_vec , x3 ) ; vst1q_f32 ( array_ptr + i , x0 ) ; vst1q_f32 ( array_ptr + i + 4 , x1 ) ; vst1q_f32 ( array_ptr + i + 8 , x2 ) ; vst1q_f32 ( array_ptr + i + 12 , x3 ) ; } for ( ; i <= bias_size - 4 ; i += 4 ) { auto b = vld1q_f32 ( bias_data + i ) ; auto a = vld1q_f32 ( array_ptr + i ) ; auto x = vaddq_f32 ( a , b ) ; x = vmaxq_f32 ( clamp_min_vec , x ) ; x = vminq_f32 ( clamp_max_vec , x ) ; vst1q_f32 ( array_ptr + i , x ) ; } for ( ; i < bias_size ; i ++ ) { array_ptr [ i ] = ActivationFunctionWithMinMax ( array_ptr [ i ] + bias_data [ i ] , clamp_min , clamp_max ) ; } } # else for ( int array_offset = 0 ; array_offset < array_size ; array_offset += bias_size ) { for ( int i = 0 ; i < bias_size ; i ++ ) { array_data [ array_offset + i ] = ActivationFunctionWithMinMax ( array_data [ array_offset + i ] + bias_data [ i ] , clamp_min , clamp_max ) ; } } # endif }", "target": "<S2SV_ModStart> array_data ) { if ( bias_size == 0 ) return ;"}
{"source": "CWE-617 bool DependencyOptimizer : : SafeToRemoveIdentity ( const NodeDef & node ) const { if ( ! IsIdentity ( node ) && ! IsIdentityN ( node ) ) { return true ; } if ( nodes_to_preserve_ . find ( node . name ( ) ) != nodes_to_preserve_ . end ( ) ) { return false ; } if ( ! fetch_nodes_known_ ) { return false ; } if ( node . input_size ( ) < 1 ) { return false ; } const NodeDef * input = node_map_ -> GetNode ( NodeName ( node . input ( 0 ) ) ) ; <S2SV_StartBug> CHECK ( input != nullptr ) << \"node<S2SV_blank>=<S2SV_blank>\" << node . name ( ) <S2SV_EndBug> <S2SV_StartBug> << \"<S2SV_blank>input<S2SV_blank>=<S2SV_blank>\" << node . input ( 0 ) ; <S2SV_EndBug> if ( IsVariable ( * input ) || IsRecv ( * input ) ) { return false ; } for ( const auto & consumer : node_map_ -> GetOutputs ( node . name ( ) ) ) { if ( node . input_size ( ) > 1 && ( IsRetval ( * consumer ) || IsMerge ( * consumer ) ) ) { return false ; } if ( IsSwitch ( * input ) ) { for ( const string & consumer_input : consumer -> input ( ) ) { if ( consumer_input == AsControlDependency ( node . name ( ) ) ) { return false ; } } } } return true ; }", "target": "<S2SV_ModStart> ) ) ; if ( input == nullptr ) { VLOG ( 1 ) <S2SV_ModEnd> << \"node<S2SV_blank>=<S2SV_blank>\" << <S2SV_ModStart> 0 ) ; return false ; }"}
{"source": "CWE-476 GF_Err mpgviddmx_process ( GF_Filter * filter ) { GF_MPGVidDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u64 byte_offset ; s64 vosh_start = - 1 ; s64 vosh_end = - 1 ; GF_Err e ; char * data ; u8 * start ; u32 pck_size ; s32 remain ; if ( ! ctx -> duration . num ) mpgviddmx_check_dur ( filter , ctx ) ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { mpgviddmx_enqueue_or_dispatch ( ctx , NULL , GF_TRUE , GF_TRUE ) ; if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } return GF_OK ; } data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; byte_offset = gf_filter_pck_get_byte_offset ( pck ) ; start = data ; remain = pck_size ; if ( ! ctx -> resume_from && ctx -> timescale ) { u64 ts = gf_filter_pck_get_cts ( pck ) ; if ( ts != GF_FILTER_NO_TS ) { if ( ! ctx -> cts || ! ctx -> recompute_cts ) ctx -> cts = ts ; } ts = gf_filter_pck_get_dts ( pck ) ; if ( ts != GF_FILTER_NO_TS ) { if ( ! ctx -> dts || ! ctx -> recompute_cts ) ctx -> dts = ts ; if ( ! ctx -> prev_dts ) ctx -> prev_dts = ts ; else if ( ctx -> prev_dts != ts ) { u64 diff = ts ; diff -= ctx -> prev_dts ; if ( ! ctx -> cur_fps . den ) ctx -> cur_fps . den = ( u32 ) diff ; else if ( ctx -> cur_fps . den > diff ) ctx -> cur_fps . den = ( u32 ) diff ; } } gf_filter_pck_get_framing ( pck , & ctx -> input_is_au_start , & ctx -> input_is_au_end ) ; if ( ctx -> recompute_cts ) ctx -> input_is_au_start = GF_FALSE ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } if ( ! ctx -> resume_from && ctx -> hdr_store_size ) { if ( ctx -> hdr_store_alloc < ctx -> hdr_store_size + pck_size ) { ctx -> hdr_store_alloc = ctx -> hdr_store_size + pck_size ; ctx -> hdr_store = gf_realloc ( ctx -> hdr_store , sizeof ( char ) * ctx -> hdr_store_alloc ) ; } memcpy ( ctx -> hdr_store + ctx -> hdr_store_size , data , sizeof ( char ) * pck_size ) ; if ( byte_offset != GF_FILTER_NO_BO ) { if ( byte_offset >= ctx -> hdr_store_size ) byte_offset -= ctx -> hdr_store_size ; else byte_offset = GF_FILTER_NO_BO ; } ctx -> hdr_store_size += pck_size ; start = data = ctx -> hdr_store ; remain = pck_size = ctx -> hdr_store_size ; } if ( ctx -> resume_from ) { if ( gf_filter_pid_would_block ( ctx -> opid ) ) return GF_OK ; if ( ctx -> hdr_store_size ) { assert ( ctx -> resume_from <= ctx -> hdr_store_size ) ; start = data = ctx -> hdr_store + ctx -> resume_from ; remain = pck_size = ctx -> hdr_store_size - ctx -> resume_from ; } else { assert ( remain >= ( s32 ) ctx -> resume_from ) ; start += ctx -> resume_from ; remain -= ctx -> resume_from ; } ctx -> resume_from = 0 ; } if ( ! ctx -> bs ) { ctx -> bs = gf_bs_new ( start , remain , GF_BITSTREAM_READ ) ; } else { gf_bs_reassign_buffer ( ctx -> bs , start , remain ) ; } if ( ! ctx -> vparser ) { ctx -> vparser = gf_m4v_parser_bs_new ( ctx -> bs , ctx -> is_mpg12 ) ; } while ( remain ) { Bool full_frame ; u8 * pck_data ; s32 current ; u8 sc_type , forced_sc_type = 0 ; Bool sc_type_forced = GF_FALSE ; Bool skip_pck = GF_FALSE ; u8 ftype ; u32 tinc ; u64 size = 0 ; u64 fstart ; Bool is_coded ; u32 bytes_from_store = 0 ; u32 hdr_offset = 0 ; Bool copy_last_bytes = GF_FALSE ; if ( remain < 5 ) { memcpy ( ctx -> hdr_store , start , remain ) ; ctx -> bytes_in_header = remain ; break ; } current = - 1 ; if ( ctx -> bytes_in_header ) { memcpy ( ctx -> hdr_store + ctx -> bytes_in_header , start , 8 - ctx -> bytes_in_header ) ; current = mpgviddmx_next_start_code ( ctx -> hdr_store , 8 ) ; if ( ( current < 0 ) || ( current >= ( s32 ) ctx -> bytes_in_header ) ) { if ( ctx -> opid ) { dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , ctx -> bytes_in_header , & pck_data ) ; if ( ! dst_pck ) return GF_OUT_OF_MEM ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; gf_filter_pck_set_cts ( dst_pck , GF_FILTER_NO_TS ) ; gf_filter_pck_set_dts ( dst_pck , GF_FILTER_NO_TS ) ; memcpy ( pck_data , ctx -> hdr_store , ctx -> bytes_in_header ) ; gf_filter_pck_set_framing ( dst_pck , GF_FALSE , GF_FALSE ) ; if ( byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , byte_offset - ctx -> bytes_in_header ) ; } mpgviddmx_enqueue_or_dispatch ( ctx , dst_pck , GF_FALSE , GF_FALSE ) ; } if ( current < 0 ) current = - 1 ; else current -= ctx -> bytes_in_header ; ctx -> bytes_in_header = 0 ; } else { hdr_offset = 4 - ctx -> bytes_in_header + current ; bytes_from_store = ctx -> bytes_in_header ; ctx -> bytes_in_header = 0 ; if ( ! hdr_offset ) { forced_sc_type = ctx -> hdr_store [ current + 3 ] ; } else { forced_sc_type = start [ hdr_offset - 1 ] ; } sc_type_forced = GF_TRUE ; } } if ( current == - 1 ) { current = mpgviddmx_next_start_code ( start , remain ) ; if ( current < 0 ) { u8 b3 , b2 , b1 ; if ( ! ctx -> frame_started ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_MEDIA , ( \"[MPGVid]<S2SV_blank>no<S2SV_blank>start<S2SV_blank>code<S2SV_blank>in<S2SV_blank>block<S2SV_blank>and<S2SV_blank>no<S2SV_blank>frame<S2SV_blank>started,<S2SV_blank>discarding<S2SV_blank>data\\\\n\" ) ) ; break ; } size = remain ; b3 = start [ remain - 3 ] ; b2 = start [ remain - 2 ] ; b1 = start [ remain - 1 ] ; if ( ! b1 || ! b2 || ! b3 ) { copy_last_bytes = GF_TRUE ; assert ( size >= 3 ) ; size -= 3 ; ctx -> bytes_in_header = 3 ; } dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , ( u32 ) size , & pck_data ) ; if ( ! dst_pck ) return GF_OUT_OF_MEM ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( pck_data , start , ( size_t ) size ) ; gf_filter_pck_set_framing ( dst_pck , GF_FALSE , GF_FALSE ) ; gf_filter_pck_set_cts ( dst_pck , GF_FILTER_NO_TS ) ; gf_filter_pck_set_dts ( dst_pck , GF_FILTER_NO_TS ) ; if ( byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , byte_offset ) ; } mpgviddmx_enqueue_or_dispatch ( ctx , dst_pck , GF_FALSE , GF_FALSE ) ; if ( copy_last_bytes ) { memcpy ( ctx -> hdr_store , start + remain - 3 , 3 ) ; } break ; } } assert ( current >= 0 ) ; if ( ( vosh_start >= 0 ) && current ) { assert ( remain >= current ) ; start += current ; remain -= current ; current = 0 ; } if ( ! ctx -> opid && current ) { assert ( remain >= current ) ; start += current ; remain -= current ; current = 0 ; } if ( current > 0 ) { dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , current , & pck_data ) ; if ( ! dst_pck ) return GF_OUT_OF_MEM ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; gf_filter_pck_set_cts ( dst_pck , GF_FILTER_NO_TS ) ; gf_filter_pck_set_dts ( dst_pck , GF_FILTER_NO_TS ) ; gf_filter_pck_set_framing ( dst_pck , GF_FALSE , GF_TRUE ) ; if ( bytes_from_store ) { if ( byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , byte_offset - bytes_from_store ) ; } assert ( bytes_from_store >= ( u32 ) current ) ; bytes_from_store -= current ; memcpy ( pck_data , ctx -> hdr_store , current ) ; } else { if ( byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , byte_offset ) ; } memcpy ( pck_data , start , current ) ; assert ( remain >= current ) ; start += current ; remain -= current ; current = 0 ; } gf_filter_pck_set_carousel_version ( dst_pck , 1 ) ; mpgviddmx_enqueue_or_dispatch ( ctx , dst_pck , GF_FALSE , GF_FALSE ) ; } <S2SV_StartBug> <S2SV_EndBug> if ( sc_type_forced ) { gf_bs_reassign_buffer ( ctx -> bs , start + hdr_offset , remain - hdr_offset ) ; sc_type = forced_sc_type ; } else { gf_bs_reassign_buffer ( ctx -> bs , start , remain ) ; gf_bs_read_int ( ctx -> bs , 24 ) ; sc_type = gf_bs_read_int ( ctx -> bs , 8 ) ; } if ( ctx -> is_mpg12 ) { switch ( sc_type ) { case M2V_SEQ_START_CODE : case M2V_EXT_START_CODE : gf_bs_reassign_buffer ( ctx -> bs , start , remain ) ; e = gf_m4v_parse_config ( ctx -> vparser , & ctx -> dsi ) ; if ( e == GF_EOS ) { if ( vosh_start < 0 ) vosh_start = 0 ; if ( data == ctx -> hdr_store ) { memmove ( ctx -> hdr_store , start , remain ) ; ctx -> hdr_store_size = remain ; } else { if ( ctx -> hdr_store_alloc < ctx -> hdr_store_size + pck_size - vosh_start ) { ctx -> hdr_store_alloc = ( u32 ) ( ctx -> hdr_store_size + pck_size - vosh_start ) ; ctx -> hdr_store = gf_realloc ( ctx -> hdr_store , sizeof ( char ) * ctx -> hdr_store_alloc ) ; } memcpy ( ctx -> hdr_store + ctx -> hdr_store_size , data + vosh_start , ( size_t ) ( pck_size - vosh_start ) ) ; ctx -> hdr_store_size += pck_size - ( u32 ) vosh_start ; } gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_OK ; } else if ( e != GF_OK ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_MEDIA , ( \"[MPGVid]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>VOS<S2SV_blank>header:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ) ; } else { mpgviddmx_check_pid ( filter , ctx , 0 , NULL ) ; } break ; case M2V_PIC_START_CODE : break ; default : break ; } } else { u8 PL ; switch ( sc_type ) { case M4V_VOS_START_CODE : ctx -> dsi . VideoPL = ( u8 ) gf_bs_read_u8 ( ctx -> bs ) ; vosh_start = start - ( u8 * ) data ; skip_pck = GF_TRUE ; assert ( remain >= 5 ) ; start += 5 ; remain -= 5 ; break ; case M4V_VOL_START_CODE : gf_bs_reassign_buffer ( ctx -> bs , start , remain ) ; PL = ctx -> dsi . VideoPL ; e = gf_m4v_parse_config ( ctx -> vparser , & ctx -> dsi ) ; ctx -> dsi . VideoPL = PL ; if ( e == GF_EOS ) { if ( vosh_start < 0 ) vosh_start = 0 ; if ( data == ctx -> hdr_store ) { memmove ( ctx -> hdr_store , start , remain ) ; ctx -> hdr_store_size = remain ; } else { if ( ctx -> hdr_store_alloc < ctx -> hdr_store_size + pck_size - vosh_start ) { ctx -> hdr_store_alloc = ( u32 ) ( ctx -> hdr_store_size + pck_size - ( u32 ) vosh_start ) ; ctx -> hdr_store = gf_realloc ( ctx -> hdr_store , sizeof ( char ) * ctx -> hdr_store_alloc ) ; } memcpy ( ctx -> hdr_store + ctx -> hdr_store_size , data + vosh_start , ( size_t ) ( pck_size - vosh_start ) ) ; ctx -> hdr_store_size += pck_size - ( u32 ) vosh_start ; } gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_OK ; } else if ( e != GF_OK ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_MEDIA , ( \"[MPGVid]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>VOS<S2SV_blank>header:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ) ; } else { u32 obj_size = ( u32 ) gf_m4v_get_object_start ( ctx -> vparser ) ; if ( vosh_start < 0 ) vosh_start = 0 ; vosh_end = start - ( u8 * ) data + obj_size ; vosh_end -= vosh_start ; mpgviddmx_check_pid ( filter , ctx , ( u32 ) vosh_end , data + vosh_start ) ; skip_pck = GF_TRUE ; assert ( remain >= ( s32 ) obj_size ) ; start += obj_size ; remain -= obj_size ; } break ; case M4V_VOP_START_CODE : case M4V_GOV_START_CODE : break ; case M4V_VO_START_CODE : case M4V_VISOBJ_START_CODE : default : if ( vosh_start >= 0 ) { skip_pck = GF_TRUE ; assert ( remain >= 4 ) ; start += 4 ; remain -= 4 ; } break ; } } if ( skip_pck ) { continue ; } if ( ! ctx -> opid ) { assert ( remain >= 4 ) ; start += 4 ; remain -= 4 ; continue ; } if ( ! ctx -> is_playing ) { ctx -> resume_from = ( u32 ) ( ( char * ) start - ( char * ) data ) ; return GF_OK ; } ctx -> hdr_store_size = 0 ; if ( ctx -> in_seek ) { u64 nb_frames_at_seek = ( u64 ) ( ctx -> start_range * ctx -> cur_fps . num ) ; if ( ctx -> cts + ctx -> cur_fps . den >= nb_frames_at_seek ) { ctx -> in_seek = GF_FALSE ; } } if ( remain < 5 ) continue ; gf_m4v_parser_reset ( ctx -> vparser , sc_type_forced ? forced_sc_type + 1 : 0 ) ; size = 0 ; e = gf_m4v_parse_frame ( ctx -> vparser , & ctx -> dsi , & ftype , & tinc , & size , & fstart , & is_coded ) ; if ( bytes_from_store ) { size += bytes_from_store + hdr_offset ; } if ( ( e == GF_EOS ) && ! ctx -> input_is_au_end ) { u8 b3 = start [ remain - 3 ] ; u8 b2 = start [ remain - 2 ] ; u8 b1 = start [ remain - 1 ] ; if ( ! b1 || ! b2 || ! b3 ) { copy_last_bytes = GF_TRUE ; assert ( size >= 3 ) ; size -= 3 ; ctx -> bytes_in_header = 3 ; } full_frame = GF_FALSE ; } else { full_frame = GF_TRUE ; } if ( ! is_coded ) { if ( ctx -> forced_packed && ctx -> b_frames ) { ctx -> is_packed = GF_TRUE ; assert ( remain >= size ) ; start += size ; remain -= ( s32 ) size ; continue ; } if ( ctx -> vfr ) { ctx -> is_vfr = GF_TRUE ; mpgviddmx_update_time ( ctx ) ; assert ( remain >= size ) ; start += size ; remain -= ( s32 ) size ; continue ; } } if ( ftype == 2 ) { ctx -> b_frames ++ ; ctx -> nb_b ++ ; } else { mpgviddmx_enqueue_or_dispatch ( ctx , NULL , GF_TRUE , GF_FALSE ) ; ctx -> last_ref_cts = ctx -> cts ; if ( ctx -> max_b < ctx -> b_frames ) ctx -> max_b = ctx -> b_frames ; ctx -> b_frames = 0 ; if ( ftype ) ctx -> nb_p ++ ; else ctx -> nb_i ++ ; } ctx -> nb_frames ++ ; dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , ( u32 ) size , & pck_data ) ; if ( ! dst_pck ) return GF_OUT_OF_MEM ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; if ( bytes_from_store ) { memcpy ( pck_data , ctx -> hdr_store + current , bytes_from_store ) ; assert ( size >= bytes_from_store ) ; size -= bytes_from_store ; if ( byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , byte_offset - bytes_from_store ) ; } memcpy ( pck_data + bytes_from_store , start , ( size_t ) size ) ; } else { memcpy ( pck_data , start , ( size_t ) size ) ; if ( byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , byte_offset + start - ( u8 * ) data ) ; } } assert ( pck_data [ 0 ] == 0 ) ; assert ( pck_data [ 1 ] == 0 ) ; assert ( pck_data [ 2 ] == 0x01 ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , ( full_frame || ctx -> input_is_au_end ) ? GF_TRUE : GF_FALSE ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_dts ( dst_pck , ctx -> dts ) ; if ( ctx -> input_is_au_start ) { ctx -> input_is_au_start = GF_FALSE ; } else { gf_filter_pck_set_carousel_version ( dst_pck , 1 ) ; } gf_filter_pck_set_sap ( dst_pck , ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1 ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> cur_fps . den ) ; if ( ctx -> in_seek ) gf_filter_pck_set_seek_flag ( dst_pck , GF_TRUE ) ; ctx -> frame_started = GF_TRUE ; mpgviddmx_enqueue_or_dispatch ( ctx , dst_pck , GF_FALSE , GF_FALSE ) ; mpgviddmx_update_time ( ctx ) ; if ( ! full_frame ) { if ( copy_last_bytes ) { memcpy ( ctx -> hdr_store , start + remain - 3 , 3 ) ; } break ; } assert ( remain >= size ) ; start += size ; remain -= ( s32 ) size ; } gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_OK ; }", "target": "<S2SV_ModStart> ) ; } if ( remain < 5 ) { memcpy ( ctx -> hdr_store , start , remain ) ; ctx -> bytes_in_header = remain ; break ; }"}
{"source": "CWE-120 static s32 svc_parse_slice ( GF_BitStream * bs , AVCState * avc , AVCSliceInfo * si ) { s32 pps_id ; gf_bs_read_ue_log ( bs , \"first_mb_in_slice\" ) ; si -> slice_type = gf_bs_read_ue_log ( bs , \"slice_type\" ) ; if ( si -> slice_type > 9 ) return - 1 ; pps_id = gf_bs_read_ue_log ( bs , \"pps_id\" ) ; <S2SV_StartBug> if ( pps_id > 255 ) <S2SV_EndBug> return - 1 ; si -> pps = & avc -> pps [ pps_id ] ; si -> pps -> id = pps_id ; if ( ! si -> pps -> slice_group_count ) return - 2 ; si -> sps = & avc -> sps [ si -> pps -> sps_id + GF_SVC_SSPS_ID_SHIFT ] ; if ( ! si -> sps -> log2_max_frame_num ) return - 2 ; si -> frame_num = gf_bs_read_int_log ( bs , si -> sps -> log2_max_frame_num , \"frame_num\" ) ; si -> field_pic_flag = 0 ; if ( si -> sps -> frame_mbs_only_flag ) { } else { si -> field_pic_flag = gf_bs_read_int_log ( bs , 1 , \"field_pic_flag\" ) ; if ( si -> field_pic_flag ) si -> bottom_field_flag = gf_bs_read_int_log ( bs , 1 , \"bottom_field_flag\" ) ; } if ( si -> nal_unit_type == GF_AVC_NALU_IDR_SLICE || si -> NalHeader . idr_pic_flag ) si -> idr_pic_id = gf_bs_read_ue_log ( bs , \"idr_pic_id\" ) ; if ( si -> sps -> poc_type == 0 ) { si -> poc_lsb = gf_bs_read_int_log ( bs , si -> sps -> log2_max_poc_lsb , \"poc_lsb\" ) ; if ( si -> pps -> pic_order_present && ! si -> field_pic_flag ) { si -> delta_poc_bottom = gf_bs_read_se_log ( bs , \"delta_poc_bottom\" ) ; } } else if ( ( si -> sps -> poc_type == 1 ) && ! si -> sps -> delta_pic_order_always_zero_flag ) { si -> delta_poc [ 0 ] = gf_bs_read_se_log ( bs , \"delta_poc0\" ) ; if ( ( si -> pps -> pic_order_present == 1 ) && ! si -> field_pic_flag ) si -> delta_poc [ 1 ] = gf_bs_read_se_log ( bs , \"delta_poc1\" ) ; } if ( si -> pps -> redundant_pic_cnt_present ) { si -> redundant_pic_cnt = gf_bs_read_ue_log ( bs , \"redundant_pic_cnt\" ) ; } return 0 ; }", "target": "<S2SV_ModStart> ; if ( ( pps_id < 0 ) || ( <S2SV_ModStart> pps_id > 255 )"}
{"source": "CWE-416 void DecodePngV2 ( OpKernelContext * context , StringPiece input ) { int channel_bits = ( data_type_ == DataType : : DT_UINT8 ) ? 8 : 16 ; png : : DecodeContext decode ; OP_REQUIRES ( context , png : : CommonInitDecode ( input , channels_ , channel_bits , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG.<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder.\" ) ) ; const int width = static_cast < int > ( decode . width ) ; const int height = static_cast < int > ( decode . height ) ; const int64_t total_size = static_cast < int64_t > ( width ) * static_cast < int64_t > ( height ) ; if ( width != static_cast < int64_t > ( decode . width ) || width <= 0 || width >= ( 1LL << 27 ) || height != static_cast < int64_t > ( decode . height ) || height <= 0 || height >= ( 1LL << 27 ) || total_size >= ( 1LL << 29 ) ) { <S2SV_StartBug> png : : CommonFreeDecode ( & decode ) ; <S2SV_EndBug> OP_REQUIRES ( context , false , errors : : InvalidArgument ( \"PNG<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>int:<S2SV_blank>\" , decode . width , \"<S2SV_blank>by<S2SV_blank>\" , decode . height ) ) ; } Tensor * output = nullptr ; Status status ; if ( op_type_ == \"DecodeGif\" ) { status = context -> allocate_output ( 0 , TensorShape ( { 1 , height , width , decode . channels } ) , & output ) ; } else { status = context -> allocate_output ( 0 , TensorShape ( { height , width , decode . channels } ) , & output ) ; } if ( op_type_ == \"DecodeBmp\" ) { OP_REQUIRES ( context , false , errors : : InvalidArgument ( \"Trying<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PNG<S2SV_blank>format<S2SV_blank>using<S2SV_blank>DecodeBmp<S2SV_blank>op.<S2SV_blank>Use<S2SV_blank>\" \"`decode_png`<S2SV_blank>or<S2SV_blank>`decode_image`<S2SV_blank>instead.\" ) ) ; } else if ( op_type_ == \"DecodeAndCropJpeg\" ) { OP_REQUIRES ( context , false , errors : : InvalidArgument ( \"DecodeAndCropJpeg<S2SV_blank>operation<S2SV_blank>can<S2SV_blank>run<S2SV_blank>on<S2SV_blank>JPEG<S2SV_blank>only,<S2SV_blank>but<S2SV_blank>\" \"detected<S2SV_blank>PNG.\" ) ) ; } if ( ! status . ok ( ) ) png : : CommonFreeDecode ( & decode ) ; OP_REQUIRES_OK ( context , status ) ; if ( data_type_ == DataType : : DT_UINT8 ) { OP_REQUIRES ( context , png : : CommonFinishDecode ( reinterpret_cast < png_bytep > ( output -> flat < uint8 > ( ) . data ( ) ) , decode . channels * width * sizeof ( uint8 ) , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG<S2SV_blank>data,<S2SV_blank>size<S2SV_blank>\" , input . size ( ) ) ) ; } else if ( data_type_ == DataType : : DT_UINT16 ) { OP_REQUIRES ( context , png : : CommonFinishDecode ( reinterpret_cast < png_bytep > ( output -> flat < uint16 > ( ) . data ( ) ) , decode . channels * width * sizeof ( uint16 ) , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG<S2SV_blank>data,<S2SV_blank>size<S2SV_blank>\" , input . size ( ) ) ) ; } else if ( data_type_ == DataType : : DT_FLOAT ) { std : : unique_ptr < uint16 [ ] > buffer ( new uint16 [ height * width * decode . channels ] ) ; OP_REQUIRES ( context , png : : CommonFinishDecode ( reinterpret_cast < png_bytep > ( buffer . get ( ) ) , decode . channels * width * sizeof ( uint16 ) , & decode ) , errors : : InvalidArgument ( \"Invalid<S2SV_blank>PNG<S2SV_blank>data,<S2SV_blank>size<S2SV_blank>\" , input . size ( ) ) ) ; const auto & device = context -> eigen_device < Eigen : : ThreadPoolDevice > ( ) ; TTypes < uint16 , 3 > : : UnalignedConstTensor buf ( buffer . get ( ) , height , width , decode . channels ) ; float scale = 1. / std : : numeric_limits < uint16 > : : max ( ) ; output -> tensor < float , 3 > ( ) . device ( device ) = buf . cast < float > ( ) * scale ; } }", "target": "<S2SV_ModStart> ) ) { <S2SV_ModEnd> OP_REQUIRES ( context"}
{"source": "CWE-415 GF_AV1Config * gf_odf_av1_cfg_read_bs_size ( GF_BitStream * bs , u32 size ) { # ifndef GPAC_DISABLE_AV_PARSERS AV1State state ; u8 reserved ; GF_AV1Config * cfg ; if ( ! size ) size = ( u32 ) gf_bs_available ( bs ) ; if ( ! size ) return NULL ; cfg = gf_odf_av1_cfg_new ( ) ; gf_av1_init_state ( & state ) ; state . config = cfg ; cfg -> marker = gf_bs_read_int ( bs , 1 ) ; cfg -> version = gf_bs_read_int ( bs , 7 ) ; cfg -> seq_profile = gf_bs_read_int ( bs , 3 ) ; cfg -> seq_level_idx_0 = gf_bs_read_int ( bs , 5 ) ; cfg -> seq_tier_0 = gf_bs_read_int ( bs , 1 ) ; cfg -> high_bitdepth = gf_bs_read_int ( bs , 1 ) ; cfg -> twelve_bit = gf_bs_read_int ( bs , 1 ) ; cfg -> monochrome = gf_bs_read_int ( bs , 1 ) ; cfg -> chroma_subsampling_x = gf_bs_read_int ( bs , 1 ) ; cfg -> chroma_subsampling_y = gf_bs_read_int ( bs , 1 ) ; cfg -> chroma_sample_position = gf_bs_read_int ( bs , 2 ) ; reserved = gf_bs_read_int ( bs , 3 ) ; if ( reserved != 0 || cfg -> marker != 1 || cfg -> version != 1 ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[AV1]<S2SV_blank>wrong<S2SV_blank>avcC<S2SV_blank>reserved<S2SV_blank>%d<S2SV_blank>/<S2SV_blank>marker<S2SV_blank>%d<S2SV_blank>/<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>expecting<S2SV_blank>0<S2SV_blank>1<S2SV_blank>1\\\\n\" , reserved , cfg -> marker , cfg -> version ) ) ; gf_odf_av1_cfg_del ( cfg ) ; return NULL ; } cfg -> initial_presentation_delay_present = gf_bs_read_int ( bs , 1 ) ; if ( cfg -> initial_presentation_delay_present ) { cfg -> initial_presentation_delay_minus_one = gf_bs_read_int ( bs , 4 ) ; } else { gf_bs_read_int ( bs , 4 ) ; cfg -> initial_presentation_delay_minus_one = 0 ; } size -= 4 ; while ( size ) { u64 pos , obu_size ; ObuType obu_type ; GF_AV1_OBUArrayEntry * a ; pos = gf_bs_get_position ( bs ) ; obu_size = 0 ; if ( gf_av1_parse_obu ( bs , & obu_type , & obu_size , NULL , & state ) != GF_OK ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[AV1]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>AV1<S2SV_blank>OBU<S2SV_blank>at<S2SV_blank>position<S2SV_blank>\" LLU \".<S2SV_blank>Leaving<S2SV_blank>parsing.\\\\n\" , pos ) ) ; break ; } assert ( obu_size == gf_bs_get_position ( bs ) - pos ) ; GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[AV1]<S2SV_blank>parsed<S2SV_blank>AV1<S2SV_blank>OBU<S2SV_blank>type=%u<S2SV_blank>size=\" LLU \"<S2SV_blank>at<S2SV_blank>position<S2SV_blank>\" LLU \".\\\\n\" , obu_type , obu_size , pos ) ) ; if ( ! av1_is_obu_header ( obu_type ) ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[AV1]<S2SV_blank>AV1<S2SV_blank>unexpected<S2SV_blank>OBU<S2SV_blank>type=%u<S2SV_blank>size=\" LLU \"<S2SV_blank>found<S2SV_blank>at<S2SV_blank>position<S2SV_blank>\" LLU \".<S2SV_blank>Forwarding.\\\\n\" , pos ) ) ; } GF_SAFEALLOC ( a , GF_AV1_OBUArrayEntry ) ; if ( ! a ) break ; a -> obu = gf_malloc ( ( size_t ) obu_size ) ; if ( ! a -> obu ) { gf_free ( a ) ; break ; } gf_bs_seek ( bs , pos ) ; gf_bs_read_data ( bs , ( char * ) a -> obu , ( u32 ) obu_size ) ; a -> obu_length = obu_size ; a -> obu_type = obu_type ; gf_list_add ( cfg -> obu_array , a ) ; if ( size < obu_size ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[AV1]<S2SV_blank>AV1<S2SV_blank>config<S2SV_blank>misses<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>fit<S2SV_blank>the<S2SV_blank>entire<S2SV_blank>OBU\\\\n\" , obu_size - size ) ) ; break ; } size -= ( u32 ) obu_size ; } gf_av1_reset_state ( & state , GF_TRUE ) ; <S2SV_StartBug> return cfg ; <S2SV_EndBug> # else return NULL ; # endif }", "target": "<S2SV_ModStart> GF_TRUE ) ; gf_bs_align ( bs ) ;"}
{"source": "CWE-862 void recalc_intercepts ( struct vcpu_svm * svm ) { struct vmcb_control_area * c , * h , * g ; unsigned int i ; vmcb_mark_dirty ( svm -> vmcb , VMCB_INTERCEPTS ) ; if ( ! is_guest_mode ( & svm -> vcpu ) ) return ; c = & svm -> vmcb -> control ; h = & svm -> vmcb01 . ptr -> control ; g = & svm -> nested . ctl ; for ( i = 0 ; i < MAX_INTERCEPT ; i ++ ) c -> intercepts [ i ] = h -> intercepts [ i ] ; if ( g -> int_ctl & V_INTR_MASKING_MASK ) { vmcb_clr_intercept ( c , INTERCEPT_CR8_READ ) ; vmcb_clr_intercept ( c , INTERCEPT_CR8_WRITE ) ; vmcb_clr_intercept ( c , INTERCEPT_VINTR ) ; } vmcb_clr_intercept ( c , INTERCEPT_VMMCALL ) ; for ( i = 0 ; i < MAX_INTERCEPT ; i ++ ) c -> intercepts [ i ] |= g -> intercepts [ i ] ; if ( ! intercept_smi ) vmcb_clr_intercept ( c , INTERCEPT_SMI ) ; <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> INTERCEPT_SMI ) ; vmcb_set_intercept ( c , INTERCEPT_VMLOAD ) ; vmcb_set_intercept ( c , INTERCEPT_VMSAVE ) ;"}
{"source": "CWE-617 bool Tensor : : FromProto ( Allocator * a , const TensorProto & proto ) { CHECK_NOTNULL ( a ) ; TensorBuffer * p = nullptr ; if ( ! TensorShape : : IsValid ( proto . tensor_shape ( ) ) ) return false ; if ( proto . dtype ( ) == DT_INVALID ) return false ; TensorShape shape ( proto . tensor_shape ( ) ) ; const int64_t N = shape . num_elements ( ) ; if ( N > 0 && proto . dtype ( ) ) { bool dtype_error = false ; if ( ! proto . tensor_content ( ) . empty ( ) ) { const auto & content = proto . tensor_content ( ) ; CASES_WITH_DEFAULT ( proto . dtype ( ) , p = Helper < T > : : Decode ( a , content , N ) , dtype_error = true , dtype_error = true ) ; } else { CASES_WITH_DEFAULT ( proto . dtype ( ) , p = FromProtoField < T > ( a , proto , N ) , dtype_error = true , dtype_error = true ) ; } <S2SV_StartBug> if ( dtype_error || p == nullptr ) return false ; <S2SV_EndBug> } shape_ = shape ; set_dtype ( proto . dtype ( ) ) ; UnrefIfNonNull ( buf_ ) ; buf_ = p ; if ( MemoryLoggingEnabled ( ) && buf_ != nullptr && buf_ -> data ( ) != nullptr ) { LogMemory : : RecordTensorAllocation ( \"Unknown<S2SV_blank>(from<S2SV_blank>Proto)\" , LogMemory : : UNKNOWN_STEP_ID , * this ) ; } return true ; }", "target": "<S2SV_ModStart> p == nullptr ) return false ; } else { bool dtype_error = false ; CASES_WITH_DEFAULT ( proto . dtype ( ) , break , dtype_error = true , dtype_error = true ) ; if ( dtype_error"}
{"source": "CWE-754 llvm : : Optional < Value > simplifyBroadcast ( ShapeComponentAnalysis & analysis , ValueRange shapes , Location loc , OpBuilder * builder ) { SmallVector < ArrayRef < ShapeComponentAnalysis : : SymbolicExpr >> shapes_found ; size_t maxRank = 0 ; for ( const auto & shape : llvm : : enumerate ( shapes ) ) { auto found_shape = analysis . GetValueInfo ( shape . value ( ) ) ; if ( ! found_shape ) return { } ; shapes_found . push_back ( * found_shape ) ; maxRank = std : : max ( maxRank , found_shape -> size ( ) ) ; } <S2SV_StartBug> <S2SV_EndBug> SmallVector < const ShapeComponentAnalysis : : SymbolicExpr * > joined_dimensions ( maxRank ) ; SmallVector < std : : pair < Value , int64_t >> shape_and_rank_for_dim ( maxRank ) ; for ( const auto & shape : llvm : : enumerate ( shapes_found ) ) { for ( const auto & dim : llvm : : enumerate ( llvm : : reverse ( shape . value ( ) ) ) ) { if ( dim . value ( ) . isConstant ( 1 ) ) continue ; auto index = maxRank - dim . index ( ) - 1 ; if ( ! joined_dimensions [ index ] ) { joined_dimensions [ index ] = & dim . value ( ) ; shape_and_rank_for_dim [ index ] = std : : make_pair ( shapes [ shape . index ( ) ] , shape . value ( ) . size ( ) ) ; continue ; } if ( * joined_dimensions [ index ] != dim . value ( ) ) return { } ; } } if ( llvm : : is_splat ( shape_and_rank_for_dim ) && shape_and_rank_for_dim [ 0 ] . first ) { return shape_and_rank_for_dim [ 0 ] . first ; } SmallVector < Value > elements ; for ( int i = 0 ; i != maxRank ; ++ i ) { if ( ! shape_and_rank_for_dim [ i ] . first ) { auto one = builder -> getIntegerAttr ( shapes [ 0 ] . getType ( ) . cast < RankedTensorType > ( ) . getElementType ( ) , 1 ) ; elements . push_back ( builder -> create < ConstantOp > ( loc , one ) ) ; continue ; } Value index = builder -> create < ConstantIndexOp > ( loc , i - maxRank + shape_and_rank_for_dim [ i ] . second ) ; elements . push_back ( builder -> create < tensor : : ExtractOp > ( loc , shape_and_rank_for_dim [ i ] . first , index ) ) ; } return Value ( builder -> create < tensor : : FromElementsOp > ( loc , elements ) ) ; }", "target": "<S2SV_ModStart> ) ; } if ( maxRank == 0 ) { return Value ( builder -> create < tensor : : FromElementsOp > ( loc , shapes [ 0 ] . getType ( ) , SmallVector < Value > ( ) ) ) ; }"}
{"source": "CWE-843 Literal * hermes : : evalUnaryOperator ( UnaryOperatorInst : : OpKind kind , IRBuilder & builder , Literal * operand ) { switch ( kind ) { case UnaryOperatorInst : : OpKind : : MinusKind : switch ( operand -> getKind ( ) ) { case ValueKind : : LiteralNumberKind : if ( auto * literalNum = llvh : : dyn_cast < LiteralNumber > ( operand ) ) { auto V = - literalNum -> getValue ( ) ; return builder . getLiteralNumber ( V ) ; } break ; case ValueKind : : LiteralUndefinedKind : return builder . getLiteralNaN ( ) ; case ValueKind : : LiteralBoolKind : if ( evalIsTrue ( builder , operand ) ) { return builder . getLiteralNumber ( - 1 ) ; } else { return builder . getLiteralNegativeZero ( ) ; } case ValueKind : : LiteralNullKind : return builder . getLiteralNegativeZero ( ) ; default : break ; } break ; case UnaryOperatorInst : : OpKind : : TypeofKind : switch ( operand -> getKind ( ) ) { case ValueKind : : GlobalObjectKind : case ValueKind : : LiteralNullKind : return builder . getLiteralString ( \"object\" ) ; case ValueKind : : LiteralUndefinedKind : return builder . getLiteralString ( \"undefined\" ) ; case ValueKind : : LiteralBoolKind : return builder . getLiteralString ( \"boolean\" ) ; case ValueKind : : LiteralNumberKind : return builder . getLiteralString ( \"number\" ) ; case ValueKind : : LiteralStringKind : return builder . getLiteralString ( \"string\" ) ; default : <S2SV_StartBug> llvm_unreachable ( \"Invalid<S2SV_blank>literal<S2SV_blank>kind.\" ) ; <S2SV_EndBug> } break ; case UnaryOperatorInst : : OpKind : : BangKind : if ( evalIsTrue ( builder , operand ) ) { return builder . getLiteralBool ( false ) ; } if ( evalIsFalse ( builder , operand ) ) { return builder . getLiteralBool ( true ) ; } break ; case UnaryOperatorInst : : OpKind : : VoidKind : return builder . getLiteralUndefined ( ) ; default : break ; } return nullptr ; }", "target": "<S2SV_ModStart> ; default : break <S2SV_ModEnd> ; } break"}
{"source": "CWE-295 int Socket : : startSslClient ( const std : : string & certificate_path , String hostname ) { if ( isssl ) { stopSsl ( ) ; } ERR_clear_error ( ) ; # if OPENSSL_VERSION_NUMBER < 0x10100000L ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ; # else ctx = SSL_CTX_new ( TLS_client_method ( ) ) ; # endif if ( ctx == NULL ) { # ifdef NETDEBUG std : : cout << thread_id << \"Error<S2SV_blank>ssl<S2SV_blank>context<S2SV_blank>is<S2SV_blank>null<S2SV_blank>(check<S2SV_blank>that<S2SV_blank>openssl<S2SV_blank>has<S2SV_blank>been<S2SV_blank>inited)\" << std : : endl ; # endif log_ssl_errors ( \"Error<S2SV_blank>ssl<S2SV_blank>context<S2SV_blank>is<S2SV_blank>null<S2SV_blank>for<S2SV_blank>%s\" , hostname . c_str ( ) ) ; return - 1 ; } if ( SSL_CTX_set_timeout ( ctx , 130l ) < 1 ) { SSL_CTX_free ( ctx ) ; ctx = NULL ; return - 1 ; } ERR_clear_error ( ) ; if ( certificate_path . length ( ) ) { if ( ! SSL_CTX_load_verify_locations ( ctx , NULL , certificate_path . c_str ( ) ) ) { # ifdef NETDEBUG std : : cout << thread_id << \"couldnt<S2SV_blank>load<S2SV_blank>certificates\" << std : : endl ; # endif log_ssl_errors ( \"couldnt<S2SV_blank>load<S2SV_blank>certificates<S2SV_blank>from<S2SV_blank>%s\" , certificate_path . c_str ( ) ) ; SSL_CTX_free ( ctx ) ; ctx = NULL ; return - 2 ; } } else if ( ! SSL_CTX_set_default_verify_paths ( ctx ) ) { # ifdef NETDEBUG std : : cout << thread_id << \"couldnt<S2SV_blank>load<S2SV_blank>certificates\" << std : : endl ; # endif log_ssl_errors ( \"couldnt<S2SV_blank>load<S2SV_blank>default<S2SV_blank>certificates<S2SV_blank>for<S2SV_blank>%s\" , hostname . c_str ( ) ) ; SSL_CTX_free ( ctx ) ; ctx = NULL ; return - 2 ; } ERR_clear_error ( ) ; X509_VERIFY_PARAM * x509_param = X509_VERIFY_PARAM_new ( ) ; if ( ! x509_param ) { log_ssl_errors ( \"couldnt<S2SV_blank>add<S2SV_blank>validation<S2SV_blank>params<S2SV_blank>for<S2SV_blank>%s\" , hostname . c_str ( ) ) ; SSL_CTX_free ( ctx ) ; ctx = NULL ; return - 2 ; } ERR_clear_error ( ) ; if ( ! X509_VERIFY_PARAM_set_flags ( x509_param , X509_V_FLAG_TRUSTED_FIRST ) ) { log_ssl_errors ( \"couldnt<S2SV_blank>add<S2SV_blank>validation<S2SV_blank>params<S2SV_blank>for<S2SV_blank>%s\" , hostname . c_str ( ) ) ; X509_VERIFY_PARAM_free ( x509_param ) ; SSL_CTX_free ( ctx ) ; ctx = NULL ; return - 2 ; } ERR_clear_error ( ) ; if ( ! SSL_CTX_set1_param ( ctx , x509_param ) ) { log_ssl_errors ( \"couldnt<S2SV_blank>add<S2SV_blank>validation<S2SV_blank>params<S2SV_blank>for<S2SV_blank>%s\" , hostname . c_str ( ) ) ; X509_VERIFY_PARAM_free ( x509_param ) ; SSL_CTX_free ( ctx ) ; ctx = NULL ; return - 2 ; } X509_VERIFY_PARAM_free ( x509_param ) ; ERR_clear_error ( ) ; ssl = SSL_new ( ctx ) ; SSL_set_options ( ssl , SSL_OP_ALL ) ; SSL_set_mode ( ssl , SSL_MODE_AUTO_RETRY ) ; SSL_set_connect_state ( ssl ) ; SSL_set_fd ( ssl , this -> getFD ( ) ) ; SSL_set_tlsext_host_name ( ssl , hostname . c_str ( ) ) ; <S2SV_StartBug> <S2SV_EndBug> ERR_clear_error ( ) ; int rc = SSL_connect ( ssl ) ; if ( rc < 0 ) { log_ssl_errors ( \"ssl_connect<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s\" , hostname . c_str ( ) ) ; # ifdef NETDEBUG std : : cout << thread_id << \"ssl_connect<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>\" << SSL_get_error ( ssl , rc ) << std : : endl ; # endif SSL_free ( ssl ) ; ssl = NULL ; SSL_CTX_free ( ctx ) ; ctx = NULL ; return - 3 ; } isssl = true ; issslserver = false ; return 0 ; }", "target": "<S2SV_ModStart> ) ) ; # if OPENSSL_VERSION_NUMBER < 0x10100000L # else X509_VERIFY_PARAM_set1_host ( SSL_get0_param ( ssl ) , hostname . c_str ( ) , 0 ) ; # endif"}
{"source": "CWE-362 int main ( int argc , char * * argv , char * * envp ) { int opt ; while ( ( opt = getopt ( argc , argv , \"b:h:k:p:q:w:z:xv\" ) ) != - 1 ) { switch ( opt ) { case 'b' : tmate_settings -> bind_addr = xstrdup ( optarg ) ; break ; case 'h' : tmate_settings -> tmate_host = xstrdup ( optarg ) ; break ; case 'k' : tmate_settings -> keys_dir = xstrdup ( optarg ) ; break ; case 'p' : tmate_settings -> ssh_port = atoi ( optarg ) ; break ; case 'q' : tmate_settings -> ssh_port_advertized = atoi ( optarg ) ; break ; case 'w' : tmate_settings -> websocket_hostname = xstrdup ( optarg ) ; break ; case 'z' : tmate_settings -> websocket_port = atoi ( optarg ) ; break ; case 'x' : tmate_settings -> use_proxy_protocol = true ; break ; case 'v' : tmate_settings -> log_level ++ ; break ; default : usage ( ) ; return 1 ; } } init_logging ( tmate_settings -> log_level ) ; setup_locale ( ) ; if ( ! tmate_settings -> tmate_host ) tmate_settings -> tmate_host = get_full_hostname ( ) ; cmdline = * argv ; cmdline_end = * envp ; tmate_preload_trace_lib ( ) ; tmate_catch_sigsegv ( ) ; tmate_init_rand ( ) ; <S2SV_StartBug> if ( ( mkdir ( TMATE_WORKDIR , 0701 ) < 0 && errno != EEXIST ) || <S2SV_EndBug> <S2SV_StartBug> ( mkdir ( TMATE_WORKDIR \"/sessions\" , 0703 ) < 0 && errno != EEXIST ) || <S2SV_EndBug> ( mkdir ( TMATE_WORKDIR \"/jail\" , 0700 ) < 0 && errno != EEXIST ) ) tmate_fatal ( \"Cannot<S2SV_blank>prepare<S2SV_blank>session<S2SV_blank>in<S2SV_blank>\" TMATE_WORKDIR ) ; <S2SV_StartBug> if ( ( chmod ( TMATE_WORKDIR , 0701 ) < 0 ) || <S2SV_EndBug> <S2SV_StartBug> ( chmod ( TMATE_WORKDIR \"/sessions\" , 0703 ) < 0 ) || <S2SV_EndBug> ( chmod ( TMATE_WORKDIR \"/jail\" , 0700 ) < 0 ) ) tmate_fatal ( \"Cannot<S2SV_blank>prepare<S2SV_blank>session<S2SV_blank>in<S2SV_blank>\" TMATE_WORKDIR ) ; <S2SV_StartBug> tmate_ssh_server_main ( tmate_session , <S2SV_EndBug> tmate_settings -> keys_dir , tmate_settings -> bind_addr , tmate_settings -> ssh_port ) ; return 0 ; }", "target": "<S2SV_ModStart> ( TMATE_WORKDIR , 0700 <S2SV_ModEnd> ) < 0 <S2SV_ModStart> TMATE_WORKDIR \"/sessions\" , 0700 <S2SV_ModEnd> ) < 0 <S2SV_ModStart> ( TMATE_WORKDIR , 0700 <S2SV_ModEnd> ) < 0 <S2SV_ModStart> TMATE_WORKDIR \"/sessions\" , 0700 <S2SV_ModEnd> ) < 0 <S2SV_ModStart> TMATE_WORKDIR ) ; if ( check_owned_directory_mode ( TMATE_WORKDIR , 0700 ) || check_owned_directory_mode ( TMATE_WORKDIR \"/sessions\" , 0700 ) || check_owned_directory_mode ( TMATE_WORKDIR \"/jail\" , 0700 ) ) tmate_fatal ( TMATE_WORKDIR \"<S2SV_blank>and<S2SV_blank>subdirectories<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>ownership/mode.<S2SV_blank>\" \"Try<S2SV_blank>deleting<S2SV_blank>\" TMATE_WORKDIR \"<S2SV_blank>and<S2SV_blank>try<S2SV_blank>again\" ) ;"}
{"source": "CWE-125 void pjmedia_rtcp_xr_rx_rtcp_xr ( pjmedia_rtcp_xr_session * sess , const void * pkt , pj_size_t size ) { const pjmedia_rtcp_xr_pkt * rtcp_xr = ( pjmedia_rtcp_xr_pkt * ) pkt ; const pjmedia_rtcp_xr_rb_rr_time * rb_rr_time = NULL ; const pjmedia_rtcp_xr_rb_dlrr * rb_dlrr = NULL ; const pjmedia_rtcp_xr_rb_stats * rb_stats = NULL ; const pjmedia_rtcp_xr_rb_voip_mtc * rb_voip_mtc = NULL ; const pjmedia_rtcp_xr_rb_header * rb_hdr = ( pjmedia_rtcp_xr_rb_header * ) rtcp_xr -> buf ; unsigned pkt_len , rb_len ; if ( rtcp_xr -> common . pt != RTCP_XR ) return ; pkt_len = pj_ntohs ( ( pj_uint16_t ) rtcp_xr -> common . length ) ; if ( ( pkt_len + 1 ) > ( size / 4 ) ) return ; while ( ( pj_int32_t * ) rb_hdr < ( pj_int32_t * ) pkt + pkt_len ) { rb_len = pj_ntohs ( ( pj_uint16_t ) rb_hdr -> length ) ; if ( rb_len ) { switch ( rb_hdr -> bt ) { case BT_RR_TIME : <S2SV_StartBug> rb_rr_time = ( pjmedia_rtcp_xr_rb_rr_time * ) rb_hdr ; <S2SV_EndBug> break ; case BT_DLRR : <S2SV_StartBug> rb_dlrr = ( pjmedia_rtcp_xr_rb_dlrr * ) rb_hdr ; <S2SV_EndBug> break ; case BT_STATS : <S2SV_StartBug> rb_stats = ( pjmedia_rtcp_xr_rb_stats * ) rb_hdr ; <S2SV_EndBug> break ; case BT_VOIP_METRICS : <S2SV_StartBug> rb_voip_mtc = ( pjmedia_rtcp_xr_rb_voip_mtc * ) rb_hdr ; <S2SV_EndBug> break ; default : break ; } } rb_hdr = ( pjmedia_rtcp_xr_rb_header * ) ( ( pj_int32_t * ) rb_hdr + rb_len + 1 ) ; } if ( rb_rr_time ) { sess -> rx_lrr = ( ( pj_ntohl ( rb_rr_time -> ntp_sec ) & 0x0000FFFF ) << 16 ) | ( ( pj_ntohl ( rb_rr_time -> ntp_frac ) >> 16 ) & 0xFFFF ) ; pj_get_timestamp ( & sess -> rx_lrr_time ) ; TRACE_ ( ( sess -> name , \"Rx<S2SV_blank>RTCP<S2SV_blank>SR:<S2SV_blank>ntp_ts=%p\" , sess -> rx_lrr , ( pj_uint32_t ) ( sess -> rx_lrr_time . u64 * 65536 / sess -> rtcp_session -> ts_freq . u64 ) ) ) ; } if ( rb_dlrr ) { pj_uint32_t lrr , now , dlrr ; pj_uint64_t eedelay ; pjmedia_rtcp_ntp_rec ntp ; lrr = pj_ntohl ( rb_dlrr -> item . lrr ) ; dlrr = pj_ntohl ( rb_dlrr -> item . dlrr ) ; pjmedia_rtcp_get_ntp_time ( sess -> rtcp_session , & ntp ) ; now = ( ( ntp . hi & 0xFFFF ) << 16 ) + ( ntp . lo >> 16 ) ; eedelay = now - lrr - dlrr ; if ( eedelay < 4294 ) { eedelay = ( eedelay * 1000000 ) >> 16 ; } else { eedelay = ( eedelay * 1000 ) >> 16 ; eedelay *= 1000 ; } TRACE_ ( ( sess -> name , \"Rx<S2SV_blank>RTCP<S2SV_blank>XR<S2SV_blank>DLRR:<S2SV_blank>lrr=%p,<S2SV_blank>dlrr=%p<S2SV_blank>(%d:%03dms),<S2SV_blank>\" \"now=%p,<S2SV_blank>rtt=%p\" , lrr , dlrr , dlrr / 65536 , ( dlrr % 65536 ) * 1000 / 65536 , now , ( pj_uint32_t ) eedelay ) ) ; if ( now - dlrr >= lrr ) { unsigned rtt = ( pj_uint32_t ) eedelay ; if ( eedelay <= 30 * 1000 * 1000UL ) { if ( rtt > ( ( unsigned ) sess -> stat . rtt . mean * 3 ) && sess -> stat . rtt . n != 0 ) { unsigned orig_rtt = rtt ; rtt = ( unsigned ) sess -> stat . rtt . mean * 3 ; PJ_LOG ( 5 , ( sess -> name , \"RTT<S2SV_blank>value<S2SV_blank>%d<S2SV_blank>usec<S2SV_blank>is<S2SV_blank>normalized<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>usec\" , orig_rtt , rtt ) ) ; } TRACE_ ( ( sess -> name , \"RTCP<S2SV_blank>RTT<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>usec\" , rtt ) ) ; pj_math_stat_update ( & sess -> stat . rtt , rtt ) ; } } else { PJ_LOG ( 5 , ( sess -> name , \"Internal<S2SV_blank>RTCP<S2SV_blank>NTP<S2SV_blank>clock<S2SV_blank>skew<S2SV_blank>detected:<S2SV_blank>\" \"lrr=%p,<S2SV_blank>now=%p,<S2SV_blank>dlrr=%p<S2SV_blank>(%d:%03dms),<S2SV_blank>\" \"diff=%d\" , lrr , now , dlrr , dlrr / 65536 , ( dlrr % 65536 ) * 1000 / 65536 , dlrr - ( now - lrr ) ) ) ; } } if ( rb_stats ) { pj_uint8_t flags = rb_stats -> header . specific ; pj_bzero ( & sess -> stat . tx . stat_sum , sizeof ( sess -> stat . tx . stat_sum ) ) ; sess -> stat . tx . stat_sum . begin_seq = pj_ntohs ( rb_stats -> begin_seq ) ; sess -> stat . tx . stat_sum . end_seq = pj_ntohs ( rb_stats -> end_seq ) ; sess -> stat . tx . stat_sum . l = ( flags & ( 1 << 7 ) ) != 0 ; sess -> stat . tx . stat_sum . d = ( flags & ( 1 << 6 ) ) != 0 ; sess -> stat . tx . stat_sum . j = ( flags & ( 1 << 5 ) ) != 0 ; sess -> stat . tx . stat_sum . t = ( flags & ( 3 << 3 ) ) != 0 ; if ( sess -> stat . tx . stat_sum . l ) { sess -> stat . tx . stat_sum . lost = pj_ntohl ( rb_stats -> lost ) ; } if ( sess -> stat . tx . stat_sum . d ) { sess -> stat . tx . stat_sum . dup = pj_ntohl ( rb_stats -> dup ) ; } if ( sess -> stat . tx . stat_sum . j ) { sess -> stat . tx . stat_sum . jitter . min = pj_ntohl ( rb_stats -> jitter_min ) ; sess -> stat . tx . stat_sum . jitter . max = pj_ntohl ( rb_stats -> jitter_max ) ; sess -> stat . tx . stat_sum . jitter . mean = pj_ntohl ( rb_stats -> jitter_mean ) ; pj_math_stat_set_stddev ( & sess -> stat . tx . stat_sum . jitter , pj_ntohl ( rb_stats -> jitter_dev ) ) ; } if ( sess -> stat . tx . stat_sum . t ) { sess -> stat . tx . stat_sum . toh . min = rb_stats -> toh_min ; sess -> stat . tx . stat_sum . toh . max = rb_stats -> toh_max ; sess -> stat . tx . stat_sum . toh . mean = rb_stats -> toh_mean ; pj_math_stat_set_stddev ( & sess -> stat . tx . stat_sum . toh , pj_ntohl ( rb_stats -> toh_dev ) ) ; } pj_gettimeofday ( & sess -> stat . tx . stat_sum . update ) ; } if ( rb_voip_mtc ) { sess -> stat . tx . voip_mtc . loss_rate = rb_voip_mtc -> loss_rate ; sess -> stat . tx . voip_mtc . discard_rate = rb_voip_mtc -> discard_rate ; sess -> stat . tx . voip_mtc . burst_den = rb_voip_mtc -> burst_den ; sess -> stat . tx . voip_mtc . gap_den = rb_voip_mtc -> gap_den ; sess -> stat . tx . voip_mtc . burst_dur = pj_ntohs ( rb_voip_mtc -> burst_dur ) ; sess -> stat . tx . voip_mtc . gap_dur = pj_ntohs ( rb_voip_mtc -> gap_dur ) ; sess -> stat . tx . voip_mtc . rnd_trip_delay = pj_ntohs ( rb_voip_mtc -> rnd_trip_delay ) ; sess -> stat . tx . voip_mtc . end_sys_delay = pj_ntohs ( rb_voip_mtc -> end_sys_delay ) ; sess -> stat . tx . voip_mtc . signal_lvl = ( pj_int8_t ) ( ( rb_voip_mtc -> signal_lvl > 127 ) ? ( ( int ) rb_voip_mtc -> signal_lvl - 256 ) : rb_voip_mtc -> signal_lvl ) ; sess -> stat . tx . voip_mtc . noise_lvl = ( pj_int8_t ) ( ( rb_voip_mtc -> noise_lvl > 127 ) ? ( ( int ) rb_voip_mtc -> noise_lvl - 256 ) : rb_voip_mtc -> noise_lvl ) ; sess -> stat . tx . voip_mtc . rerl = rb_voip_mtc -> rerl ; sess -> stat . tx . voip_mtc . gmin = rb_voip_mtc -> gmin ; sess -> stat . tx . voip_mtc . r_factor = rb_voip_mtc -> r_factor ; sess -> stat . tx . voip_mtc . ext_r_factor = rb_voip_mtc -> ext_r_factor ; sess -> stat . tx . voip_mtc . mos_lq = rb_voip_mtc -> mos_lq ; sess -> stat . tx . voip_mtc . mos_cq = rb_voip_mtc -> mos_cq ; sess -> stat . tx . voip_mtc . rx_config = rb_voip_mtc -> rx_config ; sess -> stat . tx . voip_mtc . jb_nom = pj_ntohs ( rb_voip_mtc -> jb_nom ) ; sess -> stat . tx . voip_mtc . jb_max = pj_ntohs ( rb_voip_mtc -> jb_max ) ; sess -> stat . tx . voip_mtc . jb_abs_max = pj_ntohs ( rb_voip_mtc -> jb_abs_max ) ; pj_gettimeofday ( & sess -> stat . tx . voip_mtc . update ) ; } }", "target": "<S2SV_ModStart> case BT_RR_TIME : if ( ( char * ) rb_hdr + sizeof ( * rb_rr_time ) <= ( char * ) pkt + size ) { rb_rr_time <S2SV_ModEnd> = ( pjmedia_rtcp_xr_rb_rr_time <S2SV_ModStart> ) rb_hdr ; } <S2SV_ModStart> case BT_DLRR : if ( ( char * ) rb_hdr + sizeof ( * rb_dlrr ) <= ( char * ) pkt + size ) { rb_dlrr <S2SV_ModEnd> = ( pjmedia_rtcp_xr_rb_dlrr <S2SV_ModStart> ) rb_hdr ; } <S2SV_ModStart> case BT_STATS : if ( ( char * ) rb_hdr + sizeof ( * rb_stats ) <= ( char * ) pkt + size ) { rb_stats <S2SV_ModEnd> = ( pjmedia_rtcp_xr_rb_stats <S2SV_ModStart> ) rb_hdr ; } <S2SV_ModStart> case BT_VOIP_METRICS : if ( ( char * ) rb_hdr + sizeof ( * rb_voip_mtc ) <= ( char * ) pkt + size ) { <S2SV_ModStart> ) rb_hdr ; }"}
{"source": "CWE-476 s32 gf_avc_parse_nalu ( GF_BitStream * bs , AVCState * avc ) { u8 idr_flag ; s32 slice , ret ; u32 nal_hdr ; AVCSliceInfo n_state ; gf_bs_enable_emulation_byte_removal ( bs , GF_TRUE ) ; nal_hdr = gf_bs_read_u8 ( bs ) ; slice = 0 ; memcpy ( & n_state , & avc -> s_info , sizeof ( AVCSliceInfo ) ) ; avc -> last_nal_type_parsed = n_state . nal_unit_type = nal_hdr & 0x1F ; n_state . nal_ref_idc = ( nal_hdr >> 5 ) & 0x3 ; idr_flag = 0 ; switch ( n_state . nal_unit_type ) { case GF_AVC_NALU_ACCESS_UNIT : case GF_AVC_NALU_END_OF_SEQ : case GF_AVC_NALU_END_OF_STREAM : ret = 1 ; break ; case GF_AVC_NALU_SVC_SLICE : SVC_ReadNal_header_extension ( bs , & n_state . NalHeader ) ; svc_parse_slice ( bs , avc , & n_state ) ; if ( avc -> s_info . nal_ref_idc ) { n_state . poc_lsb_prev = avc -> s_info . poc_lsb ; n_state . poc_msb_prev = avc -> s_info . poc_msb ; } avc_compute_poc ( & n_state ) ; if ( avc -> s_info . poc != n_state . poc ) { memcpy ( & avc -> s_info , & n_state , sizeof ( AVCSliceInfo ) ) ; return 1 ; } memcpy ( & avc -> s_info , & n_state , sizeof ( AVCSliceInfo ) ) ; return 0 ; case GF_AVC_NALU_SVC_PREFIX_NALU : SVC_ReadNal_header_extension ( bs , & n_state . NalHeader ) ; return 0 ; case GF_AVC_NALU_IDR_SLICE : case GF_AVC_NALU_NON_IDR_SLICE : case GF_AVC_NALU_DP_A_SLICE : case GF_AVC_NALU_DP_B_SLICE : case GF_AVC_NALU_DP_C_SLICE : slice = 1 ; ret = avc_parse_slice ( bs , avc , idr_flag , & n_state ) ; if ( ret < 0 ) return ret ; ret = 0 ; if ( ( ( avc -> s_info . nal_unit_type > GF_AVC_NALU_IDR_SLICE ) || ( avc -> s_info . nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE ) ) && ( avc -> s_info . nal_unit_type != GF_AVC_NALU_SVC_SLICE ) ) { break ; } if ( avc -> s_info . frame_num != n_state . frame_num ) { ret = 1 ; break ; } if ( avc -> s_info . field_pic_flag != n_state . field_pic_flag ) { ret = 1 ; break ; } if ( ( avc -> s_info . nal_ref_idc != n_state . nal_ref_idc ) && ( ! avc -> s_info . nal_ref_idc || ! n_state . nal_ref_idc ) ) { ret = 1 ; break ; } <S2SV_StartBug> assert ( avc -> s_info . sps ) ; <S2SV_EndBug> if ( avc -> s_info . sps -> poc_type == n_state . sps -> poc_type ) { if ( ! avc -> s_info . sps -> poc_type ) { if ( ! n_state . bottom_field_flag && ( avc -> s_info . poc_lsb != n_state . poc_lsb ) ) { ret = 1 ; break ; } if ( avc -> s_info . delta_poc_bottom != n_state . delta_poc_bottom ) { ret = 1 ; break ; } } else if ( avc -> s_info . sps -> poc_type == 1 ) { if ( avc -> s_info . delta_poc [ 0 ] != n_state . delta_poc [ 0 ] ) { ret = 1 ; break ; } if ( avc -> s_info . delta_poc [ 1 ] != n_state . delta_poc [ 1 ] ) { ret = 1 ; break ; } } } if ( n_state . nal_unit_type == GF_AVC_NALU_IDR_SLICE ) { if ( avc -> s_info . nal_unit_type != GF_AVC_NALU_IDR_SLICE ) { ret = 1 ; break ; } else if ( avc -> s_info . idr_pic_id != n_state . idr_pic_id ) { ret = 1 ; break ; } } break ; case GF_AVC_NALU_SEQ_PARAM : avc -> last_ps_idx = gf_avc_read_sps_bs_internal ( bs , avc , 0 , NULL , nal_hdr ) ; if ( avc -> last_ps_idx < 0 ) return - 1 ; return 0 ; case GF_AVC_NALU_PIC_PARAM : avc -> last_ps_idx = gf_avc_read_pps_bs_internal ( bs , avc , nal_hdr ) ; if ( avc -> last_ps_idx < 0 ) return - 1 ; return 0 ; case GF_AVC_NALU_SVC_SUBSEQ_PARAM : avc -> last_ps_idx = gf_avc_read_sps_bs_internal ( bs , avc , 1 , NULL , nal_hdr ) ; if ( avc -> last_ps_idx < 0 ) return - 1 ; return 0 ; case GF_AVC_NALU_SEQ_PARAM_EXT : avc -> last_ps_idx = ( s32 ) gf_bs_read_ue ( bs ) ; if ( avc -> last_ps_idx < 0 ) return - 1 ; return 0 ; case GF_AVC_NALU_SEI : case GF_AVC_NALU_FILLER_DATA : return 0 ; default : if ( avc -> s_info . nal_unit_type <= GF_AVC_NALU_IDR_SLICE ) ret = 1 ; else if ( ( nal_hdr & 0x1F ) == GF_AVC_NALU_SEI && avc -> s_info . nal_unit_type == GF_AVC_NALU_SVC_SLICE ) ret = 1 ; else if ( ( nal_hdr & 0x1F ) == GF_AVC_NALU_SEQ_PARAM && avc -> s_info . nal_unit_type == GF_AVC_NALU_SVC_SLICE ) ret = 1 ; else ret = 0 ; break ; } if ( ret && avc -> s_info . sps ) { n_state . frame_num_offset_prev = avc -> s_info . frame_num_offset ; if ( ( avc -> s_info . sps -> poc_type != 2 ) || ( avc -> s_info . nal_ref_idc != 0 ) ) n_state . frame_num_prev = avc -> s_info . frame_num ; if ( avc -> s_info . nal_ref_idc ) { n_state . poc_lsb_prev = avc -> s_info . poc_lsb ; n_state . poc_msb_prev = avc -> s_info . poc_msb ; } } if ( slice ) avc_compute_poc ( & n_state ) ; memcpy ( & avc -> s_info , & n_state , sizeof ( AVCSliceInfo ) ) ; return ret ; }", "target": "<S2SV_ModStart> break ; } if ( ! <S2SV_ModEnd> avc -> s_info <S2SV_ModStart> . sps ) return - 1"}
{"source": "CWE-787 Status SetUnknownShape ( const NodeDef * node , int output_port ) { shape_inference : : ShapeHandle shape = GetUnknownOutputShape ( node , output_port ) ; InferenceContext * ctx = GetContext ( node ) ; if ( ctx == nullptr ) { <S2SV_StartBug> return errors : : InvalidArgument ( \"Missing<S2SV_blank>context\" ) ; <S2SV_EndBug> } ctx -> set_output ( output_port , shape ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> : InvalidArgument ( \"SetUnknownShape:<S2SV_blank>Missing<S2SV_blank>context\" ) ; } if ( output_port < 0 || output_port >= ctx -> num_outputs ( ) ) { return errors : : InvalidArgument ( \"SetUnknownShape:<S2SV_blank>output_port<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>[0,<S2SV_blank>\" , ctx -> num_outputs ( ) , \")<S2SV_blank>but<S2SV_blank>was<S2SV_blank>\" , output_port <S2SV_ModEnd> ) ; }"}
{"source": "CWE-617 Status BuildInputArgIndex ( const OpDef : : ArgDef & arg_def , AttrSlice attr_values , const FunctionDef : : ArgAttrs * arg_attrs , bool ints_on_device , int64_t resource_arg_unique_id ) { bool is_type_list ; DataTypeVector dtypes ; TF_RETURN_IF_ERROR ( ArgNumType ( attr_values , arg_def , & is_type_list , & dtypes ) ) ; if ( dtypes . size ( ) < size_t { 1 } ) { return errors : : Internal ( \"Expected<S2SV_blank>a<S2SV_blank>list<S2SV_blank>of<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>dtype\" ) ; } int arg_index = result_ . nodes . size ( ) ; TF_RETURN_IF_ERROR ( AddItem ( arg_def . name ( ) , { true , arg_index , 0 , is_type_list , dtypes } ) ) ; for ( size_t i = 0 ; i < dtypes . size ( ) ; ++ i ) { TF_RETURN_IF_ERROR ( AddItem ( strings : : StrCat ( arg_def . name ( ) , \":\" , i ) , { true , arg_index , 0 , false , { dtypes [ i ] } } ) ) ; <S2SV_StartBug> DCHECK_EQ ( arg_index , result_ . nodes . size ( ) ) ; <S2SV_EndBug> string name = arg_def . name ( ) ; if ( dtypes . size ( ) > 1 ) { strings : : StrAppend ( & name , \"_\" , i ) ; } NodeDef * gnode = AddNode ( name ) ; if ( ints_on_device && dtypes [ i ] == DataType : : DT_INT32 ) { gnode -> set_op ( FunctionLibraryDefinition : : kDeviceArgOp ) ; } else { gnode -> set_op ( FunctionLibraryDefinition : : kArgOp ) ; } DataType dtype = arg_def . is_ref ( ) ? MakeRefType ( dtypes [ i ] ) : dtypes [ i ] ; AddAttr ( \"T\" , dtype , gnode ) ; AddAttr ( \"index\" , arg_index , gnode ) ; if ( resource_arg_unique_id >= 0 ) { AddAttr ( \"_resource_arg_unique_id\" , resource_arg_unique_id , gnode ) ; } if ( arg_attrs ) { for ( const auto & arg_attr : arg_attrs -> attr ( ) ) { AddAttr ( arg_attr . first , arg_attr . second , gnode -> mutable_attr ( ) ) ; } } result_ . arg_types . push_back ( dtypes [ i ] ) ; ++ arg_index ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ) ) ; if ( arg_index != <S2SV_ModEnd> result_ . nodes <S2SV_ModStart> ( ) ) { return errors : : Internal ( \"Expected<S2SV_blank>arg_index<S2SV_blank>to<S2SV_blank>be<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>nodes<S2SV_blank>in<S2SV_blank>result.\" , \"<S2SV_blank>Got<S2SV_blank>\" , arg_index , \"<S2SV_blank>and<S2SV_blank>\" , result_ . nodes . size ( ) ) ; } <S2SV_ModEnd> string name ="}
{"source": "CWE-190 static Image * ReadPCLImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define CropBox \"CropBox\" # define DeviceCMYK \"DeviceCMYK\" # define MediaBox \"MediaBox\" # define RenderPCLText \"<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>PCL...<S2SV_blank><S2SV_blank>\" char command [ MagickPathExtent ] , * density , filename [ MagickPathExtent ] , geometry [ MagickPathExtent ] , * options , input_filename [ MagickPathExtent ] ; const DelegateInfo * delegate_info ; Image * image , * next_image ; ImageInfo * read_info ; MagickBooleanType cmyk , status ; PointInfo delta ; RectangleInfo bounding_box , page ; char * p ; ssize_t c ; SegmentInfo bounds ; size_t height , width ; ssize_t count ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> resolution . x == 0.0 ) || ( image -> resolution . y == 0.0 ) ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; if ( ( flags & RhoValue ) != 0 ) image -> resolution . x = geometry_info . rho ; image -> resolution . y = image -> resolution . x ; if ( ( flags & SigmaValue ) != 0 ) image -> resolution . y = geometry_info . sigma ; } cmyk = image -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; count = 0 ; ( void ) memset ( & bounding_box , 0 , sizeof ( bounding_box ) ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( & page , 0 , sizeof ( page ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { if ( image_info -> page != ( char * ) NULL ) continue ; * p ++ = ( char ) c ; if ( ( c != ( int ) '/' ) && ( c != '\\\\n' ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( DeviceCMYK , command , strlen ( DeviceCMYK ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CropBox , command , strlen ( CropBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , \"CropBox<S2SV_blank>[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; if ( count != 4 ) count = ( ssize_t ) sscanf ( command , \"CropBox[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; } if ( LocaleNCompare ( MediaBox , command , strlen ( MediaBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , \"MediaBox<S2SV_blank>[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; if ( count != 4 ) count = ( ssize_t ) sscanf ( command , \"MediaBox[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; } if ( count != 4 ) continue ; <S2SV_StartBug> width = ( size_t ) floor ( bounds . x2 - bounds . x1 + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> height = ( size_t ) floor ( bounds . y2 - bounds . y1 + 0.5 ) ; <S2SV_EndBug> if ( width > page . width ) page . width = width ; if ( height > page . height ) page . height = height ; } ( void ) CloseBlob ( image ) ; if ( ( page . width == 0 ) || ( page . height == 0 ) ) ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , \"%.20gx%.20g\" , ( double ) page . width , ( double ) page . height ) ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( \"pcl:mono\" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( \"pcl:cmyk\" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( \"pcl:color\" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } if ( ( page . width == 0 ) || ( page . height == 0 ) ) ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; density = AcquireString ( \"\" ) ; options = AcquireString ( \"\" ) ; ( void ) FormatLocaleString ( density , MagickPathExtent , \"%gx%g\" , image -> resolution . x , image -> resolution . y ) ; if ( image_info -> ping != MagickFalse ) ( void ) FormatLocaleString ( density , MagickPathExtent , \"2.0x2.0\" ) ; page . width = ( size_t ) floor ( page . width * image -> resolution . x / delta . x + 0.5 ) ; page . height = ( size_t ) floor ( page . height * image -> resolution . y / delta . y + 0.5 ) ; ( void ) FormatLocaleString ( options , MagickPathExtent , \"-g%.20gx%.20g<S2SV_blank>\" , ( double ) page . width , ( double ) page . height ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\\\0' ; if ( read_info -> number_scenes != 0 ) { if ( read_info -> number_scenes != 1 ) ( void ) FormatLocaleString ( options , MagickPathExtent , \"-dLastPage=%.20g\" , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; else ( void ) FormatLocaleString ( options , MagickPathExtent , \"-dFirstPage=%.20g<S2SV_blank>-dLastPage=%.20g\" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\\\0' ; } ( void ) CopyMagickString ( filename , read_info -> filename , MagickPathExtent ) ; ( void ) AcquireUniqueFilename ( read_info -> filename ) ; ( void ) FormatLocaleString ( command , MagickPathExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , read_info -> filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; status = ExternalDelegateCommand ( MagickFalse , read_info -> verbose , command , ( char * ) NULL , exception ) != 0 ? MagickTrue : MagickFalse ; image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image == ( Image * ) NULL ) ThrowReaderException ( DelegateError , \"PCLDelegateFailed\" ) ; if ( LocaleCompare ( image -> magick , \"BMP\" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { image = DestroyImageList ( image ) ; image = cmyk_image ; } } do { ( void ) CopyMagickString ( image -> filename , filename , MagickPathExtent ) ; image -> page = page ; if ( image_info -> ping != MagickFalse ) { image -> magick_columns *= image -> resolution . x / 2.0 ; image -> magick_rows *= image -> resolution . y / 2.0 ; image -> columns *= image -> resolution . x / 2.0 ; image -> rows *= image -> resolution . y / 2.0 ; } next_image = SyncNextImageInList ( image ) ; if ( next_image != ( Image * ) NULL ) image = next_image ; } while ( next_image != ( Image * ) NULL ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> ( size_t ) CastDoubleToLong ( <S2SV_ModStart> + 0.5 ) ) <S2SV_ModStart> ( size_t ) CastDoubleToLong ( <S2SV_ModStart> y1 + 0.5 )"}
{"source": "CWE-125 static void compile_xclass_matchingpath ( compiler_common * common , PCRE2_SPTR cc , jump_list * * backtracks ) { DEFINE_COMPILER ; jump_list * found = NULL ; jump_list * * list = ( cc [ 0 ] & XCL_NOT ) == 0 ? & found : backtracks ; sljit_uw c , charoffset , max = 256 , min = READ_CHAR_MAX ; struct sljit_jump * jump = NULL ; PCRE2_SPTR ccbegin ; int compares , invertcmp , numberofcmps ; # if defined SUPPORT_UNICODE && ( PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 ) BOOL utf = common -> utf ; # endif # ifdef SUPPORT_UNICODE sljit_u32 unicode_status = 0 ; int typereg = TMP1 ; const sljit_u32 * other_cases ; sljit_uw typeoffset ; # endif cc ++ ; ccbegin = cc ; compares = 0 ; if ( cc [ - 1 ] & XCL_MAP ) { min = 0 ; cc += 32 / sizeof ( PCRE2_UCHAR ) ; } while ( * cc != XCL_END ) { compares ++ ; if ( * cc == XCL_SINGLE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; if ( c > max ) max = c ; if ( c < min ) min = c ; # ifdef SUPPORT_UNICODE unicode_status |= XCLASS_SAVE_CHAR ; # endif } else if ( * cc == XCL_RANGE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; if ( c < min ) min = c ; GETCHARINCTEST ( c , cc ) ; if ( c > max ) max = c ; # ifdef SUPPORT_UNICODE unicode_status |= XCLASS_SAVE_CHAR ; # endif } # ifdef SUPPORT_UNICODE else { SLJIT_ASSERT ( * cc == XCL_PROP || * cc == XCL_NOTPROP ) ; cc ++ ; <S2SV_StartBug> if ( * cc == PT_CLIST && * cc == XCL_PROP ) <S2SV_EndBug> { other_cases = PRIV ( ucd_caseless_sets ) + cc [ 1 ] ; while ( * other_cases != NOTACHAR ) { if ( * other_cases > max ) max = * other_cases ; if ( * other_cases < min ) min = * other_cases ; other_cases ++ ; } } else { max = READ_CHAR_MAX ; min = 0 ; } switch ( * cc ) { case PT_ANY : if ( cc [ - 1 ] == XCL_PROP ) { compile_char1_matchingpath ( common , OP_ALLANY , cc , backtracks , FALSE ) ; if ( list == backtracks ) add_jump ( compiler , backtracks , JUMP ( SLJIT_JUMP ) ) ; return ; } break ; case PT_LAMP : case PT_GC : case PT_PC : case PT_ALNUM : unicode_status |= XCLASS_HAS_TYPE ; break ; case PT_SCX : unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION ; if ( cc [ - 1 ] == XCL_NOTPROP ) { unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP ; break ; } compares ++ ; case PT_SC : unicode_status |= XCLASS_HAS_SCRIPT ; break ; case PT_SPACE : case PT_PXSPACE : case PT_WORD : case PT_PXGRAPH : case PT_PXPRINT : case PT_PXPUNCT : unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE ; break ; case PT_CLIST : case PT_UCNC : unicode_status |= XCLASS_SAVE_CHAR ; break ; case PT_BOOL : unicode_status |= XCLASS_HAS_BOOL ; break ; case PT_BIDICL : unicode_status |= XCLASS_HAS_BIDICL ; break ; default : SLJIT_UNREACHABLE ( ) ; break ; } cc += 2 ; } # endif } SLJIT_ASSERT ( compares > 0 ) ; cc = ccbegin ; if ( ( cc [ - 1 ] & XCL_NOT ) != 0 ) read_char ( common , min , max , backtracks , READ_CHAR_UPDATE_STR_PTR ) ; else { # ifdef SUPPORT_UNICODE read_char ( common , min , max , ( unicode_status & XCLASS_NEEDS_UCD ) ? backtracks : NULL , 0 ) ; # else read_char ( common , min , max , NULL , 0 ) ; # endif } if ( ( cc [ - 1 ] & XCL_HASPROP ) == 0 ) { if ( ( cc [ - 1 ] & XCL_MAP ) != 0 ) { jump = CMP ( SLJIT_GREATER , TMP1 , 0 , SLJIT_IMM , 255 ) ; if ( ! optimize_class ( common , ( const sljit_u8 * ) cc , ( ( ( const sljit_u8 * ) cc ) [ 31 ] & 0x80 ) != 0 , TRUE , & found ) ) { OP2 ( SLJIT_AND , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , 0x7 ) ; OP2 ( SLJIT_LSHR , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , 3 ) ; OP1 ( SLJIT_MOV_U8 , TMP1 , 0 , SLJIT_MEM1 ( TMP1 ) , ( sljit_sw ) cc ) ; OP2 ( SLJIT_SHL , TMP2 , 0 , SLJIT_IMM , 1 , TMP2 , 0 ) ; OP2U ( SLJIT_AND | SLJIT_SET_Z , TMP1 , 0 , TMP2 , 0 ) ; add_jump ( compiler , & found , JUMP ( SLJIT_NOT_ZERO ) ) ; } add_jump ( compiler , backtracks , JUMP ( SLJIT_JUMP ) ) ; JUMPHERE ( jump ) ; cc += 32 / sizeof ( PCRE2_UCHAR ) ; } else { OP2 ( SLJIT_SUB , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , min ) ; add_jump ( compiler , ( cc [ - 1 ] & XCL_NOT ) == 0 ? backtracks : & found , CMP ( SLJIT_GREATER , TMP2 , 0 , SLJIT_IMM , max - min ) ) ; } } else if ( ( cc [ - 1 ] & XCL_MAP ) != 0 ) { OP1 ( SLJIT_MOV , RETURN_ADDR , 0 , TMP1 , 0 ) ; # ifdef SUPPORT_UNICODE unicode_status |= XCLASS_CHAR_SAVED ; # endif if ( ! optimize_class ( common , ( const sljit_u8 * ) cc , FALSE , TRUE , list ) ) { # if PCRE2_CODE_UNIT_WIDTH == 8 jump = NULL ; if ( common -> utf ) # endif jump = CMP ( SLJIT_GREATER , TMP1 , 0 , SLJIT_IMM , 255 ) ; OP2 ( SLJIT_AND , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , 0x7 ) ; OP2 ( SLJIT_LSHR , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , 3 ) ; OP1 ( SLJIT_MOV_U8 , TMP1 , 0 , SLJIT_MEM1 ( TMP1 ) , ( sljit_sw ) cc ) ; OP2 ( SLJIT_SHL , TMP2 , 0 , SLJIT_IMM , 1 , TMP2 , 0 ) ; OP2U ( SLJIT_AND | SLJIT_SET_Z , TMP1 , 0 , TMP2 , 0 ) ; add_jump ( compiler , list , JUMP ( SLJIT_NOT_ZERO ) ) ; # if PCRE2_CODE_UNIT_WIDTH == 8 if ( common -> utf ) # endif JUMPHERE ( jump ) ; } OP1 ( SLJIT_MOV , TMP1 , 0 , RETURN_ADDR , 0 ) ; cc += 32 / sizeof ( PCRE2_UCHAR ) ; } # ifdef SUPPORT_UNICODE if ( unicode_status & XCLASS_NEEDS_UCD ) { if ( ( unicode_status & ( XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED ) ) == XCLASS_SAVE_CHAR ) OP1 ( SLJIT_MOV , RETURN_ADDR , 0 , TMP1 , 0 ) ; # if PCRE2_CODE_UNIT_WIDTH == 32 if ( ! common -> utf ) { jump = CMP ( SLJIT_LESS , TMP1 , 0 , SLJIT_IMM , MAX_UTF_CODE_POINT + 1 ) ; OP1 ( SLJIT_MOV , TMP1 , 0 , SLJIT_IMM , UNASSIGNED_UTF_CHAR ) ; JUMPHERE ( jump ) ; } # endif OP2 ( SLJIT_LSHR , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , UCD_BLOCK_SHIFT ) ; OP2 ( SLJIT_SHL , TMP2 , 0 , TMP2 , 0 , SLJIT_IMM , 1 ) ; OP1 ( SLJIT_MOV_U16 , TMP2 , 0 , SLJIT_MEM1 ( TMP2 ) , ( sljit_sw ) PRIV ( ucd_stage1 ) ) ; OP2 ( SLJIT_AND , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , UCD_BLOCK_MASK ) ; OP2 ( SLJIT_SHL , TMP2 , 0 , TMP2 , 0 , SLJIT_IMM , UCD_BLOCK_SHIFT ) ; OP2 ( SLJIT_ADD , TMP1 , 0 , TMP1 , 0 , TMP2 , 0 ) ; OP1 ( SLJIT_MOV , TMP2 , 0 , SLJIT_IMM , ( sljit_sw ) PRIV ( ucd_stage2 ) ) ; OP1 ( SLJIT_MOV_U16 , TMP2 , 0 , SLJIT_MEM2 ( TMP2 , TMP1 ) , 1 ) ; OP2 ( SLJIT_SHL , TMP1 , 0 , TMP2 , 0 , SLJIT_IMM , 3 ) ; OP2 ( SLJIT_SHL , TMP2 , 0 , TMP2 , 0 , SLJIT_IMM , 2 ) ; OP2 ( SLJIT_ADD , TMP2 , 0 , TMP2 , 0 , TMP1 , 0 ) ; ccbegin = cc ; if ( unicode_status & XCLASS_HAS_BIDICL ) { OP1 ( SLJIT_MOV_U16 , TMP1 , 0 , SLJIT_MEM1 ( TMP2 ) , ( sljit_sw ) PRIV ( ucd_records ) + SLJIT_OFFSETOF ( ucd_record , scriptx_bidiclass ) ) ; OP2 ( SLJIT_LSHR , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , UCD_BIDICLASS_SHIFT ) ; while ( * cc != XCL_END ) { if ( * cc == XCL_SINGLE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; } else if ( * cc == XCL_RANGE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; GETCHARINCTEST ( c , cc ) ; } else { SLJIT_ASSERT ( * cc == XCL_PROP || * cc == XCL_NOTPROP ) ; cc ++ ; if ( * cc == PT_BIDICL ) { compares -- ; invertcmp = ( compares == 0 && list != backtracks ) ; if ( cc [ - 1 ] == XCL_NOTPROP ) invertcmp ^= 0x1 ; jump = CMP ( SLJIT_EQUAL ^ invertcmp , TMP1 , 0 , SLJIT_IMM , ( int ) cc [ 1 ] ) ; add_jump ( compiler , compares > 0 ? list : backtracks , jump ) ; } cc += 2 ; } } cc = ccbegin ; } if ( unicode_status & XCLASS_HAS_BOOL ) { OP1 ( SLJIT_MOV_U16 , TMP1 , 0 , SLJIT_MEM1 ( TMP2 ) , ( sljit_sw ) PRIV ( ucd_records ) + SLJIT_OFFSETOF ( ucd_record , bprops ) ) ; OP2 ( SLJIT_AND , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , UCD_BPROPS_MASK ) ; OP2 ( SLJIT_SHL , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , 2 ) ; while ( * cc != XCL_END ) { if ( * cc == XCL_SINGLE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; } else if ( * cc == XCL_RANGE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; GETCHARINCTEST ( c , cc ) ; } else { SLJIT_ASSERT ( * cc == XCL_PROP || * cc == XCL_NOTPROP ) ; cc ++ ; if ( * cc == PT_BOOL ) { compares -- ; invertcmp = ( compares == 0 && list != backtracks ) ; if ( cc [ - 1 ] == XCL_NOTPROP ) invertcmp ^= 0x1 ; OP2U ( SLJIT_AND32 | SLJIT_SET_Z , SLJIT_MEM1 ( TMP1 ) , ( sljit_sw ) ( PRIV ( ucd_boolprop_sets ) + ( cc [ 1 ] >> 5 ) ) , SLJIT_IMM , ( sljit_sw ) 1 << ( cc [ 1 ] & 0x1f ) ) ; add_jump ( compiler , compares > 0 ? list : backtracks , JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ) ; } cc += 2 ; } } cc = ccbegin ; } if ( unicode_status & XCLASS_HAS_SCRIPT ) { OP1 ( SLJIT_MOV_U8 , TMP1 , 0 , SLJIT_MEM1 ( TMP2 ) , ( sljit_sw ) PRIV ( ucd_records ) + SLJIT_OFFSETOF ( ucd_record , script ) ) ; while ( * cc != XCL_END ) { if ( * cc == XCL_SINGLE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; } else if ( * cc == XCL_RANGE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; GETCHARINCTEST ( c , cc ) ; } else { SLJIT_ASSERT ( * cc == XCL_PROP || * cc == XCL_NOTPROP ) ; cc ++ ; switch ( * cc ) { case PT_SCX : if ( cc [ - 1 ] == XCL_NOTPROP ) break ; case PT_SC : compares -- ; invertcmp = ( compares == 0 && list != backtracks ) ; if ( cc [ - 1 ] == XCL_NOTPROP ) invertcmp ^= 0x1 ; add_jump ( compiler , compares > 0 ? list : backtracks , CMP ( SLJIT_EQUAL ^ invertcmp , TMP1 , 0 , SLJIT_IMM , ( int ) cc [ 1 ] ) ) ; } cc += 2 ; } } cc = ccbegin ; } if ( unicode_status & XCLASS_HAS_SCRIPT_EXTENSION ) { OP1 ( SLJIT_MOV_U16 , TMP1 , 0 , SLJIT_MEM1 ( TMP2 ) , ( sljit_sw ) PRIV ( ucd_records ) + SLJIT_OFFSETOF ( ucd_record , scriptx_bidiclass ) ) ; OP2 ( SLJIT_AND , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , UCD_SCRIPTX_MASK ) ; OP2 ( SLJIT_SHL , TMP1 , 0 , TMP1 , 0 , SLJIT_IMM , 2 ) ; if ( unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP ) { if ( unicode_status & XCLASS_HAS_TYPE ) { if ( unicode_status & XCLASS_SAVE_CHAR ) { OP1 ( SLJIT_MOV , SLJIT_MEM1 ( SLJIT_SP ) , LOCALS0 , TMP2 , 0 ) ; unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0 ; } else { OP1 ( SLJIT_MOV , RETURN_ADDR , 0 , TMP2 , 0 ) ; unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR ; } } OP1 ( SLJIT_MOV_U8 , TMP2 , 0 , SLJIT_MEM1 ( TMP2 ) , ( sljit_sw ) PRIV ( ucd_records ) + SLJIT_OFFSETOF ( ucd_record , script ) ) ; } while ( * cc != XCL_END ) { if ( * cc == XCL_SINGLE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; } else if ( * cc == XCL_RANGE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; GETCHARINCTEST ( c , cc ) ; } else { SLJIT_ASSERT ( * cc == XCL_PROP || * cc == XCL_NOTPROP ) ; cc ++ ; if ( * cc == PT_SCX ) { compares -- ; invertcmp = ( compares == 0 && list != backtracks ) ; jump = NULL ; if ( cc [ - 1 ] == XCL_NOTPROP ) { jump = CMP ( SLJIT_EQUAL , TMP2 , 0 , SLJIT_IMM , ( int ) cc [ 1 ] ) ; if ( invertcmp ) { add_jump ( compiler , backtracks , jump ) ; jump = NULL ; } invertcmp ^= 0x1 ; } OP2U ( SLJIT_AND32 | SLJIT_SET_Z , SLJIT_MEM1 ( TMP1 ) , ( sljit_sw ) ( PRIV ( ucd_script_sets ) + ( cc [ 1 ] >> 5 ) ) , SLJIT_IMM , ( sljit_sw ) 1 << ( cc [ 1 ] & 0x1f ) ) ; add_jump ( compiler , compares > 0 ? list : backtracks , JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ) ; if ( jump != NULL ) JUMPHERE ( jump ) ; } cc += 2 ; } } if ( unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0 ) OP1 ( SLJIT_MOV , TMP2 , 0 , SLJIT_MEM1 ( SLJIT_SP ) , LOCALS0 ) ; else if ( unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR ) OP1 ( SLJIT_MOV , TMP2 , 0 , RETURN_ADDR , 0 ) ; cc = ccbegin ; } if ( unicode_status & XCLASS_SAVE_CHAR ) OP1 ( SLJIT_MOV , TMP1 , 0 , RETURN_ADDR , 0 ) ; if ( unicode_status & XCLASS_HAS_TYPE ) { if ( unicode_status & XCLASS_SAVE_CHAR ) typereg = RETURN_ADDR ; OP1 ( SLJIT_MOV_U8 , typereg , 0 , SLJIT_MEM1 ( TMP2 ) , ( sljit_sw ) PRIV ( ucd_records ) + SLJIT_OFFSETOF ( ucd_record , chartype ) ) ; } } # endif charoffset = 0 ; numberofcmps = 0 ; # ifdef SUPPORT_UNICODE typeoffset = 0 ; # endif while ( * cc != XCL_END ) { compares -- ; invertcmp = ( compares == 0 && list != backtracks ) ; jump = NULL ; if ( * cc == XCL_SINGLE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; if ( numberofcmps < 3 && ( * cc == XCL_SINGLE || * cc == XCL_RANGE ) ) { OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( c - charoffset ) ) ; OP_FLAGS ( numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; numberofcmps ++ ; } else if ( numberofcmps > 0 ) { OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( c - charoffset ) ) ; OP_FLAGS ( SLJIT_OR | SLJIT_SET_Z , TMP2 , 0 , SLJIT_EQUAL ) ; jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; numberofcmps = 0 ; } else { jump = CMP ( SLJIT_EQUAL ^ invertcmp , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( c - charoffset ) ) ; numberofcmps = 0 ; } } else if ( * cc == XCL_RANGE ) { cc ++ ; GETCHARINCTEST ( c , cc ) ; SET_CHAR_OFFSET ( c ) ; GETCHARINCTEST ( c , cc ) ; if ( numberofcmps < 3 && ( * cc == XCL_SINGLE || * cc == XCL_RANGE ) ) { OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( c - charoffset ) ) ; OP_FLAGS ( numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; numberofcmps ++ ; } else if ( numberofcmps > 0 ) { OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( c - charoffset ) ) ; OP_FLAGS ( SLJIT_OR | SLJIT_SET_Z , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; numberofcmps = 0 ; } else { jump = CMP ( SLJIT_LESS_EQUAL ^ invertcmp , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( c - charoffset ) ) ; numberofcmps = 0 ; } } # ifdef SUPPORT_UNICODE else { SLJIT_ASSERT ( * cc == XCL_PROP || * cc == XCL_NOTPROP ) ; if ( * cc == XCL_NOTPROP ) invertcmp ^= 0x1 ; cc ++ ; switch ( * cc ) { case PT_ANY : if ( ! invertcmp ) jump = JUMP ( SLJIT_JUMP ) ; break ; case PT_LAMP : OP2U ( SLJIT_SUB | SLJIT_SET_Z , typereg , 0 , SLJIT_IMM , ucp_Lu - typeoffset ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , typereg , 0 , SLJIT_IMM , ucp_Ll - typeoffset ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , typereg , 0 , SLJIT_IMM , ucp_Lt - typeoffset ) ; OP_FLAGS ( SLJIT_OR | SLJIT_SET_Z , TMP2 , 0 , SLJIT_EQUAL ) ; jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; break ; case PT_GC : c = PRIV ( ucp_typerange ) [ ( int ) cc [ 1 ] * 2 ] ; SET_TYPE_OFFSET ( c ) ; jump = CMP ( SLJIT_LESS_EQUAL ^ invertcmp , typereg , 0 , SLJIT_IMM , PRIV ( ucp_typerange ) [ ( int ) cc [ 1 ] * 2 + 1 ] - c ) ; break ; case PT_PC : jump = CMP ( SLJIT_EQUAL ^ invertcmp , typereg , 0 , SLJIT_IMM , ( int ) cc [ 1 ] - typeoffset ) ; break ; case PT_SC : case PT_SCX : case PT_BOOL : case PT_BIDICL : compares ++ ; break ; case PT_SPACE : case PT_PXSPACE : SET_CHAR_OFFSET ( 9 ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , TMP1 , 0 , SLJIT_IMM , 0xd - 0x9 ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , 0x85 - 0x9 ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , 0x180e - 0x9 ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; SET_TYPE_OFFSET ( ucp_Zl ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , typereg , 0 , SLJIT_IMM , ucp_Zs - ucp_Zl ) ; OP_FLAGS ( SLJIT_OR | SLJIT_SET_Z , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; break ; case PT_WORD : OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( CHAR_UNDERSCORE - charoffset ) ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_EQUAL ) ; case PT_ALNUM : SET_TYPE_OFFSET ( ucp_Ll ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , typereg , 0 , SLJIT_IMM , ucp_Lu - ucp_Ll ) ; OP_FLAGS ( ( * cc == PT_ALNUM ) ? SLJIT_MOV : SLJIT_OR , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; SET_TYPE_OFFSET ( ucp_Nd ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , typereg , 0 , SLJIT_IMM , ucp_No - ucp_Nd ) ; OP_FLAGS ( SLJIT_OR | SLJIT_SET_Z , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; break ; case PT_CLIST : other_cases = PRIV ( ucd_caseless_sets ) + cc [ 1 ] ; SLJIT_ASSERT ( other_cases [ 0 ] != NOTACHAR && other_cases [ 1 ] != NOTACHAR && other_cases [ 2 ] != NOTACHAR ) ; SLJIT_ASSERT ( other_cases [ 0 ] < other_cases [ 1 ] && other_cases [ 1 ] < other_cases [ 2 ] ) ; if ( is_powerof2 ( other_cases [ 1 ] ^ other_cases [ 0 ] ) ) { if ( charoffset == 0 ) OP2 ( SLJIT_OR , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , other_cases [ 1 ] ^ other_cases [ 0 ] ) ; else { OP2 ( SLJIT_ADD , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) charoffset ) ; OP2 ( SLJIT_OR , TMP2 , 0 , TMP2 , 0 , SLJIT_IMM , other_cases [ 1 ] ^ other_cases [ 0 ] ) ; } OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP2 , 0 , SLJIT_IMM , other_cases [ 1 ] ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_EQUAL ) ; other_cases += 2 ; } else if ( is_powerof2 ( other_cases [ 2 ] ^ other_cases [ 1 ] ) ) { if ( charoffset == 0 ) OP2 ( SLJIT_OR , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , other_cases [ 2 ] ^ other_cases [ 1 ] ) ; else { OP2 ( SLJIT_ADD , TMP2 , 0 , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) charoffset ) ; OP2 ( SLJIT_OR , TMP2 , 0 , TMP2 , 0 , SLJIT_IMM , other_cases [ 1 ] ^ other_cases [ 0 ] ) ; } OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP2 , 0 , SLJIT_IMM , other_cases [ 2 ] ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( other_cases [ 0 ] - charoffset ) ) ; OP_FLAGS ( SLJIT_OR | ( ( other_cases [ 3 ] == NOTACHAR ) ? SLJIT_SET_Z : 0 ) , TMP2 , 0 , SLJIT_EQUAL ) ; other_cases += 3 ; } else { OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( * other_cases ++ - charoffset ) ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_EQUAL ) ; } while ( * other_cases != NOTACHAR ) { OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( * other_cases ++ - charoffset ) ) ; OP_FLAGS ( SLJIT_OR | ( ( * other_cases == NOTACHAR ) ? SLJIT_SET_Z : 0 ) , TMP2 , 0 , SLJIT_EQUAL ) ; } jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; break ; case PT_UCNC : OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( CHAR_DOLLAR_SIGN - charoffset ) ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( CHAR_COMMERCIAL_AT - charoffset ) ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( CHAR_GRAVE_ACCENT - charoffset ) ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; SET_CHAR_OFFSET ( 0xa0 ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , TMP1 , 0 , SLJIT_IMM , ( sljit_sw ) ( 0xd7ff - charoffset ) ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; SET_CHAR_OFFSET ( 0 ) ; OP2U ( SLJIT_SUB | SLJIT_SET_GREATER_EQUAL , TMP1 , 0 , SLJIT_IMM , 0xe000 - 0 ) ; OP_FLAGS ( SLJIT_OR | SLJIT_SET_Z , TMP2 , 0 , SLJIT_GREATER_EQUAL ) ; jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; break ; case PT_PXGRAPH : SET_TYPE_OFFSET ( ucp_Ll ) ; OP2U ( SLJIT_SUB | SLJIT_SET_GREATER , typereg , 0 , SLJIT_IMM , ucp_So - ucp_Ll ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_GREATER ) ; jump = CMP ( SLJIT_NOT_EQUAL , typereg , 0 , SLJIT_IMM , ucp_Cf - ucp_Ll ) ; SET_CHAR_OFFSET ( 0x2066 ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , TMP1 , 0 , SLJIT_IMM , 0x2069 - 0x2066 ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , 0x061c - 0x2066 ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , 0x180e - 0x2066 ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; JUMPHERE ( jump ) ; jump = CMP ( SLJIT_ZERO ^ invertcmp , TMP2 , 0 , SLJIT_IMM , 0 ) ; break ; case PT_PXPRINT : SET_TYPE_OFFSET ( ucp_Ll ) ; OP2U ( SLJIT_SUB | SLJIT_SET_GREATER , typereg , 0 , SLJIT_IMM , ucp_So - ucp_Ll ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_GREATER ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , typereg , 0 , SLJIT_IMM , ucp_Zs - ucp_Ll ) ; OP_FLAGS ( SLJIT_AND , TMP2 , 0 , SLJIT_NOT_EQUAL ) ; jump = CMP ( SLJIT_NOT_EQUAL , typereg , 0 , SLJIT_IMM , ucp_Cf - ucp_Ll ) ; SET_CHAR_OFFSET ( 0x2066 ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , TMP1 , 0 , SLJIT_IMM , 0x2069 - 0x2066 ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; OP2U ( SLJIT_SUB | SLJIT_SET_Z , TMP1 , 0 , SLJIT_IMM , 0x061c - 0x2066 ) ; OP_FLAGS ( SLJIT_OR , TMP2 , 0 , SLJIT_EQUAL ) ; JUMPHERE ( jump ) ; jump = CMP ( SLJIT_ZERO ^ invertcmp , TMP2 , 0 , SLJIT_IMM , 0 ) ; break ; case PT_PXPUNCT : SET_TYPE_OFFSET ( ucp_Sc ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , typereg , 0 , SLJIT_IMM , ucp_So - ucp_Sc ) ; OP_FLAGS ( SLJIT_MOV , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; SET_CHAR_OFFSET ( 0 ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , TMP1 , 0 , SLJIT_IMM , 0x7f ) ; OP_FLAGS ( SLJIT_AND , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; SET_TYPE_OFFSET ( ucp_Pc ) ; OP2U ( SLJIT_SUB | SLJIT_SET_LESS_EQUAL , typereg , 0 , SLJIT_IMM , ucp_Ps - ucp_Pc ) ; OP_FLAGS ( SLJIT_OR | SLJIT_SET_Z , TMP2 , 0 , SLJIT_LESS_EQUAL ) ; jump = JUMP ( SLJIT_NOT_ZERO ^ invertcmp ) ; break ; default : SLJIT_UNREACHABLE ( ) ; break ; } cc += 2 ; } # endif if ( jump != NULL ) add_jump ( compiler , compares > 0 ? list : backtracks , jump ) ; } if ( found != NULL ) set_jumps ( found , LABEL ( ) ) ; }", "target": "<S2SV_ModStart> == PT_CLIST && cc [ - 1 ] <S2SV_ModEnd> == XCL_PROP )"}
{"source": "CWE-476 bool ConstantFolding : : MulConvPushDown ( GraphDef * optimized_graph , NodeDef * node , const GraphProperties & properties ) { if ( ! IsAnyMul ( * node ) || NumNonControlInputs ( * node ) != 2 ) return false ; NodeDef * mul_left_child = node_map_ -> GetNode ( node -> input ( 0 ) ) ; NodeDef * mul_right_child = node_map_ -> GetNode ( node -> input ( 1 ) ) ; <S2SV_StartBug> const bool left_child_is_constant = IsReallyConstant ( * mul_left_child ) ; <S2SV_EndBug> const bool right_child_is_constant = IsReallyConstant ( * mul_right_child ) ; if ( ! left_child_is_constant && ! right_child_is_constant ) { return false ; } NodeDef * conv_node = left_child_is_constant ? mul_right_child : mul_left_child ; if ( ! IsConv2D ( * conv_node ) && ! IsConv3D ( * conv_node ) ) { return false ; } if ( node -> device ( ) != mul_left_child -> device ( ) || node -> device ( ) != mul_right_child -> device ( ) ) { return false ; } if ( conv_node -> input_size ( ) < 2 || NumNonControlOutputs ( * conv_node , * node_map_ ) > 1 || nodes_to_preserve_ . find ( conv_node -> name ( ) ) != nodes_to_preserve_ . end ( ) ) { return false ; } NodeDef * conv_left_child = node_map_ -> GetNode ( conv_node -> input ( 0 ) ) ; NodeDef * conv_right_child = node_map_ -> GetNode ( conv_node -> input ( 1 ) ) ; const bool conv_left_is_constant = IsReallyConstant ( * conv_left_child ) ; const bool conv_right_is_constant = IsReallyConstant ( * conv_right_child ) ; if ( ! conv_left_is_constant && ! conv_right_is_constant ) { return false ; } if ( conv_left_is_constant && conv_right_is_constant ) { return false ; } const auto & mul_props = properties . GetOutputProperties ( node -> name ( ) ) ; const auto & conv_props = properties . GetOutputProperties ( conv_node -> name ( ) ) ; if ( mul_props . empty ( ) || conv_props . empty ( ) ) { return false ; } const auto & mul_shape = mul_props [ 0 ] . shape ( ) ; const auto & conv_shape = conv_props [ 0 ] . shape ( ) ; if ( ! ShapesSymbolicallyEqual ( mul_shape , conv_shape ) ) { return false ; } const auto & input_props = properties . GetInputProperties ( conv_node -> name ( ) ) ; if ( input_props . size ( ) < 2 ) { return false ; } const auto & filter_shape = input_props [ 1 ] . shape ( ) ; NodeDef * const_node = left_child_is_constant ? mul_left_child : mul_right_child ; const auto & const_props = properties . GetOutputProperties ( const_node -> name ( ) ) ; if ( const_props . empty ( ) ) { return false ; } const auto & const_shape = const_props [ 0 ] . shape ( ) ; if ( ! IsValidConstShapeForMulConvPushDown ( conv_node -> attr ( ) . at ( \"data_format\" ) . s ( ) , filter_shape , const_shape ) ) { return false ; } string mul_new_name = AddPrefixToNodeName ( \"merged_input\" , conv_node -> name ( ) ) ; if ( node_map_ -> NodeExists ( mul_new_name ) ) { return false ; } string conv_const_input = conv_left_is_constant ? conv_node -> input ( 0 ) : conv_node -> input ( 1 ) ; if ( MaybeRemoveControlInput ( conv_node -> name ( ) , const_node , optimized_graph , node_map_ . get ( ) ) ) { MaybeAddControlInput ( conv_const_input , const_node , optimized_graph , node_map_ . get ( ) ) ; } conv_node -> set_name ( node -> name ( ) ) ; node -> set_name ( mul_new_name ) ; if ( conv_left_is_constant ) { node_map_ -> UpdateInput ( conv_node -> name ( ) , node -> input ( 0 ) , mul_new_name ) ; conv_node -> set_input ( 0 , mul_new_name ) ; } else { node_map_ -> UpdateInput ( conv_node -> name ( ) , node -> input ( 1 ) , mul_new_name ) ; conv_node -> set_input ( 1 , mul_new_name ) ; } NodeDef * conv_const_node = conv_left_is_constant ? conv_left_child : conv_right_child ; if ( left_child_is_constant ) { node -> set_input ( 1 , conv_const_node -> name ( ) ) ; } else { node -> set_input ( 0 , conv_const_node -> name ( ) ) ; } node_map_ -> AddNode ( mul_new_name , node ) ; return true ; }", "target": "<S2SV_ModStart> ) ) ; if ( mul_left_child == nullptr || mul_right_child == nullptr ) { return false ; }"}
{"source": "CWE-908 void Compute ( OpKernelContext * context ) override { const Tensor & rhs = context -> input ( 1 ) ; <S2SV_StartBug> context -> forward_ref_input_to_ref_output ( 0 , 0 ) ; <S2SV_EndBug> AllocatorAttributes attr ; if ( ! relax_constraints_ ) { attr . set_gpu_compatible ( true ) ; attr . set_nic_compatible ( true ) ; } { mutex_lock l ( * context -> input_ref_mutex ( 0 ) ) ; const Tensor & old_lhs = context -> mutable_input ( 0 , true ) ; const bool same_shape = old_lhs . shape ( ) . IsSameSize ( rhs . shape ( ) ) ; if ( validate_shape_ ) { OP_REQUIRES ( context , same_shape , errors : : InvalidArgument ( \"Assign<S2SV_blank>requires<S2SV_blank>shapes<S2SV_blank>of<S2SV_blank>both<S2SV_blank>tensors<S2SV_blank>to<S2SV_blank>match.<S2SV_blank>\" \"lhs<S2SV_blank>shape=<S2SV_blank>\" , old_lhs . shape ( ) . DebugString ( ) , \"<S2SV_blank>rhs<S2SV_blank>shape=<S2SV_blank>\" , rhs . shape ( ) . DebugString ( ) ) ) ; } if ( old_lhs . IsInitialized ( ) && old_lhs . shape ( ) . num_elements ( ) == rhs . shape ( ) . num_elements ( ) ) { Tensor reshaped_old_lhs ; if ( same_shape ) { reshaped_old_lhs = old_lhs ; } else { CHECK ( reshaped_old_lhs . CopyFrom ( old_lhs , rhs . shape ( ) ) ) ; context -> replace_ref_input ( 0 , reshaped_old_lhs , true ) ; } if ( use_exclusive_lock_ ) { Copy ( context , & reshaped_old_lhs , rhs ) ; return ; } } else { std : : unique_ptr < Tensor > input_alias = context -> forward_input ( 1 , OpKernelContext : : Params : : kNoReservation , rhs . dtype ( ) , rhs . shape ( ) , DEVICE_MEMORY , attr ) ; if ( input_alias != nullptr ) { context -> replace_ref_input ( 0 , * input_alias , true ) ; return ; } Tensor copy_tensor ; OP_REQUIRES_OK ( context , context -> allocate_temp ( old_lhs . dtype ( ) , rhs . shape ( ) , & copy_tensor , attr ) ) ; context -> clear_recorded_memory ( ) ; context -> replace_ref_input ( 0 , copy_tensor , true ) ; if ( use_exclusive_lock_ ) { Copy ( context , & copy_tensor , rhs ) ; return ; } } } Tensor old_unlocked_lhs = context -> mutable_input ( 0 , false ) ; Copy ( context , & old_unlocked_lhs , rhs ) ; }", "target": "<S2SV_ModStart> 0 , 0 ) ; OP_REQUIRES ( context , rhs . IsInitialized ( ) , errors : : Internal ( \"Right<S2SV_blank>hand<S2SV_blank>side<S2SV_blank>of<S2SV_blank>AssignOp<S2SV_blank>is<S2SV_blank>not<S2SV_blank>initialized\" )"}
{"source": "CWE-476 gen_hash ( codegen_scope * s , node * tree , int val , int limit ) { int slimit = GEN_VAL_STACK_MAX ; if ( cursp ( ) >= GEN_LIT_ARY_MAX ) slimit = INT16_MAX ; int len = 0 ; mrb_bool update = FALSE ; while ( tree ) { if ( nint ( tree -> car -> car -> car ) == NODE_KW_REST_ARGS ) { <S2SV_StartBug> if ( len > 0 ) { <S2SV_EndBug> pop_n ( len * 2 ) ; if ( ! update ) { genop_2 ( s , OP_HASH , cursp ( ) , len ) ; } else { pop ( ) ; genop_2 ( s , OP_HASHADD , cursp ( ) , len ) ; } push ( ) ; } codegen ( s , tree -> car -> cdr , val ) ; <S2SV_StartBug> if ( len > 0 || update ) { <S2SV_EndBug> pop ( ) ; pop ( ) ; genop_1 ( s , OP_HASHCAT , cursp ( ) ) ; push ( ) ; } update = TRUE ; len = 0 ; } else { codegen ( s , tree -> car -> car , val ) ; codegen ( s , tree -> car -> cdr , val ) ; len ++ ; } tree = tree -> cdr ; if ( val && cursp ( ) >= slimit ) { pop_n ( len * 2 ) ; if ( ! update ) { genop_2 ( s , OP_HASH , cursp ( ) , len ) ; } else { pop ( ) ; genop_2 ( s , OP_HASHADD , cursp ( ) , len ) ; } push ( ) ; update = TRUE ; len = 0 ; } } if ( update ) { if ( val && len > 0 ) { pop_n ( len * 2 + 1 ) ; genop_2 ( s , OP_HASHADD , cursp ( ) , len ) ; push ( ) ; } return - 1 ; } return len ; }", "target": "<S2SV_ModStart> { if ( val && <S2SV_ModStart> ; if ( val && ( <S2SV_ModStart> 0 || update )"}
{"source": "CWE-843 void Compute ( OpKernelContext * ctx ) override { StagingMap < Ordered > * map = nullptr ; OP_REQUIRES_OK ( ctx , GetStagingMap ( ctx , def ( ) , & map ) ) ; core : : ScopedUnref scope ( map ) ; typename StagingMap < Ordered > : : OptionalTuple tuple ; const Tensor * key_tensor ; const Tensor * indices_tensor ; OpInputList values_tensor ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"key\" , & key_tensor ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"indices\" , & indices_tensor ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input_list ( \"values\" , & values_tensor ) ) ; OP_REQUIRES ( ctx , key_tensor -> NumElements ( ) > 0 , errors : : InvalidArgument ( \"key<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty\" ) ) ; <S2SV_StartBug> Tensor key ( * key_tensor ) ; <S2SV_EndBug> for ( std : : size_t i = 0 ; i < values_tensor . size ( ) ; ++ i ) { tuple . push_back ( values_tensor [ i ] ) ; } OP_REQUIRES_OK ( ctx , map -> put ( & key , indices_tensor , & tuple ) ) ; }", "target": "<S2SV_ModStart> ) ) ; OP_REQUIRES ( ctx , key_tensor -> NumElements ( ) == 1 , errors : : InvalidArgument ( \"key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>int64<S2SV_blank>scalar,<S2SV_blank>got<S2SV_blank>tensor<S2SV_blank>with<S2SV_blank>shape:<S2SV_blank>\" , key_tensor -> shape ( ) ) ) ;"}
{"source": "CWE-125 gen_assignment ( codegen_scope * s , node * tree , node * rhs , int sp , int val ) { int idx ; int type = nint ( tree -> car ) ; switch ( type ) { case NODE_GVAR : case NODE_ARG : case NODE_LVAR : case NODE_IVAR : case NODE_CVAR : case NODE_CONST : case NODE_NIL : case NODE_MASGN : if ( rhs ) { codegen ( s , rhs , VAL ) ; pop ( ) ; sp = cursp ( ) ; } break ; case NODE_COLON2 : case NODE_CALL : case NODE_SCALL : break ; case NODE_NVAR : codegen_error ( s , \"Can\\'t<S2SV_blank>assign<S2SV_blank>to<S2SV_blank>numbered<S2SV_blank>parameter\" ) ; break ; default : codegen_error ( s , \"unknown<S2SV_blank>lhs\" ) ; break ; } tree = tree -> cdr ; switch ( type ) { case NODE_GVAR : gen_setxv ( s , OP_SETGV , sp , nsym ( tree ) , val ) ; break ; case NODE_ARG : case NODE_LVAR : idx = lv_idx ( s , nsym ( tree ) ) ; if ( idx > 0 ) { if ( idx != sp ) { gen_move ( s , idx , sp , val ) ; } break ; } else { gen_setupvar ( s , sp , nsym ( tree ) ) ; } break ; case NODE_IVAR : gen_setxv ( s , OP_SETIV , sp , nsym ( tree ) , val ) ; break ; case NODE_CVAR : gen_setxv ( s , OP_SETCV , sp , nsym ( tree ) , val ) ; break ; case NODE_CONST : gen_setxv ( s , OP_SETCONST , sp , nsym ( tree ) , val ) ; break ; case NODE_COLON2 : if ( sp ) { gen_move ( s , cursp ( ) , sp , 0 ) ; } sp = cursp ( ) ; push ( ) ; codegen ( s , tree -> car , VAL ) ; if ( rhs ) { codegen ( s , rhs , VAL ) ; pop ( ) ; gen_move ( s , sp , cursp ( ) , 0 ) ; } pop_n ( 2 ) ; idx = new_sym ( s , nsym ( tree -> cdr ) ) ; genop_2 ( s , OP_SETMCNST , sp , idx ) ; break ; case NODE_CALL : case NODE_SCALL : { int noself = 0 , safe = ( type == NODE_SCALL ) , skip = 0 , top , call , n = 0 ; mrb_sym mid = nsym ( tree -> cdr -> car ) ; top = cursp ( ) ; if ( val || sp == cursp ( ) ) { push ( ) ; } call = cursp ( ) ; if ( ! tree -> car ) { noself = 1 ; push ( ) ; } else { codegen ( s , tree -> car , VAL ) ; } if ( safe ) { int recv = cursp ( ) - 1 ; gen_move ( s , cursp ( ) , recv , 1 ) ; skip = genjmp2_0 ( s , OP_JMPNIL , cursp ( ) , val ) ; } tree = tree -> cdr -> cdr -> car ; if ( tree ) { if ( tree -> car ) { n = gen_values ( s , tree -> car , VAL , ( tree -> cdr -> car ) ? 13 : 14 ) ; if ( n < 0 ) { n = 15 ; push ( ) ; } } if ( tree -> cdr -> car ) { <S2SV_StartBug> if ( n == 14 ) { <S2SV_EndBug> pop_n ( n ) ; genop_2 ( s , OP_ARRAY , cursp ( ) , n ) ; push ( ) ; n = 15 ; } gen_hash ( s , tree -> cdr -> car -> cdr , VAL , 0 ) ; if ( n < 14 ) { n ++ ; } else { pop_n ( 2 ) ; genop_2 ( s , OP_ARYPUSH , cursp ( ) , 1 ) ; } push ( ) ; } } if ( rhs ) { codegen ( s , rhs , VAL ) ; pop ( ) ; } else { gen_move ( s , cursp ( ) , sp , 0 ) ; } if ( val ) { gen_move ( s , top , cursp ( ) , 1 ) ; } if ( n < 15 ) { n ++ ; if ( n == 15 ) { pop_n ( 14 ) ; genop_2 ( s , OP_ARRAY , cursp ( ) , 15 ) ; } } else { pop ( ) ; genop_2 ( s , OP_ARYPUSH , cursp ( ) , 1 ) ; } s -> sp = call ; if ( mid == MRB_OPSYM_2 ( s -> mrb , aref ) && n == 2 ) { genop_1 ( s , OP_SETIDX , cursp ( ) ) ; } else { genop_3 ( s , noself ? OP_SSEND : OP_SEND , cursp ( ) , new_sym ( s , attrsym ( s , mid ) ) , n ) ; } if ( safe ) { dispatch ( s , skip ) ; } s -> sp = top ; } break ; case NODE_MASGN : gen_massignment ( s , tree -> car , sp , val ) ; break ; case NODE_NIL : break ; default : codegen_error ( s , \"unknown<S2SV_blank>lhs\" ) ; break ; } if ( val ) push ( ) ; }", "target": "<S2SV_ModStart> ( n == 13 || n =="}
{"source": "CWE-787 void publish ( Topic * iterator , size_t start , size_t stop , std : : string_view topic , std : : pair < std : : string_view , std : : string_view > message ) { <S2SV_StartBug> if ( numTriggeredTopics == 64 ) { <S2SV_EndBug> drain ( ) ; } for ( ; stop != std : : string : : npos ; start = stop + 1 ) { stop = topic . find ( '/' , start ) ; std : : string_view segment = topic . substr ( start , stop - start ) ; if ( segment . length ( ) == 1 ) { if ( segment [ 0 ] == '+' || segment [ 0 ] == '#' ) { return ; } } if ( iterator -> terminatingWildcardChild ) { iterator -> terminatingWildcardChild -> messages [ messageId ] = message ; <S2SV_StartBug> if ( ! iterator -> terminatingWildcardChild -> triggered ) { <S2SV_EndBug> triggeredTopics [ numTriggeredTopics ++ ] = iterator -> terminatingWildcardChild ; iterator -> terminatingWildcardChild -> triggered = true ; } } if ( iterator -> wildcardChild ) { publish ( iterator -> wildcardChild , stop + 1 , stop , topic , message ) ; } std : : map < std : : string_view , Topic * > : : iterator it = iterator -> children . find ( segment ) ; if ( it == iterator -> children . end ( ) ) { return ; } iterator = it -> second ; } iterator -> messages [ messageId ] = message ; if ( ! iterator -> triggered ) { <S2SV_StartBug> triggeredTopics [ numTriggeredTopics ++ ] = iterator ; <S2SV_EndBug> iterator -> triggered = true ; } }", "target": "<S2SV_ModStart> message ) { <S2SV_ModEnd> for ( ; <S2SV_ModStart> triggered ) { if ( numTriggeredTopics == 64 ) { drain ( ) ; } <S2SV_ModStart> triggered ) { if ( numTriggeredTopics == 64 ) { drain ( ) ; }"}
{"source": "CWE-20 setup_seccomp ( FlatpakBwrap * bwrap , const char * arch , gulong allowed_personality , FlatpakRunFlags run_flags , GError * * error ) { gboolean multiarch = ( run_flags & FLATPAK_RUN_FLAG_MULTIARCH ) != 0 ; gboolean devel = ( run_flags & FLATPAK_RUN_FLAG_DEVEL ) != 0 ; __attribute__ ( ( cleanup ( cleanup_seccomp ) ) ) scmp_filter_ctx seccomp = NULL ; struct { int scall ; int errnum ; struct scmp_arg_cmp * arg ; } syscall_blocklist [ ] = { { SCMP_SYS ( syslog ) , EPERM } , { SCMP_SYS ( uselib ) , EPERM } , { SCMP_SYS ( acct ) , EPERM } , { SCMP_SYS ( modify_ldt ) , EPERM } , { SCMP_SYS ( quotactl ) , EPERM } , { SCMP_SYS ( add_key ) , EPERM } , { SCMP_SYS ( keyctl ) , EPERM } , { SCMP_SYS ( request_key ) , EPERM } , { SCMP_SYS ( move_pages ) , EPERM } , { SCMP_SYS ( mbind ) , EPERM } , { SCMP_SYS ( get_mempolicy ) , EPERM } , { SCMP_SYS ( set_mempolicy ) , EPERM } , { SCMP_SYS ( migrate_pages ) , EPERM } , { SCMP_SYS ( unshare ) , EPERM } , { SCMP_SYS ( setns ) , EPERM } , { SCMP_SYS ( mount ) , EPERM } , { SCMP_SYS ( umount ) , EPERM } , { SCMP_SYS ( umount2 ) , EPERM } , <S2SV_StartBug> { SCMP_SYS ( pivot_root ) , EPERM } , <S2SV_EndBug> # if defined ( __s390__ ) || defined ( __s390x__ ) || defined ( __CRIS__ ) { SCMP_SYS ( clone ) , EPERM , & SCMP_A1 ( SCMP_CMP_MASKED_EQ , CLONE_NEWUSER , CLONE_NEWUSER ) } , # else { SCMP_SYS ( clone ) , EPERM , & SCMP_A0 ( SCMP_CMP_MASKED_EQ , CLONE_NEWUSER , CLONE_NEWUSER ) } , # endif { SCMP_SYS ( ioctl ) , EPERM , & SCMP_A1 ( SCMP_CMP_MASKED_EQ , 0xFFFFFFFFu , ( int ) TIOCSTI ) } , { SCMP_SYS ( clone3 ) , ENOSYS } , { SCMP_SYS ( open_tree ) , ENOSYS } , { SCMP_SYS ( move_mount ) , ENOSYS } , { SCMP_SYS ( fsopen ) , ENOSYS } , { SCMP_SYS ( fsconfig ) , ENOSYS } , { SCMP_SYS ( fsmount ) , ENOSYS } , { SCMP_SYS ( fspick ) , ENOSYS } , { SCMP_SYS ( mount_setattr ) , ENOSYS } , } ; struct { int scall ; int errnum ; struct scmp_arg_cmp * arg ; } syscall_nondevel_blocklist [ ] = { { SCMP_SYS ( perf_event_open ) , EPERM } , { SCMP_SYS ( personality ) , EPERM , & SCMP_A0 ( SCMP_CMP_NE , allowed_personality ) } , { SCMP_SYS ( ptrace ) , EPERM } } ; struct { int family ; FlatpakRunFlags flags_mask ; } socket_family_allowlist [ ] = { { AF_UNSPEC , 0 } , { AF_LOCAL , 0 } , { AF_INET , 0 } , { AF_INET6 , 0 } , { AF_NETLINK , 0 } , { AF_CAN , FLATPAK_RUN_FLAG_CANBUS } , { AF_BLUETOOTH , FLATPAK_RUN_FLAG_BLUETOOTH } , } ; int last_allowed_family ; int i , r ; g_auto ( GLnxTmpfile ) seccomp_tmpf = { 0 , } ; seccomp = seccomp_init ( SCMP_ACT_ALLOW ) ; if ( ! seccomp ) return flatpak_fail_error ( error , FLATPAK_ERROR_SETUP_FAILED , _ ( \"Initialize<S2SV_blank>seccomp<S2SV_blank>failed\" ) ) ; if ( arch != NULL ) { uint32_t arch_id = 0 ; const uint32_t * extra_arches = NULL ; if ( strcmp ( arch , \"i386\" ) == 0 ) { arch_id = SCMP_ARCH_X86 ; } else if ( strcmp ( arch , \"x86_64\" ) == 0 ) { arch_id = SCMP_ARCH_X86_64 ; extra_arches = seccomp_x86_64_extra_arches ; } else if ( strcmp ( arch , \"arm\" ) == 0 ) { arch_id = SCMP_ARCH_ARM ; } # ifdef SCMP_ARCH_AARCH64 else if ( strcmp ( arch , \"aarch64\" ) == 0 ) { arch_id = SCMP_ARCH_AARCH64 ; extra_arches = seccomp_aarch64_extra_arches ; } # endif if ( arch_id != 0 ) { r = seccomp_arch_add ( seccomp , arch_id ) ; if ( r < 0 && r != - EEXIST ) return flatpak_fail_error ( error , FLATPAK_ERROR_SETUP_FAILED , _ ( \"Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>architecture<S2SV_blank>to<S2SV_blank>seccomp<S2SV_blank>filter\" ) ) ; if ( multiarch && extra_arches != NULL ) { for ( i = 0 ; extra_arches [ i ] != 0 ; i ++ ) { r = seccomp_arch_add ( seccomp , extra_arches [ i ] ) ; if ( r < 0 && r != - EEXIST ) return flatpak_fail_error ( error , FLATPAK_ERROR_SETUP_FAILED , _ ( \"Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>multiarch<S2SV_blank>architecture<S2SV_blank>to<S2SV_blank>seccomp<S2SV_blank>filter\" ) ) ; } } } } for ( i = 0 ; i < G_N_ELEMENTS ( syscall_blocklist ) ; i ++ ) { int scall = syscall_blocklist [ i ] . scall ; int errnum = syscall_blocklist [ i ] . errnum ; g_return_val_if_fail ( errnum == EPERM || errnum == ENOSYS , FALSE ) ; if ( syscall_blocklist [ i ] . arg ) r = seccomp_rule_add ( seccomp , SCMP_ACT_ERRNO ( errnum ) , scall , 1 , * syscall_blocklist [ i ] . arg ) ; else r = seccomp_rule_add ( seccomp , SCMP_ACT_ERRNO ( errnum ) , scall , 0 ) ; if ( r < 0 && r == - EFAULT ) return flatpak_fail_error ( error , FLATPAK_ERROR_SETUP_FAILED , _ ( \"Failed<S2SV_blank>to<S2SV_blank>block<S2SV_blank>syscall<S2SV_blank>%d\" ) , scall ) ; } if ( ! devel ) { for ( i = 0 ; i < G_N_ELEMENTS ( syscall_nondevel_blocklist ) ; i ++ ) { int scall = syscall_nondevel_blocklist [ i ] . scall ; int errnum = syscall_nondevel_blocklist [ i ] . errnum ; g_return_val_if_fail ( errnum == EPERM || errnum == ENOSYS , FALSE ) ; if ( syscall_nondevel_blocklist [ i ] . arg ) r = seccomp_rule_add ( seccomp , SCMP_ACT_ERRNO ( errnum ) , scall , 1 , * syscall_nondevel_blocklist [ i ] . arg ) ; else r = seccomp_rule_add ( seccomp , SCMP_ACT_ERRNO ( errnum ) , scall , 0 ) ; if ( r < 0 && r == - EFAULT ) return flatpak_fail_error ( error , FLATPAK_ERROR_SETUP_FAILED , _ ( \"Failed<S2SV_blank>to<S2SV_blank>block<S2SV_blank>syscall<S2SV_blank>%d\" ) , scall ) ; } } last_allowed_family = - 1 ; for ( i = 0 ; i < G_N_ELEMENTS ( socket_family_allowlist ) ; i ++ ) { int family = socket_family_allowlist [ i ] . family ; int disallowed ; if ( socket_family_allowlist [ i ] . flags_mask != 0 && ( socket_family_allowlist [ i ] . flags_mask & run_flags ) != socket_family_allowlist [ i ] . flags_mask ) continue ; for ( disallowed = last_allowed_family + 1 ; disallowed < family ; disallowed ++ ) { seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EAFNOSUPPORT ) , SCMP_SYS ( socket ) , 1 , SCMP_A0 ( SCMP_CMP_EQ , disallowed ) ) ; } last_allowed_family = family ; } seccomp_rule_add_exact ( seccomp , SCMP_ACT_ERRNO ( EAFNOSUPPORT ) , SCMP_SYS ( socket ) , 1 , SCMP_A0 ( SCMP_CMP_GE , last_allowed_family + 1 ) ) ; if ( ! glnx_open_anonymous_tmpfile_full ( O_RDWR | O_CLOEXEC , \"/tmp\" , & seccomp_tmpf , error ) ) return FALSE ; if ( seccomp_export_bpf ( seccomp , seccomp_tmpf . fd ) != 0 ) return flatpak_fail_error ( error , FLATPAK_ERROR_SETUP_FAILED , _ ( \"Failed<S2SV_blank>to<S2SV_blank>export<S2SV_blank>bpf\" ) ) ; lseek ( seccomp_tmpf . fd , 0 , SEEK_SET ) ; flatpak_bwrap_add_args_data_fd ( bwrap , \"--seccomp\" , glnx_steal_fd ( & seccomp_tmpf . fd ) , NULL ) ; return TRUE ; }", "target": "<S2SV_ModStart> SCMP_SYS ( pivot_root ) , EPERM } , { SCMP_SYS ( chroot"}
{"source": "CWE-400 gopherToHTML ( GopherStateData * gopherState , char * inbuf , int len ) { char * pos = inbuf ; char * lpos = NULL ; char * tline = NULL ; LOCAL_ARRAY ( char , line , TEMP_BUF_SIZE ) ; <S2SV_StartBug> LOCAL_ARRAY ( char , tmpbuf , TEMP_BUF_SIZE ) ; <S2SV_EndBug> char * name = NULL ; char * selector = NULL ; char * host = NULL ; char * port = NULL ; char * escaped_selector = NULL ; const char * icon_url = NULL ; char gtype ; StoreEntry * entry = NULL ; <S2SV_StartBug> memset ( tmpbuf , '\\\\0' , TEMP_BUF_SIZE ) ; <S2SV_EndBug> memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; entry = gopherState -> entry ; if ( gopherState -> conversion == GopherStateData : : HTML_INDEX_PAGE ) { char * html_url = html_quote ( entry -> url ( ) ) ; gopherHTMLHeader ( entry , \"Gopher<S2SV_blank>Index<S2SV_blank>%s\" , html_url ) ; storeAppendPrintf ( entry , \"<p>This<S2SV_blank>is<S2SV_blank>a<S2SV_blank>searchable<S2SV_blank>Gopher<S2SV_blank>index.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>search\\\\n\" \"function<S2SV_blank>of<S2SV_blank>your<S2SV_blank>browser<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>search<S2SV_blank>terms.\\\\n\" \"<ISINDEX>\\\\n\" ) ; gopherHTMLFooter ( entry ) ; entry -> flush ( ) ; gopherState -> HTML_header_added = 1 ; return ; } if ( gopherState -> conversion == GopherStateData : : HTML_CSO_PAGE ) { char * html_url = html_quote ( entry -> url ( ) ) ; gopherHTMLHeader ( entry , \"CSO<S2SV_blank>Search<S2SV_blank>of<S2SV_blank>%s\" , html_url ) ; storeAppendPrintf ( entry , \"<P>A<S2SV_blank>CSO<S2SV_blank>database<S2SV_blank>usually<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>phonebook<S2SV_blank>or\\\\n\" \"directory.<S2SV_blank><S2SV_blank>Use<S2SV_blank>the<S2SV_blank>search<S2SV_blank>function<S2SV_blank>of<S2SV_blank>your<S2SV_blank>browser<S2SV_blank>to<S2SV_blank>enter\\\\n\" \"search<S2SV_blank>terms.</P><ISINDEX>\\\\n\" ) ; gopherHTMLFooter ( entry ) ; entry -> flush ( ) ; gopherState -> HTML_header_added = 1 ; return ; } <S2SV_StartBug> String outbuf ; <S2SV_EndBug> if ( ! gopherState -> HTML_header_added ) { if ( gopherState -> conversion == GopherStateData : : HTML_CSO_RESULT ) gopherHTMLHeader ( entry , \"CSO<S2SV_blank>Search<S2SV_blank>Result\" , NULL ) ; else gopherHTMLHeader ( entry , \"Gopher<S2SV_blank>Menu\" , NULL ) ; outbuf . append ( \"<PRE>\" ) ; gopherState -> HTML_header_added = 1 ; gopherState -> HTML_pre = 1 ; } while ( pos < inbuf + len ) { int llen ; int left = len - ( pos - inbuf ) ; lpos = ( char * ) memchr ( pos , '\\\\n' , left ) ; if ( lpos ) { ++ lpos ; llen = lpos - pos ; } else { llen = left ; } if ( gopherState -> len + llen >= TEMP_BUF_SIZE ) { debugs ( 10 , DBG_IMPORTANT , \"GopherHTML:<S2SV_blank>Buffer<S2SV_blank>overflow.<S2SV_blank>Lost<S2SV_blank>some<S2SV_blank>data<S2SV_blank>on<S2SV_blank>URL:<S2SV_blank>\" << entry -> url ( ) ) ; llen = TEMP_BUF_SIZE - gopherState -> len - 1 ; gopherState -> overflowed = true ; } if ( ! lpos ) { memcpy ( gopherState -> buf + gopherState -> len , pos , llen ) ; gopherState -> len += llen ; break ; } if ( gopherState -> len != 0 ) { memcpy ( line , gopherState -> buf , gopherState -> len ) ; memcpy ( line + gopherState -> len , pos , llen ) ; llen += gopherState -> len ; gopherState -> len = 0 ; } else { memcpy ( line , pos , llen ) ; } line [ llen + 1 ] = '\\\\0' ; pos = lpos ; if ( * line == '.' ) { memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; continue ; } switch ( gopherState -> conversion ) { case GopherStateData : : HTML_INDEX_RESULT : case GopherStateData : : HTML_DIR : { tline = line ; gtype = * tline ; ++ tline ; name = tline ; selector = strchr ( tline , TAB ) ; if ( selector ) { * selector = '\\\\0' ; ++ selector ; host = strchr ( selector , TAB ) ; if ( host ) { * host = '\\\\0' ; ++ host ; port = strchr ( host , TAB ) ; if ( port ) { char * junk ; port [ 0 ] = ':' ; junk = strchr ( host , TAB ) ; if ( junk ) * junk ++ = 0 ; else { junk = strchr ( host , '\\\\r' ) ; if ( junk ) * junk ++ = 0 ; else { junk = strchr ( host , '\\\\n' ) ; if ( junk ) * junk ++ = 0 ; } } if ( ( port [ 1 ] == '0' ) && ( ! port [ 2 ] ) ) port [ 0 ] = 0 ; } escaped_selector = xstrdup ( rfc1738_escape_part ( selector ) ) ; switch ( gtype ) { case GOPHER_DIRECTORY : icon_url = mimeGetIconURL ( \"internal-menu\" ) ; break ; case GOPHER_HTML : case GOPHER_FILE : icon_url = mimeGetIconURL ( \"internal-text\" ) ; break ; case GOPHER_INDEX : case GOPHER_CSO : icon_url = mimeGetIconURL ( \"internal-index\" ) ; break ; case GOPHER_IMAGE : case GOPHER_GIF : case GOPHER_PLUS_IMAGE : icon_url = mimeGetIconURL ( \"internal-image\" ) ; break ; case GOPHER_SOUND : case GOPHER_PLUS_SOUND : icon_url = mimeGetIconURL ( \"internal-sound\" ) ; break ; case GOPHER_PLUS_MOVIE : icon_url = mimeGetIconURL ( \"internal-movie\" ) ; break ; case GOPHER_TELNET : case GOPHER_3270 : icon_url = mimeGetIconURL ( \"internal-telnet\" ) ; break ; case GOPHER_BIN : case GOPHER_MACBINHEX : case GOPHER_DOSBIN : case GOPHER_UUENCODED : icon_url = mimeGetIconURL ( \"internal-binary\" ) ; break ; case GOPHER_INFO : icon_url = NULL ; break ; case GOPHER_WWW : icon_url = mimeGetIconURL ( \"internal-link\" ) ; break ; default : icon_url = mimeGetIconURL ( \"internal-unknown\" ) ; break ; } <S2SV_StartBug> memset ( tmpbuf , '\\\\0' , TEMP_BUF_SIZE ) ; <S2SV_EndBug> if ( ( gtype == GOPHER_TELNET ) || ( gtype == GOPHER_3270 ) ) { if ( strlen ( escaped_selector ) != 0 ) <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s@%s%s%s/\\\\\">%s</A>\\\\n\" , <S2SV_EndBug> icon_url , escaped_selector , rfc1738_escape_part ( host ) , * port ? \":\" : \"\" , port , html_quote ( name ) ) ; else <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s%s%s/\\\\\">%s</A>\\\\n\" , <S2SV_EndBug> icon_url , rfc1738_escape_part ( host ) , * port ? \":\" : \"\" , port , html_quote ( name ) ) ; } else if ( gtype == GOPHER_INFO ) { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"\\\\t%s\\\\n\" , html_quote ( name ) ) ; <S2SV_EndBug> } else { if ( strncmp ( selector , \"GET<S2SV_blank>/\" , 5 ) == 0 ) { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"http://%s/%s\\\\\">%s</A>\\\\n\" , <S2SV_EndBug> icon_url , host , rfc1738_escape_unescaped ( selector + 5 ) , html_quote ( name ) ) ; } else if ( gtype == GOPHER_WWW ) { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"%s\\\\\">%s</A>\\\\n\" , <S2SV_EndBug> icon_url , rfc1738_escape_unescaped ( selector ) , html_quote ( name ) ) ; } else { snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"gopher://%s/%c%s\\\\\">%s</A>\\\\n\" , icon_url , host , gtype , escaped_selector , html_quote ( name ) ) ; } } safe_free ( escaped_selector ) ; outbuf . append ( tmpbuf ) ; } else { memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; continue ; } } else { memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; continue ; } break ; } case GopherStateData : : HTML_CSO_RESULT : { if ( line [ 0 ] == '-' ) { int code , recno ; char * s_code , * s_recno , * result ; s_code = strtok ( line + 1 , \":\\\\n\" ) ; s_recno = strtok ( NULL , \":\\\\n\" ) ; result = strtok ( NULL , \"\\\\n\" ) ; if ( ! result ) break ; code = atoi ( s_code ) ; recno = atoi ( s_recno ) ; if ( code != 200 ) break ; if ( gopherState -> cso_recno != recno ) { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>Record#<S2SV_blank>%d<br><i>%s</i></H2>\\\\n<PRE>\" , recno , html_quote ( result ) ) ; <S2SV_EndBug> gopherState -> cso_recno = recno ; } else { snprintf ( tmpbuf , TEMP_BUF_SIZE , \"%s\\\\n\" , html_quote ( result ) ) ; } outbuf . append ( tmpbuf ) ; break ; } else { int code ; char * s_code , * result ; s_code = strtok ( line , \":\" ) ; result = strtok ( NULL , \"\\\\n\" ) ; if ( ! result ) break ; code = atoi ( s_code ) ; switch ( code ) { case 200 : { break ; } case 102 : case 501 : case 502 : { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>%s</H2>\\\\n<PRE>\" , html_quote ( result ) ) ; <S2SV_EndBug> outbuf . append ( tmpbuf ) ; break ; } } } break ; } default : break ; } } <S2SV_StartBug> if ( outbuf . size ( ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> entry -> append ( outbuf . rawBuf ( ) , outbuf . size ( ) ) ; <S2SV_EndBug> entry -> flush ( ) ; } <S2SV_StartBug> outbuf . clean ( ) ; <S2SV_EndBug> return ; }", "target": "<S2SV_ModStart> TEMP_BUF_SIZE ) ; <S2SV_ModEnd> char * name <S2SV_ModStart> = NULL ; <S2SV_ModEnd> memset ( line <S2SV_ModStart> return ; } SBuf <S2SV_ModEnd> outbuf ; if <S2SV_ModStart> break ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> != 0 ) outbuf . appendf ( <S2SV_ModEnd> \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s@%s%s%s/\\\\\">%s</A>\\\\n\" , icon_url <S2SV_ModStart> ) ; else outbuf . appendf ( <S2SV_ModEnd> \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s%s%s/\\\\\">%s</A>\\\\n\" , icon_url <S2SV_ModStart> GOPHER_INFO ) { outbuf . appendf ( <S2SV_ModEnd> \"\\\\t%s\\\\n\" , html_quote <S2SV_ModStart> 0 ) { outbuf . appendf ( <S2SV_ModEnd> \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"http://%s/%s\\\\\">%s</A>\\\\n\" , icon_url <S2SV_ModStart> GOPHER_WWW ) { outbuf . appendf ( \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"gopher://%s/%c%s\\\\\">%s</A>\\\\n\" , icon_url , rfc1738_escape_unescaped ( selector ) , html_quote ( name ) ) ; } else { outbuf . appendf ( \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"gopher://%s/%c%s\\\\\">%s</A>\\\\n\" , icon_url , host , gtype , escaped_selector , html_quote ( name ) ) ; } } safe_free ( escaped_selector <S2SV_ModEnd> ) ; } <S2SV_ModStart> recno ) { outbuf . appendf ( \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>Record#<S2SV_blank>%d<br><i>%s</i></H2>\\\\n<PRE>\" , recno , html_quote ( result ) ) ; gopherState -> cso_recno = recno ; } else { outbuf . appendf ( \"%s\\\\n\" , html_quote ( result ) ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 502 : { outbuf . appendf ( \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>%s</H2>\\\\n<PRE>\" , html_quote ( result ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( outbuf . length <S2SV_ModEnd> ( ) > <S2SV_ModStart> ( outbuf . rawContent <S2SV_ModEnd> ( ) , <S2SV_ModStart> , outbuf . length <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> return ; }"}
{"source": "CWE-415 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; <S2SV_StartBug> char szLineConv [ 1024 ] ; <S2SV_EndBug> unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = gf_fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; j ++ ; szLine [ i ] &= 0xbf ; } else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } szLineConv [ j ] = szLine [ i ] ; j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) # else if ( unicode_type == 2 ) # endif { i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; <S2SV_StartBug> i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; <S2SV_EndBug> szLineConv [ i ] = 0 ; strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) gf_fgetc ( txt_in ) ; return sOK ; }", "target": "<S2SV_ModStart> char szLineConv [ 2048 <S2SV_ModEnd> ] ; unsigned <S2SV_ModStart> ( szLineConv , 2048 <S2SV_ModEnd> , ( const"}
{"source": "CWE-843 Status ConcatShapeHelper ( InferenceContext * c , int start_value_index , int end_value_index , int dim_index ) { ShapeHandle unused ; TF_RETURN_IF_ERROR ( c -> WithRank ( c -> input ( dim_index ) , 0 , & unused ) ) ; const Tensor * concat_dim_t = c -> input_tensor ( dim_index ) ; if ( concat_dim_t == nullptr ) { int32_t rank = InferenceContext : : kUnknownRank ; for ( int i = start_value_index ; i < end_value_index ; ++ i ) { if ( rank == InferenceContext : : kUnknownRank ) rank = c -> Rank ( c -> input ( i ) ) ; if ( rank != InferenceContext : : kUnknownRank ) { break ; } } if ( rank == InferenceContext : : kUnknownRank ) { c -> set_output ( 0 , c -> UnknownShape ( ) ) ; return Status : : OK ( ) ; } else if ( rank == 0 ) { return errors : : InvalidArgument ( \"Can\\'t<S2SV_blank>concatenate<S2SV_blank>scalars<S2SV_blank>(use<S2SV_blank>tf.stack<S2SV_blank>instead)\" ) ; } else { for ( int i = start_value_index ; i < end_value_index ; ++ i ) { TF_RETURN_IF_ERROR ( c -> WithRank ( c -> input ( i ) , rank , & unused ) ) ; } } std : : vector < DimensionHandle > dims ; dims . reserve ( rank ) ; for ( int i = 0 ; i < rank ; ++ i ) dims . push_back ( c -> UnknownDim ( ) ) ; c -> set_output ( 0 , c -> MakeShape ( dims ) ) ; return Status : : OK ( ) ; } int64_t concat_dim ; if ( concat_dim_t -> dtype ( ) == DT_INT32 ) { concat_dim = static_cast < int64_t > ( concat_dim_t -> flat < int32 > ( ) ( 0 ) ) ; } else { concat_dim = concat_dim_t -> flat < int64_t > ( ) ( 0 ) ; } <S2SV_StartBug> const int min_rank = concat_dim < 0 ? - concat_dim : concat_dim + 1 ; <S2SV_EndBug> ShapeHandle output_before ; ShapeHandle output_after ; ShapeHandle input = c -> input ( end_value_index - 1 ) ; TF_RETURN_IF_ERROR ( c -> WithRankAtLeast ( input , min_rank , & input ) ) ; TF_RETURN_IF_ERROR ( c -> Subshape ( input , 0 , concat_dim , & output_before ) ) ; DimensionHandle output_middle = c -> Dim ( input , concat_dim ) ; if ( concat_dim == - 1 ) { output_after = c -> Scalar ( ) ; } else { TF_RETURN_IF_ERROR ( c -> Subshape ( input , concat_dim + 1 , & output_after ) ) ; } for ( int i = end_value_index - 2 ; i >= start_value_index ; -- i ) { ShapeHandle before ; ShapeHandle after ; input = c -> input ( i ) ; TF_RETURN_IF_ERROR ( c -> WithRankAtLeast ( input , min_rank , & input ) ) ; TF_RETURN_IF_ERROR ( c -> Subshape ( input , 0 , concat_dim , & before ) ) ; DimensionHandle middle = c -> Dim ( input , concat_dim ) ; if ( concat_dim == - 1 ) { after = c -> Scalar ( ) ; } else { TF_RETURN_IF_ERROR ( c -> Subshape ( input , concat_dim + 1 , & after ) ) ; } TF_RETURN_IF_ERROR ( c -> Merge ( before , output_before , & output_before ) ) ; TF_RETURN_IF_ERROR ( c -> Add ( output_middle , middle , & output_middle ) ) ; TF_RETURN_IF_ERROR ( c -> Merge ( after , output_after , & output_after ) ) ; } ShapeHandle s ; TF_RETURN_IF_ERROR ( c -> Concatenate ( output_before , c -> Vector ( output_middle ) , & s ) ) ; TF_RETURN_IF_ERROR ( c -> Concatenate ( s , output_after , & s ) ) ; c -> set_output ( 0 , s ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ; } const int64 <S2SV_ModEnd> min_rank = concat_dim"}
{"source": "CWE-415 GF_Err iloc_box_read ( GF_Box * s , GF_BitStream * bs ) { u32 item_count , extent_count , i , j ; GF_ItemLocationBox * ptr = ( GF_ItemLocationBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 2 ) ptr -> offset_size = gf_bs_read_int ( bs , 4 ) ; ptr -> length_size = gf_bs_read_int ( bs , 4 ) ; ptr -> base_offset_size = gf_bs_read_int ( bs , 4 ) ; if ( ptr -> version == 1 || ptr -> version == 2 ) { ptr -> index_size = gf_bs_read_int ( bs , 4 ) ; } else { gf_bs_read_int ( bs , 4 ) ; } if ( ptr -> version < 2 ) { ISOM_DECREASE_SIZE ( ptr , 2 ) item_count = gf_bs_read_u16 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) item_count = gf_bs_read_u32 ( bs ) ; } for ( i = 0 ; i < item_count ; i ++ ) { <S2SV_StartBug> GF_ItemLocationEntry * location_entry = ( GF_ItemLocationEntry * ) gf_malloc ( sizeof ( GF_ItemLocationEntry ) ) ; <S2SV_EndBug> if ( ! location_entry ) return GF_OUT_OF_MEM ; gf_list_add ( ptr -> location_entries , location_entry ) ; if ( ptr -> version < 2 ) { ISOM_DECREASE_SIZE ( ptr , 2 ) location_entry -> item_ID = gf_bs_read_u16 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) location_entry -> item_ID = gf_bs_read_u32 ( bs ) ; } if ( ptr -> version == 1 || ptr -> version == 2 ) { ISOM_DECREASE_SIZE ( ptr , 2 ) location_entry -> construction_method = gf_bs_read_u16 ( bs ) ; } else { location_entry -> construction_method = 0 ; } ISOM_DECREASE_SIZE ( ptr , ( 2 + ptr -> base_offset_size ) ) location_entry -> data_reference_index = gf_bs_read_u16 ( bs ) ; location_entry -> base_offset = gf_bs_read_int ( bs , 8 * ptr -> base_offset_size ) ; # ifndef GPAC_DISABLE_ISOM_WRITE location_entry -> original_base_offset = location_entry -> base_offset ; # endif ISOM_DECREASE_SIZE ( ptr , 2 ) extent_count = gf_bs_read_u16 ( bs ) ; location_entry -> extent_entries = gf_list_new ( ) ; for ( j = 0 ; j < extent_count ; j ++ ) { <S2SV_StartBug> GF_ItemExtentEntry * extent_entry = ( GF_ItemExtentEntry * ) gf_malloc ( sizeof ( GF_ItemExtentEntry ) ) ; <S2SV_EndBug> if ( ! extent_entry ) return GF_OUT_OF_MEM ; gf_list_add ( location_entry -> extent_entries , extent_entry ) ; if ( ( ptr -> version == 1 || ptr -> version == 2 ) && ptr -> index_size > 0 ) { ISOM_DECREASE_SIZE ( ptr , ptr -> index_size ) extent_entry -> extent_index = gf_bs_read_int ( bs , 8 * ptr -> index_size ) ; } else { extent_entry -> extent_index = 0 ; } ISOM_DECREASE_SIZE ( ptr , ( ptr -> offset_size + ptr -> length_size ) ) extent_entry -> extent_offset = gf_bs_read_int ( bs , 8 * ptr -> offset_size ) ; extent_entry -> extent_length = gf_bs_read_int ( bs , 8 * ptr -> length_size ) ; # ifndef GPAC_DISABLE_ISOM_WRITE extent_entry -> original_extent_offset = extent_entry -> extent_offset ; # endif } } return GF_OK ; }", "target": "<S2SV_ModStart> GF_ItemLocationEntry * location_entry ; GF_SAFEALLOC ( location_entry , GF_ItemLocationEntry <S2SV_ModEnd> ) ; if <S2SV_ModStart> GF_ItemExtentEntry * extent_entry ; GF_SAFEALLOC ( extent_entry , GF_ItemExtentEntry <S2SV_ModEnd> ) ; if"}
{"source": "CWE-190 void Compute ( OpKernelContext * ctx ) override { const Tensor * indices_t , * values_t , * shape_t , * dense_t ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"sp_indices\" , & indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"sp_values\" , & values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"sp_shape\" , & shape_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"dense\" , & dense_t ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( indices_t -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>sp_indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape:<S2SV_blank>\" , indices_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( values_t -> shape ( ) ) && TensorShapeUtils : : IsVector ( shape_t -> shape ( ) ) , errors : : InvalidArgument ( \"Inputs<S2SV_blank>sp_values<S2SV_blank>and<S2SV_blank>sp_shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>vectors<S2SV_blank>\" \"but<S2SV_blank>received<S2SV_blank>shapes:<S2SV_blank>\" , values_t -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , shape_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( shape_t -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>sp_shape<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector.<S2SV_blank>Got:<S2SV_blank>\" , shape_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , values_t -> dim_size ( 0 ) == indices_t -> dim_size ( 0 ) , errors : : InvalidArgument ( \"The<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>values<S2SV_blank>and<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>match.<S2SV_blank>(\" , values_t -> dim_size ( 0 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , indices_t -> dim_size ( 0 ) , \")\" ) ) ; OP_REQUIRES ( ctx , shape_t -> shape ( ) . dim_size ( 0 ) == indices_t -> shape ( ) . dim_size ( 1 ) , errors : : InvalidArgument ( \"Number<S2SV_blank>of<S2SV_blank>dimensions<S2SV_blank>must<S2SV_blank>match<S2SV_blank>second<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices.<S2SV_blank>\" , \"Got<S2SV_blank>\" , shape_t -> shape ( ) . dim_size ( 0 ) , \"<S2SV_blank>dimensions,<S2SV_blank>indices<S2SV_blank>shape:<S2SV_blank>\" , indices_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , shape_t -> NumElements ( ) > 0 , errors : : InvalidArgument ( \"The<S2SV_blank>shape<S2SV_blank>argument<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>element.\" ) ) ; const auto indices_mat = indices_t -> matrix < int64_t > ( ) ; const auto shape_vec = shape_t -> vec < int64_t > ( ) ; <S2SV_StartBug> const auto lhs_dims = BCast : : FromShape ( TensorShape ( shape_vec ) ) ; <S2SV_EndBug> const auto rhs_dims = BCast : : FromShape ( dense_t -> shape ( ) ) ; BCast b ( lhs_dims , rhs_dims , false ) ; auto VecGreaterEq = [ ] ( ArraySlice < int64_t > lhs , ArraySlice < int64_t > rhs ) { if ( lhs . size ( ) < rhs . size ( ) ) return false ; for ( size_t i = 0 ; i < rhs . size ( ) ; ++ i ) { if ( lhs [ lhs . size ( ) - 1 - i ] < rhs [ rhs . size ( ) - 1 - i ] ) return false ; } return true ; } ; OP_REQUIRES ( ctx , VecGreaterEq ( lhs_dims , rhs_dims ) && b . IsValid ( ) , errors : : InvalidArgument ( \"SparseDenseBinaryOpShared<S2SV_blank>broadcasts<S2SV_blank>dense<S2SV_blank>to<S2SV_blank>sparse<S2SV_blank>\" \"only;<S2SV_blank>got<S2SV_blank>incompatible<S2SV_blank>shapes:<S2SV_blank>[\" , absl : : StrJoin ( lhs_dims , \",\" ) , \"]<S2SV_blank>vs.<S2SV_blank>[\" , absl : : StrJoin ( rhs_dims , \",\" ) , \"]\" ) ) ; Tensor * output_values = nullptr ; Tensor dense_gathered ; const int64_t nnz = indices_t -> dim_size ( 0 ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { nnz } ) , & output_values ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > : : value , TensorShape ( { nnz } ) , & dense_gathered ) ) ; bool op_is_div = false ; if ( absl : : StrContains ( ctx -> op_kernel ( ) . type_string_view ( ) , \"Div\" ) ) { op_is_div = true ; } auto dense_gathered_flat = dense_gathered . flat < T > ( ) ; const int ndims = lhs_dims . size ( ) ; switch ( ndims ) { # define CASE ( NDIM ) case NDIM : { TensorRef < Eigen : : Tensor < const T , NDIM , Eigen : : RowMajor >> rhs_ref = dense_t -> shaped < T , NDIM > ( b . y_reshape ( ) ) . broadcast ( BCast : : ToIndexArray < NDIM > ( b . y_bcast ( ) ) ) ; Eigen : : array < Eigen : : DenseIndex , NDIM > idx ; bool indices_valid = true ; for ( int i = 0 ; i < nnz ; ++ i ) { for ( int d = 0 ; d < NDIM ; ++ d ) { idx [ d ] = internal : : SubtleMustCopy ( indices_mat ( i , d ) ) ; if ( ! FastBoundsCheck ( idx [ d ] , rhs_ref . dimension ( d ) ) ) { indices_valid = false ; } } OP_REQUIRES ( ctx , indices_valid , errors : : InvalidArgument ( \"Provided<S2SV_blank>indices<S2SV_blank>are<S2SV_blank>out-of-bounds<S2SV_blank>w.r.t.<S2SV_blank>\" \"dense<S2SV_blank>side<S2SV_blank>with<S2SV_blank>broadcasted<S2SV_blank>shape\" ) ) ; dense_gathered_flat ( i ) = rhs_ref . coeff ( idx ) ; if ( op_is_div ) { OP_REQUIRES ( ctx , dense_gathered_flat ( i ) != 0 , errors : : InvalidArgument ( \"SparseDenseCwiseDiv<S2SV_blank>cannot<S2SV_blank>divide<S2SV_blank>by<S2SV_blank>zero,\" \"but<S2SV_blank>input<S2SV_blank>dense<S2SV_blank>tensor<S2SV_blank>contains<S2SV_blank>zero<S2SV_blank>\" ) ) ; } } break ; } CASE ( 1 ) ; CASE ( 2 ) ; CASE ( 3 ) ; CASE ( 4 ) ; CASE ( 5 ) ; default : OP_REQUIRES ( ctx , false , errors : : InvalidArgument ( \"Only<S2SV_blank>tensors<S2SV_blank>with<S2SV_blank>ranks<S2SV_blank>between<S2SV_blank>1<S2SV_blank>and<S2SV_blank>5<S2SV_blank>\" \"are<S2SV_blank>currently<S2SV_blank>supported.<S2SV_blank><S2SV_blank>Tensor<S2SV_blank>rank:<S2SV_blank>\" , ndims ) ) ; # undef CASE } output_values -> flat < T > ( ) . device ( ctx -> eigen_device < Device > ( ) ) = values_t -> flat < T > ( ) . binaryExpr ( dense_gathered_flat , typename Functor : : func ( ) ) ; }", "target": "<S2SV_ModStart> ( ) ; TensorShape lhs_shape ; OP_REQUIRES_OK ( ctx , TensorShape : : BuildTensorShape ( shape_vec , & lhs_shape ) ) ; <S2SV_ModStart> : FromShape ( lhs_shape <S2SV_ModEnd> ) ; const"}
{"source": "CWE-125 void Compute ( OpKernelContext * context ) override { typedef Eigen : : Map < const Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> ConstEigenMatrixMap ; typedef Eigen : : Map < Eigen : : Matrix < double , Eigen : : Dynamic , Eigen : : Dynamic >> EigenDoubleMatrixMap ; const Tensor & orig_input_tensor_shape = context -> input ( 0 ) ; OP_REQUIRES ( context , orig_input_tensor_shape . dims ( ) == 1 && orig_input_tensor_shape . NumElements ( ) == 4 , errors : : InvalidArgument ( \"original<S2SV_blank>input<S2SV_blank>tensor<S2SV_blank>shape<S2SV_blank>must<S2SV_blank>be\" \"1-dimensional<S2SV_blank>and<S2SV_blank>4<S2SV_blank>elements\" ) ) ; const Tensor & out_backprop = context -> input ( 1 ) ; const Tensor & row_seq_tensor = context -> input ( 2 ) ; const Tensor & col_seq_tensor = context -> input ( 3 ) ; const int64_t out_batch = out_backprop . dim_size ( 0 ) ; const int64_t out_rows = out_backprop . dim_size ( 1 ) ; const int64_t out_cols = out_backprop . dim_size ( 2 ) ; const int64_t out_depth = out_backprop . dim_size ( 3 ) ; OP_REQUIRES ( context , row_seq_tensor . NumElements ( ) > out_rows , errors : : InvalidArgument ( \"Given<S2SV_blank>out_backprop<S2SV_blank>shape<S2SV_blank>\" , out_backprop . shape ( ) . DebugString ( ) , \",<S2SV_blank>row_seq_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>\" , out_rows + 1 , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , row_seq_tensor . NumElements ( ) ) ) ; OP_REQUIRES ( context , col_seq_tensor . NumElements ( ) > out_cols , errors : : InvalidArgument ( \"Given<S2SV_blank>out_backprop<S2SV_blank>shape<S2SV_blank>\" , out_backprop . shape ( ) . DebugString ( ) , \",<S2SV_blank>col_seq_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>\" , out_cols + 1 , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , col_seq_tensor . NumElements ( ) ) ) ; auto row_seq_tensor_flat = row_seq_tensor . flat < int64_t > ( ) ; auto col_seq_tensor_flat = col_seq_tensor . flat < int64_t > ( ) ; auto orig_input_tensor_shape_flat = orig_input_tensor_shape . flat < int64_t > ( ) ; const int64_t in_batch = orig_input_tensor_shape_flat ( 0 ) ; const int64_t in_rows = orig_input_tensor_shape_flat ( 1 ) ; const int64_t in_cols = orig_input_tensor_shape_flat ( 2 ) ; const int64_t in_depth = orig_input_tensor_shape_flat ( 3 ) ; OP_REQUIRES ( context , in_batch != 0 , errors : : InvalidArgument ( \"Batch<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" ) ) ; OP_REQUIRES ( context , in_rows != 0 , errors : : InvalidArgument ( \"Rows<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" ) ) ; OP_REQUIRES ( context , in_cols != 0 , errors : : InvalidArgument ( \"Columns<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" ) ) ; OP_REQUIRES ( context , in_depth != 0 , errors : : InvalidArgument ( \"Depth<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" ) ) ; constexpr int tensor_in_and_out_dims = 4 ; TensorShape in_shape ; for ( auto i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { in_shape . AddDim ( orig_input_tensor_shape_flat ( i ) ) ; } Tensor in_backprop_tensor_temp ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_temp ( { 0 } , DataTypeToEnum < double > : : v ( ) , in_shape , & in_backprop_tensor_temp ) ) ; in_backprop_tensor_temp . flat < double > ( ) . setZero ( ) ; EigenDoubleMatrixMap in_backprop_tensor_temp_mat ( in_backprop_tensor_temp . flat < double > ( ) . data ( ) , in_depth , in_cols * in_rows * in_batch ) ; ConstEigenMatrixMap out_backprop_mat ( out_backprop . flat < T > ( ) . data ( ) , out_depth , out_cols * out_rows * out_batch ) ; const int64_t in_max_row_index = in_rows - 1 ; const int64_t in_max_col_index = in_cols - 1 ; for ( int64_t b = 0 ; b < out_batch ; ++ b ) { for ( int64_t r = 0 ; r < out_rows ; ++ r ) { const int64_t in_row_start = row_seq_tensor_flat ( r ) ; int64_t in_row_end = overlapping_ ? row_seq_tensor_flat ( r + 1 ) : row_seq_tensor_flat ( r + 1 ) - 1 ; in_row_end = std : : min ( in_row_end , in_max_row_index ) ; <S2SV_StartBug> for ( int64_t c = 0 ; c < out_cols ; ++ c ) { <S2SV_EndBug> const int64_t in_col_start = col_seq_tensor_flat ( c ) ; int64_t in_col_end = overlapping_ ? col_seq_tensor_flat ( c + 1 ) : col_seq_tensor_flat ( c + 1 ) - 1 ; in_col_end = std : : min ( in_col_end , in_max_col_index ) ; <S2SV_StartBug> const int64_t num_elements_in_pooling_cell = <S2SV_EndBug> ( in_row_end - in_row_start + 1 ) * ( in_col_end - in_col_start + 1 ) ; const int64_t out_index = ( b * out_rows + r ) * out_cols + c ; for ( int64_t in_r = in_row_start ; in_r <= in_row_end ; ++ in_r ) { for ( int64_t in_c = in_col_start ; in_c <= in_col_end ; ++ in_c ) { const int64_t in_index = ( b * in_rows + in_r ) * in_cols + in_c ; for ( int64_t d = 0 ; d < out_depth ; ++ d ) { const double out_backprop_element = static_cast < double > ( out_backprop_mat . coeffRef ( d , out_index ) ) ; double & in_backprop_ref = in_backprop_tensor_temp_mat . coeffRef ( d , in_index ) ; in_backprop_ref += out_backprop_element / num_elements_in_pooling_cell ; } } } } } } Tensor * in_backprop_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 0 , in_shape , & in_backprop_tensor ) ) ; auto in_backprop_tensor_flat = in_backprop_tensor -> flat < T > ( ) ; auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp . flat < double > ( ) ; for ( int64_t i = 0 ; i < in_backprop_tensor_flat . size ( ) ; ++ i ) { in_backprop_tensor_flat ( i ) = static_cast < T > ( in_backprop_tensor_temp_flat ( i ) ) ; } }", "target": "<S2SV_ModStart> in_max_row_index ) ; OP_REQUIRES ( context , in_row_start >= 0 && in_row_end >= 0 , errors : : InvalidArgument ( \"Row<S2SV_blank>sequence<S2SV_blank>tensor<S2SV_blank>values<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>negative,<S2SV_blank>got<S2SV_blank>\" , row_seq_tensor_flat ) ) ; <S2SV_ModStart> in_max_col_index ) ; OP_REQUIRES ( context , in_col_start >= 0 && in_col_end >= 0 , errors : : InvalidArgument ( \"Column<S2SV_blank>sequence<S2SV_blank>tensor<S2SV_blank>values<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>negative,<S2SV_blank>got<S2SV_blank>\" , col_seq_tensor_flat ) ) ;"}
{"source": "CWE-276 flatpak_dir_ensure_bundle_remote ( FlatpakDir * self , GFile * file , GBytes * extra_gpg_data , FlatpakDecomposed * * out_ref , char * * out_checksum , char * * out_metadata , gboolean * out_created_remote , GCancellable * cancellable , GError * * error ) { g_autoptr ( FlatpakDecomposed ) ref = NULL ; gboolean created_remote = FALSE ; g_autoptr ( GBytes ) deploy_data = NULL ; g_autoptr ( GVariant ) metadata = NULL ; g_autofree char * origin = NULL ; g_autofree char * fp_metadata = NULL ; g_autofree char * basename = NULL ; g_autoptr ( GBytes ) included_gpg_data = NULL ; GBytes * gpg_data = NULL ; g_autofree char * to_checksum = NULL ; g_autofree char * remote = NULL ; g_autofree char * collection_id = NULL ; if ( ! flatpak_dir_ensure_repo ( self , cancellable , error ) ) return NULL ; metadata = flatpak_bundle_load ( file , & to_checksum , & ref , & origin , NULL , & fp_metadata , NULL , & included_gpg_data , & collection_id , error ) ; if ( metadata == NULL ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data ; deploy_data = flatpak_dir_get_deploy_data ( self , ref , FLATPAK_DEPLOY_VERSION_ANY , cancellable , NULL ) ; if ( deploy_data != NULL ) { remote = g_strdup ( flatpak_deploy_data_get_origin ( deploy_data ) ) ; if ( gpg_data != NULL ) { g_autoptr ( GKeyFile ) new_config = NULL ; new_config = ostree_repo_copy_config ( flatpak_dir_get_repo ( self ) ) ; if ( ! flatpak_dir_modify_remote ( self , remote , new_config , gpg_data , cancellable , error ) ) return NULL ; } } else { g_autofree char * id = flatpak_decomposed_dup_id ( ref ) ; basename = g_file_get_basename ( file ) ; remote = flatpak_dir_create_origin_remote ( self , origin , id , basename , flatpak_decomposed_get_ref ( ref ) , gpg_data , collection_id , & created_remote , cancellable , error ) ; if ( remote == NULL ) return NULL ; } if ( out_created_remote ) * out_created_remote = created_remote ; if ( out_ref ) * out_ref = g_steal_pointer ( & ref ) ; if ( out_checksum ) * out_checksum = g_steal_pointer ( & to_checksum ) ; if ( out_metadata ) * out_metadata = g_steal_pointer ( & fp_metadata ) ; return g_steal_pointer ( & remote ) ; }", "target": "<S2SV_ModStart> return NULL ; if ( out_metadata && fp_metadata == NULL ) { flatpak_fail_error ( error , FLATPAK_ERROR_INVALID_DATA , \"No<S2SV_blank>metadata<S2SV_blank>in<S2SV_blank>bundler<S2SV_blank>header\" ) ; return NULL ; }"}
{"source": "CWE-522 PQconnectPoll ( PGconn * conn ) { bool reset_connection_state_machine = false ; bool need_new_connection = false ; PGresult * res ; char sebuf [ PG_STRERROR_R_BUFLEN ] ; int optval ; if ( conn == NULL ) return PGRES_POLLING_FAILED ; switch ( conn -> status ) { case CONNECTION_BAD : return PGRES_POLLING_FAILED ; case CONNECTION_OK : return PGRES_POLLING_OK ; case CONNECTION_AWAITING_RESPONSE : case CONNECTION_AUTH_OK : case CONNECTION_CHECK_WRITABLE : case CONNECTION_CONSUME : case CONNECTION_CHECK_STANDBY : { int n = pqReadData ( conn ) ; if ( n < 0 ) goto error_return ; if ( n == 0 ) return PGRES_POLLING_READING ; break ; } case CONNECTION_STARTED : case CONNECTION_MADE : break ; case CONNECTION_SSL_STARTUP : case CONNECTION_NEEDED : case CONNECTION_GSS_STARTUP : case CONNECTION_CHECK_TARGET : break ; default : appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"invalid<S2SV_blank>connection<S2SV_blank>state,<S2SV_blank>probably<S2SV_blank>indicative<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>corruption\\\\n\" ) ) ; goto error_return ; } keep_going : if ( conn -> try_next_addr ) { if ( conn -> addr_cur && conn -> addr_cur -> ai_next ) { conn -> addr_cur = conn -> addr_cur -> ai_next ; reset_connection_state_machine = true ; } else conn -> try_next_host = true ; conn -> try_next_addr = false ; } if ( conn -> try_next_host ) { pg_conn_host * ch ; struct addrinfo hint ; int thisport ; int ret ; char portstr [ MAXPGPATH ] ; if ( conn -> whichhost + 1 < conn -> nconnhost ) conn -> whichhost ++ ; else { if ( conn -> target_server_type == SERVER_TYPE_PREFER_STANDBY && conn -> nconnhost > 0 ) { conn -> target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2 ; conn -> whichhost = 0 ; } else goto error_return ; } release_conn_addrinfo ( conn ) ; ch = & conn -> connhost [ conn -> whichhost ] ; MemSet ( & hint , 0 , sizeof ( hint ) ) ; hint . ai_socktype = SOCK_STREAM ; conn -> addrlist_family = hint . ai_family = AF_UNSPEC ; if ( ch -> port == NULL || ch -> port [ 0 ] == '\\\\0' ) thisport = DEF_PGPORT ; else { if ( ! parse_int_param ( ch -> port , & thisport , conn , \"port\" ) ) goto error_return ; if ( thisport < 1 || thisport > 65535 ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"invalid<S2SV_blank>port<S2SV_blank>number:<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" ) , ch -> port ) ; goto keep_going ; } } snprintf ( portstr , sizeof ( portstr ) , \"%d\" , thisport ) ; switch ( ch -> type ) { case CHT_HOST_NAME : ret = pg_getaddrinfo_all ( ch -> host , portstr , & hint , & conn -> addrlist ) ; if ( ret || ! conn -> addrlist ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>translate<S2SV_blank>host<S2SV_blank>name<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>to<S2SV_blank>address:<S2SV_blank>%s\\\\n\" ) , ch -> host , gai_strerror ( ret ) ) ; goto keep_going ; } break ; case CHT_HOST_ADDRESS : hint . ai_flags = AI_NUMERICHOST ; ret = pg_getaddrinfo_all ( ch -> hostaddr , portstr , & hint , & conn -> addrlist ) ; if ( ret || ! conn -> addrlist ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>network<S2SV_blank>address<S2SV_blank>\\\\\"%s\\\\\":<S2SV_blank>%s\\\\n\" ) , ch -> hostaddr , gai_strerror ( ret ) ) ; goto keep_going ; } break ; case CHT_UNIX_SOCKET : # ifdef HAVE_UNIX_SOCKETS conn -> addrlist_family = hint . ai_family = AF_UNIX ; UNIXSOCK_PATH ( portstr , thisport , ch -> host ) ; if ( strlen ( portstr ) >= UNIXSOCK_PATH_BUFLEN ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"Unix-domain<S2SV_blank>socket<S2SV_blank>path<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(maximum<S2SV_blank>%d<S2SV_blank>bytes)\\\\n\" ) , portstr , ( int ) ( UNIXSOCK_PATH_BUFLEN - 1 ) ) ; goto keep_going ; } ret = pg_getaddrinfo_all ( NULL , portstr , & hint , & conn -> addrlist ) ; if ( ret || ! conn -> addrlist ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>translate<S2SV_blank>Unix-domain<S2SV_blank>socket<S2SV_blank>path<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>to<S2SV_blank>address:<S2SV_blank>%s\\\\n\" ) , portstr , gai_strerror ( ret ) ) ; goto keep_going ; } # else Assert ( false ) ; # endif break ; } conn -> addr_cur = conn -> addrlist ; reset_connection_state_machine = true ; conn -> try_next_host = false ; } if ( reset_connection_state_machine ) { conn -> pversion = PG_PROTOCOL ( 3 , 0 ) ; conn -> send_appname = true ; # ifdef USE_SSL conn -> allow_ssl_try = ( conn -> sslmode [ 0 ] != 'd' ) ; conn -> wait_ssl_try = ( conn -> sslmode [ 0 ] == 'a' ) ; # endif # ifdef ENABLE_GSS conn -> try_gss = ( conn -> gssencmode [ 0 ] != 'd' ) ; # endif reset_connection_state_machine = false ; need_new_connection = true ; } if ( need_new_connection ) { pqDropConnection ( conn , true ) ; pqDropServerData ( conn ) ; conn -> asyncStatus = PGASYNC_IDLE ; conn -> xactStatus = PQTRANS_IDLE ; conn -> pipelineStatus = PQ_PIPELINE_OFF ; pqClearAsyncResult ( conn ) ; conn -> status = CONNECTION_NEEDED ; need_new_connection = false ; } switch ( conn -> status ) { case CONNECTION_NEEDED : { { struct addrinfo * addr_cur = conn -> addr_cur ; char host_addr [ NI_MAXHOST ] ; if ( addr_cur == NULL ) { conn -> try_next_host = true ; goto keep_going ; } memcpy ( & conn -> raddr . addr , addr_cur -> ai_addr , addr_cur -> ai_addrlen ) ; conn -> raddr . salen = addr_cur -> ai_addrlen ; if ( conn -> connip != NULL ) { free ( conn -> connip ) ; conn -> connip = NULL ; } getHostaddr ( conn , host_addr , NI_MAXHOST ) ; if ( host_addr [ 0 ] ) conn -> connip = strdup ( host_addr ) ; conn -> sock = socket ( addr_cur -> ai_family , SOCK_STREAM , 0 ) ; if ( conn -> sock == PGINVALID_SOCKET ) { int errorno = SOCK_ERRNO ; if ( addr_cur -> ai_next != NULL || conn -> whichhost + 1 < conn -> nconnhost ) { conn -> try_next_addr = true ; goto keep_going ; } emitHostIdentityInfo ( conn , host_addr ) ; appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>socket:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( errorno , sebuf , sizeof ( sebuf ) ) ) ; goto error_return ; } emitHostIdentityInfo ( conn , host_addr ) ; if ( ! IS_AF_UNIX ( addr_cur -> ai_family ) ) { if ( ! connectNoDelay ( conn ) ) { conn -> try_next_addr = true ; goto keep_going ; } } if ( ! pg_set_noblock ( conn -> sock ) ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>nonblocking<S2SV_blank>mode:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; conn -> try_next_addr = true ; goto keep_going ; } # ifdef F_SETFD if ( fcntl ( conn -> sock , F_SETFD , FD_CLOEXEC ) == - 1 ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>close-on-exec<S2SV_blank>mode:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; conn -> try_next_addr = true ; goto keep_going ; } # endif if ( ! IS_AF_UNIX ( addr_cur -> ai_family ) ) { # ifndef WIN32 int on = 1 ; # endif int usekeepalives = useKeepalives ( conn ) ; int err = 0 ; if ( usekeepalives < 0 ) { appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"keepalives<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>integer\\\\n\" ) ) ; err = 1 ; } else if ( usekeepalives == 0 ) { } # ifndef WIN32 else if ( setsockopt ( conn -> sock , SOL_SOCKET , SO_KEEPALIVE , ( char * ) & on , sizeof ( on ) ) < 0 ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"%s(%s)<S2SV_blank>failed:<S2SV_blank>%s\\\\n\" ) , \"setsockopt\" , \"SO_KEEPALIVE\" , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; err = 1 ; } else if ( ! setKeepalivesIdle ( conn ) || ! setKeepalivesInterval ( conn ) || ! setKeepalivesCount ( conn ) ) err = 1 ; # else # ifdef SIO_KEEPALIVE_VALS else if ( ! setKeepalivesWin32 ( conn ) ) err = 1 ; # endif # endif else if ( ! setTCPUserTimeout ( conn ) ) err = 1 ; if ( err ) { conn -> try_next_addr = true ; goto keep_going ; } } conn -> sigpipe_so = false ; # ifdef MSG_NOSIGNAL conn -> sigpipe_flag = true ; # else conn -> sigpipe_flag = false ; # endif # ifdef SO_NOSIGPIPE optval = 1 ; if ( setsockopt ( conn -> sock , SOL_SOCKET , SO_NOSIGPIPE , ( char * ) & optval , sizeof ( optval ) ) == 0 ) { conn -> sigpipe_so = true ; conn -> sigpipe_flag = false ; } # endif if ( connect ( conn -> sock , addr_cur -> ai_addr , addr_cur -> ai_addrlen ) < 0 ) { if ( SOCK_ERRNO == EINPROGRESS || # ifdef WIN32 SOCK_ERRNO == EWOULDBLOCK || # endif SOCK_ERRNO == EINTR ) { conn -> status = CONNECTION_STARTED ; return PGRES_POLLING_WRITING ; } } else { conn -> status = CONNECTION_STARTED ; goto keep_going ; } connectFailureMessage ( conn , SOCK_ERRNO ) ; conn -> try_next_addr = true ; goto keep_going ; } } case CONNECTION_STARTED : { ACCEPT_TYPE_ARG3 optlen = sizeof ( optval ) ; if ( getsockopt ( conn -> sock , SOL_SOCKET , SO_ERROR , ( char * ) & optval , & optlen ) == - 1 ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>socket<S2SV_blank>error<S2SV_blank>status:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; goto error_return ; } else if ( optval != 0 ) { connectFailureMessage ( conn , optval ) ; conn -> try_next_addr = true ; goto keep_going ; } conn -> laddr . salen = sizeof ( conn -> laddr . addr ) ; if ( getsockname ( conn -> sock , ( struct sockaddr * ) & conn -> laddr . addr , & conn -> laddr . salen ) < 0 ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>client<S2SV_blank>address<S2SV_blank>from<S2SV_blank>socket:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; goto error_return ; } conn -> status = CONNECTION_MADE ; return PGRES_POLLING_WRITING ; } case CONNECTION_MADE : { char * startpacket ; int packetlen ; if ( conn -> requirepeer && conn -> requirepeer [ 0 ] && IS_AF_UNIX ( conn -> raddr . addr . ss_family ) ) { # ifndef WIN32 char pwdbuf [ BUFSIZ ] ; struct passwd pass_buf ; struct passwd * pass ; int passerr ; # endif uid_t uid ; gid_t gid ; errno = 0 ; if ( getpeereid ( conn -> sock , & uid , & gid ) != 0 ) { if ( errno == ENOSYS ) appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"requirepeer<S2SV_blank>parameter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform\\\\n\" ) ) ; else appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>peer<S2SV_blank>credentials:<S2SV_blank>%s\\\\n\" ) , strerror_r ( errno , sebuf , sizeof ( sebuf ) ) ) ; goto error_return ; } # ifndef WIN32 passerr = pqGetpwuid ( uid , & pass_buf , pwdbuf , sizeof ( pwdbuf ) , & pass ) ; if ( pass == NULL ) { if ( passerr != 0 ) appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>look<S2SV_blank>up<S2SV_blank>local<S2SV_blank>user<S2SV_blank>ID<S2SV_blank>%d:<S2SV_blank>%s\\\\n\" ) , ( int ) uid , strerror_r ( passerr , sebuf , sizeof ( sebuf ) ) ) ; else appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"local<S2SV_blank>user<S2SV_blank>with<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist\\\\n\" ) , ( int ) uid ) ; goto error_return ; } if ( strcmp ( pass -> pw_name , conn -> requirepeer ) != 0 ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"requirepeer<S2SV_blank>specifies<S2SV_blank>\\\\\"%s\\\\\",<S2SV_blank>but<S2SV_blank>actual<S2SV_blank>peer<S2SV_blank>user<S2SV_blank>name<S2SV_blank>is<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" ) , conn -> requirepeer , pass -> pw_name ) ; goto error_return ; } # else Assert ( false ) ; # endif } if ( IS_AF_UNIX ( conn -> raddr . addr . ss_family ) ) { # ifdef USE_SSL conn -> allow_ssl_try = false ; # endif # ifdef ENABLE_GSS conn -> try_gss = false ; # endif } # ifdef ENABLE_GSS if ( conn -> try_gss && ! conn -> gctx ) conn -> try_gss = pg_GSS_have_cred_cache ( & conn -> gcred ) ; if ( conn -> try_gss && ! conn -> gctx ) { ProtocolVersion pv = pg_hton32 ( NEGOTIATE_GSS_CODE ) ; if ( pqPacketSend ( conn , 0 , & pv , sizeof ( pv ) ) != STATUS_OK ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>send<S2SV_blank>GSSAPI<S2SV_blank>negotiation<S2SV_blank>packet:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; goto error_return ; } conn -> status = CONNECTION_GSS_STARTUP ; return PGRES_POLLING_READING ; } else if ( ! conn -> gctx && conn -> gssencmode [ 0 ] == 'r' ) { appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"GSSAPI<S2SV_blank>encryption<S2SV_blank>required<S2SV_blank>but<S2SV_blank>was<S2SV_blank>impossible<S2SV_blank>(possibly<S2SV_blank>no<S2SV_blank>credential<S2SV_blank>cache,<S2SV_blank>no<S2SV_blank>server<S2SV_blank>support,<S2SV_blank>or<S2SV_blank>using<S2SV_blank>a<S2SV_blank>local<S2SV_blank>socket)\\\\n\" ) ) ; goto error_return ; } # endif # ifdef USE_SSL if ( pqsecure_initialize ( conn , false , true ) < 0 ) goto error_return ; if ( conn -> allow_ssl_try && ! conn -> wait_ssl_try && ! conn -> ssl_in_use # ifdef ENABLE_GSS && ! conn -> gssenc # endif ) { ProtocolVersion pv ; pv = pg_hton32 ( NEGOTIATE_SSL_CODE ) ; if ( pqPacketSend ( conn , 0 , & pv , sizeof ( pv ) ) != STATUS_OK ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>send<S2SV_blank>SSL<S2SV_blank>negotiation<S2SV_blank>packet:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; goto error_return ; } conn -> status = CONNECTION_SSL_STARTUP ; return PGRES_POLLING_READING ; } # endif startpacket = pqBuildStartupPacket3 ( conn , & packetlen , EnvironmentOptions ) ; if ( ! startpacket ) { appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"out<S2SV_blank>of<S2SV_blank>memory\\\\n\" ) ) ; goto error_return ; } if ( pqPacketSend ( conn , 0 , startpacket , packetlen ) != STATUS_OK ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"could<S2SV_blank>not<S2SV_blank>send<S2SV_blank>startup<S2SV_blank>packet:<S2SV_blank>%s\\\\n\" ) , SOCK_STRERROR ( SOCK_ERRNO , sebuf , sizeof ( sebuf ) ) ) ; free ( startpacket ) ; goto error_return ; } free ( startpacket ) ; conn -> status = CONNECTION_AWAITING_RESPONSE ; return PGRES_POLLING_READING ; } case CONNECTION_SSL_STARTUP : { # ifdef USE_SSL PostgresPollingStatusType pollres ; if ( ! conn -> ssl_in_use ) { char SSLok ; int rdresult ; rdresult = pqReadData ( conn ) ; if ( rdresult < 0 ) { goto error_return ; } if ( rdresult == 0 ) { return PGRES_POLLING_READING ; } if ( pqGetc ( & SSLok , conn ) < 0 ) { return PGRES_POLLING_READING ; } if ( SSLok == 'S' ) { conn -> inStart = conn -> inCursor ; if ( pqsecure_initialize ( conn , true , false ) != 0 ) goto error_return ; } else if ( SSLok == 'N' ) { conn -> inStart = conn -> inCursor ; if ( conn -> sslmode [ 0 ] == 'r' || conn -> sslmode [ 0 ] == 'v' ) { appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"server<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>SSL,<S2SV_blank>but<S2SV_blank>SSL<S2SV_blank>was<S2SV_blank>required\\\\n\" ) ) ; goto error_return ; } conn -> allow_ssl_try = false ; conn -> status = CONNECTION_MADE ; return PGRES_POLLING_WRITING ; } else if ( SSLok == 'E' ) { conn -> status = CONNECTION_AWAITING_RESPONSE ; goto keep_going ; } else { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"received<S2SV_blank>invalid<S2SV_blank>response<S2SV_blank>to<S2SV_blank>SSL<S2SV_blank>negotiation:<S2SV_blank>%c\\\\n\" ) , SSLok ) ; goto error_return ; } } pollres = pqsecure_open_client ( conn ) ; if ( pollres == PGRES_POLLING_OK ) { <S2SV_StartBug> conn -> status = CONNECTION_MADE ; <S2SV_EndBug> return PGRES_POLLING_WRITING ; } if ( pollres == PGRES_POLLING_FAILED ) { if ( conn -> sslmode [ 0 ] == 'p' && conn -> allow_ssl_try && ! conn -> wait_ssl_try ) { conn -> allow_ssl_try = false ; need_new_connection = true ; goto keep_going ; } goto error_return ; } return pollres ; # else goto error_return ; # endif } case CONNECTION_GSS_STARTUP : { # ifdef ENABLE_GSS PostgresPollingStatusType pollres ; if ( conn -> try_gss && ! conn -> gctx ) { char gss_ok ; int rdresult = pqReadData ( conn ) ; if ( rdresult < 0 ) goto error_return ; else if ( rdresult == 0 ) return PGRES_POLLING_READING ; if ( pqGetc ( & gss_ok , conn ) < 0 ) return PGRES_POLLING_READING ; if ( gss_ok == 'E' ) { conn -> try_gss = false ; need_new_connection = true ; goto keep_going ; } conn -> inStart = conn -> inCursor ; if ( gss_ok == 'N' ) { if ( conn -> gssencmode [ 0 ] == 'r' ) { appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"server<S2SV_blank>doesn\\'t<S2SV_blank>support<S2SV_blank>GSSAPI<S2SV_blank>encryption,<S2SV_blank>but<S2SV_blank>it<S2SV_blank>was<S2SV_blank>required\\\\n\" ) ) ; goto error_return ; } conn -> try_gss = false ; conn -> status = CONNECTION_MADE ; return PGRES_POLLING_WRITING ; } else if ( gss_ok != 'G' ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"received<S2SV_blank>invalid<S2SV_blank>response<S2SV_blank>to<S2SV_blank>GSSAPI<S2SV_blank>negotiation:<S2SV_blank>%c\\\\n\" ) , gss_ok ) ; goto error_return ; } } pollres = pqsecure_open_gss ( conn ) ; if ( pollres == PGRES_POLLING_OK ) <S2SV_StartBug> { <S2SV_EndBug> conn -> status = CONNECTION_MADE ; return PGRES_POLLING_WRITING ; } else if ( pollres == PGRES_POLLING_FAILED && conn -> gssencmode [ 0 ] == 'p' ) { conn -> try_gss = false ; need_new_connection = true ; goto keep_going ; } return pollres ; # else goto error_return ; # endif } case CONNECTION_AWAITING_RESPONSE : { char beresp ; int msgLength ; int avail ; AuthRequest areq ; int res ; conn -> inCursor = conn -> inStart ; if ( pqGetc ( & beresp , conn ) ) { return PGRES_POLLING_READING ; } if ( ! ( beresp == 'R' || beresp == 'E' ) ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"expected<S2SV_blank>authentication<S2SV_blank>request<S2SV_blank>from<S2SV_blank>server,<S2SV_blank>but<S2SV_blank>received<S2SV_blank>%c\\\\n\" ) , beresp ) ; goto error_return ; } if ( pqGetInt ( & msgLength , 4 , conn ) ) { return PGRES_POLLING_READING ; } if ( beresp == 'R' && ( msgLength < 8 || msgLength > 2000 ) ) { appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"expected<S2SV_blank>authentication<S2SV_blank>request<S2SV_blank>from<S2SV_blank>server,<S2SV_blank>but<S2SV_blank>received<S2SV_blank>%c\\\\n\" ) , beresp ) ; goto error_return ; } if ( beresp == 'E' && ( msgLength < 8 || msgLength > 30000 ) ) { conn -> inCursor = conn -> inStart + 1 ; if ( pqGets_append ( & conn -> errorMessage , conn ) ) { return PGRES_POLLING_READING ; } conn -> inStart = conn -> inCursor ; if ( conn -> errorMessage . len == 0 || conn -> errorMessage . data [ conn -> errorMessage . len - 1 ] != '\\\\n' ) { appendPQExpBufferChar ( & conn -> errorMessage , '\\\\n' ) ; } goto error_return ; } msgLength -= 4 ; avail = conn -> inEnd - conn -> inCursor ; if ( avail < msgLength ) { if ( pqCheckInBufferSpace ( conn -> inCursor + ( size_t ) msgLength , conn ) ) goto error_return ; return PGRES_POLLING_READING ; } if ( beresp == 'E' ) { if ( pqGetErrorNotice3 ( conn , true ) ) { return PGRES_POLLING_READING ; } conn -> inStart = conn -> inCursor ; if ( strcmp ( conn -> last_sqlstate , ERRCODE_CANNOT_CONNECT_NOW ) == 0 ) { conn -> try_next_host = true ; goto keep_going ; } pgpassfileWarning ( conn ) ; # ifdef ENABLE_GSS if ( conn -> gssenc && conn -> gssencmode [ 0 ] == 'p' ) { conn -> try_gss = false ; need_new_connection = true ; goto keep_going ; } # endif # ifdef USE_SSL if ( conn -> sslmode [ 0 ] == 'a' && ! conn -> ssl_in_use && conn -> allow_ssl_try && conn -> wait_ssl_try ) { conn -> wait_ssl_try = false ; need_new_connection = true ; goto keep_going ; } if ( conn -> sslmode [ 0 ] == 'p' && conn -> ssl_in_use && conn -> allow_ssl_try && ! conn -> wait_ssl_try ) { conn -> allow_ssl_try = false ; need_new_connection = true ; goto keep_going ; } # endif goto error_return ; } conn -> auth_req_received = true ; if ( pqGetInt ( ( int * ) & areq , 4 , conn ) ) { return PGRES_POLLING_READING ; } msgLength -= 4 ; res = pg_fe_sendauth ( areq , msgLength , conn ) ; conn -> inStart = conn -> inCursor ; if ( res != STATUS_OK ) goto error_return ; if ( pqFlush ( conn ) ) goto error_return ; if ( areq == AUTH_REQ_OK ) { conn -> status = CONNECTION_AUTH_OK ; conn -> asyncStatus = PGASYNC_BUSY ; } goto keep_going ; } case CONNECTION_AUTH_OK : { if ( PQisBusy ( conn ) ) return PGRES_POLLING_READING ; res = PQgetResult ( conn ) ; if ( res ) { if ( res -> resultStatus != PGRES_FATAL_ERROR ) appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"unexpected<S2SV_blank>message<S2SV_blank>from<S2SV_blank>server<S2SV_blank>during<S2SV_blank>startup\\\\n\" ) ) ; else if ( conn -> send_appname && ( conn -> appname || conn -> fbappname ) ) { const char * sqlstate ; sqlstate = PQresultErrorField ( res , PG_DIAG_SQLSTATE ) ; if ( sqlstate && strcmp ( sqlstate , ERRCODE_APPNAME_UNKNOWN ) == 0 ) { PQclear ( res ) ; conn -> send_appname = false ; need_new_connection = true ; goto keep_going ; } } if ( conn -> errorMessage . len <= 0 || conn -> errorMessage . data [ conn -> errorMessage . len - 1 ] != '\\\\n' ) appendPQExpBufferChar ( & conn -> errorMessage , '\\\\n' ) ; PQclear ( res ) ; goto error_return ; } conn -> status = CONNECTION_CHECK_TARGET ; goto keep_going ; } case CONNECTION_CHECK_TARGET : { if ( conn -> target_server_type == SERVER_TYPE_READ_WRITE || conn -> target_server_type == SERVER_TYPE_READ_ONLY ) { bool read_only_server ; if ( conn -> default_transaction_read_only == PG_BOOL_UNKNOWN || conn -> in_hot_standby == PG_BOOL_UNKNOWN ) { conn -> status = CONNECTION_OK ; if ( ! PQsendQueryContinue ( conn , \"SHOW<S2SV_blank>transaction_read_only\" ) ) goto error_return ; conn -> status = CONNECTION_CHECK_WRITABLE ; return PGRES_POLLING_READING ; } read_only_server = ( conn -> default_transaction_read_only == PG_BOOL_YES || conn -> in_hot_standby == PG_BOOL_YES ) ; if ( ( conn -> target_server_type == SERVER_TYPE_READ_WRITE ) ? read_only_server : ! read_only_server ) { if ( conn -> target_server_type == SERVER_TYPE_READ_WRITE ) appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"session<S2SV_blank>is<S2SV_blank>read-only\\\\n\" ) ) ; else appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"session<S2SV_blank>is<S2SV_blank>not<S2SV_blank>read-only\\\\n\" ) ) ; conn -> status = CONNECTION_OK ; sendTerminateConn ( conn ) ; conn -> try_next_host = true ; goto keep_going ; } } else if ( conn -> target_server_type == SERVER_TYPE_PRIMARY || conn -> target_server_type == SERVER_TYPE_STANDBY || conn -> target_server_type == SERVER_TYPE_PREFER_STANDBY ) { if ( conn -> sversion < 90000 ) conn -> in_hot_standby = PG_BOOL_NO ; if ( conn -> in_hot_standby == PG_BOOL_UNKNOWN ) { conn -> status = CONNECTION_OK ; if ( ! PQsendQueryContinue ( conn , \"SELECT<S2SV_blank>pg_catalog.pg_is_in_recovery()\" ) ) goto error_return ; conn -> status = CONNECTION_CHECK_STANDBY ; return PGRES_POLLING_READING ; } if ( ( conn -> target_server_type == SERVER_TYPE_PRIMARY ) ? ( conn -> in_hot_standby == PG_BOOL_YES ) : ( conn -> in_hot_standby == PG_BOOL_NO ) ) { if ( conn -> target_server_type == SERVER_TYPE_PRIMARY ) appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"server<S2SV_blank>is<S2SV_blank>in<S2SV_blank>hot<S2SV_blank>standby<S2SV_blank>mode\\\\n\" ) ) ; else appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>hot<S2SV_blank>standby<S2SV_blank>mode\\\\n\" ) ) ; conn -> status = CONNECTION_OK ; sendTerminateConn ( conn ) ; conn -> try_next_host = true ; goto keep_going ; } } release_conn_addrinfo ( conn ) ; resetPQExpBuffer ( & conn -> errorMessage ) ; conn -> status = CONNECTION_OK ; return PGRES_POLLING_OK ; } case CONNECTION_CONSUME : { conn -> status = CONNECTION_OK ; if ( ! PQconsumeInput ( conn ) ) goto error_return ; if ( PQisBusy ( conn ) ) { conn -> status = CONNECTION_CONSUME ; return PGRES_POLLING_READING ; } res = PQgetResult ( conn ) ; if ( res != NULL ) { PQclear ( res ) ; conn -> status = CONNECTION_CONSUME ; return PGRES_POLLING_READING ; } conn -> status = CONNECTION_CHECK_TARGET ; goto keep_going ; } case CONNECTION_CHECK_WRITABLE : { conn -> status = CONNECTION_OK ; if ( ! PQconsumeInput ( conn ) ) goto error_return ; if ( PQisBusy ( conn ) ) { conn -> status = CONNECTION_CHECK_WRITABLE ; return PGRES_POLLING_READING ; } res = PQgetResult ( conn ) ; if ( res && PQresultStatus ( res ) == PGRES_TUPLES_OK && PQntuples ( res ) == 1 ) { char * val = PQgetvalue ( res , 0 , 0 ) ; if ( strncmp ( val , \"on\" , 2 ) == 0 ) { conn -> default_transaction_read_only = PG_BOOL_YES ; conn -> in_hot_standby = PG_BOOL_YES ; } else { conn -> default_transaction_read_only = PG_BOOL_NO ; conn -> in_hot_standby = PG_BOOL_NO ; } PQclear ( res ) ; conn -> status = CONNECTION_CONSUME ; goto keep_going ; } if ( res ) PQclear ( res ) ; appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"\\\\\"%s\\\\\"<S2SV_blank>failed\\\\n\" ) , \"SHOW<S2SV_blank>transaction_read_only\" ) ; conn -> status = CONNECTION_OK ; sendTerminateConn ( conn ) ; conn -> try_next_host = true ; goto keep_going ; } case CONNECTION_CHECK_STANDBY : { conn -> status = CONNECTION_OK ; if ( ! PQconsumeInput ( conn ) ) goto error_return ; if ( PQisBusy ( conn ) ) { conn -> status = CONNECTION_CHECK_STANDBY ; return PGRES_POLLING_READING ; } res = PQgetResult ( conn ) ; if ( res && PQresultStatus ( res ) == PGRES_TUPLES_OK && PQntuples ( res ) == 1 ) { char * val = PQgetvalue ( res , 0 , 0 ) ; if ( strncmp ( val , \"t\" , 1 ) == 0 ) conn -> in_hot_standby = PG_BOOL_YES ; else conn -> in_hot_standby = PG_BOOL_NO ; PQclear ( res ) ; conn -> status = CONNECTION_CONSUME ; goto keep_going ; } if ( res ) PQclear ( res ) ; appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"\\\\\"%s\\\\\"<S2SV_blank>failed\\\\n\" ) , \"SELECT<S2SV_blank>pg_is_in_recovery()\" ) ; conn -> status = CONNECTION_OK ; sendTerminateConn ( conn ) ; conn -> try_next_host = true ; goto keep_going ; } default : appendPQExpBuffer ( & conn -> errorMessage , libpq_gettext ( \"invalid<S2SV_blank>connection<S2SV_blank>state<S2SV_blank>%d,<S2SV_blank>\" \"probably<S2SV_blank>indicative<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>corruption\\\\n\" ) , conn -> status ) ; goto error_return ; } error_return : conn -> status = CONNECTION_BAD ; return PGRES_POLLING_FAILED ; }", "target": "<S2SV_ModStart> PGRES_POLLING_OK ) { if ( conn -> inCursor != conn -> inEnd ) { appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"received<S2SV_blank>unencrypted<S2SV_blank>data<S2SV_blank>after<S2SV_blank>SSL<S2SV_blank>response\\\\n\" ) ) ; goto error_return ; } <S2SV_ModStart> PGRES_POLLING_OK ) { if ( conn -> inCursor != conn -> inEnd ) { appendPQExpBufferStr ( & conn -> errorMessage , libpq_gettext ( \"received<S2SV_blank>unencrypted<S2SV_blank>data<S2SV_blank>after<S2SV_blank>GSSAPI<S2SV_blank>encryption<S2SV_blank>response\\\\n\" ) ) ; goto error_return ; }"}
{"source": "CWE-617 bool RepeatedAttrDefEqual ( const protobuf : : RepeatedPtrField < OpDef : : AttrDef > & a1 , const protobuf : : RepeatedPtrField < OpDef : : AttrDef > & a2 ) { std : : unordered_map < string , const OpDef : : AttrDef * > a1_set ; for ( const OpDef : : AttrDef & def : a1 ) { <S2SV_StartBug> DCHECK ( a1_set . find ( def . name ( ) ) == a1_set . end ( ) ) <S2SV_EndBug> <S2SV_StartBug> << \"AttrDef<S2SV_blank>names<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unique,<S2SV_blank>but<S2SV_blank>\\'\" << def . name ( ) <S2SV_EndBug> << \"\\'<S2SV_blank>appears<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\" ; <S2SV_StartBug> a1_set [ def . name ( ) ] = & def ; <S2SV_EndBug> } for ( const OpDef : : AttrDef & def : a2 ) { auto iter = a1_set . find ( def . name ( ) ) ; if ( iter == a1_set . end ( ) ) return false ; if ( ! AttrDefEqual ( * iter -> second , def ) ) return false ; a1_set . erase ( iter ) ; } if ( ! a1_set . empty ( ) ) return false ; return true ; }", "target": "<S2SV_ModStart> a1 ) { if <S2SV_ModEnd> ( a1_set . <S2SV_ModStart> ( ) ) != <S2SV_ModEnd> a1_set . end <S2SV_ModStart> ( ) ) { LOG ( ERROR ) <S2SV_ModStart> << \"\\'<S2SV_blank>appears<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\" ; }"}
{"source": "CWE-190 void Compute ( tensorflow : : OpKernelContext * context ) override { for ( int ngram_width : ngram_widths_ ) { OP_REQUIRES ( context , ngram_width > 0 , errors : : InvalidArgument ( \"ngram_widths<S2SV_blank>must<S2SV_blank>contain<S2SV_blank>positive<S2SV_blank>values\" ) ) ; } const tensorflow : : Tensor * data ; OP_REQUIRES_OK ( context , context -> input ( \"data\" , & data ) ) ; const auto & input_data = data -> flat < tstring > ( ) . data ( ) ; const tensorflow : : Tensor * splits ; OP_REQUIRES_OK ( context , context -> input ( \"data_splits\" , & splits ) ) ; const auto & splits_vec = splits -> flat < SPLITS_TYPE > ( ) ; const int input_data_size = data -> flat < tstring > ( ) . size ( ) ; const int splits_vec_size = splits_vec . size ( ) ; if ( splits_vec_size > 0 ) { int prev_split = splits_vec ( 0 ) ; OP_REQUIRES ( context , prev_split == 0 , errors : : InvalidArgument ( \"First<S2SV_blank>split<S2SV_blank>value<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>got<S2SV_blank>\" , prev_split ) ) ; for ( int i = 1 ; i < splits_vec_size ; ++ i ) { bool valid_splits = splits_vec ( i ) >= prev_split ; valid_splits = valid_splits && ( splits_vec ( i ) <= input_data_size ) ; OP_REQUIRES ( context , valid_splits , errors : : InvalidArgument ( \"Invalid<S2SV_blank>split<S2SV_blank>value<S2SV_blank>\" , splits_vec ( i ) , \",<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>[\" , prev_split , \",<S2SV_blank>\" , input_data_size , \"]\" ) ) ; prev_split = splits_vec ( i ) ; } OP_REQUIRES ( context , prev_split == input_data_size , errors : : InvalidArgument ( \"Last<S2SV_blank>split<S2SV_blank>value<S2SV_blank>must<S2SV_blank>be<S2SV_blank>data<S2SV_blank>size.<S2SV_blank>Expected<S2SV_blank>\" , input_data_size , \",<S2SV_blank>got<S2SV_blank>\" , prev_split ) ) ; } int num_batch_items = splits_vec . size ( ) - 1 ; tensorflow : : Tensor * ngrams_splits ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , splits -> shape ( ) , & ngrams_splits ) ) ; auto ngrams_splits_data = ngrams_splits -> flat < SPLITS_TYPE > ( ) . data ( ) ; if ( data -> flat < tstring > ( ) . size ( ) == 0 || splits_vec . size ( ) == 0 ) { tensorflow : : Tensor * empty ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , data -> shape ( ) , & empty ) ) ; for ( int i = 0 ; i <= num_batch_items ; ++ i ) { ngrams_splits_data [ i ] = 0 ; } return ; } ngrams_splits_data [ 0 ] = 0 ; for ( int i = 1 ; i <= num_batch_items ; ++ i ) { int length = splits_vec ( i ) - splits_vec ( i - 1 ) ; int num_ngrams = 0 ; for ( int ngram_width : ngram_widths_ ) num_ngrams += get_num_ngrams ( length , ngram_width ) ; if ( preserve_short_ && length > 0 && num_ngrams == 0 ) { num_ngrams = 1 ; } ngrams_splits_data [ i ] = ngrams_splits_data [ i - 1 ] + num_ngrams ; } tensorflow : : Tensor * ngrams ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { ngrams_splits_data [ num_batch_items ] } ) , & ngrams ) ) ; auto ngrams_data = ngrams -> flat < tstring > ( ) . data ( ) ; for ( int i = 0 ; i < num_batch_items ; ++ i ) { auto data_start = & input_data [ splits_vec ( i ) ] ; int output_start_idx = ngrams_splits_data [ i ] ; for ( int ngram_width : ngram_widths_ ) { auto output_start = & ngrams_data [ output_start_idx ] ; int length = splits_vec ( i + 1 ) - splits_vec ( i ) ; int num_ngrams = get_num_ngrams ( length , ngram_width ) ; CreateNgrams ( data_start , output_start , num_ngrams , ngram_width ) ; output_start_idx += num_ngrams ; } if ( preserve_short_ && output_start_idx == ngrams_splits_data [ i ] ) { int data_length = splits_vec ( i + 1 ) - splits_vec ( i ) ; if ( data_length == 0 ) { continue ; } <S2SV_StartBug> int ngram_width = data_length + 2 * pad_width_ ; <S2SV_EndBug> auto output_start = & ngrams_data [ output_start_idx ] ; int num_ngrams = 1 ; CreateNgrams ( data_start , output_start , num_ngrams , ngram_width ) ; } } }", "target": "<S2SV_ModStart> continue ; } OP_REQUIRES ( context , pad_width_ >= 0 , errors : : InvalidArgument ( \"Pad<S2SV_blank>width<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>0<S2SV_blank>when<S2SV_blank>\" \"preserve_short_sequences<S2SV_blank>is<S2SV_blank>True<S2SV_blank>and<S2SV_blank>\" \"ngram_widths<S2SV_blank>are<S2SV_blank>not<S2SV_blank>provided,<S2SV_blank>got<S2SV_blank>\" , pad_width_ ) ) ;"}
{"source": "CWE-134 static int vidioc_querycap ( struct file * file , void * priv , struct v4l2_capability * cap ) { struct v4l2_loopback_device * dev = v4l2loopback_getdevice ( file ) ; int labellen = ( sizeof ( cap -> card ) < sizeof ( dev -> card_label ) ) ? sizeof ( cap -> card ) : sizeof ( dev -> card_label ) ; int device_nr = ( ( struct v4l2loopback_private * ) video_get_drvdata ( dev -> vdev ) ) -> device_nr ; __u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE ; strlcpy ( cap -> driver , \"v4l2<S2SV_blank>loopback\" , sizeof ( cap -> driver ) ) ; <S2SV_StartBug> snprintf ( cap -> card , labellen , dev -> card_label ) ; <S2SV_EndBug> snprintf ( cap -> bus_info , sizeof ( cap -> bus_info ) , \"platform:v4l2loopback-%03d\" , device_nr ) ; # if LINUX_VERSION_CODE < KERNEL_VERSION ( 3 , 1 , 0 ) cap -> version = V4L2LOOPBACK_VERSION_CODE ; # endif # ifdef V4L2_CAP_VIDEO_M2M capabilities |= V4L2_CAP_VIDEO_M2M ; # endif if ( dev -> announce_all_caps ) { capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT ; } else { if ( dev -> ready_for_capture ) { capabilities |= V4L2_CAP_VIDEO_CAPTURE ; } if ( dev -> ready_for_output ) { capabilities |= V4L2_CAP_VIDEO_OUTPUT ; } } # if LINUX_VERSION_CODE >= KERNEL_VERSION ( 4 , 7 , 0 ) dev -> vdev -> device_caps = # endif cap -> device_caps = cap -> capabilities = capabilities ; # if LINUX_VERSION_CODE >= KERNEL_VERSION ( 3 , 3 , 0 ) cap -> capabilities |= V4L2_CAP_DEVICE_CAPS ; # endif memset ( cap -> reserved , 0 , sizeof ( cap -> reserved ) ) ; return 0 ; }", "target": "<S2SV_ModStart> , labellen , \"%s\" ,"}
{"source": "CWE-476 bool IsIdentityConsumingSwitch ( const MutableGraphView & graph , const NodeDef & node ) { if ( ( IsIdentity ( node ) || IsIdentityNSingleInput ( node ) ) && node . input_size ( ) > 0 ) { TensorId tensor_id = ParseTensorName ( node . input ( 0 ) ) ; if ( IsTensorIdControlling ( tensor_id ) ) { return false ; } NodeDef * input_node = graph . GetNode ( tensor_id . node ( ) ) ; <S2SV_StartBug> return IsSwitch ( * input_node ) ; <S2SV_EndBug> } return false ; }", "target": "<S2SV_ModStart> ) ) ; if ( input_node == nullptr ) { return false ; }"}
{"source": "CWE-190 <S2SV_StartBug> int TfLiteIntArrayGetSizeInBytes ( int size ) { <S2SV_EndBug> static TfLiteIntArray dummy ; <S2SV_StartBug> int computed_size = sizeof ( dummy ) + sizeof ( dummy . data [ 0 ] ) * size ; <S2SV_EndBug> # if defined ( _MSC_VER ) computed_size -= sizeof ( dummy . data [ 0 ] ) ; # endif return computed_size ; }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> size_t <S2SV_ModEnd> TfLiteIntArrayGetSizeInBytes ( int <S2SV_ModStart> TfLiteIntArray dummy ; size_t <S2SV_ModEnd> computed_size = sizeof"}
{"source": "CWE-190 TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <S2SV_StartBug> int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; <S2SV_EndBug> if ( alloc_size <= 0 ) return NULL ; TfLiteIntArray * ret = ( TfLiteIntArray * ) malloc ( alloc_size ) ; if ( ! ret ) return ret ; ret -> size = size ; return ret ; }", "target": "<S2SV_ModStart> size ) { size_t <S2SV_ModEnd> alloc_size = TfLiteIntArrayGetSizeInBytes"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { typedef Eigen : : Map < const Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> ConstEigenMatrixMap ; typedef Eigen : : Map < Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> EigenMatrixMap ; constexpr int tensor_in_and_out_dims = 4 ; const Tensor & tensor_in = context -> input ( 0 ) ; OP_REQUIRES ( context , tensor_in . dims ( ) == tensor_in_and_out_dims , errors : : InvalidArgument ( \"tensor_in<S2SV_blank>must<S2SV_blank>be<S2SV_blank>4-dimensional\" ) ) ; std : : vector < int > input_size ( tensor_in_and_out_dims ) ; std : : vector < int > output_size ( tensor_in_and_out_dims ) ; for ( int i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { input_size [ i ] = tensor_in . dim_size ( i ) ; <S2SV_StartBug> } <S2SV_EndBug> for ( int i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { output_size [ i ] = static_cast < int > ( std : : floor ( input_size [ i ] / pooling_ratio_ [ i ] ) ) ; DCHECK_GT ( output_size [ i ] , 0 ) ; } std : : vector < int64_t > height_cum_seq ; std : : vector < int64_t > width_cum_seq ; GuardedPhiloxRandom generator ; generator . Init ( seed_ , seed2_ ) ; height_cum_seq = GeneratePoolingSequence ( input_size [ 1 ] , output_size [ 1 ] , & generator , pseudo_random_ ) ; width_cum_seq = GeneratePoolingSequence ( input_size [ 2 ] , output_size [ 2 ] , & generator , pseudo_random_ ) ; Tensor * output_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { output_size [ 0 ] , output_size [ 1 ] , output_size [ 2 ] , output_size [ 3 ] } ) , & output_tensor ) ) ; Tensor * output_height_seq_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , TensorShape ( { static_cast < int64_t > ( height_cum_seq . size ( ) ) } ) , & output_height_seq_tensor ) ) ; Tensor * output_width_seq_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , TensorShape ( { static_cast < int64_t > ( width_cum_seq . size ( ) ) } ) , & output_width_seq_tensor ) ) ; ConstEigenMatrixMap in_mat ( tensor_in . flat < T > ( ) . data ( ) , input_size [ 3 ] , input_size [ 2 ] * input_size [ 1 ] * input_size [ 0 ] ) ; EigenMatrixMap out_mat ( output_tensor -> flat < T > ( ) . data ( ) , output_size [ 3 ] , output_size [ 2 ] * output_size [ 1 ] * output_size [ 0 ] ) ; output_tensor -> flat < T > ( ) . setConstant ( Eigen : : NumTraits < T > : : lowest ( ) ) ; auto output_height_seq_flat = output_height_seq_tensor -> flat < int64_t > ( ) ; auto output_width_seq_flat = output_width_seq_tensor -> flat < int64_t > ( ) ; for ( int i = 0 ; i < height_cum_seq . size ( ) ; ++ i ) { output_height_seq_flat ( i ) = height_cum_seq [ i ] ; } for ( int i = 0 ; i < width_cum_seq . size ( ) ; ++ i ) { output_width_seq_flat ( i ) = width_cum_seq [ i ] ; } const int64_t height_max = input_size [ 1 ] - 1 ; const int64_t width_max = input_size [ 2 ] - 1 ; for ( int64_t b = 0 ; b < input_size [ 0 ] ; ++ b ) { for ( int64_t hs = 0 ; hs < height_cum_seq . size ( ) - 1 ; ++ hs ) { const int64_t height_start = height_cum_seq [ hs ] ; int64_t height_end = overlapping_ ? height_cum_seq [ hs + 1 ] : height_cum_seq [ hs + 1 ] - 1 ; height_end = std : : min ( height_end , height_max ) ; for ( int64_t ws = 0 ; ws < width_cum_seq . size ( ) - 1 ; ++ ws ) { const int64_t out_offset = ( b * output_size [ 1 ] + hs ) * output_size [ 2 ] + ws ; const int64_t width_start = width_cum_seq [ ws ] ; int64_t width_end = overlapping_ ? width_cum_seq [ ws + 1 ] : width_cum_seq [ ws + 1 ] - 1 ; width_end = std : : min ( width_end , width_max ) ; for ( int64_t h = height_start ; h <= height_end ; ++ h ) { for ( int64_t w = width_start ; w <= width_end ; ++ w ) { const int64_t in_offset = ( b * input_size [ 1 ] + h ) * input_size [ 2 ] + w ; out_mat . col ( out_offset ) = out_mat . col ( out_offset ) . cwiseMax ( in_mat . col ( in_offset ) ) ; } } } } } }", "target": "<S2SV_ModStart> i ) ; OP_REQUIRES ( context , input_size [ i ] >= pooling_ratio_ [ i ] , errors : : InvalidArgument ( \"Pooling<S2SV_blank>ratio<S2SV_blank>is<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>input<S2SV_blank>\" \"dimension<S2SV_blank>size<S2SV_blank>for<S2SV_blank>dimension<S2SV_blank>\" , i , \".<S2SV_blank>Input<S2SV_blank>dim<S2SV_blank>size:<S2SV_blank>\" , input_size [ i ] , \"<S2SV_blank>pooling<S2SV_blank>ratio:<S2SV_blank>\" , pooling_ratio_ [ i ] ) ) ;"}
{"source": "CWE-190 static Image * ReadPCLImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define CropBox \"CropBox\" # define DeviceCMYK \"DeviceCMYK\" # define MediaBox \"MediaBox\" # define RenderPCLText \"<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>PCL...<S2SV_blank><S2SV_blank>\" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , * options , input_filename [ MaxTextExtent ] ; const DelegateInfo * delegate_info ; Image * image , * next_image ; ImageInfo * read_info ; int c ; MagickBooleanType cmyk , status ; PointInfo delta ; RectangleInfo bounding_box , page ; char * p ; SegmentInfo bounds ; size_t height , width ; ssize_t count ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , \"UnableToCreateTemporaryFile\" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; if ( ( flags & RhoValue ) != 0 ) image -> x_resolution = geometry_info . rho ; image -> y_resolution = image -> x_resolution ; if ( ( flags & SigmaValue ) != 0 ) image -> y_resolution = geometry_info . sigma ; } cmyk = image -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; count = 0 ; ( void ) memset ( & bounding_box , 0 , sizeof ( bounding_box ) ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( & page , 0 , sizeof ( page ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { if ( image_info -> page != ( char * ) NULL ) continue ; * p ++ = ( char ) c ; if ( ( c != ( int ) '/' ) && ( c != '\\\\n' ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\\\0' ; p = command ; if ( LocaleNCompare ( DeviceCMYK , command , strlen ( DeviceCMYK ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CropBox , command , strlen ( CropBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , \"CropBox<S2SV_blank>[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; if ( count != 4 ) count = ( ssize_t ) sscanf ( command , \"CropBox[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; } if ( LocaleNCompare ( MediaBox , command , strlen ( MediaBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , \"MediaBox<S2SV_blank>[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; if ( count != 4 ) count = ( ssize_t ) sscanf ( command , \"MediaBox[%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf\" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; } if ( count != 4 ) continue ; <S2SV_StartBug> width = ( size_t ) floor ( bounds . x2 - bounds . x1 + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> height = ( size_t ) floor ( bounds . y2 - bounds . y1 + 0.5 ) ; <S2SV_EndBug> if ( width > page . width ) page . width = width ; if ( height > page . height ) page . height = height ; } ( void ) CloseBlob ( image ) ; if ( ( page . width == 0 ) || ( page . height == 0 ) ) ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%.20gx%.20g\" , ( double ) page . width , ( double ) page . height ) ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( \"pcl:mono\" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( \"pcl:cmyk\" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( \"pcl:color\" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } if ( ( page . width == 0 ) || ( page . height == 0 ) ) ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; density = AcquireString ( \"\" ) ; options = AcquireString ( \"\" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , \"%gx%g\" , image -> x_resolution , image -> y_resolution ) ; if ( image_info -> ping != MagickFalse ) ( void ) FormatLocaleString ( density , MagickPathExtent , \"2.0x2.0\" ) ; page . width = ( size_t ) floor ( ( double ) page . width * image -> x_resolution / delta . x + 0.5 ) ; page . height = ( size_t ) floor ( ( double ) page . height * image -> y_resolution / delta . y + 0.5 ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , \"-g%.20gx%.20g<S2SV_blank>\" , ( double ) page . width , ( double ) page . height ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\\\0' ; if ( read_info -> number_scenes != 0 ) { if ( read_info -> number_scenes != 1 ) ( void ) FormatLocaleString ( options , MaxTextExtent , \"-dLastPage=%.20g\" , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; else ( void ) FormatLocaleString ( options , MaxTextExtent , \"-dFirstPage=%.20g<S2SV_blank>-dLastPage=%.20g\" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\\\0' ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( read_info -> filename ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , read_info -> filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; status = ExternalDelegateCommand ( MagickFalse , read_info -> verbose , command , ( char * ) NULL , exception ) != 0 ? MagickTrue : MagickFalse ; image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image == ( Image * ) NULL ) ThrowReaderException ( DelegateError , \"PCLDelegateFailed\" ) ; if ( LocaleCompare ( image -> magick , \"BMP\" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( image , & image -> exception ) ; if ( cmyk_image != ( Image * ) NULL ) { image = DestroyImageList ( image ) ; image = cmyk_image ; } } do { ( void ) CopyMagickString ( image -> filename , filename , MaxTextExtent ) ; image -> page = page ; if ( image_info -> ping != MagickFalse ) { image -> magick_columns *= image -> x_resolution / 2.0 ; image -> magick_rows *= image -> y_resolution / 2.0 ; image -> columns *= image -> x_resolution / 2.0 ; image -> rows *= image -> y_resolution / 2.0 ; } next_image = SyncNextImageInList ( image ) ; if ( next_image != ( Image * ) NULL ) image = next_image ; } while ( next_image != ( Image * ) NULL ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> ( size_t ) CastDoubleToLong ( <S2SV_ModStart> + 0.5 ) ) <S2SV_ModStart> ( size_t ) CastDoubleToLong ( <S2SV_ModStart> y1 + 0.5 )"}
{"source": "CWE-476 void gitn_box_del ( GF_Box * s ) { u32 i ; GroupIdToNameBox * ptr = ( GroupIdToNameBox * ) s ; <S2SV_StartBug> if ( ptr == NULL ) return ; <S2SV_EndBug> for ( i = 0 ; i < ptr -> nb_entries ; i ++ ) { if ( ptr -> entries [ i ] . name ) gf_free ( ptr -> entries [ i ] . name ) ; } <S2SV_StartBug> if ( ptr -> entries ) gf_free ( ptr -> entries ) ; <S2SV_EndBug> gf_free ( ptr ) ;", "target": "<S2SV_ModStart> ) return ; if ( ptr -> entries ) { <S2SV_ModStart> ) ; } <S2SV_ModEnd> gf_free ( ptr <S2SV_ModStart> entries ) ; }"}
{"source": "CWE-476 void MakeDataset ( OpKernelContext * ctx , DatasetBase * * output ) override { const Tensor * indices ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"indices\" , & indices ) ) ; const Tensor * values ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"values\" , & values ) ) ; const Tensor * dense_shape ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"dense_shape\" , & dense_shape ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( indices -> shape ( ) ) , errors : : InvalidArgument ( <S2SV_StartBug> \"Input<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , <S2SV_EndBug> indices -> shape ( ) . DebugString ( ) ) ) ; <S2SV_StartBug> const auto num_indices = indices -> NumElements ( ) ; <S2SV_EndBug> const auto num_values = values -> NumElements ( ) ; if ( num_indices == 0 || num_values == 0 ) { OP_REQUIRES ( ctx , num_indices == num_values , errors : : InvalidArgument ( <S2SV_StartBug> \"If<S2SV_blank>indices<S2SV_blank>or<S2SV_blank>values<S2SV_blank>are<S2SV_blank>empty,<S2SV_blank>the<S2SV_blank>other<S2SV_blank>one<S2SV_blank>must<S2SV_blank>also<S2SV_blank>\" <S2SV_EndBug> \"be.<S2SV_blank>Got<S2SV_blank>indices<S2SV_blank>of<S2SV_blank>shape<S2SV_blank>\" , indices -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>values<S2SV_blank>of<S2SV_blank>shape<S2SV_blank>\" , values -> shape ( ) . DebugString ( ) ) ) ; } OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( values -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , indices -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( dense_shape -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , dense_shape -> shape ( ) . DebugString ( ) ) ) ; int64_t previous_batch_index = - 1 ; for ( int64_t i = 0 ; i < indices -> dim_size ( 0 ) ; ++ i ) { int64_t next_batch_index = indices -> matrix < int64_t > ( ) ( i , 0 ) ; OP_REQUIRES ( ctx , next_batch_index >= previous_batch_index , errors : : Unimplemented ( \"The<S2SV_blank>SparseTensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>ordered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>batch<S2SV_blank>\" \"dimension;<S2SV_blank>handling<S2SV_blank>arbitrarily<S2SV_blank>ordered<S2SV_blank>input<S2SV_blank>\" \"is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\" ) ) ; previous_batch_index = next_batch_index ; } gtl : : InlinedVector < int64_t , 8 > std_order ( dense_shape -> NumElements ( ) , 0 ) ; sparse : : SparseTensor tensor ; OP_REQUIRES_OK ( ctx , sparse : : SparseTensor : : Create ( * indices , * values , TensorShape ( dense_shape -> vec < int64_t > ( ) ) , std_order , & tensor ) ) ; * output = new Dataset < T > ( ctx , std : : move ( tensor ) ) ; }", "target": "<S2SV_ModStart> : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix.<S2SV_blank>Got:<S2SV_blank>\" <S2SV_ModEnd> , indices -> <S2SV_ModStart> ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( values -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>values<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector.<S2SV_blank>Got:<S2SV_blank>\" , values -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( dense_shape -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector.<S2SV_blank>Got:<S2SV_blank>\" , dense_shape -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , values -> shape ( ) . dim_size ( 0 ) == indices -> shape ( ) . dim_size ( 0 ) , errors : : InvalidArgument ( \"Number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>must<S2SV_blank>match<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices.<S2SV_blank>\" , \"Got<S2SV_blank>\" , values -> shape ( ) . dim_size ( 0 ) , \"<S2SV_blank>values,<S2SV_blank>indices<S2SV_blank>shape:<S2SV_blank>\" , indices -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , dense_shape -> shape ( ) . dim_size ( 0 ) == indices -> shape ( ) . dim_size ( 1 ) , errors : : InvalidArgument ( \"Number<S2SV_blank>of<S2SV_blank>dimensions<S2SV_blank>must<S2SV_blank>match<S2SV_blank>second<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>indices.<S2SV_blank>\" , \"Got<S2SV_blank>\" , dense_shape -> shape ( ) . dim_size ( 0 ) , \"<S2SV_blank>dimensions,<S2SV_blank>indices<S2SV_blank>shape:<S2SV_blank>\" , indices -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , dense_shape <S2SV_ModEnd> -> NumElements ( <S2SV_ModStart> NumElements ( ) > 0 <S2SV_ModEnd> , errors : <S2SV_ModStart> : InvalidArgument ( \"The<S2SV_blank>shape<S2SV_blank>argument<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>element.\" <S2SV_ModEnd> ) ) ;"}
{"source": "CWE-476 IRC_PROTOCOL_CALLBACK ( 352 ) { char * pos_attr , * pos_hopcount , * pos_realname , * str_host ; int arg_start , length ; struct t_irc_channel * ptr_channel ; struct t_irc_nick * ptr_nick ; IRC_PROTOCOL_MIN_ARGS ( 5 ) ; if ( argc < 8 ) return WEECHAT_RC_OK ; pos_attr = NULL ; pos_hopcount = NULL ; pos_realname = NULL ; if ( argc > 8 ) { <S2SV_StartBug> arg_start = ( strcmp ( argv [ 8 ] , \"*\" ) == 0 ) ? 9 : 8 ; <S2SV_EndBug> if ( argv [ arg_start ] [ 0 ] == ':' ) { pos_attr = NULL ; pos_hopcount = ( argc > arg_start ) ? argv [ arg_start ] + 1 : NULL ; pos_realname = ( argc > arg_start + 1 ) ? argv_eol [ arg_start + 1 ] : NULL ; } else { pos_attr = argv [ arg_start ] ; pos_hopcount = ( argc > arg_start + 1 ) ? argv [ arg_start + 1 ] + 1 : NULL ; pos_realname = ( argc > arg_start + 2 ) ? argv_eol [ arg_start + 2 ] : NULL ; } } ptr_channel = irc_channel_search ( server , argv [ 3 ] ) ; ptr_nick = ( ptr_channel ) ? irc_nick_search ( server , ptr_channel , argv [ 7 ] ) : NULL ; if ( ptr_nick ) { length = strlen ( argv [ 4 ] ) + 1 + strlen ( argv [ 5 ] ) + 1 ; str_host = malloc ( length ) ; if ( str_host ) { snprintf ( str_host , length , \"%s@%s\" , argv [ 4 ] , argv [ 5 ] ) ; irc_nick_set_host ( ptr_nick , str_host ) ; free ( str_host ) ; } } if ( ptr_channel && ptr_nick && pos_attr ) { irc_nick_set_away ( server , ptr_channel , ptr_nick , ( pos_attr [ 0 ] == 'G' ) ? 1 : 0 ) ; } if ( ptr_channel && ptr_nick && pos_realname ) { if ( ptr_nick -> realname ) free ( ptr_nick -> realname ) ; if ( pos_realname && weechat_hashtable_has_key ( server -> cap_list , \"extended-join\" ) ) { ptr_nick -> realname = strdup ( pos_realname ) ; } else { ptr_nick -> realname = NULL ; } } if ( ! ptr_channel || ( ptr_channel -> checking_whox <= 0 ) ) { weechat_printf_date_tags ( irc_msgbuffer_get_target_buffer ( server , NULL , command , \"who\" , NULL ) , date , irc_protocol_tags ( command , \"irc_numeric\" , NULL , NULL ) , \"%s%s[%s%s%s]<S2SV_blank>%s%s<S2SV_blank>%s(%s%s@%s%s)%s<S2SV_blank>%s%s%s%s(%s)\" , weechat_prefix ( \"network\" ) , IRC_COLOR_CHAT_DELIMITERS , IRC_COLOR_CHAT_CHANNEL , argv [ 3 ] , IRC_COLOR_CHAT_DELIMITERS , irc_nick_color_for_msg ( server , 1 , NULL , argv [ 7 ] ) , argv [ 7 ] , IRC_COLOR_CHAT_DELIMITERS , IRC_COLOR_CHAT_HOST , argv [ 4 ] , argv [ 5 ] , IRC_COLOR_CHAT_DELIMITERS , IRC_COLOR_RESET , ( pos_attr ) ? pos_attr : \"\" , ( pos_attr ) ? \"<S2SV_blank>\" : \"\" , ( pos_hopcount ) ? pos_hopcount : \"\" , ( pos_hopcount ) ? \"<S2SV_blank>\" : \"\" , ( pos_realname ) ? pos_realname : \"\" ) ; } return WEECHAT_RC_OK ; }", "target": "<S2SV_ModStart> arg_start = ( ( argc > 9 ) && ( <S2SV_ModStart> ) == 0 )"}
{"source": "CWE-119 String string_number_format ( double d , int dec , const String & dec_point , const String & thousand_sep ) { char * tmpbuf = nullptr , * resbuf ; char * s , * t ; char * dp ; int integral ; int tmplen , reslen = 0 ; int count = 0 ; int is_negative = 0 ; if ( d < 0 ) { is_negative = 1 ; d = - d ; } if ( dec < 0 ) dec = 0 ; d = php_math_round ( d , dec ) ; String tmpstr ( 63 , ReserveString ) ; tmpbuf = tmpstr . mutableData ( ) ; tmplen = snprintf ( tmpbuf , 64 , \"%.*F\" , dec , d ) ; if ( tmplen < 0 ) return empty_string ( ) ; <S2SV_StartBug> if ( tmpbuf == nullptr || ! isdigit ( ( int ) tmpbuf [ 0 ] ) ) { <S2SV_EndBug> tmpstr . setSize ( tmplen ) ; return tmpstr ; } if ( tmplen >= 64 ) { tmpstr = String ( tmplen , ReserveString ) ; tmpbuf = tmpstr . mutableData ( ) ; tmplen = snprintf ( tmpbuf , tmplen + 1 , \"%.*F\" , dec , d ) ; if ( tmplen < 0 ) return empty_string ( ) ; if ( tmpbuf == nullptr || ! isdigit ( ( int ) tmpbuf [ 0 ] ) ) { tmpstr . setSize ( tmplen ) ; return tmpstr ; } } if ( dec ) { dp = strpbrk ( tmpbuf , \".,\" ) ; } else { dp = nullptr ; } if ( dp ) { integral = dp - tmpbuf ; } else { integral = tmplen ; } if ( ! thousand_sep . empty ( ) ) { if ( integral + thousand_sep . size ( ) * ( ( integral - 1 ) / 3 ) < integral ) { raise_error ( \"String<S2SV_blank>overflow\" ) ; } integral += ( ( integral - 1 ) / 3 ) * thousand_sep . size ( ) ; } reslen = integral ; if ( dec ) { reslen += dec ; if ( ! dec_point . empty ( ) ) { if ( reslen + dec_point . size ( ) < dec_point . size ( ) ) { raise_error ( \"String<S2SV_blank>overflow\" ) ; } reslen += dec_point . size ( ) ; } } if ( is_negative ) { reslen ++ ; } String resstr ( reslen , ReserveString ) ; resbuf = resstr . mutableData ( ) ; s = tmpbuf + tmplen - 1 ; t = resbuf + reslen - 1 ; if ( dec ) { int declen = dp ? s - dp : 0 ; int topad = dec > declen ? dec - declen : 0 ; while ( topad -- ) { * t -- = '0' ; } if ( dp ) { s -= declen + 1 ; t -= declen ; memcpy ( t + 1 , dp + 1 , declen ) ; } if ( ! dec_point . empty ( ) ) { memcpy ( t + ( 1 - dec_point . size ( ) ) , dec_point . data ( ) , dec_point . size ( ) ) ; t -= dec_point . size ( ) ; } } while ( s >= tmpbuf ) { * t -- = * s -- ; if ( thousand_sep && ( ++ count % 3 ) == 0 && s >= tmpbuf ) { memcpy ( t + ( 1 - thousand_sep . size ( ) ) , thousand_sep . data ( ) , thousand_sep . size ( ) ) ; t -= thousand_sep . size ( ) ; } } if ( is_negative ) { * t -- = '-' ; } resstr . setSize ( reslen ) ; return resstr ; }", "target": "<S2SV_ModStart> ) ; if ( tmplen < 64 && <S2SV_ModStart> ] ) ) )"}
{"source": "CWE-787 static size_t send_control_msg ( VirtIOSerial * vser , void * buf , size_t len ) { VirtQueueElement elem ; VirtQueue * vq ; vq = vser -> c_ivq ; if ( ! virtio_queue_ready ( vq ) ) { return 0 ; } if ( ! virtqueue_pop ( vq , & elem ) ) { return 0 ; } <S2SV_StartBug> memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ; <S2SV_EndBug> virtqueue_push ( vq , & elem , len ) ; virtio_notify ( VIRTIO_DEVICE ( vser ) , vq ) ; return len ; }", "target": "<S2SV_ModStart> 0 ; } iov_from_buf <S2SV_ModEnd> ( elem . <S2SV_ModStart> elem . in_sg , elem . in_num , 0 <S2SV_ModEnd> , buf ,"}
{"source": "CWE-476 Status GetDeviceForInput ( const EagerOperation & op , const EagerContext & ctx , TensorHandle * tensor_handle , Device * * result ) { Device * cpu_device = ctx . HostCPU ( ) ; string device_name ; if ( tensor_handle -> Type ( ) != TensorHandle : : LOCAL ) { Device * device = tensor_handle -> device ( ) ; device_name = device != nullptr ? device -> name ( ) : cpu_device -> name ( ) ; * result = ( device == nullptr ? cpu_device : device ) ; } else if ( tensor_handle -> dtype == DT_RESOURCE ) { const Tensor * tensor ; <S2SV_StartBug> TF_RETURN_IF_ERROR ( tensor_handle -> Tensor ( & tensor ) ) ; <S2SV_EndBug> const ResourceHandle & handle = tensor -> flat < ResourceHandle > ( ) ( 0 ) ; device_name = handle . device ( ) ; Device * input_device ; TF_RETURN_IF_ERROR ( ctx . FindDeviceFromName ( device_name . c_str ( ) , & input_device ) ) ; * result = input_device ; } else { Device * device = tensor_handle -> device ( ) ; const bool is_tpu = device != nullptr && device -> device_type ( ) == \"TPU\" ; const bool use_host_memory = is_tpu ? MTypeFromDTypeIntsOnDevice ( tensor_handle -> dtype ) : MTypeFromDType ( tensor_handle -> dtype ) ; if ( use_host_memory ) { * result = cpu_device ; } else { if ( ! op . is_function ( ) && device != nullptr && device != cpu_device ) { device = absl : : get < Device * > ( op . Device ( ) ) ; } * result = ( device == nullptr ? cpu_device : device ) ; } } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ) ) ; if ( tensor -> NumElements ( ) == 0 ) { return errors : : InvalidArgument ( \"Empty<S2SV_blank>resource<S2SV_blank>handle\" ) ; }"}
{"source": "CWE-703 njs_array_prototype_splice ( njs_vm_t * vm , njs_value_t * args , njs_uint_t nargs , njs_index_t unused ) { int64_t i , n , start , length , items , delta , delete ; njs_int_t ret ; njs_value_t * this , value , del_object ; njs_array_t * array , * deleted ; this = njs_argument ( args , 0 ) ; ret = njs_value_to_object ( vm , this ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } ret = njs_object_length ( vm , this , & length ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return ret ; } ret = njs_value_to_integer ( vm , njs_arg ( args , nargs , 1 ) , & start ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } start = ( start < 0 ) ? njs_max ( length + start , 0 ) : njs_min ( start , length ) ; items = 0 ; delete = 0 ; if ( nargs == 2 ) { delete = length - start ; } else if ( nargs > 2 ) { items = nargs - 3 ; ret = njs_value_to_integer ( vm , njs_arg ( args , nargs , 2 ) , & delete ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } delete = njs_min ( njs_max ( delete , 0 ) , length - start ) ; } delta = items - delete ; if ( njs_slow_path ( ( length + delta ) > NJS_MAX_LENGTH ) ) { njs_type_error ( vm , \"Invalid<S2SV_blank>length\" ) ; return NJS_ERROR ; } deleted = njs_array_alloc ( vm , 0 , delete , 0 ) ; if ( njs_slow_path ( deleted == NULL ) ) { return NJS_ERROR ; } if ( njs_fast_path ( njs_is_fast_array ( this ) && deleted -> object . fast_array ) ) { array = njs_array ( this ) ; for ( i = 0 , n = start ; i < delete ; i ++ , n ++ ) { deleted -> start [ i ] = array -> start [ n ] ; } } else { njs_set_array ( & del_object , deleted ) ; for ( i = 0 , n = start ; i < delete ; i ++ , n ++ ) { ret = njs_value_property_i64 ( vm , this , n , & value ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return NJS_ERROR ; } if ( ret == NJS_OK ) { ret = njs_value_property_i64_set ( vm , & del_object , i , & value ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return ret ; } <S2SV_StartBug> } <S2SV_EndBug> } ret = njs_object_length_set ( vm , & del_object , delete ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return NJS_ERROR ; } } if ( njs_fast_path ( njs_is_fast_array ( this ) ) ) { array = njs_array ( this ) ; if ( delta != 0 ) { if ( delta > 0 ) { ret = njs_array_expand ( vm , array , 0 , delta ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } } ret = njs_array_copy_within ( vm , this , start + items , start + delete , array -> length - ( start + delete ) , 0 ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } array -> length += delta ; } if ( items > 0 ) { memcpy ( & array -> start [ start ] , & args [ 3 ] , items * sizeof ( njs_value_t ) ) ; } } else { if ( delta != 0 ) { ret = njs_array_copy_within ( vm , this , start + items , start + delete , length - ( start + delete ) , delta < 0 ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } for ( i = length - 1 ; i >= length + delta ; i -- ) { ret = njs_value_property_i64_delete ( vm , this , i , NULL ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return NJS_ERROR ; } } } for ( i = 3 , n = start ; items -- > 0 ; i ++ , n ++ ) { ret = njs_value_property_i64_set ( vm , this , n , & args [ i ] ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return NJS_ERROR ; } } ret = njs_object_length_set ( vm , this , length + delta ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return NJS_ERROR ; } } njs_set_array ( & vm -> retval , deleted ) ; return NJS_OK ; }", "target": "<S2SV_ModStart> ret ; } } else { if ( deleted -> object . fast_array ) { njs_set_invalid ( & deleted -> start [ i ] ) ; }"}
{"source": "CWE-703 static pj_xml_node * xml_parse_node ( pj_pool_t * pool , pj_scanner * scanner ) { pj_xml_node * node ; pj_str_t end_name ; PJ_CHECK_STACK ( ) ; if ( * scanner -> curptr != '<' ) on_syntax_error ( scanner ) ; if ( * scanner -> curptr == '<' && * ( scanner -> curptr + 1 ) == '?' ) { pj_scan_advance_n ( scanner , 2 , PJ_FALSE ) ; for ( ; ; ) { pj_str_t dummy ; pj_scan_get_until_ch ( scanner , '?' , & dummy ) ; if ( * scanner -> curptr == '?' && * ( scanner -> curptr + 1 ) == '>' ) { pj_scan_advance_n ( scanner , 2 , PJ_TRUE ) ; break ; } else { pj_scan_advance_n ( scanner , 1 , PJ_FALSE ) ; } } return xml_parse_node ( pool , scanner ) ; } if ( pj_scan_strcmp ( scanner , \"<!\" , 2 ) == 0 ) { pj_scan_advance_n ( scanner , 2 , PJ_FALSE ) ; for ( ; ; ) { pj_str_t dummy ; pj_scan_get_until_ch ( scanner , '>' , & dummy ) ; if ( pj_scan_strcmp ( scanner , \">\" , 1 ) == 0 ) { pj_scan_advance_n ( scanner , 1 , PJ_TRUE ) ; break ; } else { pj_scan_advance_n ( scanner , 1 , PJ_FALSE ) ; } } return xml_parse_node ( pool , scanner ) ; } node = alloc_node ( pool ) ; pj_scan_get_char ( scanner ) ; pj_scan_get_until_chr ( scanner , \"<S2SV_blank>/>\\\\t\\\\r\\\\n\" , & node -> name ) ; while ( * scanner -> curptr != '>' && * scanner -> curptr != '/' ) { pj_xml_attr * attr = alloc_attr ( pool ) ; pj_scan_get_until_chr ( scanner , \"=><S2SV_blank>\\\\t\\\\r\\\\n\" , & attr -> name ) ; if ( * scanner -> curptr == '=' ) { pj_scan_get_char ( scanner ) ; pj_scan_get_quotes ( scanner , \"\\\\\"\\'\" , \"\\\\\"\\'\" , 2 , & attr -> value ) ; ++ attr -> value . ptr ; attr -> value . slen -= 2 ; } pj_list_push_back ( & node -> attr_head , attr ) ; } if ( * scanner -> curptr == '/' ) { pj_scan_get_char ( scanner ) ; if ( pj_scan_get_char ( scanner ) != '>' ) on_syntax_error ( scanner ) ; return node ; } if ( pj_scan_get_char ( scanner ) != '>' ) on_syntax_error ( scanner ) ; while ( * scanner -> curptr == '<' && * ( scanner -> curptr + 1 ) != '/' && * ( scanner -> curptr + 1 ) != '!' ) { pj_xml_node * sub_node = xml_parse_node ( pool , scanner ) ; pj_list_push_back ( & node -> node_head , sub_node ) ; } if ( ! pj_scan_is_eof ( scanner ) && * scanner -> curptr != '<' ) { pj_scan_get_until_ch ( scanner , '<' , & node -> content ) ; } if ( * scanner -> curptr == '<' && * ( scanner -> curptr + 1 ) == '!' && pj_scan_strcmp ( scanner , \"<![CDATA[\" , 9 ) == 0 ) { pj_scan_advance_n ( scanner , 9 , PJ_FALSE ) ; pj_scan_get_until_ch ( scanner , ']' , & node -> content ) ; while ( pj_scan_strcmp ( scanner , \"]]>\" , 3 ) ) { pj_str_t dummy ; <S2SV_StartBug> pj_scan_get_until_ch ( scanner , ']' , & dummy ) ; <S2SV_EndBug> } node -> content . slen = scanner -> curptr - node -> content . ptr ; pj_scan_advance_n ( scanner , 3 , PJ_TRUE ) ; } if ( pj_scan_get_char ( scanner ) != '<' || pj_scan_get_char ( scanner ) != '/' ) on_syntax_error ( scanner ) ; pj_scan_get_until_chr ( scanner , \"<S2SV_blank>\\\\t>\" , & end_name ) ; if ( pj_stricmp ( & node -> name , & end_name ) != 0 ) on_syntax_error ( scanner ) ; if ( pj_scan_get_char ( scanner ) != '>' ) on_syntax_error ( scanner ) ; return node ; }", "target": "<S2SV_ModStart> pj_str_t dummy ; pj_scan_advance_n ( scanner , 1 , PJ_FALSE ) ;"}
{"source": "CWE-703 mrb_vm_exec ( mrb_state * mrb , const struct RProc * proc , const mrb_code * pc ) { const mrb_irep * irep = proc -> body . irep ; const mrb_pool_value * pool = irep -> pool ; const mrb_sym * syms = irep -> syms ; mrb_code insn ; int ai = mrb_gc_arena_save ( mrb ) ; struct mrb_jmpbuf * prev_jmp = mrb -> jmp ; struct mrb_jmpbuf c_jmp ; uint32_t a ; uint16_t b ; uint16_t c ; mrb_sym mid ; const struct mrb_irep_catch_handler * ch ; # ifdef DIRECT_THREADED static const void * const optable [ ] = { # define OPCODE ( x , _ ) && L_OP_ ## x , # include \"mruby/ops.h\" # undef OPCODE } ; # endif mrb_bool exc_catched = FALSE ; RETRY_TRY_BLOCK : MRB_TRY ( & c_jmp ) { if ( exc_catched ) { exc_catched = FALSE ; mrb_gc_arena_restore ( mrb , ai ) ; if ( mrb -> exc && mrb -> exc -> tt == MRB_TT_BREAK ) goto L_BREAK ; goto L_RAISE ; } mrb -> jmp = & c_jmp ; mrb_vm_ci_proc_set ( mrb -> c -> ci , proc ) ; # define regs ( mrb -> c -> ci -> stack ) INIT_DISPATCH { CASE ( OP_NOP , Z ) { NEXT ; } CASE ( OP_MOVE , BB ) { regs [ a ] = regs [ b ] ; NEXT ; } CASE ( OP_LOADL , BB ) { switch ( pool [ b ] . tt ) { case IREP_TT_INT32 : regs [ a ] = mrb_int_value ( mrb , ( mrb_int ) pool [ b ] . u . i32 ) ; break ; case IREP_TT_INT64 : # if defined ( MRB_INT64 ) regs [ a ] = mrb_int_value ( mrb , ( mrb_int ) pool [ b ] . u . i64 ) ; break ; # else # if defined ( MRB_64BIT ) if ( INT32_MIN <= pool [ b ] . u . i64 && pool [ b ] . u . i64 <= INT32_MAX ) { regs [ a ] = mrb_int_value ( mrb , ( mrb_int ) pool [ b ] . u . i64 ) ; break ; } # endif goto L_INT_OVERFLOW ; # endif case IREP_TT_BIGINT : # ifdef MRB_USE_BIGINT { const char * s = pool [ b ] . u . str ; regs [ a ] = mrb_bint_new_str ( mrb , s + 2 , ( mrb_int ) s [ 0 ] , ( mrb_int ) s [ 1 ] ) ; } break ; # else goto L_INT_OVERFLOW ; # endif # ifndef MRB_NO_FLOAT case IREP_TT_FLOAT : regs [ a ] = mrb_float_value ( mrb , pool [ b ] . u . f ) ; break ; # endif default : regs [ a ] = mrb_nil_value ( ) ; break ; } NEXT ; } CASE ( OP_LOADI , BB ) { SET_FIXNUM_VALUE ( regs [ a ] , b ) ; NEXT ; } CASE ( OP_LOADINEG , BB ) { SET_FIXNUM_VALUE ( regs [ a ] , - b ) ; NEXT ; } CASE ( OP_LOADI__1 , B ) goto L_LOADI ; CASE ( OP_LOADI_0 , B ) goto L_LOADI ; CASE ( OP_LOADI_1 , B ) goto L_LOADI ; CASE ( OP_LOADI_2 , B ) goto L_LOADI ; CASE ( OP_LOADI_3 , B ) goto L_LOADI ; CASE ( OP_LOADI_4 , B ) goto L_LOADI ; CASE ( OP_LOADI_5 , B ) goto L_LOADI ; CASE ( OP_LOADI_6 , B ) goto L_LOADI ; CASE ( OP_LOADI_7 , B ) { L_LOADI : SET_FIXNUM_VALUE ( regs [ a ] , ( mrb_int ) insn - ( mrb_int ) OP_LOADI_0 ) ; NEXT ; } CASE ( OP_LOADI16 , BS ) { SET_FIXNUM_VALUE ( regs [ a ] , ( mrb_int ) ( int16_t ) b ) ; NEXT ; } CASE ( OP_LOADI32 , BSS ) { SET_INT_VALUE ( mrb , regs [ a ] , ( int32_t ) ( ( ( uint32_t ) b << 16 ) + c ) ) ; NEXT ; } CASE ( OP_LOADSYM , BB ) { SET_SYM_VALUE ( regs [ a ] , syms [ b ] ) ; NEXT ; } CASE ( OP_LOADNIL , B ) { SET_NIL_VALUE ( regs [ a ] ) ; NEXT ; } CASE ( OP_LOADSELF , B ) { regs [ a ] = regs [ 0 ] ; NEXT ; } CASE ( OP_LOADT , B ) { SET_TRUE_VALUE ( regs [ a ] ) ; NEXT ; } CASE ( OP_LOADF , B ) { SET_FALSE_VALUE ( regs [ a ] ) ; NEXT ; } CASE ( OP_GETGV , BB ) { mrb_value val = mrb_gv_get ( mrb , syms [ b ] ) ; regs [ a ] = val ; NEXT ; } CASE ( OP_SETGV , BB ) { mrb_gv_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETSV , BB ) { mrb_value val = mrb_vm_special_get ( mrb , syms [ b ] ) ; regs [ a ] = val ; NEXT ; } CASE ( OP_SETSV , BB ) { mrb_vm_special_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETIV , BB ) { regs [ a ] = mrb_iv_get ( mrb , regs [ 0 ] , syms [ b ] ) ; NEXT ; } CASE ( OP_SETIV , BB ) { mrb_iv_set ( mrb , regs [ 0 ] , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETCV , BB ) { mrb_value val ; val = mrb_vm_cv_get ( mrb , syms [ b ] ) ; regs [ a ] = val ; NEXT ; } CASE ( OP_SETCV , BB ) { mrb_vm_cv_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETIDX , B ) { mrb_value va = regs [ a ] , vb = regs [ a + 1 ] ; switch ( mrb_type ( va ) ) { case MRB_TT_ARRAY : if ( ! mrb_integer_p ( vb ) ) goto getidx_fallback ; regs [ a ] = mrb_ary_entry ( va , mrb_integer ( vb ) ) ; break ; case MRB_TT_HASH : va = mrb_hash_get ( mrb , va , vb ) ; regs [ a ] = va ; break ; case MRB_TT_STRING : switch ( mrb_type ( vb ) ) { case MRB_TT_INTEGER : case MRB_TT_STRING : case MRB_TT_RANGE : va = mrb_str_aref ( mrb , va , vb , mrb_undef_value ( ) ) ; regs [ a ] = va ; break ; default : goto getidx_fallback ; } break ; default : getidx_fallback : mid = MRB_OPSYM ( aref ) ; goto L_SEND_SYM ; } NEXT ; } CASE ( OP_SETIDX , B ) { c = 2 ; mid = MRB_OPSYM ( aset ) ; SET_NIL_VALUE ( regs [ a + 3 ] ) ; goto L_SENDB_SYM ; } CASE ( OP_GETCONST , BB ) { mrb_value v = mrb_vm_const_get ( mrb , syms [ b ] ) ; regs [ a ] = v ; NEXT ; } CASE ( OP_SETCONST , BB ) { mrb_vm_const_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETMCNST , BB ) { mrb_value v = mrb_const_get ( mrb , regs [ a ] , syms [ b ] ) ; regs [ a ] = v ; NEXT ; } CASE ( OP_SETMCNST , BB ) { mrb_const_set ( mrb , regs [ a + 1 ] , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETUPVAR , BBB ) { mrb_value * regs_a = regs + a ; struct REnv * e = uvenv ( mrb , c ) ; if ( e && b < MRB_ENV_LEN ( e ) ) { * regs_a = e -> stack [ b ] ; } else { * regs_a = mrb_nil_value ( ) ; } NEXT ; } CASE ( OP_SETUPVAR , BBB ) { struct REnv * e = uvenv ( mrb , c ) ; if ( e ) { mrb_value * regs_a = regs + a ; if ( b < MRB_ENV_LEN ( e ) ) { e -> stack [ b ] = * regs_a ; mrb_write_barrier ( mrb , ( struct RBasic * ) e ) ; } } NEXT ; } CASE ( OP_JMP , S ) { pc += ( int16_t ) a ; JUMP ; } CASE ( OP_JMPIF , BS ) { if ( mrb_test ( regs [ a ] ) ) { pc += ( int16_t ) b ; JUMP ; } NEXT ; } CASE ( OP_JMPNOT , BS ) { if ( ! mrb_test ( regs [ a ] ) ) { pc += ( int16_t ) b ; JUMP ; } NEXT ; } CASE ( OP_JMPNIL , BS ) { if ( mrb_nil_p ( regs [ a ] ) ) { pc += ( int16_t ) b ; JUMP ; } NEXT ; } CASE ( OP_JMPUW , S ) { a = ( uint32_t ) ( ( pc - irep -> iseq ) + ( int16_t ) a ) ; CHECKPOINT_RESTORE ( RBREAK_TAG_JUMP ) { struct RBreak * brk = ( struct RBreak * ) mrb -> exc ; mrb_value target = mrb_break_value_get ( brk ) ; mrb_assert ( mrb_integer_p ( target ) ) ; a = ( uint32_t ) mrb_integer ( target ) ; mrb_assert ( a >= 0 && a < irep -> ilen ) ; } CHECKPOINT_MAIN ( RBREAK_TAG_JUMP ) { ch = catch_handler_find ( mrb , mrb -> c -> ci , pc , MRB_CATCH_FILTER_ENSURE ) ; if ( ch ) { if ( a < mrb_irep_catch_handler_unpack ( ch -> begin ) || a >= mrb_irep_catch_handler_unpack ( ch -> end ) ) { THROW_TAGGED_BREAK ( mrb , RBREAK_TAG_JUMP , proc , mrb_fixnum_value ( a ) ) ; } } } CHECKPOINT_END ( RBREAK_TAG_JUMP ) ; mrb -> exc = NULL ; pc = irep -> iseq + a ; JUMP ; } CASE ( OP_EXCEPT , B ) { mrb_value exc ; if ( mrb -> exc == NULL ) { exc = mrb_nil_value ( ) ; } else { switch ( mrb -> exc -> tt ) { case MRB_TT_BREAK : case MRB_TT_EXCEPTION : exc = mrb_obj_value ( mrb -> exc ) ; break ; default : mrb_assert ( ! \"bad<S2SV_blank>mrb_type\" ) ; exc = mrb_nil_value ( ) ; break ; } mrb -> exc = NULL ; } regs [ a ] = exc ; NEXT ; } CASE ( OP_RESCUE , BB ) { mrb_value exc = regs [ a ] ; mrb_value e = regs [ b ] ; struct RClass * ec ; switch ( mrb_type ( e ) ) { case MRB_TT_CLASS : case MRB_TT_MODULE : break ; default : { mrb_value exc ; exc = mrb_exc_new_lit ( mrb , E_TYPE_ERROR , \"class<S2SV_blank>or<S2SV_blank>module<S2SV_blank>required<S2SV_blank>for<S2SV_blank>rescue<S2SV_blank>clause\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } } ec = mrb_class_ptr ( e ) ; regs [ b ] = mrb_bool_value ( mrb_obj_is_kind_of ( mrb , exc , ec ) ) ; NEXT ; } CASE ( OP_RAISEIF , B ) { mrb_value exc = regs [ a ] ; if ( mrb_break_p ( exc ) ) { mrb -> exc = mrb_obj_ptr ( exc ) ; goto L_BREAK ; } mrb_exc_set ( mrb , exc ) ; if ( mrb -> exc ) { goto L_RAISE ; } NEXT ; } CASE ( OP_SSEND , BBB ) { regs [ a ] = regs [ 0 ] ; insn = OP_SEND ; } goto L_SENDB ; CASE ( OP_SSENDB , BBB ) { regs [ a ] = regs [ 0 ] ; } goto L_SENDB ; CASE ( OP_SEND , BBB ) goto L_SENDB ; L_SEND_SYM : c = 1 ; SET_NIL_VALUE ( regs [ a + 2 ] ) ; goto L_SENDB_SYM ; CASE ( OP_SENDB , BBB ) L_SENDB : mid = syms [ b ] ; L_SENDB_SYM : { mrb_callinfo * ci = mrb -> c -> ci ; mrb_method_t m ; struct RClass * cls ; mrb_value recv , blk ; ARGUMENT_NORMALIZE ( a , & c , insn ) ; recv = regs [ a ] ; cls = mrb_class ( mrb , recv ) ; m = mrb_method_search_vm ( mrb , & cls , mid ) ; if ( MRB_METHOD_UNDEF_P ( m ) ) { m = prepare_missing ( mrb , recv , mid , & cls , a , & c , blk , 0 ) ; mid = MRB_SYM ( method_missing ) ; } ci = cipush ( mrb , a , 0 , cls , NULL , mid , c ) ; if ( MRB_METHOD_CFUNC_P ( m ) ) { if ( MRB_METHOD_PROC_P ( m ) ) { struct RProc * p = MRB_METHOD_PROC ( m ) ; mrb_vm_ci_proc_set ( ci , p ) ; recv = p -> body . func ( mrb , recv ) ; } else { if ( MRB_METHOD_NOARG_P ( m ) ) { check_method_noarg ( mrb , ci ) ; } recv = MRB_METHOD_FUNC ( m ) ( mrb , recv ) ; } mrb_gc_arena_shrink ( mrb , ai ) ; if ( mrb -> exc ) goto L_RAISE ; ci = mrb -> c -> ci ; if ( mrb_proc_p ( blk ) ) { struct RProc * p = mrb_proc_ptr ( blk ) ; if ( p && ! MRB_PROC_STRICT_P ( p ) && MRB_PROC_ENV ( p ) == mrb_vm_ci_env ( & ci [ - 1 ] ) ) { p -> flags |= MRB_PROC_ORPHAN ; } } if ( ! ci -> u . target_class ) { if ( ci -> cci == CINFO_RESUMED ) { mrb -> jmp = prev_jmp ; return recv ; } else { mrb_assert ( ! MRB_PROC_CFUNC_P ( ci [ - 1 ] . proc ) ) ; proc = ci [ - 1 ] . proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; } } ci -> stack [ 0 ] = recv ; ci = cipop ( mrb ) ; pc = ci -> pc ; } else { mrb_vm_ci_proc_set ( ci , ( proc = MRB_METHOD_PROC ( m ) ) ) ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , ( irep -> nregs < 4 ) ? 4 : irep -> nregs ) ; pc = irep -> iseq ; } } JUMP ; CASE ( OP_CALL , Z ) { mrb_callinfo * ci = mrb -> c -> ci ; mrb_value recv = ci -> stack [ 0 ] ; struct RProc * m = mrb_proc_ptr ( recv ) ; ci -> u . target_class = MRB_PROC_TARGET_CLASS ( m ) ; mrb_vm_ci_proc_set ( ci , m ) ; if ( MRB_PROC_ENV_P ( m ) ) { ci -> mid = MRB_PROC_ENV ( m ) -> mid ; } if ( MRB_PROC_CFUNC_P ( m ) ) { recv = MRB_PROC_CFUNC ( m ) ( mrb , recv ) ; mrb_gc_arena_shrink ( mrb , ai ) ; if ( mrb -> exc ) goto L_RAISE ; ci = cipop ( mrb ) ; pc = ci -> pc ; ci [ 1 ] . stack [ 0 ] = recv ; irep = mrb -> c -> ci -> proc -> body . irep ; } else { proc = m ; irep = m -> body . irep ; if ( ! irep ) { mrb -> c -> ci -> stack [ 0 ] = mrb_nil_value ( ) ; a = 0 ; c = OP_R_NORMAL ; goto L_OP_RETURN_BODY ; } mrb_int nargs = mrb_ci_bidx ( ci ) + 1 ; if ( nargs < irep -> nregs ) { mrb_stack_extend ( mrb , irep -> nregs ) ; stack_clear ( regs + nargs , irep -> nregs - nargs ) ; } if ( MRB_PROC_ENV_P ( m ) ) { regs [ 0 ] = MRB_PROC_ENV ( m ) -> stack [ 0 ] ; } pc = irep -> iseq ; } pool = irep -> pool ; syms = irep -> syms ; JUMP ; } CASE ( OP_SUPER , BB ) { mrb_method_t m ; struct RClass * cls ; mrb_callinfo * ci = mrb -> c -> ci ; mrb_value recv , blk ; const struct RProc * p = ci -> proc ; mrb_sym mid = ci -> mid ; struct RClass * target_class = MRB_PROC_TARGET_CLASS ( p ) ; if ( MRB_PROC_ENV_P ( p ) && p -> e . env -> mid && p -> e . env -> mid != mid ) { mid = p -> e . env -> mid ; } if ( mid == 0 || ! target_class ) { mrb_value exc = mrb_exc_new_lit ( mrb , E_NOMETHOD_ERROR , \"super<S2SV_blank>called<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>method\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } <S2SV_StartBug> if ( target_class -> flags & MRB_FL_CLASS_IS_PREPENDED ) { <S2SV_EndBug> target_class = mrb_vm_ci_target_class ( ci ) ; } else if ( target_class -> tt == MRB_TT_MODULE ) { target_class = mrb_vm_ci_target_class ( ci ) ; if ( ! target_class || target_class -> tt != MRB_TT_ICLASS ) { goto super_typeerror ; } } recv = regs [ 0 ] ; if ( ! mrb_obj_is_kind_of ( mrb , recv , target_class ) ) { super_typeerror : ; mrb_value exc = mrb_exc_new_lit ( mrb , E_TYPE_ERROR , \"self<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>type<S2SV_blank>to<S2SV_blank>call<S2SV_blank>super<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } ARGUMENT_NORMALIZE ( a , & b , OP_SUPER ) ; cls = target_class -> super ; m = mrb_method_search_vm ( mrb , & cls , mid ) ; if ( MRB_METHOD_UNDEF_P ( m ) ) { m = prepare_missing ( mrb , recv , mid , & cls , a , & b , blk , 1 ) ; mid = MRB_SYM ( method_missing ) ; } ci = cipush ( mrb , a , 0 , cls , NULL , mid , b ) ; ci -> stack [ 0 ] = recv ; if ( MRB_METHOD_CFUNC_P ( m ) ) { mrb_value v ; if ( MRB_METHOD_PROC_P ( m ) ) { mrb_vm_ci_proc_set ( ci , MRB_METHOD_PROC ( m ) ) ; } v = MRB_METHOD_CFUNC ( m ) ( mrb , recv ) ; mrb_gc_arena_restore ( mrb , ai ) ; if ( mrb -> exc ) goto L_RAISE ; ci = mrb -> c -> ci ; mrb_assert ( ! mrb_break_p ( v ) ) ; if ( ! mrb_vm_ci_target_class ( ci ) ) { if ( ci -> cci == CINFO_RESUMED ) { mrb -> jmp = prev_jmp ; return v ; } else { mrb_assert ( ! MRB_PROC_CFUNC_P ( ci [ - 1 ] . proc ) ) ; proc = ci [ - 1 ] . proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; } } mrb -> c -> ci -> stack [ 0 ] = v ; ci = cipop ( mrb ) ; pc = ci -> pc ; } else { mrb_vm_ci_proc_set ( ci , ( proc = MRB_METHOD_PROC ( m ) ) ) ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , ( irep -> nregs < 4 ) ? 4 : irep -> nregs ) ; pc = irep -> iseq ; } JUMP ; } CASE ( OP_ARGARY , BS ) { mrb_int m1 = ( b >> 11 ) & 0x3f ; mrb_int r = ( b >> 10 ) & 0x1 ; mrb_int m2 = ( b >> 5 ) & 0x1f ; mrb_int kd = ( b >> 4 ) & 0x1 ; mrb_int lv = ( b >> 0 ) & 0xf ; mrb_value * stack ; if ( mrb -> c -> ci -> mid == 0 || mrb_vm_ci_target_class ( mrb -> c -> ci ) == NULL ) { mrb_value exc ; L_NOSUPER : exc = mrb_exc_new_lit ( mrb , E_NOMETHOD_ERROR , \"super<S2SV_blank>called<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>method\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } if ( lv == 0 ) stack = regs + 1 ; else { struct REnv * e = uvenv ( mrb , lv - 1 ) ; if ( ! e ) goto L_NOSUPER ; if ( MRB_ENV_LEN ( e ) <= m1 + r + m2 + 1 ) goto L_NOSUPER ; stack = e -> stack + 1 ; } if ( r == 0 ) { regs [ a ] = mrb_ary_new_from_values ( mrb , m1 + m2 , stack ) ; } else { mrb_value * pp = NULL ; struct RArray * rest ; mrb_int len = 0 ; if ( mrb_array_p ( stack [ m1 ] ) ) { struct RArray * ary = mrb_ary_ptr ( stack [ m1 ] ) ; pp = ARY_PTR ( ary ) ; len = ARY_LEN ( ary ) ; } regs [ a ] = mrb_ary_new_capa ( mrb , m1 + len + m2 ) ; rest = mrb_ary_ptr ( regs [ a ] ) ; if ( m1 > 0 ) { stack_copy ( ARY_PTR ( rest ) , stack , m1 ) ; } if ( len > 0 ) { stack_copy ( ARY_PTR ( rest ) + m1 , pp , len ) ; } if ( m2 > 0 ) { stack_copy ( ARY_PTR ( rest ) + m1 + len , stack + m1 + 1 , m2 ) ; } ARY_SET_LEN ( rest , m1 + len + m2 ) ; } if ( kd ) { regs [ a + 1 ] = stack [ m1 + r + m2 ] ; regs [ a + 2 ] = stack [ m1 + r + m2 + 1 ] ; } else { regs [ a + 1 ] = stack [ m1 + r + m2 ] ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ENTER , W ) { mrb_int m1 = MRB_ASPEC_REQ ( a ) ; mrb_int o = MRB_ASPEC_OPT ( a ) ; mrb_int r = MRB_ASPEC_REST ( a ) ; mrb_int m2 = MRB_ASPEC_POST ( a ) ; mrb_int kd = ( MRB_ASPEC_KEY ( a ) > 0 || MRB_ASPEC_KDICT ( a ) ) ? 1 : 0 ; mrb_int const len = m1 + o + r + m2 ; mrb_callinfo * ci = mrb -> c -> ci ; mrb_int argc = ci -> n ; mrb_value * argv = regs + 1 ; mrb_value * const argv0 = argv ; mrb_int const kw_pos = len + kd ; mrb_int const blk_pos = kw_pos + 1 ; mrb_value blk = regs [ mrb_ci_bidx ( ci ) ] ; mrb_value kdict = mrb_nil_value ( ) ; if ( ci -> nk > 0 ) { mrb_int kidx = mrb_ci_kidx ( ci ) ; kdict = regs [ kidx ] ; if ( ! mrb_hash_p ( kdict ) || mrb_hash_size ( mrb , kdict ) == 0 ) { kdict = mrb_nil_value ( ) ; ci -> nk = 0 ; } } if ( ! kd && ! mrb_nil_p ( kdict ) ) { if ( argc < 14 ) { ci -> n ++ ; argc ++ ; } else if ( argc == 14 ) { regs [ 1 ] = mrb_ary_new_from_values ( mrb , argc + 1 , & regs [ 1 ] ) ; argc = ci -> n = 15 ; } else { mrb_ary_push ( mrb , regs [ 1 ] , regs [ 2 ] ) ; } ci -> nk = 0 ; } if ( kd && MRB_ASPEC_KEY ( a ) > 0 && mrb_hash_p ( kdict ) ) { kdict = mrb_hash_dup ( mrb , kdict ) ; } if ( argc == 15 ) { struct RArray * ary = mrb_ary_ptr ( regs [ 1 ] ) ; argv = ARY_PTR ( ary ) ; argc = ( int ) ARY_LEN ( ary ) ; mrb_gc_protect ( mrb , regs [ 1 ] ) ; } if ( ci -> proc && MRB_PROC_STRICT_P ( ci -> proc ) ) { if ( argc < m1 + m2 || ( r == 0 && argc > len ) ) { argnum_error ( mrb , m1 + m2 ) ; goto L_RAISE ; } } else if ( len > 1 && argc == 1 && mrb_array_p ( argv [ 0 ] ) ) { mrb_gc_protect ( mrb , argv [ 0 ] ) ; argc = ( int ) RARRAY_LEN ( argv [ 0 ] ) ; argv = RARRAY_PTR ( argv [ 0 ] ) ; } mrb_value rest = mrb_nil_value ( ) ; if ( argc < len ) { mrb_int mlen = m2 ; if ( argc < m1 + m2 ) { mlen = m1 < argc ? argc - m1 : 0 ; } if ( argv0 != argv && argv ) { value_move ( & regs [ 1 ] , argv , argc - mlen ) ; } if ( argc < m1 ) { stack_clear ( & regs [ argc + 1 ] , m1 - argc ) ; } if ( mlen ) { value_move ( & regs [ len - m2 + 1 ] , & argv [ argc - mlen ] , mlen ) ; } if ( mlen < m2 ) { stack_clear ( & regs [ len - m2 + mlen + 1 ] , m2 - mlen ) ; } if ( r ) { rest = mrb_ary_new_capa ( mrb , 0 ) ; regs [ m1 + o + 1 ] = rest ; } if ( o > 0 && argc > m1 + m2 ) pc += ( argc - m1 - m2 ) * 3 ; } else { mrb_int rnum = 0 ; if ( argv0 != argv ) { value_move ( & regs [ 1 ] , argv , m1 + o ) ; } if ( r ) { rnum = argc - m1 - o - m2 ; rest = mrb_ary_new_from_values ( mrb , rnum , argv + m1 + o ) ; regs [ m1 + o + 1 ] = rest ; } if ( m2 > 0 && argc - m2 > m1 ) { value_move ( & regs [ m1 + o + r + 1 ] , & argv [ m1 + o + rnum ] , m2 ) ; } pc += o * 3 ; } regs [ blk_pos ] = blk ; if ( kd ) { if ( mrb_nil_p ( kdict ) ) kdict = mrb_hash_new_capa ( mrb , 0 ) ; regs [ kw_pos ] = kdict ; } mrb -> c -> ci -> n = ( uint8_t ) len ; if ( irep -> nlocals - blk_pos - 1 > 0 ) { stack_clear ( & regs [ blk_pos + 1 ] , irep -> nlocals - blk_pos - 1 ) ; } JUMP ; } CASE ( OP_KARG , BB ) { mrb_value k = mrb_symbol_value ( syms [ b ] ) ; mrb_int kidx = mrb_ci_kidx ( mrb -> c -> ci ) ; mrb_value kdict , v ; if ( kidx < 0 || ! mrb_hash_p ( kdict = regs [ kidx ] ) || ! mrb_hash_key_p ( mrb , kdict , k ) ) { mrb_value str = mrb_format ( mrb , \"missing<S2SV_blank>keyword:<S2SV_blank>%v\" , k ) ; mrb_exc_set ( mrb , mrb_exc_new_str ( mrb , E_ARGUMENT_ERROR , str ) ) ; goto L_RAISE ; } v = mrb_hash_get ( mrb , kdict , k ) ; regs [ a ] = v ; mrb_hash_delete_key ( mrb , kdict , k ) ; NEXT ; } CASE ( OP_KEY_P , BB ) { mrb_value k = mrb_symbol_value ( syms [ b ] ) ; mrb_int kidx = mrb_ci_kidx ( mrb -> c -> ci ) ; mrb_value kdict ; mrb_bool key_p = FALSE ; if ( kidx >= 0 && mrb_hash_p ( kdict = regs [ kidx ] ) ) { key_p = mrb_hash_key_p ( mrb , kdict , k ) ; } regs [ a ] = mrb_bool_value ( key_p ) ; NEXT ; } CASE ( OP_KEYEND , Z ) { mrb_int kidx = mrb_ci_kidx ( mrb -> c -> ci ) ; mrb_value kdict ; if ( kidx >= 0 && mrb_hash_p ( kdict = regs [ kidx ] ) && ! mrb_hash_empty_p ( mrb , kdict ) ) { mrb_value keys = mrb_hash_keys ( mrb , kdict ) ; mrb_value key1 = RARRAY_PTR ( keys ) [ 0 ] ; mrb_value str = mrb_format ( mrb , \"unknown<S2SV_blank>keyword:<S2SV_blank>%v\" , key1 ) ; mrb_exc_set ( mrb , mrb_exc_new_str ( mrb , E_ARGUMENT_ERROR , str ) ) ; goto L_RAISE ; } NEXT ; } CASE ( OP_BREAK , B ) { c = OP_R_BREAK ; goto L_RETURN ; } CASE ( OP_RETURN_BLK , B ) { c = OP_R_RETURN ; goto L_RETURN ; } CASE ( OP_RETURN , B ) c = OP_R_NORMAL ; L_RETURN : { mrb_callinfo * ci ; ci = mrb -> c -> ci ; if ( ci -> mid ) { mrb_value blk = regs [ mrb_ci_bidx ( ci ) ] ; if ( mrb_proc_p ( blk ) ) { struct RProc * p = mrb_proc_ptr ( blk ) ; if ( ! MRB_PROC_STRICT_P ( p ) && ci > mrb -> c -> cibase && MRB_PROC_ENV ( p ) == mrb_vm_ci_env ( & ci [ - 1 ] ) ) { p -> flags |= MRB_PROC_ORPHAN ; } } } if ( mrb -> exc ) { L_RAISE : ci = mrb -> c -> ci ; if ( ci == mrb -> c -> cibase ) { ch = catch_handler_find ( mrb , ci , pc , MRB_CATCH_FILTER_ALL ) ; if ( ch == NULL ) goto L_FTOP ; goto L_CATCH ; } while ( ( ch = catch_handler_find ( mrb , ci , pc , MRB_CATCH_FILTER_ALL ) ) == NULL ) { ci = cipop ( mrb ) ; if ( ci [ 1 ] . cci == CINFO_SKIP && prev_jmp ) { mrb -> jmp = prev_jmp ; MRB_THROW ( prev_jmp ) ; } pc = ci [ 0 ] . pc ; if ( ci == mrb -> c -> cibase ) { ch = catch_handler_find ( mrb , ci , pc , MRB_CATCH_FILTER_ALL ) ; if ( ch == NULL ) { L_FTOP : if ( mrb -> c == mrb -> root_c ) { mrb -> c -> ci -> stack = mrb -> c -> stbase ; goto L_STOP ; } else { struct mrb_context * c = mrb -> c ; c -> status = MRB_FIBER_TERMINATED ; mrb -> c = c -> prev ; c -> prev = NULL ; goto L_RAISE ; } } break ; } } L_CATCH : if ( ch == NULL ) goto L_STOP ; if ( FALSE ) { L_CATCH_TAGGED_BREAK : ci = mrb -> c -> ci ; } proc = ci -> proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , irep -> nregs ) ; pc = irep -> iseq + mrb_irep_catch_handler_unpack ( ch -> target ) ; } else { mrb_int acc ; mrb_value v ; ci = mrb -> c -> ci ; v = regs [ a ] ; mrb_gc_protect ( mrb , v ) ; switch ( c ) { case OP_R_RETURN : if ( ci -> cci == CINFO_NONE && MRB_PROC_ENV_P ( proc ) && ! MRB_PROC_STRICT_P ( proc ) ) { const struct RProc * dst ; mrb_callinfo * cibase ; cibase = mrb -> c -> cibase ; dst = top_proc ( mrb , proc ) ; if ( MRB_PROC_ENV_P ( dst ) ) { struct REnv * e = MRB_PROC_ENV ( dst ) ; if ( ! MRB_ENV_ONSTACK_P ( e ) || ( e -> cxt && e -> cxt != mrb -> c ) ) { localjump_error ( mrb , LOCALJUMP_ERROR_RETURN ) ; goto L_RAISE ; } } while ( cibase <= ci && ci -> proc != dst ) { if ( ci -> cci > CINFO_NONE ) { localjump_error ( mrb , LOCALJUMP_ERROR_RETURN ) ; goto L_RAISE ; } ci -- ; } if ( ci <= cibase ) { localjump_error ( mrb , LOCALJUMP_ERROR_RETURN ) ; goto L_RAISE ; } ci = mrb -> c -> ci ; while ( cibase <= ci && ci -> proc != dst ) { CHECKPOINT_RESTORE ( RBREAK_TAG_RETURN_BLOCK ) { cibase = mrb -> c -> cibase ; dst = top_proc ( mrb , proc ) ; } CHECKPOINT_MAIN ( RBREAK_TAG_RETURN_BLOCK ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_RETURN_BLOCK , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_RETURN_BLOCK ) ; ci = cipop ( mrb ) ; pc = ci -> pc ; } proc = ci -> proc ; mrb -> exc = NULL ; break ; } case OP_R_NORMAL : NORMAL_RETURN : if ( ci == mrb -> c -> cibase ) { struct mrb_context * c ; c = mrb -> c ; if ( ! c -> prev ) { regs [ irep -> nlocals ] = v ; goto CHECKPOINT_LABEL_MAKE ( RBREAK_TAG_STOP ) ; } if ( ! c -> vmexec && c -> prev -> ci == c -> prev -> cibase ) { mrb_value exc = mrb_exc_new_lit ( mrb , E_FIBER_ERROR , \"double<S2SV_blank>resume\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } CHECKPOINT_RESTORE ( RBREAK_TAG_RETURN_TOPLEVEL ) { c = mrb -> c ; } CHECKPOINT_MAIN ( RBREAK_TAG_RETURN_TOPLEVEL ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_RETURN_TOPLEVEL , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_RETURN_TOPLEVEL ) ; c -> status = MRB_FIBER_TERMINATED ; mrb -> c = c -> prev ; mrb -> c -> status = MRB_FIBER_RUNNING ; c -> prev = NULL ; if ( c -> vmexec ) { mrb_gc_arena_restore ( mrb , ai ) ; c -> vmexec = FALSE ; mrb -> jmp = prev_jmp ; return v ; } ci = mrb -> c -> ci ; } CHECKPOINT_RESTORE ( RBREAK_TAG_RETURN ) { } CHECKPOINT_MAIN ( RBREAK_TAG_RETURN ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_RETURN , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_RETURN ) ; mrb -> exc = NULL ; break ; case OP_R_BREAK : if ( MRB_PROC_STRICT_P ( proc ) ) goto NORMAL_RETURN ; if ( MRB_PROC_ORPHAN_P ( proc ) ) { mrb_value exc ; L_BREAK_ERROR : exc = mrb_exc_new_lit ( mrb , E_LOCALJUMP_ERROR , \"break<S2SV_blank>from<S2SV_blank>proc-closure\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } if ( ! MRB_PROC_ENV_P ( proc ) || ! MRB_ENV_ONSTACK_P ( MRB_PROC_ENV ( proc ) ) ) { goto L_BREAK_ERROR ; } else { struct REnv * e = MRB_PROC_ENV ( proc ) ; if ( e -> cxt != mrb -> c ) { goto L_BREAK_ERROR ; } } CHECKPOINT_RESTORE ( RBREAK_TAG_BREAK ) { } CHECKPOINT_MAIN ( RBREAK_TAG_BREAK ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_BREAK , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_BREAK ) ; if ( ci == mrb -> c -> cibase && ci -> pc ) { struct mrb_context * c = mrb -> c ; mrb -> c = c -> prev ; c -> prev = NULL ; ci = mrb -> c -> ci ; } if ( ci -> cci > CINFO_NONE ) { ci = cipop ( mrb ) ; mrb -> exc = ( struct RObject * ) break_new ( mrb , RBREAK_TAG_BREAK , proc , v ) ; mrb_gc_arena_restore ( mrb , ai ) ; mrb -> c -> vmexec = FALSE ; mrb -> jmp = prev_jmp ; MRB_THROW ( prev_jmp ) ; } if ( FALSE ) { struct RBreak * brk ; L_BREAK : brk = ( struct RBreak * ) mrb -> exc ; proc = mrb_break_proc_get ( brk ) ; v = mrb_break_value_get ( brk ) ; ci = mrb -> c -> ci ; switch ( mrb_break_tag_get ( brk ) ) { # define DISPATCH_CHECKPOINTS ( n , i ) case n : goto CHECKPOINT_LABEL_MAKE ( n ) ; RBREAK_TAG_FOREACH ( DISPATCH_CHECKPOINTS ) # undef DISPATCH_CHECKPOINTS default : mrb_assert ( ! \"wrong<S2SV_blank>break<S2SV_blank>tag\" ) ; } } while ( mrb -> c -> cibase < ci && ci [ - 1 ] . proc != proc -> upper ) { if ( ci [ - 1 ] . cci == CINFO_SKIP ) { goto L_BREAK_ERROR ; } CHECKPOINT_RESTORE ( RBREAK_TAG_BREAK_UPPER ) { } CHECKPOINT_MAIN ( RBREAK_TAG_BREAK_UPPER ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_BREAK_UPPER , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_BREAK_UPPER ) ; ci = cipop ( mrb ) ; pc = ci -> pc ; } CHECKPOINT_RESTORE ( RBREAK_TAG_BREAK_INTARGET ) { } CHECKPOINT_MAIN ( RBREAK_TAG_BREAK_INTARGET ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_BREAK_INTARGET , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_BREAK_INTARGET ) ; if ( ci == mrb -> c -> cibase ) { goto L_BREAK_ERROR ; } mrb -> exc = NULL ; break ; default : break ; } mrb_assert ( ci == mrb -> c -> ci ) ; mrb_assert ( mrb -> exc == NULL ) ; if ( mrb -> c -> vmexec && ! mrb_vm_ci_target_class ( ci ) ) { mrb_gc_arena_restore ( mrb , ai ) ; mrb -> c -> vmexec = FALSE ; mrb -> jmp = prev_jmp ; return v ; } acc = ci -> cci ; ci = cipop ( mrb ) ; if ( acc == CINFO_SKIP || acc == CINFO_DIRECT ) { mrb_gc_arena_restore ( mrb , ai ) ; mrb -> jmp = prev_jmp ; return v ; } pc = ci -> pc ; DEBUG ( fprintf ( stderr , \"from<S2SV_blank>:%s\\\\n\" , mrb_sym_name ( mrb , ci -> mid ) ) ) ; proc = ci -> proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; ci [ 1 ] . stack [ 0 ] = v ; mrb_gc_arena_restore ( mrb , ai ) ; } JUMP ; } CASE ( OP_BLKPUSH , BS ) { int m1 = ( b >> 11 ) & 0x3f ; int r = ( b >> 10 ) & 0x1 ; int m2 = ( b >> 5 ) & 0x1f ; int kd = ( b >> 4 ) & 0x1 ; int lv = ( b >> 0 ) & 0xf ; mrb_value * stack ; if ( lv == 0 ) stack = regs + 1 ; else { struct REnv * e = uvenv ( mrb , lv - 1 ) ; if ( ! e || ( ! MRB_ENV_ONSTACK_P ( e ) && e -> mid == 0 ) || MRB_ENV_LEN ( e ) <= m1 + r + m2 + 1 ) { localjump_error ( mrb , LOCALJUMP_ERROR_YIELD ) ; goto L_RAISE ; } stack = e -> stack + 1 ; } if ( mrb_nil_p ( stack [ m1 + r + m2 + kd ] ) ) { localjump_error ( mrb , LOCALJUMP_ERROR_YIELD ) ; goto L_RAISE ; } regs [ a ] = stack [ m1 + r + m2 + kd ] ; NEXT ; } # if ! defined ( MRB_USE_BIGINT ) || defined ( MRB_INT32 ) L_INT_OVERFLOW : { mrb_value exc = mrb_exc_new_lit ( mrb , E_RANGE_ERROR , \"integer<S2SV_blank>overflow\" ) ; mrb_exc_set ( mrb , exc ) ; } goto L_RAISE ; # endif # define TYPES2 ( a , b ) ( ( ( ( uint16_t ) ( a ) ) << 8 ) | ( ( ( uint16_t ) ( b ) ) & 0xff ) ) # define OP_MATH ( op_name ) switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { OP_MATH_CASE_INTEGER ( op_name ) ; OP_MATH_CASE_FLOAT ( op_name , integer , float ) ; OP_MATH_CASE_FLOAT ( op_name , float , integer ) ; OP_MATH_CASE_FLOAT ( op_name , float , float ) ; OP_MATH_CASE_STRING_ ## op_name ( ) ; default : mid = MRB_OPSYM ( op_name ) ; goto L_SEND_SYM ; } NEXT ; # define OP_MATH_CASE_INTEGER ( op_name ) case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : { mrb_int x = mrb_integer ( regs [ a ] ) , y = mrb_integer ( regs [ a + 1 ] ) , z ; if ( mrb_int_ ## op_name ## _overflow ( x , y , & z ) ) { OP_MATH_OVERFLOW_INT ( op_name , x , y ) ; } else SET_INT_VALUE ( mrb , regs [ a ] , z ) ; } break # ifdef MRB_NO_FLOAT # define OP_MATH_CASE_FLOAT ( op_name , t1 , t2 ) ( void ) 0 # else # define OP_MATH_CASE_FLOAT ( op_name , t1 , t2 ) case TYPES2 ( OP_MATH_TT_ ## t1 , OP_MATH_TT_ ## t2 ) : { mrb_float z = mrb_ ## t1 ( regs [ a ] ) OP_MATH_OP_ ## op_name mrb_ ## t2 ( regs [ a + 1 ] ) ; SET_FLOAT_VALUE ( mrb , regs [ a ] , z ) ; } break # endif # ifdef MRB_USE_BIGINT # define OP_MATH_OVERFLOW_INT ( op , x , y ) regs [ a ] = mrb_bint_ ## op ## _ii ( mrb , x , y ) # else # define OP_MATH_OVERFLOW_INT ( op , x , y ) goto L_INT_OVERFLOW # endif # define OP_MATH_CASE_STRING_add ( ) case TYPES2 ( MRB_TT_STRING , MRB_TT_STRING ) : regs [ a ] = mrb_str_plus ( mrb , regs [ a ] , regs [ a + 1 ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; break # define OP_MATH_CASE_STRING_sub ( ) ( void ) 0 # define OP_MATH_CASE_STRING_mul ( ) ( void ) 0 # define OP_MATH_OP_add + # define OP_MATH_OP_sub - # define OP_MATH_OP_mul * # define OP_MATH_TT_integer MRB_TT_INTEGER # define OP_MATH_TT_float MRB_TT_FLOAT CASE ( OP_ADD , B ) { OP_MATH ( add ) ; } CASE ( OP_SUB , B ) { OP_MATH ( sub ) ; } CASE ( OP_MUL , B ) { OP_MATH ( mul ) ; } CASE ( OP_DIV , B ) { # ifndef MRB_NO_FLOAT mrb_float x , y , f ; # endif switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : { mrb_int x = mrb_integer ( regs [ a ] ) ; mrb_int y = mrb_integer ( regs [ a + 1 ] ) ; mrb_int div = mrb_div_int ( mrb , x , y ) ; SET_INT_VALUE ( mrb , regs [ a ] , div ) ; } NEXT ; # ifndef MRB_NO_FLOAT case TYPES2 ( MRB_TT_INTEGER , MRB_TT_FLOAT ) : x = ( mrb_float ) mrb_integer ( regs [ a ] ) ; y = mrb_float ( regs [ a + 1 ] ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_INTEGER ) : x = mrb_float ( regs [ a ] ) ; y = ( mrb_float ) mrb_integer ( regs [ a + 1 ] ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_FLOAT ) : x = mrb_float ( regs [ a ] ) ; y = mrb_float ( regs [ a + 1 ] ) ; break ; # endif default : mid = MRB_OPSYM ( div ) ; goto L_SEND_SYM ; } # ifndef MRB_NO_FLOAT f = mrb_div_float ( x , y ) ; SET_FLOAT_VALUE ( mrb , regs [ a ] , f ) ; # endif NEXT ; } # define OP_MATHI ( op_name ) switch ( mrb_type ( regs [ a ] ) ) { OP_MATHI_CASE_INTEGER ( op_name ) ; OP_MATHI_CASE_FLOAT ( op_name ) ; default : SET_INT_VALUE ( mrb , regs [ a + 1 ] , b ) ; mid = MRB_OPSYM ( op_name ) ; goto L_SEND_SYM ; } NEXT ; # define OP_MATHI_CASE_INTEGER ( op_name ) case MRB_TT_INTEGER : { mrb_int x = mrb_integer ( regs [ a ] ) , y = ( mrb_int ) b , z ; if ( mrb_int_ ## op_name ## _overflow ( x , y , & z ) ) { OP_MATH_OVERFLOW_INT ( op_name , x , y ) ; } else SET_INT_VALUE ( mrb , regs [ a ] , z ) ; } break # ifdef MRB_NO_FLOAT # define OP_MATHI_CASE_FLOAT ( op_name ) ( void ) 0 # else # define OP_MATHI_CASE_FLOAT ( op_name ) case MRB_TT_FLOAT : { mrb_float z = mrb_float ( regs [ a ] ) OP_MATH_OP_ ## op_name b ; SET_FLOAT_VALUE ( mrb , regs [ a ] , z ) ; } break # endif CASE ( OP_ADDI , BB ) { OP_MATHI ( add ) ; } CASE ( OP_SUBI , BB ) { OP_MATHI ( sub ) ; } # define OP_CMP_BODY ( op , v1 , v2 ) ( v1 ( regs [ a ] ) op v2 ( regs [ a + 1 ] ) ) # ifdef MRB_NO_FLOAT <S2SV_StartBug> # define OP_CMP ( op , sym ) do { int result ; switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : result = OP_CMP_BODY ( op , mrb_fixnum , mrb_fixnum ) ; break ; default : mid = MRB_OPSYM ( sym ) ; goto L_SEND_SYM ; } if ( result ) { SET_TRUE_VALUE ( regs [ a ] ) ; } else { SET_FALSE_VALUE ( regs [ a ] ) ; } } while ( 0 ) <S2SV_EndBug> # else <S2SV_StartBug> # define OP_CMP ( op , sym ) do { int result ; switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : result = OP_CMP_BODY ( op , mrb_fixnum , mrb_fixnum ) ; break ; case TYPES2 ( MRB_TT_INTEGER , MRB_TT_FLOAT ) : result = OP_CMP_BODY ( op , mrb_fixnum , mrb_float ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_INTEGER ) : result = OP_CMP_BODY ( op , mrb_float , mrb_fixnum ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_FLOAT ) : result = OP_CMP_BODY ( op , mrb_float , mrb_float ) ; break ; default : mid = MRB_OPSYM ( sym ) ; goto L_SEND_SYM ; } if ( result ) { SET_TRUE_VALUE ( regs [ a ] ) ; } else { SET_FALSE_VALUE ( regs [ a ] ) ; } } while ( 0 ) <S2SV_EndBug> # endif CASE ( OP_EQ , B ) { if ( mrb_obj_eq ( mrb , regs [ a ] , regs [ a + 1 ] ) ) { SET_TRUE_VALUE ( regs [ a ] ) ; } else { OP_CMP ( == , eq ) ; } NEXT ; } CASE ( OP_LT , B ) { OP_CMP ( < , lt ) ; NEXT ; } CASE ( OP_LE , B ) { OP_CMP ( <= , le ) ; NEXT ; } CASE ( OP_GT , B ) { OP_CMP ( > , gt ) ; NEXT ; } CASE ( OP_GE , B ) { OP_CMP ( >= , ge ) ; NEXT ; } CASE ( OP_ARRAY , BB ) { regs [ a ] = mrb_ary_new_from_values ( mrb , b , & regs [ a ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ARRAY2 , BBB ) { regs [ a ] = mrb_ary_new_from_values ( mrb , c , & regs [ b ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ARYCAT , B ) { mrb_value splat = mrb_ary_splat ( mrb , regs [ a + 1 ] ) ; if ( mrb_nil_p ( regs [ a ] ) ) { regs [ a ] = splat ; } else { mrb_assert ( mrb_array_p ( regs [ a ] ) ) ; mrb_ary_concat ( mrb , regs [ a ] , splat ) ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ARYPUSH , BB ) { mrb_assert ( mrb_array_p ( regs [ a ] ) ) ; for ( mrb_int i = 0 ; i < b ; i ++ ) { mrb_ary_push ( mrb , regs [ a ] , regs [ a + i + 1 ] ) ; } NEXT ; } CASE ( OP_ARYDUP , B ) { mrb_value ary = regs [ a ] ; if ( mrb_array_p ( ary ) ) { ary = mrb_ary_new_from_values ( mrb , RARRAY_LEN ( ary ) , RARRAY_PTR ( ary ) ) ; } else { ary = mrb_ary_new_from_values ( mrb , 1 , & ary ) ; } regs [ a ] = ary ; NEXT ; } CASE ( OP_AREF , BBB ) { mrb_value v = regs [ b ] ; if ( ! mrb_array_p ( v ) ) { if ( c == 0 ) { regs [ a ] = v ; } else { SET_NIL_VALUE ( regs [ a ] ) ; } } else { v = mrb_ary_ref ( mrb , v , c ) ; regs [ a ] = v ; } NEXT ; } CASE ( OP_ASET , BBB ) { mrb_assert ( mrb_array_p ( regs [ a ] ) ) ; mrb_ary_set ( mrb , regs [ b ] , c , regs [ a ] ) ; NEXT ; } CASE ( OP_APOST , BBB ) { mrb_value v = regs [ a ] ; int pre = b ; int post = c ; struct RArray * ary ; int len , idx ; if ( ! mrb_array_p ( v ) ) { v = mrb_ary_new_from_values ( mrb , 1 , & regs [ a ] ) ; } ary = mrb_ary_ptr ( v ) ; len = ( int ) ARY_LEN ( ary ) ; if ( len > pre + post ) { v = mrb_ary_new_from_values ( mrb , len - pre - post , ARY_PTR ( ary ) + pre ) ; regs [ a ++ ] = v ; while ( post -- ) { regs [ a ++ ] = ARY_PTR ( ary ) [ len - post - 1 ] ; } } else { v = mrb_ary_new_capa ( mrb , 0 ) ; regs [ a ++ ] = v ; for ( idx = 0 ; idx + pre < len ; idx ++ ) { regs [ a + idx ] = ARY_PTR ( ary ) [ pre + idx ] ; } while ( idx < post ) { SET_NIL_VALUE ( regs [ a + idx ] ) ; idx ++ ; } } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_INTERN , B ) { mrb_assert ( mrb_string_p ( regs [ a ] ) ) ; mrb_sym sym = mrb_intern_str ( mrb , regs [ a ] ) ; regs [ a ] = mrb_symbol_value ( sym ) ; NEXT ; } CASE ( OP_SYMBOL , BB ) { size_t len ; mrb_sym sym ; mrb_assert ( ( pool [ b ] . tt & IREP_TT_NFLAG ) == 0 ) ; len = pool [ b ] . tt >> 2 ; if ( pool [ b ] . tt & IREP_TT_SFLAG ) { sym = mrb_intern_static ( mrb , pool [ b ] . u . str , len ) ; } else { sym = mrb_intern ( mrb , pool [ b ] . u . str , len ) ; } regs [ a ] = mrb_symbol_value ( sym ) ; NEXT ; } CASE ( OP_STRING , BB ) { mrb_int len ; mrb_assert ( ( pool [ b ] . tt & IREP_TT_NFLAG ) == 0 ) ; len = pool [ b ] . tt >> 2 ; if ( pool [ b ] . tt & IREP_TT_SFLAG ) { regs [ a ] = mrb_str_new_static ( mrb , pool [ b ] . u . str , len ) ; } else { regs [ a ] = mrb_str_new ( mrb , pool [ b ] . u . str , len ) ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_STRCAT , B ) { mrb_assert ( mrb_string_p ( regs [ a ] ) ) ; mrb_str_concat ( mrb , regs [ a ] , regs [ a + 1 ] ) ; NEXT ; } CASE ( OP_HASH , BB ) { mrb_value hash = mrb_hash_new_capa ( mrb , b ) ; int i ; int lim = a + b * 2 ; for ( i = a ; i < lim ; i += 2 ) { mrb_hash_set ( mrb , hash , regs [ i ] , regs [ i + 1 ] ) ; } regs [ a ] = hash ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_HASHADD , BB ) { mrb_value hash ; int i ; int lim = a + b * 2 + 1 ; hash = regs [ a ] ; mrb_ensure_hash_type ( mrb , hash ) ; for ( i = a + 1 ; i < lim ; i += 2 ) { mrb_hash_set ( mrb , hash , regs [ i ] , regs [ i + 1 ] ) ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_HASHCAT , B ) { mrb_value hash = regs [ a ] ; mrb_assert ( mrb_hash_p ( hash ) ) ; mrb_hash_merge ( mrb , hash , regs [ a + 1 ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_LAMBDA , BB ) c = OP_L_LAMBDA ; L_MAKE_LAMBDA : { struct RProc * p ; const mrb_irep * nirep = irep -> reps [ b ] ; if ( c & OP_L_CAPTURE ) { p = mrb_closure_new ( mrb , nirep ) ; } else { p = mrb_proc_new ( mrb , nirep ) ; p -> flags |= MRB_PROC_SCOPE ; } if ( c & OP_L_STRICT ) p -> flags |= MRB_PROC_STRICT ; regs [ a ] = mrb_obj_value ( p ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_BLOCK , BB ) { c = OP_L_BLOCK ; goto L_MAKE_LAMBDA ; } CASE ( OP_METHOD , BB ) { c = OP_L_METHOD ; goto L_MAKE_LAMBDA ; } CASE ( OP_RANGE_INC , B ) { mrb_value v = mrb_range_new ( mrb , regs [ a ] , regs [ a + 1 ] , FALSE ) ; regs [ a ] = v ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_RANGE_EXC , B ) { mrb_value v = mrb_range_new ( mrb , regs [ a ] , regs [ a + 1 ] , TRUE ) ; regs [ a ] = v ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_OCLASS , B ) { regs [ a ] = mrb_obj_value ( mrb -> object_class ) ; NEXT ; } CASE ( OP_CLASS , BB ) { struct RClass * c = 0 , * baseclass ; mrb_value base , super ; mrb_sym id = syms [ b ] ; base = regs [ a ] ; super = regs [ a + 1 ] ; if ( mrb_nil_p ( base ) ) { baseclass = MRB_PROC_TARGET_CLASS ( mrb -> c -> ci -> proc ) ; if ( ! baseclass ) baseclass = mrb -> object_class ; base = mrb_obj_value ( baseclass ) ; } c = mrb_vm_define_class ( mrb , base , super , id ) ; regs [ a ] = mrb_obj_value ( c ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_MODULE , BB ) { struct RClass * cls = 0 , * baseclass ; mrb_value base ; mrb_sym id = syms [ b ] ; base = regs [ a ] ; if ( mrb_nil_p ( base ) ) { baseclass = MRB_PROC_TARGET_CLASS ( mrb -> c -> ci -> proc ) ; if ( ! baseclass ) baseclass = mrb -> object_class ; base = mrb_obj_value ( baseclass ) ; } cls = mrb_vm_define_module ( mrb , base , id ) ; regs [ a ] = mrb_obj_value ( cls ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_EXEC , BB ) { mrb_value recv = regs [ a ] ; struct RProc * p ; const mrb_irep * nirep = irep -> reps [ b ] ; p = mrb_proc_new ( mrb , nirep ) ; p -> c = NULL ; mrb_field_write_barrier ( mrb , ( struct RBasic * ) p , ( struct RBasic * ) proc ) ; MRB_PROC_SET_TARGET_CLASS ( p , mrb_class_ptr ( recv ) ) ; p -> flags |= MRB_PROC_SCOPE ; cipush ( mrb , a , 0 , mrb_class_ptr ( recv ) , p , 0 , 0 ) ; irep = p -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , irep -> nregs ) ; stack_clear ( regs + 1 , irep -> nregs - 1 ) ; pc = irep -> iseq ; JUMP ; } CASE ( OP_DEF , BB ) { struct RClass * target = mrb_class_ptr ( regs [ a ] ) ; struct RProc * p = mrb_proc_ptr ( regs [ a + 1 ] ) ; mrb_method_t m ; mrb_sym mid = syms [ b ] ; MRB_METHOD_FROM_PROC ( m , p ) ; mrb_define_method_raw ( mrb , target , mid , m ) ; mrb_method_added ( mrb , target , mid ) ; mrb_gc_arena_restore ( mrb , ai ) ; regs [ a ] = mrb_symbol_value ( mid ) ; NEXT ; } CASE ( OP_SCLASS , B ) { regs [ a ] = mrb_singleton_class ( mrb , regs [ a ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_TCLASS , B ) { struct RClass * target = check_target_class ( mrb ) ; if ( ! target ) goto L_RAISE ; regs [ a ] = mrb_obj_value ( target ) ; NEXT ; } CASE ( OP_ALIAS , BB ) { struct RClass * target = check_target_class ( mrb ) ; if ( ! target ) goto L_RAISE ; mrb_alias_method ( mrb , target , syms [ a ] , syms [ b ] ) ; mrb_method_added ( mrb , target , syms [ a ] ) ; NEXT ; } CASE ( OP_UNDEF , B ) { struct RClass * target = check_target_class ( mrb ) ; if ( ! target ) goto L_RAISE ; mrb_undef_method_id ( mrb , target , syms [ a ] ) ; NEXT ; } CASE ( OP_DEBUG , Z ) { FETCH_BBB ( ) ; # ifdef MRB_USE_DEBUG_HOOK mrb -> debug_op_hook ( mrb , irep , pc , regs ) ; # else # ifndef MRB_NO_STDIO printf ( \"OP_DEBUG<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , a , b , c ) ; # else abort ( ) ; # endif # endif NEXT ; } CASE ( OP_ERR , B ) { size_t len = pool [ a ] . tt >> 2 ; mrb_value exc ; mrb_assert ( ( pool [ a ] . tt & IREP_TT_NFLAG ) == 0 ) ; exc = mrb_exc_new ( mrb , E_LOCALJUMP_ERROR , pool [ a ] . u . str , len ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } CASE ( OP_EXT1 , Z ) { insn = READ_B ( ) ; switch ( insn ) { # define OPCODE ( insn , ops ) case OP_ ## insn : FETCH_ ## ops ## _1 ( ) ; mrb -> c -> ci -> pc = pc ; goto L_OP_ ## insn ## _BODY ; # include \"mruby/ops.h\" # undef OPCODE } pc -- ; NEXT ; } CASE ( OP_EXT2 , Z ) { insn = READ_B ( ) ; switch ( insn ) { # define OPCODE ( insn , ops ) case OP_ ## insn : FETCH_ ## ops ## _2 ( ) ; mrb -> c -> ci -> pc = pc ; goto L_OP_ ## insn ## _BODY ; # include \"mruby/ops.h\" # undef OPCODE } pc -- ; NEXT ; } CASE ( OP_EXT3 , Z ) { uint8_t insn = READ_B ( ) ; switch ( insn ) { # define OPCODE ( insn , ops ) case OP_ ## insn : FETCH_ ## ops ## _3 ( ) ; mrb -> c -> ci -> pc = pc ; goto L_OP_ ## insn ## _BODY ; # include \"mruby/ops.h\" # undef OPCODE } pc -- ; NEXT ; } CASE ( OP_STOP , Z ) { CHECKPOINT_RESTORE ( RBREAK_TAG_STOP ) { } CHECKPOINT_MAIN ( RBREAK_TAG_STOP ) { UNWIND_ENSURE ( mrb , mrb -> c -> ci , pc , RBREAK_TAG_STOP , proc , mrb_nil_value ( ) ) ; } CHECKPOINT_END ( RBREAK_TAG_STOP ) ; L_STOP : mrb -> jmp = prev_jmp ; if ( mrb -> exc ) { mrb_assert ( mrb -> exc -> tt == MRB_TT_EXCEPTION ) ; return mrb_obj_value ( mrb -> exc ) ; } return regs [ irep -> nlocals ] ; } } END_DISPATCH ; # undef regs } MRB_CATCH ( & c_jmp ) { mrb_callinfo * ci = mrb -> c -> ci ; while ( ci > mrb -> c -> cibase && ci -> cci == CINFO_DIRECT ) { ci = cipop ( mrb ) ; } exc_catched = TRUE ; pc = ci -> pc ; goto RETRY_TRY_BLOCK ; } MRB_END_EXC ( & c_jmp ) ; }", "target": "<S2SV_ModStart> } if ( ( <S2SV_ModStart> & MRB_FL_CLASS_IS_PREPENDED ) || <S2SV_ModEnd> target_class -> tt <S2SV_ModStart> ) ; } \\\\\\n} <S2SV_ModEnd> while ( 0 <S2SV_ModStart> ) ; } \\\\\\n} <S2SV_ModEnd> while ( 0"}
{"source": "CWE-200 QueueHandle_t xQueueGenericCreate ( const UBaseType_t uxQueueLength , const UBaseType_t uxItemSize , const uint8_t ucQueueType ) { Queue_t * pxNewQueue ; size_t xQueueSizeInBytes ; uint8_t * pucQueueStorage ; configASSERT ( uxQueueLength > ( UBaseType_t ) 0 ) ; xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) ; configASSERT ( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) ) ; <S2SV_StartBug> pxNewQueue = ( Queue_t * ) pvPortMalloc ( sizeof ( Queue_t ) + xQueueSizeInBytes ) ; <S2SV_EndBug> if ( pxNewQueue != NULL ) { pucQueueStorage = ( uint8_t * ) pxNewQueue ; pucQueueStorage += sizeof ( Queue_t ) ; # if ( configSUPPORT_STATIC_ALLOCATION == 1 ) { pxNewQueue -> ucStaticallyAllocated = pdFALSE ; } # endif prvInitialiseNewQueue ( uxQueueLength , uxItemSize , pucQueueStorage , ucQueueType , pxNewQueue ) ; } else { traceQUEUE_CREATE_FAILED ( ucQueueType ) ; mtCOVERAGE_TEST_MARKER ( ) ; } return pxNewQueue ; }", "target": "<S2SV_ModStart> ) ) ; configASSERT ( ( sizeof ( Queue_t ) + xQueueSizeInBytes ) > xQueueSizeInBytes ) ;"}
{"source": "CWE-703 void updateHandshakeState ( QuicServerConnectionState & conn ) { auto handshakeLayer = conn . serverHandshakeLayer ; auto zeroRttReadCipher = handshakeLayer -> getZeroRttReadCipher ( ) ; auto zeroRttHeaderCipher = handshakeLayer -> getZeroRttReadHeaderCipher ( ) ; auto oneRttWriteCipher = handshakeLayer -> getOneRttWriteCipher ( ) ; auto oneRttReadCipher = handshakeLayer -> getOneRttReadCipher ( ) ; auto oneRttWriteHeaderCipher = handshakeLayer -> getOneRttWriteHeaderCipher ( ) ; auto oneRttReadHeaderCipher = handshakeLayer -> getOneRttReadHeaderCipher ( ) ; if ( zeroRttReadCipher ) { if ( conn . qLogger ) { conn . qLogger -> addTransportStateUpdate ( kDerivedZeroRttReadCipher ) ; } QUIC_TRACE ( fst_trace , conn , \"derived<S2SV_blank>0-rtt<S2SV_blank>read<S2SV_blank>cipher\" ) ; conn . readCodec -> setZeroRttReadCipher ( std : : move ( zeroRttReadCipher ) ) ; } if ( zeroRttHeaderCipher ) { conn . readCodec -> setZeroRttHeaderCipher ( std : : move ( zeroRttHeaderCipher ) ) ; } if ( oneRttWriteHeaderCipher ) { conn . oneRttWriteHeaderCipher = std : : move ( oneRttWriteHeaderCipher ) ; } if ( oneRttReadHeaderCipher ) { conn . readCodec -> setOneRttHeaderCipher ( std : : move ( oneRttReadHeaderCipher ) ) ; } if ( oneRttWriteCipher ) { if ( conn . qLogger ) { conn . qLogger -> addTransportStateUpdate ( kDerivedOneRttWriteCipher ) ; } QUIC_TRACE ( fst_trace , conn , \"derived<S2SV_blank>1-rtt<S2SV_blank>write<S2SV_blank>cipher\" ) ; <S2SV_StartBug> CHECK ( ! conn . oneRttWriteCipher . get ( ) ) ; <S2SV_EndBug> conn . oneRttWriteCipher = std : : move ( oneRttWriteCipher ) ; updatePacingOnKeyEstablished ( conn ) ; auto clientParams = handshakeLayer -> getClientTransportParams ( ) ; if ( ! clientParams ) { throw QuicTransportException ( \"No<S2SV_blank>client<S2SV_blank>transport<S2SV_blank>params\" , TransportErrorCode : : TRANSPORT_PARAMETER_ERROR ) ; } processClientInitialParams ( conn , std : : move ( * clientParams ) ) ; } if ( oneRttReadCipher ) { if ( conn . qLogger ) { conn . qLogger -> addTransportStateUpdate ( kDerivedOneRttReadCipher ) ; } QUIC_TRACE ( fst_trace , conn , \"derived<S2SV_blank>1-rtt<S2SV_blank>read<S2SV_blank>cipher\" ) ; conn . writableBytesLimit = folly : : none ; conn . readCodec -> setOneRttReadCipher ( std : : move ( oneRttReadCipher ) ) ; } auto handshakeReadCipher = handshakeLayer -> getHandshakeReadCipher ( ) ; auto handshakeReadHeaderCipher = handshakeLayer -> getHandshakeReadHeaderCipher ( ) ; if ( handshakeReadCipher ) { CHECK ( handshakeReadHeaderCipher ) ; conn . readCodec -> setHandshakeReadCipher ( std : : move ( handshakeReadCipher ) ) ; conn . readCodec -> setHandshakeHeaderCipher ( std : : move ( handshakeReadHeaderCipher ) ) ; } if ( handshakeLayer -> isHandshakeDone ( ) ) { CHECK ( conn . oneRttWriteCipher ) ; if ( conn . version != QuicVersion : : MVFST_D24 && ! conn . sentHandshakeDone ) { sendSimpleFrame ( conn , HandshakeDoneFrame ( ) ) ; conn . sentHandshakeDone = true ; } } }", "target": "<S2SV_ModStart> \"derived<S2SV_blank>1-rtt<S2SV_blank>write<S2SV_blank>cipher\" ) ; if ( <S2SV_ModEnd> conn . oneRttWriteCipher <S2SV_ModStart> conn . oneRttWriteCipher ) { throw QuicTransportException ( \"Duplicate<S2SV_blank>1-rtt<S2SV_blank>write<S2SV_blank>cipher\" , TransportErrorCode : : CRYPTO_ERROR ) ; } <S2SV_ModEnd> conn . oneRttWriteCipher"}
{"source": "CWE-703 bool SampleInterleavedLSScan : : ParseMCU ( void ) { # if ACCUSOFT_CODE int lines = m_ulRemaining [ 0 ] ; UBYTE preshift = m_ucLowBit + FractionalColorBitsOf ( ) ; struct Line * line [ 4 ] ; UBYTE cx ; if ( m_pFrame -> HeightOf ( ) == 0 ) { assert ( lines == 0 ) ; lines = 8 ; } if ( lines > 8 ) { lines = 8 ; } <S2SV_StartBug> if ( m_pFrame -> HeightOf ( ) > 0 ) <S2SV_EndBug> <S2SV_StartBug> m_ulRemaining [ 0 ] -= lines ; <S2SV_EndBug> assert ( lines > 0 ) ; assert ( m_ucCount < 4 ) ; for ( cx = 0 ; cx < m_ucCount ; cx ++ ) { line [ cx ] = CurrentLine ( cx ) ; } do { LONG length = m_ulWidth [ 0 ] ; LONG * lp [ 4 ] ; for ( cx = 0 ; cx < m_ucCount ; cx ++ ) { lp [ cx ] = line [ cx ] -> m_pData ; StartLine ( cx ) ; } if ( BeginReadMCU ( m_Stream . ByteStreamOf ( ) ) ) { do { LONG a [ 4 ] , b [ 4 ] , c [ 4 ] , d [ 4 ] ; LONG d1 [ 4 ] , d2 [ 4 ] , d3 [ 4 ] ; bool isrun = true ; for ( cx = 0 ; cx < m_ucCount ; cx ++ ) { GetContext ( cx , a [ cx ] , b [ cx ] , c [ cx ] , d [ cx ] ) ; d1 [ cx ] = d [ cx ] - b [ cx ] ; d2 [ cx ] = b [ cx ] - c [ cx ] ; d3 [ cx ] = c [ cx ] - a [ cx ] ; if ( isrun && ! isRunMode ( d1 [ cx ] , d2 [ cx ] , d3 [ cx ] ) ) isrun = false ; } if ( isrun ) { LONG run = DecodeRun ( length , m_lRunIndex [ 0 ] ) ; while ( run ) { for ( cx = 0 ; cx < m_ucCount ; cx ++ ) { UpdateContext ( cx , a [ cx ] ) ; * lp [ cx ] ++ = a [ cx ] << preshift ; } run -- , length -- ; } if ( length ) { bool negative ; LONG errval ; LONG merr ; LONG rx ; UBYTE k ; for ( cx = 0 ; cx < m_ucCount ; cx ++ ) { GetContext ( cx , a [ cx ] , b [ cx ] , c [ cx ] , d [ cx ] ) ; negative = a [ cx ] > b [ cx ] ; k = GolombParameter ( false ) ; merr = GolombDecode ( k , m_lLimit - m_lJ [ m_lRunIndex [ 0 ] ] - 1 ) ; errval = InverseErrorMapping ( merr , ErrorMappingOffset ( false , merr != 0 , k ) ) ; rx = Reconstruct ( negative , b [ cx ] , errval ) ; UpdateContext ( cx , rx ) ; * lp [ cx ] ++ = rx << preshift ; UpdateState ( false , errval ) ; } if ( m_lRunIndex [ 0 ] > 0 ) m_lRunIndex [ 0 ] -- ; } else break ; } else { UWORD ctxt ; bool negative ; LONG px ; LONG rx ; LONG errval ; LONG merr ; UBYTE k ; for ( cx = 0 ; cx < m_ucCount ; cx ++ ) { d1 [ cx ] = QuantizedGradient ( d1 [ cx ] ) ; d2 [ cx ] = QuantizedGradient ( d2 [ cx ] ) ; d3 [ cx ] = QuantizedGradient ( d3 [ cx ] ) ; ctxt = Context ( negative , d1 [ cx ] , d2 [ cx ] , d3 [ cx ] ) ; px = Predict ( a [ cx ] , b [ cx ] , c [ cx ] ) ; px = CorrectPrediction ( ctxt , negative , px ) ; k = GolombParameter ( ctxt ) ; merr = GolombDecode ( k , m_lLimit ) ; errval = InverseErrorMapping ( merr , ErrorMappingOffset ( ctxt , k ) ) ; UpdateState ( ctxt , errval ) ; rx = Reconstruct ( negative , px , errval ) ; UpdateContext ( cx , rx ) ; * lp [ cx ] ++ = rx << preshift ; } } } while ( -- length ) ; } for ( cx = 0 ; cx < m_ucCount ; cx ++ ) { EndLine ( cx ) ; line [ cx ] = line [ cx ] -> m_pNext ; } } while ( -- lines ) ; m_Stream . SkipStuffing ( ) ; # endif return false ; }", "target": "<S2SV_ModStart> 8 ; } if ( lines == 0 ) return false ; <S2SV_ModStart> ] -= lines <S2SV_ModEnd> ; assert ("}
{"source": "CWE-703 bool SingleComponentLSScan : : ParseMCU ( void ) { # if ACCUSOFT_CODE int lines = m_ulRemaining [ 0 ] ; UBYTE preshift = m_ucLowBit + FractionalColorBitsOf ( ) ; struct Line * line = CurrentLine ( 0 ) ; if ( m_pFrame -> HeightOf ( ) == 0 ) { assert ( lines == 0 ) ; lines = 8 ; } assert ( m_ucCount == 1 ) ; if ( lines > 8 ) { lines = 8 ; } if ( m_pFrame -> HeightOf ( ) > 0 ) m_ulRemaining [ 0 ] -= lines ; <S2SV_StartBug> assert ( lines > 0 ) ; <S2SV_EndBug> do { LONG length = m_ulWidth [ 0 ] ; LONG * lp = line -> m_pData ; # ifdef DEBUG_LS int xpos = 0 ; static int linenumber = 0 ; printf ( \"\\\\n%4d<S2SV_blank>:<S2SV_blank>\" , ++ linenumber ) ; # endif StartLine ( 0 ) ; if ( BeginReadMCU ( m_Stream . ByteStreamOf ( ) ) ) { do { LONG a , b , c , d ; LONG d1 , d2 , d3 ; GetContext ( 0 , a , b , c , d ) ; d1 = d - b ; d2 = b - c ; d3 = c - a ; if ( isRunMode ( d1 , d2 , d3 ) ) { LONG run = DecodeRun ( length , m_lRunIndex [ 0 ] ) ; while ( run ) { UpdateContext ( 0 , a ) ; * lp ++ = a << preshift ; # ifdef DEBUG_LS printf ( \"%4d:<%2x><S2SV_blank>\" , xpos ++ , a ) ; # endif run -- , length -- ; } if ( length ) { bool negative ; bool rtype ; LONG errval ; LONG merr ; LONG rx ; UBYTE k ; GetContext ( 0 , a , b , c , d ) ; rtype = InterruptedPredictionMode ( negative , a , b ) ; k = GolombParameter ( rtype ) ; merr = GolombDecode ( k , m_lLimit - m_lJ [ m_lRunIndex [ 0 ] ] - 1 ) ; errval = InverseErrorMapping ( merr + rtype , ErrorMappingOffset ( rtype , rtype || merr , k ) ) ; rx = Reconstruct ( negative , rtype ? a : b , errval ) ; UpdateContext ( 0 , rx ) ; * lp = rx << preshift ; # ifdef DEBUG_LS printf ( \"%4d:<%2x><S2SV_blank>\" , xpos ++ , * lp ) ; # endif UpdateState ( rtype , errval ) ; if ( m_lRunIndex [ 0 ] > 0 ) m_lRunIndex [ 0 ] -- ; } else break ; } else { UWORD ctxt ; bool negative ; LONG px ; LONG rx ; LONG errval ; LONG merr ; UBYTE k ; d1 = QuantizedGradient ( d1 ) ; d2 = QuantizedGradient ( d2 ) ; d3 = QuantizedGradient ( d3 ) ; ctxt = Context ( negative , d1 , d2 , d3 ) ; px = Predict ( a , b , c ) ; px = CorrectPrediction ( ctxt , negative , px ) ; k = GolombParameter ( ctxt ) ; merr = GolombDecode ( k , m_lLimit ) ; errval = InverseErrorMapping ( merr , ErrorMappingOffset ( ctxt , k ) ) ; UpdateState ( ctxt , errval ) ; rx = Reconstruct ( negative , px , errval ) ; UpdateContext ( 0 , rx ) ; * lp = rx << preshift ; # ifdef DEBUG_LS printf ( \"%4d:<%2x><S2SV_blank>\" , xpos ++ , * lp ) ; # endif } } while ( ++ lp , -- length ) ; } EndLine ( 0 ) ; line = line -> m_pNext ; } while ( -- lines ) ; m_Stream . SkipStuffing ( ) ; # endif return false ; }", "target": "<S2SV_ModStart> -= lines ; if ( lines == 0 ) return false <S2SV_ModEnd> ; do {"}
{"source": "CWE-476 static GF_Err gf_isom_parse_movie_boxes_internal ( GF_ISOFile * mov , u32 * boxType , u64 * bytesMissing , Bool progressive_mode ) { GF_Box * a ; u64 totSize , mdat_end = 0 ; GF_Err e = GF_OK ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( mov -> single_moof_mode && mov -> single_moof_state == 2 ) { return e ; } totSize = mov -> current_top_box_start ; if ( mov -> bytes_removed ) { assert ( totSize >= mov -> bytes_removed ) ; totSize -= mov -> bytes_removed ; } gf_bs_seek ( mov -> movieFileMap -> bs , totSize ) ; # endif while ( gf_bs_available ( mov -> movieFileMap -> bs ) ) { * bytesMissing = 0 ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS mov -> current_top_box_start = gf_bs_get_position ( mov -> movieFileMap -> bs ) + mov -> bytes_removed ; GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Parsing<S2SV_blank>a<S2SV_blank>top-level<S2SV_blank>box<S2SV_blank>at<S2SV_blank>position<S2SV_blank>%d\\\\n\" , mov -> current_top_box_start ) ) ; # endif e = gf_isom_parse_root_box ( & a , mov -> movieFileMap -> bs , boxType , bytesMissing , progressive_mode ) ; if ( e >= 0 ) { <S2SV_StartBug> <S2SV_EndBug> } else if ( e == GF_ISOM_INCOMPLETE_FILE ) { if ( mov -> openMode != GF_ISOM_OPEN_READ ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Incomplete<S2SV_blank>MDAT<S2SV_blank>while<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>read-only\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( ( mov -> openMode == GF_ISOM_OPEN_READ ) && ! progressive_mode ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Incomplete<S2SV_blank>file<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>for<S2SV_blank>dump<S2SV_blank>-<S2SV_blank>aborting<S2SV_blank>parsing\\\\n\" ) ) ; break ; } return e ; } else { return e ; } switch ( a -> type ) { case GF_ISOM_BOX_TYPE_MOOV : if ( mov -> moov ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>MOOV<S2SV_blank>detected!\\\\n\" ) ) ; gf_isom_box_del ( a ) ; return GF_ISOM_INVALID_FILE ; } mov -> moov = ( GF_MovieBox * ) a ; mov -> original_moov_offset = mov -> current_top_box_start ; mov -> moov -> mov = mov ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( mov -> moov -> mvex ) mov -> moov -> mvex -> mov = mov ; # ifdef GF_ENABLE_CTRN if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { gf_isom_setup_traf_inheritance ( mov ) ; } # endif # endif e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; totSize += a -> size ; if ( ! mov -> moov -> mvhd ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>MovieHeaderBox\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( mov -> meta ) { gf_isom_meta_restore_items_ref ( mov , mov -> meta ) ; } if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { u32 k ; for ( k = 0 ; k < gf_list_count ( mov -> moov -> trackList ) ; k ++ ) { GF_TrackBox * trak = ( GF_TrackBox * ) gf_list_get ( mov -> moov -> trackList , k ) ; if ( trak -> sample_encryption ) { e = senc_Parse ( mov -> movieFileMap -> bs , trak , NULL , trak -> sample_encryption ) ; if ( e ) return e ; } } } else { u32 k ; for ( k = 0 ; k < gf_list_count ( mov -> moov -> trackList ) ; k ++ ) { GF_TrackBox * trak = ( GF_TrackBox * ) gf_list_get ( mov -> moov -> trackList , k ) ; if ( trak -> Media -> information -> sampleTable -> sampleGroups ) { convert_compact_sample_groups ( trak -> Media -> information -> sampleTable -> child_boxes , trak -> Media -> information -> sampleTable -> sampleGroups ) ; } } } if ( mdat_end && mov -> signal_frag_bounds && ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { gf_isom_push_mdat_end ( mov , mdat_end ) ; mdat_end = 0 ; } break ; case GF_ISOM_BOX_TYPE_META : if ( mov -> meta ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>META<S2SV_blank>detected!\\\\n\" ) ) ; gf_isom_box_del ( a ) ; return GF_ISOM_INVALID_FILE ; } mov -> meta = ( GF_MetaBox * ) a ; mov -> original_meta_offset = mov -> current_top_box_start ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) { return e ; } totSize += a -> size ; gf_isom_meta_restore_items_ref ( mov , mov -> meta ) ; break ; case GF_ISOM_BOX_TYPE_MDAT : if ( ! mov -> first_data_toplevel_offset ) { mov -> first_data_toplevel_offset = mov -> current_top_box_start ; mov -> first_data_toplevel_size = a -> size ; } totSize += a -> size ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( mov -> emsgs ) { gf_isom_box_array_del ( mov -> emsgs ) ; mov -> emsgs = NULL ; } # endif if ( mov -> openMode == GF_ISOM_OPEN_READ ) { if ( ! mov -> mdat ) { mov -> mdat = ( GF_MediaDataBox * ) a ; e = gf_list_add ( mov -> TopBoxes , mov -> mdat ) ; if ( e ) { return e ; } } # ifndef GPAC_DISABLE_ISOM_FRAGMENTS else if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) gf_list_add ( mov -> TopBoxes , a ) ; # endif else gf_isom_box_del ( a ) ; if ( mov -> signal_frag_bounds && ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { mdat_end = gf_bs_get_position ( mov -> movieFileMap -> bs ) ; if ( mov -> moov ) { gf_isom_push_mdat_end ( mov , mdat_end ) ; mdat_end = 0 ; } } } else if ( ! mov -> mdat && ( mov -> openMode != GF_ISOM_OPEN_READ ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) ) { gf_isom_box_del ( a ) ; mov -> mdat = ( GF_MediaDataBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_MDAT ) ; if ( ! mov -> mdat ) return GF_OUT_OF_MEM ; e = gf_list_add ( mov -> TopBoxes , mov -> mdat ) ; if ( e ) { return e ; } } else { gf_isom_box_del ( a ) ; } break ; case GF_ISOM_BOX_TYPE_FTYP : if ( mov -> brand ) { gf_isom_box_del ( a ) ; GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>\\'ftyp\\'<S2SV_blank>detected!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } mov -> brand = ( GF_FileTypeBox * ) a ; totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; break ; case GF_ISOM_BOX_TYPE_OTYP : if ( mov -> otyp ) { gf_isom_box_del ( a ) ; GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>\\'otyp\\'<S2SV_blank>detected!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { mov -> otyp = ( GF_Box * ) a ; totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; } else { GF_FileTypeBox * brand = ( GF_FileTypeBox * ) gf_isom_box_find_child ( a -> child_boxes , GF_ISOM_BOX_TYPE_FTYP ) ; if ( brand ) { s32 pos ; gf_list_del_item ( a -> child_boxes , brand ) ; pos = gf_list_del_item ( mov -> TopBoxes , mov -> brand ) ; gf_isom_box_del ( ( GF_Box * ) mov -> brand ) ; mov -> brand = brand ; if ( pos < 0 ) pos = 0 ; gf_list_insert ( mov -> TopBoxes , brand , pos ) ; } gf_isom_box_del ( a ) ; } break ; case GF_ISOM_BOX_TYPE_PDIN : if ( mov -> pdin ) { gf_isom_box_del ( a ) ; GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Duplicate<S2SV_blank>\\'pdin\\'\\'<S2SV_blank>detected!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } mov -> pdin = ( GF_ProgressiveDownloadBox * ) a ; totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; break ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS case GF_ISOM_BOX_TYPE_STYP : { u32 brand = ( ( GF_FileTypeBox * ) a ) -> majorBrand ; switch ( brand ) { case GF_ISOM_BRAND_SISX : case GF_ISOM_BRAND_RISX : case GF_ISOM_BRAND_SSSS : mov -> is_index_segment = GF_TRUE ; break ; default : break ; } } case GF_ISOM_BOX_TYPE_SIDX : case GF_ISOM_BOX_TYPE_SSIX : if ( mov -> moov && ! mov -> first_data_toplevel_offset ) { mov -> first_data_toplevel_offset = mov -> current_top_box_start ; mov -> first_data_toplevel_size = a -> size ; } totSize += a -> size ; if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; } else if ( mov -> signal_frag_bounds && ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) ) { if ( a -> type == GF_ISOM_BOX_TYPE_SIDX ) { if ( mov -> root_sidx ) gf_isom_box_del ( ( GF_Box * ) mov -> root_sidx ) ; mov -> root_sidx = ( GF_SegmentIndexBox * ) a ; mov -> sidx_start_offset = mov -> current_top_box_start ; mov -> sidx_end_offset = gf_bs_get_position ( mov -> movieFileMap -> bs ) ; } else if ( a -> type == GF_ISOM_BOX_TYPE_STYP ) { mov -> styp_start_offset = mov -> current_top_box_start ; if ( mov -> seg_styp ) gf_isom_box_del ( mov -> seg_styp ) ; mov -> seg_styp = a ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SSIX ) { if ( mov -> seg_ssix ) gf_isom_box_del ( mov -> seg_ssix ) ; mov -> seg_ssix = a ; } else { gf_isom_box_del ( a ) ; } gf_isom_push_mdat_end ( mov , mov -> current_top_box_start ) ; } else if ( ! mov -> NextMoofNumber && ( a -> type == GF_ISOM_BOX_TYPE_SIDX ) ) { if ( mov -> main_sidx ) gf_isom_box_del ( ( GF_Box * ) mov -> main_sidx ) ; mov -> main_sidx = ( GF_SegmentIndexBox * ) a ; mov -> main_sidx_end_pos = mov -> current_top_box_start + a -> size ; } else { gf_isom_box_del ( a ) ; } break ; case GF_ISOM_BOX_TYPE_MOOF : gf_isom_disable_inplace_rewrite ( mov ) ; if ( ! mov -> moov ) { GF_LOG ( mov -> moof ? GF_LOG_DEBUG : GF_LOG_WARNING , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Movie<S2SV_blank>fragment<S2SV_blank>but<S2SV_blank>no<S2SV_blank>moov<S2SV_blank>(yet)<S2SV_blank>-<S2SV_blank>possibly<S2SV_blank>broken<S2SV_blank>parsing!\\\\n\" ) ) ; } if ( mov -> single_moof_mode ) { mov -> single_moof_state ++ ; if ( mov -> single_moof_state > 1 ) { gf_isom_box_del ( a ) ; return GF_OK ; } } ( ( GF_MovieFragmentBox * ) a ) -> mov = mov ; totSize += a -> size ; mov -> moof = ( GF_MovieFragmentBox * ) a ; FixTrackID ( mov ) ; if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { FixSDTPInTRAF ( mov -> moof ) ; } else { u32 k ; for ( k = 0 ; k < gf_list_count ( mov -> moof -> TrackList ) ; k ++ ) { GF_TrackFragmentBox * traf = ( GF_TrackFragmentBox * ) gf_list_get ( mov -> moof -> TrackList , k ) ; if ( traf -> sampleGroups ) { convert_compact_sample_groups ( traf -> child_boxes , traf -> sampleGroups ) ; } } } if ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) { u32 k ; gf_list_add ( mov -> TopBoxes , a ) ; if ( mov -> moov ) { for ( k = 0 ; k < gf_list_count ( mov -> moof -> TrackList ) ; k ++ ) { GF_TrackFragmentBox * traf = gf_list_get ( mov -> moof -> TrackList , k ) ; if ( traf -> tfhd && mov -> moov -> mvex && mov -> moov -> mvex -> TrackExList ) { GF_TrackBox * trak = gf_isom_get_track_from_id ( mov -> moov , traf -> tfhd -> trackID ) ; u32 j = 0 ; while ( ( traf -> trex = ( GF_TrackExtendsBox * ) gf_list_enum ( mov -> moov -> mvex -> TrackExList , & j ) ) ) { if ( traf -> trex -> trackID == traf -> tfhd -> trackID ) { if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; break ; } traf -> trex = NULL ; } } if ( traf -> trex && traf -> tfhd && traf -> trex -> track && traf -> sample_encryption ) { GF_TrackBox * trak = GetTrackbyID ( mov -> moov , traf -> tfhd -> trackID ) ; if ( trak ) { trak -> current_traf_stsd_idx = traf -> tfhd -> sample_desc_index ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; e = senc_Parse ( mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; if ( e ) return e ; trak -> current_traf_stsd_idx = 0 ; } } } } else { for ( k = 0 ; k < gf_list_count ( mov -> moof -> TrackList ) ; k ++ ) { GF_TrackFragmentBox * traf = gf_list_get ( mov -> moof -> TrackList , k ) ; if ( traf -> sample_encryption ) { e = senc_Parse ( mov -> movieFileMap -> bs , NULL , traf , traf -> sample_encryption ) ; if ( e ) return e ; } } } } else if ( mov -> openMode == GF_ISOM_OPEN_KEEP_FRAGMENTS ) { mov -> NextMoofNumber = mov -> moof -> mfhd -> sequence_number + 1 ; mov -> moof = NULL ; gf_isom_box_del ( a ) ; } else { e = MergeFragment ( ( GF_MovieFragmentBox * ) a , mov ) ; gf_isom_box_del ( a ) ; if ( e ) return e ; } if ( mov -> root_sidx ) { gf_isom_box_del ( ( GF_Box * ) mov -> root_sidx ) ; mov -> root_sidx = NULL ; } if ( mov -> root_ssix ) { gf_isom_box_del ( mov -> seg_ssix ) ; mov -> root_ssix = NULL ; } if ( mov -> seg_styp ) { gf_isom_box_del ( mov -> seg_styp ) ; mov -> seg_styp = NULL ; } mov -> sidx_start_offset = 0 ; mov -> sidx_end_offset = 0 ; mov -> styp_start_offset = 0 ; break ; # endif case GF_ISOM_BOX_TYPE_UNKNOWN : { GF_UnknownBox * box = ( GF_UnknownBox * ) a ; if ( box -> original_4cc == GF_ISOM_BOX_TYPE_JP ) { u8 * c = ( u8 * ) box -> data ; if ( ( box -> dataSize == 4 ) && ( GF_4CC ( c [ 0 ] , c [ 1 ] , c [ 2 ] , c [ 3 ] ) == ( u32 ) 0x0D0A870A ) ) mov -> is_jp2 = 1 ; gf_isom_box_del ( a ) ; } else { e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; } } break ; case GF_ISOM_BOX_TYPE_PRFT : # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { if ( mov -> last_producer_ref_time ) gf_isom_box_del ( a ) ; else mov -> last_producer_ref_time = ( GF_ProducerReferenceTimeBox * ) a ; break ; } # endif case GF_ISOM_BOX_TYPE_EMSG : # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { if ( ! mov -> emsgs ) mov -> emsgs = gf_list_new ( ) ; gf_list_add ( mov -> emsgs , a ) ; break ; } # endif case GF_ISOM_BOX_TYPE_MFRA : case GF_ISOM_BOX_TYPE_MFRO : if ( ! ( mov -> FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG ) ) { totSize += a -> size ; gf_isom_box_del ( a ) ; break ; } default : totSize += a -> size ; e = gf_list_add ( mov -> TopBoxes , a ) ; if ( e ) return e ; break ; } # ifndef GPAC_DISABLE_ISOM_FRAGMENTS mov -> current_top_box_start = gf_bs_get_position ( mov -> movieFileMap -> bs ) + mov -> bytes_removed ; # endif } if ( ! mov -> moov && ! mov -> meta # ifndef GPAC_DISABLE_ISOM_FRAGMENTS && ! mov -> moof && ! mov -> is_index_segment # endif ) { return GF_ISOM_INCOMPLETE_FILE ; } if ( ! gf_opts_get_bool ( \"core\" , \"no-check\" ) ) { if ( mov -> moov && ! mov -> moov -> mvhd ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>MVHD<S2SV_blank>in<S2SV_blank>MOOV!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } if ( mov -> meta && ! mov -> meta -> handler ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>handler<S2SV_blank>in<S2SV_blank>META!\\\\n\" ) ) ; return GF_ISOM_INVALID_FILE ; } } # ifndef GPAC_DISABLE_ISOM_WRITE if ( mov -> moov ) { mov -> interleavingTime = mov -> moov -> mvhd -> timeScale ; # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( ( mov -> openMode > GF_ISOM_OPEN_READ ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) && mov -> moov -> mvex ) { gf_isom_box_del_parent ( & mov -> moov -> child_boxes , ( GF_Box * ) mov -> moov -> mvex ) ; mov -> moov -> mvex = NULL ; } # endif } if ( ! mov -> mdat && ( mov -> openMode != GF_ISOM_OPEN_READ ) && ( mov -> openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS ) ) { mov -> mdat = ( GF_MediaDataBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_MDAT ) ; if ( ! mov -> mdat ) return GF_OUT_OF_MEM ; e = gf_list_add ( mov -> TopBoxes , mov -> mdat ) ; if ( e ) return e ; } # endif return GF_OK ; }", "target": "<S2SV_ModStart> 0 ) { if ( ! a ) return GF_ISOM_INVALID_FILE ;"}
{"source": "CWE-476 void MakeDataset ( OpKernelContext * ctx , DatasetBase * * output ) override { const Tensor * indices ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"indices\" , & indices ) ) ; const Tensor * values ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"values\" , & values ) ) ; const Tensor * dense_shape ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"dense_shape\" , & dense_shape ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( indices -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , <S2SV_StartBug> indices -> shape ( ) . DebugString ( ) ) ) ; <S2SV_EndBug> OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( values -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , indices -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsVector ( dense_shape -> shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , dense_shape -> shape ( ) . DebugString ( ) ) ) ; int64_t previous_batch_index = - 1 ; for ( int64_t i = 0 ; i < indices -> dim_size ( 0 ) ; ++ i ) { int64_t next_batch_index = indices -> matrix < int64 > ( ) ( i , 0 ) ; OP_REQUIRES ( ctx , next_batch_index >= previous_batch_index , errors : : Unimplemented ( \"The<S2SV_blank>SparseTensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>ordered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>batch<S2SV_blank>\" \"dimension;<S2SV_blank>handling<S2SV_blank>arbitrarily<S2SV_blank>ordered<S2SV_blank>input<S2SV_blank>\" \"is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\" ) ) ; previous_batch_index = next_batch_index ; } gtl : : InlinedVector < int64 , 8 > std_order ( dense_shape -> NumElements ( ) , 0 ) ; sparse : : SparseTensor tensor ; OP_REQUIRES_OK ( ctx , sparse : : SparseTensor : : Create ( * indices , * values , TensorShape ( dense_shape -> vec < int64 > ( ) ) , std_order , & tensor ) ) ; * output = new Dataset < T > ( ctx , std : : move ( tensor ) ) ; }", "target": "<S2SV_ModStart> ) ) ; const auto num_indices = indices -> NumElements ( ) ; const auto num_values = values -> NumElements ( ) ; if ( num_indices == 0 || num_values == 0 ) { OP_REQUIRES ( ctx , num_indices == num_values , errors : : InvalidArgument ( \"If<S2SV_blank>indices<S2SV_blank>or<S2SV_blank>values<S2SV_blank>are<S2SV_blank>empty,<S2SV_blank>the<S2SV_blank>other<S2SV_blank>one<S2SV_blank>must<S2SV_blank>also<S2SV_blank>\" \"be.<S2SV_blank>Got<S2SV_blank>indices<S2SV_blank>of<S2SV_blank>shape<S2SV_blank>\" , indices -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>values<S2SV_blank>of<S2SV_blank>shape<S2SV_blank>\" , values -> shape ( ) . DebugString ( ) ) ) ; }"}
{"source": "CWE-703 void Compute ( OpKernelContext * context ) override { const Tensor * epsilon_t ; OP_REQUIRES_OK ( context , context -> input ( kEpsilonName , & epsilon_t ) ) ; float epsilon = epsilon_t -> scalar < float > ( ) ( ) ; OP_REQUIRES ( context , epsilon > 0 , errors : : InvalidArgument ( \"An<S2SV_blank>epsilon<S2SV_blank>value<S2SV_blank>of<S2SV_blank>zero<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed.\" ) ) ; const Tensor * num_streams_t ; OP_REQUIRES_OK ( context , context -> input ( kNumStreamsName , & num_streams_t ) ) ; int64_t num_streams = num_streams_t -> scalar < int64 > ( ) ( ) ; <S2SV_StartBug> <S2SV_EndBug> auto result = new QuantileStreamResource ( epsilon , max_elements_ , num_streams ) ; auto status = CreateResource ( context , HandleFromInput ( context , 0 ) , result ) ; if ( ! status . ok ( ) && status . code ( ) != tensorflow : : error : : ALREADY_EXISTS ) { OP_REQUIRES ( context , false , status ) ; } }", "target": "<S2SV_ModStart> ( ) ; OP_REQUIRES ( context , num_streams >= 0 , errors : : InvalidArgument ( \"Num_streams<S2SV_blank>input<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>integer\" ) ) ;"}
{"source": "CWE-369 void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , \"additional<S2SV_blank>PixMap<S2SV_blank>header<S2SV_blank>fields,<S2SV_blank>at<S2SV_blank>%d\" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , \"pixmap<S2SV_blank>version:<S2SV_blank>%d\" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , \"packing<S2SV_blank>type:<S2SV_blank>%d\" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , \"pixel<S2SV_blank>data<S2SV_blank>length:<S2SV_blank>%d\" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , \"dpi:<S2SV_blank>%.2f\" DE_CHAR_TIMES \"%.2f\" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , \"pixel<S2SV_blank>type=%d,<S2SV_blank>bits/pixel=%d,<S2SV_blank>components/pixel=%d,<S2SV_blank>bits/comp=%d\" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ; <S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug> bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , \"plane<S2SV_blank>bytes:<S2SV_blank>%d\" , ( int ) plane_bytes ) ; bi -> pmTable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , \"pmTable:<S2SV_blank>0x%08x\" , ( unsigned int ) bi -> pmTable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , \"pmReserved:<S2SV_blank>0x%08x\" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }", "target": "<S2SV_ModStart> cmpsize ) ; if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> -> pixelsize ; }"}
{"source": "CWE-476 * / static void php_wddx_pop_element ( void * user_data , const XML_Char * name ) { st_entry * ent1 , * ent2 ; wddx_stack * stack = ( wddx_stack * ) user_data ; HashTable * target_hash ; zend_class_entry * pce ; zval obj ; if ( stack -> top == 0 ) { return ; } if ( ! strcmp ( ( char * ) name , EL_STRING ) || ! strcmp ( ( char * ) name , EL_NUMBER ) || ! strcmp ( ( char * ) name , EL_BOOLEAN ) || ! strcmp ( ( char * ) name , EL_NULL ) || ! strcmp ( ( char * ) name , EL_ARRAY ) || ! strcmp ( ( char * ) name , EL_STRUCT ) || ! strcmp ( ( char * ) name , EL_RECORDSET ) || ! strcmp ( ( char * ) name , EL_BINARY ) || ! strcmp ( ( char * ) name , EL_DATETIME ) ) { wddx_stack_top ( stack , ( void * * ) & ent1 ) ; if ( Z_TYPE ( ent1 -> data ) == IS_UNDEF ) { if ( stack -> top > 1 ) { stack -> top -- ; <S2SV_StartBug> } else { <S2SV_EndBug> stack -> done = 1 ; } <S2SV_StartBug> efree ( ent1 ) ; <S2SV_EndBug> return ; } if ( ! strcmp ( ( char * ) name , EL_BINARY ) ) { zend_string * new_str = php_base64_decode ( ( unsigned char * ) Z_STRVAL ( ent1 -> data ) , Z_STRLEN ( ent1 -> data ) ) ; zval_ptr_dtor ( & ent1 -> data ) ; ZVAL_STR ( & ent1 -> data , new_str ) ; } if ( Z_TYPE ( ent1 -> data ) == IS_OBJECT ) { zval fname , retval ; ZVAL_STRING ( & fname , \"__wakeup\" ) ; call_user_function_ex ( NULL , & ent1 -> data , & fname , & retval , 0 , 0 , 0 , NULL ) ; zval_ptr_dtor ( & fname ) ; zval_ptr_dtor ( & retval ) ; } if ( stack -> top > 1 ) { stack -> top -- ; wddx_stack_top ( stack , ( void * * ) & ent2 ) ; if ( ent2 -> type == ST_FIELD && Z_ISUNDEF ( ent2 -> data ) ) { zval_ptr_dtor ( & ent1 -> data ) ; efree ( ent1 ) ; return ; } if ( Z_TYPE ( ent2 -> data ) == IS_ARRAY || Z_TYPE ( ent2 -> data ) == IS_OBJECT ) { target_hash = HASH_OF ( & ent2 -> data ) ; if ( ent1 -> varname ) { if ( ! strcmp ( ent1 -> varname , PHP_CLASS_NAME_VAR ) && Z_TYPE ( ent1 -> data ) == IS_STRING && Z_STRLEN ( ent1 -> data ) && ent2 -> type == ST_STRUCT && Z_TYPE ( ent2 -> data ) == IS_ARRAY ) { zend_bool incomplete_class = 0 ; zend_str_tolower ( Z_STRVAL ( ent1 -> data ) , Z_STRLEN ( ent1 -> data ) ) ; zend_string_forget_hash_val ( Z_STR ( ent1 -> data ) ) ; if ( ( pce = zend_hash_find_ptr ( EG ( class_table ) , Z_STR ( ent1 -> data ) ) ) == NULL ) { incomplete_class = 1 ; pce = PHP_IC_ENTRY ; } object_init_ex ( & obj , pce ) ; zend_hash_merge ( Z_OBJPROP ( obj ) , Z_ARRVAL ( ent2 -> data ) , zval_add_ref , 0 ) ; if ( incomplete_class ) { php_store_class_name ( & obj , Z_STRVAL ( ent1 -> data ) , Z_STRLEN ( ent1 -> data ) ) ; } zval_ptr_dtor ( & ent2 -> data ) ; ZVAL_COPY_VALUE ( & ent2 -> data , & obj ) ; zval_ptr_dtor ( & ent1 -> data ) ; } else if ( Z_TYPE ( ent2 -> data ) == IS_OBJECT ) { zend_class_entry * old_scope = EG ( scope ) ; EG ( scope ) = Z_OBJCE ( ent2 -> data ) ; add_property_zval ( & ent2 -> data , ent1 -> varname , & ent1 -> data ) ; if Z_REFCOUNTED ( ent1 -> data ) Z_DELREF ( ent1 -> data ) ; EG ( scope ) = old_scope ; } else { zend_symtable_str_update ( target_hash , ent1 -> varname , strlen ( ent1 -> varname ) , & ent1 -> data ) ; } efree ( ent1 -> varname ) ; } else { zend_hash_next_index_insert ( target_hash , & ent1 -> data ) ; } } efree ( ent1 ) ; } else { stack -> done = 1 ; } } else if ( ! strcmp ( ( char * ) name , EL_VAR ) && stack -> varname ) { efree ( stack -> varname ) ; stack -> varname = NULL ; } else if ( ! strcmp ( ( char * ) name , EL_FIELD ) ) { st_entry * ent ; wddx_stack_top ( stack , ( void * * ) & ent ) ; efree ( ent ) ; stack -> top -- ; }", "target": "<S2SV_ModStart> top -- ; efree ( ent1 ) ; <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return ; }"}
{"source": "CWE-703 int btrfs_rm_device ( struct btrfs_fs_info * fs_info , const char * device_path , u64 devid ) { struct btrfs_device * device ; struct btrfs_fs_devices * cur_devices ; struct btrfs_fs_devices * fs_devices = fs_info -> fs_devices ; u64 num_devices ; int ret = 0 ; mutex_lock ( & uuid_mutex ) ; num_devices = btrfs_num_devices ( fs_info ) ; ret = btrfs_check_raid_min_devices ( fs_info , num_devices - 1 ) ; if ( ret ) goto out ; device = btrfs_find_device_by_devspec ( fs_info , devid , device_path ) ; if ( IS_ERR ( device ) ) { if ( PTR_ERR ( device ) == - ENOENT && <S2SV_StartBug> strcmp ( device_path , \"missing\" ) == 0 ) <S2SV_EndBug> ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND ; else ret = PTR_ERR ( device ) ; goto out ; } if ( btrfs_pinned_by_swapfile ( fs_info , device ) ) { btrfs_warn_in_rcu ( fs_info , \"cannot<S2SV_blank>remove<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>(devid<S2SV_blank>%llu)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>active<S2SV_blank>swapfile\" , rcu_str_deref ( device -> name ) , device -> devid ) ; ret = - ETXTBSY ; goto out ; } if ( test_bit ( BTRFS_DEV_STATE_REPLACE_TGT , & device -> dev_state ) ) { ret = BTRFS_ERROR_DEV_TGT_REPLACE ; goto out ; } if ( test_bit ( BTRFS_DEV_STATE_WRITEABLE , & device -> dev_state ) && fs_info -> fs_devices -> rw_devices == 1 ) { ret = BTRFS_ERROR_DEV_ONLY_WRITABLE ; goto out ; } if ( test_bit ( BTRFS_DEV_STATE_WRITEABLE , & device -> dev_state ) ) { mutex_lock ( & fs_info -> chunk_mutex ) ; list_del_init ( & device -> dev_alloc_list ) ; device -> fs_devices -> rw_devices -- ; mutex_unlock ( & fs_info -> chunk_mutex ) ; } mutex_unlock ( & uuid_mutex ) ; ret = btrfs_shrink_device ( device , 0 ) ; if ( ! ret ) btrfs_reada_remove_dev ( device ) ; mutex_lock ( & uuid_mutex ) ; if ( ret ) goto error_undo ; ret = btrfs_rm_dev_item ( device ) ; if ( ret ) goto error_undo ; clear_bit ( BTRFS_DEV_STATE_IN_FS_METADATA , & device -> dev_state ) ; btrfs_scrub_cancel_dev ( device ) ; cur_devices = device -> fs_devices ; mutex_lock ( & fs_devices -> device_list_mutex ) ; list_del_rcu ( & device -> dev_list ) ; cur_devices -> num_devices -- ; cur_devices -> total_devices -- ; if ( cur_devices != fs_devices ) fs_devices -> total_devices -- ; if ( test_bit ( BTRFS_DEV_STATE_MISSING , & device -> dev_state ) ) cur_devices -> missing_devices -- ; btrfs_assign_next_active_device ( device , NULL ) ; if ( device -> bdev ) { cur_devices -> open_devices -- ; btrfs_sysfs_remove_device ( device ) ; } num_devices = btrfs_super_num_devices ( fs_info -> super_copy ) - 1 ; btrfs_set_super_num_devices ( fs_info -> super_copy , num_devices ) ; mutex_unlock ( & fs_devices -> device_list_mutex ) ; if ( test_bit ( BTRFS_DEV_STATE_WRITEABLE , & device -> dev_state ) ) btrfs_scratch_superblocks ( fs_info , device -> bdev , device -> name -> str ) ; btrfs_close_bdev ( device ) ; synchronize_rcu ( ) ; btrfs_free_device ( device ) ; if ( cur_devices -> open_devices == 0 ) { list_del_init ( & cur_devices -> seed_list ) ; close_fs_devices ( cur_devices ) ; free_fs_devices ( cur_devices ) ; } out : mutex_unlock ( & uuid_mutex ) ; return ret ; error_undo : btrfs_reada_undo_remove_dev ( device ) ; if ( test_bit ( BTRFS_DEV_STATE_WRITEABLE , & device -> dev_state ) ) { mutex_lock ( & fs_info -> chunk_mutex ) ; list_add ( & device -> dev_alloc_list , & fs_devices -> alloc_list ) ; device -> fs_devices -> rw_devices ++ ; mutex_unlock ( & fs_info -> chunk_mutex ) ; } goto out ; }", "target": "<S2SV_ModStart> - ENOENT && device_path &&"}
{"source": "CWE-125 static Image * ReadOneMNGImage ( MngInfo * mng_info , const ImageInfo * image_info , ExceptionInfo * exception ) { char page_geometry [ MagickPathExtent ] ; Image * image ; MagickBooleanType logging ; volatile int first_mng_object , object_id , term_chunk_found , skip_to_iend ; volatile ssize_t image_count = 0 ; MagickBooleanType status ; MagickOffsetType offset ; MngBox default_fb , fb , previous_fb ; # if defined ( MNG_INSERT_LAYERS ) PixelInfo mng_background_color ; # endif register unsigned char * p ; register ssize_t i ; size_t count ; ssize_t loop_level ; volatile short skipping_loop ; # if defined ( MNG_INSERT_LAYERS ) unsigned int mandatory_back = 0 ; # endif volatile unsigned int # ifdef MNG_OBJECT_BUFFERS mng_background_object = 0 , # endif mng_type = 0 ; size_t default_frame_timeout , frame_timeout , # if defined ( MNG_INSERT_LAYERS ) image_height , image_width , # endif length ; volatile size_t default_frame_delay , final_delay , final_image_delay , frame_delay , # if defined ( MNG_INSERT_LAYERS ) insert_layers , # endif mng_iterations = 1 , simplicity = 0 , subframe_height = 0 , subframe_width = 0 ; previous_fb . top = 0 ; previous_fb . bottom = 0 ; previous_fb . left = 0 ; previous_fb . right = 0 ; default_fb . top = 0 ; default_fb . bottom = 0 ; default_fb . left = 0 ; default_fb . right = 0 ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Enter<S2SV_blank>ReadOneMNGImage()\" ) ; image = mng_info -> image ; if ( LocaleCompare ( image_info -> magick , \"MNG\" ) == 0 ) { char magic_number [ MagickPathExtent ] ; count = ( size_t ) ReadBlob ( image , 8 , ( unsigned char * ) magic_number ) ; if ( memcmp ( magic_number , \"\\\\212MNG\\\\r\\\\n\\\\032\\\\n\" , 8 ) != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; for ( i = 0 ; i < MNG_MAX_OBJECTS ; i ++ ) { mng_info -> object_clip [ i ] . right = ( ssize_t ) PNG_UINT_31_MAX ; mng_info -> object_clip [ i ] . bottom = ( ssize_t ) PNG_UINT_31_MAX ; } mng_info -> exists [ 0 ] = MagickTrue ; } skipping_loop = ( - 1 ) ; first_mng_object = MagickTrue ; mng_type = 0 ; # if defined ( MNG_INSERT_LAYERS ) insert_layers = MagickFalse ; # endif default_frame_delay = 0 ; default_frame_timeout = 0 ; frame_delay = 0 ; final_delay = 1 ; mng_info -> ticks_per_second = 1UL * image -> ticks_per_second ; object_id = 0 ; skip_to_iend = MagickFalse ; term_chunk_found = MagickFalse ; mng_info -> framing_mode = 1 ; # if defined ( MNG_INSERT_LAYERS ) mandatory_back = MagickFalse ; # endif # if defined ( MNG_INSERT_LAYERS ) mng_background_color = image -> background_color ; # endif default_fb = mng_info -> frame ; previous_fb = mng_info -> frame ; do { char type [ MagickPathExtent ] ; if ( LocaleCompare ( image_info -> magick , \"MNG\" ) == 0 ) { unsigned char * chunk ; type [ 0 ] = '\\\\0' ; ( void ) ConcatenateMagickString ( type , \"errr\" , MagickPathExtent ) ; length = ReadBlobMSBLong ( image ) ; count = ( size_t ) ReadBlob ( image , 4 , ( unsigned char * ) type ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Reading<S2SV_blank>MNG<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>%c%c%c%c,<S2SV_blank>length:<S2SV_blank>%.20g\" , type [ 0 ] , type [ 1 ] , type [ 2 ] , type [ 3 ] , ( double ) length ) ; if ( length > PNG_UINT_31_MAX ) { status = MagickFalse ; break ; } if ( count == 0 ) ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; p = NULL ; chunk = ( unsigned char * ) NULL ; if ( length != 0 ) { if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; chunk = ( unsigned char * ) AcquireQuantumMemory ( length + MagickPathExtent , sizeof ( * chunk ) ) ; if ( chunk == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; chunk [ i ] = ( unsigned char ) c ; } p = chunk ; } ( void ) ReadBlobMSBLong ( image ) ; # if ! defined ( JNG_SUPPORTED ) if ( memcmp ( type , mng_JHDR , 4 ) == 0 ) { skip_to_iend = MagickTrue ; if ( mng_info -> jhdr_warning == 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"JNGCompressNotSupported\" , \"`%s\\'\" , image -> filename ) ; mng_info -> jhdr_warning ++ ; } # endif if ( memcmp ( type , mng_DHDR , 4 ) == 0 ) { skip_to_iend = MagickTrue ; if ( mng_info -> dhdr_warning == 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"DeltaPNGNotSupported\" , \"`%s\\'\" , image -> filename ) ; mng_info -> dhdr_warning ++ ; } if ( memcmp ( type , mng_MEND , 4 ) == 0 ) break ; if ( skip_to_iend ) { if ( memcmp ( type , mng_IEND , 4 ) == 0 ) skip_to_iend = MagickFalse ; if ( length != 0 ) chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Skip<S2SV_blank>to<S2SV_blank>IEND.\" ) ; continue ; } if ( memcmp ( type , mng_MHDR , 4 ) == 0 ) { if ( length != 28 ) { chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } mng_info -> mng_width = ( size_t ) ( ( p [ 0 ] << 24 ) | ( p [ 1 ] << 16 ) | ( p [ 2 ] << 8 ) | p [ 3 ] ) ; mng_info -> mng_height = ( size_t ) ( ( p [ 4 ] << 24 ) | ( p [ 5 ] << 16 ) | ( p [ 6 ] << 8 ) | p [ 7 ] ) ; if ( logging != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MNG<S2SV_blank>width:<S2SV_blank>%.20g\" , ( double ) mng_info -> mng_width ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MNG<S2SV_blank>height:<S2SV_blank>%.20g\" , ( double ) mng_info -> mng_height ) ; } p += 8 ; mng_info -> ticks_per_second = ( size_t ) mng_get_long ( p ) ; if ( mng_info -> ticks_per_second == 0 ) default_frame_delay = 0 ; else default_frame_delay = 1UL * image -> ticks_per_second / mng_info -> ticks_per_second ; frame_delay = default_frame_delay ; simplicity = 0 ; p += 16 ; simplicity = ( size_t ) mng_get_long ( p ) ; mng_type = 1 ; if ( ( simplicity != 0 ) && ( ( simplicity | 11 ) == 11 ) ) mng_type = 2 ; if ( ( simplicity != 0 ) && ( ( simplicity | 9 ) == 9 ) ) mng_type = 3 ; # if defined ( MNG_INSERT_LAYERS ) if ( mng_type != 3 ) insert_layers = MagickTrue ; # endif if ( GetAuthenticPixelQueue ( image ) != ( Quantum * ) NULL ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( ( Image * ) NULL ) ; image = SyncNextImageInList ( image ) ; mng_info -> image = image ; } if ( ( mng_info -> mng_width > 65535L ) || ( mng_info -> mng_height > 65535L ) ) { chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; ThrowReaderException ( ImageError , \"WidthOrHeightExceedsLimit\" ) ; } ( void ) FormatLocaleString ( page_geometry , MagickPathExtent , \"%.20gx%.20g+0+0\" , ( double ) mng_info -> mng_width , ( double ) mng_info -> mng_height ) ; mng_info -> frame . left = 0 ; mng_info -> frame . right = ( ssize_t ) mng_info -> mng_width ; mng_info -> frame . top = 0 ; mng_info -> frame . bottom = ( ssize_t ) mng_info -> mng_height ; mng_info -> clip = default_fb = previous_fb = mng_info -> frame ; for ( i = 0 ; i < MNG_MAX_OBJECTS ; i ++ ) mng_info -> object_clip [ i ] = mng_info -> frame ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_TERM , 4 ) == 0 ) { int repeat = 0 ; if ( length != 0 ) repeat = p [ 0 ] ; if ( repeat == 3 ) { final_delay = ( png_uint_32 ) mng_get_long ( & p [ 2 ] ) ; mng_iterations = ( png_uint_32 ) mng_get_long ( & p [ 6 ] ) ; if ( mng_iterations == PNG_UINT_31_MAX ) mng_iterations = 0 ; image -> iterations = mng_iterations ; term_chunk_found = MagickTrue ; } if ( logging != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>repeat=%d,<S2SV_blank><S2SV_blank>final_delay=%.20g,<S2SV_blank><S2SV_blank>iterations=%.20g\" , repeat , ( double ) final_delay , ( double ) image -> iterations ) ; } chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_DEFI , 4 ) == 0 ) { if ( mng_type == 3 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"DEFI<S2SV_blank>chunk<S2SV_blank>found<S2SV_blank>in<S2SV_blank>MNG-VLC<S2SV_blank>datastream\" , \"`%s\\'\" , image -> filename ) ; if ( length < 2 ) { if ( chunk ) chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ; } object_id = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( mng_type == 2 && object_id != 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"Nonzero<S2SV_blank>object_id<S2SV_blank>in<S2SV_blank>MNG-LC<S2SV_blank>datastream\" , \"`%s\\'\" , image -> filename ) ; if ( object_id > MNG_MAX_OBJECTS ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"object<S2SV_blank>id<S2SV_blank>too<S2SV_blank>large\" , \"`%s\\'\" , image -> filename ) ; object_id = MNG_MAX_OBJECTS ; } if ( mng_info -> exists [ object_id ] ) if ( mng_info -> frozen [ object_id ] ) { chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"DEFI<S2SV_blank>cannot<S2SV_blank>redefine<S2SV_blank>a<S2SV_blank>frozen<S2SV_blank>MNG<S2SV_blank>object\" , \"`%s\\'\" , image -> filename ) ; continue ; } mng_info -> exists [ object_id ] = MagickTrue ; if ( length > 2 ) mng_info -> invisible [ object_id ] = p [ 2 ] ; if ( length > 11 ) { mng_info -> x_off [ object_id ] = ( ssize_t ) ( ( p [ 4 ] << 24 ) | ( p [ 5 ] << 16 ) | ( p [ 6 ] << 8 ) | p [ 7 ] ) ; mng_info -> y_off [ object_id ] = ( ssize_t ) ( ( p [ 8 ] << 24 ) | ( p [ 9 ] << 16 ) | ( p [ 10 ] << 8 ) | p [ 11 ] ) ; if ( logging != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>x_off[%d]:<S2SV_blank>%.20g,<S2SV_blank><S2SV_blank>y_off[%d]:<S2SV_blank>%.20g\" , object_id , ( double ) mng_info -> x_off [ object_id ] , object_id , ( double ) mng_info -> y_off [ object_id ] ) ; } } if ( length > 27 ) mng_info -> object_clip [ object_id ] = mng_read_box ( mng_info -> frame , 0 , & p [ 12 ] ) ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_bKGD , 4 ) == 0 ) { mng_info -> have_global_bkgd = MagickFalse ; if ( length > 5 ) { mng_info -> mng_global_bkgd . red = ScaleShortToQuantum ( ( unsigned short ) ( ( p [ 0 ] << 8 ) | p [ 1 ] ) ) ; mng_info -> mng_global_bkgd . green = ScaleShortToQuantum ( ( unsigned short ) ( ( p [ 2 ] << 8 ) | p [ 3 ] ) ) ; mng_info -> mng_global_bkgd . blue = ScaleShortToQuantum ( ( unsigned short ) ( ( p [ 4 ] << 8 ) | p [ 5 ] ) ) ; mng_info -> have_global_bkgd = MagickTrue ; } chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_BACK , 4 ) == 0 ) { # if defined ( MNG_INSERT_LAYERS ) if ( length > 6 ) mandatory_back = p [ 6 ] ; else mandatory_back = 0 ; if ( mandatory_back && length > 5 ) { mng_background_color . red = ScaleShortToQuantum ( ( unsigned short ) ( ( p [ 0 ] << 8 ) | p [ 1 ] ) ) ; mng_background_color . green = ScaleShortToQuantum ( ( unsigned short ) ( ( p [ 2 ] << 8 ) | p [ 3 ] ) ) ; mng_background_color . blue = ScaleShortToQuantum ( ( unsigned short ) ( ( p [ 4 ] << 8 ) | p [ 5 ] ) ) ; mng_background_color . alpha = OpaqueAlpha ; } # ifdef MNG_OBJECT_BUFFERS if ( length > 8 ) mng_background_object = ( p [ 7 ] << 8 ) | p [ 8 ] ; # endif # endif chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_PLTE , 4 ) == 0 ) { if ( length && ( length < 769 ) ) { if ( mng_info -> global_plte == ( png_colorp ) NULL ) mng_info -> global_plte = ( png_colorp ) AcquireQuantumMemory ( 256 , sizeof ( * mng_info -> global_plte ) ) ; for ( i = 0 ; i < ( ssize_t ) ( length / 3 ) ; i ++ ) { mng_info -> global_plte [ i ] . red = p [ 3 * i ] ; mng_info -> global_plte [ i ] . green = p [ 3 * i + 1 ] ; mng_info -> global_plte [ i ] . blue = p [ 3 * i + 2 ] ; } mng_info -> global_plte_length = ( unsigned int ) ( length / 3 ) ; } # ifdef MNG_LOOSE for ( ; i < 256 ; i ++ ) { mng_info -> global_plte [ i ] . red = i ; mng_info -> global_plte [ i ] . green = i ; mng_info -> global_plte [ i ] . blue = i ; } if ( length != 0 ) mng_info -> global_plte_length = 256 ; # endif else mng_info -> global_plte_length = 0 ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_tRNS , 4 ) == 0 ) { if ( length > 0 && length < 257 ) for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) mng_info -> global_trns [ i ] = p [ i ] ; # ifdef MNG_LOOSE for ( ; i < 256 ; i ++ ) mng_info -> global_trns [ i ] = 255 ; # endif mng_info -> global_trns_length = ( unsigned int ) length ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_gAMA , 4 ) == 0 ) { if ( length == 4 ) { ssize_t igamma ; igamma = mng_get_long ( p ) ; mng_info -> global_gamma = ( ( float ) igamma ) * 0.00001 ; mng_info -> have_global_gama = MagickTrue ; } else mng_info -> have_global_gama = MagickFalse ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_cHRM , 4 ) == 0 ) { if ( length == 32 ) { mng_info -> global_chrm . white_point . x = 0.00001 * mng_get_long ( p ) ; mng_info -> global_chrm . white_point . y = 0.00001 * mng_get_long ( & p [ 4 ] ) ; mng_info -> global_chrm . red_primary . x = 0.00001 * mng_get_long ( & p [ 8 ] ) ; mng_info -> global_chrm . red_primary . y = 0.00001 * mng_get_long ( & p [ 12 ] ) ; mng_info -> global_chrm . green_primary . x = 0.00001 * mng_get_long ( & p [ 16 ] ) ; mng_info -> global_chrm . green_primary . y = 0.00001 * mng_get_long ( & p [ 20 ] ) ; mng_info -> global_chrm . blue_primary . x = 0.00001 * mng_get_long ( & p [ 24 ] ) ; mng_info -> global_chrm . blue_primary . y = 0.00001 * mng_get_long ( & p [ 28 ] ) ; mng_info -> have_global_chrm = MagickTrue ; } else mng_info -> have_global_chrm = MagickFalse ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_sRGB , 4 ) == 0 ) { if ( length != 0 ) { mng_info -> global_srgb_intent = Magick_RenderingIntent_from_PNG_RenderingIntent ( p [ 0 ] ) ; mng_info -> have_global_srgb = MagickTrue ; } else mng_info -> have_global_srgb = MagickFalse ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_iCCP , 4 ) == 0 ) { if ( length != 0 ) chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_FRAM , 4 ) == 0 ) { if ( mng_type == 3 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"FRAM<S2SV_blank>chunk<S2SV_blank>found<S2SV_blank>in<S2SV_blank>MNG-VLC<S2SV_blank>datastream\" , \"`%s\\'\" , image -> filename ) ; if ( ( mng_info -> framing_mode == 2 ) || ( mng_info -> framing_mode == 4 ) ) image -> delay = frame_delay ; frame_delay = default_frame_delay ; frame_timeout = default_frame_timeout ; fb = default_fb ; if ( length != 0 ) if ( p [ 0 ] ) mng_info -> framing_mode = p [ 0 ] ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Framing_mode=%d\" , mng_info -> framing_mode ) ; if ( length > 6 ) { p ++ ; while ( * p && ( ( p - chunk ) < ( ssize_t ) length ) ) p ++ ; p ++ ; if ( ( p - chunk ) < ( ssize_t ) ( length - 4 ) ) { int change_delay , change_timeout , change_clipping ; change_delay = ( * p ++ ) ; change_timeout = ( * p ++ ) ; change_clipping = ( * p ++ ) ; p ++ ; if ( change_delay ) { frame_delay = 1UL * image -> ticks_per_second * mng_get_long ( p ) ; if ( mng_info -> ticks_per_second != 0 ) frame_delay /= mng_info -> ticks_per_second ; else frame_delay = PNG_UINT_31_MAX ; if ( change_delay == 2 ) default_frame_delay = frame_delay ; p += 4 ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Framing_delay=%.20g\" , ( double ) frame_delay ) ; } if ( change_timeout ) { frame_timeout = 1UL * image -> ticks_per_second * mng_get_long ( p ) ; if ( mng_info -> ticks_per_second != 0 ) frame_timeout /= mng_info -> ticks_per_second ; else frame_timeout = PNG_UINT_31_MAX ; if ( change_timeout == 2 ) default_frame_timeout = frame_timeout ; p += 4 ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Framing_timeout=%.20g\" , ( double ) frame_timeout ) ; } if ( change_clipping ) { fb = mng_read_box ( previous_fb , ( char ) p [ 0 ] , & p [ 1 ] ) ; p += 17 ; previous_fb = fb ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Frame_clip:<S2SV_blank>L=%.20g<S2SV_blank>R=%.20g<S2SV_blank>T=%.20g<S2SV_blank>B=%.20g\" , ( double ) fb . left , ( double ) fb . right , ( double ) fb . top , ( double ) fb . bottom ) ; if ( change_clipping == 2 ) default_fb = fb ; } } } mng_info -> clip = fb ; mng_info -> clip = mng_minimum_box ( fb , mng_info -> frame ) ; subframe_width = ( size_t ) ( mng_info -> clip . right - mng_info -> clip . left ) ; subframe_height = ( size_t ) ( mng_info -> clip . bottom - mng_info -> clip . top ) ; # if defined ( MNG_INSERT_LAYERS ) if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank>subframe_width=%.20g,<S2SV_blank>subframe_height=%.20g\" , ( double ) subframe_width , ( double ) subframe_height ) ; if ( insert_layers && ( mng_info -> framing_mode == 4 ) && ( subframe_width ) && ( subframe_height ) ) { if ( GetAuthenticPixelQueue ( image ) != ( Quantum * ) NULL ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } mng_info -> image = image ; if ( term_chunk_found ) { image -> start_loop = MagickTrue ; image -> iterations = mng_iterations ; term_chunk_found = MagickFalse ; } else image -> start_loop = MagickFalse ; image -> columns = subframe_width ; image -> rows = subframe_height ; image -> page . width = subframe_width ; image -> page . height = subframe_height ; image -> page . x = mng_info -> clip . left ; image -> page . y = mng_info -> clip . top ; image -> background_color = mng_background_color ; image -> alpha_trait = UndefinedPixelTrait ; image -> delay = 0 ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Insert<S2SV_blank>backgd<S2SV_blank>layer,<S2SV_blank>L=%.20g,<S2SV_blank>R=%.20g<S2SV_blank>T=%.20g,<S2SV_blank>B=%.20g\" , ( double ) mng_info -> clip . left , ( double ) mng_info -> clip . right , ( double ) mng_info -> clip . top , ( double ) mng_info -> clip . bottom ) ; } # endif chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_CLIP , 4 ) == 0 ) { unsigned int first_object , last_object ; if ( length > 3 ) { first_object = ( p [ 0 ] << 8 ) | p [ 1 ] ; last_object = ( p [ 2 ] << 8 ) | p [ 3 ] ; p += 4 ; for ( i = ( int ) first_object ; i <= ( int ) last_object ; i ++ ) <S2SV_StartBug> { <S2SV_EndBug> if ( mng_info -> exists [ i ] && ! mng_info -> frozen [ i ] ) { MngBox box ; box = mng_info -> object_clip [ i ] ; if ( ( p - chunk ) < ( ssize_t ) ( length - 17 ) ) mng_info -> object_clip [ i ] = mng_read_box ( box , ( char ) p [ 0 ] , & p [ 1 ] ) ; } } } chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_SAVE , 4 ) == 0 ) { for ( i = 1 ; i < MNG_MAX_OBJECTS ; i ++ ) if ( mng_info -> exists [ i ] ) { mng_info -> frozen [ i ] = MagickTrue ; # ifdef MNG_OBJECT_BUFFERS if ( mng_info -> ob [ i ] != ( MngBuffer * ) NULL ) mng_info -> ob [ i ] -> frozen = MagickTrue ; # endif } if ( length != 0 ) chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( ( memcmp ( type , mng_DISC , 4 ) == 0 ) || ( memcmp ( type , mng_SEEK , 4 ) == 0 ) ) { if ( ( length == 0 ) || ! memcmp ( type , mng_SEEK , 4 ) ) { for ( i = 1 ; i < MNG_MAX_OBJECTS ; i ++ ) MngInfoDiscardObject ( mng_info , i ) ; } else { register ssize_t j ; for ( j = 1 ; j < ( ssize_t ) length ; j += 2 ) { i = p [ j - 1 ] << 8 | p [ j ] ; MngInfoDiscardObject ( mng_info , i ) ; } } if ( length != 0 ) chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_MOVE , 4 ) == 0 ) { size_t first_object , last_object ; if ( length > 3 ) { first_object = ( p [ 0 ] << 8 ) | p [ 1 ] ; last_object = ( p [ 2 ] << 8 ) | p [ 3 ] ; p += 4 ; for ( i = ( ssize_t ) first_object ; i <= ( ssize_t ) last_object ; i ++ ) { if ( ( i < 0 ) || ( i >= MNG_MAX_OBJECTS ) ) continue ; if ( mng_info -> exists [ i ] && ! mng_info -> frozen [ i ] && ( p - chunk ) < ( ssize_t ) ( length - 8 ) ) { MngPair new_pair ; MngPair old_pair ; old_pair . a = mng_info -> x_off [ i ] ; old_pair . b = mng_info -> y_off [ i ] ; new_pair = mng_read_pair ( old_pair , ( int ) p [ 0 ] , & p [ 1 ] ) ; mng_info -> x_off [ i ] = new_pair . a ; mng_info -> y_off [ i ] = new_pair . b ; } } } chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_LOOP , 4 ) == 0 ) { ssize_t loop_iters = 1 ; if ( length > 4 ) { loop_level = chunk [ 0 ] ; mng_info -> loop_active [ loop_level ] = 1 ; loop_iters = mng_get_long ( & chunk [ 1 ] ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>LOOP<S2SV_blank>level<S2SV_blank>%.20g<S2SV_blank>has<S2SV_blank>%.20g<S2SV_blank>iterations<S2SV_blank>\" , ( double ) loop_level , ( double ) loop_iters ) ; if ( loop_iters == 0 ) skipping_loop = loop_level ; else { mng_info -> loop_jump [ loop_level ] = TellBlob ( image ) ; mng_info -> loop_count [ loop_level ] = loop_iters ; } mng_info -> loop_iteration [ loop_level ] = 0 ; } chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_ENDL , 4 ) == 0 ) { if ( length > 0 ) { loop_level = chunk [ 0 ] ; if ( skipping_loop > 0 ) { if ( skipping_loop == loop_level ) { skipping_loop = ( - 1 ) ; mng_info -> loop_active [ loop_level ] = 0 ; } } else { if ( mng_info -> loop_active [ loop_level ] == 1 ) { mng_info -> loop_count [ loop_level ] -- ; mng_info -> loop_iteration [ loop_level ] ++ ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>ENDL:<S2SV_blank>LOOP<S2SV_blank>level<S2SV_blank>%.20g<S2SV_blank>has<S2SV_blank>%.20g<S2SV_blank>remaining<S2SV_blank>iters\" , ( double ) loop_level , ( double ) mng_info -> loop_count [ loop_level ] ) ; if ( mng_info -> loop_count [ loop_level ] != 0 ) { offset = SeekBlob ( image , mng_info -> loop_jump [ loop_level ] , SEEK_SET ) ; if ( offset < 0 ) { chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } } else { short last_level ; mng_info -> loop_active [ loop_level ] = 0 ; last_level = ( - 1 ) ; for ( i = 0 ; i < loop_level ; i ++ ) if ( mng_info -> loop_active [ i ] == 1 ) last_level = ( short ) i ; loop_level = last_level ; } } } } chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_CLON , 4 ) == 0 ) { if ( mng_info -> clon_warning == 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"CLON<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet\" , \"`%s\\'\" , image -> filename ) ; mng_info -> clon_warning ++ ; } if ( memcmp ( type , mng_MAGN , 4 ) == 0 ) { png_uint_16 magn_first , magn_last , magn_mb , magn_ml , magn_mr , magn_mt , magn_mx , magn_my , magn_methx , magn_methy ; if ( length > 1 ) magn_first = ( p [ 0 ] << 8 ) | p [ 1 ] ; else magn_first = 0 ; if ( length > 3 ) magn_last = ( p [ 2 ] << 8 ) | p [ 3 ] ; else magn_last = magn_first ; # ifndef MNG_OBJECT_BUFFERS if ( magn_first || magn_last ) if ( mng_info -> magn_warning == 0 ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"MAGN<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet<S2SV_blank>for<S2SV_blank>nonzero<S2SV_blank>objects\" , \"`%s\\'\" , image -> filename ) ; mng_info -> magn_warning ++ ; } # endif if ( length > 4 ) magn_methx = p [ 4 ] ; else magn_methx = 0 ; if ( length > 6 ) magn_mx = ( p [ 5 ] << 8 ) | p [ 6 ] ; else magn_mx = 1 ; if ( magn_mx == 0 ) magn_mx = 1 ; if ( length > 8 ) magn_my = ( p [ 7 ] << 8 ) | p [ 8 ] ; else magn_my = magn_mx ; if ( magn_my == 0 ) magn_my = 1 ; if ( length > 10 ) magn_ml = ( p [ 9 ] << 8 ) | p [ 10 ] ; else magn_ml = magn_mx ; if ( magn_ml == 0 ) magn_ml = 1 ; if ( length > 12 ) magn_mr = ( p [ 11 ] << 8 ) | p [ 12 ] ; else magn_mr = magn_mx ; if ( magn_mr == 0 ) magn_mr = 1 ; if ( length > 14 ) magn_mt = ( p [ 13 ] << 8 ) | p [ 14 ] ; else magn_mt = magn_my ; if ( magn_mt == 0 ) magn_mt = 1 ; if ( length > 16 ) magn_mb = ( p [ 15 ] << 8 ) | p [ 16 ] ; else magn_mb = magn_my ; if ( magn_mb == 0 ) magn_mb = 1 ; if ( length > 17 ) magn_methy = p [ 17 ] ; else magn_methy = magn_methx ; if ( magn_methx > 5 || magn_methy > 5 ) if ( mng_info -> magn_warning == 0 ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"Unknown<S2SV_blank>MAGN<S2SV_blank>method<S2SV_blank>in<S2SV_blank>MNG<S2SV_blank>datastream\" , \"`%s\\'\" , image -> filename ) ; mng_info -> magn_warning ++ ; } # ifdef MNG_OBJECT_BUFFERS # endif if ( magn_first == 0 || magn_last == 0 ) { mng_info -> magn_mb = magn_mb ; mng_info -> magn_ml = magn_ml ; mng_info -> magn_mr = magn_mr ; mng_info -> magn_mt = magn_mt ; mng_info -> magn_mx = magn_mx ; mng_info -> magn_my = magn_my ; mng_info -> magn_methx = magn_methx ; mng_info -> magn_methy = magn_methy ; } } if ( memcmp ( type , mng_PAST , 4 ) == 0 ) { if ( mng_info -> past_warning == 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"PAST<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet\" , \"`%s\\'\" , image -> filename ) ; mng_info -> past_warning ++ ; } if ( memcmp ( type , mng_SHOW , 4 ) == 0 ) { if ( mng_info -> show_warning == 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"SHOW<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet\" , \"`%s\\'\" , image -> filename ) ; mng_info -> show_warning ++ ; } if ( memcmp ( type , mng_sBIT , 4 ) == 0 ) { if ( length < 4 ) mng_info -> have_global_sbit = MagickFalse ; else { mng_info -> global_sbit . gray = p [ 0 ] ; mng_info -> global_sbit . red = p [ 0 ] ; mng_info -> global_sbit . green = p [ 1 ] ; mng_info -> global_sbit . blue = p [ 2 ] ; mng_info -> global_sbit . alpha = p [ 3 ] ; mng_info -> have_global_sbit = MagickTrue ; } } if ( memcmp ( type , mng_pHYs , 4 ) == 0 ) { if ( length > 8 ) { mng_info -> global_x_pixels_per_unit = ( size_t ) mng_get_long ( p ) ; mng_info -> global_y_pixels_per_unit = ( size_t ) mng_get_long ( & p [ 4 ] ) ; mng_info -> global_phys_unit_type = p [ 8 ] ; mng_info -> have_global_phys = MagickTrue ; } else mng_info -> have_global_phys = MagickFalse ; } if ( memcmp ( type , mng_pHYg , 4 ) == 0 ) { if ( mng_info -> phyg_warning == 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"pHYg<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented.\" , \"`%s\\'\" , image -> filename ) ; mng_info -> phyg_warning ++ ; } if ( memcmp ( type , mng_BASI , 4 ) == 0 ) { skip_to_iend = MagickTrue ; if ( mng_info -> basi_warning == 0 ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"BASI<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet\" , \"`%s\\'\" , image -> filename ) ; mng_info -> basi_warning ++ ; # ifdef MNG_BASI_SUPPORTED basi_width = ( size_t ) ( ( p [ 0 ] << 24 ) | ( p [ 1 ] << 16 ) | ( p [ 2 ] << 8 ) | p [ 3 ] ) ; basi_height = ( size_t ) ( ( p [ 4 ] << 24 ) | ( p [ 5 ] << 16 ) | ( p [ 6 ] << 8 ) | p [ 7 ] ) ; basi_color_type = p [ 8 ] ; basi_compression_method = p [ 9 ] ; basi_filter_type = p [ 10 ] ; basi_interlace_method = p [ 11 ] ; if ( length > 11 ) basi_red = ( p [ 12 ] << 8 ) & p [ 13 ] ; else basi_red = 0 ; if ( length > 13 ) basi_green = ( p [ 14 ] << 8 ) & p [ 15 ] ; else basi_green = 0 ; if ( length > 15 ) basi_blue = ( p [ 16 ] << 8 ) & p [ 17 ] ; else basi_blue = 0 ; if ( length > 17 ) basi_alpha = ( p [ 18 ] << 8 ) & p [ 19 ] ; else { if ( basi_sample_depth == 16 ) basi_alpha = 65535L ; else basi_alpha = 255 ; } if ( length > 19 ) basi_viewable = p [ 20 ] ; else basi_viewable = 0 ; # endif chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( memcmp ( type , mng_IHDR , 4 ) # if defined ( JNG_SUPPORTED ) && memcmp ( type , mng_JHDR , 4 ) # endif ) { if ( length != 0 ) chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Processing<S2SV_blank>%c%c%c%c<S2SV_blank>chunk\" , type [ 0 ] , type [ 1 ] , type [ 2 ] , type [ 3 ] ) ; mng_info -> exists [ object_id ] = MagickTrue ; mng_info -> viewable [ object_id ] = MagickTrue ; if ( mng_info -> invisible [ object_id ] ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Skipping<S2SV_blank>invisible<S2SV_blank>object\" ) ; skip_to_iend = MagickTrue ; chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; continue ; } # if defined ( MNG_INSERT_LAYERS ) if ( length < 8 ) { chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } image_width = ( size_t ) mng_get_long ( p ) ; image_height = ( size_t ) mng_get_long ( & p [ 4 ] ) ; # endif chunk = ( unsigned char * ) RelinquishMagickMemory ( chunk ) ; # if defined ( MNG_INSERT_LAYERS ) if ( insert_layers && mng_type && first_mng_object ) { if ( ( mng_info -> clip . left > 0 ) || ( mng_info -> clip . top > 0 ) || ( image_width < mng_info -> mng_width ) || ( mng_info -> clip . right < ( ssize_t ) mng_info -> mng_width ) || ( image_height < mng_info -> mng_height ) || ( mng_info -> clip . bottom < ( ssize_t ) mng_info -> mng_height ) ) { if ( GetAuthenticPixelQueue ( image ) != ( Quantum * ) NULL ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } mng_info -> image = image ; if ( term_chunk_found ) { image -> start_loop = MagickTrue ; image -> iterations = mng_iterations ; term_chunk_found = MagickFalse ; } else image -> start_loop = MagickFalse ; image -> delay = 0 ; image -> columns = mng_info -> mng_width ; image -> rows = mng_info -> mng_height ; image -> page . width = mng_info -> mng_width ; image -> page . height = mng_info -> mng_height ; image -> page . x = 0 ; image -> page . y = 0 ; image -> background_color = mng_background_color ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Inserted<S2SV_blank>transparent<S2SV_blank>background<S2SV_blank>layer,<S2SV_blank>W=%.20g,<S2SV_blank>H=%.20g\" , ( double ) mng_info -> mng_width , ( double ) mng_info -> mng_height ) ; } } if ( insert_layers && ( mng_info -> framing_mode == 3 ) && ( subframe_width ) && ( subframe_height ) && ( simplicity == 0 || ( simplicity & 0x08 ) ) ) { if ( GetAuthenticPixelQueue ( image ) != ( Quantum * ) NULL ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } mng_info -> image = image ; if ( term_chunk_found ) { image -> start_loop = MagickTrue ; image -> iterations = mng_iterations ; term_chunk_found = MagickFalse ; } else image -> start_loop = MagickFalse ; image -> delay = 0 ; image -> columns = subframe_width ; image -> rows = subframe_height ; image -> page . width = subframe_width ; image -> page . height = subframe_height ; image -> page . x = mng_info -> clip . left ; image -> page . y = mng_info -> clip . top ; image -> background_color = mng_background_color ; image -> alpha_trait = UndefinedPixelTrait ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Insert<S2SV_blank>background<S2SV_blank>layer,<S2SV_blank>L=%.20g,<S2SV_blank>R=%.20g<S2SV_blank>T=%.20g,<S2SV_blank>B=%.20g\" , ( double ) mng_info -> clip . left , ( double ) mng_info -> clip . right , ( double ) mng_info -> clip . top , ( double ) mng_info -> clip . bottom ) ; } # endif first_mng_object = MagickFalse ; if ( GetAuthenticPixelQueue ( image ) != ( Quantum * ) NULL ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } mng_info -> image = image ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; if ( term_chunk_found ) { image -> start_loop = MagickTrue ; term_chunk_found = MagickFalse ; } else image -> start_loop = MagickFalse ; if ( mng_info -> framing_mode == 1 || mng_info -> framing_mode == 3 ) { image -> delay = frame_delay ; frame_delay = default_frame_delay ; } else image -> delay = 0 ; image -> page . width = mng_info -> mng_width ; image -> page . height = mng_info -> mng_height ; image -> page . x = mng_info -> x_off [ object_id ] ; image -> page . y = mng_info -> y_off [ object_id ] ; image -> iterations = mng_iterations ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Seeking<S2SV_blank>back<S2SV_blank>to<S2SV_blank>beginning<S2SV_blank>of<S2SV_blank>%c%c%c%c<S2SV_blank>chunk\" , type [ 0 ] , type [ 1 ] , type [ 2 ] , type [ 3 ] ) ; offset = SeekBlob ( image , - ( ( ssize_t ) length + 12 ) , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } mng_info -> image = image ; mng_info -> mng_type = mng_type ; mng_info -> object_id = object_id ; if ( memcmp ( type , mng_IHDR , 4 ) == 0 ) image = ReadOnePNGImage ( mng_info , image_info , exception ) ; # if defined ( JNG_SUPPORTED ) else image = ReadOneJNGImage ( mng_info , image_info , exception ) ; # endif if ( image == ( Image * ) NULL ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"exit<S2SV_blank>ReadJNGImage()<S2SV_blank>with<S2SV_blank>error\" ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 || image -> rows == 0 ) { ( void ) CloseBlob ( image ) ; return ( DestroyImageList ( image ) ) ; } mng_info -> image = image ; if ( mng_type ) { MngBox crop_box ; if ( mng_info -> magn_methx || mng_info -> magn_methy ) { png_uint_32 magnified_height , magnified_width ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Processing<S2SV_blank>MNG<S2SV_blank>MAGN<S2SV_blank>chunk\" ) ; if ( mng_info -> magn_methx == 1 ) { magnified_width = mng_info -> magn_ml ; if ( image -> columns > 1 ) magnified_width += mng_info -> magn_mr ; if ( image -> columns > 2 ) magnified_width += ( png_uint_32 ) ( ( image -> columns - 2 ) * ( mng_info -> magn_mx ) ) ; } else { magnified_width = ( png_uint_32 ) image -> columns ; if ( image -> columns > 1 ) magnified_width += mng_info -> magn_ml - 1 ; if ( image -> columns > 2 ) magnified_width += mng_info -> magn_mr - 1 ; if ( image -> columns > 3 ) magnified_width += ( png_uint_32 ) ( ( image -> columns - 3 ) * ( mng_info -> magn_mx - 1 ) ) ; } if ( mng_info -> magn_methy == 1 ) { magnified_height = mng_info -> magn_mt ; if ( image -> rows > 1 ) magnified_height += mng_info -> magn_mb ; if ( image -> rows > 2 ) magnified_height += ( png_uint_32 ) ( ( image -> rows - 2 ) * ( mng_info -> magn_my ) ) ; } else { magnified_height = ( png_uint_32 ) image -> rows ; if ( image -> rows > 1 ) magnified_height += mng_info -> magn_mt - 1 ; if ( image -> rows > 2 ) magnified_height += mng_info -> magn_mb - 1 ; if ( image -> rows > 3 ) magnified_height += ( png_uint_32 ) ( ( image -> rows - 3 ) * ( mng_info -> magn_my - 1 ) ) ; } if ( magnified_height > image -> rows || magnified_width > image -> columns ) { Image * large_image ; int yy ; Quantum * next , * prev ; png_uint_16 magn_methx , magn_methy ; ssize_t m , y ; register Quantum * n , * q ; register ssize_t x ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Allocate<S2SV_blank>magnified<S2SV_blank>image\" ) ; AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; large_image = SyncNextImageInList ( image ) ; large_image -> columns = magnified_width ; large_image -> rows = magnified_height ; magn_methx = mng_info -> magn_methx ; magn_methy = mng_info -> magn_methy ; # if ( MAGICKCORE_QUANTUM_DEPTH > 16 ) # define QM unsigned short if ( magn_methx != 1 || magn_methy != 1 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; for ( x = ( ssize_t ) image -> columns - 1 ; x >= 0 ; x -- ) { SetPixelRed ( image , ScaleQuantumToShort ( GetPixelRed ( image , q ) ) , q ) ; SetPixelGreen ( image , ScaleQuantumToShort ( GetPixelGreen ( image , q ) ) , q ) ; SetPixelBlue ( image , ScaleQuantumToShort ( GetPixelBlue ( image , q ) ) , q ) ; SetPixelAlpha ( image , ScaleQuantumToShort ( GetPixelAlpha ( image , q ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } # else # define QM Quantum # endif if ( image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageBackgroundColor ( large_image , exception ) ; else { large_image -> background_color . alpha = OpaqueAlpha ; ( void ) SetImageBackgroundColor ( large_image , exception ) ; if ( magn_methx == 4 ) magn_methx = 2 ; if ( magn_methx == 5 ) magn_methx = 3 ; if ( magn_methy == 4 ) magn_methy = 2 ; if ( magn_methy == 5 ) magn_methy = 3 ; } if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Magnify<S2SV_blank>the<S2SV_blank>rows<S2SV_blank>to<S2SV_blank>%.20g\" , ( double ) large_image -> rows ) ; m = ( ssize_t ) mng_info -> magn_mt ; yy = 0 ; length = ( size_t ) GetPixelChannels ( image ) * image -> columns ; next = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * next ) ) ; prev = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * prev ) ) ; if ( ( prev == ( Quantum * ) NULL ) || ( next == ( Quantum * ) NULL ) ) { image = DestroyImageList ( image ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } n = GetAuthenticPixels ( image , 0 , 0 , image -> columns , 1 , exception ) ; ( void ) CopyMagickMemory ( next , n , length ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( y == 0 ) m = ( ssize_t ) mng_info -> magn_mt ; else if ( magn_methy > 1 && y == ( ssize_t ) image -> rows - 2 ) m = ( ssize_t ) mng_info -> magn_mb ; else if ( magn_methy <= 1 && y == ( ssize_t ) image -> rows - 1 ) m = ( ssize_t ) mng_info -> magn_mb ; else if ( magn_methy > 1 && y == ( ssize_t ) image -> rows - 1 ) m = 1 ; else m = ( ssize_t ) mng_info -> magn_my ; n = prev ; prev = next ; next = n ; if ( y < ( ssize_t ) image -> rows - 1 ) { n = GetAuthenticPixels ( image , 0 , y + 1 , image -> columns , 1 , exception ) ; ( void ) CopyMagickMemory ( next , n , length ) ; } for ( i = 0 ; i < m ; i ++ , yy ++ ) { register Quantum * pixels ; assert ( yy < ( ssize_t ) large_image -> rows ) ; pixels = prev ; n = next ; q = GetAuthenticPixels ( large_image , 0 , yy , large_image -> columns , 1 , exception ) ; q += ( large_image -> columns - image -> columns ) * GetPixelChannels ( large_image ) ; for ( x = ( ssize_t ) image -> columns - 1 ; x >= 0 ; x -- ) { if ( magn_methy <= 1 ) { SetPixelRed ( large_image , GetPixelRed ( image , pixels ) , q ) ; SetPixelGreen ( large_image , GetPixelGreen ( image , pixels ) , q ) ; SetPixelBlue ( large_image , GetPixelBlue ( image , pixels ) , q ) ; SetPixelAlpha ( large_image , GetPixelAlpha ( image , pixels ) , q ) ; } else if ( magn_methy == 2 || magn_methy == 4 ) { if ( i == 0 ) { SetPixelRed ( large_image , GetPixelRed ( image , pixels ) , q ) ; SetPixelGreen ( large_image , GetPixelGreen ( image , pixels ) , q ) ; SetPixelBlue ( large_image , GetPixelBlue ( image , pixels ) , q ) ; SetPixelAlpha ( large_image , GetPixelAlpha ( image , pixels ) , q ) ; } else { SetPixelRed ( large_image , ( ( QM ) ( ( ( ssize_t ) ( 2 * i * ( GetPixelRed ( image , n ) - GetPixelRed ( image , pixels ) + m ) ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelRed ( image , pixels ) ) ) ) , q ) ; SetPixelGreen ( large_image , ( ( QM ) ( ( ( ssize_t ) ( 2 * i * ( GetPixelGreen ( image , n ) - GetPixelGreen ( image , pixels ) + m ) ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelGreen ( image , pixels ) ) ) ) , q ) ; SetPixelBlue ( large_image , ( ( QM ) ( ( ( ssize_t ) ( 2 * i * ( GetPixelBlue ( image , n ) - GetPixelBlue ( image , pixels ) + m ) ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelBlue ( image , pixels ) ) ) ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( large_image , ( ( QM ) ( ( ( ssize_t ) ( 2 * i * ( GetPixelAlpha ( image , n ) - GetPixelAlpha ( image , pixels ) + m ) ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelAlpha ( image , pixels ) ) ) ) , q ) ; } if ( magn_methy == 4 ) { if ( i <= ( ( m + 1 ) << 1 ) ) SetPixelAlpha ( large_image , GetPixelAlpha ( image , pixels ) , q ) ; else SetPixelAlpha ( large_image , GetPixelAlpha ( image , n ) , q ) ; } } else { if ( i <= ( ( m + 1 ) << 1 ) ) { SetPixelRed ( large_image , GetPixelRed ( image , pixels ) , q ) ; SetPixelGreen ( large_image , GetPixelGreen ( image , pixels ) , q ) ; SetPixelBlue ( large_image , GetPixelBlue ( image , pixels ) , q ) ; SetPixelAlpha ( large_image , GetPixelAlpha ( image , pixels ) , q ) ; } else { SetPixelRed ( large_image , GetPixelRed ( image , n ) , q ) ; SetPixelGreen ( large_image , GetPixelGreen ( image , n ) , q ) ; SetPixelBlue ( large_image , GetPixelBlue ( image , n ) , q ) ; SetPixelAlpha ( large_image , GetPixelAlpha ( image , n ) , q ) ; } if ( magn_methy == 5 ) { SetPixelAlpha ( large_image , ( QM ) ( ( ( ssize_t ) ( 2 * i * ( GetPixelAlpha ( image , n ) - GetPixelAlpha ( image , pixels ) ) + m ) ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelAlpha ( image , pixels ) ) , q ) ; } } n += GetPixelChannels ( image ) ; q += GetPixelChannels ( large_image ) ; pixels += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( large_image , exception ) == 0 ) break ; } } prev = ( Quantum * ) RelinquishMagickMemory ( prev ) ; next = ( Quantum * ) RelinquishMagickMemory ( next ) ; length = image -> columns ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Delete<S2SV_blank>original<S2SV_blank>image\" ) ; DeleteImageFromList ( & image ) ; image = large_image ; mng_info -> image = image ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Magnify<S2SV_blank>the<S2SV_blank>columns<S2SV_blank>to<S2SV_blank>%.20g\" , ( double ) image -> columns ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * pixels ; q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; pixels = q + ( image -> columns - length ) * GetPixelChannels ( image ) ; n = pixels + GetPixelChannels ( image ) ; for ( x = ( ssize_t ) ( image -> columns - length ) ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( x == ( ssize_t ) ( image -> columns - length ) ) m = ( ssize_t ) mng_info -> magn_ml ; else if ( magn_methx > 1 && x == ( ssize_t ) image -> columns - 2 ) m = ( ssize_t ) mng_info -> magn_mr ; else if ( magn_methx <= 1 && x == ( ssize_t ) image -> columns - 1 ) m = ( ssize_t ) mng_info -> magn_mr ; else if ( magn_methx > 1 && x == ( ssize_t ) image -> columns - 1 ) m = 1 ; else m = ( ssize_t ) mng_info -> magn_mx ; for ( i = 0 ; i < m ; i ++ ) { if ( magn_methx <= 1 ) { SetPixelRed ( image , GetPixelRed ( image , pixels ) , q ) ; SetPixelGreen ( image , GetPixelGreen ( image , pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( image , pixels ) , q ) ; SetPixelAlpha ( image , GetPixelAlpha ( image , pixels ) , q ) ; } else if ( magn_methx == 2 || magn_methx == 4 ) { if ( i == 0 ) { SetPixelRed ( image , GetPixelRed ( image , pixels ) , q ) ; SetPixelGreen ( image , GetPixelGreen ( image , pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( image , pixels ) , q ) ; SetPixelAlpha ( image , GetPixelAlpha ( image , pixels ) , q ) ; } else { SetPixelRed ( image , ( QM ) ( ( 2 * i * ( GetPixelRed ( image , n ) - GetPixelRed ( image , pixels ) ) + m ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelRed ( image , pixels ) ) , q ) ; SetPixelGreen ( image , ( QM ) ( ( 2 * i * ( GetPixelGreen ( image , n ) - GetPixelGreen ( image , pixels ) ) + m ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelGreen ( image , pixels ) ) , q ) ; SetPixelBlue ( image , ( QM ) ( ( 2 * i * ( GetPixelBlue ( image , n ) - GetPixelBlue ( image , pixels ) ) + m ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelBlue ( image , pixels ) ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ( QM ) ( ( 2 * i * ( GetPixelAlpha ( image , n ) - GetPixelAlpha ( image , pixels ) ) + m ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelAlpha ( image , pixels ) ) , q ) ; } if ( magn_methx == 4 ) { if ( i <= ( ( m + 1 ) << 1 ) ) { SetPixelAlpha ( image , GetPixelAlpha ( image , pixels ) + 0 , q ) ; } else { SetPixelAlpha ( image , GetPixelAlpha ( image , n ) + 0 , q ) ; } } } else { if ( i <= ( ( m + 1 ) << 1 ) ) { SetPixelRed ( image , GetPixelRed ( image , pixels ) , q ) ; SetPixelGreen ( image , GetPixelGreen ( image , pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( image , pixels ) , q ) ; SetPixelAlpha ( image , GetPixelAlpha ( image , pixels ) , q ) ; } else { SetPixelRed ( image , GetPixelRed ( image , n ) , q ) ; SetPixelGreen ( image , GetPixelGreen ( image , n ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( image , n ) , q ) ; SetPixelAlpha ( image , GetPixelAlpha ( image , n ) , q ) ; } if ( magn_methx == 5 ) { SetPixelAlpha ( image , ( QM ) ( ( 2 * i * ( GetPixelAlpha ( image , n ) - GetPixelAlpha ( image , pixels ) ) + m ) / ( ( ssize_t ) ( m * 2 ) ) + GetPixelAlpha ( image , pixels ) ) , q ) ; } } q += GetPixelChannels ( image ) ; } n += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } # if ( MAGICKCORE_QUANTUM_DEPTH > 16 ) if ( magn_methx != 1 || magn_methy != 1 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; for ( x = ( ssize_t ) image -> columns - 1 ; x >= 0 ; x -- ) { SetPixelRed ( image , ScaleShortToQuantum ( GetPixelRed ( image , q ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( GetPixelGreen ( image , q ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( GetPixelBlue ( image , q ) ) , q ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( GetPixelAlpha ( image , q ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } # endif if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Finished<S2SV_blank>MAGN<S2SV_blank>processing\" ) ; } } crop_box . left = mng_info -> image_box . left + mng_info -> x_off [ object_id ] ; crop_box . right = mng_info -> image_box . right + mng_info -> x_off [ object_id ] ; crop_box . top = mng_info -> image_box . top + mng_info -> y_off [ object_id ] ; crop_box . bottom = mng_info -> image_box . bottom + mng_info -> y_off [ object_id ] ; crop_box = mng_minimum_box ( crop_box , mng_info -> clip ) ; crop_box = mng_minimum_box ( crop_box , mng_info -> frame ) ; crop_box = mng_minimum_box ( crop_box , mng_info -> object_clip [ object_id ] ) ; if ( ( crop_box . left != ( mng_info -> image_box . left + mng_info -> x_off [ object_id ] ) ) || ( crop_box . right != ( mng_info -> image_box . right + mng_info -> x_off [ object_id ] ) ) || ( crop_box . top != ( mng_info -> image_box . top + mng_info -> y_off [ object_id ] ) ) || ( crop_box . bottom != ( mng_info -> image_box . bottom + mng_info -> y_off [ object_id ] ) ) ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Crop<S2SV_blank>the<S2SV_blank>PNG<S2SV_blank>image\" ) ; if ( ( crop_box . left < crop_box . right ) && ( crop_box . top < crop_box . bottom ) ) { Image * im ; RectangleInfo crop_info ; crop_info . x = ( crop_box . left - mng_info -> x_off [ object_id ] ) ; crop_info . y = ( crop_box . top - mng_info -> y_off [ object_id ] ) ; crop_info . width = ( size_t ) ( crop_box . right - crop_box . left ) ; crop_info . height = ( size_t ) ( crop_box . bottom - crop_box . top ) ; image -> page . width = image -> columns ; image -> page . height = image -> rows ; image -> page . x = 0 ; image -> page . y = 0 ; im = CropImage ( image , & crop_info , exception ) ; if ( im != ( Image * ) NULL ) { image -> columns = im -> columns ; image -> rows = im -> rows ; im = DestroyImage ( im ) ; image -> page . width = image -> columns ; image -> page . height = image -> rows ; image -> page . x = crop_box . left ; image -> page . y = crop_box . top ; } } else { image -> columns = 1 ; image -> rows = 1 ; image -> colors = 2 ; ( void ) SetImageBackgroundColor ( image , exception ) ; image -> page . width = 1 ; image -> page . height = 1 ; image -> page . x = 0 ; image -> page . y = 0 ; } } # ifndef PNG_READ_EMPTY_PLTE_SUPPORTED image = mng_info -> image ; # endif } # if ( MAGICKCORE_QUANTUM_DEPTH > 16 ) if ( image -> depth > 16 ) image -> depth = 16 ; # endif # if ( MAGICKCORE_QUANTUM_DEPTH > 8 ) if ( image -> depth > 8 ) { image -> depth = 16 ; } if ( LosslessReduceDepthOK ( image , exception ) != MagickFalse ) image -> depth = 8 ; # endif if ( image_info -> number_scenes != 0 ) { if ( mng_info -> scenes_found > ( ssize_t ) ( image_info -> first_scene + image_info -> number_scenes ) ) break ; } if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Finished<S2SV_blank>reading<S2SV_blank>image<S2SV_blank>datastream.\" ) ; } while ( LocaleCompare ( image_info -> magick , \"MNG\" ) == 0 ) ; ( void ) CloseBlob ( image ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Finished<S2SV_blank>reading<S2SV_blank>all<S2SV_blank>image<S2SV_blank>datastreams.\" ) ; # if defined ( MNG_INSERT_LAYERS ) if ( insert_layers && ! mng_info -> image_found && ( mng_info -> mng_width ) && ( mng_info -> mng_height ) ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>No<S2SV_blank>images<S2SV_blank>found.<S2SV_blank><S2SV_blank>Inserting<S2SV_blank>a<S2SV_blank>background<S2SV_blank>layer.\" ) ; if ( GetAuthenticPixelQueue ( image ) != ( Quantum * ) NULL ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Allocation<S2SV_blank>failed,<S2SV_blank>returning<S2SV_blank>NULL.\" ) ; return ( DestroyImageList ( image ) ) ; ; } image = SyncNextImageInList ( image ) ; } image -> columns = mng_info -> mng_width ; image -> rows = mng_info -> mng_height ; image -> page . width = mng_info -> mng_width ; image -> page . height = mng_info -> mng_height ; image -> page . x = 0 ; image -> page . y = 0 ; image -> background_color = mng_background_color ; image -> alpha_trait = UndefinedPixelTrait ; if ( image_info -> ping == MagickFalse ) ( void ) SetImageBackgroundColor ( image , exception ) ; mng_info -> image_found ++ ; } # endif image -> iterations = mng_iterations ; if ( mng_iterations == 1 ) image -> start_loop = MagickTrue ; while ( GetPreviousImageInList ( image ) != ( Image * ) NULL ) { image_count ++ ; if ( image_count > 10 * mng_info -> image_found ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>No<S2SV_blank>beginning\" ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"Linked<S2SV_blank>list<S2SV_blank>is<S2SV_blank>corrupted,<S2SV_blank>beginning<S2SV_blank>of<S2SV_blank>list<S2SV_blank>not<S2SV_blank>found\" , \"`%s\\'\" , image_info -> filename ) ; return ( DestroyImageList ( image ) ) ; } image = GetPreviousImageInList ( image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Corrupt<S2SV_blank>list\" ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"Linked<S2SV_blank>list<S2SV_blank>is<S2SV_blank>corrupted;<S2SV_blank>next_image<S2SV_blank>is<S2SV_blank>NULL\" , \"`%s\\'\" , image_info -> filename ) ; } } if ( mng_info -> ticks_per_second && mng_info -> image_found > 1 && GetNextImageInList ( image ) == ( Image * ) NULL ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>First<S2SV_blank>image<S2SV_blank>null\" ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"image->next<S2SV_blank>for<S2SV_blank>first<S2SV_blank>image<S2SV_blank>is<S2SV_blank>NULL<S2SV_blank>but<S2SV_blank>shouldn\\'t<S2SV_blank>be.\" , \"`%s\\'\" , image_info -> filename ) ; } if ( mng_info -> image_found == 0 ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>No<S2SV_blank>visible<S2SV_blank>images<S2SV_blank>found.\" ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CoderError , \"No<S2SV_blank>visible<S2SV_blank>images<S2SV_blank>in<S2SV_blank>file\" , \"`%s\\'\" , image_info -> filename ) ; return ( DestroyImageList ( image ) ) ; } if ( mng_info -> ticks_per_second ) final_delay = 1UL * MagickMax ( image -> ticks_per_second , 1L ) * final_delay / mng_info -> ticks_per_second ; else image -> start_loop = MagickTrue ; final_image_delay = 0 ; while ( GetNextImageInList ( image ) != ( Image * ) NULL ) { if ( image -> delay ) final_image_delay = image -> delay ; image = GetNextImageInList ( image ) ; } if ( final_delay < final_image_delay ) final_delay = final_image_delay ; image -> delay = final_delay ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>image->delay=%.20g,<S2SV_blank>final_delay=%.20g\" , ( double ) image -> delay , ( double ) final_delay ) ; if ( logging != MagickFalse ) { int scene ; scene = 0 ; image = GetFirstImageInList ( image ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Before<S2SV_blank>coalesce:\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>scene<S2SV_blank>0<S2SV_blank>delay=%.20g\" , ( double ) image -> delay ) ; while ( GetNextImageInList ( image ) != ( Image * ) NULL ) { image = GetNextImageInList ( image ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>scene<S2SV_blank>%.20g<S2SV_blank>delay=%.20g\" , ( double ) scene ++ , ( double ) image -> delay ) ; } } image = GetFirstImageInList ( image ) ; # ifdef MNG_COALESCE_LAYERS if ( insert_layers ) { Image * next_image , * next ; size_t scene ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Coalesce<S2SV_blank>Images\" ) ; scene = image -> scene ; next_image = CoalesceImages ( image , exception ) ; if ( next_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; image = DestroyImageList ( image ) ; image = next_image ; for ( next = image ; next != ( Image * ) NULL ; next = next_image ) { next -> page . width = mng_info -> mng_width ; next -> page . height = mng_info -> mng_height ; next -> page . x = 0 ; next -> page . y = 0 ; next -> scene = scene ++ ; next_image = GetNextImageInList ( next ) ; if ( next_image == ( Image * ) NULL ) break ; if ( next -> delay == 0 ) { scene -- ; next_image -> previous = GetPreviousImageInList ( next ) ; if ( GetPreviousImageInList ( next ) == ( Image * ) NULL ) image = next_image ; else next -> previous -> next = next_image ; next = DestroyImage ( next ) ; } } } # endif while ( GetNextImageInList ( image ) != ( Image * ) NULL ) image = GetNextImageInList ( image ) ; image -> dispose = BackgroundDispose ; if ( logging != MagickFalse ) { int scene ; scene = 0 ; image = GetFirstImageInList ( image ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>After<S2SV_blank>coalesce:\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>scene<S2SV_blank>0<S2SV_blank>delay=%.20g<S2SV_blank>dispose=%.20g\" , ( double ) image -> delay , ( double ) image -> dispose ) ; while ( GetNextImageInList ( image ) != ( Image * ) NULL ) { image = GetNextImageInList ( image ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>scene<S2SV_blank>%.20g<S2SV_blank>delay=%.20g<S2SV_blank>dispose=%.20g\" , ( double ) scene ++ , ( double ) image -> delay , ( double ) image -> dispose ) ; } } if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>exit<S2SV_blank>ReadOneMNGImage();\" ) ; return ( image ) ; }", "target": "<S2SV_ModStart> ++ ) { if ( ( i < 0 ) || ( i >= MNG_MAX_OBJECTS ) ) continue ;"}
{"source": "CWE-787 static pj_status_t parse_query ( pj_dns_parsed_query * q , pj_pool_t * pool , const pj_uint8_t * pkt , const pj_uint8_t * start , const pj_uint8_t * max , int * parsed_len ) { const pj_uint8_t * p = start ; int name_len , name_part_len ; pj_status_t status ; status = get_name_len ( 0 , pkt , start , max , & name_part_len , & name_len ) ; if ( status != PJ_SUCCESS ) return status ; q -> name . ptr = ( char * ) pj_pool_alloc ( pool , name_len + 4 ) ; q -> name . slen = 0 ; status = get_name ( 0 , pkt , start , max , & q -> name ) ; if ( status != PJ_SUCCESS ) return status ; p = ( start + name_part_len ) ; <S2SV_StartBug> pj_memcpy ( & q -> type , p , 2 ) ; <S2SV_EndBug> q -> type = pj_ntohs ( q -> type ) ; p += 2 ; pj_memcpy ( & q -> dnsclass , p , 2 ) ; q -> dnsclass = pj_ntohs ( q -> dnsclass ) ; p += 2 ; * parsed_len = ( int ) ( p - start ) ; return PJ_SUCCESS ; }", "target": "<S2SV_ModStart> name_part_len ) ; if ( p + 4 > max ) return PJLIB_UTIL_EDNSINSIZE ;"}
{"source": "CWE-787 void Compute ( OpKernelContext * ctx ) override { const Tensor * hypothesis_indices ; const Tensor * hypothesis_values ; const Tensor * hypothesis_shape ; const Tensor * truth_indices ; const Tensor * truth_values ; const Tensor * truth_shape ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"hypothesis_indices\" , & hypothesis_indices ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"hypothesis_values\" , & hypothesis_values ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"hypothesis_shape\" , & hypothesis_shape ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"truth_indices\" , & truth_indices ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"truth_values\" , & truth_values ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"truth_shape\" , & truth_shape ) ) ; OP_REQUIRES_OK ( ctx , ValidateShapes ( ctx , * hypothesis_indices , * hypothesis_values , * hypothesis_shape , * truth_indices , * truth_values , * truth_shape ) ) ; TensorShape hypothesis_st_shape ; OP_REQUIRES_OK ( ctx , TensorShapeUtils : : MakeShape ( hypothesis_shape -> vec < int64_t > ( ) . data ( ) , hypothesis_shape -> NumElements ( ) , & hypothesis_st_shape ) ) ; TensorShape truth_st_shape ; OP_REQUIRES_OK ( ctx , TensorShapeUtils : : MakeShape ( truth_shape -> vec < int64_t > ( ) . data ( ) , truth_shape -> NumElements ( ) , & truth_st_shape ) ) ; std : : vector < int64_t > sorted_order ( truth_st_shape . dims ( ) ) ; std : : iota ( sorted_order . begin ( ) , sorted_order . end ( ) , 0 ) ; sparse : : SparseTensor hypothesis ; OP_REQUIRES_OK ( ctx , sparse : : SparseTensor : : Create ( * hypothesis_indices , * hypothesis_values , hypothesis_st_shape , sorted_order , & hypothesis ) ) ; sparse : : SparseTensor truth ; OP_REQUIRES_OK ( ctx , sparse : : SparseTensor : : Create ( * truth_indices , * truth_values , truth_st_shape , sorted_order , & truth ) ) ; std : : vector < int64_t > group_dims ( truth_st_shape . dims ( ) - 1 ) ; std : : iota ( group_dims . begin ( ) , group_dims . end ( ) , 0 ) ; TensorShape output_shape ; for ( int d = 0 ; d < static_cast < int > ( group_dims . size ( ) ) ; ++ d ) { output_shape . AddDim ( std : : max ( hypothesis_st_shape . dim_size ( d ) , truth_st_shape . dim_size ( d ) ) ) ; } const auto output_elements = output_shape . num_elements ( ) ; OP_REQUIRES ( ctx , output_elements > 0 , errors : : InvalidArgument ( \"Got<S2SV_blank>output<S2SV_blank>shape<S2SV_blank>\" , output_shape . DebugString ( ) , \"<S2SV_blank>which<S2SV_blank>has<S2SV_blank>0<S2SV_blank>elements\" ) ) ; Tensor * output = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( \"output\" , output_shape , & output ) ) ; auto output_t = output -> flat < float > ( ) ; output_t . setZero ( ) ; std : : vector < int64_t > output_strides ( output_shape . dims ( ) ) ; output_strides [ output_shape . dims ( ) - 1 ] = 1 ; for ( int d = output_shape . dims ( ) - 2 ; d >= 0 ; -- d ) { output_strides [ d ] = output_strides [ d + 1 ] * output_shape . dim_size ( d + 1 ) ; } auto hypothesis_grouper = hypothesis . group ( group_dims ) ; auto truth_grouper = truth . group ( group_dims ) ; auto hypothesis_iter = hypothesis_grouper . begin ( ) ; auto truth_iter = truth_grouper . begin ( ) ; auto cmp = std : : equal_to < T > ( ) ; while ( hypothesis_iter != hypothesis_grouper . end ( ) && truth_iter != truth_grouper . end ( ) ) { sparse : : Group truth_i = * truth_iter ; sparse : : Group hypothesis_j = * hypothesis_iter ; std : : vector < int64_t > g_truth = truth_i . group ( ) ; std : : vector < int64_t > g_hypothesis = hypothesis_j . group ( ) ; auto truth_seq = truth_i . values < T > ( ) ; auto hypothesis_seq = hypothesis_j . values < T > ( ) ; if ( g_truth == g_hypothesis ) { auto loc = std : : inner_product ( g_truth . begin ( ) , g_truth . end ( ) , output_strides . begin ( ) , int64_t { 0 } ) ; OP_REQUIRES ( <S2SV_StartBug> ctx , loc < output_elements , <S2SV_EndBug> errors : : Internal ( \"Got<S2SV_blank>an<S2SV_blank>inner<S2SV_blank>product<S2SV_blank>\" , loc , <S2SV_StartBug> \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>\" <S2SV_EndBug> \"the<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements , \")\" ) ) ; output_t ( loc ) = gtl : : LevenshteinDistance < T > ( truth_seq , hypothesis_seq , cmp ) ; if ( normalize_ ) output_t ( loc ) /= truth_seq . size ( ) ; ++ hypothesis_iter ; ++ truth_iter ; } else if ( g_truth > g_hypothesis ) { auto loc = std : : inner_product ( g_hypothesis . begin ( ) , g_hypothesis . end ( ) , output_strides . begin ( ) , int64_t { 0 } ) ; OP_REQUIRES ( <S2SV_StartBug> ctx , loc < output_elements , <S2SV_EndBug> errors : : Internal ( \"Got<S2SV_blank>an<S2SV_blank>inner<S2SV_blank>product<S2SV_blank>\" , loc , <S2SV_StartBug> \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>\" <S2SV_EndBug> \"the<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements , \")\" ) ) ; output_t ( loc ) = hypothesis_seq . size ( ) ; if ( normalize_ && output_t ( loc ) != 0.0f ) { output_t ( loc ) = std : : numeric_limits < float > : : infinity ( ) ; } ++ hypothesis_iter ; } else { auto loc = std : : inner_product ( g_truth . begin ( ) , g_truth . end ( ) , output_strides . begin ( ) , int64_t { 0 } ) ; OP_REQUIRES ( <S2SV_StartBug> ctx , loc < output_elements , <S2SV_EndBug> errors : : Internal ( \"Got<S2SV_blank>an<S2SV_blank>inner<S2SV_blank>product<S2SV_blank>\" , loc , <S2SV_StartBug> \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>\" <S2SV_EndBug> \"the<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements , \")\" ) ) ; output_t ( loc ) = ( normalize_ ) ? 1.0 : truth_seq . size ( ) ; ++ truth_iter ; } } while ( hypothesis_iter != hypothesis_grouper . end ( ) ) { sparse : : Group hypothesis_j = * hypothesis_iter ; std : : vector < int64_t > g_hypothesis = hypothesis_j . group ( ) ; auto hypothesis_seq = hypothesis_j . values < T > ( ) ; auto loc = std : : inner_product ( g_hypothesis . begin ( ) , g_hypothesis . end ( ) , output_strides . begin ( ) , int64_t { 0 } ) ; OP_REQUIRES ( <S2SV_StartBug> ctx , loc < output_elements , <S2SV_EndBug> errors : : Internal ( \"Got<S2SV_blank>an<S2SV_blank>inner<S2SV_blank>product<S2SV_blank>\" , loc , <S2SV_StartBug> \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>the<S2SV_blank>\" <S2SV_EndBug> \"buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements , \")\" ) ) ; output_t ( loc ) = hypothesis_seq . size ( ) ; if ( normalize_ && output_t ( loc ) != 0.0f ) { output_t ( loc ) = std : : numeric_limits < float > : : infinity ( ) ; } ++ hypothesis_iter ; } while ( truth_iter != truth_grouper . end ( ) ) { sparse : : Group truth_i = * truth_iter ; std : : vector < int64_t > g_truth = truth_i . group ( ) ; auto truth_seq = truth_i . values < T > ( ) ; auto loc = std : : inner_product ( g_truth . begin ( ) , g_truth . end ( ) , output_strides . begin ( ) , int64_t { 0 } ) ; OP_REQUIRES ( <S2SV_StartBug> ctx , loc < output_elements , <S2SV_EndBug> errors : : Internal ( \"Got<S2SV_blank>an<S2SV_blank>inner<S2SV_blank>product<S2SV_blank>\" , loc , <S2SV_StartBug> \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>in<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>the<S2SV_blank>\" <S2SV_EndBug> \"buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements , \")\" ) ) ; output_t ( loc ) = ( normalize_ ) ? 1.0 : truth_seq . size ( ) ; ++ truth_iter ; } }", "target": "<S2SV_ModStart> ( ctx , 0 <= loc && <S2SV_ModStart> , loc , \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>\" <S2SV_ModEnd> \"the<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements <S2SV_ModStart> ( ctx , 0 <= loc && <S2SV_ModStart> , loc , \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>\" <S2SV_ModEnd> \"the<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements <S2SV_ModStart> ( ctx , 0 <= loc && <S2SV_ModStart> , loc , \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>\" <S2SV_ModEnd> \"the<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements <S2SV_ModStart> ( ctx , 0 <= loc && <S2SV_ModStart> , loc , \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>the<S2SV_blank>\" <S2SV_ModEnd> \"buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements <S2SV_ModStart> ( ctx , 0 <= loc && <S2SV_ModStart> , loc , \"<S2SV_blank>which<S2SV_blank>would<S2SV_blank>require<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>the<S2SV_blank>\" <S2SV_ModEnd> \"buffer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>tensor<S2SV_blank>(max<S2SV_blank>elements<S2SV_blank>\" , output_elements"}
{"source": "CWE-703 GF_Err diST_box_read ( GF_Box * s , GF_BitStream * bs ) { <S2SV_StartBug> u32 i ; <S2SV_EndBug> char str [ 1024 ] ; GF_DIMSScriptTypesBox * p = ( GF_DIMSScriptTypesBox * ) s ; <S2SV_StartBug> i = 0 ; <S2SV_EndBug> str [ 0 ] = 0 ; while ( 1 ) { str [ i ] = gf_bs_read_u8 ( bs ) ; <S2SV_StartBug> if ( ! str [ i ] ) break ; <S2SV_EndBug> i ++ ; } ISOM_DECREASE_SIZE ( p , i ) ; <S2SV_StartBug> p -> content_script_types = gf_strdup ( str ) ; <S2SV_EndBug> return GF_OK ; }", "target": "<S2SV_ModStart> bs ) { <S2SV_ModEnd> GF_DIMSScriptTypesBox * p <S2SV_ModStart> ) s ; p -> content_script_types = gf_malloc ( sizeof ( char ) * ( s -> size + 1 ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! p -> content_script_types ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , p -> content_script_types , s -> size <S2SV_ModEnd> ) ; p <S2SV_ModStart> p -> content_script_types [ s -> size ] = 0 <S2SV_ModEnd> ; return GF_OK"}
{"source": "CWE-269 lsquic_qeh_settings ( struct qpack_enc_hdl * qeh , unsigned max_table_size , unsigned dyn_table_size , unsigned max_risked_streams , int server ) { enum lsqpack_enc_opts enc_opts ; assert ( qeh -> qeh_flags & QEH_INITIALIZED ) ; if ( qeh -> qeh_flags & QEH_HAVE_SETTINGS ) { LSQ_WARN ( \"settings<S2SV_blank>already<S2SV_blank>set\" ) ; return - 1 ; } enc_opts = LSQPACK_ENC_OPT_STAGE_2 | ( server ? LSQPACK_ENC_OPT_SERVER : 0 ) ; qeh -> qeh_tsu_sz = sizeof ( qeh -> qeh_tsu_buf ) ; <S2SV_StartBug> if ( 0 != lsqpack_enc_init ( & qeh -> qeh_encoder , ( void * ) qeh -> qeh_conn , <S2SV_EndBug> max_table_size , dyn_table_size , max_risked_streams , enc_opts , qeh -> qeh_tsu_buf , & qeh -> qeh_tsu_sz ) ) { LSQ_INFO ( \"could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>QPACK<S2SV_blank>encoder\" ) ; return - 1 ; } LSQ_DEBUG ( \"%zu-byte<S2SV_blank>post-init<S2SV_blank>TSU\" , qeh -> qeh_tsu_sz ) ; qeh -> qeh_flags |= QEH_HAVE_SETTINGS ; qeh -> qeh_max_prefix_size = lsqpack_enc_header_block_prefix_size ( & qeh -> qeh_encoder ) ; LSQ_DEBUG ( \"have<S2SV_blank>settings:<S2SV_blank>max<S2SV_blank>table<S2SV_blank>size=%u;<S2SV_blank>dyn<S2SV_blank>table<S2SV_blank>size=%u;<S2SV_blank>max<S2SV_blank>risked<S2SV_blank>\" \"streams=%u\" , max_table_size , dyn_table_size , max_risked_streams ) ; if ( qeh -> qeh_enc_sm_out ) qeh_begin_out ( qeh ) ; return 0 ; }", "target": "<S2SV_ModStart> ; if ( QENC_MIN_DYN_TABLE_SIZE > dyn_table_size ) dyn_table_size = 0 ; if ("}
{"source": "CWE-200 int digest_generic_verify ( struct digest * d , const unsigned char * md ) { int ret ; int len = digest_length ( d ) ; unsigned char * tmp ; tmp = xmalloc ( len ) ; ret = digest_final ( d , tmp ) ; if ( ret ) goto end ; <S2SV_StartBug> ret = memcmp ( md , tmp , len ) ; <S2SV_EndBug> ret = ret ? - EINVAL : 0 ; end : free ( tmp ) ; return ret ; }", "target": "<S2SV_ModStart> goto end ; if ( crypto_memneq <S2SV_ModEnd> ( md , <S2SV_ModStart> , len ) ) ret = - EINVAL ; else ret = <S2SV_ModEnd> 0 ; end"}
{"source": "CWE-416 find_pattern_in_path ( char_u * ptr , int dir UNUSED , int len , int whole , int skip_comments , int type , long count , int action , linenr_T start_lnum , linenr_T end_lnum ) { SearchedFile * files ; SearchedFile * bigger ; int max_path_depth = 50 ; long match_count = 1 ; char_u * pat ; char_u * new_fname ; char_u * curr_fname = curbuf -> b_fname ; char_u * prev_fname = NULL ; linenr_T lnum ; int depth ; int depth_displayed ; int old_files ; int already_searched ; char_u * file_line ; char_u * line ; char_u * p ; char_u save_char ; int define_matched ; regmatch_T regmatch ; regmatch_T incl_regmatch ; regmatch_T def_regmatch ; int matched = FALSE ; int did_show = FALSE ; int found = FALSE ; int i ; char_u * already = NULL ; char_u * startp = NULL ; char_u * inc_opt = NULL ; # if defined ( FEAT_QUICKFIX ) win_T * curwin_save = NULL ; # endif regmatch . regprog = NULL ; incl_regmatch . regprog = NULL ; def_regmatch . regprog = NULL ; file_line = alloc ( LSIZE ) ; if ( file_line == NULL ) return ; if ( type != CHECK_PATH && type != FIND_DEFINE && ! compl_status_sol ( ) ) { pat = alloc ( len + 5 ) ; if ( pat == NULL ) goto fpip_end ; sprintf ( ( char * ) pat , whole ? \"\\\\\\\\<%.*s\\\\\\\\>\" : \"%.*s\" , len , ptr ) ; regmatch . rm_ic = ignorecase ( pat ) ; regmatch . regprog = vim_regcomp ( pat , magic_isset ( ) ? RE_MAGIC : 0 ) ; vim_free ( pat ) ; if ( regmatch . regprog == NULL ) goto fpip_end ; } inc_opt = ( * curbuf -> b_p_inc == NUL ) ? p_inc : curbuf -> b_p_inc ; if ( * inc_opt != NUL ) { incl_regmatch . regprog = vim_regcomp ( inc_opt , magic_isset ( ) ? RE_MAGIC : 0 ) ; if ( incl_regmatch . regprog == NULL ) goto fpip_end ; incl_regmatch . rm_ic = FALSE ; } if ( type == FIND_DEFINE && ( * curbuf -> b_p_def != NUL || * p_def != NUL ) ) { def_regmatch . regprog = vim_regcomp ( * curbuf -> b_p_def == NUL ? p_def : curbuf -> b_p_def , magic_isset ( ) ? RE_MAGIC : 0 ) ; if ( def_regmatch . regprog == NULL ) goto fpip_end ; def_regmatch . rm_ic = FALSE ; } files = lalloc_clear ( max_path_depth * sizeof ( SearchedFile ) , TRUE ) ; if ( files == NULL ) goto fpip_end ; old_files = max_path_depth ; depth = depth_displayed = - 1 ; lnum = start_lnum ; if ( end_lnum > curbuf -> b_ml . ml_line_count ) end_lnum = curbuf -> b_ml . ml_line_count ; if ( lnum > end_lnum ) lnum = end_lnum ; <S2SV_StartBug> line = ml_get ( lnum ) ; <S2SV_EndBug> for ( ; ; ) { if ( incl_regmatch . regprog != NULL && vim_regexec ( & incl_regmatch , line , ( colnr_T ) 0 ) ) { char_u * p_fname = ( curr_fname == curbuf -> b_fname ) ? curbuf -> b_ffname : curr_fname ; if ( inc_opt != NULL && strstr ( ( char * ) inc_opt , \"\\\\\\\\zs\" ) != NULL ) new_fname = find_file_name_in_path ( incl_regmatch . startp [ 0 ] , ( int ) ( incl_regmatch . endp [ 0 ] - incl_regmatch . startp [ 0 ] ) , FNAME_EXP | FNAME_INCL | FNAME_REL , 1L , p_fname ) ; else new_fname = file_name_in_line ( incl_regmatch . endp [ 0 ] , 0 , FNAME_EXP | FNAME_INCL | FNAME_REL , 1L , p_fname , NULL ) ; already_searched = FALSE ; if ( new_fname != NULL ) { for ( i = 0 ; ; i ++ ) { if ( i == depth + 1 ) i = old_files ; if ( i == max_path_depth ) break ; if ( fullpathcmp ( new_fname , files [ i ] . name , TRUE , TRUE ) & FPC_SAME ) { if ( type != CHECK_PATH && action == ACTION_SHOW_ALL && files [ i ] . matched ) { msg_putchar ( '\\\\n' ) ; if ( ! got_int ) { msg_home_replace_hl ( new_fname ) ; msg_puts ( _ ( \"<S2SV_blank>(includes<S2SV_blank>previously<S2SV_blank>listed<S2SV_blank>match)\" ) ) ; prev_fname = NULL ; } } VIM_CLEAR ( new_fname ) ; already_searched = TRUE ; break ; } } } if ( type == CHECK_PATH && ( action == ACTION_SHOW_ALL || ( new_fname == NULL && ! already_searched ) ) ) { if ( did_show ) msg_putchar ( '\\\\n' ) ; else { gotocmdline ( TRUE ) ; msg_puts_title ( _ ( \"---<S2SV_blank>Included<S2SV_blank>files<S2SV_blank>\" ) ) ; if ( action != ACTION_SHOW_ALL ) msg_puts_title ( _ ( \"not<S2SV_blank>found<S2SV_blank>\" ) ) ; msg_puts_title ( _ ( \"in<S2SV_blank>path<S2SV_blank>---\\\\n\" ) ) ; } did_show = TRUE ; while ( depth_displayed < depth && ! got_int ) { ++ depth_displayed ; for ( i = 0 ; i < depth_displayed ; i ++ ) msg_puts ( \"<S2SV_blank><S2SV_blank>\" ) ; msg_home_replace ( files [ depth_displayed ] . name ) ; msg_puts ( \"<S2SV_blank>-->\\\\n\" ) ; } if ( ! got_int ) { for ( i = 0 ; i <= depth_displayed ; i ++ ) msg_puts ( \"<S2SV_blank><S2SV_blank>\" ) ; if ( new_fname != NULL ) { msg_outtrans_attr ( new_fname , HL_ATTR ( HLF_D ) ) ; } else { if ( inc_opt != NULL && strstr ( ( char * ) inc_opt , \"\\\\\\\\zs\" ) != NULL ) { p = incl_regmatch . startp [ 0 ] ; i = ( int ) ( incl_regmatch . endp [ 0 ] - incl_regmatch . startp [ 0 ] ) ; } else { for ( p = incl_regmatch . endp [ 0 ] ; * p && ! vim_isfilec ( * p ) ; p ++ ) ; for ( i = 0 ; vim_isfilec ( p [ i ] ) ; i ++ ) ; } if ( i == 0 ) { p = incl_regmatch . endp [ 0 ] ; i = ( int ) STRLEN ( p ) ; } else if ( p > line ) { if ( p [ - 1 ] == \\'\"\\' || p [ - 1 ] == '<' ) { -- p ; ++ i ; } if ( p [ i ] == \\'\"\\' || p [ i ] == '>' ) ++ i ; } save_char = p [ i ] ; p [ i ] = NUL ; msg_outtrans_attr ( p , HL_ATTR ( HLF_D ) ) ; p [ i ] = save_char ; } if ( new_fname == NULL && action == ACTION_SHOW_ALL ) { if ( already_searched ) msg_puts ( _ ( \"<S2SV_blank><S2SV_blank>(Already<S2SV_blank>listed)\" ) ) ; else msg_puts ( _ ( \"<S2SV_blank><S2SV_blank>NOT<S2SV_blank>FOUND\" ) ) ; } } out_flush ( ) ; } if ( new_fname != NULL ) { if ( depth + 1 == old_files ) { bigger = ALLOC_MULT ( SearchedFile , max_path_depth * 2 ) ; if ( bigger != NULL ) { for ( i = 0 ; i <= depth ; i ++ ) bigger [ i ] = files [ i ] ; for ( i = depth + 1 ; i < old_files + max_path_depth ; i ++ ) { bigger [ i ] . fp = NULL ; bigger [ i ] . name = NULL ; bigger [ i ] . lnum = 0 ; bigger [ i ] . matched = FALSE ; } for ( i = old_files ; i < max_path_depth ; i ++ ) bigger [ i + max_path_depth ] = files [ i ] ; old_files += max_path_depth ; max_path_depth *= 2 ; vim_free ( files ) ; files = bigger ; } } if ( ( files [ depth + 1 ] . fp = mch_fopen ( ( char * ) new_fname , \"r\" ) ) == NULL ) vim_free ( new_fname ) ; else { if ( ++ depth == old_files ) { vim_free ( files [ old_files ] . name ) ; ++ old_files ; } files [ depth ] . name = curr_fname = new_fname ; files [ depth ] . lnum = 0 ; files [ depth ] . matched = FALSE ; if ( action == ACTION_EXPAND ) { msg_hist_off = TRUE ; vim_snprintf ( ( char * ) IObuff , IOSIZE , _ ( \"Scanning<S2SV_blank>included<S2SV_blank>file:<S2SV_blank>%s\" ) , ( char * ) new_fname ) ; msg_trunc_attr ( ( char * ) IObuff , TRUE , HL_ATTR ( HLF_R ) ) ; } else if ( p_verbose >= 5 ) { verbose_enter ( ) ; smsg ( _ ( \"Searching<S2SV_blank>included<S2SV_blank>file<S2SV_blank>%s\" ) , ( char * ) new_fname ) ; verbose_leave ( ) ; } } } } else { p = line ; search_line : define_matched = FALSE ; if ( def_regmatch . regprog != NULL && vim_regexec ( & def_regmatch , line , ( colnr_T ) 0 ) ) { p = def_regmatch . endp [ 0 ] ; while ( * p && ! vim_iswordc ( * p ) ) p ++ ; define_matched = TRUE ; } if ( def_regmatch . regprog == NULL || define_matched ) { if ( define_matched || compl_status_sol ( ) ) { startp = skipwhite ( p ) ; if ( p_ic ) matched = ! MB_STRNICMP ( startp , ptr , len ) ; else matched = ! STRNCMP ( startp , ptr , len ) ; if ( matched && define_matched && whole && vim_iswordc ( startp [ len ] ) ) matched = FALSE ; } else if ( regmatch . regprog != NULL && vim_regexec ( & regmatch , line , ( colnr_T ) ( p - line ) ) ) { matched = TRUE ; startp = regmatch . startp [ 0 ] ; if ( ! define_matched && skip_comments ) { if ( ( * line != '#' || STRNCMP ( skipwhite ( line + 1 ) , \"define\" , 6 ) != 0 ) && get_leader_len ( line , NULL , FALSE , TRUE ) ) matched = FALSE ; p = skipwhite ( line ) ; if ( matched || ( p [ 0 ] == '/' && p [ 1 ] == '*' ) || p [ 0 ] == '*' ) for ( p = line ; * p && p < startp ; ++ p ) { if ( matched && p [ 0 ] == '/' && ( p [ 1 ] == '*' || p [ 1 ] == '/' ) ) { matched = FALSE ; if ( p [ 1 ] == '/' ) break ; ++ p ; } else if ( ! matched && p [ 0 ] == '*' && p [ 1 ] == '/' ) { matched = TRUE ; ++ p ; } } } } } } if ( matched ) { if ( action == ACTION_EXPAND ) { int cont_s_ipos = FALSE ; int add_r ; char_u * aux ; if ( depth == - 1 && lnum == curwin -> w_cursor . lnum ) break ; found = TRUE ; aux = p = startp ; if ( compl_status_adding ( ) ) { p += ins_compl_len ( ) ; if ( vim_iswordp ( p ) ) goto exit_matched ; p = find_word_start ( p ) ; } p = find_word_end ( p ) ; i = ( int ) ( p - aux ) ; if ( compl_status_adding ( ) && i == ins_compl_len ( ) ) { STRNCPY ( IObuff , aux , i ) ; if ( depth < 0 ) { if ( lnum >= end_lnum ) goto exit_matched ; <S2SV_StartBug> line = ml_get ( ++ lnum ) ; <S2SV_EndBug> } else if ( vim_fgets ( line = file_line , LSIZE , files [ depth ] . fp ) ) goto exit_matched ; already = aux = p = skipwhite ( line ) ; p = find_word_start ( p ) ; p = find_word_end ( p ) ; if ( p > aux ) { if ( * aux != ')' && IObuff [ i - 1 ] != TAB ) { if ( IObuff [ i - 1 ] != '<S2SV_blank>' ) IObuff [ i ++ ] = '<S2SV_blank>' ; if ( p_js && ( IObuff [ i - 2 ] == '.' || ( vim_strchr ( p_cpo , CPO_JOINSP ) == NULL && ( IObuff [ i - 2 ] == '?' || IObuff [ i - 2 ] == '!' ) ) ) ) IObuff [ i ++ ] = '<S2SV_blank>' ; } if ( p - aux >= IOSIZE - i ) p = aux + IOSIZE - i - 1 ; STRNCPY ( IObuff + i , aux , p - aux ) ; i += ( int ) ( p - aux ) ; cont_s_ipos = TRUE ; } IObuff [ i ] = NUL ; aux = IObuff ; if ( i == ins_compl_len ( ) ) goto exit_matched ; } add_r = ins_compl_add_infercase ( aux , i , p_ic , curr_fname == curbuf -> b_fname ? NULL : curr_fname , dir , cont_s_ipos ) ; if ( add_r == OK ) dir = FORWARD ; else if ( add_r == FAIL ) break ; } else if ( action == ACTION_SHOW_ALL ) { found = TRUE ; if ( ! did_show ) gotocmdline ( TRUE ) ; if ( curr_fname != prev_fname ) { if ( did_show ) msg_putchar ( '\\\\n' ) ; if ( ! got_int ) msg_home_replace_hl ( curr_fname ) ; prev_fname = curr_fname ; } did_show = TRUE ; if ( ! got_int ) show_pat_in_path ( line , type , TRUE , action , ( depth == - 1 ) ? NULL : files [ depth ] . fp , ( depth == - 1 ) ? & lnum : & files [ depth ] . lnum , match_count ++ ) ; for ( i = 0 ; i <= depth ; ++ i ) files [ i ] . matched = TRUE ; } else if ( -- count <= 0 ) { found = TRUE ; if ( depth == - 1 && lnum == curwin -> w_cursor . lnum # if defined ( FEAT_QUICKFIX ) && g_do_tagpreview == 0 # endif ) emsg ( _ ( e_match_is_on_current_line ) ) ; else if ( action == ACTION_SHOW ) { show_pat_in_path ( line , type , did_show , action , ( depth == - 1 ) ? NULL : files [ depth ] . fp , ( depth == - 1 ) ? & lnum : & files [ depth ] . lnum , 1L ) ; did_show = TRUE ; } else { # ifdef FEAT_GUI need_mouse_correct = TRUE ; # endif # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) { curwin_save = curwin ; prepare_tagpreview ( TRUE , TRUE , FALSE ) ; } # endif if ( action == ACTION_SPLIT ) { if ( win_split ( 0 , 0 ) == FAIL ) break ; RESET_BINDING ( curwin ) ; } if ( depth == - 1 ) { # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) { if ( ! win_valid ( curwin_save ) ) break ; if ( ! GETFILE_SUCCESS ( getfile ( curwin_save -> w_buffer -> b_fnum , NULL , NULL , TRUE , lnum , FALSE ) ) ) break ; } else # endif setpcmark ( ) ; curwin -> w_cursor . lnum = lnum ; check_cursor ( ) ; } else { if ( ! GETFILE_SUCCESS ( getfile ( 0 , files [ depth ] . name , NULL , TRUE , files [ depth ] . lnum , FALSE ) ) ) break ; curwin -> w_cursor . lnum = files [ depth ] . lnum ; } } if ( action != ACTION_SHOW ) { curwin -> w_cursor . col = ( colnr_T ) ( startp - line ) ; curwin -> w_set_curswant = TRUE ; } # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 && curwin != curwin_save && win_valid ( curwin_save ) ) { validate_cursor ( ) ; redraw_later ( VALID ) ; win_enter ( curwin_save , TRUE ) ; } # ifdef FEAT_PROP_POPUP else if ( WIN_IS_POPUP ( curwin ) ) win_enter ( firstwin , TRUE ) ; # endif # endif break ; } exit_matched : matched = FALSE ; if ( def_regmatch . regprog == NULL && action == ACTION_EXPAND && ! compl_status_sol ( ) && * startp != NUL && * ( p = startp + mb_ptr2len ( startp ) ) != NUL ) goto search_line ; } line_breakcheck ( ) ; if ( action == ACTION_EXPAND ) ins_compl_check_keys ( 30 , FALSE ) ; if ( got_int || ins_compl_interrupted ( ) ) break ; while ( depth >= 0 && ! already && vim_fgets ( line = file_line , LSIZE , files [ depth ] . fp ) ) { fclose ( files [ depth ] . fp ) ; -- old_files ; files [ old_files ] . name = files [ depth ] . name ; files [ old_files ] . matched = files [ depth ] . matched ; -- depth ; curr_fname = ( depth == - 1 ) ? curbuf -> b_fname : files [ depth ] . name ; if ( depth < depth_displayed ) depth_displayed = depth ; } if ( depth >= 0 ) { files [ depth ] . lnum ++ ; i = ( int ) STRLEN ( line ) ; if ( i > 0 && line [ i - 1 ] == '\\\\n' ) line [ -- i ] = NUL ; if ( i > 0 && line [ i - 1 ] == '\\\\r' ) line [ -- i ] = NUL ; } else if ( ! already ) { if ( ++ lnum > end_lnum ) break ; <S2SV_StartBug> line = ml_get ( lnum ) ; <S2SV_EndBug> } already = NULL ; } for ( i = 0 ; i <= depth ; i ++ ) { fclose ( files [ i ] . fp ) ; vim_free ( files [ i ] . name ) ; } for ( i = old_files ; i < max_path_depth ; i ++ ) vim_free ( files [ i ] . name ) ; vim_free ( files ) ; if ( type == CHECK_PATH ) { if ( ! did_show ) { if ( action != ACTION_SHOW_ALL ) msg ( _ ( \"All<S2SV_blank>included<S2SV_blank>files<S2SV_blank>were<S2SV_blank>found\" ) ) ; else msg ( _ ( \"No<S2SV_blank>included<S2SV_blank>files\" ) ) ; } } else if ( ! found && action != ACTION_EXPAND ) { if ( got_int || ins_compl_interrupted ( ) ) emsg ( _ ( e_interrupted ) ) ; else if ( type == FIND_DEFINE ) emsg ( _ ( e_couldnt_find_definition ) ) ; else emsg ( _ ( e_couldnt_find_pattern ) ) ; } if ( action == ACTION_SHOW || action == ACTION_SHOW_ALL ) msg_end ( ) ; fpip_end : vim_free ( file_line ) ; vim_regfree ( regmatch . regprog ) ; vim_regfree ( incl_regmatch . regprog ) ; vim_regfree ( def_regmatch . regprog ) ; }", "target": "<S2SV_ModStart> ; line = get_line_and_copy ( lnum , file_line <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; line = get_line_and_copy <S2SV_ModEnd> ( ++ lnum <S2SV_ModStart> ( ++ lnum , file_line <S2SV_ModStart> ; line = get_line_and_copy ( lnum , file_line <S2SV_ModEnd> ) ; }"}
{"source": "CWE-787 yank_copy_line ( struct block_def * bd , long y_idx , int exclude_trailing_space ) { char_u * pnew ; if ( exclude_trailing_space ) bd -> endspaces = 0 ; if ( ( pnew = alloc ( bd -> startspaces + bd -> endspaces + bd -> textlen + 1 ) ) == NULL ) return FAIL ; y_current -> y_array [ y_idx ] = pnew ; vim_memset ( pnew , '<S2SV_blank>' , ( size_t ) bd -> startspaces ) ; pnew += bd -> startspaces ; mch_memmove ( pnew , bd -> textstart , ( size_t ) bd -> textlen ) ; pnew += bd -> textlen ; vim_memset ( pnew , '<S2SV_blank>' , ( size_t ) bd -> endspaces ) ; pnew += bd -> endspaces ; if ( exclude_trailing_space ) { int s = bd -> textlen + bd -> endspaces ; <S2SV_StartBug> while ( VIM_ISWHITE ( * ( bd -> textstart + s - 1 ) ) && s > 0 ) <S2SV_EndBug> { s = s - ( * mb_head_off ) ( bd -> textstart , bd -> textstart + s - 1 ) - 1 ; pnew -- ; } } * pnew = NUL ; return OK ; }", "target": "<S2SV_ModStart> ; while ( <S2SV_ModEnd> s > 0 <S2SV_ModStart> s > 0 && VIM_ISWHITE ( * ( bd -> textstart + s - 1 ) )"}
{"source": "CWE-369 void DoCompute ( OpKernelContext * c ) { core : : RefCountPtr < Var > v ; OP_REQUIRES_OK ( c , LookupResource ( c , HandleFromInput ( c , 0 ) , & v ) ) ; Tensor * params = v -> tensor ( ) ; const Tensor & indices = c -> input ( 1 ) ; const Tensor & updates = c -> input ( 2 ) ; OP_REQUIRES ( c , updates . dims ( ) == 0 || updates . dims ( ) == indices . dims ( ) + params -> dims ( ) - 1 , errors : : InvalidArgument ( \"Must<S2SV_blank>have<S2SV_blank>updates.shape<S2SV_blank>=<S2SV_blank>indices.shape<S2SV_blank>+<S2SV_blank>\" \"params.shape[1:]<S2SV_blank>or<S2SV_blank>updates.shape<S2SV_blank>=<S2SV_blank>[],<S2SV_blank>got<S2SV_blank>\" , \"updates.shape<S2SV_blank>\" , updates . shape ( ) . DebugString ( ) , \",<S2SV_blank>indices.shape<S2SV_blank>\" , indices . shape ( ) . DebugString ( ) , \",<S2SV_blank>params.shape<S2SV_blank>\" , params -> shape ( ) . DebugString ( ) ) ) ; const int64_t N_big = indices . NumElements ( ) ; OP_REQUIRES ( c , N_big <= std : : numeric_limits < Index > : : max ( ) , errors : : InvalidArgument ( \"indices<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>elements<S2SV_blank>for<S2SV_blank>\" , DataTypeString ( DataTypeToEnum < Index > : : v ( ) ) , \"<S2SV_blank>indexing:<S2SV_blank>\" , N_big , \"<S2SV_blank>><S2SV_blank>\" , std : : numeric_limits < Index > : : max ( ) ) ) ; const Index N = static_cast < Index > ( N_big ) ; OP_REQUIRES ( c , params -> dim_size ( 0 ) <= std : : numeric_limits < Index > : : max ( ) , errors : : InvalidArgument ( \"params.shape[0]<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>\" , DataTypeString ( DataTypeToEnum < Index > : : v ( ) ) , \"<S2SV_blank>indexing:<S2SV_blank>\" , params -> dim_size ( 0 ) , \"<S2SV_blank>><S2SV_blank>\" , <S2SV_StartBug> std : : numeric_limits < Index > : : max ( ) ) ) ; <S2SV_EndBug> if ( N > 0 ) { auto indices_flat = indices . flat < Index > ( ) ; auto params_flat = params -> flat_outer_dims < T > ( ) ; if ( TensorShapeUtils : : IsScalar ( updates . shape ( ) ) ) { const auto update = updates . scalar < T > ( ) ; functor : : ScatterScalarFunctor < Device , T , Index , op > functor ; const Index bad_i = functor ( c , c -> template eigen_device < Device > ( ) , params_flat , update , indices_flat ) ; OP_REQUIRES ( c , bad_i < 0 , errors : : InvalidArgument ( \"indices\" , SliceDebugString ( indices . shape ( ) , bad_i ) , \"<S2SV_blank>=<S2SV_blank>\" , indices_flat ( bad_i ) , \"<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>[0,<S2SV_blank>\" , params -> dim_size ( 0 ) , \")\" ) ) ; } else { int64_t num_updates = updates . NumElements ( ) ; OP_REQUIRES ( c , TensorShapeUtils : : StartsWith ( updates . shape ( ) , indices . shape ( ) ) , errors : : InvalidArgument ( \"The<S2SV_blank>shape<S2SV_blank>of<S2SV_blank>indices<S2SV_blank>(\" , indices . shape ( ) . DebugString ( ) , \")<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>prefix<S2SV_blank>of<S2SV_blank>the<S2SV_blank>shape<S2SV_blank>of<S2SV_blank>updates<S2SV_blank>(\" , updates . shape ( ) . DebugString ( ) , \")\" ) ) ; auto updates_flat = updates . shaped < T , 2 > ( { N , num_updates / N } ) ; functor : : ScatterFunctor < Device , T , Index , op > functor ; const Index bad_i = functor ( c , c -> template eigen_device < Device > ( ) , params_flat , updates_flat , indices_flat ) ; OP_REQUIRES ( c , bad_i < 0 , errors : : InvalidArgument ( \"indices\" , SliceDebugString ( indices . shape ( ) , bad_i ) , \"<S2SV_blank>=<S2SV_blank>\" , indices_flat ( bad_i ) , \"<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>[0,<S2SV_blank>\" , params -> dim_size ( 0 ) , \")\" ) ) ; } } }", "target": "<S2SV_ModStart> ) ) ; if ( isCPUDevice < Device > ( ) && op == tensorflow : : scatter_op : : UpdateOp : : DIV ) { OP_REQUIRES ( c , ValidateInput < T > ( updates ) , errors : : InvalidArgument ( \"updates<S2SV_blank>must<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>0\" ) ) ; }"}
{"source": "CWE-284 static int setup_config ( int type ) { int rv ; rv = read_config ( cl . configfile , type ) ; if ( rv < 0 ) goto out ; <S2SV_StartBug> if ( is_auth_req ( ) ) { <S2SV_EndBug> rv = read_authkey ( ) ; if ( rv < 0 ) goto out ; # if HAVE_LIBGCRYPT if ( ! gcry_check_version ( NULL ) ) { log_error ( \"gcry_check_version\" ) ; rv = - ENOENT ; goto out ; } gcry_control ( GCRYCTL_DISABLE_SECMEM , 0 ) ; gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ; # endif } if ( cl . type == DAEMON && cl . site [ 0 ] ) { if ( ! find_site_by_name ( cl . site , & local , 1 ) ) { log_error ( \"Cannot<S2SV_blank>find<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>in<S2SV_blank>the<S2SV_blank>configuration.\" , cl . site ) ; return - EINVAL ; } local -> local = 1 ; } else find_myself ( NULL , type == CLIENT || type == GEOSTORE ) ; rv = check_config ( type ) ; if ( rv < 0 ) goto out ; if ( ! cl . lockfile [ 0 ] ) { snprintf ( cl . lockfile , sizeof ( cl . lockfile ) - 1 , \"%s/%s.pid\" , BOOTH_RUN_DIR , booth_conf -> name ) ; } out : return rv ; }", "target": "<S2SV_ModStart> ; if ( booth_conf -> authfile [ 0 ] != '\\\\0' <S2SV_ModEnd> ) { rv"}
{"source": "CWE-787 mrb_remove_method ( mrb_state * mrb , struct RClass * c , mrb_sym mid ) { mt_tbl * h ; MRB_CLASS_ORIGIN ( c ) ; h = c -> mt ; <S2SV_StartBug> if ( h && mt_del ( mrb , h , mid ) ) return ; <S2SV_EndBug> mrb_name_error ( mrb , mid , \"method<S2SV_blank>\\'%n\\'<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>in<S2SV_blank>%C\" , mid , c ) ; }", "target": "<S2SV_ModStart> mid ) ) { mrb_mc_clear_by_class ( mrb , c ) ; return ; } <S2SV_ModEnd> mrb_name_error ( mrb"}
{"source": "CWE-354 void ComputeAsync ( OpKernelContext * context , DoneCallback done ) final { const Tensor & input = context -> input ( 0 ) ; const Tensor & rhs = context -> input ( 1 ) ; const int ndims = input . dims ( ) ; const int64 n = input . dim_size ( ndims - 1 ) ; const int64 nrhs = rhs . dim_size ( ndims - 1 ) ; OP_REQUIRES_ASYNC ( context , ndims >= 2 , errors : : InvalidArgument ( \"Input<S2SV_blank>must<S2SV_blank>have<S2SV_blank>rank<S2SV_blank>>=<S2SV_blank>2,<S2SV_blank>got<S2SV_blank>\" , ndims ) , done ) ; OP_REQUIRES_ASYNC ( context , rhs . dims ( ) == ndims , errors : : InvalidArgument ( \"Input<S2SV_blank>and<S2SV_blank>right-hand<S2SV_blank>side<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>rank,<S2SV_blank>got<S2SV_blank>\" , ndims , \"<S2SV_blank>!=<S2SV_blank>\" , rhs . dims ( ) ) , done ) ; OP_REQUIRES_ASYNC ( context , input . dim_size ( ndims - 2 ) == n , <S2SV_StartBug> errors : : InvalidArgument ( \"Input<S2SV_blank>matrices<S2SV_blank>must<S2SV_blank>be<S2SV_blank>squares,<S2SV_blank>got\" , <S2SV_EndBug> input . dim_size ( ndims - 2 ) , \"<S2SV_blank>!=<S2SV_blank>\" , n ) , done ) ; OP_REQUIRES_ASYNC ( context , rhs . dim_size ( ndims - 2 ) == n , errors : : InvalidArgument ( \"Input<S2SV_blank>matrix<S2SV_blank>and<S2SV_blank>right-hand<S2SV_blank>side<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>\" <S2SV_StartBug> \"same<S2SV_blank>number<S2SV_blank>of<S2SV_blank>rows,<S2SV_blank>got\" , <S2SV_EndBug> n , \"<S2SV_blank>!=<S2SV_blank>\" , rhs . dim_size ( ndims - 2 ) ) , <S2SV_StartBug> done ) ; <S2SV_EndBug> Tensor * output ; OP_REQUIRES_OK_ASYNC ( context , context -> forward_input_or_allocate_output ( { 1 } , 0 , rhs . shape ( ) , & output ) , done ) ; if ( input . NumElements ( ) == 0 || rhs . NumElements ( ) == 0 ) { done ( ) ; return ; } std : : unique_ptr < CudaSolver > solver ( new CudaSolver ( context ) ) ; Tensor input_copy ; const GPUDevice & device = context -> eigen_device < GPUDevice > ( ) ; if ( adjoint_ ) { OP_REQUIRES_OK_ASYNC ( context , solver -> allocate_scoped_tensor ( DataTypeToEnum < Scalar > : : value , input . shape ( ) , & input_copy ) , done ) ; OP_REQUIRES_OK_ASYNC ( context , DoMatrixTranspose ( device , input , & input_copy ) , done ) ; } else { OP_REQUIRES_OK_ASYNC ( context , solver -> forward_input_or_allocate_scoped_tensor ( { 0 } , DataTypeToEnum < Scalar > : : value , input . shape ( ) , & input_copy ) , done ) ; if ( ! input . SharesBufferWith ( input_copy ) ) { device . memcpy ( input_copy . flat < Scalar > ( ) . data ( ) , input . flat < Scalar > ( ) . data ( ) , input . NumElements ( ) * sizeof ( Scalar ) ) ; } } auto input_copy_reshaped = input_copy . template flat_inner_dims < Scalar , 3 > ( ) ; const int64 batch_size = input_copy_reshaped . dimension ( 0 ) ; Tensor pivots ; OP_REQUIRES_OK_ASYNC ( context , solver -> allocate_scoped_tensor ( DataTypeToEnum < int > : : value , TensorShape { batch_size , n } , & pivots ) , done ) ; auto pivots_mat = pivots . template matrix < int > ( ) ; std : : vector < DeviceLapackInfo > dev_info ; auto input_copy_ptrs = solver -> GetScratchSpace < uint8 > ( sizeof ( Scalar * ) * batch_size , \"input_copt_ptrs\" , true ) ; const int kMaxMatrixSizeToBatchSizeRatio = 128 ; const bool use_batched_solver = n <= kMaxMatrixSizeToBatchSizeRatio * batch_size ; if ( use_batched_solver ) { const Scalar * * input_copy_ptrs_base = reinterpret_cast < const Scalar * * > ( input_copy_ptrs . mutable_data ( ) ) ; for ( int batch = 0 ; batch < batch_size ; ++ batch ) { input_copy_ptrs_base [ batch ] = & input_copy_reshaped ( batch , 0 , 0 ) ; } dev_info . push_back ( solver -> GetDeviceLapackInfo ( batch_size , \"getrfBatched\" ) ) ; OP_REQUIRES_OK_ASYNC ( context , solver -> GetrfBatched ( n , input_copy_ptrs_base , n , pivots_mat . data ( ) , & dev_info . back ( ) , batch_size ) , done ) ; } else { dev_info . push_back ( solver -> GetDeviceLapackInfo ( batch_size , \"getrf\" ) ) ; for ( int batch = 0 ; batch < batch_size ; ++ batch ) { OP_REQUIRES_OK_ASYNC ( context , solver -> Getrf ( n , n , & input_copy_reshaped ( batch , 0 , 0 ) , n , & pivots_mat ( batch , 0 ) , & dev_info . back ( ) ( batch ) ) , done ) ; } } TensorShape transposed_rhs_shape ( rhs . shape ( ) ) ; transposed_rhs_shape . RemoveLastDims ( 2 ) ; transposed_rhs_shape . AddDim ( nrhs ) ; transposed_rhs_shape . AddDim ( n ) ; Tensor transposed_rhs ; OP_REQUIRES_OK_ASYNC ( context , solver -> allocate_scoped_tensor ( DataTypeToEnum < Scalar > : : value , transposed_rhs_shape , & transposed_rhs ) , done ) ; if ( nrhs > 1 ) { OP_REQUIRES_OK_ASYNC ( context , DoMatrixTranspose ( device , rhs , & transposed_rhs ) , done ) ; } else { device . memcpy ( transposed_rhs . flat < Scalar > ( ) . data ( ) , rhs . flat < Scalar > ( ) . data ( ) , rhs . NumElements ( ) * sizeof ( Scalar ) ) ; } auto input_copy_ptr_array = solver -> GetScratchSpace < uint8 > ( sizeof ( Scalar * ) * batch_size , \"input_copy_ptr_array\" , true ) ; auto transposed_rhs_ptr_array = solver -> GetScratchSpace < uint8 > ( sizeof ( Scalar * ) * batch_size , \"transposed_rhs_ptr_array\" , true ) ; auto transposed_rhs_reshaped = transposed_rhs . template flat_inner_dims < Scalar , 3 > ( ) ; if ( use_batched_solver ) { const Scalar * * input_copy_ptrs_base = reinterpret_cast < const Scalar * * > ( input_copy_ptr_array . mutable_data ( ) ) ; const Scalar * * transposed_rhs_ptrs_base = reinterpret_cast < const Scalar * * > ( transposed_rhs_ptr_array . mutable_data ( ) ) ; for ( int batch = 0 ; batch < batch_size ; ++ batch ) { input_copy_ptrs_base [ batch ] = & input_copy_reshaped ( batch , 0 , 0 ) ; transposed_rhs_ptrs_base [ batch ] = & transposed_rhs_reshaped ( batch , 0 , 0 ) ; } int host_info = 0 ; OP_REQUIRES_OK_ASYNC ( context , solver -> GetrsBatched ( adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T , n , nrhs , input_copy_ptrs_base , n , pivots_mat . data ( ) , transposed_rhs_ptrs_base , n , & host_info , batch_size ) , done ) ; OP_REQUIRES_ASYNC ( context , host_info == 0 , errors : : InvalidArgument ( \"The<S2SV_blank>\" , - host_info , \"\\'th<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>cublas*getrsBatched<S2SV_blank>had<S2SV_blank>\" \"an<S2SV_blank>illegal<S2SV_blank>value.\" ) , done ) ; } else { dev_info . push_back ( solver -> GetDeviceLapackInfo ( batch_size , \"getrs\" ) ) ; for ( int batch = 0 ; batch < batch_size ; ++ batch ) { OP_REQUIRES_OK_ASYNC ( context , solver -> Getrs ( adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T , n , nrhs , & input_copy_reshaped ( batch , 0 , 0 ) , n , & pivots_mat ( batch , 0 ) , & transposed_rhs_reshaped ( batch , 0 , 0 ) , n , & dev_info . back ( ) ( batch ) ) , done ) ; } } if ( nrhs > 1 ) { OP_REQUIRES_OK_ASYNC ( context , DoMatrixTranspose ( device , transposed_rhs , output ) , done ) ; } else { device . memcpy ( output -> flat < Scalar > ( ) . data ( ) , transposed_rhs . flat < Scalar > ( ) . data ( ) , transposed_rhs . NumElements ( ) * sizeof ( Scalar ) ) ; } auto info_checker = [ context , done , dev_info ] ( const Status & status , const std : : vector < HostLapackInfo > & host_infos ) { if ( ! status . ok ( ) && errors : : IsInvalidArgument ( status ) && ! host_infos . empty ( ) ) { for ( int i = 0 ; i < host_infos [ 0 ] . size ( ) ; ++ i ) { OP_REQUIRES_ASYNC ( context , host_infos [ 0 ] . data ( ) [ i ] <= 0 , errors : : InvalidArgument ( kErrMsg ) , done ) ; } } OP_REQUIRES_OK_ASYNC ( context , status , done ) ; done ( ) ; } ; CudaSolver : : CheckLapackInfoAndDeleteSolverAsync ( std : : move ( solver ) , dev_info , std : : move ( info_checker ) ) ; }", "target": "<S2SV_ModStart> : InvalidArgument ( \"Input<S2SV_blank>matrices<S2SV_blank>must<S2SV_blank>be<S2SV_blank>squares,<S2SV_blank>got<S2SV_blank>\" <S2SV_ModEnd> , input . <S2SV_ModStart> InvalidArgument ( \"Input<S2SV_blank>matrix<S2SV_blank>and<S2SV_blank>right-hand<S2SV_blank>side<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>\" \"same<S2SV_blank>number<S2SV_blank>of<S2SV_blank>rows,<S2SV_blank>got<S2SV_blank>\" <S2SV_ModEnd> , n , <S2SV_ModStart> done ) ; for ( int dim = 0 ; dim < ndims - 2 ; dim ++ ) { OP_REQUIRES_ASYNC ( context , input . dim_size ( dim ) == rhs . dim_size ( dim ) , errors : : InvalidArgument ( \"All<S2SV_blank>input<S2SV_blank>tensors<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>outer<S2SV_blank>dimensions.\" ) , done ) ; }"}
{"source": "CWE-703 void Compute ( OpKernelContext * ctx ) override { Buffer * buf = nullptr ; OP_REQUIRES_OK ( ctx , GetBuffer ( ctx , def ( ) , & buf ) ) ; core : : ScopedUnref scope ( buf ) ; Buffer : : Tuple tuple ; <S2SV_StartBug> std : : size_t index = ctx -> input ( 0 ) . scalar < int > ( ) ( ) ; <S2SV_EndBug> OP_REQUIRES_OK ( ctx , buf -> Peek ( index , & tuple ) ) ; OP_REQUIRES ( ctx , tuple . size ( ) == ( size_t ) ctx -> num_outputs ( ) , errors : : InvalidArgument ( \"Mismatch<S2SV_blank>stage/unstage:<S2SV_blank>\" , tuple . size ( ) , \"<S2SV_blank>vs.<S2SV_blank>\" , ctx -> num_outputs ( ) ) ) ; for ( size_t i = 0 ; i < tuple . size ( ) ; ++ i ) { ctx -> set_output ( i , tuple [ i ] ) ; } }", "target": "<S2SV_ModStart> Tuple tuple ; buf -> Get ( & tuple <S2SV_ModEnd> ) ; OP_REQUIRES"}
{"source": "CWE-703 static GF_Err isoffin_process ( GF_Filter * filter ) { ISOMReader * read = gf_filter_get_udta ( filter ) ; u32 i , count = gf_list_count ( read -> channels ) ; Bool is_active = GF_FALSE ; Bool in_is_eos = GF_FALSE ; Bool check_forced_end = GF_FALSE ; Bool has_new_data = GF_FALSE ; u64 min_offset_plus_one = 0 ; u32 nb_forced_end = 0 ; if ( read -> in_error ) return read -> in_error ; if ( read -> pid ) { Bool fetch_input = GF_TRUE ; if ( ! read -> is_partial_download && ! read -> mem_load_mode && ( read -> moov_not_loaded == 2 ) ) { isoffin_configure_pid ( filter , read -> pid , GF_FALSE ) ; if ( read -> moov_not_loaded ) return GF_OK ; } if ( read -> mem_load_mode == 2 ) { if ( ! read -> force_fetch && read -> mem_blob . size > read -> mstore_size ) { fetch_input = GF_FALSE ; } read -> force_fetch = GF_FALSE ; } while ( fetch_input ) { GF_FilterPacket * pck = gf_filter_pid_get_packet ( read -> pid ) ; if ( ! pck ) { if ( read -> wait_for_source ) { if ( gf_filter_pid_is_eos ( read -> pid ) ) return GF_EOS ; return GF_OK ; } break ; } read -> wait_for_source = GF_FALSE ; if ( read -> mem_load_mode ) { u32 data_size ; const u8 * pck_data = gf_filter_pck_get_data ( pck , & data_size ) ; isoffin_push_buffer ( filter , read , pck_data , data_size ) ; } else if ( read -> moov_not_loaded == 2 ) { gf_filter_pid_drop_packet ( read -> pid ) ; return GF_OK ; } gf_filter_pid_drop_packet ( read -> pid ) ; has_new_data = GF_TRUE ; if ( read -> in_error ) return read -> in_error ; } if ( gf_filter_pid_is_eos ( read -> pid ) ) { read -> input_loaded = GF_TRUE ; in_is_eos = GF_TRUE ; } if ( read -> input_is_stop ) { read -> input_loaded = GF_TRUE ; in_is_eos = GF_TRUE ; read -> input_is_stop = GF_FALSE ; } if ( ! read -> frag_type && read -> input_loaded ) { in_is_eos = GF_TRUE ; } if ( read -> invalid_segment ) { if ( ! in_is_eos ) return GF_OK ; read -> invalid_segment = GF_FALSE ; for ( i = 0 ; i < count ; i ++ ) { ISOMChannel * ch = gf_list_get ( read -> channels , i ) ; if ( ! ch -> playing ) { continue ; } if ( ! ch -> eos_sent ) { ch -> eos_sent = GF_TRUE ; gf_filter_pid_set_eos ( ch -> pid ) ; } } read -> eos_signaled = GF_TRUE ; return GF_EOS ; } } else if ( read -> extern_mov ) { in_is_eos = GF_TRUE ; read -> input_loaded = GF_TRUE ; } if ( read -> moov_not_loaded == 1 ) { if ( read -> mem_load_mode ) return GF_OK ; read -> moov_not_loaded = GF_FALSE ; return isoffin_setup ( filter , read ) ; } if ( read -> refresh_fragmented ) { const GF_PropertyValue * prop ; if ( in_is_eos ) { read -> refresh_fragmented = GF_FALSE ; } else { prop = gf_filter_pid_get_property ( read -> pid , GF_PROP_PID_FILE_CACHED ) ; if ( prop && prop -> value . boolean ) read -> refresh_fragmented = GF_FALSE ; } if ( has_new_data ) { u64 bytesMissing = 0 ; GF_Err e ; const char * new_url = NULL ; prop = gf_filter_pid_get_property ( read -> pid , GF_PROP_PID_FILEPATH ) ; if ( prop ) new_url = prop -> value . string ; e = gf_isom_refresh_fragmented ( read -> mov , & bytesMissing , new_url ) ; if ( e && ( e != GF_ISOM_INCOMPLETE_FILE ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_DASH , ( \"[IsoMedia]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>refresh<S2SV_blank>current<S2SV_blank>segment:<S2SV_blank>%s\\\\n\" , gf_error_to_string ( e ) ) ) ; read -> refresh_fragmented = GF_FALSE ; } else { GF_LOG ( GF_LOG_DEBUG , GF_LOG_DASH , ( \"[IsoMedia]<S2SV_blank>Refreshing<S2SV_blank>current<S2SV_blank>segment<S2SV_blank>at<S2SV_blank>UTC<S2SV_blank>\" LLU \"<S2SV_blank>-<S2SV_blank>\" LLU \"<S2SV_blank>bytes<S2SV_blank>still<S2SV_blank>missing<S2SV_blank>-<S2SV_blank>input<S2SV_blank>is<S2SV_blank>EOS<S2SV_blank>%d\\\\n\" , gf_net_get_utc ( ) , bytesMissing , in_is_eos ) ) ; } if ( ! read -> refresh_fragmented && ( e == GF_ISOM_INCOMPLETE_FILE ) ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_DASH , ( \"[IsoMedia]<S2SV_blank>Incomplete<S2SV_blank>Segment<S2SV_blank>received<S2SV_blank>-<S2SV_blank>\" LLU \"<S2SV_blank>bytes<S2SV_blank>missing<S2SV_blank>but<S2SV_blank>EOF<S2SV_blank>found\\\\n\" , bytesMissing ) ) ; } # ifndef GPAC_DISABLE_LOG if ( gf_log_tool_level_on ( GF_LOG_DASH , GF_LOG_DEBUG ) ) { for ( i = 0 ; i < count ; i ++ ) { ISOMChannel * ch = gf_list_get ( read -> channels , i ) ; GF_LOG ( GF_LOG_DEBUG , GF_LOG_DASH , ( \"[IsoMedia]<S2SV_blank>refresh<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>fragment<S2SV_blank>-<S2SV_blank>cur<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>new<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>%d\\\\n\" , ch -> track , ch -> sample_num , gf_isom_get_sample_count ( ch -> owner -> mov , ch -> track ) ) ) ; } } # endif isor_check_producer_ref_time ( read ) ; if ( ! read -> frag_type ) read -> refresh_fragmented = GF_FALSE ; } } for ( i = 0 ; i < count ; i ++ ) { u8 * data ; u32 nb_pck = 50 ; ISOMChannel * ch ; ch = gf_list_get ( read -> channels , i ) ; if ( ! ch -> playing ) { nb_forced_end ++ ; continue ; } if ( ! ch -> eos_sent ) is_active = GF_TRUE ; while ( nb_pck ) { ch -> sample_data_offset = 0 ; if ( ! read -> full_segment_flush && gf_filter_pid_would_block ( ch -> pid ) ) break ; if ( ch -> item_id ) { isor_reader_get_sample_from_item ( ch ) ; } else { isor_reader_get_sample ( ch ) ; } if ( read -> stsd && ( ch -> last_sample_desc_index != read -> stsd ) && ch -> sample ) { isor_reader_release_sample ( ch ) ; continue ; } if ( ch -> sample ) { u32 sample_dur ; u8 dep_flags ; u8 * subs_buf ; u32 subs_buf_size ; GF_FilterPacket * pck ; if ( ch -> needs_pid_reconfig ) { isor_update_channel_config ( ch ) ; ch -> needs_pid_reconfig = GF_FALSE ; } if ( ch -> check_has_rap && ( gf_isom_get_sample_count ( ch -> owner -> mov , ch -> track ) > 1 ) && ( gf_isom_has_sync_points ( ch -> owner -> mov , ch -> track ) == 1 ) ) { ch -> check_has_rap = GF_FALSE ; ch -> has_rap = GF_TRUE ; gf_filter_pid_set_property ( ch -> pid , GF_PROP_PID_HAS_SYNC , & PROP_BOOL ( ch -> has_rap ) ) ; } isor_reader_check_config ( ch ) ; if ( read -> nodata ) { pck = gf_filter_pck_new_shared ( ch -> pid , NULL , ch -> sample -> dataLength , NULL ) ; if ( ! pck ) return GF_OUT_OF_MEM ; } else { pck = gf_filter_pck_new_alloc ( ch -> pid , ch -> sample -> dataLength , & data ) ; if ( ! pck ) return GF_OUT_OF_MEM ; memcpy ( data , ch -> sample -> data , ch -> sample -> dataLength ) ; } gf_filter_pck_set_dts ( pck , ch -> dts ) ; gf_filter_pck_set_cts ( pck , ch -> cts ) ; if ( ch -> sample -> IsRAP == - 1 ) { gf_filter_pck_set_sap ( pck , GF_FILTER_SAP_1 ) ; ch -> redundant = 1 ; } else { gf_filter_pck_set_sap ( pck , ( GF_FilterSAPType ) ch -> sample -> IsRAP ) ; } if ( ch -> sap_3 ) gf_filter_pck_set_sap ( pck , GF_FILTER_SAP_3 ) ; else if ( ch -> sap_4_type ) { gf_filter_pck_set_sap ( pck , ( ch -> sap_4_type == GF_ISOM_SAMPLE_PREROLL ) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4 ) ; gf_filter_pck_set_roll_info ( pck , ch -> roll ) ; } sample_dur = ch -> au_duration ; if ( ch -> sample -> nb_pack ) sample_dur *= ch -> sample -> nb_pack ; gf_filter_pck_set_duration ( pck , sample_dur ) ; gf_filter_pck_set_seek_flag ( pck , ch -> seek_flag ) ; if ( ch -> xps_mask && ! gf_filter_pck_get_sap ( pck ) ) { gf_filter_pck_set_property ( pck , GF_PROP_PCK_XPS_MASK , & PROP_UINT ( ch -> xps_mask ) ) ; } dep_flags = ch -> isLeading ; dep_flags <<= 2 ; dep_flags |= ch -> dependsOn ; dep_flags <<= 2 ; dep_flags |= ch -> dependedOn ; dep_flags <<= 2 ; dep_flags |= ch -> redundant ; if ( dep_flags ) gf_filter_pck_set_dependency_flags ( pck , dep_flags ) ; gf_filter_pck_set_crypt_flags ( pck , ch -> pck_encrypted ? GF_FILTER_PCK_CRYPT : 0 ) ; gf_filter_pck_set_seq_num ( pck , ch -> sample_num ) ; subs_buf = gf_isom_sample_get_subsamples_buffer ( read -> mov , ch -> track , ch -> sample_num , & subs_buf_size ) ; if ( subs_buf ) { gf_filter_pck_set_property ( pck , GF_PROP_PCK_SUBS , & PROP_DATA_NO_COPY ( subs_buf , subs_buf_size ) ) ; } if ( ch -> sai_buffer && ch -> pck_encrypted ) { assert ( ch -> sai_buffer_size ) ; gf_filter_pck_set_property ( pck , GF_PROP_PCK_CENC_SAI , & PROP_DATA ( ch -> sai_buffer , ch -> sai_buffer_size ) ) ; } if ( read -> sigfrag ) { GF_ISOFragmentBoundaryInfo finfo ; if ( gf_isom_sample_is_fragment_start ( read -> mov , ch -> track , ch -> sample_num , & finfo ) ) { u64 start = 0 ; u32 traf_start = finfo . seg_start_plus_one ? 2 : 1 ; if ( finfo . seg_start_plus_one ) gf_filter_pck_set_property ( pck , GF_PROP_PCK_CUE_START , & PROP_BOOL ( GF_TRUE ) ) ; gf_filter_pck_set_property ( pck , GF_PROP_PCK_FRAG_START , & PROP_UINT ( traf_start ) ) ; start = finfo . frag_start ; if ( finfo . seg_start_plus_one ) start = finfo . seg_start_plus_one - 1 ; gf_filter_pck_set_property ( pck , GF_PROP_PCK_FRAG_RANGE , & PROP_FRAC64_INT ( start , finfo . mdat_end ) ) ; if ( finfo . moof_template ) { gf_filter_pck_set_property ( pck , GF_PROP_PCK_MOOF_TEMPLATE , & PROP_DATA ( ( u8 * ) finfo . moof_template , finfo . moof_template_size ) ) ; } if ( finfo . sidx_end ) { gf_filter_pck_set_property ( pck , GF_PROP_PCK_SIDX_RANGE , & PROP_FRAC64_INT ( finfo . sidx_start , finfo . sidx_end ) ) ; } if ( read -> seg_name_changed ) { const GF_PropertyValue * p = gf_filter_pid_get_property ( read -> pid , GF_PROP_PID_URL ) ; read -> seg_name_changed = GF_FALSE ; if ( p && p -> value . string ) { gf_filter_pck_set_property ( pck , GF_PROP_PID_URL , & PROP_STRING ( p -> value . string ) ) ; } } } } if ( ch -> sender_ntp ) { gf_filter_pck_set_property ( pck , GF_PROP_PCK_SENDER_NTP , & PROP_LONGUINT ( ch -> sender_ntp ) ) ; if ( ch -> ntp_at_server_ntp ) { gf_filter_pck_set_property ( pck , GF_PROP_PCK_RECEIVER_NTP , & PROP_LONGUINT ( ch -> ntp_at_server_ntp ) ) ; } } ch -> eos_sent = GF_FALSE ; if ( ( ch -> streamType == GF_STREAM_AUDIO ) && ( ch -> sample_num == gf_isom_get_sample_count ( read -> mov , ch -> track ) ) ) { gf_filter_pck_set_property ( pck , GF_PROP_PCK_END_RANGE , & PROP_BOOL ( GF_TRUE ) ) ; } gf_filter_pck_send ( pck ) ; isor_reader_release_sample ( ch ) ; ch -> last_valid_sample_data_offset = ch -> sample_data_offset ; nb_pck -- ; } else if ( ch -> last_state == GF_EOS ) { if ( ch -> playing == 2 ) { if ( in_is_eos ) { ch -> playing = GF_FALSE ; } else { nb_forced_end ++ ; check_forced_end = GF_TRUE ; } } if ( in_is_eos && ! ch -> eos_sent ) { void * tfrf ; const void * gf_isom_get_tfrf ( GF_ISOFile * movie , u32 trackNumber ) ; ch -> eos_sent = GF_TRUE ; read -> eos_signaled = GF_TRUE ; tfrf = ( void * ) gf_isom_get_tfrf ( read -> mov , ch -> track ) ; if ( tfrf ) { gf_filter_pid_set_info_str ( ch -> pid , \"smooth_tfrf\" , & PROP_POINTER ( tfrf ) ) ; ch -> last_has_tfrf = GF_TRUE ; } else if ( ch -> last_has_tfrf ) { gf_filter_pid_set_info_str ( ch -> pid , \"smooth_tfrf\" , NULL ) ; ch -> last_has_tfrf = GF_FALSE ; } gf_filter_pid_set_eos ( ch -> pid ) ; } break ; <S2SV_StartBug> } else { <S2SV_EndBug> read -> force_fetch = GF_TRUE ; break ; } } if ( ! min_offset_plus_one || ( min_offset_plus_one - 1 > ch -> last_valid_sample_data_offset ) ) min_offset_plus_one = 1 + ch -> last_valid_sample_data_offset ; } if ( read -> mem_load_mode && min_offset_plus_one ) { isoffin_purge_mem ( read , min_offset_plus_one - 1 ) ; } if ( read -> pid && check_forced_end && ( nb_forced_end == count ) ) { GF_FilterEvent evt ; GF_FEVT_INIT ( evt , GF_FEVT_STOP , read -> pid ) ; gf_filter_pid_send_event ( read -> pid , & evt ) ; } if ( ! is_active ) { return GF_EOS ; } return GF_OK ; }", "target": "<S2SV_ModStart> ; } else if ( ch -> last_state == GF_ISOM_INVALID_FILE ) { if ( ! ch -> eos_sent ) { ch -> eos_sent = GF_TRUE ; read -> eos_signaled = GF_TRUE ; gf_filter_pid_set_eos ( ch -> pid ) ; } return ch -> last_state ; } else"}
{"source": "CWE-125 void SparseFillEmptyRowsOpImpl ( OpKernelContext * context , AsyncOpKernel : : DoneCallback done = nullptr ) { if ( ! done ) { done = [ ] { } ; } const int kIndicesInput = 0 ; const int kValuesInput = 1 ; const int kDenseShapeInput = 2 ; const int kDefaultValueInput = 3 ; const Tensor & indices_t = context -> input ( kIndicesInput ) ; const Tensor & values_t = context -> input ( kValuesInput ) ; const Tensor & dense_shape_t = context -> input ( kDenseShapeInput ) ; const Tensor & default_value_t = context -> input ( kDefaultValueInput ) ; OP_REQUIRES_ASYNC ( context , TensorShapeUtils : : IsVector ( dense_shape_t . shape ( ) ) , errors : : InvalidArgument ( \"dense_shape<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector,<S2SV_blank>saw:<S2SV_blank>\" , dense_shape_t . shape ( ) . DebugString ( ) ) , done ) ; OP_REQUIRES_ASYNC ( context , TensorShapeUtils : : IsMatrix ( indices_t . shape ( ) ) , errors : : InvalidArgument ( \"indices<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix,<S2SV_blank>saw:<S2SV_blank>\" , indices_t . shape ( ) . DebugString ( ) ) , done ) ; OP_REQUIRES_ASYNC ( context , TensorShapeUtils : : IsVector ( values_t . shape ( ) ) , errors : : InvalidArgument ( \"values<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector,<S2SV_blank>saw:<S2SV_blank>\" , values_t . shape ( ) . DebugString ( ) ) , done ) ; OP_REQUIRES_ASYNC ( <S2SV_StartBug> context , TensorShapeUtils : : IsScalar ( default_value_t . shape ( ) ) , <S2SV_EndBug> errors : : InvalidArgument ( \"default_value<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar,<S2SV_blank>saw:<S2SV_blank>\" , default_value_t . shape ( ) . DebugString ( ) ) , done ) ; OP_REQUIRES_ASYNC ( context , dense_shape_t . NumElements ( ) != 0 , errors : : InvalidArgument ( \"Dense<S2SV_blank>shape<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>empty.\" ) , done ) ; using FunctorType = functor : : SparseFillEmptyRows < Device , T , Tindex > ; OP_REQUIRES_OK_ASYNC ( context , FunctorType ( ) ( context , default_value_t , indices_t , values_t , dense_shape_t , done ) , done ) ; }", "target": "<S2SV_ModStart> ( context , indices_t . dim_size ( 0 ) == values_t . dim_size ( 0 ) , errors : : InvalidArgument ( \"The<S2SV_blank>length<S2SV_blank>of<S2SV_blank>`values`<S2SV_blank>(\" , values_t . dim_size ( 0 ) , \")<S2SV_blank>must<S2SV_blank>match<S2SV_blank>the<S2SV_blank>first<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>`indices`<S2SV_blank>(\" , indices_t . dim_size ( 0 ) , \").\" ) , done ) ; OP_REQUIRES_ASYNC ( context ,"}
{"source": "CWE-20 Status ValidateInputs ( const Tensor * a_indices , const Tensor * a_values , const Tensor * a_shape , const Tensor * b ) { if ( ! TensorShapeUtils : : IsMatrix ( a_indices -> shape ( ) ) ) { return errors : : InvalidArgument ( \"Input<S2SV_blank>a_indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape:<S2SV_blank>\" , a_indices -> shape ( ) . DebugString ( ) ) ; } if ( ! TensorShapeUtils : : IsVector ( a_values -> shape ( ) ) || ! TensorShapeUtils : : IsVector ( a_shape -> shape ( ) ) ) { return errors : : InvalidArgument ( \"Inputs<S2SV_blank>a_values<S2SV_blank>and<S2SV_blank>a_shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>vectors<S2SV_blank>\" \"but<S2SV_blank>received<S2SV_blank>shapes:<S2SV_blank>\" , a_values -> shape ( ) . DebugString ( ) , \"<S2SV_blank>and<S2SV_blank>\" , a_shape -> shape ( ) . DebugString ( ) ) ; } <S2SV_StartBug> if ( a_shape -> NumElements ( ) != b -> dims ( ) ) { <S2SV_EndBug> return errors : : InvalidArgument ( \"Two<S2SV_blank>operands<S2SV_blank>have<S2SV_blank>different<S2SV_blank>ranks;<S2SV_blank>received:<S2SV_blank>\" , a_shape -> NumElements ( ) , \"<S2SV_blank>and<S2SV_blank>\" , b -> dims ( ) ) ; } const auto a_shape_flat = a_shape -> flat < Index > ( ) ; for ( int i = 0 ; i < b -> dims ( ) ; ++ i ) { if ( a_shape_flat ( i ) != b -> dim_size ( i ) ) { return errors : : InvalidArgument ( \"Dimension<S2SV_blank>\" , i , \"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>equal<S2SV_blank>(no<S2SV_blank>broadcasting<S2SV_blank>is<S2SV_blank>supported):<S2SV_blank>sparse<S2SV_blank>side<S2SV_blank>\" , a_shape_flat ( i ) , \"<S2SV_blank>vs<S2SV_blank>dense<S2SV_blank>side<S2SV_blank>\" , b -> dim_size ( i ) ) ; } } <S2SV_StartBug> return Status : : OK ( ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ) ; } int64_t nnz = a_indices -> dim_size ( 0 ) ; int64_t ndims = a_indices -> dim_size ( 1 ) ; if ( a_values -> dim_size ( 0 ) != nnz ) { return errors : : InvalidArgument ( \"Dimensions<S2SV_blank>\" , nnz , \"<S2SV_blank>and<S2SV_blank>\" , a_values -> dim_size ( 0 ) , \"<S2SV_blank>are<S2SV_blank>not<S2SV_blank>compatible\" ) ; } if ( a_shape -> dim_size ( 0 ) != ndims ) { return errors : : InvalidArgument ( \"Dimensions<S2SV_blank>\" , ndims , \"<S2SV_blank>and<S2SV_blank>\" , a_shape -> dim_size ( 0 ) , \"<S2SV_blank>are<S2SV_blank>not<S2SV_blank>compatible\" ) ; } <S2SV_ModStart> ; } } const auto a_indices_mat = a_indices -> flat_inner_dims < Index > ( ) ; for ( int64_t zidx = 0 ; zidx < nnz ; ++ zidx ) { for ( int64_t didx = 0 ; didx < ndims ; ++ didx ) { const Index idx = a_indices_mat ( zidx , didx ) ; if ( idx < 0 || idx >= a_shape_flat ( didx ) ) { return errors : : InvalidArgument ( \"Sparse<S2SV_blank>tensor<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>index<S2SV_blank>on<S2SV_blank>dimension<S2SV_blank>\" , didx , \":<S2SV_blank>\" \"a_indices(\" , zidx , \",\" , didx , \")<S2SV_blank>=<S2SV_blank>\" , idx , \",<S2SV_blank>dense<S2SV_blank>tensor<S2SV_blank>shape:<S2SV_blank>\" , a_shape_flat ) ; } } }"}
{"source": "CWE-703 Status Examples : : Initialize ( OpKernelContext * const context , const ModelWeights & weights , const int num_sparse_features , const int num_sparse_features_with_values , const int num_dense_features ) { num_features_ = num_sparse_features + num_dense_features ; OpInputList sparse_example_indices_inputs ; TF_RETURN_IF_ERROR ( context -> input_list ( \"sparse_example_indices\" , & sparse_example_indices_inputs ) ) ; if ( sparse_example_indices_inputs . size ( ) != num_sparse_features ) return errors : : InvalidArgument ( \"Expected<S2SV_blank>\" , num_sparse_features , \"<S2SV_blank>tensors<S2SV_blank>in<S2SV_blank>sparse_example_indices<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , sparse_example_indices_inputs . size ( ) ) ; OpInputList sparse_feature_indices_inputs ; TF_RETURN_IF_ERROR ( context -> input_list ( \"sparse_feature_indices\" , & sparse_feature_indices_inputs ) ) ; if ( sparse_feature_indices_inputs . size ( ) != num_sparse_features ) return errors : : InvalidArgument ( \"Expected<S2SV_blank>\" , num_sparse_features , \"<S2SV_blank>tensors<S2SV_blank>in<S2SV_blank>sparse_feature_indices<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , sparse_feature_indices_inputs . size ( ) ) ; OpInputList sparse_feature_values_inputs ; if ( num_sparse_features_with_values > 0 ) { TF_RETURN_IF_ERROR ( context -> input_list ( \"sparse_feature_values\" , & sparse_feature_values_inputs ) ) ; if ( sparse_feature_values_inputs . size ( ) != num_sparse_features_with_values ) return errors : : InvalidArgument ( \"Expected<S2SV_blank>\" , num_sparse_features_with_values , \"<S2SV_blank>tensors<S2SV_blank>in<S2SV_blank>sparse_feature_values<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , sparse_feature_values_inputs . size ( ) ) ; } const Tensor * example_weights_t ; TF_RETURN_IF_ERROR ( context -> input ( \"example_weights\" , & example_weights_t ) ) ; auto example_weights = example_weights_t -> flat < float > ( ) ; if ( example_weights . size ( ) >= std : : numeric_limits < int > : : max ( ) ) { return errors : : InvalidArgument ( strings : : Printf ( \"Too<S2SV_blank>many<S2SV_blank>examples<S2SV_blank>in<S2SV_blank>a<S2SV_blank>mini-batch:<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%d\" , example_weights . size ( ) , std : : numeric_limits < int > : : max ( ) ) ) ; } const int num_examples = static_cast < int > ( example_weights . size ( ) ) ; const Tensor * example_labels_t ; TF_RETURN_IF_ERROR ( context -> input ( \"example_labels\" , & example_labels_t ) ) ; auto example_labels = example_labels_t -> flat < float > ( ) ; <S2SV_StartBug> <S2SV_EndBug> OpInputList dense_features_inputs ; TF_RETURN_IF_ERROR ( context -> input_list ( \"dense_features\" , & dense_features_inputs ) ) ; examples_ . clear ( ) ; examples_ . resize ( num_examples ) ; probabilities_ . resize ( num_examples ) ; sampled_index_ . resize ( num_examples ) ; sampled_count_ . resize ( num_examples ) ; for ( int example_id = 0 ; example_id < num_examples ; ++ example_id ) { Example * const example = & examples_ [ example_id ] ; example -> sparse_features_ . resize ( num_sparse_features ) ; example -> dense_vectors_ . resize ( num_dense_features ) ; example -> example_weight_ = example_weights ( example_id ) ; example -> example_label_ = example_labels ( example_id ) ; } const DeviceBase : : CpuWorkerThreads & worker_threads = * context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ; TF_RETURN_IF_ERROR ( CreateSparseFeatureRepresentation ( worker_threads , num_examples , num_sparse_features , weights , sparse_example_indices_inputs , sparse_feature_indices_inputs , sparse_feature_values_inputs , & examples_ ) ) ; TF_RETURN_IF_ERROR ( CreateDenseFeatureRepresentation ( worker_threads , num_examples , num_dense_features , weights , dense_features_inputs , & examples_ ) ) ; TF_RETURN_IF_ERROR ( ComputeSquaredNormPerExample ( worker_threads , num_examples , num_sparse_features , num_dense_features , & examples_ ) ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> ( ) ; if ( example_labels . size ( ) != num_examples ) { return errors : : InvalidArgument ( \"Expected<S2SV_blank>\" , num_examples , \"<S2SV_blank>example<S2SV_blank>labels<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , example_labels . size ( ) ) ; }"}
{"source": "CWE-703 GF_Err gf_hinter_finalize ( GF_ISOFile * file , GF_SDP_IODProfile IOD_Profile , u32 bandwidth ) { u32 i , sceneT , odT , descIndex , size , size64 ; GF_InitialObjectDescriptor * iod ; GF_SLConfig slc ; GF_ISOSample * samp ; Bool remove_ocr ; u8 * buffer ; char buf64 [ 5000 ] , sdpLine [ 5100 ] ; gf_isom_sdp_clean ( file ) ; if ( bandwidth ) { sprintf ( buf64 , \"b=AS:%d\" , bandwidth ) ; gf_isom_sdp_add_line ( file , buf64 ) ; } if ( gf_sys_is_test_mode ( ) ) { sprintf ( buf64 , \"a=x-copyright:<S2SV_blank>%s\" , \"MP4/3GP<S2SV_blank>File<S2SV_blank>hinted<S2SV_blank>with<S2SV_blank>GPAC<S2SV_blank>-<S2SV_blank>(c)<S2SV_blank>Telecom<S2SV_blank>ParisTech<S2SV_blank>(http://gpac.io)\" ) ; } else { sprintf ( buf64 , \"a=x-copyright:<S2SV_blank>MP4/3GP<S2SV_blank>File<S2SV_blank>hinted<S2SV_blank>with<S2SV_blank>GPAC<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%s\" , gf_gpac_version ( ) , gf_gpac_copyright ( ) ) ; } gf_isom_sdp_add_line ( file , buf64 ) ; if ( IOD_Profile == GF_SDP_IOD_NONE ) return GF_OK ; odT = sceneT = 0 ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( ! gf_isom_is_track_in_root_od ( file , i + 1 ) ) continue ; switch ( gf_isom_get_media_type ( file , i + 1 ) ) { case GF_ISOM_MEDIA_OD : odT = i + 1 ; break ; case GF_ISOM_MEDIA_SCENE : sceneT = i + 1 ; break ; } } remove_ocr = 0 ; if ( IOD_Profile == GF_SDP_IOD_ISMA_STRICT ) { IOD_Profile = GF_SDP_IOD_ISMA ; remove_ocr = 1 ; } if ( ( IOD_Profile == GF_SDP_IOD_ISMA ) && ! sceneT ) return GF_BAD_PARAM ; iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) return GF_NOT_SUPPORTED ; if ( IOD_Profile == GF_SDP_IOD_ISMA ) { GF_ESD * esd ; Bool is_ok = 1 ; while ( gf_list_count ( iod -> ESDescriptors ) ) { esd = ( GF_ESD * ) gf_list_get ( iod -> ESDescriptors , 0 ) ; gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; gf_list_rem ( iod -> ESDescriptors , 0 ) ; } if ( odT ) { esd = gf_isom_get_esd ( file , odT , 1 ) ; if ( gf_isom_get_sample_count ( file , odT ) == 1 ) { samp = gf_isom_get_sample ( file , odT , 1 , & descIndex ) ; if ( samp && gf_hinter_can_embbed_data ( samp -> data , samp -> dataLength , GF_STREAM_OD ) ) { InitSL_NULL ( & slc ) ; slc . predefined = 0 ; slc . hasRandomAccessUnitsOnlyFlag = 1 ; slc . timeScale = slc . timestampResolution = gf_isom_get_media_timescale ( file , odT ) ; slc . OCRResolution = 1000 ; slc . startCTS = samp -> DTS + samp -> CTS_Offset ; slc . startDTS = samp -> DTS ; gf_isom_set_extraction_slc ( file , odT , 1 , & slc ) ; size64 = gf_base64_encode ( samp -> data , samp -> dataLength , buf64 , 2000 ) ; buf64 [ size64 ] = 0 ; sprintf ( sdpLine , \"data:application/mpeg4-od-au;base64,%s\" , buf64 ) ; if ( esd -> decoderConfig ) { esd -> decoderConfig -> avgBitrate = 0 ; esd -> decoderConfig -> bufferSizeDB = samp -> dataLength ; esd -> decoderConfig -> maxBitrate = 0 ; } size64 = ( u32 ) strlen ( sdpLine ) + 1 ; esd -> URLString = ( char * ) gf_malloc ( sizeof ( char ) * size64 ) ; strcpy ( esd -> URLString , sdpLine ) ; } else { GF_LOG ( GF_LOG_WARNING , GF_LOG_RTP , ( \"[rtp<S2SV_blank>hinter]<S2SV_blank>OD<S2SV_blank>sample<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>be<S2SV_blank>embedded<S2SV_blank>in<S2SV_blank>IOD<S2SV_blank>-<S2SV_blank>ISMA<S2SV_blank>disabled\\\\n\" ) ) ; is_ok = 0 ; } gf_isom_sample_del ( & samp ) ; } if ( remove_ocr ) esd -> OCRESID = 0 ; else if ( esd -> OCRESID == esd -> ESID ) esd -> OCRESID = 0 ; gf_list_add ( iod -> ESDescriptors , esd ) ; } esd = gf_isom_get_esd ( file , sceneT , 1 ) ; if ( gf_isom_get_sample_count ( file , sceneT ) == 1 ) { samp = gf_isom_get_sample ( file , sceneT , 1 , & descIndex ) ; if ( samp && gf_hinter_can_embbed_data ( samp -> data , samp -> dataLength , GF_STREAM_SCENE ) ) { <S2SV_StartBug> <S2SV_EndBug> slc . timeScale = slc . timestampResolution = gf_isom_get_media_timescale ( file , sceneT ) ; slc . OCRResolution = 1000 ; slc . startCTS = samp -> DTS + samp -> CTS_Offset ; slc . startDTS = samp -> DTS ; gf_isom_set_extraction_slc ( file , sceneT , 1 , & slc ) ; size64 = gf_base64_encode ( samp -> data , samp -> dataLength , buf64 , 2000 ) ; buf64 [ size64 ] = 0 ; sprintf ( sdpLine , \"data:application/mpeg4-bifs-au;base64,%s\" , buf64 ) ; if ( esd -> decoderConfig ) { esd -> decoderConfig -> avgBitrate = 0 ; esd -> decoderConfig -> bufferSizeDB = samp -> dataLength ; esd -> decoderConfig -> maxBitrate = 0 ; } esd -> URLString = ( char * ) gf_malloc ( sizeof ( char ) * ( strlen ( sdpLine ) + 1 ) ) ; strcpy ( esd -> URLString , sdpLine ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_RTP , ( \"[rtp<S2SV_blank>hinter]<S2SV_blank>Scene<S2SV_blank>description<S2SV_blank>sample<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>be<S2SV_blank>embedded<S2SV_blank>in<S2SV_blank>IOD<S2SV_blank>-<S2SV_blank>ISMA<S2SV_blank>disabled\\\\n\" ) ) ; is_ok = 0 ; } gf_isom_sample_del ( & samp ) ; } if ( remove_ocr ) esd -> OCRESID = 0 ; else if ( esd -> OCRESID == esd -> ESID ) esd -> OCRESID = 0 ; gf_list_add ( iod -> ESDescriptors , esd ) ; if ( is_ok ) { u32 has_a , has_v , has_i_a , has_i_v ; has_a = has_v = has_i_a = has_i_v = 0 ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { esd = gf_isom_get_esd ( file , i + 1 , 1 ) ; if ( ! esd ) continue ; if ( esd -> decoderConfig ) { if ( esd -> decoderConfig -> streamType == GF_STREAM_VISUAL ) { if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_MPEG4_PART2 ) has_i_v ++ ; else has_v ++ ; } else if ( esd -> decoderConfig -> streamType == GF_STREAM_AUDIO ) { if ( esd -> decoderConfig -> objectTypeIndication == GF_CODECID_AAC_MPEG4 ) has_i_a ++ ; else has_a ++ ; } } gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; } if ( ! has_v && ! has_a && ( has_i_v <= 1 ) && ( has_i_a <= 1 ) ) { sprintf ( sdpLine , \"a=isma-compliance:1,1.0,1\" ) ; gf_isom_sdp_add_line ( file , sdpLine ) ; } } } buffer = NULL ; size = 0 ; gf_odf_desc_write ( ( GF_Descriptor * ) iod , & buffer , & size ) ; gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; size64 = gf_base64_encode ( buffer , size , buf64 , 2000 ) ; buf64 [ size64 ] = 0 ; gf_free ( buffer ) ; sprintf ( sdpLine , \"a=mpeg4-iod:\\\\\"data:application/mpeg4-iod;base64,%s\\\\\"\" , buf64 ) ; gf_isom_sdp_add_line ( file , sdpLine ) ; return GF_OK ; }", "target": "<S2SV_ModStart> ) ) { InitSL_NULL ( & slc ) ;"}
{"source": "CWE-476 void Compute ( OpKernelContext * ctx ) override { const Tensor & val = ctx -> input ( 0 ) ; <S2SV_StartBug> int64 id = ctx -> session_state ( ) -> GetNewId ( ) ; <S2SV_EndBug> TensorStore : : TensorAndKey tk { val , id , requested_device ( ) } ; OP_REQUIRES_OK ( ctx , ctx -> tensor_store ( ) -> AddTensor ( name ( ) , tk ) ) ; Tensor * handle = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { } ) , & handle ) ) ; if ( ctx -> expected_output_dtype ( 0 ) == DT_RESOURCE ) { ResourceHandle resource_handle = MakeResourceHandle < Tensor > ( ctx , SessionState : : kTensorHandleResourceTypeName , tk . GetHandle ( name ( ) ) ) ; resource_handle . set_maybe_type_name ( SessionState : : kTensorHandleResourceTypeName ) ; handle -> scalar < ResourceHandle > ( ) ( ) = resource_handle ; } else { handle -> flat < tstring > ( ) . setConstant ( tk . GetHandle ( name ( ) ) ) ; } }", "target": "<S2SV_ModStart> 0 ) ; auto session_state = ctx -> session_state ( ) ; OP_REQUIRES ( ctx , session_state != nullptr , errors : : FailedPrecondition ( \"GetSessionHandle<S2SV_blank>called<S2SV_blank>on<S2SV_blank>null<S2SV_blank>session<S2SV_blank>state\" ) ) ; <S2SV_ModStart> int64 id = session_state <S2SV_ModEnd> -> GetNewId ("}
{"source": "CWE-125 <S2SV_StartBug> Status SparseCountSparseOutputShapeFn ( InferenceContext * c ) { <S2SV_EndBug> auto rank = c -> Dim ( c -> input ( 0 ) , 1 ) ; auto nvals = c -> UnknownDim ( ) ; c -> set_output ( 0 , c -> Matrix ( nvals , rank ) ) ; c -> set_output ( 1 , c -> Vector ( nvals ) ) ; c -> set_output ( 2 , c -> Vector ( rank ) ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> c ) { ShapeHandle unused ; TF_RETURN_IF_ERROR ( c -> WithRank ( c -> input ( 0 ) , 2 , & unused ) ) ;"}
{"source": "CWE-703 inline void FurnaceGUI : : patternRow ( int i , bool isPlaying , float lineHeight , int chans , int ord , const DivPattern * * patCache ) { static char id [ 32 ] ; bool selectedRow = ( i >= sel1 . y && i <= sel2 . y ) ; ImGui : : TableNextRow ( 0 , lineHeight ) ; ImGui : : TableNextColumn ( ) ; float cursorPosY = ImGui : : GetCursorPos ( ) . y - ImGui : : GetScrollY ( ) ; if ( cursorPosY < - lineHeight || cursorPosY > ImGui : : GetWindowSize ( ) . y ) { return ; } if ( ord < 0 || ord >= e -> song . ordersLen ) { return ; } if ( i < 0 || i >= e -> song . patLen ) { return ; } bool isPushing = false ; ImVec4 activeColor = uiColors [ GUI_COLOR_PATTERN_ACTIVE ] ; ImVec4 inactiveColor = uiColors [ GUI_COLOR_PATTERN_INACTIVE ] ; ImVec4 rowIndexColor = uiColors [ GUI_COLOR_PATTERN_ROW_INDEX ] ; if ( e -> song . hilightB > 0 && ! ( i % e -> song . hilightB ) ) { activeColor = uiColors [ GUI_COLOR_PATTERN_ACTIVE_HI2 ] ; inactiveColor = uiColors [ GUI_COLOR_PATTERN_INACTIVE_HI2 ] ; rowIndexColor = uiColors [ GUI_COLOR_PATTERN_ROW_INDEX_HI2 ] ; } else if ( e -> song . hilightA > 0 && ! ( i % e -> song . hilightA ) ) { activeColor = uiColors [ GUI_COLOR_PATTERN_ACTIVE_HI1 ] ; inactiveColor = uiColors [ GUI_COLOR_PATTERN_INACTIVE_HI1 ] ; rowIndexColor = uiColors [ GUI_COLOR_PATTERN_ROW_INDEX_HI1 ] ; } if ( settings . overflowHighlight ) { if ( edit && cursor . y == i ) { ImGui : : TableSetBgColor ( ImGuiTableBgTarget_RowBg0 , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_EDITING ] ) ) ; } else if ( isPlaying && oldRow == i ) { ImGui : : TableSetBgColor ( ImGuiTableBgTarget_RowBg0 , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_PATTERN_PLAY_HEAD ] ) ) ; } else if ( e -> song . hilightB > 0 && ! ( i % e -> song . hilightB ) ) { ImGui : : TableSetBgColor ( ImGuiTableBgTarget_RowBg0 , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_PATTERN_HI_2 ] ) ) ; } else if ( e -> song . hilightA > 0 && ! ( i % e -> song . hilightA ) ) { ImGui : : TableSetBgColor ( ImGuiTableBgTarget_RowBg0 , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_PATTERN_HI_1 ] ) ) ; } } else { isPushing = true ; if ( edit && cursor . y == i ) { ImGui : : PushStyleColor ( ImGuiCol_Header , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_EDITING ] ) ) ; } else if ( isPlaying && oldRow == i ) { ImGui : : PushStyleColor ( ImGuiCol_Header , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_PATTERN_PLAY_HEAD ] ) ) ; } else if ( e -> song . hilightB > 0 && ! ( i % e -> song . hilightB ) ) { ImGui : : PushStyleColor ( ImGuiCol_Header , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_PATTERN_HI_2 ] ) ) ; } else if ( e -> song . hilightA > 0 && ! ( i % e -> song . hilightA ) ) { ImGui : : PushStyleColor ( ImGuiCol_Header , ImGui : : GetColorU32 ( uiColors [ GUI_COLOR_PATTERN_HI_1 ] ) ) ; } else { isPushing = false ; } } if ( settings . patRowsBase == 1 ) { ImGui : : TextColored ( rowIndexColor , \"<S2SV_blank>%.2X<S2SV_blank>\" , i ) ; } else { ImGui : : TextColored ( rowIndexColor , \"%3d<S2SV_blank>\" , i ) ; } for ( int j = 0 ; j < chans ; j ++ ) { if ( ! e -> song . chanShow [ j ] ) { patChanX [ j ] = ImGui : : GetCursorPosX ( ) ; continue ; } int chanVolMax = e -> getMaxVolumeChan ( j ) ; if ( chanVolMax < 1 ) chanVolMax = 1 ; const DivPattern * pat = patCache [ j ] ; ImGui : : TableNextColumn ( ) ; patChanX [ j ] = ImGui : : GetCursorPosX ( ) ; int sel1XSum = sel1 . xCoarse * 32 + sel1 . xFine ; int sel2XSum = sel2 . xCoarse * 32 + sel2 . xFine ; int j32 = j * 32 ; bool selectedNote = selectedRow && ( j32 >= sel1XSum && j32 <= sel2XSum ) ; bool selectedIns = selectedRow && ( j32 + 1 >= sel1XSum && j32 + 1 <= sel2XSum ) ; bool selectedVol = selectedRow && ( j32 + 2 >= sel1XSum && j32 + 2 <= sel2XSum ) ; bool cursorNote = ( cursor . y == i && cursor . xCoarse == j && cursor . xFine == 0 ) ; bool cursorIns = ( cursor . y == i && cursor . xCoarse == j && cursor . xFine == 1 ) ; bool cursorVol = ( cursor . y == i && cursor . xCoarse == j && cursor . xFine == 2 ) ; sprintf ( id , \"%s##PN_%d_%d\" , noteName ( pat -> data [ i ] [ 0 ] , pat -> data [ i ] [ 1 ] ) , i , j ) ; if ( pat -> data [ i ] [ 0 ] == 0 && pat -> data [ i ] [ 1 ] == 0 ) { ImGui : : PushStyleColor ( ImGuiCol_Text , inactiveColor ) ; } else { ImGui : : PushStyleColor ( ImGuiCol_Text , activeColor ) ; } if ( cursorNote ) { ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_CURSOR ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderActive , uiColors [ GUI_COLOR_PATTERN_CURSOR_ACTIVE ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderHovered , uiColors [ GUI_COLOR_PATTERN_CURSOR_HOVER ] ) ; ImGui : : Selectable ( id , true , ImGuiSelectableFlags_NoPadWithHalfSpacing , threeChars ) ; demandX = ImGui : : GetCursorPosX ( ) ; ImGui : : PopStyleColor ( 3 ) ; } else { if ( selectedNote ) ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_SELECTION ] ) ; ImGui : : Selectable ( id , isPushing || selectedNote , ImGuiSelectableFlags_NoPadWithHalfSpacing , threeChars ) ; if ( selectedNote ) ImGui : : PopStyleColor ( ) ; } if ( ImGui : : IsItemClicked ( ) ) { startSelection ( j , 0 , i ) ; } if ( ImGui : : IsItemHovered ( ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) ) { updateSelection ( j , 0 , i ) ; } ImGui : : PopStyleColor ( ) ; if ( ! e -> song . chanCollapse [ j ] ) { if ( pat -> data [ i ] [ 2 ] == - 1 ) { ImGui : : PushStyleColor ( ImGuiCol_Text , inactiveColor ) ; sprintf ( id , \"..##PI_%d_%d\" , i , j ) ; } else { if ( pat -> data [ i ] [ 2 ] < 0 || pat -> data [ i ] [ 2 ] >= e -> song . insLen ) { ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_INS_ERROR ] ) ; } else { DivInstrumentType t = e -> song . ins [ pat -> data [ i ] [ 2 ] ] -> type ; if ( t != DIV_INS_AMIGA && t != e -> getPreferInsType ( j ) ) { ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_INS_WARN ] ) ; } else { ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_INS ] ) ; } } sprintf ( id , \"%.2X##PI_%d_%d\" , pat -> data [ i ] [ 2 ] , i , j ) ; } ImGui : : SameLine ( 0.0f , 0.0f ) ; if ( cursorIns ) { ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_CURSOR ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderActive , uiColors [ GUI_COLOR_PATTERN_CURSOR_ACTIVE ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderHovered , uiColors [ GUI_COLOR_PATTERN_CURSOR_HOVER ] ) ; ImGui : : Selectable ( id , true , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; demandX = ImGui : : GetCursorPosX ( ) ; ImGui : : PopStyleColor ( 3 ) ; } else { if ( selectedIns ) ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_SELECTION ] ) ; ImGui : : Selectable ( id , isPushing || selectedIns , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; if ( selectedIns ) ImGui : : PopStyleColor ( ) ; } if ( ImGui : : IsItemClicked ( ) ) { startSelection ( j , 1 , i ) ; } if ( ImGui : : IsItemHovered ( ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) ) { updateSelection ( j , 1 , i ) ; } ImGui : : PopStyleColor ( ) ; if ( pat -> data [ i ] [ 3 ] == - 1 ) { sprintf ( id , \"..##PV_%d_%d\" , i , j ) ; ImGui : : PushStyleColor ( ImGuiCol_Text , inactiveColor ) ; } else { int volColor = ( pat -> data [ i ] [ 3 ] * 127 ) / chanVolMax ; if ( volColor > 127 ) volColor = 127 ; if ( volColor < 0 ) volColor = 0 ; sprintf ( id , \"%.2X##PV_%d_%d\" , pat -> data [ i ] [ 3 ] , i , j ) ; ImGui : : PushStyleColor ( ImGuiCol_Text , volColors [ volColor ] ) ; } ImGui : : SameLine ( 0.0f , 0.0f ) ; if ( cursorVol ) { ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_CURSOR ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderActive , uiColors [ GUI_COLOR_PATTERN_CURSOR_ACTIVE ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderHovered , uiColors [ GUI_COLOR_PATTERN_CURSOR_HOVER ] ) ; ImGui : : Selectable ( id , true , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; demandX = ImGui : : GetCursorPosX ( ) ; ImGui : : PopStyleColor ( 3 ) ; } else { if ( selectedVol ) ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_SELECTION ] ) ; ImGui : : Selectable ( id , isPushing || selectedVol , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; if ( selectedVol ) ImGui : : PopStyleColor ( ) ; } if ( ImGui : : IsItemClicked ( ) ) { startSelection ( j , 2 , i ) ; } if ( ImGui : : IsItemHovered ( ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) ) { updateSelection ( j , 2 , i ) ; } ImGui : : PopStyleColor ( ) ; for ( int k = 0 ; k < e -> song . pat [ j ] . effectRows ; k ++ ) { int index = 4 + ( k << 1 ) ; bool selectedEffect = selectedRow && ( j32 + index - 1 >= sel1XSum && j32 + index - 1 <= sel2XSum ) ; bool selectedEffectVal = selectedRow && ( j32 + index >= sel1XSum && j32 + index <= sel2XSum ) ; bool cursorEffect = ( cursor . y == i && cursor . xCoarse == j && cursor . xFine == index - 1 ) ; bool cursorEffectVal = ( cursor . y == i && cursor . xCoarse == j && cursor . xFine == index ) ; if ( pat -> data [ i ] [ index ] == - 1 ) { sprintf ( id , \"..##PE%d_%d_%d\" , k , i , j ) ; ImGui : : PushStyleColor ( ImGuiCol_Text , inactiveColor ) ; } else { <S2SV_StartBug> sprintf ( id , \"%.2X##PE%d_%d_%d\" , pat -> data [ i ] [ index ] , k , i , j ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pat -> data [ i ] [ index ] < 0x10 ) { <S2SV_EndBug> <S2SV_StartBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ fxColors [ pat -> data [ i ] [ index ] ] ] ) ; <S2SV_EndBug> } else if ( pat -> data [ i ] [ index ] < 0x20 ) { ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY ] ) ; <S2SV_StartBug> } else if ( pat -> data [ i ] [ index ] < 0x30 ) { <S2SV_EndBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY ] ) ; <S2SV_StartBug> } else if ( pat -> data [ i ] [ index ] < 0x48 ) { <S2SV_EndBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY ] ) ; <S2SV_StartBug> } else if ( pat -> data [ i ] [ index ] < 0x90 ) { <S2SV_EndBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_INVALID ] ) ; <S2SV_StartBug> } else if ( pat -> data [ i ] [ index ] < 0xa0 ) { <S2SV_EndBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_MISC ] ) ; <S2SV_StartBug> } else if ( pat -> data [ i ] [ index ] < 0xc0 ) { <S2SV_EndBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_INVALID ] ) ; <S2SV_StartBug> } else if ( pat -> data [ i ] [ index ] < 0xd0 ) { <S2SV_EndBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_SPEED ] ) ; <S2SV_StartBug> } else if ( pat -> data [ i ] [ index ] < 0xe0 ) { <S2SV_EndBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_INVALID ] ) ; } else { <S2SV_StartBug> ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ extFxColors [ pat -> data [ i ] [ index ] - 0xe0 ] ] ) ; <S2SV_EndBug> } } ImGui : : SameLine ( 0.0f , 0.0f ) ; if ( cursorEffect ) { ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_CURSOR ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderActive , uiColors [ GUI_COLOR_PATTERN_CURSOR_ACTIVE ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderHovered , uiColors [ GUI_COLOR_PATTERN_CURSOR_HOVER ] ) ; ImGui : : Selectable ( id , true , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; demandX = ImGui : : GetCursorPosX ( ) ; ImGui : : PopStyleColor ( 3 ) ; } else { if ( selectedEffect ) ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_SELECTION ] ) ; ImGui : : Selectable ( id , isPushing || selectedEffect , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; if ( selectedEffect ) ImGui : : PopStyleColor ( ) ; } if ( ImGui : : IsItemClicked ( ) ) { startSelection ( j , index - 1 , i ) ; } if ( ImGui : : IsItemHovered ( ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) ) { updateSelection ( j , index - 1 , i ) ; } if ( pat -> data [ i ] [ index + 1 ] == - 1 ) { sprintf ( id , \"..##PF%d_%d_%d\" , k , i , j ) ; } else { sprintf ( id , \"%.2X##PF%d_%d_%d\" , pat -> data [ i ] [ index + 1 ] , k , i , j ) ; } ImGui : : SameLine ( 0.0f , 0.0f ) ; if ( cursorEffectVal ) { ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_CURSOR ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderActive , uiColors [ GUI_COLOR_PATTERN_CURSOR_ACTIVE ] ) ; ImGui : : PushStyleColor ( ImGuiCol_HeaderHovered , uiColors [ GUI_COLOR_PATTERN_CURSOR_HOVER ] ) ; ImGui : : Selectable ( id , true , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; demandX = ImGui : : GetCursorPosX ( ) ; ImGui : : PopStyleColor ( 3 ) ; } else { if ( selectedEffectVal ) ImGui : : PushStyleColor ( ImGuiCol_Header , uiColors [ GUI_COLOR_PATTERN_SELECTION ] ) ; ImGui : : Selectable ( id , isPushing || selectedEffectVal , ImGuiSelectableFlags_NoPadWithHalfSpacing , twoChars ) ; if ( selectedEffectVal ) ImGui : : PopStyleColor ( ) ; } if ( ImGui : : IsItemClicked ( ) ) { startSelection ( j , index , i ) ; } if ( ImGui : : IsItemHovered ( ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) ) { updateSelection ( j , index , i ) ; } ImGui : : PopStyleColor ( ) ; } } } if ( isPushing ) { ImGui : : PopStyleColor ( ) ; } ImGui : : TableNextColumn ( ) ; patChanX [ chans ] = ImGui : : GetCursorPosX ( ) ; }", "target": "<S2SV_ModStart> } else { if ( pat -> data [ i ] [ index ] > 0xff ) { <S2SV_ModStart> ( id , \"??##PE%d_%d_%d\" , k , i , j ) ; ImGui : : PushStyleColor ( ImGuiCol_Text , uiColors [ GUI_COLOR_PATTERN_EFFECT_INVALID ] ) ; } else { const unsigned char data = pat -> data [ i ] [ index ] ; sprintf ( id , \"%.2X##PE%d_%d_%d\" , data <S2SV_ModEnd> , k , <S2SV_ModStart> ; if ( data <S2SV_ModEnd> < 0x10 ) <S2SV_ModStart> [ fxColors [ data ] ] ) ; } else if ( data <S2SV_ModEnd> < 0x20 ) <S2SV_ModStart> else if ( data <S2SV_ModEnd> < 0x30 ) <S2SV_ModStart> else if ( data <S2SV_ModEnd> < 0x48 ) <S2SV_ModStart> else if ( data <S2SV_ModEnd> < 0x90 ) <S2SV_ModStart> else if ( data <S2SV_ModEnd> < 0xa0 ) <S2SV_ModStart> else if ( data <S2SV_ModEnd> < 0xc0 ) <S2SV_ModStart> else if ( data <S2SV_ModEnd> < 0xd0 ) <S2SV_ModStart> else if ( data <S2SV_ModEnd> < 0xe0 ) <S2SV_ModStart> [ extFxColors [ data <S2SV_ModEnd> - 0xe0 ] <S2SV_ModStart> ] ) ; }"}
{"source": "CWE-369 TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteDivParams * > ( node -> builtin_data ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input1 ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor1 , & input1 ) ) ; const TfLiteTensor * input2 ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor2 , & input2 ) ) ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , <S2SV_StartBug> GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output -> type == kTfLiteFloat32 || output -> type == kTfLiteInt32 ) { <S2SV_EndBug> <S2SV_StartBug> EvalDiv < kernel_type > ( context , node , params , data , input1 , input2 , output ) ; <S2SV_EndBug> } else if ( output -> type == kTfLiteUInt8 ) { <S2SV_StartBug> TF_LITE_ENSURE_OK ( <S2SV_EndBug> context , EvalQuantized < kernel_type > ( context , node , params , data , input1 , input2 , output ) ) ; } else { context -> ReportError ( context , \"Div<S2SV_blank>only<S2SV_blank>supports<S2SV_blank>FLOAT32,<S2SV_blank>INT32<S2SV_blank>and<S2SV_blank>quantized<S2SV_blank>UINT8<S2SV_blank>now,<S2SV_blank>got<S2SV_blank>%d.\" , output -> type ) ; return kTfLiteError ; } <S2SV_StartBug> <S2SV_EndBug> return kTfLiteOk ; }", "target": "<S2SV_ModStart> ) ) ; # define TF_LITE_CHECK_DIV_NON_ZERO ( data_type ) const auto * input2_data = GetTensorData < data_type > ( input2 ) ; const size_t input2_elements = input2 -> bytes / sizeof ( data_type ) ; for ( size_t i = 0 ; i < input2_elements ; i ++ ) { TF_LITE_ENSURE ( context , input2_data [ i ] != 0 ) ; } <S2SV_ModStart> type == kTfLiteFloat32 ) { EvalDiv < kernel_type > ( context , node , params , data , input1 , input2 , output ) ; } else if ( <S2SV_ModEnd> output -> type <S2SV_ModStart> kTfLiteInt32 ) { TF_LITE_CHECK_DIV_NON_ZERO ( int32_t ) ; <S2SV_ModStart> kTfLiteUInt8 ) { TF_LITE_CHECK_DIV_NON_ZERO ( uint8_t ) ; <S2SV_ModStart> kTfLiteError ; } # undef TF_LITE_CHECK_DIV_NON_ZERO"}
{"source": "CWE-787 GF_Err afra_box_read ( GF_Box * s , GF_BitStream * bs ) { unsigned int i ; GF_AdobeFragRandomAccessBox * ptr = ( GF_AdobeFragRandomAccessBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 9 ) ptr -> long_ids = gf_bs_read_int ( bs , 1 ) ; ptr -> long_offsets = gf_bs_read_int ( bs , 1 ) ; ptr -> global_entries = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 5 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> entry_count = gf_bs_read_u32 ( bs ) ; if ( ptr -> size / ( ( ptr -> long_offsets ? 16 : 12 ) ) < ptr -> entry_count ) return GF_ISOM_INVALID_FILE ; for ( i = 0 ; i < ptr -> entry_count ; i ++ ) { GF_AfraEntry * ae = gf_malloc ( sizeof ( GF_AfraEntry ) ) ; if ( ! ae ) return GF_OUT_OF_MEM ; <S2SV_StartBug> <S2SV_EndBug> ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> time = gf_bs_read_u64 ( bs ) ; if ( ptr -> long_offsets ) { ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> offset = gf_bs_read_u64 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) ae -> offset = gf_bs_read_u32 ( bs ) ; } <S2SV_StartBug> gf_list_insert ( ptr -> local_access_entries , ae , i ) ; <S2SV_EndBug> } if ( ptr -> global_entries ) { ISOM_DECREASE_SIZE ( ptr , 4 ) ptr -> global_entry_count = gf_bs_read_u32 ( bs ) ; for ( i = 0 ; i < ptr -> global_entry_count ; i ++ ) { GF_GlobalAfraEntry * ae = gf_malloc ( sizeof ( GF_GlobalAfraEntry ) ) ; if ( ! ae ) return GF_OUT_OF_MEM ; <S2SV_StartBug> ISOM_DECREASE_SIZE ( ptr , 8 ) <S2SV_EndBug> ae -> time = gf_bs_read_u64 ( bs ) ; if ( ptr -> long_ids ) { ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> segment = gf_bs_read_u32 ( bs ) ; ae -> fragment = gf_bs_read_u32 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) ae -> segment = gf_bs_read_u16 ( bs ) ; ae -> fragment = gf_bs_read_u16 ( bs ) ; } if ( ptr -> long_offsets ) { ISOM_DECREASE_SIZE ( ptr , 16 ) ae -> afra_offset = gf_bs_read_u64 ( bs ) ; ae -> offset_from_afra = gf_bs_read_u64 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> afra_offset = gf_bs_read_u32 ( bs ) ; ae -> offset_from_afra = gf_bs_read_u32 ( bs ) ; } <S2SV_StartBug> gf_list_insert ( ptr -> global_access_entries , ae , i ) ; <S2SV_EndBug> } } return GF_OK ; }", "target": "<S2SV_ModStart> return GF_OUT_OF_MEM ; gf_list_insert ( ptr -> local_access_entries , ae , i ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> } if ( <S2SV_ModStart> return GF_OUT_OF_MEM ; gf_list_insert ( ptr -> global_access_entries , ae , i ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> } } return"}
{"source": "CWE-20 void Compute ( OpKernelContext * ctx ) override { const Tensor & input = ctx -> input ( kInputTensorIndex ) ; const Tensor & input_min = ctx -> input ( kInputMinIndex ) ; const Tensor & input_max = ctx -> input ( kInputMaxIndex ) ; const size_t depth = input_max . NumElements ( ) ; OP_REQUIRES ( ctx , input_min . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"input_min<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>was<S2SV_blank>\" , input_min . dim_size ( 0 ) ) ) ; OP_REQUIRES ( ctx , input_max . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"input_max<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>expected<S2SV_blank>\" , <S2SV_StartBug> depth , \"<S2SV_blank>was<S2SV_blank>\" , input_max . dim_size ( 0 ) ) ) ; <S2SV_EndBug> const float * input_min_data = input_min . flat < float > ( ) . data ( ) ; const float * input_max_data = input_max . flat < float > ( ) . data ( ) ; std : : vector < float > ranges ( depth ) ; bool is_non_negative = true ; Eigen : : array < int , 2 > shuffling ( { 1 , 0 } ) ; auto input_matrix = input . flat_inner_dims < qint32 > ( ) ; auto transposed_input = input_matrix . shuffle ( shuffling ) ; float out_min_max = std : : numeric_limits < float > : : min ( ) ; # ifdef ENABLE_ONEDNN_OPENMP # ifdef _MSC_VER # pragma omp parallel for # else # pragma omp parallel for reduction ( max : out_min_max ) # endif # endif for ( int64_t i = 0 ; i < depth ; ++ i ) { Eigen : : Tensor < qint32 , 0 , Eigen : : RowMajor > min = transposed_input . chip < 0 > ( i ) . minimum ( ) ; Eigen : : Tensor < qint32 , 0 , Eigen : : RowMajor > max = transposed_input . chip < 0 > ( i ) . maximum ( ) ; const int32_t min_per_channel = min ( ) ; const int32_t max_per_channel = max ( ) ; const int32_t abs_max = std : : max ( std : : abs ( min_per_channel ) , std : : abs ( max_per_channel ) ) ; float scale = std : : max ( std : : abs ( input_min_data [ i ] ) , std : : abs ( input_max_data [ i ] ) ) ; ranges [ i ] = scale * static_cast < float > ( abs_max ) / static_cast < float > ( 1L << 31 ) ; if ( min_per_channel < 0 ) is_non_negative = false ; out_min_max = std : : max ( out_min_max , ranges [ i ] ) ; } if ( out_min_max > clip_value_max_ ) out_min_max = clip_value_max_ ; Tensor * output_min = nullptr ; Tensor * output_max = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( kOutputMinIndex , { } , & output_min ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( kOutputMaxIndex , { } , & output_max ) ) ; output_min -> flat < float > ( ) ( 0 ) = is_non_negative ? 0.0f : - out_min_max ; output_max -> flat < float > ( ) ( 0 ) = out_min_max ; }", "target": "<S2SV_ModStart> ( 0 ) ) ) ; OP_REQUIRES ( ctx , input_min . NumElements ( ) == depth , errors : : InvalidArgument ( \"input_min<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>number<S2SV_blank>of<S2SV_blank>\" \"elements<S2SV_blank>as<S2SV_blank>input_max,<S2SV_blank>got<S2SV_blank>\" , input_min . NumElements ( ) , \"<S2SV_blank>and<S2SV_blank>\" , depth ) ) ; OP_REQUIRES ( ctx , input . NumElements ( ) > 0 , errors : : InvalidArgument ( \"input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty\" ) ) ; OP_REQUIRES ( ctx , input . dims ( ) == 4 , errors : : InvalidArgument ( \"input<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>NHWC<S2SV_blank>format\" ) ) ; OP_REQUIRES ( ctx , input . dim_size ( 3 ) == depth , errors : : InvalidArgument ( \"input<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>number<S2SV_blank>of<S2SV_blank>channels<S2SV_blank>as<S2SV_blank>length<S2SV_blank>of<S2SV_blank>input_min:<S2SV_blank>\" , input . dim_size ( 3 ) , \"<S2SV_blank>vs<S2SV_blank>\" , depth"}
{"source": "CWE-284 int pgpPrtParams ( const uint8_t * pkts , size_t pktlen , unsigned int pkttype , pgpDigParams * ret ) { const uint8_t * p = pkts ; const uint8_t * pend = pkts + pktlen ; pgpDigParams digp = NULL ; <S2SV_StartBug> struct pgpPkt pkt ; <S2SV_EndBug> int rc = - 1 ; <S2SV_StartBug> <S2SV_EndBug> while ( p < pend ) { <S2SV_StartBug> if ( decodePkt ( p , ( pend - p ) , & pkt ) ) <S2SV_EndBug> break ; if ( digp == NULL ) { <S2SV_StartBug> if ( pkttype && pkt . tag != pkttype ) { <S2SV_EndBug> break ; } else { <S2SV_StartBug> digp = pgpDigParamsNew ( pkt . tag ) ; <S2SV_EndBug> } } <S2SV_StartBug> if ( pgpPrtPkt ( & pkt , digp ) ) <S2SV_EndBug> break ; <S2SV_StartBug> p += ( pkt . body - pkt . head ) + pkt . blen ; <S2SV_EndBug> if ( pkttype == PGPTAG_SIGNATURE ) break ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> rc = ( digp && ( p == pend ) ) ? 0 : - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret && rc == 0 ) { <S2SV_EndBug> * ret = digp ; } else { pgpDigParamsFree ( digp ) ; } return rc ; }", "target": "<S2SV_ModStart> = NULL ; pgpDigParams selfsig = NULL ; int i = 0 ; int alloced = 16 ; struct pgpPkt * all = xmalloc ( alloced * sizeof ( * all ) ) <S2SV_ModEnd> ; int rc <S2SV_ModStart> - 1 ; int expect = 0 ; int prevtag = 0 ; <S2SV_ModStart> pend ) { struct pgpPkt * pkt = & all [ i ] ; <S2SV_ModStart> p ) , <S2SV_ModEnd> pkt ) ) <S2SV_ModStart> pkttype && pkt -> <S2SV_ModEnd> tag != pkttype <S2SV_ModStart> pgpDigParamsNew ( pkt -> tag ) ; } } if ( expect ) { if ( pkt -> tag != expect ) break ; selfsig = pgpDigParamsNew ( pkt -> tag ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ( pgpPrtPkt ( pkt , selfsig ? selfsig : digp ) ) break ; if ( selfsig ) { if ( prevtag == PGPTAG_PUBLIC_SUBKEY ) { if ( selfsig -> sigtype != PGPSIGTYPE_SUBKEY_BINDING ) break ; } int xx = pgpVerifySelf ( digp , selfsig , all , i ) ; selfsig = pgpDigParamsFree ( selfsig ) ; if ( xx ) break ; expect = 0 ; } if ( pkt -> tag == PGPTAG_PUBLIC_SUBKEY ) expect = PGPTAG_SIGNATURE ; prevtag = pkt -> tag ; i ++ ; <S2SV_ModEnd> p += ( <S2SV_ModStart> += ( pkt -> <S2SV_ModEnd> body - pkt <S2SV_ModStart> body - pkt -> <S2SV_ModEnd> head ) + <S2SV_ModStart> ) + pkt -> <S2SV_ModEnd> blen ; if <S2SV_ModStart> ) break ; if ( alloced <= i ) { alloced *= 2 ; all = xrealloc ( all , alloced * sizeof ( * all ) ) ; } <S2SV_ModStart> == pend ) && expect == 0 <S2SV_ModStart> - 1 ; free ( all ) ;"}
{"source": "CWE-362 void DefaultCertValidator : : updateDigestForSessionId ( bssl : : ScopedEVP_MD_CTX & md , uint8_t hash_buffer [ EVP_MAX_MD_SIZE ] , unsigned hash_length ) { int rc ; if ( ca_cert_ != nullptr ) { rc = X509_digest ( ca_cert_ . get ( ) , EVP_sha256 ( ) , hash_buffer , & hash_length ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; RELEASE_ASSERT ( hash_length == SHA256_DIGEST_LENGTH , fmt : : format ( \"invalid<S2SV_blank>SHA256<S2SV_blank>hash<S2SV_blank>length<S2SV_blank>{}\" , hash_length ) ) ; rc = EVP_DigestUpdate ( md . get ( ) , hash_buffer , hash_length ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; } for ( const auto & hash : verify_certificate_hash_list_ ) { rc = EVP_DigestUpdate ( md . get ( ) , hash . data ( ) , hash . size ( ) * sizeof ( std : : remove_reference < decltype ( hash ) > : : type : : value_type ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; } for ( const auto & hash : verify_certificate_spki_list_ ) { rc = EVP_DigestUpdate ( md . get ( ) , hash . data ( ) , hash . size ( ) * sizeof ( std : : remove_reference < decltype ( hash ) > : : type : : value_type ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; } <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> ) ; } rc = EVP_DigestUpdate ( md . get ( ) , & verify_trusted_ca_ , sizeof ( verify_trusted_ca_ ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; if ( config_ != nullptr ) { for ( const auto & matcher : config_ -> subjectAltNameMatchers ( ) ) { size_t hash = MessageUtil : : hash ( matcher ) ; rc = EVP_DigestUpdate ( md . get ( ) , & hash , sizeof ( hash ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; } const std : : string & crl = config_ -> certificateRevocationList ( ) ; if ( ! crl . empty ( ) ) { rc = EVP_DigestUpdate ( md . get ( ) , crl . data ( ) , crl . length ( ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; } bool allow_expired = config_ -> allowExpiredCertificate ( ) ; rc = EVP_DigestUpdate ( md . get ( ) , & allow_expired , sizeof ( allow_expired ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; auto trust_chain_verification = config_ -> trustChainVerification ( ) ; rc = EVP_DigestUpdate ( md . get ( ) , & trust_chain_verification , sizeof ( trust_chain_verification ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; auto only_leaf_crl = config_ -> onlyVerifyLeafCertificateCrl ( ) ; rc = EVP_DigestUpdate ( md . get ( ) , & only_leaf_crl , sizeof ( only_leaf_crl ) ) ; RELEASE_ASSERT ( rc == 1 , Utility : : getLastCryptoError ( ) . value_or ( \"\" ) ) ; } } <S2SV_ModEnd>  <S2SV_null> <S2SV_null>"}
{"source": "CWE-399 Integer InvertibleRWFunction : : CalculateInverse ( RandomNumberGenerator & rng , const Integer & x ) const { DoQuickSanityCheck ( ) ; ModularArithmetic modn ( m_n ) ; Integer r , rInv ; do { r . Randomize ( rng , Integer : : One ( ) , m_n - Integer : : One ( ) ) ; <S2SV_StartBug> rInv = modn . MultiplicativeInverse ( r ) ; <S2SV_EndBug> } while ( rInv . IsZero ( ) ) ; Integer re = modn . Square ( r ) ; re = modn . Multiply ( re , x ) ; Integer cp = re % m_p , cq = re % m_q ; if ( Jacobi ( cp , m_p ) * Jacobi ( cq , m_q ) != 1 ) { cp = cp . IsOdd ( ) ? ( cp + m_p ) >> 1 : cp >> 1 ; cq = cq . IsOdd ( ) ? ( cq + m_q ) >> 1 : cq >> 1 ; } # pragma omp parallel # pragma omp sections { # pragma omp section cp = ModularSquareRoot ( cp , m_p ) ; # pragma omp section cq = ModularSquareRoot ( cq , m_q ) ; } Integer y = CRT ( cq , m_q , cp , m_p , m_u ) ; y = modn . Multiply ( y , rInv ) ; y = STDMIN ( y , m_n - y ) ; if ( ApplyFunction ( y ) != x ) throw Exception ( Exception : : OTHER_ERROR , \"InvertibleRWFunction:<S2SV_blank>computational<S2SV_blank>error<S2SV_blank>during<S2SV_blank>private<S2SV_blank>key<S2SV_blank>operation\" ) ; return y ; }", "target": "<S2SV_ModStart> ) ) ; r = modn . Square ( r ) ;"}
{"source": "CWE-369 Status DecodeImageAPNG ( Span < const uint8_t > bytes , ThreadPool * pool , CodecInOut * io ) { Reader r ; unsigned int id , i , j , w , h , w0 , h0 , x0 , y0 ; unsigned int delay_num , delay_den , dop , bop , rowbytes , imagesize ; unsigned char sig [ 8 ] ; png_structp png_ptr ; png_infop info_ptr ; CHUNK chunk ; CHUNK chunkIHDR ; std : : vector < CHUNK > chunksInfo ; bool isAnimated = false ; bool skipFirst = false ; bool hasInfo = false ; bool all_dispose_bg = true ; APNGFrame frameRaw = { } ; r = { bytes . data ( ) , bytes . data ( ) + bytes . size ( ) } ; unsigned char png_signature [ 8 ] = { 137 , 80 , 78 , 71 , 13 , 10 , 26 , 10 } ; if ( r . Read ( sig , 8 ) || memcmp ( sig , png_signature , 8 ) != 0 ) { return false ; } id = read_chunk ( & r , & chunkIHDR ) ; io -> frames . clear ( ) ; io -> dec_pixels = 0 ; io -> metadata . m . SetUintSamples ( 8 ) ; io -> metadata . m . SetAlphaBits ( 8 ) ; io -> metadata . m . color_encoding = ColorEncoding : : SRGB ( ) ; ( void ) io -> dec_hints . Foreach ( [ ] ( const std : : string & key , const std : : string & ) { JXL_WARNING ( \"APNG<S2SV_blank>decoder<S2SV_blank>ignoring<S2SV_blank>%s<S2SV_blank>hint\" , key . c_str ( ) ) ; return true ; } ) ; bool errorstate = true ; if ( id == kId_IHDR && chunkIHDR . size == 25 ) { w0 = w = png_get_uint_32 ( chunkIHDR . p + 8 ) ; h0 = h = png_get_uint_32 ( chunkIHDR . p + 12 ) ; if ( w > cMaxPNGSize || h > cMaxPNGSize ) { return false ; } x0 = 0 ; y0 = 0 ; delay_num = 1 ; delay_den = 10 ; dop = 0 ; bop = 0 ; rowbytes = w * 4 ; imagesize = h * rowbytes ; frameRaw . p = new unsigned char [ imagesize ] ; frameRaw . rows = new png_bytep [ h * sizeof ( png_bytep ) ] ; for ( j = 0 ; j < h ; j ++ ) frameRaw . rows [ j ] = frameRaw . p + j * rowbytes ; if ( ! processing_start ( png_ptr , info_ptr , ( void * ) & frameRaw , hasInfo , chunkIHDR , chunksInfo ) ) { bool last_base_was_none = true ; while ( ! r . Eof ( ) ) { id = read_chunk ( & r , & chunk ) ; if ( ! id ) break ; JXL_ASSERT ( chunk . p != nullptr ) ; if ( id == kId_acTL && ! hasInfo && ! isAnimated ) { isAnimated = true ; skipFirst = true ; io -> metadata . m . have_animation = true ; io -> metadata . m . animation . tps_numerator = 1000 ; } else if ( id == kId_IEND || ( id == kId_fcTL && ( ! hasInfo || isAnimated ) ) ) { if ( hasInfo ) { if ( ! processing_finish ( png_ptr , info_ptr ) ) { ImageBundle bundle ( & io -> metadata . m ) ; bundle . duration = delay_num * 1000 / delay_den ; bundle . origin . x0 = x0 ; bundle . origin . y0 = y0 ; if ( last_base_was_none && ! all_dispose_bg && ( x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0 ) ) { return JXL_FAILURE ( \"APNG<S2SV_blank>with<S2SV_blank>dispose-to-0<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>non-full<S2SV_blank>or<S2SV_blank>\" \"blended<S2SV_blank>frames\" ) ; } switch ( dop ) { case 0 : bundle . use_for_next_frame = true ; last_base_was_none = false ; all_dispose_bg = false ; break ; case 2 : bundle . use_for_next_frame = false ; all_dispose_bg = false ; break ; default : bundle . use_for_next_frame = false ; last_base_was_none = true ; } bundle . blend = bop != 0 ; io -> dec_pixels += w0 * h0 ; Image3F sub_frame ( w0 , h0 ) ; ImageF sub_frame_alpha ( w0 , h0 ) ; for ( size_t y = 0 ; y < h0 ; ++ y ) { float * const JXL_RESTRICT row_r = sub_frame . PlaneRow ( 0 , y ) ; float * const JXL_RESTRICT row_g = sub_frame . PlaneRow ( 1 , y ) ; float * const JXL_RESTRICT row_b = sub_frame . PlaneRow ( 2 , y ) ; float * const JXL_RESTRICT row_alpha = sub_frame_alpha . Row ( y ) ; uint8_t * const f = frameRaw . rows [ y ] ; for ( size_t x = 0 ; x < w0 ; ++ x ) { if ( f [ 4 * x + 3 ] == 0 ) { row_alpha [ x ] = 0 ; row_r [ x ] = 0 ; row_g [ x ] = 0 ; row_b [ x ] = 0 ; continue ; } row_r [ x ] = f [ 4 * x + 0 ] * ( 1.f / 255 ) ; row_g [ x ] = f [ 4 * x + 1 ] * ( 1.f / 255 ) ; row_b [ x ] = f [ 4 * x + 2 ] * ( 1.f / 255 ) ; row_alpha [ x ] = f [ 4 * x + 3 ] * ( 1.f / 255 ) ; } } bundle . SetFromImage ( std : : move ( sub_frame ) , ColorEncoding : : SRGB ( ) ) ; bundle . SetAlpha ( std : : move ( sub_frame_alpha ) , false ) ; io -> frames . push_back ( std : : move ( bundle ) ) ; } else { delete [ ] chunk . p ; break ; } } if ( id == kId_IEND ) { errorstate = false ; break ; } w0 = png_get_uint_32 ( chunk . p + 12 ) ; h0 = png_get_uint_32 ( chunk . p + 16 ) ; x0 = png_get_uint_32 ( chunk . p + 20 ) ; y0 = png_get_uint_32 ( chunk . p + 24 ) ; delay_num = png_get_uint_16 ( chunk . p + 28 ) ; delay_den = png_get_uint_16 ( chunk . p + 30 ) ; dop = chunk . p [ 32 ] ; <S2SV_StartBug> bop = chunk . p [ 33 ] ; <S2SV_EndBug> if ( w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize || y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 || bop > 1 ) { delete [ ] chunk . p ; break ; } if ( hasInfo ) { memcpy ( chunkIHDR . p + 8 , chunk . p + 12 , 8 ) ; if ( processing_start ( png_ptr , info_ptr , ( void * ) & frameRaw , hasInfo , chunkIHDR , chunksInfo ) ) { delete [ ] chunk . p ; break ; } } else skipFirst = false ; if ( io -> frames . size ( ) == ( skipFirst ? 1 : 0 ) ) { bop = 0 ; if ( dop == 2 ) dop = 1 ; } } else if ( id == kId_IDAT ) { hasInfo = true ; if ( processing_data ( png_ptr , info_ptr , chunk . p , chunk . size ) ) { delete [ ] chunk . p ; break ; } } else if ( id == kId_fdAT && isAnimated ) { png_save_uint_32 ( chunk . p + 4 , chunk . size - 16 ) ; memcpy ( chunk . p + 8 , \"IDAT\" , 4 ) ; if ( processing_data ( png_ptr , info_ptr , chunk . p + 4 , chunk . size - 4 ) ) { delete [ ] chunk . p ; break ; } } else if ( ! isAbc ( chunk . p [ 4 ] ) || ! isAbc ( chunk . p [ 5 ] ) || ! isAbc ( chunk . p [ 6 ] ) || ! isAbc ( chunk . p [ 7 ] ) ) { delete [ ] chunk . p ; break ; } else if ( ! hasInfo ) { if ( processing_data ( png_ptr , info_ptr , chunk . p , chunk . size ) ) { delete [ ] chunk . p ; break ; } chunksInfo . push_back ( chunk ) ; continue ; } delete [ ] chunk . p ; } } delete [ ] frameRaw . rows ; delete [ ] frameRaw . p ; } for ( i = 0 ; i < chunksInfo . size ( ) ; i ++ ) delete [ ] chunksInfo [ i ] . p ; chunksInfo . clear ( ) ; delete [ ] chunkIHDR . p ; if ( errorstate ) return false ; SetIntensityTarget ( io ) ; return true ; }", "target": "<S2SV_ModStart> [ 33 ] ; if ( ! delay_den ) delay_den = 100"}
{"source": "CWE-476 GF_Err SetupWriters ( MovieWriter * mw , GF_List * writers , u8 interleaving ) { u32 i , trackCount ; TrackWriter * writer ; GF_TrackBox * trak ; GF_ISOFile * movie = mw -> movie ; mw -> total_samples = mw -> nb_done = 0 ; if ( ! movie -> moov ) return GF_OK ; trackCount = gf_list_count ( movie -> moov -> trackList ) ; for ( i = 0 ; i < trackCount ; i ++ ) { <S2SV_StartBug> trak = gf_isom_get_track ( movie -> moov , i + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> GF_SAFEALLOC ( writer , TrackWriter ) ; <S2SV_EndBug> if ( ! writer ) goto exit ; writer -> sampleNumber = 1 ; writer -> mdia = trak -> Media ; writer -> stbl = trak -> Media -> information -> sampleTable ; writer -> timeScale = trak -> Media -> mediaHeader -> timeScale ; writer -> all_dref_mode = Media_SelfContainedType ( writer -> mdia ) ; if ( trak -> sample_encryption ) writer -> prevent_dispatch = GF_TRUE ; writer -> isDone = 0 ; writer -> DTSprev = 0 ; writer -> chunkDur = 0 ; writer -> chunkSize = 0 ; writer -> constant_size = writer -> constant_dur = 0 ; if ( writer -> stbl -> SampleSize -> sampleSize ) writer -> constant_size = writer -> stbl -> SampleSize -> sampleSize ; if ( writer -> stbl -> TimeToSample -> nb_entries == 1 ) { writer -> constant_dur = writer -> stbl -> TimeToSample -> entries [ 0 ] . sampleDelta ; if ( writer -> constant_dur > 1 ) writer -> constant_dur = 0 ; } if ( ! writer -> constant_dur || ! writer -> constant_size || ( writer -> constant_size >= 10 ) ) writer -> constant_size = writer -> constant_dur = 0 ; writer -> stsc = ( GF_SampleToChunkBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_STSC ) ; if ( ! writer -> stsc ) return GF_OUT_OF_MEM ; if ( writer -> stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_STCO ) ; } else { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_CO64 ) ; } if ( ! writer -> stco ) return GF_OUT_OF_MEM ; if ( interleaving ) writer -> stbl -> MaxSamplePerChunk = 0 ; if ( Media_IsSelfContained ( writer -> mdia , 1 ) ) mw -> total_samples += writer -> stbl -> SampleSize -> sampleCount ; if ( movie -> storageMode != GF_ISOM_STORE_INTERLEAVED ) { gf_list_add ( writers , writer ) ; } else { if ( writer -> mdia -> information -> InfoHeader && writer -> mdia -> information -> InfoHeader -> type == GF_ISOM_BOX_TYPE_SMHD ) { gf_list_add ( writers , writer ) ; } else { gf_list_insert ( writers , writer , 0 ) ; } } if ( movie -> sample_groups_in_traf && trak -> Media -> information -> sampleTable ) { gf_isom_box_array_del_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; trak -> Media -> information -> sampleTable -> sampleGroupsDescription = NULL ; } } return GF_OK ; exit : CleanWriters ( writers ) ; return GF_OUT_OF_MEM ; }", "target": "<S2SV_ModStart> ++ ) { GF_SampleTableBox * stbl ; <S2SV_ModStart> 1 ) ; stbl = ( trak -> Media && trak -> Media -> information ) ? trak -> Media -> information -> sampleTable : NULL ; if ( ! stbl || ! stbl -> SampleSize || ! stbl -> ChunkOffset || ! stbl -> SampleToChunk ) { return GF_ISOM_INVALID_FILE ; }"}
{"source": "CWE-552 <S2SV_StartBug> int HttpFileImpl : : save ( const std : : string & path ) const <S2SV_EndBug> { assert ( ! path . empty ( ) ) ; <S2SV_StartBug> if ( fileName_ . empty ( ) ) <S2SV_EndBug> return - 1 ; filesystem : : path fsPath ( utils : : toNativePath ( path ) ) ; if ( ! fsPath . is_absolute ( ) && <S2SV_StartBug> ( ! fsPath . has_parent_path ( ) || <S2SV_EndBug> <S2SV_StartBug> ( fsPath . begin ( ) -> string ( ) != \".\" && fsPath . begin ( ) -> string ( ) != \"..\" ) ) ) <S2SV_EndBug> { filesystem : : path fsUploadPath ( utils : : toNativePath ( HttpAppFrameworkImpl : : instance ( ) . getUploadPath ( ) ) ) ; <S2SV_StartBug> fsPath = fsUploadPath / fsPath ; <S2SV_EndBug> } filesystem : : path fsFileName ( utils : : toNativePath ( fileName_ ) ) ; <S2SV_StartBug> if ( ! filesystem : : exists ( fsPath ) ) <S2SV_EndBug> { <S2SV_StartBug> LOG_TRACE << \"create<S2SV_blank>path:\" << fsPath ; <S2SV_EndBug> drogon : : error_code err ; <S2SV_StartBug> filesystem : : create_directories ( fsPath , err ) ; <S2SV_EndBug> if ( err ) { LOG_SYSERR ; return - 1 ; } } <S2SV_StartBug> return saveTo ( fsPath / fsFileName ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> HttpFileImpl : : saveAs <S2SV_ModEnd> ( const std <S2SV_ModStart> : string & fileName ) const { assert ( ! fileName . empty ( ) ) ; filesystem : : path fsFileName ( utils : : toNativePath ( fileName <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; if ( ! fsFileName <S2SV_ModEnd> . is_absolute ( <S2SV_ModStart> ( ) && ( ! fsFileName <S2SV_ModEnd> . has_parent_path ( <S2SV_ModStart> ) || ( fsFileName <S2SV_ModEnd> . begin ( <S2SV_ModStart> != \".\" && fsFileName <S2SV_ModEnd> . begin ( <S2SV_ModStart> ) ) ; fsFileName <S2SV_ModEnd> = fsUploadPath / <S2SV_ModStart> = fsUploadPath / fsFileName ; } if ( fsFileName . has_parent_path ( ) && <S2SV_ModEnd> ! filesystem : <S2SV_ModStart> : exists ( fsFileName . parent_path ( ) <S2SV_ModEnd> ) ) { <S2SV_ModStart> << \"create<S2SV_blank>path:\" << fsFileName . parent_path ( ) <S2SV_ModEnd> ; drogon : <S2SV_ModStart> : create_directories ( fsFileName . parent_path ( ) <S2SV_ModEnd> , err ) <S2SV_ModStart> return saveTo ( <S2SV_ModEnd> fsFileName ) ;"}
{"source": "CWE-369 inline void BinaryBroadcastFiveFold ( const ArithmeticParams & unswitched_params , const RuntimeShape & unswitched_input1_shape , const T * unswitched_input1_data , const RuntimeShape & unswitched_input2_shape , const T * unswitched_input2_data , const RuntimeShape & output_shape , T * output_data , ElementwiseF elementwise_f , ScalarBroadcastF scalar_broadcast_f ) { ArithmeticParams switched_params = unswitched_params ; switched_params . input1_offset = unswitched_params . input2_offset ; switched_params . input1_multiplier = unswitched_params . input2_multiplier ; switched_params . input1_shift = unswitched_params . input2_shift ; switched_params . input2_offset = unswitched_params . input1_offset ; switched_params . input2_multiplier = unswitched_params . input1_multiplier ; switched_params . input2_shift = unswitched_params . input1_shift ; const bool use_unswitched = unswitched_params . broadcast_category == tflite : : BroadcastableOpCategory : : kFirstInputBroadcastsFast ; const ArithmeticParams & params = use_unswitched ? unswitched_params : switched_params ; const T * input1_data = use_unswitched ? unswitched_input1_data : unswitched_input2_data ; const T * input2_data = use_unswitched ? unswitched_input2_data : unswitched_input1_data ; T * output_data_ptr = output_data ; const T * input1_data_ptr = input1_data ; const T * input2_data_reset = input2_data ; int y0 = params . broadcast_shape [ 0 ] ; int y1 = params . broadcast_shape [ 1 ] ; int y2 = params . broadcast_shape [ 2 ] ; int y3 = params . broadcast_shape [ 3 ] ; int y4 = params . broadcast_shape [ 4 ] ; if ( y4 > 1 ) { for ( int i0 = 0 ; i0 < y0 ; ++ i0 ) { const T * input2_data_ptr = nullptr ; for ( int i1 = 0 ; i1 < y1 ; ++ i1 ) { input2_data_ptr = input2_data_reset ; for ( int i2 = 0 ; i2 < y2 ; ++ i2 ) { for ( int i3 = 0 ; i3 < y3 ; ++ i3 ) { elementwise_f ( y4 , params , input1_data_ptr , input2_data_ptr , output_data_ptr ) ; input2_data_ptr += y4 ; output_data_ptr += y4 ; } input1_data_ptr += y4 ; } } input2_data_reset = input2_data_ptr ; } <S2SV_StartBug> } else { <S2SV_EndBug> for ( int i0 = 0 ; i0 < y0 ; ++ i0 ) { const T * input2_data_ptr = nullptr ; for ( int i1 = 0 ; i1 < y1 ; ++ i1 ) { input2_data_ptr = input2_data_reset ; for ( int i2 = 0 ; i2 < y2 ; ++ i2 ) { scalar_broadcast_f ( y3 , params , * input1_data_ptr , input2_data_ptr , output_data_ptr ) ; input2_data_ptr += y3 ; output_data_ptr += y3 ; input1_data_ptr += 1 ; } } input2_data_reset = input2_data_ptr ; } } }", "target": "<S2SV_ModStart> } } else if ( input1_data_ptr != nullptr )"}
{"source": "CWE-20 static int DecodeChunk ( EXRImage * exr_image , const EXRHeader * exr_header , const std : : vector < tinyexr : : tinyexr_uint64 > & offsets , const unsigned char * head , const size_t size , std : : string * err ) { int num_channels = exr_header -> num_channels ; int num_scanline_blocks = 1 ; if ( exr_header -> compression_type == TINYEXR_COMPRESSIONTYPE_ZIP ) { num_scanline_blocks = 16 ; } else if ( exr_header -> compression_type == TINYEXR_COMPRESSIONTYPE_PIZ ) { num_scanline_blocks = 32 ; } else if ( exr_header -> compression_type == TINYEXR_COMPRESSIONTYPE_ZFP ) { num_scanline_blocks = 16 ; } int data_width = exr_header -> data_window [ 2 ] - exr_header -> data_window [ 0 ] + 1 ; int data_height = exr_header -> data_window [ 3 ] - exr_header -> data_window [ 1 ] + 1 ; if ( ( data_width < 0 ) || ( data_height < 0 ) ) { if ( err ) { std : : stringstream ss ; ss << \"Invalid<S2SV_blank>data<S2SV_blank>width<S2SV_blank>or<S2SV_blank>data<S2SV_blank>height:<S2SV_blank>\" << data_width << \",<S2SV_blank>\" << data_height << std : : endl ; ( * err ) += ss . str ( ) ; } return TINYEXR_ERROR_INVALID_DATA ; } { const int threshold = 1024 * 8192 ; if ( ( data_width > threshold ) || ( data_height > threshold ) ) { if ( err ) { std : : stringstream ss ; ss << \"data_with<S2SV_blank>or<S2SV_blank>data_height<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>data_width:<S2SV_blank>\" << data_width << \",<S2SV_blank>\" << \"data_height<S2SV_blank>=<S2SV_blank>\" << data_height << std : : endl ; ( * err ) += ss . str ( ) ; } return TINYEXR_ERROR_INVALID_DATA ; } } size_t num_blocks = offsets . size ( ) ; std : : vector < size_t > channel_offset_list ; int pixel_data_size = 0 ; size_t channel_offset = 0 ; if ( ! tinyexr : : ComputeChannelLayout ( & channel_offset_list , & pixel_data_size , & channel_offset , num_channels , exr_header -> channels ) ) { if ( err ) { ( * err ) += \"Failed<S2SV_blank>to<S2SV_blank>compute<S2SV_blank>channel<S2SV_blank>layout.\\\\n\" ; } return TINYEXR_ERROR_INVALID_DATA ; } bool invalid_data = false ; if ( exr_header -> tiled ) { if ( exr_header -> tile_size_x < 0 ) { if ( err ) { std : : stringstream ss ; ss << \"Invalid<S2SV_blank>tile<S2SV_blank>size<S2SV_blank>x<S2SV_blank>:<S2SV_blank>\" << exr_header -> tile_size_x << \"\\\\n\" ; ( * err ) += ss . str ( ) ; } return TINYEXR_ERROR_INVALID_HEADER ; } if ( exr_header -> tile_size_y < 0 ) { if ( err ) { std : : stringstream ss ; ss << \"Invalid<S2SV_blank>tile<S2SV_blank>size<S2SV_blank>y<S2SV_blank>:<S2SV_blank>\" << exr_header -> tile_size_y << \"\\\\n\" ; ( * err ) += ss . str ( ) ; } return TINYEXR_ERROR_INVALID_HEADER ; } size_t num_tiles = offsets . size ( ) ; exr_image -> tiles = static_cast < EXRTile * > ( calloc ( sizeof ( EXRTile ) , static_cast < size_t > ( num_tiles ) ) ) ; for ( size_t tile_idx = 0 ; tile_idx < num_tiles ; tile_idx ++ ) { exr_image -> tiles [ tile_idx ] . images = tinyexr : : AllocateImage ( num_channels , exr_header -> channels , exr_header -> requested_pixel_types , exr_header -> tile_size_x , exr_header -> tile_size_y ) ; if ( offsets [ tile_idx ] + sizeof ( int ) * 5 > size ) { if ( err ) { ( * err ) += \"Insufficient<S2SV_blank>data<S2SV_blank>size.\\\\n\" ; } return TINYEXR_ERROR_INVALID_DATA ; } size_t data_size = size_t ( size - ( offsets [ tile_idx ] + sizeof ( int ) * 5 ) ) ; const unsigned char * data_ptr = reinterpret_cast < const unsigned char * > ( head + offsets [ tile_idx ] ) ; int tile_coordinates [ 4 ] ; memcpy ( tile_coordinates , data_ptr , sizeof ( int ) * 4 ) ; tinyexr : : swap4 ( reinterpret_cast < unsigned int * > ( & tile_coordinates [ 0 ] ) ) ; tinyexr : : swap4 ( reinterpret_cast < unsigned int * > ( & tile_coordinates [ 1 ] ) ) ; tinyexr : : swap4 ( reinterpret_cast < unsigned int * > ( & tile_coordinates [ 2 ] ) ) ; tinyexr : : swap4 ( reinterpret_cast < unsigned int * > ( & tile_coordinates [ 3 ] ) ) ; if ( tile_coordinates [ 2 ] != 0 ) { return TINYEXR_ERROR_UNSUPPORTED_FEATURE ; } if ( tile_coordinates [ 3 ] != 0 ) { return TINYEXR_ERROR_UNSUPPORTED_FEATURE ; } int data_len ; memcpy ( & data_len , data_ptr + 16 , sizeof ( int ) ) ; tinyexr : : swap4 ( reinterpret_cast < unsigned int * > ( & data_len ) ) ; if ( data_len < 4 || size_t ( data_len ) > data_size ) { if ( err ) { ( * err ) += \"Insufficient<S2SV_blank>data<S2SV_blank>length.\\\\n\" ; } return TINYEXR_ERROR_INVALID_DATA ; } data_ptr += 20 ; tinyexr : : DecodeTiledPixelData ( exr_image -> tiles [ tile_idx ] . images , & ( exr_image -> tiles [ tile_idx ] . width ) , & ( exr_image -> tiles [ tile_idx ] . height ) , exr_header -> requested_pixel_types , data_ptr , static_cast < size_t > ( data_len ) , exr_header -> compression_type , exr_header -> line_order , data_width , data_height , tile_coordinates [ 0 ] , tile_coordinates [ 1 ] , exr_header -> tile_size_x , exr_header -> tile_size_y , static_cast < size_t > ( pixel_data_size ) , static_cast < size_t > ( exr_header -> num_custom_attributes ) , exr_header -> custom_attributes , static_cast < size_t > ( exr_header -> num_channels ) , exr_header -> channels , channel_offset_list ) ; exr_image -> tiles [ tile_idx ] . offset_x = tile_coordinates [ 0 ] ; exr_image -> tiles [ tile_idx ] . offset_y = tile_coordinates [ 1 ] ; exr_image -> tiles [ tile_idx ] . level_x = tile_coordinates [ 2 ] ; exr_image -> tiles [ tile_idx ] . level_y = tile_coordinates [ 3 ] ; exr_image -> num_tiles = static_cast < int > ( num_tiles ) ; } } else { size_t total_data_len = size_t ( data_width ) * size_t ( data_height ) * size_t ( num_channels ) ; const bool total_data_len_overflown = sizeof ( void * ) == 8 ? ( total_data_len >= 0x4000000000 ) : false ; if ( ( total_data_len == 0 ) || total_data_len_overflown ) { if ( err ) { std : : stringstream ss ; ss << \"Image<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero<S2SV_blank>or<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>width<S2SV_blank>=<S2SV_blank>\" << data_width << \",<S2SV_blank>height<S2SV_blank>=<S2SV_blank>\" << data_height << \",<S2SV_blank>channels<S2SV_blank>=<S2SV_blank>\" << num_channels << std : : endl ; ( * err ) += ss . str ( ) ; } return TINYEXR_ERROR_INVALID_DATA ; } exr_image -> images = tinyexr : : AllocateImage ( num_channels , exr_header -> channels , exr_header -> requested_pixel_types , data_width , data_height ) ; # ifdef _OPENMP # pragma omp parallel for # endif for ( int y = 0 ; y < static_cast < int > ( num_blocks ) ; y ++ ) { size_t y_idx = static_cast < size_t > ( y ) ; if ( offsets [ y_idx ] + sizeof ( int ) * 2 > size ) { invalid_data = true ; } else { size_t data_size = size_t ( size - ( offsets [ y_idx ] + sizeof ( int ) * 2 ) ) ; const unsigned char * data_ptr = reinterpret_cast < const unsigned char * > ( head + offsets [ y_idx ] ) ; int line_no ; memcpy ( & line_no , data_ptr , sizeof ( int ) ) ; int data_len ; memcpy ( & data_len , data_ptr + 4 , sizeof ( int ) ) ; tinyexr : : swap4 ( reinterpret_cast < unsigned int * > ( & line_no ) ) ; tinyexr : : swap4 ( reinterpret_cast < unsigned int * > ( & data_len ) ) ; if ( size_t ( data_len ) > data_size ) { invalid_data = true ; <S2SV_StartBug> } else if ( data_len == 0 ) { <S2SV_EndBug> invalid_data = true ; } else { int end_line_no = ( std : : min ) ( line_no + num_scanline_blocks , ( exr_header -> data_window [ 3 ] + 1 ) ) ; int num_lines = end_line_no - line_no ; if ( num_lines <= 0 ) { invalid_data = true ; } else { data_ptr += 8 ; tinyexr_int64 lno = static_cast < tinyexr_int64 > ( line_no ) - static_cast < tinyexr_int64 > ( exr_header -> data_window [ 1 ] ) ; if ( lno > std : : numeric_limits < int > : : max ( ) ) { line_no = - 1 ; } else if ( lno < - std : : numeric_limits < int > : : max ( ) ) { line_no = - 1 ; } else { line_no -= exr_header -> data_window [ 1 ] ; } if ( line_no < 0 ) { invalid_data = true ; } else { if ( ! tinyexr : : DecodePixelData ( exr_image -> images , exr_header -> requested_pixel_types , data_ptr , static_cast < size_t > ( data_len ) , exr_header -> compression_type , exr_header -> line_order , data_width , data_height , data_width , y , line_no , num_lines , static_cast < size_t > ( pixel_data_size ) , static_cast < size_t > ( exr_header -> num_custom_attributes ) , exr_header -> custom_attributes , static_cast < size_t > ( exr_header -> num_channels ) , exr_header -> channels , channel_offset_list ) ) { invalid_data = true ; } } } } } } } if ( invalid_data ) { if ( err ) { std : : stringstream ss ; ( * err ) += \"Invalid<S2SV_blank>data<S2SV_blank>found<S2SV_blank>when<S2SV_blank>decoding<S2SV_blank>pixels.\\\\n\" ; } return TINYEXR_ERROR_INVALID_DATA ; } { for ( int c = 0 ; c < exr_header -> num_channels ; c ++ ) { exr_header -> pixel_types [ c ] = exr_header -> requested_pixel_types [ c ] ; } } { exr_image -> num_channels = num_channels ; exr_image -> width = data_width ; exr_image -> height = data_height ; } return TINYEXR_SUCCESS ; }", "target": "<S2SV_ModStart> = true ; } else if ( ( line_no > ( 2 << 20 ) ) || ( line_no < - ( 2 << 20 ) ) ) { invalid_data = true ;"}
{"source": "CWE-125 gen_assignment ( codegen_scope * s , node * tree , node * rhs , int sp , int val ) { int idx ; int type = nint ( tree -> car ) ; switch ( type ) { case NODE_GVAR : case NODE_ARG : case NODE_LVAR : case NODE_IVAR : case NODE_CVAR : case NODE_CONST : case NODE_NIL : case NODE_MASGN : if ( rhs ) { codegen ( s , rhs , VAL ) ; pop ( ) ; sp = cursp ( ) ; } break ; case NODE_COLON2 : case NODE_CALL : case NODE_SCALL : break ; case NODE_NVAR : codegen_error ( s , \"Can\\'t<S2SV_blank>assign<S2SV_blank>to<S2SV_blank>numbered<S2SV_blank>parameter\" ) ; break ; default : codegen_error ( s , \"unknown<S2SV_blank>lhs\" ) ; break ; } tree = tree -> cdr ; switch ( type ) { case NODE_GVAR : gen_setxv ( s , OP_SETGV , sp , nsym ( tree ) , val ) ; break ; case NODE_ARG : case NODE_LVAR : idx = lv_idx ( s , nsym ( tree ) ) ; if ( idx > 0 ) { if ( idx != sp ) { gen_move ( s , idx , sp , val ) ; } break ; } else { gen_setupvar ( s , sp , nsym ( tree ) ) ; } break ; case NODE_IVAR : gen_setxv ( s , OP_SETIV , sp , nsym ( tree ) , val ) ; break ; case NODE_CVAR : gen_setxv ( s , OP_SETCV , sp , nsym ( tree ) , val ) ; break ; case NODE_CONST : gen_setxv ( s , OP_SETCONST , sp , nsym ( tree ) , val ) ; break ; case NODE_COLON2 : if ( sp ) { gen_move ( s , cursp ( ) , sp , 0 ) ; } sp = cursp ( ) ; push ( ) ; codegen ( s , tree -> car , VAL ) ; if ( rhs ) { codegen ( s , rhs , VAL ) ; pop ( ) ; gen_move ( s , sp , cursp ( ) , 0 ) ; } pop_n ( 2 ) ; idx = new_sym ( s , nsym ( tree -> cdr ) ) ; genop_2 ( s , OP_SETMCNST , sp , idx ) ; break ; case NODE_CALL : case NODE_SCALL : { int noself = 0 , safe = ( type == NODE_SCALL ) , skip = 0 , top , call , n = 0 ; mrb_sym mid = nsym ( tree -> cdr -> car ) ; top = cursp ( ) ; if ( val || sp == cursp ( ) ) { push ( ) ; } call = cursp ( ) ; if ( ! tree -> car ) { noself = 1 ; push ( ) ; } else { codegen ( s , tree -> car , VAL ) ; } if ( safe ) { int recv = cursp ( ) - 1 ; gen_move ( s , cursp ( ) , recv , 1 ) ; skip = genjmp2_0 ( s , OP_JMPNIL , cursp ( ) , val ) ; } tree = tree -> cdr -> cdr -> car ; if ( tree ) { if ( tree -> car ) { n = gen_values ( s , tree -> car , VAL , ( tree -> cdr -> car ) ? 13 : 14 ) ; if ( n < 0 ) { n = 15 ; push ( ) ; } } if ( tree -> cdr -> car ) { if ( n == 14 ) { pop_n ( n ) ; genop_2 ( s , OP_ARRAY , cursp ( ) , n ) ; push ( ) ; n = 15 ; } gen_hash ( s , tree -> cdr -> car -> cdr , VAL , 0 ) ; if ( n < 14 ) { n ++ ; } else { pop_n ( 2 ) ; genop_2 ( s , OP_ARYPUSH , cursp ( ) , 1 ) ; } push ( ) ; } } if ( rhs ) { codegen ( s , rhs , VAL ) ; pop ( ) ; } else { gen_move ( s , cursp ( ) , sp , 0 ) ; } if ( val ) { gen_move ( s , top , cursp ( ) , 1 ) ; } <S2SV_StartBug> if ( n < 14 ) { <S2SV_EndBug> n ++ ; } else { pop ( ) ; genop_2 ( s , OP_ARYPUSH , cursp ( ) , 1 ) ; } s -> sp = call ; if ( mid == MRB_OPSYM_2 ( s -> mrb , aref ) && n == 2 ) { genop_1 ( s , OP_SETIDX , cursp ( ) ) ; } else { genop_3 ( s , noself ? OP_SSEND : OP_SEND , cursp ( ) , new_sym ( s , attrsym ( s , mid ) ) , n ) ; } if ( safe ) { dispatch ( s , skip ) ; } s -> sp = top ; } break ; case NODE_MASGN : gen_vmassignment ( s , tree -> car , sp , val ) ; break ; case NODE_NIL : break ; default : codegen_error ( s , \"unknown<S2SV_blank>lhs\" ) ; break ; } if ( val ) push ( ) ; }", "target": "<S2SV_ModStart> ( n < 15 ) { n ++ ; if ( n == 15 ) { pop_n ( 14 ) ; genop_2 ( s , OP_ARRAY , cursp ( ) , 15 ) ; } <S2SV_ModEnd> } else {"}
{"source": "CWE-703 ccp_run_aes_gcm_cmd ( struct ccp_cmd_queue * cmd_q , struct ccp_cmd * cmd ) { struct ccp_aes_engine * aes = & cmd -> u . aes ; struct ccp_dm_workarea key , ctx , final_wa , tag ; struct ccp_data src , dst ; struct ccp_data aad ; struct ccp_op op ; unsigned int dm_offset ; unsigned int authsize ; unsigned int jobid ; unsigned int ilen ; bool in_place = true ; __be64 * final ; int ret ; struct scatterlist * p_inp , sg_inp [ 2 ] ; struct scatterlist * p_tag , sg_tag [ 2 ] ; struct scatterlist * p_outp , sg_outp [ 2 ] ; struct scatterlist * p_aad ; if ( ! aes -> iv ) return - EINVAL ; if ( ! ( ( aes -> key_len == AES_KEYSIZE_128 ) || ( aes -> key_len == AES_KEYSIZE_192 ) || ( aes -> key_len == AES_KEYSIZE_256 ) ) ) return - EINVAL ; if ( ! aes -> key ) return - EINVAL ; authsize = aes -> authsize ? aes -> authsize : AES_BLOCK_SIZE ; switch ( authsize ) { case 16 : case 15 : case 14 : case 13 : case 12 : case 8 : case 4 : break ; default : return - EINVAL ; } p_aad = aes -> src ; p_inp = scatterwalk_ffwd ( sg_inp , aes -> src , aes -> aad_len ) ; p_outp = scatterwalk_ffwd ( sg_outp , aes -> dst , aes -> aad_len ) ; if ( aes -> action == CCP_AES_ACTION_ENCRYPT ) { ilen = aes -> src_len ; p_tag = scatterwalk_ffwd ( sg_tag , p_outp , ilen ) ; } else { ilen = aes -> src_len - authsize ; p_tag = scatterwalk_ffwd ( sg_tag , p_inp , ilen ) ; } jobid = CCP_NEW_JOBID ( cmd_q -> ccp ) ; memset ( & op , 0 , sizeof ( op ) ) ; op . cmd_q = cmd_q ; op . jobid = jobid ; op . sb_key = cmd_q -> sb_key ; op . sb_ctx = cmd_q -> sb_ctx ; op . init = 1 ; op . u . aes . type = aes -> type ; ret = ccp_init_dm_workarea ( & key , cmd_q , CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES , DMA_TO_DEVICE ) ; if ( ret ) return ret ; dm_offset = CCP_SB_BYTES - aes -> key_len ; ret = ccp_set_dm_area ( & key , dm_offset , aes -> key , 0 , aes -> key_len ) ; if ( ret ) goto e_key ; ret = ccp_copy_to_sb ( cmd_q , & key , op . jobid , op . sb_key , CCP_PASSTHRU_BYTESWAP_256BIT ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_key ; } ret = ccp_init_dm_workarea ( & ctx , cmd_q , CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES , DMA_BIDIRECTIONAL ) ; if ( ret ) goto e_key ; dm_offset = CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES - aes -> iv_len ; ret = ccp_set_dm_area ( & ctx , dm_offset , aes -> iv , 0 , aes -> iv_len ) ; if ( ret ) goto e_ctx ; ret = ccp_copy_to_sb ( cmd_q , & ctx , op . jobid , op . sb_ctx , CCP_PASSTHRU_BYTESWAP_256BIT ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_ctx ; } op . init = 1 ; if ( aes -> aad_len > 0 ) { ret = ccp_init_data ( & aad , cmd_q , p_aad , aes -> aad_len , AES_BLOCK_SIZE , DMA_TO_DEVICE ) ; if ( ret ) goto e_ctx ; op . u . aes . mode = CCP_AES_MODE_GHASH ; op . u . aes . action = CCP_AES_GHASHAAD ; while ( aad . sg_wa . bytes_left ) { ccp_prepare_data ( & aad , NULL , & op , AES_BLOCK_SIZE , true ) ; ret = cmd_q -> ccp -> vdata -> perform -> aes ( & op ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_aad ; } ccp_process_data ( & aad , NULL , & op ) ; op . init = 0 ; } } op . u . aes . mode = CCP_AES_MODE_GCTR ; op . u . aes . action = aes -> action ; if ( ilen > 0 ) { in_place = ( sg_virt ( p_inp ) == sg_virt ( p_outp ) ) ? true : false ; ret = ccp_init_data ( & src , cmd_q , p_inp , ilen , AES_BLOCK_SIZE , in_place ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE ) ; if ( ret ) <S2SV_StartBug> goto e_ctx ; <S2SV_EndBug> if ( in_place ) { dst = src ; } else { ret = ccp_init_data ( & dst , cmd_q , p_outp , ilen , AES_BLOCK_SIZE , DMA_FROM_DEVICE ) ; if ( ret ) goto e_src ; } op . soc = 0 ; op . eom = 0 ; op . init = 1 ; while ( src . sg_wa . bytes_left ) { ccp_prepare_data ( & src , & dst , & op , AES_BLOCK_SIZE , true ) ; if ( ! src . sg_wa . bytes_left ) { unsigned int nbytes = ilen % AES_BLOCK_SIZE ; if ( nbytes ) { op . eom = 1 ; op . u . aes . size = ( nbytes * 8 ) - 1 ; } } ret = cmd_q -> ccp -> vdata -> perform -> aes ( & op ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_dst ; } ccp_process_data ( & src , & dst , & op ) ; op . init = 0 ; } } ret = ccp_copy_from_sb ( cmd_q , & ctx , op . jobid , op . sb_ctx , CCP_PASSTHRU_BYTESWAP_256BIT ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_dst ; } ret = ccp_set_dm_area ( & ctx , dm_offset , aes -> iv , 0 , aes -> iv_len ) ; if ( ret ) goto e_dst ; ret = ccp_copy_to_sb ( cmd_q , & ctx , op . jobid , op . sb_ctx , CCP_PASSTHRU_BYTESWAP_256BIT ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_dst ; } ret = ccp_init_dm_workarea ( & final_wa , cmd_q , AES_BLOCK_SIZE , DMA_BIDIRECTIONAL ) ; if ( ret ) goto e_dst ; final = ( __be64 * ) final_wa . address ; final [ 0 ] = cpu_to_be64 ( aes -> aad_len * 8 ) ; final [ 1 ] = cpu_to_be64 ( ilen * 8 ) ; memset ( & op , 0 , sizeof ( op ) ) ; op . cmd_q = cmd_q ; op . jobid = jobid ; op . sb_key = cmd_q -> sb_key ; op . sb_ctx = cmd_q -> sb_ctx ; op . init = 1 ; op . u . aes . type = aes -> type ; op . u . aes . mode = CCP_AES_MODE_GHASH ; op . u . aes . action = CCP_AES_GHASHFINAL ; op . src . type = CCP_MEMTYPE_SYSTEM ; op . src . u . dma . address = final_wa . dma . address ; op . src . u . dma . length = AES_BLOCK_SIZE ; op . dst . type = CCP_MEMTYPE_SYSTEM ; op . dst . u . dma . address = final_wa . dma . address ; op . dst . u . dma . length = AES_BLOCK_SIZE ; op . eom = 1 ; op . u . aes . size = 0 ; ret = cmd_q -> ccp -> vdata -> perform -> aes ( & op ) ; if ( ret ) <S2SV_StartBug> goto e_dst ; <S2SV_EndBug> if ( aes -> action == CCP_AES_ACTION_ENCRYPT ) { ccp_get_dm_area ( & final_wa , 0 , p_tag , 0 , authsize ) ; } else { ret = ccp_init_dm_workarea ( & tag , cmd_q , authsize , DMA_BIDIRECTIONAL ) ; if ( ret ) <S2SV_StartBug> goto e_tag ; <S2SV_EndBug> ret = ccp_set_dm_area ( & tag , 0 , p_tag , 0 , authsize ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> goto e_tag ; ret = crypto_memneq ( tag . address , final_wa . address , authsize ) ? - EBADMSG : 0 ; ccp_dm_free ( & tag ) ; } <S2SV_StartBug> e_tag : <S2SV_EndBug> ccp_dm_free ( & final_wa ) ; e_dst : if ( ilen > 0 && ! in_place ) ccp_free_data ( & dst , cmd_q ) ; e_src : if ( ilen > 0 ) ccp_free_data ( & src , cmd_q ) ; e_aad : if ( aes -> aad_len ) ccp_free_data ( & aad , cmd_q ) ; e_ctx : ccp_dm_free ( & ctx ) ; e_key : ccp_dm_free ( & key ) ; return ret ; }", "target": "<S2SV_ModStart> ret ) goto e_aad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ret ) goto e_final_wa <S2SV_ModEnd> ; if ( <S2SV_ModStart> ret ) goto e_final_wa <S2SV_ModEnd> ; ret = <S2SV_ModStart> ( ret ) { ccp_dm_free ( & tag ) ; goto e_final_wa ; } <S2SV_ModEnd> ret = crypto_memneq <S2SV_ModStart> ) ; } e_final_wa <S2SV_ModEnd> : ccp_dm_free ("}
{"source": "CWE-476 void Compute ( OpKernelContext * ctx ) override { const Tensor & input = ctx -> input ( 0 ) ; const Tensor & input_min_range = ctx -> input ( 1 ) ; const Tensor & input_max_range = ctx -> input ( 2 ) ; int num_slices = 1 ; if ( axis_ > - 1 ) { <S2SV_StartBug> num_slices = input . dim_size ( axis_ ) ; <S2SV_EndBug> } const TensorShape & minmax_shape = ctx -> input ( 1 ) . shape ( ) ; Tensor * output = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , input . shape ( ) , & output ) ) ; Tensor * output_min_tensor = nullptr ; Tensor * output_max_tensor = nullptr ; if ( num_slices == 1 ) { OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , { } , & output_min_tensor ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 2 , { } , & output_max_tensor ) ) ; const float min_range = input_min_range . template flat < float > ( ) ( 0 ) ; const float max_range = input_max_range . template flat < float > ( ) ( 0 ) ; QuantizeTensor ( ctx , input , min_range , max_range , output , output_min_tensor , output_max_tensor ) ; return ; } OP_REQUIRES ( ctx , mode_ != QUANTIZE_MODE_MIN_FIRST , errors : : Unimplemented ( \"MIN_FIRST<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>for<S2SV_blank>\" \"Quantize<S2SV_blank>with<S2SV_blank>axis<S2SV_blank>!=<S2SV_blank>-1.\" ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , minmax_shape , & output_min_tensor ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 2 , minmax_shape , & output_max_tensor ) ) ; auto input_tensor = input . template flat_inner_outer_dims < float , 3 > ( axis_ - 1 ) ; int64_t pre_dim = 1 , post_dim = 1 ; for ( int i = 0 ; i < axis_ ; ++ i ) { pre_dim *= output -> dim_size ( i ) ; } for ( int i = axis_ + 1 ; i < output -> dims ( ) ; ++ i ) { post_dim *= output -> dim_size ( i ) ; } auto output_tensor = output -> template bit_casted_shaped < T , 3 > ( { pre_dim , num_slices , post_dim } ) ; auto min_ranges = input_min_range . template vec < float > ( ) ; auto max_ranges = input_max_range . template vec < float > ( ) ; for ( int i = 0 ; i < num_slices ; ++ i ) { QuantizeSlice ( ctx -> eigen_device < Device > ( ) , ctx , input_tensor . template chip < 1 > ( i ) , min_ranges ( i ) , max_ranges ( i ) , output_tensor . template chip < 1 > ( i ) , & output_min_tensor -> flat < float > ( ) ( i ) , & output_max_tensor -> flat < float > ( ) ( i ) ) ; } }", "target": "<S2SV_ModStart> 1 ) { OP_REQUIRES ( ctx , input . dims ( ) > axis_ , errors : : InvalidArgument ( \"Axis<S2SV_blank>is<S2SV_blank>on<S2SV_blank>a<S2SV_blank>zero-based<S2SV_blank>index,<S2SV_blank>so<S2SV_blank>its<S2SV_blank>value<S2SV_blank>must<S2SV_blank>always<S2SV_blank>be<S2SV_blank>less<S2SV_blank>\" \"than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>input\\'s<S2SV_blank>dims,<S2SV_blank>but<S2SV_blank>given<S2SV_blank>axis<S2SV_blank>value<S2SV_blank>was<S2SV_blank>\" , axis_ , \"<S2SV_blank>and<S2SV_blank>input\\'s<S2SV_blank>dims<S2SV_blank>was<S2SV_blank>\" , input . dims ( ) ) ) ; <S2SV_ModStart> dim_size ( axis_ ) ; OP_REQUIRES ( ctx , input_min_range . dims ( ) == 1 , errors : : InvalidArgument ( \"If<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>specified,<S2SV_blank>min_range<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>1-D<S2SV_blank>tensor<S2SV_blank>\" \"whose<S2SV_blank>size<S2SV_blank>matches<S2SV_blank>the<S2SV_blank>axis<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>the<S2SV_blank>input<S2SV_blank>and<S2SV_blank>\" \"output<S2SV_blank>tensors,<S2SV_blank>but<S2SV_blank>min_range<S2SV_blank>dims<S2SV_blank>are<S2SV_blank>\" , input_min_range . dims ( ) ) ) ; OP_REQUIRES ( ctx , input_min_range . dim_size ( 0 ) == num_slices , errors : : InvalidArgument ( \"If<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>specified,<S2SV_blank>min_range<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>1-D<S2SV_blank>tensor<S2SV_blank>\" \"whose<S2SV_blank>size<S2SV_blank>matches<S2SV_blank>the<S2SV_blank>axis<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>the<S2SV_blank>input<S2SV_blank>and<S2SV_blank>\" \"output<S2SV_blank>tensors,<S2SV_blank>but<S2SV_blank>min_range<S2SV_blank>is<S2SV_blank>a<S2SV_blank>1-D<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>size<S2SV_blank>\" , input_min_range . dim_size ( 0 ) , \"<S2SV_blank>and<S2SV_blank>input\\'s<S2SV_blank>axis<S2SV_blank>dimension<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size<S2SV_blank>\" , num_slices ) ) ; OP_REQUIRES ( ctx , input_max_range . dims ( ) == 1 , errors : : InvalidArgument ( \"If<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>specified,<S2SV_blank>max_range<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>1-D<S2SV_blank>tensor<S2SV_blank>\" \"whose<S2SV_blank>size<S2SV_blank>matches<S2SV_blank>the<S2SV_blank>axis<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>the<S2SV_blank>input<S2SV_blank>and<S2SV_blank>\" \"output<S2SV_blank>tensors,<S2SV_blank>but<S2SV_blank>max_range<S2SV_blank>dims<S2SV_blank>are<S2SV_blank>\" , input_max_range . dims ( ) ) ) ; OP_REQUIRES ( ctx , input_max_range . dim_size ( 0 ) == num_slices , errors : : InvalidArgument ( \"If<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>specified,<S2SV_blank>max_range<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>1-D<S2SV_blank>tensor<S2SV_blank>\" \"whose<S2SV_blank>size<S2SV_blank>matches<S2SV_blank>the<S2SV_blank>axis<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>the<S2SV_blank>input<S2SV_blank>and<S2SV_blank>\" \"output<S2SV_blank>tensors,<S2SV_blank>but<S2SV_blank>max_range<S2SV_blank>is<S2SV_blank>a<S2SV_blank>1-D<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>size<S2SV_blank>\" , input_max_range . dim_size ( 0 ) , \"<S2SV_blank>and<S2SV_blank>input\\'s<S2SV_blank>axis<S2SV_blank>dimension<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size<S2SV_blank>\" , num_slices ) ) ; } else { OP_REQUIRES ( ctx , input_min_range . NumElements ( ) == 1 , errors : : InvalidArgument ( \"If<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>min_range<S2SV_blank>must<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>\" \"single<S2SV_blank>float<S2SV_blank>element,<S2SV_blank>but<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>\" , input_min_range . NumElements ( ) , \"<S2SV_blank>elements\" ) ) ; OP_REQUIRES ( ctx , input_max_range . NumElements ( ) == 1 , errors : : InvalidArgument ( \"If<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>max_range<S2SV_blank>must<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>\" \"single<S2SV_blank>float<S2SV_blank>element,<S2SV_blank>but<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>\" , input_max_range . NumElements ( ) , \"<S2SV_blank>elements\" )"}
{"source": "CWE-252 static int adts_decode_extradata ( AVFormatContext * s , ADTSContext * adts , const uint8_t * buf , int size ) { GetBitContext gb ; PutBitContext pb ; MPEG4AudioConfig m4ac ; <S2SV_StartBug> int off ; <S2SV_EndBug> <S2SV_StartBug> init_get_bits ( & gb , buf , size * 8 ) ; <S2SV_EndBug> off = avpriv_mpeg4audio_get_config2 ( & m4ac , buf , size , 1 , s ) ; if ( off < 0 ) return off ; skip_bits_long ( & gb , off ) ; adts -> objecttype = m4ac . object_type - 1 ; adts -> sample_rate_index = m4ac . sampling_index ; adts -> channel_conf = m4ac . chan_config ; if ( adts -> objecttype > 3U ) { av_log ( s , AV_LOG_ERROR , \"MPEG-4<S2SV_blank>AOT<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>ADTS\\\\n\" , adts -> objecttype + 1 ) ; return AVERROR_INVALIDDATA ; } if ( adts -> sample_rate_index == 15 ) { av_log ( s , AV_LOG_ERROR , \"Escape<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>index<S2SV_blank>illegal<S2SV_blank>in<S2SV_blank>ADTS\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits ( & gb , 1 ) ) { av_log ( s , AV_LOG_ERROR , \"960/120<S2SV_blank>MDCT<S2SV_blank>window<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>ADTS\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits ( & gb , 1 ) ) { av_log ( s , AV_LOG_ERROR , \"Scalable<S2SV_blank>configurations<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>ADTS\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits ( & gb , 1 ) ) { av_log ( s , AV_LOG_ERROR , \"Extension<S2SV_blank>flag<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>ADTS\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( ! adts -> channel_conf ) { init_put_bits ( & pb , adts -> pce_data , MAX_PCE_SIZE ) ; put_bits ( & pb , 3 , 5 ) ; adts -> pce_size = ( ff_copy_pce_data ( & pb , & gb ) + 3 ) / 8 ; flush_put_bits ( & pb ) ; } adts -> write_adts = 1 ; return 0 ; }", "target": "<S2SV_ModStart> ; int off , ret ; ret = init_get_bits8 <S2SV_ModEnd> ( & gb <S2SV_ModStart> buf , size ) ; if ( ret < 0 ) return ret <S2SV_ModEnd> ; off ="}
{"source": "CWE-787 njs_module_path ( njs_vm_t * vm , const njs_str_t * dir , njs_module_info_t * info ) { char * p ; size_t length ; njs_bool_t trail ; char src [ NJS_MAX_PATH + 1 ] ; trail = 0 ; length = info -> name . length ; if ( dir != NULL ) { <S2SV_StartBug> length = dir -> length ; <S2SV_EndBug> if ( length == 0 ) { return NJS_DECLINED ; } trail = ( dir -> start [ dir -> length - 1 ] != '/' ) ; if ( trail ) { length ++ ; } } if ( njs_slow_path ( length > NJS_MAX_PATH ) ) { return NJS_ERROR ; } p = & src [ 0 ] ; if ( dir != NULL ) { p = ( char * ) njs_cpymem ( p , dir -> start , dir -> length ) ; if ( trail ) { * p ++ = '/' ; } } p = ( char * ) njs_cpymem ( p , info -> name . start , info -> name . length ) ; * p = '\\\\0' ; p = realpath ( & src [ 0 ] , & info -> path [ 0 ] ) ; if ( p == NULL ) { return NJS_DECLINED ; } info -> fd = open ( & info -> path [ 0 ] , O_RDONLY ) ; if ( info -> fd < 0 ) { return NJS_DECLINED ; } info -> file . start = ( u_char * ) & info -> path [ 0 ] ; info -> file . length = njs_strlen ( info -> file . start ) ; return NJS_OK ; }", "target": "<S2SV_ModStart> ) { length += <S2SV_ModEnd> dir -> length"}
{"source": "CWE-20 void Compute ( OpKernelContext * ctx ) override { try { const Tensor & input = ctx -> input ( kInputTensorIndex ) ; <S2SV_StartBug> const Tensor & input_min_vec = ctx -> input ( kInputMinVecIndex ) ; <S2SV_EndBug> <S2SV_StartBug> float * input_min_vec_data = ( float * ) const_cast < void * > ( <S2SV_EndBug> static_cast < const void * > ( input_min_vec . flat < float > ( ) . data ( ) ) ) ; const Tensor & input_max_vec = ctx -> input ( kInputMaxVecIndex ) ; <S2SV_StartBug> float * input_max_vec_data = ( float * ) const_cast < void * > ( <S2SV_EndBug> static_cast < const void * > ( input_max_vec . flat < float > ( ) . data ( ) ) ) ; const Tensor & input_requested_min = ctx -> input ( this -> kRequestMinIndex ) ; <S2SV_StartBug> const float input_requested_min_float = <S2SV_EndBug> input_requested_min . flat < float > ( ) ( 0 ) ; const Tensor & input_requested_max = ctx -> input ( this -> kRequestMaxIndex ) ; <S2SV_StartBug> const float input_requested_max_float = <S2SV_EndBug> <S2SV_StartBug> input_requested_max . flat < float > ( ) ( 0 ) ; <S2SV_EndBug> size_t depth = input_min_vec . NumElements ( ) ; OP_REQUIRES ( ctx , input . dims ( ) == 4 , errors : : InvalidArgument ( \"Current<S2SV_blank>RequantizePerChannel<S2SV_blank>operator\" \"supports<S2SV_blank>4D<S2SV_blank>tensors<S2SV_blank>only.\" ) ) ; OP_REQUIRES ( ctx , input_min_vec . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"input_min<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>was<S2SV_blank>\" , input_min_vec . dim_size ( 0 ) ) ) ; OP_REQUIRES ( ctx , input_max_vec . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"input_max<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>was<S2SV_blank>\" , input_max_vec . dim_size ( 0 ) ) ) ; <S2SV_StartBug> if ( out_type_ == DT_QINT8 ) DCHECK ( input_requested_min_float < 0.0f ) ; <S2SV_EndBug> const float factor = ( out_type_ == DT_QINT8 ) ? 127.0f : 255.0f ; const float requested_min_max = std : : max ( std : : abs ( input_requested_min_float ) , std : : abs ( input_requested_max_float ) ) ; Tensor * output = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( kOutputTensorIndex , input . shape ( ) , & output ) ) ; std : : vector < float > scales ( depth ) ; for ( int i = 0 ; i < depth ; ++ i ) { float min_max_from_vec = std : : max ( std : : abs ( input_min_vec_data [ i ] ) , std : : abs ( input_max_vec_data [ i ] ) ) ; scales [ i ] = factor * ( min_max_from_vec / requested_min_max / static_cast < float > ( 1L << 31 ) ) ; } mkldnn : : primitive_attr reorder_attr ; reorder_attr . set_output_scales ( 2 , scales ) ; memory : : dims dims_mkl_order = TFShapeToMklDnnDimsInNCHW ( input . shape ( ) , FORMAT_NHWC ) ; memory : : desc input_md = memory : : desc ( dims_mkl_order , MklDnnType < qint32 > ( ) , memory : : format_tag : : nhwc ) ; memory : : desc output_md = ( out_type_ == DT_QINT8 ) ? memory : : desc ( dims_mkl_order , MklDnnType < qint8 > ( ) , memory : : format_tag : : nhwc ) : memory : : desc ( dims_mkl_order , MklDnnType < quint8 > ( ) , memory : : format_tag : : nhwc ) ; void * input_buf = static_cast < void * > ( const_cast < qint32 * > ( input . flat < qint32 > ( ) . data ( ) ) ) ; void * output_buf ; if ( out_type_ == DT_QINT8 ) { output_buf = static_cast < void * > ( const_cast < qint8 * > ( output -> flat < qint8 > ( ) . data ( ) ) ) ; } else { output_buf = static_cast < void * > ( const_cast < quint8 * > ( output -> flat < quint8 > ( ) . data ( ) ) ) ; } std : : unique_ptr < memory > input_mem_prim ( new memory ( input_md , cpu_engine_ , input_buf ) ) ; std : : unique_ptr < memory > output_mem_prim ( new memory ( output_md , cpu_engine_ , output_buf ) ) ; mkldnn : : reorder : : primitive_desc reorder_pd = ReorderPd ( cpu_engine_ , input_mem_prim -> get_desc ( ) , cpu_engine_ , output_mem_prim -> get_desc ( ) , reorder_attr ) ; std : : shared_ptr < stream > reorder_stream ; MklDnnThreadPool eigen_tp ( ctx ) ; reorder_stream . reset ( CreateStream ( & eigen_tp , cpu_engine_ ) ) ; std : : unordered_map < int , mkldnn : : memory > reorder_args = { { MKLDNN_ARG_FROM , * input_mem_prim } , { MKLDNN_ARG_TO , * output_mem_prim } } ; std : : unique_ptr < mkldnn : : primitive > reorder_prim ( new mkldnn : : reorder ( reorder_pd ) ) ; reorder_prim -> execute ( * reorder_stream , reorder_args ) ; Tensor * output_min = nullptr ; Tensor * output_max = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( kOutputMinIndex , { } , & output_min ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( kOutputMaxIndex , { } , & output_max ) ) ; output_min -> flat < float > ( ) ( 0 ) = input_requested_min_float ; output_max -> flat < float > ( ) ( 0 ) = input_requested_max_float ; } catch ( mkldnn : : error & e ) { string error_msg = \"Status:<S2SV_blank>\" + std : : to_string ( e . status ) + \",<S2SV_blank>message:<S2SV_blank>\" + std : : string ( e . message ) + \",<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\" + std : : string ( __FILE__ ) + \":\" + std : : to_string ( __LINE__ ) ; OP_REQUIRES_OK ( ctx , errors : : Aborted ( \"Operation<S2SV_blank>received<S2SV_blank>an<S2SV_blank>exception:\" , error_msg ) ) ; } }", "target": "<S2SV_ModStart> kInputTensorIndex ) ; OP_REQUIRES ( ctx , input . dims ( ) == 4 , errors : : InvalidArgument ( \"Current<S2SV_blank>RequantizePerChannel<S2SV_blank>operator\" \"supports<S2SV_blank>4D<S2SV_blank>tensors<S2SV_blank>only.\" ) ) ; <S2SV_ModStart> kInputMinVecIndex ) ; size_t depth = input_min_vec . NumElements ( ) ; <S2SV_ModStart> kInputMaxVecIndex ) ; OP_REQUIRES ( ctx , input_max_vec . NumElements ( ) == depth , errors : : InvalidArgument ( \"input_max<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>was<S2SV_blank>\" , input_max_vec . NumElements ( ) ) ) ; <S2SV_ModStart> kRequestMinIndex ) ; OP_REQUIRES ( ctx , input_requested_min . NumElements ( ) == 1 , errors : : InvalidArgument ( \"requested_output_min<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) ) ; <S2SV_ModStart> kRequestMaxIndex ) ; OP_REQUIRES ( ctx , input_requested_min . NumElements ( ) == 1 , errors : : InvalidArgument ( \"requested_output_max<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar\" ) ) ; <S2SV_ModStart> ) ( 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> == DT_QINT8 ) { OP_REQUIRES ( ctx , <S2SV_ModEnd> input_requested_min_float < 0.0f <S2SV_ModStart> input_requested_min_float < 0.0f , errors : : InvalidArgument ( \"If<S2SV_blank>out_type<S2SV_blank>is<S2SV_blank>QINT8,<S2SV_blank>requested_output_max<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\" \"non<S2SV_blank>negative,<S2SV_blank>got<S2SV_blank>\" , input_requested_min_float ) ) ; } <S2SV_ModEnd> const float factor"}
{"source": "CWE-908 TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { const auto * params = reinterpret_cast < TfLiteSVDFParams * > ( node -> builtin_data ) ; OpData * op_data = reinterpret_cast < OpData * > ( node -> user_data ) ; int scratch_tensor_index = op_data -> scratch_tensor_index ; TF_LITE_ENSURE_EQ ( context , node -> outputs -> size , 1 ) ; TF_LITE_ENSURE_EQ ( context , node -> inputs -> size , 5 ) ; const TfLiteTensor * input ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor , & input ) ) ; const TfLiteTensor * weights_feature ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kWeightsFeatureTensor , & weights_feature ) ) ; const TfLiteTensor * weights_time ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kWeightsTimeTensor , & weights_time ) ) ; TF_LITE_ENSURE ( context , input -> type == kTfLiteFloat32 || input -> type == kTfLiteInt8 ) ; const int rank = params -> rank ; const int batch_size = input -> dims -> data [ 0 ] ; const int num_filters = weights_feature -> dims -> data [ 0 ] ; TF_LITE_ENSURE ( context , rank != 0 ) ; TF_LITE_ENSURE_EQ ( context , num_filters % rank , 0 ) ; const int num_units = num_filters / rank ; const int memory_size = weights_time -> dims -> data [ 1 ] ; TF_LITE_ENSURE_EQ ( context , input -> dims -> data [ 1 ] , weights_feature -> dims -> data [ 1 ] ) ; TF_LITE_ENSURE_EQ ( context , weights_time -> dims -> data [ 0 ] , num_filters ) ; const TfLiteTensor * bias = GetOptionalInputTensor ( context , node , kBiasTensor ) ; if ( bias ) { TF_LITE_ENSURE_EQ ( context , bias -> dims -> data [ 0 ] , num_units ) ; } const TfLiteTensor * state ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kStateTensor , & state ) ) ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( state ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , SizeOfDimension ( state , 0 ) , batch_size ) ; TF_LITE_ENSURE_EQ ( context , SizeOfDimension ( state , 1 ) , memory_size * num_filters ) ; TfLiteIntArray * output_size_array = TfLiteIntArrayCreate ( 2 ) ; output_size_array -> data [ 0 ] = batch_size ; output_size_array -> data [ 1 ] = num_units ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , output , output_size_array ) ) ; const bool is_hybrid_op = IsHybridOp ( input , weights_feature ) ; const bool is_full_integer = input -> type == kTfLiteInt8 ; TfLiteIntArrayFree ( node -> temporaries ) ; if ( is_hybrid_op ) { node -> temporaries = TfLiteIntArrayCreate ( 6 ) ; } else if ( is_full_integer ) { node -> temporaries = TfLiteIntArrayCreate ( 2 ) ; } else { node -> temporaries = TfLiteIntArrayCreate ( 1 ) ; } node -> temporaries -> data [ 0 ] = scratch_tensor_index ; TfLiteIntArray * scratch_size_array = TfLiteIntArrayCreate ( 2 ) ; scratch_size_array -> data [ 0 ] = batch_size ; scratch_size_array -> data [ 1 ] = num_filters ; TfLiteTensor * scratch_tensor ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 0 , & scratch_tensor ) ) ; if ( is_full_integer ) { scratch_tensor -> type = kTfLiteInt32 ; } else { scratch_tensor -> type = kTfLiteFloat32 ; } scratch_tensor -> allocation_type = kTfLiteArenaRw ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , scratch_tensor , scratch_size_array ) ) ; if ( is_hybrid_op ) { op_data -> compute_row_sums = true ; node -> temporaries -> data [ 1 ] = scratch_tensor_index + 1 ; TfLiteTensor * input_quantized ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 1 , & input_quantized ) ) ; input_quantized -> type = weights_feature -> type ; input_quantized -> allocation_type = kTfLiteArenaRw ; if ( ! TfLiteIntArrayEqual ( input_quantized -> dims , input -> dims ) ) { TfLiteIntArray * input_quantized_size = TfLiteIntArrayCopy ( input -> dims ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , input_quantized , input_quantized_size ) ) ; } node -> temporaries -> data [ 2 ] = scratch_tensor_index + 2 ; TfLiteTensor * scaling_factors ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 2 , & scaling_factors ) ) ; scaling_factors -> type = kTfLiteFloat32 ; scaling_factors -> allocation_type = kTfLiteArenaRw ; int scaling_dims [ 1 ] = { batch_size } ; if ( ! TfLiteIntArrayEqualsArray ( scaling_factors -> dims , 1 , scaling_dims ) ) { TfLiteIntArray * scaling_factors_size = TfLiteIntArrayCreate ( 1 ) ; scaling_factors_size -> data [ 0 ] = batch_size ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , scaling_factors , scaling_factors_size ) ) ; } node -> temporaries -> data [ 3 ] = scratch_tensor_index + 3 ; TfLiteTensor * float_weights_time ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 3 , & float_weights_time ) ) ; float_weights_time -> type = kTfLiteFloat32 ; float_weights_time -> allocation_type = kTfLiteArenaRwPersistent ; if ( ! TfLiteIntArrayEqual ( float_weights_time -> dims , weights_time -> dims ) ) { TfLiteIntArray * float_weights_time_size = TfLiteIntArrayCopy ( weights_time -> dims ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , float_weights_time , float_weights_time_size ) ) ; } node -> temporaries -> data [ 4 ] = scratch_tensor_index + 4 ; TfLiteTensor * zero_points ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 4 , & zero_points ) ) ; zero_points -> type = kTfLiteFloat32 ; zero_points -> allocation_type = kTfLiteArenaRw ; int zero_points_dims [ 1 ] = { batch_size } ; if ( ! TfLiteIntArrayEqualsArray ( zero_points -> dims , 1 , zero_points_dims ) ) { TfLiteIntArray * zero_points_size = TfLiteIntArrayCreate ( 1 ) ; zero_points_size -> data [ 0 ] = zero_points_dims [ 0 ] ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , zero_points , zero_points_size ) ) ; } node -> temporaries -> data [ 5 ] = scratch_tensor_index + 5 ; TfLiteTensor * row_sums ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 5 , & row_sums ) ) ; row_sums -> type = kTfLiteFloat32 ; row_sums -> allocation_type = kTfLiteArenaRwPersistent ; int row_sums_dims [ 1 ] = { num_filters } ; if ( ! TfLiteIntArrayEqualsArray ( row_sums -> dims , 1 , row_sums_dims ) ) { TfLiteIntArray * row_sums_size = TfLiteIntArrayCreate ( 1 ) ; row_sums_size -> data [ 0 ] = row_sums_dims [ 0 ] ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , row_sums , row_sums_size ) ) ; } } if ( is_full_integer ) { TfLiteIntArray * output_temp_size_array = TfLiteIntArrayCreate ( 2 ) ; output_temp_size_array -> data [ 0 ] = num_units ; output_temp_size_array -> data [ 1 ] = batch_size ; node -> temporaries -> data [ 1 ] = scratch_tensor_index + 1 ; TfLiteTensor * output_temp ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 1 , & output_temp ) ) ; output_temp -> type = kTfLiteInt32 ; output_temp -> allocation_type = kTfLiteArenaRw ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , output_temp , output_temp_size_array ) ) ; <S2SV_StartBug> auto * input_params = <S2SV_EndBug> reinterpret_cast < TfLiteAffineQuantization * > ( input -> quantization . params ) ; <S2SV_StartBug> auto * weights_feature_params = reinterpret_cast < TfLiteAffineQuantization * > ( <S2SV_EndBug> weights_feature -> quantization . params ) ; <S2SV_StartBug> auto * state_params = <S2SV_EndBug> reinterpret_cast < TfLiteAffineQuantization * > ( state -> quantization . params ) ; <S2SV_StartBug> auto * weight_time_params = reinterpret_cast < TfLiteAffineQuantization * > ( <S2SV_EndBug> weights_time -> quantization . params ) ; <S2SV_StartBug> auto * output_params = reinterpret_cast < TfLiteAffineQuantization * > ( <S2SV_EndBug> output -> quantization . params ) ; const double effective_scale_1 = input_params -> scale -> data [ 0 ] * weights_feature_params -> scale -> data [ 0 ] / state_params -> scale -> data [ 0 ] ; const double effective_scale_2 = state_params -> scale -> data [ 0 ] * weight_time_params -> scale -> data [ 0 ] / output_params -> scale -> data [ 0 ] ; QuantizeMultiplier ( effective_scale_1 , & op_data -> effective_scale_1_a , & op_data -> effective_scale_1_b ) ; QuantizeMultiplier ( effective_scale_2 , & op_data -> effective_scale_2_a , & op_data -> effective_scale_2_b ) ; } return kTfLiteOk ; }", "target": "<S2SV_ModStart> ) ) ; TF_LITE_ENSURE ( context , input -> quantization . type != kTfLiteNoQuantization ) ; <S2SV_ModStart> params ) ; TF_LITE_ENSURE ( context , weights_feature -> quantization . type != kTfLiteNoQuantization ) ; <S2SV_ModStart> params ) ; TF_LITE_ENSURE ( context , state -> quantization . type != kTfLiteNoQuantization ) ; <S2SV_ModStart> params ) ; TF_LITE_ENSURE ( context , weights_time -> quantization . type != kTfLiteNoQuantization ) ; <S2SV_ModStart> params ) ; TF_LITE_ENSURE ( context , output -> quantization . type != kTfLiteNoQuantization ) ;"}
{"source": "CWE-369 Status ShapeRefiner : : InferShapesForFunctionSubNode ( const Node * node , InferenceContext * outer_context ) { TF_RETURN_IF_ERROR ( AddNodeInternal ( node , outer_context ) ) ; InferenceContext * node_context = CHECK_NOTNULL ( GetContext ( node ) ) ; if ( StringPiece ( node -> type_string ( ) ) == kArgOp ) { int index ; TF_RETURN_IF_ERROR ( GetNodeAttr ( AttrSlice ( node -> def ( ) ) , \"index\" , & index ) ) ; if ( index < 0 || outer_context -> num_inputs ( ) <= index ) { return errors : : Internal ( \"Function<S2SV_blank>instantiation<S2SV_blank>included<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>index:<S2SV_blank>\" , index , \"<S2SV_blank>not<S2SV_blank>in<S2SV_blank>[0,<S2SV_blank>\" , outer_context -> num_inputs ( ) , \").\" ) ; } if ( outer_context -> input ( index ) . SameHandle ( ShapeHandle ( ) ) ) { VLOG ( 1 ) << \"Function<S2SV_blank>instantiation<S2SV_blank>has<S2SV_blank>undefined<S2SV_blank>input<S2SV_blank>shape<S2SV_blank>at<S2SV_blank>\" << \"index:<S2SV_blank>\" << index << \"<S2SV_blank>in<S2SV_blank>the<S2SV_blank>outer<S2SV_blank>inference<S2SV_blank>context.\" ; node_context -> set_output ( 0 , node_context -> UnknownShape ( ) ) ; } else { node_context -> set_output ( 0 , outer_context -> input ( index ) ) ; } auto * resource = outer_context -> input_handle_shapes_and_types ( index ) ; if ( resource ) { node_context -> set_output_handle_shapes_and_types ( 0 , * resource ) ; } } else if ( StringPiece ( node -> type_string ( ) ) == kRetvalOp ) { int index ; TF_RETURN_IF_ERROR ( GetNodeAttr ( AttrSlice ( node -> def ( ) ) , \"index\" , & index ) ) ; if ( index < 0 || outer_context -> num_outputs ( ) <= index ) { return errors : : Internal ( \"Function<S2SV_blank>instantiation<S2SV_blank>included<S2SV_blank>invalid<S2SV_blank>output<S2SV_blank>index:<S2SV_blank>\" , index , \"<S2SV_blank>not<S2SV_blank>in<S2SV_blank>[0,<S2SV_blank>\" , outer_context -> num_outputs ( ) , \").\" ) ; } ShapeHandle handle ; TensorShapeProto proto ; node_context -> ShapeHandleToProto ( node_context -> input ( 0 ) , & proto ) ; TF_RETURN_IF_ERROR ( outer_context -> MakeShapeFromShapeProto ( proto , & handle ) ) ; outer_context -> set_output ( index , handle ) ; <S2SV_StartBug> auto * resource = node_context -> input_handle_shapes_and_types ( 0 ) ; <S2SV_EndBug> if ( resource ) { <S2SV_StartBug> outer_context -> set_output_handle_shapes_and_types ( index , * resource ) ; <S2SV_EndBug> } } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> handle ) ; const std : : vector < ShapeAndType > * resource = node_context -> input_handle_shapes_and_types ( 0 ) ; if ( resource ) { std : : vector < ShapeAndType > copied_shapes_and_types ; for ( auto & shape_and_type : * resource ) { ShapeHandle handle ; TensorShapeProto proto ; node_context -> ShapeHandleToProto ( shape_and_type . shape , & proto ) ; TF_RETURN_IF_ERROR ( outer_context -> MakeShapeFromShapeProto ( proto , & handle ) ) ; copied_shapes_and_types . push_back ( ShapeAndType ( handle , shape_and_type . dtype , shape_and_type . type ) ) ; } <S2SV_ModEnd> outer_context -> set_output_handle_shapes_and_types <S2SV_ModStart> -> set_output_handle_shapes_and_types ( index , copied_shapes_and_types <S2SV_ModEnd> ) ; }"}
{"source": "CWE-125 void Compute ( OpKernelContext * ctx ) override { const Tensor & a = ctx -> input ( 0 ) ; const Tensor & b = ctx -> input ( 1 ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( a . shape ( ) ) , errors : : InvalidArgument ( \"a<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>matrix\" ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsMatrix ( b . shape ( ) ) , errors : : InvalidArgument ( \"b<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>matrix\" ) ) ; const int m = transpose_a_ ? a . dim_size ( 1 ) : a . dim_size ( 0 ) ; const int k = transpose_a_ ? a . dim_size ( 0 ) : a . dim_size ( 1 ) ; const int n = transpose_b_ ? b . dim_size ( 0 ) : b . dim_size ( 1 ) ; const int k2 = transpose_b_ ? b . dim_size ( 1 ) : b . dim_size ( 0 ) ; OP_REQUIRES ( ctx , k == k2 , errors : : InvalidArgument ( \"Matrix<S2SV_blank>size<S2SV_blank>incompatible:<S2SV_blank>a:<S2SV_blank>\" , a . shape ( ) . DebugString ( ) , \",<S2SV_blank>b:<S2SV_blank>\" , b . shape ( ) . DebugString ( ) ) ) ; <S2SV_StartBug> Tensor * output = nullptr ; <S2SV_EndBug> <S2SV_StartBug> OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { m , n } ) , & output ) ) ; <S2SV_EndBug> if ( k == 0 ) { functor : : SetZeroFunctor < CPUDevice , float > f ; f ( ctx -> eigen_device < CPUDevice > ( ) , output -> flat < float > ( ) ) ; return ; } auto out = output -> matrix < float > ( ) ; std : : unique_ptr < Tensor > a_float ; std : : unique_ptr < Tensor > b_float ; if ( ! a_is_sparse_ && ! b_is_sparse_ ) { auto left = & a ; auto right = & b ; if ( std : : is_same < TL , bfloat16 > : : value ) { a_float . reset ( new Tensor ( DT_FLOAT , a . shape ( ) ) ) ; BFloat16ToFloat ( a . flat < bfloat16 > ( ) . data ( ) , a_float -> flat < float > ( ) . data ( ) , a . NumElements ( ) ) ; left = a_float . get ( ) ; } if ( std : : is_same < TR , bfloat16 > : : value ) { b_float . reset ( new Tensor ( DT_FLOAT , b . shape ( ) ) ) ; BFloat16ToFloat ( b . flat < bfloat16 > ( ) . data ( ) , b_float -> flat < float > ( ) . data ( ) , b . NumElements ( ) ) ; right = b_float . get ( ) ; } Eigen : : array < Eigen : : IndexPair < Eigen : : DenseIndex > , 1 > dim_pair ; dim_pair [ 0 ] . first = transpose_a_ ? 0 : 1 ; dim_pair [ 0 ] . second = transpose_b_ ? 1 : 0 ; out . device ( ctx -> template eigen_device < CPUDevice > ( ) ) = left -> matrix < float > ( ) . contract ( right -> matrix < float > ( ) , dim_pair ) ; return ; } auto left = & a ; auto right = & b ; bool transpose_output = false ; bool transpose_a = transpose_a_ ; bool transpose_b = transpose_b_ ; if ( ! a_is_sparse_ ) { std : : swap ( left , right ) ; std : : swap ( transpose_a , transpose_b ) ; transpose_a = ! transpose_a ; transpose_b = ! transpose_b ; transpose_output = ! transpose_output ; } std : : unique_ptr < Tensor > right_tr ; if ( transpose_b ) { OP_REQUIRES ( ctx , right -> dim_size ( 0 ) != 0 , errors : : InvalidArgument ( \"b<S2SV_blank>has<S2SV_blank>an<S2SV_blank>entry<S2SV_blank>0<S2SV_blank>in<S2SV_blank>it\\'s<S2SV_blank>shape.\" ) ) ; OP_REQUIRES ( ctx , right -> dim_size ( 1 ) != 0 , errors : : InvalidArgument ( \"b<S2SV_blank>has<S2SV_blank>an<S2SV_blank>entry<S2SV_blank>0<S2SV_blank>in<S2SV_blank>it\\'s<S2SV_blank>shape.\" ) ) ; right_tr . reset ( new Tensor ( right -> dtype ( ) , TensorShape ( { right -> dim_size ( 1 ) , right -> dim_size ( 0 ) } ) ) ) ; const auto perm = dsizes_10 ( ) ; if ( transpose_output ) { right_tr -> matrix < TL > ( ) . device ( ctx -> template eigen_device < CPUDevice > ( ) ) = right -> matrix < TL > ( ) . shuffle ( perm ) ; } else { right_tr -> matrix < TR > ( ) . device ( ctx -> template eigen_device < CPUDevice > ( ) ) = right -> matrix < TR > ( ) . shuffle ( perm ) ; } right = right_tr . get ( ) ; } if ( transpose_output ) { DoMatMul < TR , TL > : : Compute ( & this -> cache_tr_ , left -> matrix < TR > ( ) , right -> matrix < TL > ( ) , transpose_a , ctx -> device ( ) -> tensorflow_cpu_worker_threads ( ) , transpose_output , & out ) ; } else { DoMatMul < TL , TR > : : Compute ( & this -> cache_nt_ , left -> matrix < TL > ( ) , right -> matrix < TR > ( ) , transpose_a , ctx -> device ( ) -> tensorflow_cpu_worker_threads ( ) , transpose_output , & out ) ; } }", "target": "<S2SV_ModStart> ) ) ; OP_REQUIRES ( ctx , m >= 0 && n >= 0 && k >= 0 , errors : : InvalidArgument ( \"Matrix<S2SV_blank>dimensions<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>negative:<S2SV_blank>a:<S2SV_blank>\" , a . shape ( ) . DebugString ( ) , \",<S2SV_blank>b:<S2SV_blank>\" , b . shape ( ) . DebugString ( ) ) ) ; <S2SV_ModStart> ) ) ; if ( m == 0 || n == 0 ) { return ; }"}
{"source": "CWE-200 PJ_DEF ( pj_status_t ) pjmedia_rtcp_fb_parse_rpsi ( const void * buf , pj_size_t length , pjmedia_rtcp_fb_rpsi * rpsi ) { <S2SV_StartBug> pjmedia_rtcp_common * hdr = ( pjmedia_rtcp_common * ) buf ; <S2SV_EndBug> pj_uint8_t * p ; pj_uint8_t padlen ; pj_size_t rpsi_len ; PJ_ASSERT_RETURN ( buf && rpsi , PJ_EINVAL ) ; <S2SV_StartBug> PJ_ASSERT_RETURN ( length >= sizeof ( pjmedia_rtcp_common ) , PJ_ETOOSMALL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> pt != RTCP_PSFB || hdr -> count != 3 ) <S2SV_EndBug> return PJ_ENOTFOUND ; <S2SV_StartBug> rpsi_len = ( pj_ntohs ( ( pj_uint16_t ) hdr -> length ) - 2 ) * 4 ; <S2SV_EndBug> if ( length < rpsi_len + 12 ) return PJ_ETOOSMALL ; p = ( pj_uint8_t * ) hdr + sizeof ( * hdr ) ; <S2SV_StartBug> padlen = * p ++ ; <S2SV_EndBug> rpsi -> pt = ( * p ++ & 0x7F ) ; rpsi -> rpsi_bit_len = rpsi_len * 8 - 16 - padlen ; pj_strset ( & rpsi -> rpsi , ( char * ) p , ( rpsi -> rpsi_bit_len + 7 ) / 8 ) ; return PJ_SUCCESS ; }", "target": "<S2SV_ModStart> rpsi ) { pjmedia_rtcp_fb_common * hdr = ( pjmedia_rtcp_fb_common <S2SV_ModEnd> * ) buf <S2SV_ModStart> >= sizeof ( pjmedia_rtcp_fb_common ) , PJ_ETOOSMALL ) ; if ( hdr -> rtcp_common . <S2SV_ModEnd> pt != RTCP_PSFB <S2SV_ModStart> || hdr -> rtcp_common . <S2SV_ModStart> return PJ_ENOTFOUND ; if ( hdr -> rtcp_common . length < 3 ) { PJ_PERROR ( 3 , ( THIS_FILE , PJ_ETOOSMALL , \"Failed<S2SV_blank>parsing<S2SV_blank>FB<S2SV_blank>RPSI,<S2SV_blank>invalid<S2SV_blank>header<S2SV_blank>length\" ) ) ; return PJ_ETOOSMALL ; } <S2SV_ModStart> ) hdr -> rtcp_common . <S2SV_ModStart> p ++ ; if ( padlen >= 32 ) { PJ_PERROR ( 3 , ( THIS_FILE , PJ_ETOOBIG , \"Failed<S2SV_blank>parsing<S2SV_blank>FB<S2SV_blank>RPSI,<S2SV_blank>invalid<S2SV_blank>RPSI<S2SV_blank>padding<S2SV_blank>len\" ) ) ; return PJ_ETOOBIG ; } if ( ( rpsi_len * 8 ) < ( unsigned ) ( 16 + padlen ) ) { PJ_PERROR ( 3 , ( THIS_FILE , PJ_ETOOSMALL , \"Failed<S2SV_blank>parsing<S2SV_blank>FB<S2SV_blank>RPSI,<S2SV_blank>invalid<S2SV_blank>RPSI<S2SV_blank>bit<S2SV_blank>len\" ) ) ; return PJ_ETOOSMALL ; }"}
{"source": "CWE-703 void Compute ( OpKernelContext * ctx ) override { <S2SV_StartBug> const Tensor & handle = ctx -> input ( 0 ) ; <S2SV_EndBug> const string & name = handle . scalar < tstring > ( ) ( ) ; auto session_state = ctx -> session_state ( ) ; OP_REQUIRES ( ctx , session_state != nullptr , errors : : FailedPrecondition ( \"DeleteSessionTensor<S2SV_blank>called<S2SV_blank>on<S2SV_blank>null<S2SV_blank>session<S2SV_blank>state\" ) ) ; OP_REQUIRES_OK ( ctx , session_state -> DeleteTensor ( name ) ) ; }", "target": "<S2SV_ModStart> input ( 0 ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( handle . shape ( ) ) , errors : : InvalidArgument ( \"`handle`<S2SV_blank>must<S2SV_blank>be<S2SV_blank>scalar\" )"}
{"source": "CWE-703 static Status ParseEquation ( const string & equation , OperandLabels * input_labels , Labels * output_labels , std : : vector < DimensionType > * label_types , OperandLabelCounts * input_label_counts , LabelCounts * output_label_counts , gtl : : InlinedVector < bool , 2 > * input_has_ellipsis , bool * output_has_ellipsis ) { gtl : : InlinedVector < string , 2 > input_str ; string output_str ; TF_RETURN_IF_ERROR ( ParseEinsumEquation ( equation , & input_str , & output_str ) ) ; absl : : flat_hash_map < char , int > label_mapping ; int num_inputs = input_str . size ( ) ; input_labels -> resize ( num_inputs ) ; for ( int i = 0 ; i < num_inputs ; ++ i ) { MapToLabels ( input_str [ i ] , & input_labels -> at ( i ) , & label_mapping ) ; } MapToLabels ( output_str , output_labels , & label_mapping ) ; int num_labels = label_mapping . size ( ) ; input_label_counts -> resize ( num_inputs ) ; input_has_ellipsis -> resize ( num_inputs ) ; for ( int i = 0 ; i < num_inputs ; ++ i ) { input_label_counts -> at ( i ) . resize ( num_labels ) ; <S2SV_StartBug> for ( const int label : input_labels -> at ( i ) ) { <S2SV_EndBug> if ( label != kEllipsisLabel ) input_label_counts -> at ( i ) [ label ] += 1 ; else input_has_ellipsis -> at ( i ) = true ; } } <S2SV_StartBug> output_label_counts -> resize ( num_labels ) ; <S2SV_EndBug> for ( const int label : * output_labels ) { if ( label != kEllipsisLabel ) output_label_counts -> at ( label ) += 1 ; else * output_has_ellipsis = true ; } label_types -> resize ( num_labels ) ; for ( int label = 0 ; label < num_labels ; ++ label ) { if ( label == kEllipsisLabel ) continue ; bool removed = ( * output_label_counts ) [ label ] == 0 ; bool unique = num_inputs == 1 || ( * input_label_counts ) [ 0 ] [ label ] == 0 || ( * input_label_counts ) [ 1 ] [ label ] == 0 ; ( * label_types ) [ label ] = GetDimensionType ( removed , unique ) ; } return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> num_labels ) ; input_has_ellipsis -> at ( i ) = false ; <S2SV_ModStart> ( num_labels ) ; * output_has_ellipsis = false"}
{"source": "CWE-703 Status AutoParallel : : Initialize ( const GrapplerItem & item ) { num_gpus_ = GetNumAvailableGPUs ( ) ; LOG ( INFO ) << \"Number<S2SV_blank>of<S2SV_blank>GPUs:<S2SV_blank>\" << num_gpus_ ; item_ = & item ; graph_ = item . graph ; LOG ( INFO ) << \"Original<S2SV_blank>graph<S2SV_blank>size:<S2SV_blank>\" << graph_ . node_size ( ) ; if ( item . fetch . empty ( ) ) { return Status ( error : : INVALID_ARGUMENT , \"No<S2SV_blank>fetch<S2SV_blank>nodes<S2SV_blank>provided.\" ) ; } if ( item . MainVariables ( ) . empty ( ) ) { return Status ( error : : INVALID_ARGUMENT , \"No<S2SV_blank>variables<S2SV_blank>provided.\" ) ; } for ( const auto & init : item . init_ops ) { VLOG ( 1 ) << \"Init<S2SV_blank>node:<S2SV_blank>\" << init ; } for ( const auto & fetch : item . fetch ) { VLOG ( 1 ) << \"Fetch<S2SV_blank>node:<S2SV_blank>\" << fetch ; } for ( const auto & var : item . MainVariables ( ) ) { VLOG ( 2 ) << \"Variable:<S2SV_blank>\" << var -> name ( ) ; } const std : : set < string > apply_gradients_ops = { \"ApplyGradientDescent\" , \"ApplyProximalGradientDescent\" , \"ApplyAdadelta\" , \"ApplyAdagrad\" , \"ApplyProximalAdagrad\" , \"ApplyAdagradDA\" , \"ApplyFtrl\" , \"ApplyMomentum\" , \"ApplyAdam\" , \"ApplyRMSProp\" , \"ApplyCenteredRMSProp\" } ; for ( int i = 0 ; i < graph_ . node_size ( ) ; i ++ ) { all_nodes_ . insert ( std : : make_pair ( graph_ . node ( i ) . name ( ) , graph_ . mutable_node ( i ) ) ) ; if ( apply_gradients_ops . find ( graph_ . node ( i ) . op ( ) ) != apply_gradients_ops . end ( ) ) { apply_gradients_nodes_ . insert ( graph_ . node ( i ) . name ( ) ) ; VLOG ( 2 ) << \"Apply<S2SV_blank>gradients<S2SV_blank>node:<S2SV_blank>\" << graph_ . node ( i ) . name ( ) ; } } auto div_const_node = AddNodeDivConst ( ) ; all_nodes_ . insert ( std : : make_pair ( div_const_node -> name ( ) , div_const_node ) ) ; std : : map < string , int > gradient_pos = { { \"ApplyGradientDescent\" , 2 } , { \"ApplyProximalGradientDescent\" , 4 } , { \"ApplyAdadelta\" , 6 } , { \"ApplyAdagrad\" , 3 } , { \"ApplyProximalAdagrad\" , 5 } , { \"ApplyAdagradDA\" , 3 } , { \"ApplyFtrl\" , 3 } , { \"ApplyMomentum\" , 3 } , { \"ApplyAdam\" , 9 } , { \"ApplyRMSProp\" , 7 } , { \"ApplyCenteredRMSProp\" , 8 } } ; for ( const auto & apply_gradient_node_name : apply_gradients_nodes_ ) { auto apply_gradients_op = all_nodes_ [ apply_gradient_node_name ] -> op ( ) ; auto apply_gradients_node = all_nodes_ [ apply_gradient_node_name ] ; auto div_node = AddNodeDiv ( apply_gradient_node_name , apply_gradients_node -> input ( gradient_pos [ apply_gradients_op ] ) , div_const_node -> name ( ) ) ; all_nodes_ . insert ( std : : make_pair ( div_node -> name ( ) , div_node ) ) ; * apply_gradients_node -> mutable_input ( gradient_pos [ apply_gradients_op ] ) = div_node -> name ( ) ; } LOG ( INFO ) << \"Graph<S2SV_blank>size<S2SV_blank>after<S2SV_blank>adding<S2SV_blank>div<S2SV_blank>nodes:<S2SV_blank>\" << all_nodes_ . size ( ) ; std : : vector < const NodeDef * > train_nodes ; TF_RETURN_IF_ERROR ( ComputeTransitiveFanin ( graph_ , item . fetch , & train_nodes ) ) ; LOG ( INFO ) << \"Number<S2SV_blank>of<S2SV_blank>training<S2SV_blank>nodes:<S2SV_blank>\" << train_nodes . size ( ) ; <S2SV_StartBug> const NodeDef * dequeue_node ; <S2SV_EndBug> for ( const auto & train_node : train_nodes ) { if ( IsDequeueOp ( * train_node ) ) { dequeue_node = train_node ; break ; } } std : : vector < const NodeDef * > input_nodes ; if ( dequeue_node ) { LOG ( INFO ) << \"Dequeue<S2SV_blank>node:<S2SV_blank>\" << dequeue_node -> name ( ) ; TF_RETURN_IF_ERROR ( ComputeTransitiveFanin ( graph_ , { dequeue_node -> name ( ) } , { } , & input_nodes ) ) ; } LOG ( INFO ) << \"Number<S2SV_blank>of<S2SV_blank>input<S2SV_blank>nodes:<S2SV_blank>\" << input_nodes . size ( ) ; std : : set < string > dont_replicate_nodes ; for ( const auto & variable : item . MainVariables ( ) ) { dont_replicate_nodes . insert ( variable -> name ( ) ) ; } for ( const auto & init : item . init_ops ) { dont_replicate_nodes . insert ( NodeName ( init ) ) ; } for ( const auto & input_node : input_nodes ) { if ( input_node -> name ( ) != dequeue_node -> name ( ) ) { dont_replicate_nodes . insert ( input_node -> name ( ) ) ; } } for ( const auto & node : train_nodes ) { if ( dont_replicate_nodes . find ( node -> name ( ) ) == dont_replicate_nodes . end ( ) ) { replica_nodes_ . insert ( node -> name ( ) ) ; } } LOG ( INFO ) << \"Number<S2SV_blank>of<S2SV_blank>replica<S2SV_blank>nodes:<S2SV_blank>\" << replica_nodes_ . size ( ) ; for ( const auto & node : all_nodes_ ) { if ( replica_nodes_ . find ( node . first ) == replica_nodes_ . end ( ) ) { shared_nodes_ . insert ( node . first ) ; } } LOG ( INFO ) << \"Number<S2SV_blank>of<S2SV_blank>shared<S2SV_blank>nodes:<S2SV_blank>\" << shared_nodes_ . size ( ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> NodeDef * dequeue_node = nullptr"}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { <S2SV_StartBug> const Tensor & input = context -> input ( 0 ) ; <S2SV_EndBug> const Tensor & dims = context -> input ( 1 ) ; if ( TensorShapeUtils : : IsScalar ( input . shape ( ) ) ) { context -> set_output ( 0 , input ) ; } else { const int input_dims = input . dims ( ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( dims . shape ( ) ) , errors : : InvalidArgument ( \"\\'dims\\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-dimension,<S2SV_blank>not<S2SV_blank>\" , dims . dims ( ) ) ) ; OP_REQUIRES ( context , input_dims == dims . dim_size ( 0 ) , errors : : InvalidArgument ( \"\\'dims\\'<S2SV_blank>must<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>as<S2SV_blank>\\'input\\'<S2SV_blank>has<S2SV_blank>\" \"dimensions.<S2SV_blank>\\'input\\'<S2SV_blank>has<S2SV_blank>\" , input_dims , \"\\'dims\\'<S2SV_blank>has<S2SV_blank>\" , dims . dim_size ( 0 ) , \"<S2SV_blank>values\" ) ) ; OP_REQUIRES ( context , input_dims <= 8 , errors : : Unimplemented ( \"reverse<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>for<S2SV_blank>tensors<S2SV_blank>of<S2SV_blank>rank<S2SV_blank>><S2SV_blank>8.\" ) ) ; Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , input . shape ( ) , & output ) ) ; # define HANDLE_REVERSE ( NDIMS ) case NDIMS : HandleReverseCase < Device , T , NDIMS > ( context , dims . vec < bool > ( ) , output ) ; return ; switch ( input_dims ) { HANDLE_REVERSE ( 0 ) ; HANDLE_REVERSE ( 1 ) ; HANDLE_REVERSE ( 2 ) ; HANDLE_REVERSE ( 3 ) ; HANDLE_REVERSE ( 4 ) ; HANDLE_REVERSE ( 5 ) ; HANDLE_REVERSE ( 6 ) ; HANDLE_REVERSE ( 7 ) ; HANDLE_REVERSE ( 8 ) ; } # undef HANDLE_REVERSE } }", "target": "<S2SV_ModStart> 0 ) ; if ( input . dims ( ) > 0 ) { OP_REQUIRES ( context , input . dim_size ( 0 ) != 0 , errors : : InvalidArgument ( \"Invalid<S2SV_blank>input<S2SV_blank>first<S2SV_blank>dimension.<S2SV_blank>Found<S2SV_blank>0.\" ) ) ; }"}
{"source": "CWE-476 void RestoreTensor ( OpKernelContext * context , checkpoint : : TensorSliceReader : : OpenTableFunction open_func , int preferred_shard , bool restore_slice , int restore_index ) { const Tensor & file_pattern_t = context -> input ( 0 ) ; { const int64_t size = file_pattern_t . NumElements ( ) ; OP_REQUIRES ( context , size == 1 , errors : : InvalidArgument ( \"Input<S2SV_blank>0<S2SV_blank>(file_pattern)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>string<S2SV_blank>scalar;<S2SV_blank>got<S2SV_blank>a<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>\" , <S2SV_StartBug> size , \"elements\" ) ) ; <S2SV_EndBug> } const string & file_pattern = file_pattern_t . flat < tstring > ( ) ( 0 ) ; <S2SV_StartBug> const Tensor & tensor_name_t = context -> input ( 1 ) ; <S2SV_EndBug> const string & tensor_name = tensor_name_t . flat < tstring > ( ) ( restore_index ) ; std : : unique_ptr < checkpoint : : TensorSliceReader > allocated_reader ; const checkpoint : : TensorSliceReader * reader = nullptr ; if ( context -> slice_reader_cache ( ) ) { reader = context -> slice_reader_cache ( ) -> GetReader ( file_pattern , open_func , preferred_shard ) ; } if ( ! reader ) { allocated_reader . reset ( new checkpoint : : TensorSliceReader ( file_pattern , open_func , preferred_shard ) ) ; reader = allocated_reader . get ( ) ; } OP_REQUIRES_OK ( context , CHECK_NOTNULL ( reader ) -> status ( ) ) ; DataType type ; TensorShape saved_shape ; OP_REQUIRES ( context , reader -> HasTensor ( tensor_name , & saved_shape , & type ) , errors : : NotFound ( \"Tensor<S2SV_blank>name<S2SV_blank>\\\\\"\" , tensor_name , \"\\\\\"<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>checkpoint<S2SV_blank>files<S2SV_blank>\" , file_pattern ) ) ; OP_REQUIRES ( context , type == context -> expected_output_dtype ( restore_index ) , errors : : InvalidArgument ( \"Expected<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>a<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( context -> expected_output_dtype ( 0 ) ) , \",<S2SV_blank>got<S2SV_blank>a<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( type ) , \"<S2SV_blank>instead:<S2SV_blank>tensor_name<S2SV_blank>=<S2SV_blank>\" , tensor_name ) ) ; TensorShape output_shape ( saved_shape ) ; TensorSlice slice_to_load ( saved_shape . dims ( ) ) ; if ( restore_slice ) { const tstring & shape_spec = context -> input ( 2 ) . flat < tstring > ( ) ( restore_index ) ; if ( ! shape_spec . empty ( ) ) { TensorShape parsed_shape ; OP_REQUIRES_OK ( context , checkpoint : : ParseShapeAndSlice ( shape_spec , & parsed_shape , & slice_to_load , & output_shape ) ) ; OP_REQUIRES ( context , parsed_shape . IsSameSize ( saved_shape ) , errors : : InvalidArgument ( \"Shape<S2SV_blank>in<S2SV_blank>shape_and_slice<S2SV_blank>spec<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>the<S2SV_blank>shape<S2SV_blank>in<S2SV_blank>the<S2SV_blank>\" \"save<S2SV_blank>file:<S2SV_blank>\" , parsed_shape . DebugString ( ) , \",<S2SV_blank>save<S2SV_blank>file<S2SV_blank>shape:<S2SV_blank>\" , saved_shape . DebugString ( ) ) ) ; } } Tensor * t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( restore_index , output_shape , & t ) ) ; if ( output_shape . num_elements ( ) == 0 ) return ; # define READER_COPY ( T ) case DataTypeToEnum < T > : : value : OP_REQUIRES ( context , reader -> CopySliceData ( tensor_name , slice_to_load , t -> flat < T > ( ) . data ( ) ) , errors : : InvalidArgument ( \"Error<S2SV_blank>copying<S2SV_blank>slice<S2SV_blank>data\" ) ) ; break ; switch ( type ) { TF_CALL_SAVE_RESTORE_TYPES ( READER_COPY ) default : context -> SetStatus ( errors : : Unimplemented ( \"Restoring<S2SV_blank>data<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( type ) , \"<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported\" ) ) ; } # undef READER_COPY }", "target": "<S2SV_ModStart> , size , \"<S2SV_blank>elements\" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> 1 ) ; { const int64_t size = tensor_name_t . NumElements ( ) ; OP_REQUIRES ( context , size > restore_index , errors : : InvalidArgument ( \"Input<S2SV_blank>1<S2SV_blank>(file_pattern)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>\" , restore_index + 1 , \"<S2SV_blank>elements\" ) ) ; }"}
{"source": "CWE-416 GF_Err BD_DecMFFieldVec ( GF_BifsDecoder * codec , GF_BitStream * bs , GF_Node * node , GF_FieldInfo * field , Bool is_mem_com ) { GF_Err e ; u32 NbBits , nbFields ; u32 i ; GF_ChildNodeItem * last ; u8 qp_local , qp_on , initial_qp ; GF_FieldInfo sffield ; memset ( & sffield , 0 , sizeof ( GF_FieldInfo ) ) ; sffield . fieldIndex = field -> fieldIndex ; sffield . fieldType = gf_sg_vrml_get_sf_type ( field -> fieldType ) ; sffield . NDTtype = field -> NDTtype ; sffield . name = field -> name ; initial_qp = qp_local = qp_on = 0 ; NbBits = gf_bs_read_int ( bs , 5 ) ; nbFields = gf_bs_read_int ( bs , NbBits ) ; if ( codec -> ActiveQP ) { initial_qp = 1 ; gf_bifs_dec_qp14_set_length ( codec , nbFields ) ; } if ( field -> fieldType != GF_SG_VRML_MFNODE ) { e = gf_sg_vrml_mf_alloc ( field -> far_ptr , field -> fieldType , nbFields ) ; if ( e ) return e ; for ( i = 0 ; i < nbFields ; i ++ ) { e = gf_sg_vrml_mf_get_item ( field -> far_ptr , field -> fieldType , & sffield . far_ptr , i ) ; if ( e ) return e ; e = gf_bifs_dec_sf_field ( codec , bs , node , & sffield , GF_FALSE ) ; if ( e ) return e ; } <S2SV_StartBug> } else { <S2SV_EndBug> last = NULL ; for ( i = 0 ; i < nbFields ; i ++ ) { GF_Node * new_node = gf_bifs_dec_node ( codec , bs , field -> NDTtype ) ; if ( new_node ) { e = gf_node_register ( new_node , is_mem_com ? NULL : node ) ; <S2SV_StartBug> if ( e ) return e ; <S2SV_EndBug> if ( node ) { if ( gf_node_get_tag ( new_node ) == TAG_MPEG4_QuantizationParameter ) { qp_local = ( ( M_QuantizationParameter * ) new_node ) -> isLocal ; if ( qp_on ) gf_bifs_dec_qp_remove ( codec , GF_FALSE ) ; e = gf_bifs_dec_qp_set ( codec , new_node ) ; <S2SV_StartBug> if ( e ) return e ; <S2SV_EndBug> qp_on = 1 ; if ( qp_local ) qp_local = 2 ; if ( codec -> force_keep_qp ) { e = gf_node_list_add_child_last ( field -> far_ptr , new_node , & last ) ; <S2SV_StartBug> if ( e ) return e ; <S2SV_EndBug> } else { gf_node_register ( new_node , NULL ) ; gf_node_unregister ( new_node , node ) ; } } else { e = gf_node_list_add_child_last ( field -> far_ptr , new_node , & last ) ; <S2SV_StartBug> if ( e ) return e ; <S2SV_EndBug> } } else if ( codec -> pCurrentProto ) { e = gf_node_list_add_child_last ( ( GF_ChildNodeItem * * ) field -> far_ptr , new_node , & last ) ; <S2SV_StartBug> if ( e ) return e ; <S2SV_EndBug> } } else { <S2SV_StartBug> return codec -> LastError ? codec -> LastError : GF_NON_COMPLIANT_BITSTREAM ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> } if ( qp_on && qp_local ) { if ( qp_local == 2 ) { } else { gf_bifs_dec_qp_remove ( codec , initial_qp ) ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( qp_on ) gf_bifs_dec_qp_remove ( codec , GF_TRUE ) ; <S2SV_StartBug> return GF_OK ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> e ; } return GF_OK ; } e = GF_OK ; <S2SV_ModEnd> last = NULL <S2SV_ModStart> ( e ) goto exit <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( e ) goto exit <S2SV_ModEnd> ; qp_on = <S2SV_ModStart> ( e ) goto exit <S2SV_ModEnd> ; } else <S2SV_ModStart> ( e ) goto exit <S2SV_ModEnd> ; } } <S2SV_ModStart> ( e ) goto exit <S2SV_ModEnd> ; } } <S2SV_ModStart> } else { e = <S2SV_ModEnd> codec -> LastError <S2SV_ModStart> : GF_NON_COMPLIANT_BITSTREAM ; goto exit ; } } exit : <S2SV_ModEnd> if ( qp_on <S2SV_ModStart> ; } } <S2SV_ModEnd> if ( qp_on <S2SV_ModStart> ) ; return e <S2SV_ModEnd> ; }"}
{"source": "CWE-787 <S2SV_StartBug> void HierarchicalBitmapRequester : : PrepareForDecoding ( void ) <S2SV_EndBug> { # if ACCUSOFT_CODE <S2SV_StartBug> UBYTE i ; <S2SV_EndBug> BuildCommon ( ) ; <S2SV_StartBug> if ( m_ppDecodingMCU == NULL ) { <S2SV_EndBug> <S2SV_StartBug> m_ppDecodingMCU = ( struct Line * * ) m_pEnviron -> AllocMem ( sizeof ( struct Line * ) * m_ucCount * 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( m_ppDecodingMCU , 0 , sizeof ( struct Line * ) * m_ucCount * 8 ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( m_ppUpsampler == NULL ) { <S2SV_EndBug> <S2SV_StartBug> m_ppUpsampler = ( class UpsamplerBase * * ) m_pEnviron -> AllocMem ( sizeof ( class UpsamplerBase * ) * m_ucCount ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( m_ppUpsampler , 0 , sizeof ( class Upsampler * ) * m_ucCount ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < m_ucCount ; i ++ ) { <S2SV_EndBug> class Component * comp = m_pFrame -> ComponentOf ( i ) ; UBYTE sx = comp -> SubXOf ( ) ; UBYTE sy = comp -> SubYOf ( ) ; if ( sx > 1 || sy > 1 ) { <S2SV_StartBug> m_ppUpsampler [ i ] = UpsamplerBase : : CreateUpsampler ( m_pEnviron , sx , sy , <S2SV_EndBug> m_ulPixelWidth , m_ulPixelHeight , <S2SV_StartBug> m_pFrame -> TablesOf ( ) -> isChromaCentered ( ) ) ; <S2SV_EndBug> m_bSubsampling = true ; } } } if ( m_pLargestScale ) <S2SV_StartBug> m_pLargestScale -> PrepareForDecoding ( ) ; <S2SV_EndBug> # endif }", "target": "<S2SV_ModStart> HierarchicalBitmapRequester : : PrepareForEncoding <S2SV_ModEnd> ( void ) <S2SV_ModStart> # if ACCUSOFT_CODE <S2SV_ModEnd> BuildCommon ( ) <S2SV_ModStart> ; if ( m_ppEncodingMCU <S2SV_ModEnd> == NULL ) <S2SV_ModStart> NULL ) { m_ppEncodingMCU <S2SV_ModEnd> = ( struct <S2SV_ModStart> ; memset ( m_ppEncodingMCU <S2SV_ModEnd> , 0 , <S2SV_ModStart> } if ( m_ppDownsampler <S2SV_ModEnd> == NULL ) <S2SV_ModStart> NULL ) { m_ppDownsampler = ( class DownsamplerBase <S2SV_ModEnd> * * ) <S2SV_ModStart> sizeof ( class DownsamplerBase <S2SV_ModEnd> * ) * <S2SV_ModStart> ; memset ( m_ppDownsampler <S2SV_ModEnd> , 0 , <S2SV_ModStart> sizeof ( class DownsamplerBase <S2SV_ModEnd> * ) * <S2SV_ModStart> ; for ( UBYTE <S2SV_ModStart> 1 ) { m_ppDownsampler <S2SV_ModEnd> [ i ] <S2SV_ModStart> i ] = DownsamplerBase : : CreateDownsampler <S2SV_ModEnd> ( m_pEnviron , <S2SV_ModStart> ( ) -> isDownsamplingInterpolated <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ) m_pLargestScale -> PrepareForEncoding <S2SV_ModEnd> ( ) ;"}
{"source": "CWE-787 static json_t * check_attestation_fido_u2f ( json_t * j_params , unsigned char * credential_id , size_t credential_id_len , unsigned char * cert_x , size_t cert_x_len , unsigned char * cert_y , size_t cert_y_len , cbor_item_t * att_stmt , unsigned char * rpid_hash , size_t rpid_hash_len , const unsigned char * client_data ) { json_t * j_error = json_array ( ) , * j_return ; cbor_item_t * key = NULL , * x5c = NULL , * sig = NULL , * att_cert = NULL ; int i , ret ; char * message = NULL ; gnutls_pubkey_t pubkey = NULL ; gnutls_x509_crt_t cert = NULL ; gnutls_datum_t cert_dat , data , signature , cert_issued_by ; <S2SV_StartBug> unsigned char data_signed [ 200 ] , client_data_hash [ 32 ] , cert_export [ 32 ] , cert_export_b64 [ 64 ] ; <S2SV_EndBug> size_t data_signed_offset = 0 , client_data_hash_len = 32 , cert_export_len = 32 , cert_export_b64_len = 0 ; if ( j_error != NULL ) { do { if ( gnutls_x509_crt_init ( & cert ) ) { json_array_append_new ( j_error , json_string ( \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>gnutls_x509_crt_init\" ) ) ; break ; } if ( gnutls_pubkey_init ( & pubkey ) ) { json_array_append_new ( j_error , json_string ( \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>gnutls_pubkey_init\" ) ) ; break ; } if ( att_stmt == NULL || ! cbor_isa_map ( att_stmt ) || cbor_map_size ( att_stmt ) != 2 ) { json_array_append_new ( j_error , json_string ( \"CBOR<S2SV_blank>map<S2SV_blank>value<S2SV_blank>\\'attStmt\\'<S2SV_blank>invalid<S2SV_blank>format\" ) ) ; break ; } for ( i = 0 ; i < 2 ; i ++ ) { key = cbor_map_handle ( att_stmt ) [ i ] . key ; if ( cbor_isa_string ( key ) ) { if ( 0 == o_strncmp ( ( const char * ) cbor_string_handle ( key ) , \"x5c\" , MIN ( o_strlen ( \"x5c\" ) , cbor_string_length ( key ) ) ) ) { x5c = cbor_map_handle ( att_stmt ) [ i ] . value ; } else if ( 0 == o_strncmp ( ( const char * ) cbor_string_handle ( key ) , \"sig\" , MIN ( o_strlen ( \"sig\" ) , cbor_string_length ( key ) ) ) ) { sig = cbor_map_handle ( att_stmt ) [ i ] . value ; } else { message = msprintf ( \"attStmt<S2SV_blank>map<S2SV_blank>element<S2SV_blank>%d<S2SV_blank>key<S2SV_blank>is<S2SV_blank>not<S2SV_blank>valid:<S2SV_blank>\\'%.*s\\'\" , i , cbor_string_length ( key ) , cbor_string_handle ( key ) ) ; json_array_append_new ( j_error , json_string ( message ) ) ; o_free ( message ) ; break ; } } else { message = msprintf ( \"attStmt<S2SV_blank>map<S2SV_blank>element<S2SV_blank>%d<S2SV_blank>key<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>string\" , i ) ; json_array_append_new ( j_error , json_string ( message ) ) ; o_free ( message ) ; break ; } } if ( x5c == NULL || ! cbor_isa_array ( x5c ) || cbor_array_size ( x5c ) != 1 ) { json_array_append_new ( j_error , json_string ( \"CBOR<S2SV_blank>map<S2SV_blank>value<S2SV_blank>\\'x5c\\'<S2SV_blank>invalid<S2SV_blank>format\" ) ) ; break ; } att_cert = cbor_array_get ( x5c , 0 ) ; cert_dat . data = cbor_bytestring_handle ( att_cert ) ; cert_dat . size = cbor_bytestring_length ( att_cert ) ; if ( ( ret = gnutls_x509_crt_import ( cert , & cert_dat , GNUTLS_X509_FMT_DER ) ) < 0 ) { json_array_append_new ( j_error , json_string ( \"Error<S2SV_blank>importing<S2SV_blank>x509<S2SV_blank>certificate\" ) ) ; y_log_message ( Y_LOG_LEVEL_DEBUG , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>gnutls_pcert_import_x509_raw:<S2SV_blank>%d\" , ret ) ; break ; } if ( json_object_get ( j_params , \"root-ca-list\" ) != json_null ( ) && validate_certificate_from_root ( j_params , cert , x5c ) != G_OK ) { json_array_append_new ( j_error , json_string ( \"Unrecognized<S2SV_blank>certificate<S2SV_blank>authority\" ) ) ; if ( gnutls_x509_crt_get_issuer_dn2 ( cert , & cert_issued_by ) >= 0 ) { message = msprintf ( \"Unrecognized<S2SV_blank>certificate<S2SV_blank>autohority:<S2SV_blank>%.*s\" , cert_issued_by . size , cert_issued_by . data ) ; y_log_message ( Y_LOG_LEVEL_DEBUG , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>%s\" , message ) ; o_free ( message ) ; gnutls_free ( cert_issued_by . data ) ; } else { y_log_message ( Y_LOG_LEVEL_DEBUG , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Unrecognized<S2SV_blank>certificate<S2SV_blank>autohority<S2SV_blank>(unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>issuer<S2SV_blank>dn)\" ) ; } break ; } if ( ( ret = gnutls_pubkey_import_x509 ( pubkey , cert , 0 ) ) < 0 ) { json_array_append_new ( j_error , json_string ( \"Error<S2SV_blank>importing<S2SV_blank>x509<S2SV_blank>certificate\" ) ) ; y_log_message ( Y_LOG_LEVEL_DEBUG , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>gnutls_pubkey_import_x509:<S2SV_blank>%d\" , ret ) ; break ; } if ( ( ret = gnutls_x509_crt_get_key_id ( cert , GNUTLS_KEYID_USE_SHA256 , cert_export , & cert_export_len ) ) < 0 ) { json_array_append_new ( j_error , json_string ( \"Error<S2SV_blank>exporting<S2SV_blank>x509<S2SV_blank>certificate\" ) ) ; y_log_message ( Y_LOG_LEVEL_DEBUG , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>gnutls_x509_crt_get_key_id:<S2SV_blank>%d\" , ret ) ; break ; } if ( ! o_base64_encode ( cert_export , cert_export_len , cert_export_b64 , & cert_export_b64_len ) ) { json_array_append_new ( j_error , json_string ( \"Internal<S2SV_blank>error\" ) ) ; y_log_message ( Y_LOG_LEVEL_DEBUG , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>o_base64_encode<S2SV_blank>cert_export\" ) ; break ; } if ( ! generate_digest_raw ( digest_SHA256 , client_data , o_strlen ( ( char * ) client_data ) , client_data_hash , & client_data_hash_len ) ) { json_array_append_new ( j_error , json_string ( \"Internal<S2SV_blank>error\" ) ) ; y_log_message ( Y_LOG_LEVEL_ERROR , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>generate_digest_raw<S2SV_blank>client_data\" ) ; break ; } if ( sig == NULL || ! cbor_isa_bytestring ( sig ) ) { json_array_append_new ( j_error , json_string ( \"Error<S2SV_blank>sig<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>bytestring\" ) ) ; break ; } <S2SV_StartBug> data_signed [ 0 ] = 0x0 ; <S2SV_EndBug> data_signed_offset = 1 ; memcpy ( data_signed + data_signed_offset , rpid_hash , rpid_hash_len ) ; data_signed_offset += rpid_hash_len ; memcpy ( data_signed + data_signed_offset , client_data_hash , client_data_hash_len ) ; data_signed_offset += client_data_hash_len ; memcpy ( data_signed + data_signed_offset , credential_id , credential_id_len ) ; data_signed_offset += credential_id_len ; data_signed [ data_signed_offset ] = 0x04 ; data_signed_offset ++ ; memcpy ( data_signed + data_signed_offset , cert_x , cert_x_len ) ; data_signed_offset += cert_x_len ; memcpy ( data_signed + data_signed_offset , cert_y , cert_y_len ) ; data_signed_offset += cert_y_len ; data . data = data_signed ; data . size = data_signed_offset ; signature . data = cbor_bytestring_handle ( sig ) ; signature . size = cbor_bytestring_length ( sig ) ; if ( gnutls_pubkey_verify_data2 ( pubkey , GNUTLS_SIGN_ECDSA_SHA256 , 0 , & data , & signature ) ) { json_array_append_new ( j_error , json_string ( \"Invalid<S2SV_blank>signature\" ) ) ; } } while ( 0 ) ; <S2SV_StartBug> <S2SV_EndBug> if ( json_array_size ( j_error ) ) { j_return = json_pack ( \"{sisO}\" , \"result\" , G_ERROR_PARAM , \"error\" , j_error ) ; } else { j_return = json_pack ( \"{sis{ss%}}\" , \"result\" , G_OK , \"data\" , \"certificate\" , cert_export_b64 , cert_export_b64_len ) ; } json_decref ( j_error ) ; gnutls_pubkey_deinit ( pubkey ) ; gnutls_x509_crt_deinit ( cert ) ; if ( att_cert != NULL ) { cbor_decref ( & att_cert ) ; } } else { y_log_message ( Y_LOG_LEVEL_ERROR , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>allocating<S2SV_blank>resources<S2SV_blank>for<S2SV_blank>j_error\" ) ; j_return = json_pack ( \"{si}\" , \"result\" , G_ERROR ) ; } return j_return ; }", "target": "<S2SV_ModStart> ; unsigned char * data_signed = NULL <S2SV_ModEnd> , client_data_hash [ <S2SV_ModStart> break ; } if ( ( data_signed = o_malloc ( rpid_hash_len + client_data_hash_len + credential_id_len + cert_x_len + cert_y_len + 2 ) ) == NULL ) { y_log_message ( Y_LOG_LEVEL_DEBUG , \"check_attestation_fido_u2f<S2SV_blank>-<S2SV_blank>Error<S2SV_blank>allocating<S2SV_blank>data_signed\" ) ; json_array_append_new ( j_error , json_string ( \"Internal<S2SV_blank>error\" ) ) ; break ; } <S2SV_ModStart> 0 ) ; o_free ( data_signed ) ;"}
{"source": "CWE-703 void Compute ( OpKernelContext * ctx ) override { const Tensor & gradient = ctx -> input ( 0 ) ; const Tensor & input = ctx -> input ( 1 ) ; Tensor * input_backprop = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , input . shape ( ) , & input_backprop ) ) ; OP_REQUIRES ( ctx , axis_ >= - 1 , errors : : InvalidArgument ( \"Axis<S2SV_blank>must<S2SV_blank>be<S2SV_blank>at<S2SV_blank>least<S2SV_blank>-1.<S2SV_blank>Found<S2SV_blank>\" , axis_ ) ) ; OP_REQUIRES ( ctx , ( axis_ == - 1 || axis_ < input . shape ( ) . dims ( ) ) , errors : : InvalidArgument ( \"Axis<S2SV_blank>should<S2SV_blank>be<S2SV_blank>-1<S2SV_blank>or<S2SV_blank>0<S2SV_blank>or<S2SV_blank>a<S2SV_blank>positive<S2SV_blank>value<S2SV_blank>less<S2SV_blank>than<S2SV_blank>\" , input . shape ( ) . dims ( ) , \"but<S2SV_blank>given<S2SV_blank>axis<S2SV_blank>value<S2SV_blank>was<S2SV_blank>\" , axis_ ) ) ; OP_REQUIRES ( ctx , input . IsSameSize ( gradient ) , errors : : InvalidArgument ( \"gradient<S2SV_blank>and<S2SV_blank>input<S2SV_blank>must<S2SV_blank>be<S2SV_blank>the<S2SV_blank>same<S2SV_blank>size\" ) ) ; const int depth = ( axis_ == - 1 ) ? 1 : input . dim_size ( axis_ ) ; const Tensor & input_min_tensor = ctx -> input ( 2 ) ; OP_REQUIRES ( ctx , input_min_tensor . dims ( ) == 0 || input_min_tensor . dims ( ) == 1 , errors : : InvalidArgument ( <S2SV_StartBug> \"Input<S2SV_blank>min<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>dimension<S2SV_blank>1.<S2SV_blank>Recieved<S2SV_blank>\" , <S2SV_EndBug> input_min_tensor . dims ( ) , \".\" ) ) ; const Tensor & input_max_tensor = ctx -> input ( 3 ) ; OP_REQUIRES ( ctx , input_max_tensor . dims ( ) == 0 || input_max_tensor . dims ( ) == 1 , errors : : InvalidArgument ( <S2SV_StartBug> \"Input<S2SV_blank>max<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>dimension<S2SV_blank>1.<S2SV_blank>Recieved<S2SV_blank>\" , <S2SV_EndBug> input_max_tensor . dims ( ) , \".\" ) ) ; if ( axis_ != - 1 ) { OP_REQUIRES ( ctx , input_min_tensor . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"min<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>was<S2SV_blank>\" , input_min_tensor . dim_size ( 0 ) ) ) ; OP_REQUIRES ( ctx , input_max_tensor . dim_size ( 0 ) == depth , errors : : InvalidArgument ( \"max<S2SV_blank>has<S2SV_blank>incorrect<S2SV_blank>size,<S2SV_blank>expected<S2SV_blank>\" , depth , \"<S2SV_blank>was<S2SV_blank>\" , input_max_tensor . dim_size ( 0 ) ) ) ; } TensorShape min_max_shape ( input_min_tensor . shape ( ) ) ; Tensor * input_min_backprop ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , min_max_shape , & input_min_backprop ) ) ; Tensor * input_max_backprop ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 2 , min_max_shape , & input_max_backprop ) ) ; if ( axis_ == - 1 ) { <S2SV_StartBug> functor : : QuantizeAndDequantizeOneScaleGradientFunctor < Device , T > f ; <S2SV_EndBug> f ( ctx -> eigen_device < Device > ( ) , gradient . template flat < T > ( ) , input . template flat < T > ( ) , input_min_tensor . scalar < T > ( ) , input_max_tensor . scalar < T > ( ) , input_backprop -> template flat < T > ( ) , input_min_backprop -> template scalar < T > ( ) , input_max_backprop -> template scalar < T > ( ) ) ; } else { functor : : QuantizeAndDequantizePerChannelGradientFunctor < Device , T > f ; f ( ctx -> eigen_device < Device > ( ) , gradient . template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , input . template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , & input_min_tensor , & input_max_tensor , input_backprop -> template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , input_min_backprop -> template flat < T > ( ) , input_max_backprop -> template flat < T > ( ) ) ; } }", "target": "<S2SV_ModStart> : InvalidArgument ( \"Input<S2SV_blank>min<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>dimension<S2SV_blank>0<S2SV_blank>or<S2SV_blank>1.<S2SV_blank>Received<S2SV_blank>\" <S2SV_ModEnd> , input_min_tensor . <S2SV_ModStart> : InvalidArgument ( \"Input<S2SV_blank>max<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>dimension<S2SV_blank>0<S2SV_blank>or<S2SV_blank>1.<S2SV_blank>Received<S2SV_blank>\" <S2SV_ModEnd> , input_max_tensor . <S2SV_ModStart> 1 ) { OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( input_min_tensor . shape ( ) ) , errors : : InvalidArgument ( \"input_min<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>if<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>unspecified\" ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils : : IsScalar ( input_max_tensor . shape ( ) ) , errors : : InvalidArgument ( \"input_max<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>scalar<S2SV_blank>if<S2SV_blank>axis<S2SV_blank>is<S2SV_blank>unspecified\" ) ) ;"}
{"source": "CWE-787 static int MqttClient_WaitType ( MqttClient * client , void * packet_obj , byte wait_type , word16 wait_packet_id , int timeout_ms ) { int rc ; word16 packet_id ; MqttPacketType packet_type ; # ifdef WOLFMQTT_MULTITHREAD MqttPendResp * pendResp ; int readLocked ; # endif MqttMsgStat * mms_stat ; int waitMatchFound ; if ( client == NULL || packet_obj == NULL ) { return MQTT_CODE_ERROR_BAD_ARG ; } mms_stat = ( MqttMsgStat * ) packet_obj ; wait_again : packet_id = 0 ; packet_type = MQTT_PACKET_TYPE_RESERVED ; # ifdef WOLFMQTT_MULTITHREAD pendResp = NULL ; readLocked = 0 ; # endif waitMatchFound = 0 ; # ifdef WOLFMQTT_DEBUG_CLIENT PRINTF ( \"MqttClient_WaitType:<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%d),<S2SV_blank>ID<S2SV_blank>%d\" , MqttPacket_TypeDesc ( ( MqttPacketType ) wait_type ) , wait_type , wait_packet_id ) ; # endif switch ( ( int ) * mms_stat ) { case MQTT_MSG_BEGIN : { # ifdef WOLFMQTT_MULTITHREAD rc = wm_SemLock ( & client -> lockRecv ) ; if ( rc != 0 ) { PRINTF ( \"MqttClient_WaitType:<S2SV_blank>recv<S2SV_blank>lock<S2SV_blank>error!\" ) ; return rc ; } readLocked = 1 ; # endif client -> packet . stat = MQTT_PK_BEGIN ; } FALL_THROUGH ; # ifdef WOLFMQTT_V5 case MQTT_MSG_AUTH : # endif case MQTT_MSG_WAIT : { # ifdef WOLFMQTT_MULTITHREAD pendResp = NULL ; rc = wm_SemLock ( & client -> lockClient ) ; if ( rc == 0 ) { if ( MqttClient_RespList_Find ( client , ( MqttPacketType ) wait_type , wait_packet_id , & pendResp ) ) { if ( pendResp -> packetDone ) { rc = pendResp -> packet_ret ; # ifdef WOLFMQTT_DEBUG_CLIENT PRINTF ( \"PendResp<S2SV_blank>already<S2SV_blank>Done<S2SV_blank>%p:<S2SV_blank>Rc<S2SV_blank>%d\" , pendResp , rc ) ; # endif MqttClient_RespList_Remove ( client , pendResp ) ; wm_SemUnlock ( & client -> lockClient ) ; wm_SemUnlock ( & client -> lockRecv ) ; return rc ; } } wm_SemUnlock ( & client -> lockClient ) ; } else { break ; } # endif * mms_stat = MQTT_MSG_WAIT ; rc = MqttPacket_Read ( client , client -> rx_buf , client -> rx_buf_len , timeout_ms ) ; if ( rc <= 0 ) { break ; } client -> packet . buf_len = rc ; rc = MqttClient_DecodePacket ( client , client -> rx_buf , client -> packet . buf_len , NULL , & packet_type , NULL , & packet_id ) ; if ( rc < 0 ) { break ; } # ifdef WOLFMQTT_DEBUG_CLIENT PRINTF ( \"Read<S2SV_blank>Packet:<S2SV_blank>Len<S2SV_blank>%d,<S2SV_blank>Type<S2SV_blank>%d,<S2SV_blank>ID<S2SV_blank>%d\" , client -> packet . buf_len , packet_type , packet_id ) ; # endif * mms_stat = MQTT_MSG_READ ; } FALL_THROUGH ; case MQTT_MSG_READ : case MQTT_MSG_READ_PAYLOAD : { MqttPacketType use_packet_type ; void * use_packet_obj ; # ifdef WOLFMQTT_MULTITHREAD readLocked = 1 ; # endif if ( * mms_stat == MQTT_MSG_READ_PAYLOAD ) { packet_type = MQTT_PACKET_TYPE_PUBLISH ; } if ( ( wait_type == MQTT_PACKET_TYPE_ANY || wait_type == packet_type || <S2SV_StartBug> MqttIsPubRespPacket ( packet_type ) == MqttIsPubRespPacket ( wait_type ) ) && <S2SV_EndBug> ( wait_packet_id == 0 || wait_packet_id == packet_id ) ) { use_packet_obj = packet_obj ; waitMatchFound = 1 ; } else { use_packet_obj = & client -> msg ; } use_packet_type = packet_type ; # ifdef WOLFMQTT_MULTITHREAD pendResp = NULL ; rc = wm_SemLock ( & client -> lockClient ) ; if ( rc == 0 ) { if ( MqttClient_RespList_Find ( client , packet_type , packet_id , & pendResp ) ) { pendResp -> packetProcessing = 1 ; use_packet_obj = pendResp -> packet_obj ; use_packet_type = pendResp -> packet_type ; waitMatchFound = 0 ; } wm_SemUnlock ( & client -> lockClient ) ; } else { break ; } # endif rc = MqttClient_HandlePacket ( client , use_packet_type , use_packet_obj , timeout_ms ) ; # ifdef WOLFMQTT_NONBLOCK if ( rc == MQTT_CODE_CONTINUE ) { return rc ; } # endif if ( rc >= 0 ) { rc = MQTT_CODE_SUCCESS ; } # ifdef WOLFMQTT_MULTITHREAD if ( pendResp ) { if ( wm_SemLock ( & client -> lockClient ) == 0 ) { pendResp -> packetDone = 1 ; pendResp -> packet_ret = rc ; # ifdef WOLFMQTT_DEBUG_CLIENT PRINTF ( \"PendResp<S2SV_blank>Done<S2SV_blank>%p\" , pendResp ) ; # endif pendResp = NULL ; wm_SemUnlock ( & client -> lockClient ) ; } } # endif break ; } case MQTT_MSG_WRITE : case MQTT_MSG_WRITE_PAYLOAD : default : { # ifdef WOLFMQTT_DEBUG_CLIENT PRINTF ( \"MqttClient_WaitType:<S2SV_blank>Invalid<S2SV_blank>state<S2SV_blank>%d!\" , * mms_stat ) ; # endif rc = MQTT_CODE_ERROR_STAT ; break ; } } # ifdef WOLFMQTT_NONBLOCK if ( rc != MQTT_CODE_CONTINUE ) # endif { * mms_stat = MQTT_MSG_BEGIN ; } # ifdef WOLFMQTT_MULTITHREAD if ( readLocked ) { wm_SemUnlock ( & client -> lockRecv ) ; } # endif if ( rc < 0 ) { # ifdef WOLFMQTT_DEBUG_CLIENT PRINTF ( \"MqttClient_WaitType:<S2SV_blank>Failure:<S2SV_blank>%s<S2SV_blank>(%d)\" , MqttClient_ReturnCodeToString ( rc ) , rc ) ; # endif return rc ; } if ( ! waitMatchFound ) { goto wait_again ; } return rc ; }", "target": "<S2SV_ModStart> == packet_type || ( <S2SV_ModStart> ( packet_type ) && <S2SV_ModEnd> MqttIsPubRespPacket ( wait_type <S2SV_ModStart> MqttIsPubRespPacket ( wait_type )"}
{"source": "CWE-416 njs_function_frame_save ( njs_vm_t * vm , njs_frame_t * frame , u_char * pc ) { size_t value_count , n ; njs_value_t * start , * end , * p , * * new , * value , * * local ; njs_function_t * function ; njs_native_frame_t * active , * native ; * frame = * vm -> active_frame ; frame -> previous_active_frame = NULL ; <S2SV_StartBug> native = & frame -> native ; <S2SV_EndBug> active = & vm -> active_frame -> native ; value_count = njs_function_frame_value_count ( active ) ; function = active -> function ; new = ( njs_value_t * * ) ( ( u_char * ) native + NJS_FRAME_SIZE ) ; value = ( njs_value_t * ) ( new + value_count + function -> u . lambda -> temp ) ; native -> arguments = value ; native -> arguments_offset = value + ( function -> args_offset - 1 ) ; native -> local = new + njs_function_frame_args_count ( active ) ; native -> temp = new + value_count ; native -> pc = pc ; start = njs_function_frame_values ( active , & end ) ; p = native -> arguments ; while ( start < end ) { * p = * start ++ ; * new ++ = p ++ ; } p = native -> arguments ; local = native -> local + function -> args_offset ; for ( n = 0 ; n < function -> args_count ; n ++ ) { if ( ! njs_is_valid ( p ) ) { njs_set_undefined ( p ) ; } * local ++ = p ++ ; } return NJS_OK ; }", "target": "<S2SV_ModStart> frame -> native ; native -> size = 0 ; native -> free = NULL ; native -> free_size = 0"}
{"source": "CWE-703 njs_object_iterate_reverse ( njs_vm_t * vm , njs_iterator_args_t * args , njs_iterator_handler_t handler ) { double idx ; int64_t i , from , to , length ; njs_int_t ret ; njs_array_t * array , * keys ; njs_value_t * entry , * value , prop , character , string_obj ; const u_char * p , * end , * pos ; njs_string_prop_t string_prop ; njs_object_value_t * object ; value = args -> value ; from = args -> from ; to = args -> to ; if ( njs_is_array ( value ) ) { array = njs_array ( value ) ; from += 1 ; while ( from -- > to ) { if ( njs_slow_path ( ! array -> object . fast_array ) ) { goto process_object ; } if ( njs_fast_path ( from < array -> length && njs_is_valid ( & array -> start [ from ] ) ) ) { ret = handler ( vm , args , & array -> start [ from ] , from ) ; } else { entry = njs_value_arg ( & njs_value_invalid ) ; ret = njs_value_property_i64 ( vm , value , from , & prop ) ; if ( njs_slow_path ( ret != NJS_DECLINED ) ) { if ( ret == NJS_ERROR ) { return NJS_ERROR ; } entry = & prop ; } ret = handler ( vm , args , entry , from ) ; } if ( njs_slow_path ( ret != NJS_OK ) ) { if ( ret == NJS_DONE ) { return NJS_DONE ; } return NJS_ERROR ; } } return NJS_OK ; } if ( njs_is_string ( value ) || njs_is_object_string ( value ) ) { if ( njs_is_string ( value ) ) { object = njs_object_value_alloc ( vm , NJS_OBJ_TYPE_STRING , 0 , value ) ; if ( njs_slow_path ( object == NULL ) ) { return NJS_ERROR ; } njs_set_object_value ( & string_obj , object ) ; args -> value = & string_obj ; } else { value = njs_object_value ( value ) ; } length = njs_string_prop ( & string_prop , value ) ; end = string_prop . start + string_prop . size ; if ( ( size_t ) length == string_prop . size ) { p = string_prop . start + from ; i = from + 1 ; while ( i -- > to ) { ( void ) njs_string_new ( vm , & character , p , 1 , 1 ) ; ret = handler ( vm , args , & character , i ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { if ( ret == NJS_DONE ) { return NJS_DONE ; } return NJS_ERROR ; } p -- ; } } else { <S2SV_StartBug> p = njs_string_offset ( string_prop . start , end , from ) ; <S2SV_EndBug> p = njs_utf8_next ( p , end ) ; <S2SV_StartBug> i = from + 1 ; <S2SV_EndBug> while ( i -- > to ) { pos = njs_utf8_prev ( p ) ; ( void ) njs_string_new ( vm , & character , pos , p - pos , 1 ) ; ret = handler ( vm , args , & character , i ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { if ( ret == NJS_DONE ) { return NJS_DONE ; } return NJS_ERROR ; } p = pos ; } } return NJS_OK ; } if ( ! njs_is_object ( value ) ) { return NJS_OK ; } process_object : if ( ! njs_fast_object ( from - to ) ) { keys = njs_array_indices ( vm , value ) ; if ( njs_slow_path ( keys == NULL ) ) { return NJS_ERROR ; } i = keys -> length ; while ( i > 0 ) { idx = njs_string_to_index ( & keys -> start [ -- i ] ) ; if ( idx < to || idx > from ) { continue ; } ret = njs_iterator_object_handler ( vm , handler , args , & keys -> start [ i ] , idx ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { njs_array_destroy ( vm , keys ) ; return ret ; } } njs_array_destroy ( vm , keys ) ; return NJS_OK ; } i = from + 1 ; while ( i -- > to ) { ret = njs_iterator_object_handler ( vm , handler , args , NULL , i ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } } return NJS_OK ; }", "target": "<S2SV_ModStart> { p = NULL ; i = from + 1 ; if ( i > to ) { p = <S2SV_ModStart> end ) ; } <S2SV_ModEnd> while ( i"}
{"source": "CWE-125 void Compute ( OpKernelContext * context ) override { OpInputList ragged_nested_splits_in ; OP_REQUIRES_OK ( context , context -> input_list ( \"rt_nested_splits\" , & ragged_nested_splits_in ) ) ; const int ragged_nested_splits_len = ragged_nested_splits_in . size ( ) ; RaggedTensorVariant batched_ragged_input ; batched_ragged_input . set_values ( context -> input ( ragged_nested_splits_len ) ) ; batched_ragged_input . mutable_nested_splits ( ) -> reserve ( ragged_nested_splits_len ) ; for ( int i = 0 ; i < ragged_nested_splits_len ; i ++ ) { batched_ragged_input . append_splits ( ragged_nested_splits_in [ i ] ) ; } if ( ! batched_input_ ) { Tensor * encoded_scalar ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { } ) , & encoded_scalar ) ) ; encoded_scalar -> scalar < Variant > ( ) ( ) = std : : move ( batched_ragged_input ) ; return ; } <S2SV_StartBug> std : : vector < RaggedTensorVariant > unbatched_ragged_input ; <S2SV_EndBug> auto batched_splits_top_vec = batched_ragged_input . splits ( 0 ) . vec < SPLIT_TYPE > ( ) ; int num_components = batched_splits_top_vec . size ( ) - 1 ; OP_REQUIRES ( context , num_components >= 0 , errors : : Internal ( \"Invalid<S2SV_blank>split<S2SV_blank>argument.\" ) ) ; OP_REQUIRES_OK ( context , UnbatchRaggedZerothDim < VALUE_TYPE , SPLIT_TYPE > ( batched_ragged_input , & unbatched_ragged_input ) ) ; Tensor * encoded_vector ; int output_size = unbatched_ragged_input . size ( ) ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { output_size } ) , & encoded_vector ) ) ; auto encoded_vector_t = encoded_vector -> vec < Variant > ( ) ; for ( int i = 0 ; i < output_size ; i ++ ) { encoded_vector_t ( i ) = unbatched_ragged_input [ i ] ; } }", "target": "<S2SV_ModStart> return ; } OP_REQUIRES ( context , ragged_nested_splits_len > 0 , errors : : InvalidArgument ( \"rt_nested_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list<S2SV_blank>of<S2SV_blank>one<S2SV_blank>or<S2SV_blank>more,<S2SV_blank>but<S2SV_blank>\" \"received<S2SV_blank>rt_nested_splits<S2SV_blank>of<S2SV_blank>length<S2SV_blank>0.\" ) ) ;"}
{"source": "CWE-703 Status TransposeShapeFn ( InferenceContext * c ) { ShapeHandle input = c -> input ( 0 ) ; ShapeHandle perm_shape = c -> input ( 1 ) ; const Tensor * perm = c -> input_tensor ( 1 ) ; DimensionHandle perm_elems = c -> NumElements ( perm_shape ) ; if ( ! c -> RankKnown ( input ) && ! c -> ValueKnown ( perm_elems ) && perm == nullptr ) { c -> set_output ( 0 , c -> UnknownShape ( ) ) ; return Status : : OK ( ) ; } int64_t rank ; if ( c -> RankKnown ( input ) ) { rank = c -> Rank ( input ) ; } else if ( c -> ValueKnown ( perm_elems ) ) { rank = c -> Value ( perm_elems ) ; } else { rank = perm -> NumElements ( ) ; } if ( ! c -> RankKnown ( input ) && rank < 2 ) { c -> set_output ( 0 , input ) ; return Status : : OK ( ) ; } std : : vector < DimensionHandle > dims ; dims . resize ( rank ) ; TF_RETURN_IF_ERROR ( c -> WithRank ( input , rank , & input ) ) ; TF_RETURN_IF_ERROR ( c -> WithRank ( perm_shape , 1 , & perm_shape ) ) ; TF_RETURN_IF_ERROR ( c -> WithValue ( perm_elems , rank , & perm_elems ) ) ; if ( perm != nullptr ) { std : : vector < int64_t > data ; if ( perm -> dtype ( ) == DT_INT32 ) { data = AsInt64 < int32 > ( perm , rank ) ; } else { data = AsInt64 < int64_t > ( perm , rank ) ; } for ( int32_t i = 0 ; i < rank ; ++ i ) { int64_t in_idx = data [ i ] ; <S2SV_StartBug> if ( in_idx >= rank ) { <S2SV_EndBug> return errors : : InvalidArgument ( \"perm<S2SV_blank>dim<S2SV_blank>\" , in_idx , \"<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range<S2SV_blank>of<S2SV_blank>input<S2SV_blank>rank<S2SV_blank>\" , rank ) ; } dims [ i ] = c -> Dim ( input , in_idx ) ; } } else { for ( int i = 0 ; i < rank ; ++ i ) { dims [ i ] = c -> UnknownDim ( ) ; } } c -> set_output ( 0 , c -> MakeShape ( dims ) ) ; return Status : : OK ( ) ; }", "target": "<S2SV_ModStart> in_idx >= rank || in_idx <= - rank"}
{"source": "CWE-125 TfLiteStatus EvalGatherNd ( TfLiteContext * context , const TfLiteTensor * params , const TfLiteTensor * indices , TfLiteTensor * output ) { <S2SV_StartBug> switch ( params -> type ) { <S2SV_EndBug> case kTfLiteFloat32 : return GatherNd < float , IndicesT > ( params , indices , output ) ; case kTfLiteUInt8 : return GatherNd < uint8_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt8 : return GatherNd < int8_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt16 : return GatherNd < int16_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt32 : return GatherNd < int32_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt64 : return GatherNd < int64_t , IndicesT > ( params , indices , output ) ; case kTfLiteString : return GatherNdString < IndicesT > ( params , indices , output ) ; default : context -> ReportError ( context , \"Params<S2SV_blank>type<S2SV_blank>\\'%s\\'<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>gather_nd.\" , TfLiteTypeGetName ( params -> type ) ) ; return kTfLiteError ; } }", "target": "<S2SV_ModStart> output ) { bool indices_has_only_positive_elements = true ; const auto * indices_values = GetTensorData < IndicesT > ( indices ) ; const size_t num_indices = indices -> bytes / sizeof ( IndicesT ) ; for ( size_t i = 0 ; i < num_indices ; i ++ ) { if ( indices_values [ i ] < 0 ) { indices_has_only_positive_elements = false ; break ; } } TF_LITE_ENSURE ( context , indices_has_only_positive_elements ) ;"}
{"source": "CWE-703 static int protocol_client_msg ( VncState * vs , uint8_t * data , size_t len ) { int i ; uint16_t limit ; VncDisplay * vd = vs -> vd ; if ( data [ 0 ] > 3 ) { update_displaychangelistener ( & vd -> dcl , VNC_REFRESH_INTERVAL_BASE ) ; } switch ( data [ 0 ] ) { case VNC_MSG_CLIENT_SET_PIXEL_FORMAT : if ( len == 1 ) return 20 ; set_pixel_format ( vs , read_u8 ( data , 4 ) , read_u8 ( data , 5 ) , read_u8 ( data , 6 ) , read_u8 ( data , 7 ) , read_u16 ( data , 8 ) , read_u16 ( data , 10 ) , read_u16 ( data , 12 ) , read_u8 ( data , 14 ) , read_u8 ( data , 15 ) , read_u8 ( data , 16 ) ) ; break ; case VNC_MSG_CLIENT_SET_ENCODINGS : if ( len == 1 ) return 4 ; if ( len == 4 ) { limit = read_u16 ( data , 2 ) ; if ( limit > 0 ) return 4 + ( limit * 4 ) ; } else limit = read_u16 ( data , 2 ) ; for ( i = 0 ; i < limit ; i ++ ) { int32_t val = read_s32 ( data , 4 + ( i * 4 ) ) ; memcpy ( data + 4 + ( i * 4 ) , & val , sizeof ( val ) ) ; } set_encodings ( vs , ( int32_t * ) ( data + 4 ) , limit ) ; break ; case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST : if ( len == 1 ) return 10 ; framebuffer_update_request ( vs , read_u8 ( data , 1 ) , read_u16 ( data , 2 ) , read_u16 ( data , 4 ) , read_u16 ( data , 6 ) , read_u16 ( data , 8 ) ) ; break ; case VNC_MSG_CLIENT_KEY_EVENT : if ( len == 1 ) return 8 ; key_event ( vs , read_u8 ( data , 1 ) , read_u32 ( data , 4 ) ) ; break ; case VNC_MSG_CLIENT_POINTER_EVENT : if ( len == 1 ) return 6 ; pointer_event ( vs , read_u8 ( data , 1 ) , read_u16 ( data , 2 ) , read_u16 ( data , 4 ) ) ; break ; case VNC_MSG_CLIENT_CUT_TEXT : <S2SV_StartBug> if ( len == 1 ) <S2SV_EndBug> return 8 ; <S2SV_StartBug> <S2SV_EndBug> if ( len == 8 ) { <S2SV_StartBug> uint32_t dlen = read_u32 ( data , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dlen > 0 ) <S2SV_EndBug> <S2SV_StartBug> return 8 + dlen ; <S2SV_EndBug> } client_cut_text ( vs , read_u32 ( data , 4 ) , data + 8 ) ; break ; case VNC_MSG_CLIENT_QEMU : if ( len == 1 ) return 2 ; switch ( read_u8 ( data , 1 ) ) { case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT : if ( len == 2 ) return 12 ; ext_key_event ( vs , read_u16 ( data , 2 ) , read_u32 ( data , 4 ) , read_u32 ( data , 8 ) ) ; break ; case VNC_MSG_CLIENT_QEMU_AUDIO : if ( len == 2 ) return 4 ; switch ( read_u16 ( data , 2 ) ) { case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE : audio_add ( vs ) ; break ; case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE : audio_del ( vs ) ; break ; case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT : if ( len == 4 ) return 10 ; switch ( read_u8 ( data , 4 ) ) { case 0 : vs -> as . fmt = AUD_FMT_U8 ; break ; case 1 : vs -> as . fmt = AUD_FMT_S8 ; break ; case 2 : vs -> as . fmt = AUD_FMT_U16 ; break ; case 3 : vs -> as . fmt = AUD_FMT_S16 ; break ; case 4 : vs -> as . fmt = AUD_FMT_U32 ; break ; case 5 : vs -> as . fmt = AUD_FMT_S32 ; break ; default : printf ( \"Invalid<S2SV_blank>audio<S2SV_blank>format<S2SV_blank>%d\\\\n\" , read_u8 ( data , 4 ) ) ; vnc_client_error ( vs ) ; break ; } vs -> as . nchannels = read_u8 ( data , 5 ) ; if ( vs -> as . nchannels != 1 && vs -> as . nchannels != 2 ) { printf ( \"Invalid<S2SV_blank>audio<S2SV_blank>channel<S2SV_blank>coount<S2SV_blank>%d\\\\n\" , read_u8 ( data , 5 ) ) ; vnc_client_error ( vs ) ; break ; } vs -> as . freq = read_u32 ( data , 6 ) ; break ; default : printf ( \"Invalid<S2SV_blank>audio<S2SV_blank>message<S2SV_blank>%d\\\\n\" , read_u8 ( data , 4 ) ) ; vnc_client_error ( vs ) ; break ; } break ; default : printf ( \"Msg:<S2SV_blank>%d\\\\n\" , read_u16 ( data , 0 ) ) ; vnc_client_error ( vs ) ; break ; } break ; default : printf ( \"Msg:<S2SV_blank>%d\\\\n\" , data [ 0 ] ) ; vnc_client_error ( vs ) ; break ; } vnc_read_when ( vs , protocol_client_msg , 1 ) ; return 0 ; }", "target": "<S2SV_ModStart> == 1 ) { <S2SV_ModStart> return 8 ; } <S2SV_ModStart> 4 ) ; if ( dlen > ( 1 << 20 ) ) { error_report ( \"vnc:<S2SV_blank>client_cut_text<S2SV_blank>msg<S2SV_blank>payload<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>bytes\" \"<S2SV_blank>which<S2SV_blank>exceeds<S2SV_blank>our<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB.\" , dlen ) ; vnc_client_error ( vs ) ; break ; } <S2SV_ModStart> > 0 ) { <S2SV_ModStart> + dlen ; }"}
{"source": "CWE-345 bool TensorSliceReader : : CopySliceData ( const string & name , const TensorSlice & slice , T * data ) const { std : : vector < std : : pair < TensorSlice , string >> details ; const TensorSliceSet * tss ; { mutex_lock l ( mu_ ) ; tss = FindTensorSlice ( name , slice , & details ) ; if ( ! tss && ! all_shards_loaded_ ) { VLOG ( 1 ) << \"Did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>slice<S2SV_blank>in<S2SV_blank>preferred<S2SV_blank>shard,<S2SV_blank>loading<S2SV_blank>all<S2SV_blank>shards.\" << name << \":<S2SV_blank>\" << slice . DebugString ( ) ; LoadAllShards ( ) ; tss = FindTensorSlice ( name , slice , & details ) ; } if ( ! tss ) { return false ; } } string value ; for ( const auto & x : details ) { const TensorSlice & slice_s = x . first ; const string & fname = x . second ; int idx = gtl : : FindWithDefault ( fname_to_index_ , fname , - 1 ) ; CHECK_GE ( idx , 0 ) << \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>the<S2SV_blank>index<S2SV_blank>for<S2SV_blank>filename<S2SV_blank>\" << fname ; const string key = EncodeTensorNameSlice ( name , slice_s ) ; if ( ! sss_ [ idx ] -> Get ( key , & value ) ) { VLOG ( 1 ) << \"Failed<S2SV_blank>to<S2SV_blank>seek<S2SV_blank>to<S2SV_blank>the<S2SV_blank>record<S2SV_blank>for<S2SV_blank>tensor<S2SV_blank>\" << name << \",<S2SV_blank>slice<S2SV_blank>\" << slice_s . DebugString ( ) << \":<S2SV_blank>computed<S2SV_blank>key<S2SV_blank>=<S2SV_blank>\" << key ; return false ; } SavedTensorSlices sts ; if ( ! ParseProtoUnlimited ( & sts , value ) ) { VLOG ( 1 ) << \"Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>the<S2SV_blank>record<S2SV_blank>for<S2SV_blank>tensor<S2SV_blank>\" << name << \",<S2SV_blank>slice<S2SV_blank>\" << slice_s . DebugString ( ) << \":<S2SV_blank>computed<S2SV_blank>key<S2SV_blank>=<S2SV_blank>\" << key ; return false ; } <S2SV_StartBug> CopyDataFromTensorSliceToTensorSlice ( <S2SV_EndBug> tss -> shape ( ) , slice_s , slice , checkpoint : : TensorProtoData < T > ( sts . data ( ) . data ( ) ) , data ) ; } return true ; }", "target": "<S2SV_ModStart> false ; } TensorShape shp_s ; Status s = slice_s . SliceTensorShape ( tss -> shape ( ) , & shp_s ) ; if ( ! s . ok ( ) ) { VLOG ( 1 ) << \"Failed<S2SV_blank>to<S2SV_blank>slice<S2SV_blank>tensor<S2SV_blank>\" << name << \",<S2SV_blank>slice<S2SV_blank>\" << slice_s . DebugString ( ) << \":<S2SV_blank>\" << s ; return false ; } if ( checkpoint : : TensorProtoDataSize < T > ( sts . data ( ) . data ( ) ) != shp_s . num_elements ( ) ) { VLOG ( 1 ) << \"Tensor<S2SV_blank>\" << name << \",<S2SV_blank>slice<S2SV_blank>\" << slice_s . DebugString ( ) << \"<S2SV_blank>had<S2SV_blank>an<S2SV_blank>unexpected<S2SV_blank>amount<S2SV_blank>of<S2SV_blank>data:<S2SV_blank>expected<S2SV_blank>=<S2SV_blank>\" << shp_s . num_elements ( ) << \",<S2SV_blank>got<S2SV_blank>=<S2SV_blank>\" << checkpoint : : TensorProtoDataSize < T > ( sts . data ( ) . data ( ) ) ; return false ; }"}
{"source": "CWE-416 static GF_Err BM_ParseGlobalQuantizer ( GF_BifsDecoder * codec , GF_BitStream * bs , GF_List * com_list ) { GF_Node * node ; GF_Command * com ; GF_CommandField * inf ; node = gf_bifs_dec_node ( codec , bs , NDT_SFWorldNode ) ; if ( ! node ) return GF_NON_COMPLIANT_BITSTREAM ; if ( codec -> scenegraph -> global_qp ) { gf_node_unregister ( codec -> scenegraph -> global_qp , NULL ) ; } codec -> ActiveQP = NULL ; codec -> scenegraph -> global_qp = NULL ; if ( gf_node_get_tag ( node ) != TAG_MPEG4_QuantizationParameter ) { <S2SV_StartBug> gf_node_unregister ( node , NULL ) ; <S2SV_EndBug> return GF_NON_COMPLIANT_BITSTREAM ; } codec -> ActiveQP = ( M_QuantizationParameter * ) node ; codec -> ActiveQP -> isLocal = 0 ; codec -> scenegraph -> global_qp = node ; <S2SV_StartBug> node -> sgprivate -> num_instances = 2 ; <S2SV_EndBug> com = gf_sg_command_new ( codec -> current_graph , GF_SG_GLOBAL_QUANTIZER ) ; inf = gf_sg_command_field_new ( com ) ; inf -> new_node = node ; inf -> field_ptr = & inf -> new_node ; inf -> fieldType = GF_SG_VRML_SFNODE ; gf_list_add ( com_list , com ) ; return GF_OK ; }", "target": "<S2SV_ModStart> TAG_MPEG4_QuantizationParameter ) { if ( ! node -> sgprivate -> num_instances ) { node -> sgprivate -> num_instances = 1 ; gf_node_unregister ( node , NULL ) ; } <S2SV_ModEnd> return GF_NON_COMPLIANT_BITSTREAM ; <S2SV_ModStart> = node ; gf_node_unregister ( node , NULL ) ; gf_node_unregister ( node , NULL ) <S2SV_ModEnd> ; com ="}
{"source": "CWE-824 bool IsConstantFoldable ( const Node * n , const std : : unordered_map < string , std : : vector < PartialTensorShape >> * shape_map , const std : : function < bool ( const Node * ) > & consider , int64_t max_constant_size_in_bytes , std : : unordered_map < const Node * , std : : vector < Tensor >> * shape_replacement_map ) { if ( n -> IsConstant ( ) ) { <S2SV_StartBug> return true ; <S2SV_EndBug> } if ( MaybeReplaceShapeOp ( n , shape_map , shape_replacement_map ) ) { return true ; } if ( n -> op_def ( ) . is_stateful ( ) ) { return false ; } if ( consider && ! consider ( n ) ) { return false ; } if ( shape_map != nullptr ) { auto shape_it = shape_map -> find ( n -> name ( ) ) ; if ( shape_it != shape_map -> end ( ) ) { for ( int64_t i = 0 ; i < shape_it -> second . size ( ) ; ++ i ) { const auto & out_shape = shape_it -> second [ i ] ; if ( out_shape . IsFullyDefined ( ) && out_shape . num_elements ( ) * DataTypeSize ( n -> output_type ( i ) ) > max_constant_size_in_bytes ) { return false ; } } } } if ( n -> IsControlFlow ( ) || n -> IsSend ( ) || n -> IsRecv ( ) ) { return false ; } if ( n -> IsGetSessionHandle ( ) || n -> IsGetSessionTensor ( ) || n -> IsDeleteSessionTensor ( ) ) { return false ; } if ( n -> IsSource ( ) ) { return false ; } if ( n -> IsSink ( ) ) { return false ; } if ( n -> IsFakeParam ( ) ) { return false ; } if ( ! KernelDefAvailable ( DeviceType ( DEVICE_CPU ) , n -> def ( ) ) ) { return false ; } if ( n -> attrs ( ) . Find ( kScopedAllocatorAttrName ) != nullptr ) { VLOG ( 2 ) << \"Skip<S2SV_blank>node<S2SV_blank>[\" << n -> DebugString ( ) << \"]<S2SV_blank>for<S2SV_blank>constant<S2SV_blank>folding<S2SV_blank>due<S2SV_blank>to<S2SV_blank>scoped<S2SV_blank>allocator\" ; return false ; } return true ; }", "target": "<S2SV_ModStart> ) { return n -> output_type ( 0 ) != DT_RESOURCE <S2SV_ModEnd> ; } if"}
{"source": "CWE-125 <S2SV_StartBug> TfLiteStatus Gather ( const TfLiteGatherParams & params , const TfLiteTensor * input , <S2SV_EndBug> <S2SV_StartBug> const TfLiteTensor * positions , TfLiteTensor * output ) { <S2SV_EndBug> tflite : : GatherParams op_params ; op_params . axis = params . axis ; op_params . batch_dims = params . batch_dims ; optimized_ops : : Gather ( op_params , GetTensorShape ( input ) , GetTensorData < InputT > ( input ) , GetTensorShape ( positions ) , GetTensorData < PositionsT > ( positions ) , GetTensorShape ( output ) , GetTensorData < InputT > ( output ) ) ; return kTfLiteOk ; }", "target": "<S2SV_ModStart> TfLiteStatus Gather ( TfLiteContext * context , <S2SV_ModStart> output ) { const PositionsT * indexes = GetTensorData < PositionsT > ( positions ) ; bool indices_has_only_positive_elements = true ; const size_t num_indices = positions -> bytes / sizeof ( PositionsT ) ; for ( size_t i = 0 ; i < num_indices ; i ++ ) { if ( indexes [ i ] < 0 ) { indices_has_only_positive_elements = false ; break ; } } TF_LITE_ENSURE ( context , indices_has_only_positive_elements ) ;"}
{"source": "CWE-276 crun_command_exec ( struct crun_global_arguments * global_args , int argc , char * * argv , libcrun_error_t * err ) { int first_arg = 0 , ret = 0 ; libcrun_context_t crun_context = { 0 , } ; cleanup_process_schema runtime_spec_schema_config_schema_process * process = NULL ; struct libcrun_container_exec_options_s exec_opts ; memset ( & exec_opts , 0 , sizeof ( exec_opts ) ) ; exec_opts . struct_size = sizeof ( exec_opts ) ; crun_context . preserve_fds = 0 ; crun_context . listen_fds = 0 ; argp_parse ( & run_argp , argc , argv , ARGP_IN_ORDER , & first_arg , & exec_options ) ; crun_assert_n_args ( argc - first_arg , exec_options . process ? 1 : 2 , - 1 ) ; ret = init_libcrun_context ( & crun_context , argv [ first_arg ] , global_args , err ) ; if ( UNLIKELY ( ret < 0 ) ) return ret ; crun_context . detach = exec_options . detach ; crun_context . console_socket = exec_options . console_socket ; crun_context . pid_file = exec_options . pid_file ; crun_context . preserve_fds = exec_options . preserve_fds ; if ( getenv ( \"LISTEN_FDS\" ) ) { crun_context . listen_fds = strtoll ( getenv ( \"LISTEN_FDS\" ) , NULL , 10 ) ; crun_context . preserve_fds += crun_context . listen_fds ; } if ( exec_options . process ) exec_opts . path = exec_options . process ; else { process = xmalloc0 ( sizeof ( * process ) ) ; int i ; process -> args_len = argc ; process -> args = xmalloc0 ( ( argc + 1 ) * sizeof ( * process -> args ) ) ; for ( i = 0 ; i < argc - first_arg ; i ++ ) process -> args [ i ] = xstrdup ( argv [ first_arg + i + 1 ] ) ; process -> args [ i ] = NULL ; if ( exec_options . cwd ) process -> cwd = exec_options . cwd ; process -> terminal = exec_options . tty ; process -> env = exec_options . env ; process -> env_len = exec_options . env_size ; process -> user = make_oci_process_user ( exec_options . user ) ; if ( exec_options . process_label != NULL ) process -> selinux_label = exec_options . process_label ; if ( exec_options . apparmor != NULL ) process -> apparmor_profile = exec_options . apparmor ; if ( exec_options . cap_size > 0 ) { runtime_spec_schema_config_schema_process_capabilities * capabilities = xmalloc ( sizeof ( runtime_spec_schema_config_schema_process_capabilities ) ) ; capabilities -> effective = exec_options . cap ; capabilities -> effective_len = exec_options . cap_size ; <S2SV_StartBug> capabilities -> inheritable = dup_array ( exec_options . cap , exec_options . cap_size ) ; <S2SV_EndBug> <S2SV_StartBug> capabilities -> inheritable_len = exec_options . cap_size ; <S2SV_EndBug> capabilities -> bounding = dup_array ( exec_options . cap , exec_options . cap_size ) ; capabilities -> bounding_len = exec_options . cap_size ; capabilities -> ambient = dup_array ( exec_options . cap , exec_options . cap_size ) ; capabilities -> ambient_len = exec_options . cap_size ; capabilities -> permitted = dup_array ( exec_options . cap , exec_options . cap_size ) ; capabilities -> permitted_len = exec_options . cap_size ; process -> capabilities = capabilities ; } if ( exec_options . no_new_privs ) process -> no_new_privileges = 1 ; exec_opts . process = process ; } exec_opts . cgroup = exec_options . cgroup ; return libcrun_container_exec_with_options ( & crun_context , argv [ first_arg ] , & exec_opts , err ) ; }", "target": "<S2SV_ModStart> -> inheritable = NULL <S2SV_ModEnd> ; capabilities -> <S2SV_ModStart> -> inheritable_len = 0 <S2SV_ModEnd> ; capabilities ->"}
{"source": "CWE-703 void Compute ( OpKernelContext * context ) override { const Tensor & input = context -> input ( 0 ) ; const TensorShape & input_shape = input . shape ( ) ; const int32 input_dims = input_shape . dims ( ) ; const Tensor & segment_id = context -> input ( 1 ) ; const TensorShape & segment_id_shape = segment_id . shape ( ) ; const int32 segment_dims = segment_id_shape . dims ( ) ; <S2SV_StartBug> const Tensor & num_segments_tensor = context -> input ( 2 ) ; <S2SV_EndBug> auto num_segments = num_segments_tensor . scalar < NUM_SEGMENTS_TYPE > ( ) ( ) ; OP_REQUIRES ( context , segment_dims != 0 , errors : : InvalidArgument ( \"Segment_id<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>rank<S2SV_blank>0\" ) ) ; OP_REQUIRES ( context , segment_dims <= input_dims , errors : : OutOfRange ( \"Invalid<S2SV_blank>segment_id<S2SV_blank>rank<S2SV_blank>\" , segment_dims , \"<S2SV_blank>for<S2SV_blank>input<S2SV_blank>with<S2SV_blank>\" , input_dims , \"<S2SV_blank>dimension(s)\" ) ) ; for ( auto i = 0 ; i < segment_dims ; i ++ ) { OP_REQUIRES ( context , segment_id_shape . dim_size ( i ) == input_shape . dim_size ( i ) , errors : : InvalidArgument ( \"Segment<S2SV_blank>dimension<S2SV_blank>is<S2SV_blank>\" , segment_id_shape . dim_size ( i ) , \"<S2SV_blank>while<S2SV_blank>input<S2SV_blank>dimension<S2SV_blank>is<S2SV_blank>\" , input_dims , \"<S2SV_blank>in<S2SV_blank>rank<S2SV_blank>\" , i ) ) ; } Tensor * output_tensor = nullptr ; TensorShape output_shape = GetOutputShape ( input_shape , segment_id_shape , num_segments ) ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"output\" , output_shape , & output_tensor ) ) ; auto output_flat = output_tensor -> flat < tstring > ( ) ; auto flat_segment_id = segment_id . flat < INDICES_TYPE > ( ) ; auto flat_input = input . flat < tstring > ( ) ; for ( int i = 0 ; i < flat_segment_id . size ( ) ; i ++ ) { OP_REQUIRES ( context , ( ( flat_segment_id ( i ) < num_segments ) && ( flat_segment_id ( i ) >= 0 ) ) , errors : : InvalidArgument ( \"segment_ids<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>exceed<S2SV_blank>num_segments<S2SV_blank>or\" \"<S2SV_blank>to<S2SV_blank>have<S2SV_blank>negative<S2SV_blank>values.\" ) ) ; } int64 big_stride ; int64 small_stride ; std : : tie ( big_stride , small_stride ) = GetStrides < INDICES_TYPE > ( input_shape , segment_id_shape ) ; auto relative_offset_set = GetFlattenedRelativeOffsets < INDICES_TYPE > ( small_stride , big_stride ) ; for ( auto start_offset = 0 ; start_offset < big_stride ; start_offset ++ ) { for ( auto i = 0 ; i < relative_offset_set . size ( ) ; i ++ ) { auto output_index = start_offset + flat_segment_id ( i ) * big_stride ; auto offset = start_offset + relative_offset_set [ i ] ; if ( output_flat ( output_index ) . length ( ) != 0 ) output_flat ( output_index ) . append ( separator_ . c_str ( ) ) ; output_flat ( output_index ) . append ( flat_input ( offset ) ) ; } } }", "target": "<S2SV_ModStart> input ( 2 ) ; OP_REQUIRES ( context , num_segments_tensor . NumElements ( ) != 0 , errors : : InvalidArgument ( \"Number<S2SV_blank>of<S2SV_blank>segments<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>empty.\" )"}
{"source": "CWE-125 static int string_scan_range ( RList * list , RBinFile * bf , int min , const ut64 from , const ut64 to , int type , int raw , RBinSection * section ) { RBin * bin = bf -> rbin ; ut8 tmp [ R_STRING_SCAN_BUFFER_SIZE ] ; ut64 str_start , needle = from ; int count = 0 , i , rc , runes ; int str_type = R_STRING_TYPE_DETECT ; r_return_val_if_fail ( bf , - 1 ) ; if ( type == - 1 ) { type = R_STRING_TYPE_DETECT ; } if ( from == to ) { return 0 ; } if ( from > to ) { eprintf ( \"Invalid<S2SV_blank>range<S2SV_blank>to<S2SV_blank>find<S2SV_blank>strings<S2SV_blank>0x%\" PFMT64x \"<S2SV_blank>..<S2SV_blank>0x%\" PFMT64x \"\\\\n\" , from , to ) ; return - 1 ; } st64 len = ( st64 ) ( to - from ) ; if ( len < 1 || len > ST32_MAX ) { eprintf ( \"String<S2SV_blank>scan<S2SV_blank>range<S2SV_blank>is<S2SV_blank>invalid<S2SV_blank>(%\" PFMT64d \"<S2SV_blank>bytes)\\\\n\" , len ) ; return - 1 ; } ut8 * buf = calloc ( len , 1 ) ; if ( ! buf || ! min ) { free ( buf ) ; return - 1 ; } st64 vdelta = 0 , pdelta = 0 ; RBinSection * s = NULL ; bool ascii_only = false ; PJ * pj = NULL ; if ( bf -> strmode == R_MODE_JSON && ! list ) { pj = pj_new ( ) ; if ( pj ) { pj_a ( pj ) ; } } r_buf_read_at ( bf -> buf , from , buf , len ) ; char * charset = r_sys_getenv ( \"RABIN2_CHARSET\" ) ; if ( ! R_STR_ISEMPTY ( charset ) ) { RCharset * ch = r_charset_new ( ) ; if ( r_charset_use ( ch , charset ) ) { int outlen = len * 4 ; ut8 * out = calloc ( len , 4 ) ; if ( out ) { int res = r_charset_encode_str ( ch , out , outlen , buf , len ) ; int i ; for ( i = 0 ; i < res ; i ++ ) { if ( out [ i ] == '?' ) { out [ i ] = 0 ; } } len = res ; free ( buf ) ; buf = out ; } else { eprintf ( \"Cannot<S2SV_blank>allocate\\\\n\" ) ; } } else { eprintf ( \"Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>RABIN2_CHARSET.\\\\n\" ) ; } r_charset_free ( ch ) ; } free ( charset ) ; RConsIsBreaked is_breaked = ( bin && bin -> consb . is_breaked ) ? bin -> consb . is_breaked : NULL ; <S2SV_StartBug> while ( needle < to ) { <S2SV_EndBug> if ( is_breaked && is_breaked ( ) ) { break ; } <S2SV_StartBug> if ( needle + 4 < to ) { <S2SV_EndBug> <S2SV_StartBug> ut32 n1 = r_read_le32 ( buf + needle - from ) ; <S2SV_EndBug> if ( ! n1 ) { needle += 4 ; continue ; } } <S2SV_StartBug> rc = r_utf8_decode ( buf + needle - from , to - needle , NULL ) ; <S2SV_EndBug> if ( ! rc ) { needle ++ ; continue ; } bool addr_aligned = ! ( needle % 4 ) ; if ( type == R_STRING_TYPE_DETECT ) { <S2SV_StartBug> char * w = ( char * ) buf + needle + rc - from ; <S2SV_EndBug> if ( ( ( to - needle ) > 8 + rc ) ) { bool is_wide32le = ( needle + rc + 2 < to ) && ( ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ) ; if ( is_wide32le ) { if ( ! w [ 5 ] && ! w [ 6 ] && w [ 7 ] && w [ 8 ] ) { is_wide32le = false ; } } if ( ! addr_aligned ) { is_wide32le = false ; } if ( is_wide32le && addr_aligned ) { str_type = R_STRING_TYPE_WIDE32 ; } else { bool is_wide = needle + rc + 4 < to && ! w [ 0 ] && w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; str_type = is_wide ? R_STRING_TYPE_WIDE : R_STRING_TYPE_ASCII ; } } else { if ( rc > 1 ) { str_type = R_STRING_TYPE_UTF8 ; } else { str_type = R_STRING_TYPE_ASCII ; } } } else if ( type == R_STRING_TYPE_UTF8 ) { str_type = R_STRING_TYPE_ASCII ; } else { str_type = type ; } runes = 0 ; str_start = needle ; for ( i = 0 ; i < sizeof ( tmp ) - 4 && needle < to ; i += rc ) { RRune r = { 0 } ; if ( str_type == R_STRING_TYPE_WIDE32 ) { rc = r_utf32le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc ) { rc = 4 ; } } else if ( str_type == R_STRING_TYPE_WIDE ) { rc = r_utf16le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc == 1 ) { rc = 2 ; } } else { <S2SV_StartBug> rc = r_utf8_decode ( buf + needle - from , to - needle , & r ) ; <S2SV_EndBug> if ( rc > 1 ) { str_type = R_STRING_TYPE_UTF8 ; } } if ( ! rc || ( ascii_only && r > 0x7f ) ) { needle ++ ; break ; } needle += rc ; if ( r_isprint ( r ) && r != '\\\\\\\\' ) { if ( str_type == R_STRING_TYPE_WIDE32 ) { if ( r == 0xff ) { r = 0 ; } } rc = r_utf8_encode ( tmp + i , r ) ; runes ++ ; } else if ( r && r < 0x100 && strchr ( \"\\\\b\\\\v\\\\f\\\\n\\\\r\\\\t\\\\a\\\\033\\\\\\\\\" , ( char ) r ) ) { if ( ( i + 32 ) < sizeof ( tmp ) && r < 93 ) { tmp [ i + 0 ] = '\\\\\\\\' ; tmp [ i + 1 ] = \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>abtnvfr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>e<S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" \"<S2SV_blank><S2SV_blank>\\\\\\\\\" [ r ] ; } else { break ; } rc = 2 ; runes ++ ; } else { break ; } } tmp [ i ++ ] = '\\\\0' ; if ( runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to ) { needle -= 2 ; } if ( runes >= min ) { int j , num_blocks , * block_list ; int * freq_list = NULL , expected_ascii , actual_ascii , num_chars ; if ( str_type == R_STRING_TYPE_ASCII ) { for ( j = 0 ; j < i ; j ++ ) { char ch = tmp [ j ] ; if ( ch != '\\\\n' && ch != '\\\\r' && ch != '\\\\t' ) { if ( ! IS_PRINTABLE ( tmp [ j ] ) ) { continue ; } } } } switch ( str_type ) { case R_STRING_TYPE_UTF8 : case R_STRING_TYPE_WIDE : case R_STRING_TYPE_WIDE32 : num_blocks = 0 ; block_list = r_utf_block_list ( ( const ut8 * ) tmp , i - 1 , str_type == R_STRING_TYPE_WIDE ? & freq_list : NULL ) ; if ( block_list ) { for ( j = 0 ; block_list [ j ] != - 1 ; j ++ ) { num_blocks ++ ; } } if ( freq_list ) { num_chars = 0 ; actual_ascii = 0 ; for ( j = 0 ; freq_list [ j ] != - 1 ; j ++ ) { num_chars += freq_list [ j ] ; if ( ! block_list [ j ] ) { actual_ascii = freq_list [ j ] ; } } free ( freq_list ) ; expected_ascii = num_blocks ? num_chars / num_blocks : 0 ; if ( actual_ascii > expected_ascii ) { ascii_only = true ; needle = str_start ; free ( block_list ) ; continue ; } } free ( block_list ) ; if ( num_blocks > R_STRING_MAX_UNI_BLOCKS ) { needle ++ ; continue ; } } RBinString * bs = R_NEW0 ( RBinString ) ; if ( ! bs ) { break ; } bs -> type = str_type ; bs -> length = runes ; bs -> size = needle - str_start ; bs -> ordinal = count ++ ; switch ( str_type ) { case R_STRING_TYPE_WIDE : if ( str_start - from > 1 ) { const ut8 * p = buf + str_start - 2 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 2 ; } } break ; case R_STRING_TYPE_WIDE32 : if ( str_start - from > 3 ) { const ut8 * p = buf + str_start - 4 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 4 ; } } break ; } if ( ! s ) { if ( section ) { s = section ; } else if ( bf -> o ) { s = r_bin_get_section_at ( bf -> o , str_start , false ) ; } if ( s ) { vdelta = s -> vaddr ; pdelta = s -> paddr ; } } ut64 baddr = bf -> loadaddr && bf -> o ? bf -> o -> baddr : bf -> loadaddr ; bs -> paddr = str_start + baddr ; bs -> vaddr = str_start - pdelta + vdelta + baddr ; bs -> string = r_str_ndup ( ( const char * ) tmp , i ) ; if ( list ) { r_list_append ( list , bs ) ; if ( bf -> o ) { ht_up_insert ( bf -> o -> strings_db , bs -> vaddr , bs ) ; } } else { print_string ( bf , bs , raw , pj ) ; r_bin_string_free ( bs ) ; } if ( from == 0 && to == bf -> size ) { s = NULL ; } } ascii_only = false ; } free ( buf ) ; if ( pj ) { pj_end ( pj ) ; if ( bin ) { RIO * io = bin -> iob . io ; if ( io ) { io -> cb_printf ( \"%s\" , pj_string ( pj ) ) ; } } pj_free ( pj ) ; } return count ; }", "target": "<S2SV_ModStart> needle < to && needle < UT64_MAX - 4 <S2SV_ModStart> if ( needle < to - 4 <S2SV_ModEnd> ) { ut32 <S2SV_ModStart> ( buf + ( <S2SV_ModStart> needle - from ) <S2SV_ModStart> ( buf + ( <S2SV_ModStart> needle - from ) <S2SV_ModStart> ) buf + ( <S2SV_ModStart> rc - from ) <S2SV_ModStart> ( buf + ( <S2SV_ModStart> needle - from )"}
{"source": "CWE-703 void Compute ( OpKernelContext * context ) override { std : : unordered_map < int64_t , int64_t > old_row_to_new_row_map ; std : : vector < bool > row_id_present ; const Tensor * row_remapping_t ; <S2SV_StartBug> OP_REQUIRES_OK ( context , context -> input ( \"row_remapping\" , & row_remapping_t ) ) ; <S2SV_EndBug> const auto row_remapping = row_remapping_t -> vec < int64_t > ( ) ; OP_REQUIRES ( context , row_remapping . size ( ) == num_rows_ , errors : : InvalidArgument ( strings : : StrCat ( \"Size<S2SV_blank>of<S2SV_blank>row_remapping<S2SV_blank>is<S2SV_blank>\" , row_remapping . size ( ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>being<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>num_rows=\" , num_rows_ ) ) ) ; OP_REQUIRES_OK ( context , RemapVectorToMap ( row_remapping , & row_id_present , & old_row_to_new_row_map ) ) ; int64_t min_old_row = - 1 ; int64_t max_old_row = - 1 ; for ( int i = 0 ; i < row_remapping . size ( ) ; ++ i ) { if ( min_old_row < 0 || ( row_remapping ( i ) >= 0 && row_remapping ( i ) < min_old_row ) ) { min_old_row = row_remapping ( i ) ; } if ( max_old_row < 0 || ( row_remapping ( i ) >= 0 && row_remapping ( i ) > max_old_row ) ) { max_old_row = row_remapping ( i ) ; } } std : : unordered_map < int64_t , int64_t > old_col_to_new_col_map ; std : : vector < bool > col_id_present ; const Tensor * col_remapping_t ; OP_REQUIRES_OK ( context , context -> input ( \"col_remapping\" , & col_remapping_t ) ) ; const auto col_remapping = col_remapping_t -> vec < int64_t > ( ) ; const bool remap_cols = col_remapping . size ( ) > 0 ; if ( remap_cols ) { OP_REQUIRES ( context , col_remapping . size ( ) == num_cols_ , errors : : InvalidArgument ( strings : : StrCat ( \"Provided<S2SV_blank>col_remapping,<S2SV_blank>but<S2SV_blank>its<S2SV_blank>size<S2SV_blank>is<S2SV_blank>\" , col_remapping . size ( ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>being<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>num_cols=\" , num_cols_ ) ) ) ; OP_REQUIRES_OK ( context , RemapVectorToMap ( col_remapping , & col_id_present , & old_col_to_new_col_map ) ) ; } else { col_id_present . clear ( ) ; col_id_present . resize ( num_cols_ , true ) ; } const Tensor * ckpt_path_t ; OP_REQUIRES_OK ( context , context -> input ( \"ckpt_path\" , & ckpt_path_t ) ) ; OP_REQUIRES ( context , ckpt_path_t -> NumElements ( ) == 1 , errors : : InvalidArgument ( \"The<S2SV_blank>`ckpt_path`<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>exactly<S2SV_blank>one<S2SV_blank>\" \"element,<S2SV_blank>got<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>shape<S2SV_blank>\" , ckpt_path_t -> shape ( ) . DebugString ( ) ) ) ; const string & ckpt_path = ckpt_path_t -> scalar < tstring > ( ) ( ) ; const Tensor * old_tensor_name_t ; OP_REQUIRES_OK ( context , context -> input ( \"old_tensor_name\" , & old_tensor_name_t ) ) ; const string & old_tensor_name = old_tensor_name_t -> scalar < tstring > ( ) ( ) ; LOG ( INFO ) << \"Processing<S2SV_blank>checkpoint<S2SV_blank>:<S2SV_blank>\" << ckpt_path ; BundleReader reader ( context -> env ( ) , ckpt_path ) ; OP_REQUIRES_OK ( context , reader . status ( ) ) ; DataType tensor_type ; TensorShape tensor_shape ; OP_REQUIRES_OK ( context , reader . LookupDtypeAndShape ( old_tensor_name , & tensor_type , & tensor_shape ) ) ; OP_REQUIRES ( context , tensor_type == DT_FLOAT , errors : : InvalidArgument ( strings : : StrCat ( \"Tensor<S2SV_blank>\" , old_tensor_name , \"<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( tensor_type ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>expected<S2SV_blank>type<S2SV_blank>\" , DataTypeString ( DT_FLOAT ) ) ) ) ; OP_REQUIRES ( context , tensor_shape . dims ( ) == 2 , errors : : InvalidArgument ( strings : : StrCat ( \"Tensor<S2SV_blank>\" , old_tensor_name , \"<S2SV_blank>has<S2SV_blank>shape<S2SV_blank>\" , tensor_shape . DebugString ( ) , \"<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>rank<S2SV_blank>\" , tensor_shape . dims ( ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>expected<S2SV_blank>shape<S2SV_blank>of<S2SV_blank>rank<S2SV_blank>2.\" ) ) ) ; if ( ! remap_cols ) { OP_REQUIRES ( context , num_cols_ == tensor_shape . dim_size ( 1 ) , errors : : InvalidArgument ( strings : : StrCat ( \"Tensor<S2SV_blank>\" , old_tensor_name , \"<S2SV_blank>has<S2SV_blank>shape<S2SV_blank>\" , tensor_shape . DebugString ( ) , \",<S2SV_blank>where<S2SV_blank>the<S2SV_blank>size<S2SV_blank>of<S2SV_blank>its<S2SV_blank>2nd<S2SV_blank>dimension<S2SV_blank>is<S2SV_blank>\" , tensor_shape . dim_size ( 1 ) , \"<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>being<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>num_cols=\" , num_cols_ ) ) ) ; } std : : vector < TensorSlice > tensor_slices ; TensorSlice slice ( tensor_shape . dims ( ) ) ; if ( min_old_row >= 0 && max_old_row >= 0 ) { int64_t row_start = min_old_row ; while ( row_start <= max_old_row ) { const int64_t slice_length = max_rows_in_memory_ <= 0 ? max_old_row - row_start + 1 : std : : min ( max_rows_in_memory_ , max_old_row - row_start + 1 ) ; slice . set_start ( 0 , row_start ) ; slice . set_length ( 0 , slice_length ) ; tensor_slices . push_back ( slice ) ; row_start += slice_length ; } } Tensor * output_matrix_t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( \"output_matrix\" , TensorShape ( { num_rows_ , num_cols_ } ) , & output_matrix_t ) ) ; auto output_matrix = output_matrix_t -> matrix < float > ( ) ; int64_t row_index = min_old_row ; int64_t rows_copied = 0 ; Tensor loaded_tensor_t ; for ( const TensorSlice & tensor_slice : tensor_slices ) { LOG ( INFO ) << \"Loading<S2SV_blank>slice<S2SV_blank>\" << tensor_slice . DebugString ( ) ; TensorShape slice_shape ; OP_REQUIRES_OK ( context , tensor_slice . SliceTensorShape ( tensor_shape , & slice_shape ) ) ; if ( loaded_tensor_t . shape ( ) != slice_shape ) { loaded_tensor_t = Tensor ( DT_FLOAT , slice_shape ) ; } OP_REQUIRES_OK ( context , reader . LookupSlice ( old_tensor_name , tensor_slice , & loaded_tensor_t ) ) ; for ( int row = 0 ; row < loaded_tensor_t . dim_size ( 0 ) ; ++ row , ++ row_index ) { if ( row_index % 500000 == min_old_row ) { LOG ( INFO ) << \"Processing<S2SV_blank>old<S2SV_blank>row<S2SV_blank>\" << row_index ; } const int64_t * new_row_ptr = gtl : : FindOrNull ( old_row_to_new_row_map , row_index ) ; if ( new_row_ptr == nullptr ) { continue ; } ++ rows_copied ; const int64_t new_row = * new_row_ptr ; const auto & loaded_tensor = loaded_tensor_t . matrix < float > ( ) ; for ( int old_col = 0 ; old_col < loaded_tensor_t . dim_size ( 1 ) ; ++ old_col ) { int64_t new_col = old_col ; if ( remap_cols ) { const int64_t * new_col_ptr = gtl : : FindOrNull ( old_col_to_new_col_map , old_col ) ; if ( new_col_ptr == nullptr ) { continue ; } new_col = * new_col_ptr ; } OP_REQUIRES ( context , new_row < num_rows_ && new_col < num_cols_ && new_row >= 0 && new_col >= 0 , errors : : Internal ( strings : : StrCat ( \"new_row=\" , new_row , \"<S2SV_blank>and<S2SV_blank>new_col=\" , new_col , \"<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>less<S2SV_blank>than<S2SV_blank>num_rows_=\" , num_rows_ , \"<S2SV_blank>and<S2SV_blank>num_cols_=\" , num_cols_ , \"<S2SV_blank>and<S2SV_blank>non-negative.<S2SV_blank>This<S2SV_blank>should<S2SV_blank>never<S2SV_blank>have<S2SV_blank>happened<S2SV_blank>\" \"if<S2SV_blank>the<S2SV_blank>code<S2SV_blank>were<S2SV_blank>correct.<S2SV_blank>Please<S2SV_blank>file<S2SV_blank>a<S2SV_blank>bug.\" ) ) ) ; output_matrix ( new_row , new_col ) = loaded_tensor ( row , old_col ) ; } } } LOG ( INFO ) << \"Copied<S2SV_blank>\" << rows_copied << \"<S2SV_blank>rows<S2SV_blank>from<S2SV_blank>old<S2SV_blank>matrix<S2SV_blank>(with<S2SV_blank>\" << tensor_shape . dim_size ( 0 ) << \"<S2SV_blank>rows)<S2SV_blank>to<S2SV_blank>new<S2SV_blank>matrix<S2SV_blank>(with<S2SV_blank>\" << num_rows_ << \"<S2SV_blank>rows).\" ; const Tensor * initializing_values_t ; OP_REQUIRES_OK ( context , context -> input ( \"initializing_values\" , & initializing_values_t ) ) ; const auto initializing_values = initializing_values_t -> flat < float > ( ) ; int64_t initializing_values_index = 0 ; for ( int i = 0 ; i < num_rows_ ; ++ i ) { for ( int j = 0 ; j < num_cols_ ; ++ j ) { if ( row_id_present [ i ] && col_id_present [ j ] ) continue ; OP_REQUIRES ( context , initializing_values_index < initializing_values . size ( ) , errors : : InvalidArgument ( \"initializing_values<S2SV_blank>contained<S2SV_blank>\" , initializing_values . size ( ) , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>more<S2SV_blank>missing<S2SV_blank>values<S2SV_blank>remain.\" ) ) ; output_matrix ( i , j ) = initializing_values ( initializing_values_index ) ; ++ initializing_values_index ; } } OP_REQUIRES ( context , initializing_values_index == initializing_values . size ( ) , errors : : InvalidArgument ( \"initializing_values<S2SV_blank>contained<S2SV_blank>\" , initializing_values . size ( ) , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>only<S2SV_blank>\" , initializing_values_index , \"<S2SV_blank>elements<S2SV_blank>were<S2SV_blank>used<S2SV_blank>to<S2SV_blank>fill<S2SV_blank>in<S2SV_blank>missing<S2SV_blank>values.\" ) ) ; }", "target": "<S2SV_ModStart> , & row_remapping_t ) ) ; OP_REQUIRES ( context , row_remapping_t -> dims ( ) == 1 , errors : : InvalidArgument ( \"The<S2SV_blank>`row_remapping`<S2SV_blank>tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1-D,<S2SV_blank>got<S2SV_blank>\" \"a<S2SV_blank>tensor<S2SV_blank>of<S2SV_blank>shape<S2SV_blank>\" , row_remapping_t -> shape ( ) . DebugString ( )"}
{"source": "CWE-125 void Compute ( OpKernelContext * ctx ) override { const Tensor * indices_t , * values_t , * shape_t , * reduction_axes_t ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"input_indices\" , & indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"input_values\" , & values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"input_shape\" , & shape_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"reduction_axes\" , & reduction_axes_t ) ) ; OP_REQUIRES_OK ( ctx , ValidateInputs ( shape_t , reduction_axes_t ) ) ; const auto shape_vec = shape_t -> vec < int64 > ( ) ; SparseTensor sp ; OP_REQUIRES_OK ( ctx , SparseTensor : : Create ( tensor : : DeepCopy ( * indices_t ) , tensor : : DeepCopy ( * values_t ) , TensorShape ( shape_vec ) , & sp ) ) ; ReduceDetails reduction = SparseTensorReduceHelper ( sp , reduction_axes_t -> flat < int32 > ( ) , keep_dims_ ) ; Tensor * out_values ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , reduction . reduced_shape , & out_values ) ) ; auto out_flat = out_values -> flat < T > ( ) ; out_flat . setZero ( ) ; Tensor tmp_reduced_val ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > : : value , TensorShape ( { } ) , & tmp_reduced_val ) ) ; auto reduced_val = tmp_reduced_val . scalar < T > ( ) ; gtl : : InlinedVector < int64 , 8 > output_strides ( reduction . group_by_dims . size ( ) ) ; if ( ! output_strides . empty ( ) ) { output_strides . back ( ) = 1 ; for ( int d = output_strides . size ( ) - 2 ; d >= 0 ; -- d ) { output_strides [ d ] = output_strides [ d + 1 ] * shape_vec ( reduction . group_by_dims [ d + 1 ] ) ; } } auto CoordinatesToFlatIndex = [ ] ( ArraySlice < int64 > coords , ArraySlice < int64 > strides ) -> int64 { if ( strides . empty ( ) ) { return 0 ; } CHECK_EQ ( coords . size ( ) , strides . size ( ) ) ; int64_t idx = 0 ; for ( int i = 0 ; i < coords . size ( ) ; ++ i ) { idx += coords [ i ] * strides [ i ] ; } return idx ; } ; sp . Reorder < T > ( reduction . reorder_dims ) ; for ( const auto & g : sp . group ( reduction . group_by_dims ) ) { Op : : template Run < T > ( ctx , reduced_val , g . template values < T > ( ) ) ; <S2SV_StartBug> const int64_t idx = CoordinatesToFlatIndex ( g . group ( ) , output_strides ) ; <S2SV_EndBug> out_flat ( idx ) = reduced_val ( ) ; VLOG ( 2 ) << \"coords:<S2SV_blank>\" << absl : : StrJoin ( g . group ( ) , \",\" ) << \";<S2SV_blank>idx:<S2SV_blank>\" << idx << \";<S2SV_blank>group<S2SV_blank>\" << Op : : Name ( ) << \":<S2SV_blank>\" << reduced_val ( ) ; } }", "target": "<S2SV_ModStart> ) ) ; OP_REQUIRES ( ctx , output_strides . empty ( ) || ( g . group ( ) . size ( ) == output_strides . size ( ) ) , errors : : Internal ( \"Expected<S2SV_blank>group<S2SV_blank>size<S2SV_blank>and<S2SV_blank>output_strides<S2SV_blank>size<S2SV_blank>to<S2SV_blank>match\" , \",<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , g . group ( ) . size ( ) , \"<S2SV_blank>and<S2SV_blank>\" , output_strides . size ( ) ) ) ; <S2SV_ModStart> ) , output_strides ) ; OP_REQUIRES ( ctx , idx >= 0 && idx < out_flat . size ( ) , errors : : Internal ( \"Obtained<S2SV_blank>a<S2SV_blank>write<S2SV_blank>index<S2SV_blank>of<S2SV_blank>\" , idx , \"<S2SV_blank>which<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>of<S2SV_blank>[0,<S2SV_blank>\" , out_flat . size ( ) , \")\" )"}
{"source": "CWE-476 void Compute ( OpKernelContext * context ) override { typedef Eigen : : Map < const Eigen : : Matrix < T , Eigen : : Dynamic , Eigen : : Dynamic >> ConstEigenMatrixMap ; typedef Eigen : : Map < Eigen : : Matrix < double , Eigen : : Dynamic , Eigen : : Dynamic >> EigenDoubleMatrixMap ; const Tensor & orig_input_tensor_shape = context -> input ( 0 ) ; OP_REQUIRES ( context , orig_input_tensor_shape . dims ( ) == 1 && orig_input_tensor_shape . NumElements ( ) == 4 , errors : : InvalidArgument ( \"original<S2SV_blank>input<S2SV_blank>tensor<S2SV_blank>shape<S2SV_blank>must<S2SV_blank>be\" \"1-dimensional<S2SV_blank>and<S2SV_blank>4<S2SV_blank>elements\" ) ) ; const Tensor & out_backprop = context -> input ( 1 ) ; const Tensor & row_seq_tensor = context -> input ( 2 ) ; const Tensor & col_seq_tensor = context -> input ( 3 ) ; const int64_t out_batch = out_backprop . dim_size ( 0 ) ; const int64_t out_rows = out_backprop . dim_size ( 1 ) ; const int64_t out_cols = out_backprop . dim_size ( 2 ) ; const int64_t out_depth = out_backprop . dim_size ( 3 ) ; OP_REQUIRES ( context , row_seq_tensor . NumElements ( ) > out_rows , errors : : InvalidArgument ( \"Given<S2SV_blank>out_backprop<S2SV_blank>shape<S2SV_blank>\" , out_backprop . shape ( ) . DebugString ( ) , \",<S2SV_blank>row_seq_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>\" , out_rows + 1 , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , row_seq_tensor . NumElements ( ) ) ) ; OP_REQUIRES ( context , col_seq_tensor . NumElements ( ) > out_cols , errors : : InvalidArgument ( \"Given<S2SV_blank>out_backprop<S2SV_blank>shape<S2SV_blank>\" , out_backprop . shape ( ) . DebugString ( ) , \",<S2SV_blank>col_seq_tensor<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>\" , out_cols + 1 , \"<S2SV_blank>elements,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" , col_seq_tensor . NumElements ( ) ) ) ; auto row_seq_tensor_flat = row_seq_tensor . flat < int64 > ( ) ; auto col_seq_tensor_flat = col_seq_tensor . flat < int64 > ( ) ; auto orig_input_tensor_shape_flat = orig_input_tensor_shape . flat < int64 > ( ) ; const int64_t in_batch = orig_input_tensor_shape_flat ( 0 ) ; const int64_t in_rows = orig_input_tensor_shape_flat ( 1 ) ; const int64_t in_cols = orig_input_tensor_shape_flat ( 2 ) ; <S2SV_StartBug> const int64_t in_depth = orig_input_tensor_shape_flat ( 3 ) ; <S2SV_EndBug> constexpr int tensor_in_and_out_dims = 4 ; TensorShape in_shape ; for ( auto i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { in_shape . AddDim ( orig_input_tensor_shape_flat ( i ) ) ; } Tensor in_backprop_tensor_temp ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_temp ( { 0 } , DataTypeToEnum < double > : : v ( ) , in_shape , & in_backprop_tensor_temp ) ) ; in_backprop_tensor_temp . flat < double > ( ) . setZero ( ) ; EigenDoubleMatrixMap in_backprop_tensor_temp_mat ( in_backprop_tensor_temp . flat < double > ( ) . data ( ) , in_depth , in_cols * in_rows * in_batch ) ; ConstEigenMatrixMap out_backprop_mat ( out_backprop . flat < T > ( ) . data ( ) , out_depth , out_cols * out_rows * out_batch ) ; const int64_t in_max_row_index = in_rows - 1 ; const int64_t in_max_col_index = in_cols - 1 ; for ( int64_t b = 0 ; b < out_batch ; ++ b ) { for ( int64_t r = 0 ; r < out_rows ; ++ r ) { const int64_t in_row_start = row_seq_tensor_flat ( r ) ; int64_t in_row_end = overlapping_ ? row_seq_tensor_flat ( r + 1 ) : row_seq_tensor_flat ( r + 1 ) - 1 ; in_row_end = std : : min ( in_row_end , in_max_row_index ) ; for ( int64_t c = 0 ; c < out_cols ; ++ c ) { const int64_t in_col_start = col_seq_tensor_flat ( c ) ; int64_t in_col_end = overlapping_ ? col_seq_tensor_flat ( c + 1 ) : col_seq_tensor_flat ( c + 1 ) - 1 ; in_col_end = std : : min ( in_col_end , in_max_col_index ) ; const int64_t num_elements_in_pooling_cell = ( in_row_end - in_row_start + 1 ) * ( in_col_end - in_col_start + 1 ) ; const int64_t out_index = ( b * out_rows + r ) * out_cols + c ; for ( int64_t in_r = in_row_start ; in_r <= in_row_end ; ++ in_r ) { for ( int64_t in_c = in_col_start ; in_c <= in_col_end ; ++ in_c ) { const int64_t in_index = ( b * in_rows + in_r ) * in_cols + in_c ; for ( int64_t d = 0 ; d < out_depth ; ++ d ) { const double out_backprop_element = static_cast < double > ( out_backprop_mat . coeffRef ( d , out_index ) ) ; double & in_backprop_ref = in_backprop_tensor_temp_mat . coeffRef ( d , in_index ) ; in_backprop_ref += out_backprop_element / num_elements_in_pooling_cell ; } } } } } } Tensor * in_backprop_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 0 , in_shape , & in_backprop_tensor ) ) ; auto in_backprop_tensor_flat = in_backprop_tensor -> flat < T > ( ) ; auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp . flat < double > ( ) ; for ( int64_t i = 0 ; i < in_backprop_tensor_flat . size ( ) ; ++ i ) { in_backprop_tensor_flat ( i ) = static_cast < T > ( in_backprop_tensor_temp_flat ( i ) ) ; } }", "target": "<S2SV_ModStart> orig_input_tensor_shape_flat ( 3 ) ; OP_REQUIRES ( context , in_batch != 0 , errors : : InvalidArgument ( \"Batch<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" ) ) ; OP_REQUIRES ( context , in_rows != 0 , errors : : InvalidArgument ( \"Rows<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" ) ) ; OP_REQUIRES ( context , in_cols != 0 , errors : : InvalidArgument ( \"Columns<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" ) ) ; OP_REQUIRES ( context , in_depth != 0 , errors : : InvalidArgument ( \"Depth<S2SV_blank>dimension<S2SV_blank>of<S2SV_blank>input<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0\" )"}
{"source": "CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"enter\" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c\" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"IM\" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , \"MI\" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , \"MATLAB\" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , \"MultidimensionalMatricesAreNotSupported\" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.StructureClass<S2SV_blank>%d\" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"MATLAB_HDR.CellType:<S2SV_blank>%.20g\" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , \"quantum:format\" , \"floating-point\" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , \"IncompatibleSizeOfDouble\" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , \"UnsupportedCellTypeInTheMatrix\" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file.\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u\" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"return\" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; return ( image ) ; }", "target": "<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;"}
{"source": "CWE-369 TfLiteTensor * GetVariableInput ( TfLiteContext * context , const TfLiteNode * node , int index ) { TfLiteTensor * tensor = GetMutableInput ( context , node , index ) ; <S2SV_StartBug> return tensor -> is_variable ? tensor : nullptr ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> index ) ; if ( tensor == nullptr ) return nullptr ;"}
{"source": "CWE-200 static int check_passwd ( unsigned char * passwd , size_t length ) { struct digest * d = NULL ; unsigned char * passwd1_sum ; unsigned char * passwd2_sum ; int ret = 0 ; int hash_len ; if ( IS_ENABLED ( CONFIG_PASSWD_CRYPTO_PBKDF2 ) ) { hash_len = PBKDF2_LENGTH ; } else { d = digest_alloc ( PASSWD_SUM ) ; if ( ! d ) { pr_err ( \"No<S2SV_blank>such<S2SV_blank>digest:<S2SV_blank>%s\\\\n\" , PASSWD_SUM ? PASSWD_SUM : \"NULL\" ) ; return - ENOENT ; } hash_len = digest_length ( d ) ; } passwd1_sum = calloc ( hash_len * 2 , sizeof ( unsigned char ) ) ; if ( ! passwd1_sum ) return - ENOMEM ; passwd2_sum = passwd1_sum + hash_len ; if ( is_passwd_env_enable ( ) ) ret = read_env_passwd ( passwd2_sum , hash_len ) ; else if ( is_passwd_default_enable ( ) ) ret = read_default_passwd ( passwd2_sum , hash_len ) ; else ret = - EINVAL ; if ( ret < 0 ) goto err ; if ( IS_ENABLED ( CONFIG_PASSWD_CRYPTO_PBKDF2 ) ) { char * key = passwd2_sum + PBKDF2_SALT_LEN ; char * salt = passwd2_sum ; int keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN ; ret = pkcs5_pbkdf2_hmac_sha1 ( passwd , length , salt , PBKDF2_SALT_LEN , PBKDF2_COUNT , keylen , passwd1_sum ) ; if ( ret ) goto err ; <S2SV_StartBug> if ( strncmp ( passwd1_sum , key , keylen ) == 0 ) <S2SV_EndBug> ret = 1 ; } else { ret = digest_digest ( d , passwd , length , passwd1_sum ) ; if ( ret ) goto err ; <S2SV_StartBug> if ( strncmp ( passwd1_sum , passwd2_sum , hash_len ) == 0 ) <S2SV_EndBug> ret = 1 ; } err : free ( passwd1_sum ) ; digest_free ( d ) ; return ret ; }", "target": "<S2SV_ModStart> ; if ( ! crypto_memneq <S2SV_ModEnd> ( passwd1_sum , <S2SV_ModStart> , keylen ) <S2SV_ModEnd> ) ret = <S2SV_ModStart> ; if ( ! crypto_memneq ( passwd1_sum , passwd2_sum , hash_len ) <S2SV_ModEnd> ) ret ="}
{"source": "CWE-369 void Compute ( OpKernelContext * context ) override { OpInputList params_nested_splits_in ; OP_REQUIRES_OK ( context , context -> input_list ( \"params_nested_splits\" , & params_nested_splits_in ) ) ; <S2SV_StartBug> const Tensor & params_dense_values_in = <S2SV_EndBug> context -> input ( params_nested_splits_in . size ( ) ) ; const Tensor & indices_in = context -> input ( params_nested_splits_in . size ( ) + 1 ) ; <S2SV_StartBug> DCHECK_GT ( params_nested_splits_in . size ( ) , 0 ) ; <S2SV_EndBug> SPLITS_TYPE num_params = params_nested_splits_in [ 0 ] . dim_size ( 0 ) - 1 ; OP_REQUIRES_OK ( context , ValidateIndices ( indices_in , num_params ) ) ; OP_REQUIRES ( context , params_dense_values_in . dims ( ) > 0 , errors : : InvalidArgument ( \"params.rank<S2SV_blank>must<S2SV_blank>be<S2SV_blank>nonzero\" ) ) ; SPLITS_TYPE num_params_dense_values = params_dense_values_in . dim_size ( 0 ) ; std : : vector < std : : pair < SPLITS_TYPE , SPLITS_TYPE >> value_slices ; SPLITS_TYPE num_values = 0 ; std : : vector < std : : vector < SPLITS_TYPE >> out_splits ; OP_REQUIRES_OK ( context , MakeSplits ( indices_in , params_nested_splits_in , num_params_dense_values , & out_splits , & value_slices , & num_values ) ) ; OP_REQUIRES_OK ( context , WriteSplits ( out_splits , context ) ) ; OP_REQUIRES_OK ( context , WriteValues ( params_dense_values_in , value_slices , out_splits . size ( ) , num_values , context ) ) ; }", "target": "<S2SV_ModStart> ) ) ; OP_REQUIRES ( context , params_nested_splits_in . size ( ) > 0 , errors : : InvalidArgument ( \"params_nested_splits<S2SV_blank>must<S2SV_blank>be<S2SV_blank>non<S2SV_blank>empty\" ) ) ; <S2SV_ModStart> 1 ) ; OP_REQUIRES ( context , params_nested_splits_in [ 0 ] . dims ( ) > 0 , errors : : InvalidArgument ( \"Split<S2SV_blank>tensors<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>scalars\" ) <S2SV_ModEnd> ) ; SPLITS_TYPE"}
{"source": "CWE-369 void ReshapeSparseTensor ( OpKernelContext * context , const Tensor & input_indices_in , const Tensor & input_shape_in , const Tensor & target_shape_in , int output_indices_idx , int output_shape_idx ) { OP_REQUIRES ( context , TensorShapeUtils : : IsMatrix ( input_indices_in . shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>indices<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>matrix<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_indices_in . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( input_shape_in . shape ( ) ) , errors : : InvalidArgument ( \"Input<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , input_shape_in . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , TensorShapeUtils : : IsVector ( target_shape_in . shape ( ) ) , errors : : InvalidArgument ( \"Target<S2SV_blank>shape<S2SV_blank>should<S2SV_blank>be<S2SV_blank>a<S2SV_blank>vector<S2SV_blank>but<S2SV_blank>received<S2SV_blank>shape<S2SV_blank>\" , target_shape_in . shape ( ) . DebugString ( ) ) ) ; const int64_t output_rank = target_shape_in . NumElements ( ) ; const TensorShape input_shape ( input_shape_in . vec < int64 > ( ) ) ; const int64_t dense_size = input_shape . num_elements ( ) ; const int64_t nnz = input_indices_in . shape ( ) . dim_size ( 0 ) ; TensorShape output_shape ; int64_t product = 1 ; int unknown_index = - 1 ; auto target_shape = target_shape_in . vec < int64 > ( ) ; for ( int d = 0 ; d < output_rank ; ++ d ) { const int64_t size = target_shape ( d ) ; if ( size == - 1 ) { OP_REQUIRES ( context , unknown_index == - 1 , errors : : InvalidArgument ( \"only<S2SV_blank>one<S2SV_blank>output<S2SV_blank>dimension<S2SV_blank>may<S2SV_blank>be<S2SV_blank>-1,<S2SV_blank>\" \"not<S2SV_blank>both<S2SV_blank>\" , unknown_index , \"<S2SV_blank>and<S2SV_blank>\" , d ) ) ; unknown_index = d ; output_shape . AddDim ( 1 ) ; } else { OP_REQUIRES ( context , size >= 0 , errors : : InvalidArgument ( \"size<S2SV_blank>\" , d , \"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>non-negative,<S2SV_blank>not<S2SV_blank>\" , size ) ) ; product *= size ; output_shape . AddDim ( size ) ; } } if ( unknown_index != - 1 ) { OP_REQUIRES ( context , product > 0 , errors : : InvalidArgument ( \"reshape<S2SV_blank>cannot<S2SV_blank>infer<S2SV_blank>the<S2SV_blank>missing<S2SV_blank>\" \"input<S2SV_blank>size<S2SV_blank>for<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>tensor<S2SV_blank>unless<S2SV_blank>all<S2SV_blank>\" \"specified<S2SV_blank>input<S2SV_blank>sizes<S2SV_blank>are<S2SV_blank>non-zero\" ) ) ; const int64_t missing = dense_size / product ; OP_REQUIRES ( context , product * missing == dense_size , errors : : InvalidArgument ( \"Input<S2SV_blank>to<S2SV_blank>reshape<S2SV_blank>is<S2SV_blank>a<S2SV_blank>SparseTensor<S2SV_blank>with<S2SV_blank>\" , dense_size , \"<S2SV_blank>dense<S2SV_blank>values,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>shape<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>\" , product , \".<S2SV_blank>input_shape=\" , input_shape . DebugString ( ) , \"<S2SV_blank>output_shape=\" , output_shape . DebugString ( ) ) ) ; output_shape . set_dim ( unknown_index , missing ) ; } OP_REQUIRES ( context , output_shape . num_elements ( ) == dense_size , errors : : InvalidArgument ( \"Input<S2SV_blank>to<S2SV_blank>reshape<S2SV_blank>is<S2SV_blank>a<S2SV_blank>tensor<S2SV_blank>with<S2SV_blank>\" , dense_size , \"<S2SV_blank>dense<S2SV_blank>values,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>shape<S2SV_blank>has<S2SV_blank>\" , output_shape . num_elements ( ) , \".<S2SV_blank>input_shape=\" , input_shape . DebugString ( ) , \"<S2SV_blank>output_shape=\" , output_shape . DebugString ( ) ) ) ; if ( input_shape == output_shape ) { context -> set_output ( output_indices_idx , input_indices_in ) ; context -> set_output ( output_shape_idx , input_shape_in ) ; return ; } Tensor * result_shape = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( output_shape_idx , TensorShape ( { output_rank } ) , & result_shape ) ) ; auto output_shape_vec = result_shape -> vec < int64 > ( ) ; for ( int j = 0 ; j < output_shape . dims ( ) ; ++ j ) { output_shape_vec ( j ) = output_shape . dim_size ( j ) ; } Tensor * result_indices = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( output_indices_idx , TensorShape ( { nnz , output_rank } ) , & result_indices ) ) ; if ( nnz > 0 ) { <S2SV_StartBug> OP_REQUIRES_OK ( context , functor : : ReshapeSparseTensorFunctor < Device > ( ) ( <S2SV_EndBug> context , input_shape , output_shape , input_indices_in . matrix < int64 > ( ) , result_indices -> matrix < int64 > ( ) ) ) ; } }", "target": "<S2SV_ModStart> 0 ) { OP_REQUIRES ( context , dense_size > 0 && product > 0 , errors : : InvalidArgument ( \"Input<S2SV_blank>tensor<S2SV_blank>has<S2SV_blank>\" , nnz , \"<S2SV_blank>non<S2SV_blank>zero<S2SV_blank>elements<S2SV_blank>but<S2SV_blank>input<S2SV_blank>shape<S2SV_blank>(\" , input_shape . DebugString ( ) , \")<S2SV_blank>or<S2SV_blank>output<S2SV_blank>shape<S2SV_blank>(\" , output_shape . DebugString ( ) , \")<S2SV_blank>is<S2SV_blank>empty\" ) ) ;"}
{"source": "CWE-416 net_bind ( short unsigned * port , int type , const char * log_service_name ) { struct addrinfo hints = { 0 } ; struct addrinfo * servinfo ; <S2SV_StartBug> struct addrinfo * ptr ; <S2SV_EndBug> const char * cfgaddr ; char addr [ INET6_ADDRSTRLEN ] ; char strport [ 8 ] ; int yes = 1 ; int no = 0 ; int fd ; int ret ; cfgaddr = cfg_getstr ( cfg_getsec ( cfg , \"general\" ) , \"bind_address\" ) ; hints . ai_socktype = ( type & ( SOCK_STREAM | SOCK_DGRAM ) ) ; hints . ai_family = ( cfg_getbool ( cfg_getsec ( cfg , \"general\" ) , \"ipv6\" ) ) ? AF_INET6 : AF_INET ; hints . ai_flags = cfgaddr ? 0 : AI_PASSIVE ; snprintf ( strport , sizeof ( strport ) , \"%hu\" , * port ) ; ret = getaddrinfo ( cfgaddr , strport , & hints , & servinfo ) ; if ( ret < 0 ) { DPRINTF ( E_LOG , L_MISC , \"Failure<S2SV_blank>creating<S2SV_blank>\\'%s\\'<S2SV_blank>service,<S2SV_blank>could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>\\'%s\\'<S2SV_blank>(port<S2SV_blank>%s):<S2SV_blank>%s\\\\n\" , log_service_name , cfgaddr ? cfgaddr : \"(ANY)\" , strport , gai_strerror ( ret ) ) ; return - 1 ; } for ( ptr = servinfo , fd = - 1 ; ptr != NULL ; ptr = ptr -> ai_next ) { if ( fd >= 0 ) close ( fd ) ; fd = socket ( ptr -> ai_family , type | SOCK_CLOEXEC , ptr -> ai_protocol ) ; if ( fd < 0 ) continue ; ret = setsockopt ( fd , SOL_SOCKET , SO_KEEPALIVE , & yes , sizeof ( yes ) ) ; if ( ret < 0 ) continue ; ret = setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , & yes , sizeof ( yes ) ) ; if ( ret < 0 ) continue ; if ( ptr -> ai_family == AF_INET6 ) { ret = setsockopt ( fd , IPPROTO_IPV6 , IPV6_V6ONLY , & no , sizeof ( no ) ) ; if ( ret < 0 ) continue ; } ret = bind ( fd , ptr -> ai_addr , ptr -> ai_addrlen ) ; if ( ret < 0 ) continue ; break ; } freeaddrinfo ( servinfo ) ; if ( ! ptr ) { DPRINTF ( E_LOG , L_MISC , \"Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>service<S2SV_blank>\\'%s\\'<S2SV_blank>with<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>port<S2SV_blank>%hu:<S2SV_blank>%s\\\\n\" , log_service_name , cfgaddr ? cfgaddr : \"(ANY)\" , * port , strerror ( errno ) ) ; goto error ; } <S2SV_StartBug> ret = getsockname ( fd , ptr -> ai_addr , & ptr -> ai_addrlen ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> DPRINTF ( E_LOG , L_MISC , \"Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>address<S2SV_blank>of<S2SV_blank>service<S2SV_blank>\\'%s\\':<S2SV_blank>%s\\\\n\" , log_service_name , strerror ( errno ) ) ; <S2SV_EndBug> goto error ; } <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> net_port_get ( port , ( union net_sockaddr * ) ptr -> ai_addr ) ; <S2SV_EndBug> <S2SV_StartBug> net_address_get ( addr , sizeof ( addr ) , ( union net_sockaddr * ) ptr -> ai_addr ) ; <S2SV_EndBug> DPRINTF ( E_DBG , L_MISC , \"Service<S2SV_blank>\\'%s\\'<S2SV_blank>bound<S2SV_blank>to<S2SV_blank>%s,<S2SV_blank>port<S2SV_blank>%hu,<S2SV_blank>socket<S2SV_blank>%d\\\\n\" , log_service_name , addr , * port , fd ) ; return fd ; error : close ( fd ) ; return - 1 ; }", "target": "<S2SV_ModStart> addrinfo * ptr ; union net_sockaddr naddr = { 0 } ; socklen_t naddr_len = sizeof ( naddr ) <S2SV_ModStart> ( fd , & naddr . sa , & naddr_len <S2SV_ModEnd> ) ; if <S2SV_ModStart> , L_MISC , \"Error<S2SV_blank>finding<S2SV_blank>address<S2SV_blank>of<S2SV_blank>service<S2SV_blank>\\'%s\\':<S2SV_blank>%s\\\\n\" <S2SV_ModEnd> , log_service_name , <S2SV_ModStart> error ; } else if ( naddr_len > sizeof ( naddr ) ) { DPRINTF ( E_LOG , L_MISC , \"Unexpected<S2SV_blank>address<S2SV_blank>length<S2SV_blank>of<S2SV_blank>service<S2SV_blank>\\'%s\\'\\\\n\" , log_service_name ) ; goto error ; } <S2SV_ModStart> ( port , & naddr <S2SV_ModEnd> ) ; net_address_get <S2SV_ModStart> addr ) , & naddr <S2SV_ModEnd> ) ; DPRINTF"}
{"source": "CWE-703 void Compute ( OpKernelContext * ctx ) override { const Tensor * x_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"x\" , & x_tensor ) ) ; const Tensor * cs_prev_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"cs_prev\" , & cs_prev_tensor ) ) ; const Tensor * h_prev_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"h_prev\" , & h_prev_tensor ) ) ; const Tensor * w_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"w\" , & w_tensor ) ) ; const Tensor * wci_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"wci\" , & wci_tensor ) ) ; const Tensor * wcf_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"wcf\" , & wcf_tensor ) ) ; const Tensor * wco_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"wco\" , & wco_tensor ) ) ; const Tensor * b_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> input ( \"b\" , & b_tensor ) ) ; const int64_t batch_size = x_tensor -> dim_size ( 0 ) ; const int64_t input_size = x_tensor -> dim_size ( 1 ) ; const int64_t cell_size = cs_prev_tensor -> dim_size ( 1 ) ; OP_REQUIRES ( ctx , cs_prev_tensor -> dim_size ( 0 ) == batch_size , errors : : InvalidArgument ( \"cs_prev.dims(0)<S2SV_blank>!=<S2SV_blank>batch_size:<S2SV_blank>\" , cs_prev_tensor -> dim_size ( 0 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , batch_size ) ) ; OP_REQUIRES ( ctx , cs_prev_tensor -> dim_size ( 1 ) == cell_size , errors : : InvalidArgument ( \"cs_prev.dims(1)<S2SV_blank>!=<S2SV_blank>cell_size:<S2SV_blank>\" , cs_prev_tensor -> dim_size ( 1 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , cell_size ) ) ; OP_REQUIRES ( ctx , h_prev_tensor -> dim_size ( 0 ) == batch_size , errors : : InvalidArgument ( \"h_prev.dims(0)<S2SV_blank>!=<S2SV_blank>batch_size:<S2SV_blank>\" , h_prev_tensor -> dim_size ( 0 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , batch_size ) ) ; OP_REQUIRES ( ctx , h_prev_tensor -> dim_size ( 1 ) == cell_size , errors : : InvalidArgument ( \"h_prev.dims(1)<S2SV_blank>!=<S2SV_blank>cell_size:<S2SV_blank>\" , h_prev_tensor -> dim_size ( 1 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , cell_size ) ) ; OP_REQUIRES ( ctx , w_tensor -> dim_size ( 0 ) == input_size + cell_size , errors : : InvalidArgument ( \"w.dim_size(0)<S2SV_blank>!=<S2SV_blank>input_size<S2SV_blank>+<S2SV_blank>cell_size:<S2SV_blank>\" , w_tensor -> dim_size ( 0 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , input_size + cell_size ) ) ; OP_REQUIRES ( ctx , w_tensor -> dim_size ( 1 ) == cell_size * 4 , errors : : InvalidArgument ( \"w.dim_size(1)<S2SV_blank>!=<S2SV_blank>cell_size<S2SV_blank>*<S2SV_blank>4:<S2SV_blank>\" , w_tensor -> dim_size ( 1 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , cell_size * 4 ) ) ; OP_REQUIRES ( ctx , b_tensor -> dim_size ( 0 ) == cell_size * 4 , errors : : InvalidArgument ( \"b.dim_size(0)<S2SV_blank>!=<S2SV_blank>cell_size<S2SV_blank>*<S2SV_blank>4:<S2SV_blank>\" , b_tensor -> dim_size ( 0 ) , \"<S2SV_blank>vs.<S2SV_blank>\" , cell_size * 4 ) ) ; Tensor * i_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> forward_input_or_allocate_output ( { \"h_prev\" } , \"i\" , TensorShape ( { batch_size , cell_size } ) , & i_tensor ) ) ; Tensor * cs_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( \"cs\" , TensorShape ( { batch_size , cell_size } ) , & cs_tensor ) ) ; Tensor * f_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( \"f\" , TensorShape ( { batch_size , cell_size } ) , & f_tensor ) ) ; Tensor * o_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> forward_input_or_allocate_output ( { \"cs_prev\" } , \"o\" , TensorShape ( { batch_size , cell_size } ) , & o_tensor ) ) ; Tensor * ci_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( \"ci\" , TensorShape ( { batch_size , cell_size } ) , & ci_tensor ) ) ; Tensor * co_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( \"co\" , TensorShape ( { batch_size , cell_size } ) , & co_tensor ) ) ; Tensor * h_tensor = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( \"h\" , TensorShape ( { batch_size , cell_size } ) , & h_tensor ) ) ; Tensor xh_tensor ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > : : v ( ) , TensorShape ( { batch_size , input_size + cell_size } ) , & xh_tensor ) ) ; Tensor gates_tensor ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > : : v ( ) , TensorShape ( { batch_size , cell_size * 4 } ) , & gates_tensor ) ) ; const Device & device = ctx -> eigen_device < Device > ( ) ; <S2SV_StartBug> functor : : LSTMBlockCellFprop < Device , T , USE_CUBLAS , gate_layout > ( <S2SV_EndBug> batch_size , input_size , cell_size ) ( ctx , device , forget_bias_ , cell_clip_ , use_peephole_ , x_tensor -> matrix < T > ( ) , cs_prev_tensor -> matrix < T > ( ) , h_prev_tensor -> matrix < T > ( ) , w_tensor -> matrix < T > ( ) , wci_tensor -> vec < T > ( ) , wcf_tensor -> vec < T > ( ) , wco_tensor -> vec < T > ( ) , b_tensor -> vec < T > ( ) , xh_tensor . matrix < T > ( ) , i_tensor -> matrix < T > ( ) , cs_tensor -> matrix < T > ( ) , f_tensor -> matrix < T > ( ) , o_tensor -> matrix < T > ( ) , ci_tensor -> matrix < T > ( ) , co_tensor -> matrix < T > ( ) , gates_tensor . matrix < T > ( ) , h_tensor -> matrix < T > ( ) ) ; }", "target": "<S2SV_ModStart> ( ) ; OP_REQUIRES ( ctx , x_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"x_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , x_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , cs_prev_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"cs_prev_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , cs_prev_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , h_prev_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"h_prev_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , h_prev_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , w_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"w_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , w_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , wci_tensor -> dims ( ) == 1 , errors : : InvalidArgument ( \"wci_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>1<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , wci_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , wcf_tensor -> dims ( ) == 1 , errors : : InvalidArgument ( \"wcf_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>1<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , wci_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , wco_tensor -> dims ( ) == 1 , errors : : InvalidArgument ( \"wco_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>1<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , wco_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , b_tensor -> dims ( ) == 1 , errors : : InvalidArgument ( \"b_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>1<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , b_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , xh_tensor . dims ( ) == 2 , errors : : InvalidArgument ( \"xh_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , xh_tensor . dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , i_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"i_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , i_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , cs_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"cs_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , cs_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , f_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"f_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , f_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , o_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"o_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , o_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , ci_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"ci_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , ci_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , co_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"co_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , co_tensor -> dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , gates_tensor . dims ( ) == 2 , errors : : InvalidArgument ( \"gates_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , gates_tensor . dims ( ) , \".\" ) ) ; OP_REQUIRES ( ctx , h_tensor -> dims ( ) == 2 , errors : : InvalidArgument ( \"h_tensor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>rank<S2SV_blank>2<S2SV_blank>but<S2SV_blank>is<S2SV_blank>rank<S2SV_blank>\" , h_tensor -> dims ( ) , \".\" ) ) ;"}
{"source": "CWE-787 static void handle_PORT ( ctrl_t * ctrl , char * str ) { int a , b , c , d , e , f ; char addr [ INET_ADDRSTRLEN ] ; struct sockaddr_in sin ; if ( ctrl -> data_sd > 0 ) { uev_io_stop ( & ctrl -> data_watcher ) ; close ( ctrl -> data_sd ) ; ctrl -> data_sd = - 1 ; } sscanf ( str , \"%d,%d,%d,%d,%d,%d\" , & a , & b , & c , & d , & e , & f ) ; <S2SV_StartBug> sprintf ( addr , \"%d.%d.%d.%d\" , a , b , c , d ) ; <S2SV_EndBug> if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) { ERR ( 0 , \"Invalid<S2SV_blank>address<S2SV_blank>\\'%s\\'<S2SV_blank>given<S2SV_blank>to<S2SV_blank>PORT<S2SV_blank>command\" , addr ) ; send_msg ( ctrl -> sd , \"500<S2SV_blank>Illegal<S2SV_blank>PORT<S2SV_blank>command.\\\\r\\\\n\" ) ; return ; } strlcpy ( ctrl -> data_address , addr , sizeof ( ctrl -> data_address ) ) ; ctrl -> data_port = e * 256 + f ; DBG ( \"Client<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>accepted<S2SV_blank>for<S2SV_blank>%s:%d\" , ctrl -> data_address , ctrl -> data_port ) ; send_msg ( ctrl -> sd , \"200<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>successful.\\\\r\\\\n\" ) ; }", "target": "<S2SV_ModStart> f ) ; snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> , \"%d.%d.%d.%d\" ,"}
{"source": "CWE-288 mrb_vm_exec ( mrb_state * mrb , const struct RProc * proc , const mrb_code * pc ) { const mrb_irep * irep = proc -> body . irep ; const mrb_pool_value * pool = irep -> pool ; const mrb_sym * syms = irep -> syms ; mrb_code insn ; int ai = mrb_gc_arena_save ( mrb ) ; struct mrb_jmpbuf * prev_jmp = mrb -> jmp ; struct mrb_jmpbuf c_jmp ; uint32_t a ; uint16_t b ; uint16_t c ; mrb_sym mid ; const struct mrb_irep_catch_handler * ch ; # ifdef DIRECT_THREADED static const void * const optable [ ] = { # define OPCODE ( x , _ ) && L_OP_ ## x , # include \"mruby/ops.h\" # undef OPCODE } ; # endif mrb_bool exc_catched = FALSE ; RETRY_TRY_BLOCK : MRB_TRY ( & c_jmp ) { if ( exc_catched ) { exc_catched = FALSE ; mrb_gc_arena_restore ( mrb , ai ) ; if ( mrb -> exc && mrb -> exc -> tt == MRB_TT_BREAK ) goto L_BREAK ; goto L_RAISE ; } mrb -> jmp = & c_jmp ; mrb_vm_ci_proc_set ( mrb -> c -> ci , proc ) ; # define regs ( mrb -> c -> ci -> stack ) INIT_DISPATCH { CASE ( OP_NOP , Z ) { NEXT ; } CASE ( OP_MOVE , BB ) { regs [ a ] = regs [ b ] ; NEXT ; } CASE ( OP_LOADL , BB ) { switch ( pool [ b ] . tt ) { case IREP_TT_INT32 : regs [ a ] = mrb_int_value ( mrb , ( mrb_int ) pool [ b ] . u . i32 ) ; break ; case IREP_TT_INT64 : # if defined ( MRB_INT64 ) regs [ a ] = mrb_int_value ( mrb , ( mrb_int ) pool [ b ] . u . i64 ) ; break ; # else # if defined ( MRB_64BIT ) if ( INT32_MIN <= pool [ b ] . u . i64 && pool [ b ] . u . i64 <= INT32_MAX ) { regs [ a ] = mrb_int_value ( mrb , ( mrb_int ) pool [ b ] . u . i64 ) ; break ; } # endif goto L_INT_OVERFLOW ; # endif case IREP_TT_BIGINT : goto L_INT_OVERFLOW ; # ifndef MRB_NO_FLOAT case IREP_TT_FLOAT : regs [ a ] = mrb_float_value ( mrb , pool [ b ] . u . f ) ; break ; # endif default : regs [ a ] = mrb_nil_value ( ) ; break ; } NEXT ; } CASE ( OP_LOADI , BB ) { SET_FIXNUM_VALUE ( regs [ a ] , b ) ; NEXT ; } CASE ( OP_LOADINEG , BB ) { SET_FIXNUM_VALUE ( regs [ a ] , - b ) ; NEXT ; } CASE ( OP_LOADI__1 , B ) goto L_LOADI ; CASE ( OP_LOADI_0 , B ) goto L_LOADI ; CASE ( OP_LOADI_1 , B ) goto L_LOADI ; CASE ( OP_LOADI_2 , B ) goto L_LOADI ; CASE ( OP_LOADI_3 , B ) goto L_LOADI ; CASE ( OP_LOADI_4 , B ) goto L_LOADI ; CASE ( OP_LOADI_5 , B ) goto L_LOADI ; CASE ( OP_LOADI_6 , B ) goto L_LOADI ; CASE ( OP_LOADI_7 , B ) { L_LOADI : SET_FIXNUM_VALUE ( regs [ a ] , ( mrb_int ) insn - ( mrb_int ) OP_LOADI_0 ) ; NEXT ; } CASE ( OP_LOADI16 , BS ) { SET_FIXNUM_VALUE ( regs [ a ] , ( mrb_int ) ( int16_t ) b ) ; NEXT ; } CASE ( OP_LOADI32 , BSS ) { SET_INT_VALUE ( mrb , regs [ a ] , ( int32_t ) ( ( ( uint32_t ) b << 16 ) + c ) ) ; NEXT ; } CASE ( OP_LOADSYM , BB ) { SET_SYM_VALUE ( regs [ a ] , syms [ b ] ) ; NEXT ; } CASE ( OP_LOADNIL , B ) { SET_NIL_VALUE ( regs [ a ] ) ; NEXT ; } CASE ( OP_LOADSELF , B ) { regs [ a ] = regs [ 0 ] ; NEXT ; } CASE ( OP_LOADT , B ) { SET_TRUE_VALUE ( regs [ a ] ) ; NEXT ; } CASE ( OP_LOADF , B ) { SET_FALSE_VALUE ( regs [ a ] ) ; NEXT ; } CASE ( OP_GETGV , BB ) { mrb_value val = mrb_gv_get ( mrb , syms [ b ] ) ; regs [ a ] = val ; NEXT ; } CASE ( OP_SETGV , BB ) { mrb_gv_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETSV , BB ) { mrb_value val = mrb_vm_special_get ( mrb , syms [ b ] ) ; regs [ a ] = val ; NEXT ; } CASE ( OP_SETSV , BB ) { mrb_vm_special_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETIV , BB ) { regs [ a ] = mrb_iv_get ( mrb , regs [ 0 ] , syms [ b ] ) ; NEXT ; } CASE ( OP_SETIV , BB ) { mrb_iv_set ( mrb , regs [ 0 ] , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETCV , BB ) { mrb_value val ; val = mrb_vm_cv_get ( mrb , syms [ b ] ) ; regs [ a ] = val ; NEXT ; } CASE ( OP_SETCV , BB ) { mrb_vm_cv_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETIDX , B ) { mrb_value va = regs [ a ] , vb = regs [ a + 1 ] ; switch ( mrb_type ( va ) ) { case MRB_TT_ARRAY : if ( ! mrb_integer_p ( vb ) ) goto getidx_fallback ; regs [ a ] = mrb_ary_entry ( va , mrb_integer ( vb ) ) ; break ; case MRB_TT_HASH : va = mrb_hash_get ( mrb , va , vb ) ; regs [ a ] = va ; break ; case MRB_TT_STRING : switch ( mrb_type ( vb ) ) { case MRB_TT_INTEGER : case MRB_TT_STRING : case MRB_TT_RANGE : va = mrb_str_aref ( mrb , va , vb , mrb_undef_value ( ) ) ; regs [ a ] = va ; break ; default : goto getidx_fallback ; } break ; default : getidx_fallback : mid = MRB_OPSYM ( aref ) ; goto L_SEND_SYM ; } NEXT ; } CASE ( OP_SETIDX , B ) { c = 2 ; mid = MRB_OPSYM ( aset ) ; SET_NIL_VALUE ( regs [ a + 3 ] ) ; goto L_SENDB_SYM ; } CASE ( OP_GETCONST , BB ) { mrb_value v = mrb_vm_const_get ( mrb , syms [ b ] ) ; regs [ a ] = v ; NEXT ; } CASE ( OP_SETCONST , BB ) { mrb_vm_const_set ( mrb , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETMCNST , BB ) { mrb_value v = mrb_const_get ( mrb , regs [ a ] , syms [ b ] ) ; regs [ a ] = v ; NEXT ; } CASE ( OP_SETMCNST , BB ) { mrb_const_set ( mrb , regs [ a + 1 ] , syms [ b ] , regs [ a ] ) ; NEXT ; } CASE ( OP_GETUPVAR , BBB ) { mrb_value * regs_a = regs + a ; struct REnv * e = uvenv ( mrb , c ) ; if ( e && b < MRB_ENV_LEN ( e ) ) { * regs_a = e -> stack [ b ] ; } else { * regs_a = mrb_nil_value ( ) ; } NEXT ; } CASE ( OP_SETUPVAR , BBB ) { struct REnv * e = uvenv ( mrb , c ) ; if ( e ) { mrb_value * regs_a = regs + a ; if ( b < MRB_ENV_LEN ( e ) ) { e -> stack [ b ] = * regs_a ; mrb_write_barrier ( mrb , ( struct RBasic * ) e ) ; } } NEXT ; } CASE ( OP_JMP , S ) { pc += ( int16_t ) a ; JUMP ; } CASE ( OP_JMPIF , BS ) { if ( mrb_test ( regs [ a ] ) ) { pc += ( int16_t ) b ; JUMP ; } NEXT ; } CASE ( OP_JMPNOT , BS ) { if ( ! mrb_test ( regs [ a ] ) ) { pc += ( int16_t ) b ; JUMP ; } NEXT ; } CASE ( OP_JMPNIL , BS ) { if ( mrb_nil_p ( regs [ a ] ) ) { pc += ( int16_t ) b ; JUMP ; } NEXT ; } CASE ( OP_JMPUW , S ) { a = ( uint32_t ) ( ( pc - irep -> iseq ) + ( int16_t ) a ) ; CHECKPOINT_RESTORE ( RBREAK_TAG_JUMP ) { struct RBreak * brk = ( struct RBreak * ) mrb -> exc ; mrb_value target = mrb_break_value_get ( brk ) ; mrb_assert ( mrb_integer_p ( target ) ) ; a = ( uint32_t ) mrb_integer ( target ) ; mrb_assert ( a >= 0 && a < irep -> ilen ) ; } CHECKPOINT_MAIN ( RBREAK_TAG_JUMP ) { ch = catch_handler_find ( mrb , mrb -> c -> ci , pc , MRB_CATCH_FILTER_ENSURE ) ; if ( ch ) { if ( a < mrb_irep_catch_handler_unpack ( ch -> begin ) || a >= mrb_irep_catch_handler_unpack ( ch -> end ) ) { THROW_TAGGED_BREAK ( mrb , RBREAK_TAG_JUMP , proc , mrb_fixnum_value ( a ) ) ; } } } CHECKPOINT_END ( RBREAK_TAG_JUMP ) ; mrb -> exc = NULL ; pc = irep -> iseq + a ; JUMP ; } CASE ( OP_EXCEPT , B ) { mrb_value exc ; if ( mrb -> exc == NULL ) { exc = mrb_nil_value ( ) ; } else { switch ( mrb -> exc -> tt ) { case MRB_TT_BREAK : case MRB_TT_EXCEPTION : exc = mrb_obj_value ( mrb -> exc ) ; break ; default : mrb_assert ( ! \"bad<S2SV_blank>mrb_type\" ) ; exc = mrb_nil_value ( ) ; break ; } mrb -> exc = NULL ; } regs [ a ] = exc ; NEXT ; } CASE ( OP_RESCUE , BB ) { mrb_value exc = regs [ a ] ; mrb_value e = regs [ b ] ; struct RClass * ec ; switch ( mrb_type ( e ) ) { case MRB_TT_CLASS : case MRB_TT_MODULE : break ; default : { mrb_value exc ; exc = mrb_exc_new_lit ( mrb , E_TYPE_ERROR , \"class<S2SV_blank>or<S2SV_blank>module<S2SV_blank>required<S2SV_blank>for<S2SV_blank>rescue<S2SV_blank>clause\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } } ec = mrb_class_ptr ( e ) ; regs [ b ] = mrb_bool_value ( mrb_obj_is_kind_of ( mrb , exc , ec ) ) ; NEXT ; } CASE ( OP_RAISEIF , B ) { mrb_value exc = regs [ a ] ; if ( mrb_break_p ( exc ) ) { mrb -> exc = mrb_obj_ptr ( exc ) ; goto L_BREAK ; } mrb_exc_set ( mrb , exc ) ; if ( mrb -> exc ) { goto L_RAISE ; } NEXT ; } CASE ( OP_SSEND , BBB ) { regs [ a ] = regs [ 0 ] ; insn = OP_SEND ; } goto L_SENDB ; CASE ( OP_SSENDB , BBB ) { regs [ a ] = regs [ 0 ] ; } goto L_SENDB ; CASE ( OP_SEND , BBB ) goto L_SENDB ; L_SEND_SYM : c = 1 ; SET_NIL_VALUE ( regs [ a + 2 ] ) ; goto L_SENDB_SYM ; CASE ( OP_SENDB , BBB ) L_SENDB : mid = syms [ b ] ; L_SENDB_SYM : { mrb_callinfo * ci = mrb -> c -> ci ; mrb_method_t m ; struct RClass * cls ; mrb_value recv , blk ; ARGUMENT_NORMALIZE ( a , & c , insn ) ; recv = regs [ a ] ; cls = mrb_class ( mrb , recv ) ; m = mrb_method_search_vm ( mrb , & cls , mid ) ; if ( MRB_METHOD_UNDEF_P ( m ) ) { m = prepare_missing ( mrb , recv , mid , & cls , a , & c , blk , 0 ) ; mid = MRB_SYM ( method_missing ) ; } ci = cipush ( mrb , a , 0 , cls , NULL , mid , c ) ; if ( MRB_METHOD_CFUNC_P ( m ) ) { if ( MRB_METHOD_PROC_P ( m ) ) { struct RProc * p = MRB_METHOD_PROC ( m ) ; mrb_vm_ci_proc_set ( ci , p ) ; recv = p -> body . func ( mrb , recv ) ; } else { if ( MRB_METHOD_NOARG_P ( m ) ) { check_method_noarg ( mrb , ci ) ; } recv = MRB_METHOD_FUNC ( m ) ( mrb , recv ) ; } mrb_gc_arena_shrink ( mrb , ai ) ; if ( mrb -> exc ) goto L_RAISE ; ci = mrb -> c -> ci ; if ( mrb_proc_p ( blk ) ) { struct RProc * p = mrb_proc_ptr ( blk ) ; if ( p && ! MRB_PROC_STRICT_P ( p ) && MRB_PROC_ENV ( p ) == mrb_vm_ci_env ( & ci [ - 1 ] ) ) { p -> flags |= MRB_PROC_ORPHAN ; } } if ( ! ci -> u . target_class ) { if ( ci -> cci == CINFO_RESUMED ) { mrb -> jmp = prev_jmp ; return recv ; } else { mrb_assert ( ! MRB_PROC_CFUNC_P ( ci [ - 1 ] . proc ) ) ; proc = ci [ - 1 ] . proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; } } ci -> stack [ 0 ] = recv ; ci = cipop ( mrb ) ; pc = ci -> pc ; } else { mrb_vm_ci_proc_set ( ci , ( proc = MRB_METHOD_PROC ( m ) ) ) ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , ( irep -> nregs < 4 ) ? 4 : irep -> nregs ) ; pc = irep -> iseq ; } } JUMP ; CASE ( OP_CALL , Z ) { mrb_callinfo * ci = mrb -> c -> ci ; mrb_value recv = ci -> stack [ 0 ] ; struct RProc * m = mrb_proc_ptr ( recv ) ; ci -> u . target_class = MRB_PROC_TARGET_CLASS ( m ) ; mrb_vm_ci_proc_set ( ci , m ) ; if ( MRB_PROC_ENV_P ( m ) ) { ci -> mid = MRB_PROC_ENV ( m ) -> mid ; } if ( MRB_PROC_CFUNC_P ( m ) ) { recv = MRB_PROC_CFUNC ( m ) ( mrb , recv ) ; mrb_gc_arena_shrink ( mrb , ai ) ; if ( mrb -> exc ) goto L_RAISE ; ci = cipop ( mrb ) ; pc = ci -> pc ; ci [ 1 ] . stack [ 0 ] = recv ; irep = mrb -> c -> ci -> proc -> body . irep ; } else { proc = m ; irep = m -> body . irep ; if ( ! irep ) { mrb -> c -> ci -> stack [ 0 ] = mrb_nil_value ( ) ; a = 0 ; c = OP_R_NORMAL ; goto L_OP_RETURN_BODY ; } mrb_int nargs = mrb_ci_bidx ( ci ) + 1 ; if ( nargs < irep -> nregs ) { mrb_stack_extend ( mrb , irep -> nregs ) ; stack_clear ( regs + nargs , irep -> nregs - nargs ) ; } if ( MRB_PROC_ENV_P ( m ) ) { regs [ 0 ] = MRB_PROC_ENV ( m ) -> stack [ 0 ] ; } pc = irep -> iseq ; } pool = irep -> pool ; syms = irep -> syms ; JUMP ; } CASE ( OP_SUPER , BB ) { mrb_method_t m ; struct RClass * cls ; mrb_callinfo * ci = mrb -> c -> ci ; mrb_value recv , blk ; const struct RProc * p = ci -> proc ; mrb_sym mid = ci -> mid ; struct RClass * target_class = MRB_PROC_TARGET_CLASS ( p ) ; if ( MRB_PROC_ENV_P ( p ) && p -> e . env -> mid && p -> e . env -> mid != mid ) { mid = p -> e . env -> mid ; } if ( mid == 0 || ! target_class ) { mrb_value exc = mrb_exc_new_lit ( mrb , E_NOMETHOD_ERROR , \"super<S2SV_blank>called<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>method\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } if ( target_class -> flags & MRB_FL_CLASS_IS_PREPENDED ) { target_class = mrb_vm_ci_target_class ( ci ) ; } else if ( target_class -> tt == MRB_TT_MODULE ) { target_class = mrb_vm_ci_target_class ( ci ) ; if ( ! target_class || target_class -> tt != MRB_TT_ICLASS ) { goto super_typeerror ; } } recv = regs [ 0 ] ; if ( ! mrb_obj_is_kind_of ( mrb , recv , target_class ) ) { super_typeerror : ; mrb_value exc = mrb_exc_new_lit ( mrb , E_TYPE_ERROR , \"self<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>type<S2SV_blank>to<S2SV_blank>call<S2SV_blank>super<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } ARGUMENT_NORMALIZE ( a , & b , OP_SUPER ) ; cls = target_class -> super ; m = mrb_method_search_vm ( mrb , & cls , mid ) ; if ( MRB_METHOD_UNDEF_P ( m ) ) { m = prepare_missing ( mrb , recv , mid , & cls , a , & b , blk , 1 ) ; mid = MRB_SYM ( method_missing ) ; } ci = cipush ( mrb , a , 0 , cls , NULL , mid , b ) ; ci -> stack [ 0 ] = recv ; if ( MRB_METHOD_CFUNC_P ( m ) ) { mrb_value v ; if ( MRB_METHOD_PROC_P ( m ) ) { mrb_vm_ci_proc_set ( ci , MRB_METHOD_PROC ( m ) ) ; } v = MRB_METHOD_CFUNC ( m ) ( mrb , recv ) ; mrb_gc_arena_restore ( mrb , ai ) ; if ( mrb -> exc ) goto L_RAISE ; ci = mrb -> c -> ci ; mrb_assert ( ! mrb_break_p ( v ) ) ; if ( ! mrb_vm_ci_target_class ( ci ) ) { if ( ci -> cci == CINFO_RESUMED ) { mrb -> jmp = prev_jmp ; return v ; } else { mrb_assert ( ! MRB_PROC_CFUNC_P ( ci [ - 1 ] . proc ) ) ; proc = ci [ - 1 ] . proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; } } mrb -> c -> ci -> stack [ 0 ] = v ; ci = cipop ( mrb ) ; pc = ci -> pc ; } else { mrb_vm_ci_proc_set ( ci , ( proc = MRB_METHOD_PROC ( m ) ) ) ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , ( irep -> nregs < 4 ) ? 4 : irep -> nregs ) ; pc = irep -> iseq ; } JUMP ; } CASE ( OP_ARGARY , BS ) { mrb_int m1 = ( b >> 11 ) & 0x3f ; mrb_int r = ( b >> 10 ) & 0x1 ; mrb_int m2 = ( b >> 5 ) & 0x1f ; mrb_int kd = ( b >> 4 ) & 0x1 ; mrb_int lv = ( b >> 0 ) & 0xf ; mrb_value * stack ; if ( mrb -> c -> ci -> mid == 0 || mrb_vm_ci_target_class ( mrb -> c -> ci ) == NULL ) { mrb_value exc ; L_NOSUPER : exc = mrb_exc_new_lit ( mrb , E_NOMETHOD_ERROR , \"super<S2SV_blank>called<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>method\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } if ( lv == 0 ) stack = regs + 1 ; else { struct REnv * e = uvenv ( mrb , lv - 1 ) ; if ( ! e ) goto L_NOSUPER ; if ( MRB_ENV_LEN ( e ) <= m1 + r + m2 + 1 ) goto L_NOSUPER ; stack = e -> stack + 1 ; } if ( r == 0 ) { regs [ a ] = mrb_ary_new_from_values ( mrb , m1 + m2 , stack ) ; } else { mrb_value * pp = NULL ; struct RArray * rest ; mrb_int len = 0 ; if ( mrb_array_p ( stack [ m1 ] ) ) { struct RArray * ary = mrb_ary_ptr ( stack [ m1 ] ) ; pp = ARY_PTR ( ary ) ; len = ARY_LEN ( ary ) ; } regs [ a ] = mrb_ary_new_capa ( mrb , m1 + len + m2 ) ; rest = mrb_ary_ptr ( regs [ a ] ) ; if ( m1 > 0 ) { stack_copy ( ARY_PTR ( rest ) , stack , m1 ) ; } if ( len > 0 ) { stack_copy ( ARY_PTR ( rest ) + m1 , pp , len ) ; } if ( m2 > 0 ) { stack_copy ( ARY_PTR ( rest ) + m1 + len , stack + m1 + 1 , m2 ) ; } ARY_SET_LEN ( rest , m1 + len + m2 ) ; } if ( kd ) { regs [ a + 1 ] = stack [ m1 + r + m2 ] ; regs [ a + 2 ] = stack [ m1 + r + m2 + 1 ] ; } else { regs [ a + 1 ] = stack [ m1 + r + m2 ] ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ENTER , W ) { mrb_int m1 = MRB_ASPEC_REQ ( a ) ; mrb_int o = MRB_ASPEC_OPT ( a ) ; mrb_int r = MRB_ASPEC_REST ( a ) ; mrb_int m2 = MRB_ASPEC_POST ( a ) ; mrb_int kd = ( MRB_ASPEC_KEY ( a ) > 0 || MRB_ASPEC_KDICT ( a ) ) ? 1 : 0 ; mrb_int const len = m1 + o + r + m2 ; mrb_callinfo * ci = mrb -> c -> ci ; mrb_int argc = ci -> n ; mrb_value * argv = regs + 1 ; mrb_value * const argv0 = argv ; mrb_int const kw_pos = len + kd ; mrb_int const blk_pos = kw_pos + 1 ; mrb_value blk = regs [ mrb_ci_bidx ( ci ) ] ; mrb_value kdict = mrb_nil_value ( ) ; if ( ci -> nk > 0 ) { mrb_int kidx = mrb_ci_kidx ( ci ) ; kdict = regs [ kidx ] ; if ( ! mrb_hash_p ( kdict ) || mrb_hash_size ( mrb , kdict ) == 0 ) { kdict = mrb_nil_value ( ) ; ci -> nk = 0 ; } } if ( ! kd && ! mrb_nil_p ( kdict ) ) { if ( argc < 14 ) { ci -> n ++ ; argc ++ ; } else if ( argc == 14 ) { regs [ 1 ] = mrb_ary_new_from_values ( mrb , argc + 1 , & regs [ 1 ] ) ; argc = ci -> n = 15 ; } else { mrb_ary_push ( mrb , regs [ 1 ] , regs [ 2 ] ) ; } ci -> nk = 0 ; } if ( kd && MRB_ASPEC_KEY ( a ) > 0 && mrb_hash_p ( kdict ) ) { kdict = mrb_hash_dup ( mrb , kdict ) ; } if ( argc == 15 ) { struct RArray * ary = mrb_ary_ptr ( regs [ 1 ] ) ; argv = ARY_PTR ( ary ) ; argc = ( int ) ARY_LEN ( ary ) ; mrb_gc_protect ( mrb , regs [ 1 ] ) ; } if ( ci -> proc && MRB_PROC_STRICT_P ( ci -> proc ) ) { if ( argc < m1 + m2 || ( r == 0 && argc > len ) ) { argnum_error ( mrb , m1 + m2 ) ; goto L_RAISE ; } } else if ( len > 1 && argc == 1 && mrb_array_p ( argv [ 0 ] ) ) { mrb_gc_protect ( mrb , argv [ 0 ] ) ; argc = ( int ) RARRAY_LEN ( argv [ 0 ] ) ; argv = RARRAY_PTR ( argv [ 0 ] ) ; } mrb_value rest = mrb_nil_value ( ) ; if ( argc < len ) { mrb_int mlen = m2 ; if ( argc < m1 + m2 ) { mlen = m1 < argc ? argc - m1 : 0 ; } if ( argv0 != argv && argv ) { value_move ( & regs [ 1 ] , argv , argc - mlen ) ; } if ( argc < m1 ) { stack_clear ( & regs [ argc + 1 ] , m1 - argc ) ; } if ( mlen ) { value_move ( & regs [ len - m2 + 1 ] , & argv [ argc - mlen ] , mlen ) ; } if ( mlen < m2 ) { stack_clear ( & regs [ len - m2 + mlen + 1 ] , m2 - mlen ) ; } if ( r ) { rest = mrb_ary_new_capa ( mrb , 0 ) ; regs [ m1 + o + 1 ] = rest ; } if ( o > 0 && argc > m1 + m2 ) pc += ( argc - m1 - m2 ) * 3 ; } else { mrb_int rnum = 0 ; if ( argv0 != argv ) { value_move ( & regs [ 1 ] , argv , m1 + o ) ; } if ( r ) { rnum = argc - m1 - o - m2 ; rest = mrb_ary_new_from_values ( mrb , rnum , argv + m1 + o ) ; regs [ m1 + o + 1 ] = rest ; } if ( m2 > 0 && argc - m2 > m1 ) { value_move ( & regs [ m1 + o + r + 1 ] , & argv [ m1 + o + rnum ] , m2 ) ; } pc += o * 3 ; } regs [ blk_pos ] = blk ; if ( kd ) { if ( mrb_nil_p ( kdict ) ) kdict = mrb_hash_new_capa ( mrb , 0 ) ; regs [ kw_pos ] = kdict ; } mrb -> c -> ci -> n = len ; if ( irep -> nlocals - blk_pos - 1 > 0 ) { stack_clear ( & regs [ blk_pos + 1 ] , irep -> nlocals - blk_pos - 1 ) ; } JUMP ; } CASE ( OP_KARG , BB ) { mrb_value k = mrb_symbol_value ( syms [ b ] ) ; mrb_int kidx = mrb_ci_kidx ( mrb -> c -> ci ) ; mrb_value kdict , v ; if ( kidx < 0 || ! mrb_hash_p ( kdict = regs [ kidx ] ) || ! mrb_hash_key_p ( mrb , kdict , k ) ) { mrb_value str = mrb_format ( mrb , \"missing<S2SV_blank>keyword:<S2SV_blank>%v\" , k ) ; mrb_exc_set ( mrb , mrb_exc_new_str ( mrb , E_ARGUMENT_ERROR , str ) ) ; goto L_RAISE ; } v = mrb_hash_get ( mrb , kdict , k ) ; regs [ a ] = v ; mrb_hash_delete_key ( mrb , kdict , k ) ; NEXT ; } CASE ( OP_KEY_P , BB ) { mrb_value k = mrb_symbol_value ( syms [ b ] ) ; mrb_int kidx = mrb_ci_kidx ( mrb -> c -> ci ) ; mrb_value kdict ; mrb_bool key_p = FALSE ; if ( kidx >= 0 && mrb_hash_p ( kdict = regs [ kidx ] ) ) { key_p = mrb_hash_key_p ( mrb , kdict , k ) ; } regs [ a ] = mrb_bool_value ( key_p ) ; NEXT ; } CASE ( OP_KEYEND , Z ) { mrb_int kidx = mrb_ci_kidx ( mrb -> c -> ci ) ; mrb_value kdict ; if ( kidx >= 0 && mrb_hash_p ( kdict = regs [ kidx ] ) && ! mrb_hash_empty_p ( mrb , kdict ) ) { mrb_value keys = mrb_hash_keys ( mrb , kdict ) ; mrb_value key1 = RARRAY_PTR ( keys ) [ 0 ] ; mrb_value str = mrb_format ( mrb , \"unknown<S2SV_blank>keyword:<S2SV_blank>%v\" , key1 ) ; mrb_exc_set ( mrb , mrb_exc_new_str ( mrb , E_ARGUMENT_ERROR , str ) ) ; goto L_RAISE ; } NEXT ; } CASE ( OP_BREAK , B ) { c = OP_R_BREAK ; goto L_RETURN ; } CASE ( OP_RETURN_BLK , B ) { c = OP_R_RETURN ; goto L_RETURN ; } CASE ( OP_RETURN , B ) c = OP_R_NORMAL ; L_RETURN : { mrb_callinfo * ci ; ci = mrb -> c -> ci ; if ( ci -> mid ) { mrb_value blk = regs [ mrb_ci_bidx ( ci ) ] ; if ( mrb_proc_p ( blk ) ) { struct RProc * p = mrb_proc_ptr ( blk ) ; if ( ! MRB_PROC_STRICT_P ( p ) && ci > mrb -> c -> cibase && MRB_PROC_ENV ( p ) == mrb_vm_ci_env ( & ci [ - 1 ] ) ) { p -> flags |= MRB_PROC_ORPHAN ; } } } if ( mrb -> exc ) { L_RAISE : ci = mrb -> c -> ci ; if ( ci == mrb -> c -> cibase ) { ch = catch_handler_find ( mrb , ci , pc , MRB_CATCH_FILTER_ALL ) ; if ( ch == NULL ) goto L_FTOP ; goto L_CATCH ; } while ( ( ch = catch_handler_find ( mrb , ci , pc , MRB_CATCH_FILTER_ALL ) ) == NULL ) { ci = cipop ( mrb ) ; if ( ci [ 1 ] . cci == CINFO_SKIP && prev_jmp ) { mrb -> jmp = prev_jmp ; MRB_THROW ( prev_jmp ) ; } pc = ci [ 0 ] . pc ; if ( ci == mrb -> c -> cibase ) { ch = catch_handler_find ( mrb , ci , pc , MRB_CATCH_FILTER_ALL ) ; if ( ch == NULL ) { L_FTOP : if ( mrb -> c == mrb -> root_c ) { mrb -> c -> ci -> stack = mrb -> c -> stbase ; goto L_STOP ; } else { struct mrb_context * c = mrb -> c ; c -> status = MRB_FIBER_TERMINATED ; mrb -> c = c -> prev ; c -> prev = NULL ; goto L_RAISE ; } } break ; } } L_CATCH : if ( ch == NULL ) goto L_STOP ; if ( FALSE ) { L_CATCH_TAGGED_BREAK : ci = mrb -> c -> ci ; } proc = ci -> proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , irep -> nregs ) ; pc = irep -> iseq + mrb_irep_catch_handler_unpack ( ch -> target ) ; } else { mrb_int acc ; mrb_value v ; ci = mrb -> c -> ci ; v = regs [ a ] ; mrb_gc_protect ( mrb , v ) ; switch ( c ) { case OP_R_RETURN : if ( ci -> cci == CINFO_NONE && MRB_PROC_ENV_P ( proc ) && ! MRB_PROC_STRICT_P ( proc ) ) { const struct RProc * dst ; mrb_callinfo * cibase ; cibase = mrb -> c -> cibase ; dst = top_proc ( mrb , proc ) ; if ( MRB_PROC_ENV_P ( dst ) ) { struct REnv * e = MRB_PROC_ENV ( dst ) ; if ( ! MRB_ENV_ONSTACK_P ( e ) || ( e -> cxt && e -> cxt != mrb -> c ) ) { localjump_error ( mrb , LOCALJUMP_ERROR_RETURN ) ; goto L_RAISE ; } } while ( cibase <= ci && ci -> proc != dst ) { if ( ci -> cci > CINFO_NONE ) { localjump_error ( mrb , LOCALJUMP_ERROR_RETURN ) ; goto L_RAISE ; } ci -- ; } if ( ci <= cibase ) { localjump_error ( mrb , LOCALJUMP_ERROR_RETURN ) ; goto L_RAISE ; } ci = mrb -> c -> ci ; while ( cibase <= ci && ci -> proc != dst ) { CHECKPOINT_RESTORE ( RBREAK_TAG_RETURN_BLOCK ) { cibase = mrb -> c -> cibase ; dst = top_proc ( mrb , proc ) ; } CHECKPOINT_MAIN ( RBREAK_TAG_RETURN_BLOCK ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_RETURN_BLOCK , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_RETURN_BLOCK ) ; ci = cipop ( mrb ) ; pc = ci -> pc ; } proc = ci -> proc ; mrb -> exc = NULL ; break ; } case OP_R_NORMAL : NORMAL_RETURN : if ( ci == mrb -> c -> cibase ) { struct mrb_context * c ; c = mrb -> c ; if ( ! c -> prev ) { regs [ irep -> nlocals ] = v ; goto CHECKPOINT_LABEL_MAKE ( RBREAK_TAG_STOP ) ; } if ( ! c -> vmexec && c -> prev -> ci == c -> prev -> cibase ) { mrb_value exc = mrb_exc_new_lit ( mrb , E_FIBER_ERROR , \"double<S2SV_blank>resume\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } CHECKPOINT_RESTORE ( RBREAK_TAG_RETURN_TOPLEVEL ) { c = mrb -> c ; } CHECKPOINT_MAIN ( RBREAK_TAG_RETURN_TOPLEVEL ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_RETURN_TOPLEVEL , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_RETURN_TOPLEVEL ) ; c -> status = MRB_FIBER_TERMINATED ; mrb -> c = c -> prev ; mrb -> c -> status = MRB_FIBER_RUNNING ; c -> prev = NULL ; if ( c -> vmexec ) { mrb_gc_arena_restore ( mrb , ai ) ; c -> vmexec = FALSE ; mrb -> jmp = prev_jmp ; return v ; } ci = mrb -> c -> ci ; } CHECKPOINT_RESTORE ( RBREAK_TAG_RETURN ) { } CHECKPOINT_MAIN ( RBREAK_TAG_RETURN ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_RETURN , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_RETURN ) ; mrb -> exc = NULL ; break ; case OP_R_BREAK : if ( MRB_PROC_STRICT_P ( proc ) ) goto NORMAL_RETURN ; if ( MRB_PROC_ORPHAN_P ( proc ) ) { mrb_value exc ; L_BREAK_ERROR : exc = mrb_exc_new_lit ( mrb , E_LOCALJUMP_ERROR , \"break<S2SV_blank>from<S2SV_blank>proc-closure\" ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } if ( ! MRB_PROC_ENV_P ( proc ) || ! MRB_ENV_ONSTACK_P ( MRB_PROC_ENV ( proc ) ) ) { goto L_BREAK_ERROR ; } else { struct REnv * e = MRB_PROC_ENV ( proc ) ; if ( e -> cxt != mrb -> c ) { goto L_BREAK_ERROR ; } } CHECKPOINT_RESTORE ( RBREAK_TAG_BREAK ) { } CHECKPOINT_MAIN ( RBREAK_TAG_BREAK ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_BREAK , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_BREAK ) ; if ( ci == mrb -> c -> cibase && ci -> pc ) { struct mrb_context * c = mrb -> c ; mrb -> c = c -> prev ; c -> prev = NULL ; ci = mrb -> c -> ci ; } if ( ci -> cci > CINFO_NONE ) { ci = cipop ( mrb ) ; <S2SV_StartBug> mrb_gc_arena_restore ( mrb , ai ) ; <S2SV_EndBug> mrb -> c -> vmexec = FALSE ; <S2SV_StartBug> mrb -> exc = ( struct RObject * ) break_new ( mrb , RBREAK_TAG_BREAK , proc , v ) ; <S2SV_EndBug> mrb -> jmp = prev_jmp ; MRB_THROW ( prev_jmp ) ; } if ( FALSE ) { struct RBreak * brk ; L_BREAK : brk = ( struct RBreak * ) mrb -> exc ; proc = mrb_break_proc_get ( brk ) ; v = mrb_break_value_get ( brk ) ; ci = mrb -> c -> ci ; switch ( mrb_break_tag_get ( brk ) ) { # define DISPATCH_CHECKPOINTS ( n , i ) case n : goto CHECKPOINT_LABEL_MAKE ( n ) ; RBREAK_TAG_FOREACH ( DISPATCH_CHECKPOINTS ) # undef DISPATCH_CHECKPOINTS default : mrb_assert ( ! \"wrong<S2SV_blank>break<S2SV_blank>tag\" ) ; } } while ( mrb -> c -> cibase < ci && ci [ - 1 ] . proc != proc -> upper ) { if ( ci [ - 1 ] . cci == CINFO_SKIP ) { goto L_BREAK_ERROR ; } CHECKPOINT_RESTORE ( RBREAK_TAG_BREAK_UPPER ) { } CHECKPOINT_MAIN ( RBREAK_TAG_BREAK_UPPER ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_BREAK_UPPER , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_BREAK_UPPER ) ; ci = cipop ( mrb ) ; pc = ci -> pc ; } CHECKPOINT_RESTORE ( RBREAK_TAG_BREAK_INTARGET ) { } CHECKPOINT_MAIN ( RBREAK_TAG_BREAK_INTARGET ) { UNWIND_ENSURE ( mrb , ci , pc , RBREAK_TAG_BREAK_INTARGET , proc , v ) ; } CHECKPOINT_END ( RBREAK_TAG_BREAK_INTARGET ) ; if ( ci == mrb -> c -> cibase ) { goto L_BREAK_ERROR ; } mrb -> exc = NULL ; break ; default : break ; } mrb_assert ( ci == mrb -> c -> ci ) ; mrb_assert ( mrb -> exc == NULL ) ; if ( mrb -> c -> vmexec && ! mrb_vm_ci_target_class ( ci ) ) { mrb_gc_arena_restore ( mrb , ai ) ; mrb -> c -> vmexec = FALSE ; mrb -> jmp = prev_jmp ; return v ; } acc = ci -> cci ; ci = cipop ( mrb ) ; if ( acc == CINFO_SKIP || acc == CINFO_DIRECT ) { mrb_gc_arena_restore ( mrb , ai ) ; mrb -> jmp = prev_jmp ; return v ; } pc = ci -> pc ; DEBUG ( fprintf ( stderr , \"from<S2SV_blank>:%s\\\\n\" , mrb_sym_name ( mrb , ci -> mid ) ) ) ; proc = ci -> proc ; irep = proc -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; ci [ 1 ] . stack [ 0 ] = v ; mrb_gc_arena_restore ( mrb , ai ) ; } JUMP ; } CASE ( OP_BLKPUSH , BS ) { int m1 = ( b >> 11 ) & 0x3f ; int r = ( b >> 10 ) & 0x1 ; int m2 = ( b >> 5 ) & 0x1f ; int kd = ( b >> 4 ) & 0x1 ; int lv = ( b >> 0 ) & 0xf ; mrb_value * stack ; if ( lv == 0 ) stack = regs + 1 ; else { struct REnv * e = uvenv ( mrb , lv - 1 ) ; if ( ! e || ( ! MRB_ENV_ONSTACK_P ( e ) && e -> mid == 0 ) || MRB_ENV_LEN ( e ) <= m1 + r + m2 + 1 ) { localjump_error ( mrb , LOCALJUMP_ERROR_YIELD ) ; goto L_RAISE ; } stack = e -> stack + 1 ; } if ( mrb_nil_p ( stack [ m1 + r + m2 + kd ] ) ) { localjump_error ( mrb , LOCALJUMP_ERROR_YIELD ) ; goto L_RAISE ; } regs [ a ] = stack [ m1 + r + m2 + kd ] ; NEXT ; } L_INT_OVERFLOW : { mrb_value exc = mrb_exc_new_lit ( mrb , E_RANGE_ERROR , \"integer<S2SV_blank>overflow\" ) ; mrb_exc_set ( mrb , exc ) ; } goto L_RAISE ; # define TYPES2 ( a , b ) ( ( ( ( uint16_t ) ( a ) ) << 8 ) | ( ( ( uint16_t ) ( b ) ) & 0xff ) ) # define OP_MATH ( op_name ) switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { OP_MATH_CASE_INTEGER ( op_name ) ; OP_MATH_CASE_FLOAT ( op_name , integer , float ) ; OP_MATH_CASE_FLOAT ( op_name , float , integer ) ; OP_MATH_CASE_FLOAT ( op_name , float , float ) ; OP_MATH_CASE_STRING_ ## op_name ( ) ; default : mid = MRB_OPSYM ( op_name ) ; goto L_SEND_SYM ; } NEXT ; # define OP_MATH_CASE_INTEGER ( op_name ) case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : { mrb_int x = mrb_integer ( regs [ a ] ) , y = mrb_integer ( regs [ a + 1 ] ) , z ; if ( mrb_int_ ## op_name ## _overflow ( x , y , & z ) ) OP_MATH_OVERFLOW_INT ( ) ; else SET_INT_VALUE ( mrb , regs [ a ] , z ) ; } break # ifdef MRB_NO_FLOAT # define OP_MATH_CASE_FLOAT ( op_name , t1 , t2 ) ( void ) 0 # else # define OP_MATH_CASE_FLOAT ( op_name , t1 , t2 ) case TYPES2 ( OP_MATH_TT_ ## t1 , OP_MATH_TT_ ## t2 ) : { mrb_float z = mrb_ ## t1 ( regs [ a ] ) OP_MATH_OP_ ## op_name mrb_ ## t2 ( regs [ a + 1 ] ) ; SET_FLOAT_VALUE ( mrb , regs [ a ] , z ) ; } break # endif # define OP_MATH_OVERFLOW_INT ( ) goto L_INT_OVERFLOW # define OP_MATH_CASE_STRING_add ( ) case TYPES2 ( MRB_TT_STRING , MRB_TT_STRING ) : regs [ a ] = mrb_str_plus ( mrb , regs [ a ] , regs [ a + 1 ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; break # define OP_MATH_CASE_STRING_sub ( ) ( void ) 0 # define OP_MATH_CASE_STRING_mul ( ) ( void ) 0 # define OP_MATH_OP_add + # define OP_MATH_OP_sub - # define OP_MATH_OP_mul * # define OP_MATH_TT_integer MRB_TT_INTEGER # define OP_MATH_TT_float MRB_TT_FLOAT CASE ( OP_ADD , B ) { OP_MATH ( add ) ; } CASE ( OP_SUB , B ) { OP_MATH ( sub ) ; } CASE ( OP_MUL , B ) { OP_MATH ( mul ) ; } CASE ( OP_DIV , B ) { # ifndef MRB_NO_FLOAT mrb_float x , y , f ; # endif switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : { mrb_int x = mrb_integer ( regs [ a ] ) ; mrb_int y = mrb_integer ( regs [ a + 1 ] ) ; mrb_int div = mrb_div_int ( mrb , x , y ) ; SET_INT_VALUE ( mrb , regs [ a ] , div ) ; } NEXT ; # ifndef MRB_NO_FLOAT case TYPES2 ( MRB_TT_INTEGER , MRB_TT_FLOAT ) : x = ( mrb_float ) mrb_integer ( regs [ a ] ) ; y = mrb_float ( regs [ a + 1 ] ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_INTEGER ) : x = mrb_float ( regs [ a ] ) ; y = ( mrb_float ) mrb_integer ( regs [ a + 1 ] ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_FLOAT ) : x = mrb_float ( regs [ a ] ) ; y = mrb_float ( regs [ a + 1 ] ) ; break ; # endif default : mid = MRB_OPSYM ( div ) ; goto L_SEND_SYM ; } # ifndef MRB_NO_FLOAT f = mrb_div_float ( x , y ) ; SET_FLOAT_VALUE ( mrb , regs [ a ] , f ) ; # endif NEXT ; } # define OP_MATHI ( op_name ) switch ( mrb_type ( regs [ a ] ) ) { OP_MATHI_CASE_INTEGER ( op_name ) ; OP_MATHI_CASE_FLOAT ( op_name ) ; default : SET_INT_VALUE ( mrb , regs [ a + 1 ] , b ) ; mid = MRB_OPSYM ( op_name ) ; goto L_SEND_SYM ; } NEXT ; # define OP_MATHI_CASE_INTEGER ( op_name ) case MRB_TT_INTEGER : { mrb_int x = mrb_integer ( regs [ a ] ) , y = ( mrb_int ) b , z ; if ( mrb_int_ ## op_name ## _overflow ( x , y , & z ) ) OP_MATH_OVERFLOW_INT ( ) ; else SET_INT_VALUE ( mrb , regs [ a ] , z ) ; } break # ifdef MRB_NO_FLOAT # define OP_MATHI_CASE_FLOAT ( op_name ) ( void ) 0 # else # define OP_MATHI_CASE_FLOAT ( op_name ) case MRB_TT_FLOAT : { mrb_float z = mrb_float ( regs [ a ] ) OP_MATH_OP_ ## op_name b ; SET_FLOAT_VALUE ( mrb , regs [ a ] , z ) ; } break # endif CASE ( OP_ADDI , BB ) { OP_MATHI ( add ) ; } CASE ( OP_SUBI , BB ) { OP_MATHI ( sub ) ; } # define OP_CMP_BODY ( op , v1 , v2 ) ( v1 ( regs [ a ] ) op v2 ( regs [ a + 1 ] ) ) # ifdef MRB_NO_FLOAT <S2SV_StartBug> # define OP_CMP ( op , sym ) do { int result ; switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : result = OP_CMP_BODY ( op , mrb_fixnum , mrb_fixnum ) ; break ; default : mid = MRB_OPSYM ( sym ) ; goto L_SEND_SYM ; } if ( result ) { SET_TRUE_VALUE ( regs [ a ] ) ; } else { SET_FALSE_VALUE ( regs [ a ] ) ; } } while ( 0 ) <S2SV_EndBug> # else <S2SV_StartBug> # define OP_CMP ( op , sym ) do { int result ; switch ( TYPES2 ( mrb_type ( regs [ a ] ) , mrb_type ( regs [ a + 1 ] ) ) ) { case TYPES2 ( MRB_TT_INTEGER , MRB_TT_INTEGER ) : result = OP_CMP_BODY ( op , mrb_fixnum , mrb_fixnum ) ; break ; case TYPES2 ( MRB_TT_INTEGER , MRB_TT_FLOAT ) : result = OP_CMP_BODY ( op , mrb_fixnum , mrb_float ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_INTEGER ) : result = OP_CMP_BODY ( op , mrb_float , mrb_fixnum ) ; break ; case TYPES2 ( MRB_TT_FLOAT , MRB_TT_FLOAT ) : result = OP_CMP_BODY ( op , mrb_float , mrb_float ) ; break ; default : mid = MRB_OPSYM ( sym ) ; goto L_SEND_SYM ; } if ( result ) { SET_TRUE_VALUE ( regs [ a ] ) ; } else { SET_FALSE_VALUE ( regs [ a ] ) ; } } while ( 0 ) <S2SV_EndBug> # endif CASE ( OP_EQ , B ) { if ( mrb_obj_eq ( mrb , regs [ a ] , regs [ a + 1 ] ) ) { SET_TRUE_VALUE ( regs [ a ] ) ; } else { OP_CMP ( == , eq ) ; } NEXT ; } CASE ( OP_LT , B ) { OP_CMP ( < , lt ) ; NEXT ; } CASE ( OP_LE , B ) { OP_CMP ( <= , le ) ; NEXT ; } CASE ( OP_GT , B ) { OP_CMP ( > , gt ) ; NEXT ; } CASE ( OP_GE , B ) { OP_CMP ( >= , ge ) ; NEXT ; } CASE ( OP_ARRAY , BB ) { regs [ a ] = mrb_ary_new_from_values ( mrb , b , & regs [ a ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ARRAY2 , BBB ) { regs [ a ] = mrb_ary_new_from_values ( mrb , c , & regs [ b ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ARYCAT , B ) { mrb_value splat = mrb_ary_splat ( mrb , regs [ a + 1 ] ) ; if ( mrb_nil_p ( regs [ a ] ) ) { regs [ a ] = splat ; } else { mrb_assert ( mrb_array_p ( regs [ a ] ) ) ; mrb_ary_concat ( mrb , regs [ a ] , splat ) ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_ARYPUSH , BB ) { mrb_assert ( mrb_array_p ( regs [ a ] ) ) ; for ( mrb_int i = 0 ; i < b ; i ++ ) { mrb_ary_push ( mrb , regs [ a ] , regs [ a + i + 1 ] ) ; } NEXT ; } CASE ( OP_ARYDUP , B ) { mrb_value ary = regs [ a ] ; if ( mrb_array_p ( ary ) ) { ary = mrb_ary_new_from_values ( mrb , RARRAY_LEN ( ary ) , RARRAY_PTR ( ary ) ) ; } else { ary = mrb_ary_new_from_values ( mrb , 1 , & ary ) ; } regs [ a ] = ary ; NEXT ; } CASE ( OP_AREF , BBB ) { mrb_value v = regs [ b ] ; if ( ! mrb_array_p ( v ) ) { if ( c == 0 ) { regs [ a ] = v ; } else { SET_NIL_VALUE ( regs [ a ] ) ; } } else { v = mrb_ary_ref ( mrb , v , c ) ; regs [ a ] = v ; } NEXT ; } CASE ( OP_ASET , BBB ) { mrb_assert ( mrb_array_p ( regs [ a ] ) ) ; mrb_ary_set ( mrb , regs [ b ] , c , regs [ a ] ) ; NEXT ; } CASE ( OP_APOST , BBB ) { mrb_value v = regs [ a ] ; int pre = b ; int post = c ; struct RArray * ary ; int len , idx ; if ( ! mrb_array_p ( v ) ) { v = mrb_ary_new_from_values ( mrb , 1 , & regs [ a ] ) ; } ary = mrb_ary_ptr ( v ) ; len = ( int ) ARY_LEN ( ary ) ; if ( len > pre + post ) { v = mrb_ary_new_from_values ( mrb , len - pre - post , ARY_PTR ( ary ) + pre ) ; regs [ a ++ ] = v ; while ( post -- ) { regs [ a ++ ] = ARY_PTR ( ary ) [ len - post - 1 ] ; } } else { v = mrb_ary_new_capa ( mrb , 0 ) ; regs [ a ++ ] = v ; for ( idx = 0 ; idx + pre < len ; idx ++ ) { regs [ a + idx ] = ARY_PTR ( ary ) [ pre + idx ] ; } while ( idx < post ) { SET_NIL_VALUE ( regs [ a + idx ] ) ; idx ++ ; } } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_INTERN , B ) { mrb_assert ( mrb_string_p ( regs [ a ] ) ) ; mrb_sym sym = mrb_intern_str ( mrb , regs [ a ] ) ; regs [ a ] = mrb_symbol_value ( sym ) ; NEXT ; } CASE ( OP_SYMBOL , BB ) { size_t len ; mrb_sym sym ; mrb_assert ( ( pool [ b ] . tt & IREP_TT_NFLAG ) == 0 ) ; len = pool [ b ] . tt >> 2 ; if ( pool [ b ] . tt & IREP_TT_SFLAG ) { sym = mrb_intern_static ( mrb , pool [ b ] . u . str , len ) ; } else { sym = mrb_intern ( mrb , pool [ b ] . u . str , len ) ; } regs [ a ] = mrb_symbol_value ( sym ) ; NEXT ; } CASE ( OP_STRING , BB ) { mrb_int len ; mrb_assert ( ( pool [ b ] . tt & IREP_TT_NFLAG ) == 0 ) ; len = pool [ b ] . tt >> 2 ; if ( pool [ b ] . tt & IREP_TT_SFLAG ) { regs [ a ] = mrb_str_new_static ( mrb , pool [ b ] . u . str , len ) ; } else { regs [ a ] = mrb_str_new ( mrb , pool [ b ] . u . str , len ) ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_STRCAT , B ) { mrb_assert ( mrb_string_p ( regs [ a ] ) ) ; mrb_str_concat ( mrb , regs [ a ] , regs [ a + 1 ] ) ; NEXT ; } CASE ( OP_HASH , BB ) { mrb_value hash = mrb_hash_new_capa ( mrb , b ) ; int i ; int lim = a + b * 2 ; for ( i = a ; i < lim ; i += 2 ) { mrb_hash_set ( mrb , hash , regs [ i ] , regs [ i + 1 ] ) ; } regs [ a ] = hash ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_HASHADD , BB ) { mrb_value hash ; int i ; int lim = a + b * 2 + 1 ; hash = regs [ a ] ; mrb_ensure_hash_type ( mrb , hash ) ; for ( i = a + 1 ; i < lim ; i += 2 ) { mrb_hash_set ( mrb , hash , regs [ i ] , regs [ i + 1 ] ) ; } mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_HASHCAT , B ) { mrb_value hash = regs [ a ] ; mrb_assert ( mrb_hash_p ( hash ) ) ; mrb_hash_merge ( mrb , hash , regs [ a + 1 ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_LAMBDA , BB ) c = OP_L_LAMBDA ; L_MAKE_LAMBDA : { struct RProc * p ; const mrb_irep * nirep = irep -> reps [ b ] ; if ( c & OP_L_CAPTURE ) { p = mrb_closure_new ( mrb , nirep ) ; } else { p = mrb_proc_new ( mrb , nirep ) ; p -> flags |= MRB_PROC_SCOPE ; } if ( c & OP_L_STRICT ) p -> flags |= MRB_PROC_STRICT ; regs [ a ] = mrb_obj_value ( p ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_BLOCK , BB ) { c = OP_L_BLOCK ; goto L_MAKE_LAMBDA ; } CASE ( OP_METHOD , BB ) { c = OP_L_METHOD ; goto L_MAKE_LAMBDA ; } CASE ( OP_RANGE_INC , B ) { mrb_value v = mrb_range_new ( mrb , regs [ a ] , regs [ a + 1 ] , FALSE ) ; regs [ a ] = v ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_RANGE_EXC , B ) { mrb_value v = mrb_range_new ( mrb , regs [ a ] , regs [ a + 1 ] , TRUE ) ; regs [ a ] = v ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_OCLASS , B ) { regs [ a ] = mrb_obj_value ( mrb -> object_class ) ; NEXT ; } CASE ( OP_CLASS , BB ) { struct RClass * c = 0 , * baseclass ; mrb_value base , super ; mrb_sym id = syms [ b ] ; base = regs [ a ] ; super = regs [ a + 1 ] ; if ( mrb_nil_p ( base ) ) { baseclass = MRB_PROC_TARGET_CLASS ( mrb -> c -> ci -> proc ) ; if ( ! baseclass ) baseclass = mrb -> object_class ; base = mrb_obj_value ( baseclass ) ; } c = mrb_vm_define_class ( mrb , base , super , id ) ; regs [ a ] = mrb_obj_value ( c ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_MODULE , BB ) { struct RClass * cls = 0 , * baseclass ; mrb_value base ; mrb_sym id = syms [ b ] ; base = regs [ a ] ; if ( mrb_nil_p ( base ) ) { baseclass = MRB_PROC_TARGET_CLASS ( mrb -> c -> ci -> proc ) ; if ( ! baseclass ) baseclass = mrb -> object_class ; base = mrb_obj_value ( baseclass ) ; } cls = mrb_vm_define_module ( mrb , base , id ) ; regs [ a ] = mrb_obj_value ( cls ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_EXEC , BB ) { mrb_value recv = regs [ a ] ; struct RProc * p ; const mrb_irep * nirep = irep -> reps [ b ] ; p = mrb_proc_new ( mrb , nirep ) ; p -> c = NULL ; mrb_field_write_barrier ( mrb , ( struct RBasic * ) p , ( struct RBasic * ) proc ) ; MRB_PROC_SET_TARGET_CLASS ( p , mrb_class_ptr ( recv ) ) ; p -> flags |= MRB_PROC_SCOPE ; cipush ( mrb , a , 0 , mrb_class_ptr ( recv ) , p , 0 , 0 ) ; irep = p -> body . irep ; pool = irep -> pool ; syms = irep -> syms ; mrb_stack_extend ( mrb , irep -> nregs ) ; stack_clear ( regs + 1 , irep -> nregs - 1 ) ; pc = irep -> iseq ; JUMP ; } CASE ( OP_DEF , BB ) { struct RClass * target = mrb_class_ptr ( regs [ a ] ) ; struct RProc * p = mrb_proc_ptr ( regs [ a + 1 ] ) ; mrb_method_t m ; mrb_sym mid = syms [ b ] ; MRB_METHOD_FROM_PROC ( m , p ) ; mrb_define_method_raw ( mrb , target , mid , m ) ; mrb_method_added ( mrb , target , mid ) ; mrb_gc_arena_restore ( mrb , ai ) ; regs [ a ] = mrb_symbol_value ( mid ) ; NEXT ; } CASE ( OP_SCLASS , B ) { regs [ a ] = mrb_singleton_class ( mrb , regs [ a ] ) ; mrb_gc_arena_restore ( mrb , ai ) ; NEXT ; } CASE ( OP_TCLASS , B ) { struct RClass * target = check_target_class ( mrb ) ; if ( ! target ) goto L_RAISE ; regs [ a ] = mrb_obj_value ( target ) ; NEXT ; } CASE ( OP_ALIAS , BB ) { struct RClass * target = check_target_class ( mrb ) ; if ( ! target ) goto L_RAISE ; mrb_alias_method ( mrb , target , syms [ a ] , syms [ b ] ) ; mrb_method_added ( mrb , target , syms [ a ] ) ; NEXT ; } CASE ( OP_UNDEF , B ) { struct RClass * target = check_target_class ( mrb ) ; if ( ! target ) goto L_RAISE ; mrb_undef_method_id ( mrb , target , syms [ a ] ) ; NEXT ; } CASE ( OP_DEBUG , Z ) { FETCH_BBB ( ) ; # ifdef MRB_USE_DEBUG_HOOK mrb -> debug_op_hook ( mrb , irep , pc , regs ) ; # else # ifndef MRB_NO_STDIO printf ( \"OP_DEBUG<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\\n\" , a , b , c ) ; # else abort ( ) ; # endif # endif NEXT ; } CASE ( OP_ERR , B ) { size_t len = pool [ a ] . tt >> 2 ; mrb_value exc ; mrb_assert ( ( pool [ a ] . tt & IREP_TT_NFLAG ) == 0 ) ; exc = mrb_exc_new ( mrb , E_LOCALJUMP_ERROR , pool [ a ] . u . str , len ) ; mrb_exc_set ( mrb , exc ) ; goto L_RAISE ; } CASE ( OP_EXT1 , Z ) { insn = READ_B ( ) ; switch ( insn ) { # define OPCODE ( insn , ops ) case OP_ ## insn : FETCH_ ## ops ## _1 ( ) ; mrb -> c -> ci -> pc = pc ; goto L_OP_ ## insn ## _BODY ; # include \"mruby/ops.h\" # undef OPCODE } pc -- ; NEXT ; } CASE ( OP_EXT2 , Z ) { insn = READ_B ( ) ; switch ( insn ) { # define OPCODE ( insn , ops ) case OP_ ## insn : FETCH_ ## ops ## _2 ( ) ; mrb -> c -> ci -> pc = pc ; goto L_OP_ ## insn ## _BODY ; # include \"mruby/ops.h\" # undef OPCODE } pc -- ; NEXT ; } CASE ( OP_EXT3 , Z ) { uint8_t insn = READ_B ( ) ; switch ( insn ) { # define OPCODE ( insn , ops ) case OP_ ## insn : FETCH_ ## ops ## _3 ( ) ; mrb -> c -> ci -> pc = pc ; goto L_OP_ ## insn ## _BODY ; # include \"mruby/ops.h\" # undef OPCODE } pc -- ; NEXT ; } CASE ( OP_STOP , Z ) { CHECKPOINT_RESTORE ( RBREAK_TAG_STOP ) { } CHECKPOINT_MAIN ( RBREAK_TAG_STOP ) { UNWIND_ENSURE ( mrb , mrb -> c -> ci , pc , RBREAK_TAG_STOP , proc , mrb_nil_value ( ) ) ; } CHECKPOINT_END ( RBREAK_TAG_STOP ) ; L_STOP : mrb -> jmp = prev_jmp ; if ( mrb -> exc ) { mrb_assert ( mrb -> exc -> tt == MRB_TT_EXCEPTION ) ; return mrb_obj_value ( mrb -> exc ) ; } return regs [ irep -> nlocals ] ; } } END_DISPATCH ; # undef regs } MRB_CATCH ( & c_jmp ) { mrb_callinfo * ci = mrb -> c -> ci ; while ( ci > mrb -> c -> cibase && ci -> cci == CINFO_DIRECT ) { ci = cipop ( mrb ) ; } exc_catched = TRUE ; pc = ci -> pc ; goto RETRY_TRY_BLOCK ; } MRB_END_EXC ( & c_jmp ) ; }", "target": "<S2SV_ModStart> mrb ) ; <S2SV_ModEnd> mrb -> exc <S2SV_ModStart> , v ) ; mrb_gc_arena_restore ( mrb , ai ) ; mrb -> c -> vmexec = FALSE <S2SV_ModStart> ) ; } \\\\\\n} <S2SV_ModEnd> while ( 0 <S2SV_ModStart> ) ; } \\\\\\n} <S2SV_ModEnd> while ( 0"}
{"source": "CWE-787 PJ_DEF ( pj_status_t ) pjstun_parse_msg ( void * buf , pj_size_t buf_len , pjstun_msg * msg ) { pj_uint16_t msg_type , msg_len ; <S2SV_StartBug> char * p_attr ; <S2SV_EndBug> PJ_CHECK_STACK ( ) ; msg -> hdr = ( pjstun_msg_hdr * ) buf ; msg_type = pj_ntohs ( msg -> hdr -> type ) ; switch ( msg_type ) { case PJSTUN_BINDING_REQUEST : case PJSTUN_BINDING_RESPONSE : case PJSTUN_BINDING_ERROR_RESPONSE : case PJSTUN_SHARED_SECRET_REQUEST : case PJSTUN_SHARED_SECRET_RESPONSE : case PJSTUN_SHARED_SECRET_ERROR_RESPONSE : break ; default : PJ_LOG ( 4 , ( THIS_FILE , \"Error:<S2SV_blank>unknown<S2SV_blank>msg<S2SV_blank>type<S2SV_blank>%d\" , msg_type ) ) ; return PJLIB_UTIL_ESTUNINMSGTYPE ; } msg_len = pj_ntohs ( msg -> hdr -> length ) ; if ( msg_len != buf_len - sizeof ( pjstun_msg_hdr ) ) { PJ_LOG ( 4 , ( THIS_FILE , \"Error:<S2SV_blank>invalid<S2SV_blank>msg_len<S2SV_blank>%d<S2SV_blank>(expecting<S2SV_blank>%d)\" , msg_len , buf_len - sizeof ( pjstun_msg_hdr ) ) ) ; return PJLIB_UTIL_ESTUNINMSGLEN ; } msg -> attr_count = 0 ; p_attr = ( char * ) buf + sizeof ( pjstun_msg_hdr ) ; <S2SV_StartBug> while ( msg_len > 0 ) { <S2SV_EndBug> pjstun_attr_hdr * * attr = & msg -> attr [ msg -> attr_count ] ; pj_uint32_t len ; pj_uint16_t attr_type ; * attr = ( pjstun_attr_hdr * ) p_attr ; len = pj_ntohs ( ( pj_uint16_t ) ( ( * attr ) -> length ) ) + sizeof ( pjstun_attr_hdr ) ; len = ( len + 3 ) & ~ 3 ; if ( msg_len < len ) { PJ_LOG ( 4 , ( THIS_FILE , \"Error:<S2SV_blank>length<S2SV_blank>mismatch<S2SV_blank>in<S2SV_blank>attr<S2SV_blank>%d\" , msg -> attr_count ) ) ; return PJLIB_UTIL_ESTUNINATTRLEN ; } attr_type = pj_ntohs ( ( * attr ) -> type ) ; if ( attr_type > PJSTUN_ATTR_REFLECTED_FROM && attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR ) { PJ_LOG ( 5 , ( THIS_FILE , \"Warning:<S2SV_blank>unknown<S2SV_blank>attr<S2SV_blank>type<S2SV_blank>%x<S2SV_blank>in<S2SV_blank>attr<S2SV_blank>%d.<S2SV_blank>\" \"Attribute<S2SV_blank>was<S2SV_blank>ignored.\" , attr_type , msg -> attr_count ) ) ; } msg_len = ( pj_uint16_t ) ( msg_len - len ) ; p_attr += len ; ++ msg -> attr_count ; } <S2SV_StartBug> <S2SV_EndBug> return PJ_SUCCESS ; }", "target": "<S2SV_ModStart> char * p_attr ; int attr_max_cnt = PJ_ARRAY_SIZE ( msg -> attr ) <S2SV_ModStart> msg_len > 0 && msg -> attr_count < attr_max_cnt <S2SV_ModStart> attr_count ; } if ( msg -> attr_count == attr_max_cnt ) { PJ_LOG ( 4 , ( THIS_FILE , \"Warning:<S2SV_blank>max<S2SV_blank>number<S2SV_blank>attribute<S2SV_blank>%d<S2SV_blank>reached.\" , attr_max_cnt ) ) ; }"}
{"source": "CWE-703 void ComparisonQuantized ( const TfLiteTensor * input1 , const TfLiteTensor * input2 , TfLiteTensor * output , bool requires_broadcast ) { if ( input1 -> type == kTfLiteUInt8 || input1 -> type == kTfLiteInt8 ) { auto input1_offset = - input1 -> params . zero_point ; auto input2_offset = - input2 -> params . zero_point ; const int left_shift = 8 ; int32 input1_multiplier ; <S2SV_StartBug> int input1_shift ; <S2SV_EndBug> <S2SV_StartBug> QuantizeMultiplierSmallerThanOneExp ( input1 -> params . scale , <S2SV_EndBug> & input1_multiplier , & input1_shift ) ; <S2SV_StartBug> int32 input2_multiplier ; <S2SV_EndBug> int input2_shift ; QuantizeMultiplierSmallerThanOneExp ( input2 -> params . scale , & input2_multiplier , & input2_shift ) ; ComparisonParams op_params ; op_params . left_shift = left_shift ; op_params . input1_offset = input1_offset ; op_params . input1_multiplier = input1_multiplier ; op_params . input1_shift = input1_shift ; op_params . input2_offset = input2_offset ; op_params . input2_multiplier = input2_multiplier ; op_params . input2_shift = input2_shift ; if ( requires_broadcast ) { reference_ops : : BroadcastComparison4DSlowWithScaling < input_dtype , opname > ( op_params , GetTensorShape ( input1 ) , GetTensorData < input_dtype > ( input1 ) , GetTensorShape ( input2 ) , GetTensorData < input_dtype > ( input2 ) , GetTensorShape ( output ) , GetTensorData < bool > ( output ) ) ; } else { reference_ops : : ComparisonWithScaling < input_dtype , opname > ( op_params , GetTensorShape ( input1 ) , GetTensorData < input_dtype > ( input1 ) , GetTensorShape ( input2 ) , GetTensorData < input_dtype > ( input2 ) , GetTensorShape ( output ) , GetTensorData < bool > ( output ) ) ; } } }", "target": "<S2SV_ModStart> int32 input1_multiplier ; int32 input2_multiplier ; <S2SV_ModStart> int input1_shift ; int input2_shift ; QuantizeMultiplier <S2SV_ModEnd> ( input1 -> <S2SV_ModStart> input1_shift ) ; QuantizeMultiplier <S2SV_ModEnd> ( input2 ->"}
{"source": "CWE-416 njs_await_fulfilled ( njs_vm_t * vm , njs_value_t * args , njs_uint_t nargs , njs_index_t unused ) { njs_int_t ret ; njs_value_t * * cur_local , * * cur_closures , * * cur_temp , * value ; njs_frame_t * frame , * async_frame ; <S2SV_StartBug> njs_function_t * function ; <S2SV_EndBug> njs_async_ctx_t * ctx ; njs_native_frame_t * top , * async ; ctx = vm -> top_frame -> function -> context ; value = njs_arg ( args , nargs , 1 ) ; if ( njs_is_error ( value ) ) { goto failed ; } async_frame = ctx -> await ; async = & async_frame -> native ; async -> previous = vm -> top_frame ; <S2SV_StartBug> function = async -> function ; <S2SV_EndBug> cur_local = vm -> levels [ NJS_LEVEL_LOCAL ] ; cur_closures = vm -> levels [ NJS_LEVEL_CLOSURE ] ; <S2SV_StartBug> cur_temp = vm -> levels [ NJS_LEVEL_TEMP ] ; <S2SV_EndBug> <S2SV_StartBug> top = vm -> top_frame ; <S2SV_EndBug> <S2SV_StartBug> frame = vm -> active_frame ; <S2SV_EndBug> vm -> levels [ NJS_LEVEL_LOCAL ] = async -> local ; vm -> levels [ NJS_LEVEL_CLOSURE ] = njs_function_closures ( async -> function ) ; vm -> levels [ NJS_LEVEL_TEMP ] = async -> temp ; <S2SV_StartBug> vm -> top_frame = async ; <S2SV_EndBug> vm -> active_frame = async_frame ; * njs_scope_value ( vm , ctx -> index ) = * value ; vm -> retval = * value ; vm -> top_frame -> retval = & vm -> retval ; <S2SV_StartBug> function -> context = ctx -> capability ; <S2SV_EndBug> function -> await = ctx ; ret = njs_vmcode_interpreter ( vm , ctx -> pc ) ; function -> context = NULL ; function -> await = NULL ; vm -> levels [ NJS_LEVEL_LOCAL ] = cur_local ; vm -> levels [ NJS_LEVEL_CLOSURE ] = cur_closures ; vm -> levels [ NJS_LEVEL_TEMP ] = cur_temp ; vm -> top_frame = top ; vm -> active_frame = frame ; if ( ret == NJS_OK ) { ret = njs_function_call ( vm , njs_function ( & ctx -> capability -> resolve ) , & njs_value_undefined , & vm -> retval , 1 , & vm -> retval ) ; njs_async_context_free ( vm , ctx ) ; } else if ( ret == NJS_AGAIN ) { ret = NJS_OK ; } else if ( ret == NJS_ERROR ) { if ( njs_is_memory_error ( vm , & vm -> retval ) ) { return NJS_ERROR ; } value = & vm -> retval ; goto failed ; } return ret ; failed : ( void ) njs_function_call ( vm , njs_function ( & ctx -> capability -> reject ) , & njs_value_undefined , value , 1 , & vm -> retval ) ; njs_async_context_free ( vm , ctx ) ; return NJS_ERROR ; }", "target": "<S2SV_ModStart> * async_frame ; <S2SV_ModEnd> njs_async_ctx_t * ctx <S2SV_ModStart> -> top_frame ; cur_local = vm -> levels [ NJS_LEVEL_LOCAL ] ; cur_closures = vm -> levels [ NJS_LEVEL_CLOSURE ] ; cur_temp = vm -> levels [ NJS_LEVEL_TEMP ] ; top = vm -> top_frame ; frame = vm -> active_frame ; vm -> levels [ NJS_LEVEL_LOCAL ] = async -> local ; vm -> levels [ NJS_LEVEL_CLOSURE ] = njs_function_closures ( async -> function ) ; <S2SV_ModEnd> vm -> levels <S2SV_ModStart> [ NJS_LEVEL_TEMP ] = async -> temp ; <S2SV_ModEnd> vm -> top_frame <S2SV_ModStart> vm -> top_frame = async ; <S2SV_ModEnd> vm -> active_frame <S2SV_ModStart> vm -> active_frame = async_frame ; * njs_scope_value ( vm , ctx -> index ) = * value ; vm -> retval = * value <S2SV_ModEnd> ; vm -> <S2SV_ModStart> vm -> top_frame -> retval = & vm -> retval ; ret = njs_vmcode_interpreter ( vm , ctx -> pc , <S2SV_ModEnd> ctx -> capability <S2SV_ModStart> ctx -> capability , ctx ) <S2SV_ModEnd> ; vm ->"}
{"source": "CWE-415 static int uECC_sign_with_k ( const uint8_t * private_key , const uint8_t * message_hash , unsigned hash_size , uECC_word_t * k , uint8_t * signature , uECC_Curve curve ) { uECC_word_t tmp [ uECC_MAX_WORDS ] ; uECC_word_t s [ uECC_MAX_WORDS ] ; uECC_word_t * k2 [ 2 ] = { tmp , s } ; <S2SV_StartBug> # if uECC_VLI_NATIVE_LITTLE_ENDIAN <S2SV_EndBug> uECC_word_t * p = ( uECC_word_t * ) signature ; # else uECC_word_t p [ uECC_MAX_WORDS * 2 ] ; # endif uECC_word_t carry ; wordcount_t num_words = curve -> num_words ; wordcount_t num_n_words = BITS_TO_WORDS ( curve -> num_n_bits ) ; bitcount_t num_n_bits = curve -> num_n_bits ; if ( uECC_vli_isZero ( k , num_words ) || uECC_vli_cmp ( curve -> n , k , num_n_words ) != 1 ) { return 0 ; } carry = regularize_k ( k , tmp , s , curve ) ; <S2SV_StartBug> EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ; <S2SV_EndBug> if ( uECC_vli_isZero ( p , num_words ) ) { return 0 ; } if ( ! g_rng_function ) { uECC_vli_clear ( tmp , num_n_words ) ; tmp [ 0 ] = 1 ; } else if ( ! uECC_generate_random_int ( tmp , curve -> n , num_n_words ) ) { return 0 ; } uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; uECC_vli_modInv ( k , k , curve -> n , num_n_words ) ; uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; # if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0 uECC_vli_nativeToBytes ( signature , curve -> num_bytes , p ) ; # endif # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # else uECC_vli_bytesToNative ( tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # endif s [ num_n_words - 1 ] = 0 ; uECC_vli_set ( s , p , num_words ) ; uECC_vli_modMult ( s , tmp , s , curve -> n , num_n_words ) ; bits2int ( tmp , message_hash , hash_size , curve ) ; uECC_vli_modAdd ( s , tmp , s , curve -> n , num_n_words ) ; uECC_vli_modMult ( s , s , k , curve -> n , num_n_words ) ; if ( uECC_vli_numBits ( s , num_n_words ) > ( bitcount_t ) curve -> num_bytes * 8 ) { return 0 ; } # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) signature + curve -> num_bytes , ( uint8_t * ) s , curve -> num_bytes ) ; # else uECC_vli_nativeToBytes ( signature + curve -> num_bytes , curve -> num_bytes , s ) ; # endif return 1 ; }", "target": "<S2SV_ModStart> s } ; uECC_word_t * initial_Z = 0 ; <S2SV_ModStart> curve ) ; if ( g_rng_function ) { if ( ! uECC_generate_random_int ( k2 [ carry ] , curve -> p , num_words ) ) { return 0 ; } initial_Z = k2 [ carry ] ; } <S2SV_ModStart> carry ] , initial_Z <S2SV_ModEnd> , num_n_bits +"}
{"source": "CWE-416 void Compute ( OpKernelContext * context ) override { const Tensor * stamp_token_t ; OP_REQUIRES_OK ( context , context -> input ( \"stamp_token\" , & stamp_token_t ) ) ; int64_t stamp_token = stamp_token_t -> scalar < int64 > ( ) ( ) ; const Tensor * tree_ensemble_serialized_t ; OP_REQUIRES_OK ( context , context -> input ( \"tree_ensemble_serialized\" , & tree_ensemble_serialized_t ) ) ; std : : unique_ptr < BoostedTreesEnsembleResource > result ( new BoostedTreesEnsembleResource ( ) ) ; if ( ! result -> InitFromSerialized ( tree_ensemble_serialized_t -> scalar < tstring > ( ) ( ) , stamp_token ) ) { result -> Unref ( ) ; <S2SV_StartBug> OP_REQUIRES ( <S2SV_EndBug> context , false , errors : : InvalidArgument ( \"Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>tree<S2SV_blank>ensemble<S2SV_blank>proto.\" ) ) ; } auto status = CreateResource ( context , HandleFromInput ( context , 0 ) , result . release ( ) ) ; if ( status . code ( ) != tensorflow : : error : : ALREADY_EXISTS ) { OP_REQUIRES_OK ( context , status ) ; } }", "target": "<S2SV_ModStart> ( ) ; result . release ( ) ;"}
{"source": "CWE-787 static int do_i2c_md ( struct cmd_tbl * cmdtp , int flag , int argc , char * const argv [ ] ) { uint chip ; uint addr , length ; <S2SV_StartBug> int alen ; <S2SV_EndBug> int j , nbytes , linebytes ; int ret ; # if CONFIG_IS_ENABLED ( DM_I2C ) struct udevice * dev ; # endif chip = i2c_dp_last_chip ; addr = i2c_dp_last_addr ; alen = i2c_dp_last_alen ; length = i2c_dp_last_length ; if ( argc < 3 ) return CMD_RET_USAGE ; if ( ( flag & CMD_FLAG_REPEAT ) == 0 ) { chip = hextoul ( argv [ 1 ] , NULL ) ; addr = hextoul ( argv [ 2 ] , NULL ) ; alen = get_alen ( argv [ 2 ] , DEFAULT_ADDR_LEN ) ; if ( alen > 3 ) return CMD_RET_USAGE ; if ( argc > 3 ) length = hextoul ( argv [ 3 ] , NULL ) ; } # if CONFIG_IS_ENABLED ( DM_I2C ) ret = i2c_get_cur_bus_chip ( chip , & dev ) ; if ( ! ret && alen != - 1 ) ret = i2c_set_chip_offset_len ( dev , alen ) ; if ( ret ) return i2c_report_err ( ret , I2C_ERR_READ ) ; # endif nbytes = length ; do { unsigned char linebuf [ DISP_LINE_LEN ] ; unsigned char * cp ; linebytes = ( nbytes > DISP_LINE_LEN ) ? DISP_LINE_LEN : nbytes ; # if CONFIG_IS_ENABLED ( DM_I2C ) ret = dm_i2c_read ( dev , addr , linebuf , linebytes ) ; # else ret = i2c_read ( chip , addr , alen , linebuf , linebytes ) ; # endif if ( ret ) return i2c_report_err ( ret , I2C_ERR_READ ) ; else { printf ( \"%04x:\" , addr ) ; cp = linebuf ; for ( j = 0 ; j < linebytes ; j ++ ) { printf ( \"<S2SV_blank>%02x\" , * cp ++ ) ; addr ++ ; } puts ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" ) ; cp = linebuf ; for ( j = 0 ; j < linebytes ; j ++ ) { if ( ( * cp < 0x20 ) || ( * cp > 0x7e ) ) puts ( \".\" ) ; else printf ( \"%c\" , * cp ) ; cp ++ ; } putc ( '\\\\n' ) ; } nbytes -= linebytes ; } while ( nbytes > 0 ) ; i2c_dp_last_chip = chip ; i2c_dp_last_addr = addr ; i2c_dp_last_alen = alen ; i2c_dp_last_length = length ; return 0 ; }", "target": "<S2SV_ModStart> , length ; uint alen ; uint <S2SV_ModEnd> j , nbytes"}
{"source": "CWE-703 fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; enum mrb_fiber_state status ; mrb_value value ; fiber_check_cfunc ( mrb , c ) ; status = c -> status ; switch ( status ) { case MRB_FIBER_TRANSFERRED : if ( resume ) { mrb_raise ( mrb , E_FIBER_ERROR , \"resuming<S2SV_blank>transferred<S2SV_blank>fiber\" ) ; } break ; case MRB_FIBER_RUNNING : case MRB_FIBER_RESUMED : mrb_raise ( mrb , E_FIBER_ERROR , \"double<S2SV_blank>resume\" ) ; break ; case MRB_FIBER_TERMINATED : mrb_raise ( mrb , E_FIBER_ERROR , \"resuming<S2SV_blank>dead<S2SV_blank>fiber\" ) ; break ; default : break ; } old_c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( status == MRB_FIBER_CREATED ) { mrb_value * b , * e ; if ( ! c -> ci -> proc ) { mrb_raise ( mrb , E_FIBER_ERROR , \"double<S2SV_blank>resume<S2SV_blank>(current)\" ) ; } <S2SV_StartBug> mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_EndBug> b = c -> stbase + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } <S2SV_StartBug> if ( vmexec ) { <S2SV_EndBug> c -> ci -- ; } c -> cibase -> n = len ; value = c -> stbase [ 0 ] = MRB_PROC_ENV ( c -> cibase -> proc ) -> stack [ 0 ] ; } else { value = fiber_result ( mrb , a , len ) ; if ( vmexec ) { c -> ci [ 1 ] . stack [ 0 ] = value ; } } if ( vmexec ) { c -> vmexec = TRUE ; value = mrb_vm_exec ( mrb , c -> ci -> proc , c -> ci -> pc ) ; mrb -> c = old_c ; } else { MARK_CONTEXT_MODIFY ( c ) ; } return value ; }", "target": "<S2SV_ModStart> ) ; } if ( vmexec ) { c -> ci -- ; } if ( len >= 15 ) { mrb_stack_extend ( mrb , 3 ) ; c -> stbase [ 1 ] = mrb_ary_new_from_values ( mrb , len , a ) ; len = 15 ; } else { <S2SV_ModStart> ++ ; } <S2SV_ModEnd> } c ->"}
{"source": "CWE-787 MOBI_RET mobi_decode_infl ( unsigned char * decoded , int * decoded_size , const unsigned char * rule ) { int pos = * decoded_size ; char mod = 'i' ; char dir = '<' ; char olddir ; unsigned char c ; while ( ( c = * rule ++ ) ) { if ( c <= 4 ) { mod = ( c <= 2 ) ? 'i' : 'd' ; olddir = dir ; dir = ( c & 2 ) ? '<' : '>' ; if ( olddir != dir && olddir ) { pos = ( c & 2 ) ? * decoded_size : 0 ; } } else if ( c > 10 && c < 20 ) { if ( dir == '>' ) { pos = * decoded_size ; } pos -= c - 10 ; dir = 0 ; <S2SV_StartBug> if ( pos < 0 || pos > * decoded_size ) { <S2SV_EndBug> debug_print ( \"Position<S2SV_blank>setting<S2SV_blank>failed<S2SV_blank>(%s)\\\\n\" , decoded ) ; return MOBI_DATA_CORRUPT ; } } else { if ( mod == 'i' ) { const unsigned char * s = decoded + pos ; unsigned char * d = decoded + pos + 1 ; const int l = * decoded_size - pos ; <S2SV_StartBug> if ( l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX ) { <S2SV_EndBug> debug_print ( \"Out<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>pos:<S2SV_blank>%i\\\\n\" , decoded , pos ) ; return MOBI_DATA_CORRUPT ; } memmove ( d , s , ( size_t ) l ) ; decoded [ pos ] = c ; ( * decoded_size ) ++ ; if ( dir == '>' ) { pos ++ ; } } else { if ( dir == '<' ) { pos -- ; } const unsigned char * s = decoded + pos + 1 ; unsigned char * d = decoded + pos ; const int l = * decoded_size - pos ; <S2SV_StartBug> if ( l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX ) { <S2SV_EndBug> debug_print ( \"Out<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>pos:<S2SV_blank>%i\\\\n\" , decoded , pos ) ; return MOBI_DATA_CORRUPT ; } if ( decoded [ pos ] != c ) { debug_print ( \"Character<S2SV_blank>mismatch<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>pos:<S2SV_blank>%i<S2SV_blank>(%c<S2SV_blank>!=<S2SV_blank>%c)\\\\n\" , decoded , pos , decoded [ pos ] , c ) ; return MOBI_DATA_CORRUPT ; } memmove ( d , s , ( size_t ) l ) ; ( * decoded_size ) -- ; } } } return MOBI_SUCCESS ; }", "target": "<S2SV_ModStart> = 0 ; <S2SV_ModEnd> } else { <S2SV_ModStart> ; if ( pos < 0 || <S2SV_ModStart> ; if ( pos <S2SV_ModEnd> < 0 || <S2SV_ModStart> < 0 || l < 0 || s <S2SV_ModEnd> + l >"}
{"source": "CWE-787 ex_copy ( linenr_T line1 , linenr_T line2 , linenr_T n ) { linenr_T count ; char_u * p ; count = line2 - line1 + 1 ; if ( ( cmdmod . cmod_flags & CMOD_LOCKMARKS ) == 0 ) { curbuf -> b_op_start . lnum = n + 1 ; curbuf -> b_op_end . lnum = n + count ; curbuf -> b_op_start . col = curbuf -> b_op_end . col = 0 ; } if ( u_save ( n , n + 1 ) == FAIL ) return ; curwin -> w_cursor . lnum = n ; while ( line1 <= line2 ) { p = vim_strsave ( ml_get ( line1 ) ) ; if ( p != NULL ) { ml_append ( curwin -> w_cursor . lnum , p , ( colnr_T ) 0 , FALSE ) ; vim_free ( p ) ; } if ( line1 == n ) line1 = curwin -> w_cursor . lnum ; ++ line1 ; if ( curwin -> w_cursor . lnum < line1 ) ++ line1 ; if ( curwin -> w_cursor . lnum < line2 ) ++ line2 ; ++ curwin -> w_cursor . lnum ; } appended_lines_mark ( n , count ) ; <S2SV_StartBug> <S2SV_EndBug> msgmore ( ( long ) count ) ; }", "target": "<S2SV_ModStart> count ) ; if ( VIsual_active ) check_pos ( curbuf , & VIsual ) ;"}
{"source": "CWE-125 int xfrm_migrate ( const struct xfrm_selector * sel , u8 dir , u8 type , struct xfrm_migrate * m , int num_migrate , struct xfrm_kmaddress * k , struct net * net , struct xfrm_encap_tmpl * encap ) { int i , err , nx_cur = 0 , nx_new = 0 ; struct xfrm_policy * pol = NULL ; struct xfrm_state * x , * xc ; struct xfrm_state * x_cur [ XFRM_MAX_DEPTH ] ; struct xfrm_state * x_new [ XFRM_MAX_DEPTH ] ; struct xfrm_migrate * mp ; if ( ( err = xfrm_migrate_check ( m , num_migrate ) ) < 0 ) goto out ; <S2SV_StartBug> if ( ( pol = xfrm_migrate_policy_find ( sel , dir , type , net ) ) == NULL ) { <S2SV_EndBug> err = - ENOENT ; goto out ; } for ( i = 0 , mp = m ; i < num_migrate ; i ++ , mp ++ ) { if ( ( x = xfrm_migrate_state_find ( mp , net ) ) ) { x_cur [ nx_cur ] = x ; nx_cur ++ ; xc = xfrm_state_migrate ( x , mp , encap ) ; if ( xc ) { x_new [ nx_new ] = xc ; nx_new ++ ; } else { err = - ENODATA ; goto restore_state ; } } } if ( ( err = xfrm_policy_migrate ( pol , m , num_migrate ) ) < 0 ) goto restore_state ; if ( nx_cur ) { xfrm_states_put ( x_cur , nx_cur ) ; xfrm_states_delete ( x_cur , nx_cur ) ; } km_migrate ( sel , dir , type , m , num_migrate , k , encap ) ; xfrm_pol_put ( pol ) ; return 0 ; out : return err ; restore_state : if ( pol ) xfrm_pol_put ( pol ) ; if ( nx_cur ) xfrm_states_put ( x_cur , nx_cur ) ; if ( nx_new ) xfrm_states_delete ( x_new , nx_new ) ; return err ; }", "target": "<S2SV_ModStart> ; if ( dir >= XFRM_POLICY_MAX ) { err = - EINVAL ; goto out ; } if ("}
{"source": "CWE-787 mp_sint32 LoaderS3M : : load ( XMFileBase & f , XModule * module ) { module -> cleanUp ( ) ; TXMHeader * header = & module -> header ; TXMInstrument * instr = module -> instr ; TXMSample * smp = module -> smp ; TXMPattern * phead = module -> phead ; if ( ! phead || ! instr || ! smp ) return MP_OUT_OF_MEMORY ; f . read ( & header -> name , 1 , 28 ) ; header -> whythis1a = f . readByte ( ) ; if ( f . readByte ( ) != 16 ) return MP_LOADER_FAILED ; f . readByte ( ) ; f . readByte ( ) ; header -> ordnum = f . readWord ( ) ; mp_ubyte * orders = new mp_ubyte [ header -> ordnum ] ; if ( orders == NULL ) return MP_OUT_OF_MEMORY ; header -> insnum = f . readWord ( ) ; <S2SV_StartBug> header -> patnum = f . readWord ( ) ; <S2SV_EndBug> mp_sint32 flags = f . readWord ( ) ; mp_sint32 Cvt = f . readWord ( ) ; header -> flags = XModule : : MODULE_ST3NEWINSTRUMENT | XModule : : MODULE_ST3DUALCOMMANDS ; if ( Cvt == 0x1300 || ( flags & 64 ) ) header -> flags |= module -> MODULE_OLDS3MVOLSLIDES ; header -> flags |= module -> MODULE_ST3NOTECUT ; f . readWord ( ) ; f . read ( header -> sig , 1 , 4 ) ; header -> mainvol = module -> vol64to255 ( f . readByte ( ) ) ; header -> tempo = f . readByte ( ) ; header -> speed = f . readByte ( ) ; f . readByte ( ) ; f . readByte ( ) ; f . readByte ( ) ; f . readDword ( ) ; f . readDword ( ) ; f . readWord ( ) ; mp_ubyte channelSettings [ 32 ] ; f . read ( channelSettings , 1 , 32 ) ; mp_sint32 numChannels = 0 ; for ( numChannels = 0 ; numChannels < 32 ; numChannels ++ ) if ( channelSettings [ numChannels ] == 255 ) break ; header -> channum = numChannels ; f . read ( orders , 1 , header -> ordnum ) ; mp_sint32 j = 0 , i = 0 ; for ( i = 0 ; i < header -> ordnum ; i ++ ) { if ( orders [ i ] == 255 ) break ; header -> ord [ j ++ ] = orders [ i ] ; } header -> ordnum = j ; delete [ ] orders ; mp_uword * insParaPtrs = new mp_uword [ header -> insnum ] ; if ( insParaPtrs == NULL ) return MP_OUT_OF_MEMORY ; f . readWords ( insParaPtrs , header -> insnum ) ; mp_uword * patParaPtrs = new mp_uword [ header -> patnum ] ; if ( patParaPtrs == NULL ) { delete [ ] insParaPtrs ; return MP_OUT_OF_MEMORY ; } f . readWords ( patParaPtrs , header -> patnum ) ; mp_uint32 * samplePtrs = new mp_uint32 [ header -> insnum ] ; if ( samplePtrs == NULL ) { delete [ ] insParaPtrs ; delete [ ] patParaPtrs ; return MP_OUT_OF_MEMORY ; } memset ( samplePtrs , 0 , sizeof ( mp_uint32 ) * header -> insnum ) ; mp_sint32 s = 0 ; for ( i = 0 ; i < header -> insnum ; i ++ ) { mp_uint32 insOffs = insParaPtrs [ i ] * 16 ; if ( insOffs ) { f . seekWithBaseOffset ( insOffs ) ; mp_ubyte type = f . readByte ( ) ; if ( type == 1 ) { f . read ( smp [ s ] . name , 1 , 12 ) ; mp_ubyte bOffs = f . readByte ( ) ; mp_uword wOffs = f . readWord ( ) ; samplePtrs [ i ] = ( ( ( mp_uint32 ) bOffs << 16 ) + ( mp_uint32 ) wOffs ) * 16 ; smp [ s ] . flags = 1 ; smp [ s ] . pan = 0x80 ; smp [ s ] . samplen = f . readDword ( ) ; smp [ s ] . loopstart = f . readDword ( ) ; mp_sint32 looplen = ( ( mp_sint32 ) f . readDword ( ) - ( mp_sint32 ) smp [ s ] . loopstart ) ; if ( looplen < 0 ) looplen = 0 ; smp [ s ] . looplen = looplen ; smp [ s ] . vol = module -> vol64to255 ( f . readByte ( ) ) ; f . readByte ( ) ; smp [ s ] . res = f . readByte ( ) == 0x04 ? 0xAD : 0 ; mp_ubyte flags = f . readByte ( ) ; if ( flags & 1 ) { smp [ s ] . type = 1 ; } if ( flags & 4 ) { smp [ s ] . type |= 16 ; smp [ s ] . samplen >>= 1 ; smp [ s ] . loopstart >>= 1 ; smp [ s ] . looplen >>= 1 ; } mp_uint32 c4spd = f . readDword ( ) ; XModule : : convertc4spd ( c4spd , & smp [ s ] . finetune , & smp [ s ] . relnote ) ; # ifdef VERBOSE printf ( \"%i,<S2SV_blank>%i\\\\n\" , c4spd , module -> getc4spd ( smp [ s ] . relnote , smp [ s ] . finetune ) ) ; # endif f . readDword ( ) ; f . readDword ( ) ; f . readDword ( ) ; f . read ( instr [ i ] . name , 1 , 28 ) ; f . readDword ( ) ; if ( samplePtrs [ i ] && smp [ s ] . samplen ) { instr [ i ] . samp = 1 ; for ( j = 0 ; j < 120 ; j ++ ) instr [ i ] . snum [ j ] = s ; s ++ ; } } else if ( type == 0 ) { samplePtrs [ i ] = 0 ; mp_ubyte buffer [ 12 ] ; f . read ( buffer , 1 , 12 ) ; f . readByte ( ) ; f . readWord ( ) ; f . readDword ( ) ; f . readDword ( ) ; f . readDword ( ) ; f . readByte ( ) ; f . readByte ( ) ; f . readByte ( ) ; f . readByte ( ) ; f . readDword ( ) ; f . readDword ( ) ; f . readDword ( ) ; f . readDword ( ) ; f . read ( instr [ i ] . name , 1 , 28 ) ; f . readDword ( ) ; } else { samplePtrs [ i ] = 0 ; } } } mp_ubyte * pattern = new mp_ubyte [ 64 * 32 * 5 ] ; if ( pattern == NULL ) { delete [ ] insParaPtrs ; delete [ ] patParaPtrs ; delete [ ] samplePtrs ; return MP_OUT_OF_MEMORY ; } mp_uint32 songMaxChannels = 1 ; for ( i = 0 ; i < header -> patnum ; i ++ ) { for ( j = 0 ; j < 32 * 64 ; j ++ ) { pattern [ j * 5 ] = 0xFF ; pattern [ j * 5 + 1 ] = 0 ; pattern [ j * 5 + 2 ] = 0xFF ; pattern [ j * 5 + 3 ] = 0xFF ; pattern [ j * 5 + 4 ] = 0 ; } mp_uint32 patOffs = patParaPtrs [ i ] * 16 ; mp_uint32 maxChannels = 1 ; if ( patOffs ) { f . seekWithBaseOffset ( patOffs ) ; mp_uint32 size = f . readWord ( ) ; if ( size > 2 ) { size -= 2 ; mp_ubyte * packed = new mp_ubyte [ size + 5 ] ; if ( packed == NULL ) { delete [ ] insParaPtrs ; delete [ ] patParaPtrs ; delete [ ] samplePtrs ; delete [ ] pattern ; return MP_OUT_OF_MEMORY ; } memset ( packed , 0 , size ) ; f . read ( packed , 1 , size ) ; mp_uint32 index = 0 ; mp_uint32 row = 0 ; while ( index < size ) { mp_ubyte pi = safeRead ( packed , index , size ) ; if ( pi == 0 ) { row ++ ; if ( row >= 64 ) { int i = 0 ; i ++ ; i -- ; break ; } continue ; } mp_uint32 chn = pi & 31 ; if ( chn > maxChannels && ( pi & ( 32 + 64 + 128 ) ) ) { maxChannels = chn ; } mp_ubyte * slot = pattern + ( row * 32 * 5 ) + chn * 5 ; if ( pi & 32 ) { slot [ 0 ] = safeRead ( packed , index , size , 0xFF ) ; slot [ 1 ] = safeRead ( packed , index , size ) ; } if ( pi & 64 ) { slot [ 2 ] = safeRead ( packed , index , size , 0xFF ) ; } if ( pi & 128 ) { slot [ 3 ] = safeRead ( packed , index , size , 0xFF ) ; slot [ 4 ] = safeRead ( packed , index , size ) ; } } maxChannels ++ ; if ( maxChannels > header -> channum ) maxChannels = header -> channum ; delete [ ] packed ; } if ( maxChannels > songMaxChannels ) songMaxChannels = maxChannels ; } convertS3MPattern ( & phead [ i ] , pattern , maxChannels , i ) ; } if ( header -> channum > songMaxChannels ) header -> channum = songMaxChannels ; delete [ ] pattern ; delete [ ] insParaPtrs ; delete [ ] patParaPtrs ; s = 0 ; for ( i = 0 ; i < header -> insnum ; i ++ ) { mp_uint32 smpOffs = samplePtrs [ i ] ; if ( smpOffs ) { f . seekWithBaseOffset ( smpOffs ) ; if ( ! smp [ s ] . samplen ) continue ; bool adpcm = ( smp [ s ] . res == 0xAD ) ; mp_sint32 result = module -> loadModuleSample ( f , s , adpcm ? XModule : : ST_PACKING_ADPCM : XModule : : ST_UNSIGNED , adpcm ? ( XModule : : ST_16BIT | XModule : : ST_PACKING_ADPCM ) : ( XModule : : ST_16BIT | XModule : : ST_UNSIGNED ) ) ; if ( result != MP_OK ) { delete [ ] samplePtrs ; return result ; } if ( adpcm ) smp [ s ] . res = 0 ; s ++ ; } } delete [ ] samplePtrs ; header -> smpnum = s ; strcpy ( header -> tracker , \"Screamtracker<S2SV_blank>3\" ) ; module -> setDefaultPanning ( ) ; module -> postProcessSamples ( ) ; return MP_OK ; }", "target": "<S2SV_ModStart> ( ) ; if ( header -> insnum > MP_MAXINS ) return MP_LOADER_FAILED ; <S2SV_ModStart> readWord ( ) ; if ( header -> patnum > 256 ) return MP_LOADER_FAILED"}
{"source": "CWE-189 int CLASS ljpeg_start ( struct jhead * jh , int info_only ) { <S2SV_StartBug> int c , tag , len ; <S2SV_EndBug> uchar data [ 0x10000 ] ; const uchar * dp ; memset ( jh , 0 , sizeof * jh ) ; jh -> restart = INT_MAX ; fread ( data , 2 , 1 , ifp ) ; if ( data [ 1 ] != 0xd8 ) return 0 ; do { fread ( data , 2 , 2 , ifp ) ; tag = data [ 0 ] << 8 | data [ 1 ] ; len = ( data [ 2 ] << 8 | data [ 3 ] ) - 2 ; if ( tag <= 0xff00 ) return 0 ; fread ( data , 1 , len , ifp ) ; switch ( tag ) { case 0xffc3 : jh -> sraw = ( ( data [ 7 ] >> 4 ) * ( data [ 7 ] & 15 ) - 1 ) & 3 ; case 0xffc0 : jh -> bits = data [ 0 ] ; jh -> high = data [ 1 ] << 8 | data [ 2 ] ; jh -> wide = data [ 3 ] << 8 | data [ 4 ] ; jh -> clrs = data [ 5 ] + jh -> sraw ; if ( len == 9 && ! dng_version ) getc ( ifp ) ; break ; case 0xffc4 : if ( info_only ) break ; for ( dp = data ; dp < data + len && ( c = * dp ++ ) < 4 ; ) jh -> free [ c ] = jh -> huff [ c ] = make_decoder_ref ( & dp ) ; break ; case 0xffda : jh -> psv = data [ 1 + data [ 0 ] * 2 ] ; jh -> bits -= data [ 3 + data [ 0 ] * 2 ] & 15 ; break ; case 0xffdd : jh -> restart = data [ 0 ] << 8 | data [ 1 ] ; } } while ( tag != 0xffda ) ; if ( info_only ) return 1 ; if ( jh -> clrs > 6 || ! jh -> huff [ 0 ] ) return 0 ; FORC ( 5 ) if ( ! jh -> huff [ c + 1 ] ) jh -> huff [ c + 1 ] = jh -> huff [ c ] ; if ( jh -> sraw ) { FORC ( 4 ) jh -> huff [ 2 + c ] = jh -> huff [ 1 ] ; FORC ( jh -> sraw ) jh -> huff [ 1 + c ] = jh -> huff [ 0 ] ; } jh -> row = ( ushort * ) calloc ( jh -> wide * jh -> clrs , 4 ) ; merror ( jh -> row , \"ljpeg_start()\" ) ; return zero_after_ff = 1 ; }", "target": "<S2SV_ModStart> c , tag ; ushort <S2SV_ModEnd> len ; uchar"}
{"source": "CWE-401 static int rsi_send_beacon ( struct rsi_common * common ) { struct sk_buff * skb = NULL ; u8 dword_align_bytes = 0 ; skb = dev_alloc_skb ( MAX_MGMT_PKT_SIZE ) ; if ( ! skb ) return - ENOMEM ; memset ( skb -> data , 0 , MAX_MGMT_PKT_SIZE ) ; dword_align_bytes = ( ( unsigned long ) skb -> data & 0x3f ) ; if ( dword_align_bytes ) skb_pull ( skb , ( 64 - dword_align_bytes ) ) ; if ( rsi_prepare_beacon ( common , skb ) ) { rsi_dbg ( ERR_ZONE , \"Failed<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>beacon\\\\n\" ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } skb_queue_tail ( & common -> tx_queue [ MGMT_BEACON_Q ] , skb ) ; rsi_set_event ( & common -> tx_thread . event ) ; rsi_dbg ( DATA_TX_ZONE , \"%s:<S2SV_blank>Added<S2SV_blank>to<S2SV_blank>beacon<S2SV_blank>queue\\\\n\" , __func__ ) ; return 0 ; }", "target": "<S2SV_ModStart> \"Failed<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>beacon\\\\n\" ) ; dev_kfree_skb ( skb ) ;"}
{"source": "CWE-125 static ptrdiff_t finderrfunc ( lua_State * L ) { cTValue * frame = L -> base - 1 , * bot = tvref ( L -> stack ) ; void * cf = L -> cframe ; while ( frame > bot && cf ) { while ( cframe_nres ( cframe_raw ( cf ) ) < 0 ) { if ( frame >= restorestack ( L , - cframe_nres ( cf ) ) ) break ; if ( cframe_errfunc ( cf ) >= 0 ) return cframe_errfunc ( cf ) ; cf = cframe_prev ( cf ) ; if ( cf == NULL ) return 0 ; } switch ( frame_typep ( frame ) ) { case FRAME_LUA : case FRAME_LUAP : frame = frame_prevl ( frame ) ; break ; case FRAME_C : cf = cframe_prev ( cf ) ; case FRAME_VARG : frame = frame_prevd ( frame ) ; break ; case FRAME_CONT : # if LJ_HASFFI if ( ( frame - 1 ) -> u32 . lo == LJ_CONT_FFI_CALLBACK ) cf = cframe_prev ( cf ) ; # endif frame = frame_prevd ( frame ) ; break ; case FRAME_CP : if ( cframe_canyield ( cf ) ) return 0 ; if ( cframe_errfunc ( cf ) >= 0 ) return cframe_errfunc ( cf ) ; <S2SV_StartBug> frame = frame_prevd ( frame ) ; <S2SV_EndBug> break ; case FRAME_PCALL : case FRAME_PCALLH : if ( frame_ftsz ( frame ) >= ( ptrdiff_t ) ( 2 * sizeof ( TValue ) ) ) return savestack ( L , frame - 1 ) ; return 0 ; default : lua_assert ( 0 ) ; return 0 ; } } return 0 ; }", "target": "<S2SV_ModStart> cf ) ; cf = cframe_prev ( cf ) ;"}
{"source": "CWE-125 RList * r_bin_ne_get_entrypoints ( r_bin_ne_obj_t * bin ) { if ( ! bin -> entry_table ) { return NULL ; } RList * entries = r_list_newf ( free ) ; if ( ! entries ) { return NULL ; } RList * segments = r_bin_ne_get_segments ( bin ) ; if ( ! segments ) { r_list_free ( entries ) ; return NULL ; } if ( bin -> ne_header -> csEntryPoint ) { RBinAddr * entry = R_NEW0 ( RBinAddr ) ; if ( ! entry ) { r_list_free ( entries ) ; return NULL ; } entry -> bits = 16 ; ut32 entry_cs = bin -> ne_header -> csEntryPoint ; RBinSection * s = r_list_get_n ( segments , entry_cs - 1 ) ; entry -> paddr = bin -> ne_header -> ipEntryPoint + ( s ? s -> paddr : 0 ) ; r_list_append ( entries , entry ) ; } int off = 0 ; size_t tableat = bin -> header_offset + bin -> ne_header -> EntryTableOffset ; while ( off < bin -> ne_header -> EntryTableLength ) { if ( tableat + off >= r_buf_size ( bin -> buf ) ) { break ; } ut8 bundle_length = * ( ut8 * ) ( bin -> entry_table + off ) ; if ( ! bundle_length ) { break ; } off ++ ; ut8 bundle_type = * ( ut8 * ) ( bin -> entry_table + off ) ; off ++ ; int i ; for ( i = 0 ; i < bundle_length ; i ++ ) { if ( tableat + off + 4 >= r_buf_size ( bin -> buf ) ) { break ; } RBinAddr * entry = R_NEW0 ( RBinAddr ) ; if ( ! entry ) { r_list_free ( entries ) ; return NULL ; } off ++ ; if ( ! bundle_type ) { off -- ; free ( entry ) ; break ; } else if ( bundle_type == 0xff ) { off += 2 ; ut8 segnum = * ( bin -> entry_table + off ) ; off ++ ; <S2SV_StartBug> ut16 segoff = * ( ut16 * ) ( bin -> entry_table + off ) ; <S2SV_EndBug> <S2SV_StartBug> if ( segnum > 0 ) { <S2SV_EndBug> entry -> paddr = ( ut64 ) bin -> segment_entries [ segnum - 1 ] . offset * bin -> alignment + segoff ; } } else { <S2SV_StartBug> if ( bundle_type < bin -> ne_header -> SegCount ) { <S2SV_EndBug> entry -> paddr = ( ut64 ) bin -> segment_entries [ bundle_type - 1 ] . offset <S2SV_StartBug> * bin -> alignment + * ( ut16 * ) ( bin -> entry_table + off ) ; <S2SV_EndBug> } } off += 2 ; r_list_append ( entries , entry ) ; } } r_list_free ( segments ) ; bin -> entries = entries ; return entries ; }", "target": "<S2SV_ModStart> off ++ ; if ( off > bin -> ne_header -> EntryTableLength ) { break ; } <S2SV_ModStart> ut16 segoff = r_read_le16 <S2SV_ModEnd> ( bin -> <S2SV_ModStart> segnum > 0 && segnum < bin -> ne_header -> SegCount <S2SV_ModStart> { if ( off + 2 >= bin -> ne_header -> EntryTableLength ) { break ; } ut16 delta = r_read_le16 ( bin -> entry_table + off ) ; if ( <S2SV_ModStart> -> alignment + delta <S2SV_ModEnd> ; } }"}
{"source": "CWE-125 SWTPM_NVRAM_CheckHeader ( unsigned char * data , uint32_t length , uint32_t * dataoffset , uint16_t * hdrflags , uint8_t * hdrversion , bool quiet ) { <S2SV_StartBug> blobheader * bh = ( blobheader * ) data ; <S2SV_EndBug> if ( length < sizeof ( bh ) ) { if ( ! quiet ) logprintf ( STDERR_FILENO , \"not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>header:<S2SV_blank>%u\\\\n\" , length ) ; return TPM_BAD_PARAMETER ; } if ( ntohl ( bh -> totlen ) != length ) { if ( ! quiet ) logprintf ( STDERR_FILENO , \"broken<S2SV_blank>header:<S2SV_blank>bh->totlen<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\\\n\" , htonl ( bh -> totlen ) , length ) ; return TPM_BAD_PARAMETER ; } if ( bh -> min_version > BLOB_HEADER_VERSION ) { if ( ! quiet ) logprintf ( STDERR_FILENO , \"Minimum<S2SV_blank>required<S2SV_blank>version<S2SV_blank>for<S2SV_blank>the<S2SV_blank>blob<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>we<S2SV_blank>\" \"only<S2SV_blank>support<S2SV_blank>version<S2SV_blank>%d\\\\n\" , bh -> min_version , BLOB_HEADER_VERSION ) ; return TPM_BAD_VERSION ; } <S2SV_StartBug> * hdrversion = bh -> version ; <S2SV_EndBug> <S2SV_StartBug> * dataoffset = ntohs ( bh -> hdrsize ) ; <S2SV_EndBug> * hdrflags = ntohs ( bh -> flags ) ; return TPM_SUCCESS ; }", "target": "<S2SV_ModStart> * ) data ; uint16_t hdrsize <S2SV_ModStart> TPM_BAD_VERSION ; } hdrsize = ntohs ( bh -> hdrsize ) ; if ( hdrsize != sizeof ( blobheader ) ) { logprintf ( STDERR_FILENO , \"bad<S2SV_blank>header<S2SV_blank>size:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%zu\\\\n\" , hdrsize , sizeof ( blobheader ) ) ; return TPM_BAD_DATASIZE ; } <S2SV_ModStart> * dataoffset = hdrsize ; * hdrflags = <S2SV_ModStart> ( bh -> <S2SV_ModEnd> flags ) ;"}
{"source": "CWE-362 static int snd_pcm_oss_sync ( struct snd_pcm_oss_file * pcm_oss_file ) { int err = 0 ; unsigned int saved_f_flags ; struct snd_pcm_substream * substream ; struct snd_pcm_runtime * runtime ; snd_pcm_format_t format ; unsigned long width ; size_t size ; substream = pcm_oss_file -> streams [ SNDRV_PCM_STREAM_PLAYBACK ] ; if ( substream != NULL ) { runtime = substream -> runtime ; if ( atomic_read ( & substream -> mmap_count ) ) goto __direct ; <S2SV_StartBug> err = snd_pcm_oss_make_ready ( substream ) ; <S2SV_EndBug> if ( err < 0 ) return err ; atomic_inc ( & runtime -> oss . rw_ref ) ; if ( mutex_lock_interruptible ( & runtime -> oss . params_lock ) ) { atomic_dec ( & runtime -> oss . rw_ref ) ; return - ERESTARTSYS ; <S2SV_StartBug> } <S2SV_EndBug> format = snd_pcm_oss_format_from ( runtime -> oss . format ) ; width = snd_pcm_format_physical_width ( format ) ; if ( runtime -> oss . buffer_used > 0 ) { # ifdef OSS_DEBUG pcm_dbg ( substream -> pcm , \"sync:<S2SV_blank>buffer_used\\\\n\" ) ; # endif size = ( 8 * ( runtime -> oss . period_bytes - runtime -> oss . buffer_used ) + 7 ) / width ; snd_pcm_format_set_silence ( format , runtime -> oss . buffer + runtime -> oss . buffer_used , size ) ; err = snd_pcm_oss_sync1 ( substream , runtime -> oss . period_bytes ) ; if ( err < 0 ) goto unlock ; } else if ( runtime -> oss . period_ptr > 0 ) { # ifdef OSS_DEBUG pcm_dbg ( substream -> pcm , \"sync:<S2SV_blank>period_ptr\\\\n\" ) ; # endif size = runtime -> oss . period_bytes - runtime -> oss . period_ptr ; snd_pcm_format_set_silence ( format , runtime -> oss . buffer , size * 8 / width ) ; err = snd_pcm_oss_sync1 ( substream , size ) ; if ( err < 0 ) goto unlock ; } size = runtime -> control -> appl_ptr % runtime -> period_size ; if ( size > 0 ) { size = runtime -> period_size - size ; if ( runtime -> access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ) snd_pcm_lib_write ( substream , NULL , size ) ; else if ( runtime -> access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED ) snd_pcm_lib_writev ( substream , NULL , size ) ; } unlock : mutex_unlock ( & runtime -> oss . params_lock ) ; atomic_dec ( & runtime -> oss . rw_ref ) ; if ( err < 0 ) return err ; __direct : saved_f_flags = substream -> f_flags ; substream -> f_flags &= ~ O_NONBLOCK ; err = snd_pcm_kernel_ioctl ( substream , SNDRV_PCM_IOCTL_DRAIN , NULL ) ; substream -> f_flags = saved_f_flags ; if ( err < 0 ) return err ; mutex_lock ( & runtime -> oss . params_lock ) ; runtime -> oss . prepare = 1 ; mutex_unlock ( & runtime -> oss . params_lock ) ; } substream = pcm_oss_file -> streams [ SNDRV_PCM_STREAM_CAPTURE ] ; if ( substream != NULL ) { err = snd_pcm_oss_make_ready ( substream ) ; if ( err < 0 ) return err ; runtime = substream -> runtime ; err = snd_pcm_kernel_ioctl ( substream , SNDRV_PCM_IOCTL_DROP , NULL ) ; if ( err < 0 ) return err ; mutex_lock ( & runtime -> oss . params_lock ) ; runtime -> oss . buffer_used = 0 ; runtime -> oss . prepare = 1 ; mutex_unlock ( & runtime -> oss . params_lock ) ; } return 0 ; }", "target": "<S2SV_ModStart> goto __direct ; <S2SV_ModEnd> atomic_inc ( & <S2SV_ModStart> ERESTARTSYS ; } err = snd_pcm_oss_make_ready_locked ( substream ) ; if ( err < 0 ) goto unlock ;"}
{"source": "CWE-415 static void rtrs_clt_dev_release ( struct device * dev ) { struct rtrs_clt_sess * clt = container_of ( dev , struct rtrs_clt_sess , dev ) ; <S2SV_StartBug> kfree ( clt ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> dev ) ; mutex_destroy ( & clt -> paths_ev_mutex ) ; mutex_destroy ( & clt -> paths_mutex ) ;"}
{"source": "CWE-22 inbound_cap_ls ( server * serv , char * nick , char * extensions_str , const message_tags_data * tags_data ) { char buffer [ 256 ] ; <S2SV_StartBug> guint32 want_cap ; <S2SV_EndBug> guint32 want_sasl ; char * * extensions ; int i ; EMIT_SIGNAL_TIMESTAMP ( XP_TE_CAPLIST , serv -> server_session , nick , extensions_str , NULL , NULL , 0 , tags_data -> timestamp ) ; <S2SV_StartBug> want_cap = 0 ; <S2SV_EndBug> want_sasl = 0 ; extensions = g_strsplit ( extensions_str , \"<S2SV_blank>\" , 0 ) ; strcpy ( buffer , \"CAP<S2SV_blank>REQ<S2SV_blank>:\" ) ; for ( i = 0 ; extensions [ i ] ; i ++ ) { const char * extension = extensions [ i ] ; <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> if ( ! strcmp ( extension , \"identify-msg\" ) ) <S2SV_EndBug> { strcat ( buffer , \"identify-msg<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"multi-prefix\" ) ) { strcat ( buffer , \"multi-prefix<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"away-notify\" ) ) { strcat ( buffer , \"away-notify<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"account-notify\" ) ) { strcat ( buffer , \"account-notify<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"extended-join\" ) ) { strcat ( buffer , \"extended-join<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"userhost-in-names\" ) ) { strcat ( buffer , \"userhost-in-names<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"znc.in/server-time-iso\" ) ) { strcat ( buffer , \"znc.in/server-time-iso<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"znc.in/server-time\" ) ) { strcat ( buffer , \"znc.in/server-time<S2SV_blank>\" ) ; want_cap = 1 ; } if ( prefs . hex_irc_cap_server_time && ! strcmp ( extension , \"server-time\" ) ) { strcat ( buffer , \"server-time<S2SV_blank>\" ) ; want_cap = 1 ; } if ( ! strcmp ( extension , \"sasl\" ) && ( ( serv -> loginmethod == LOGIN_SASL && strlen ( serv -> password ) != 0 ) || ( serv -> loginmethod == LOGIN_SASLEXTERNAL && serv -> have_cert ) ) ) { <S2SV_StartBug> strcat ( buffer , \"sasl<S2SV_blank>\" ) ; <S2SV_EndBug> <S2SV_StartBug> want_cap = 1 ; <S2SV_EndBug> want_sasl = 1 ; } } g_strfreev ( extensions ) ; if ( want_cap ) { EMIT_SIGNAL_TIMESTAMP ( XP_TE_CAPREQ , serv -> server_session , buffer + 9 , NULL , NULL , NULL , 0 , tags_data -> timestamp ) ; tcp_sendf ( serv , \"%s\\\\r\\\\n\" , g_strchomp ( buffer ) ) ; } if ( ! want_sasl ) { serv -> sent_capend = TRUE ; tcp_send_len ( serv , \"CAP<S2SV_blank>END\\\\r\\\\n\" , 9 ) ; } }", "target": "<S2SV_ModStart> 256 ] ; gboolean want_cap = FALSE ; gboolean want_sasl = FALSE <S2SV_ModEnd> ; char * <S2SV_ModStart> timestamp ) ; <S2SV_ModEnd> extensions = g_strsplit <S2SV_ModStart> i ] ; gsize x ; <S2SV_ModStart> if ( ! g_strcmp0 <S2SV_ModEnd> ( extension , <S2SV_ModStart> ( extension , \"sasl\" ) && <S2SV_ModEnd> ( ( serv <S2SV_ModStart> ) ) { want_cap = TRUE ; want_sasl = TRUE ; g_strlcat <S2SV_ModEnd> ( buffer , <S2SV_ModStart> buffer , \"sasl<S2SV_blank>\" , sizeof ( buffer ) ) ; continue ; } for ( x = 0 ; x < G_N_ELEMENTS ( supported_caps ) ; ++ x ) { if ( ! g_strcmp0 ( extension , supported_caps [ x ] ) ) { g_strlcat ( buffer , extension , sizeof ( buffer ) ) ; g_strlcat ( buffer , \"<S2SV_blank>\" , sizeof ( buffer ) <S2SV_ModStart> ; want_cap = TRUE ; } <S2SV_ModEnd> } } g_strfreev"}
{"source": "CWE-444 size_t puma_parser_execute ( puma_parser * parser , const char * buffer , size_t len , size_t off ) { const char * p , * pe ; int cs = parser -> cs ; assert ( off <= len && \"offset<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer\" ) ; p = buffer + off ; pe = buffer + len ; assert ( ( size_t ) ( pe - p ) == len - off && \"pointers<S2SV_blank>aren\\'t<S2SV_blank>same<S2SV_blank>distance\" ) ; # line 87 \"ext/puma_http11/http11_parser.c\" { if ( p == pe ) goto _test_eof ; switch ( cs ) { case 1 : switch ( ( * p ) ) { case 36 : goto tr0 ; case 95 : goto tr0 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto tr0 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto tr0 ; } else goto tr0 ; goto st0 ; st0 : cs = 0 ; goto _out ; tr0 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st2 ; st2 : if ( ++ p == pe ) goto _test_eof2 ; case 2 : # line 118 \"ext/puma_http11/http11_parser.c\" switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st27 ; case 95 : goto st27 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st27 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st27 ; } else goto st27 ; goto st0 ; tr2 : # line 50 \"ext/puma_http11/http11_parser.rl\" { parser -> request_method ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st3 ; st3 : if ( ++ p == pe ) goto _test_eof3 ; case 3 : # line 143 \"ext/puma_http11/http11_parser.c\" switch ( ( * p ) ) { case 42 : goto tr4 ; case 43 : goto tr5 ; case 47 : goto tr6 ; case 58 : goto tr7 ; } if ( ( * p ) < 65 ) { if ( 45 <= ( * p ) && ( * p ) <= 57 ) goto tr5 ; } else if ( ( * p ) > 90 ) { if ( 97 <= ( * p ) && ( * p ) <= 122 ) goto tr5 ; } else goto tr5 ; goto st0 ; tr4 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st4 ; st4 : if ( ++ p == pe ) goto _test_eof4 ; case 4 : # line 167 \"ext/puma_http11/http11_parser.c\" switch ( ( * p ) ) { case 32 : goto tr8 ; case 35 : goto tr9 ; } goto st0 ; tr8 : # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st5 ; tr31 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } # line 56 \"ext/puma_http11/http11_parser.rl\" { parser -> fragment ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st5 ; tr33 : # line 56 \"ext/puma_http11/http11_parser.rl\" { parser -> fragment ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st5 ; tr37 : # line 69 \"ext/puma_http11/http11_parser.rl\" { parser -> request_path ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st5 ; tr41 : # line 60 \"ext/puma_http11/http11_parser.rl\" { MARK ( query_start , p ) ; } # line 61 \"ext/puma_http11/http11_parser.rl\" { parser -> query_string ( parser , PTR_TO ( query_start ) , LEN ( query_start , p ) ) ; } # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st5 ; tr44 : # line 61 \"ext/puma_http11/http11_parser.rl\" { parser -> query_string ( parser , PTR_TO ( query_start ) , LEN ( query_start , p ) ) ; } # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st5 ; st5 : if ( ++ p == pe ) goto _test_eof5 ; case 5 : # line 229 \"ext/puma_http11/http11_parser.c\" if ( ( * p ) == 72 ) goto tr10 ; goto st0 ; tr10 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st6 ; st6 : if ( ++ p == pe ) goto _test_eof6 ; case 6 : # line 241 \"ext/puma_http11/http11_parser.c\" if ( ( * p ) == 84 ) goto st7 ; goto st0 ; st7 : if ( ++ p == pe ) goto _test_eof7 ; case 7 : if ( ( * p ) == 84 ) goto st8 ; goto st0 ; st8 : if ( ++ p == pe ) goto _test_eof8 ; case 8 : if ( ( * p ) == 80 ) goto st9 ; goto st0 ; st9 : if ( ++ p == pe ) goto _test_eof9 ; case 9 : if ( ( * p ) == 47 ) goto st10 ; goto st0 ; st10 : if ( ++ p == pe ) goto _test_eof10 ; case 10 : if ( 48 <= ( * p ) && ( * p ) <= 57 ) goto st11 ; goto st0 ; st11 : if ( ++ p == pe ) goto _test_eof11 ; case 11 : if ( ( * p ) == 46 ) goto st12 ; if ( 48 <= ( * p ) && ( * p ) <= 57 ) goto st11 ; goto st0 ; st12 : if ( ++ p == pe ) goto _test_eof12 ; case 12 : if ( 48 <= ( * p ) && ( * p ) <= 57 ) goto st13 ; goto st0 ; st13 : if ( ++ p == pe ) goto _test_eof13 ; case 13 : if ( ( * p ) == 13 ) goto tr18 ; if ( 48 <= ( * p ) && ( * p ) <= 57 ) goto st13 ; goto st0 ; tr18 : # line 65 \"ext/puma_http11/http11_parser.rl\" { parser -> http_version ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st14 ; tr26 : # line 46 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } # line 47 \"ext/puma_http11/http11_parser.rl\" { parser -> http_field ( parser , PTR_TO ( field_start ) , parser -> field_len , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st14 ; tr29 : # line 47 \"ext/puma_http11/http11_parser.rl\" { parser -> http_field ( parser , PTR_TO ( field_start ) , parser -> field_len , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st14 ; st14 : if ( ++ p == pe ) goto _test_eof14 ; case 14 : # line 322 \"ext/puma_http11/http11_parser.c\" if ( ( * p ) == 10 ) goto st15 ; goto st0 ; st15 : if ( ++ p == pe ) goto _test_eof15 ; case 15 : switch ( ( * p ) ) { case 13 : goto st16 ; case 33 : goto tr21 ; case 124 : goto tr21 ; case 126 : goto tr21 ; } if ( ( * p ) < 45 ) { if ( ( * p ) > 39 ) { if ( 42 <= ( * p ) && ( * p ) <= 43 ) goto tr21 ; } else if ( ( * p ) >= 35 ) goto tr21 ; } else if ( ( * p ) > 46 ) { if ( ( * p ) < 65 ) { if ( 48 <= ( * p ) && ( * p ) <= 57 ) goto tr21 ; } else if ( ( * p ) > 90 ) { if ( 94 <= ( * p ) && ( * p ) <= 122 ) goto tr21 ; } else goto tr21 ; } else goto tr21 ; goto st0 ; st16 : if ( ++ p == pe ) goto _test_eof16 ; case 16 : if ( ( * p ) == 10 ) goto tr22 ; goto st0 ; tr22 : # line 73 \"ext/puma_http11/http11_parser.rl\" { parser -> body_start = p - buffer + 1 ; parser -> header_done ( parser , p + 1 , pe - p - 1 ) ; { p ++ ; cs = 46 ; goto _out ; } } goto st46 ; st46 : if ( ++ p == pe ) goto _test_eof46 ; case 46 : # line 373 \"ext/puma_http11/http11_parser.c\" goto st0 ; tr21 : # line 40 \"ext/puma_http11/http11_parser.rl\" { MARK ( field_start , p ) ; } # line 41 \"ext/puma_http11/http11_parser.rl\" { snake_upcase_char ( ( char * ) p ) ; } goto st17 ; tr23 : # line 41 \"ext/puma_http11/http11_parser.rl\" { snake_upcase_char ( ( char * ) p ) ; } goto st17 ; st17 : if ( ++ p == pe ) goto _test_eof17 ; case 17 : # line 389 \"ext/puma_http11/http11_parser.c\" switch ( ( * p ) ) { case 33 : goto tr23 ; case 58 : goto tr24 ; case 124 : goto tr23 ; case 126 : goto tr23 ; } if ( ( * p ) < 45 ) { if ( ( * p ) > 39 ) { if ( 42 <= ( * p ) && ( * p ) <= 43 ) goto tr23 ; } else if ( ( * p ) >= 35 ) goto tr23 ; } else if ( ( * p ) > 46 ) { if ( ( * p ) < 65 ) { if ( 48 <= ( * p ) && ( * p ) <= 57 ) goto tr23 ; } else if ( ( * p ) > 90 ) { if ( 94 <= ( * p ) && ( * p ) <= 122 ) goto tr23 ; } else goto tr23 ; } else goto tr23 ; goto st0 ; tr24 : # line 42 \"ext/puma_http11/http11_parser.rl\" { parser -> field_len = LEN ( field_start , p ) ; } goto st18 ; tr27 : # line 46 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st18 ; st18 : if ( ++ p == pe ) goto _test_eof18 ; case 18 : # line 428 \"ext/puma_http11/http11_parser.c\" switch ( ( * p ) ) { <S2SV_StartBug> case 13 : goto tr26 ; <S2SV_EndBug> case 32 : goto tr27 ; } <S2SV_StartBug> goto tr25 ; <S2SV_EndBug> tr25 : # line 46 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st19 ; st19 : if ( ++ p == pe ) goto _test_eof19 ; case 19 : <S2SV_StartBug> # line 442 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> if ( ( * p ) == 13 ) goto tr29 ; <S2SV_StartBug> goto st19 ; <S2SV_EndBug> tr9 : # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st20 ; tr38 : # line 69 \"ext/puma_http11/http11_parser.rl\" { parser -> request_path ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st20 ; tr42 : # line 60 \"ext/puma_http11/http11_parser.rl\" { MARK ( query_start , p ) ; } # line 61 \"ext/puma_http11/http11_parser.rl\" { parser -> query_string ( parser , PTR_TO ( query_start ) , LEN ( query_start , p ) ) ; } # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st20 ; tr45 : # line 61 \"ext/puma_http11/http11_parser.rl\" { parser -> query_string ( parser , PTR_TO ( query_start ) , LEN ( query_start , p ) ) ; } # line 53 \"ext/puma_http11/http11_parser.rl\" { parser -> request_uri ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st20 ; st20 : if ( ++ p == pe ) goto _test_eof20 ; case 20 : <S2SV_StartBug> # line 488 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> switch ( ( * p ) ) { case 32 : goto tr31 ; case 60 : goto st0 ; case 62 : goto st0 ; case 127 : goto st0 ; } if ( ( * p ) > 31 ) { if ( 34 <= ( * p ) && ( * p ) <= 35 ) goto st0 ; } else if ( ( * p ) >= 0 ) goto st0 ; goto tr30 ; tr30 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st21 ; st21 : if ( ++ p == pe ) goto _test_eof21 ; case 21 : <S2SV_StartBug> # line 509 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> switch ( ( * p ) ) { case 32 : goto tr33 ; case 60 : goto st0 ; case 62 : goto st0 ; case 127 : goto st0 ; } if ( ( * p ) > 31 ) { if ( 34 <= ( * p ) && ( * p ) <= 35 ) goto st0 ; } else if ( ( * p ) >= 0 ) goto st0 ; goto st21 ; tr5 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st22 ; st22 : if ( ++ p == pe ) goto _test_eof22 ; case 22 : <S2SV_StartBug> # line 530 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> switch ( ( * p ) ) { case 43 : goto st22 ; case 58 : goto st23 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st22 ; } else if ( ( * p ) > 57 ) { if ( ( * p ) > 90 ) { if ( 97 <= ( * p ) && ( * p ) <= 122 ) goto st22 ; } else if ( ( * p ) >= 65 ) goto st22 ; } else goto st22 ; goto st0 ; tr7 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st23 ; st23 : if ( ++ p == pe ) goto _test_eof23 ; case 23 : <S2SV_StartBug> # line 555 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> switch ( ( * p ) ) { case 32 : goto tr8 ; case 34 : goto st0 ; case 35 : goto tr9 ; case 60 : goto st0 ; case 62 : goto st0 ; case 127 : goto st0 ; } if ( 0 <= ( * p ) && ( * p ) <= 31 ) goto st0 ; goto st23 ; tr6 : # line 37 \"ext/puma_http11/http11_parser.rl\" { MARK ( mark , p ) ; } goto st24 ; st24 : if ( ++ p == pe ) goto _test_eof24 ; case 24 : <S2SV_StartBug> # line 575 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> switch ( ( * p ) ) { case 32 : goto tr37 ; case 34 : goto st0 ; case 35 : goto tr38 ; case 60 : goto st0 ; case 62 : goto st0 ; case 63 : goto tr39 ; case 127 : goto st0 ; } if ( 0 <= ( * p ) && ( * p ) <= 31 ) goto st0 ; goto st24 ; tr39 : # line 69 \"ext/puma_http11/http11_parser.rl\" { parser -> request_path ( parser , PTR_TO ( mark ) , LEN ( mark , p ) ) ; } goto st25 ; st25 : if ( ++ p == pe ) goto _test_eof25 ; case 25 : <S2SV_StartBug> # line 598 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> switch ( ( * p ) ) { case 32 : goto tr41 ; case 34 : goto st0 ; case 35 : goto tr42 ; case 60 : goto st0 ; case 62 : goto st0 ; case 127 : goto st0 ; } if ( 0 <= ( * p ) && ( * p ) <= 31 ) goto st0 ; goto tr40 ; tr40 : # line 60 \"ext/puma_http11/http11_parser.rl\" { MARK ( query_start , p ) ; } goto st26 ; st26 : if ( ++ p == pe ) goto _test_eof26 ; case 26 : <S2SV_StartBug> # line 618 \"ext/puma_http11/http11_parser.c\" <S2SV_EndBug> switch ( ( * p ) ) { case 32 : goto tr44 ; case 34 : goto st0 ; case 35 : goto tr45 ; case 60 : goto st0 ; case 62 : goto st0 ; case 127 : goto st0 ; } if ( 0 <= ( * p ) && ( * p ) <= 31 ) goto st0 ; goto st26 ; st27 : if ( ++ p == pe ) goto _test_eof27 ; case 27 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st28 ; case 95 : goto st28 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st28 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st28 ; } else goto st28 ; goto st0 ; st28 : if ( ++ p == pe ) goto _test_eof28 ; case 28 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st29 ; case 95 : goto st29 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st29 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st29 ; } else goto st29 ; goto st0 ; st29 : if ( ++ p == pe ) goto _test_eof29 ; case 29 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st30 ; case 95 : goto st30 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st30 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st30 ; } else goto st30 ; goto st0 ; st30 : if ( ++ p == pe ) goto _test_eof30 ; case 30 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st31 ; case 95 : goto st31 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st31 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st31 ; } else goto st31 ; goto st0 ; st31 : if ( ++ p == pe ) goto _test_eof31 ; case 31 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st32 ; case 95 : goto st32 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st32 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st32 ; } else goto st32 ; goto st0 ; st32 : if ( ++ p == pe ) goto _test_eof32 ; case 32 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st33 ; case 95 : goto st33 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st33 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st33 ; } else goto st33 ; goto st0 ; st33 : if ( ++ p == pe ) goto _test_eof33 ; case 33 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st34 ; case 95 : goto st34 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st34 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st34 ; } else goto st34 ; goto st0 ; st34 : if ( ++ p == pe ) goto _test_eof34 ; case 34 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st35 ; case 95 : goto st35 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st35 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st35 ; } else goto st35 ; goto st0 ; st35 : if ( ++ p == pe ) goto _test_eof35 ; case 35 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st36 ; case 95 : goto st36 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st36 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st36 ; } else goto st36 ; goto st0 ; st36 : if ( ++ p == pe ) goto _test_eof36 ; case 36 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st37 ; case 95 : goto st37 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st37 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st37 ; } else goto st37 ; goto st0 ; st37 : if ( ++ p == pe ) goto _test_eof37 ; case 37 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st38 ; case 95 : goto st38 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st38 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st38 ; } else goto st38 ; goto st0 ; st38 : if ( ++ p == pe ) goto _test_eof38 ; case 38 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st39 ; case 95 : goto st39 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st39 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st39 ; } else goto st39 ; goto st0 ; st39 : if ( ++ p == pe ) goto _test_eof39 ; case 39 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st40 ; case 95 : goto st40 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st40 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st40 ; } else goto st40 ; goto st0 ; st40 : if ( ++ p == pe ) goto _test_eof40 ; case 40 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st41 ; case 95 : goto st41 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st41 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st41 ; } else goto st41 ; goto st0 ; st41 : if ( ++ p == pe ) goto _test_eof41 ; case 41 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st42 ; case 95 : goto st42 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st42 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st42 ; } else goto st42 ; goto st0 ; st42 : if ( ++ p == pe ) goto _test_eof42 ; case 42 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st43 ; case 95 : goto st43 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st43 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st43 ; } else goto st43 ; goto st0 ; st43 : if ( ++ p == pe ) goto _test_eof43 ; case 43 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st44 ; case 95 : goto st44 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st44 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st44 ; } else goto st44 ; goto st0 ; st44 : if ( ++ p == pe ) goto _test_eof44 ; case 44 : switch ( ( * p ) ) { case 32 : goto tr2 ; case 36 : goto st45 ; case 95 : goto st45 ; } if ( ( * p ) < 48 ) { if ( 45 <= ( * p ) && ( * p ) <= 46 ) goto st45 ; } else if ( ( * p ) > 57 ) { if ( 65 <= ( * p ) && ( * p ) <= 90 ) goto st45 ; } else goto st45 ; goto st0 ; st45 : if ( ++ p == pe ) goto _test_eof45 ; case 45 : if ( ( * p ) == 32 ) goto tr2 ; goto st0 ; } _test_eof2 : cs = 2 ; goto _test_eof ; _test_eof3 : cs = 3 ; goto _test_eof ; _test_eof4 : cs = 4 ; goto _test_eof ; _test_eof5 : cs = 5 ; goto _test_eof ; _test_eof6 : cs = 6 ; goto _test_eof ; _test_eof7 : cs = 7 ; goto _test_eof ; _test_eof8 : cs = 8 ; goto _test_eof ; _test_eof9 : cs = 9 ; goto _test_eof ; _test_eof10 : cs = 10 ; goto _test_eof ; _test_eof11 : cs = 11 ; goto _test_eof ; _test_eof12 : cs = 12 ; goto _test_eof ; _test_eof13 : cs = 13 ; goto _test_eof ; _test_eof14 : cs = 14 ; goto _test_eof ; _test_eof15 : cs = 15 ; goto _test_eof ; _test_eof16 : cs = 16 ; goto _test_eof ; _test_eof46 : cs = 46 ; goto _test_eof ; _test_eof17 : cs = 17 ; goto _test_eof ; _test_eof18 : cs = 18 ; goto _test_eof ; _test_eof19 : cs = 19 ; goto _test_eof ; _test_eof20 : cs = 20 ; goto _test_eof ; _test_eof21 : cs = 21 ; goto _test_eof ; _test_eof22 : cs = 22 ; goto _test_eof ; _test_eof23 : cs = 23 ; goto _test_eof ; _test_eof24 : cs = 24 ; goto _test_eof ; _test_eof25 : cs = 25 ; goto _test_eof ; _test_eof26 : cs = 26 ; goto _test_eof ; _test_eof27 : cs = 27 ; goto _test_eof ; _test_eof28 : cs = 28 ; goto _test_eof ; _test_eof29 : cs = 29 ; goto _test_eof ; _test_eof30 : cs = 30 ; goto _test_eof ; _test_eof31 : cs = 31 ; goto _test_eof ; _test_eof32 : cs = 32 ; goto _test_eof ; _test_eof33 : cs = 33 ; goto _test_eof ; _test_eof34 : cs = 34 ; goto _test_eof ; _test_eof35 : cs = 35 ; goto _test_eof ; _test_eof36 : cs = 36 ; goto _test_eof ; _test_eof37 : cs = 37 ; goto _test_eof ; _test_eof38 : cs = 38 ; goto _test_eof ; _test_eof39 : cs = 39 ; goto _test_eof ; _test_eof40 : cs = 40 ; goto _test_eof ; _test_eof41 : cs = 41 ; goto _test_eof ; _test_eof42 : cs = 42 ; goto _test_eof ; _test_eof43 : cs = 43 ; goto _test_eof ; _test_eof44 : cs = 44 ; goto _test_eof ; _test_eof45 : cs = 45 ; goto _test_eof ; _test_eof : { } _out : { } } # line 117 \"ext/puma_http11/http11_parser.rl\" if ( ! puma_parser_has_error ( parser ) ) parser -> cs = cs ; parser -> nread += p - ( buffer + off ) ; assert ( p <= pe && \"buffer<S2SV_blank>overflow<S2SV_blank>after<S2SV_blank>parsing<S2SV_blank>execute\" ) ; assert ( parser -> nread <= len && \"nread<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>length\" ) ; assert ( parser -> body_start <= len && \"body<S2SV_blank>starts<S2SV_blank>after<S2SV_blank>buffer<S2SV_blank>end\" ) ; assert ( parser -> mark < len && \"mark<S2SV_blank>is<S2SV_blank>after<S2SV_blank>buffer<S2SV_blank>end\" ) ; assert ( parser -> field_len <= len && \"field<S2SV_blank>has<S2SV_blank>length<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>whole<S2SV_blank>buffer\" ) ; assert ( parser -> field_start < len && \"field<S2SV_blank>starts<S2SV_blank>after<S2SV_blank>buffer<S2SV_blank>end\" ) ; return ( parser -> nread ) ; }", "target": "<S2SV_ModStart> ) { case 9 : goto tr25 ; case <S2SV_ModStart> tr27 ; } if ( 33 <= ( * p ) && ( * p ) <= 126 ) goto tr25 ; goto st0 <S2SV_ModEnd> ; tr25 : <S2SV_ModStart> : # line 445 \"ext/puma_http11/http11_parser.c\" switch ( ( * p ) ) { case 9 : goto st19 ; case 13 : <S2SV_ModEnd> goto tr29 ; <S2SV_ModStart> goto tr29 ; } if ( 32 <= ( * p ) && ( * p ) <= 126 ) goto st19 ; goto st0 <S2SV_ModEnd> ; tr9 : <S2SV_ModStart> : # line 495 <S2SV_ModEnd> \"ext/puma_http11/http11_parser.c\" switch ( <S2SV_ModStart> : # line 516 <S2SV_ModEnd> \"ext/puma_http11/http11_parser.c\" switch ( <S2SV_ModStart> : # line 537 <S2SV_ModEnd> \"ext/puma_http11/http11_parser.c\" switch ( <S2SV_ModStart> : # line 562 <S2SV_ModEnd> \"ext/puma_http11/http11_parser.c\" switch ( <S2SV_ModStart> : # line 582 <S2SV_ModEnd> \"ext/puma_http11/http11_parser.c\" switch ( <S2SV_ModStart> : # line 605 <S2SV_ModEnd> \"ext/puma_http11/http11_parser.c\" switch ( <S2SV_ModStart> : # line 625 <S2SV_ModEnd> \"ext/puma_http11/http11_parser.c\" switch ("}
{"source": "CWE-476 gif_internal_decode_frame ( gif_animation * gif , unsigned int frame , bool clear_image ) { unsigned int index = 0 ; const unsigned char * gif_data , * gif_end ; ssize_t gif_bytes ; unsigned int width , height , offset_x , offset_y ; unsigned int flags , colour_table_size , interlace ; unsigned int * colour_table ; unsigned int * frame_data = 0 ; unsigned int * frame_scanline ; ssize_t save_buffer_position ; unsigned int return_value = 0 ; unsigned int x , y , decode_y , burst_bytes ; register unsigned char colour ; <S2SV_StartBug> if ( gif -> frames [ frame ] . display == false ) { <S2SV_EndBug> return GIF_OK ; } if ( frame > gif -> frame_count_partial ) { return GIF_INSUFFICIENT_DATA ; } if ( ( ! clear_image ) && ( ( int ) frame == gif -> decoded_frame ) ) { return GIF_OK ; } gif_data = gif -> gif_data + gif -> frames [ frame ] . frame_pointer ; gif_end = gif -> gif_data + gif -> buffer_size ; gif_bytes = ( gif_end - gif_data ) ; if ( gif_bytes < 12 ) { return GIF_INSUFFICIENT_FRAME_DATA ; } save_buffer_position = gif -> buffer_position ; gif -> buffer_position = gif_data - gif -> gif_data ; if ( ( return_value = gif_skip_frame_extensions ( gif ) ) != GIF_OK ) { goto gif_decode_frame_exit ; } gif_data = ( gif -> gif_data + gif -> buffer_position ) ; gif_bytes = ( gif_end - gif_data ) ; if ( gif_bytes < 12 ) { return_value = GIF_INSUFFICIENT_FRAME_DATA ; goto gif_decode_frame_exit ; } if ( gif_data [ 0 ] != GIF_IMAGE_SEPARATOR ) { return_value = GIF_DATA_ERROR ; goto gif_decode_frame_exit ; } offset_x = gif_data [ 1 ] | ( gif_data [ 2 ] << 8 ) ; offset_y = gif_data [ 3 ] | ( gif_data [ 4 ] << 8 ) ; width = gif_data [ 5 ] | ( gif_data [ 6 ] << 8 ) ; height = gif_data [ 7 ] | ( gif_data [ 8 ] << 8 ) ; if ( ( offset_x + width > gif -> width ) || ( offset_y + height > gif -> height ) ) { return_value = GIF_DATA_ERROR ; goto gif_decode_frame_exit ; } flags = gif_data [ 9 ] ; colour_table_size = 2 << ( flags & GIF_COLOUR_TABLE_SIZE_MASK ) ; interlace = flags & GIF_INTERLACE_MASK ; gif_data += 10 ; gif_bytes = ( gif_end - gif_data ) ; if ( flags & GIF_COLOUR_TABLE_MASK ) { if ( gif_bytes < ( int ) ( 3 * colour_table_size ) ) { return_value = GIF_INSUFFICIENT_FRAME_DATA ; goto gif_decode_frame_exit ; } colour_table = gif -> local_colour_table ; if ( ! clear_image ) { for ( index = 0 ; index < colour_table_size ; index ++ ) { unsigned char * entry = ( unsigned char * ) & colour_table [ index ] ; entry [ 0 ] = gif_data [ 0 ] ; entry [ 1 ] = gif_data [ 1 ] ; entry [ 2 ] = gif_data [ 2 ] ; entry [ 3 ] = 0xff ; gif_data += 3 ; } } else { gif_data += 3 * colour_table_size ; } gif_bytes = ( gif_end - gif_data ) ; } else { colour_table = gif -> global_colour_table ; } if ( gif_bytes < 1 ) { return_value = GIF_INSUFFICIENT_FRAME_DATA ; goto gif_decode_frame_exit ; } if ( gif_data [ 0 ] == GIF_TRAILER ) { return_value = GIF_OK ; goto gif_decode_frame_exit ; } assert ( gif -> bitmap_callbacks . bitmap_get_buffer ) ; frame_data = ( void * ) gif -> bitmap_callbacks . bitmap_get_buffer ( gif -> frame_image ) ; if ( ! frame_data ) { return GIF_INSUFFICIENT_MEMORY ; } if ( ! clear_image ) { lzw_result res ; const uint8_t * stack_base ; const uint8_t * stack_pos ; if ( gif_bytes < 2 ) { return_value = GIF_INSUFFICIENT_FRAME_DATA ; goto gif_decode_frame_exit ; } if ( ( gif_bytes == 2 ) && ( gif_data [ 1 ] == GIF_TRAILER ) ) { return_value = GIF_OK ; goto gif_decode_frame_exit ; } if ( ( frame == 0 ) || ( gif -> decoded_frame == GIF_INVALID_FRAME ) ) { memset ( ( char * ) frame_data , GIF_TRANSPARENT_COLOUR , gif -> width * gif -> height * sizeof ( int ) ) ; gif -> decoded_frame = frame ; } else if ( ( frame != 0 ) && ( gif -> frames [ frame - 1 ] . disposal_method == GIF_FRAME_CLEAR ) ) { return_value = gif_internal_decode_frame ( gif , ( frame - 1 ) , true ) ; if ( return_value != GIF_OK ) { goto gif_decode_frame_exit ; } } else if ( ( frame != 0 ) && ( gif -> frames [ frame - 1 ] . disposal_method == GIF_FRAME_RESTORE ) ) { int last_undisposed_frame = frame - 2 ; while ( ( last_undisposed_frame >= 0 ) && ( gif -> frames [ last_undisposed_frame ] . disposal_method == GIF_FRAME_RESTORE ) ) { last_undisposed_frame -- ; } if ( last_undisposed_frame == - 1 ) { memset ( ( char * ) frame_data , GIF_TRANSPARENT_COLOUR , gif -> width * gif -> height * sizeof ( int ) ) ; } else { return_value = gif_internal_decode_frame ( gif , last_undisposed_frame , false ) ; if ( return_value != GIF_OK ) { goto gif_decode_frame_exit ; } assert ( gif -> bitmap_callbacks . bitmap_get_buffer ) ; frame_data = ( void * ) gif -> bitmap_callbacks . bitmap_get_buffer ( gif -> frame_image ) ; if ( ! frame_data ) { return GIF_INSUFFICIENT_MEMORY ; } } } gif -> decoded_frame = frame ; gif -> buffer_position = ( gif_data - gif -> gif_data ) + 1 ; res = lzw_decode_init ( gif -> lzw_ctx , gif -> gif_data , gif -> buffer_size , gif -> buffer_position , gif_data [ 0 ] , & stack_base , & stack_pos ) ; if ( res != LZW_OK ) { return gif_error_from_lzw ( res ) ; } for ( y = 0 ; y < height ; y ++ ) { if ( interlace ) { decode_y = gif_interlaced_line ( height , y ) + offset_y ; } else { decode_y = y + offset_y ; } frame_scanline = frame_data + offset_x + ( decode_y * gif -> width ) ; x = width ; while ( x > 0 ) { burst_bytes = ( stack_pos - stack_base ) ; if ( burst_bytes > 0 ) { if ( burst_bytes > x ) { burst_bytes = x ; } x -= burst_bytes ; while ( burst_bytes -- > 0 ) { colour = * -- stack_pos ; if ( ( ( gif -> frames [ frame ] . transparency ) && ( colour != gif -> frames [ frame ] . transparency_index ) ) || ( ! gif -> frames [ frame ] . transparency ) ) { * frame_scanline = colour_table [ colour ] ; } frame_scanline ++ ; } } else { res = lzw_decode ( gif -> lzw_ctx , & stack_pos ) ; if ( res != LZW_OK ) { if ( res == LZW_OK_EOD ) { return_value = GIF_OK ; } else { return_value = gif_error_from_lzw ( res ) ; } goto gif_decode_frame_exit ; } } } } } else { if ( gif -> frames [ frame ] . disposal_method == GIF_FRAME_CLEAR ) { for ( y = 0 ; y < height ; y ++ ) { frame_scanline = frame_data + offset_x + ( ( offset_y + y ) * gif -> width ) ; if ( gif -> frames [ frame ] . transparency ) { memset ( frame_scanline , GIF_TRANSPARENT_COLOUR , width * 4 ) ; } else { memset ( frame_scanline , colour_table [ gif -> background_index ] , width * 4 ) ; } } } } gif_decode_frame_exit : if ( gif -> frames [ frame ] . virgin ) { if ( gif -> bitmap_callbacks . bitmap_test_opaque ) { gif -> frames [ frame ] . opaque = gif -> bitmap_callbacks . bitmap_test_opaque ( gif -> frame_image ) ; } else { gif -> frames [ frame ] . opaque = false ; } gif -> frames [ frame ] . virgin = false ; } if ( gif -> bitmap_callbacks . bitmap_set_opaque ) { gif -> bitmap_callbacks . bitmap_set_opaque ( gif -> frame_image , gif -> frames [ frame ] . opaque ) ; } if ( gif -> bitmap_callbacks . bitmap_modified ) { gif -> bitmap_callbacks . bitmap_modified ( gif -> frame_image ) ; } gif -> buffer_position = save_buffer_position ; return return_value ; }", "target": "<S2SV_ModStart> gif -> frames == NULL ) { return GIF_INSUFFICIENT_DATA ; } if ( gif -> frames"}
{"source": "CWE-125 PJ_DEF ( int ) pj_scan_get_char ( pj_scanner * scanner ) { <S2SV_StartBug> int chr = * scanner -> curptr ; <S2SV_EndBug> <S2SV_StartBug> <S2SV_EndBug> if ( ! chr ) { pj_scan_syntax_err ( scanner ) ; return 0 ; } <S2SV_StartBug> ++ scanner -> curptr ; <S2SV_EndBug> <S2SV_StartBug> if ( PJ_SCAN_IS_PROBABLY_SPACE ( * scanner -> curptr ) && scanner -> skip_ws ) { <S2SV_EndBug> pj_scan_skip_whitespace ( scanner ) ; } return chr ; }", "target": "<S2SV_ModStart> scanner ) { register char * s = <S2SV_ModEnd> scanner -> curptr <S2SV_ModStart> -> curptr ; int chr ; if ( s >= scanner -> end || ! * s <S2SV_ModEnd> ) { pj_scan_syntax_err <S2SV_ModStart> 0 ; } chr = * s ; ++ s ; <S2SV_ModEnd> scanner -> curptr <S2SV_ModStart> scanner -> curptr = s <S2SV_ModStart> ; if ( PJ_SCAN_CHECK_EOF ( s ) && <S2SV_ModStart> PJ_SCAN_IS_PROBABLY_SPACE ( * s <S2SV_ModEnd> ) && scanner"}
{"source": "CWE-476 static bool load_buffer ( RBinFile * bf , void * * bin_obj , RBuffer * buf , ut64 loadaddr , Sdb * sdb ) { RBuffer * fbuf = r_buf_ref ( buf ) ; struct MACH0_ ( opts_t ) opts ; MACH0_ ( opts_set_default ) ( & opts , bf ) ; struct MACH0_ ( obj_t ) * main_mach0 = MACH0_ ( new_buf ) ( fbuf , & opts ) ; if ( ! main_mach0 ) { return false ; } RRebaseInfo * rebase_info = r_rebase_info_new_from_mach0 ( fbuf , main_mach0 ) ; RKernelCacheObj * obj = NULL ; RPrelinkRange * prelink_range = get_prelink_info_range_from_mach0 ( main_mach0 ) ; if ( ! prelink_range ) { goto beach ; } obj = R_NEW0 ( RKernelCacheObj ) ; if ( ! obj ) { R_FREE ( prelink_range ) ; goto beach ; } RCFValueDict * prelink_info = NULL ; if ( main_mach0 -> hdr . filetype != MH_FILESET && prelink_range -> range . size ) { prelink_info = r_cf_value_dict_parse ( fbuf , prelink_range -> range . offset , prelink_range -> range . size , R_CF_OPTION_SKIP_NSDATA ) ; if ( ! prelink_info ) { R_FREE ( prelink_range ) ; R_FREE ( obj ) ; goto beach ; } } if ( ! pending_bin_files ) { pending_bin_files = r_list_new ( ) ; if ( ! pending_bin_files ) { R_FREE ( prelink_range ) ; R_FREE ( obj ) ; R_FREE ( prelink_info ) ; goto beach ; } } obj -> mach0 = main_mach0 ; obj -> rebase_info = rebase_info ; obj -> prelink_info = prelink_info ; obj -> cache_buf = fbuf ; obj -> pa2va_exec = prelink_range -> pa2va_exec ; obj -> pa2va_data = prelink_range -> pa2va_data ; R_FREE ( prelink_range ) ; * bin_obj = obj ; r_list_push ( pending_bin_files , bf ) ; if ( rebase_info || main_mach0 -> chained_starts ) { RIO * io = bf -> rbin -> iob . io ; swizzle_io_read ( obj , io ) ; } return true ; beach : r_buf_free ( fbuf ) ; <S2SV_StartBug> obj -> cache_buf = NULL ; <S2SV_EndBug> MACH0_ ( mach0_free ) ( main_mach0 ) ; return false ; }", "target": "<S2SV_ModStart> fbuf ) ; if ( obj ) { <S2SV_ModStart> = NULL ; }"}
{"source": "CWE-787 ex_retab ( exarg_T * eap ) { linenr_T lnum ; int got_tab = FALSE ; long num_spaces = 0 ; long num_tabs ; long len ; long col ; long vcol ; long start_col = 0 ; long start_vcol = 0 ; long old_len ; char_u * ptr ; char_u * new_line = ( char_u * ) 1 ; int did_undo ; # ifdef FEAT_VARTABS int * new_vts_array = NULL ; char_u * new_ts_str ; # else int temp ; int new_ts ; # endif int save_list ; linenr_T first_line = 0 ; linenr_T last_line = 0 ; save_list = curwin -> w_p_list ; curwin -> w_p_list = 0 ; # ifdef FEAT_VARTABS new_ts_str = eap -> arg ; if ( tabstop_set ( eap -> arg , & new_vts_array ) == FAIL ) return ; while ( vim_isdigit ( * ( eap -> arg ) ) || * ( eap -> arg ) == ',' ) ++ ( eap -> arg ) ; if ( new_vts_array == NULL ) { new_vts_array = curbuf -> b_p_vts_array ; new_ts_str = NULL ; } else new_ts_str = vim_strnsave ( new_ts_str , eap -> arg - new_ts_str ) ; # else ptr = eap -> arg ; new_ts = getdigits ( & ptr ) ; if ( new_ts < 0 && * eap -> arg == '-' ) { emsg ( _ ( e_argument_must_be_positive ) ) ; return ; } if ( new_ts < 0 || new_ts > TABSTOP_MAX ) { semsg ( _ ( e_invalid_argument_str ) , eap -> arg ) ; return ; } if ( new_ts == 0 ) new_ts = curbuf -> b_p_ts ; # endif for ( lnum = eap -> line1 ; ! got_int && lnum <= eap -> line2 ; ++ lnum ) { ptr = ml_get ( lnum ) ; col = 0 ; vcol = 0 ; did_undo = FALSE ; for ( ; ; ) { if ( VIM_ISWHITE ( ptr [ col ] ) ) { if ( ! got_tab && num_spaces == 0 ) { start_vcol = vcol ; start_col = col ; } if ( ptr [ col ] == '<S2SV_blank>' ) num_spaces ++ ; else got_tab = TRUE ; } else { if ( got_tab || ( eap -> forceit && num_spaces > 1 ) ) { len = num_spaces = vcol - start_vcol ; num_tabs = 0 ; if ( ! curbuf -> b_p_et ) { # ifdef FEAT_VARTABS int t , s ; tabstop_fromto ( start_vcol , vcol , curbuf -> b_p_ts , new_vts_array , & t , & s ) ; num_tabs = t ; num_spaces = s ; # else temp = new_ts - ( start_vcol % new_ts ) ; if ( num_spaces >= temp ) { num_spaces -= temp ; num_tabs ++ ; } num_tabs += num_spaces / new_ts ; num_spaces -= ( num_spaces / new_ts ) * new_ts ; # endif } if ( curbuf -> b_p_et || got_tab || ( num_spaces + num_tabs < len ) ) { if ( did_undo == FALSE ) { did_undo = TRUE ; if ( u_save ( ( linenr_T ) ( lnum - 1 ) , ( linenr_T ) ( lnum + 1 ) ) == FAIL ) { new_line = NULL ; break ; } } len = num_spaces + num_tabs ; old_len = ( long ) STRLEN ( ptr ) ; new_line = alloc ( old_len - col + start_col + len + 1 ) ; if ( new_line == NULL ) break ; if ( start_col > 0 ) mch_memmove ( new_line , ptr , ( size_t ) start_col ) ; mch_memmove ( new_line + start_col + len , ptr + col , ( size_t ) ( old_len - col + 1 ) ) ; ptr = new_line + start_col ; for ( col = 0 ; col < len ; col ++ ) ptr [ col ] = ( col < num_tabs ) ? '\\\\t' : '<S2SV_blank>' ; if ( ml_replace ( lnum , new_line , FALSE ) == OK ) new_line = curbuf -> b_ml . ml_line_ptr ; if ( first_line == 0 ) first_line = lnum ; last_line = lnum ; ptr = new_line ; col = start_col + len ; } } got_tab = FALSE ; num_spaces = 0 ; } if ( ptr [ col ] == NUL ) break ; vcol += chartabsize ( ptr + col , ( colnr_T ) vcol ) ; <S2SV_StartBug> if ( has_mbyte ) <S2SV_EndBug> col += ( * mb_ptr2len ) ( ptr + col ) ; else ++ col ; } if ( new_line == NULL ) break ; line_breakcheck ( ) ; } if ( got_int ) emsg ( _ ( e_interrupted ) ) ; # ifdef FEAT_VARTABS if ( tabstop_count ( curbuf -> b_p_vts_array ) == 0 && tabstop_count ( new_vts_array ) == 1 && curbuf -> b_p_ts == tabstop_first ( new_vts_array ) ) ; else if ( tabstop_count ( curbuf -> b_p_vts_array ) > 0 && tabstop_eq ( curbuf -> b_p_vts_array , new_vts_array ) ) ; else redraw_curbuf_later ( NOT_VALID ) ; # else if ( curbuf -> b_p_ts != new_ts ) redraw_curbuf_later ( NOT_VALID ) ; # endif if ( first_line != 0 ) changed_lines ( first_line , 0 , last_line + 1 , 0L ) ; curwin -> w_p_list = save_list ; # ifdef FEAT_VARTABS if ( new_ts_str != NULL ) { int * old_vts_ary = curbuf -> b_p_vts_array ; if ( tabstop_count ( old_vts_ary ) > 0 || tabstop_count ( new_vts_array ) > 1 ) { set_string_option_direct ( ( char_u * ) \"vts\" , - 1 , new_ts_str , OPT_FREE | OPT_LOCAL , 0 ) ; curbuf -> b_p_vts_array = new_vts_array ; vim_free ( old_vts_ary ) ; } else { curbuf -> b_p_ts = tabstop_first ( new_vts_array ) ; vim_free ( new_vts_array ) ; } vim_free ( new_ts_str ) ; } # else curbuf -> b_p_ts = new_ts ; # endif coladvance ( curwin -> w_curswant ) ; u_clearline ( ) ; }", "target": "<S2SV_ModStart> ; if ( vcol >= MAXCOL ) { emsg ( _ ( e_resulting_text_too_long ) ) ; break ; } if ("}
{"source": "CWE-787 mp_sint32 LoaderXM : : load ( XMFileBase & f , XModule * module ) { mp_ubyte insData [ 230 ] ; mp_sint32 smpReloc [ MP_MAXINSSAMPS ] ; mp_ubyte nbu [ MP_MAXINSSAMPS ] ; mp_uint32 fileSize = 0 ; module -> cleanUp ( ) ; TXMHeader * header = & module -> header ; TXMInstrument * instr = module -> instr ; TXMSample * smp = module -> smp ; TXMPattern * phead = module -> phead ; if ( ! phead || ! instr || ! smp ) return MP_OUT_OF_MEMORY ; fileSize = f . sizeWithBaseOffset ( ) ; f . read ( & header -> sig , 1 , 17 ) ; f . read ( & header -> name , 1 , 20 ) ; f . read ( & header -> whythis1a , 1 , 1 ) ; header -> whythis1a = 0 ; f . read ( & header -> tracker , 1 , 20 ) ; f . readWords ( & header -> ver , 1 ) ; if ( header -> ver != 0x102 && header -> ver != 0x103 && header -> ver != 0x104 ) return MP_LOADER_FAILED ; f . readDwords ( & header -> hdrsize , 1 ) ; header -> hdrsize -= 4 ; mp_uint32 hdrSize = 0x110 ; if ( header -> hdrsize > hdrSize ) hdrSize = header -> hdrsize ; mp_ubyte * hdrBuff = new mp_ubyte [ hdrSize ] ; memset ( hdrBuff , 0 , hdrSize ) ; f . read ( hdrBuff , 1 , header -> hdrsize ) ; header -> ordnum = LittleEndian : : GET_WORD ( hdrBuff ) ; header -> restart = LittleEndian : : GET_WORD ( hdrBuff + 2 ) ; header -> channum = LittleEndian : : GET_WORD ( hdrBuff + 4 ) ; header -> patnum = LittleEndian : : GET_WORD ( hdrBuff + 6 ) ; header -> insnum = LittleEndian : : GET_WORD ( hdrBuff + 8 ) ; header -> freqtab = LittleEndian : : GET_WORD ( hdrBuff + 10 ) ; header -> tempo = LittleEndian : : GET_WORD ( hdrBuff + 12 ) ; header -> speed = LittleEndian : : GET_WORD ( hdrBuff + 14 ) ; memcpy ( header -> ord , hdrBuff + 16 , 256 ) ; if ( header -> ordnum > MP_MAXORDERS ) header -> ordnum = MP_MAXORDERS ; if ( header -> insnum > MP_MAXINS ) return MP_LOADER_FAILED ; delete [ ] hdrBuff ; header -> mainvol = 255 ; header -> flags = XModule : : MODULE_XMNOTECLIPPING | XModule : : MODULE_XMARPEGGIO | XModule : : MODULE_XMPORTANOTEBUFFER | XModule : : MODULE_XMVOLCOLUMNVIBRATO ; header -> uppernotebound = 119 ; mp_sint32 i , y , sc ; for ( i = 0 ; i < 32 ; i ++ ) header -> pan [ i ] = 0x80 ; if ( header -> ver == 0x102 || header -> ver == 0x103 ) { mp_sint32 s = 0 ; mp_sint32 e = 0 ; for ( y = 0 ; y < header -> insnum ; y ++ ) { f . readDwords ( & instr [ y ] . size , 1 ) ; f . read ( & instr [ y ] . name , 1 , 22 ) ; f . read ( & instr [ y ] . type , 1 , 1 ) ; mp_uword numSamples = 0 ; f . readWords ( & numSamples , 1 ) ; if ( numSamples > MP_MAXINSSAMPS ) return MP_LOADER_FAILED ; instr [ y ] . samp = numSamples ; if ( instr [ y ] . size == 29 ) { # ifdef MILKYTRACKER s += 16 ; # endif for ( mp_sint32 i = 0 ; i < 120 ; i ++ ) instr [ y ] . snum [ i ] = - 1 ; continue ; } f . readDwords ( & instr [ y ] . shsize , 1 ) ; memset ( insData , 0 , 230 ) ; if ( instr [ y ] . size - 33 > 230 ) return MP_OUT_OF_MEMORY ; f . read ( insData , 1 , instr [ y ] . size - 33 ) ; if ( instr [ y ] . samp ) { mp_ubyte * insDataPtr = insData ; memcpy ( nbu , insDataPtr , MP_MAXINSSAMPS ) ; insDataPtr += MP_MAXINSSAMPS ; TEnvelope venv ; TEnvelope penv ; memset ( & venv , 0 , sizeof ( venv ) ) ; memset ( & penv , 0 , sizeof ( penv ) ) ; mp_sint32 k ; for ( k = 0 ; k < XM_ENVELOPENUMPOINTS ; k ++ ) { venv . env [ k ] [ 0 ] = LittleEndian : : GET_WORD ( insDataPtr ) ; venv . env [ k ] [ 1 ] = LittleEndian : : GET_WORD ( insDataPtr + 2 ) ; insDataPtr += 4 ; } for ( k = 0 ; k < XM_ENVELOPENUMPOINTS ; k ++ ) { penv . env [ k ] [ 0 ] = LittleEndian : : GET_WORD ( insDataPtr ) ; penv . env [ k ] [ 1 ] = LittleEndian : : GET_WORD ( insDataPtr + 2 ) ; insDataPtr += 4 ; } venv . num = * insDataPtr ++ ; if ( venv . num > XM_ENVELOPENUMPOINTS ) venv . num = XM_ENVELOPENUMPOINTS ; penv . num = * insDataPtr ++ ; if ( penv . num > XM_ENVELOPENUMPOINTS ) penv . num = XM_ENVELOPENUMPOINTS ; venv . sustain = * insDataPtr ++ ; venv . loops = * insDataPtr ++ ; venv . loope = * insDataPtr ++ ; penv . sustain = * insDataPtr ++ ; penv . loops = * insDataPtr ++ ; penv . loope = * insDataPtr ++ ; venv . type = * insDataPtr ++ ; penv . type = * insDataPtr ++ ; mp_ubyte vibtype , vibsweep , vibdepth , vibrate ; mp_uword volfade ; vibtype = * insDataPtr ++ ; vibsweep = * insDataPtr ++ ; vibdepth = * insDataPtr ++ ; vibrate = * insDataPtr ++ ; vibdepth <<= 1 ; volfade = LittleEndian : : GET_WORD ( insDataPtr ) ; insDataPtr += 2 ; volfade <<= 1 ; insDataPtr += 2 ; for ( mp_sint32 l = 0 ; l < XM_ENVELOPENUMPOINTS ; l ++ ) { venv . env [ l ] [ 1 ] <<= 2 ; penv . env [ l ] [ 1 ] <<= 2 ; } if ( ! module -> addVolumeEnvelope ( venv ) ) return MP_OUT_OF_MEMORY ; if ( ! module -> addPanningEnvelope ( penv ) ) return MP_OUT_OF_MEMORY ; mp_sint32 g = 0 , sc ; for ( sc = 0 ; sc < instr [ y ] . samp ; sc ++ ) { smp [ g + s ] . flags = 3 ; smp [ g + s ] . venvnum = e + 1 ; smp [ g + s ] . penvnum = e + 1 ; smp [ g + s ] . vibtype = vibtype ; smp [ g + s ] . vibsweep = vibsweep ; smp [ g + s ] . vibdepth = vibdepth ; smp [ g + s ] . vibrate = vibrate ; smp [ g + s ] . volfade = volfade ; f . readDwords ( & smp [ g + s ] . samplen , 1 ) ; f . readDwords ( & smp [ g + s ] . loopstart , 1 ) ; f . readDwords ( & smp [ g + s ] . looplen , 1 ) ; smp [ g + s ] . vol = XModule : : vol64to255 ( f . readByte ( ) ) ; f . read ( & smp [ g + s ] . finetune , 1 , 1 ) ; f . read ( & smp [ g + s ] . type , 1 , 1 ) ; # ifdef VERBOSE printf ( \"Before:<S2SV_blank>%i,<S2SV_blank>After:<S2SV_blank>%i\\\\n\" , smp [ g + s ] . type , smp [ g + s ] . type & ( 3 + 16 ) ) ; # endif f . read ( & smp [ g + s ] . pan , 1 , 1 ) ; f . read ( & smp [ g + s ] . relnote , 1 , 1 ) ; f . read ( & smp [ g + s ] . res , 1 , 1 ) ; f . read ( & smp [ g + s ] . name , 1 , 22 ) ; char line [ 30 ] ; memset ( line , 0 , sizeof ( line ) ) ; XModule : : convertStr ( line , smp [ g + s ] . name , 23 , false ) ; if ( line [ 0 ] ) module -> addSongMessageLine ( line ) ; # ifndef MILKYTRACKER if ( smp [ g + s ] . samplen ) { smpReloc [ sc ] = g ; g ++ ; } else smpReloc [ sc ] = - 1 ; # else smpReloc [ sc ] = g ; g ++ ; # endif } instr [ y ] . samp = g ; for ( sc = 0 ; sc < MP_MAXINSSAMPS ; sc ++ ) { if ( smpReloc [ nbu [ sc ] ] == - 1 ) instr [ y ] . snum [ sc ] = - 1 ; else instr [ y ] . snum [ sc ] = smpReloc [ nbu [ sc ] ] + s ; } e ++ ; } else { for ( mp_sint32 i = 0 ; i < 120 ; i ++ ) instr [ y ] . snum [ i ] = - 1 ; } # ifdef MILKYTRACKER s += 16 ; # else s += instr [ y ] . samp ; # endif } header -> smpnum = s ; header -> volenvnum = e ; header -> panenvnum = e ; } for ( y = 0 ; y < header -> patnum ; y ++ ) { if ( header -> ver == 0x104 || header -> ver == 0x103 ) { f . readDwords ( & phead [ y ] . len , 1 ) ; f . read ( & phead [ y ] . ptype , 1 , 1 ) ; f . readWords ( & phead [ y ] . rows , 1 ) ; f . readWords ( & phead [ y ] . patdata , 1 ) ; } else { f . readDwords ( & phead [ y ] . len , 1 ) ; f . read ( & phead [ y ] . ptype , 1 , 1 ) ; phead [ y ] . rows = ( mp_uword ) f . readByte ( ) + 1 ; f . readWords ( & phead [ y ] . patdata , 1 ) ; } phead [ y ] . effnum = 2 ; phead [ y ] . channum = ( mp_ubyte ) header -> channum ; phead [ y ] . patternData = new mp_ubyte [ phead [ y ] . rows * header -> channum * 6 ] ; if ( phead [ y ] . patternData == NULL ) { return MP_OUT_OF_MEMORY ; } memset ( phead [ y ] . patternData , 0 , phead [ y ] . rows * header -> channum * 6 ) ; if ( phead [ y ] . patdata ) { mp_ubyte * buffer = new mp_ubyte [ phead [ y ] . patdata ] ; if ( buffer == NULL ) { return MP_OUT_OF_MEMORY ; } f . read ( buffer , 1 , phead [ y ] . patdata ) ; mp_sint32 pc = 0 , bc = 0 ; for ( mp_sint32 r = 0 ; r < phead [ y ] . rows ; r ++ ) { for ( mp_sint32 c = 0 ; c < header -> channum ; c ++ ) { mp_ubyte slot [ 5 ] ; memset ( slot , 0 , 5 ) ; if ( ( buffer [ pc ] & 128 ) ) { mp_ubyte pb = buffer [ pc ] ; pc ++ ; if ( ( pb & 1 ) ) { slot [ 0 ] = buffer [ pc ] ; pc ++ ; } if ( ( pb & 2 ) ) { slot [ 1 ] = buffer [ pc ] ; pc ++ ; } if ( ( pb & 4 ) ) { slot [ 2 ] = buffer [ pc ] ; pc ++ ; } if ( ( pb & 8 ) ) { slot [ 3 ] = buffer [ pc ] ; pc ++ ; } if ( ( pb & 16 ) ) { slot [ 4 ] = buffer [ pc ] ; pc ++ ; } } else { memcpy ( slot , buffer + pc , 5 ) ; pc += 5 ; } char gl = 0 ; for ( mp_sint32 i = 0 ; i < XModule : : numValidXMEffects ; i ++ ) if ( slot [ 3 ] == XModule : : validXMEffects [ i ] ) gl = 1 ; if ( ! gl ) slot [ 3 ] = slot [ 4 ] = 0 ; if ( ( slot [ 3 ] == 0xC ) || ( slot [ 3 ] == 0x10 ) ) { slot [ 4 ] = XModule : : vol64to255 ( slot [ 4 ] ) ; } if ( ( ! slot [ 3 ] ) && ( slot [ 4 ] ) ) slot [ 3 ] = 0x20 ; if ( slot [ 3 ] == 0xE ) { slot [ 3 ] = ( slot [ 4 ] >> 4 ) + 0x30 ; slot [ 4 ] = slot [ 4 ] & 0xf ; } if ( slot [ 3 ] == 0x21 ) { slot [ 3 ] = ( slot [ 4 ] >> 4 ) + 0x40 ; slot [ 4 ] = slot [ 4 ] & 0xf ; } if ( slot [ 0 ] == 97 ) slot [ 0 ] = XModule : : NOTE_OFF ; phead [ y ] . patternData [ bc ] = slot [ 0 ] ; phead [ y ] . patternData [ bc + 1 ] = slot [ 1 ] ; XModule : : convertXMVolumeEffects ( slot [ 2 ] , phead [ y ] . patternData [ bc + 2 ] , phead [ y ] . patternData [ bc + 3 ] ) ; phead [ y ] . patternData [ bc + 4 ] = slot [ 3 ] ; phead [ y ] . patternData [ bc + 5 ] = slot [ 4 ] ; bc += 6 ; } } delete [ ] buffer ; } } if ( header -> ver == 0x104 ) { mp_sint32 s = 0 ; mp_sint32 e = 0 ; for ( y = 0 ; y < header -> insnum ; y ++ ) { if ( f . posWithBaseOffset ( ) >= fileSize ) break ; f . readDwords ( & instr [ y ] . size , 1 ) ; <S2SV_StartBug> if ( instr [ y ] . size < 29 ) <S2SV_EndBug> { mp_ubyte buffer [ 29 ] ; memset ( buffer , 0 , sizeof ( buffer ) ) ; f . read ( buffer , 1 , instr [ y ] . size - 4 ) ; memcpy ( instr [ y ] . name , buffer , 22 ) ; instr [ y ] . type = buffer [ 22 ] ; instr [ y ] . samp = LittleEndian : : GET_WORD ( buffer + 23 ) ; } else { f . read ( & instr [ y ] . name , 1 , 22 ) ; f . read ( & instr [ y ] . type , 1 , 1 ) ; f . readWords ( & instr [ y ] . samp , 1 ) ; } if ( instr [ y ] . samp > MP_MAXINSSAMPS ) return MP_LOADER_FAILED ; if ( instr [ y ] . size <= 29 ) { # ifdef MILKYTRACKER s += 16 ; # endif for ( mp_sint32 i = 0 ; i < 120 ; i ++ ) instr [ y ] . snum [ i ] = - 1 ; continue ; } f . readDwords ( & instr [ y ] . shsize , 1 ) ; # ifdef VERBOSE printf ( \"%i/%i:<S2SV_blank>%i,<S2SV_blank>%i,<S2SV_blank>%i,<S2SV_blank>%s\\\\n\" , y , header -> insnum - 1 , instr [ y ] . size , instr [ y ] . shsize , instr [ y ] . samp , instr [ y ] . name ) ; # endif memset ( insData , 0 , 230 ) ; if ( instr [ y ] . size - 33 > 230 ) { break ; } f . read ( insData , 1 , instr [ y ] . size - 33 ) ; memset ( smpReloc , 0 , sizeof ( smpReloc ) ) ; if ( instr [ y ] . samp ) { mp_ubyte * insDataPtr = insData ; memcpy ( nbu , insDataPtr , MP_MAXINSSAMPS ) ; insDataPtr += MP_MAXINSSAMPS ; TEnvelope venv ; TEnvelope penv ; memset ( & venv , 0 , sizeof ( venv ) ) ; memset ( & penv , 0 , sizeof ( penv ) ) ; mp_sint32 k ; for ( k = 0 ; k < XM_ENVELOPENUMPOINTS ; k ++ ) { venv . env [ k ] [ 0 ] = LittleEndian : : GET_WORD ( insDataPtr ) ; venv . env [ k ] [ 1 ] = LittleEndian : : GET_WORD ( insDataPtr + 2 ) ; insDataPtr += 4 ; } for ( k = 0 ; k < XM_ENVELOPENUMPOINTS ; k ++ ) { penv . env [ k ] [ 0 ] = LittleEndian : : GET_WORD ( insDataPtr ) ; penv . env [ k ] [ 1 ] = LittleEndian : : GET_WORD ( insDataPtr + 2 ) ; insDataPtr += 4 ; } venv . num = * insDataPtr ++ ; if ( venv . num > XM_ENVELOPENUMPOINTS ) venv . num = XM_ENVELOPENUMPOINTS ; penv . num = * insDataPtr ++ ; if ( penv . num > XM_ENVELOPENUMPOINTS ) penv . num = XM_ENVELOPENUMPOINTS ; venv . sustain = * insDataPtr ++ ; venv . loops = * insDataPtr ++ ; venv . loope = * insDataPtr ++ ; penv . sustain = * insDataPtr ++ ; penv . loops = * insDataPtr ++ ; penv . loope = * insDataPtr ++ ; venv . type = * insDataPtr ++ ; penv . type = * insDataPtr ++ ; mp_ubyte vibtype , vibsweep , vibdepth , vibrate ; mp_uword volfade ; vibtype = * insDataPtr ++ ; vibsweep = * insDataPtr ++ ; vibdepth = * insDataPtr ++ ; vibrate = * insDataPtr ++ ; vibdepth <<= 1 ; volfade = LittleEndian : : GET_WORD ( insDataPtr ) ; insDataPtr += 2 ; volfade <<= 1 ; insDataPtr += 2 ; for ( mp_sint32 l = 0 ; l < XM_ENVELOPENUMPOINTS ; l ++ ) { venv . env [ l ] [ 1 ] <<= 2 ; penv . env [ l ] [ 1 ] <<= 2 ; } if ( ! module -> addVolumeEnvelope ( venv ) ) return MP_OUT_OF_MEMORY ; if ( ! module -> addPanningEnvelope ( penv ) ) return MP_OUT_OF_MEMORY ; mp_sint32 g = 0 , sc ; for ( sc = 0 ; sc < instr [ y ] . samp ; sc ++ ) { smp [ g + s ] . flags = 3 ; smp [ g + s ] . venvnum = e + 1 ; smp [ g + s ] . penvnum = e + 1 ; smp [ g + s ] . vibtype = vibtype ; smp [ g + s ] . vibsweep = vibsweep ; smp [ g + s ] . vibdepth = vibdepth ; smp [ g + s ] . vibrate = vibrate ; smp [ g + s ] . volfade = volfade ; f . readDwords ( & smp [ g + s ] . samplen , 1 ) ; f . readDwords ( & smp [ g + s ] . loopstart , 1 ) ; f . readDwords ( & smp [ g + s ] . looplen , 1 ) ; smp [ g + s ] . vol = XModule : : vol64to255 ( f . readByte ( ) ) ; f . read ( & smp [ g + s ] . finetune , 1 , 1 ) ; f . read ( & smp [ g + s ] . type , 1 , 1 ) ; # ifdef VERBOSE printf ( \"Before:<S2SV_blank>%i,<S2SV_blank>After:<S2SV_blank>%i\\\\n\" , smp [ g + s ] . type , smp [ g + s ] . type & ( 3 + 16 ) ) ; # endif f . read ( & smp [ g + s ] . pan , 1 , 1 ) ; f . read ( & smp [ g + s ] . relnote , 1 , 1 ) ; f . read ( & smp [ g + s ] . res , 1 , 1 ) ; f . read ( & smp [ g + s ] . name , 1 , 22 ) ; char line [ 30 ] ; memset ( line , 0 , sizeof ( line ) ) ; XModule : : convertStr ( line , smp [ g + s ] . name , 23 , false ) ; if ( line [ 0 ] ) module -> addSongMessageLine ( line ) ; # ifndef MILKYTRACKER if ( smp [ g + s ] . samplen ) { smpReloc [ sc ] = g ; g ++ ; } else smpReloc [ sc ] = - 1 ; # else smpReloc [ sc ] = g ; g ++ ; # endif } instr [ y ] . samp = g ; for ( sc = 0 ; sc < MP_MAXINSSAMPS ; sc ++ ) { if ( smpReloc [ nbu [ sc ] ] == - 1 ) instr [ y ] . snum [ sc ] = - 1 ; else instr [ y ] . snum [ sc ] = smpReloc [ nbu [ sc ] ] + s ; } for ( sc = 0 ; sc < instr [ y ] . samp ; sc ++ ) { if ( smp [ s ] . samplen ) { bool adpcm = ( smp [ s ] . res == 0xAD ) ; mp_uint32 oldSize = smp [ s ] . samplen ; if ( smp [ s ] . type & 16 ) { smp [ s ] . samplen >>= 1 ; smp [ s ] . loopstart >>= 1 ; smp [ s ] . looplen >>= 1 ; } mp_sint32 result = module -> loadModuleSample ( f , s , adpcm ? XModule : : ST_PACKING_ADPCM : XModule : : ST_DELTA , adpcm ? ( XModule : : ST_PACKING_ADPCM | XModule : : ST_16BIT ) : ( XModule : : ST_DELTA | XModule : : ST_16BIT ) , oldSize ) ; if ( result != MP_OK ) return result ; if ( adpcm ) smp [ s ] . res = 0 ; } s ++ ; if ( s >= MP_MAXSAMPLES ) return MP_OUT_OF_MEMORY ; } e ++ ; } else { for ( mp_sint32 i = 0 ; i < 120 ; i ++ ) instr [ y ] . snum [ i ] = - 1 ; } # ifdef MILKYTRACKER s += 16 - instr [ y ] . samp ; # endif } header -> smpnum = s ; header -> volenvnum = e ; header -> panenvnum = e ; } else { mp_sint32 s = 0 ; for ( y = 0 ; y < header -> insnum ; y ++ ) { for ( sc = 0 ; sc < instr [ y ] . samp ; sc ++ ) { if ( smp [ s ] . samplen ) { mp_uint32 oldSize = smp [ s ] . samplen ; if ( smp [ s ] . type & 16 ) { smp [ s ] . samplen >>= 1 ; smp [ s ] . loopstart >>= 1 ; smp [ s ] . looplen >>= 1 ; } mp_sint32 result = module -> loadModuleSample ( f , s , XModule : : ST_DELTA , XModule : : ST_DELTA | XModule : : ST_16BIT , oldSize ) ; if ( result != MP_OK ) return result ; } s ++ ; if ( s >= MP_MAXSAMPLES ) return MP_OUT_OF_MEMORY ; } # ifdef MILKYTRACKER s += 16 - instr [ y ] . samp ; # endif } } for ( mp_sint32 s = 0 ; s < header -> smpnum ; s ++ ) { if ( smp [ s ] . type & 32 ) { smp [ s ] . type &= 3 + 16 ; if ( smp [ s ] . sample == NULL ) continue ; if ( ! ( smp [ s ] . type & 16 ) ) { smp [ s ] . samplen >>= 1 ; smp [ s ] . loopstart >>= 1 ; smp [ s ] . looplen >>= 1 ; mp_sbyte * sample = ( mp_sbyte * ) smp [ s ] . sample ; mp_sint32 samplen = smp [ s ] . samplen ; for ( mp_sint32 i = 0 ; i < samplen ; i ++ ) { mp_sint32 s = ( ( mp_sint32 ) sample [ i ] + ( mp_sint32 ) sample [ i + samplen ] ) >> 1 ; if ( s < - 128 ) s = - 128 ; if ( s > 127 ) s = 127 ; sample [ i ] = ( mp_sbyte ) s ; } } else { smp [ s ] . samplen >>= 1 ; smp [ s ] . loopstart >>= 1 ; smp [ s ] . looplen >>= 1 ; mp_sword * sample = ( mp_sword * ) smp [ s ] . sample ; mp_sint32 samplen = smp [ s ] . samplen ; for ( mp_sint32 i = 0 ; i < samplen ; i ++ ) { mp_sint32 s = ( ( mp_sint32 ) sample [ i ] + ( mp_sint32 ) sample [ i + samplen ] ) >> 1 ; if ( s < - 32768 ) s = - 32768 ; if ( s > 32767 ) s = 32767 ; sample [ i ] = ( mp_sword ) s ; } } } if ( ( smp [ s ] . type & 0x3 ) == 0x3 ) smp [ s ] . type &= ~ 1 ; } bool addPatterns = false ; for ( i = 0 ; i < header -> ordnum ; i ++ ) if ( header -> ord [ i ] + 1 > header -> patnum ) { header -> patnum = header -> ord [ i ] + 1 ; addPatterns = true ; } if ( addPatterns ) { for ( i = 0 ; i < header -> patnum ; i ++ ) if ( phead [ i ] . patternData == NULL ) { phead [ i ] . rows = 64 ; phead [ i ] . effnum = 2 ; phead [ i ] . channum = ( mp_ubyte ) header -> channum ; phead [ i ] . patternData = new mp_ubyte [ phead [ i ] . rows * header -> channum * 6 ] ; if ( phead [ i ] . patternData == NULL ) { return MP_OUT_OF_MEMORY ; } memset ( phead [ i ] . patternData , 0 , phead [ i ] . rows * header -> channum * 6 ) ; } } if ( f . posWithBaseOffset ( ) + 8 <= fileSize ) { char buffer [ 4 ] ; f . read ( buffer , 1 , 4 ) ; if ( memcmp ( buffer , \"text\" , 4 ) == 0 ) { mp_uint32 len = f . readDword ( ) ; module -> allocateSongMessage ( len + 1 ) ; memset ( module -> message , 0 , len + 1 ) ; f . read ( module -> message , 1 , len ) ; } } module -> postProcessSamples ( ) ; return MP_OK ; }", "target": "<S2SV_ModStart> ] . size >= 4 && instr [ y ] . size"}
{"source": "CWE-416 ex_substitute ( exarg_T * eap ) { linenr_T lnum ; long i = 0 ; regmmatch_T regmatch ; static subflags_T subflags = { FALSE , FALSE , FALSE , TRUE , FALSE , FALSE , FALSE , 0 } ; # ifdef FEAT_EVAL subflags_T subflags_save ; # endif int save_do_all ; int save_do_ask ; <S2SV_StartBug> char_u * pat = NULL , * sub = NULL ; <S2SV_EndBug> int delimiter ; int sublen ; int got_quit = FALSE ; int got_match = FALSE ; int temp ; int which_pat ; char_u * cmd ; int save_State ; linenr_T first_line = 0 ; linenr_T last_line = 0 ; linenr_T old_line_count = curbuf -> b_ml . ml_line_count ; linenr_T line2 ; long nmatch ; char_u * sub_firstline ; int endcolumn = FALSE ; pos_T old_cursor = curwin -> w_cursor ; int start_nsubs ; # ifdef FEAT_EVAL int save_ma = 0 ; # endif cmd = eap -> arg ; if ( ! global_busy ) { sub_nsubs = 0 ; sub_nlines = 0 ; } start_nsubs = sub_nsubs ; if ( eap -> cmdidx == CMD_tilde ) which_pat = RE_LAST ; else which_pat = RE_SUBST ; if ( eap -> cmd [ 0 ] == 's' && * cmd != NUL && ! VIM_ISWHITE ( * cmd ) && vim_strchr ( ( char_u * ) \"0123456789cegriIp|\\\\\"\" , * cmd ) == NULL ) { if ( check_regexp_delim ( * cmd ) == FAIL ) return ; # ifdef FEAT_EVAL if ( in_vim9script ( ) && check_global_and_subst ( eap -> cmd , eap -> arg ) == FAIL ) return ; # endif if ( * cmd == '\\\\\\\\' ) { ++ cmd ; if ( vim_strchr ( ( char_u * ) \"/?&\" , * cmd ) == NULL ) { emsg ( _ ( e_backslash_should_be_followed_by ) ) ; return ; } if ( * cmd != '&' ) which_pat = RE_SEARCH ; pat = ( char_u * ) \"\" ; delimiter = * cmd ++ ; } else { which_pat = RE_LAST ; delimiter = * cmd ++ ; pat = cmd ; cmd = skip_regexp_ex ( cmd , delimiter , magic_isset ( ) , & eap -> arg , NULL , NULL ) ; if ( cmd [ 0 ] == delimiter ) * cmd ++ = NUL ; } sub = cmd ; cmd = skip_substitute ( cmd , delimiter ) ; if ( ! eap -> skip ) { if ( STRCMP ( sub , \"%\" ) == 0 && vim_strchr ( p_cpo , CPO_SUBPERCENT ) != NULL ) { if ( old_sub == NULL ) { emsg ( _ ( e_no_previous_substitute_regular_expression ) ) ; return ; } sub = old_sub ; } else { vim_free ( old_sub ) ; old_sub = vim_strsave ( sub ) ; } } } else if ( ! eap -> skip ) { if ( old_sub == NULL ) { emsg ( _ ( e_no_previous_substitute_regular_expression ) ) ; return ; } pat = NULL ; sub = old_sub ; endcolumn = ( curwin -> w_curswant == MAXCOL ) ; } if ( pat != NULL && STRCMP ( pat , \"\\\\\\\\n\" ) == 0 && * sub == NUL && ( * cmd == NUL || ( cmd [ 1 ] == NUL && ( * cmd == 'g' || * cmd == 'l' || * cmd == 'p' || * cmd == '#' ) ) ) ) { linenr_T joined_lines_count ; if ( eap -> skip ) return ; curwin -> w_cursor . lnum = eap -> line1 ; if ( * cmd == 'l' ) eap -> flags = EXFLAG_LIST ; else if ( * cmd == '#' ) eap -> flags = EXFLAG_NR ; else if ( * cmd == 'p' ) eap -> flags = EXFLAG_PRINT ; joined_lines_count = eap -> line2 - eap -> line1 + 1 ; if ( eap -> line2 < curbuf -> b_ml . ml_line_count ) ++ joined_lines_count ; if ( joined_lines_count > 1 ) { ( void ) do_join ( joined_lines_count , FALSE , TRUE , FALSE , TRUE ) ; sub_nsubs = joined_lines_count - 1 ; sub_nlines = 1 ; ( void ) do_sub_msg ( FALSE ) ; ex_may_print ( eap ) ; } if ( ( cmdmod . cmod_flags & CMOD_KEEPPATTERNS ) == 0 ) save_re_pat ( RE_SUBST , pat , magic_isset ( ) ) ; add_to_history ( HIST_SEARCH , pat , TRUE , NUL ) ; return ; } if ( * cmd == '&' ) ++ cmd ; else { # ifdef FEAT_EVAL if ( in_vim9script ( ) ) { subflags . do_all = FALSE ; subflags . do_ask = FALSE ; } else # endif if ( ! p_ed ) { if ( p_gd ) subflags . do_all = TRUE ; else subflags . do_all = FALSE ; subflags . do_ask = FALSE ; } subflags . do_error = TRUE ; subflags . do_print = FALSE ; subflags . do_list = FALSE ; subflags . do_count = FALSE ; subflags . do_number = FALSE ; subflags . do_ic = 0 ; } while ( * cmd ) { if ( * cmd == 'g' ) subflags . do_all = ! subflags . do_all ; else if ( * cmd == 'c' ) subflags . do_ask = ! subflags . do_ask ; else if ( * cmd == 'n' ) subflags . do_count = TRUE ; else if ( * cmd == 'e' ) subflags . do_error = ! subflags . do_error ; else if ( * cmd == 'r' ) which_pat = RE_LAST ; else if ( * cmd == 'p' ) subflags . do_print = TRUE ; else if ( * cmd == '#' ) { subflags . do_print = TRUE ; subflags . do_number = TRUE ; } else if ( * cmd == 'l' ) { subflags . do_print = TRUE ; subflags . do_list = TRUE ; } else if ( * cmd == 'i' ) subflags . do_ic = 'i' ; else if ( * cmd == 'I' ) subflags . do_ic = 'I' ; else break ; ++ cmd ; } if ( subflags . do_count ) subflags . do_ask = FALSE ; save_do_all = subflags . do_all ; save_do_ask = subflags . do_ask ; cmd = skipwhite ( cmd ) ; if ( VIM_ISDIGIT ( * cmd ) ) { i = getdigits ( & cmd ) ; if ( i <= 0 && ! eap -> skip && subflags . do_error ) { emsg ( _ ( e_positive_count_required ) ) ; return ; } eap -> line1 = eap -> line2 ; eap -> line2 += i - 1 ; if ( eap -> line2 > curbuf -> b_ml . ml_line_count ) eap -> line2 = curbuf -> b_ml . ml_line_count ; } cmd = skipwhite ( cmd ) ; if ( * cmd && * cmd != \\'\"\\' ) { set_nextcmd ( eap , cmd ) ; if ( eap -> nextcmd == NULL ) { semsg ( _ ( e_trailing_characters_str ) , cmd ) ; return ; } } if ( eap -> skip ) return ; if ( ! subflags . do_count && ! curbuf -> b_p_ma ) { emsg ( _ ( e_cannot_make_changes_modifiable_is_off ) ) ; return ; } if ( search_regcomp ( pat , RE_SUBST , which_pat , SEARCH_HIS , & regmatch ) == FAIL ) { if ( subflags . do_error ) emsg ( _ ( e_invalid_command ) ) ; return ; } if ( subflags . do_ic == 'i' ) regmatch . rmm_ic = TRUE ; else if ( subflags . do_ic == 'I' ) regmatch . rmm_ic = FALSE ; sub_firstline = NULL ; <S2SV_StartBug> if ( ! ( sub [ 0 ] == '\\\\\\\\' && sub [ 1 ] == '=' ) ) <S2SV_EndBug> sub = regtilde ( sub , magic_isset ( ) ) ; line2 = eap -> line2 ; for ( lnum = eap -> line1 ; lnum <= line2 && ! ( got_quit # if defined ( FEAT_EVAL ) || aborting ( ) # endif ) ; ++ lnum ) { nmatch = vim_regexec_multi ( & regmatch , curwin , curbuf , lnum , ( colnr_T ) 0 , NULL , NULL ) ; if ( nmatch ) { colnr_T copycol ; colnr_T matchcol ; colnr_T prev_matchcol = MAXCOL ; char_u * new_end , * new_start = NULL ; unsigned new_start_len = 0 ; char_u * p1 ; int did_sub = FALSE ; int lastone ; int len , copy_len , needed_len ; long nmatch_tl = 0 ; int do_again ; int skip_match = FALSE ; linenr_T sub_firstlnum ; # ifdef FEAT_PROP_POPUP int apc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE ; colnr_T total_added = 0 ; # endif sub_firstlnum = lnum ; copycol = 0 ; matchcol = 0 ; if ( ! got_match ) { setpcmark ( ) ; got_match = TRUE ; } for ( ; ; ) { if ( regmatch . startpos [ 0 ] . lnum > 0 ) { lnum += regmatch . startpos [ 0 ] . lnum ; sub_firstlnum += regmatch . startpos [ 0 ] . lnum ; nmatch -= regmatch . startpos [ 0 ] . lnum ; VIM_CLEAR ( sub_firstline ) ; } if ( lnum > curbuf -> b_ml . ml_line_count ) break ; if ( sub_firstline == NULL ) { sub_firstline = vim_strsave ( ml_get ( sub_firstlnum ) ) ; if ( sub_firstline == NULL ) { vim_free ( new_start ) ; goto outofmem ; } } curwin -> w_cursor . lnum = lnum ; do_again = FALSE ; if ( matchcol == prev_matchcol && regmatch . endpos [ 0 ] . lnum == 0 && matchcol == regmatch . endpos [ 0 ] . col ) { if ( sub_firstline [ matchcol ] == NUL ) skip_match = TRUE ; else { if ( has_mbyte ) matchcol += mb_ptr2len ( sub_firstline + matchcol ) ; else ++ matchcol ; } goto skip ; } matchcol = regmatch . endpos [ 0 ] . col ; prev_matchcol = matchcol ; if ( subflags . do_count ) { if ( nmatch > 1 ) { matchcol = ( colnr_T ) STRLEN ( sub_firstline ) ; nmatch = 1 ; skip_match = TRUE ; } sub_nsubs ++ ; did_sub = TRUE ; # ifdef FEAT_EVAL if ( ! ( sub [ 0 ] == '\\\\\\\\' && sub [ 1 ] == '=' ) ) # endif goto skip ; } if ( subflags . do_ask ) { int typed = 0 ; save_State = State ; State = CONFIRM ; setmouse ( ) ; curwin -> w_cursor . col = regmatch . startpos [ 0 ] . col ; if ( curwin -> w_p_crb ) do_check_cursorbind ( ) ; if ( vim_strchr ( p_cpo , CPO_UNDO ) != NULL ) ++ no_u_sync ; while ( subflags . do_ask ) { if ( exmode_active ) { char_u * resp ; colnr_T sc , ec ; print_line_no_prefix ( lnum , subflags . do_number , subflags . do_list ) ; getvcol ( curwin , & curwin -> w_cursor , & sc , NULL , NULL ) ; curwin -> w_cursor . col = regmatch . endpos [ 0 ] . col - 1 ; if ( curwin -> w_cursor . col < 0 ) curwin -> w_cursor . col = 0 ; getvcol ( curwin , & curwin -> w_cursor , NULL , NULL , & ec ) ; curwin -> w_cursor . col = regmatch . startpos [ 0 ] . col ; if ( subflags . do_number || curwin -> w_p_nu ) { int numw = number_width ( curwin ) + 1 ; sc += numw ; ec += numw ; } msg_start ( ) ; for ( i = 0 ; i < ( long ) sc ; ++ i ) msg_putchar ( '<S2SV_blank>' ) ; for ( ; i <= ( long ) ec ; ++ i ) msg_putchar ( '^' ) ; resp = getexmodeline ( '?' , NULL , 0 , TRUE ) ; if ( resp != NULL ) { typed = * resp ; vim_free ( resp ) ; } } else { char_u * orig_line = NULL ; int len_change = 0 ; int save_p_lz = p_lz ; # ifdef FEAT_FOLDING int save_p_fen = curwin -> w_p_fen ; curwin -> w_p_fen = FALSE ; # endif temp = RedrawingDisabled ; RedrawingDisabled = 0 ; p_lz = FALSE ; if ( new_start != NULL ) { orig_line = vim_strsave ( ml_get ( lnum ) ) ; if ( orig_line != NULL ) { char_u * new_line = concat_str ( new_start , sub_firstline + copycol ) ; if ( new_line == NULL ) VIM_CLEAR ( orig_line ) ; else { len_change = ( int ) STRLEN ( new_line ) - ( int ) STRLEN ( orig_line ) ; curwin -> w_cursor . col += len_change ; ml_replace ( lnum , new_line , FALSE ) ; } } } search_match_lines = regmatch . endpos [ 0 ] . lnum - regmatch . startpos [ 0 ] . lnum ; search_match_endcol = regmatch . endpos [ 0 ] . col + len_change ; highlight_match = TRUE ; update_topline ( ) ; validate_cursor ( ) ; update_screen ( SOME_VALID ) ; highlight_match = FALSE ; redraw_later ( SOME_VALID ) ; # ifdef FEAT_FOLDING curwin -> w_p_fen = save_p_fen ; # endif if ( msg_row == Rows - 1 ) msg_didout = FALSE ; msg_starthere ( ) ; i = msg_scroll ; msg_scroll = 0 ; msg_no_more = TRUE ; smsg_attr ( HL_ATTR ( HLF_R ) , _ ( \"replace<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>(y/n/a/q/l/^E/^Y)?\" ) , sub ) ; msg_no_more = FALSE ; msg_scroll = i ; showruler ( TRUE ) ; windgoto ( msg_row , msg_col ) ; RedrawingDisabled = temp ; # ifdef USE_ON_FLY_SCROLL dont_scroll = FALSE ; # endif ++ no_mapping ; ++ allow_keys ; typed = plain_vgetc ( ) ; -- allow_keys ; -- no_mapping ; msg_didout = FALSE ; msg_col = 0 ; gotocmdline ( TRUE ) ; p_lz = save_p_lz ; if ( orig_line != NULL ) ml_replace ( lnum , orig_line , FALSE ) ; } need_wait_return = FALSE ; if ( typed == 'q' || typed == ESC || typed == Ctrl_C # ifdef UNIX || typed == intr_char # endif ) { got_quit = TRUE ; break ; } if ( typed == 'n' ) break ; if ( typed == 'y' ) break ; if ( typed == 'l' ) { subflags . do_all = FALSE ; line2 = lnum ; break ; } if ( typed == 'a' ) { subflags . do_ask = FALSE ; break ; } if ( typed == Ctrl_E ) scrollup_clamp ( ) ; else if ( typed == Ctrl_Y ) scrolldown_clamp ( ) ; } State = save_State ; setmouse ( ) ; if ( vim_strchr ( p_cpo , CPO_UNDO ) != NULL ) -- no_u_sync ; if ( typed == 'n' ) { if ( nmatch > 1 ) { matchcol = ( colnr_T ) STRLEN ( sub_firstline ) ; skip_match = TRUE ; } goto skip ; } if ( got_quit ) goto skip ; } curwin -> w_cursor . col = regmatch . startpos [ 0 ] . col ; # ifdef FEAT_EVAL save_ma = curbuf -> b_p_ma ; if ( subflags . do_count ) { curbuf -> b_p_ma = FALSE ; sandbox ++ ; } subflags_save = subflags ; # endif sublen = vim_regsub_multi ( & regmatch , sub_firstlnum - regmatch . startpos [ 0 ] . lnum , sub , sub_firstline , FALSE , magic_isset ( ) , TRUE ) ; # ifdef FEAT_EVAL subflags = subflags_save ; if ( aborting ( ) || subflags . do_count ) { curbuf -> b_p_ma = save_ma ; if ( sandbox > 0 ) sandbox -- ; goto skip ; } # endif if ( nmatch > curbuf -> b_ml . ml_line_count - sub_firstlnum + 1 ) { nmatch = curbuf -> b_ml . ml_line_count - sub_firstlnum + 1 ; skip_match = TRUE ; } if ( nmatch == 1 ) { p1 = sub_firstline ; # ifdef FEAT_PROP_POPUP if ( curbuf -> b_has_textprop ) { int bytes_added = sublen - 1 - ( regmatch . endpos [ 0 ] . col - regmatch . startpos [ 0 ] . col ) ; if ( adjust_prop_columns ( lnum , total_added + regmatch . startpos [ 0 ] . col , bytes_added , apc_flags ) ) apc_flags &= ~ APC_SAVE_FOR_UNDO ; total_added += bytes_added ; } # endif } else { p1 = ml_get ( sub_firstlnum + nmatch - 1 ) ; nmatch_tl += nmatch - 1 ; } copy_len = regmatch . startpos [ 0 ] . col - copycol ; needed_len = copy_len + ( ( unsigned ) STRLEN ( p1 ) - regmatch . endpos [ 0 ] . col ) + sublen + 1 ; if ( new_start == NULL ) { new_start_len = needed_len + 50 ; if ( ( new_start = alloc ( new_start_len ) ) == NULL ) goto outofmem ; * new_start = NUL ; new_end = new_start ; } else { len = ( unsigned ) STRLEN ( new_start ) ; needed_len += len ; if ( needed_len > ( int ) new_start_len ) { new_start_len = needed_len + 50 ; if ( ( p1 = alloc ( new_start_len ) ) == NULL ) { vim_free ( new_start ) ; goto outofmem ; } mch_memmove ( p1 , new_start , ( size_t ) ( len + 1 ) ) ; vim_free ( new_start ) ; new_start = p1 ; } new_end = new_start + len ; } mch_memmove ( new_end , sub_firstline + copycol , ( size_t ) copy_len ) ; new_end += copy_len ; ( void ) vim_regsub_multi ( & regmatch , sub_firstlnum - regmatch . startpos [ 0 ] . lnum , sub , new_end , TRUE , magic_isset ( ) , TRUE ) ; sub_nsubs ++ ; did_sub = TRUE ; curwin -> w_cursor . col = 0 ; if ( nmatch > 1 ) { sub_firstlnum += nmatch - 1 ; vim_free ( sub_firstline ) ; sub_firstline = vim_strsave ( ml_get ( sub_firstlnum ) ) ; if ( sub_firstlnum <= line2 ) do_again = TRUE ; else subflags . do_all = FALSE ; } copycol = regmatch . endpos [ 0 ] . col ; if ( skip_match ) { vim_free ( sub_firstline ) ; sub_firstline = vim_strsave ( ( char_u * ) \"\" ) ; copycol = 0 ; } for ( p1 = new_end ; * p1 ; ++ p1 ) { if ( p1 [ 0 ] == '\\\\\\\\' && p1 [ 1 ] != NUL ) { STRMOVE ( p1 , p1 + 1 ) ; # ifdef FEAT_PROP_POPUP if ( curbuf -> b_has_textprop ) { if ( adjust_prop_columns ( lnum , ( colnr_T ) ( p1 - new_start ) , - 1 , apc_flags ) ) apc_flags &= ~ APC_SAVE_FOR_UNDO ; } # endif } else if ( * p1 == CAR ) { if ( u_inssub ( lnum ) == OK ) { colnr_T plen = ( colnr_T ) ( p1 - new_start + 1 ) ; * p1 = NUL ; ml_append ( lnum - 1 , new_start , plen , FALSE ) ; mark_adjust ( lnum + 1 , ( linenr_T ) MAXLNUM , 1L , 0L ) ; if ( subflags . do_ask ) appended_lines ( lnum - 1 , 1L ) ; else { if ( first_line == 0 ) first_line = lnum ; last_line = lnum + 1 ; } # ifdef FEAT_PROP_POPUP adjust_props_for_split ( lnum + 1 , lnum , plen , 1 ) ; # endif ++ sub_firstlnum ; ++ lnum ; ++ line2 ; ++ curwin -> w_cursor . lnum ; STRMOVE ( new_start , p1 + 1 ) ; p1 = new_start - 1 ; } } else if ( has_mbyte ) p1 += ( * mb_ptr2len ) ( p1 ) - 1 ; } skip : lastone = ( skip_match || got_int || got_quit || lnum > line2 || ! ( subflags . do_all || do_again ) || ( sub_firstline [ matchcol ] == NUL && nmatch <= 1 && ! re_multiline ( regmatch . regprog ) ) ) ; nmatch = - 1 ; if ( lastone || nmatch_tl > 0 || ( nmatch = vim_regexec_multi ( & regmatch , curwin , curbuf , sub_firstlnum , matchcol , NULL , NULL ) ) == 0 || regmatch . startpos [ 0 ] . lnum > 0 ) { if ( new_start != NULL ) { STRCAT ( new_start , sub_firstline + copycol ) ; matchcol = ( colnr_T ) STRLEN ( sub_firstline ) - matchcol ; prev_matchcol = ( colnr_T ) STRLEN ( sub_firstline ) - prev_matchcol ; if ( u_savesub ( lnum ) != OK ) break ; ml_replace ( lnum , new_start , TRUE ) ; if ( nmatch_tl > 0 ) { ++ lnum ; if ( u_savedel ( lnum , nmatch_tl ) != OK ) break ; for ( i = 0 ; i < nmatch_tl ; ++ i ) ml_delete ( lnum ) ; mark_adjust ( lnum , lnum + nmatch_tl - 1 , ( long ) MAXLNUM , - nmatch_tl ) ; if ( subflags . do_ask ) deleted_lines ( lnum , nmatch_tl ) ; -- lnum ; line2 -= nmatch_tl ; nmatch_tl = 0 ; } if ( subflags . do_ask ) changed_bytes ( lnum , 0 ) ; else { if ( first_line == 0 ) first_line = lnum ; last_line = lnum + 1 ; } sub_firstlnum = lnum ; vim_free ( sub_firstline ) ; sub_firstline = new_start ; new_start = NULL ; matchcol = ( colnr_T ) STRLEN ( sub_firstline ) - matchcol ; prev_matchcol = ( colnr_T ) STRLEN ( sub_firstline ) - prev_matchcol ; copycol = 0 ; } if ( nmatch == - 1 && ! lastone ) nmatch = vim_regexec_multi ( & regmatch , curwin , curbuf , sub_firstlnum , matchcol , NULL , NULL ) ; if ( nmatch <= 0 ) { if ( nmatch == - 1 ) lnum -= regmatch . startpos [ 0 ] . lnum ; break ; } } line_breakcheck ( ) ; } if ( did_sub ) ++ sub_nlines ; vim_free ( new_start ) ; VIM_CLEAR ( sub_firstline ) ; } line_breakcheck ( ) ; } if ( first_line != 0 ) { i = curbuf -> b_ml . ml_line_count - old_line_count ; changed_lines ( first_line , 0 , last_line - i , i ) ; } outofmem : vim_free ( sub_firstline ) ; if ( subflags . do_count ) curwin -> w_cursor = old_cursor ; if ( sub_nsubs > start_nsubs ) { if ( ( cmdmod . cmod_flags & CMOD_LOCKMARKS ) == 0 ) { curbuf -> b_op_start . lnum = eap -> line1 ; curbuf -> b_op_end . lnum = line2 ; curbuf -> b_op_start . col = curbuf -> b_op_end . col = 0 ; } if ( ! global_busy ) { if ( ! subflags . do_ask ) { if ( endcolumn ) coladvance ( ( colnr_T ) MAXCOL ) ; else beginline ( BL_WHITE | BL_FIX ) ; } if ( ! do_sub_msg ( subflags . do_count ) && subflags . do_ask ) msg ( \"\" ) ; } else global_need_beginline = TRUE ; if ( subflags . do_print ) print_line ( curwin -> w_cursor . lnum , subflags . do_number , subflags . do_list ) ; } else if ( ! global_busy ) { if ( got_int ) emsg ( _ ( e_interrupted ) ) ; else if ( got_match ) msg ( \"\" ) ; else if ( subflags . do_error ) semsg ( _ ( e_pattern_not_found_str ) , get_search_pat ( ) ) ; } # ifdef FEAT_FOLDING if ( subflags . do_ask && hasAnyFolding ( curwin ) ) changed_window_setting ( ) ; # endif vim_regfree ( regmatch . regprog ) ; <S2SV_StartBug> <S2SV_EndBug> subflags . do_all = save_do_all ; subflags . do_ask = save_do_ask ; }", "target": "<S2SV_ModStart> , * sub = NULL ; char_u * sub_copy <S2SV_ModStart> NULL ; if <S2SV_ModEnd> ( sub [ <S2SV_ModStart> == '=' ) { sub = vim_strsave ( sub ) ; if ( sub == NULL ) return ; sub_copy = sub ; } else <S2SV_ModEnd> sub = regtilde <S2SV_ModStart> regprog ) ; vim_free ( sub_copy ) ;"}
{"source": "CWE-787 static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotated_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; quantum_info = ( QuantumInfo * ) NULL ; <S2SV_StartBug> ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; <S2SV_EndBug> while ( EOFBlob ( image ) == MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ; if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian = LSBEndian ; } else { HDR . nRows = ReadBlobMSBLong ( image ) ; HDR . nCols = ReadBlobMSBLong ( image ) ; HDR . imagf = ReadBlobMSBLong ( image ) ; HDR . nameLen = ReadBlobMSBLong ( image ) ; endian = MSBEndian ; } if ( ( HDR . imagf != 0 ) && ( HDR . imagf != 1 ) ) break ; if ( HDR . nameLen > 0xFFFF ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) { int byte ; byte = ReadBlobByte ( image ) ; if ( byte == EOF ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } } image -> columns = ( size_t ) HDR . nRows ; image -> rows = ( size_t ) HDR . nCols ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) { Swap ( image -> columns , image -> rows ) ; if ( HDR . imagf == 1 ) ldblk *= 2 ; SeekBlob ( image , HDR . nCols * ldblk , SEEK_CUR ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( image -> previous == ( Image * ) NULL ? DestroyImageList ( image ) : image ) ; goto skip_reading_current ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) return ( DestroyImageList ( image ) ) ; switch ( HDR . Type [ 1 ] ) { case 0 : format_type = FloatingPointQuantumFormat ; depth = 64 ; break ; case 1 : format_type = FloatingPointQuantumFormat ; depth = 32 ; break ; case 2 : format_type = UnsignedQuantumFormat ; depth = 16 ; break ; case 3 : format_type = SignedQuantumFormat ; depth = 16 ; break ; case 4 : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; default : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; } image -> depth = depth ; if ( HDR . Type [ 0 ] != 0 ) SetQuantumEndian ( image , quantum_info , MSBEndian ) ; status = SetQuantumFormat ( image , quantum_info , format_type ) ; status = SetQuantumDepth ( image , quantum_info , depth ) ; status = SetQuantumEndian ( image , quantum_info , endian ) ; SetQuantumScale ( quantum_info , 1.0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) FixSignedValues ( image , q , ( int ) image -> columns ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( HDR . imagf == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; if ( HDR . Type [ 1 ] == 0 ) InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; else InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; skip_reading_current : AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> , SEEK_SET ) ; status = MagickTrue"}
{"source": "CWE-264 readconf_main ( void ) { int sep = 0 ; struct stat statbuf ; uschar * s , * filename ; uschar * list = config_main_filelist ; while ( ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { # if defined ( CONFIGURE_FILE_USE_NODE ) || defined ( CONFIGURE_FILE_USE_EUID ) uschar * suffix = filename + Ustrlen ( filename ) ; # ifdef CONFIGURE_FILE_USE_NODE struct utsname uts ; if ( uname ( & uts ) >= 0 ) { # ifdef CONFIGURE_FILE_USE_EUID sprintf ( CS suffix , \".%ld.%.256s\" , ( long int ) original_euid , uts . nodename ) ; config_file = Ufopen ( filename , \"rb\" ) ; if ( config_file == NULL ) # endif { sprintf ( CS suffix , \".%.256s\" , uts . nodename ) ; config_file = Ufopen ( filename , \"rb\" ) ; } } # endif # ifdef CONFIGURE_FILE_USE_EUID if ( config_file == NULL ) { sprintf ( CS suffix , \".%ld\" , ( long int ) original_euid ) ; config_file = Ufopen ( filename , \"rb\" ) ; } # endif if ( config_file == NULL ) { * suffix = 0 ; config_file = Ufopen ( filename , \"rb\" ) ; } # else config_file = Ufopen ( filename , \"rb\" ) ; # endif if ( config_file != NULL || errno != ENOENT ) break ; } if ( config_file != NULL ) { config_filename = config_main_filename = string_copy ( filename ) ; } else { if ( filename == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"non-existent<S2SV_blank>configuration<S2SV_blank>file(s):<S2SV_blank>\" \"%s\" , config_main_filelist ) ; else log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"%s\" , string_open_failed ( errno , \"configuration<S2SV_blank>file<S2SV_blank>%s\" , filename ) ) ; } <S2SV_StartBug> if ( ! config_changed ) <S2SV_EndBug> { if ( fstat ( fileno ( config_file ) , & statbuf ) != 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"failed<S2SV_blank>to<S2SV_blank>stat<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>%s\" , big_buffer ) ; if ( ( statbuf . st_uid != root_uid # ifdef CONFIGURE_OWNER && statbuf . st_uid != config_uid # endif ) || ( statbuf . st_gid != root_gid # ifdef CONFIGURE_GROUP && statbuf . st_gid != config_gid # endif && ( statbuf . st_mode & 020 ) != 0 ) || ( ( statbuf . st_mode & 2 ) != 0 ) ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"Exim<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>the<S2SV_blank>\" \"wrong<S2SV_blank>owner,<S2SV_blank>group,<S2SV_blank>or<S2SV_blank>mode\" , big_buffer ) ; } while ( ( s = get_config_line ( ) ) != NULL ) { if ( isupper ( s [ 0 ] ) ) read_macro_assignment ( s ) ; else if ( Ustrncmp ( s , \"domainlist\" , 10 ) == 0 ) read_named_list ( & domainlist_anchor , & domainlist_count , MAX_NAMED_LIST , s + 10 , US \"domain<S2SV_blank>list\" ) ; else if ( Ustrncmp ( s , \"hostlist\" , 8 ) == 0 ) read_named_list ( & hostlist_anchor , & hostlist_count , MAX_NAMED_LIST , s + 8 , US \"host<S2SV_blank>list\" ) ; else if ( Ustrncmp ( s , US \"addresslist\" , 11 ) == 0 ) read_named_list ( & addresslist_anchor , & addresslist_count , MAX_NAMED_LIST , s + 11 , US \"address<S2SV_blank>list\" ) ; else if ( Ustrncmp ( s , US \"localpartlist\" , 13 ) == 0 ) read_named_list ( & localpartlist_anchor , & localpartlist_count , MAX_NAMED_LIST , s + 13 , US \"local<S2SV_blank>part<S2SV_blank>list\" ) ; else ( void ) readconf_handle_option ( s , optionlist_config , optionlist_config_size , NULL , US \"main<S2SV_blank>option<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>unknown\" ) ; } if ( local_sender_retain && local_from_check ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"both<S2SV_blank>local_from_check<S2SV_blank>and<S2SV_blank>\" \"local_sender_retain<S2SV_blank>are<S2SV_blank>set;<S2SV_blank>this<S2SV_blank>combination<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\" ) ; if ( timezone_string != NULL && * timezone_string == 0 ) timezone_string = NULL ; if ( retry_interval_max > 24 * 60 * 60 ) retry_interval_max = 24 * 60 * 60 ; if ( remote_max_parallel <= 0 ) remote_max_parallel = 1 ; freeze_tell_config = freeze_tell ; if ( primary_hostname == NULL ) { uschar * hostname ; struct utsname uts ; if ( uname ( & uts ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"uname()<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>yield<S2SV_blank>host<S2SV_blank>name\" ) ; hostname = US uts . nodename ; if ( Ustrchr ( hostname , '.' ) == NULL ) { int af = AF_INET ; struct hostent * hostdata ; # if HAVE_IPV6 if ( ! disable_ipv6 && ( dns_ipv4_lookup == NULL || match_isinlist ( hostname , & dns_ipv4_lookup , 0 , NULL , NULL , MCL_DOMAIN , TRUE , NULL ) != OK ) ) af = AF_INET6 ; # else af = AF_INET ; # endif for ( ; ; ) { # if HAVE_IPV6 # if HAVE_GETIPNODEBYNAME int error_num ; hostdata = getipnodebyname ( CS hostname , af , 0 , & error_num ) ; # else hostdata = gethostbyname2 ( CS hostname , af ) ; # endif # else hostdata = gethostbyname ( CS hostname ) ; # endif if ( hostdata != NULL ) { hostname = US hostdata -> h_name ; break ; } if ( af == AF_INET ) break ; af = AF_INET ; } } primary_hostname = string_copy ( hostname ) ; } smtp_active_hostname = primary_hostname ; if ( * spool_directory == 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"spool_directory<S2SV_blank>undefined:<S2SV_blank>cannot<S2SV_blank>\" \"proceed\" ) ; s = expand_string ( spool_directory ) ; if ( s == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>spool_directory<S2SV_blank>\" \"\\\\\"%s\\\\\":<S2SV_blank>%s\" , spool_directory , expand_string_message ) ; spool_directory = s ; if ( * log_file_path != 0 ) { uschar * ss , * sss ; int sep = ':' ; s = expand_string ( log_file_path ) ; if ( s == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>log_file_path<S2SV_blank>\" \"\\\\\"%s\\\\\":<S2SV_blank>%s\" , log_file_path , expand_string_message ) ; ss = s ; while ( ( sss = string_nextinlist ( & ss , & sep , big_buffer , big_buffer_size ) ) != NULL ) { uschar * t ; if ( sss [ 0 ] == 0 || Ustrcmp ( sss , \"syslog\" ) == 0 ) continue ; t = Ustrstr ( sss , \"%s\" ) ; if ( t == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"log_file_path<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>\" \"contain<S2SV_blank>\\\\\"%%s\\\\\"\" , sss ) ; * t = 'X' ; t = Ustrchr ( sss , '%' ) ; if ( t != NULL ) { if ( t [ 1 ] != 'D' || Ustrchr ( t + 2 , '%' ) != NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"log_file_path<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>contains<S2SV_blank>\" \"unexpected<S2SV_blank>\\\\\"%%\\\\\"<S2SV_blank>character\" , s ) ; } } log_file_path = s ; } if ( syslog_facility_str != NULL ) { int i ; uschar * s = syslog_facility_str ; if ( ( Ustrlen ( syslog_facility_str ) >= 4 ) && ( strncmpic ( syslog_facility_str , US \"log_\" , 4 ) == 0 ) ) s += 4 ; for ( i = 0 ; i < syslog_list_size ; i ++ ) { if ( strcmpic ( s , syslog_list [ i ] . name ) == 0 ) { syslog_facility = syslog_list [ i ] . value ; break ; } } if ( i >= syslog_list_size ) { log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"failed<S2SV_blank>to<S2SV_blank>interpret<S2SV_blank>syslog_facility<S2SV_blank>\\\\\"%s\\\\\"\" , syslog_facility_str ) ; } } if ( * pid_file_path != 0 ) { s = expand_string ( pid_file_path ) ; if ( s == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>pid_file_path<S2SV_blank>\" \"\\\\\"%s\\\\\":<S2SV_blank>%s\" , pid_file_path , expand_string_message ) ; pid_file_path = s ; } regex_From = regex_must_compile ( uucp_from_pattern , FALSE , TRUE ) ; if ( smtp_ratelimit_mail != NULL ) { unpick_ratelimit ( smtp_ratelimit_mail , & smtp_rlm_threshold , & smtp_rlm_base , & smtp_rlm_factor , & smtp_rlm_limit ) ; } if ( smtp_ratelimit_rcpt != NULL ) { unpick_ratelimit ( smtp_ratelimit_rcpt , & smtp_rlr_threshold , & smtp_rlr_base , & smtp_rlr_factor , & smtp_rlr_limit ) ; } if ( qualify_domain_sender == NULL ) qualify_domain_sender = primary_hostname ; if ( qualify_domain_recipient == NULL ) qualify_domain_recipient = qualify_domain_sender ; if ( system_filter_uid_set && ! system_filter_gid_set ) { struct passwd * pw = getpwuid ( system_filter_uid ) ; if ( pw == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , \"Failed<S2SV_blank>to<S2SV_blank>look<S2SV_blank>up<S2SV_blank>uid<S2SV_blank>%ld\" , ( long int ) system_filter_uid ) ; system_filter_gid = pw -> pw_gid ; system_filter_gid_set = TRUE ; } if ( errors_reply_to != NULL ) { uschar * errmess ; int start , end , domain ; uschar * recipient = parse_extract_address ( errors_reply_to , & errmess , & start , & end , & domain , FALSE ) ; if ( recipient == NULL ) log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"error<S2SV_blank>in<S2SV_blank>errors_reply_to<S2SV_blank>(%s):<S2SV_blank>%s\" , errors_reply_to , errmess ) ; if ( domain == 0 ) log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"errors_reply_to<S2SV_blank>(%s)<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>domain\" , errors_reply_to ) ; } if ( smtp_accept_max == 0 && ( smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL ) ) log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"smtp_accept_max<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>if<S2SV_blank>smtp_accept_queue<S2SV_blank>or<S2SV_blank>\" \"smtp_accept_max_per_host<S2SV_blank>is<S2SV_blank>set\" ) ; if ( host_number_string != NULL ) { uschar * end ; uschar * s = expand_string ( host_number_string ) ; long int n = Ustrtol ( s , & end , 0 ) ; while ( isspace ( * end ) ) end ++ ; if ( * end != 0 ) log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"localhost_number<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>number:<S2SV_blank>%s\" , s ) ; if ( n > LOCALHOST_MAX ) log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"localhost_number<S2SV_blank>is<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>value<S2SV_blank>(%d)\" , LOCALHOST_MAX ) ; host_number = n ; } # ifdef SUPPORT_TLS if ( ( tls_verify_hosts != NULL || tls_try_verify_hosts != NULL ) && tls_verify_certificates == NULL ) log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"tls_%sverify_hosts<S2SV_blank>is<S2SV_blank>set,<S2SV_blank>but<S2SV_blank>tls_verify_certificates<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set\" , ( tls_verify_hosts != NULL ) ? \"\" : \"try_\" ) ; if ( openssl_options != NULL ) { # ifdef USE_GNUTLS log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"openssl_options<S2SV_blank>is<S2SV_blank>set<S2SV_blank>but<S2SV_blank>we\\'re<S2SV_blank>using<S2SV_blank>GnuTLS\" ) ; # else long dummy ; if ( ! ( tls_openssl_options_parse ( openssl_options , & dummy ) ) ) log_write ( 0 , LOG_PANIC_DIE | LOG_CONFIG , \"openssl_options<S2SV_blank>parse<S2SV_blank>error:<S2SV_blank>%s\" , openssl_options ) ; # endif } # endif }", "target": "<S2SV_ModStart> } if ( trusted_config <S2SV_ModEnd> ) { if"}
{"source": "CWE-200 static int elo_probe ( struct hid_device * hdev , const struct hid_device_id * id ) { struct elo_priv * priv ; int ret ; struct usb_device * udev ; if ( ! hid_is_usb ( hdev ) ) return - EINVAL ; priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; INIT_DELAYED_WORK ( & priv -> work , elo_work ) ; udev = interface_to_usbdev ( to_usb_interface ( hdev -> dev . parent ) ) ; priv -> usbdev = usb_get_dev ( udev ) ; hid_set_drvdata ( hdev , priv ) ; ret = hid_parse ( hdev ) ; if ( ret ) { hid_err ( hdev , \"parse<S2SV_blank>failed\\\\n\" ) ; goto err_free ; } ret = hid_hw_start ( hdev , HID_CONNECT_DEFAULT ) ; if ( ret ) { hid_err ( hdev , \"hw<S2SV_blank>start<S2SV_blank>failed\\\\n\" ) ; goto err_free ; } if ( elo_broken_firmware ( priv -> usbdev ) ) { hid_info ( hdev , \"broken<S2SV_blank>firmware<S2SV_blank>found,<S2SV_blank>installing<S2SV_blank>workaround\\\\n\" ) ; queue_delayed_work ( wq , & priv -> work , ELO_PERIODIC_READ_INTERVAL ) ; } return 0 ; err_free : <S2SV_StartBug> kfree ( priv ) ; <S2SV_EndBug> return ret ; }", "target": "<S2SV_ModStart> ; err_free : usb_put_dev ( udev ) ;"}
{"source": "CWE-200 static int __tipc_sendmsg ( struct socket * sock , struct msghdr * m , size_t dlen ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct tipc_sock * tsk = tipc_sk ( sk ) ; struct tipc_uaddr * ua = ( struct tipc_uaddr * ) m -> msg_name ; long timeout = sock_sndtimeo ( sk , m -> msg_flags & MSG_DONTWAIT ) ; struct list_head * clinks = & tsk -> cong_links ; bool syn = ! tipc_sk_type_connectionless ( sk ) ; struct tipc_group * grp = tsk -> group ; struct tipc_msg * hdr = & tsk -> phdr ; struct tipc_socket_addr skaddr ; struct sk_buff_head pkts ; int atype , mtu , rc ; if ( unlikely ( dlen > TIPC_MAX_USER_MSG_SIZE ) ) return - EMSGSIZE ; if ( ua ) { if ( ! tipc_uaddr_valid ( ua , m -> msg_namelen ) ) return - EINVAL ; atype = ua -> addrtype ; } if ( grp ) { if ( ! ua ) return tipc_send_group_bcast ( sock , m , dlen , timeout ) ; if ( atype == TIPC_SERVICE_ADDR ) return tipc_send_group_anycast ( sock , m , dlen , timeout ) ; if ( atype == TIPC_SOCKET_ADDR ) return tipc_send_group_unicast ( sock , m , dlen , timeout ) ; if ( atype == TIPC_SERVICE_RANGE ) return tipc_send_group_mcast ( sock , m , dlen , timeout ) ; return - EINVAL ; } if ( ! ua ) { ua = ( struct tipc_uaddr * ) & tsk -> peer ; if ( ! syn && ua -> family != AF_TIPC ) return - EDESTADDRREQ ; atype = ua -> addrtype ; } if ( unlikely ( syn ) ) { if ( sk -> sk_state == TIPC_LISTEN ) return - EPIPE ; if ( sk -> sk_state != TIPC_OPEN ) return - EISCONN ; if ( tsk -> published ) return - EOPNOTSUPP ; if ( atype == TIPC_SERVICE_ADDR ) tsk -> conn_addrtype = atype ; msg_set_syn ( hdr , 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( atype == TIPC_SERVICE_RANGE ) { return tipc_sendmcast ( sock , ua , m , dlen , timeout ) ; } else if ( atype == TIPC_SERVICE_ADDR ) { skaddr . node = ua -> lookup_node ; ua -> scope = tipc_node2scope ( skaddr . node ) ; if ( ! tipc_nametbl_lookup_anycast ( net , ua , & skaddr ) ) return - EHOSTUNREACH ; } else if ( atype == TIPC_SOCKET_ADDR ) { skaddr = ua -> sk ; } else { return - EINVAL ; } rc = tipc_wait_for_cond ( sock , & timeout , ! tipc_dest_find ( clinks , skaddr . node , 0 ) ) ; if ( unlikely ( rc ) ) return rc ; msg_set_destnode ( hdr , skaddr . node ) ; msg_set_destport ( hdr , skaddr . ref ) ; if ( atype == TIPC_SERVICE_ADDR ) { msg_set_type ( hdr , TIPC_NAMED_MSG ) ; msg_set_hdr_sz ( hdr , NAMED_H_SIZE ) ; msg_set_nametype ( hdr , ua -> sa . type ) ; msg_set_nameinst ( hdr , ua -> sa . instance ) ; msg_set_lookup_scope ( hdr , ua -> scope ) ; } else { msg_set_type ( hdr , TIPC_DIRECT_MSG ) ; msg_set_lookup_scope ( hdr , 0 ) ; msg_set_hdr_sz ( hdr , BASIC_H_SIZE ) ; } __skb_queue_head_init ( & pkts ) ; mtu = tipc_node_get_mtu ( net , skaddr . node , tsk -> portid , true ) ; rc = tipc_msg_build ( hdr , m , 0 , dlen , mtu , & pkts ) ; if ( unlikely ( rc != dlen ) ) return rc ; if ( unlikely ( syn && ! tipc_msg_skb_clone ( & pkts , & sk -> sk_write_queue ) ) ) { __skb_queue_purge ( & pkts ) ; return - ENOMEM ; } trace_tipc_sk_sendmsg ( sk , skb_peek ( & pkts ) , TIPC_DUMP_SK_SNDQ , \"<S2SV_blank>\" ) ; rc = tipc_node_xmit ( net , & pkts , skaddr . node , tsk -> portid ) ; if ( unlikely ( rc == - ELINKCONG ) ) { tipc_dest_push ( clinks , skaddr . node , 0 ) ; tsk -> cong_link_cnt ++ ; rc = 0 ; } if ( unlikely ( syn && ! rc ) ) { tipc_set_sk_state ( sk , TIPC_CONNECTING ) ; if ( dlen && timeout ) { timeout = msecs_to_jiffies ( timeout ) ; tipc_wait_for_connect ( sock , & timeout ) ; } } return rc ? rc : dlen ; }", "target": "<S2SV_ModStart> ) ; } memset ( & skaddr , 0 , sizeof ( skaddr ) ) ;"}
{"source": "CWE-787 pcx_write_rle ( const byte * from , const byte * end , int step , gp_file * file ) { # define MAX_RUN_COUNT 15 int max_run = step * MAX_RUN_COUNT ; while ( from < end ) { byte data = * from ; from += step ; <S2SV_StartBug> if ( data != * from || from == end ) { <S2SV_EndBug> if ( data >= 0xc0 ) gp_fputc ( 0xc1 , file ) ; } else { const byte * start = from ; while ( ( from < end ) && ( * from == data ) ) from += step ; while ( from - start >= max_run ) { gp_fputc ( 0xc0 + MAX_RUN_COUNT , file ) ; gp_fputc ( data , file ) ; start += max_run ; } if ( from > start || data >= 0xc0 ) gp_fputc ( ( from - start ) / step + 0xc1 , file ) ; } gp_fputc ( data , file ) ; } # undef MAX_RUN_COUNT }", "target": "<S2SV_ModStart> ; if ( from >= end || <S2SV_ModStart> != * from <S2SV_ModEnd> ) { if"}
{"source": "CWE-665 static NTSTATUS vfswrap_fsctl ( struct vfs_handle_struct * handle , struct files_struct * fsp , TALLOC_CTX * ctx , uint32_t function , uint16_t req_flags , const uint8_t * _in_data , uint32_t in_len , uint8_t * * _out_data , uint32_t max_out_len , uint32_t * out_len ) { const char * in_data = ( const char * ) _in_data ; char * * out_data = ( char * * ) _out_data ; switch ( function ) { case FSCTL_SET_SPARSE : { bool set_sparse = true ; NTSTATUS status ; if ( in_len >= 1 && in_data [ 0 ] == 0 ) { set_sparse = false ; } status = file_set_sparse ( handle -> conn , fsp , set_sparse ) ; DEBUG ( NT_STATUS_IS_OK ( status ) ? 10 : 9 , ( \"FSCTL_SET_SPARSE:<S2SV_blank>fname[%s]<S2SV_blank>set[%u]<S2SV_blank>-<S2SV_blank>%s\\\\n\" , smb_fname_str_dbg ( fsp -> fsp_name ) , set_sparse , nt_errstr ( status ) ) ) ; return status ; } case FSCTL_CREATE_OR_GET_OBJECT_ID : { unsigned char objid [ 16 ] ; char * return_data = NULL ; DEBUG ( 10 , ( \"FSCTL_CREATE_OR_GET_OBJECT_ID:<S2SV_blank>called<S2SV_blank>on<S2SV_blank>%s\\\\n\" , fsp_fnum_dbg ( fsp ) ) ) ; * out_len = ( max_out_len >= 64 ) ? 64 : max_out_len ; return_data = talloc_array ( ctx , char , 64 ) ; if ( return_data == NULL ) { return NT_STATUS_NO_MEMORY ; } push_file_id_16 ( return_data , & fsp -> file_id ) ; memcpy ( return_data + 16 , create_volume_objectid ( fsp -> conn , objid ) , 16 ) ; push_file_id_16 ( return_data + 32 , & fsp -> file_id ) ; * out_data = return_data ; return NT_STATUS_OK ; } case FSCTL_GET_REPARSE_POINT : { DEBUG ( 10 , ( \"FSCTL_GET_REPARSE_POINT:<S2SV_blank>called<S2SV_blank>on<S2SV_blank>%s.<S2SV_blank>\" \"Status:<S2SV_blank>NOT_IMPLEMENTED\\\\n\" , fsp_fnum_dbg ( fsp ) ) ) ; return NT_STATUS_NOT_A_REPARSE_POINT ; } case FSCTL_SET_REPARSE_POINT : { DEBUG ( 10 , ( \"FSCTL_SET_REPARSE_POINT:<S2SV_blank>called<S2SV_blank>on<S2SV_blank>%s.<S2SV_blank>\" \"Status:<S2SV_blank>NOT_IMPLEMENTED\\\\n\" , fsp_fnum_dbg ( fsp ) ) ) ; return NT_STATUS_NOT_A_REPARSE_POINT ; } case FSCTL_GET_SHADOW_COPY_DATA : { struct shadow_copy_data * shadow_data = NULL ; bool labels = False ; uint32 labels_data_count = 0 ; uint32 i ; char * cur_pdata = NULL ; if ( max_out_len < 16 ) { DEBUG ( 0 , ( \"FSCTL_GET_SHADOW_COPY_DATA:<S2SV_blank>max_data_count(%u)<S2SV_blank><<S2SV_blank>16<S2SV_blank>is<S2SV_blank>invalid!\\\\n\" , max_out_len ) ) ; return NT_STATUS_INVALID_PARAMETER ; } if ( max_out_len > 16 ) { labels = True ; } shadow_data = talloc_zero ( ctx , struct shadow_copy_data ) ; if ( shadow_data == NULL ) { DEBUG ( 0 , ( \"TALLOC_ZERO()<S2SV_blank>failed!\\\\n\" ) ) ; return NT_STATUS_NO_MEMORY ; } if ( SMB_VFS_GET_SHADOW_COPY_DATA ( fsp , shadow_data , labels ) != 0 ) { TALLOC_FREE ( shadow_data ) ; if ( errno == ENOSYS ) { DEBUG ( 5 , ( \"FSCTL_GET_SHADOW_COPY_DATA:<S2SV_blank>connectpath<S2SV_blank>%s,<S2SV_blank>not<S2SV_blank>supported.\\\\n\" , fsp -> conn -> connectpath ) ) ; return NT_STATUS_NOT_SUPPORTED ; } else { DEBUG ( 0 , ( \"FSCTL_GET_SHADOW_COPY_DATA:<S2SV_blank>connectpath<S2SV_blank>%s,<S2SV_blank>failed.\\\\n\" , fsp -> conn -> connectpath ) ) ; return NT_STATUS_UNSUCCESSFUL ; } } labels_data_count = ( shadow_data -> num_volumes * 2 * sizeof ( SHADOW_COPY_LABEL ) ) + 2 ; if ( ! labels ) { * out_len = 16 ; } else { <S2SV_StartBug> * out_len = 12 + labels_data_count + 4 ; <S2SV_EndBug> } if ( max_out_len < * out_len ) { DEBUG ( 0 , ( \"FSCTL_GET_SHADOW_COPY_DATA:<S2SV_blank>max_data_count(%u)<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>needed!\\\\n\" , max_out_len , * out_len ) ) ; TALLOC_FREE ( shadow_data ) ; return NT_STATUS_BUFFER_TOO_SMALL ; } cur_pdata = talloc_zero_array ( ctx , char , * out_len ) ; if ( cur_pdata == NULL ) { TALLOC_FREE ( shadow_data ) ; return NT_STATUS_NO_MEMORY ; } * out_data = cur_pdata ; SIVAL ( cur_pdata , 0 , shadow_data -> num_volumes ) ; if ( labels ) { SIVAL ( cur_pdata , 4 , shadow_data -> num_volumes ) ; } <S2SV_StartBug> SIVAL ( cur_pdata , 8 , labels_data_count + 4 ) ; <S2SV_EndBug> cur_pdata += 12 ; DEBUG ( 10 , ( \"FSCTL_GET_SHADOW_COPY_DATA:<S2SV_blank>%u<S2SV_blank>volumes<S2SV_blank>for<S2SV_blank>path[%s].\\\\n\" , shadow_data -> num_volumes , fsp_str_dbg ( fsp ) ) ) ; if ( labels && shadow_data -> labels ) { for ( i = 0 ; i < shadow_data -> num_volumes ; i ++ ) { srvstr_push ( cur_pdata , req_flags , cur_pdata , shadow_data -> labels [ i ] , 2 * sizeof ( SHADOW_COPY_LABEL ) , STR_UNICODE | STR_TERMINATE ) ; cur_pdata += 2 * sizeof ( SHADOW_COPY_LABEL ) ; DEBUGADD ( 10 , ( \"Label[%u]:<S2SV_blank>\\'%s\\'\\\\n\" , i , shadow_data -> labels [ i ] ) ) ; } } TALLOC_FREE ( shadow_data ) ; return NT_STATUS_OK ; } case FSCTL_FIND_FILES_BY_SID : { struct dom_sid sid ; uid_t uid ; size_t sid_len ; DEBUG ( 10 , ( \"FSCTL_FIND_FILES_BY_SID:<S2SV_blank>called<S2SV_blank>on<S2SV_blank>%s\\\\n\" , fsp_fnum_dbg ( fsp ) ) ) ; if ( in_len < 8 ) { return NT_STATUS_INVALID_PARAMETER ; } sid_len = MIN ( in_len - 4 , SID_MAX_SIZE ) ; if ( ! sid_parse ( in_data + 4 , sid_len , & sid ) ) { return NT_STATUS_INVALID_PARAMETER ; } DEBUGADD ( 10 , ( \"for<S2SV_blank>SID:<S2SV_blank>%s\\\\n\" , sid_string_dbg ( & sid ) ) ) ; if ( ! sid_to_uid ( & sid , & uid ) ) { DEBUG ( 0 , ( \"sid_to_uid:<S2SV_blank>failed,<S2SV_blank>sid[%s]<S2SV_blank>sid_len[%lu]\\\\n\" , sid_string_dbg ( & sid ) , ( unsigned long ) sid_len ) ) ; uid = ( - 1 ) ; } return NT_STATUS_OK ; } case FSCTL_QUERY_ALLOCATED_RANGES : { NTSTATUS status ; uint64_t offset , length ; char * out_data_tmp = NULL ; if ( in_len != 16 ) { DEBUG ( 0 , ( \"FSCTL_QUERY_ALLOCATED_RANGES:<S2SV_blank>data_count(%u)<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>is<S2SV_blank>invalid!\\\\n\" , in_len ) ) ; return NT_STATUS_INVALID_PARAMETER ; } if ( max_out_len < 16 ) { DEBUG ( 0 , ( \"FSCTL_QUERY_ALLOCATED_RANGES:<S2SV_blank>max_out_len<S2SV_blank>(%u)<S2SV_blank><<S2SV_blank>16<S2SV_blank>is<S2SV_blank>invalid!\\\\n\" , max_out_len ) ) ; return NT_STATUS_INVALID_PARAMETER ; } offset = BVAL ( in_data , 0 ) ; length = BVAL ( in_data , 8 ) ; if ( offset + length < offset ) { return NT_STATUS_INVALID_PARAMETER ; } status = vfs_stat_fsp ( fsp ) ; if ( ! NT_STATUS_IS_OK ( status ) ) { return status ; } * out_len = 16 ; out_data_tmp = talloc_array ( ctx , char , * out_len ) ; if ( out_data_tmp == NULL ) { DEBUG ( 10 , ( \"unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>response\\\\n\" ) ) ; return NT_STATUS_NO_MEMORY ; } if ( offset > fsp -> fsp_name -> st . st_ex_size || fsp -> fsp_name -> st . st_ex_size == 0 || length == 0 ) { memset ( out_data_tmp , 0 , * out_len ) ; } else { uint64_t end = offset + length ; end = MIN ( end , fsp -> fsp_name -> st . st_ex_size ) ; SBVAL ( out_data_tmp , 0 , 0 ) ; SBVAL ( out_data_tmp , 8 , end ) ; } * out_data = out_data_tmp ; return NT_STATUS_OK ; } case FSCTL_IS_VOLUME_DIRTY : { DEBUG ( 10 , ( \"FSCTL_IS_VOLUME_DIRTY:<S2SV_blank>called<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>\" \"(but<S2SV_blank>remotely<S2SV_blank>not<S2SV_blank>supported)\\\\n\" , fsp_fnum_dbg ( fsp ) ) ) ; return NT_STATUS_INVALID_PARAMETER ; } default : if ( ! vfswrap_logged_ioctl_message ) { vfswrap_logged_ioctl_message = true ; DEBUG ( 2 , ( \"%s<S2SV_blank>(0x%x):<S2SV_blank>Currently<S2SV_blank>not<S2SV_blank>implemented.\\\\n\" , __func__ , function ) ) ; } } return NT_STATUS_NOT_SUPPORTED ; }", "target": "<S2SV_ModStart> 12 + labels_data_count <S2SV_ModEnd> ; } if <S2SV_ModStart> 8 , labels_data_count <S2SV_ModEnd> ) ; cur_pdata"}
{"source": "CWE-787 suggest_trie_walk ( suginfo_T * su , langp_T * lp , char_u * fword , int soundfold ) { char_u tword [ MAXWLEN ] ; trystate_T stack [ MAXWLEN ] ; char_u preword [ MAXWLEN * 3 ] ; char_u compflags [ MAXWLEN ] ; trystate_T * sp ; int newscore ; int score ; char_u * byts , * fbyts , * pbyts ; idx_T * idxs , * fidxs , * pidxs ; int depth ; int c , c2 , c3 ; int n = 0 ; int flags ; garray_T * gap ; idx_T arridx ; int len ; char_u * p ; fromto_T * ftp ; int fl = 0 , tl ; int repextra = 0 ; slang_T * slang = lp -> lp_slang ; int fword_ends ; int goodword_ends ; # ifdef DEBUG_TRIEWALK char_u changename [ MAXWLEN ] [ 80 ] ; # endif int breakcheckcount = 1000 ; # ifdef FEAT_RELTIME proftime_T time_limit ; # endif int compound_ok ; depth = 0 ; sp = & stack [ 0 ] ; CLEAR_POINTER ( sp ) ; sp -> ts_curi = 1 ; if ( soundfold ) { byts = fbyts = slang -> sl_sbyts ; idxs = fidxs = slang -> sl_sidxs ; pbyts = NULL ; pidxs = NULL ; sp -> ts_prefixdepth = PFD_NOPREFIX ; sp -> ts_state = STATE_START ; } else { fbyts = slang -> sl_fbyts ; fidxs = slang -> sl_fidxs ; pbyts = slang -> sl_pbyts ; pidxs = slang -> sl_pidxs ; if ( pbyts != NULL ) { byts = pbyts ; idxs = pidxs ; sp -> ts_prefixdepth = PFD_PREFIXTREE ; sp -> ts_state = STATE_NOPREFIX ; } else { byts = fbyts ; idxs = fidxs ; sp -> ts_prefixdepth = PFD_NOPREFIX ; sp -> ts_state = STATE_START ; } } # ifdef FEAT_RELTIME if ( spell_suggest_timeout > 0 ) profile_setlimit ( spell_suggest_timeout , & time_limit ) ; # endif while ( depth >= 0 && ! got_int ) { sp = & stack [ depth ] ; switch ( sp -> ts_state ) { case STATE_START : case STATE_NOPREFIX : arridx = sp -> ts_arridx ; len = byts [ arridx ] ; arridx += sp -> ts_curi ; if ( sp -> ts_prefixdepth == PFD_PREFIXTREE ) { for ( n = 0 ; n < len && byts [ arridx + n ] == 0 ; ++ n ) ; sp -> ts_curi += n ; n = ( int ) sp -> ts_state ; PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_ENDNUL ; sp -> ts_save_badflags = su -> su_badflags ; if ( depth < MAXWLEN - 1 && ( byts [ arridx ] == 0 || n == ( int ) STATE_NOPREFIX ) ) { if ( has_mbyte ) n = nofold_len ( fword , sp -> ts_fidx , su -> su_badptr ) ; else n = sp -> ts_fidx ; flags = badword_captype ( su -> su_badptr , su -> su_badptr + n ) ; su -> su_badflags = badword_captype ( su -> su_badptr + n , su -> su_badptr + su -> su_badlen ) ; # ifdef DEBUG_TRIEWALK sprintf ( changename [ depth ] , \"prefix\" ) ; # endif go_deeper ( stack , depth , 0 ) ; ++ depth ; sp = & stack [ depth ] ; sp -> ts_prefixdepth = depth - 1 ; byts = fbyts ; idxs = fidxs ; sp -> ts_arridx = 0 ; tword [ sp -> ts_twordlen ] = NUL ; make_case_word ( tword + sp -> ts_splitoff , preword + sp -> ts_prewordlen , flags ) ; sp -> ts_prewordlen = ( char_u ) STRLEN ( preword ) ; sp -> ts_splitoff = sp -> ts_twordlen ; } break ; } if ( sp -> ts_curi > len || byts [ arridx ] != 0 ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_ENDNUL ; sp -> ts_save_badflags = su -> su_badflags ; break ; } ++ sp -> ts_curi ; flags = ( int ) idxs [ arridx ] ; if ( flags & WF_NOSUGGEST ) break ; fword_ends = ( fword [ sp -> ts_fidx ] == NUL || ( soundfold ? VIM_ISWHITE ( fword [ sp -> ts_fidx ] ) : ! spell_iswordp ( fword + sp -> ts_fidx , curwin ) ) ) ; tword [ sp -> ts_twordlen ] = NUL ; if ( sp -> ts_prefixdepth <= PFD_NOTSPECIAL && ( sp -> ts_flags & TSF_PREFIXOK ) == 0 && pbyts != NULL ) { n = stack [ sp -> ts_prefixdepth ] . ts_arridx ; len = pbyts [ n ++ ] ; for ( c = 0 ; c < len && pbyts [ n + c ] == 0 ; ++ c ) ; if ( c > 0 ) { c = valid_word_prefix ( c , n , flags , tword + sp -> ts_splitoff , slang , FALSE ) ; if ( c == 0 ) break ; if ( c & WF_RAREPFX ) flags |= WF_RARE ; sp -> ts_flags |= TSF_PREFIXOK ; } } if ( sp -> ts_complen == sp -> ts_compsplit && fword_ends && ( flags & WF_NEEDCOMP ) ) goodword_ends = FALSE ; else goodword_ends = TRUE ; p = NULL ; compound_ok = TRUE ; if ( sp -> ts_complen > sp -> ts_compsplit ) { if ( slang -> sl_nobreak ) { if ( sp -> ts_fidx - sp -> ts_splitfidx == sp -> ts_twordlen - sp -> ts_splitoff && STRNCMP ( fword + sp -> ts_splitfidx , tword + sp -> ts_splitoff , sp -> ts_fidx - sp -> ts_splitfidx ) == 0 ) { preword [ sp -> ts_prewordlen ] = NUL ; newscore = score_wordcount_adj ( slang , sp -> ts_score , preword + sp -> ts_prewordlen , sp -> ts_prewordlen > 0 ) ; if ( newscore <= su -> su_maxscore ) add_suggestion ( su , & su -> su_ga , preword , sp -> ts_splitfidx - repextra , newscore , 0 , FALSE , lp -> lp_sallang , FALSE ) ; break ; } } else { if ( ( ( unsigned ) flags >> 24 ) == 0 || sp -> ts_twordlen - sp -> ts_splitoff < slang -> sl_compminlen ) break ; if ( has_mbyte && slang -> sl_compminlen > 0 && mb_charlen ( tword + sp -> ts_splitoff ) < slang -> sl_compminlen ) break ; compflags [ sp -> ts_complen ] = ( ( unsigned ) flags >> 24 ) ; compflags [ sp -> ts_complen + 1 ] = NUL ; vim_strncpy ( preword + sp -> ts_prewordlen , tword + sp -> ts_splitoff , sp -> ts_twordlen - sp -> ts_splitoff ) ; if ( match_checkcompoundpattern ( preword , sp -> ts_prewordlen , & slang -> sl_comppat ) ) compound_ok = FALSE ; if ( compound_ok ) { p = preword ; while ( * skiptowhite ( p ) != NUL ) p = skipwhite ( skiptowhite ( p ) ) ; if ( fword_ends && ! can_compound ( slang , p , compflags + sp -> ts_compsplit ) ) compound_ok = FALSE ; } p = preword + sp -> ts_prewordlen ; MB_PTR_BACK ( preword , p ) ; } } if ( soundfold ) STRCPY ( preword + sp -> ts_prewordlen , tword + sp -> ts_splitoff ) ; else if ( flags & WF_KEEPCAP ) find_keepcap_word ( slang , tword + sp -> ts_splitoff , preword + sp -> ts_prewordlen ) ; else { c = su -> su_badflags ; if ( ( c & WF_ALLCAP ) && su -> su_badlen == ( * mb_ptr2len ) ( su -> su_badptr ) ) c = WF_ONECAP ; c |= flags ; if ( p != NULL && spell_iswordp_nmw ( p , curwin ) ) c &= ~ WF_ONECAP ; make_case_word ( tword + sp -> ts_splitoff , preword + sp -> ts_prewordlen , c ) ; } if ( ! soundfold ) { if ( flags & WF_BANNED ) { add_banned ( su , preword + sp -> ts_prewordlen ) ; break ; } if ( ( sp -> ts_complen == sp -> ts_compsplit && WAS_BANNED ( su , preword + sp -> ts_prewordlen ) ) || WAS_BANNED ( su , preword ) ) { if ( slang -> sl_compprog == NULL ) break ; goodword_ends = FALSE ; } } newscore = 0 ; if ( ! soundfold ) { if ( ( flags & WF_REGION ) && ( ( ( unsigned ) flags >> 16 ) & lp -> lp_region ) == 0 ) newscore += SCORE_REGION ; if ( flags & WF_RARE ) newscore += SCORE_RARE ; if ( ! spell_valid_case ( su -> su_badflags , captype ( preword + sp -> ts_prewordlen , NULL ) ) ) newscore += SCORE_ICASE ; } if ( fword_ends && goodword_ends && sp -> ts_fidx >= sp -> ts_fidxtry && compound_ok ) { # ifdef DEBUG_TRIEWALK if ( soundfold && STRCMP ( preword , \"smwrd\" ) == 0 ) { int j ; smsg ( \"------<S2SV_blank>%s<S2SV_blank>-------\" , fword ) ; for ( j = 0 ; j < depth ; ++ j ) smsg ( \"%s\" , changename [ j ] ) ; } # endif if ( soundfold ) { add_sound_suggest ( su , preword , sp -> ts_score , lp ) ; } else if ( sp -> ts_fidx > 0 ) { p = fword + sp -> ts_fidx ; MB_PTR_BACK ( fword , p ) ; if ( ! spell_iswordp ( p , curwin ) && * preword != NUL ) { p = preword + STRLEN ( preword ) ; MB_PTR_BACK ( preword , p ) ; if ( spell_iswordp ( p , curwin ) ) newscore += SCORE_NONWORD ; } score = score_wordcount_adj ( slang , sp -> ts_score + newscore , preword + sp -> ts_prewordlen , sp -> ts_prewordlen > 0 ) ; if ( score <= su -> su_maxscore ) { add_suggestion ( su , & su -> su_ga , preword , sp -> ts_fidx - repextra , score , 0 , FALSE , lp -> lp_sallang , FALSE ) ; if ( su -> su_badflags & WF_MIXCAP ) { c = captype ( preword , NULL ) ; if ( c == 0 || c == WF_ALLCAP ) { make_case_word ( tword + sp -> ts_splitoff , preword + sp -> ts_prewordlen , c == 0 ? WF_ALLCAP : 0 ) ; add_suggestion ( su , & su -> su_ga , preword , sp -> ts_fidx - repextra , score + SCORE_ICASE , 0 , FALSE , lp -> lp_sallang , FALSE ) ; } } } } } if ( ( sp -> ts_fidx >= sp -> ts_fidxtry || fword_ends ) && ( ! has_mbyte || sp -> ts_tcharlen == 0 ) ) { int try_compound ; int try_split ; try_split = ( sp -> ts_fidx - repextra < su -> su_badlen ) && ! soundfold ; try_compound = FALSE ; if ( ! soundfold && ! slang -> sl_nocompoundsugs && slang -> sl_compprog != NULL && ( ( unsigned ) flags >> 24 ) != 0 && sp -> ts_twordlen - sp -> ts_splitoff >= slang -> sl_compminlen && ( ! has_mbyte || slang -> sl_compminlen == 0 || mb_charlen ( tword + sp -> ts_splitoff ) >= slang -> sl_compminlen ) && ( slang -> sl_compsylmax < MAXWLEN || sp -> ts_complen + 1 - sp -> ts_compsplit < slang -> sl_compmax ) && ( can_be_compound ( sp , slang , compflags , ( ( unsigned ) flags >> 24 ) ) ) ) { try_compound = TRUE ; compflags [ sp -> ts_complen ] = ( ( unsigned ) flags >> 24 ) ; compflags [ sp -> ts_complen + 1 ] = NUL ; } if ( slang -> sl_nobreak && ! slang -> sl_nocompoundsugs ) try_compound = TRUE ; else if ( ! fword_ends && try_compound && ( sp -> ts_flags & TSF_DIDSPLIT ) == 0 ) { try_compound = FALSE ; sp -> ts_flags |= TSF_DIDSPLIT ; -- sp -> ts_curi ; compflags [ sp -> ts_complen ] = NUL ; } else sp -> ts_flags &= ~ TSF_DIDSPLIT ; if ( try_split || try_compound ) { if ( ! try_compound && ( ! fword_ends || ! goodword_ends ) ) { if ( sp -> ts_complen == sp -> ts_compsplit && ( flags & WF_NEEDCOMP ) ) break ; p = preword ; while ( * skiptowhite ( p ) != NUL ) p = skipwhite ( skiptowhite ( p ) ) ; if ( sp -> ts_complen > sp -> ts_compsplit && ! can_compound ( slang , p , compflags + sp -> ts_compsplit ) ) break ; if ( slang -> sl_nosplitsugs ) newscore += SCORE_SPLIT_NO ; else newscore += SCORE_SPLIT ; newscore = score_wordcount_adj ( slang , newscore , preword + sp -> ts_prewordlen , TRUE ) ; } if ( TRY_DEEPER ( su , stack , depth , newscore ) ) { go_deeper ( stack , depth , newscore ) ; # ifdef DEBUG_TRIEWALK if ( ! try_compound && ! fword_ends ) sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>split\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx ) ; else sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>compound\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx ) ; # endif sp -> ts_save_badflags = su -> su_badflags ; PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_SPLITUNDO ; ++ depth ; sp = & stack [ depth ] ; if ( ! try_compound && ! fword_ends ) STRCAT ( preword , \"<S2SV_blank>\" ) ; sp -> ts_prewordlen = ( char_u ) STRLEN ( preword ) ; sp -> ts_splitoff = sp -> ts_twordlen ; sp -> ts_splitfidx = sp -> ts_fidx ; if ( ( ( ! try_compound && ! spell_iswordp_nmw ( fword + sp -> ts_fidx , curwin ) ) || fword_ends ) && fword [ sp -> ts_fidx ] != NUL && goodword_ends ) { int l ; l = mb_ptr2len ( fword + sp -> ts_fidx ) ; if ( fword_ends ) { mch_memmove ( preword + sp -> ts_prewordlen , fword + sp -> ts_fidx , l ) ; sp -> ts_prewordlen += l ; preword [ sp -> ts_prewordlen ] = NUL ; } else sp -> ts_score -= SCORE_SPLIT - SCORE_SUBST ; sp -> ts_fidx += l ; } if ( try_compound ) ++ sp -> ts_complen ; else sp -> ts_compsplit = sp -> ts_complen ; sp -> ts_prefixdepth = PFD_NOPREFIX ; if ( has_mbyte ) n = nofold_len ( fword , sp -> ts_fidx , su -> su_badptr ) ; else n = sp -> ts_fidx ; su -> su_badflags = badword_captype ( su -> su_badptr + n , su -> su_badptr + su -> su_badlen ) ; sp -> ts_arridx = 0 ; if ( pbyts != NULL ) { byts = pbyts ; idxs = pidxs ; sp -> ts_prefixdepth = PFD_PREFIXTREE ; PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_NOPREFIX ; } } } } break ; case STATE_SPLITUNDO : su -> su_badflags = sp -> ts_save_badflags ; PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_START ; byts = fbyts ; idxs = fidxs ; break ; case STATE_ENDNUL : su -> su_badflags = sp -> ts_save_badflags ; if ( fword [ sp -> ts_fidx ] == NUL && sp -> ts_tcharlen == 0 ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_DEL ; break ; } PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_PLAIN ; case STATE_PLAIN : arridx = sp -> ts_arridx ; if ( sp -> ts_curi > byts [ arridx ] ) { PROF_STORE ( sp -> ts_state ) if ( sp -> ts_fidx >= sp -> ts_fidxtry ) sp -> ts_state = STATE_DEL ; else sp -> ts_state = STATE_FINAL ; } else { arridx += sp -> ts_curi ++ ; c = byts [ arridx ] ; if ( c == fword [ sp -> ts_fidx ] || ( sp -> ts_tcharlen > 0 && sp -> ts_isdiff != DIFF_NONE ) ) newscore = 0 ; else newscore = SCORE_SUBST ; if ( ( newscore == 0 || ( sp -> ts_fidx >= sp -> ts_fidxtry && ( ( sp -> ts_flags & TSF_DIDDEL ) == 0 || c != fword [ sp -> ts_delidx ] ) ) ) && TRY_DEEPER ( su , stack , depth , newscore ) ) { go_deeper ( stack , depth , newscore ) ; # ifdef DEBUG_TRIEWALK if ( newscore > 0 ) sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>subst<S2SV_blank>%c<S2SV_blank>to<S2SV_blank>%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , fword [ sp -> ts_fidx ] , c ) ; else sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>accept<S2SV_blank>%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , fword [ sp -> ts_fidx ] ) ; # endif ++ depth ; sp = & stack [ depth ] ; if ( fword [ sp -> ts_fidx ] != NUL ) ++ sp -> ts_fidx ; tword [ sp -> ts_twordlen ++ ] = c ; sp -> ts_arridx = idxs [ arridx ] ; if ( newscore == SCORE_SUBST ) sp -> ts_isdiff = DIFF_YES ; if ( has_mbyte ) { if ( sp -> ts_tcharlen == 0 ) { sp -> ts_tcharidx = 0 ; sp -> ts_tcharlen = MB_BYTE2LEN ( c ) ; sp -> ts_fcharstart = sp -> ts_fidx - 1 ; sp -> ts_isdiff = ( newscore != 0 ) ? DIFF_YES : DIFF_NONE ; } <S2SV_StartBug> else if ( sp -> ts_isdiff == DIFF_INSERT ) <S2SV_EndBug> -- sp -> ts_fidx ; if ( ++ sp -> ts_tcharidx == sp -> ts_tcharlen ) { if ( sp -> ts_isdiff == DIFF_YES ) { sp -> ts_fidx = sp -> ts_fcharstart + mb_ptr2len ( fword + sp -> ts_fcharstart ) ; if ( enc_utf8 && utf_iscomposing ( utf_ptr2char ( tword + sp -> ts_twordlen - sp -> ts_tcharlen ) ) && utf_iscomposing ( utf_ptr2char ( fword + sp -> ts_fcharstart ) ) ) sp -> ts_score -= SCORE_SUBST - SCORE_SUBCOMP ; else if ( ! soundfold && slang -> sl_has_map && similar_chars ( slang , mb_ptr2char ( tword + sp -> ts_twordlen - sp -> ts_tcharlen ) , mb_ptr2char ( fword + sp -> ts_fcharstart ) ) ) sp -> ts_score -= SCORE_SUBST - SCORE_SIMILAR ; } else if ( sp -> ts_isdiff == DIFF_INSERT && sp -> ts_twordlen > sp -> ts_tcharlen ) { p = tword + sp -> ts_twordlen - sp -> ts_tcharlen ; c = mb_ptr2char ( p ) ; if ( enc_utf8 && utf_iscomposing ( c ) ) { sp -> ts_score -= SCORE_INS - SCORE_INSCOMP ; } else { MB_PTR_BACK ( tword , p ) ; if ( c == mb_ptr2char ( p ) ) sp -> ts_score -= SCORE_INS - SCORE_INSDUP ; } } sp -> ts_tcharlen = 0 ; } } else { if ( newscore != 0 && ! soundfold && slang -> sl_has_map && similar_chars ( slang , c , fword [ sp -> ts_fidx - 1 ] ) ) sp -> ts_score -= SCORE_SUBST - SCORE_SIMILAR ; } } } break ; case STATE_DEL : if ( has_mbyte && sp -> ts_tcharlen > 0 ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_FINAL ; break ; } PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_INS_PREP ; sp -> ts_curi = 1 ; if ( soundfold && sp -> ts_fidx == 0 && fword [ sp -> ts_fidx ] == '*' ) newscore = 2 * SCORE_DEL / 3 ; else newscore = SCORE_DEL ; if ( fword [ sp -> ts_fidx ] != NUL && TRY_DEEPER ( su , stack , depth , newscore ) ) { go_deeper ( stack , depth , newscore ) ; # ifdef DEBUG_TRIEWALK sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>delete<S2SV_blank>%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , fword [ sp -> ts_fidx ] ) ; # endif ++ depth ; stack [ depth ] . ts_flags |= TSF_DIDDEL ; stack [ depth ] . ts_delidx = sp -> ts_fidx ; if ( has_mbyte ) { c = mb_ptr2char ( fword + sp -> ts_fidx ) ; stack [ depth ] . ts_fidx += mb_ptr2len ( fword + sp -> ts_fidx ) ; if ( enc_utf8 && utf_iscomposing ( c ) ) stack [ depth ] . ts_score -= SCORE_DEL - SCORE_DELCOMP ; else if ( c == mb_ptr2char ( fword + stack [ depth ] . ts_fidx ) ) stack [ depth ] . ts_score -= SCORE_DEL - SCORE_DELDUP ; } else { ++ stack [ depth ] . ts_fidx ; if ( fword [ sp -> ts_fidx ] == fword [ sp -> ts_fidx + 1 ] ) stack [ depth ] . ts_score -= SCORE_DEL - SCORE_DELDUP ; } break ; } case STATE_INS_PREP : if ( sp -> ts_flags & TSF_DIDDEL ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_SWAP ; break ; } n = sp -> ts_arridx ; for ( ; ; ) { if ( sp -> ts_curi > byts [ n ] ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_SWAP ; break ; } if ( byts [ n + sp -> ts_curi ] != NUL ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_INS ; break ; } ++ sp -> ts_curi ; } break ; case STATE_INS : n = sp -> ts_arridx ; if ( sp -> ts_curi > byts [ n ] ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_SWAP ; break ; } n += sp -> ts_curi ++ ; c = byts [ n ] ; if ( soundfold && sp -> ts_twordlen == 0 && c == '*' ) newscore = 2 * SCORE_INS / 3 ; else newscore = SCORE_INS ; if ( c != fword [ sp -> ts_fidx ] && TRY_DEEPER ( su , stack , depth , newscore ) ) { go_deeper ( stack , depth , newscore ) ; # ifdef DEBUG_TRIEWALK sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>insert<S2SV_blank>%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , c ) ; # endif ++ depth ; sp = & stack [ depth ] ; tword [ sp -> ts_twordlen ++ ] = c ; sp -> ts_arridx = idxs [ n ] ; if ( has_mbyte ) { fl = MB_BYTE2LEN ( c ) ; if ( fl > 1 ) { sp -> ts_tcharlen = fl ; sp -> ts_tcharidx = 1 ; sp -> ts_isdiff = DIFF_INSERT ; } } else fl = 1 ; if ( fl == 1 ) { if ( sp -> ts_twordlen >= 2 && tword [ sp -> ts_twordlen - 2 ] == c ) sp -> ts_score -= SCORE_INS - SCORE_INSDUP ; } } break ; case STATE_SWAP : p = fword + sp -> ts_fidx ; c = * p ; if ( c == NUL ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_FINAL ; break ; } if ( ! soundfold && ! spell_iswordp ( p , curwin ) ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; break ; } if ( has_mbyte ) { n = MB_CPTR2LEN ( p ) ; c = mb_ptr2char ( p ) ; if ( p [ n ] == NUL ) c2 = NUL ; else if ( ! soundfold && ! spell_iswordp ( p + n , curwin ) ) c2 = c ; else c2 = mb_ptr2char ( p + n ) ; } else { if ( p [ 1 ] == NUL ) c2 = NUL ; else if ( ! soundfold && ! spell_iswordp ( p + 1 , curwin ) ) c2 = c ; else c2 = p [ 1 ] ; } if ( c2 == NUL ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; break ; } if ( c == c2 ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_SWAP3 ; break ; } if ( c2 != NUL && TRY_DEEPER ( su , stack , depth , SCORE_SWAP ) ) { go_deeper ( stack , depth , SCORE_SWAP ) ; # ifdef DEBUG_TRIEWALK sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>swap<S2SV_blank>%c<S2SV_blank>and<S2SV_blank>%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , c , c2 ) ; # endif PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_UNSWAP ; ++ depth ; if ( has_mbyte ) { fl = mb_char2len ( c2 ) ; mch_memmove ( p , p + n , fl ) ; mb_char2bytes ( c , p + fl ) ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + n + fl ; } else { p [ 0 ] = c2 ; p [ 1 ] = c ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + 2 ; } } else { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; } break ; case STATE_UNSWAP : p = fword + sp -> ts_fidx ; if ( has_mbyte ) { n = mb_ptr2len ( p ) ; c = mb_ptr2char ( p + n ) ; mch_memmove ( p + mb_ptr2len ( p + n ) , p , n ) ; mb_char2bytes ( c , p ) ; } else { c = * p ; * p = p [ 1 ] ; p [ 1 ] = c ; } case STATE_SWAP3 : p = fword + sp -> ts_fidx ; if ( has_mbyte ) { n = MB_CPTR2LEN ( p ) ; c = mb_ptr2char ( p ) ; fl = MB_CPTR2LEN ( p + n ) ; c2 = mb_ptr2char ( p + n ) ; if ( ! soundfold && ! spell_iswordp ( p + n + fl , curwin ) ) c3 = c ; else c3 = mb_ptr2char ( p + n + fl ) ; } else { c = * p ; c2 = p [ 1 ] ; if ( ! soundfold && ! spell_iswordp ( p + 2 , curwin ) ) c3 = c ; else c3 = p [ 2 ] ; } if ( c == c3 || c3 == NUL ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; break ; } if ( TRY_DEEPER ( su , stack , depth , SCORE_SWAP3 ) ) { go_deeper ( stack , depth , SCORE_SWAP3 ) ; # ifdef DEBUG_TRIEWALK sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>swap3<S2SV_blank>%c<S2SV_blank>and<S2SV_blank>%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , c , c3 ) ; # endif PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_UNSWAP3 ; ++ depth ; if ( has_mbyte ) { tl = mb_char2len ( c3 ) ; mch_memmove ( p , p + n + fl , tl ) ; mb_char2bytes ( c2 , p + tl ) ; mb_char2bytes ( c , p + fl + tl ) ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + n + fl + tl ; } else { p [ 0 ] = p [ 2 ] ; p [ 2 ] = c ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + 3 ; } } else { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; } break ; case STATE_UNSWAP3 : p = fword + sp -> ts_fidx ; if ( has_mbyte ) { n = mb_ptr2len ( p ) ; c2 = mb_ptr2char ( p + n ) ; fl = mb_ptr2len ( p + n ) ; c = mb_ptr2char ( p + n + fl ) ; tl = mb_ptr2len ( p + n + fl ) ; mch_memmove ( p + fl + tl , p , n ) ; mb_char2bytes ( c , p ) ; mb_char2bytes ( c2 , p + tl ) ; p = p + tl ; } else { c = * p ; * p = p [ 2 ] ; p [ 2 ] = c ; ++ p ; } if ( ! soundfold && ! spell_iswordp ( p , curwin ) ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; break ; } if ( TRY_DEEPER ( su , stack , depth , SCORE_SWAP3 ) ) { go_deeper ( stack , depth , SCORE_SWAP3 ) ; # ifdef DEBUG_TRIEWALK p = fword + sp -> ts_fidx ; sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>rotate<S2SV_blank>left<S2SV_blank>%c%c%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , p [ 0 ] , p [ 1 ] , p [ 2 ] ) ; # endif PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_UNROT3L ; ++ depth ; p = fword + sp -> ts_fidx ; if ( has_mbyte ) { n = MB_CPTR2LEN ( p ) ; c = mb_ptr2char ( p ) ; fl = MB_CPTR2LEN ( p + n ) ; fl += MB_CPTR2LEN ( p + n + fl ) ; mch_memmove ( p , p + n , fl ) ; mb_char2bytes ( c , p + fl ) ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + n + fl ; } else { c = * p ; * p = p [ 1 ] ; p [ 1 ] = p [ 2 ] ; p [ 2 ] = c ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + 3 ; } } else { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; } break ; case STATE_UNROT3L : p = fword + sp -> ts_fidx ; if ( has_mbyte ) { n = mb_ptr2len ( p ) ; n += mb_ptr2len ( p + n ) ; c = mb_ptr2char ( p + n ) ; tl = mb_ptr2len ( p + n ) ; mch_memmove ( p + tl , p , n ) ; mb_char2bytes ( c , p ) ; } else { c = p [ 2 ] ; p [ 2 ] = p [ 1 ] ; p [ 1 ] = * p ; * p = c ; } if ( TRY_DEEPER ( su , stack , depth , SCORE_SWAP3 ) ) { go_deeper ( stack , depth , SCORE_SWAP3 ) ; # ifdef DEBUG_TRIEWALK p = fword + sp -> ts_fidx ; sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>rotate<S2SV_blank>right<S2SV_blank>%c%c%c\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , p [ 0 ] , p [ 1 ] , p [ 2 ] ) ; # endif PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_UNROT3R ; ++ depth ; p = fword + sp -> ts_fidx ; if ( has_mbyte ) { n = MB_CPTR2LEN ( p ) ; n += MB_CPTR2LEN ( p + n ) ; c = mb_ptr2char ( p + n ) ; tl = MB_CPTR2LEN ( p + n ) ; mch_memmove ( p + tl , p , n ) ; mb_char2bytes ( c , p ) ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + n + tl ; } else { c = p [ 2 ] ; p [ 2 ] = p [ 1 ] ; p [ 1 ] = * p ; * p = c ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + 3 ; } } else { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_INI ; } break ; case STATE_UNROT3R : p = fword + sp -> ts_fidx ; if ( has_mbyte ) { c = mb_ptr2char ( p ) ; tl = mb_ptr2len ( p ) ; n = mb_ptr2len ( p + tl ) ; n += mb_ptr2len ( p + tl + n ) ; mch_memmove ( p , p + tl , n ) ; mb_char2bytes ( c , p + n ) ; } else { c = * p ; * p = p [ 1 ] ; p [ 1 ] = p [ 2 ] ; p [ 2 ] = c ; } case STATE_REP_INI : if ( ( lp -> lp_replang == NULL && ! soundfold ) || sp -> ts_score + SCORE_REP >= su -> su_maxscore || sp -> ts_fidx < sp -> ts_fidxtry ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_FINAL ; break ; } if ( soundfold ) sp -> ts_curi = slang -> sl_repsal_first [ fword [ sp -> ts_fidx ] ] ; else sp -> ts_curi = lp -> lp_replang -> sl_rep_first [ fword [ sp -> ts_fidx ] ] ; if ( sp -> ts_curi < 0 ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_FINAL ; break ; } PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP ; case STATE_REP : p = fword + sp -> ts_fidx ; if ( soundfold ) gap = & slang -> sl_repsal ; else gap = & lp -> lp_replang -> sl_rep ; while ( sp -> ts_curi < gap -> ga_len ) { ftp = ( fromto_T * ) gap -> ga_data + sp -> ts_curi ++ ; if ( * ftp -> ft_from != * p ) { sp -> ts_curi = gap -> ga_len ; break ; } if ( STRNCMP ( ftp -> ft_from , p , STRLEN ( ftp -> ft_from ) ) == 0 && TRY_DEEPER ( su , stack , depth , SCORE_REP ) ) { go_deeper ( stack , depth , SCORE_REP ) ; # ifdef DEBUG_TRIEWALK sprintf ( changename [ depth ] , \"%.*s-%s:<S2SV_blank>replace<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\" , sp -> ts_twordlen , tword , fword + sp -> ts_fidx , ftp -> ft_from , ftp -> ft_to ) ; # endif PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP_UNDO ; ++ depth ; fl = ( int ) STRLEN ( ftp -> ft_from ) ; tl = ( int ) STRLEN ( ftp -> ft_to ) ; if ( fl != tl ) { STRMOVE ( p + tl , p + fl ) ; repextra += tl - fl ; } mch_memmove ( p , ftp -> ft_to , tl ) ; stack [ depth ] . ts_fidxtry = sp -> ts_fidx + tl ; stack [ depth ] . ts_tcharlen = 0 ; break ; } } if ( sp -> ts_curi >= gap -> ga_len && sp -> ts_state == STATE_REP ) { PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_FINAL ; } break ; case STATE_REP_UNDO : if ( soundfold ) gap = & slang -> sl_repsal ; else gap = & lp -> lp_replang -> sl_rep ; ftp = ( fromto_T * ) gap -> ga_data + sp -> ts_curi - 1 ; fl = ( int ) STRLEN ( ftp -> ft_from ) ; tl = ( int ) STRLEN ( ftp -> ft_to ) ; p = fword + sp -> ts_fidx ; if ( fl != tl ) { STRMOVE ( p + fl , p + tl ) ; repextra -= tl - fl ; } mch_memmove ( p , ftp -> ft_from , fl ) ; PROF_STORE ( sp -> ts_state ) sp -> ts_state = STATE_REP ; break ; default : -- depth ; if ( depth >= 0 && stack [ depth ] . ts_prefixdepth == PFD_PREFIXTREE ) { byts = pbyts ; idxs = pidxs ; } if ( -- breakcheckcount == 0 ) { ui_breakcheck ( ) ; breakcheckcount = 1000 ; # ifdef FEAT_RELTIME if ( spell_suggest_timeout > 0 && profile_passed_limit ( & time_limit ) ) got_int = TRUE ; # endif } } } }", "target": "<S2SV_ModStart> ts_isdiff == DIFF_INSERT && sp -> ts_fidx > 0"}
{"source": "CWE-476 RList * r_bin_ne_get_segments ( r_bin_ne_obj_t * bin ) { int i ; <S2SV_StartBug> if ( ! bin ) { <S2SV_EndBug> return NULL ; } RList * segments = r_list_newf ( free ) ; for ( i = 0 ; i < bin -> ne_header -> SegCount ; i ++ ) { RBinSection * bs = R_NEW0 ( RBinSection ) ; if ( ! bs ) { return segments ; } NE_image_segment_entry * se = & bin -> segment_entries [ i ] ; bs -> size = se -> length ; bs -> vsize = se -> minAllocSz ? se -> minAllocSz : 64000 ; bs -> bits = R_SYS_BITS_16 ; bs -> is_data = se -> flags & IS_DATA ; bs -> perm = __translate_perms ( se -> flags ) ; bs -> paddr = ( ut64 ) se -> offset * bin -> alignment ; bs -> name = r_str_newf ( \"%s.%\" PFMT64d , se -> flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\" , bs -> paddr ) ; bs -> is_segment = true ; r_list_append ( segments , bs ) ; } bin -> segments = segments ; return segments ; }", "target": "<S2SV_ModStart> ( ! bin || ! bin -> segment_entries"}
{"source": "CWE-401 static int fastrpc_dma_buf_attach ( struct dma_buf * dmabuf , struct dma_buf_attachment * attachment ) { struct fastrpc_dma_buf_attachment * a ; struct fastrpc_buf * buffer = dmabuf -> priv ; int ret ; a = kzalloc ( sizeof ( * a ) , GFP_KERNEL ) ; if ( ! a ) return - ENOMEM ; ret = dma_get_sgtable ( buffer -> dev , & a -> sgt , buffer -> virt , FASTRPC_PHYS ( buffer -> phys ) , buffer -> size ) ; if ( ret < 0 ) { dev_err ( buffer -> dev , \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>scatterlist<S2SV_blank>from<S2SV_blank>DMA<S2SV_blank>API\\\\n\" ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } a -> dev = attachment -> dev ; INIT_LIST_HEAD ( & a -> node ) ; attachment -> priv = a ; mutex_lock ( & buffer -> lock ) ; list_add ( & a -> node , & buffer -> attachments ) ; mutex_unlock ( & buffer -> lock ) ; return 0 ; }", "target": "<S2SV_ModStart> \"failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>scatterlist<S2SV_blank>from<S2SV_blank>DMA<S2SV_blank>API\\\\n\" ) ; kfree ( a ) ;"}
{"source": "CWE-787 cvtchar ( register const char * sp ) { unsigned char c = 0 ; int len ; switch ( * sp ) { case '\\\\\\\\' : switch ( * ++ sp ) { case '\\\\'' : case '$' : case '\\\\\\\\' : case '%' : c = UChar ( * sp ) ; len = 2 ; break ; case '\\\\0' : c = '\\\\\\\\' ; len = 1 ; break ; case '0' : case '1' : case '2' : case '3' : len = 1 ; while ( isdigit ( UChar ( * sp ) ) ) { c = UChar ( 8 * c + ( * sp ++ - '0' ) ) ; len ++ ; } break ; default : c = UChar ( * sp ) ; len = ( c != '\\\\0' ) ? 2 : 1 ; break ; } break ; case '^' : <S2SV_StartBug> c = UChar ( * ++ sp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( c == '?' ) <S2SV_EndBug> c = 127 ; <S2SV_StartBug> else <S2SV_EndBug> c &= 0x1f ; <S2SV_StartBug> len = 2 ; <S2SV_EndBug> break ; default : c = UChar ( * sp ) ; len = ( c != '\\\\0' ) ? 1 : 0 ; } if ( isgraph ( c ) && c != ',' && c != '\\\\'' && c != '\\\\\\\\' && c != ':' ) { dp = save_string ( dp , \"%\\\\\\'\" ) ; dp = save_char ( dp , c ) ; dp = save_char ( dp , '\\\\'' ) ; } else if ( c != '\\\\0' ) { dp = save_string ( dp , \"%{\" ) ; if ( c > 99 ) dp = save_char ( dp , c / 100 + '0' ) ; if ( c > 9 ) dp = save_char ( dp , ( ( int ) ( c / 10 ) ) % 10 + '0' ) ; dp = save_char ( dp , c % 10 + '0' ) ; dp = save_char ( dp , '}' ) ; } return len ; }", "target": "<S2SV_ModStart> case '^' : len = 2 ; <S2SV_ModStart> == '?' ) { <S2SV_ModStart> = 127 ; } else if ( c == '\\\\0' ) { len = 1 ; } else { <S2SV_ModEnd> c &= 0x1f <S2SV_ModStart> &= 0x1f ; } <S2SV_ModEnd> break ; default"}
{"source": "CWE-703 call_qftf_func ( qf_list_T * qfl , int qf_winid , long start_idx , long end_idx ) { callback_T * cb = & qftf_cb ; <S2SV_StartBug> list_T * qftf_list = NULL ; <S2SV_EndBug> if ( qfl -> qf_qftf_cb . cb_name != NULL ) cb = & qfl -> qf_qftf_cb ; if ( cb -> cb_name != NULL ) { typval_T args [ 1 ] ; dict_T * d ; typval_T rettv ; if ( ( d = dict_alloc_lock ( VAR_FIXED ) ) == NULL ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> dict_add_number ( d , \"quickfix\" , ( long ) IS_QF_LIST ( qfl ) ) ; dict_add_number ( d , \"winid\" , ( long ) qf_winid ) ; dict_add_number ( d , \"id\" , ( long ) qfl -> qf_id ) ; dict_add_number ( d , \"start_idx\" , start_idx ) ; dict_add_number ( d , \"end_idx\" , end_idx ) ; ++ d -> dv_refcount ; args [ 0 ] . v_type = VAR_DICT ; args [ 0 ] . vval . v_dict = d ; qftf_list = NULL ; if ( call_callback ( cb , 0 , & rettv , 1 , args ) != FAIL ) { if ( rettv . v_type == VAR_LIST ) { qftf_list = rettv . vval . v_list ; qftf_list -> lv_refcount ++ ; } clear_tv ( & rettv ) ; } dict_unref ( d ) ; } <S2SV_StartBug> return qftf_list ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> qftf_list = NULL ; static int recursive = FALSE ; if ( recursive ) return NULL ; recursive = TRUE <S2SV_ModStart> == NULL ) { recursive = FALSE ; <S2SV_ModStart> return NULL ; } <S2SV_ModStart> ) ; } recursive = FALSE ;"}
{"source": "CWE-212 testBackingParse ( const void * args ) { const struct testBackingParseData * data = args ; g_auto ( virBuffer ) buf = VIR_BUFFER_INITIALIZER ; g_autofree char * xml = NULL ; g_autoptr ( virStorageSource ) src = NULL ; int rc ; int erc = data -> rv ; <S2SV_StartBug> <S2SV_EndBug> if ( ! data -> expect ) erc = - 1 ; if ( ( rc = virStorageSourceNewFromBackingAbsolute ( data -> backing , & src ) ) != erc ) { fprintf ( stderr , \"expected<S2SV_blank>return<S2SV_blank>value<S2SV_blank>\\'%d\\'<S2SV_blank>actual<S2SV_blank>\\'%d\\'\\\\n\" , erc , rc ) ; return - 1 ; } if ( ! src ) return 0 ; if ( src && ! data -> expect ) { fprintf ( stderr , \"parsing<S2SV_blank>of<S2SV_blank>backing<S2SV_blank>store<S2SV_blank>string<S2SV_blank>\\'%s\\'<S2SV_blank>should<S2SV_blank>\" \"have<S2SV_blank>failed\\\\n\" , data -> backing ) ; return - 1 ; } <S2SV_StartBug> if ( virDomainDiskSourceFormat ( & buf , src , \"source\" , 0 , false , 0 , true , NULL ) < 0 || <S2SV_EndBug> ! ( xml = virBufferContentAndReset ( & buf ) ) ) { fprintf ( stderr , \"failed<S2SV_blank>to<S2SV_blank>format<S2SV_blank>disk<S2SV_blank>source<S2SV_blank>xml\\\\n\" ) ; return - 1 ; } if ( STRNEQ ( xml , data -> expect ) ) { fprintf ( stderr , \"\\\\n<S2SV_blank>backing<S2SV_blank>store<S2SV_blank>string<S2SV_blank>\\'%s\\'\\\\n\" \"expected<S2SV_blank>storage<S2SV_blank>source<S2SV_blank>xml:\\\\n%s\\\\n\" \"actual<S2SV_blank>storage<S2SV_blank>source<S2SV_blank>xml:\\\\n%s\\\\n\" , data -> backing , data -> expect , xml ) ; return - 1 ; } return 0 ; }", "target": "<S2SV_ModStart> -> rv ; unsigned int xmlformatflags = VIR_DOMAIN_DEF_FORMAT_SECURE ; <S2SV_ModStart> , false , xmlformatflags <S2SV_ModEnd> , true ,"}
{"source": "CWE-787 get_visual_text ( cmdarg_T * cap , char_u * * pp , int * lenp ) { if ( VIsual_mode != 'V' ) unadjust_for_sel ( ) ; if ( VIsual . lnum != curwin -> w_cursor . lnum ) { if ( cap != NULL ) clearopbeep ( cap -> oap ) ; return FAIL ; } if ( VIsual_mode == 'V' ) { * pp = ml_get_curline ( ) ; * lenp = ( int ) STRLEN ( * pp ) ; } else { if ( LT_POS ( curwin -> w_cursor , VIsual ) ) { * pp = ml_get_pos ( & curwin -> w_cursor ) ; * lenp = VIsual . col - curwin -> w_cursor . col + 1 ; } else { * pp = ml_get_pos ( & VIsual ) ; * lenp = curwin -> w_cursor . col - VIsual . col + 1 ; } if ( * * pp == NUL ) * lenp = 0 ; <S2SV_StartBug> if ( has_mbyte && * lenp > 0 ) <S2SV_EndBug> <S2SV_StartBug> * lenp += ( * mb_ptr2len ) ( * pp + ( * lenp - 1 ) ) - 1 ; <S2SV_EndBug> } reset_VIsual_and_resel ( ) ; return OK ; }", "target": "<S2SV_ModStart> ; if ( <S2SV_ModEnd> * lenp > <S2SV_ModStart> > 0 ) { if ( has_mbyte ) <S2SV_ModStart> - 1 ; else if ( ( * pp ) [ * lenp - 1 ] == NUL ) * lenp -= 1 ; }"}
{"source": "CWE-787 static int print_media_desc ( const pjmedia_sdp_media * m , char * buf , pj_size_t len ) { char * p = buf ; char * end = buf + len ; unsigned i ; int printed ; if ( len < ( pj_size_t ) m -> desc . media . slen + m -> desc . transport . slen + 12 + 24 ) { return - 1 ; } * p ++ = 'm' ; * p ++ = '=' ; pj_memcpy ( p , m -> desc . media . ptr , m -> desc . media . slen ) ; p += m -> desc . media . slen ; * p ++ = '<S2SV_blank>' ; printed = pj_utoa ( m -> desc . port , p ) ; p += printed ; if ( m -> desc . port_count > 1 ) { * p ++ = '/' ; printed = pj_utoa ( m -> desc . port_count , p ) ; p += printed ; } * p ++ = '<S2SV_blank>' ; pj_memcpy ( p , m -> desc . transport . ptr , m -> desc . transport . slen ) ; p += m -> desc . transport . slen ; for ( i = 0 ; i < m -> desc . fmt_count ; ++ i ) { <S2SV_StartBug> * p ++ = '<S2SV_blank>' ; <S2SV_EndBug> <S2SV_StartBug> pj_memcpy ( p , m -> desc . fmt [ i ] . ptr , m -> desc . fmt [ i ] . slen ) ; <S2SV_EndBug> <S2SV_StartBug> p += m -> desc . fmt [ i ] . slen ; <S2SV_EndBug> } * p ++ = '\\\\r' ; <S2SV_StartBug> * p ++ = '\\\\n' ; <S2SV_EndBug> if ( m -> conn ) { printed = print_connection_info ( m -> conn , p , ( int ) ( end - p ) ) ; if ( printed < 0 ) { return - 1 ; } p += printed ; } for ( i = 0 ; i < m -> bandw_count ; ++ i ) { printed = ( int ) print_bandw ( m -> bandw [ i ] , p , end - p ) ; if ( printed < 0 ) { return - 1 ; } p += printed ; } for ( i = 0 ; i < m -> attr_count ; ++ i ) { printed = ( int ) print_attr ( m -> attr [ i ] , p , end - p ) ; if ( printed < 0 ) { return - 1 ; } p += printed ; } return ( int ) ( p - buf ) ; }", "target": "<S2SV_ModStart> i ) { if ( end - p > <S2SV_ModEnd> m -> desc <S2SV_ModStart> i ] . slen ) { * p ++ = '<S2SV_blank>' ; pj_memcpy ( p <S2SV_ModEnd> , m -> <S2SV_ModStart> i ] . ptr , <S2SV_ModEnd> m -> desc <S2SV_ModStart> ] . slen ) ; p += m -> desc . fmt [ i ] . slen ; } else { return - 1 ; } } if ( end - p >= 2 ) { <S2SV_ModEnd> * p ++ <S2SV_ModStart> = '\\\\n' ; } else { return - 1 ; }"}
{"source": "CWE-416 static int selinux_ptrace_traceme ( struct task_struct * parent ) { return avc_has_perm ( & selinux_state , <S2SV_StartBug> task_sid_subj ( parent ) , task_sid_obj ( current ) , <S2SV_EndBug> SECCLASS_PROCESS , PROCESS__PTRACE , NULL ) ; }", "target": "<S2SV_ModStart> & selinux_state , task_sid_obj <S2SV_ModEnd> ( parent )"}
{"source": "CWE-415 static int rsi_init_usb_interface ( struct rsi_hw * adapter , struct usb_interface * pfunction ) { struct rsi_91x_usbdev * rsi_dev ; int status ; rsi_dev = kzalloc ( sizeof ( * rsi_dev ) , GFP_KERNEL ) ; if ( ! rsi_dev ) return - ENOMEM ; adapter -> rsi_dev = rsi_dev ; rsi_dev -> usbdev = interface_to_usbdev ( pfunction ) ; rsi_dev -> priv = ( void * ) adapter ; if ( rsi_find_bulk_in_and_out_endpoints ( pfunction , adapter ) ) { status = - EINVAL ; goto fail_eps ; } adapter -> device = & pfunction -> dev ; usb_set_intfdata ( pfunction , adapter ) ; rsi_dev -> tx_buffer = kmalloc ( 2048 , GFP_KERNEL ) ; if ( ! rsi_dev -> tx_buffer ) { status = - ENOMEM ; goto fail_eps ; } if ( rsi_usb_init_rx ( adapter ) ) { rsi_dbg ( ERR_ZONE , \"Failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>RX<S2SV_blank>handle\\\\n\" ) ; status = - ENOMEM ; goto fail_rx ; } rsi_dev -> tx_blk_size = 252 ; adapter -> block_size = rsi_dev -> tx_blk_size ; adapter -> check_hw_queue_status = rsi_usb_check_queue_status ; adapter -> determine_event_timeout = rsi_usb_event_timeout ; adapter -> rsi_host_intf = RSI_HOST_INTF_USB ; adapter -> host_intf_ops = & usb_host_intf_ops ; # ifdef CONFIG_RSI_DEBUGFS adapter -> num_debugfs_entries = ( MAX_DEBUGFS_ENTRIES - 1 ) ; # endif rsi_dbg ( INIT_ZONE , \"%s:<S2SV_blank>Enabled<S2SV_blank>the<S2SV_blank>interface\\\\n\" , __func__ ) ; return 0 ; fail_rx : kfree ( rsi_dev -> tx_buffer ) ; fail_eps : <S2SV_StartBug> kfree ( rsi_dev ) ; <S2SV_EndBug> return status ; }", "target": "<S2SV_ModStart> ; fail_eps : <S2SV_ModEnd> return status ;"}
{"source": "CWE-787 drill_parse_T_code ( gerb_file_t * fd , drill_state_t * state , gerbv_image_t * image , ssize_t file_line ) { int tool_num ; gboolean done = FALSE ; int temp ; double size ; gerbv_drill_stats_t * stats = image -> drill_stats ; gerbv_aperture_t * apert ; gchar * tmps ; gchar * string ; dprintf ( \"---><S2SV_blank>entering<S2SV_blank>%s()...\\\\n\" , __FUNCTION__ ) ; temp = gerb_fgetc ( fd ) ; dprintf ( \"<S2SV_blank><S2SV_blank>Found<S2SV_blank>a<S2SV_blank>char<S2SV_blank>\\'%s\\'<S2SV_blank>(0x%02x)<S2SV_blank>after<S2SV_blank>the<S2SV_blank>T\\\\n\" , gerbv_escape_char ( temp ) , temp ) ; if ( ( temp == 'C' ) && ( ( fd -> ptr + 2 ) < fd -> datalen ) ) { if ( gerb_fgetc ( fd ) == 'S' ) { if ( gerb_fgetc ( fd ) == 'T' ) { fd -> ptr -= 4 ; tmps = get_line ( fd ++ ) ; gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_NOTE , - 1 , _ ( \"Tool<S2SV_blank>change<S2SV_blank>stop<S2SV_blank>switch<S2SV_blank>found<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\" \"at<S2SV_blank>line<S2SV_blank>%ld<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , tmps , file_line , fd -> filename ) ; g_free ( tmps ) ; return - 1 ; } gerb_ungetc ( fd ) ; } gerb_ungetc ( fd ) ; } if ( ! ( isdigit ( temp ) != 0 || temp == '+' || temp == '-' ) ) { if ( temp != EOF ) { gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_ERROR , - 1 , _ ( \"OrCAD<S2SV_blank>bug:<S2SV_blank>Junk<S2SV_blank>text<S2SV_blank>found<S2SV_blank>in<S2SV_blank>place<S2SV_blank>of<S2SV_blank>tool<S2SV_blank>definition\" ) ) ; tmps = get_line ( fd ) ; gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_WARNING , - 1 , _ ( \"Junk<S2SV_blank>text<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\" \"at<S2SV_blank>line<S2SV_blank>%ld<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , tmps , file_line , fd -> filename ) ; g_free ( tmps ) ; gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_WARNING , - 1 , _ ( \"Ignoring<S2SV_blank>junk<S2SV_blank>text\" ) ) ; } return - 1 ; } gerb_ungetc ( fd ) ; tool_num = ( int ) gerb_fgetint ( fd , NULL ) ; dprintf ( \"<S2SV_blank><S2SV_blank>Handling<S2SV_blank>tool<S2SV_blank>T%d<S2SV_blank>at<S2SV_blank>line<S2SV_blank>%ld\\\\n\" , tool_num , file_line ) ; if ( tool_num == 0 ) return tool_num ; if ( tool_num < TOOL_MIN || tool_num >= TOOL_MAX ) { gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_ERROR , - 1 , _ ( \"Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>drill<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>\" \"at<S2SV_blank>line<S2SV_blank>%ld<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , <S2SV_StartBug> tool_num , file_line , fd -> filename ) ; <S2SV_EndBug> } state -> current_tool = tool_num ; apert = image -> aperture [ tool_num ] ; temp = gerb_fgetc ( fd ) ; while ( ! done ) { switch ( ( char ) temp ) { case 'C' : size = read_double ( fd , state -> header_number_format , GERBV_OMIT_ZEROS_TRAILING , state -> decimals ) ; dprintf ( \"<S2SV_blank><S2SV_blank>Read<S2SV_blank>a<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%g\\\\n\" , size ) ; if ( state -> unit == GERBV_UNIT_MM ) { size /= 25.4 ; } else if ( size >= 4.0 ) { gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_ERROR , - 1 , _ ( \"Read<S2SV_blank>a<S2SV_blank>drill<S2SV_blank>of<S2SV_blank>diameter<S2SV_blank>%g<S2SV_blank>inches<S2SV_blank>\" \"at<S2SV_blank>line<S2SV_blank>%ld<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , size , file_line , fd -> filename ) ; gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_WARNING , - 1 , _ ( \"Assuming<S2SV_blank>units<S2SV_blank>are<S2SV_blank>mils\" ) ) ; size /= 1000.0 ; } if ( size <= 0. || size >= 10000. ) { gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_ERROR , - 1 , _ ( \"Unreasonable<S2SV_blank>drill<S2SV_blank>size<S2SV_blank>%g<S2SV_blank>found<S2SV_blank>for<S2SV_blank>drill<S2SV_blank>%d<S2SV_blank>\" \"at<S2SV_blank>line<S2SV_blank>%ld<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , size , tool_num , file_line , fd -> filename ) ; } else { if ( apert != NULL ) { if ( apert -> parameter [ 0 ] != size || apert -> type != GERBV_APTYPE_CIRCLE || apert -> nuf_parameters != 1 || apert -> unit != GERBV_UNIT_INCH ) { gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_ERROR , - 1 , _ ( \"Found<S2SV_blank>redefinition<S2SV_blank>of<S2SV_blank>drill<S2SV_blank>%d<S2SV_blank>\" \"at<S2SV_blank>line<S2SV_blank>%ld<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , tool_num , file_line , fd -> filename ) ; } } else { apert = image -> aperture [ tool_num ] = g_new0 ( gerbv_aperture_t , 1 ) ; if ( apert == NULL ) GERB_FATAL_ERROR ( \"malloc<S2SV_blank>tool<S2SV_blank>failed<S2SV_blank>in<S2SV_blank>%s()\" , __FUNCTION__ ) ; apert -> parameter [ 0 ] = size ; apert -> type = GERBV_APTYPE_CIRCLE ; apert -> nuf_parameters = 1 ; apert -> unit = GERBV_UNIT_INCH ; } } stats = image -> drill_stats ; string = g_strdup_printf ( \"%s\" , ( state -> unit == GERBV_UNIT_MM ? _ ( \"mm\" ) : _ ( \"inch\" ) ) ) ; drill_stats_add_to_drill_list ( stats -> drill_list , tool_num , state -> unit == GERBV_UNIT_MM ? size * 25.4 : size , string ) ; g_free ( string ) ; break ; case 'F' : case 'S' : gerb_fgetint ( fd , NULL ) ; break ; default : gerb_ungetc ( fd ) ; done = TRUE ; break ; } temp = gerb_fgetc ( fd ) ; if ( EOF == temp ) { gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_ERROR , - 1 , _ ( \"Unexpected<S2SV_blank>EOF<S2SV_blank>encountered<S2SV_blank>in<S2SV_blank>header<S2SV_blank>of<S2SV_blank>\" \"drill<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , fd -> filename ) ; if ( '\\\\n' == temp || '\\\\r' == temp ) gerb_ungetc ( fd ) ; } } if ( apert == NULL ) { double dia ; apert = image -> aperture [ tool_num ] = g_new0 ( gerbv_aperture_t , 1 ) ; if ( apert == NULL ) GERB_FATAL_ERROR ( \"malloc<S2SV_blank>tool<S2SV_blank>failed<S2SV_blank>in<S2SV_blank>%s()\" , __FUNCTION__ ) ; dia = gerbv_get_tool_diameter ( tool_num ) ; if ( dia <= 0 ) { dia = ( double ) ( 16 + 8 * tool_num ) / 1000 ; if ( tool_num != 0 ) { gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_ERROR , - 1 , _ ( \"Tool<S2SV_blank>%02d<S2SV_blank>used<S2SV_blank>without<S2SV_blank>being<S2SV_blank>defined<S2SV_blank>\" \"at<S2SV_blank>line<S2SV_blank>%ld<S2SV_blank>in<S2SV_blank>file<S2SV_blank>\\\\\"%s\\\\\"\" ) , tool_num , file_line , fd -> filename ) ; gerbv_stats_printf ( stats -> error_list , GERBV_MESSAGE_WARNING , - 1 , _ ( \"Setting<S2SV_blank>a<S2SV_blank>default<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%g\\\\\"\" ) , dia ) ; } } apert -> type = GERBV_APTYPE_CIRCLE ; apert -> nuf_parameters = 1 ; apert -> parameter [ 0 ] = dia ; if ( tool_num != 0 ) { stats = image -> drill_stats ; string = g_strdup_printf ( \"%s\" , ( state -> unit == GERBV_UNIT_MM ? _ ( \"mm\" ) : _ ( \"inch\" ) ) ) ; drill_stats_add_to_drill_list ( stats -> drill_list , tool_num , state -> unit == GERBV_UNIT_MM ? dia * 25.4 : dia , string ) ; g_free ( string ) ; } } dprintf ( \"<----<S2SV_blank><S2SV_blank>...leaving<S2SV_blank>%s()\\\\n\" , __FUNCTION__ ) ; return tool_num ; }", "target": "<S2SV_ModStart> -> filename ) ; return - 1"}
{"source": "CWE-787 ga_concat_shorten_esc ( garray_T * gap , char_u * str ) { char_u * p ; char_u * s ; int c ; int clen ; char_u buf [ NUMBUFLEN ] ; int same_len ; if ( str == NULL ) { ga_concat ( gap , ( char_u * ) \"NULL\" ) ; return ; } for ( p = str ; * p != NUL ; ++ p ) { same_len = 1 ; s = p ; <S2SV_StartBug> c = mb_ptr2char_adv ( & s ) ; <S2SV_EndBug> clen = s - p ; while ( * s != NUL && c == mb_ptr2char ( s ) ) { ++ same_len ; s += clen ; } if ( same_len > 20 ) { ga_concat ( gap , ( char_u * ) \"\\\\\\\\[\" ) ; ga_concat_esc ( gap , p , clen ) ; ga_concat ( gap , ( char_u * ) \"<S2SV_blank>occurs<S2SV_blank>\" ) ; vim_snprintf ( ( char * ) buf , NUMBUFLEN , \"%d\" , same_len ) ; ga_concat ( gap , buf ) ; ga_concat ( gap , ( char_u * ) \"<S2SV_blank>times]\" ) ; p = s - 1 ; } else ga_concat_esc ( gap , p , clen ) ; } }", "target": "<S2SV_ModStart> ; c = mb_cptr2char_adv <S2SV_ModEnd> ( & s"}
{"source": "CWE-787 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MaxTextExtent ] ; CINInfo cin ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; ssize_t i ; PixelPacket * q ; size_t extent , length ; ssize_t count , y ; unsigned char magick [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , \"\\\\200\\\\052\\\\137\\\\327\" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.version\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.filename\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.create_date\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.create_time\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , \"dpx:image.orientation\" , \"%d\" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , \"dpx:image.label\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:origination.x_offset\" , \"%.20g\" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:origination.y_offset\" , \"%.20g\" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.filename\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.create_date\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.create_time\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.device\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.model\" , property ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.serial\" , property ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , \"dpx:film.id\" , \"%d\" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , \"dpx:film.type\" , \"%d\" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , \"dpx:film.offset\" , \"%d\" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:film.prefix\" , \"%.20g\" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , \"dpx:film.format\" , property ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:film.frame_position\" , \"%.20g\" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , \"dpx:film.frame_rate\" , \"%g\" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , \"dpx:film.frame_id\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , \"dpx:film.slate_info\" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , \"dpx:user.data\" , profile ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows / 8 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } ( void ) SetImageBackgroundColor ( image ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; SetQuantumQuantum ( quantum_info , 32 ) ; SetQuantumPack ( quantum_info , MagickFalse ) ; quantum_type = RGBQuantum ; extent = GetQuantumExtent ( image , quantum_info , quantum_type ) ; ( void ) extent ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } status = SetQuantumPad ( image , quantum_info , 0 ) ; pixels = GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { const void * stream ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; stream = ReadBlobStream ( image , length , pixels , & count ) ; if ( count != ( ssize_t ) length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , ( unsigned char * ) stream , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; SetImageColorspace ( image , LogColorspace ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> image ) ; if ( cin . file . image_offset < 712 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;"}
{"source": "CWE-310 _gnutls_server_select_suite ( gnutls_session_t session , uint8_t * data , unsigned int datalen ) { int ret ; unsigned int i , j , cipher_suites_size ; size_t pk_algos_size ; uint8_t cipher_suites [ MAX_CIPHERSUITE_SIZE ] ; int retval ; gnutls_pk_algorithm_t pk_algos [ MAX_ALGOS ] ; for ( i = 0 ; i < datalen ; i += 2 ) { if ( session -> internals . priorities . sr != SR_DISABLED && data [ i ] == GNUTLS_RENEGO_PROTECTION_REQUEST_MAJOR && data [ i + 1 ] == GNUTLS_RENEGO_PROTECTION_REQUEST_MINOR ) { _gnutls_handshake_log ( \"HSK[%p]:<S2SV_blank>Received<S2SV_blank>safe<S2SV_blank>renegotiation<S2SV_blank>CS\\\\n\" , session ) ; retval = _gnutls_ext_sr_recv_cs ( session ) ; if ( retval < 0 ) { gnutls_assert ( ) ; return retval ; } } if ( data [ i ] == GNUTLS_FALLBACK_SCSV_MAJOR && data [ i + 1 ] == GNUTLS_FALLBACK_SCSV_MINOR ) { <S2SV_StartBug> _gnutls_handshake_log <S2SV_EndBug> ( \"HSK[%p]:<S2SV_blank>Received<S2SV_blank>fallback<S2SV_blank>CS\\\\n\" , session ) ; if ( gnutls_protocol_get_version ( session ) != <S2SV_StartBug> GNUTLS_TLS_VERSION_MAX ) <S2SV_EndBug> return GNUTLS_E_INAPPROPRIATE_FALLBACK ; } } pk_algos_size = MAX_ALGOS ; ret = server_find_pk_algos_in_ciphersuites ( data , datalen , pk_algos , & pk_algos_size ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; ret = _gnutls_supported_ciphersuites ( session , cipher_suites , sizeof ( cipher_suites ) ) ; if ( ret < 0 ) return gnutls_assert_val ( ret ) ; cipher_suites_size = ret ; ret = _gnutls_remove_unwanted_ciphersuites ( session , cipher_suites , cipher_suites_size , pk_algos , pk_algos_size ) ; if ( ret <= 0 ) { gnutls_assert ( ) ; if ( ret < 0 ) return ret ; else return GNUTLS_E_UNKNOWN_CIPHER_SUITE ; } cipher_suites_size = ret ; if ( datalen % 2 != 0 ) { gnutls_assert ( ) ; return GNUTLS_E_UNEXPECTED_PACKET_LENGTH ; } memset ( session -> security_parameters . cipher_suite , 0 , 2 ) ; retval = GNUTLS_E_UNKNOWN_CIPHER_SUITE ; _gnutls_handshake_log ( \"HSK[%p]:<S2SV_blank>Requested<S2SV_blank>cipher<S2SV_blank>suites[size:<S2SV_blank>%d]:<S2SV_blank>\\\\n\" , session , ( int ) datalen ) ; if ( session -> internals . priorities . server_precedence == 0 ) { for ( j = 0 ; j < datalen ; j += 2 ) { _gnutls_handshake_log ( \"\\\\t0x%.2x,<S2SV_blank>0x%.2x<S2SV_blank>%s\\\\n\" , data [ j ] , data [ j + 1 ] , _gnutls_cipher_suite_get_name ( & data [ j ] ) ) ; for ( i = 0 ; i < cipher_suites_size ; i += 2 ) { if ( memcmp ( & cipher_suites [ i ] , & data [ j ] , 2 ) == 0 ) { _gnutls_handshake_log ( \"HSK[%p]:<S2SV_blank>Selected<S2SV_blank>cipher<S2SV_blank>suite:<S2SV_blank>%s\\\\n\" , session , _gnutls_cipher_suite_get_name ( & data [ j ] ) ) ; memcpy ( session -> security_parameters . cipher_suite , & cipher_suites [ i ] , 2 ) ; _gnutls_epoch_set_cipher_suite ( session , EPOCH_NEXT , session -> security_parameters . cipher_suite ) ; retval = 0 ; goto finish ; } } } } else { for ( i = 0 ; i < cipher_suites_size ; i += 2 ) { for ( j = 0 ; j < datalen ; j += 2 ) { if ( memcmp ( & cipher_suites [ i ] , & data [ j ] , 2 ) == 0 ) { _gnutls_handshake_log ( \"HSK[%p]:<S2SV_blank>Selected<S2SV_blank>cipher<S2SV_blank>suite:<S2SV_blank>%s\\\\n\" , session , _gnutls_cipher_suite_get_name ( & data [ j ] ) ) ; memcpy ( session -> security_parameters . cipher_suite , & cipher_suites [ i ] , 2 ) ; _gnutls_epoch_set_cipher_suite ( session , EPOCH_NEXT , session -> security_parameters . cipher_suite ) ; retval = 0 ; goto finish ; } } } } finish : if ( retval != 0 ) { gnutls_assert ( ) ; return retval ; } if ( _gnutls_get_kx_cred ( session , _gnutls_cipher_suite_get_kx_algo ( session -> security_parameters . cipher_suite ) ) == NULL ) { gnutls_assert ( ) ; return GNUTLS_E_INSUFFICIENT_CREDENTIALS ; } session -> internals . auth_struct = _gnutls_kx_auth_struct ( _gnutls_cipher_suite_get_kx_algo ( session -> security_parameters . cipher_suite ) ) ; if ( session -> internals . auth_struct == NULL ) { _gnutls_handshake_log ( \"HSK[%p]:<S2SV_blank>Cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>appropriate<S2SV_blank>handler<S2SV_blank>for<S2SV_blank>the<S2SV_blank>KX<S2SV_blank>algorithm\\\\n\" , session ) ; gnutls_assert ( ) ; return GNUTLS_E_INTERNAL_ERROR ; } return 0 ; }", "target": "<S2SV_ModStart> GNUTLS_FALLBACK_SCSV_MINOR ) { unsigned max = _gnutls_version_max ( session ) ; <S2SV_ModStart> session ) != max ) return gnutls_assert_val ( GNUTLS_E_INAPPROPRIATE_FALLBACK ) <S2SV_ModEnd> ; } }"}
{"source": "CWE-416 regmatch ( char_u * scan , proftime_T * tm UNUSED , int * timed_out UNUSED ) { char_u * next ; int op ; int c ; regitem_T * rp ; int no ; int status ; # ifdef FEAT_RELTIME int tm_count = 0 ; # endif regstack . ga_len = 0 ; backpos . ga_len = 0 ; for ( ; ; ) { fast_breakcheck ( ) ; # ifdef DEBUG if ( scan != NULL && regnarrate ) { mch_errmsg ( ( char * ) regprop ( scan ) ) ; mch_errmsg ( \"(\\\\n\" ) ; } # endif for ( ; ; ) { if ( got_int || scan == NULL ) { status = RA_FAIL ; break ; } # ifdef FEAT_RELTIME if ( tm != NULL && ++ tm_count == 100 ) { tm_count = 0 ; if ( profile_passed_limit ( tm ) ) { if ( timed_out != NULL ) * timed_out = TRUE ; status = RA_FAIL ; break ; } } # endif status = RA_CONT ; # ifdef DEBUG if ( regnarrate ) { mch_errmsg ( ( char * ) regprop ( scan ) ) ; mch_errmsg ( \"...\\\\n\" ) ; # ifdef FEAT_SYN_HL if ( re_extmatch_in != NULL ) { int i ; mch_errmsg ( _ ( \"External<S2SV_blank>submatches:\\\\n\" ) ) ; for ( i = 0 ; i < NSUBEXP ; i ++ ) { mch_errmsg ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\\\\"\" ) ; if ( re_extmatch_in -> matches [ i ] != NULL ) mch_errmsg ( ( char * ) re_extmatch_in -> matches [ i ] ) ; mch_errmsg ( \"\\\\\"\\\\n\" ) ; } } # endif } # endif next = regnext ( scan ) ; op = OP ( scan ) ; if ( ! rex . reg_line_lbr && WITH_NL ( op ) && REG_MULTI && * rex . input == NUL && rex . lnum <= rex . reg_maxline ) { reg_nextline ( ) ; } else if ( rex . reg_line_lbr && WITH_NL ( op ) && * rex . input == '\\\\n' ) { ADVANCE_REGINPUT ( ) ; } else { if ( WITH_NL ( op ) ) op -= ADD_NL ; if ( has_mbyte ) c = ( * mb_ptr2char ) ( rex . input ) ; else c = * rex . input ; switch ( op ) { case BOL : if ( rex . input != rex . line ) status = RA_NOMATCH ; break ; case EOL : if ( c != NUL ) status = RA_NOMATCH ; break ; case RE_BOF : if ( rex . lnum != 0 || rex . input != rex . line || ( REG_MULTI && rex . reg_firstlnum > 1 ) ) status = RA_NOMATCH ; break ; case RE_EOF : if ( rex . lnum != rex . reg_maxline || c != NUL ) status = RA_NOMATCH ; break ; case CURSOR : if ( rex . reg_win == NULL || ( rex . lnum + rex . reg_firstlnum != rex . reg_win -> w_cursor . lnum ) || ( ( colnr_T ) ( rex . input - rex . line ) != rex . reg_win -> w_cursor . col ) ) status = RA_NOMATCH ; break ; case RE_MARK : { int mark = OPERAND ( scan ) [ 0 ] ; int cmp = OPERAND ( scan ) [ 1 ] ; pos_T * pos ; <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> pos = getmark_buf ( rex . reg_buf , mark , FALSE ) ; <S2SV_EndBug> if ( pos == NULL || pos -> lnum <= 0 ) { status = RA_NOMATCH ; } else { colnr_T pos_col = pos -> lnum == rex . lnum + rex . reg_firstlnum && pos -> col == MAXCOL ? ( colnr_T ) STRLEN ( reg_getline ( pos -> lnum - rex . reg_firstlnum ) ) : pos -> col ; if ( ( pos -> lnum == rex . lnum + rex . reg_firstlnum ? ( pos_col == ( colnr_T ) ( rex . input - rex . line ) ? ( cmp == '<' || cmp == '>' ) : ( pos_col < ( colnr_T ) ( rex . input - rex . line ) ? cmp != '>' : cmp != '<' ) ) : ( pos -> lnum < rex . lnum + rex . reg_firstlnum ? cmp != '>' : cmp != '<' ) ) ) status = RA_NOMATCH ; } } break ; case RE_VISUAL : if ( ! reg_match_visual ( ) ) status = RA_NOMATCH ; break ; case RE_LNUM : if ( ! REG_MULTI || ! re_num_cmp ( ( long_u ) ( rex . lnum + rex . reg_firstlnum ) , scan ) ) status = RA_NOMATCH ; break ; case RE_COL : if ( ! re_num_cmp ( ( long_u ) ( rex . input - rex . line ) + 1 , scan ) ) status = RA_NOMATCH ; break ; case RE_VCOL : if ( ! re_num_cmp ( ( long_u ) win_linetabsize ( rex . reg_win == NULL ? curwin : rex . reg_win , rex . line , ( colnr_T ) ( rex . input - rex . line ) ) + 1 , scan ) ) status = RA_NOMATCH ; break ; case BOW : if ( c == NUL ) status = RA_NOMATCH ; else if ( has_mbyte ) { int this_class ; this_class = mb_get_class_buf ( rex . input , rex . reg_buf ) ; if ( this_class <= 1 ) status = RA_NOMATCH ; else if ( reg_prev_class ( ) == this_class ) status = RA_NOMATCH ; } else { if ( ! vim_iswordc_buf ( c , rex . reg_buf ) || ( rex . input > rex . line && vim_iswordc_buf ( rex . input [ - 1 ] , rex . reg_buf ) ) ) status = RA_NOMATCH ; } break ; case EOW : if ( rex . input == rex . line ) status = RA_NOMATCH ; else if ( has_mbyte ) { int this_class , prev_class ; this_class = mb_get_class_buf ( rex . input , rex . reg_buf ) ; prev_class = reg_prev_class ( ) ; if ( this_class == prev_class || prev_class == 0 || prev_class == 1 ) status = RA_NOMATCH ; } else { if ( ! vim_iswordc_buf ( rex . input [ - 1 ] , rex . reg_buf ) || ( rex . input [ 0 ] != NUL && vim_iswordc_buf ( c , rex . reg_buf ) ) ) status = RA_NOMATCH ; } break ; case ANY : if ( c == NUL ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case IDENT : if ( ! vim_isIDc ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case SIDENT : if ( VIM_ISDIGIT ( * rex . input ) || ! vim_isIDc ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case KWORD : if ( ! vim_iswordp_buf ( rex . input , rex . reg_buf ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case SKWORD : if ( VIM_ISDIGIT ( * rex . input ) || ! vim_iswordp_buf ( rex . input , rex . reg_buf ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case FNAME : if ( ! vim_isfilec ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case SFNAME : if ( VIM_ISDIGIT ( * rex . input ) || ! vim_isfilec ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case PRINT : if ( ! vim_isprintc ( PTR2CHAR ( rex . input ) ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case SPRINT : if ( VIM_ISDIGIT ( * rex . input ) || ! vim_isprintc ( PTR2CHAR ( rex . input ) ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case WHITE : if ( ! VIM_ISWHITE ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NWHITE : if ( c == NUL || VIM_ISWHITE ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case DIGIT : if ( ! ri_digit ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NDIGIT : if ( c == NUL || ri_digit ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case HEX : if ( ! ri_hex ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NHEX : if ( c == NUL || ri_hex ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case OCTAL : if ( ! ri_octal ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NOCTAL : if ( c == NUL || ri_octal ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case WORD : if ( ! ri_word ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NWORD : if ( c == NUL || ri_word ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case HEAD : if ( ! ri_head ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NHEAD : if ( c == NUL || ri_head ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case ALPHA : if ( ! ri_alpha ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NALPHA : if ( c == NUL || ri_alpha ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case LOWER : if ( ! ri_lower ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NLOWER : if ( c == NUL || ri_lower ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case UPPER : if ( ! ri_upper ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case NUPPER : if ( c == NUL || ri_upper ( c ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case EXACTLY : { int len ; char_u * opnd ; opnd = OPERAND ( scan ) ; if ( * opnd != * rex . input && ( ! rex . reg_ic || ( ! enc_utf8 && MB_TOLOWER ( * opnd ) != MB_TOLOWER ( * rex . input ) ) ) ) status = RA_NOMATCH ; else if ( * opnd == NUL ) { } else { if ( opnd [ 1 ] == NUL && ! ( enc_utf8 && rex . reg_ic ) ) { len = 1 ; } else { len = ( int ) STRLEN ( opnd ) ; if ( cstrncmp ( opnd , rex . input , & len ) != 0 ) status = RA_NOMATCH ; } if ( status != RA_NOMATCH && enc_utf8 && UTF_COMPOSINGLIKE ( rex . input , rex . input + len ) && ! rex . reg_icombine && OP ( next ) != RE_COMPOSING ) { status = RA_NOMATCH ; } if ( status != RA_NOMATCH ) rex . input += len ; } } break ; case ANYOF : case ANYBUT : if ( c == NUL ) status = RA_NOMATCH ; else if ( ( cstrchr ( OPERAND ( scan ) , c ) == NULL ) == ( op == ANYOF ) ) status = RA_NOMATCH ; else ADVANCE_REGINPUT ( ) ; break ; case MULTIBYTECODE : if ( has_mbyte ) { int i , len ; char_u * opnd ; int opndc = 0 , inpc ; opnd = OPERAND ( scan ) ; if ( ( len = ( * mb_ptr2len ) ( opnd ) ) < 2 ) { status = RA_NOMATCH ; break ; } if ( enc_utf8 ) opndc = utf_ptr2char ( opnd ) ; if ( enc_utf8 && utf_iscomposing ( opndc ) ) { status = RA_NOMATCH ; for ( i = 0 ; rex . input [ i ] != NUL ; i += utf_ptr2len ( rex . input + i ) ) { inpc = utf_ptr2char ( rex . input + i ) ; if ( ! utf_iscomposing ( inpc ) ) { if ( i > 0 ) break ; } else if ( opndc == inpc ) { len = i + utfc_ptr2len ( rex . input + i ) ; status = RA_MATCH ; break ; } } } else for ( i = 0 ; i < len ; ++ i ) if ( opnd [ i ] != rex . input [ i ] ) { status = RA_NOMATCH ; break ; } rex . input += len ; } else status = RA_NOMATCH ; break ; case RE_COMPOSING : if ( enc_utf8 ) { while ( utf_iscomposing ( utf_ptr2char ( rex . input ) ) ) MB_CPTR_ADV ( rex . input ) ; } break ; case NOTHING : break ; case BACK : { int i ; backpos_T * bp ; bp = ( backpos_T * ) backpos . ga_data ; for ( i = 0 ; i < backpos . ga_len ; ++ i ) if ( bp [ i ] . bp_scan == scan ) break ; if ( i == backpos . ga_len ) { if ( ga_grow ( & backpos , 1 ) == FAIL ) status = RA_FAIL ; else { bp = ( backpos_T * ) backpos . ga_data ; bp [ i ] . bp_scan = scan ; ++ backpos . ga_len ; } } else if ( reg_save_equal ( & bp [ i ] . bp_pos ) ) status = RA_NOMATCH ; if ( status != RA_FAIL && status != RA_NOMATCH ) reg_save ( & bp [ i ] . bp_pos , & backpos ) ; } break ; case MOPEN + 0 : case MOPEN + 1 : case MOPEN + 2 : case MOPEN + 3 : case MOPEN + 4 : case MOPEN + 5 : case MOPEN + 6 : case MOPEN + 7 : case MOPEN + 8 : case MOPEN + 9 : { no = op - MOPEN ; cleanup_subexpr ( ) ; rp = regstack_push ( RS_MOPEN , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { rp -> rs_no = no ; save_se ( & rp -> rs_un . sesave , & rex . reg_startpos [ no ] , & rex . reg_startp [ no ] ) ; } } break ; case NOPEN : case NCLOSE : if ( regstack_push ( RS_NOPEN , scan ) == NULL ) status = RA_FAIL ; break ; # ifdef FEAT_SYN_HL case ZOPEN + 1 : case ZOPEN + 2 : case ZOPEN + 3 : case ZOPEN + 4 : case ZOPEN + 5 : case ZOPEN + 6 : case ZOPEN + 7 : case ZOPEN + 8 : case ZOPEN + 9 : { no = op - ZOPEN ; cleanup_zsubexpr ( ) ; rp = regstack_push ( RS_ZOPEN , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { rp -> rs_no = no ; save_se ( & rp -> rs_un . sesave , & reg_startzpos [ no ] , & reg_startzp [ no ] ) ; } } break ; # endif case MCLOSE + 0 : case MCLOSE + 1 : case MCLOSE + 2 : case MCLOSE + 3 : case MCLOSE + 4 : case MCLOSE + 5 : case MCLOSE + 6 : case MCLOSE + 7 : case MCLOSE + 8 : case MCLOSE + 9 : { no = op - MCLOSE ; cleanup_subexpr ( ) ; rp = regstack_push ( RS_MCLOSE , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { rp -> rs_no = no ; save_se ( & rp -> rs_un . sesave , & rex . reg_endpos [ no ] , & rex . reg_endp [ no ] ) ; } } break ; # ifdef FEAT_SYN_HL case ZCLOSE + 1 : case ZCLOSE + 2 : case ZCLOSE + 3 : case ZCLOSE + 4 : case ZCLOSE + 5 : case ZCLOSE + 6 : case ZCLOSE + 7 : case ZCLOSE + 8 : case ZCLOSE + 9 : { no = op - ZCLOSE ; cleanup_zsubexpr ( ) ; rp = regstack_push ( RS_ZCLOSE , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { rp -> rs_no = no ; save_se ( & rp -> rs_un . sesave , & reg_endzpos [ no ] , & reg_endzp [ no ] ) ; } } break ; # endif case BACKREF + 1 : case BACKREF + 2 : case BACKREF + 3 : case BACKREF + 4 : case BACKREF + 5 : case BACKREF + 6 : case BACKREF + 7 : case BACKREF + 8 : case BACKREF + 9 : { int len ; no = op - BACKREF ; cleanup_subexpr ( ) ; if ( ! REG_MULTI ) { if ( rex . reg_startp [ no ] == NULL || rex . reg_endp [ no ] == NULL ) { len = 0 ; } else { len = ( int ) ( rex . reg_endp [ no ] - rex . reg_startp [ no ] ) ; if ( cstrncmp ( rex . reg_startp [ no ] , rex . input , & len ) != 0 ) status = RA_NOMATCH ; } } else { if ( rex . reg_startpos [ no ] . lnum < 0 || rex . reg_endpos [ no ] . lnum < 0 ) { len = 0 ; } else { if ( rex . reg_startpos [ no ] . lnum == rex . lnum && rex . reg_endpos [ no ] . lnum == rex . lnum ) { len = rex . reg_endpos [ no ] . col - rex . reg_startpos [ no ] . col ; if ( cstrncmp ( rex . line + rex . reg_startpos [ no ] . col , rex . input , & len ) != 0 ) status = RA_NOMATCH ; } else { int r = match_with_backref ( rex . reg_startpos [ no ] . lnum , rex . reg_startpos [ no ] . col , rex . reg_endpos [ no ] . lnum , rex . reg_endpos [ no ] . col , & len ) ; if ( r != RA_MATCH ) status = r ; } } } rex . input += len ; } break ; # ifdef FEAT_SYN_HL case ZREF + 1 : case ZREF + 2 : case ZREF + 3 : case ZREF + 4 : case ZREF + 5 : case ZREF + 6 : case ZREF + 7 : case ZREF + 8 : case ZREF + 9 : { int len ; cleanup_zsubexpr ( ) ; no = op - ZREF ; if ( re_extmatch_in != NULL && re_extmatch_in -> matches [ no ] != NULL ) { len = ( int ) STRLEN ( re_extmatch_in -> matches [ no ] ) ; if ( cstrncmp ( re_extmatch_in -> matches [ no ] , rex . input , & len ) != 0 ) status = RA_NOMATCH ; else rex . input += len ; } else { } } break ; # endif case BRANCH : { if ( OP ( next ) != BRANCH ) next = OPERAND ( scan ) ; else { rp = regstack_push ( RS_BRANCH , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else status = RA_BREAK ; } } break ; case BRACE_LIMITS : { if ( OP ( next ) == BRACE_SIMPLE ) { bl_minval = OPERAND_MIN ( scan ) ; bl_maxval = OPERAND_MAX ( scan ) ; } else if ( OP ( next ) >= BRACE_COMPLEX && OP ( next ) < BRACE_COMPLEX + 10 ) { no = OP ( next ) - BRACE_COMPLEX ; brace_min [ no ] = OPERAND_MIN ( scan ) ; brace_max [ no ] = OPERAND_MAX ( scan ) ; brace_count [ no ] = 0 ; } else { internal_error ( \"BRACE_LIMITS\" ) ; status = RA_FAIL ; } } break ; case BRACE_COMPLEX + 0 : case BRACE_COMPLEX + 1 : case BRACE_COMPLEX + 2 : case BRACE_COMPLEX + 3 : case BRACE_COMPLEX + 4 : case BRACE_COMPLEX + 5 : case BRACE_COMPLEX + 6 : case BRACE_COMPLEX + 7 : case BRACE_COMPLEX + 8 : case BRACE_COMPLEX + 9 : { no = op - BRACE_COMPLEX ; ++ brace_count [ no ] ; if ( brace_count [ no ] <= ( brace_min [ no ] <= brace_max [ no ] ? brace_min [ no ] : brace_max [ no ] ) ) { rp = regstack_push ( RS_BRCPLX_MORE , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { rp -> rs_no = no ; reg_save ( & rp -> rs_un . regsave , & backpos ) ; next = OPERAND ( scan ) ; } break ; } if ( brace_min [ no ] <= brace_max [ no ] ) { if ( brace_count [ no ] <= brace_max [ no ] ) { rp = regstack_push ( RS_BRCPLX_LONG , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { rp -> rs_no = no ; reg_save ( & rp -> rs_un . regsave , & backpos ) ; next = OPERAND ( scan ) ; } } } else { if ( brace_count [ no ] <= brace_min [ no ] ) { rp = regstack_push ( RS_BRCPLX_SHORT , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { reg_save ( & rp -> rs_un . regsave , & backpos ) ; } } } } break ; case BRACE_SIMPLE : case STAR : case PLUS : { regstar_T rst ; if ( OP ( next ) == EXACTLY ) { rst . nextb = * OPERAND ( next ) ; if ( rex . reg_ic ) { if ( MB_ISUPPER ( rst . nextb ) ) rst . nextb_ic = MB_TOLOWER ( rst . nextb ) ; else rst . nextb_ic = MB_TOUPPER ( rst . nextb ) ; } else rst . nextb_ic = rst . nextb ; } else { rst . nextb = NUL ; rst . nextb_ic = NUL ; } if ( op != BRACE_SIMPLE ) { rst . minval = ( op == STAR ) ? 0 : 1 ; rst . maxval = MAX_LIMIT ; } else { rst . minval = bl_minval ; rst . maxval = bl_maxval ; } rst . count = regrepeat ( OPERAND ( scan ) , rst . maxval ) ; if ( got_int ) { status = RA_FAIL ; break ; } if ( rst . minval <= rst . maxval ? rst . count >= rst . minval : rst . count >= rst . maxval ) { if ( ( long ) ( ( unsigned ) regstack . ga_len >> 10 ) >= p_mmp ) { emsg ( _ ( e_pattern_uses_more_memory_than_maxmempattern ) ) ; status = RA_FAIL ; } else if ( ga_grow ( & regstack , sizeof ( regstar_T ) ) == FAIL ) status = RA_FAIL ; else { regstack . ga_len += sizeof ( regstar_T ) ; rp = regstack_push ( rst . minval <= rst . maxval ? RS_STAR_LONG : RS_STAR_SHORT , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { * ( ( ( regstar_T * ) rp ) - 1 ) = rst ; status = RA_BREAK ; } } } else status = RA_NOMATCH ; } break ; case NOMATCH : case MATCH : case SUBPAT : rp = regstack_push ( RS_NOMATCH , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { rp -> rs_no = op ; reg_save ( & rp -> rs_un . regsave , & backpos ) ; next = OPERAND ( scan ) ; } break ; case BEHIND : case NOBEHIND : if ( ( long ) ( ( unsigned ) regstack . ga_len >> 10 ) >= p_mmp ) { emsg ( _ ( e_pattern_uses_more_memory_than_maxmempattern ) ) ; status = RA_FAIL ; } else if ( ga_grow ( & regstack , sizeof ( regbehind_T ) ) == FAIL ) status = RA_FAIL ; else { regstack . ga_len += sizeof ( regbehind_T ) ; rp = regstack_push ( RS_BEHIND1 , scan ) ; if ( rp == NULL ) status = RA_FAIL ; else { save_subexpr ( ( ( regbehind_T * ) rp ) - 1 ) ; rp -> rs_no = op ; reg_save ( & rp -> rs_un . regsave , & backpos ) ; } } break ; case BHPOS : if ( REG_MULTI ) { if ( behind_pos . rs_u . pos . col != ( colnr_T ) ( rex . input - rex . line ) || behind_pos . rs_u . pos . lnum != rex . lnum ) status = RA_NOMATCH ; } else if ( behind_pos . rs_u . ptr != rex . input ) status = RA_NOMATCH ; break ; case NEWL : if ( ( c != NUL || ! REG_MULTI || rex . lnum > rex . reg_maxline || rex . reg_line_lbr ) && ( c != '\\\\n' || ! rex . reg_line_lbr ) ) status = RA_NOMATCH ; else if ( rex . reg_line_lbr ) ADVANCE_REGINPUT ( ) ; else reg_nextline ( ) ; break ; case END : status = RA_MATCH ; break ; default : iemsg ( _ ( e_corrupted_regexp_program ) ) ; # ifdef DEBUG printf ( \"Illegal<S2SV_blank>op<S2SV_blank>code<S2SV_blank>%d\\\\n\" , op ) ; # endif status = RA_FAIL ; break ; } } if ( status != RA_CONT ) break ; scan = next ; } while ( regstack . ga_len > 0 && status != RA_FAIL ) { rp = ( regitem_T * ) ( ( char * ) regstack . ga_data + regstack . ga_len ) - 1 ; switch ( rp -> rs_state ) { case RS_NOPEN : regstack_pop ( & scan ) ; break ; case RS_MOPEN : if ( status == RA_NOMATCH ) restore_se ( & rp -> rs_un . sesave , & rex . reg_startpos [ rp -> rs_no ] , & rex . reg_startp [ rp -> rs_no ] ) ; regstack_pop ( & scan ) ; break ; # ifdef FEAT_SYN_HL case RS_ZOPEN : if ( status == RA_NOMATCH ) restore_se ( & rp -> rs_un . sesave , & reg_startzpos [ rp -> rs_no ] , & reg_startzp [ rp -> rs_no ] ) ; regstack_pop ( & scan ) ; break ; # endif case RS_MCLOSE : if ( status == RA_NOMATCH ) restore_se ( & rp -> rs_un . sesave , & rex . reg_endpos [ rp -> rs_no ] , & rex . reg_endp [ rp -> rs_no ] ) ; regstack_pop ( & scan ) ; break ; # ifdef FEAT_SYN_HL case RS_ZCLOSE : if ( status == RA_NOMATCH ) restore_se ( & rp -> rs_un . sesave , & reg_endzpos [ rp -> rs_no ] , & reg_endzp [ rp -> rs_no ] ) ; regstack_pop ( & scan ) ; break ; # endif case RS_BRANCH : if ( status == RA_MATCH ) regstack_pop ( & scan ) ; else { if ( status != RA_BREAK ) { reg_restore ( & rp -> rs_un . regsave , & backpos ) ; scan = rp -> rs_scan ; } if ( scan == NULL || OP ( scan ) != BRANCH ) { status = RA_NOMATCH ; regstack_pop ( & scan ) ; } else { rp -> rs_scan = regnext ( scan ) ; reg_save ( & rp -> rs_un . regsave , & backpos ) ; scan = OPERAND ( scan ) ; } } break ; case RS_BRCPLX_MORE : if ( status == RA_NOMATCH ) { reg_restore ( & rp -> rs_un . regsave , & backpos ) ; -- brace_count [ rp -> rs_no ] ; } regstack_pop ( & scan ) ; break ; case RS_BRCPLX_LONG : if ( status == RA_NOMATCH ) { reg_restore ( & rp -> rs_un . regsave , & backpos ) ; -- brace_count [ rp -> rs_no ] ; status = RA_CONT ; } regstack_pop ( & scan ) ; if ( status == RA_CONT ) scan = regnext ( scan ) ; break ; case RS_BRCPLX_SHORT : if ( status == RA_NOMATCH ) reg_restore ( & rp -> rs_un . regsave , & backpos ) ; regstack_pop ( & scan ) ; if ( status == RA_NOMATCH ) { scan = OPERAND ( scan ) ; status = RA_CONT ; } break ; case RS_NOMATCH : if ( status == ( rp -> rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH ) ) status = RA_NOMATCH ; else { status = RA_CONT ; if ( rp -> rs_no != SUBPAT ) reg_restore ( & rp -> rs_un . regsave , & backpos ) ; } regstack_pop ( & scan ) ; if ( status == RA_CONT ) scan = regnext ( scan ) ; break ; case RS_BEHIND1 : if ( status == RA_NOMATCH ) { regstack_pop ( & scan ) ; regstack . ga_len -= sizeof ( regbehind_T ) ; } else { reg_save ( & ( ( ( regbehind_T * ) rp ) - 1 ) -> save_after , & backpos ) ; ( ( ( regbehind_T * ) rp ) - 1 ) -> save_behind = behind_pos ; behind_pos = rp -> rs_un . regsave ; rp -> rs_state = RS_BEHIND2 ; reg_restore ( & rp -> rs_un . regsave , & backpos ) ; scan = OPERAND ( rp -> rs_scan ) + 4 ; } break ; case RS_BEHIND2 : if ( status == RA_MATCH && reg_save_equal ( & behind_pos ) ) { behind_pos = ( ( ( regbehind_T * ) rp ) - 1 ) -> save_behind ; if ( rp -> rs_no == BEHIND ) reg_restore ( & ( ( ( regbehind_T * ) rp ) - 1 ) -> save_after , & backpos ) ; else { status = RA_NOMATCH ; restore_subexpr ( ( ( regbehind_T * ) rp ) - 1 ) ; } regstack_pop ( & scan ) ; regstack . ga_len -= sizeof ( regbehind_T ) ; } else { long limit ; no = OK ; limit = OPERAND_MIN ( rp -> rs_scan ) ; if ( REG_MULTI ) { if ( limit > 0 && ( ( rp -> rs_un . regsave . rs_u . pos . lnum < behind_pos . rs_u . pos . lnum ? ( colnr_T ) STRLEN ( rex . line ) : behind_pos . rs_u . pos . col ) - rp -> rs_un . regsave . rs_u . pos . col >= limit ) ) no = FAIL ; else if ( rp -> rs_un . regsave . rs_u . pos . col == 0 ) { if ( rp -> rs_un . regsave . rs_u . pos . lnum < behind_pos . rs_u . pos . lnum || reg_getline ( -- rp -> rs_un . regsave . rs_u . pos . lnum ) == NULL ) no = FAIL ; else { reg_restore ( & rp -> rs_un . regsave , & backpos ) ; rp -> rs_un . regsave . rs_u . pos . col = ( colnr_T ) STRLEN ( rex . line ) ; } } else { if ( has_mbyte ) { char_u * line = reg_getline ( rp -> rs_un . regsave . rs_u . pos . lnum ) ; rp -> rs_un . regsave . rs_u . pos . col -= ( * mb_head_off ) ( line , line + rp -> rs_un . regsave . rs_u . pos . col - 1 ) + 1 ; } else -- rp -> rs_un . regsave . rs_u . pos . col ; } } else { if ( rp -> rs_un . regsave . rs_u . ptr == rex . line ) no = FAIL ; else { MB_PTR_BACK ( rex . line , rp -> rs_un . regsave . rs_u . ptr ) ; if ( limit > 0 && ( long ) ( behind_pos . rs_u . ptr - rp -> rs_un . regsave . rs_u . ptr ) > limit ) no = FAIL ; } } if ( no == OK ) { reg_restore ( & rp -> rs_un . regsave , & backpos ) ; scan = OPERAND ( rp -> rs_scan ) + 4 ; if ( status == RA_MATCH ) { status = RA_NOMATCH ; restore_subexpr ( ( ( regbehind_T * ) rp ) - 1 ) ; } } else { behind_pos = ( ( ( regbehind_T * ) rp ) - 1 ) -> save_behind ; if ( rp -> rs_no == NOBEHIND ) { reg_restore ( & ( ( ( regbehind_T * ) rp ) - 1 ) -> save_after , & backpos ) ; status = RA_MATCH ; } else { if ( status == RA_MATCH ) { status = RA_NOMATCH ; restore_subexpr ( ( ( regbehind_T * ) rp ) - 1 ) ; } } regstack_pop ( & scan ) ; regstack . ga_len -= sizeof ( regbehind_T ) ; } } break ; case RS_STAR_LONG : case RS_STAR_SHORT : { regstar_T * rst = ( ( regstar_T * ) rp ) - 1 ; if ( status == RA_MATCH ) { regstack_pop ( & scan ) ; regstack . ga_len -= sizeof ( regstar_T ) ; break ; } if ( status != RA_BREAK ) reg_restore ( & rp -> rs_un . regsave , & backpos ) ; for ( ; ; ) { if ( status != RA_BREAK ) { if ( rp -> rs_state == RS_STAR_LONG ) { if ( -- rst -> count < rst -> minval ) break ; if ( rex . input == rex . line ) { if ( rex . lnum == 0 ) { status = RA_NOMATCH ; break ; } -- rex . lnum ; rex . line = reg_getline ( rex . lnum ) ; if ( rex . line == NULL ) break ; rex . input = rex . line + STRLEN ( rex . line ) ; fast_breakcheck ( ) ; } else MB_PTR_BACK ( rex . line , rex . input ) ; } else { if ( rst -> count == rst -> minval || regrepeat ( OPERAND ( rp -> rs_scan ) , 1L ) == 0 ) break ; ++ rst -> count ; } if ( got_int ) break ; } else status = RA_NOMATCH ; if ( rst -> nextb == NUL || * rex . input == rst -> nextb || * rex . input == rst -> nextb_ic ) { reg_save ( & rp -> rs_un . regsave , & backpos ) ; scan = regnext ( rp -> rs_scan ) ; status = RA_CONT ; break ; } } if ( status != RA_CONT ) { regstack_pop ( & scan ) ; regstack . ga_len -= sizeof ( regstar_T ) ; status = RA_NOMATCH ; } } break ; } if ( status == RA_CONT || rp == ( regitem_T * ) ( ( char * ) regstack . ga_data + regstack . ga_len ) - 1 ) break ; } if ( status == RA_CONT ) continue ; if ( regstack . ga_len == 0 || status == RA_FAIL ) { if ( scan == NULL ) { iemsg ( _ ( e_corrupted_regexp_program ) ) ; # ifdef DEBUG printf ( \"Premature<S2SV_blank>EOL\\\\n\" ) ; # endif } return ( status == RA_MATCH ) ; } } }", "target": "<S2SV_ModStart> * pos ; size_t col = REG_MULTI ? rex . input - rex . line : 0 ; <S2SV_ModStart> FALSE ) ; if ( REG_MULTI ) { rex . line = reg_getline ( rex . lnum ) ; rex . input = rex . line + col ; }"}
{"source": "CWE-59 set_fflags_platform ( struct archive_write_disk * a , int fd , const char * name , mode_t mode , unsigned long set , unsigned long clear ) { int ret ; int myfd = fd ; int newflags , oldflags ; const int sf_mask = 0 # if defined ( FS_IMMUTABLE_FL ) | FS_IMMUTABLE_FL # elif defined ( EXT2_IMMUTABLE_FL ) | EXT2_IMMUTABLE_FL # endif # if defined ( FS_APPEND_FL ) | FS_APPEND_FL # elif defined ( EXT2_APPEND_FL ) | EXT2_APPEND_FL # endif # if defined ( FS_JOURNAL_DATA_FL ) | FS_JOURNAL_DATA_FL # endif ; if ( set == 0 && clear == 0 ) return ( ARCHIVE_OK ) ; if ( ! S_ISREG ( mode ) && ! S_ISDIR ( mode ) ) return ( ARCHIVE_OK ) ; if ( myfd < 0 ) { <S2SV_StartBug> myfd = open ( name , O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC ) ; <S2SV_EndBug> __archive_ensure_cloexec_flag ( myfd ) ; } if ( myfd < 0 ) return ( ARCHIVE_OK ) ; ret = ARCHIVE_OK ; if ( ioctl ( myfd , # ifdef FS_IOC_GETFLAGS FS_IOC_GETFLAGS , # else EXT2_IOC_GETFLAGS , # endif & oldflags ) < 0 ) goto fail ; newflags = ( oldflags & ~ clear ) | set ; if ( ioctl ( myfd , # ifdef FS_IOC_SETFLAGS FS_IOC_SETFLAGS , # else EXT2_IOC_SETFLAGS , # endif & newflags ) >= 0 ) goto cleanup ; if ( errno != EPERM ) goto fail ; newflags &= ~ sf_mask ; oldflags &= sf_mask ; newflags |= oldflags ; if ( ioctl ( myfd , # ifdef FS_IOC_SETFLAGS FS_IOC_SETFLAGS , # else EXT2_IOC_SETFLAGS , # endif & newflags ) >= 0 ) goto cleanup ; fail : archive_set_error ( & a -> archive , errno , \"Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>file<S2SV_blank>flags\" ) ; ret = ARCHIVE_WARN ; cleanup : if ( fd < 0 ) close ( myfd ) ; return ( ret ) ; }", "target": "<S2SV_ModStart> O_BINARY | O_CLOEXEC | O_NOFOLLOW"}
{"source": "CWE-476 * vidtv_s302m_encoder_init ( struct vidtv_s302m_encoder_init_args args ) { u32 priv_sz = sizeof ( struct vidtv_s302m_ctx ) ; struct vidtv_s302m_ctx * ctx ; struct vidtv_encoder * e ; e = kzalloc ( sizeof ( * e ) , GFP_KERNEL ) ; if ( ! e ) return NULL ; e -> id = S302M ; if ( args . name ) e -> name = kstrdup ( args . name , GFP_KERNEL ) ; e -> encoder_buf = vzalloc ( VIDTV_S302M_BUF_SZ ) ; <S2SV_StartBug> e -> encoder_buf_sz = VIDTV_S302M_BUF_SZ ; <S2SV_EndBug> e -> encoder_buf_offset = 0 ; e -> sample_count = 0 ; e -> src_buf = ( args . src_buf ) ? args . src_buf : NULL ; e -> src_buf_sz = ( args . src_buf ) ? args . src_buf_sz : 0 ; e -> src_buf_offset = 0 ; e -> is_video_encoder = false ; ctx = kzalloc ( priv_sz , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! ctx ) { <S2SV_EndBug> kfree ( e ) ; return NULL ; } <S2SV_StartBug> e -> ctx = ctx ; <S2SV_EndBug> ctx -> last_duration = 0 ; e -> encode = vidtv_s302m_encode ; e -> clear = vidtv_s302m_clear ; e -> es_pid = cpu_to_be16 ( args . es_pid ) ; e -> stream_id = cpu_to_be16 ( PES_PRIVATE_STREAM_1 ) ; e -> sync = args . sync ; e -> sampling_rate_hz = S302M_SAMPLING_RATE_HZ ; e -> last_sample_cb = args . last_sample_cb ; e -> destroy = vidtv_s302m_encoder_destroy ; if ( args . head ) { while ( args . head -> next ) args . head = args . head -> next ; args . head -> next = e ; } e -> next = NULL ; return e ; }", "target": "<S2SV_ModStart> VIDTV_S302M_BUF_SZ ) ; if ( ! e -> encoder_buf ) goto out_kfree_e ; <S2SV_ModStart> ! ctx ) goto out_kfree_buf ; e -> ctx = ctx ; ctx -> last_duration = 0 ; e -> encode = vidtv_s302m_encode ; e -> clear = vidtv_s302m_clear ; e -> es_pid = cpu_to_be16 ( args . es_pid ) ; e -> stream_id = cpu_to_be16 ( PES_PRIVATE_STREAM_1 ) ; e -> sync = args . sync ; e -> sampling_rate_hz = S302M_SAMPLING_RATE_HZ ; e -> last_sample_cb = args . last_sample_cb ; e -> destroy = vidtv_s302m_encoder_destroy ; if ( args . head ) { while ( args . head -> next ) args . head = args . head -> next ; args . head -> next = e ; } e -> next = NULL ; return e ; out_kfree_buf : kfree ( e -> encoder_buf ) ; out_kfree_e : kfree ( e -> name ) ; <S2SV_ModEnd> kfree ( e <S2SV_ModStart> NULL ; } <S2SV_ModEnd>  <S2SV_null> <S2SV_null>"}
{"source": "CWE-787 do_put ( int regname , char_u * expr_result , int dir , long count , int flags ) { char_u * ptr ; char_u * newp , * oldp ; int yanklen ; int totlen = 0 ; linenr_T lnum ; colnr_T col ; long i ; int y_type ; long y_size ; int oldlen ; long y_width = 0 ; colnr_T vcol ; int delcount ; int incr = 0 ; long j ; struct block_def bd ; char_u * * y_array = NULL ; yankreg_T * y_current_used = NULL ; long nr_lines = 0 ; pos_T new_cursor ; int indent ; int orig_indent = 0 ; int indent_diff = 0 ; int first_indent = TRUE ; int lendiff = 0 ; pos_T old_pos ; char_u * insert_string = NULL ; int allocated = FALSE ; long cnt ; pos_T orig_start = curbuf -> b_op_start ; pos_T orig_end = curbuf -> b_op_end ; unsigned int cur_ve_flags = get_ve_flags ( ) ; # ifdef FEAT_CLIPBOARD adjust_clip_reg ( & regname ) ; ( void ) may_get_selection ( regname ) ; # endif if ( flags & PUT_FIXINDENT ) orig_indent = get_indent ( ) ; curbuf -> b_op_start = curwin -> w_cursor ; curbuf -> b_op_end = curwin -> w_cursor ; if ( regname == '.' ) { if ( VIsual_active ) stuffcharReadbuff ( VIsual_mode ) ; ( void ) stuff_inserted ( ( dir == FORWARD ? ( count == - 1 ? 'o' : 'a' ) : ( count == - 1 ? 'O' : 'i' ) ) , count , FALSE ) ; if ( ( flags & PUT_CURSEND ) && gchar_cursor ( ) != NUL ) stuffcharReadbuff ( 'l' ) ; return ; } if ( regname == '=' && expr_result != NULL ) insert_string = expr_result ; else if ( get_spec_reg ( regname , & insert_string , & allocated , TRUE ) && insert_string == NULL ) return ; if ( u_save ( curwin -> w_cursor . lnum , curwin -> w_cursor . lnum + 1 ) == FAIL ) goto end ; if ( insert_string != NULL ) { y_type = MCHAR ; # ifdef FEAT_EVAL if ( regname == '=' ) { for ( ; ; ) { y_size = 0 ; ptr = insert_string ; while ( ptr != NULL ) { if ( y_array != NULL ) y_array [ y_size ] = ptr ; ++ y_size ; ptr = vim_strchr ( ptr , '\\\\n' ) ; if ( ptr != NULL ) { if ( y_array != NULL ) * ptr = NUL ; ++ ptr ; if ( * ptr == NUL ) { y_type = MLINE ; break ; } } } if ( y_array != NULL ) break ; y_array = ALLOC_MULT ( char_u * , y_size ) ; if ( y_array == NULL ) goto end ; } } else # endif { y_size = 1 ; y_array = & insert_string ; } } else { get_yank_register ( regname , FALSE ) ; y_type = y_current -> y_type ; y_width = y_current -> y_width ; y_size = y_current -> y_size ; y_array = y_current -> y_array ; y_current_used = y_current ; } if ( y_type == MLINE ) { if ( flags & PUT_LINE_SPLIT ) { char_u * p ; if ( u_save_cursor ( ) == FAIL ) goto end ; p = ml_get_cursor ( ) ; if ( dir == FORWARD && * p != NUL ) MB_PTR_ADV ( p ) ; ptr = vim_strsave ( p ) ; if ( ptr == NULL ) goto end ; ml_append ( curwin -> w_cursor . lnum , ptr , ( colnr_T ) 0 , FALSE ) ; vim_free ( ptr ) ; oldp = ml_get_curline ( ) ; p = oldp + curwin -> w_cursor . col ; if ( dir == FORWARD && * p != NUL ) MB_PTR_ADV ( p ) ; ptr = vim_strnsave ( oldp , p - oldp ) ; if ( ptr == NULL ) goto end ; ml_replace ( curwin -> w_cursor . lnum , ptr , FALSE ) ; ++ nr_lines ; dir = FORWARD ; } if ( flags & PUT_LINE_FORWARD ) { curwin -> w_cursor = curbuf -> b_visual . vi_end ; dir = FORWARD ; } curbuf -> b_op_start = curwin -> w_cursor ; curbuf -> b_op_end = curwin -> w_cursor ; } if ( flags & PUT_LINE ) y_type = MLINE ; if ( y_size == 0 || y_array == NULL ) { semsg ( _ ( e_nothing_in_register_str ) , regname == 0 ? ( char_u * ) \"\\\\\"\" : transchar ( regname ) ) ; goto end ; } if ( y_type == MBLOCK ) { lnum = curwin -> w_cursor . lnum + y_size + 1 ; if ( lnum > curbuf -> b_ml . ml_line_count ) lnum = curbuf -> b_ml . ml_line_count + 1 ; if ( u_save ( curwin -> w_cursor . lnum - 1 , lnum ) == FAIL ) goto end ; } else if ( y_type == MLINE ) { lnum = curwin -> w_cursor . lnum ; # ifdef FEAT_FOLDING if ( dir == BACKWARD ) ( void ) hasFolding ( lnum , & lnum , NULL ) ; else ( void ) hasFolding ( lnum , NULL , & lnum ) ; # endif if ( dir == FORWARD ) ++ lnum ; if ( ( BUFEMPTY ( ) ? u_save ( 0 , 2 ) : u_save ( lnum - 1 , lnum ) ) == FAIL ) goto end ; # ifdef FEAT_FOLDING if ( dir == FORWARD ) curwin -> w_cursor . lnum = lnum - 1 ; else curwin -> w_cursor . lnum = lnum ; curbuf -> b_op_start = curwin -> w_cursor ; # endif } else if ( u_save_cursor ( ) == FAIL ) goto end ; yanklen = ( int ) STRLEN ( y_array [ 0 ] ) ; if ( cur_ve_flags == VE_ALL && y_type == MCHAR ) { if ( gchar_cursor ( ) == TAB ) { int viscol = getviscol ( ) ; int ts = curbuf -> b_p_ts ; if ( dir == FORWARD ? # ifdef FEAT_VARTABS tabstop_padding ( viscol , ts , curbuf -> b_p_vts_array ) != 1 # else ts - ( viscol % ts ) != 1 # endif : curwin -> w_cursor . coladd > 0 ) coladvance_force ( viscol ) ; else curwin -> w_cursor . coladd = 0 ; } else if ( curwin -> w_cursor . coladd > 0 || gchar_cursor ( ) == NUL ) coladvance_force ( getviscol ( ) + ( dir == FORWARD ) ) ; } lnum = curwin -> w_cursor . lnum ; col = curwin -> w_cursor . col ; if ( y_type == MBLOCK ) { int c = gchar_cursor ( ) ; colnr_T endcol2 = 0 ; if ( dir == FORWARD && c != NUL ) { if ( cur_ve_flags == VE_ALL ) getvcol ( curwin , & curwin -> w_cursor , & col , NULL , & endcol2 ) ; else getvcol ( curwin , & curwin -> w_cursor , NULL , NULL , & col ) ; if ( has_mbyte ) curwin -> w_cursor . col += ( * mb_ptr2len ) ( ml_get_cursor ( ) ) ; else if ( c != TAB || cur_ve_flags != VE_ALL ) ++ curwin -> w_cursor . col ; ++ col ; } else getvcol ( curwin , & curwin -> w_cursor , & col , NULL , & endcol2 ) ; col += curwin -> w_cursor . coladd ; if ( cur_ve_flags == VE_ALL && ( curwin -> w_cursor . coladd > 0 || endcol2 == curwin -> w_cursor . col ) ) { if ( dir == FORWARD && c == NUL ) ++ col ; if ( dir != FORWARD && c != NUL && curwin -> w_cursor . coladd > 0 ) ++ curwin -> w_cursor . col ; if ( c == TAB ) { if ( dir == BACKWARD && curwin -> w_cursor . col ) curwin -> w_cursor . col -- ; if ( dir == FORWARD && col - 1 == endcol2 ) curwin -> w_cursor . col ++ ; } } curwin -> w_cursor . coladd = 0 ; bd . textcol = 0 ; for ( i = 0 ; i < y_size ; ++ i ) { int spaces = 0 ; char shortline ; bd . startspaces = 0 ; bd . endspaces = 0 ; vcol = 0 ; delcount = 0 ; if ( curwin -> w_cursor . lnum > curbuf -> b_ml . ml_line_count ) { if ( ml_append ( curbuf -> b_ml . ml_line_count , ( char_u * ) \"\" , ( colnr_T ) 1 , FALSE ) == FAIL ) break ; ++ nr_lines ; } oldp = ml_get_curline ( ) ; oldlen = ( int ) STRLEN ( oldp ) ; for ( ptr = oldp ; vcol < col && * ptr ; ) { incr = lbr_chartabsize_adv ( oldp , & ptr , vcol ) ; vcol += incr ; } bd . textcol = ( colnr_T ) ( ptr - oldp ) ; shortline = ( vcol < col ) || ( vcol == col && ! * ptr ) ; if ( vcol < col ) bd . startspaces = col - vcol ; else if ( vcol > col ) { bd . endspaces = vcol - col ; bd . startspaces = incr - bd . endspaces ; -- bd . textcol ; delcount = 1 ; if ( has_mbyte ) bd . textcol -= ( * mb_head_off ) ( oldp , oldp + bd . textcol ) ; if ( oldp [ bd . textcol ] != TAB ) { delcount = 0 ; bd . endspaces = 0 ; } } yanklen = ( int ) STRLEN ( y_array [ i ] ) ; if ( ( flags & PUT_BLOCK_INNER ) == 0 ) { spaces = y_width + 1 ; for ( j = 0 ; j < yanklen ; j ++ ) spaces -= lbr_chartabsize ( NULL , & y_array [ i ] [ j ] , 0 ) ; if ( spaces < 0 ) spaces = 0 ; } if ( yanklen + spaces != 0 && count > ( ( INT_MAX - ( bd . startspaces + bd . endspaces ) ) / ( yanklen + spaces ) ) ) { emsg ( _ ( e_resulting_text_too_long ) ) ; break ; } totlen = count * ( yanklen + spaces ) + bd . startspaces + bd . endspaces ; newp = alloc ( totlen + oldlen + 1 ) ; if ( newp == NULL ) break ; ptr = newp ; mch_memmove ( ptr , oldp , ( size_t ) bd . textcol ) ; ptr += bd . textcol ; vim_memset ( ptr , '<S2SV_blank>' , ( size_t ) bd . startspaces ) ; ptr += bd . startspaces ; for ( j = 0 ; j < count ; ++ j ) { mch_memmove ( ptr , y_array [ i ] , ( size_t ) yanklen ) ; ptr += yanklen ; if ( ( j < count - 1 || ! shortline ) && spaces ) { vim_memset ( ptr , '<S2SV_blank>' , ( size_t ) spaces ) ; ptr += spaces ; } <S2SV_StartBug> } <S2SV_EndBug> vim_memset ( ptr , '<S2SV_blank>' , ( size_t ) bd . endspaces ) ; ptr += bd . endspaces ; mch_memmove ( ptr , oldp + bd . textcol + delcount , ( size_t ) ( oldlen - bd . textcol - delcount + 1 ) ) ; ml_replace ( curwin -> w_cursor . lnum , newp , FALSE ) ; ++ curwin -> w_cursor . lnum ; if ( i == 0 ) curwin -> w_cursor . col += bd . startspaces ; } changed_lines ( lnum , 0 , curwin -> w_cursor . lnum , nr_lines ) ; curbuf -> b_op_start = curwin -> w_cursor ; curbuf -> b_op_start . lnum = lnum ; curbuf -> b_op_end . lnum = curwin -> w_cursor . lnum - 1 ; curbuf -> b_op_end . col = bd . textcol + totlen - 1 ; curbuf -> b_op_end . coladd = 0 ; if ( flags & PUT_CURSEND ) { colnr_T len ; curwin -> w_cursor = curbuf -> b_op_end ; curwin -> w_cursor . col ++ ; len = ( colnr_T ) STRLEN ( ml_get_curline ( ) ) ; if ( curwin -> w_cursor . col > len ) curwin -> w_cursor . col = len ; } else curwin -> w_cursor . lnum = lnum ; } else { if ( y_type == MCHAR ) { if ( dir == FORWARD && gchar_cursor ( ) != NUL ) { if ( has_mbyte ) { int bytelen = ( * mb_ptr2len ) ( ml_get_cursor ( ) ) ; col += bytelen ; if ( yanklen ) { curwin -> w_cursor . col += bytelen ; curbuf -> b_op_end . col += bytelen ; } } else { ++ col ; if ( yanklen ) { ++ curwin -> w_cursor . col ; ++ curbuf -> b_op_end . col ; } } } curbuf -> b_op_start = curwin -> w_cursor ; } else if ( dir == BACKWARD ) -- lnum ; new_cursor = curwin -> w_cursor ; if ( y_type == MCHAR && y_size == 1 ) { linenr_T end_lnum = 0 ; linenr_T start_lnum = lnum ; int first_byte_off = 0 ; if ( VIsual_active ) { end_lnum = curbuf -> b_visual . vi_end . lnum ; if ( end_lnum < curbuf -> b_visual . vi_start . lnum ) end_lnum = curbuf -> b_visual . vi_start . lnum ; if ( end_lnum > start_lnum ) { pos_T pos ; pos . lnum = lnum ; pos . col = col ; pos . coladd = 0 ; getvcol ( curwin , & pos , NULL , & vcol , NULL ) ; } } if ( count == 0 || yanklen == 0 ) { if ( VIsual_active ) lnum = end_lnum ; } else if ( count > INT_MAX / yanklen ) emsg ( _ ( e_resulting_text_too_long ) ) ; else { totlen = count * yanklen ; do { oldp = ml_get ( lnum ) ; oldlen = ( int ) STRLEN ( oldp ) ; if ( lnum > start_lnum ) { pos_T pos ; pos . lnum = lnum ; if ( getvpos ( & pos , vcol ) == OK ) col = pos . col ; else col = MAXCOL ; } if ( VIsual_active && col > oldlen ) { lnum ++ ; continue ; } newp = alloc ( totlen + oldlen + 1 ) ; if ( newp == NULL ) goto end ; mch_memmove ( newp , oldp , ( size_t ) col ) ; ptr = newp + col ; for ( i = 0 ; i < count ; ++ i ) { mch_memmove ( ptr , y_array [ 0 ] , ( size_t ) yanklen ) ; ptr += yanklen ; } STRMOVE ( ptr , oldp + col ) ; ml_replace ( lnum , newp , FALSE ) ; first_byte_off = mb_head_off ( newp , ptr - 1 ) ; if ( lnum == curwin -> w_cursor . lnum ) { changed_cline_bef_curs ( ) ; curwin -> w_cursor . col += ( colnr_T ) ( totlen - 1 ) ; } if ( VIsual_active ) lnum ++ ; } while ( VIsual_active && lnum <= end_lnum ) ; if ( VIsual_active ) lnum -- ; } curbuf -> b_op_end = curwin -> w_cursor ; curbuf -> b_op_end . col -= first_byte_off ; if ( totlen && ( restart_edit != 0 || ( flags & PUT_CURSEND ) ) ) ++ curwin -> w_cursor . col ; else curwin -> w_cursor . col -= first_byte_off ; changed_bytes ( lnum , col ) ; } else { linenr_T new_lnum = new_cursor . lnum ; size_t len ; for ( cnt = 1 ; cnt <= count ; ++ cnt ) { i = 0 ; if ( y_type == MCHAR ) { lnum = new_cursor . lnum ; ptr = ml_get ( lnum ) + col ; totlen = ( int ) STRLEN ( y_array [ y_size - 1 ] ) ; newp = alloc ( STRLEN ( ptr ) + totlen + 1 ) ; if ( newp == NULL ) goto error ; STRCPY ( newp , y_array [ y_size - 1 ] ) ; STRCAT ( newp , ptr ) ; ml_append ( lnum , newp , ( colnr_T ) 0 , FALSE ) ; ++ new_lnum ; vim_free ( newp ) ; oldp = ml_get ( lnum ) ; newp = alloc ( col + yanklen + 1 ) ; if ( newp == NULL ) goto error ; mch_memmove ( newp , oldp , ( size_t ) col ) ; mch_memmove ( newp + col , y_array [ 0 ] , ( size_t ) ( yanklen + 1 ) ) ; ml_replace ( lnum , newp , FALSE ) ; curwin -> w_cursor . lnum = lnum ; i = 1 ; } for ( ; i < y_size ; ++ i ) { if ( y_type != MCHAR || i < y_size - 1 ) { if ( ml_append ( lnum , y_array [ i ] , ( colnr_T ) 0 , FALSE ) == FAIL ) goto error ; new_lnum ++ ; } lnum ++ ; ++ nr_lines ; if ( flags & PUT_FIXINDENT ) { old_pos = curwin -> w_cursor ; curwin -> w_cursor . lnum = lnum ; ptr = ml_get ( lnum ) ; if ( cnt == count && i == y_size - 1 ) lendiff = ( int ) STRLEN ( ptr ) ; if ( * ptr == '#' && preprocs_left ( ) ) indent = 0 ; else if ( * ptr == NUL ) indent = 0 ; else if ( first_indent ) { indent_diff = orig_indent - get_indent ( ) ; indent = orig_indent ; first_indent = FALSE ; } else if ( ( indent = get_indent ( ) + indent_diff ) < 0 ) indent = 0 ; ( void ) set_indent ( indent , 0 ) ; curwin -> w_cursor = old_pos ; if ( cnt == count && i == y_size - 1 ) lendiff -= ( int ) STRLEN ( ml_get ( lnum ) ) ; } } if ( cnt == 1 ) new_lnum = lnum ; } error : if ( y_type == MLINE ) { curbuf -> b_op_start . col = 0 ; if ( dir == FORWARD ) curbuf -> b_op_start . lnum ++ ; } if ( curbuf -> b_op_start . lnum + ( y_type == MCHAR ) - 1 + nr_lines < curbuf -> b_ml . ml_line_count # ifdef FEAT_DIFF || curwin -> w_p_diff # endif ) mark_adjust ( curbuf -> b_op_start . lnum + ( y_type == MCHAR ) , ( linenr_T ) MAXLNUM , nr_lines , 0L ) ; if ( y_type == MCHAR ) changed_lines ( curwin -> w_cursor . lnum , col , curwin -> w_cursor . lnum + 1 , nr_lines ) ; else changed_lines ( curbuf -> b_op_start . lnum , 0 , curbuf -> b_op_start . lnum , nr_lines ) ; if ( y_current_used != NULL && ( y_current_used != y_current || y_current -> y_array != y_array ) ) { emsg ( _ ( e_yank_register_changed_while_using_it ) ) ; goto end ; } curbuf -> b_op_end . lnum = new_lnum ; len = STRLEN ( y_array [ y_size - 1 ] ) ; col = ( colnr_T ) len - lendiff ; if ( col > 1 ) { curbuf -> b_op_end . col = col - 1 ; if ( len > 0 ) curbuf -> b_op_end . col -= mb_head_off ( y_array [ y_size - 1 ] , y_array [ y_size - 1 ] + len - 1 ) ; } else curbuf -> b_op_end . col = 0 ; if ( flags & PUT_CURSLINE ) { curwin -> w_cursor . lnum = lnum ; beginline ( BL_WHITE | BL_FIX ) ; } else if ( flags & PUT_CURSEND ) { if ( y_type == MLINE ) { if ( lnum >= curbuf -> b_ml . ml_line_count ) curwin -> w_cursor . lnum = curbuf -> b_ml . ml_line_count ; else curwin -> w_cursor . lnum = lnum + 1 ; curwin -> w_cursor . col = 0 ; } else { curwin -> w_cursor . lnum = new_lnum ; curwin -> w_cursor . col = col ; curbuf -> b_op_end = curwin -> w_cursor ; if ( col > 1 ) curbuf -> b_op_end . col = col - 1 ; } } else if ( y_type == MLINE ) { curwin -> w_cursor . col = 0 ; if ( dir == FORWARD ) ++ curwin -> w_cursor . lnum ; beginline ( BL_WHITE | BL_FIX ) ; } else curwin -> w_cursor = new_cursor ; } } msgmore ( nr_lines ) ; curwin -> w_set_curswant = TRUE ; end : if ( cmdmod . cmod_flags & CMOD_LOCKMARKS ) { curbuf -> b_op_start = orig_start ; curbuf -> b_op_end = orig_end ; } if ( allocated ) vim_free ( insert_string ) ; if ( regname == '=' ) vim_free ( y_array ) ; VIsual_active = FALSE ; adjust_cursor_eol ( ) ; }", "target": "<S2SV_ModStart> spaces ; } else totlen -= spaces ;"}
{"source": "CWE-125 R_API RBinJavaAttrInfo * r_bin_java_bootstrap_methods_attr_new ( RBinJavaObj * bin , ut8 * buffer , ut64 sz , ut64 buf_offset ) { ut32 i = 0 ; RBinJavaBootStrapMethod * bsm = NULL ; ut64 offset = 0 ; RBinJavaAttrInfo * attr = r_bin_java_default_attr_new ( bin , buffer , sz , buf_offset ) ; offset += 6 ; if ( attr ) { attr -> type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR ; <S2SV_StartBug> attr -> info . bootstrap_methods_attr . num_bootstrap_methods = R_BIN_JAVA_USHORT ( buffer , offset ) ; <S2SV_EndBug> offset += 2 ; attr -> info . bootstrap_methods_attr . bootstrap_methods = r_list_newf ( r_bin_java_bootstrap_method_free ) ; for ( i = 0 ; i < attr -> info . bootstrap_methods_attr . num_bootstrap_methods ; i ++ ) { if ( offset >= sz ) { break ; } bsm = r_bin_java_bootstrap_method_new ( buffer + offset , sz - offset , buf_offset + offset ) ; if ( bsm ) { offset += bsm -> size ; r_list_append ( attr -> info . bootstrap_methods_attr . bootstrap_methods , ( void * ) bsm ) ; } else { } } attr -> size = offset ; } return attr ; }", "target": "<S2SV_ModStart> = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR ; if ( offset + 8 > sz ) { free ( attr ) ; return NULL ; }"}
{"source": "CWE-787 _inplace_src_spans ( void * abstract_renderer , int y , int h , const cairo_half_open_span_t * spans , unsigned num_spans ) { cairo_image_span_renderer_t * r = abstract_renderer ; <S2SV_StartBug> uint8_t * m ; <S2SV_EndBug> int x0 ; if ( num_spans == 0 ) return CAIRO_STATUS_SUCCESS ; x0 = spans [ 0 ] . x ; <S2SV_StartBug> m = r -> _buf ; <S2SV_EndBug> do { int len = spans [ 1 ] . x - spans [ 0 ] . x ; if ( len >= r -> u . composite . run_length && spans [ 0 ] . coverage == 0xff ) { if ( spans [ 0 ] . x != x0 ) { # if PIXMAN_HAS_OP_LERP pixman_image_composite32 ( PIXMAN_OP_LERP_SRC , r -> src , r -> mask , r -> u . composite . dst , x0 + r -> u . composite . src_x , y + r -> u . composite . src_y , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; # else pixman_image_composite32 ( PIXMAN_OP_OUT_REVERSE , r -> mask , NULL , r -> u . composite . dst , 0 , 0 , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; pixman_image_composite32 ( PIXMAN_OP_ADD , r -> src , r -> mask , r -> u . composite . dst , x0 + r -> u . composite . src_x , y + r -> u . composite . src_y , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; # endif } pixman_image_composite32 ( PIXMAN_OP_SRC , r -> src , NULL , r -> u . composite . dst , spans [ 0 ] . x + r -> u . composite . src_x , y + r -> u . composite . src_y , 0 , 0 , spans [ 0 ] . x , y , spans [ 1 ] . x - spans [ 0 ] . x , h ) ; <S2SV_StartBug> m = r -> _buf ; <S2SV_EndBug> x0 = spans [ 1 ] . x ; } else if ( spans [ 0 ] . coverage == 0x0 ) { if ( spans [ 0 ] . x != x0 ) { # if PIXMAN_HAS_OP_LERP pixman_image_composite32 ( PIXMAN_OP_LERP_SRC , r -> src , r -> mask , r -> u . composite . dst , x0 + r -> u . composite . src_x , y + r -> u . composite . src_y , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; # else pixman_image_composite32 ( PIXMAN_OP_OUT_REVERSE , r -> mask , NULL , r -> u . composite . dst , 0 , 0 , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; pixman_image_composite32 ( PIXMAN_OP_ADD , r -> src , r -> mask , r -> u . composite . dst , x0 + r -> u . composite . src_x , y + r -> u . composite . src_y , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; # endif } <S2SV_StartBug> m = r -> _buf ; <S2SV_EndBug> x0 = spans [ 1 ] . x ; } else { * m ++ = spans [ 0 ] . coverage ; if ( len > 1 ) { memset ( m , spans [ 0 ] . coverage , -- len ) ; m += len ; } } spans ++ ; } while ( -- num_spans > 1 ) ; if ( spans [ 0 ] . x != x0 ) { # if PIXMAN_HAS_OP_LERP pixman_image_composite32 ( PIXMAN_OP_LERP_SRC , r -> src , r -> mask , r -> u . composite . dst , x0 + r -> u . composite . src_x , y + r -> u . composite . src_y , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; # else pixman_image_composite32 ( PIXMAN_OP_OUT_REVERSE , r -> mask , NULL , r -> u . composite . dst , 0 , 0 , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; pixman_image_composite32 ( PIXMAN_OP_ADD , r -> src , r -> mask , r -> u . composite . dst , x0 + r -> u . composite . src_x , y + r -> u . composite . src_y , 0 , 0 , x0 , y , spans [ 0 ] . x - x0 , h ) ; # endif } return CAIRO_STATUS_SUCCESS ; }", "target": "<S2SV_ModStart> uint8_t * m , * base = ( uint8_t * ) pixman_image_get_data ( r -> mask ) <S2SV_ModStart> ; m = base <S2SV_ModEnd> ; do { <S2SV_ModStart> ; m = base <S2SV_ModEnd> ; x0 = <S2SV_ModStart> } m = base <S2SV_ModEnd> ; x0 ="}
{"source": "CWE-787 void QPaintEngineEx : : stroke ( const QVectorPath & path , const QPen & inPen ) { # ifdef QT_DEBUG_DRAW qDebug ( ) << \"QPaintEngineEx::stroke()\" << pen ; # endif Q_D ( QPaintEngineEx ) ; if ( path . isEmpty ( ) ) return ; if ( ! d -> strokeHandler ) { d -> strokeHandler = new StrokeHandler ( path . elementCount ( ) + 4 ) ; d -> stroker . setMoveToHook ( qpaintengineex_moveTo ) ; d -> stroker . setLineToHook ( qpaintengineex_lineTo ) ; d -> stroker . setCubicToHook ( qpaintengineex_cubicTo ) ; } QRectF clipRect ; QPen pen = inPen ; if ( pen . style ( ) > Qt : : SolidLine ) { QRectF cpRect = path . controlPointRect ( ) ; const QTransform & xf = state ( ) -> matrix ; if ( pen . isCosmetic ( ) ) { clipRect = d -> exDeviceRect ; cpRect . translate ( xf . dx ( ) , xf . dy ( ) ) ; } else { clipRect = xf . inverted ( ) . mapRect ( QRectF ( d -> exDeviceRect ) ) ; } QRectF extentRect = cpRect & clipRect ; qreal extent = qMax ( extentRect . width ( ) , extentRect . height ( ) ) ; qreal patternLength = 0 ; const QList < qreal > pattern = pen . dashPattern ( ) ; const int patternSize = qMin ( pattern . size ( ) , 32 ) ; for ( int i = 0 ; i < patternSize ; i ++ ) patternLength += qMax ( pattern . at ( i ) , qreal ( 0 ) ) ; if ( pen . widthF ( ) ) patternLength *= pen . widthF ( ) ; if ( qFuzzyIsNull ( patternLength ) ) { pen . setStyle ( Qt : : NoPen ) ; <S2SV_StartBug> } else if ( extent / patternLength > 10000 ) { <S2SV_EndBug> pen . setStyle ( Qt : : SolidLine ) ; QColor color ( pen . color ( ) ) ; color . setAlpha ( color . alpha ( ) / 2 ) ; pen . setColor ( color ) ; } } if ( ! qpen_fast_equals ( pen , d -> strokerPen ) ) { d -> strokerPen = pen ; d -> stroker . setJoinStyle ( pen . joinStyle ( ) ) ; d -> stroker . setCapStyle ( pen . capStyle ( ) ) ; d -> stroker . setMiterLimit ( pen . miterLimit ( ) ) ; qreal penWidth = pen . widthF ( ) ; if ( penWidth == 0 ) d -> stroker . setStrokeWidth ( 1 ) ; else d -> stroker . setStrokeWidth ( penWidth ) ; Qt : : PenStyle style = pen . style ( ) ; if ( style == Qt : : SolidLine ) { d -> activeStroker = & d -> stroker ; } else if ( style == Qt : : NoPen ) { d -> activeStroker = nullptr ; } else { d -> dasher . setDashPattern ( pen . dashPattern ( ) ) ; d -> dasher . setDashOffset ( pen . dashOffset ( ) ) ; d -> activeStroker = & d -> dasher ; } } if ( ! d -> activeStroker ) { return ; } if ( ! clipRect . isNull ( ) ) d -> activeStroker -> setClipRect ( clipRect ) ; if ( d -> activeStroker == & d -> stroker ) d -> stroker . setForceOpen ( path . hasExplicitOpen ( ) ) ; const QPainterPath : : ElementType * types = path . elements ( ) ; const qreal * points = path . points ( ) ; int pointCount = path . elementCount ( ) ; const qreal * lastPoint = points + ( pointCount << 1 ) ; d -> strokeHandler -> types . reset ( ) ; d -> strokeHandler -> pts . reset ( ) ; uint flags = QVectorPath : : WindingFill ; if ( path . elementCount ( ) > 2 ) flags |= QVectorPath : : NonConvexShapeMask ; if ( d -> stroker . capStyle ( ) == Qt : : RoundCap || d -> stroker . joinStyle ( ) == Qt : : RoundJoin ) flags |= QVectorPath : : CurvedShapeMask ; if ( ! pen . isCosmetic ( ) ) { d -> activeStroker -> setCurveThresholdFromTransform ( state ( ) -> matrix ) ; d -> activeStroker -> begin ( d -> strokeHandler ) ; if ( types ) { while ( points < lastPoint ) { switch ( * types ) { case QPainterPath : : MoveToElement : d -> activeStroker -> moveTo ( points [ 0 ] , points [ 1 ] ) ; points += 2 ; ++ types ; break ; case QPainterPath : : LineToElement : d -> activeStroker -> lineTo ( points [ 0 ] , points [ 1 ] ) ; points += 2 ; ++ types ; break ; case QPainterPath : : CurveToElement : d -> activeStroker -> cubicTo ( points [ 0 ] , points [ 1 ] , points [ 2 ] , points [ 3 ] , points [ 4 ] , points [ 5 ] ) ; points += 6 ; types += 3 ; flags |= QVectorPath : : CurvedShapeMask ; break ; default : break ; } } if ( path . hasImplicitClose ( ) ) d -> activeStroker -> lineTo ( path . points ( ) [ 0 ] , path . points ( ) [ 1 ] ) ; } else { d -> activeStroker -> moveTo ( points [ 0 ] , points [ 1 ] ) ; points += 2 ; while ( points < lastPoint ) { d -> activeStroker -> lineTo ( points [ 0 ] , points [ 1 ] ) ; points += 2 ; } if ( path . hasImplicitClose ( ) ) d -> activeStroker -> lineTo ( path . points ( ) [ 0 ] , path . points ( ) [ 1 ] ) ; } d -> activeStroker -> end ( ) ; if ( ! d -> strokeHandler -> types . size ( ) ) return ; QVectorPath strokePath ( d -> strokeHandler -> pts . data ( ) , d -> strokeHandler -> types . size ( ) , d -> strokeHandler -> types . data ( ) , flags ) ; fill ( strokePath , pen . brush ( ) ) ; } else { if ( state ( ) -> matrix . type ( ) >= QTransform : : TxProject ) { QPainterPath painterPath = state ( ) -> matrix . map ( path . convertToPainterPath ( ) ) ; d -> activeStroker -> strokePath ( painterPath , d -> strokeHandler , QTransform ( ) ) ; } else { d -> activeStroker -> setCurveThresholdFromTransform ( QTransform ( ) ) ; d -> activeStroker -> begin ( d -> strokeHandler ) ; if ( types ) { while ( points < lastPoint ) { switch ( * types ) { case QPainterPath : : MoveToElement : { QPointF pt = ( * ( const QPointF * ) points ) * state ( ) -> matrix ; d -> activeStroker -> moveTo ( pt . x ( ) , pt . y ( ) ) ; points += 2 ; ++ types ; break ; } case QPainterPath : : LineToElement : { QPointF pt = ( * ( const QPointF * ) points ) * state ( ) -> matrix ; d -> activeStroker -> lineTo ( pt . x ( ) , pt . y ( ) ) ; points += 2 ; ++ types ; break ; } case QPainterPath : : CurveToElement : { QPointF c1 = ( ( const QPointF * ) points ) [ 0 ] * state ( ) -> matrix ; QPointF c2 = ( ( const QPointF * ) points ) [ 1 ] * state ( ) -> matrix ; QPointF e = ( ( const QPointF * ) points ) [ 2 ] * state ( ) -> matrix ; d -> activeStroker -> cubicTo ( c1 . x ( ) , c1 . y ( ) , c2 . x ( ) , c2 . y ( ) , e . x ( ) , e . y ( ) ) ; points += 6 ; types += 3 ; flags |= QVectorPath : : CurvedShapeMask ; break ; } default : break ; } } if ( path . hasImplicitClose ( ) ) { QPointF pt = * ( ( const QPointF * ) path . points ( ) ) * state ( ) -> matrix ; d -> activeStroker -> lineTo ( pt . x ( ) , pt . y ( ) ) ; } } else { QPointF p = ( ( const QPointF * ) points ) [ 0 ] * state ( ) -> matrix ; d -> activeStroker -> moveTo ( p . x ( ) , p . y ( ) ) ; points += 2 ; while ( points < lastPoint ) { QPointF p = ( ( const QPointF * ) points ) [ 0 ] * state ( ) -> matrix ; d -> activeStroker -> lineTo ( p . x ( ) , p . y ( ) ) ; points += 2 ; } if ( path . hasImplicitClose ( ) ) d -> activeStroker -> lineTo ( p . x ( ) , p . y ( ) ) ; } d -> activeStroker -> end ( ) ; } QVectorPath strokePath ( d -> strokeHandler -> pts . data ( ) , d -> strokeHandler -> types . size ( ) , d -> strokeHandler -> types . data ( ) , flags ) ; QTransform xform = state ( ) -> matrix ; state ( ) -> matrix = QTransform ( ) ; transformChanged ( ) ; QBrush brush = pen . brush ( ) ; if ( qbrush_style ( brush ) != Qt : : SolidPattern ) brush . setTransform ( brush . transform ( ) * xform ) ; fill ( strokePath , brush ) ; state ( ) -> matrix = xform ; transformChanged ( ) ; } }", "target": "<S2SV_ModStart> else if ( qFuzzyIsNull ( extent ) ||"}
{"source": "CWE-787 block_insert ( oparg_T * oap , char_u * s , int b_insert , struct block_def * bdp ) { int ts_val ; int count = 0 ; int spaces = 0 ; colnr_T offset ; colnr_T startcol ; unsigned s_len ; char_u * newp , * oldp ; linenr_T lnum ; int oldstate = State ; State = INSERT ; s_len = ( unsigned ) STRLEN ( s ) ; for ( lnum = oap -> start . lnum + 1 ; lnum <= oap -> end . lnum ; lnum ++ ) { block_prep ( oap , bdp , lnum , TRUE ) ; if ( bdp -> is_short && b_insert ) continue ; oldp = ml_get ( lnum ) ; if ( b_insert ) { ts_val = bdp -> start_char_vcols ; spaces = bdp -> startspaces ; if ( spaces != 0 ) count = ts_val - 1 ; offset = bdp -> textcol ; } else { ts_val = bdp -> end_char_vcols ; if ( ! bdp -> is_short ) { spaces = ( bdp -> endspaces ? ts_val - bdp -> endspaces : 0 ) ; if ( spaces != 0 ) count = ts_val - 1 ; offset = bdp -> textcol + bdp -> textlen - ( spaces != 0 ) ; } else { if ( ! bdp -> is_MAX ) spaces = ( oap -> end_vcol - bdp -> end_vcol ) + 1 ; count = spaces ; offset = bdp -> textcol + bdp -> textlen ; } } if ( has_mbyte && spaces > 0 ) <S2SV_StartBug> { <S2SV_EndBug> int off ; if ( b_insert ) { <S2SV_StartBug> off = ( * mb_head_off ) ( oldp , oldp + offset + spaces ) ; <S2SV_EndBug> spaces -= off ; count -= off ; } else { off = ( * mb_head_off ) ( oldp , oldp + offset ) ; offset -= off ; } } if ( spaces < 0 ) spaces = 0 ; newp = alloc ( STRLEN ( oldp ) + spaces + s_len + ( spaces > 0 && ! bdp -> is_short ? ts_val - spaces : 0 ) + count + 1 ) ; if ( newp == NULL ) continue ; mch_memmove ( newp , oldp , ( size_t ) offset ) ; oldp += offset ; vim_memset ( newp + offset , '<S2SV_blank>' , ( size_t ) spaces ) ; startcol = offset + spaces ; mch_memmove ( newp + startcol , s , ( size_t ) s_len ) ; offset += s_len ; if ( spaces > 0 && ! bdp -> is_short ) { if ( * oldp == TAB ) { vim_memset ( newp + offset + spaces , '<S2SV_blank>' , ( size_t ) ( ts_val - spaces ) ) ; oldp ++ ; count ++ ; } else count = spaces ; } if ( spaces > 0 ) offset += count ; STRMOVE ( newp + offset , oldp ) ; ml_replace ( lnum , newp , FALSE ) ; if ( b_insert ) inserted_bytes ( lnum , startcol , s_len ) ; if ( lnum == oap -> end . lnum ) { curbuf -> b_op_end . lnum = oap -> end . lnum ; curbuf -> b_op_end . col = offset ; } } changed_lines ( oap -> start . lnum + 1 , 0 , oap -> end . lnum + 1 , 0L ) ; State = oldstate ; }", "target": "<S2SV_ModStart> > 0 ) offset -= <S2SV_ModEnd> ( * mb_head_off <S2SV_ModStart> oldp + offset ) ; <S2SV_ModEnd> if ( spaces"}
{"source": "CWE-122 find_match_text ( colnr_T startcol , int regstart , char_u * match_text ) { colnr_T col = startcol ; int c1 , c2 ; int len1 , len2 ; int match ; for ( ; ; ) { match = TRUE ; len2 = MB_CHAR2LEN ( regstart ) ; for ( len1 = 0 ; match_text [ len1 ] != NUL ; len1 += MB_CHAR2LEN ( c1 ) ) { c1 = PTR2CHAR ( match_text + len1 ) ; c2 = PTR2CHAR ( rex . line + col + len2 ) ; if ( c1 != c2 && ( ! rex . reg_ic || MB_CASEFOLD ( c1 ) != MB_CASEFOLD ( c2 ) ) ) { match = FALSE ; break ; } <S2SV_StartBug> len2 += MB_CHAR2LEN ( c2 ) ; <S2SV_EndBug> } if ( match && ! ( enc_utf8 && utf_iscomposing ( PTR2CHAR ( rex . line + col + len2 ) ) ) ) { cleanup_subexpr ( ) ; if ( REG_MULTI ) { rex . reg_startpos [ 0 ] . lnum = rex . lnum ; rex . reg_startpos [ 0 ] . col = col ; rex . reg_endpos [ 0 ] . lnum = rex . lnum ; rex . reg_endpos [ 0 ] . col = col + len2 ; } else { rex . reg_startp [ 0 ] = rex . line + col ; rex . reg_endp [ 0 ] = rex . line + col + len2 ; } return 1L ; } col += MB_CHAR2LEN ( regstart ) ; if ( skip_to_start ( regstart , & col ) == FAIL ) break ; } return 0L ; }", "target": "<S2SV_ModStart> } len2 += enc_utf8 ? utf_ptr2len ( rex . line + col + len2 ) :"}
{"source": "CWE-119 static inline LineContribType * _gdContributionsAlloc ( unsigned int line_length , unsigned int windows_size ) { unsigned int u = 0 ; LineContribType * res ; int overflow_error = 0 ; res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u = 0 ; u < line_length ; u ++ ) { if ( overflow2 ( windows_size , sizeof ( double ) ) ) { overflow_error = 1 ; } else { res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ; } if ( overflow_error == 1 || res -> ContribRow [ u ] . Weights == NULL ) { <S2SV_StartBug> u -- ; <S2SV_EndBug> <S2SV_StartBug> while ( u >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> gdFree ( res -> ContribRow [ u ] . Weights ) ; <S2SV_EndBug> <S2SV_StartBug> u -- ; <S2SV_EndBug> } return NULL ; } } return res ; }", "target": "<S2SV_ModStart> NULL ) { unsigned int i ; <S2SV_ModStart> u -- ; for ( i = 0 ; i <= u ; i ++ <S2SV_ModEnd> ) { gdFree <S2SV_ModStart> -> ContribRow [ i <S2SV_ModEnd> ] . Weights <S2SV_ModStart> Weights ) ; } gdFree ( res ) ; <S2SV_ModEnd> return NULL ;"}
{"source": "CWE-125 static void ip6gre_err ( struct sk_buff * skb , struct inet6_skb_parm * opt , u8 type , u8 code , int offset , __be32 info ) { <S2SV_StartBug> const struct ipv6hdr * ipv6h = ( const struct ipv6hdr * ) skb -> data ; <S2SV_EndBug> __be16 * p = ( __be16 * ) ( skb -> data + offset ) ; <S2SV_StartBug> int grehlen = offset + 4 ; <S2SV_EndBug> <S2SV_StartBug> struct ip6_tnl * t ; <S2SV_EndBug> __be16 flags ; <S2SV_StartBug> <S2SV_EndBug> flags = p [ 0 ] ; if ( flags & ( GRE_CSUM | GRE_KEY | GRE_SEQ | GRE_ROUTING | GRE_VERSION ) ) { if ( flags & ( GRE_VERSION | GRE_ROUTING ) ) return ; <S2SV_StartBug> if ( flags & GRE_KEY ) { <S2SV_EndBug> grehlen += 4 ; <S2SV_StartBug> if ( flags & GRE_CSUM ) <S2SV_EndBug> grehlen += 4 ; } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! pskb_may_pull ( skb , grehlen ) ) <S2SV_EndBug> return ; ipv6h = ( const struct ipv6hdr * ) skb -> data ; <S2SV_StartBug> p = ( __be16 * ) ( skb -> data + offset ) ; <S2SV_EndBug> t = ip6gre_tunnel_lookup ( skb -> dev , & ipv6h -> daddr , & ipv6h -> saddr , <S2SV_StartBug> flags & GRE_KEY ? <S2SV_EndBug> * ( ( ( __be32 * ) p ) + ( grehlen / 4 ) - 1 ) : 0 , p [ 1 ] ) ; if ( ! t ) return ; switch ( type ) { __u32 teli ; struct ipv6_tlv_tnl_enc_lim * tel ; __u32 mtu ; case ICMPV6_DEST_UNREACH : net_dbg_ratelimited ( \"%s:<S2SV_blank>Path<S2SV_blank>to<S2SV_blank>destination<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>inactive!\\\\n\" , t -> parms . name ) ; break ; case ICMPV6_TIME_EXCEED : if ( code == ICMPV6_EXC_HOPLIMIT ) { net_dbg_ratelimited ( \"%s:<S2SV_blank>Too<S2SV_blank>small<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>or<S2SV_blank>routing<S2SV_blank>loop<S2SV_blank>in<S2SV_blank>tunnel!\\\\n\" , t -> parms . name ) ; } break ; case ICMPV6_PARAMPROB : teli = 0 ; if ( code == ICMPV6_HDR_FIELD ) teli = ip6_tnl_parse_tlv_enc_lim ( skb , skb -> data ) ; if ( teli && teli == be32_to_cpu ( info ) - 2 ) { tel = ( struct ipv6_tlv_tnl_enc_lim * ) & skb -> data [ teli ] ; if ( tel -> encap_limit == 0 ) { net_dbg_ratelimited ( \"%s:<S2SV_blank>Too<S2SV_blank>small<S2SV_blank>encapsulation<S2SV_blank>limit<S2SV_blank>or<S2SV_blank>routing<S2SV_blank>loop<S2SV_blank>in<S2SV_blank>tunnel!\\\\n\" , t -> parms . name ) ; } } else { net_dbg_ratelimited ( \"%s:<S2SV_blank>Recipient<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>tunneled<S2SV_blank>packet!\\\\n\" , t -> parms . name ) ; } break ; case ICMPV6_PKT_TOOBIG : mtu = be32_to_cpu ( info ) - offset ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; t -> dev -> mtu = mtu ; break ; } if ( time_before ( jiffies , t -> err_time + IP6TUNNEL_ERR_TIMEO ) ) t -> err_count ++ ; else t -> err_count = 1 ; t -> err_time = jiffies ; }", "target": "<S2SV_ModStart> { const struct gre_base_hdr * greh ; const struct <S2SV_ModStart> ipv6hdr * ipv6h <S2SV_ModEnd> ; int grehlen <S2SV_ModStart> int grehlen = sizeof ( * greh ) <S2SV_ModEnd> ; struct ip6_tnl <S2SV_ModStart> ip6_tnl * t ; int key_off = 0 <S2SV_ModStart> __be16 flags ; __be32 key ; if ( ! pskb_may_pull ( skb , offset + grehlen ) ) return ; greh = ( const struct gre_base_hdr * ) ( skb -> data + offset ) ; flags = greh -> flags ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> ( flags & GRE_CSUM ) <S2SV_ModEnd> grehlen += 4 <S2SV_ModStart> ( flags & GRE_KEY ) { key_off = grehlen + offset ; <S2SV_ModEnd> grehlen += 4 <S2SV_ModStart> 4 ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( skb , offset + <S2SV_ModStart> -> data ; greh = ( const struct gre_base_hdr <S2SV_ModEnd> * ) ( <S2SV_ModStart> + offset ) ; key = key_off ? * ( __be32 * ) ( skb -> data + key_off ) : 0 <S2SV_ModStart> -> saddr , key , greh -> protocol <S2SV_ModEnd> ) ; if"}
{"source": "CWE-369 static int parallels_open ( BlockDriverState * bs , QDict * options , int flags , Error * * errp ) { BDRVParallelsState * s = bs -> opaque ; int i ; struct parallels_header ph ; int ret ; bs -> read_only = 1 ; ret = bdrv_pread ( bs -> file , 0 , & ph , sizeof ( ph ) ) ; if ( ret < 0 ) { goto fail ; } if ( memcmp ( ph . magic , HEADER_MAGIC , 16 ) || ( le32_to_cpu ( ph . version ) != HEADER_VERSION ) ) { error_setg ( errp , \"Image<S2SV_blank>not<S2SV_blank>in<S2SV_blank>Parallels<S2SV_blank>format\" ) ; ret = - EINVAL ; goto fail ; } bs -> total_sectors = le32_to_cpu ( ph . nb_sectors ) ; <S2SV_StartBug> s -> tracks = le32_to_cpu ( ph . tracks ) ; <S2SV_EndBug> s -> catalog_size = le32_to_cpu ( ph . catalog_entries ) ; if ( s -> catalog_size > INT_MAX / 4 ) { error_setg ( errp , \"Catalog<S2SV_blank>too<S2SV_blank>large\" ) ; ret = - EFBIG ; goto fail ; } s -> catalog_bitmap = g_malloc ( s -> catalog_size * 4 ) ; ret = bdrv_pread ( bs -> file , 64 , s -> catalog_bitmap , s -> catalog_size * 4 ) ; if ( ret < 0 ) { goto fail ; } for ( i = 0 ; i < s -> catalog_size ; i ++ ) le32_to_cpus ( & s -> catalog_bitmap [ i ] ) ; qemu_co_mutex_init ( & s -> lock ) ; return 0 ; fail : g_free ( s -> catalog_bitmap ) ; return ret ; }", "target": "<S2SV_ModStart> tracks ) ; if ( s -> tracks == 0 ) { error_setg ( errp , \"Invalid<S2SV_blank>image:<S2SV_blank>Zero<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>track\" ) ; ret = - EINVAL ; goto fail ; }"}
{"source": "CWE-787 lprn_is_black ( gx_device_printer * pdev , int r , int h , int bx ) { gx_device_lprn * const lprn = ( gx_device_lprn * ) pdev ; int bh = lprn -> nBh ; int bpl = gdev_mem_bytes_per_scan_line ( pdev ) ; int x , y , y0 ; byte * p ; int maxY = lprn -> BlockLine / lprn -> nBh * lprn -> nBh ; y0 = ( r + h - bh ) % maxY ; for ( y = 0 ; y < bh ; y ++ ) { p = & lprn -> ImageBuf [ ( y0 + y ) * bpl + bx * lprn -> nBw ] ; <S2SV_StartBug> for ( x = 0 ; x < lprn -> nBw ; x ++ ) <S2SV_EndBug> if ( p [ x ] != 0 ) return 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> x ++ ) { if ( bx * lprn -> nBw + x >= bpl ) break ; <S2SV_ModStart> 1 ; } }"}
{"source": "CWE-476 fname_match ( regmatch_T * rmp , char_u * name , int ignore_case ) { char_u * match = NULL ; char_u * p ; if ( name != NULL ) { rmp -> rm_ic = p_fic || ignore_case ; if ( vim_regexec ( rmp , name , ( colnr_T ) 0 ) ) match = name ; <S2SV_StartBug> else <S2SV_EndBug> { p = home_replace_save ( NULL , name ) ; if ( p != NULL && vim_regexec ( rmp , p , ( colnr_T ) 0 ) ) match = name ; vim_free ( p ) ; } } return match ; }", "target": "<S2SV_ModStart> name ; else if ( rmp -> regprog != NULL )"}
{"source": "CWE-704 struct sctp_chunk * sctp_make_strreset_req ( const struct sctp_association * asoc , __u16 stream_num , __be16 * stream_list , bool out , bool in ) { __u16 stream_len = stream_num * sizeof ( __u16 ) ; struct sctp_strreset_outreq outreq ; struct sctp_strreset_inreq inreq ; struct sctp_chunk * retval ; __u16 outlen , inlen ; outlen = ( sizeof ( outreq ) + stream_len ) * out ; inlen = ( sizeof ( inreq ) + stream_len ) * in ; <S2SV_StartBug> retval = sctp_make_reconf ( asoc , outlen + inlen ) ; <S2SV_EndBug> if ( ! retval ) return NULL ; if ( outlen ) { outreq . param_hdr . type = SCTP_PARAM_RESET_OUT_REQUEST ; outreq . param_hdr . length = htons ( outlen ) ; outreq . request_seq = htonl ( asoc -> strreset_outseq ) ; outreq . response_seq = htonl ( asoc -> strreset_inseq - 1 ) ; outreq . send_reset_at_tsn = htonl ( asoc -> next_tsn - 1 ) ; sctp_addto_chunk ( retval , sizeof ( outreq ) , & outreq ) ; if ( stream_len ) sctp_addto_chunk ( retval , stream_len , stream_list ) ; } if ( inlen ) { inreq . param_hdr . type = SCTP_PARAM_RESET_IN_REQUEST ; inreq . param_hdr . length = htons ( inlen ) ; inreq . request_seq = htonl ( asoc -> strreset_outseq + out ) ; sctp_addto_chunk ( retval , sizeof ( inreq ) , & inreq ) ; if ( stream_len ) sctp_addto_chunk ( retval , stream_len , stream_list ) ; } return retval ; }", "target": "<S2SV_ModStart> ( asoc , SCTP_PAD4 ( outlen ) + SCTP_PAD4 ( inlen ) <S2SV_ModEnd> ) ; if"}
{"source": "CWE-772 static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; PixelInfo pixel ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t base , flag , offset , real , skip ; ssize_t count , y ; TGAInfo tga_info ; unsigned char j , k , pixels [ 4 ] , runlength ; unsigned int alpha_bits ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & tga_info . id_length ) ; tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; tga_info . colormap_index = ReadBlobLSBShort ( image ) ; tga_info . colormap_length = ReadBlobLSBShort ( image ) ; tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . x_origin = ReadBlobLSBShort ( image ) ; tga_info . y_origin = ReadBlobLSBShort ( image ) ; tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> columns = tga_info . width ; image -> rows = tga_info . height ; alpha_bits = ( tga_info . attributes & 0x0FU ) ; image -> alpha_trait = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || ( tga_info . colormap_size == 32 ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARLEColormap ) ) image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : ( tga_info . bits_per_pixel <= 16 ) ? 5 : 8 ) ; else image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : ( tga_info . colormap_size <= 16 ) ? 5 : 8 ) ; if ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGAMonochrome ) || ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) ) image -> storage_class = PseudoClass ; image -> compression = NoCompression ; if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) || ( tga_info . image_type == TGARLERGB ) ) image -> compression = RLECompression ; if ( image -> storage_class == PseudoClass ) { if ( tga_info . colormap_type != 0 ) image -> colors = tga_info . colormap_index + tga_info . colormap_length ; else { size_t one ; one = 1 ; <S2SV_StartBug> image -> colors = one << tga_info . bits_per_pixel ; <S2SV_EndBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } } if ( tga_info . id_length != 0 ) { char * comment ; size_t length ; length = ( size_t ) tga_info . id_length ; comment = ( char * ) NULL ; if ( ~ length >= ( MagickPathExtent - 1 ) ) comment = ( char * ) AcquireQuantumMemory ( length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; count = ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; comment [ tga_info . id_length ] = '\\\\0' ; ( void ) SetImageProperty ( image , \"comment\" , comment , exception ) ; comment = DestroyString ( comment ) ; } if ( tga_info . attributes & ( 1UL << 4 ) ) { if ( tga_info . attributes & ( 1UL << 5 ) ) SetImageArtifact ( image , \"tga:image-origin\" , \"TopRight\" ) ; else SetImageArtifact ( image , \"tga:image-origin\" , \"BottomRight\" ) ; } else { if ( tga_info . attributes & ( 1UL << 5 ) ) SetImageArtifact ( image , \"tga:image-origin\" , \"TopLeft\" ) ; else SetImageArtifact ( image , \"tga:image-origin\" , \"BottomLeft\" ) ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; pixel . alpha = ( MagickRealType ) OpaqueAlpha ; if ( tga_info . colormap_type != 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; for ( i = 0 ; i < ( ssize_t ) tga_info . colormap_index ; i ++ ) image -> colormap [ i ] = pixel ; for ( ; i < ( ssize_t ) image -> colors ; i ++ ) { switch ( tga_info . colormap_size ) { case 8 : default : { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = pixel . red ; pixel . blue = pixel . red ; break ; } case 15 : case 16 : { QuantumAny range ; j = ( unsigned char ) ReadBlobByte ( image ) ; k = ( unsigned char ) ReadBlobByte ( image ) ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; break ; } case 24 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } case 32 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } } image -> colormap [ i ] = pixel ; } } base = 0 ; flag = 0 ; skip = MagickFalse ; real = 0 ; index = 0 ; runlength = 0 ; offset = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { real = offset ; if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) real = image -> rows - real - 1 ; q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLERGB ) || ( tga_info . image_type == TGARLEMonochrome ) ) { if ( runlength != 0 ) { runlength -- ; skip = flag != 0 ; } else { count = ReadBlob ( image , 1 , & runlength ) ; if ( count != 1 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; flag = runlength & 0x80 ; if ( flag != 0 ) runlength -= 128 ; skip = MagickFalse ; } } if ( skip == MagickFalse ) switch ( tga_info . bits_per_pixel ) { case 8 : default : { index = ( Quantum ) ReadBlobByte ( image ) ; if ( tga_info . colormap_type != 0 ) pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index , exception ) ] ; else { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; } break ; } case 15 : case 16 : { QuantumAny range ; if ( ReadBlob ( image , 2 , pixels ) != 2 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; j = pixels [ 0 ] ; k = pixels [ 1 ] ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) pixel . alpha = ( MagickRealType ) ( ( k & 0x80 ) == 0 ? ( Quantum ) TransparentAlpha : ( Quantum ) OpaqueAlpha ) ; if ( image -> storage_class == PseudoClass ) index = ( Quantum ) ConstrainColormapIndex ( image , ( ( ssize_t ) ( k << 8 ) ) + j , exception ) ; break ; } case 24 : { if ( ReadBlob ( image , 3 , pixels ) != 3 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; break ; } case 32 : { if ( ReadBlob ( image , 4 , pixels ) != 4 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 3 ] ) ; break ; } } if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , index , q ) ; SetPixelRed ( image , ClampToQuantum ( pixel . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( pixel . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( pixel . blue ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ClampToQuantum ( pixel . alpha ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) offset += 2 ; else offset ++ ; if ( offset >= image -> rows ) { base ++ ; offset = base ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> tga_info . bits_per_pixel ; if ( image -> colors > ( ( ~ 0UL ) / sizeof ( * image -> colormap ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" )"}
{"source": "CWE-119 static Bigint * Balloc ( int k ) { int x ; <S2SV_StartBug> Bigint * rv ; <S2SV_EndBug> _THREAD_PRIVATE_MUTEX_LOCK ( dtoa_mutex ) ; if ( ( rv = freelist [ k ] ) ) { freelist [ k ] = rv -> next ; } else { x = 1 << k ; rv = ( Bigint * ) MALLOC ( sizeof ( Bigint ) + ( x - 1 ) * sizeof ( Long ) ) ; <S2SV_StartBug> rv -> k = k ; <S2SV_EndBug> rv -> maxwds = x ; } _THREAD_PRIVATE_MUTEX_UNLOCK ( dtoa_mutex ) ; rv -> sign = rv -> wds = 0 ; return rv ; }", "target": "<S2SV_ModStart> * rv ; if ( k > Kmax ) { zend_error ( E_ERROR , \"Balloc()<S2SV_blank>allocation<S2SV_blank>exceeds<S2SV_blank>list<S2SV_blank>boundary\" ) ; } <S2SV_ModStart> ) ) ; if ( ! rv ) { _THREAD_PRIVATE_MUTEX_UNLOCK ( dtoa_mutex ) ; zend_error ( E_ERROR , \"Balloc()<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\" ) ; }"}
{"source": "CWE-787 search_impl ( i_ctx_t * i_ctx_p , bool forward ) { os_ptr op = osp ; os_ptr op1 = op - 1 ; uint size = r_size ( op ) ; uint count ; byte * pat ; byte * ptr ; byte ch ; int incr = forward ? 1 : - 1 ; check_read_type ( * op1 , t_string ) ; check_read_type ( * op , t_string ) ; if ( size > r_size ( op1 ) ) { make_false ( op ) ; return 0 ; } count = r_size ( op1 ) - size ; ptr = op1 -> value . bytes ; if ( size == 0 ) goto found ; if ( ! forward ) ptr += count ; pat = op -> value . bytes ; ch = pat [ 0 ] ; do { if ( * ptr == ch && ( size == 1 || ! memcmp ( ptr , pat , size ) ) ) goto found ; ptr += incr ; } while ( count -- ) ; make_false ( op ) ; return 0 ; found : op -> tas . type_attrs = op1 -> tas . type_attrs ; op -> value . bytes = ptr ; <S2SV_StartBug> r_set_size ( op , size ) ; <S2SV_EndBug> push ( 2 ) ; op [ - 1 ] = * op1 ; <S2SV_StartBug> r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; <S2SV_EndBug> op1 -> value . bytes = ptr + size ; <S2SV_StartBug> r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; <S2SV_EndBug> make_true ( op ) ; return 0 ; }", "target": "<S2SV_ModStart> = ptr ; op -> tas . rsize = size <S2SV_ModEnd> ; push ( <S2SV_ModStart> * op1 ; op [ - 3 ] . <S2SV_ModEnd> value . bytes <S2SV_ModStart> + size ; if ( forward ) { op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ; op [ - 3 ] . tas . rsize = count ; } else { op [ - 1 ] . tas . rsize = count ; op [ - 3 ] . tas . rsize -= count + size ; } <S2SV_ModEnd> make_true ( op"}
{"source": "CWE-787 int esp_output_head ( struct xfrm_state * x , struct sk_buff * skb , struct esp_info * esp ) { u8 * tail ; int nfrags ; int esph_offset ; struct page * page ; struct sk_buff * trailer ; <S2SV_StartBug> int tailen = esp -> tailen ; <S2SV_EndBug> if ( x -> encap ) { int err = esp_output_encap ( x , skb , esp ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> if ( ! skb_cloned ( skb ) ) { <S2SV_EndBug> if ( tailen <= skb_tailroom ( skb ) ) { nfrags = 1 ; trailer = skb ; tail = skb_tail_pointer ( trailer ) ; goto skip_cow ; } else if ( ( skb_shinfo ( skb ) -> nr_frags < MAX_SKB_FRAGS ) && ! skb_has_frag_list ( skb ) ) { int allocsize ; struct sock * sk = skb -> sk ; struct page_frag * pfrag = & x -> xfrag ; esp -> inplace = false ; allocsize = ALIGN ( tailen , L1_CACHE_BYTES ) ; spin_lock_bh ( & x -> lock ) ; if ( unlikely ( ! skb_page_frag_refill ( allocsize , pfrag , GFP_ATOMIC ) ) ) { spin_unlock_bh ( & x -> lock ) ; goto cow ; } page = pfrag -> page ; get_page ( page ) ; tail = page_address ( page ) + pfrag -> offset ; esp_output_fill_trailer ( tail , esp -> tfclen , esp -> plen , esp -> proto ) ; nfrags = skb_shinfo ( skb ) -> nr_frags ; __skb_fill_page_desc ( skb , nfrags , page , pfrag -> offset , tailen ) ; skb_shinfo ( skb ) -> nr_frags = ++ nfrags ; pfrag -> offset = pfrag -> offset + allocsize ; spin_unlock_bh ( & x -> lock ) ; nfrags ++ ; skb -> len += tailen ; skb -> data_len += tailen ; skb -> truesize += tailen ; if ( sk && sk_fullsock ( sk ) ) refcount_add ( tailen , & sk -> sk_wmem_alloc ) ; goto out ; } } cow : esph_offset = ( unsigned char * ) esp -> esph - skb_transport_header ( skb ) ; nfrags = skb_cow_data ( skb , tailen , & trailer ) ; if ( nfrags < 0 ) goto out ; tail = skb_tail_pointer ( trailer ) ; esp -> esph = ( struct ip_esp_hdr * ) ( skb_transport_header ( skb ) + esph_offset ) ; skip_cow : esp_output_fill_trailer ( tail , esp -> tfclen , esp -> plen , esp -> proto ) ; pskb_put ( skb , trailer , tailen ) ; out : return nfrags ; }", "target": "<S2SV_ModStart> esp -> tailen ; unsigned int allocsz <S2SV_ModStart> err ; } allocsz = ALIGN ( skb -> data_len + tailen , L1_CACHE_BYTES ) ; if ( allocsz > ESP_SKB_FRAG_MAXSIZE ) goto cow ;"}
{"source": "CWE-787 int esp6_output_head ( struct xfrm_state * x , struct sk_buff * skb , struct esp_info * esp ) { u8 * tail ; int nfrags ; int esph_offset ; struct page * page ; struct sk_buff * trailer ; <S2SV_StartBug> int tailen = esp -> tailen ; <S2SV_EndBug> if ( x -> encap ) { int err = esp6_output_encap ( x , skb , esp ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> if ( ! skb_cloned ( skb ) ) { <S2SV_EndBug> if ( tailen <= skb_tailroom ( skb ) ) { nfrags = 1 ; trailer = skb ; tail = skb_tail_pointer ( trailer ) ; goto skip_cow ; } else if ( ( skb_shinfo ( skb ) -> nr_frags < MAX_SKB_FRAGS ) && ! skb_has_frag_list ( skb ) ) { int allocsize ; struct sock * sk = skb -> sk ; struct page_frag * pfrag = & x -> xfrag ; esp -> inplace = false ; allocsize = ALIGN ( tailen , L1_CACHE_BYTES ) ; spin_lock_bh ( & x -> lock ) ; if ( unlikely ( ! skb_page_frag_refill ( allocsize , pfrag , GFP_ATOMIC ) ) ) { spin_unlock_bh ( & x -> lock ) ; goto cow ; } page = pfrag -> page ; get_page ( page ) ; tail = page_address ( page ) + pfrag -> offset ; esp_output_fill_trailer ( tail , esp -> tfclen , esp -> plen , esp -> proto ) ; nfrags = skb_shinfo ( skb ) -> nr_frags ; __skb_fill_page_desc ( skb , nfrags , page , pfrag -> offset , tailen ) ; skb_shinfo ( skb ) -> nr_frags = ++ nfrags ; pfrag -> offset = pfrag -> offset + allocsize ; spin_unlock_bh ( & x -> lock ) ; nfrags ++ ; skb -> len += tailen ; skb -> data_len += tailen ; skb -> truesize += tailen ; if ( sk && sk_fullsock ( sk ) ) refcount_add ( tailen , & sk -> sk_wmem_alloc ) ; goto out ; } } cow : esph_offset = ( unsigned char * ) esp -> esph - skb_transport_header ( skb ) ; nfrags = skb_cow_data ( skb , tailen , & trailer ) ; if ( nfrags < 0 ) goto out ; tail = skb_tail_pointer ( trailer ) ; esp -> esph = ( struct ip_esp_hdr * ) ( skb_transport_header ( skb ) + esph_offset ) ; skip_cow : esp_output_fill_trailer ( tail , esp -> tfclen , esp -> plen , esp -> proto ) ; pskb_put ( skb , trailer , tailen ) ; out : return nfrags ; }", "target": "<S2SV_ModStart> esp -> tailen ; unsigned int allocsz <S2SV_ModStart> err ; } allocsz = ALIGN ( skb -> data_len + tailen , L1_CACHE_BYTES ) ; if ( allocsz > ESP_SKB_FRAG_MAXSIZE ) goto cow ;"}
{"source": "CWE-434 void dostor ( char * name , const int append , const int autorename ) { ULHandler ulhandler ; int f ; const char * ul_name = NULL ; const char * atomic_file = NULL ; off_t filesize = ( off_t ) 0U ; struct stat st ; double started = 0.0 ; signed char overwrite = 0 ; int overflow = 0 ; int ret = - 1 ; off_t max_filesize = ( off_t ) - 1 ; # ifdef QUOTAS Quota quota ; # endif const char * name2 = NULL ; if ( type < 1 || ( type == 1 && restartat > ( off_t ) 1 ) ) { addreply_noformat ( 503 , MSG_NO_ASCII_RESUME ) ; goto end ; } # ifndef ANON_CAN_RESUME if ( guest != 0 && anon_noupload != 0 ) { addreply_noformat ( 550 , MSG_ANON_CANT_OVERWRITE ) ; goto end ; } # endif if ( ul_check_free_space ( name , - 1.0 ) == 0 ) { addreply_noformat ( 552 , MSG_NO_DISK_SPACE ) ; goto end ; } if ( checknamesanity ( name , dot_write_ok ) != 0 ) { addreply ( 553 , MSG_SANITY_FILE_FAILURE , name ) ; goto end ; } if ( autorename != 0 ) { no_truncate = 1 ; } if ( restartat > ( off_t ) 0 || no_truncate != 0 ) { if ( ( atomic_file = get_atomic_file ( name ) ) == NULL ) { addreply ( 553 , MSG_SANITY_FILE_FAILURE , name ) ; goto end ; } if ( restartat > ( off_t ) 0 && rename ( name , atomic_file ) != 0 && errno != ENOENT ) { error ( 553 , MSG_RENAME_FAILURE ) ; atomic_file = NULL ; goto end ; } } if ( atomic_file != NULL ) { ul_name = atomic_file ; } else { ul_name = name ; } if ( atomic_file == NULL && ( f = open ( ul_name , O_WRONLY | O_NOFOLLOW ) ) != - 1 ) { overwrite ++ ; } else if ( ( f = open ( ul_name , O_CREAT | O_WRONLY | O_NOFOLLOW , ( mode_t ) 0777 & ~ u_mask ) ) == - 1 ) { error ( 553 , MSG_OPEN_FAILURE2 ) ; goto end ; } if ( fstat ( f , & st ) < 0 ) { ( void ) close ( f ) ; error ( 553 , MSG_STAT_FAILURE2 ) ; goto end ; } if ( ! S_ISREG ( st . st_mode ) ) { ( void ) close ( f ) ; addreply_noformat ( 550 , MSG_NOT_REGULAR_FILE ) ; goto end ; } alarm ( MAX_SESSION_XFER_IDLE ) ; if ( st . st_size > ( off_t ) 0 ) { # ifndef ANON_CAN_RESUME if ( guest != 0 ) { addreply_noformat ( 550 , MSG_ANON_CANT_OVERWRITE ) ; ( void ) close ( f ) ; goto end ; } # endif if ( append != 0 ) { restartat = st . st_size ; } } else { restartat = ( off_t ) 0 ; } if ( restartat > st . st_size ) { restartat = st . st_size ; } if ( restartat > ( off_t ) 0 && lseek ( f , restartat , SEEK_SET ) < ( off_t ) 0 ) { ( void ) close ( f ) ; error ( 451 , \"seek\" ) ; goto end ; } if ( restartat < st . st_size ) { if ( ftruncate ( f , restartat ) < 0 ) { ( void ) close ( f ) ; error ( 451 , \"ftruncate\" ) ; goto end ; } # ifdef QUOTAS if ( restartat != st . st_size ) { ( void ) quota_update ( NULL , 0LL , ( long long ) ( restartat - st . st_size ) , & overflow ) ; } # endif } # ifdef QUOTAS if ( quota_update ( & quota , 0LL , 0LL , & overflow ) == 0 && ( overflow > 0 || quota . files >= user_quota_files || quota . size > user_quota_size || <S2SV_StartBug> ( max_filesize >= ( off_t ) 0 && <S2SV_EndBug> <S2SV_StartBug> ( max_filesize = user_quota_size - quota . size ) < ( off_t ) 0 ) ) ) { <S2SV_EndBug> overflow = 1 ; ( void ) close ( f ) ; goto afterquota ; } # endif opendata ( ) ; if ( xferfd == - 1 ) { ( void ) close ( f ) ; goto end ; } doreply ( ) ; # ifdef WITH_TLS if ( data_protection_level == CPL_PRIVATE ) { tls_init_data_session ( xferfd , passive ) ; } # endif state_needs_update = 1 ; setprocessname ( \"pure-ftpd<S2SV_blank>(UPLOAD)\" ) ; filesize = restartat ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { const size_t sl = strlen ( name ) ; ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_UPLOAD ; shm_data_cur -> download_total_size = ( off_t ) 0U ; shm_data_cur -> download_current_size = ( off_t ) filesize ; shm_data_cur -> restartat = restartat ; ( void ) time ( & shm_data_cur -> xfer_date ) ; if ( sl < sizeof shm_data_cur -> filename ) { memcpy ( shm_data_cur -> filename , name , sl ) ; shm_data_cur -> filename [ sl ] = 0 ; } else { memcpy ( shm_data_cur -> filename , & name [ sl - sizeof shm_data_cur -> filename - 1U ] , sizeof shm_data_cur -> filename ) ; } ftpwho_unlock ( ) ; } # endif started = get_usec_time ( ) ; if ( ul_init ( & ulhandler , clientfd , tls_cnx , xferfd , name , f , tls_data_cnx , restartat , type == 1 , throttling_bandwidth_ul , max_filesize ) == 0 ) { ret = ul_send ( & ulhandler ) ; ul_exit ( & ulhandler ) ; } else { ret = - 1 ; } ( void ) close ( f ) ; closedata ( ) ; # ifdef SHOW_REAL_DISK_SPACE if ( FSTATFS ( f , & statfsbuf ) == 0 ) { double space ; space = ( double ) STATFS_BAVAIL ( statfsbuf ) * ( double ) STATFS_FRSIZE ( statfsbuf ) ; if ( space > 524288.0 ) { addreply ( 0 , MSG_SPACE_FREE_M , space / 1048576.0 ) ; } else { addreply ( 0 , MSG_SPACE_FREE_K , space / 1024.0 ) ; } } # endif uploaded += ( unsigned long long ) ulhandler . total_uploaded ; { off_t atomic_file_size ; off_t original_file_size ; int files_count ; if ( overwrite == 0 ) { files_count = 1 ; } else { files_count = 0 ; } if ( autorename != 0 && restartat == ( off_t ) 0 ) { if ( ( atomic_file_size = get_file_size ( atomic_file ) ) < ( off_t ) 0 ) { goto afterquota ; } if ( tryautorename ( atomic_file , name , & name2 ) != 0 ) { error ( 553 , MSG_RENAME_FAILURE ) ; goto afterquota ; } else { # ifdef QUOTAS ul_quota_update ( name2 ? name2 : name , 1 , atomic_file_size ) ; # endif atomic_file = NULL ; } } else if ( atomic_file != NULL ) { if ( ( atomic_file_size = get_file_size ( atomic_file ) ) < ( off_t ) 0 ) { goto afterquota ; } if ( ( original_file_size = get_file_size ( name ) ) < ( off_t ) 0 || restartat > original_file_size ) { original_file_size = restartat ; } if ( rename ( atomic_file , name ) != 0 ) { error ( 553 , MSG_RENAME_FAILURE ) ; goto afterquota ; } else { # ifdef QUOTAS overflow = ul_quota_update ( name , files_count , atomic_file_size - original_file_size ) ; # endif atomic_file = NULL ; } } else { # ifdef QUOTAS overflow = ul_quota_update ( name , files_count , ulhandler . total_uploaded ) ; # endif } } afterquota : if ( overflow > 0 ) { addreply ( 552 , MSG_QUOTA_EXCEEDED , name ) ; } else { if ( ret == 0 ) { addreply_noformat ( 226 , MSG_TRANSFER_SUCCESSFUL ) ; } else { addreply_noformat ( 451 , MSG_ABORTED ) ; } displayrate ( MSG_UPLOADED , ulhandler . total_uploaded , started , name2 ? name2 : name , 1 ) ; } end : restartat = ( off_t ) 0 ; if ( atomic_file != NULL ) { unlink ( atomic_file ) ; atomic_file = NULL ; } }", "target": "<S2SV_ModStart> || ( max_filesize <S2SV_ModEnd> = user_quota_size - <S2SV_ModStart> off_t ) 0 <S2SV_ModEnd> ) ) {"}
{"source": "CWE-787 l_noret luaG_runerror ( lua_State * L , const char * fmt , ... ) { CallInfo * ci = L -> ci ; const char * msg ; va_list argp ; luaC_checkGC ( L ) ; va_start ( argp , fmt ) ; msg = luaO_pushvfstring ( L , fmt , argp ) ; va_end ( argp ) ; <S2SV_StartBug> if ( isLua ( ci ) ) <S2SV_EndBug> luaG_addinfo ( L , msg , ci_func ( ci ) -> p -> source , getcurrentline ( ci ) ) ; <S2SV_StartBug> luaG_errormsg ( L ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ci ) ) { <S2SV_ModStart> ) ) ; setobjs2s ( L , L -> top - 2 , L -> top - 1 ) ; L -> top -- ; }"}
{"source": "CWE-703 pxa3xx_gcu_write ( struct file * file , const char * buff , size_t count , loff_t * offp ) { int ret ; unsigned long flags ; struct pxa3xx_gcu_batch * buffer ; struct pxa3xx_gcu_priv * priv = to_pxa3xx_gcu_priv ( file ) ; <S2SV_StartBug> int words = count / 4 ; <S2SV_EndBug> priv -> shared -> num_writes ++ ; priv -> shared -> num_words += words ; if ( words >= PXA3XX_GCU_BATCH_WORDS ) return - E2BIG ; if ( ! priv -> free ) { ret = pxa3xx_gcu_wait_free ( priv ) ; if ( ret < 0 ) return ret ; } spin_lock_irqsave ( & priv -> spinlock , flags ) ; buffer = priv -> free ; priv -> free = buffer -> next ; spin_unlock_irqrestore ( & priv -> spinlock , flags ) ; ret = copy_from_user ( buffer -> ptr , buff , words * 4 ) ; if ( ret ) { spin_lock_irqsave ( & priv -> spinlock , flags ) ; buffer -> next = priv -> free ; priv -> free = buffer ; spin_unlock_irqrestore ( & priv -> spinlock , flags ) ; return - EFAULT ; } buffer -> length = words ; buffer -> ptr [ words ] = 0x01000000 ; spin_lock_irqsave ( & priv -> spinlock , flags ) ; buffer -> next = NULL ; if ( priv -> ready ) { BUG_ON ( priv -> ready_last == NULL ) ; priv -> ready_last -> next = buffer ; } else priv -> ready = buffer ; priv -> ready_last = buffer ; if ( ! priv -> shared -> hw_running ) run_ready ( priv ) ; spin_unlock_irqrestore ( & priv -> spinlock , flags ) ; return words * 4 ; }", "target": "<S2SV_ModStart> file ) ; size_t <S2SV_ModEnd> words = count"}
{"source": "CWE-703 get_one_sourceline ( source_cookie_T * sp ) { garray_T ga ; int len ; int c ; char_u * buf ; # ifdef USE_CRNL int has_cr ; # endif int have_read = FALSE ; ga_init2 ( & ga , 1 , 250 ) ; ++ sp -> sourcing_lnum ; for ( ; ; ) { if ( ga_grow ( & ga , 120 ) == FAIL ) break ; if ( sp -> source_from_buf ) { if ( sp -> buf_lnum >= sp -> buflines . ga_len ) break ; ga_concat ( & ga , ( ( char_u * * ) sp -> buflines . ga_data ) [ sp -> buf_lnum ] ) ; sp -> buf_lnum ++ ; if ( ga_grow ( & ga , 1 ) == FAIL ) break ; buf = ( char_u * ) ga . ga_data ; buf [ ga . ga_len ++ ] = NUL ; <S2SV_StartBug> } <S2SV_EndBug> else { buf = ( char_u * ) ga . ga_data ; if ( fgets ( ( char * ) buf + ga . ga_len , ga . ga_maxlen - ga . ga_len , sp -> fp ) == NULL ) break ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> len = ga . ga_len + ( int ) STRLEN ( buf + ga . ga_len ) ; <S2SV_EndBug> # ifdef USE_CRNL if ( ( len == 1 || ( len >= 2 && buf [ len - 2 ] == '\\\\n' ) ) && sp -> fileformat == EOL_DOS && buf [ len - 1 ] == Ctrl_Z ) { buf [ len - 1 ] = NUL ; break ; } # endif have_read = TRUE ; ga . ga_len = len ; if ( ga . ga_maxlen - ga . ga_len == 1 && buf [ len - 1 ] != '\\\\n' ) continue ; if ( len >= 1 && buf [ len - 1 ] == '\\\\n' ) { # ifdef USE_CRNL has_cr = ( len >= 2 && buf [ len - 2 ] == '\\\\r' ) ; if ( sp -> fileformat == EOL_UNKNOWN ) { if ( has_cr ) sp -> fileformat = EOL_DOS ; else sp -> fileformat = EOL_UNIX ; } if ( sp -> fileformat == EOL_DOS ) { if ( has_cr ) { buf [ len - 2 ] = '\\\\n' ; -- len ; -- ga . ga_len ; } else { if ( ! sp -> error ) { msg_source ( HL_ATTR ( HLF_W ) ) ; emsg ( _ ( \"W15:<S2SV_blank>Warning:<S2SV_blank>Wrong<S2SV_blank>line<S2SV_blank>separator,<S2SV_blank>^M<S2SV_blank>may<S2SV_blank>be<S2SV_blank>missing\" ) ) ; } sp -> error = TRUE ; sp -> fileformat = EOL_UNIX ; } } # endif for ( c = len - 2 ; c >= 0 && buf [ c ] == Ctrl_V ; c -- ) ; if ( ( len & 1 ) != ( c & 1 ) ) { ++ sp -> sourcing_lnum ; continue ; } buf [ len - 1 ] = NUL ; } line_breakcheck ( ) ; break ; } if ( have_read ) return ( char_u * ) ga . ga_data ; vim_free ( ga . ga_data ) ; return NULL ; }", "target": "<S2SV_ModStart> = NUL ; len = ga . ga_len ; <S2SV_ModStart> ) break ; <S2SV_ModEnd> len = ga <S2SV_ModStart> ga_len ) ; }"}
{"source": "CWE-200 static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { <S2SV_StartBug> squashfs_dir_header_2 dirh ; <S2SV_EndBug> <S2SV_StartBug> char buffer [ sizeof ( squashfs_dir_entry_2 ) + SQUASHFS_NAME_LEN + 1 ] <S2SV_EndBug> __attribute__ ( ( aligned ) ) ; <S2SV_StartBug> squashfs_dir_entry_2 * dire = ( squashfs_dir_entry_2 * ) buffer ; <S2SV_EndBug> long long start ; int bytes = 0 ; int dir_count , size , res ; struct dir_ent * ent , * cur_ent = NULL ; struct dir * dir ; TRACE ( \"squashfs_opendir:<S2SV_blank>inode<S2SV_blank>start<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>offset<S2SV_blank>%d\\\\n\" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) MEM_ERROR ( ) ; dir -> dir_count = 0 ; dir -> cur_entry = NULL ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; <S2SV_StartBug> if ( ( * i ) -> data == 0 ) <S2SV_EndBug> return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; offset = ( * i ) -> offset ; <S2SV_StartBug> size = ( * i ) -> data + bytes ; <S2SV_EndBug> while ( bytes < size ) { if ( swap ) { <S2SV_StartBug> squashfs_dir_header_2 sdirh ; <S2SV_EndBug> res = read_directory_data ( & sdirh , & start , & offset , sizeof ( sdirh ) ) ; if ( res ) <S2SV_StartBug> SQUASHFS_SWAP_DIR_HEADER_2 ( & dirh , & sdirh ) ; <S2SV_EndBug> } else res = read_directory_data ( & dirh , & start , & offset , sizeof ( dirh ) ) ; if ( res == FALSE ) goto corrupted ; dir_count = dirh . count + 1 ; TRACE ( \"squashfs_opendir:<S2SV_blank>Read<S2SV_blank>directory<S2SV_blank>header<S2SV_blank>@<S2SV_blank>byte<S2SV_blank>position<S2SV_blank>\" \"%d,<S2SV_blank>%d<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>directory\\\\n\" ) ; goto corrupted ; } while ( dir_count -- ) { if ( swap ) { <S2SV_StartBug> squashfs_dir_entry_2 sdire ; <S2SV_EndBug> res = read_directory_data ( & sdire , & start , & offset , sizeof ( sdire ) ) ; if ( res ) <S2SV_StartBug> SQUASHFS_SWAP_DIR_ENTRY_2 ( dire , & sdire ) ; <S2SV_EndBug> } else res = read_directory_data ( dire , & start , & offset , sizeof ( * dire ) ) ; if ( res == FALSE ) goto corrupted ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long\\\\n\" ) ; goto corrupted ; } res = read_directory_data ( dire -> name , & start , & offset , dire -> size + 1 ) ; if ( res == FALSE ) goto corrupted ; dire -> name [ dire -> size + 1 ] = '\\\\0' ; if ( check_name ( dire -> name , dire -> size + 1 ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>invalid<S2SV_blank>characters<S2SV_blank>in<S2SV_blank>name\\\\n\" ) ; goto corrupted ; } TRACE ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>entry<S2SV_blank>%s,<S2SV_blank>inode<S2SV_blank>\" \"%d:%d,<S2SV_blank>type<S2SV_blank>%d\\\\n\" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; ent = malloc ( sizeof ( struct dir_ent ) ) ; if ( ent == NULL ) MEM_ERROR ( ) ; ent -> name = strdup ( dire -> name ) ; ent -> start_block = dirh . start_block ; ent -> offset = dire -> offset ; ent -> type = dire -> type ; ent -> next = NULL ; if ( cur_ent == NULL ) dir -> dirs = ent ; else cur_ent -> next = ent ; cur_ent = ent ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } <S2SV_StartBug> return dir ; <S2SV_EndBug> corrupted : squashfs_closedir ( dir ) ; return NULL ; }", "target": "<S2SV_ModStart> i ) { squashfs_dir_header_3 <S2SV_ModEnd> dirh ; char <S2SV_ModStart> [ sizeof ( squashfs_dir_entry_3 <S2SV_ModEnd> ) + SQUASHFS_NAME_LEN <S2SV_ModStart> ) ) ; squashfs_dir_entry_3 * dire = ( squashfs_dir_entry_3 <S2SV_ModEnd> * ) buffer <S2SV_ModStart> -> data == 3 <S2SV_ModEnd> ) return dir <S2SV_ModStart> data + bytes - 3 <S2SV_ModStart> swap ) { squashfs_dir_header_3 <S2SV_ModEnd> sdirh ; res <S2SV_ModStart> ( res ) SQUASHFS_SWAP_DIR_HEADER_3 <S2SV_ModEnd> ( & dirh <S2SV_ModStart> swap ) { squashfs_dir_entry_3 <S2SV_ModEnd> sdire ; res <S2SV_ModStart> ( res ) SQUASHFS_SWAP_DIR_ENTRY_3 <S2SV_ModEnd> ( dire , <S2SV_ModStart> ; } } if ( check_directory ( dir ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>directory<S2SV_blank>has<S2SV_blank>duplicate<S2SV_blank>names<S2SV_blank>or<S2SV_blank>is<S2SV_blank>unsorted\\\\n\" ) ; goto corrupted ; }"}
{"source": "CWE-200 static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { squashfs_dir_header_3 dirh ; char buffer [ sizeof ( squashfs_dir_entry_3 ) + SQUASHFS_NAME_LEN + 1 ] __attribute__ ( ( aligned ) ) ; squashfs_dir_entry_3 * dire = ( squashfs_dir_entry_3 * ) buffer ; long long start ; int bytes = 0 ; int dir_count , size , res ; struct dir_ent * ent , * cur_ent = NULL ; struct dir * dir ; TRACE ( \"squashfs_opendir:<S2SV_blank>inode<S2SV_blank>start<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>offset<S2SV_blank>%d\\\\n\" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) MEM_ERROR ( ) ; dir -> dir_count = 0 ; dir -> cur_entry = NULL ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; if ( ( * i ) -> data == 3 ) return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; offset = ( * i ) -> offset ; size = ( * i ) -> data + bytes - 3 ; while ( bytes < size ) { if ( swap ) { squashfs_dir_header_3 sdirh ; res = read_directory_data ( & sdirh , & start , & offset , sizeof ( sdirh ) ) ; if ( res ) SQUASHFS_SWAP_DIR_HEADER_3 ( & dirh , & sdirh ) ; } else res = read_directory_data ( & dirh , & start , & offset , sizeof ( dirh ) ) ; if ( res == FALSE ) goto corrupted ; dir_count = dirh . count + 1 ; TRACE ( \"squashfs_opendir:<S2SV_blank>Read<S2SV_blank>directory<S2SV_blank>header<S2SV_blank>@<S2SV_blank>byte<S2SV_blank>position<S2SV_blank>\" \"%d,<S2SV_blank>%d<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>directory\\\\n\" ) ; goto corrupted ; } while ( dir_count -- ) { if ( swap ) { squashfs_dir_entry_3 sdire ; res = read_directory_data ( & sdire , & start , & offset , sizeof ( sdire ) ) ; if ( res ) SQUASHFS_SWAP_DIR_ENTRY_3 ( dire , & sdire ) ; } else res = read_directory_data ( dire , & start , & offset , sizeof ( * dire ) ) ; if ( res == FALSE ) goto corrupted ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long\\\\n\" ) ; goto corrupted ; } res = read_directory_data ( dire -> name , & start , & offset , dire -> size + 1 ) ; if ( res == FALSE ) goto corrupted ; dire -> name [ dire -> size + 1 ] = '\\\\0' ; if ( check_name ( dire -> name , dire -> size + 1 ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>invalid<S2SV_blank>characters<S2SV_blank>in<S2SV_blank>name\\\\n\" ) ; goto corrupted ; } TRACE ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>entry<S2SV_blank>%s,<S2SV_blank>inode<S2SV_blank>\" \"%d:%d,<S2SV_blank>type<S2SV_blank>%d\\\\n\" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; ent = malloc ( sizeof ( struct dir_ent ) ) ; if ( ent == NULL ) MEM_ERROR ( ) ; ent -> name = strdup ( dire -> name ) ; ent -> start_block = dirh . start_block ; ent -> offset = dire -> offset ; ent -> type = dire -> type ; ent -> next = NULL ; if ( cur_ent == NULL ) dir -> dirs = ent ; else cur_ent -> next = ent ; cur_ent = ent ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } <S2SV_StartBug> return dir ; <S2SV_EndBug> corrupted : squashfs_closedir ( dir ) ; return NULL ; }", "target": "<S2SV_ModStart> ; } } if ( check_directory ( dir ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>directory<S2SV_blank>has<S2SV_blank>duplicate<S2SV_blank>names<S2SV_blank>or<S2SV_blank>is<S2SV_blank>unsorted\\\\n\" ) ; goto corrupted ; }"}
{"source": "CWE-200 static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { struct squashfs_dir_header dirh ; char buffer [ sizeof ( struct squashfs_dir_entry ) + SQUASHFS_NAME_LEN + 1 ] __attribute__ ( ( aligned ) ) ; struct squashfs_dir_entry * dire = ( struct squashfs_dir_entry * ) buffer ; long long start ; int bytes = 0 , dir_count , size , res ; struct dir_ent * ent , * cur_ent = NULL ; struct dir * dir ; TRACE ( \"squashfs_opendir:<S2SV_blank>inode<S2SV_blank>start<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>offset<S2SV_blank>%d\\\\n\" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) MEM_ERROR ( ) ; dir -> dir_count = 0 ; dir -> cur_entry = NULL ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; if ( ( * i ) -> data == 3 ) return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; offset = ( * i ) -> offset ; size = ( * i ) -> data + bytes - 3 ; while ( bytes < size ) { res = read_directory_data ( & dirh , & start , & offset , sizeof ( dirh ) ) ; if ( res == FALSE ) goto corrupted ; SQUASHFS_INSWAP_DIR_HEADER ( & dirh ) ; dir_count = dirh . count + 1 ; TRACE ( \"squashfs_opendir:<S2SV_blank>Read<S2SV_blank>directory<S2SV_blank>header<S2SV_blank>@<S2SV_blank>byte<S2SV_blank>position<S2SV_blank>\" \"%d,<S2SV_blank>%d<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>directory\\\\n\" ) ; goto corrupted ; } while ( dir_count -- ) { res = read_directory_data ( dire , & start , & offset , sizeof ( * dire ) ) ; if ( res == FALSE ) goto corrupted ; SQUASHFS_INSWAP_DIR_ENTRY ( dire ) ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long\\\\n\" ) ; goto corrupted ; } res = read_directory_data ( dire -> name , & start , & offset , dire -> size + 1 ) ; if ( res == FALSE ) goto corrupted ; dire -> name [ dire -> size + 1 ] = '\\\\0' ; if ( check_name ( dire -> name , dire -> size + 1 ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>invalid<S2SV_blank>characters<S2SV_blank>in<S2SV_blank>name\\\\n\" ) ; goto corrupted ; } TRACE ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>entry<S2SV_blank>%s,<S2SV_blank>inode<S2SV_blank>\" \"%d:%d,<S2SV_blank>type<S2SV_blank>%d\\\\n\" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; ent = malloc ( sizeof ( struct dir_ent ) ) ; if ( ent == NULL ) MEM_ERROR ( ) ; ent -> name = strdup ( dire -> name ) ; ent -> start_block = dirh . start_block ; ent -> offset = dire -> offset ; ent -> type = dire -> type ; ent -> next = NULL ; if ( cur_ent == NULL ) dir -> dirs = ent ; else cur_ent -> next = ent ; cur_ent = ent ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } <S2SV_StartBug> return dir ; <S2SV_EndBug> corrupted : squashfs_closedir ( dir ) ; return NULL ; }", "target": "<S2SV_ModStart> ; } } if ( check_directory ( dir ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>directory<S2SV_blank>has<S2SV_blank>duplicate<S2SV_blank>names<S2SV_blank>or<S2SV_blank>is<S2SV_blank>unsorted\\\\n\" ) ; goto corrupted ; }"}
{"source": "CWE-772 static void virtbt_rx_handle ( struct virtio_bluetooth * vbt , struct sk_buff * skb ) { __u8 pkt_type ; pkt_type = * ( ( __u8 * ) skb -> data ) ; skb_pull ( skb , 1 ) ; switch ( pkt_type ) { case HCI_EVENT_PKT : case HCI_ACLDATA_PKT : case HCI_SCODATA_PKT : case HCI_ISODATA_PKT : hci_skb_pkt_type ( skb ) = pkt_type ; hci_recv_frame ( vbt -> hdev , skb ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> }", "target": "<S2SV_ModStart> ; break ; default : kfree_skb ( skb ) ; break ;"}
{"source": "CWE-787 int hw_atl_utils_fw_rpc_wait ( struct aq_hw_s * self , struct hw_atl_utils_fw_rpc * * rpc ) { struct aq_hw_atl_utils_fw_rpc_tid_s sw ; struct aq_hw_atl_utils_fw_rpc_tid_s fw ; int err = 0 ; do { sw . val = aq_hw_read_reg ( self , HW_ATL_RPC_CONTROL_ADR ) ; self -> rpc_tid = sw . tid ; err = readx_poll_timeout_atomic ( hw_atl_utils_rpc_state_get , self , fw . val , sw . tid == fw . tid , 1000U , 100000U ) ; if ( err < 0 ) goto err_exit ; err = aq_hw_err_from_flags ( self ) ; if ( err < 0 ) goto err_exit ; <S2SV_StartBug> if ( fw . len == 0xFFFFU ) { <S2SV_EndBug> err = hw_atl_utils_fw_rpc_call ( self , sw . len ) ; if ( err < 0 ) goto err_exit ; } } while ( sw . tid != fw . tid || 0xFFFFU == fw . len ) ; if ( rpc ) { if ( fw . len ) { <S2SV_StartBug> err = <S2SV_EndBug> hw_atl_utils_fw_downld_dwords ( self , self -> rpc_addr , ( u32 * ) ( void * ) & self -> rpc , ( fw . len + sizeof ( u32 ) - sizeof ( u8 ) ) / sizeof ( u32 ) ) ; if ( err < 0 ) goto err_exit ; } * rpc = & self -> rpc ; } err_exit : return err ; }", "target": "<S2SV_ModStart> 0xFFFFU ) { if ( sw . len > sizeof ( self -> rpc ) ) { printk ( KERN_INFO \"Invalid<S2SV_blank>sw<S2SV_blank>len:<S2SV_blank>%x\\\\n\" , sw . len ) ; err = - EINVAL ; goto err_exit ; } <S2SV_ModStart> len ) { if ( fw . len > sizeof ( self -> rpc ) ) { printk ( KERN_INFO \"Invalid<S2SV_blank>fw<S2SV_blank>len:<S2SV_blank>%x\\\\n\" , fw . len ) ; err = - EINVAL ; goto err_exit ; }"}
{"source": "CWE-415 static char * * split ( const char * arg , const char * delim ) { char * copy = dupstr ( arg ) ; char * * result = NULL ; int i = 0 ; for ( char * cptr = strtok ( copy , delim ) ; cptr ; cptr = strtok ( NULL , delim ) ) { char * * tmp = realloc ( result , sizeof * result * ( i + 1 ) ) ; if ( ! tmp && result ) { while ( i > 0 ) { free ( result [ -- i ] ) ; } free ( result ) ; free ( copy ) ; return NULL ; } result = tmp ; result [ i ++ ] = dupstr ( cptr ) ; } free ( copy ) ; if ( i ) { char * * tmp = realloc ( result , sizeof * result * ( i + 1 ) ) ; if ( ! tmp ) { while ( i > 0 ) { free ( result [ -- i ] ) ; } free ( result ) ; <S2SV_StartBug> free ( copy ) ; <S2SV_EndBug> return NULL ; } result = tmp ; result [ i ++ ] = NULL ; } return result ; }", "target": "<S2SV_ModStart> result ) ; <S2SV_ModEnd> return NULL ;"}
{"source": "CWE-617 issuerAndThisUpdateCheck ( struct berval * in , struct berval * is , struct berval * tu , void * ctx ) { int numdquotes = 0 ; struct berval x = * in ; struct berval ni = BER_BVNULL ; enum { HAVE_NONE = 0x0 , HAVE_ISSUER = 0x1 , HAVE_THISUPDATE = 0x2 , HAVE_ALL = ( HAVE_ISSUER | HAVE_THISUPDATE ) } have = HAVE_NONE ; if ( in -> bv_len < STRLENOF ( \"{issuer<S2SV_blank>\\\\\"\\\\\",thisUpdate<S2SV_blank>\\\\\"YYMMDDhhmmssZ\\\\\"}\" ) ) return LDAP_INVALID_SYNTAX ; if ( in -> bv_val [ 0 ] != '{' || in -> bv_val [ in -> bv_len - 1 ] != '}' ) { return LDAP_INVALID_SYNTAX ; } x . bv_val ++ ; x . bv_len -= STRLENOF ( \"{}\" ) ; do { for ( ; ( x . bv_val [ 0 ] == '<S2SV_blank>' ) && x . bv_len ; x . bv_val ++ , x . bv_len -- ) { ; } if ( strncasecmp ( x . bv_val , \"issuer\" , STRLENOF ( \"issuer\" ) ) == 0 ) { if ( have & HAVE_ISSUER ) return LDAP_INVALID_SYNTAX ; x . bv_val += STRLENOF ( \"issuer\" ) ; x . bv_len -= STRLENOF ( \"issuer\" ) ; if ( x . bv_val [ 0 ] != '<S2SV_blank>' ) return LDAP_INVALID_SYNTAX ; x . bv_val ++ ; x . bv_len -- ; for ( ; ( x . bv_val [ 0 ] == '<S2SV_blank>' ) && x . bv_len ; x . bv_val ++ , x . bv_len -- ) { ; } if ( strncasecmp ( x . bv_val , \"rdnSequence:\" , STRLENOF ( \"rdnSequence:\" ) ) != 0 ) { return LDAP_INVALID_SYNTAX ; } x . bv_val += STRLENOF ( \"rdnSequence:\" ) ; x . bv_len -= STRLENOF ( \"rdnSequence:\" ) ; if ( x . bv_val [ 0 ] != \\'\"\\' ) return LDAP_INVALID_SYNTAX ; x . bv_val ++ ; x . bv_len -- ; is -> bv_val = x . bv_val ; is -> bv_len = 0 ; for ( ; is -> bv_len < x . bv_len ; ) { if ( is -> bv_val [ is -> bv_len ] != \\'\"\\' ) { is -> bv_len ++ ; continue ; } if ( is -> bv_val [ is -> bv_len + 1 ] == \\'\"\\' ) { numdquotes ++ ; is -> bv_len += 2 ; continue ; } break ; } x . bv_val += is -> bv_len + 1 ; x . bv_len -= is -> bv_len + 1 ; have |= HAVE_ISSUER ; } else if ( strncasecmp ( x . bv_val , \"thisUpdate\" , STRLENOF ( \"thisUpdate\" ) ) == 0 ) { if ( have & HAVE_THISUPDATE ) return LDAP_INVALID_SYNTAX ; x . bv_val += STRLENOF ( \"thisUpdate\" ) ; x . bv_len -= STRLENOF ( \"thisUpdate\" ) ; if ( x . bv_val [ 0 ] != '<S2SV_blank>' ) return LDAP_INVALID_SYNTAX ; x . bv_val ++ ; x . bv_len -- ; for ( ; ( x . bv_val [ 0 ] == '<S2SV_blank>' ) && x . bv_len ; x . bv_val ++ , x . bv_len -- ) { ; } if ( ! x . bv_len || x . bv_val [ 0 ] != \\'\"\\' ) return LDAP_INVALID_SYNTAX ; x . bv_val ++ ; x . bv_len -- ; tu -> bv_val = x . bv_val ; tu -> bv_len = 0 ; for ( ; tu -> bv_len < x . bv_len ; tu -> bv_len ++ ) { if ( tu -> bv_val [ tu -> bv_len ] == \\'\"\\' ) { break ; } } <S2SV_StartBug> x . bv_val += tu -> bv_len + 1 ; <S2SV_EndBug> x . bv_len -= tu -> bv_len + 1 ; have |= HAVE_THISUPDATE ; } else { return LDAP_INVALID_SYNTAX ; } for ( ; ( x . bv_val [ 0 ] == '<S2SV_blank>' ) && x . bv_len ; x . bv_val ++ , x . bv_len -- ) { ; } if ( have == HAVE_ALL ) { break ; } if ( x . bv_val [ 0 ] != ',' ) { return LDAP_INVALID_SYNTAX ; } x . bv_val ++ ; x . bv_len -- ; } while ( 1 ) ; if ( x . bv_len ) return LDAP_INVALID_SYNTAX ; if ( numdquotes == 0 ) { ber_dupbv_x ( & ni , is , ctx ) ; } else { ber_len_t src , dst ; ni . bv_len = is -> bv_len - numdquotes ; ni . bv_val = slap_sl_malloc ( ni . bv_len + 1 , ctx ) ; for ( src = 0 , dst = 0 ; src < is -> bv_len ; src ++ , dst ++ ) { if ( is -> bv_val [ src ] == \\'\"\\' ) { src ++ ; } ni . bv_val [ dst ] = is -> bv_val [ src ] ; } ni . bv_val [ dst ] = '\\\\0' ; } * is = ni ; return 0 ; }", "target": "<S2SV_ModStart> ; } } if ( tu -> bv_len < STRLENOF ( \"YYYYmmddHHmmssZ\" ) ) return LDAP_INVALID_SYNTAX ;"}
{"source": "CWE-369 bool SplashOutputDev : : tilingPatternFill ( GfxState * state , Gfx * gfxA , Catalog * catalog , Object * str , const double * ptm , int paintType , int , Dict * resDict , const double * mat , const double * bbox , int x0 , int y0 , int x1 , int y1 , double xStep , double yStep ) { PDFRectangle box ; Gfx * gfx ; Splash * formerSplash = splash ; SplashBitmap * formerBitmap = bitmap ; double width , height ; int surface_width , surface_height , result_width , result_height , i ; int repeatX , repeatY ; SplashCoord matc [ 6 ] ; Matrix m1 ; const double * ctm ; double savedCTM [ 6 ] ; double kx , ky , sx , sy ; bool retValue = false ; width = bbox [ 2 ] - bbox [ 0 ] ; height = bbox [ 3 ] - bbox [ 1 ] ; if ( xStep != width || yStep != height ) return false ; ctm = state -> getCTM ( ) ; for ( i = 0 ; i < 6 ; ++ i ) { savedCTM [ i ] = ctm [ i ] ; } state -> concatCTM ( mat [ 0 ] , mat [ 1 ] , mat [ 2 ] , mat [ 3 ] , mat [ 4 ] , mat [ 5 ] ) ; state -> concatCTM ( 1 , 0 , 0 , 1 , bbox [ 0 ] , bbox [ 1 ] ) ; ctm = state -> getCTM ( ) ; for ( i = 0 ; i < 6 ; ++ i ) { if ( ! std : : isfinite ( ctm [ i ] ) ) { state -> setCTM ( savedCTM [ 0 ] , savedCTM [ 1 ] , savedCTM [ 2 ] , savedCTM [ 3 ] , savedCTM [ 4 ] , savedCTM [ 5 ] ) ; return false ; } } matc [ 4 ] = x0 * xStep * ctm [ 0 ] + y0 * yStep * ctm [ 2 ] + ctm [ 4 ] ; matc [ 5 ] = x0 * xStep * ctm [ 1 ] + y0 * yStep * ctm [ 3 ] + ctm [ 5 ] ; if ( splashAbs ( ctm [ 1 ] ) > splashAbs ( ctm [ 0 ] ) ) { kx = - ctm [ 1 ] ; ky = ctm [ 2 ] - ( ctm [ 0 ] * ctm [ 3 ] ) / ctm [ 1 ] ; } else { kx = ctm [ 0 ] ; ky = ctm [ 3 ] - ( ctm [ 1 ] * ctm [ 2 ] ) / ctm [ 0 ] ; } result_width = ( int ) ceil ( fabs ( kx * width * ( x1 - x0 ) ) ) ; result_height = ( int ) ceil ( fabs ( ky * height * ( y1 - y0 ) ) ) ; kx = state -> getHDPI ( ) / 72.0 ; ky = state -> getVDPI ( ) / 72.0 ; m1 . m [ 0 ] = ( ptm [ 0 ] == 0 ) ? fabs ( ptm [ 2 ] ) * kx : fabs ( ptm [ 0 ] ) * kx ; m1 . m [ 1 ] = 0 ; m1 . m [ 2 ] = 0 ; m1 . m [ 3 ] = ( ptm [ 3 ] == 0 ) ? fabs ( ptm [ 1 ] ) * ky : fabs ( ptm [ 3 ] ) * ky ; m1 . m [ 4 ] = 0 ; m1 . m [ 5 ] = 0 ; m1 . transform ( width , height , & kx , & ky ) ; surface_width = ( int ) ceil ( fabs ( kx ) ) ; surface_height = ( int ) ceil ( fabs ( ky ) ) ; sx = ( double ) result_width / ( surface_width * ( x1 - x0 ) ) ; sy = ( double ) result_height / ( surface_height * ( y1 - y0 ) ) ; m1 . m [ 0 ] *= sx ; m1 . m [ 3 ] *= sy ; m1 . transform ( width , height , & kx , & ky ) ; if ( fabs ( kx ) < 1 && fabs ( ky ) < 1 ) { kx = std : : min < double > ( kx , ky ) ; ky = 2 / kx ; m1 . m [ 0 ] *= ky ; m1 . m [ 3 ] *= ky ; m1 . transform ( width , height , & kx , & ky ) ; surface_width = ( int ) ceil ( fabs ( kx ) ) ; surface_height = ( int ) ceil ( fabs ( ky ) ) ; repeatX = x1 - x0 ; repeatY = y1 - y0 ; } else { if ( ( unsigned long ) surface_width * surface_height > 0x800000L ) { state -> setCTM ( savedCTM [ 0 ] , savedCTM [ 1 ] , savedCTM [ 2 ] , savedCTM [ 3 ] , savedCTM [ 4 ] , savedCTM [ 5 ] ) ; return false ; } while ( fabs ( kx ) > 16384 || fabs ( ky ) > 16384 ) { m1 . m [ 0 ] /= 2 ; m1 . m [ 3 ] /= 2 ; m1 . transform ( width , height , & kx , & ky ) ; } surface_width = ( int ) ceil ( fabs ( kx ) ) ; surface_height = ( int ) ceil ( fabs ( ky ) ) ; <S2SV_StartBug> repeatX = result_width / surface_width ; <S2SV_EndBug> repeatY = result_height / surface_height ; if ( surface_width * repeatX < result_width ) repeatX ++ ; if ( surface_height * repeatY < result_height ) repeatY ++ ; if ( x1 - x0 > repeatX ) repeatX = x1 - x0 ; if ( y1 - y0 > repeatY ) repeatY = y1 - y0 ; } state -> setCTM ( savedCTM [ 0 ] , savedCTM [ 1 ] , savedCTM [ 2 ] , savedCTM [ 3 ] , savedCTM [ 4 ] , savedCTM [ 5 ] ) ; state -> concatCTM ( mat [ 0 ] , mat [ 1 ] , mat [ 2 ] , mat [ 3 ] , mat [ 4 ] , mat [ 5 ] ) ; state -> concatCTM ( width * repeatX , 0 , 0 , height * repeatY , bbox [ 0 ] , bbox [ 1 ] ) ; ctm = state -> getCTM ( ) ; matc [ 0 ] = ctm [ 0 ] ; matc [ 1 ] = ctm [ 1 ] ; matc [ 2 ] = ctm [ 2 ] ; matc [ 3 ] = ctm [ 3 ] ; if ( surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4 ) { state -> setCTM ( savedCTM [ 0 ] , savedCTM [ 1 ] , savedCTM [ 2 ] , savedCTM [ 3 ] , savedCTM [ 4 ] , savedCTM [ 5 ] ) ; return false ; } m1 . transform ( bbox [ 0 ] , bbox [ 1 ] , & kx , & ky ) ; m1 . m [ 4 ] = - kx ; m1 . m [ 5 ] = - ky ; bitmap = new SplashBitmap ( surface_width , surface_height , 1 , ( paintType == 1 ) ? colorMode : splashModeMono8 , true ) ; if ( bitmap -> getDataPtr ( ) == nullptr ) { SplashBitmap * tBitmap = bitmap ; bitmap = formerBitmap ; delete tBitmap ; state -> setCTM ( savedCTM [ 0 ] , savedCTM [ 1 ] , savedCTM [ 2 ] , savedCTM [ 3 ] , savedCTM [ 4 ] , savedCTM [ 5 ] ) ; return false ; } splash = new Splash ( bitmap , true ) ; if ( paintType == 2 ) { SplashColor clearColor ; # ifdef SPLASH_CMYK clearColor [ 0 ] = ( colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8 ) ? 0x00 : 0xFF ; # else clearColor [ 0 ] = 0xFF ; # endif splash -> clear ( clearColor , 0 ) ; } else { splash -> clear ( paperColor , 0 ) ; } splash -> setThinLineMode ( formerSplash -> getThinLineMode ( ) ) ; splash -> setMinLineWidth ( s_minLineWidth ) ; box . x1 = bbox [ 0 ] ; box . y1 = bbox [ 1 ] ; box . x2 = bbox [ 2 ] ; box . y2 = bbox [ 3 ] ; gfx = new Gfx ( doc , this , resDict , & box , nullptr , nullptr , nullptr , gfxA ) ; gfx -> getState ( ) -> setCTM ( m1 . m [ 0 ] , m1 . m [ 1 ] , m1 . m [ 2 ] , m1 . m [ 3 ] , m1 . m [ 4 ] , m1 . m [ 5 ] ) ; updateCTM ( gfx -> getState ( ) , m1 . m [ 0 ] , m1 . m [ 1 ] , m1 . m [ 2 ] , m1 . m [ 3 ] , m1 . m [ 4 ] , m1 . m [ 5 ] ) ; gfx -> display ( str ) ; delete splash ; splash = formerSplash ; TilingSplashOutBitmap imgData ; imgData . bitmap = bitmap ; imgData . paintType = paintType ; imgData . pattern = splash -> getFillPattern ( ) ; imgData . colorMode = colorMode ; imgData . y = 0 ; imgData . repeatX = repeatX ; imgData . repeatY = repeatY ; SplashBitmap * tBitmap = bitmap ; bitmap = formerBitmap ; result_width = tBitmap -> getWidth ( ) * imgData . repeatX ; result_height = tBitmap -> getHeight ( ) * imgData . repeatY ; if ( splashAbs ( matc [ 1 ] ) > splashAbs ( matc [ 0 ] ) ) { kx = - matc [ 1 ] ; ky = matc [ 2 ] - ( matc [ 0 ] * matc [ 3 ] ) / matc [ 1 ] ; } else { kx = matc [ 0 ] ; ky = matc [ 3 ] - ( matc [ 1 ] * matc [ 2 ] ) / matc [ 0 ] ; } kx = result_width / ( fabs ( kx ) + 1 ) ; ky = result_height / ( fabs ( ky ) + 1 ) ; state -> concatCTM ( kx , 0 , 0 , ky , 0 , 0 ) ; ctm = state -> getCTM ( ) ; matc [ 0 ] = ctm [ 0 ] ; matc [ 1 ] = ctm [ 1 ] ; matc [ 2 ] = ctm [ 2 ] ; matc [ 3 ] = ctm [ 3 ] ; bool minorAxisZero = matc [ 1 ] == 0 && matc [ 2 ] == 0 ; if ( matc [ 0 ] > 0 && minorAxisZero && matc [ 3 ] > 0 ) { for ( int y = 0 ; y < imgData . repeatY ; ++ y ) { for ( int x = 0 ; x < imgData . repeatX ; ++ x ) { x0 = splashFloor ( matc [ 4 ] ) + x * tBitmap -> getWidth ( ) ; y0 = splashFloor ( matc [ 5 ] ) + y * tBitmap -> getHeight ( ) ; splash -> blitImage ( tBitmap , true , x0 , y0 ) ; } } retValue = true ; } else { retValue = splash -> drawImage ( & tilingBitmapSrc , nullptr , & imgData , colorMode , true , result_width , result_height , matc , false , true ) == splashOk ; } delete tBitmap ; delete gfx ; return retValue ; }", "target": "<S2SV_ModStart> ) ) ; if ( unlikely ( surface_width == 0 || surface_height == 0 ) ) { state -> setCTM ( savedCTM [ 0 ] , savedCTM [ 1 ] , savedCTM [ 2 ] , savedCTM [ 3 ] , savedCTM [ 4 ] , savedCTM [ 5 ] ) ; return false ; }"}
{"source": "CWE-125 static void parse_rtcp_bye ( pjmedia_rtcp_session * sess , const void * pkt , pj_size_t size ) { pj_str_t reason = { \"-\" , 1 } ; if ( size > 8 ) { reason . slen = PJ_MIN ( sizeof ( sess -> stat . peer_sdes_buf_ ) , * ( ( pj_uint8_t * ) pkt + 8 ) ) ; <S2SV_StartBug> pj_memcpy ( sess -> stat . peer_sdes_buf_ , ( ( pj_uint8_t * ) pkt + 9 ) , <S2SV_EndBug> reason . slen ) ; reason . ptr = sess -> stat . peer_sdes_buf_ ; } PJ_LOG ( 5 , ( sess -> name , \"Received<S2SV_blank>RTCP<S2SV_blank>BYE,<S2SV_blank>reason:<S2SV_blank>%.*s\" , reason . slen , reason . ptr ) ) ; }", "target": "<S2SV_ModStart> ) ) ; reason . slen = PJ_MIN ( reason . slen , size - 9 ) ;"}
{"source": "CWE-787 eval7 ( char_u * * arg , typval_T * rettv , evalarg_T * evalarg , int want_string ) { int evaluate = evalarg != NULL && ( evalarg -> eval_flags & EVAL_EVALUATE ) ; int len ; char_u * s ; char_u * name_start = NULL ; char_u * start_leader , * end_leader ; int ret = OK ; char_u * alias ; <S2SV_StartBug> <S2SV_EndBug> rettv -> v_type = VAR_UNKNOWN ; start_leader = * arg ; if ( eval_leader ( arg , in_vim9script ( ) ) == FAIL ) return FAIL ; end_leader = * arg ; if ( * * arg == '.' && ( ! isdigit ( * ( * arg + 1 ) ) # ifdef FEAT_FLOAT || in_old_script ( 2 ) # endif ) ) { semsg ( _ ( e_invalid_expression_str ) , * arg ) ; ++ * arg ; return FAIL ; } <S2SV_StartBug> switch ( * * arg ) <S2SV_EndBug> { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '.' : ret = eval_number ( arg , rettv , evaluate , want_string ) ; if ( ret == OK && evaluate && end_leader > start_leader && rettv -> v_type != VAR_BLOB ) ret = eval7_leader ( rettv , TRUE , start_leader , & end_leader ) ; break ; case \\'\"\\' : ret = eval_string ( arg , rettv , evaluate ) ; break ; case '\\\\'' : ret = eval_lit_string ( arg , rettv , evaluate ) ; break ; case '[' : ret = eval_list ( arg , rettv , evalarg , TRUE ) ; break ; case '#' : if ( in_vim9script ( ) ) { ret = vim9_bad_comment ( * arg ) ? FAIL : NOTDONE ; } else if ( ( * arg ) [ 1 ] == '{' ) { ++ * arg ; ret = eval_dict ( arg , rettv , evalarg , TRUE ) ; } else ret = NOTDONE ; break ; case '{' : if ( in_vim9script ( ) ) ret = NOTDONE ; else ret = get_lambda_tv ( arg , rettv , in_vim9script ( ) , evalarg ) ; if ( ret == NOTDONE ) ret = eval_dict ( arg , rettv , evalarg , FALSE ) ; break ; case '&' : ret = eval_option ( arg , rettv , evaluate ) ; break ; case '$' : ret = eval_env_var ( arg , rettv , evaluate ) ; break ; case '@' : ++ * arg ; if ( evaluate ) { if ( in_vim9script ( ) && IS_WHITE_OR_NUL ( * * arg ) ) semsg ( _ ( e_syntax_error_at_str ) , * arg ) ; else if ( in_vim9script ( ) && ! valid_yank_reg ( * * arg , FALSE ) ) emsg_invreg ( * * arg ) ; else { rettv -> v_type = VAR_STRING ; rettv -> vval . v_string = get_reg_contents ( * * arg , GREG_EXPR_SRC ) ; } } if ( * * arg != NUL ) ++ * arg ; break ; case '(' : ret = NOTDONE ; if ( in_vim9script ( ) ) { ret = get_lambda_tv ( arg , rettv , TRUE , evalarg ) ; if ( ret == OK && evaluate ) { ufunc_T * ufunc = rettv -> vval . v_partial -> pt_func ; if ( ufunc -> uf_ret_type -> tt_type == VAR_VOID ) ufunc -> uf_ret_type = & t_unknown ; if ( compile_def_function ( ufunc , FALSE , COMPILE_TYPE ( ufunc ) , NULL ) == FAIL ) { clear_tv ( rettv ) ; ret = FAIL ; } } } if ( ret == NOTDONE ) { * arg = skipwhite_and_linebreak ( * arg + 1 , evalarg ) ; ret = eval1 ( arg , rettv , evalarg ) ; * arg = skipwhite_and_linebreak ( * arg , evalarg ) ; if ( * * arg == ')' ) ++ * arg ; else if ( ret == OK ) { emsg ( _ ( e_missing_closing_paren ) ) ; clear_tv ( rettv ) ; ret = FAIL ; } } break ; default : ret = NOTDONE ; break ; } if ( ret == NOTDONE ) { s = * arg ; len = get_name_len ( arg , & alias , evaluate , TRUE ) ; if ( alias != NULL ) s = alias ; if ( len <= 0 ) ret = FAIL ; else { int flags = evalarg == NULL ? 0 : evalarg -> eval_flags ; if ( evaluate && in_vim9script ( ) && len == 1 && * s == '_' ) { emsg ( _ ( e_cannot_use_underscore_here ) ) ; ret = FAIL ; } else if ( ( in_vim9script ( ) ? * * arg : * skipwhite ( * arg ) ) == '(' ) { * arg = skipwhite ( * arg ) ; ret = eval_func ( arg , evalarg , s , len , rettv , flags , NULL ) ; } else if ( flags & EVAL_CONSTANT ) ret = FAIL ; else if ( evaluate ) { if ( len == 4 && in_vim9script ( ) && STRNCMP ( s , \"true\" , 4 ) == 0 ) { rettv -> v_type = VAR_BOOL ; rettv -> vval . v_number = VVAL_TRUE ; ret = OK ; } else if ( len == 5 && in_vim9script ( ) && STRNCMP ( s , \"false\" , 5 ) == 0 ) { rettv -> v_type = VAR_BOOL ; rettv -> vval . v_number = VVAL_FALSE ; ret = OK ; } else if ( len == 4 && in_vim9script ( ) && STRNCMP ( s , \"null\" , 4 ) == 0 ) { rettv -> v_type = VAR_SPECIAL ; rettv -> vval . v_number = VVAL_NULL ; ret = OK ; } else { name_start = s ; ret = eval_variable ( s , len , 0 , rettv , NULL , EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT ) ; } } else { check_vars ( s , len ) ; ret = OK ; } } vim_free ( alias ) ; } if ( ret == OK ) ret = handle_subscript ( arg , name_start , rettv , evalarg , TRUE ) ; if ( ret == OK && evaluate && end_leader > start_leader ) ret = eval7_leader ( rettv , FALSE , start_leader , & end_leader ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> * alias ; static int recurse = 0 ; <S2SV_ModStart> FAIL ; } if ( recurse == 1000 ) { semsg ( _ ( e_expression_too_recursive_str ) , * arg ) ; return FAIL ; } ++ recurse ; <S2SV_ModStart> end_leader ) ; -- recurse ;"}
{"source": "CWE-94 static void build_dirs ( char * src , char * dst , size_t src_prefix_len , size_t dst_prefix_len ) { char * p = src + src_prefix_len + 1 ; char * q = dst + dst_prefix_len + 1 ; char * r = dst + dst_prefix_len ; struct stat s ; bool last = false ; * r = '\\\\0' ; for ( ; ! last ; p ++ , q ++ ) { if ( * p == '\\\\0' ) { last = true ; } if ( * p == '\\\\0' || ( * p == '/' && * ( p - 1 ) != '/' ) ) { * p = '\\\\0' ; if ( stat ( src , & s ) == 0 && S_ISDIR ( s . st_mode ) ) { * q = '\\\\0' ; * r = '/' ; r = q ; <S2SV_StartBug> mkdir_attr ( dst , s . st_mode , 0 , 0 ) ; <S2SV_EndBug> } if ( ! last ) { * p = '/' ; } } } }", "target": "<S2SV_ModStart> = q ; if ( mkdir ( dst , 0700 ) != 0 && errno != EEXIST ) errExit ( \"mkdir\" ) ; if ( chmod <S2SV_ModEnd> ( dst , <S2SV_ModStart> s . st_mode ) != 0 ) errExit ( \"chmod\" <S2SV_ModEnd> ) ; }"}
{"source": "CWE-125 bool SQClass : : NewSlot ( SQSharedState * ss , const SQObjectPtr & key , const SQObjectPtr & val , bool bstatic ) { SQObjectPtr temp ; bool belongs_to_static_table = sq_type ( val ) == OT_CLOSURE || sq_type ( val ) == OT_NATIVECLOSURE || bstatic ; if ( _locked && ! belongs_to_static_table ) return false ; if ( _members -> Get ( key , temp ) && _isfield ( temp ) ) { _defaultvalues [ _member_idx ( temp ) ] . val = val ; return true ; } <S2SV_StartBug> if ( belongs_to_static_table ) { <S2SV_EndBug> SQInteger mmidx ; if ( ( sq_type ( val ) == OT_CLOSURE || sq_type ( val ) == OT_NATIVECLOSURE ) && ( mmidx = ss -> GetMetaMethodIdxByName ( key ) ) != - 1 ) { _metamethods [ mmidx ] = val ; } else { SQObjectPtr theval = val ; if ( _base && sq_type ( val ) == OT_CLOSURE ) { theval = _closure ( val ) -> Clone ( ) ; _closure ( theval ) -> _base = _base ; __ObjAddRef ( _base ) ; } if ( sq_type ( temp ) == OT_NULL ) { bool isconstructor ; SQVM : : IsEqual ( ss -> _constructoridx , key , isconstructor ) ; if ( isconstructor ) { _constructoridx = ( SQInteger ) _methods . size ( ) ; } SQClassMember m ; m . val = theval ; _members -> NewSlot ( key , SQObjectPtr ( _make_method_idx ( _methods . size ( ) ) ) ) ; _methods . push_back ( m ) ; } else { _methods [ _member_idx ( temp ) ] . val = theval ; } } return true ; } SQClassMember m ; m . val = val ; _members -> NewSlot ( key , SQObjectPtr ( _make_field_idx ( _defaultvalues . size ( ) ) ) ) ; _defaultvalues . push_back ( m ) ; return true ; }", "target": "<S2SV_ModStart> } if ( _members -> CountUsed ( ) >= MEMBER_MAX_COUNT ) { return false ; } if ("}
{"source": "CWE-787 static void * __bpf_ringbuf_reserve ( struct bpf_ringbuf * rb , u64 size ) { unsigned long cons_pos , prod_pos , new_prod_pos , flags ; u32 len , pg_off ; struct bpf_ringbuf_hdr * hdr ; if ( unlikely ( size > RINGBUF_MAX_RECORD_SZ ) ) return NULL ; len = round_up ( size + BPF_RINGBUF_HDR_SZ , 8 ) ; <S2SV_StartBug> cons_pos = smp_load_acquire ( & rb -> consumer_pos ) ; <S2SV_EndBug> if ( in_nmi ( ) ) { if ( ! spin_trylock_irqsave ( & rb -> spinlock , flags ) ) return NULL ; } else { spin_lock_irqsave ( & rb -> spinlock , flags ) ; } prod_pos = rb -> producer_pos ; new_prod_pos = prod_pos + len ; if ( new_prod_pos - cons_pos > rb -> mask ) { spin_unlock_irqrestore ( & rb -> spinlock , flags ) ; return NULL ; } hdr = ( void * ) rb -> data + ( prod_pos & rb -> mask ) ; pg_off = bpf_ringbuf_rec_pg_off ( rb , hdr ) ; hdr -> len = size | BPF_RINGBUF_BUSY_BIT ; hdr -> pg_off = pg_off ; smp_store_release ( & rb -> producer_pos , new_prod_pos ) ; spin_unlock_irqrestore ( & rb -> spinlock , flags ) ; return ( void * ) hdr + BPF_RINGBUF_HDR_SZ ; }", "target": "<S2SV_ModStart> 8 ) ; if ( len > rb -> mask + 1 ) return NULL ;"}
{"source": "CWE-125 bgp_capability_msg_parse ( struct peer * peer , u_char * pnt , bgp_size_t length ) { u_char * end ; <S2SV_StartBug> struct capability cap ; <S2SV_EndBug> u_char action ; struct bgp * bgp ; afi_t afi ; safi_t safi ; bgp = peer -> bgp ; end = pnt + length ; while ( pnt < end ) { if ( pnt + 3 > end ) { zlog_info ( \"%s<S2SV_blank>Capability<S2SV_blank>length<S2SV_blank>error\" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } <S2SV_StartBug> action = * pnt ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & cap , pnt + 1 , sizeof ( struct capability ) ) ; <S2SV_EndBug> if ( action != CAPABILITY_ACTION_SET && action != CAPABILITY_ACTION_UNSET ) { zlog_info ( \"%s<S2SV_blank>Capability<S2SV_blank>Action<S2SV_blank>Value<S2SV_blank>error<S2SV_blank>%d\" , peer -> host , action ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } if ( BGP_DEBUG ( normal , NORMAL ) ) zlog_debug ( \"%s<S2SV_blank>CAPABILITY<S2SV_blank>has<S2SV_blank>action:<S2SV_blank>%d,<S2SV_blank>code:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u\" , <S2SV_StartBug> peer -> host , action , cap . code , cap . length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pnt + ( cap . length + 3 ) > end ) <S2SV_EndBug> { zlog_info ( \"%s<S2SV_blank>Capability<S2SV_blank>length<S2SV_blank>error\" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } <S2SV_StartBug> if ( cap . code == CAPABILITY_CODE_MP ) <S2SV_EndBug> { <S2SV_StartBug> afi = ntohs ( cap . mpc . afi ) ; <S2SV_EndBug> <S2SV_StartBug> safi = cap . mpc . safi ; <S2SV_EndBug> if ( CHECK_FLAG ( peer -> flags , PEER_FLAG_OVERRIDE_CAPABILITY ) ) continue ; <S2SV_StartBug> if ( ( afi == AFI_IP <S2SV_EndBug> || afi == AFI_IP6 ) && ( safi == SAFI_UNICAST || safi == SAFI_MULTICAST || safi == BGP_SAFI_VPNV4 ) ) { if ( BGP_DEBUG ( normal , NORMAL ) ) zlog_debug ( \"%s<S2SV_blank>CAPABILITY<S2SV_blank>has<S2SV_blank>%s<S2SV_blank>MP_EXT<S2SV_blank>CAP<S2SV_blank>for<S2SV_blank>afi/safi:<S2SV_blank>%u/%u\" , peer -> host , action == CAPABILITY_ACTION_SET ? \"Advertising\" : \"Removing\" , <S2SV_StartBug> ntohs ( cap . mpc . afi ) , cap . mpc . safi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( safi == BGP_SAFI_VPNV4 ) <S2SV_EndBug> safi = SAFI_MPLS_VPN ; if ( action == CAPABILITY_ACTION_SET ) { peer -> afc_recv [ afi ] [ safi ] = 1 ; if ( peer -> afc [ afi ] [ safi ] ) { peer -> afc_nego [ afi ] [ safi ] = 1 ; bgp_announce_route ( peer , afi , safi ) ; } } else { peer -> afc_recv [ afi ] [ safi ] = 0 ; peer -> afc_nego [ afi ] [ safi ] = 0 ; if ( peer_active_nego ( peer ) ) bgp_clear_route ( peer , afi , safi ) ; else BGP_EVENT_ADD ( peer , BGP_Stop ) ; } } <S2SV_StartBug> } <S2SV_EndBug> else { zlog_warn ( \"%s<S2SV_blank>unrecognized<S2SV_blank>capability<S2SV_blank>code:<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>ignored\" , <S2SV_StartBug> peer -> host , cap . code ) ; <S2SV_EndBug> } <S2SV_StartBug> pnt += cap . length + 3 ; <S2SV_EndBug> } return 0 ; }", "target": "<S2SV_ModStart> end ; struct capability_mp_data mpc ; struct capability_header * hdr <S2SV_ModEnd> ; u_char action <S2SV_ModStart> 1 ; } action = * pnt ; hdr = ( struct capability_header * ) ( <S2SV_ModEnd> pnt + 1 <S2SV_ModStart> pnt + 1 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , action , hdr -> code , hdr -> <S2SV_ModEnd> length ) ; <S2SV_ModStart> ; if ( ( pnt + hdr -> <S2SV_ModEnd> length + 3 <S2SV_ModStart> 1 ; } memcpy ( & mpc , pnt + 3 , sizeof ( struct capability_mp_data ) ) ; if ( hdr -> <S2SV_ModEnd> code == CAPABILITY_CODE_MP <S2SV_ModStart> = ntohs ( <S2SV_ModEnd> mpc . afi <S2SV_ModStart> ; safi = <S2SV_ModEnd> mpc . safi <S2SV_ModStart> ; if ( ! bgp_afi_safi_valid_indices ( afi , & safi ) ) { if ( BGP_DEBUG ( normal , NORMAL ) ) zlog_debug ( \"%s<S2SV_blank>Dynamic<S2SV_blank>Capability<S2SV_blank>MP_EXT<S2SV_blank>afi/safi<S2SV_blank>invalid\" , peer -> host , afi , safi ) ; continue ; } <S2SV_ModEnd> if ( BGP_DEBUG <S2SV_ModStart> , ntohs ( <S2SV_ModEnd> mpc . afi <S2SV_ModStart> afi ) , <S2SV_ModEnd> mpc . safi <S2SV_ModStart> ; if ( <S2SV_ModEnd> action == CAPABILITY_ACTION_SET <S2SV_ModStart> ; } } <S2SV_ModEnd> else { zlog_warn <S2SV_ModStart> -> host , hdr -> <S2SV_ModEnd> code ) ; <S2SV_ModStart> } pnt += hdr -> <S2SV_ModEnd> length + 3"}
{"source": "CWE-617 WandPrivate void CLINoImageOperator ( MagickCLI * cli_wand , const char * option , const char * arg1n , const char * arg2n ) { const char * arg1 , * arg2 ; # define _image_info ( cli_wand -> wand . image_info ) # define _images ( cli_wand -> wand . images ) # define _exception ( cli_wand -> wand . exception ) # define _process_flags ( cli_wand -> process_flags ) # define _option_type ( ( CommandOptionFlags ) cli_wand -> command -> flags ) # define IfNormalOp ( * option == '-' ) # define IfPlusOp ( * option != '-' ) assert ( cli_wand != ( MagickCLI * ) NULL ) ; assert ( cli_wand -> signature == MagickWandSignature ) ; assert ( cli_wand -> wand . signature == MagickWandSignature ) ; if ( cli_wand -> wand . debug != MagickFalse ) ( void ) CLILogEvent ( cli_wand , CommandEvent , GetMagickModule ( ) , \"-<S2SV_blank>NoImage<S2SV_blank>Operator:<S2SV_blank>%s<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>\\\\\"%s\\\\\"\" , option , arg1n != ( char * ) NULL ? arg1n : \"\" , arg2n != ( char * ) NULL ? arg2n : \"\" ) ; arg1 = arg1n ; arg2 = arg2n ; if ( ( ( ( _process_flags & ProcessInterpretProperities ) != 0 ) || ( ( _option_type & AlwaysInterpretArgsFlag ) != 0 ) ) && ( ( _option_type & NeverInterpretArgsFlag ) == 0 ) ) { if ( arg1n != ( char * ) NULL ) { arg1 = InterpretImageProperties ( _image_info , _images , arg1n , _exception ) ; if ( arg1 == ( char * ) NULL ) { CLIWandException ( OptionWarning , \"InterpretPropertyFailure\" , option ) ; arg1 = arg1n ; } } if ( arg2n != ( char * ) NULL ) { arg2 = InterpretImageProperties ( _image_info , _images , arg2n , _exception ) ; if ( arg2 == ( char * ) NULL ) { CLIWandException ( OptionWarning , \"InterpretPropertyFailure\" , option ) ; arg2 = arg2n ; } } } # undef _process_flags # undef _option_type do { if ( LocaleCompare ( \"noop\" , option + 1 ) == 0 ) break ; if ( LocaleCompare ( \"sans\" , option + 1 ) == 0 ) break ; if ( LocaleCompare ( \"sans0\" , option + 1 ) == 0 ) break ; if ( LocaleCompare ( \"sans1\" , option + 1 ) == 0 ) break ; if ( LocaleCompare ( \"sans2\" , option + 1 ) == 0 ) break ; if ( ( LocaleCompare ( \"read\" , option + 1 ) == 0 ) || ( LocaleCompare ( \"--\" , option ) == 0 ) ) { int argc ; char * * argv ; ssize_t i ; argc = 1 ; argv = ( char * * ) & arg1 ; if ( ExpandFilenames ( & argc , & argv ) == MagickFalse ) CLIWandExceptArgBreak ( ResourceLimitError , \"MemoryAllocationFailed\" , option , GetExceptionMessage ( errno ) ) ; for ( i = 0 ; i < ( ssize_t ) argc ; i ++ ) { Image * new_images ; if ( _image_info -> ping != MagickFalse ) new_images = PingImages ( _image_info , argv [ i ] , _exception ) ; else new_images = ReadImages ( _image_info , argv [ i ] , _exception ) ; AppendImageToList ( & _images , new_images ) ; argv [ i ] = DestroyString ( argv [ i ] ) ; } argv = ( char * * ) RelinquishMagickMemory ( argv ) ; break ; } if ( LocaleCompare ( \"write\" , option + 1 ) == 0 ) { char key [ MagickPathExtent ] ; Image * write_images ; ImageInfo * write_info ; if ( _images == ( Image * ) NULL ) { if ( LocaleCompare ( arg1 , \"null:\" ) == 0 ) break ; CLIWandExceptArgBreak ( OptionError , \"NoImagesForWrite\" , option , arg1 ) ; } ( void ) FormatLocaleString ( key , MagickPathExtent , \"cache:%s\" , arg1 ) ; ( void ) DeleteImageRegistry ( key ) ; write_images = CloneImageList ( _images , _exception ) ; write_info = CloneImageInfo ( _image_info ) ; <S2SV_StartBug> ( void ) WriteImages ( write_info , write_images , arg1 , _exception ) ; <S2SV_EndBug> write_info = DestroyImageInfo ( write_info ) ; write_images = DestroyImageList ( write_images ) ; break ; } if ( LocaleCompare ( \"(\" , option ) == 0 ) { Stack * node ; size_t size ; size = 0 ; node = cli_wand -> image_list_stack ; for ( ; node != ( Stack * ) NULL ; node = node -> next ) size ++ ; if ( size >= MAX_STACK_DEPTH ) CLIWandExceptionBreak ( OptionError , \"ParenthesisNestedTooDeeply\" , option ) ; node = ( Stack * ) AcquireMagickMemory ( sizeof ( * node ) ) ; if ( node == ( Stack * ) NULL ) CLIWandExceptionBreak ( ResourceLimitFatalError , \"MemoryAllocationFailed\" , option ) ; node -> data = ( void * ) cli_wand -> wand . images ; node -> next = cli_wand -> image_list_stack ; cli_wand -> image_list_stack = node ; cli_wand -> wand . images = NewImageList ( ) ; if ( IsStringTrue ( GetImageOption ( cli_wand -> wand . image_info , \"respect-parenthesis\" ) ) != MagickFalse ) option = \"{\" ; else break ; } if ( LocaleCompare ( \"{\" , option ) == 0 ) { Stack * node ; size_t size ; size = 0 ; node = cli_wand -> image_info_stack ; for ( ; node != ( Stack * ) NULL ; node = node -> next ) size ++ ; if ( size >= MAX_STACK_DEPTH ) CLIWandExceptionBreak ( OptionError , \"CurlyBracesNestedTooDeeply\" , option ) ; node = ( Stack * ) AcquireMagickMemory ( sizeof ( * node ) ) ; if ( node == ( Stack * ) NULL ) CLIWandExceptionBreak ( ResourceLimitFatalError , \"MemoryAllocationFailed\" , option ) ; node -> data = ( void * ) cli_wand -> wand . image_info ; node -> next = cli_wand -> image_info_stack ; cli_wand -> image_info_stack = node ; cli_wand -> wand . image_info = CloneImageInfo ( cli_wand -> wand . image_info ) ; if ( cli_wand -> wand . image_info == ( ImageInfo * ) NULL ) { CLIWandException ( ResourceLimitFatalError , \"MemoryAllocationFailed\" , option ) ; cli_wand -> wand . image_info = ( ImageInfo * ) node -> data ; node = ( Stack * ) RelinquishMagickMemory ( node ) ; break ; } break ; } if ( LocaleCompare ( \")\" , option ) == 0 ) { Stack * node ; node = ( Stack * ) cli_wand -> image_list_stack ; if ( node == ( Stack * ) NULL ) CLIWandExceptionBreak ( OptionError , \"UnbalancedParenthesis\" , option ) ; cli_wand -> image_list_stack = node -> next ; AppendImageToList ( ( Image * * ) & node -> data , cli_wand -> wand . images ) ; cli_wand -> wand . images = ( Image * ) node -> data ; node = ( Stack * ) RelinquishMagickMemory ( node ) ; node = cli_wand -> image_info_stack ; if ( node != ( Stack * ) NULL ) { if ( IsStringTrue ( GetImageOption ( cli_wand -> wand . image_info , \"respect-parenthesis\" ) ) != MagickFalse ) option = \"}\" ; else break ; } else break ; } if ( LocaleCompare ( \"}\" , option ) == 0 ) { Stack * node ; node = ( Stack * ) cli_wand -> image_info_stack ; if ( node == ( Stack * ) NULL ) CLIWandExceptionBreak ( OptionError , \"UnbalancedCurlyBraces\" , option ) ; cli_wand -> image_info_stack = node -> next ; ( void ) DestroyImageInfo ( cli_wand -> wand . image_info ) ; cli_wand -> wand . image_info = ( ImageInfo * ) node -> data ; node = ( Stack * ) RelinquishMagickMemory ( node ) ; GetDrawInfo ( cli_wand -> wand . image_info , cli_wand -> draw_info ) ; cli_wand -> quantize_info = DestroyQuantizeInfo ( cli_wand -> quantize_info ) ; cli_wand -> quantize_info = AcquireQuantizeInfo ( cli_wand -> wand . image_info ) ; break ; } if ( LocaleCompare ( \"print\" , option + 1 ) == 0 ) { ( void ) FormatLocaleFile ( stdout , \"%s\" , arg1 ) ; break ; } if ( LocaleCompare ( \"set\" , option + 1 ) == 0 ) { arg1 = InterpretImageProperties ( _image_info , _images , arg1n , _exception ) ; if ( arg1 == ( char * ) NULL ) CLIWandExceptionBreak ( OptionWarning , \"InterpretPropertyFailure\" , option ) ; if ( LocaleNCompare ( arg1 , \"registry:\" , 9 ) == 0 ) { if ( IfPlusOp ) { ( void ) DeleteImageRegistry ( arg1 + 9 ) ; arg1 = DestroyString ( ( char * ) arg1 ) ; break ; } arg2 = InterpretImageProperties ( _image_info , _images , arg2n , _exception ) ; if ( arg2 == ( char * ) NULL ) { arg1 = DestroyString ( ( char * ) arg1 ) ; CLIWandExceptionBreak ( OptionWarning , \"InterpretPropertyFailure\" , option ) ; } ( void ) SetImageRegistry ( StringRegistryType , arg1 + 9 , arg2 , _exception ) ; arg1 = DestroyString ( ( char * ) arg1 ) ; arg2 = DestroyString ( ( char * ) arg2 ) ; break ; } if ( LocaleNCompare ( arg1 , \"option:\" , 7 ) == 0 ) { if ( _images != ( Image * ) NULL ) { MagickResetIterator ( & cli_wand -> wand ) ; while ( MagickNextImage ( & cli_wand -> wand ) != MagickFalse ) ( void ) DeleteImageArtifact ( _images , arg1 + 7 ) ; MagickResetIterator ( & cli_wand -> wand ) ; } arg2 = ( char * ) NULL ; if ( IfNormalOp ) { arg2 = InterpretImageProperties ( _image_info , _images , arg2n , _exception ) ; if ( arg2 == ( char * ) NULL ) CLIWandExceptionBreak ( OptionWarning , \"InterpretPropertyFailure\" , option ) ; } ( void ) SetImageOption ( _image_info , arg1 + 7 , arg2 ) ; arg1 = DestroyString ( ( char * ) arg1 ) ; arg2 = DestroyString ( ( char * ) arg2 ) ; break ; } if ( _images == ( Image * ) NULL ) CLIWandExceptArgBreak ( OptionWarning , \"NoImageForProperty\" , option , arg1 ) ; MagickResetIterator ( & cli_wand -> wand ) ; while ( MagickNextImage ( & cli_wand -> wand ) != MagickFalse ) { arg2 = ( char * ) NULL ; if ( IfNormalOp ) { arg2 = InterpretImageProperties ( _image_info , _images , arg2n , _exception ) ; if ( arg2 == ( char * ) NULL ) CLIWandExceptionBreak ( OptionWarning , \"InterpretPropertyFailure\" , option ) ; } if ( LocaleNCompare ( arg1 , \"artifact:\" , 9 ) == 0 ) ( void ) SetImageArtifact ( _images , arg1 + 9 , arg2 ) ; else if ( LocaleNCompare ( arg1 , \"property:\" , 9 ) == 0 ) ( void ) SetImageProperty ( _images , arg1 + 9 , arg2 , _exception ) ; else ( void ) SetImageProperty ( _images , arg1 , arg2 , _exception ) ; arg2 = DestroyString ( ( char * ) arg2 ) ; } MagickResetIterator ( & cli_wand -> wand ) ; arg1 = DestroyString ( ( char * ) arg1 ) ; break ; } if ( LocaleCompare ( \"clone\" , option + 1 ) == 0 ) { Image * new_images ; if ( * option == '+' ) arg1 = AcquireString ( \"-1\" ) ; if ( IsSceneGeometry ( arg1 , MagickFalse ) == MagickFalse ) CLIWandExceptionBreak ( OptionError , \"InvalidArgument\" , option ) ; if ( cli_wand -> image_list_stack == ( Stack * ) NULL ) CLIWandExceptionBreak ( OptionError , \"UnableToCloneImage\" , option ) ; new_images = ( Image * ) cli_wand -> image_list_stack -> data ; if ( new_images == ( Image * ) NULL ) CLIWandExceptionBreak ( OptionError , \"UnableToCloneImage\" , option ) ; new_images = CloneImages ( new_images , arg1 , _exception ) ; if ( new_images == ( Image * ) NULL ) CLIWandExceptionBreak ( OptionError , \"NoSuchImage\" , option ) ; AppendImageToList ( & _images , new_images ) ; break ; } if ( LocaleCompare ( \"version\" , option + 1 ) == 0 ) { ListMagickVersion ( stdout ) ; break ; } if ( LocaleCompare ( \"list\" , option + 1 ) == 0 ) { ssize_t list ; list = ParseCommandOption ( MagickListOptions , MagickFalse , arg1 ) ; if ( list < 0 ) { CLIWandExceptionArg ( OptionError , \"UnrecognizedListType\" , option , arg1 ) ; break ; } switch ( list ) { case MagickCoderOptions : { ( void ) ListCoderInfo ( ( FILE * ) NULL , _exception ) ; break ; } case MagickColorOptions : { ( void ) ListColorInfo ( ( FILE * ) NULL , _exception ) ; break ; } case MagickConfigureOptions : { ( void ) ListConfigureInfo ( ( FILE * ) NULL , _exception ) ; break ; } case MagickDelegateOptions : { ( void ) ListDelegateInfo ( ( FILE * ) NULL , _exception ) ; break ; } case MagickFontOptions : { ( void ) ListTypeInfo ( ( FILE * ) NULL , _exception ) ; break ; } case MagickFormatOptions : ( void ) ListMagickInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickLocaleOptions : ( void ) ListLocaleInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickLogOptions : ( void ) ListLogInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickMagicOptions : ( void ) ListMagicInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickMimeOptions : ( void ) ListMimeInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickModuleOptions : ( void ) ListModuleInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickPolicyOptions : ( void ) ListPolicyInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickResourceOptions : ( void ) ListMagickResourceInfo ( ( FILE * ) NULL , _exception ) ; break ; case MagickThresholdOptions : ( void ) ListThresholdMaps ( ( FILE * ) NULL , _exception ) ; break ; default : ( void ) ListCommandOptions ( ( FILE * ) NULL , ( CommandOption ) list , _exception ) ; break ; } break ; } CLIWandException ( OptionError , \"UnrecognizedOption\" , option ) ; DisableMSCWarning ( 4127 ) } while ( 0 ) ; RestoreMSCWarning if ( arg1 != arg1n ) arg1 = DestroyString ( ( char * ) arg1 ) ; if ( arg2 != arg2n ) arg2 = DestroyString ( ( char * ) arg2 ) ; # undef _image_info # undef _images # undef _exception # undef IfNormalOp # undef IfPlusOp }", "target": "<S2SV_ModStart> _image_info ) ; if ( write_images != ( Image * ) NULL )"}
{"source": "CWE-193 static int __io_sync_cancel ( struct io_uring_task * tctx , struct io_cancel_data * cd , int fd ) { struct io_ring_ctx * ctx = cd -> ctx ; if ( ( cd -> flags & IORING_ASYNC_CANCEL_FD ) && ( cd -> flags & IORING_ASYNC_CANCEL_FD_FIXED ) ) { unsigned long file_ptr ; <S2SV_StartBug> if ( unlikely ( fd > ctx -> nr_user_files ) ) <S2SV_EndBug> return - EBADF ; fd = array_index_nospec ( fd , ctx -> nr_user_files ) ; file_ptr = io_fixed_file_slot ( & ctx -> file_table , fd ) -> file_ptr ; cd -> file = ( struct file * ) ( file_ptr & FFS_MASK ) ; if ( ! cd -> file ) return - EBADF ; } return __io_async_cancel ( cd , tctx , 0 ) ; }", "target": "<S2SV_ModStart> unlikely ( fd >= <S2SV_ModEnd> ctx -> nr_user_files"}
{"source": "CWE-125 stl_remove_degenerate ( stl_file * stl , int facet ) { int edge1 ; int edge2 ; int edge3 ; int neighbor1 ; int neighbor2 ; int neighbor3 ; int vnot1 ; int vnot2 ; int vnot3 ; if ( stl -> error ) return ; if ( ! memcmp ( & stl -> facet_start [ facet ] . vertex [ 0 ] , & stl -> facet_start [ facet ] . vertex [ 1 ] , sizeof ( stl_vertex ) ) && ! memcmp ( & stl -> facet_start [ facet ] . vertex [ 1 ] , & stl -> facet_start [ facet ] . vertex [ 2 ] , sizeof ( stl_vertex ) ) ) { printf ( \"removing<S2SV_blank>a<S2SV_blank>facet<S2SV_blank>in<S2SV_blank>stl_remove_degenerate\\\\n\" ) ; stl_remove_facet ( stl , facet ) ; return ; } if ( ! memcmp ( & stl -> facet_start [ facet ] . vertex [ 0 ] , & stl -> facet_start [ facet ] . vertex [ 1 ] , sizeof ( stl_vertex ) ) ) { edge1 = 1 ; edge2 = 2 ; edge3 = 0 ; } else if ( ! memcmp ( & stl -> facet_start [ facet ] . vertex [ 1 ] , & stl -> facet_start [ facet ] . vertex [ 2 ] , sizeof ( stl_vertex ) ) ) { edge1 = 0 ; edge2 = 2 ; edge3 = 1 ; } else if ( ! memcmp ( & stl -> facet_start [ facet ] . vertex [ 2 ] , & stl -> facet_start [ facet ] . vertex [ 0 ] , sizeof ( stl_vertex ) ) ) { edge1 = 0 ; edge2 = 1 ; edge3 = 2 ; } else { return ; } neighbor1 = stl -> neighbors_start [ facet ] . neighbor [ edge1 ] ; neighbor2 = stl -> neighbors_start [ facet ] . neighbor [ edge2 ] ; <S2SV_StartBug> if ( neighbor1 == - 1 ) { <S2SV_EndBug> stl_update_connects_remove_1 ( stl , neighbor2 ) ; } <S2SV_StartBug> if ( neighbor2 == - 1 ) { <S2SV_EndBug> stl_update_connects_remove_1 ( stl , neighbor1 ) ; } neighbor3 = stl -> neighbors_start [ facet ] . neighbor [ edge3 ] ; vnot1 = stl -> neighbors_start [ facet ] . which_vertex_not [ edge1 ] ; vnot2 = stl -> neighbors_start [ facet ] . which_vertex_not [ edge2 ] ; vnot3 = stl -> neighbors_start [ facet ] . which_vertex_not [ edge3 ] ; if ( neighbor1 != - 1 ) { stl -> neighbors_start [ neighbor1 ] . neighbor [ ( vnot1 + 1 ) % 3 ] = neighbor2 ; stl -> neighbors_start [ neighbor1 ] . which_vertex_not [ ( vnot1 + 1 ) % 3 ] = vnot2 ; } if ( neighbor2 != - 1 ) { stl -> neighbors_start [ neighbor2 ] . neighbor [ ( vnot2 + 1 ) % 3 ] = neighbor1 ; stl -> neighbors_start [ neighbor2 ] . which_vertex_not [ ( vnot2 + 1 ) % 3 ] = vnot1 ; } stl_remove_facet ( stl , facet ) ; if ( neighbor3 != - 1 ) { stl_update_connects_remove_1 ( stl , neighbor3 ) ; stl -> neighbors_start [ neighbor3 ] . neighbor [ ( vnot3 + 1 ) % 3 ] = - 1 ; } }", "target": "<S2SV_ModStart> == - 1 && neighbor2 != - 1 <S2SV_ModStart> ) ; } else <S2SV_ModStart> == - 1 && neighbor1 != - 1"}
{"source": "CWE-125 stl_update_connects_remove_1 ( stl_file * stl , int facet_num ) { int j ; <S2SV_StartBug> if ( stl -> error ) return ; <S2SV_EndBug> j = ( ( stl -> neighbors_start [ facet_num ] . neighbor [ 0 ] == - 1 ) + ( stl -> neighbors_start [ facet_num ] . neighbor [ 1 ] == - 1 ) + ( stl -> neighbors_start [ facet_num ] . neighbor [ 2 ] == - 1 ) ) ; if ( j == 0 ) { stl -> stats . connected_facets_3_edge -= 1 ; } else if ( j == 1 ) { stl -> stats . connected_facets_2_edge -= 1 ; } else if ( j == 2 ) { stl -> stats . connected_facets_1_edge -= 1 ; } }", "target": "<S2SV_ModStart> stl -> error || facet_num < 0"}
{"source": "CWE-416 static int em28xx_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * udev ; struct em28xx * dev = NULL ; int retval ; bool has_vendor_audio = false , has_video = false , has_dvb = false ; int i , nr , try_bulk ; const int ifnum = intf -> altsetting [ 0 ] . desc . bInterfaceNumber ; char * speed ; udev = usb_get_dev ( interface_to_usbdev ( intf ) ) ; do { nr = find_first_zero_bit ( em28xx_devused , EM28XX_MAXBOARDS ) ; if ( nr >= EM28XX_MAXBOARDS ) { dev_err ( & intf -> dev , \"Driver<S2SV_blank>supports<S2SV_blank>up<S2SV_blank>to<S2SV_blank>%i<S2SV_blank>em28xx<S2SV_blank>boards.\\\\n\" , EM28XX_MAXBOARDS ) ; retval = - ENOMEM ; goto err_no_slot ; } } while ( test_and_set_bit ( nr , em28xx_devused ) ) ; if ( intf -> altsetting [ 0 ] . desc . bInterfaceClass == USB_CLASS_AUDIO ) { dev_info ( & intf -> dev , \"audio<S2SV_blank>device<S2SV_blank>(%04x:%04x):<S2SV_blank>interface<S2SV_blank>%i,<S2SV_blank>class<S2SV_blank>%i\\\\n\" , le16_to_cpu ( udev -> descriptor . idVendor ) , le16_to_cpu ( udev -> descriptor . idProduct ) , ifnum , intf -> altsetting [ 0 ] . desc . bInterfaceClass ) ; retval = - ENODEV ; goto err ; } dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) { retval = - ENOMEM ; goto err ; } dev -> alt_max_pkt_size_isoc = kcalloc ( intf -> num_altsetting , sizeof ( dev -> alt_max_pkt_size_isoc [ 0 ] ) , GFP_KERNEL ) ; if ( ! dev -> alt_max_pkt_size_isoc ) { kfree ( dev ) ; retval = - ENOMEM ; goto err ; } for ( i = 0 ; i < intf -> num_altsetting ; i ++ ) { int ep ; for ( ep = 0 ; ep < intf -> altsetting [ i ] . desc . bNumEndpoints ; ep ++ ) em28xx_check_usb_descriptor ( dev , udev , intf , i , ep , & has_vendor_audio , & has_video , & has_dvb ) ; } if ( ! ( has_vendor_audio || has_video || has_dvb ) ) { retval = - ENODEV ; goto err_free ; } switch ( udev -> speed ) { case USB_SPEED_LOW : speed = \"1.5\" ; break ; case USB_SPEED_UNKNOWN : case USB_SPEED_FULL : speed = \"12\" ; break ; case USB_SPEED_HIGH : speed = \"480\" ; break ; default : speed = \"unknown\" ; } dev_info ( & intf -> dev , \"New<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>@<S2SV_blank>%s<S2SV_blank>Mbps<S2SV_blank>(%04x:%04x,<S2SV_blank>interface<S2SV_blank>%d,<S2SV_blank>class<S2SV_blank>%d)\\\\n\" , udev -> manufacturer ? udev -> manufacturer : \"\" , udev -> product ? udev -> product : \"\" , speed , le16_to_cpu ( udev -> descriptor . idVendor ) , le16_to_cpu ( udev -> descriptor . idProduct ) , ifnum , intf -> altsetting -> desc . bInterfaceNumber ) ; if ( udev -> speed != USB_SPEED_HIGH && disable_usb_speed_check == 0 ) { dev_err ( & intf -> dev , \"Device<S2SV_blank>initialization<S2SV_blank>failed.\\\\n\" ) ; dev_err ( & intf -> dev , \"Device<S2SV_blank>must<S2SV_blank>be<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>a<S2SV_blank>high-speed<S2SV_blank>USB<S2SV_blank>2.0<S2SV_blank>port.\\\\n\" ) ; retval = - ENODEV ; goto err_free ; } <S2SV_StartBug> dev -> devno = nr ; <S2SV_EndBug> dev -> model = id -> driver_info ; dev -> alt = - 1 ; dev -> is_audio_only = has_vendor_audio && ! ( has_video || has_dvb ) ; dev -> has_video = has_video ; dev -> ifnum = ifnum ; dev -> ts = PRIMARY_TS ; snprintf ( dev -> name , 28 , \"em28xx\" ) ; dev -> dev_next = NULL ; if ( has_vendor_audio ) { dev_info ( & intf -> dev , \"Audio<S2SV_blank>interface<S2SV_blank>%i<S2SV_blank>found<S2SV_blank>(Vendor<S2SV_blank>Class)\\\\n\" , ifnum ) ; dev -> usb_audio_type = EM28XX_USB_AUDIO_VENDOR ; } for ( i = 0 ; i < udev -> config -> desc . bNumInterfaces ; i ++ ) { struct usb_interface * uif = udev -> config -> interface [ i ] ; if ( uif -> altsetting [ 0 ] . desc . bInterfaceClass == USB_CLASS_AUDIO ) { if ( has_vendor_audio ) dev_err ( & intf -> dev , \"em28xx:<S2SV_blank>device<S2SV_blank>seems<S2SV_blank>to<S2SV_blank>have<S2SV_blank>vendor<S2SV_blank>AND<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>class<S2SV_blank>interfaces<S2SV_blank>!\\\\n\" \"\\\\t\\\\tThe<S2SV_blank>vendor<S2SV_blank>interface<S2SV_blank>will<S2SV_blank>be<S2SV_blank>ignored.<S2SV_blank>Please<S2SV_blank>contact<S2SV_blank>the<S2SV_blank>developers<S2SV_blank><linux-media@vger.kernel.org>\\\\n\" ) ; dev -> usb_audio_type = EM28XX_USB_AUDIO_CLASS ; break ; } } if ( has_video ) dev_info ( & intf -> dev , \"Video<S2SV_blank>interface<S2SV_blank>%i<S2SV_blank>found:%s%s\\\\n\" , ifnum , dev -> analog_ep_bulk ? \"<S2SV_blank>bulk\" : \"\" , dev -> analog_ep_isoc ? \"<S2SV_blank>isoc\" : \"\" ) ; if ( has_dvb ) dev_info ( & intf -> dev , \"DVB<S2SV_blank>interface<S2SV_blank>%i<S2SV_blank>found:%s%s\\\\n\" , ifnum , dev -> dvb_ep_bulk ? \"<S2SV_blank>bulk\" : \"\" , dev -> dvb_ep_isoc ? \"<S2SV_blank>isoc\" : \"\" ) ; dev -> num_alt = intf -> num_altsetting ; if ( ( unsigned int ) card [ nr ] < em28xx_bcount ) dev -> model = card [ nr ] ; usb_set_intfdata ( intf , dev ) ; mutex_init ( & dev -> lock ) ; retval = em28xx_init_dev ( dev , udev , intf , nr ) ; if ( retval ) goto err_free ; if ( usb_xfer_mode < 0 ) { if ( dev -> is_webcam ) try_bulk = 1 ; else try_bulk = 0 ; } else { try_bulk = usb_xfer_mode > 0 ; } if ( has_video && dev -> board . decoder == EM28XX_NODECODER && dev -> em28xx_sensor == EM28XX_NOSENSOR ) { dev_err ( & intf -> dev , \"Currently,<S2SV_blank>V4L2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>model\\\\n\" ) ; has_video = false ; dev -> has_video = false ; } if ( dev -> board . has_dual_ts && ( dev -> tuner_type != TUNER_ABSENT || INPUT ( 0 ) -> type ) ) { dev_err ( & intf -> dev , \"We<S2SV_blank>currently<S2SV_blank>don\\'t<S2SV_blank>support<S2SV_blank>analog<S2SV_blank>TV<S2SV_blank>or<S2SV_blank>stream<S2SV_blank>capture<S2SV_blank>on<S2SV_blank>dual<S2SV_blank>tuners.\\\\n\" ) ; has_video = false ; } if ( has_video ) { if ( ! dev -> analog_ep_isoc || ( try_bulk && dev -> analog_ep_bulk ) ) dev -> analog_xfer_bulk = 1 ; dev_info ( & intf -> dev , \"analog<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>mode.\\\\n\" , dev -> analog_xfer_bulk ? \"bulk\" : \"isoc\" ) ; } if ( has_dvb ) { if ( ! dev -> dvb_ep_isoc || ( try_bulk && dev -> dvb_ep_bulk ) ) dev -> dvb_xfer_bulk = 1 ; dev_info ( & intf -> dev , \"dvb<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>mode.\\\\n\" , dev -> dvb_xfer_bulk ? \"bulk\" : \"isoc\" ) ; } if ( dev -> board . has_dual_ts && em28xx_duplicate_dev ( dev ) == 0 ) { <S2SV_StartBug> dev -> dev_next -> ts = SECONDARY_TS ; <S2SV_EndBug> dev -> dev_next -> alt = - 1 ; dev -> dev_next -> is_audio_only = has_vendor_audio && ! ( has_video || has_dvb ) ; dev -> dev_next -> has_video = false ; dev -> dev_next -> ifnum = ifnum ; dev -> dev_next -> model = id -> driver_info ; mutex_init ( & dev -> dev_next -> lock ) ; retval = em28xx_init_dev ( dev -> dev_next , udev , intf , dev -> dev_next -> devno ) ; if ( retval ) goto err_free ; dev -> dev_next -> board . ir_codes = NULL ; dev -> dev_next -> board . has_ir_i2c = 0 ; if ( usb_xfer_mode < 0 ) { if ( dev -> dev_next -> is_webcam ) try_bulk = 1 ; else try_bulk = 0 ; } else { try_bulk = usb_xfer_mode > 0 ; } if ( has_dvb ) { if ( ! dev -> dvb_ep_isoc_ts2 || ( try_bulk && dev -> dvb_ep_bulk_ts2 ) ) dev -> dev_next -> dvb_xfer_bulk = 1 ; dev_info ( & dev -> intf -> dev , \"dvb<S2SV_blank>ts2<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>mode.\\\\n\" , dev -> dev_next -> dvb_xfer_bulk ? \"bulk\" : \"isoc\" ) ; } dev -> dev_next -> dvb_ep_isoc = dev -> dvb_ep_isoc_ts2 ; dev -> dev_next -> dvb_ep_bulk = dev -> dvb_ep_bulk_ts2 ; dev -> dev_next -> dvb_max_pkt_size_isoc = dev -> dvb_max_pkt_size_isoc_ts2 ; dev -> dev_next -> dvb_alt_isoc = dev -> dvb_alt_isoc ; if ( dev -> dvb_xfer_bulk ) { em28xx_write_reg ( dev , 0x0b , 0x96 ) ; mdelay ( 100 ) ; em28xx_write_reg ( dev , 0x0b , 0x80 ) ; mdelay ( 100 ) ; } else { em28xx_write_reg ( dev , 0x0b , 0x96 ) ; mdelay ( 100 ) ; em28xx_write_reg ( dev , 0x0b , 0x82 ) ; mdelay ( 100 ) ; } <S2SV_StartBug> kref_init ( & dev -> dev_next -> ref ) ; <S2SV_EndBug> } kref_init ( & dev -> ref ) ; request_modules ( dev ) ; # ifdef CONFIG_MEDIA_CONTROLLER retval = media_device_register ( dev -> media_dev ) ; # endif return 0 ; err_free : kfree ( dev -> alt_max_pkt_size_isoc ) ; kfree ( dev ) ; err : clear_bit ( nr , em28xx_devused ) ; err_no_slot : usb_put_dev ( udev ) ; return retval ; }", "target": "<S2SV_ModStart> err_free ; } kref_init ( & dev -> ref ) ; <S2SV_ModStart> 0 ) { kref_init ( & dev -> dev_next -> ref ) ; <S2SV_ModStart> ) ; } } <S2SV_ModEnd> request_modules ( dev"}
{"source": "CWE-703 static void sixpack_close ( struct tty_struct * tty ) { struct sixpack * sp ; write_lock_irq ( & disc_data_lock ) ; sp = tty -> disc_data ; tty -> disc_data = NULL ; write_unlock_irq ( & disc_data_lock ) ; if ( ! sp ) return ; if ( ! refcount_dec_and_test ( & sp -> refcnt ) ) wait_for_completion ( & sp -> dead ) ; netif_stop_queue ( sp -> dev ) ; <S2SV_StartBug> del_timer_sync ( & sp -> tx_t ) ; <S2SV_EndBug> <S2SV_StartBug> del_timer_sync ( & sp -> resync_t ) ; <S2SV_EndBug> unregister_netdev ( sp -> dev ) ; kfree ( sp -> rbuff ) ; kfree ( sp -> xbuff ) ; free_netdev ( sp -> dev ) ; }", "target": "<S2SV_ModStart> dev ) ; unregister_netdev ( sp -> dev ) ; <S2SV_ModStart> sp -> resync_t <S2SV_ModEnd> ) ; kfree"}
{"source": "CWE-200 struct vfsmount * clone_private_mount ( const struct path * path ) { struct mount * old_mnt = real_mount ( path -> mnt ) ; struct mount * new_mnt ; <S2SV_StartBug> if ( IS_MNT_UNBINDABLE ( old_mnt ) ) <S2SV_EndBug> <S2SV_StartBug> return ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> <S2SV_StartBug> new_mnt = clone_mnt ( old_mnt , path -> dentry , CL_PRIVATE ) ; <S2SV_EndBug> if ( IS_ERR ( new_mnt ) ) return ERR_CAST ( new_mnt ) ; new_mnt -> mnt_ns = MNT_NS_INTERNAL ; return & new_mnt -> mnt ; <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> * new_mnt ; down_read ( & namespace_sem ) ; <S2SV_ModStart> old_mnt ) ) goto invalid ; if ( ! check_mnt ( old_mnt ) ) goto invalid ; if ( has_locked_children ( old_mnt , path -> dentry ) ) goto invalid <S2SV_ModEnd> ; new_mnt = <S2SV_ModStart> CL_PRIVATE ) ; up_read ( & namespace_sem ) ; <S2SV_ModStart> -> mnt ; invalid : up_read ( & namespace_sem ) ; return ERR_PTR ( - EINVAL ) ;"}
{"source": "CWE-94 static int io_rw_init_file ( struct io_kiocb * req , fmode_t mode ) { struct kiocb * kiocb = & req -> rw . kiocb ; struct io_ring_ctx * ctx = req -> ctx ; struct file * file = req -> file ; int ret ; if ( unlikely ( ! file || ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! io_req_ffs_set ( req ) ) req -> flags |= io_file_get_flags ( file ) << REQ_F_SUPPORT_NOWAIT_BIT ; kiocb -> ki_flags = iocb_flags ( file ) ; ret = kiocb_set_rw_flags ( kiocb , req -> rw . flags ) ; if ( unlikely ( ret ) ) return ret ; if ( ( kiocb -> ki_flags & IOCB_NOWAIT ) || ( ( file -> f_flags & O_NONBLOCK ) && ! io_file_supports_nowait ( req ) ) ) req -> flags |= REQ_F_NOWAIT ; if ( ctx -> flags & IORING_SETUP_IOPOLL ) { if ( ! ( kiocb -> ki_flags & IOCB_DIRECT ) || ! file -> f_op -> iopoll ) return - EOPNOTSUPP ; <S2SV_StartBug> <S2SV_EndBug> kiocb -> ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE ; kiocb -> ki_complete = io_complete_rw_iopoll ; req -> iopoll_completed = 0 ; } else { if ( kiocb -> ki_flags & IOCB_HIPRI ) return - EINVAL ; kiocb -> ki_complete = io_complete_rw ; } return 0 ; }", "target": "<S2SV_ModStart> - EOPNOTSUPP ; kiocb -> private = NULL ;"}
{"source": "CWE-787 static pyc_object * get_complex_object ( RzBinPycObj * pyc , RzBuffer * buffer ) { pyc_object * ret = NULL ; bool error = false ; <S2SV_StartBug> ut32 size = 0 ; <S2SV_EndBug> ut32 n1 = 0 ; ut32 n2 = 0 ; ret = RZ_NEW0 ( pyc_object ) ; if ( ! ret ) { return NULL ; } if ( ( pyc -> magic_int & 0xffff ) <= 62061 ) { n1 = get_ut8 ( buffer , & error ) ; } else { n1 = get_st32 ( buffer , & error ) ; } <S2SV_StartBug> if ( error ) { <S2SV_EndBug> free ( ret ) ; return NULL ; } ut8 * s1 = malloc ( n1 + 1 ) ; if ( ! s1 ) { return NULL ; } <S2SV_StartBug> size = rz_buf_read ( buffer , s1 , n1 ) ; <S2SV_EndBug> if ( size != n1 ) { RZ_FREE ( s1 ) ; RZ_FREE ( ret ) ; return NULL ; } s1 [ n1 ] = '\\\\0' ; if ( ( pyc -> magic_int & 0xffff ) <= 62061 ) { n2 = get_ut8 ( buffer , & error ) ; <S2SV_StartBug> } else <S2SV_EndBug> n2 = get_st32 ( buffer , & error ) ; <S2SV_StartBug> if ( error ) { <S2SV_EndBug> return NULL ; } ut8 * s2 = malloc ( n2 + 1 ) ; if ( ! s2 ) { return NULL ; } <S2SV_StartBug> size = rz_buf_read ( buffer , s2 , n2 ) ; <S2SV_EndBug> if ( size != n2 ) { RZ_FREE ( s1 ) ; RZ_FREE ( s2 ) ; RZ_FREE ( ret ) ; return NULL ; } s2 [ n2 ] = '\\\\0' ; ret -> type = TYPE_COMPLEX ; ret -> data = rz_str_newf ( \"%s+%sj\" , s1 , s2 ) ; RZ_FREE ( s1 ) ; RZ_FREE ( s2 ) ; if ( ! ret -> data ) { RZ_FREE ( ret ) ; return NULL ; } return ret ; }", "target": "<S2SV_ModStart> false ; ut32 <S2SV_ModEnd> n1 = 0 <S2SV_ModStart> if ( error || UT32_ADD_OVFCHK ( n1 , 1 ) <S2SV_ModStart> NULL ; } if ( <S2SV_ModEnd> rz_buf_read ( buffer <S2SV_ModStart> , n1 ) <S2SV_ModEnd> != n1 ) <S2SV_ModStart> ; } else { <S2SV_ModStart> error ) ; } if ( error || UT32_ADD_OVFCHK ( n2 , 1 ) <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } if ( <S2SV_ModEnd> rz_buf_read ( buffer <S2SV_ModStart> , n2 ) <S2SV_ModEnd> != n2 )"}
{"source": "CWE-834 static inline void fuse_make_bad ( struct inode * inode ) <S2SV_StartBug> { <S2SV_EndBug> set_bit ( FUSE_I_BAD , & get_fuse_inode ( inode ) -> state ) ; }", "target": "<S2SV_ModStart> inode ) { remove_inode_hash ( inode ) ;"}
{"source": "CWE-269 void sdb_edit ( procinfo * pi ) { <S2SV_StartBug> char * filename = omStrDup ( \"/tmp/sd000000\" ) ; <S2SV_EndBug> sprintf ( filename + 7 , \"%d\" , getpid ( ) ) ; FILE * fp = fopen ( filename , \"w\" ) ; if ( fp == NULL ) { Print ( \"cannot<S2SV_blank>open<S2SV_blank>%s\\\\n\" , filename ) ; omFree ( filename ) ; return ; } if ( pi -> language != LANG_SINGULAR ) { Print ( \"cannot<S2SV_blank>edit<S2SV_blank>type<S2SV_blank>%d\\\\n\" , pi -> language ) ; <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> fp = NULL ; } else { const char * editor = getenv ( \"EDITOR\" ) ; if ( editor == NULL ) editor = getenv ( \"VISUAL\" ) ; if ( editor == NULL ) editor = \"vi\" ; editor = omStrDup ( editor ) ; if ( pi -> data . s . body == NULL ) { iiGetLibProcBuffer ( pi ) ; if ( pi -> data . s . body == NULL ) { PrintS ( \"cannot<S2SV_blank>get<S2SV_blank>the<S2SV_blank>procedure<S2SV_blank>body\\\\n\" ) ; <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> si_unlink ( filename ) ; omFree ( filename ) ; return ; } } <S2SV_StartBug> fwrite ( pi -> data . s . body , 1 , strlen ( pi -> data . s . body ) , fp ) ; <S2SV_EndBug> fclose ( fp ) ; int pid = fork ( ) ; if ( pid != 0 ) { si_wait ( & pid ) ; } else if ( pid == 0 ) { if ( strchr ( editor , '<S2SV_blank>' ) == NULL ) { execlp ( editor , editor , filename , NULL ) ; Print ( \"cannot<S2SV_blank>exec<S2SV_blank>%s\\\\n\" , editor ) ; } else { char * p = ( char * ) omAlloc ( strlen ( editor ) + strlen ( filename ) + 2 ) ; sprintf ( p , \"%s<S2SV_blank>%s\" , editor , filename ) ; system ( p ) ; } exit ( 0 ) ; } else { PrintS ( \"cannot<S2SV_blank>fork\\\\n\" ) ; } <S2SV_StartBug> fp = fopen ( filename , \"r\" ) ; <S2SV_EndBug> if ( fp == NULL ) { Print ( \"cannot<S2SV_blank>read<S2SV_blank>from<S2SV_blank>%s\\\\n\" , filename ) ; } else { fseek ( fp , 0L , SEEK_END ) ; long len = ftell ( fp ) ; fseek ( fp , 0L , SEEK_SET ) ; omFree ( ( ADDRESS ) pi -> data . s . body ) ; pi -> data . s . body = ( char * ) omAlloc ( ( int ) len + 1 ) ; myfread ( pi -> data . s . body , len , 1 , fp ) ; pi -> data . s . body [ len ] = '\\\\0' ; fclose ( fp ) ; } } si_unlink ( filename ) ; omFree ( filename ) ; }", "target": "<S2SV_ModStart> = omStrDup ( \"/tmp/sdXXXXXX\" ) ; int f = mkstemp ( filename ) ; if ( f == - 1 <S2SV_ModEnd> ) { Print <S2SV_ModStart> language ) ; close ( f ) ; f <S2SV_ModEnd> = NULL ; <S2SV_ModStart> \"cannot<S2SV_blank>get<S2SV_blank>the<S2SV_blank>procedure<S2SV_blank>body\\\\n\" ) ; close ( f <S2SV_ModEnd> ) ; si_unlink <S2SV_ModStart> ; } } write ( f , pi -> data . s . body <S2SV_ModEnd> , strlen ( <S2SV_ModStart> . body ) ) ; close ( f <S2SV_ModEnd> ) ; int <S2SV_ModStart> ) ; } FILE *"}
{"source": "CWE-401 ipf_extract_frags_from_batch ( struct ipf * ipf , struct dp_packet_batch * pb , ovs_be16 dl_type , uint16_t zone , long long now , uint32_t hash_basis ) { const size_t pb_cnt = dp_packet_batch_size ( pb ) ; int pb_idx ; struct dp_packet * pkt ; DP_PACKET_BATCH_REFILL_FOR_EACH ( pb_idx , pb_cnt , pkt , pb ) { if ( OVS_UNLIKELY ( ( dl_type == htons ( ETH_TYPE_IP ) && ipf_is_valid_v4_frag ( ipf , pkt ) ) || ( dl_type == htons ( ETH_TYPE_IPV6 ) && ipf_is_valid_v6_frag ( ipf , pkt ) ) ) ) { ovs_mutex_lock ( & ipf -> ipf_lock ) ; if ( ! ipf_handle_frag ( ipf , pkt , dl_type , zone , now , hash_basis ) ) { dp_packet_batch_refill ( pb , pkt , pb_idx ) ; <S2SV_StartBug> } <S2SV_EndBug> ovs_mutex_unlock ( & ipf -> ipf_lock ) ; } else { dp_packet_batch_refill ( pb , pkt , pb_idx ) ; } } }", "target": "<S2SV_ModStart> ) ; } else { dp_packet_delete ( pkt ) ; }"}
{"source": "CWE-200 gpg_ctx_add_recipient ( struct _GpgCtx * gpg , const gchar * keyid ) <S2SV_StartBug> { <S2SV_EndBug> if ( gpg -> mode != GPG_CTX_MODE_ENCRYPT && gpg -> mode != GPG_CTX_MODE_EXPORT ) return ; if ( ! gpg -> recipients ) gpg -> recipients = g_ptr_array_new ( ) ; <S2SV_StartBug> g_ptr_array_add ( gpg -> recipients , g_strdup ( keyid ) ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> keyid ) { gchar * safe_keyid ; <S2SV_ModStart> ( ) ; g_return_if_fail ( keyid != NULL ) ; if ( strchr ( keyid , '@' ) != NULL ) { safe_keyid = g_strdup_printf ( \"<%s>\" , keyid ) ; } else { safe_keyid = g_strdup ( keyid ) ; } <S2SV_ModStart> -> recipients , safe_keyid <S2SV_ModEnd> ) ; }"}
{"source": "CWE-125 load_image ( const gchar * filename , GError * * error ) { gchar * name ; gint fd ; BrushHeader bh ; guchar * brush_buf = NULL ; gint32 image_ID ; gint32 layer_ID ; GimpParasite * parasite ; GimpDrawable * drawable ; GimpPixelRgn pixel_rgn ; gint bn_size ; GimpImageBaseType base_type ; GimpImageType image_type ; gsize size ; fd = g_open ( filename , O_RDONLY | _O_BINARY , 0 ) ; if ( fd == - 1 ) { g_set_error ( error , G_FILE_ERROR , g_file_error_from_errno ( errno ) , _ ( \"Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>\\'%s\\'<S2SV_blank>for<S2SV_blank>reading:<S2SV_blank>%s\" ) , gimp_filename_to_utf8 ( filename ) , g_strerror ( errno ) ) ; return - 1 ; } gimp_progress_init_printf ( _ ( \"Opening<S2SV_blank>\\'%s\\'\" ) , gimp_filename_to_utf8 ( filename ) ) ; if ( read ( fd , & bh , sizeof ( BrushHeader ) ) != sizeof ( BrushHeader ) ) { close ( fd ) ; return - 1 ; } bh . header_size = g_ntohl ( bh . header_size ) ; bh . version = g_ntohl ( bh . version ) ; bh . width = g_ntohl ( bh . width ) ; bh . height = g_ntohl ( bh . height ) ; bh . bytes = g_ntohl ( bh . bytes ) ; bh . magic_number = g_ntohl ( bh . magic_number ) ; bh . spacing = g_ntohl ( bh . spacing ) ; if ( ( bh . width == 0 ) || ( bh . width > GIMP_MAX_IMAGE_SIZE ) || ( bh . height == 0 ) || ( bh . height > GIMP_MAX_IMAGE_SIZE ) || ( ( bh . bytes != 1 ) && ( bh . bytes != 2 ) && ( bh . bytes != 4 ) && ( bh . bytes != 18 ) ) || ( G_MAXSIZE / bh . width / bh . height / bh . bytes < 1 ) ) { g_set_error ( error , G_FILE_ERROR , G_FILE_ERROR_FAILED , _ ( \"Invalid<S2SV_blank>header<S2SV_blank>data<S2SV_blank>in<S2SV_blank>\\'%s\\':<S2SV_blank>width=%lu,<S2SV_blank>height=%lu,<S2SV_blank>\" \"bytes=%lu\" ) , gimp_filename_to_utf8 ( filename ) , ( unsigned long int ) bh . width , ( unsigned long int ) bh . height , ( unsigned long int ) bh . bytes ) ; return - 1 ; } switch ( bh . version ) { case 1 : bh . spacing = 25 ; lseek ( fd , - 8 , SEEK_CUR ) ; bh . header_size += 8 ; break ; case 3 : if ( bh . bytes == 18 ) { bh . bytes = 2 ; } else { g_message ( _ ( \"Unsupported<S2SV_blank>brush<S2SV_blank>format\" ) ) ; close ( fd ) ; return - 1 ; } case 2 : if ( bh . magic_number == GBRUSH_MAGIC && bh . header_size > sizeof ( BrushHeader ) ) break ; default : g_message ( _ ( \"Unsupported<S2SV_blank>brush<S2SV_blank>format\" ) ) ; close ( fd ) ; return - 1 ; } if ( ( bn_size = ( bh . header_size - sizeof ( BrushHeader ) ) ) > 0 ) { gchar * temp = g_new ( gchar , bn_size ) ; <S2SV_StartBug> if ( ( read ( fd , temp , bn_size ) ) < bn_size ) <S2SV_EndBug> { g_set_error ( error , G_FILE_ERROR , G_FILE_ERROR_FAILED , _ ( \"Error<S2SV_blank>in<S2SV_blank>GIMP<S2SV_blank>brush<S2SV_blank>file<S2SV_blank>\\'%s\\'\" ) , gimp_filename_to_utf8 ( filename ) ) ; close ( fd ) ; g_free ( temp ) ; return - 1 ; } name = gimp_any_to_utf8 ( temp , - 1 , _ ( \"Invalid<S2SV_blank>UTF-8<S2SV_blank>string<S2SV_blank>in<S2SV_blank>brush<S2SV_blank>file<S2SV_blank>\\'%s\\'.\" ) , gimp_filename_to_utf8 ( filename ) ) ; g_free ( temp ) ; } else { name = g_strdup ( _ ( \"Unnamed\" ) ) ; } size = bh . width * bh . height * bh . bytes ; brush_buf = g_malloc ( size ) ; if ( read ( fd , brush_buf , size ) != size ) { close ( fd ) ; g_free ( brush_buf ) ; g_free ( name ) ; return - 1 ; } switch ( bh . bytes ) { case 1 : { PatternHeader ph ; if ( read ( fd , & ph , sizeof ( PatternHeader ) ) == sizeof ( PatternHeader ) ) { ph . header_size = g_ntohl ( ph . header_size ) ; ph . version = g_ntohl ( ph . version ) ; ph . width = g_ntohl ( ph . width ) ; ph . height = g_ntohl ( ph . height ) ; ph . bytes = g_ntohl ( ph . bytes ) ; ph . magic_number = g_ntohl ( ph . magic_number ) ; if ( ph . magic_number == GPATTERN_MAGIC && ph . version == 1 && ph . header_size > sizeof ( PatternHeader ) && ph . bytes == 3 && ph . width == bh . width && ph . height == bh . height && lseek ( fd , ph . header_size - sizeof ( PatternHeader ) , SEEK_CUR ) > 0 ) { guchar * plain_brush = brush_buf ; gint i ; bh . bytes = 4 ; brush_buf = g_malloc ( 4 * bh . width * bh . height ) ; for ( i = 0 ; i < ph . width * ph . height ; i ++ ) { if ( read ( fd , brush_buf + i * 4 , 3 ) != 3 ) { close ( fd ) ; g_free ( name ) ; g_free ( plain_brush ) ; g_free ( brush_buf ) ; return - 1 ; } brush_buf [ i * 4 + 3 ] = plain_brush [ i ] ; } g_free ( plain_brush ) ; } } } break ; case 2 : { guint16 * buf = ( guint16 * ) brush_buf ; gint i ; for ( i = 0 ; i < bh . width * bh . height ; i ++ , buf ++ ) { union { guint16 u [ 2 ] ; gfloat f ; } short_float ; # if G_BYTE_ORDER == G_LITTLE_ENDIAN short_float . u [ 0 ] = 0 ; short_float . u [ 1 ] = GUINT16_FROM_BE ( * buf ) ; # else short_float . u [ 0 ] = GUINT16_FROM_BE ( * buf ) ; short_float . u [ 1 ] = 0 ; # endif brush_buf [ i ] = ( guchar ) ( short_float . f * 255.0 + 0.5 ) ; } bh . bytes = 1 ; } break ; default : break ; } switch ( bh . bytes ) { case 1 : base_type = GIMP_GRAY ; image_type = GIMP_GRAY_IMAGE ; break ; case 4 : base_type = GIMP_RGB ; image_type = GIMP_RGBA_IMAGE ; break ; default : g_message ( \"Unsupported<S2SV_blank>brush<S2SV_blank>depth:<S2SV_blank>%d\\\\n\" \"GIMP<S2SV_blank>Brushes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>GRAY<S2SV_blank>or<S2SV_blank>RGBA\\\\n\" , bh . bytes ) ; g_free ( name ) ; return - 1 ; } image_ID = gimp_image_new ( bh . width , bh . height , base_type ) ; gimp_image_set_filename ( image_ID , filename ) ; parasite = gimp_parasite_new ( \"gimp-brush-name\" , GIMP_PARASITE_PERSISTENT , strlen ( name ) + 1 , name ) ; gimp_image_attach_parasite ( image_ID , parasite ) ; gimp_parasite_free ( parasite ) ; layer_ID = gimp_layer_new ( image_ID , name , bh . width , bh . height , image_type , 100 , GIMP_NORMAL_MODE ) ; gimp_image_insert_layer ( image_ID , layer_ID , - 1 , 0 ) ; g_free ( name ) ; drawable = gimp_drawable_get ( layer_ID ) ; gimp_pixel_rgn_init ( & pixel_rgn , drawable , 0 , 0 , drawable -> width , drawable -> height , TRUE , FALSE ) ; gimp_pixel_rgn_set_rect ( & pixel_rgn , brush_buf , 0 , 0 , bh . width , bh . height ) ; g_free ( brush_buf ) ; if ( image_type == GIMP_GRAY_IMAGE ) gimp_invert ( layer_ID ) ; close ( fd ) ; gimp_drawable_flush ( drawable ) ; gimp_progress_update ( 1.0 ) ; return image_ID ; }", "target": "<S2SV_ModStart> ) < bn_size || temp [ bn_size - 1 ] != '\\\\0'"}
{"source": "CWE-672 void ZRLE_DECODE ( const Rect & r , rdr : : InStream * is , rdr : : ZlibInStream * zis , const PixelFormat & pf , ModifiablePixelBuffer * pb ) { int length = is -> readU32 ( ) ; zis -> setUnderlying ( is , length ) ; Rect t ; PIXEL_T buf [ 64 * 64 ] ; for ( t . tl . y = r . tl . y ; t . tl . y < r . br . y ; t . tl . y += 64 ) { t . br . y = __rfbmin ( r . br . y , t . tl . y + 64 ) ; for ( t . tl . x = r . tl . x ; t . tl . x < r . br . x ; t . tl . x += 64 ) { t . br . x = __rfbmin ( r . br . x , t . tl . x + 64 ) ; int mode = zis -> readU8 ( ) ; bool rle = mode & 128 ; int palSize = mode & 127 ; PIXEL_T palette [ 128 ] ; for ( int i = 0 ; i < palSize ; i ++ ) { palette [ i ] = READ_PIXEL ( zis ) ; } if ( palSize == 1 ) { PIXEL_T pix = palette [ 0 ] ; pb -> fillRect ( pf , t , & pix ) ; continue ; } if ( ! rle ) { if ( palSize == 0 ) { # ifdef CPIXEL for ( PIXEL_T * ptr = buf ; ptr < buf + t . area ( ) ; ptr ++ ) { * ptr = READ_PIXEL ( zis ) ; } # else zis -> readBytes ( buf , t . area ( ) * ( BPP / 8 ) ) ; # endif } else { int bppp = ( ( palSize > 16 ) ? 8 : ( ( palSize > 4 ) ? 4 : ( ( palSize > 2 ) ? 2 : 1 ) ) ) ; PIXEL_T * ptr = buf ; for ( int i = 0 ; i < t . height ( ) ; i ++ ) { PIXEL_T * eol = ptr + t . width ( ) ; rdr : : U8 byte = 0 ; rdr : : U8 nbits = 0 ; while ( ptr < eol ) { if ( nbits == 0 ) { byte = zis -> readU8 ( ) ; nbits = 8 ; } nbits -= bppp ; rdr : : U8 index = ( byte >> nbits ) & ( ( 1 << bppp ) - 1 ) & 127 ; * ptr ++ = palette [ index ] ; } } } } else { if ( palSize == 0 ) { PIXEL_T * ptr = buf ; PIXEL_T * end = ptr + t . area ( ) ; while ( ptr < end ) { PIXEL_T pix = READ_PIXEL ( zis ) ; int len = 1 ; int b ; do { b = zis -> readU8 ( ) ; len += b ; } while ( b == 255 ) ; if ( end - ptr < len ) { throw Exception ( \"ZRLE<S2SV_blank>decode<S2SV_blank>error\" ) ; } while ( len -- > 0 ) * ptr ++ = pix ; } } else { PIXEL_T * ptr = buf ; PIXEL_T * end = ptr + t . area ( ) ; while ( ptr < end ) { int index = zis -> readU8 ( ) ; int len = 1 ; if ( index & 128 ) { int b ; do { b = zis -> readU8 ( ) ; len += b ; } while ( b == 255 ) ; if ( end - ptr < len ) { throw Exception ( \"ZRLE<S2SV_blank>decode<S2SV_blank>error\" ) ; } } index &= 127 ; PIXEL_T pix = palette [ index ] ; while ( len -- > 0 ) * ptr ++ = pix ; } } } pb -> imageRect ( pf , t , buf ) ; } } <S2SV_StartBug> zis -> removeUnderlying ( ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> } zis -> flushUnderlying ( ) ; zis -> setUnderlying ( NULL , 0 <S2SV_ModEnd> ) ; }"}
{"source": "CWE-787 parse_command_modifiers ( exarg_T * eap , char * * errormsg , cmdmod_T * cmod , int skip_only ) { char_u * orig_cmd = eap -> cmd ; char_u * cmd_start = NULL ; int use_plus_cmd = FALSE ; int starts_with_colon = FALSE ; int vim9script = in_vim9script ( ) ; int has_visual_range = FALSE ; CLEAR_POINTER ( cmod ) ; cmod -> cmod_flags = sticky_cmdmod_flags ; if ( STRNCMP ( eap -> cmd , \"\\'<,\\'>\" , 5 ) == 0 ) { eap -> cmd += 5 ; cmd_start = eap -> cmd ; has_visual_range = TRUE ; } for ( ; ; ) { char_u * p ; while ( * eap -> cmd == '<S2SV_blank>' || * eap -> cmd == '\\\\t' || * eap -> cmd == ':' ) { if ( * eap -> cmd == ':' ) starts_with_colon = TRUE ; ++ eap -> cmd ; } if ( * eap -> cmd == NUL && exmode_active && ( getline_equal ( eap -> getline , eap -> cookie , getexmodeline ) || getline_equal ( eap -> getline , eap -> cookie , getexline ) ) && curwin -> w_cursor . lnum < curbuf -> b_ml . ml_line_count ) { use_plus_cmd = TRUE ; if ( ! skip_only ) ex_pressedreturn = TRUE ; break ; } if ( comment_start ( eap -> cmd , starts_with_colon ) ) { if ( eap -> nextcmd == NULL ) { eap -> nextcmd = vim_strchr ( eap -> cmd , '\\\\n' ) ; if ( eap -> nextcmd != NULL ) ++ eap -> nextcmd ; } if ( vim9script && has_cmdmod ( cmod , FALSE ) ) * errormsg = _ ( e_command_modifier_without_command ) ; return FAIL ; } if ( * eap -> cmd == NUL ) { if ( ! skip_only ) { ex_pressedreturn = TRUE ; if ( vim9script && has_cmdmod ( cmod , FALSE ) ) * errormsg = _ ( e_command_modifier_without_command ) ; } return FAIL ; } p = skip_range ( eap -> cmd , TRUE , NULL ) ; if ( vim9script ) { char_u * s , * n ; for ( s = eap -> cmd ; ASCII_ISALPHA ( * s ) ; ++ s ) ; n = skipwhite ( s ) ; if ( * n == '.' || * n == '=' || ( * n != NUL && n [ 1 ] == '=' ) || * s == '[' ) break ; } switch ( * p ) { case 'a' : if ( ! checkforcmd_noparen ( & eap -> cmd , \"aboveleft\" , 3 ) ) break ; cmod -> cmod_split |= WSP_ABOVE ; continue ; case 'b' : if ( checkforcmd_noparen ( & eap -> cmd , \"belowright\" , 3 ) ) { cmod -> cmod_split |= WSP_BELOW ; continue ; } if ( checkforcmd_opt ( & eap -> cmd , \"browse\" , 3 , TRUE ) ) { # ifdef FEAT_BROWSE_CMD cmod -> cmod_flags |= CMOD_BROWSE ; # endif continue ; } if ( ! checkforcmd_noparen ( & eap -> cmd , \"botright\" , 2 ) ) break ; cmod -> cmod_split |= WSP_BOT ; continue ; case 'c' : if ( ! checkforcmd_opt ( & eap -> cmd , \"confirm\" , 4 , TRUE ) ) break ; # if defined ( FEAT_GUI_DIALOG ) || defined ( FEAT_CON_DIALOG ) cmod -> cmod_flags |= CMOD_CONFIRM ; # endif continue ; case 'k' : if ( checkforcmd_noparen ( & eap -> cmd , \"keepmarks\" , 3 ) ) { cmod -> cmod_flags |= CMOD_KEEPMARKS ; continue ; } if ( checkforcmd_noparen ( & eap -> cmd , \"keepalt\" , 5 ) ) { cmod -> cmod_flags |= CMOD_KEEPALT ; continue ; } if ( checkforcmd_noparen ( & eap -> cmd , \"keeppatterns\" , 5 ) ) { cmod -> cmod_flags |= CMOD_KEEPPATTERNS ; continue ; } if ( ! checkforcmd_noparen ( & eap -> cmd , \"keepjumps\" , 5 ) ) break ; cmod -> cmod_flags |= CMOD_KEEPJUMPS ; continue ; case 'f' : { char_u * reg_pat ; char_u * nulp = NULL ; int c = 0 ; if ( ! checkforcmd_noparen ( & p , \"filter\" , 4 ) || * p == NUL || ( ends_excmd ( * p ) # ifdef FEAT_EVAL && ( ! vim9script || VIM_ISWHITE ( p [ 1 ] ) ) # endif ) ) break ; if ( * p == '!' ) { cmod -> cmod_filter_force = TRUE ; p = skipwhite ( p + 1 ) ; if ( * p == NUL || ends_excmd ( * p ) ) break ; } # ifdef FEAT_EVAL if ( vim9script && ! VIM_ISWHITE ( p [ - 1 ] ) ) break ; # endif if ( skip_only ) p = skip_vimgrep_pat ( p , NULL , NULL ) ; else p = skip_vimgrep_pat_ext ( p , & reg_pat , NULL , & nulp , & c ) ; if ( p == NULL || * p == NUL ) break ; if ( ! skip_only ) { cmod -> cmod_filter_regmatch . regprog = vim_regcomp ( reg_pat , RE_MAGIC ) ; if ( cmod -> cmod_filter_regmatch . regprog == NULL ) break ; if ( nulp != NULL ) * nulp = c ; } eap -> cmd = p ; continue ; } case 'h' : if ( p != eap -> cmd || ! checkforcmd_noparen ( & p , \"hide\" , 3 ) || * p == NUL || ends_excmd ( * p ) ) break ; eap -> cmd = p ; cmod -> cmod_flags |= CMOD_HIDE ; continue ; case 'l' : if ( checkforcmd_noparen ( & eap -> cmd , \"lockmarks\" , 3 ) ) { cmod -> cmod_flags |= CMOD_LOCKMARKS ; continue ; } if ( checkforcmd_noparen ( & eap -> cmd , \"legacy\" , 3 ) ) { if ( ends_excmd2 ( p , eap -> cmd ) ) { * errormsg = _ ( e_legacy_must_be_followed_by_command ) ; return FAIL ; } cmod -> cmod_flags |= CMOD_LEGACY ; continue ; } if ( ! checkforcmd_noparen ( & eap -> cmd , \"leftabove\" , 5 ) ) break ; cmod -> cmod_split |= WSP_ABOVE ; continue ; case 'n' : if ( checkforcmd_noparen ( & eap -> cmd , \"noautocmd\" , 3 ) ) { cmod -> cmod_flags |= CMOD_NOAUTOCMD ; continue ; } if ( ! checkforcmd_noparen ( & eap -> cmd , \"noswapfile\" , 3 ) ) break ; cmod -> cmod_flags |= CMOD_NOSWAPFILE ; continue ; case 'r' : if ( ! checkforcmd_noparen ( & eap -> cmd , \"rightbelow\" , 6 ) ) break ; cmod -> cmod_split |= WSP_BELOW ; continue ; case 's' : if ( checkforcmd_noparen ( & eap -> cmd , \"sandbox\" , 3 ) ) { cmod -> cmod_flags |= CMOD_SANDBOX ; continue ; } if ( ! checkforcmd_noparen ( & eap -> cmd , \"silent\" , 3 ) ) break ; cmod -> cmod_flags |= CMOD_SILENT ; if ( * eap -> cmd == '!' && ! VIM_ISWHITE ( eap -> cmd [ - 1 ] ) ) { eap -> cmd = skipwhite ( eap -> cmd + 1 ) ; cmod -> cmod_flags |= CMOD_ERRSILENT ; } continue ; case 't' : if ( checkforcmd_noparen ( & p , \"tab\" , 3 ) ) { if ( ! skip_only ) { long tabnr = get_address ( eap , & eap -> cmd , ADDR_TABS , eap -> skip , skip_only , FALSE , 1 ) ; if ( tabnr == MAXLNUM ) cmod -> cmod_tab = tabpage_index ( curtab ) + 1 ; else { if ( tabnr < 0 || tabnr > LAST_TAB_NR ) { * errormsg = _ ( e_invalid_range ) ; return FAIL ; } cmod -> cmod_tab = tabnr + 1 ; } } eap -> cmd = p ; continue ; } if ( ! checkforcmd_noparen ( & eap -> cmd , \"topleft\" , 2 ) ) break ; cmod -> cmod_split |= WSP_TOP ; continue ; case 'u' : if ( ! checkforcmd_noparen ( & eap -> cmd , \"unsilent\" , 3 ) ) break ; cmod -> cmod_flags |= CMOD_UNSILENT ; continue ; case 'v' : if ( checkforcmd_noparen ( & eap -> cmd , \"vertical\" , 4 ) ) { cmod -> cmod_split |= WSP_VERT ; continue ; } if ( checkforcmd_noparen ( & eap -> cmd , \"vim9cmd\" , 4 ) ) { if ( ends_excmd2 ( p , eap -> cmd ) ) { * errormsg = _ ( e_vim9cmd_must_be_followed_by_command ) ; return FAIL ; } cmod -> cmod_flags |= CMOD_VIM9CMD ; continue ; } if ( ! checkforcmd_noparen ( & p , \"verbose\" , 4 ) ) break ; if ( vim_isdigit ( * eap -> cmd ) ) { cmod -> cmod_verbose = atoi ( ( char * ) eap -> cmd ) + 1 ; } else cmod -> cmod_verbose = 2 ; eap -> cmd = p ; continue ; } break ; } if ( has_visual_range ) { if ( eap -> cmd > cmd_start ) { if ( use_plus_cmd ) { size_t len = STRLEN ( cmd_start ) ; mch_memmove ( orig_cmd , cmd_start , len ) ; <S2SV_StartBug> STRCPY ( orig_cmd + len , \"\\'<,\\'>+\" ) ; <S2SV_EndBug> } else { mch_memmove ( cmd_start - 5 , cmd_start , eap -> cmd - cmd_start ) ; eap -> cmd -= 5 ; mch_memmove ( eap -> cmd - 1 , \":\\'<,\\'>\" , 6 ) ; } } else if ( use_plus_cmd ) eap -> cmd = ( char_u * ) \"\\'<,\\'>+\" ; else eap -> cmd = orig_cmd ; } else if ( use_plus_cmd ) eap -> cmd = ( char_u * ) \"+\" ; return OK ; }", "target": "<S2SV_ModStart> + len , \"<S2SV_blank>*+\" <S2SV_ModEnd> ) ; }"}
{"source": "CWE-416 static void extract_arg ( RAnal * anal , RAnalFunction * fcn , RAnalOp * op , const char * reg , const char * sign , char type ) { st64 ptr = 0 ; char * addr , * esil_buf = NULL ; const st64 maxstackframe = 1024 * 8 ; r_return_if_fail ( anal && fcn && op && reg ) ; size_t i ; for ( i = 0 ; i < R_ARRAY_SIZE ( op -> src ) ; i ++ ) { if ( op -> src [ i ] && op -> src [ i ] -> reg && op -> src [ i ] -> reg -> name ) { if ( ! strcmp ( reg , op -> src [ i ] -> reg -> name ) ) { st64 delta = op -> src [ i ] -> delta ; if ( ( delta > 0 && * sign == '+' ) || ( delta < 0 && * sign == '-' ) ) { ptr = R_ABS ( op -> src [ i ] -> delta ) ; break ; } } } } if ( ! ptr ) { const char * op_esil = r_strbuf_get ( & op -> esil ) ; if ( ! op_esil ) { return ; } esil_buf = strdup ( op_esil ) ; if ( ! esil_buf ) { return ; } r_strf_var ( esilexpr , 64 , \",%s,%s,\" , reg , sign ) ; char * ptr_end = strstr ( esil_buf , esilexpr ) ; if ( ! ptr_end ) { free ( esil_buf ) ; return ; } * ptr_end = 0 ; addr = ptr_end ; while ( ( addr [ 0 ] != '0' || addr [ 1 ] != 'x' ) && addr >= esil_buf + 1 && * addr != ',' ) { addr -- ; } if ( strncmp ( addr , \"0x\" , 2 ) ) { if ( ! op -> stackop && op -> dst ) { const char * sp = r_reg_get_name ( anal -> reg , R_REG_NAME_SP ) ; const char * bp = r_reg_get_name ( anal -> reg , R_REG_NAME_BP ) ; const char * rn = op -> dst -> reg ? op -> dst -> reg -> name : NULL ; if ( rn && ( ( bp && ! strcmp ( bp , rn ) ) || ( sp && ! strcmp ( sp , rn ) ) ) ) { if ( anal -> verbose ) { eprintf ( \"Warning:<S2SV_blank>Analysis<S2SV_blank>didn\\'t<S2SV_blank>fill<S2SV_blank>op->stackop<S2SV_blank>for<S2SV_blank>instruction<S2SV_blank>that<S2SV_blank>alters<S2SV_blank>stack<S2SV_blank>at<S2SV_blank>0x%\" PFMT64x \".\\\\n\" , op -> addr ) ; } goto beach ; } } if ( * addr == ',' ) { addr ++ ; } if ( ! op -> stackop && op -> type != R_ANAL_OP_TYPE_PUSH && op -> type != R_ANAL_OP_TYPE_POP && op -> type != R_ANAL_OP_TYPE_RET && r_str_isnumber ( addr ) ) { ptr = ( st64 ) r_num_get ( NULL , addr ) ; if ( ptr && op -> src [ 0 ] && ptr == op -> src [ 0 ] -> imm ) { goto beach ; } } else if ( ( op -> stackop == R_ANAL_STACK_SET ) || ( op -> stackop == R_ANAL_STACK_GET ) ) { if ( op -> ptr % 4 ) { goto beach ; } ptr = R_ABS ( op -> ptr ) ; } else { goto beach ; } } else { ptr = ( st64 ) r_num_get ( NULL , addr ) ; } } if ( anal -> verbose && ( ! op -> src [ 0 ] || ! op -> dst ) ) { eprintf ( \"Warning:<S2SV_blank>Analysis<S2SV_blank>didn\\'t<S2SV_blank>fill<S2SV_blank>op->src/dst<S2SV_blank>at<S2SV_blank>0x%\" PFMT64x \".\\\\n\" , op -> addr ) ; } int rw = ( op -> direction == R_ANAL_OP_DIR_WRITE ) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ ; if ( * sign == '+' ) { const bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn -> stack : ptr >= fcn -> bp_off ; const char * pfx = isarg ? ARGPREFIX : VARPREFIX ; st64 frame_off ; if ( type == R_ANAL_VAR_KIND_SPV ) { frame_off = ptr - fcn -> stack ; } else { frame_off = ptr - fcn -> bp_off ; } if ( maxstackframe != 0 && ( frame_off > maxstackframe || frame_off < - maxstackframe ) ) { goto beach ; } RAnalVar * var = get_stack_var ( fcn , frame_off ) ; if ( var ) { r_anal_var_set_access ( var , reg , op -> addr , rw , ptr ) ; goto beach ; } char * varname = NULL , * vartype = NULL ; if ( isarg ) { const char * place = fcn -> cc ? r_anal_cc_arg ( anal , fcn -> cc , ST32_MAX ) : NULL ; bool stack_rev = place ? ! strcmp ( place , \"stack_rev\" ) : false ; char * fname = r_type_func_guess ( anal -> sdb_types , fcn -> name ) ; if ( fname ) { ut64 sum_sz = 0 ; size_t from , to , i ; if ( stack_rev ) { const size_t cnt = r_type_func_args_count ( anal -> sdb_types , fname ) ; from = cnt ? cnt - 1 : cnt ; to = fcn -> cc ? r_anal_cc_max_arg ( anal , fcn -> cc ) : 0 ; } else { from = fcn -> cc ? r_anal_cc_max_arg ( anal , fcn -> cc ) : 0 ; to = r_type_func_args_count ( anal -> sdb_types , fname ) ; } const int bytes = ( fcn -> bits ? fcn -> bits : anal -> bits ) / 8 ; for ( i = from ; stack_rev ? i >= to : i < to ; stack_rev ? i -- : i ++ ) { char * tp = r_type_func_args_type ( anal -> sdb_types , fname , i ) ; if ( ! tp ) { break ; } if ( sum_sz == frame_off ) { vartype = tp ; varname = strdup ( r_type_func_args_name ( anal -> sdb_types , fname , i ) ) ; break ; } ut64 bit_sz = r_type_get_bitsize ( anal -> sdb_types , tp ) ; sum_sz += bit_sz ? bit_sz / 8 : bytes ; sum_sz = R_ROUND ( sum_sz , bytes ) ; free ( tp ) ; } free ( fname ) ; } } if ( ! varname ) { if ( anal -> opt . varname_stack ) { varname = r_str_newf ( \"%s_%\" PFMT64x \"h\" , pfx , R_ABS ( frame_off ) ) ; } else { varname = r_anal_function_autoname_var ( fcn , type , pfx , ptr ) ; } } if ( varname ) { # if 0 if ( isarg && frame_off > 48 ) { free ( varname ) ; goto beach ; } # endif RAnalVar * var = r_anal_function_set_var ( fcn , frame_off , type , vartype , anal -> bits / 8 , isarg , varname ) ; if ( var ) { r_anal_var_set_access ( var , reg , op -> addr , rw , ptr ) ; } free ( varname ) ; } free ( vartype ) ; } else { st64 frame_off = - ( ptr + fcn -> bp_off ) ; <S2SV_StartBug> if ( maxstackframe != 0 && ( frame_off > maxstackframe || frame_off < - maxstackframe ) ) { <S2SV_EndBug> goto beach ; } RAnalVar * var = get_stack_var ( fcn , frame_off ) ; if ( var ) { r_anal_var_set_access ( var , reg , op -> addr , rw , - ptr ) ; goto beach ; } char * varname = anal -> opt . varname_stack ? r_str_newf ( \"%s_%\" PFMT64x \"h\" , VARPREFIX , R_ABS ( frame_off ) ) : r_anal_function_autoname_var ( fcn , type , VARPREFIX , - ptr ) ; if ( varname ) { RAnalVar * var = r_anal_function_set_var ( fcn , frame_off , type , NULL , anal -> bits / 8 , false , varname ) ; if ( var ) { r_anal_var_set_access ( var , reg , op -> addr , rw , - ptr ) ; } free ( varname ) ; } } beach : free ( esil_buf ) ; }", "target": "<S2SV_ModStart> if ( maxstackframe > <S2SV_ModEnd> 0 && ("}
{"source": "CWE-787 ins_bs ( int c , int mode , int * inserted_space_p ) { linenr_T lnum ; int cc ; int temp = 0 ; colnr_T save_col ; colnr_T mincol ; int did_backspace = FALSE ; int in_indent ; int oldState ; int cpc [ MAX_MCO ] ; int call_fix_indent = FALSE ; if ( BUFEMPTY ( ) || ( # ifdef FEAT_RIGHTLEFT ! revins_on && # endif ( ( curwin -> w_cursor . lnum == 1 && curwin -> w_cursor . col == 0 ) || ( ! can_bs ( BS_START ) && ( ( arrow_used # ifdef FEAT_JOB_CHANNEL && ! bt_prompt ( curbuf ) # endif ) || ( curwin -> w_cursor . lnum == Insstart_orig . lnum && curwin -> w_cursor . col <= Insstart_orig . col ) ) ) || ( ! can_bs ( BS_INDENT ) && ! arrow_used && ai_col > 0 && curwin -> w_cursor . col <= ai_col ) || ( ! can_bs ( BS_EOL ) && curwin -> w_cursor . col == 0 ) ) ) ) { vim_beep ( BO_BS ) ; return FALSE ; } if ( stop_arrow ( ) == FAIL ) return FALSE ; in_indent = inindent ( 0 ) ; if ( in_indent ) can_cindent = FALSE ; end_comment_pending = NUL ; # ifdef FEAT_RIGHTLEFT if ( revins_on ) inc_cursor ( ) ; # endif if ( curwin -> w_cursor . coladd > 0 ) { if ( mode == BACKSPACE_CHAR ) { -- curwin -> w_cursor . coladd ; return TRUE ; } if ( mode == BACKSPACE_WORD ) { curwin -> w_cursor . coladd = 0 ; return TRUE ; } curwin -> w_cursor . coladd = 0 ; } if ( curwin -> w_cursor . col == 0 ) { lnum = Insstart . lnum ; if ( curwin -> w_cursor . lnum == lnum # ifdef FEAT_RIGHTLEFT || revins_on # endif ) { if ( u_save ( ( linenr_T ) ( curwin -> w_cursor . lnum - 2 ) , ( linenr_T ) ( curwin -> w_cursor . lnum + 1 ) ) == FAIL ) return FALSE ; -- Insstart . lnum ; Insstart . col = ( colnr_T ) STRLEN ( ml_get ( Insstart . lnum ) ) ; } cc = - 1 ; if ( State & REPLACE_FLAG ) cc = replace_pop ( ) ; if ( ( State & REPLACE_FLAG ) && curwin -> w_cursor . lnum <= lnum ) { dec_cursor ( ) ; } else { if ( ! ( State & VREPLACE_FLAG ) || curwin -> w_cursor . lnum > orig_line_count ) { temp = gchar_cursor ( ) ; -- curwin -> w_cursor . lnum ; if ( has_format_option ( FO_AUTO ) && has_format_option ( FO_WHITE_PAR ) ) { char_u * ptr = ml_get_buf ( curbuf , curwin -> w_cursor . lnum , TRUE ) ; int len ; len = ( int ) STRLEN ( ptr ) ; if ( len > 0 && ptr [ len - 1 ] == '<S2SV_blank>' ) ptr [ len - 1 ] = NUL ; } ( void ) do_join ( 2 , FALSE , FALSE , FALSE , FALSE ) ; if ( temp == NUL && gchar_cursor ( ) != NUL ) inc_cursor ( ) ; } else dec_cursor ( ) ; if ( State & REPLACE_FLAG ) { oldState = State ; State = MODE_NORMAL ; while ( cc > 0 ) { save_col = curwin -> w_cursor . col ; mb_replace_pop_ins ( cc ) ; curwin -> w_cursor . col = save_col ; cc = replace_pop ( ) ; } replace_pop_ins ( ) ; State = oldState ; } } did_ai = FALSE ; } else { # ifdef FEAT_RIGHTLEFT if ( revins_on ) dec_cursor ( ) ; # endif mincol = 0 ; if ( mode == BACKSPACE_LINE && ( curbuf -> b_p_ai || cindent_on ( ) ) # ifdef FEAT_RIGHTLEFT && ! revins_on # endif ) { save_col = curwin -> w_cursor . col ; beginline ( BL_WHITE ) ; if ( curwin -> w_cursor . col < save_col ) { mincol = curwin -> w_cursor . col ; call_fix_indent = TRUE ; } curwin -> w_cursor . col = save_col ; } if ( mode == BACKSPACE_CHAR && ( ( p_sta && in_indent ) || ( ( get_sts_value ( ) != 0 # ifdef FEAT_VARTABS || tabstop_count ( curbuf -> b_p_vsts_array ) # endif ) && curwin -> w_cursor . col > 0 && ( * ( ml_get_cursor ( ) - 1 ) == TAB || ( * ( ml_get_cursor ( ) - 1 ) == '<S2SV_blank>' && ( ! * inserted_space_p || arrow_used ) ) ) ) ) ) { int ts ; colnr_T vcol ; colnr_T want_vcol ; colnr_T start_vcol ; * inserted_space_p = FALSE ; getvcol ( curwin , & curwin -> w_cursor , & vcol , NULL , NULL ) ; start_vcol = vcol ; dec_cursor ( ) ; getvcol ( curwin , & curwin -> w_cursor , NULL , NULL , & want_vcol ) ; inc_cursor ( ) ; # ifdef FEAT_VARTABS if ( p_sta && in_indent ) { ts = ( int ) get_sw_value ( curbuf ) ; want_vcol = ( want_vcol / ts ) * ts ; } else want_vcol = tabstop_start ( want_vcol , get_sts_value ( ) , curbuf -> b_p_vsts_array ) ; # else if ( p_sta && in_indent ) ts = ( int ) get_sw_value ( curbuf ) ; else ts = ( int ) get_sts_value ( ) ; want_vcol = ( want_vcol / ts ) * ts ; # endif <S2SV_StartBug> while ( vcol > want_vcol <S2SV_EndBug> && ( cc = * ( ml_get_cursor ( ) - 1 ) , VIM_ISWHITE ( cc ) ) ) ins_bs_one ( & vcol ) ; while ( vcol < want_vcol ) { if ( curwin -> w_cursor . lnum == Insstart_orig . lnum && curwin -> w_cursor . col < Insstart_orig . col ) Insstart_orig . col = curwin -> w_cursor . col ; if ( State & VREPLACE_FLAG ) ins_char ( '<S2SV_blank>' ) ; else { ins_str ( ( char_u * ) \"<S2SV_blank>\" ) ; if ( ( State & REPLACE_FLAG ) ) replace_push ( NUL ) ; } getvcol ( curwin , & curwin -> w_cursor , & vcol , NULL , NULL ) ; } if ( vcol >= start_vcol ) ins_bs_one ( & vcol ) ; } else { int cclass = 0 , prev_cclass = 0 ; if ( has_mbyte ) cclass = mb_get_class ( ml_get_cursor ( ) ) ; do { # ifdef FEAT_RIGHTLEFT if ( ! revins_on ) # endif dec_cursor ( ) ; cc = gchar_cursor ( ) ; if ( has_mbyte ) { prev_cclass = cclass ; cclass = mb_get_class ( ml_get_cursor ( ) ) ; } if ( mode == BACKSPACE_WORD && ! vim_isspace ( cc ) ) { mode = BACKSPACE_WORD_NOT_SPACE ; temp = vim_iswordc ( cc ) ; } else if ( mode == BACKSPACE_WORD_NOT_SPACE && ( ( vim_isspace ( cc ) || vim_iswordc ( cc ) != temp ) || prev_cclass != cclass ) ) { # ifdef FEAT_RIGHTLEFT if ( ! revins_on ) # endif inc_cursor ( ) ; # ifdef FEAT_RIGHTLEFT else if ( State & REPLACE_FLAG ) dec_cursor ( ) ; # endif break ; } if ( State & REPLACE_FLAG ) replace_do_bs ( - 1 ) ; else { if ( enc_utf8 && p_deco ) ( void ) utfc_ptr2char ( ml_get_cursor ( ) , cpc ) ; ( void ) del_char ( FALSE ) ; if ( enc_utf8 && p_deco && cpc [ 0 ] != NUL ) inc_cursor ( ) ; # ifdef FEAT_RIGHTLEFT if ( revins_chars ) { revins_chars -- ; revins_legal ++ ; } if ( revins_on && gchar_cursor ( ) == NUL ) break ; # endif } if ( mode == BACKSPACE_CHAR ) break ; } while ( # ifdef FEAT_RIGHTLEFT revins_on || # endif ( curwin -> w_cursor . col > mincol && ( can_bs ( BS_NOSTOP ) || ( curwin -> w_cursor . lnum != Insstart_orig . lnum || curwin -> w_cursor . col != Insstart_orig . col ) ) ) ) ; } did_backspace = TRUE ; } did_si = FALSE ; can_si = FALSE ; can_si_back = FALSE ; if ( curwin -> w_cursor . col <= 1 ) did_ai = FALSE ; if ( call_fix_indent ) fix_indent ( ) ; AppendCharToRedobuff ( c ) ; if ( curwin -> w_cursor . lnum == Insstart_orig . lnum && curwin -> w_cursor . col < Insstart_orig . col ) Insstart_orig . col = curwin -> w_cursor . col ; if ( vim_strchr ( p_cpo , CPO_BACKSPACE ) != NULL && dollar_vcol == - 1 ) dollar_vcol = curwin -> w_virtcol ; # ifdef FEAT_FOLDING if ( did_backspace ) foldOpenCursor ( ) ; # endif return did_backspace ; }", "target": "<S2SV_ModStart> vcol > want_vcol && curwin -> w_cursor . col > 0"}
{"source": "CWE-119 static int dynamicGetbuf ( gdIOCtxPtr ctx , void * buf , int len ) { int rlen , remain ; dpIOCtxPtr dctx ; dynamicPtr * dp ; dctx = ( dpIOCtxPtr ) ctx ; dp = dctx -> dp ; remain = dp -> logicalSize - dp -> pos ; if ( remain >= len ) { rlen = len ; } else { <S2SV_StartBug> if ( remain == 0 ) { <S2SV_EndBug> return EOF ; } rlen = remain ; } memcpy ( buf , ( void * ) ( ( char * ) dp -> data + dp -> pos ) , rlen ) ; dp -> pos += rlen ; return rlen ; }", "target": "<S2SV_ModStart> if ( remain <= <S2SV_ModEnd> 0 ) {"}
{"source": "CWE-119 <S2SV_StartBug> gdImageFillToBorder ( gdImagePtr im , int x , int y , int border , int color ) <S2SV_EndBug> { int lastBorder ; <S2SV_StartBug> int leftLimit , rightLimit ; <S2SV_EndBug> int i ; <S2SV_StartBug> leftLimit = ( - 1 ) ; <S2SV_EndBug> if ( border < 0 ) { return ; } <S2SV_StartBug> for ( i = x ; ( i >= 0 ) ; i -- ) <S2SV_EndBug> { if ( gdImageGetPixel ( im , i , y ) == border ) { break ; } gdImageSetPixel ( im , i , y , color ) ; leftLimit = i ; } <S2SV_StartBug> if ( leftLimit == ( - 1 ) ) <S2SV_EndBug> { return ; } rightLimit = x ; <S2SV_StartBug> for ( i = ( x + 1 ) ; ( i < im -> sx ) ; i ++ ) <S2SV_EndBug> { if ( gdImageGetPixel ( im , i , y ) == border ) { break ; } gdImageSetPixel ( im , i , y , color ) ; rightLimit = i ; } if ( y > 0 ) { lastBorder = 1 ; <S2SV_StartBug> for ( i = leftLimit ; ( i <= rightLimit ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int c ; c = gdImageGetPixel ( im , i , y - 1 ) ; if ( lastBorder ) { if ( ( c != border ) && ( c != color ) ) { gdImageFillToBorder ( im , i , y - 1 , border , color ) ; lastBorder = 0 ; } } else if ( ( c == border ) || ( c == color ) ) { lastBorder = 1 ; } } } if ( y < ( ( im -> sy ) - 1 ) ) { lastBorder = 1 ; <S2SV_StartBug> for ( i = leftLimit ; ( i <= rightLimit ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int c ; c = gdImageGetPixel ( im , i , y + 1 ) ; <S2SV_StartBug> if ( lastBorder ) <S2SV_EndBug> { if ( ( c != border ) && ( c != color ) ) { gdImageFillToBorder ( im , i , y + 1 , border , color ) ; lastBorder = 0 ; } } else if ( ( c == border ) || ( c == color ) ) { lastBorder = 1 ; } } } }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void <S2SV_ModStart> ; int leftLimit = - 1 <S2SV_ModStart> int i ; <S2SV_ModEnd> if ( border <S2SV_ModStart> return ; } if ( x >= im -> sx ) { x = im -> sx - 1 ; } if ( y >= im -> sy ) { y = im -> sy - 1 ; } <S2SV_ModStart> = x ; <S2SV_ModEnd> i >= 0 <S2SV_ModStart> i >= 0 <S2SV_ModEnd> ; i -- <S2SV_ModStart> ( leftLimit == - 1 ) <S2SV_ModEnd> { return ; <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> i < im <S2SV_ModStart> im -> sx <S2SV_ModEnd> ; i ++ <S2SV_ModStart> = leftLimit ; <S2SV_ModEnd> i <= rightLimit <S2SV_ModStart> i <= rightLimit <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ ) { int <S2SV_ModEnd> c = gdImageGetPixel <S2SV_ModStart> = leftLimit ; <S2SV_ModEnd> i <= rightLimit <S2SV_ModStart> i <= rightLimit <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ ) { int <S2SV_ModEnd> c = gdImageGetPixel <S2SV_ModStart> 1 ) ; if ( lastBorder ) <S2SV_ModEnd> { if ("}
{"source": "CWE-787 raptor_xml_writer_start_element_common ( raptor_xml_writer * xml_writer , raptor_xml_element * element , int auto_empty ) { raptor_iostream * iostr = xml_writer -> iostr ; raptor_namespace_stack * nstack = xml_writer -> nstack ; int depth = xml_writer -> depth ; int auto_indent = XML_WRITER_AUTO_INDENT ( xml_writer ) ; struct nsd * nspace_declarations = NULL ; size_t nspace_declarations_count = 0 ; unsigned int i ; if ( nstack ) { <S2SV_StartBug> int nspace_max_count = element -> attribute_count + 1 ; <S2SV_EndBug> if ( element -> declared_nspaces ) nspace_max_count += raptor_sequence_size ( element -> declared_nspaces ) ; if ( element -> xml_language ) nspace_max_count ++ ; nspace_declarations = RAPTOR_CALLOC ( struct nsd * , nspace_max_count , sizeof ( struct nsd ) ) ; if ( ! nspace_declarations ) return 1 ; } if ( element -> name -> nspace ) { if ( nstack && ! raptor_namespaces_namespace_in_scope ( nstack , element -> name -> nspace ) ) { nspace_declarations [ 0 ] . declaration = raptor_namespace_format_as_xml ( element -> name -> nspace , & nspace_declarations [ 0 ] . length ) ; if ( ! nspace_declarations [ 0 ] . declaration ) goto error ; nspace_declarations [ 0 ] . nspace = element -> name -> nspace ; nspace_declarations_count ++ ; } } if ( nstack && element -> attributes ) { for ( i = 0 ; i < element -> attribute_count ; i ++ ) { if ( element -> attributes [ i ] -> nspace ) { if ( nstack && ! raptor_namespaces_namespace_in_scope ( nstack , element -> attributes [ i ] -> nspace ) && element -> attributes [ i ] -> nspace != element -> name -> nspace ) { unsigned int j ; int declare_me = 1 ; for ( j = 0 ; j < nspace_declarations_count ; j ++ ) if ( nspace_declarations [ j ] . nspace == element -> attributes [ j ] -> nspace ) { declare_me = 0 ; break ; } if ( declare_me ) { nspace_declarations [ nspace_declarations_count ] . declaration = raptor_namespace_format_as_xml ( element -> attributes [ i ] -> nspace , & nspace_declarations [ nspace_declarations_count ] . length ) ; if ( ! nspace_declarations [ nspace_declarations_count ] . declaration ) goto error ; nspace_declarations [ nspace_declarations_count ] . nspace = element -> attributes [ i ] -> nspace ; nspace_declarations_count ++ ; } } } nspace_declarations [ nspace_declarations_count ] . declaration = raptor_qname_format_as_xml ( element -> attributes [ i ] , & nspace_declarations [ nspace_declarations_count ] . length ) ; if ( ! nspace_declarations [ nspace_declarations_count ] . declaration ) goto error ; nspace_declarations [ nspace_declarations_count ] . nspace = NULL ; nspace_declarations_count ++ ; } } if ( nstack && element -> declared_nspaces && raptor_sequence_size ( element -> declared_nspaces ) > 0 ) { for ( i = 0 ; i < ( unsigned int ) raptor_sequence_size ( element -> declared_nspaces ) ; i ++ ) { raptor_namespace * nspace = ( raptor_namespace * ) raptor_sequence_get_at ( element -> declared_nspaces , i ) ; unsigned int j ; int declare_me = 1 ; for ( j = 0 ; j < nspace_declarations_count ; j ++ ) if ( nspace_declarations [ j ] . nspace == nspace ) { declare_me = 0 ; break ; } if ( declare_me ) { nspace_declarations [ nspace_declarations_count ] . declaration = raptor_namespace_format_as_xml ( nspace , & nspace_declarations [ nspace_declarations_count ] . length ) ; if ( ! nspace_declarations [ nspace_declarations_count ] . declaration ) goto error ; nspace_declarations [ nspace_declarations_count ] . nspace = nspace ; nspace_declarations_count ++ ; } } } if ( nstack && element -> xml_language ) { size_t lang_len = strlen ( RAPTOR_GOOD_CAST ( char * , element -> xml_language ) ) ; # define XML_LANG_PREFIX_LEN 10 size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1 ; unsigned char * buffer = RAPTOR_MALLOC ( unsigned char * , buf_length + 1 ) ; const char quote = \\'\\\\\"\\' ; unsigned char * p ; memcpy ( buffer , \"xml:lang=\\\\\"\" , XML_LANG_PREFIX_LEN ) ; p = buffer + XML_LANG_PREFIX_LEN ; p += raptor_xml_escape_string ( xml_writer -> world , element -> xml_language , lang_len , p , buf_length , quote ) ; * p ++ = quote ; * p = '\\\\0' ; nspace_declarations [ nspace_declarations_count ] . declaration = buffer ; nspace_declarations [ nspace_declarations_count ] . length = buf_length ; nspace_declarations [ nspace_declarations_count ] . nspace = NULL ; nspace_declarations_count ++ ; } raptor_iostream_write_byte ( '<' , iostr ) ; if ( element -> name -> nspace && element -> name -> nspace -> prefix_length > 0 ) { raptor_iostream_counted_string_write ( ( const char * ) element -> name -> nspace -> prefix , element -> name -> nspace -> prefix_length , iostr ) ; raptor_iostream_write_byte ( ':' , iostr ) ; } raptor_iostream_counted_string_write ( ( const char * ) element -> name -> local_name , element -> name -> local_name_length , iostr ) ; if ( nspace_declarations_count ) { int need_indent = 0 ; qsort ( ( void * ) nspace_declarations , nspace_declarations_count , sizeof ( struct nsd ) , raptor_xml_writer_nsd_compare ) ; for ( i = 0 ; i < nspace_declarations_count ; i ++ ) { if ( ! nspace_declarations [ i ] . nspace ) continue ; if ( auto_indent && need_indent ) { raptor_xml_writer_newline ( xml_writer ) ; xml_writer -> depth ++ ; raptor_xml_writer_indent ( xml_writer ) ; xml_writer -> depth -- ; } raptor_iostream_write_byte ( '<S2SV_blank>' , iostr ) ; raptor_iostream_counted_string_write ( ( const char * ) nspace_declarations [ i ] . declaration , nspace_declarations [ i ] . length , iostr ) ; RAPTOR_FREE ( char * , nspace_declarations [ i ] . declaration ) ; nspace_declarations [ i ] . declaration = NULL ; need_indent = 1 ; if ( raptor_namespace_stack_start_namespace ( nstack , ( raptor_namespace * ) nspace_declarations [ i ] . nspace , depth ) ) goto error ; } for ( i = 0 ; i < nspace_declarations_count ; i ++ ) { if ( nspace_declarations [ i ] . nspace ) continue ; if ( auto_indent && need_indent ) { raptor_xml_writer_newline ( xml_writer ) ; xml_writer -> depth ++ ; raptor_xml_writer_indent ( xml_writer ) ; xml_writer -> depth -- ; } raptor_iostream_write_byte ( '<S2SV_blank>' , iostr ) ; raptor_iostream_counted_string_write ( ( const char * ) nspace_declarations [ i ] . declaration , nspace_declarations [ i ] . length , iostr ) ; need_indent = 1 ; RAPTOR_FREE ( char * , nspace_declarations [ i ] . declaration ) ; nspace_declarations [ i ] . declaration = NULL ; } } if ( ! auto_empty ) raptor_iostream_write_byte ( '>' , iostr ) ; if ( nstack ) RAPTOR_FREE ( stringarray , nspace_declarations ) ; return 0 ; error : for ( i = 0 ; i < nspace_declarations_count ; i ++ ) { if ( nspace_declarations [ i ] . declaration ) RAPTOR_FREE ( char * , nspace_declarations [ i ] . declaration ) ; } RAPTOR_FREE ( stringarray , nspace_declarations ) ; return 1 ; }", "target": "<S2SV_ModStart> element -> attribute_count * 2 ; if ( element -> name -> nspace ) nspace_max_count ++ <S2SV_ModEnd> ; if ("}
{"source": "CWE-703 static int nft_verdict_init ( const struct nft_ctx * ctx , struct nft_data * data , struct nft_data_desc * desc , const struct nlattr * nla ) { u8 genmask = nft_genmask_next ( ctx -> net ) ; struct nlattr * tb [ NFTA_VERDICT_MAX + 1 ] ; struct nft_chain * chain ; int err ; err = nla_parse_nested_deprecated ( tb , NFTA_VERDICT_MAX , nla , nft_verdict_policy , NULL ) ; if ( err < 0 ) return err ; if ( ! tb [ NFTA_VERDICT_CODE ] ) return - EINVAL ; data -> verdict . code = ntohl ( nla_get_be32 ( tb [ NFTA_VERDICT_CODE ] ) ) ; switch ( data -> verdict . code ) { default : switch ( data -> verdict . code & NF_VERDICT_MASK ) { case NF_ACCEPT : case NF_DROP : case NF_QUEUE : break ; default : return - EINVAL ; } fallthrough ; case NFT_CONTINUE : case NFT_BREAK : case NFT_RETURN : break ; case NFT_JUMP : case NFT_GOTO : if ( tb [ NFTA_VERDICT_CHAIN ] ) { chain = nft_chain_lookup ( ctx -> net , ctx -> table , tb [ NFTA_VERDICT_CHAIN ] , genmask ) ; } else if ( tb [ NFTA_VERDICT_CHAIN_ID ] ) { chain = nft_chain_lookup_byid ( ctx -> net , ctx -> table , tb [ NFTA_VERDICT_CHAIN_ID ] ) ; if ( IS_ERR ( chain ) ) return PTR_ERR ( chain ) ; } else { return - EINVAL ; } if ( IS_ERR ( chain ) ) return PTR_ERR ( chain ) ; if ( nft_is_base_chain ( chain ) ) return - EOPNOTSUPP ; <S2SV_StartBug> if ( desc -> flags & NFT_DATA_DESC_SETELEM && <S2SV_EndBug> chain -> flags & NFT_CHAIN_BINDING ) return - EINVAL ; chain -> use ++ ; data -> verdict . chain = chain ; break ; } desc -> len = sizeof ( data -> verdict ) ; return 0 ; }", "target": "<S2SV_ModStart> ; if ( nft_chain_is_bound ( chain ) ) return - EINVAL ; if ("}
{"source": "CWE-924 negotiate_handshake_newstyle_options ( void ) { GET_CONN ; struct nbd_new_option new_option ; size_t nr_options ; bool list_seen = false ; uint64_t version ; uint32_t option ; uint32_t optlen ; struct nbd_export_name_option_reply handshake_finish ; const char * optname ; uint64_t exportsize ; struct backend * b ; for ( nr_options = MAX_NR_OPTIONS ; nr_options > 0 ; -- nr_options ) { CLEANUP_FREE char * data = NULL ; if ( conn_recv_full ( & new_option , sizeof new_option , \"reading<S2SV_blank>option:<S2SV_blank>conn->recv:<S2SV_blank>%m\" ) == - 1 ) return - 1 ; version = be64toh ( new_option . version ) ; if ( version != NBD_NEW_VERSION ) { nbdkit_error ( \"unknown<S2SV_blank>option<S2SV_blank>version<S2SV_blank>%\" PRIx64 \",<S2SV_blank>expecting<S2SV_blank>%\" PRIx64 , version , NBD_NEW_VERSION ) ; return - 1 ; } optlen = be32toh ( new_option . optlen ) ; if ( optlen > MAX_REQUEST_SIZE ) { nbdkit_error ( \"client<S2SV_blank>option<S2SV_blank>data<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%\" PRIu32 \")\" , optlen ) ; return - 1 ; } data = malloc ( optlen + 1 ) ; if ( data == NULL ) { nbdkit_error ( \"malloc:<S2SV_blank>%m\" ) ; return - 1 ; } option = be32toh ( new_option . option ) ; optname = name_of_nbd_opt ( option ) ; if ( ! ( conn -> cflags & NBD_FLAG_FIXED_NEWSTYLE ) && option != NBD_OPT_EXPORT_NAME ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) ) return - 1 ; continue ; } if ( tls == 2 && ! conn -> using_tls && ! ( option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS ) ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_TLS_REQD ) ) return - 1 ; continue ; } switch ( option ) { case NBD_OPT_EXPORT_NAME : if ( conn_recv_full ( data , optlen , \"read:<S2SV_blank>%s:<S2SV_blank>%m\" , name_of_nbd_opt ( option ) ) == - 1 ) return - 1 ; if ( check_export_name ( option , data , optlen , optlen ) == - 1 ) return - 1 ; if ( finish_newstyle_options ( & exportsize , data , optlen ) == - 1 ) return - 1 ; memset ( & handshake_finish , 0 , sizeof handshake_finish ) ; handshake_finish . exportsize = htobe64 ( exportsize ) ; handshake_finish . eflags = htobe16 ( conn -> eflags ) ; if ( conn -> send ( & handshake_finish , ( conn -> cflags & NBD_FLAG_NO_ZEROES ) ? offsetof ( struct nbd_export_name_option_reply , zeroes ) : sizeof handshake_finish , 0 ) == - 1 ) { nbdkit_error ( \"write:<S2SV_blank>%s:<S2SV_blank>%m\" , optname ) ; return - 1 ; } break ; case NBD_OPT_ABORT : if ( send_newstyle_option_reply ( option , NBD_REP_ACK ) == - 1 ) return - 1 ; debug ( \"client<S2SV_blank>sent<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>abort<S2SV_blank>the<S2SV_blank>connection\" , name_of_nbd_opt ( option ) ) ; return - 1 ; case NBD_OPT_LIST : if ( optlen != 0 ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; if ( conn_recv_full ( data , optlen , \"read:<S2SV_blank>%s:<S2SV_blank>%m\" , name_of_nbd_opt ( option ) ) == - 1 ) return - 1 ; continue ; } if ( list_seen ) { debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>export<S2SV_blank>list<S2SV_blank>already<S2SV_blank>advertised\" , name_of_nbd_opt ( option ) ) ; if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } else { debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>advertising<S2SV_blank>exports\" , name_of_nbd_opt ( option ) ) ; if ( send_newstyle_option_reply_exportnames ( option , & nr_options ) == - 1 ) return - 1 ; list_seen = true ; } break ; case NBD_OPT_STARTTLS : if ( optlen != 0 ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; if ( conn_recv_full ( data , optlen , \"read:<S2SV_blank>%s:<S2SV_blank>%m\" , name_of_nbd_opt ( option ) ) == - 1 ) return - 1 ; continue ; } if ( tls == 0 ) { # ifdef HAVE_GNUTLS # define NO_TLS_REPLY NBD_REP_ERR_POLICY # else # define NO_TLS_REPLY NBD_REP_ERR_UNSUP # endif if ( send_newstyle_option_reply ( option , NO_TLS_REPLY ) == - 1 ) return - 1 ; } else { if ( conn -> using_tls ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } if ( send_newstyle_option_reply ( option , NBD_REP_ACK ) == - 1 ) return - 1 ; if ( crypto_negotiate_tls ( conn -> sockin , conn -> sockout ) == - 1 ) return - 1 ; conn -> using_tls = true ; debug ( \"using<S2SV_blank>TLS<S2SV_blank>on<S2SV_blank>this<S2SV_blank>connection\" ) ; <S2SV_StartBug> conn -> structured_replies = false ; <S2SV_EndBug> for_each_backend ( b ) { free ( conn -> default_exportname [ b -> i ] ) ; conn -> default_exportname [ b -> i ] = NULL ; } } break ; case NBD_OPT_INFO : case NBD_OPT_GO : if ( conn_recv_full ( data , optlen , \"read:<S2SV_blank>%s:<S2SV_blank>%m\" , optname ) == - 1 ) return - 1 ; if ( optlen < 6 ) { debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>length<S2SV_blank><<S2SV_blank>6\" , optname ) ; if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } { uint32_t exportnamelen ; uint16_t nrinfos ; uint16_t info ; size_t i ; memcpy ( & exportnamelen , & data [ 0 ] , 4 ) ; exportnamelen = be32toh ( exportnamelen ) ; if ( exportnamelen > optlen - 6 ) { debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>export<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\" , optname ) ; if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } memcpy ( & nrinfos , & data [ exportnamelen + 4 ] , 2 ) ; nrinfos = be16toh ( nrinfos ) ; if ( optlen != 4 + exportnamelen + 2 + 2 * nrinfos ) { debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>\" \"number<S2SV_blank>of<S2SV_blank>information<S2SV_blank>requests<S2SV_blank>incorrect\" , optname ) ; if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } if ( check_export_name ( option , & data [ 4 ] , exportnamelen , optlen - 6 ) == - 1 ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } if ( finish_newstyle_options ( & exportsize , & data [ 4 ] , exportnamelen ) == - 1 ) { if ( conn -> top_context ) { if ( backend_finalize ( conn -> top_context ) == - 1 ) return - 1 ; backend_close ( conn -> top_context ) ; conn -> top_context = NULL ; } if ( send_newstyle_option_reply ( option , NBD_REP_ERR_UNKNOWN ) == - 1 ) return - 1 ; continue ; } if ( send_newstyle_option_reply_info_export ( option , NBD_REP_INFO , NBD_INFO_EXPORT , exportsize ) == - 1 ) return - 1 ; for ( i = 0 ; i < nrinfos ; ++ i ) { memcpy ( & info , & data [ 4 + exportnamelen + 2 + i * 2 ] , 2 ) ; info = be16toh ( info ) ; switch ( info ) { case NBD_INFO_EXPORT : break ; case NBD_INFO_NAME : { const char * name = & data [ 4 ] ; size_t namelen = exportnamelen ; if ( exportnamelen == 0 ) { name = backend_default_export ( top , read_only ) ; if ( ! name ) { debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>\" \"NBD_INFO_NAME:<S2SV_blank>no<S2SV_blank>name<S2SV_blank>to<S2SV_blank>send\" , optname ) ; break ; } namelen = - 1 ; } if ( send_newstyle_option_reply_info_str ( option , NBD_REP_INFO , NBD_INFO_NAME , name , namelen ) == - 1 ) return - 1 ; } break ; case NBD_INFO_DESCRIPTION : { const char * desc = backend_export_description ( conn -> top_context ) ; if ( ! desc ) { debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>\" \"NBD_INFO_DESCRIPTION:<S2SV_blank>no<S2SV_blank>description<S2SV_blank>to<S2SV_blank>send\" , optname ) ; break ; } if ( send_newstyle_option_reply_info_str ( option , NBD_REP_INFO , NBD_INFO_DESCRIPTION , desc , - 1 ) == - 1 ) return - 1 ; } break ; default : debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>\" \"ignoring<S2SV_blank>NBD_INFO_*<S2SV_blank>request<S2SV_blank>%u<S2SV_blank>(%s)\" , optname , ( unsigned ) info , name_of_nbd_info ( info ) ) ; break ; } } } if ( send_newstyle_option_reply ( option , NBD_REP_ACK ) == - 1 ) return - 1 ; if ( option == NBD_OPT_INFO ) { if ( backend_finalize ( conn -> top_context ) == - 1 ) return - 1 ; backend_close ( conn -> top_context ) ; conn -> top_context = NULL ; } break ; case NBD_OPT_STRUCTURED_REPLY : if ( optlen != 0 ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; if ( conn_recv_full ( data , optlen , \"read:<S2SV_blank>%s:<S2SV_blank>%m\" , name_of_nbd_opt ( option ) ) == - 1 ) return - 1 ; continue ; } debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>client<S2SV_blank>requested<S2SV_blank>structured<S2SV_blank>replies\" , name_of_nbd_opt ( option ) ) ; if ( no_sr ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_UNSUP ) == - 1 ) return - 1 ; debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>structured<S2SV_blank>replies<S2SV_blank>are<S2SV_blank>disabled\" , name_of_nbd_opt ( option ) ) ; break ; } if ( send_newstyle_option_reply ( option , NBD_REP_ACK ) == - 1 ) return - 1 ; conn -> structured_replies = true ; break ; case NBD_OPT_LIST_META_CONTEXT : case NBD_OPT_SET_META_CONTEXT : { uint32_t opt_index ; uint32_t exportnamelen ; uint32_t nr_queries ; uint32_t querylen ; const char * what ; if ( conn_recv_full ( data , optlen , \"read:<S2SV_blank>%s:<S2SV_blank>%m\" , optname ) == - 1 ) return - 1 ; if ( ! conn -> structured_replies ) { if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } what = \"optlen<S2SV_blank><<S2SV_blank>8\" ; if ( optlen < 8 ) { opt_meta_invalid_option_len : debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>length:<S2SV_blank>%s\" , optname , what ) ; if ( send_newstyle_option_reply ( option , NBD_REP_ERR_INVALID ) == - 1 ) return - 1 ; continue ; } memcpy ( & exportnamelen , & data [ 0 ] , 4 ) ; exportnamelen = be32toh ( exportnamelen ) ; what = \"validating<S2SV_blank>export<S2SV_blank>name\" ; if ( check_export_name ( option , & data [ 4 ] , exportnamelen , optlen - 8 ) == - 1 ) goto opt_meta_invalid_option_len ; if ( option == NBD_OPT_SET_META_CONTEXT ) { conn -> exportname_from_set_meta_context = strndup ( & data [ 4 ] , exportnamelen ) ; if ( conn -> exportname_from_set_meta_context == NULL ) { nbdkit_error ( \"malloc:<S2SV_blank>%m\" ) ; return - 1 ; } } opt_index = 4 + exportnamelen ; what = \"reading<S2SV_blank>number<S2SV_blank>of<S2SV_blank>queries\" ; if ( opt_index + 4 > optlen ) goto opt_meta_invalid_option_len ; memcpy ( & nr_queries , & data [ opt_index ] , 4 ) ; nr_queries = be32toh ( nr_queries ) ; opt_index += 4 ; debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>%s<S2SV_blank>count:<S2SV_blank>%d\" , optname , option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\" , nr_queries ) ; if ( option == NBD_OPT_SET_META_CONTEXT ) conn -> meta_context_base_allocation = false ; if ( nr_queries == 0 ) { if ( option == NBD_OPT_LIST_META_CONTEXT ) { if ( send_newstyle_option_reply_meta_context ( option , NBD_REP_META_CONTEXT , 0 , \"base:allocation\" ) == - 1 ) return - 1 ; } if ( send_newstyle_option_reply ( option , NBD_REP_ACK ) == - 1 ) return - 1 ; } else { while ( nr_queries > 0 ) { what = \"reading<S2SV_blank>query<S2SV_blank>string<S2SV_blank>length\" ; if ( opt_index + 4 > optlen ) goto opt_meta_invalid_option_len ; memcpy ( & querylen , & data [ opt_index ] , 4 ) ; querylen = be32toh ( querylen ) ; opt_index += 4 ; what = \"reading<S2SV_blank>query<S2SV_blank>string\" ; if ( check_string ( option , & data [ opt_index ] , querylen , optlen - opt_index , \"meta<S2SV_blank>context<S2SV_blank>query\" ) == - 1 ) goto opt_meta_invalid_option_len ; debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>%s<S2SV_blank>%.*s\" , optname , option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\" , ( int ) querylen , & data [ opt_index ] ) ; if ( option == NBD_OPT_LIST_META_CONTEXT && querylen == 5 && strncmp ( & data [ opt_index ] , \"base:\" , 5 ) == 0 ) { if ( send_newstyle_option_reply_meta_context ( option , NBD_REP_META_CONTEXT , 0 , \"base:allocation\" ) == - 1 ) return - 1 ; } else if ( querylen == 15 && strncmp ( & data [ opt_index ] , \"base:allocation\" , 15 ) == 0 ) { if ( send_newstyle_option_reply_meta_context ( option , NBD_REP_META_CONTEXT , option == NBD_OPT_SET_META_CONTEXT ? base_allocation_id : 0 , \"base:allocation\" ) == - 1 ) return - 1 ; if ( option == NBD_OPT_SET_META_CONTEXT ) conn -> meta_context_base_allocation = true ; } opt_index += querylen ; nr_queries -- ; } if ( send_newstyle_option_reply ( option , NBD_REP_ACK ) == - 1 ) return - 1 ; } debug ( \"newstyle<S2SV_blank>negotiation:<S2SV_blank>%s:<S2SV_blank>reply<S2SV_blank>complete\" , optname ) ; } break ; default : if ( send_newstyle_option_reply ( option , NBD_REP_ERR_UNSUP ) == - 1 ) return - 1 ; if ( conn_recv_full ( data , optlen , \"reading<S2SV_blank>unknown<S2SV_blank>option<S2SV_blank>data:<S2SV_blank>conn->recv:<S2SV_blank>%m\" ) == - 1 ) return - 1 ; } if ( option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO ) break ; } if ( nr_options == 0 ) { nbdkit_error ( \"client<S2SV_blank>spent<S2SV_blank>too<S2SV_blank>much<S2SV_blank>time<S2SV_blank>negotiating<S2SV_blank>without<S2SV_blank>selecting<S2SV_blank>\" \"an<S2SV_blank>export\" ) ; return - 1 ; } if ( tls == 2 && ! conn -> using_tls ) { nbdkit_error ( \"non-TLS<S2SV_blank>client<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>in<S2SV_blank>--tls=require<S2SV_blank>mode\" ) ; return - 1 ; } return 0 ; }", "target": "<S2SV_ModStart> conn -> structured_replies = false ; free ( conn -> exportname_from_set_meta_context ) ; conn -> exportname_from_set_meta_context = NULL ; conn -> meta_context_base_allocation"}
{"source": "CWE-122 update_topline ( void ) { long line_count ; int halfheight ; int n ; linenr_T old_topline ; # ifdef FEAT_DIFF int old_topfill ; # endif # ifdef FEAT_FOLDING linenr_T lnum ; # endif int check_topline = FALSE ; int check_botline = FALSE ; long * so_ptr = curwin -> w_p_so >= 0 ? & curwin -> w_p_so : & p_so ; int save_so = * so_ptr ; if ( ! screen_valid ( TRUE ) || curwin -> w_height == 0 ) { check_cursor_lnum ( ) ; curwin -> w_topline = curwin -> w_cursor . lnum ; curwin -> w_botline = curwin -> w_topline ; <S2SV_StartBug> curwin -> w_valid |= VALID_BOTLINE | VALID_BOTLINE_AP ; <S2SV_EndBug> curwin -> w_scbind_pos = 1 ; <S2SV_StartBug> return ; <S2SV_EndBug> } check_cursor_moved ( curwin ) ; if ( curwin -> w_valid & VALID_TOPLINE ) return ; if ( mouse_dragging > 0 ) * so_ptr = mouse_dragging - 1 ; old_topline = curwin -> w_topline ; # ifdef FEAT_DIFF old_topfill = curwin -> w_topfill ; # endif if ( BUFEMPTY ( ) ) { if ( curwin -> w_topline != 1 ) redraw_later ( NOT_VALID ) ; curwin -> w_topline = 1 ; curwin -> w_botline = 2 ; curwin -> w_valid |= VALID_BOTLINE | VALID_BOTLINE_AP ; curwin -> w_scbind_pos = 1 ; } else { if ( curwin -> w_topline > 1 ) { if ( curwin -> w_cursor . lnum < curwin -> w_topline ) check_topline = TRUE ; else if ( check_top_offset ( ) ) check_topline = TRUE ; } # ifdef FEAT_DIFF if ( ! check_topline && curwin -> w_topfill > diff_check_fill ( curwin , curwin -> w_topline ) ) check_topline = TRUE ; # endif if ( check_topline ) { halfheight = curwin -> w_height / 2 - 1 ; if ( halfheight < 2 ) halfheight = 2 ; # ifdef FEAT_FOLDING if ( hasAnyFolding ( curwin ) ) { n = 0 ; for ( lnum = curwin -> w_cursor . lnum ; lnum < curwin -> w_topline + * so_ptr ; ++ lnum ) { ++ n ; if ( lnum >= curbuf -> b_ml . ml_line_count || n >= halfheight ) break ; ( void ) hasFolding ( lnum , NULL , & lnum ) ; } } else # endif n = curwin -> w_topline + * so_ptr - curwin -> w_cursor . lnum ; if ( n >= halfheight ) scroll_cursor_halfway ( FALSE ) ; else { scroll_cursor_top ( scrolljump_value ( ) , FALSE ) ; check_botline = TRUE ; } } else { # ifdef FEAT_FOLDING ( void ) hasFolding ( curwin -> w_topline , & curwin -> w_topline , NULL ) ; # endif check_botline = TRUE ; } } if ( check_botline ) { if ( ! ( curwin -> w_valid & VALID_BOTLINE_AP ) ) validate_botline ( ) ; if ( curwin -> w_botline <= curbuf -> b_ml . ml_line_count ) { if ( curwin -> w_cursor . lnum < curwin -> w_botline ) { if ( ( ( long ) curwin -> w_cursor . lnum >= ( long ) curwin -> w_botline - * so_ptr # ifdef FEAT_FOLDING || hasAnyFolding ( curwin ) # endif ) ) { lineoff_T loff ; n = curwin -> w_empty_rows ; loff . lnum = curwin -> w_cursor . lnum ; # ifdef FEAT_FOLDING ( void ) hasFolding ( loff . lnum , NULL , & loff . lnum ) ; # endif # ifdef FEAT_DIFF loff . fill = 0 ; n += curwin -> w_filler_rows ; # endif loff . height = 0 ; while ( loff . lnum < curwin -> w_botline # ifdef FEAT_DIFF && ( loff . lnum + 1 < curwin -> w_botline || loff . fill == 0 ) # endif ) { n += loff . height ; if ( n >= * so_ptr ) break ; botline_forw ( & loff ) ; } if ( n >= * so_ptr ) check_botline = FALSE ; } else check_botline = FALSE ; } if ( check_botline ) { # ifdef FEAT_FOLDING if ( hasAnyFolding ( curwin ) ) { line_count = 0 ; for ( lnum = curwin -> w_cursor . lnum ; lnum >= curwin -> w_botline - * so_ptr ; -- lnum ) { ++ line_count ; if ( lnum <= 0 || line_count > curwin -> w_height + 1 ) break ; ( void ) hasFolding ( lnum , & lnum , NULL ) ; } } else # endif line_count = curwin -> w_cursor . lnum - curwin -> w_botline + 1 + * so_ptr ; if ( line_count <= curwin -> w_height + 1 ) scroll_cursor_bot ( scrolljump_value ( ) , FALSE ) ; else scroll_cursor_halfway ( FALSE ) ; } } } curwin -> w_valid |= VALID_TOPLINE ; if ( curwin -> w_topline != old_topline # ifdef FEAT_DIFF || curwin -> w_topfill != old_topfill # endif ) { dollar_vcol = - 1 ; if ( curwin -> w_skipcol != 0 ) { curwin -> w_skipcol = 0 ; redraw_later ( NOT_VALID ) ; } else redraw_later ( VALID ) ; if ( curwin -> w_cursor . lnum == curwin -> w_topline ) validate_cursor ( ) ; } * so_ptr = save_so ; }", "target": "<S2SV_ModStart> ; curwin -> w_scbind_pos = 1 ; return ; } check_cursor_moved ( curwin ) ; if ( curwin -> w_valid & VALID_TOPLINE ) return ; if ( mouse_dragging > 0 ) * so_ptr = mouse_dragging - 1 ; old_topline = curwin -> w_topline ; # ifdef FEAT_DIFF old_topfill = curwin -> w_topfill ; # endif if ( BUFEMPTY ( ) ) { if ( curwin -> w_topline != 1 ) redraw_later ( NOT_VALID ) ; curwin -> w_topline = 1 ; curwin -> w_botline = 2 ; curwin -> <S2SV_ModStart> = 1 ; <S2SV_ModEnd> } else {"}
{"source": "CWE-703 unix_expandpath ( garray_T * gap , char_u * path , int wildoff , int flags , int didstar ) { char_u * buf ; char_u * path_end ; char_u * p , * s , * e ; int start_len = gap -> ga_len ; char_u * pat ; regmatch_T regmatch ; int starts_with_dot ; int matches ; int len ; int starstar = FALSE ; static int stardepth = 0 ; DIR * dirp ; struct dirent * dp ; if ( stardepth > 0 ) { ui_breakcheck ( ) ; if ( got_int ) return 0 ; } buf = alloc ( STRLEN ( path ) + BASENAMELEN + 5 ) ; if ( buf == NULL ) return 0 ; p = buf ; s = buf ; e = NULL ; path_end = path ; while ( * path_end != NUL ) { if ( path_end >= path + wildoff && rem_backslash ( path_end ) ) * p ++ = * path_end ++ ; else if ( * path_end == '/' ) { if ( e != NULL ) break ; s = p + 1 ; } else if ( path_end >= path + wildoff && ( vim_strchr ( ( char_u * ) \"*?[{~$\" , * path_end ) != NULL || ( ! p_fic && ( flags & EW_ICASE ) <S2SV_StartBug> && isalpha ( PTR2CHAR ( path_end ) ) ) ) ) <S2SV_EndBug> e = p ; if ( has_mbyte ) { len = ( * mb_ptr2len ) ( path_end ) ; STRNCPY ( p , path_end , len ) ; p += len ; path_end += len ; } else * p ++ = * path_end ++ ; } e = p ; * e = NUL ; for ( p = buf + wildoff ; p < s ; ++ p ) if ( rem_backslash ( p ) ) { STRMOVE ( p , p + 1 ) ; -- e ; -- s ; } for ( p = s ; p < e ; ++ p ) if ( p [ 0 ] == '*' && p [ 1 ] == '*' ) starstar = TRUE ; starts_with_dot = * s == '.' ; pat = file_pat_to_reg_pat ( s , e , NULL , FALSE ) ; if ( pat == NULL ) { vim_free ( buf ) ; return 0 ; } if ( flags & EW_ICASE ) regmatch . rm_ic = TRUE ; else regmatch . rm_ic = p_fic ; if ( flags & ( EW_NOERROR | EW_NOTWILD ) ) ++ emsg_silent ; regmatch . regprog = vim_regcomp ( pat , RE_MAGIC ) ; if ( flags & ( EW_NOERROR | EW_NOTWILD ) ) -- emsg_silent ; vim_free ( pat ) ; if ( regmatch . regprog == NULL && ( flags & EW_NOTWILD ) == 0 ) { vim_free ( buf ) ; return 0 ; } if ( ! didstar && stardepth < 100 && starstar && e - s == 2 && * path_end == '/' ) { STRCPY ( s , path_end + 1 ) ; ++ stardepth ; ( void ) unix_expandpath ( gap , buf , ( int ) ( s - buf ) , flags , TRUE ) ; -- stardepth ; } * s = NUL ; dirp = opendir ( * buf == NUL ? \".\" : ( char * ) buf ) ; if ( dirp != NULL ) { for ( ; ; ) { dp = readdir ( dirp ) ; if ( dp == NULL ) break ; if ( ( dp -> d_name [ 0 ] != '.' || starts_with_dot || ( ( flags & EW_DODOT ) && dp -> d_name [ 1 ] != NUL && ( dp -> d_name [ 1 ] != '.' || dp -> d_name [ 2 ] != NUL ) ) ) && ( ( regmatch . regprog != NULL && vim_regexec ( & regmatch , ( char_u * ) dp -> d_name , ( colnr_T ) 0 ) ) || ( ( flags & EW_NOTWILD ) && fnamencmp ( path + ( s - buf ) , dp -> d_name , e - s ) == 0 ) ) ) { STRCPY ( s , dp -> d_name ) ; len = STRLEN ( buf ) ; if ( starstar && stardepth < 100 ) { STRCPY ( buf + len , \"/**\" ) ; STRCPY ( buf + len + 3 , path_end ) ; ++ stardepth ; ( void ) unix_expandpath ( gap , buf , len + 1 , flags , TRUE ) ; -- stardepth ; } STRCPY ( buf + len , path_end ) ; if ( mch_has_exp_wildcard ( path_end ) ) { ( void ) unix_expandpath ( gap , buf , len + 1 , flags , FALSE ) ; } else { stat_T sb ; if ( * path_end != NUL ) backslash_halve ( buf + len + 1 ) ; if ( ( flags & EW_ALLLINKS ) ? mch_lstat ( ( char * ) buf , & sb ) >= 0 : mch_getperm ( buf ) >= 0 ) { # ifdef MACOS_CONVERT size_t precomp_len = STRLEN ( buf ) + 1 ; char_u * precomp_buf = mac_precompose_path ( buf , precomp_len , & precomp_len ) ; if ( precomp_buf ) { mch_memmove ( buf , precomp_buf , precomp_len ) ; vim_free ( precomp_buf ) ; } # endif addfile ( gap , buf , flags ) ; } } } } closedir ( dirp ) ; } vim_free ( buf ) ; vim_regfree ( regmatch . regprog ) ; matches = gap -> ga_len - start_len ; if ( matches > 0 ) qsort ( ( ( char_u * * ) gap -> ga_data ) + start_len , matches , sizeof ( char_u * ) , pstrcmp ) ; return matches ; }", "target": "<S2SV_ModStart> EW_ICASE ) && vim_isalpha <S2SV_ModEnd> ( PTR2CHAR ("}
{"source": "CWE-191 bool DL_Dxf : : handleLWPolylineData ( DL_CreationInterface * ) { if ( groupCode == 90 ) { maxVertices = toInt ( groupValue ) ; if ( maxVertices > 0 ) { if ( vertices != NULL ) { delete [ ] vertices ; } vertices = new double [ 4 * maxVertices ] ; for ( int i = 0 ; i < maxVertices ; ++ i ) { vertices [ i * 4 ] = 0.0 ; vertices [ i * 4 + 1 ] = 0.0 ; vertices [ i * 4 + 2 ] = 0.0 ; vertices [ i * 4 + 3 ] = 0.0 ; } } vertexIndex = - 1 ; return true ; } else if ( groupCode == 10 || groupCode == 20 || groupCode == 30 || groupCode == 42 ) { if ( vertexIndex < maxVertices - 1 && groupCode == 10 ) { vertexIndex ++ ; } if ( groupCode <= 30 ) { <S2SV_StartBug> if ( vertexIndex >= 0 && vertexIndex < maxVertices ) { <S2SV_EndBug> vertices [ 4 * vertexIndex + ( groupCode / 10 - 1 ) ] = toReal ( groupValue ) ; } <S2SV_StartBug> } else if ( groupCode == 42 && vertexIndex < maxVertices ) { <S2SV_EndBug> vertices [ 4 * vertexIndex + 3 ] = toReal ( groupValue ) ; } return true ; } return false ; }", "target": "<S2SV_ModStart> vertexIndex < maxVertices && vertexIndex >= 0 <S2SV_ModStart> vertexIndex < maxVertices && vertexIndex >= 0"}
{"source": "CWE-476 int udf_expand_file_adinicb ( struct inode * inode ) { struct page * page ; char * kaddr ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; int err ; WARN_ON_ONCE ( ! inode_is_locked ( inode ) ) ; if ( ! iinfo -> i_lenAlloc ) { if ( UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_USE_SHORT_AD ) ) iinfo -> i_alloc_type = ICBTAG_FLAG_AD_SHORT ; else iinfo -> i_alloc_type = ICBTAG_FLAG_AD_LONG ; inode -> i_data . a_ops = & udf_aops ; up_write ( & iinfo -> i_data_sem ) ; mark_inode_dirty ( inode ) ; return 0 ; } up_write ( & iinfo -> i_data_sem ) ; page = find_or_create_page ( inode -> i_mapping , 0 , GFP_NOFS ) ; if ( ! page ) return - ENOMEM ; if ( ! PageUptodate ( page ) ) { kaddr = kmap_atomic ( page ) ; memset ( kaddr + iinfo -> i_lenAlloc , 0x00 , PAGE_SIZE - iinfo -> i_lenAlloc ) ; memcpy ( kaddr , iinfo -> i_data + iinfo -> i_lenEAttr , iinfo -> i_lenAlloc ) ; flush_dcache_page ( page ) ; SetPageUptodate ( page ) ; kunmap_atomic ( kaddr ) ; } down_write ( & iinfo -> i_data_sem ) ; memset ( iinfo -> i_data + iinfo -> i_lenEAttr , 0x00 , iinfo -> i_lenAlloc ) ; iinfo -> i_lenAlloc = 0 ; if ( UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_USE_SHORT_AD ) ) iinfo -> i_alloc_type = ICBTAG_FLAG_AD_SHORT ; else iinfo -> i_alloc_type = ICBTAG_FLAG_AD_LONG ; inode -> i_data . a_ops = & udf_aops ; set_page_dirty ( page ) ; unlock_page ( page ) ; up_write ( & iinfo -> i_data_sem ) ; err = filemap_fdatawrite ( inode -> i_mapping ) ; if ( err ) { lock_page ( page ) ; down_write ( & iinfo -> i_data_sem ) ; kaddr = kmap_atomic ( page ) ; memcpy ( iinfo -> i_data + iinfo -> i_lenEAttr , kaddr , inode -> i_size ) ; kunmap_atomic ( kaddr ) ; unlock_page ( page ) ; iinfo -> i_alloc_type = ICBTAG_FLAG_AD_IN_ICB ; inode -> i_data . a_ops = & udf_adinicb_aops ; <S2SV_StartBug> up_write ( & iinfo -> i_data_sem ) ; <S2SV_EndBug> } put_page ( page ) ; mark_inode_dirty ( inode ) ; return err ; }", "target": "<S2SV_ModStart> & udf_adinicb_aops ; iinfo -> i_lenAlloc = inode -> i_size ;"}
{"source": "CWE-125 static MagickBooleanType SetGrayscaleImage ( Image * image , ExceptionInfo * exception ) { CacheView * image_view ; MagickBooleanType status ; PixelInfo * colormap ; register ssize_t i ; ssize_t * colormap_index , j , y ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> type != GrayscaleType ) ( void ) TransformImageColorspace ( image , GRAYColorspace , exception ) ; if ( image -> storage_class == PseudoClass ) <S2SV_StartBug> colormap_index = ( ssize_t * ) AcquireQuantumMemory ( image -> colors + 1 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * colormap_index ) ) ; <S2SV_EndBug> else <S2SV_StartBug> colormap_index = ( ssize_t * ) AcquireQuantumMemory ( MaxColormapSize + 1 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * colormap_index ) ) ; <S2SV_EndBug> if ( colormap_index == ( ssize_t * ) NULL ) ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; if ( image -> storage_class != PseudoClass ) { ( void ) memset ( colormap_index , ( - 1 ) , MaxColormapSize * sizeof ( * colormap_index ) ) ; if ( AcquireImageColormap ( image , MaxColormapSize , exception ) == MagickFalse ) { colormap_index = ( ssize_t * ) RelinquishMagickMemory ( colormap_index ) ; ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; } image -> colors = 0 ; status = MagickTrue ; image_view = AcquireAuthenticCacheView ( image , exception ) ; # if defined ( MAGICKCORE_OPENMP_SUPPORT ) # pragma omp parallel for schedule ( static ) shared ( status ) magick_number_threads ( image , image , image -> rows , 1 ) # endif for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; register ssize_t x ; if ( status == MagickFalse ) continue ; q = GetCacheViewAuthenticPixels ( image_view , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { status = MagickFalse ; continue ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { register size_t intensity ; intensity = ScaleQuantumToMap ( GetPixelRed ( image , q ) ) ; if ( colormap_index [ intensity ] < 0 ) { # if defined ( MAGICKCORE_OPENMP_SUPPORT ) # pragma omp critical ( MagickCore_SetGrayscaleImage ) # endif if ( colormap_index [ intensity ] < 0 ) { colormap_index [ intensity ] = ( ssize_t ) image -> colors ; image -> colormap [ image -> colors ] . red = ( double ) GetPixelRed ( image , q ) ; image -> colormap [ image -> colors ] . green = ( double ) GetPixelGreen ( image , q ) ; image -> colormap [ image -> colors ] . blue = ( double ) GetPixelBlue ( image , q ) ; image -> colors ++ ; } } SetPixelIndex ( image , ( Quantum ) colormap_index [ intensity ] , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncCacheViewAuthenticPixels ( image_view , exception ) == MagickFalse ) status = MagickFalse ; } image_view = DestroyCacheView ( image_view ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . alpha = ( double ) i ; qsort ( ( void * ) image -> colormap , image -> colors , sizeof ( PixelInfo ) , IntensityCompare ) ; colormap = ( PixelInfo * ) AcquireQuantumMemory ( image -> colors , sizeof ( * colormap ) ) ; if ( colormap == ( PixelInfo * ) NULL ) { colormap_index = ( ssize_t * ) RelinquishMagickMemory ( colormap_index ) ; ThrowBinaryException ( ResourceLimitError , \"MemoryAllocationFailed\" , image -> filename ) ; } j = 0 ; colormap [ j ] = image -> colormap [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { if ( IsPixelInfoEquivalent ( & colormap [ j ] , & image -> colormap [ i ] ) == MagickFalse ) { j ++ ; colormap [ j ] = image -> colormap [ i ] ; } colormap_index [ ( ssize_t ) image -> colormap [ i ] . alpha ] = j ; } image -> colors = ( size_t ) ( j + 1 ) ; image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> colormap = colormap ; status = MagickTrue ; image_view = AcquireAuthenticCacheView ( image , exception ) ; # if defined ( MAGICKCORE_OPENMP_SUPPORT ) # pragma omp parallel for schedule ( static ) shared ( status ) magick_number_threads ( image , image , image -> rows , 1 ) # endif for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; register ssize_t x ; if ( status == MagickFalse ) continue ; q = GetCacheViewAuthenticPixels ( image_view , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { status = MagickFalse ; continue ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , ( Quantum ) colormap_index [ ScaleQuantumToMap ( GetPixelIndex ( image , q ) ) ] , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncCacheViewAuthenticPixels ( image_view , exception ) == MagickFalse ) status = MagickFalse ; } image_view = DestroyCacheView ( image_view ) ; colormap_index = ( ssize_t * ) RelinquishMagickMemory ( colormap_index ) ; image -> type = GrayscaleType ; if ( SetImageMonochrome ( image , exception ) != MagickFalse ) image -> type = BilevelType ; return ( status ) ; }", "target": "<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( <S2SV_ModStart> + 1 , MaxMap ) , <S2SV_ModStart> * ) AcquireQuantumMemory ( MagickMax <S2SV_ModStart> + 1 , MaxMap ) ,"}
{"source": "CWE-125 static unsigned long get_ctl_id_hash ( const struct snd_ctl_elem_id * id ) { int i ; unsigned long h ; h = id -> iface ; h = MULTIPLIER * h + id -> device ; h = MULTIPLIER * h + id -> subdevice ; <S2SV_StartBug> for ( i = 0 ; id -> name [ i ] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN ; i ++ ) <S2SV_EndBug> h = MULTIPLIER * h + id -> name [ i ] ; h = MULTIPLIER * h + id -> index ; h &= LONG_MAX ; return h ; }", "target": "<S2SV_ModStart> = 0 ; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && <S2SV_ModStart> [ i ] <S2SV_ModEnd> ; i ++"}
{"source": "CWE-125 eval_string ( char_u * * arg , typval_T * rettv , int evaluate , int interpolate ) { char_u * p ; char_u * end ; int extra = interpolate ? 1 : 0 ; int off = interpolate ? 0 : 1 ; int len ; for ( p = * arg + off ; * p != NUL && * p != \\'\"\\' ; MB_PTR_ADV ( p ) ) { if ( * p == '\\\\\\\\' && p [ 1 ] != NUL ) { ++ p ; if ( * p == '<' ) <S2SV_StartBug> extra += 5 ; <S2SV_EndBug> } else if ( interpolate && ( * p == '{' || * p == '}' ) ) { if ( * p == '{' && p [ 1 ] != '{' ) break ; ++ p ; if ( p [ - 1 ] == '}' && * p != '}' ) { semsg ( _ ( e_stray_closing_curly_str ) , * arg ) ; return FAIL ; } -- extra ; } } if ( * p != \\'\"\\' && ! ( interpolate && * p == '{' ) ) { semsg ( _ ( e_missing_double_quote_str ) , * arg ) ; return FAIL ; } if ( ! evaluate ) { * arg = p + off ; return OK ; } rettv -> v_type = VAR_STRING ; len = ( int ) ( p - * arg + extra ) ; rettv -> vval . v_string = alloc ( len ) ; if ( rettv -> vval . v_string == NULL ) return FAIL ; end = rettv -> vval . v_string ; for ( p = * arg + off ; * p != NUL && * p != \\'\"\\' ; ) { if ( * p == '\\\\\\\\' ) { switch ( * ++ p ) { case 'b' : * end ++ = BS ; ++ p ; break ; case 'e' : * end ++ = ESC ; ++ p ; break ; case 'f' : * end ++ = FF ; ++ p ; break ; case 'n' : * end ++ = NL ; ++ p ; break ; case 'r' : * end ++ = CAR ; ++ p ; break ; case 't' : * end ++ = TAB ; ++ p ; break ; case 'X' : case 'x' : case 'u' : case 'U' : if ( vim_isxdigit ( p [ 1 ] ) ) { int n , nr ; int c = toupper ( * p ) ; if ( c == 'X' ) n = 2 ; else if ( * p == 'u' ) n = 4 ; else n = 8 ; nr = 0 ; while ( -- n >= 0 && vim_isxdigit ( p [ 1 ] ) ) { ++ p ; nr = ( nr << 4 ) + hex2nr ( * p ) ; } ++ p ; if ( c != 'X' ) end += ( * mb_char2bytes ) ( nr , end ) ; else * end ++ = nr ; } break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : * end = * p ++ - '0' ; if ( * p >= '0' && * p <= '7' ) { * end = ( * end << 3 ) + * p ++ - '0' ; if ( * p >= '0' && * p <= '7' ) * end = ( * end << 3 ) + * p ++ - '0' ; } ++ end ; break ; case '<' : { int flags = FSK_KEYCODE | FSK_IN_STRING ; if ( p [ 1 ] != '*' ) flags |= FSK_SIMPLIFY ; extra = trans_special ( & p , end , flags , FALSE , NULL ) ; if ( extra != 0 ) { end += extra ; if ( end >= rettv -> vval . v_string + len ) iemsg ( \"eval_string()<S2SV_blank>used<S2SV_blank>more<S2SV_blank>space<S2SV_blank>than<S2SV_blank>allocated\" ) ; break ; } } default : MB_COPY_CHAR ( p , end ) ; break ; } } else { if ( interpolate && ( * p == '{' || * p == '}' ) ) { if ( * p == '{' && p [ 1 ] != '{' ) break ; ++ p ; } MB_COPY_CHAR ( p , end ) ; } } * end = NUL ; if ( * p == \\'\"\\' && ! interpolate ) ++ p ; * arg = p ; return OK ; }", "target": "<S2SV_ModStart> == '<' ) { int modifiers = 0 ; int flags = FSK_KEYCODE | FSK_IN_STRING ; <S2SV_ModStart> += 5 ; if ( p [ 1 ] != '*' ) flags |= FSK_SIMPLIFY ; if ( find_special_key ( & p , & modifiers , flags , NULL ) != 0 ) -- p ; }"}
{"source": "CWE-703 cmdopts_t * cmdopts_parse ( int argc , char * * argv ) { enum { CMDOPT_HELP = 0 , CMDOPT_VERBOSE , CMDOPT_QUIET , CMDOPT_INFILE , CMDOPT_INFMT , CMDOPT_INOPT , CMDOPT_OUTFILE , CMDOPT_OUTFMT , CMDOPT_OUTOPT , CMDOPT_VERSION , CMDOPT_DEBUG , CMDOPT_CMPTNO , CMDOPT_SRGB , CMDOPT_MAXMEM , CMDOPT_LIST_ENABLED_CODECS , CMDOPT_LIST_ALL_CODECS , CMDOPT_ENABLE_FORMAT , CMDOPT_ENABLE_ALL_FORMATS , } ; static const jas_opt_t cmdoptions [ ] = { { CMDOPT_HELP , \"help\" , 0 } , { CMDOPT_VERBOSE , \"verbose\" , 0 } , { CMDOPT_QUIET , \"quiet\" , 0 } , { CMDOPT_QUIET , \"q\" , 0 } , { CMDOPT_INFILE , \"input\" , JAS_OPT_HASARG } , { CMDOPT_INFILE , \"f\" , JAS_OPT_HASARG } , { CMDOPT_INFMT , \"input-format\" , JAS_OPT_HASARG } , { CMDOPT_INFMT , \"t\" , JAS_OPT_HASARG } , { CMDOPT_INOPT , \"input-option\" , JAS_OPT_HASARG } , { CMDOPT_INOPT , \"o\" , JAS_OPT_HASARG } , { CMDOPT_OUTFILE , \"output\" , JAS_OPT_HASARG } , { CMDOPT_OUTFILE , \"F\" , JAS_OPT_HASARG } , { CMDOPT_OUTFMT , \"output-format\" , JAS_OPT_HASARG } , { CMDOPT_OUTFMT , \"T\" , JAS_OPT_HASARG } , { CMDOPT_OUTOPT , \"output-option\" , JAS_OPT_HASARG } , { CMDOPT_OUTOPT , \"O\" , JAS_OPT_HASARG } , { CMDOPT_VERSION , \"version\" , 0 } , { CMDOPT_DEBUG , \"debug-level\" , JAS_OPT_HASARG } , { CMDOPT_CMPTNO , \"cmptno\" , JAS_OPT_HASARG } , { CMDOPT_SRGB , \"force-srgb\" , 0 } , { CMDOPT_SRGB , \"S\" , 0 } , { CMDOPT_MAXMEM , \"memory-limit\" , JAS_OPT_HASARG } , { CMDOPT_LIST_ENABLED_CODECS , \"list-enabled-formats\" , 0 } , { CMDOPT_LIST_ALL_CODECS , \"list-all-formats\" , 0 } , { CMDOPT_ENABLE_FORMAT , \"enable-format\" , JAS_OPT_HASARG } , { CMDOPT_ENABLE_ALL_FORMATS , \"enable-all-formats\" , 0 } , { - 1 , 0 , 0 } } ; cmdopts_t * cmdopts ; int c ; if ( ! ( cmdopts = malloc ( sizeof ( cmdopts_t ) ) ) ) { fprintf ( stderr , \"error:<S2SV_blank>insufficient<S2SV_blank>memory\\\\n\" ) ; exit ( EXIT_FAILURE ) ; } cmdopts -> infile = 0 ; cmdopts -> infmt = - 1 ; cmdopts -> infmt_str = 0 ; cmdopts -> inopts = 0 ; cmdopts -> inoptsbuf [ 0 ] = '\\\\0' ; cmdopts -> outfile = 0 ; cmdopts -> outfmt = - 1 ; cmdopts -> outfmt_str = 0 ; cmdopts -> outopts = 0 ; cmdopts -> outoptsbuf [ 0 ] = '\\\\0' ; cmdopts -> verbose = 0 ; cmdopts -> version = 0 ; cmdopts -> cmptno = - 1 ; cmdopts -> debug = 0 ; cmdopts -> srgb = 0 ; cmdopts -> list_codecs = 0 ; cmdopts -> list_codecs_all = 0 ; cmdopts -> help = 0 ; cmdopts -> max_mem = get_default_max_mem_usage ( ) ; cmdopts -> enable_format = 0 ; cmdopts -> enable_all_formats = 0 ; while ( ( c = jas_getopt ( argc , argv , cmdoptions ) ) != EOF ) { switch ( c ) { case CMDOPT_HELP : cmdopts -> help = 1 ; break ; case CMDOPT_VERBOSE : cmdopts -> verbose = 1 ; break ; case CMDOPT_QUIET : cmdopts -> verbose = - 1 ; break ; case CMDOPT_VERSION : cmdopts -> version = 1 ; break ; case CMDOPT_LIST_ENABLED_CODECS : cmdopts -> list_codecs = 1 ; cmdopts -> list_codecs_all = 0 ; break ; case CMDOPT_LIST_ALL_CODECS : cmdopts -> list_codecs = 1 ; cmdopts -> list_codecs_all = 1 ; break ; case CMDOPT_DEBUG : cmdopts -> debug = atoi ( jas_optarg ) ; break ; case CMDOPT_INFILE : cmdopts -> infile = jas_optarg ; break ; case CMDOPT_INFMT : cmdopts -> infmt_str = jas_optarg ; break ; case CMDOPT_INOPT : addopt ( cmdopts -> inoptsbuf , OPTSMAX , jas_optarg ) ; cmdopts -> inopts = cmdopts -> inoptsbuf ; break ; case CMDOPT_OUTFILE : cmdopts -> outfile = jas_optarg ; break ; case CMDOPT_OUTFMT : cmdopts -> outfmt_str = jas_optarg ; break ; case CMDOPT_OUTOPT : addopt ( cmdopts -> outoptsbuf , OPTSMAX , jas_optarg ) ; cmdopts -> outopts = cmdopts -> outoptsbuf ; break ; case CMDOPT_CMPTNO : cmdopts -> cmptno = atoi ( jas_optarg ) ; break ; case CMDOPT_SRGB : cmdopts -> srgb = 1 ; break ; case CMDOPT_MAXMEM : cmdopts -> max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case CMDOPT_ENABLE_FORMAT : cmdopts -> enable_format = jas_optarg ; break ; case CMDOPT_ENABLE_ALL_FORMATS : cmdopts -> enable_all_formats = 1 ; break ; default : <S2SV_StartBug> badusage ( ) ; <S2SV_EndBug> break ; } } while ( jas_optind < argc ) { fprintf ( stderr , \"warning:<S2SV_blank>ignoring<S2SV_blank>bogus<S2SV_blank>command<S2SV_blank>line<S2SV_blank>argument<S2SV_blank>%s\\\\n\" , argv [ jas_optind ] ) ; ++ jas_optind ; } if ( cmdopts -> version || cmdopts -> list_codecs || cmdopts -> help ) { goto done ; } if ( ! cmdopts -> outfmt_str && ! cmdopts -> outfile ) { fprintf ( stderr , \"error:<S2SV_blank>cannot<S2SV_blank>determine<S2SV_blank>output<S2SV_blank>format\\\\n\" ) ; <S2SV_StartBug> badusage ( ) ; <S2SV_EndBug> } done : return cmdopts ; }", "target": "<S2SV_ModStart> ; default : cmdopts_destroy ( cmdopts ) ; <S2SV_ModStart> \"error:<S2SV_blank>cannot<S2SV_blank>determine<S2SV_blank>output<S2SV_blank>format\\\\n\" ) ; cmdopts_destroy ( cmdopts ) ;"}
{"source": "CWE-120 static ssize_t remove_slot_store ( struct kobject * kobj , struct kobj_attribute * attr , const char * buf , size_t nbytes ) { char drc_name [ MAX_DRC_NAME_LEN ] ; int rc ; char * end ; if ( nbytes >= MAX_DRC_NAME_LEN ) return 0 ; <S2SV_StartBug> memcpy ( drc_name , buf , nbytes ) ; <S2SV_EndBug> end = strchr ( drc_name , '\\\\n' ) ; <S2SV_StartBug> if ( ! end ) <S2SV_EndBug> end = & drc_name [ nbytes ] ; * end = '\\\\0' ; rc = dlpar_remove_slot ( drc_name ) ; if ( rc ) return rc ; return nbytes ; }", "target": "<S2SV_ModStart> return 0 ; strscpy <S2SV_ModEnd> ( drc_name , <S2SV_ModStart> buf , nbytes + 1 <S2SV_ModStart> ; if ( end ) <S2SV_ModEnd> * end ="}
{"source": "CWE-120 static ssize_t add_slot_store ( struct kobject * kobj , struct kobj_attribute * attr , const char * buf , size_t nbytes ) { char drc_name [ MAX_DRC_NAME_LEN ] ; char * end ; int rc ; if ( nbytes >= MAX_DRC_NAME_LEN ) return 0 ; <S2SV_StartBug> memcpy ( drc_name , buf , nbytes ) ; <S2SV_EndBug> end = strchr ( drc_name , '\\\\n' ) ; <S2SV_StartBug> if ( ! end ) <S2SV_EndBug> end = & drc_name [ nbytes ] ; * end = '\\\\0' ; rc = dlpar_add_slot ( drc_name ) ; if ( rc ) return rc ; return nbytes ; }", "target": "<S2SV_ModStart> return 0 ; strscpy <S2SV_ModEnd> ( drc_name , <S2SV_ModStart> buf , nbytes + 1 <S2SV_ModStart> ; if ( end ) <S2SV_ModEnd> * end ="}
{"source": "CWE-703 static SQInteger thread_call ( HSQUIRRELVM v ) { SQObjectPtr o = stack_get ( v , 1 ) ; if ( sq_type ( o ) == OT_THREAD ) { <S2SV_StartBug> SQInteger nparams = sq_gettop ( v ) ; <S2SV_EndBug> _thread ( o ) -> Push ( _thread ( o ) -> _roottable ) ; for ( SQInteger i = 2 ; i < ( nparams + 1 ) ; i ++ ) sq_move ( _thread ( o ) , v , i ) ; if ( SQ_SUCCEEDED ( sq_call ( _thread ( o ) , nparams , SQTrue , SQTrue ) ) ) { sq_move ( v , _thread ( o ) , - 1 ) ; sq_pop ( _thread ( o ) , 1 ) ; return 1 ; } v -> _lasterror = _thread ( o ) -> _lasterror ; return SQ_ERROR ; } return sq_throwerror ( v , _SC ( \"wrong<S2SV_blank>parameter\" ) ) ; }", "target": "<S2SV_ModStart> sq_gettop ( v ) ; sq_reservestack ( _thread ( o ) , nparams + 3"}
{"source": "CWE-787 at_bitmap input_bmp_reader ( gchar * filename , at_input_opts_type * opts , at_msg_func msg_func , gpointer msg_data , gpointer user_data ) { FILE * fd ; <S2SV_StartBug> unsigned char buffer [ 64 ] ; <S2SV_EndBug> int ColormapSize , rowbytes , Maps ; gboolean Grey = FALSE ; unsigned char ColorMap [ 256 ] [ 3 ] ; at_bitmap image = at_bitmap_init ( 0 , 0 , 0 , 1 ) ; unsigned char * image_storage ; at_exception_type exp = at_exception_new ( msg_func , msg_data ) ; char magick [ 2 ] ; Bitmap_Channel masks [ 4 ] ; fd = fopen ( filename , \"rb\" ) ; if ( ! fd ) { LOG ( \"Can\\'t<S2SV_blank>open<S2SV_blank>\\\\\"%s\\\\\"\\\\n\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } if ( ! ReadOK ( fd , magick , 2 ) || ! ( ! strncmp ( magick , \"BA\" , 2 ) || ! strncmp ( magick , \"BM\" , 2 ) || ! strncmp ( magick , \"IC\" , 2 ) || ! strncmp ( magick , \"PT\" , 2 ) || ! strncmp ( magick , \"CI\" , 2 ) || ! strncmp ( magick , \"CP\" , 2 ) ) ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } while ( ! strncmp ( magick , \"BA\" , 2 ) ) { if ( ! ReadOK ( fd , buffer , 12 ) ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } if ( ! ReadOK ( fd , magick , 2 ) ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } } if ( ! ReadOK ( fd , buffer , 12 ) ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } Bitmap_File_Head . bfSize = ToL ( & buffer [ 0x00 ] ) ; Bitmap_File_Head . zzHotX = ToS ( & buffer [ 0x04 ] ) ; Bitmap_File_Head . zzHotY = ToS ( & buffer [ 0x06 ] ) ; Bitmap_File_Head . bfOffs = ToL ( & buffer [ 0x08 ] ) ; if ( ! ReadOK ( fd , buffer , 4 ) ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } Bitmap_File_Head . biSize = ToL ( & buffer [ 0x00 ] ) ; if ( Bitmap_File_Head . biSize == 12 ) { if ( ! ReadOK ( fd , buffer , 8 ) ) { LOG ( \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\\\\n\" ) ; at_exception_fatal ( & exp , \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\" ) ; goto cleanup ; } Bitmap_Head . biWidth = ToS ( & buffer [ 0x00 ] ) ; Bitmap_Head . biHeight = ToS ( & buffer [ 0x02 ] ) ; Bitmap_Head . biPlanes = ToS ( & buffer [ 0x04 ] ) ; Bitmap_Head . biBitCnt = ToS ( & buffer [ 0x06 ] ) ; Bitmap_Head . biCompr = 0 ; Bitmap_Head . biSizeIm = 0 ; Bitmap_Head . biXPels = Bitmap_Head . biYPels = 0 ; Bitmap_Head . biClrUsed = 0 ; Bitmap_Head . biClrImp = 0 ; Bitmap_Head . masks [ 0 ] = 0 ; Bitmap_Head . masks [ 1 ] = 0 ; Bitmap_Head . masks [ 2 ] = 0 ; Bitmap_Head . masks [ 3 ] = 0 ; memset ( masks , 0 , sizeof ( masks ) ) ; Maps = 3 ; } else if ( Bitmap_File_Head . biSize == 40 ) { if ( ! ReadOK ( fd , buffer , 36 ) ) { LOG ( \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\\\\n\" ) ; at_exception_fatal ( & exp , \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\" ) ; goto cleanup ; } Bitmap_Head . biWidth = ToL ( & buffer [ 0x00 ] ) ; Bitmap_Head . biHeight = ToL ( & buffer [ 0x04 ] ) ; Bitmap_Head . biPlanes = ToS ( & buffer [ 0x08 ] ) ; Bitmap_Head . biBitCnt = ToS ( & buffer [ 0x0A ] ) ; Bitmap_Head . biCompr = ToL ( & buffer [ 0x0C ] ) ; Bitmap_Head . biSizeIm = ToL ( & buffer [ 0x10 ] ) ; Bitmap_Head . biXPels = ToL ( & buffer [ 0x14 ] ) ; Bitmap_Head . biYPels = ToL ( & buffer [ 0x18 ] ) ; Bitmap_Head . biClrUsed = ToL ( & buffer [ 0x1C ] ) ; Bitmap_Head . biClrImp = ToL ( & buffer [ 0x20 ] ) ; Bitmap_Head . masks [ 0 ] = 0 ; Bitmap_Head . masks [ 1 ] = 0 ; Bitmap_Head . masks [ 2 ] = 0 ; Bitmap_Head . masks [ 3 ] = 0 ; Maps = 4 ; memset ( masks , 0 , sizeof ( masks ) ) ; if ( Bitmap_Head . biCompr == BI_BITFIELDS ) { if ( ! ReadOK ( fd , buffer , 3 * sizeof ( unsigned long ) ) ) { LOG ( \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\\\\n\" ) ; at_exception_fatal ( & exp , \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\" ) ; goto cleanup ; } Bitmap_Head . masks [ 0 ] = ToL ( & buffer [ 0x00 ] ) ; Bitmap_Head . masks [ 1 ] = ToL ( & buffer [ 0x04 ] ) ; Bitmap_Head . masks [ 2 ] = ToL ( & buffer [ 0x08 ] ) ; ReadChannelMasks ( & Bitmap_Head . masks [ 0 ] , masks , 3 ) ; } else if ( Bitmap_Head . biCompr == BI_RGB ) { setMasksDefault ( Bitmap_Head . biBitCnt , masks ) ; } else if ( ( Bitmap_Head . biCompr != BI_RLE4 ) && ( Bitmap_Head . biCompr != BI_RLE8 ) ) { LOG ( \"Unsupported<S2SV_blank>compression<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\\\n\" ) ; at_exception_fatal ( & exp , \"Unsupported<S2SV_blank>compression<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\" ) ; goto cleanup ; } } else if ( Bitmap_File_Head . biSize >= 56 && Bitmap_File_Head . biSize <= 64 ) { if ( ! ReadOK ( fd , buffer , Bitmap_File_Head . biSize - 4 ) ) { LOG ( \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\\\\n\" ) ; at_exception_fatal ( & exp , \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\" ) ; goto cleanup ; } Bitmap_Head . biWidth = ToL ( & buffer [ 0x00 ] ) ; Bitmap_Head . biHeight = ToL ( & buffer [ 0x04 ] ) ; Bitmap_Head . biPlanes = ToS ( & buffer [ 0x08 ] ) ; Bitmap_Head . biBitCnt = ToS ( & buffer [ 0x0A ] ) ; Bitmap_Head . biCompr = ToL ( & buffer [ 0x0C ] ) ; Bitmap_Head . biSizeIm = ToL ( & buffer [ 0x10 ] ) ; Bitmap_Head . biXPels = ToL ( & buffer [ 0x14 ] ) ; Bitmap_Head . biYPels = ToL ( & buffer [ 0x18 ] ) ; Bitmap_Head . biClrUsed = ToL ( & buffer [ 0x1C ] ) ; Bitmap_Head . biClrImp = ToL ( & buffer [ 0x20 ] ) ; Bitmap_Head . masks [ 0 ] = ToL ( & buffer [ 0x24 ] ) ; Bitmap_Head . masks [ 1 ] = ToL ( & buffer [ 0x28 ] ) ; Bitmap_Head . masks [ 2 ] = ToL ( & buffer [ 0x2C ] ) ; Bitmap_Head . masks [ 3 ] = ToL ( & buffer [ 0x30 ] ) ; Maps = 4 ; ReadChannelMasks ( & Bitmap_Head . masks [ 0 ] , masks , 4 ) ; } else if ( Bitmap_File_Head . biSize == 108 || Bitmap_File_Head . biSize == 124 ) { if ( ! ReadOK ( fd , buffer , Bitmap_File_Head . biSize - 4 ) ) { LOG ( \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\\\\n\" ) ; at_exception_fatal ( & exp , \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\" ) ; goto cleanup ; } Bitmap_Head . biWidth = ToL ( & buffer [ 0x00 ] ) ; Bitmap_Head . biHeight = ToL ( & buffer [ 0x04 ] ) ; Bitmap_Head . biPlanes = ToS ( & buffer [ 0x08 ] ) ; Bitmap_Head . biBitCnt = ToS ( & buffer [ 0x0A ] ) ; Bitmap_Head . biCompr = ToL ( & buffer [ 0x0C ] ) ; Bitmap_Head . biSizeIm = ToL ( & buffer [ 0x10 ] ) ; Bitmap_Head . biXPels = ToL ( & buffer [ 0x14 ] ) ; Bitmap_Head . biYPels = ToL ( & buffer [ 0x18 ] ) ; Bitmap_Head . biClrUsed = ToL ( & buffer [ 0x1C ] ) ; Bitmap_Head . biClrImp = ToL ( & buffer [ 0x20 ] ) ; Bitmap_Head . masks [ 0 ] = ToL ( & buffer [ 0x24 ] ) ; Bitmap_Head . masks [ 1 ] = ToL ( & buffer [ 0x28 ] ) ; Bitmap_Head . masks [ 2 ] = ToL ( & buffer [ 0x2C ] ) ; Bitmap_Head . masks [ 3 ] = ToL ( & buffer [ 0x30 ] ) ; Maps = 4 ; if ( Bitmap_Head . biCompr == BI_BITFIELDS ) { ReadChannelMasks ( & Bitmap_Head . masks [ 0 ] , masks , 4 ) ; } else if ( Bitmap_Head . biCompr == BI_RGB ) { setMasksDefault ( Bitmap_Head . biBitCnt , masks ) ; } } else { LOG ( \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\\\\n\" ) ; at_exception_fatal ( & exp , \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header\" ) ; goto cleanup ; } switch ( Bitmap_Head . biBitCnt ) { case 1 : case 2 : case 4 : case 8 : case 16 : case 24 : case 32 : break ; default : LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } ColormapSize = ( Bitmap_File_Head . bfOffs - Bitmap_File_Head . biSize - 14 ) / Maps ; if ( ( Bitmap_Head . biClrUsed == 0 ) && ( Bitmap_Head . biBitCnt <= 8 ) ) { ColormapSize = Bitmap_Head . biClrUsed = 1 << Bitmap_Head . biBitCnt ; } if ( ColormapSize > 256 ) ColormapSize = 256 ; if ( Bitmap_Head . biHeight == 0 || Bitmap_Head . biWidth == 0 ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } if ( Bitmap_Head . biWidth < 0 || Bitmap_Head . biHeight == - 2147483648 ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } if ( Bitmap_Head . biPlanes != 1 ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } if ( Bitmap_Head . biClrUsed > 256 && Bitmap_Head . biBitCnt <= 8 ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } if ( ( ( unsigned long ) Bitmap_Head . biWidth ) > ( unsigned int ) 0x7fffffff / Bitmap_Head . biBitCnt || ( ( unsigned long ) Bitmap_Head . biWidth ) > ( ( unsigned int ) 0x7fffffff / abs ( Bitmap_Head . biHeight ) ) / 4 ) { LOG ( \"%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>BMP<S2SV_blank>file\" , filename ) ; at_exception_fatal ( & exp , \"bmp:<S2SV_blank>invalid<S2SV_blank>input<S2SV_blank>file\" ) ; goto cleanup ; } unsigned long overflowTest = Bitmap_Head . biWidth * Bitmap_Head . biBitCnt ; if ( overflowTest / Bitmap_Head . biWidth != Bitmap_Head . biBitCnt ) { LOG ( \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header.<S2SV_blank>Width<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; at_exception_fatal ( & exp , \"Error<S2SV_blank>reading<S2SV_blank>BMP<S2SV_blank>file<S2SV_blank>header.<S2SV_blank>Width<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\" ) ; goto cleanup ; } rowbytes = ( ( Bitmap_Head . biWidth * Bitmap_Head . biBitCnt - 1 ) / 32 ) * 4 + 4 ; # ifdef DEBUG printf ( \"\\\\nSize:<S2SV_blank>%u,<S2SV_blank>Colors:<S2SV_blank>%u,<S2SV_blank>Bits:<S2SV_blank>%u,<S2SV_blank>Width:<S2SV_blank>%u,<S2SV_blank>Height:<S2SV_blank>%u,<S2SV_blank>Comp:<S2SV_blank>%u,<S2SV_blank>Zeile:<S2SV_blank>%u\\\\n\" , Bitmap_File_Head . bfSize , Bitmap_Head . biClrUsed , Bitmap_Head . biBitCnt , Bitmap_Head . biWidth , Bitmap_Head . biHeight , Bitmap_Head . biCompr , rowbytes ) ; # endif if ( Bitmap_Head . biBitCnt <= 8 ) { # ifdef DEBUG printf ( \"Colormap<S2SV_blank>read\\\\n\" ) ; # endif if ( ! ReadColorMap ( fd , ColorMap , ColormapSize , Maps , & Grey , & exp ) ) goto cleanup ; } fseek ( fd , Bitmap_File_Head . bfOffs , SEEK_SET ) ; image_storage = ReadImage ( fd , Bitmap_Head . biWidth , Bitmap_Head . biHeight , ColorMap , Bitmap_Head . biClrUsed , Bitmap_Head . biBitCnt , Bitmap_Head . biCompr , rowbytes , Grey , masks , & exp ) ; image = at_bitmap_init ( image_storage , ( unsigned short ) Bitmap_Head . biWidth , ( unsigned short ) Bitmap_Head . biHeight , Grey ? 1 : 3 ) ; cleanup : fclose ( fd ) ; return ( image ) ; }", "target": "<S2SV_ModStart> char buffer [ 128 <S2SV_ModEnd> ] ; int"}
{"source": "CWE-787 static const ut8 * parse_die ( const ut8 * buf , const ut8 * buf_end , RzBinDwarfDebugInfo * info , RzBinDwarfAbbrevDecl * abbrev , RzBinDwarfCompUnitHdr * hdr , RzBinDwarfDie * die , const ut8 * debug_str , size_t debug_str_len , bool big_endian ) { size_t i ; const char * comp_dir = NULL ; <S2SV_StartBug> ut64 line_info_offset = UT64_MAX ; <S2SV_EndBug> for ( i = 0 ; i < abbrev -> count - 1 ; i ++ ) { memset ( & die -> attr_values [ i ] , 0 , sizeof ( die -> attr_values [ i ] ) ) ; buf = parse_attr_value ( buf , buf_end - buf , & abbrev -> defs [ i ] , & die -> attr_values [ i ] , hdr , debug_str , debug_str_len , big_endian ) ; RzBinDwarfAttrValue * attribute = & die -> attr_values [ i ] ; if ( attribute -> attr_name == DW_AT_comp_dir && ( attribute -> attr_form == DW_FORM_strp || attribute -> attr_form == DW_FORM_string ) && attribute -> string . content ) { comp_dir = attribute -> string . content ; } if ( attribute -> attr_name == DW_AT_stmt_list ) { if ( attribute -> kind == DW_AT_KIND_CONSTANT ) { line_info_offset = attribute -> uconstant ; } else if ( attribute -> kind == DW_AT_KIND_REFERENCE ) { line_info_offset = attribute -> reference ; } } die -> count ++ ; } <S2SV_StartBug> <S2SV_EndBug> if ( comp_dir && line_info_offset != UT64_MAX ) { char * name = strdup ( comp_dir ) ; if ( name ) { if ( ! ht_up_insert ( info -> line_info_offset_comp_dir , line_info_offset , name ) ) { free ( name ) ; } } } return buf ; }", "target": "<S2SV_ModStart> = UT64_MAX ; if ( abbrev -> count ) { <S2SV_ModStart> ++ ; } }"}
{"source": "CWE-362 <S2SV_StartBug> TerminalUserInfo UserTerminalRouter : : getInfoForId ( const string & id ) { <S2SV_EndBug> auto it = idInfoMap . find ( id ) ; if ( it == idInfoMap . end ( ) ) { STFATAL << \"<S2SV_blank>Tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>an<S2SV_blank>id<S2SV_blank>that<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>exists\" ; } return it -> second ; }", "target": "<S2SV_ModStart> id ) { lock_guard < recursive_mutex > guard ( routerMutex ) ;"}
{"source": "CWE-362 set < int > PipeSocketHandler : : listen ( const SocketEndpoint & endpoint ) { lock_guard < std : : recursive_mutex > guard ( globalMutex ) ; string pipePath = endpoint . name ( ) ; if ( pipeServerSockets . find ( pipePath ) != pipeServerSockets . end ( ) ) { throw runtime_error ( \"Tried<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>twice<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>path\" ) ; } sockaddr_un local ; int fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; FATAL_FAIL ( fd ) ; initServerSocket ( fd ) ; local . sun_family = AF_UNIX ; <S2SV_StartBug> strcpy ( local . sun_path , pipePath . c_str ( ) ) ; <S2SV_EndBug> unlink ( local . sun_path ) ; FATAL_FAIL ( : : bind ( fd , ( struct sockaddr * ) & local , sizeof ( sockaddr_un ) ) ) ; : : listen ( fd , 5 ) ; # ifndef WIN32 FATAL_FAIL ( : : chmod ( local . sun_path , S_IRUSR | S_IWUSR | S_IXUSR ) ) ; # endif pipeServerSockets [ pipePath ] = set < int > ( { fd } ) ; return pipeServerSockets [ pipePath ] ; }", "target": "<S2SV_ModStart> = AF_UNIX ; strncpy <S2SV_ModEnd> ( local . <S2SV_ModStart> . c_str ( ) , sizeof ( local . sun_path"}
{"source": "CWE-787 <S2SV_StartBug> display_dollar ( colnr_T col ) <S2SV_EndBug> { colnr_T save_col ; if ( ! redrawing ( ) ) return ; cursor_off ( ) ; save_col = curwin -> w_cursor . col ; curwin -> w_cursor . col = col ; if ( has_mbyte ) { char_u * p ; p = ml_get_curline ( ) ; curwin -> w_cursor . col -= ( * mb_head_off ) ( p , p + col ) ; } curs_columns ( FALSE ) ; if ( curwin -> w_wcol < curwin -> w_width ) { edit_putchar ( '$' , FALSE ) ; dollar_vcol = curwin -> w_virtcol ; } curwin -> w_cursor . col = save_col ; }", "target": "<S2SV_ModStart> display_dollar ( colnr_T col_arg ) { colnr_T col = col_arg < 0 ? 0 : col_arg ; <S2SV_ModEnd> colnr_T save_col ;"}
{"source": "CWE-284 static size_t copy_page_to_iter_pipe ( struct page * page , size_t offset , size_t bytes , struct iov_iter * i ) { struct pipe_inode_info * pipe = i -> pipe ; struct pipe_buffer * buf ; unsigned int p_tail = pipe -> tail ; unsigned int p_mask = pipe -> ring_size - 1 ; unsigned int i_head = i -> head ; size_t off ; if ( unlikely ( bytes > i -> count ) ) bytes = i -> count ; if ( unlikely ( ! bytes ) ) return 0 ; if ( ! sanity ( i ) ) return 0 ; off = i -> iov_offset ; buf = & pipe -> bufs [ i_head & p_mask ] ; if ( off ) { if ( offset == off && buf -> page == page ) { buf -> len += bytes ; i -> iov_offset += bytes ; goto out ; } i_head ++ ; buf = & pipe -> bufs [ i_head & p_mask ] ; } if ( pipe_full ( i_head , p_tail , pipe -> max_usage ) ) return 0 ; buf -> ops = & page_cache_pipe_buf_ops ; <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> buf -> page = page ; buf -> offset = offset ; buf -> len = bytes ; pipe -> head = i_head + 1 ; i -> iov_offset = offset + bytes ; i -> head = i_head ; out : i -> count -= bytes ; return bytes ; }", "target": "<S2SV_ModStart> & page_cache_pipe_buf_ops ; buf -> flags = 0 ;"}
{"source": "CWE-284 static size_t push_pipe ( struct iov_iter * i , size_t size , int * iter_headp , size_t * offp ) { struct pipe_inode_info * pipe = i -> pipe ; unsigned int p_tail = pipe -> tail ; unsigned int p_mask = pipe -> ring_size - 1 ; unsigned int iter_head ; size_t off ; ssize_t left ; if ( unlikely ( size > i -> count ) ) size = i -> count ; if ( unlikely ( ! size ) ) return 0 ; left = size ; data_start ( i , & iter_head , & off ) ; * iter_headp = iter_head ; * offp = off ; if ( off ) { left -= PAGE_SIZE - off ; if ( left <= 0 ) { pipe -> bufs [ iter_head & p_mask ] . len += size ; return size ; } pipe -> bufs [ iter_head & p_mask ] . len = PAGE_SIZE ; iter_head ++ ; } while ( ! pipe_full ( iter_head , p_tail , pipe -> max_usage ) ) { struct pipe_buffer * buf = & pipe -> bufs [ iter_head & p_mask ] ; struct page * page = alloc_page ( GFP_USER ) ; if ( ! page ) break ; buf -> ops = & default_pipe_buf_ops ; <S2SV_StartBug> buf -> page = page ; <S2SV_EndBug> buf -> offset = 0 ; buf -> len = min_t ( ssize_t , left , PAGE_SIZE ) ; left -= buf -> len ; iter_head ++ ; pipe -> head = iter_head ; if ( left == 0 ) return size ; } return size - left ; }", "target": "<S2SV_ModStart> ; buf -> flags = 0 ; buf ->"}
{"source": "CWE-200 <S2SV_StartBug> PHP_FUNCTION ( openssl_encrypt ) <S2SV_EndBug> { <S2SV_StartBug> zend_bool raw_output = 0 ; <S2SV_EndBug> char * data , * method , * password , * iv = \"\" ; <S2SV_StartBug> int data_len , method_len , password_len , iv_len = 0 , max_iv_len ; <S2SV_EndBug> const EVP_CIPHER * cipher_type ; EVP_CIPHER_CTX cipher_ctx ; int i , outlen , keylen ; unsigned char * outbuf , * key ; <S2SV_StartBug> zend_bool free_iv ; <S2SV_EndBug> <S2SV_StartBug> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"sss|bs\" , & data , & data_len , & method , & method_len , & password , & password_len , & raw_output , & iv , & iv_len ) == FAILURE ) { <S2SV_EndBug> return ; } <S2SV_StartBug> cipher_type = EVP_get_cipherbyname ( method ) ; <S2SV_EndBug> if ( ! cipher_type ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Unknown<S2SV_blank>cipher<S2SV_blank>algorithm\" ) ; <S2SV_StartBug> RETURN_FALSE ; <S2SV_EndBug> } keylen = EVP_CIPHER_key_length ( cipher_type ) ; if ( keylen > password_len ) { key = emalloc ( keylen ) ; memset ( key , 0 , keylen ) ; memcpy ( key , password , password_len ) ; } else { key = ( unsigned char * ) password ; } <S2SV_StartBug> max_iv_len = EVP_CIPHER_iv_length ( cipher_type ) ; <S2SV_EndBug> if ( iv_len <= 0 && max_iv_len > 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Using<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>Initialization<S2SV_blank>Vector<S2SV_blank>(iv)<S2SV_blank>is<S2SV_blank>potentially<S2SV_blank>insecure<S2SV_blank>and<S2SV_blank>not<S2SV_blank>recommended\" ) ; } free_iv = php_openssl_validate_iv ( & iv , & iv_len , max_iv_len TSRMLS_CC ) ; outlen = data_len + EVP_CIPHER_block_size ( cipher_type ) ; outbuf = emalloc ( outlen + 1 ) ; <S2SV_StartBug> EVP_EncryptInit ( & cipher_ctx , cipher_type , NULL , NULL ) ; <S2SV_EndBug> if ( password_len > keylen ) { EVP_CIPHER_CTX_set_key_length ( & cipher_ctx , password_len ) ; } <S2SV_StartBug> EVP_EncryptInit_ex ( & cipher_ctx , NULL , NULL , key , ( unsigned char * ) iv ) ; <S2SV_EndBug> <S2SV_StartBug> EVP_EncryptUpdate ( & cipher_ctx , outbuf , & i , ( unsigned char * ) data , data_len ) ; <S2SV_EndBug> outlen = i ; <S2SV_StartBug> if ( EVP_EncryptFinal ( & cipher_ctx , ( unsigned char * ) outbuf + i , & i ) ) { <S2SV_EndBug> outlen += i ; <S2SV_StartBug> if ( raw_output ) { <S2SV_EndBug> outbuf [ outlen ] = '\\\\0' ; RETVAL_STRINGL ( ( char * ) outbuf , outlen , 0 ) ; } else { <S2SV_StartBug> int base64_str_len ; <S2SV_EndBug> char * base64_str ; base64_str = ( char * ) php_base64_encode ( outbuf , outlen , & base64_str_len ) ; efree ( outbuf ) ; RETVAL_STRINGL ( base64_str , base64_str_len , 0 ) ; } } else { efree ( outbuf ) ; RETVAL_FALSE ; } if ( key != ( unsigned char * ) password ) { efree ( key ) ; } if ( free_iv ) { efree ( iv ) ; } EVP_CIPHER_CTX_cleanup ( & cipher_ctx ) ; }", "target": "<S2SV_ModStart> <S2SV_null> PHP_FUNCTION ( openssl_decrypt <S2SV_ModEnd> ) { zend_bool <S2SV_ModStart> ) { zend_bool raw_input <S2SV_ModEnd> = 0 ; <S2SV_ModStart> iv_len = 0 <S2SV_ModEnd> ; const EVP_CIPHER <S2SV_ModStart> * key ; int base64_str_len ; char * base64_str = NULL ; <S2SV_ModStart> password_len , & raw_input <S2SV_ModEnd> , & iv <S2SV_ModStart> return ; } if ( ! method_len ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Unknown<S2SV_blank>cipher<S2SV_blank>algorithm\" ) ; RETURN_FALSE ; } <S2SV_ModStart> ) ; RETURN_FALSE ; } if ( ! raw_input ) { base64_str = ( char * ) php_base64_decode ( ( unsigned char * ) data , data_len , & base64_str_len ) ; data_len = base64_str_len ; data = base64_str <S2SV_ModStart> password ; } free_iv = php_openssl_validate_iv ( & iv , & iv_len , <S2SV_ModEnd> EVP_CIPHER_iv_length ( cipher_type <S2SV_ModStart> ( cipher_type ) <S2SV_ModEnd> TSRMLS_CC ) ; <S2SV_ModStart> 1 ) ; EVP_DecryptInit <S2SV_ModEnd> ( & cipher_ctx <S2SV_ModStart> ) ; } EVP_DecryptInit_ex <S2SV_ModEnd> ( & cipher_ctx <S2SV_ModStart> iv ) ; EVP_DecryptUpdate <S2SV_ModEnd> ( & cipher_ctx <S2SV_ModStart> ; if ( EVP_DecryptFinal <S2SV_ModEnd> ( & cipher_ctx <S2SV_ModStart> += i ; <S2SV_ModEnd> outbuf [ outlen <S2SV_ModStart> } else { efree ( outbuf ) ; RETVAL_FALSE ; } if ( key != ( unsigned char * ) password ) { efree ( key ) ; } if ( free_iv ) { efree ( iv ) ; } if ( base64_str ) { efree ( base64_str <S2SV_ModEnd> ) ; }"}
{"source": "CWE-703 static RList * create_cache_bins ( RBinFile * bf , RDyldCache * cache ) { RList * bins = r_list_newf ( ( RListFree ) free_bin ) ; ut16 * depArray = NULL ; cache_imgxtr_t * extras = NULL ; if ( ! bins ) { return NULL ; } char * target_libs = NULL ; RList * target_lib_names = NULL ; int * deps = NULL ; target_libs = r_sys_getenv ( \"R_DYLDCACHE_FILTER\" ) ; if ( target_libs ) { target_lib_names = r_str_split_list ( target_libs , \":\" , 0 ) ; if ( ! target_lib_names ) { r_list_free ( bins ) ; return NULL ; } deps = R_NEWS0 ( int , cache -> hdr -> imagesCount ) ; if ( ! deps ) { r_list_free ( bins ) ; r_list_free ( target_lib_names ) ; return NULL ; } } ut32 i ; for ( i = 0 ; i < cache -> n_hdr ; i ++ ) { cache_hdr_t * hdr = & cache -> hdr [ i ] ; ut64 hdr_offset = cache -> hdr_offset [ i ] ; ut32 maps_index = cache -> maps_index [ i ] ; cache_img_t * img = read_cache_images ( cache -> buf , hdr , hdr_offset ) ; if ( ! img ) { goto next ; } ut32 j ; if ( target_libs ) { HtPU * path_to_idx = NULL ; if ( cache -> accel ) { depArray = R_NEWS0 ( ut16 , cache -> accel -> depListCount ) ; if ( ! depArray ) { goto next ; } if ( r_buf_fread_at ( cache -> buf , cache -> accel -> depListOffset , ( ut8 * ) depArray , \"s\" , cache -> accel -> depListCount ) != cache -> accel -> depListCount * 2 ) { goto next ; } extras = read_cache_imgextra ( cache -> buf , hdr , cache -> accel ) ; if ( ! extras ) { goto next ; } } else { path_to_idx = create_path_to_index ( cache -> buf , img , hdr ) ; } for ( j = 0 ; j < hdr -> imagesCount ; j ++ ) { bool printing = ! deps [ j ] ; char * lib_name = get_lib_name ( cache -> buf , & img [ j ] ) ; if ( ! lib_name ) { break ; } if ( strstr ( lib_name , \"libobjc.A.dylib\" ) ) { deps [ j ] ++ ; } if ( ! r_list_find ( target_lib_names , lib_name , string_contains ) ) { R_FREE ( lib_name ) ; continue ; } if ( printing ) { eprintf ( \"FILTER:<S2SV_blank>%s\\\\n\" , lib_name ) ; } R_FREE ( lib_name ) ; deps [ j ] ++ ; if ( extras && depArray ) { ut32 k ; for ( k = extras [ j ] . dependentsStartArrayIndex ; depArray [ k ] != 0xffff ; k ++ ) { ut16 dep_index = depArray [ k ] & 0x7fff ; deps [ dep_index ] ++ ; char * dep_name = get_lib_name ( cache -> buf , & img [ dep_index ] ) ; if ( ! dep_name ) { break ; } if ( printing ) { eprintf ( \"-><S2SV_blank>%s\\\\n\" , dep_name ) ; } free ( dep_name ) ; } } else if ( path_to_idx ) { carve_deps_at_address ( cache , img , path_to_idx , img [ j ] . address , deps , printing ) ; } } ht_pu_free ( path_to_idx ) ; R_FREE ( depArray ) ; R_FREE ( extras ) ; } for ( j = 0 ; j < hdr -> imagesCount ; j ++ ) { if ( deps && ! deps [ j ] ) { continue ; } <S2SV_StartBug> ut64 pa = va2pa ( img [ j ] . address , hdr -> mappingCount , & cache -> maps [ maps_index ] , cache -> buf , 0 , NULL , NULL ) ; <S2SV_EndBug> if ( pa == UT64_MAX ) { continue ; } ut8 magicbytes [ 4 ] ; r_buf_read_at ( cache -> buf , pa , magicbytes , 4 ) ; int magic = r_read_le32 ( magicbytes ) ; switch ( magic ) { case MH_MAGIC_64 : { char file [ 256 ] ; RDyldBinImage * bin = R_NEW0 ( RDyldBinImage ) ; if ( ! bin ) { goto next ; } bin -> header_at = pa ; bin -> hdr_offset = hdr_offset ; bin -> symbols_off = resolve_symbols_off ( cache , pa ) ; bin -> va = img [ j ] . address ; if ( r_buf_read_at ( cache -> buf , img [ j ] . pathFileOffset , ( ut8 * ) & file , sizeof ( file ) ) == sizeof ( file ) ) { file [ 255 ] = 0 ; char * last_slash = strrchr ( file , '/' ) ; if ( last_slash && * last_slash ) { if ( last_slash > file ) { char * scan = last_slash - 1 ; while ( scan > file && * scan != '/' ) { scan -- ; } if ( * scan == '/' ) { bin -> file = strdup ( scan + 1 ) ; } else { bin -> file = strdup ( last_slash + 1 ) ; } } else { bin -> file = strdup ( last_slash + 1 ) ; } } else { bin -> file = strdup ( file ) ; } } r_list_append ( bins , bin ) ; break ; } default : eprintf ( \"Unknown<S2SV_blank>sub-bin\\\\n\" ) ; break ; } } next : R_FREE ( depArray ) ; R_FREE ( extras ) ; R_FREE ( img ) ; } if ( r_list_empty ( bins ) ) { r_list_free ( bins ) ; bins = NULL ; } R_FREE ( deps ) ; R_FREE ( target_libs ) ; r_list_free ( target_lib_names ) ; return bins ; }", "target": "<S2SV_ModStart> . address , cache -> n_maps <S2SV_ModEnd> , & cache"}
{"source": "CWE-200 void add_interrupt_randomness ( int irq , int irq_flags ) { struct entropy_store * r ; struct fast_pool * fast_pool = this_cpu_ptr ( & irq_randomness ) ; struct pt_regs * regs = get_irq_regs ( ) ; unsigned long now = jiffies ; cycles_t cycles = random_get_entropy ( ) ; __u32 c_high , j_high ; __u64 ip ; unsigned long seed ; int credit = 0 ; if ( cycles == 0 ) cycles = get_reg ( fast_pool , regs ) ; c_high = ( sizeof ( cycles ) > 4 ) ? cycles >> 32 : 0 ; j_high = ( sizeof ( now ) > 4 ) ? now >> 32 : 0 ; fast_pool -> pool [ 0 ] ^= cycles ^ j_high ^ irq ; fast_pool -> pool [ 1 ] ^= now ^ c_high ; ip = regs ? instruction_pointer ( regs ) : _RET_IP_ ; fast_pool -> pool [ 2 ] ^= ip ; fast_pool -> pool [ 3 ] ^= ( sizeof ( ip ) > 4 ) ? ip >> 32 : get_reg ( fast_pool , regs ) ; fast_mix ( fast_pool ) ; add_interrupt_bench ( cycles ) ; <S2SV_StartBug> <S2SV_EndBug> if ( unlikely ( crng_init == 0 ) ) { if ( ( fast_pool -> count >= 64 ) && crng_fast_load ( ( char * ) fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ) { fast_pool -> count = 0 ; fast_pool -> last = now ; } return ; } if ( ( fast_pool -> count < 64 ) && ! time_after ( now , fast_pool -> last + HZ ) ) return ; r = & input_pool ; if ( ! spin_trylock ( & r -> lock ) ) return ; fast_pool -> last = now ; __mix_pool_bytes ( r , & fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ; if ( arch_get_random_seed_long ( & seed ) ) { __mix_pool_bytes ( r , & seed , sizeof ( seed ) ) ; credit = 1 ; } spin_unlock ( & r -> lock ) ; fast_pool -> count = 0 ; credit_entropy_bits ( r , credit + 1 ) ; }", "target": "<S2SV_ModStart> cycles ) ; this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ;"}
{"source": "CWE-200 void update_process_times ( int user_tick ) { struct task_struct * p = current ; account_process_tick ( p , user_tick ) ; run_local_timers ( ) ; rcu_sched_clock_irq ( user_tick ) ; # ifdef CONFIG_IRQ_WORK if ( in_irq ( ) ) irq_work_tick ( ) ; # endif scheduler_tick ( ) ; if ( IS_ENABLED ( CONFIG_POSIX_TIMERS ) ) run_posix_cpu_timers ( ) ; <S2SV_StartBug> } <S2SV_EndBug>", "target": "<S2SV_ModStart> ( ) ; this_cpu_add ( net_rand_state . s1 , rol32 ( jiffies , 24 ) + user_tick ) ;"}
{"source": "CWE-703 static int get_recurse_data_length ( compiler_common * common , PCRE2_SPTR cc , PCRE2_SPTR ccend , BOOL * needs_control_head , BOOL * has_quit , BOOL * has_accept ) { int length = 1 ; <S2SV_StartBug> int size ; <S2SV_EndBug> PCRE2_SPTR alternative ; BOOL quit_found = FALSE ; BOOL accept_found = FALSE ; BOOL setsom_found = FALSE ; BOOL setmark_found = FALSE ; <S2SV_StartBug> BOOL capture_last_found = FALSE ; <S2SV_EndBug> <S2SV_StartBug> BOOL control_head_found = FALSE ; <S2SV_EndBug> # if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD SLJIT_ASSERT ( common -> control_head_ptr != 0 ) ; control_head_found = TRUE ; # endif while ( cc < ccend ) { size = 0 ; switch ( * cc ) { case OP_SET_SOM : SLJIT_ASSERT ( common -> has_set_som ) ; setsom_found = TRUE ; cc += 1 ; break ; case OP_RECURSE : if ( common -> has_set_som ) setsom_found = TRUE ; if ( common -> mark_ptr != 0 ) setmark_found = TRUE ; <S2SV_StartBug> if ( common -> capture_last_ptr != 0 ) <S2SV_EndBug> capture_last_found = TRUE ; cc += 1 + LINK_SIZE ; break ; case OP_KET : <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> length ++ ; <S2SV_EndBug> SLJIT_ASSERT ( PRIVATE_DATA ( cc + 1 ) != 0 ) ; cc += PRIVATE_DATA ( cc + 1 ) ; } cc += 1 + LINK_SIZE ; break ; case OP_ASSERT : case OP_ASSERT_NOT : case OP_ASSERTBACK : case OP_ASSERTBACK_NOT : case OP_ASSERT_NA : case OP_ASSERTBACK_NA : case OP_ONCE : case OP_SCRIPT_RUN : case OP_BRAPOS : case OP_SBRA : case OP_SBRAPOS : case OP_SCOND : <S2SV_StartBug> length ++ ; <S2SV_EndBug> SLJIT_ASSERT ( PRIVATE_DATA ( cc ) != 0 ) ; <S2SV_StartBug> cc += 1 + LINK_SIZE ; <S2SV_EndBug> break ; case OP_CBRA : case OP_SCBRA : <S2SV_StartBug> length += 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( common -> capture_last_ptr != 0 ) <S2SV_EndBug> capture_last_found = TRUE ; <S2SV_StartBug> if ( common -> optimized_cbracket [ GET2 ( cc , 1 + LINK_SIZE ) ] == 0 ) <S2SV_EndBug> length ++ ; cc += 1 + LINK_SIZE + IMM2_SIZE ; break ; case OP_CBRAPOS : case OP_SCBRAPOS : <S2SV_StartBug> length += 2 + 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( common -> capture_last_ptr != 0 ) <S2SV_EndBug> capture_last_found = TRUE ; cc += 1 + LINK_SIZE + IMM2_SIZE ; break ; case OP_COND : alternative = cc + GET ( cc , 1 ) ; <S2SV_StartBug> if ( * alternative == OP_KETRMAX || * alternative == OP_KETRMIN ) <S2SV_EndBug> length ++ ; cc += 1 + LINK_SIZE ; break ; CASE_ITERATOR_PRIVATE_DATA_1 <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> length ++ ; cc += 2 ; # ifdef SUPPORT_UNICODE if ( common -> utf && HAS_EXTRALEN ( cc [ - 1 ] ) ) cc += GET_EXTRALEN ( cc [ - 1 ] ) ; # endif break ; CASE_ITERATOR_PRIVATE_DATA_2A <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> length += 2 ; <S2SV_EndBug> cc += 2 ; # ifdef SUPPORT_UNICODE if ( common -> utf && HAS_EXTRALEN ( cc [ - 1 ] ) ) cc += GET_EXTRALEN ( cc [ - 1 ] ) ; # endif break ; CASE_ITERATOR_PRIVATE_DATA_2B <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> length += 2 ; <S2SV_EndBug> cc += 2 + IMM2_SIZE ; # ifdef SUPPORT_UNICODE if ( common -> utf && HAS_EXTRALEN ( cc [ - 1 ] ) ) cc += GET_EXTRALEN ( cc [ - 1 ] ) ; # endif break ; CASE_ITERATOR_TYPE_PRIVATE_DATA_1 <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> length ++ ; cc += 1 ; break ; CASE_ITERATOR_TYPE_PRIVATE_DATA_2A <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> length += 2 ; <S2SV_StartBug> cc += 1 ; <S2SV_EndBug> break ; CASE_ITERATOR_TYPE_PRIVATE_DATA_2B <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> length += 2 ; <S2SV_EndBug> cc += 1 + IMM2_SIZE ; break ; case OP_CLASS : case OP_NCLASS : # if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8 case OP_XCLASS : size = ( * cc == OP_XCLASS ) ? GET ( cc , 1 ) : 1 + 32 / ( int ) sizeof ( PCRE2_UCHAR ) ; # else size = 1 + 32 / ( int ) sizeof ( PCRE2_UCHAR ) ; # endif <S2SV_StartBug> if ( PRIVATE_DATA ( cc ) != 0 ) <S2SV_EndBug> length += get_class_iterator_size ( cc + size ) ; cc += size ; break ; case OP_MARK : case OP_COMMIT_ARG : case OP_PRUNE_ARG : case OP_THEN_ARG : SLJIT_ASSERT ( common -> mark_ptr != 0 ) ; if ( ! setmark_found ) setmark_found = TRUE ; if ( common -> control_head_ptr != 0 ) control_head_found = TRUE ; if ( * cc != OP_MARK ) quit_found = TRUE ; cc += 1 + 2 + cc [ 1 ] ; break ; case OP_PRUNE : case OP_SKIP : case OP_COMMIT : quit_found = TRUE ; cc ++ ; break ; case OP_SKIP_ARG : quit_found = TRUE ; cc += 1 + 2 + cc [ 1 ] ; break ; case OP_THEN : SLJIT_ASSERT ( common -> control_head_ptr != 0 ) ; quit_found = TRUE ; <S2SV_StartBug> if ( ! control_head_found ) <S2SV_EndBug> control_head_found = TRUE ; cc ++ ; break ; case OP_ACCEPT : case OP_ASSERT_ACCEPT : accept_found = TRUE ; cc ++ ; break ; default : cc = next_opcode ( common , cc ) ; SLJIT_ASSERT ( cc != NULL ) ; break ; } } SLJIT_ASSERT ( cc == ccend ) ; if ( control_head_found ) length ++ ; <S2SV_StartBug> if ( capture_last_found ) <S2SV_EndBug> length ++ ; if ( quit_found ) { if ( setsom_found ) length ++ ; if ( setmark_found ) length ++ ; } * needs_control_head = control_head_found ; * has_quit = quit_found ; * has_accept = accept_found ; return length ; }", "target": "<S2SV_ModStart> ; int size , offset <S2SV_ModStart> FALSE ; BOOL control_head_found <S2SV_ModEnd> = FALSE ; <S2SV_ModStart> = FALSE ; memset ( common -> recurse_bitset , 0 , common -> recurse_bitset_size ) <S2SV_ModEnd> ; # if <S2SV_ModStart> capture_last_ptr != 0 && recurse_check_bit ( common , common -> capture_last_ptr ) ) length ++ <S2SV_ModEnd> ; cc += <S2SV_ModStart> case OP_KET : offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset <S2SV_ModStart> 0 ) { if ( recurse_check_bit ( common , offset ) ) <S2SV_ModStart> case OP_SCOND : <S2SV_ModEnd> SLJIT_ASSERT ( PRIVATE_DATA <S2SV_ModStart> 0 ) ; if ( recurse_check_bit ( common , PRIVATE_DATA ( cc ) ) ) length ++ ; <S2SV_ModStart> case OP_SCBRA : offset = GET2 ( cc , 1 + LINK_SIZE ) ; if ( recurse_check_bit ( common , OVECTOR ( offset << 1 ) ) ) { SLJIT_ASSERT ( recurse_check_bit ( common , OVECTOR ( ( offset << 1 ) + 1 ) ) ) ; <S2SV_ModStart> += 2 ; } <S2SV_ModEnd> if ( common <S2SV_ModStart> -> optimized_cbracket [ offset <S2SV_ModEnd> ] == 0 <S2SV_ModStart> ] == 0 && recurse_check_bit ( common , OVECTOR_PRIV ( offset ) ) ) length ++ ; if ( common -> capture_last_ptr != 0 && recurse_check_bit ( common , common -> capture_last_ptr ) <S2SV_ModStart> case OP_SCBRAPOS : offset = GET2 ( cc , 1 + LINK_SIZE ) ; if ( recurse_check_bit ( common , OVECTOR ( offset << 1 ) ) ) { SLJIT_ASSERT ( recurse_check_bit ( common , OVECTOR ( ( offset << 1 ) + 1 ) ) ) ; <S2SV_ModStart> length += 2 ; } if ( recurse_check_bit ( common , OVECTOR_PRIV ( offset ) ) ) length ++ ; if ( recurse_check_bit ( common , PRIVATE_DATA ( cc ) ) ) length ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> capture_last_ptr != 0 && recurse_check_bit ( common , common -> capture_last_ptr ) ) length ++ <S2SV_ModEnd> ; cc += <S2SV_ModStart> ) ; if ( <S2SV_ModStart> == OP_KETRMIN ) && recurse_check_bit ( common , PRIVATE_DATA ( cc ) ) ) <S2SV_ModStart> break ; CASE_ITERATOR_PRIVATE_DATA_1 offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset != 0 && recurse_check_bit ( common , offset ) <S2SV_ModEnd> ) length ++ <S2SV_ModStart> break ; CASE_ITERATOR_PRIVATE_DATA_2A offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset != 0 && recurse_check_bit ( common , offset ) ) { SLJIT_ASSERT ( recurse_check_bit ( common , offset + sizeof ( sljit_sw ) ) ) ; <S2SV_ModEnd> length += 2 <S2SV_ModStart> += 2 ; } <S2SV_ModStart> break ; CASE_ITERATOR_PRIVATE_DATA_2B offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset != 0 && recurse_check_bit ( common , offset ) ) { SLJIT_ASSERT ( recurse_check_bit ( common , offset + sizeof ( sljit_sw ) ) ) ; <S2SV_ModEnd> length += 2 <S2SV_ModStart> += 2 ; } <S2SV_ModStart> break ; CASE_ITERATOR_TYPE_PRIVATE_DATA_1 offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset != 0 && recurse_check_bit ( common , offset ) <S2SV_ModEnd> ) length ++ <S2SV_ModStart> break ; CASE_ITERATOR_TYPE_PRIVATE_DATA_2A offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset != 0 && recurse_check_bit ( common , offset ) ) { SLJIT_ASSERT ( recurse_check_bit ( common , offset + sizeof ( sljit_sw ) ) ) ; <S2SV_ModEnd> length += 2 <S2SV_ModStart> += 2 ; } <S2SV_ModStart> break ; CASE_ITERATOR_TYPE_PRIVATE_DATA_2B offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset != 0 && recurse_check_bit ( common , offset ) ) { SLJIT_ASSERT ( recurse_check_bit ( common , offset + sizeof ( sljit_sw ) ) ) ; <S2SV_ModEnd> length += 2 <S2SV_ModStart> += 2 ; } <S2SV_ModStart> ; # endif offset = <S2SV_ModEnd> PRIVATE_DATA ( cc <S2SV_ModStart> ( cc ) ; if ( offset != 0 && recurse_check_bit ( common , offset ) <S2SV_ModEnd> ) length += <S2SV_ModStart> = TRUE ; <S2SV_ModEnd> control_head_found = TRUE <S2SV_ModStart> ; if ( <S2SV_ModEnd> quit_found ) {"}
{"source": "CWE-703 static int xfrm_expand_policies ( const struct flowi * fl , u16 family , struct xfrm_policy * * pols , int * num_pols , int * num_xfrms ) { int i ; if ( * num_pols == 0 || ! pols [ 0 ] ) { * num_pols = 0 ; * num_xfrms = 0 ; return 0 ; } <S2SV_StartBug> if ( IS_ERR ( pols [ 0 ] ) ) <S2SV_EndBug> <S2SV_StartBug> return PTR_ERR ( pols [ 0 ] ) ; <S2SV_EndBug> * num_xfrms = pols [ 0 ] -> xfrm_nr ; # ifdef CONFIG_XFRM_SUB_POLICY if ( pols [ 0 ] -> action == XFRM_POLICY_ALLOW && pols [ 0 ] -> type != XFRM_POLICY_TYPE_MAIN ) { pols [ 1 ] = xfrm_policy_lookup_bytype ( xp_net ( pols [ 0 ] ) , XFRM_POLICY_TYPE_MAIN , fl , family , XFRM_POLICY_OUT , pols [ 0 ] -> if_id ) ; if ( pols [ 1 ] ) { if ( IS_ERR ( pols [ 1 ] ) ) { xfrm_pols_put ( pols , * num_pols ) ; <S2SV_StartBug> return PTR_ERR ( pols [ 1 ] ) ; <S2SV_EndBug> } ( * num_pols ) ++ ; ( * num_xfrms ) += pols [ 1 ] -> xfrm_nr ; } } # endif for ( i = 0 ; i < * num_pols ; i ++ ) { if ( pols [ i ] -> action != XFRM_POLICY_ALLOW ) { * num_xfrms = - 1 ; break ; } } return 0 ; }", "target": "<S2SV_ModStart> ] ) ) { * num_pols = 0 ; <S2SV_ModStart> ] ) ; } <S2SV_ModStart> num_pols ) ; * num_pols = 0 ;"}
{"source": "CWE-703 static int xemaclite_of_probe ( struct platform_device * ofdev ) { struct resource * res ; struct net_device * ndev = NULL ; struct net_local * lp = NULL ; struct device * dev = & ofdev -> dev ; int rc = 0 ; dev_info ( dev , \"Device<S2SV_blank>Tree<S2SV_blank>Probing\\\\n\" ) ; ndev = alloc_etherdev ( sizeof ( struct net_local ) ) ; if ( ! ndev ) return - ENOMEM ; dev_set_drvdata ( dev , ndev ) ; SET_NETDEV_DEV ( ndev , & ofdev -> dev ) ; lp = netdev_priv ( ndev ) ; lp -> ndev = ndev ; res = platform_get_resource ( ofdev , IORESOURCE_IRQ , 0 ) ; if ( ! res ) { dev_err ( dev , \"no<S2SV_blank>IRQ<S2SV_blank>found\\\\n\" ) ; rc = - ENXIO ; goto error ; } ndev -> irq = res -> start ; res = platform_get_resource ( ofdev , IORESOURCE_MEM , 0 ) ; lp -> base_addr = devm_ioremap_resource ( & ofdev -> dev , res ) ; if ( IS_ERR ( lp -> base_addr ) ) { rc = PTR_ERR ( lp -> base_addr ) ; goto error ; } ndev -> mem_start = res -> start ; ndev -> mem_end = res -> end ; spin_lock_init ( & lp -> reset_lock ) ; lp -> next_tx_buf_to_use = 0x0 ; lp -> next_rx_buf_to_use = 0x0 ; lp -> tx_ping_pong = get_bool ( ofdev , \"xlnx,tx-ping-pong\" ) ; lp -> rx_ping_pong = get_bool ( ofdev , \"xlnx,rx-ping-pong\" ) ; rc = of_get_mac_address ( ofdev -> dev . of_node , ndev -> dev_addr ) ; if ( rc ) { dev_warn ( dev , \"No<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>found,<S2SV_blank>using<S2SV_blank>random\\\\n\" ) ; eth_hw_addr_random ( ndev ) ; } xemaclite_writel ( 0 , lp -> base_addr + XEL_TSR_OFFSET ) ; xemaclite_writel ( 0 , lp -> base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET ) ; xemaclite_update_address ( lp , ndev -> dev_addr ) ; lp -> phy_node = of_parse_phandle ( ofdev -> dev . of_node , \"phy-handle\" , 0 ) ; xemaclite_mdio_setup ( lp , & ofdev -> dev ) ; dev_info ( dev , \"MAC<S2SV_blank>address<S2SV_blank>is<S2SV_blank>now<S2SV_blank>%pM\\\\n\" , ndev -> dev_addr ) ; ndev -> netdev_ops = & xemaclite_netdev_ops ; ndev -> ethtool_ops = & xemaclite_ethtool_ops ; ndev -> flags &= ~ IFF_MULTICAST ; ndev -> watchdog_timeo = TX_TIMEOUT ; rc = register_netdev ( ndev ) ; if ( rc ) { dev_err ( dev , \"Cannot<S2SV_blank>register<S2SV_blank>network<S2SV_blank>device,<S2SV_blank>aborting\\\\n\" ) ; goto error ; } dev_info ( dev , <S2SV_StartBug> \"Xilinx<S2SV_blank>EmacLite<S2SV_blank>at<S2SV_blank>0x%08lX<S2SV_blank>mapped<S2SV_blank>to<S2SV_blank>0x%08lX,<S2SV_blank>irq=%d\\\\n\" , <S2SV_EndBug> ( unsigned long __force ) ndev -> mem_start , <S2SV_StartBug> ( unsigned long __force ) lp -> base_addr , ndev -> irq ) ; <S2SV_EndBug> return 0 ; error : free_netdev ( ndev ) ; return rc ; }", "target": "<S2SV_ModStart> ( dev , \"Xilinx<S2SV_blank>EmacLite<S2SV_blank>at<S2SV_blank>0x%08lX<S2SV_blank>mapped<S2SV_blank>to<S2SV_blank>0x%p,<S2SV_blank>irq=%d\\\\n\" <S2SV_ModEnd> , ( unsigned <S2SV_ModStart> -> mem_start , <S2SV_ModEnd> lp -> base_addr"}
{"source": "CWE-200 int main ( int argc , char * * argv ) { int c , rc = MOUNT_EX_SUCCESS , all = 0 , show_labels = 0 ; struct libmnt_context * cxt ; struct libmnt_table * fstab = NULL ; char * srcbuf = NULL ; char * types = NULL ; unsigned long oper = 0 ; enum { MOUNT_OPT_SHARED = CHAR_MAX + 1 , MOUNT_OPT_SLAVE , MOUNT_OPT_PRIVATE , MOUNT_OPT_UNBINDABLE , MOUNT_OPT_RSHARED , MOUNT_OPT_RSLAVE , MOUNT_OPT_RPRIVATE , MOUNT_OPT_RUNBINDABLE , MOUNT_OPT_TARGET , MOUNT_OPT_SOURCE } ; static const struct option longopts [ ] = { { \"all\" , 0 , 0 , 'a' } , { \"fake\" , 0 , 0 , 'f' } , { \"fstab\" , 1 , 0 , 'T' } , { \"fork\" , 0 , 0 , 'F' } , { \"help\" , 0 , 0 , 'h' } , { \"no-mtab\" , 0 , 0 , 'n' } , { \"read-only\" , 0 , 0 , 'r' } , { \"ro\" , 0 , 0 , 'r' } , { \"verbose\" , 0 , 0 , 'v' } , { \"version\" , 0 , 0 , 'V' } , { \"read-write\" , 0 , 0 , 'w' } , { \"rw\" , 0 , 0 , 'w' } , { \"options\" , 1 , 0 , 'o' } , { \"test-opts\" , 1 , 0 , 'O' } , { \"pass-fd\" , 1 , 0 , 'p' } , { \"types\" , 1 , 0 , 't' } , { \"uuid\" , 1 , 0 , 'U' } , { \"label\" , 1 , 0 , 'L' } , { \"bind\" , 0 , 0 , 'B' } , { \"move\" , 0 , 0 , 'M' } , { \"rbind\" , 0 , 0 , 'R' } , { \"make-shared\" , 0 , 0 , MOUNT_OPT_SHARED } , { \"make-slave\" , 0 , 0 , MOUNT_OPT_SLAVE } , { \"make-private\" , 0 , 0 , MOUNT_OPT_PRIVATE } , { \"make-unbindable\" , 0 , 0 , MOUNT_OPT_UNBINDABLE } , { \"make-rshared\" , 0 , 0 , MOUNT_OPT_RSHARED } , { \"make-rslave\" , 0 , 0 , MOUNT_OPT_RSLAVE } , { \"make-rprivate\" , 0 , 0 , MOUNT_OPT_RPRIVATE } , { \"make-runbindable\" , 0 , 0 , MOUNT_OPT_RUNBINDABLE } , { \"no-canonicalize\" , 0 , 0 , 'c' } , { \"internal-only\" , 0 , 0 , 'i' } , { \"show-labels\" , 0 , 0 , 'l' } , { \"target\" , 1 , 0 , MOUNT_OPT_TARGET } , { \"source\" , 1 , 0 , MOUNT_OPT_SOURCE } , { NULL , 0 , 0 , 0 } } ; static const ul_excl_t excl [ ] = { { 'B' , 'M' , 'R' , MOUNT_OPT_SHARED , MOUNT_OPT_SLAVE , MOUNT_OPT_PRIVATE , MOUNT_OPT_UNBINDABLE , MOUNT_OPT_RSHARED , MOUNT_OPT_RSLAVE , MOUNT_OPT_RPRIVATE , MOUNT_OPT_RUNBINDABLE } , { 'L' , 'U' , MOUNT_OPT_SOURCE } , { 0 } } ; int excl_st [ ARRAY_SIZE ( excl ) ] = UL_EXCL_STATUS_INIT ; sanitize_env ( ) ; setlocale ( LC_ALL , \"\" ) ; bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; atexit ( close_stdout ) ; mnt_init_debug ( 0 ) ; cxt = mnt_new_context ( ) ; if ( ! cxt ) err ( MOUNT_EX_SYSERR , _ ( \"libmount<S2SV_blank>context<S2SV_blank>allocation<S2SV_blank>failed\" ) ) ; mnt_context_set_tables_errcb ( cxt , table_parser_errcb ) ; while ( ( c = getopt_long ( argc , argv , \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\" , longopts , NULL ) ) != - 1 ) { if ( mnt_context_is_restricted ( cxt ) && ! strchr ( \"hlLUVvpris\" , c ) && c != MOUNT_OPT_TARGET && c != MOUNT_OPT_SOURCE ) exit_non_root ( option_to_longopt ( c , longopts ) ) ; err_exclusive_options ( c , longopts , excl , excl_st ) ; switch ( c ) { case 'a' : all = 1 ; break ; case 'c' : mnt_context_disable_canonicalize ( cxt , TRUE ) ; break ; case 'f' : mnt_context_enable_fake ( cxt , TRUE ) ; break ; case 'F' : mnt_context_enable_fork ( cxt , TRUE ) ; break ; case 'h' : usage ( stdout ) ; break ; case 'i' : mnt_context_disable_helpers ( cxt , TRUE ) ; break ; case 'n' : mnt_context_disable_mtab ( cxt , TRUE ) ; break ; case 'r' : if ( mnt_context_append_options ( cxt , \"ro\" ) ) err ( MOUNT_EX_SYSERR , _ ( \"failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>options\" ) ) ; readwrite = 0 ; break ; case 'v' : mnt_context_enable_verbose ( cxt , TRUE ) ; break ; case 'V' : print_version ( ) ; break ; case 'w' : if ( mnt_context_append_options ( cxt , \"rw\" ) ) err ( MOUNT_EX_SYSERR , _ ( \"failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>options\" ) ) ; readwrite = 1 ; break ; case 'o' : if ( mnt_context_append_options ( cxt , optarg ) ) err ( MOUNT_EX_SYSERR , _ ( \"failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>options\" ) ) ; break ; case 'O' : if ( mnt_context_set_options_pattern ( cxt , optarg ) ) err ( MOUNT_EX_SYSERR , _ ( \"failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>options<S2SV_blank>pattern\" ) ) ; break ; case 'p' : warnx ( _ ( \"--pass-fd<S2SV_blank>is<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>supported\" ) ) ; break ; case 'L' : xasprintf ( & srcbuf , \"LABEL=\\\\\"%s\\\\\"\" , optarg ) ; mnt_context_disable_swapmatch ( cxt , 1 ) ; mnt_context_set_source ( cxt , srcbuf ) ; free ( srcbuf ) ; break ; case 'U' : xasprintf ( & srcbuf , \"UUID=\\\\\"%s\\\\\"\" , optarg ) ; mnt_context_disable_swapmatch ( cxt , 1 ) ; mnt_context_set_source ( cxt , srcbuf ) ; free ( srcbuf ) ; break ; case 'l' : show_labels = 1 ; break ; case 't' : types = optarg ; break ; case 'T' : fstab = append_fstab ( cxt , fstab , optarg ) ; break ; case 's' : mnt_context_enable_sloppy ( cxt , TRUE ) ; break ; case 'B' : oper |= MS_BIND ; break ; case 'M' : oper |= MS_MOVE ; break ; case 'R' : oper |= ( MS_BIND | MS_REC ) ; break ; case MOUNT_OPT_SHARED : oper |= MS_SHARED ; break ; case MOUNT_OPT_SLAVE : oper |= MS_SLAVE ; break ; case MOUNT_OPT_PRIVATE : oper |= MS_PRIVATE ; break ; case MOUNT_OPT_UNBINDABLE : oper |= MS_UNBINDABLE ; break ; case MOUNT_OPT_RSHARED : oper |= ( MS_SHARED | MS_REC ) ; break ; case MOUNT_OPT_RSLAVE : oper |= ( MS_SLAVE | MS_REC ) ; break ; case MOUNT_OPT_RPRIVATE : oper |= ( MS_PRIVATE | MS_REC ) ; break ; case MOUNT_OPT_RUNBINDABLE : oper |= ( MS_UNBINDABLE | MS_REC ) ; break ; case MOUNT_OPT_TARGET : mnt_context_disable_swapmatch ( cxt , 1 ) ; mnt_context_set_target ( cxt , optarg ) ; break ; case MOUNT_OPT_SOURCE : mnt_context_disable_swapmatch ( cxt , 1 ) ; mnt_context_set_source ( cxt , optarg ) ; break ; default : usage ( stderr ) ; break ; } } argc -= optind ; argv += optind ; if ( fstab && ! mnt_context_is_nocanonicalize ( cxt ) ) { struct libmnt_cache * cache = mnt_context_get_cache ( cxt ) ; mnt_table_set_cache ( fstab , cache ) ; } if ( ! mnt_context_get_source ( cxt ) && ! mnt_context_get_target ( cxt ) && ! argc && ! all ) { if ( oper ) usage ( stderr ) ; print_all ( cxt , types , show_labels ) ; goto done ; } if ( oper && ( types || all || mnt_context_get_source ( cxt ) ) ) usage ( stderr ) ; if ( types && ( all || strchr ( types , ',' ) || strncmp ( types , \"no\" , 2 ) == 0 ) ) mnt_context_set_fstype_pattern ( cxt , types ) ; else if ( types ) mnt_context_set_fstype ( cxt , types ) ; if ( all ) { rc = mount_all ( cxt ) ; goto done ; } else if ( argc == 0 && ( mnt_context_get_source ( cxt ) || mnt_context_get_target ( cxt ) ) ) { if ( mnt_context_is_restricted ( cxt ) && mnt_context_get_source ( cxt ) && mnt_context_get_target ( cxt ) ) exit_non_root ( NULL ) ; } else if ( argc == 1 ) { if ( mnt_context_is_restricted ( cxt ) && mnt_context_get_source ( cxt ) ) exit_non_root ( NULL ) ; mnt_context_set_target ( cxt , argv [ 0 ] ) ; } else if ( argc == 2 && ! mnt_context_get_source ( cxt ) && ! mnt_context_get_target ( cxt ) ) { if ( mnt_context_is_restricted ( cxt ) ) exit_non_root ( NULL ) ; mnt_context_set_source ( cxt , argv [ 0 ] ) ; mnt_context_set_target ( cxt , argv [ 1 ] ) ; } else usage ( stderr ) ; <S2SV_StartBug> if ( oper ) { <S2SV_EndBug> mnt_context_set_mflags ( cxt , oper ) ; mnt_context_set_optsmode ( cxt , MNT_OMODE_NOTAB ) ; } rc = mnt_context_mount ( cxt ) ; rc = mk_exit_code ( cxt , rc ) ; if ( rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose ( cxt ) ) success_message ( cxt ) ; done : mnt_free_context ( cxt ) ; mnt_free_table ( fstab ) ; return rc ; }", "target": "<S2SV_ModStart> ; if ( mnt_context_is_restricted ( cxt ) ) sanitize_paths ( cxt ) ; if ("}
{"source": "CWE-787 bracketed_paste ( paste_mode_T mode , int drop , garray_T * gap ) { int c ; char_u buf [ NUMBUFLEN + MB_MAXBYTES ] ; int idx = 0 ; char_u * end = find_termcode ( ( char_u * ) \"PE\" ) ; int ret_char = - 1 ; int save_allow_keys = allow_keys ; int save_paste = p_paste ; if ( end != NULL && STRLEN ( end ) >= NUMBUFLEN ) end = NULL ; ++ no_mapping ; allow_keys = 0 ; if ( ! p_paste ) set_option_value ( ( char_u * ) \"paste\" , TRUE , NULL , 0 ) ; for ( ; ; ) { if ( end == NULL && vpeekc ( ) == NUL ) break ; do c = vgetc ( ) ; while ( c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR ) ; if ( c == NUL || got_int || ( ex_normal_busy > 0 && c == Ctrl_C ) ) break ; if ( has_mbyte ) idx += ( * mb_char2bytes ) ( c , buf + idx ) ; else buf [ idx ++ ] = c ; buf [ idx ] = NUL ; if ( end != NULL && STRNCMP ( buf , end , idx ) == 0 ) { if ( end [ idx ] == NUL ) break ; continue ; } if ( ! drop ) { switch ( mode ) { case PASTE_CMDLINE : put_on_cmdline ( buf , idx , TRUE ) ; break ; case PASTE_EX : <S2SV_StartBug> if ( gap != NULL && ga_grow ( gap , idx ) == OK ) <S2SV_EndBug> { mch_memmove ( ( char * ) gap -> ga_data + gap -> ga_len , buf , ( size_t ) idx ) ; gap -> ga_len += idx ; } break ; case PASTE_INSERT : if ( stop_arrow ( ) == OK ) { c = buf [ 0 ] ; if ( idx == 1 && ( c == CAR || c == K_KENTER || c == NL ) ) ins_eol ( c ) ; else { ins_char_bytes ( buf , idx ) ; AppendToRedobuffLit ( buf , idx ) ; } } break ; case PASTE_ONE_CHAR : if ( ret_char == - 1 ) { if ( has_mbyte ) ret_char = ( * mb_ptr2char ) ( buf ) ; else ret_char = buf [ 0 ] ; } break ; } } idx = 0 ; } -- no_mapping ; allow_keys = save_allow_keys ; if ( ! save_paste ) set_option_value ( ( char_u * ) \"paste\" , FALSE , NULL , 0 ) ; return ret_char ; }", "target": "<S2SV_ModStart> gap , idx + 1"}
{"source": "CWE-787 check_termcode ( int max_offset , char_u * buf , int bufsize , int * buflen ) { char_u * tp ; char_u * p ; int slen = 0 ; int modslen ; int len ; int retval = 0 ; int offset ; char_u key_name [ 2 ] ; int modifiers ; char_u * modifiers_start = NULL ; int key ; int new_slen ; char_u string [ MAX_KEY_CODE_LEN + 1 ] ; int i , j ; int idx = 0 ; int cpo_koffset ; cpo_koffset = ( vim_strchr ( p_cpo , CPO_KOFFSET ) != NULL ) ; if ( need_gather ) gather_termleader ( ) ; for ( offset = 0 ; offset < max_offset ; ++ offset ) { if ( buf == NULL ) { if ( offset >= typebuf . tb_len ) break ; tp = typebuf . tb_buf + typebuf . tb_off + offset ; len = typebuf . tb_len - offset ; } else { if ( offset >= * buflen ) break ; tp = buf + offset ; len = * buflen - offset ; } if ( * tp == K_SPECIAL ) { offset += 2 ; continue ; } i = * tp ; for ( p = termleader ; * p && * p != i ; ++ p ) ; if ( * p == NUL ) continue ; if ( * tp == ESC && ! p_ek && ( State & MODE_INSERT ) ) continue ; <S2SV_StartBug> key_name [ 0 ] = NUL ; <S2SV_EndBug> key_name [ 1 ] = NUL ; modifiers = 0 ; # ifdef FEAT_GUI if ( gui . in_use ) { if ( * tp == CSI ) { if ( len < 3 ) return - 1 ; slen = 3 ; key_name [ 0 ] = tp [ 1 ] ; key_name [ 1 ] = tp [ 2 ] ; } } else # endif { int mouse_index_found = - 1 ; for ( idx = 0 ; idx < tc_len ; ++ idx ) { slen = termcodes [ idx ] . len ; modifiers_start = NULL ; if ( cpo_koffset && offset && len < slen ) continue ; if ( STRNCMP ( termcodes [ idx ] . code , tp , ( size_t ) ( slen > len ? len : slen ) ) == 0 ) { int looks_like_mouse_start = FALSE ; if ( len < slen ) return - 1 ; if ( termcodes [ idx ] . name [ 0 ] == 'K' && VIM_ISDIGIT ( termcodes [ idx ] . name [ 1 ] ) ) { for ( j = idx + 1 ; j < tc_len ; ++ j ) if ( termcodes [ j ] . len == slen && STRNCMP ( termcodes [ idx ] . code , termcodes [ j ] . code , slen ) == 0 ) { idx = j ; break ; } } if ( slen == 2 && len > 2 && termcodes [ idx ] . code [ 0 ] == ESC && termcodes [ idx ] . code [ 1 ] == '[' ) { if ( ! isdigit ( tp [ 2 ] ) ) { looks_like_mouse_start = TRUE ; } else if ( termcodes [ idx ] . name [ 0 ] == KS_DEC_MOUSE ) { char_u * nr = tp + 2 ; int count = 0 ; for ( ; ; ) { ++ count ; ( void ) getdigits ( & nr ) ; if ( nr >= tp + len ) return - 1 ; if ( * nr != ';' ) break ; ++ nr ; if ( nr >= tp + len ) return - 1 ; } if ( count < 4 ) continue ; } } if ( looks_like_mouse_start ) { if ( mouse_index_found < 0 ) mouse_index_found = idx ; } else { key_name [ 0 ] = termcodes [ idx ] . name [ 0 ] ; key_name [ 1 ] = termcodes [ idx ] . name [ 1 ] ; break ; } } if ( termcodes [ idx ] . modlen > 0 && mouse_index_found < 0 ) { int at_code ; modslen = termcodes [ idx ] . modlen ; if ( cpo_koffset && offset && len < modslen ) continue ; at_code = termcodes [ idx ] . code [ modslen ] == '@' ; if ( STRNCMP ( termcodes [ idx ] . code , tp , ( size_t ) ( modslen > len ? len : modslen ) ) == 0 ) { int n ; if ( len <= modslen ) return - 1 ; if ( tp [ modslen ] == termcodes [ idx ] . code [ slen - 1 ] ) slen = modslen + 1 ; else if ( tp [ modslen ] != ';' && modslen == slen - 3 ) continue ; else if ( at_code && tp [ modslen ] != '1' ) continue ; else { for ( j = slen - 2 ; j < len && ( isdigit ( tp [ j ] ) || tp [ j ] == '-' || tp [ j ] == ';' ) ; ++ j ) ; ++ j ; if ( len < j ) return - 1 ; if ( tp [ j - 1 ] != termcodes [ idx ] . code [ slen - 1 ] ) continue ; modifiers_start = tp + slen - 2 ; n = atoi ( ( char * ) modifiers_start ) ; modifiers |= decode_modifiers ( n ) ; slen = j ; } key_name [ 0 ] = termcodes [ idx ] . name [ 0 ] ; key_name [ 1 ] = termcodes [ idx ] . name [ 1 ] ; break ; } } } if ( idx == tc_len && mouse_index_found >= 0 ) { key_name [ 0 ] = termcodes [ mouse_index_found ] . name [ 0 ] ; key_name [ 1 ] = termcodes [ mouse_index_found ] . name [ 1 ] ; } } # ifdef FEAT_TERMRESPONSE if ( key_name [ 0 ] == NUL # ifdef FEAT_MOUSE_DEC || key_name [ 0 ] == KS_DEC_MOUSE # endif # ifdef FEAT_MOUSE_PTERM || key_name [ 0 ] == KS_PTERM_MOUSE # endif ) { char_u * argp = tp [ 0 ] == ESC ? tp + 2 : tp + 1 ; if ( ( ( tp [ 0 ] == ESC && len >= 3 && tp [ 1 ] == '[' ) || ( tp [ 0 ] == CSI && len >= 2 ) ) && ( VIM_ISDIGIT ( * argp ) || * argp == '>' || * argp == '?' ) ) { int resp = handle_csi ( tp , len , argp , offset , buf , bufsize , buflen , key_name , & slen ) ; if ( resp != 0 ) { # ifdef DEBUG_TERMRESPONSE if ( resp == - 1 ) LOG_TR ( ( \"Not<S2SV_blank>enough<S2SV_blank>characters<S2SV_blank>for<S2SV_blank>CSI<S2SV_blank>sequence\" ) ) ; # endif return resp ; } } else if ( ( * T_RBG != NUL || * T_RFG != NUL ) && ( ( tp [ 0 ] == ESC && len >= 2 && tp [ 1 ] == ']' ) || tp [ 0 ] == OSC ) ) { if ( handle_osc ( tp , argp , len , key_name , & slen ) == FAIL ) return - 1 ; } else if ( ( check_for_codes || rcs_status . tr_progress == STATUS_SENT ) && ( ( tp [ 0 ] == ESC && len >= 2 && tp [ 1 ] == 'P' ) || tp [ 0 ] == DCS ) ) { if ( handle_dcs ( tp , argp , len , key_name , & slen ) == FAIL ) return - 1 ; } } # endif if ( key_name [ 0 ] == NUL ) continue ; # ifdef FEAT_GUI if ( gui . in_use && key_name [ 0 ] == ( int ) KS_EXTRA && ( key_name [ 1 ] == ( int ) KE_X1MOUSE || key_name [ 1 ] == ( int ) KE_X2MOUSE || key_name [ 1 ] == ( int ) KE_MOUSEMOVE_XY || key_name [ 1 ] == ( int ) KE_MOUSELEFT || key_name [ 1 ] == ( int ) KE_MOUSERIGHT || key_name [ 1 ] == ( int ) KE_MOUSEDOWN || key_name [ 1 ] == ( int ) KE_MOUSEUP ) ) { char_u bytes [ 6 ] ; int num_bytes = get_bytes_from_buf ( tp + slen , bytes , 4 ) ; if ( num_bytes == - 1 ) return - 1 ; mouse_col = 128 * ( bytes [ 0 ] - '<S2SV_blank>' - 1 ) + bytes [ 1 ] - '<S2SV_blank>' - 1 ; mouse_row = 128 * ( bytes [ 2 ] - '<S2SV_blank>' - 1 ) + bytes [ 3 ] - '<S2SV_blank>' - 1 ; slen += num_bytes ; if ( key_name [ 1 ] == ( int ) KE_MOUSEMOVE_XY ) key_name [ 1 ] = ( int ) KE_MOUSEMOVE ; } else # endif if ( key_name [ 0 ] == KS_MOUSE # ifdef FEAT_MOUSE_GPM || key_name [ 0 ] == KS_GPM_MOUSE # endif # ifdef FEAT_MOUSE_JSB || key_name [ 0 ] == KS_JSBTERM_MOUSE # endif # ifdef FEAT_MOUSE_NET || key_name [ 0 ] == KS_NETTERM_MOUSE # endif # ifdef FEAT_MOUSE_DEC || key_name [ 0 ] == KS_DEC_MOUSE # endif # ifdef FEAT_MOUSE_PTERM || key_name [ 0 ] == KS_PTERM_MOUSE # endif # ifdef FEAT_MOUSE_URXVT || key_name [ 0 ] == KS_URXVT_MOUSE # endif || key_name [ 0 ] == KS_SGR_MOUSE || key_name [ 0 ] == KS_SGR_MOUSE_RELEASE ) { if ( check_termcode_mouse ( tp , & slen , key_name , modifiers_start , idx , & modifiers ) == - 1 ) return - 1 ; } # ifdef FEAT_GUI # ifdef FEAT_MENU else if ( key_name [ 0 ] == ( int ) KS_MENU ) { long_u val ; int num_bytes = get_long_from_buf ( tp + slen , & val ) ; if ( num_bytes == - 1 ) return - 1 ; current_menu = ( vimmenu_T * ) val ; slen += num_bytes ; if ( check_menu_pointer ( root_menu , current_menu ) == FAIL ) { key_name [ 0 ] = KS_EXTRA ; key_name [ 1 ] = ( int ) KE_IGNORE ; } } # endif # ifdef FEAT_GUI_TABLINE else if ( key_name [ 0 ] == ( int ) KS_TABLINE ) { char_u bytes [ 6 ] ; int num_bytes = get_bytes_from_buf ( tp + slen , bytes , 1 ) ; if ( num_bytes == - 1 ) return - 1 ; current_tab = ( int ) bytes [ 0 ] ; if ( current_tab == 255 ) current_tab = - 1 ; slen += num_bytes ; } else if ( key_name [ 0 ] == ( int ) KS_TABMENU ) { char_u bytes [ 6 ] ; int num_bytes = get_bytes_from_buf ( tp + slen , bytes , 2 ) ; if ( num_bytes == - 1 ) return - 1 ; current_tab = ( int ) bytes [ 0 ] ; current_tabmenu = ( int ) bytes [ 1 ] ; slen += num_bytes ; } # endif # ifndef USE_ON_FLY_SCROLL else if ( key_name [ 0 ] == ( int ) KS_VER_SCROLLBAR ) { long_u val ; char_u bytes [ 6 ] ; int num_bytes ; j = 0 ; for ( i = 0 ; tp [ j ] == CSI && tp [ j + 1 ] == KS_VER_SCROLLBAR && tp [ j + 2 ] != NUL ; ++ i ) { j += 3 ; num_bytes = get_bytes_from_buf ( tp + j , bytes , 1 ) ; if ( num_bytes == - 1 ) break ; if ( i == 0 ) current_scrollbar = ( int ) bytes [ 0 ] ; else if ( current_scrollbar != ( int ) bytes [ 0 ] ) break ; j += num_bytes ; num_bytes = get_long_from_buf ( tp + j , & val ) ; if ( num_bytes == - 1 ) break ; scrollbar_value = val ; j += num_bytes ; slen = j ; } if ( i == 0 ) return - 1 ; } else if ( key_name [ 0 ] == ( int ) KS_HOR_SCROLLBAR ) { long_u val ; int num_bytes ; j = 0 ; for ( i = 0 ; tp [ j ] == CSI && tp [ j + 1 ] == KS_HOR_SCROLLBAR && tp [ j + 2 ] != NUL ; ++ i ) { j += 3 ; num_bytes = get_long_from_buf ( tp + j , & val ) ; if ( num_bytes == - 1 ) break ; scrollbar_value = val ; j += num_bytes ; slen = j ; } if ( i == 0 ) return - 1 ; } # endif # endif # if ( defined ( UNIX ) || defined ( VMS ) ) if ( key_name [ 0 ] == KS_EXTRA # ifdef FEAT_GUI && ! gui . in_use # endif ) { if ( key_name [ 1 ] == KE_FOCUSGAINED ) { if ( ! focus_state ) { ui_focus_change ( TRUE ) ; did_cursorhold = TRUE ; focus_state = TRUE ; } key_name [ 1 ] = ( int ) KE_IGNORE ; } else if ( key_name [ 1 ] == KE_FOCUSLOST ) { if ( focus_state ) { ui_focus_change ( FALSE ) ; did_cursorhold = TRUE ; focus_state = FALSE ; } key_name [ 1 ] = ( int ) KE_IGNORE ; } } # endif key = handle_x_keys ( TERMCAP2KEY ( key_name [ 0 ] , key_name [ 1 ] ) ) ; new_slen = modifiers2keycode ( modifiers , & key , string ) ; key_name [ 0 ] = KEY2TERMCAP0 ( key ) ; key_name [ 1 ] = KEY2TERMCAP1 ( key ) ; if ( key_name [ 0 ] == KS_KEY ) { if ( has_mbyte ) new_slen += ( * mb_char2bytes ) ( key_name [ 1 ] , string + new_slen ) ; else string [ new_slen ++ ] = key_name [ 1 ] ; } else if ( new_slen == 0 && key_name [ 0 ] == KS_EXTRA && key_name [ 1 ] == KE_IGNORE ) { retval = KEYLEN_REMOVED ; } else { string [ new_slen ++ ] = K_SPECIAL ; string [ new_slen ++ ] = key_name [ 0 ] ; string [ new_slen ++ ] = key_name [ 1 ] ; } if ( put_string_in_typebuf ( offset , slen , string , new_slen , buf , bufsize , buflen ) == FAIL ) return - 1 ; return retval == 0 ? ( len + new_slen - slen + offset ) : retval ; } # ifdef FEAT_TERMRESPONSE LOG_TR ( ( \"normal<S2SV_blank>character\" ) ) ; # endif return 0 ; }", "target": "<S2SV_ModStart> ) continue ; tp [ len ] = NUL ;"}
{"source": "CWE-399 networkstatus_parse_vote_from_string ( const char * s , const char * * eos_out , networkstatus_type_t ns_type ) { smartlist_t * tokens = smartlist_create ( ) ; smartlist_t * rs_tokens = NULL , * footer_tokens = NULL ; networkstatus_voter_info_t * voter = NULL ; networkstatus_t * ns = NULL ; digests_t ns_digests ; const char * cert , * end_of_header , * end_of_footer , * s_dup = s ; directory_token_t * tok ; int ok ; struct in_addr in ; int i , inorder , n_signatures = 0 ; memarea_t * area = NULL , * rs_area = NULL ; consensus_flavor_t flav = FLAV_NS ; tor_assert ( s ) ; if ( eos_out ) * eos_out = NULL ; if ( router_get_networkstatus_v3_hashes ( s , & ns_digests ) ) { log_warn ( LD_DIR , \"Unable<S2SV_blank>to<S2SV_blank>compute<S2SV_blank>digest<S2SV_blank>of<S2SV_blank>network-status\" ) ; goto err ; } area = memarea_new ( ) ; end_of_header = find_start_of_next_routerstatus ( s ) ; if ( tokenize_string ( area , s , end_of_header , tokens , ( ns_type == NS_TYPE_CONSENSUS ) ? networkstatus_consensus_token_table : networkstatus_token_table , 0 ) ) { log_warn ( LD_DIR , \"Error<S2SV_blank>tokenizing<S2SV_blank>network-status<S2SV_blank>vote<S2SV_blank>header\" ) ; goto err ; } ns = tor_malloc_zero ( sizeof ( networkstatus_t ) ) ; memcpy ( & ns -> digests , & ns_digests , sizeof ( ns_digests ) ) ; tok = find_by_keyword ( tokens , K_NETWORK_STATUS_VERSION ) ; tor_assert ( tok ) ; if ( tok -> n_args > 1 ) { int flavor = networkstatus_parse_flavor_name ( tok -> args [ 1 ] ) ; if ( flavor < 0 ) { log_warn ( LD_DIR , \"Can\\'t<S2SV_blank>parse<S2SV_blank>document<S2SV_blank>with<S2SV_blank>unknown<S2SV_blank>flavor<S2SV_blank>%s\" , <S2SV_StartBug> escaped ( tok -> args [ 2 ] ) ) ; <S2SV_EndBug> goto err ; } ns -> flavor = flav = flavor ; } if ( flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS ) { log_warn ( LD_DIR , \"Flavor<S2SV_blank>found<S2SV_blank>on<S2SV_blank>non-consensus<S2SV_blank>networkstatus.\" ) ; goto err ; } if ( ns_type != NS_TYPE_CONSENSUS ) { const char * end_of_cert = NULL ; if ( ! ( cert = strstr ( s , \"\\\\ndir-key-certificate-version\" ) ) ) goto err ; ++ cert ; ns -> cert = authority_cert_parse_from_string ( cert , & end_of_cert ) ; if ( ! ns -> cert || ! end_of_cert || end_of_cert > end_of_header ) goto err ; } tok = find_by_keyword ( tokens , K_VOTE_STATUS ) ; tor_assert ( tok -> n_args ) ; if ( ! strcmp ( tok -> args [ 0 ] , \"vote\" ) ) { ns -> type = NS_TYPE_VOTE ; } else if ( ! strcmp ( tok -> args [ 0 ] , \"consensus\" ) ) { ns -> type = NS_TYPE_CONSENSUS ; } else if ( ! strcmp ( tok -> args [ 0 ] , \"opinion\" ) ) { ns -> type = NS_TYPE_OPINION ; } else { log_warn ( LD_DIR , \"Unrecognized<S2SV_blank>vote<S2SV_blank>status<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>network-status\" , escaped ( tok -> args [ 0 ] ) ) ; goto err ; } if ( ns_type != ns -> type ) { log_warn ( LD_DIR , \"Got<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>kind<S2SV_blank>of<S2SV_blank>v3<S2SV_blank>networkstatus.\" ) ; goto err ; } if ( ns -> type == NS_TYPE_VOTE || ns -> type == NS_TYPE_OPINION ) { tok = find_by_keyword ( tokens , K_PUBLISHED ) ; if ( parse_iso_time ( tok -> args [ 0 ] , & ns -> published ) ) goto err ; ns -> supported_methods = smartlist_create ( ) ; tok = find_opt_by_keyword ( tokens , K_CONSENSUS_METHODS ) ; if ( tok ) { for ( i = 0 ; i < tok -> n_args ; ++ i ) smartlist_add ( ns -> supported_methods , tor_strdup ( tok -> args [ i ] ) ) ; } else { smartlist_add ( ns -> supported_methods , tor_strdup ( \"1\" ) ) ; } } else { tok = find_opt_by_keyword ( tokens , K_CONSENSUS_METHOD ) ; if ( tok ) { ns -> consensus_method = ( int ) tor_parse_long ( tok -> args [ 0 ] , 10 , 1 , INT_MAX , & ok , NULL ) ; if ( ! ok ) goto err ; } else { ns -> consensus_method = 1 ; } } tok = find_by_keyword ( tokens , K_VALID_AFTER ) ; if ( parse_iso_time ( tok -> args [ 0 ] , & ns -> valid_after ) ) goto err ; tok = find_by_keyword ( tokens , K_FRESH_UNTIL ) ; if ( parse_iso_time ( tok -> args [ 0 ] , & ns -> fresh_until ) ) goto err ; tok = find_by_keyword ( tokens , K_VALID_UNTIL ) ; if ( parse_iso_time ( tok -> args [ 0 ] , & ns -> valid_until ) ) goto err ; tok = find_by_keyword ( tokens , K_VOTING_DELAY ) ; tor_assert ( tok -> n_args >= 2 ) ; ns -> vote_seconds = ( int ) tor_parse_long ( tok -> args [ 0 ] , 10 , 0 , INT_MAX , & ok , NULL ) ; if ( ! ok ) goto err ; ns -> dist_seconds = ( int ) tor_parse_long ( tok -> args [ 1 ] , 10 , 0 , INT_MAX , & ok , NULL ) ; if ( ! ok ) goto err ; if ( ns -> valid_after + MIN_VOTE_INTERVAL > ns -> fresh_until ) { log_warn ( LD_DIR , \"Vote/consensus<S2SV_blank>freshness<S2SV_blank>interval<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\" ) ; goto err ; } if ( ns -> valid_after + MIN_VOTE_INTERVAL * 2 > ns -> valid_until ) { log_warn ( LD_DIR , \"Vote/consensus<S2SV_blank>liveness<S2SV_blank>interval<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\" ) ; goto err ; } if ( ns -> vote_seconds < MIN_VOTE_SECONDS ) { log_warn ( LD_DIR , \"Vote<S2SV_blank>seconds<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\" ) ; goto err ; } if ( ns -> dist_seconds < MIN_DIST_SECONDS ) { log_warn ( LD_DIR , \"Dist<S2SV_blank>seconds<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\" ) ; goto err ; } if ( ( tok = find_opt_by_keyword ( tokens , K_CLIENT_VERSIONS ) ) ) { ns -> client_versions = tor_strdup ( tok -> args [ 0 ] ) ; } if ( ( tok = find_opt_by_keyword ( tokens , K_SERVER_VERSIONS ) ) ) { ns -> server_versions = tor_strdup ( tok -> args [ 0 ] ) ; } tok = find_by_keyword ( tokens , K_KNOWN_FLAGS ) ; ns -> known_flags = smartlist_create ( ) ; inorder = 1 ; for ( i = 0 ; i < tok -> n_args ; ++ i ) { smartlist_add ( ns -> known_flags , tor_strdup ( tok -> args [ i ] ) ) ; if ( i > 0 && strcmp ( tok -> args [ i - 1 ] , tok -> args [ i ] ) >= 0 ) { log_warn ( LD_DIR , \"%s<S2SV_blank>>=<S2SV_blank>%s\" , tok -> args [ i - 1 ] , tok -> args [ i ] ) ; inorder = 0 ; } } if ( ! inorder ) { log_warn ( LD_DIR , \"known-flags<S2SV_blank>not<S2SV_blank>in<S2SV_blank>order\" ) ; goto err ; } tok = find_opt_by_keyword ( tokens , K_PARAMS ) ; if ( tok ) { inorder = 1 ; ns -> net_params = smartlist_create ( ) ; for ( i = 0 ; i < tok -> n_args ; ++ i ) { int ok = 0 ; char * eq = strchr ( tok -> args [ i ] , '=' ) ; if ( ! eq ) { log_warn ( LD_DIR , \"Bad<S2SV_blank>element<S2SV_blank>\\'%s\\'<S2SV_blank>in<S2SV_blank>params\" , escaped ( tok -> args [ i ] ) ) ; goto err ; } tor_parse_long ( eq + 1 , 10 , INT32_MIN , INT32_MAX , & ok , NULL ) ; if ( ! ok ) { log_warn ( LD_DIR , \"Bad<S2SV_blank>element<S2SV_blank>\\'%s\\'<S2SV_blank>in<S2SV_blank>params\" , escaped ( tok -> args [ i ] ) ) ; goto err ; } if ( i > 0 && strcmp ( tok -> args [ i - 1 ] , tok -> args [ i ] ) >= 0 ) { log_warn ( LD_DIR , \"%s<S2SV_blank>>=<S2SV_blank>%s\" , tok -> args [ i - 1 ] , tok -> args [ i ] ) ; inorder = 0 ; } smartlist_add ( ns -> net_params , tor_strdup ( tok -> args [ i ] ) ) ; } if ( ! inorder ) { log_warn ( LD_DIR , \"params<S2SV_blank>not<S2SV_blank>in<S2SV_blank>order\" ) ; goto err ; } } ns -> voters = smartlist_create ( ) ; SMARTLIST_FOREACH_BEGIN ( tokens , directory_token_t * , _tok ) { tok = _tok ; if ( tok -> tp == K_DIR_SOURCE ) { tor_assert ( tok -> n_args >= 6 ) ; if ( voter ) smartlist_add ( ns -> voters , voter ) ; voter = tor_malloc_zero ( sizeof ( networkstatus_voter_info_t ) ) ; voter -> sigs = smartlist_create ( ) ; if ( ns -> type != NS_TYPE_CONSENSUS ) memcpy ( voter -> vote_digest , ns_digests . d [ DIGEST_SHA1 ] , DIGEST_LEN ) ; voter -> nickname = tor_strdup ( tok -> args [ 0 ] ) ; if ( strlen ( tok -> args [ 1 ] ) != HEX_DIGEST_LEN || base16_decode ( voter -> identity_digest , sizeof ( voter -> identity_digest ) , tok -> args [ 1 ] , HEX_DIGEST_LEN ) < 0 ) { log_warn ( LD_DIR , \"Error<S2SV_blank>decoding<S2SV_blank>identity<S2SV_blank>digest<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>\" \"network-status<S2SV_blank>vote.\" , escaped ( tok -> args [ 1 ] ) ) ; goto err ; } if ( ns -> type != NS_TYPE_CONSENSUS && tor_memneq ( ns -> cert -> cache_info . identity_digest , voter -> identity_digest , DIGEST_LEN ) ) { log_warn ( LD_DIR , \"Mismatch<S2SV_blank>between<S2SV_blank>identities<S2SV_blank>in<S2SV_blank>certificate<S2SV_blank>and<S2SV_blank>vote\" ) ; goto err ; } voter -> address = tor_strdup ( tok -> args [ 2 ] ) ; if ( ! tor_inet_aton ( tok -> args [ 3 ] , & in ) ) { log_warn ( LD_DIR , \"Error<S2SV_blank>decoding<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>network-status.\" , escaped ( tok -> args [ 3 ] ) ) ; goto err ; } voter -> addr = ntohl ( in . s_addr ) ; voter -> dir_port = ( uint16_t ) tor_parse_long ( tok -> args [ 4 ] , 10 , 0 , 65535 , & ok , NULL ) ; if ( ! ok ) goto err ; voter -> or_port = ( uint16_t ) tor_parse_long ( tok -> args [ 5 ] , 10 , 0 , 65535 , & ok , NULL ) ; if ( ! ok ) goto err ; } else if ( tok -> tp == K_CONTACT ) { if ( ! voter || voter -> contact ) { log_warn ( LD_DIR , \"contact<S2SV_blank>element<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>place.\" ) ; goto err ; } voter -> contact = tor_strdup ( tok -> args [ 0 ] ) ; } else if ( tok -> tp == K_VOTE_DIGEST ) { tor_assert ( ns -> type == NS_TYPE_CONSENSUS ) ; tor_assert ( tok -> n_args >= 1 ) ; if ( ! voter || ! tor_digest_is_zero ( voter -> vote_digest ) ) { log_warn ( LD_DIR , \"vote-digest<S2SV_blank>element<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>place.\" ) ; goto err ; } if ( strlen ( tok -> args [ 0 ] ) != HEX_DIGEST_LEN || base16_decode ( voter -> vote_digest , sizeof ( voter -> vote_digest ) , tok -> args [ 0 ] , HEX_DIGEST_LEN ) < 0 ) { log_warn ( LD_DIR , \"Error<S2SV_blank>decoding<S2SV_blank>vote<S2SV_blank>digest<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>\" \"network-status<S2SV_blank>consensus.\" , escaped ( tok -> args [ 0 ] ) ) ; goto err ; } } } SMARTLIST_FOREACH_END ( _tok ) ; if ( voter ) { smartlist_add ( ns -> voters , voter ) ; voter = NULL ; } if ( smartlist_len ( ns -> voters ) == 0 ) { log_warn ( LD_DIR , \"Missing<S2SV_blank>dir-source<S2SV_blank>elements<S2SV_blank>in<S2SV_blank>a<S2SV_blank>vote<S2SV_blank>networkstatus.\" ) ; goto err ; } else if ( ns -> type != NS_TYPE_CONSENSUS && smartlist_len ( ns -> voters ) != 1 ) { log_warn ( LD_DIR , \"Too<S2SV_blank>many<S2SV_blank>dir-source<S2SV_blank>elements<S2SV_blank>in<S2SV_blank>a<S2SV_blank>vote<S2SV_blank>networkstatus.\" ) ; goto err ; } if ( ns -> type != NS_TYPE_CONSENSUS && ( tok = find_opt_by_keyword ( tokens , K_LEGACY_DIR_KEY ) ) ) { int bad = 1 ; if ( strlen ( tok -> args [ 0 ] ) == HEX_DIGEST_LEN ) { networkstatus_voter_info_t * voter = smartlist_get ( ns -> voters , 0 ) ; if ( base16_decode ( voter -> legacy_id_digest , DIGEST_LEN , tok -> args [ 0 ] , HEX_DIGEST_LEN ) < 0 ) bad = 1 ; else bad = 0 ; } if ( bad ) { log_warn ( LD_DIR , \"Invalid<S2SV_blank>legacy<S2SV_blank>key<S2SV_blank>digest<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>vote.\" , escaped ( tok -> args [ 0 ] ) ) ; } } rs_tokens = smartlist_create ( ) ; rs_area = memarea_new ( ) ; s = end_of_header ; ns -> routerstatus_list = smartlist_create ( ) ; while ( ! strcmpstart ( s , \"r<S2SV_blank>\" ) ) { if ( ns -> type != NS_TYPE_CONSENSUS ) { vote_routerstatus_t * rs = tor_malloc_zero ( sizeof ( vote_routerstatus_t ) ) ; if ( routerstatus_parse_entry_from_string ( rs_area , & s , rs_tokens , ns , rs , 0 , 0 ) ) smartlist_add ( ns -> routerstatus_list , rs ) ; else { tor_free ( rs -> version ) ; tor_free ( rs ) ; } } else { routerstatus_t * rs ; if ( ( rs = routerstatus_parse_entry_from_string ( rs_area , & s , rs_tokens , NULL , NULL , ns -> consensus_method , flav ) ) ) smartlist_add ( ns -> routerstatus_list , rs ) ; } } for ( i = 1 ; i < smartlist_len ( ns -> routerstatus_list ) ; ++ i ) { routerstatus_t * rs1 , * rs2 ; if ( ns -> type != NS_TYPE_CONSENSUS ) { vote_routerstatus_t * a = smartlist_get ( ns -> routerstatus_list , i - 1 ) ; vote_routerstatus_t * b = smartlist_get ( ns -> routerstatus_list , i ) ; rs1 = & a -> status ; rs2 = & b -> status ; } else { rs1 = smartlist_get ( ns -> routerstatus_list , i - 1 ) ; rs2 = smartlist_get ( ns -> routerstatus_list , i ) ; } if ( fast_memcmp ( rs1 -> identity_digest , rs2 -> identity_digest , DIGEST_LEN ) >= 0 ) { log_warn ( LD_DIR , \"Vote<S2SV_blank>networkstatus<S2SV_blank>entries<S2SV_blank>not<S2SV_blank>sorted<S2SV_blank>by<S2SV_blank>identity<S2SV_blank>\" \"digest\" ) ; goto err ; } } footer_tokens = smartlist_create ( ) ; if ( ( end_of_footer = strstr ( s , \"\\\\nnetwork-status-version<S2SV_blank>\" ) ) ) ++ end_of_footer ; else end_of_footer = s + strlen ( s ) ; if ( tokenize_string ( area , s , end_of_footer , footer_tokens , networkstatus_vote_footer_token_table , 0 ) ) { log_warn ( LD_DIR , \"Error<S2SV_blank>tokenizing<S2SV_blank>network-status<S2SV_blank>vote<S2SV_blank>footer.\" ) ; goto err ; } { int found_sig = 0 ; SMARTLIST_FOREACH_BEGIN ( footer_tokens , directory_token_t * , _tok ) { tok = _tok ; if ( tok -> tp == K_DIRECTORY_SIGNATURE ) found_sig = 1 ; else if ( found_sig ) { log_warn ( LD_DIR , \"Extraneous<S2SV_blank>token<S2SV_blank>after<S2SV_blank>first<S2SV_blank>directory-signature\" ) ; goto err ; } } SMARTLIST_FOREACH_END ( _tok ) ; } if ( ( tok = find_opt_by_keyword ( footer_tokens , K_DIRECTORY_FOOTER ) ) ) { if ( tok != smartlist_get ( footer_tokens , 0 ) ) { log_warn ( LD_DIR , \"Misplaced<S2SV_blank>directory-footer<S2SV_blank>token\" ) ; goto err ; } } tok = find_opt_by_keyword ( footer_tokens , K_BW_WEIGHTS ) ; if ( tok ) { ns -> weight_params = smartlist_create ( ) ; for ( i = 0 ; i < tok -> n_args ; ++ i ) { int ok = 0 ; char * eq = strchr ( tok -> args [ i ] , '=' ) ; if ( ! eq ) { log_warn ( LD_DIR , \"Bad<S2SV_blank>element<S2SV_blank>\\'%s\\'<S2SV_blank>in<S2SV_blank>weight<S2SV_blank>params\" , escaped ( tok -> args [ i ] ) ) ; goto err ; } tor_parse_long ( eq + 1 , 10 , INT32_MIN , INT32_MAX , & ok , NULL ) ; if ( ! ok ) { log_warn ( LD_DIR , \"Bad<S2SV_blank>element<S2SV_blank>\\'%s\\'<S2SV_blank>in<S2SV_blank>params\" , escaped ( tok -> args [ i ] ) ) ; goto err ; } smartlist_add ( ns -> weight_params , tor_strdup ( tok -> args [ i ] ) ) ; } } SMARTLIST_FOREACH_BEGIN ( footer_tokens , directory_token_t * , _tok ) { char declared_identity [ DIGEST_LEN ] ; networkstatus_voter_info_t * v ; document_signature_t * sig ; const char * id_hexdigest = NULL ; const char * sk_hexdigest = NULL ; digest_algorithm_t alg = DIGEST_SHA1 ; tok = _tok ; if ( tok -> tp != K_DIRECTORY_SIGNATURE ) continue ; tor_assert ( tok -> n_args >= 2 ) ; if ( tok -> n_args == 2 ) { id_hexdigest = tok -> args [ 0 ] ; sk_hexdigest = tok -> args [ 1 ] ; } else { const char * algname = tok -> args [ 0 ] ; int a ; id_hexdigest = tok -> args [ 1 ] ; sk_hexdigest = tok -> args [ 2 ] ; a = crypto_digest_algorithm_parse_name ( algname ) ; if ( a < 0 ) { log_warn ( LD_DIR , \"Unknown<S2SV_blank>digest<S2SV_blank>algorithm<S2SV_blank>%s;<S2SV_blank>skipping\" , escaped ( algname ) ) ; continue ; } alg = a ; } if ( ! tok -> object_type || strcmp ( tok -> object_type , \"SIGNATURE\" ) || tok -> object_size < 128 || tok -> object_size > 512 ) { log_warn ( LD_DIR , \"Bad<S2SV_blank>object<S2SV_blank>type<S2SV_blank>or<S2SV_blank>length<S2SV_blank>on<S2SV_blank>directory-signature\" ) ; goto err ; } if ( strlen ( id_hexdigest ) != HEX_DIGEST_LEN || base16_decode ( declared_identity , sizeof ( declared_identity ) , id_hexdigest , HEX_DIGEST_LEN ) < 0 ) { log_warn ( LD_DIR , \"Error<S2SV_blank>decoding<S2SV_blank>declared<S2SV_blank>identity<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>\" \"network-status<S2SV_blank>vote.\" , escaped ( id_hexdigest ) ) ; goto err ; } if ( ! ( v = networkstatus_get_voter_by_id ( ns , declared_identity ) ) ) { log_warn ( LD_DIR , \"ID<S2SV_blank>on<S2SV_blank>signature<S2SV_blank>on<S2SV_blank>network-status<S2SV_blank>vote<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>\" \"any<S2SV_blank>declared<S2SV_blank>directory<S2SV_blank>source.\" ) ; goto err ; } sig = tor_malloc_zero ( sizeof ( document_signature_t ) ) ; memcpy ( sig -> identity_digest , v -> identity_digest , DIGEST_LEN ) ; sig -> alg = alg ; if ( strlen ( sk_hexdigest ) != HEX_DIGEST_LEN || base16_decode ( sig -> signing_key_digest , sizeof ( sig -> signing_key_digest ) , sk_hexdigest , HEX_DIGEST_LEN ) < 0 ) { log_warn ( LD_DIR , \"Error<S2SV_blank>decoding<S2SV_blank>declared<S2SV_blank>signing<S2SV_blank>key<S2SV_blank>digest<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>\" \"network-status<S2SV_blank>vote.\" , escaped ( sk_hexdigest ) ) ; tor_free ( sig ) ; goto err ; } if ( ns -> type != NS_TYPE_CONSENSUS ) { if ( tor_memneq ( declared_identity , ns -> cert -> cache_info . identity_digest , DIGEST_LEN ) ) { log_warn ( LD_DIR , \"Digest<S2SV_blank>mismatch<S2SV_blank>between<S2SV_blank>declared<S2SV_blank>and<S2SV_blank>actual<S2SV_blank>on<S2SV_blank>\" \"network-status<S2SV_blank>vote.\" ) ; tor_free ( sig ) ; goto err ; } } if ( voter_get_sig_by_algorithm ( v , sig -> alg ) ) { log_fn ( LOG_PROTOCOL_WARN , LD_DIR , \"We<S2SV_blank>received<S2SV_blank>a<S2SV_blank>networkstatus<S2SV_blank>\" \"that<S2SV_blank>contains<S2SV_blank>two<S2SV_blank>votes<S2SV_blank>from<S2SV_blank>the<S2SV_blank>same<S2SV_blank>voter<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>\" \"algorithm.<S2SV_blank>Ignoring<S2SV_blank>the<S2SV_blank>second<S2SV_blank>vote.\" ) ; tor_free ( sig ) ; continue ; } if ( ns -> type != NS_TYPE_CONSENSUS ) { if ( check_signature_token ( ns_digests . d [ DIGEST_SHA1 ] , DIGEST_LEN , tok , ns -> cert -> signing_key , 0 , \"network-status<S2SV_blank>vote\" ) ) { tor_free ( sig ) ; goto err ; } sig -> good_signature = 1 ; } else { if ( tok -> object_size >= INT_MAX || tok -> object_size >= SIZE_T_CEILING ) { tor_free ( sig ) ; goto err ; } sig -> signature = tor_memdup ( tok -> object_body , tok -> object_size ) ; sig -> signature_len = ( int ) tok -> object_size ; } smartlist_add ( v -> sigs , sig ) ; ++ n_signatures ; } SMARTLIST_FOREACH_END ( _tok ) ; if ( ! n_signatures ) { log_warn ( LD_DIR , \"No<S2SV_blank>signatures<S2SV_blank>on<S2SV_blank>networkstatus<S2SV_blank>vote.\" ) ; goto err ; } else if ( ns -> type == NS_TYPE_VOTE && n_signatures != 1 ) { log_warn ( LD_DIR , \"Received<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>signature<S2SV_blank>on<S2SV_blank>a<S2SV_blank>\" \"network-status<S2SV_blank>vote.\" ) ; goto err ; } if ( eos_out ) * eos_out = end_of_footer ; goto done ; err : dump_desc ( s_dup , \"v3<S2SV_blank>networkstatus\" ) ; networkstatus_vote_free ( ns ) ; ns = NULL ; done : if ( tokens ) { SMARTLIST_FOREACH ( tokens , directory_token_t * , t , token_clear ( t ) ) ; smartlist_free ( tokens ) ; } if ( voter ) { if ( voter -> sigs ) { SMARTLIST_FOREACH ( voter -> sigs , document_signature_t * , sig , document_signature_free ( sig ) ) ; smartlist_free ( voter -> sigs ) ; } tor_free ( voter -> nickname ) ; tor_free ( voter -> address ) ; tor_free ( voter -> contact ) ; tor_free ( voter ) ; } if ( rs_tokens ) { SMARTLIST_FOREACH ( rs_tokens , directory_token_t * , t , token_clear ( t ) ) ; smartlist_free ( rs_tokens ) ; } if ( footer_tokens ) { SMARTLIST_FOREACH ( footer_tokens , directory_token_t * , t , token_clear ( t ) ) ; smartlist_free ( footer_tokens ) ; } if ( area ) { DUMP_AREA ( area , \"v3<S2SV_blank>networkstatus\" ) ; memarea_drop_all ( area ) ; } if ( rs_area ) memarea_drop_all ( rs_area ) ; return ns ; }", "target": "<S2SV_ModStart> -> args [ 1 <S2SV_ModEnd> ] ) )"}
{"source": "CWE-476 tgs_build_reply ( astgs_request_t priv , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_context context = priv -> context ; krb5_kdc_configuration * config = priv -> config ; KDC_REQ * req = & priv -> req ; KDC_REQ_BODY * b = & priv -> req . req_body ; const char * from = priv -> from ; krb5_error_code ret , ret2 ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ; const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; if ( b -> kdc_options . canonicalize ) flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 4 , \"No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>user-to-user<S2SV_blank>request\" ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>user-to-user<S2SV_blank>request\" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 4 , \"Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket\" ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket\" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; ret = krb5_unparse_name ( context , p , & tpn ) ; if ( ret ) goto out ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"User-to-user<S2SV_blank>service<S2SV_blank>principal<S2SV_blank>(TGS)<S2SV_blank>unknown\" ) ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"User-to-user<S2SV_blank>enctype<S2SV_blank>not<S2SV_blank>supported\" ) ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"User-to-user<S2SV_blank>TGT<S2SV_blank>decrypt<S2SV_blank>failure\" ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"User-to-user<S2SV_blank>TGT<S2SV_blank>expired<S2SV_blank>or<S2SV_blank>invalid\" ) ; goto out ; } s = & adtkt . cname ; <S2SV_StartBug> r = adtkt . crealm ; <S2SV_EndBug> } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & priv -> sname ) ; if ( ret ) goto out ; spn = priv -> sname ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & priv -> cname ) ; if ( ret ) goto out ; cpn = priv -> cname ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 4 , \"TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]\" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 4 , \"TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s\" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags , NULL , NULL , & server ) ; priv -> server = server ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , \"target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy\" , spn ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Target<S2SV_blank>not<S2SV_blank>found<S2SV_blank>here\" ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 4 , \"Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>\" \"server<S2SV_blank>%s.\" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( priv -> sname ) ; priv -> sname = NULL ; ret = krb5_unparse_name ( context , sp , & priv -> sname ) ; if ( ret ) goto out ; spn = priv -> sname ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret2 = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret2 ) { ret = ret2 ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"No<S2SV_blank>trusted<S2SV_blank>path<S2SV_blank>from<S2SV_blank>client<S2SV_blank>realm<S2SV_blank>to<S2SV_blank>ours\" ) ; goto out ; } } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , \"krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>\" \"realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s\" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( priv -> sname ) ; priv -> sname = NULL ; ret = krb5_unparse_name ( context , sp , & priv -> sname ) ; if ( ret ) goto out ; spn = priv -> sname ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 4 , \"Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>\" \"server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found\" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( priv -> sname ) ; priv -> sname = NULL ; ret = krb5_unparse_name ( context , sp , & priv -> sname ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } spn = priv -> sname ; free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 3 , \"Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s\" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Service<S2SV_blank>principal<S2SV_blank>unknown\" ) ; goto out ; } if ( server -> entry . flags . force_canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 4 , \"Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes\" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"No<S2SV_blank>matching<S2SV_blank>enctypes<S2SV_blank>for<S2SV_blank>2nd<S2SV_blank>ticket\" ) ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( priv , krb5_principal_is_krbtgt ( context , sp ) ? KFE_IS_TGS : 0 , b -> etype . val , b -> etype . len , & etype , NULL , NULL ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes\" , spn ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Enctype<S2SV_blank>not<S2SV_blank>supported\" ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes\" , spn ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Enctype<S2SV_blank>not<S2SV_blank>supported\" ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check\" ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"No<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check\" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>\" \"authz-data<S2SV_blank>signatures\" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>\" \"authz-data<S2SV_blank>signatures\" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 4 , \"No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>\" \"while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s\" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : \"<unknown>\" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 4 , \"Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s\" , ( ret == 0 ) ? ktpn : \"<unknown>\" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>TGT\" ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature\" ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature\" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature\" ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature\" ) ; goto out ; } { krb5_data verified_cas ; ret = krb5_ticket_get_authorization_data_type ( context , ticket , KRB5_AUTHDATA_INITIAL_VERIFIED_CAS , & verified_cas ) ; if ( ret == 0 ) { krb5_data_free ( & verified_cas ) ; flags |= HDB_F_SYNTHETIC_OK ; } } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; flags &= ~ HDB_F_SYNTHETIC_OK ; priv -> client = client ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 4 , \"Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s\" , cpn ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>HDB\" ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 4 , \"Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s\" , msg ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Client<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist\" ) ; krb5_free_error_message ( context , msg ) ; } else if ( ret == 0 && ( client -> entry . flags . invalid || ! client -> entry . flags . client ) ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Client<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>bit<S2SV_blank>set\" ) ; kdc_log ( context , config , 4 , \"Client<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>bit<S2SV_blank>set\" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"PAC<S2SV_blank>check<S2SV_blank>failed\" ) ; kdc_log ( context , config , 4 , \"Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed\" ) ; kdc_log ( context , config , 4 , \"KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { struct astgs_request_desc imp_req ; krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self\" ) ; kdc_log ( context , config , 4 , \"Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self\" ) ; goto out ; } if ( ! krb5_checksum_is_keyed ( context , self . cksum . cksumtype ) ) { free_PA_S4U2Self ( & self ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"PA-S4U2Self<S2SV_blank>with<S2SV_blank>unkeyed<S2SV_blank>checksum\" ) ; kdc_log ( context , config , 4 , \"Reject<S2SV_blank>PA-S4U2Self<S2SV_blank>with<S2SV_blank>unkeyed<S2SV_blank>checksum\" ) ; ret = KRB5KRB_AP_ERR_INAPP_CKSUM ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 4 , \"krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s\" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( self . cksum . cksumtype == CKSUMTYPE_HMAC_MD5 ) { struct krb5_crypto_iov iov ; unsigned char csdata [ 16 ] ; Checksum cs ; cs . checksum . length = sizeof ( csdata ) ; cs . checksum . data = & csdata ; iov . data . data = datack . data ; iov . data . length = datack . length ; iov . flags = KRB5_CRYPTO_TYPE_DATA ; ret = _krb5_HMAC_MD5_checksum ( context , NULL , & crypto -> key , KRB5_KU_OTHER_CKSUM , & iov , 1 , & cs ) ; if ( ret == 0 && krb5_data_ct_cmp ( & cs . checksum , & self . cksum . checksum ) != 0 ) ret = KRB5KRB_AP_ERR_BAD_INTEGRITY ; } else { ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; } krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"S4U2Self<S2SV_blank>checksum<S2SV_blank>failed\" ) ; kdc_log ( context , config , 4 , \"krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s\" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"S4U2Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>not<S2SV_blank>found\" ) ; kdc_log ( context , config , 2 , \"S4U2Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s\" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } s4u2self_impersonated_client -> entry . flags . require_pwchange = FALSE ; free ( s4u2self_impersonated_client -> entry . pw_end ) ; s4u2self_impersonated_client -> entry . pw_end = NULL ; imp_req = * priv ; imp_req . client = s4u2self_impersonated_client ; imp_req . client_princ = tp ; ret = kdc_check_flags ( & imp_req , FALSE ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"KRB5SignedPath<S2SV_blank>missing\" ) ; kdc_log ( context , config , 4 , \"PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s\" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 4 , \"PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s\" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 4 , \"S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>\" \"to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>\" \"(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)\" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation && s4u2self_impersonated_client -> entry . flags . forwardable ) { str = \"[forwardable]\" ; } else { b -> kdc_options . forwardable = 0 ; str = \"\" ; } kdc_log ( context , config , 4 , \"s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>\" \"service<S2SV_blank>%s<S2SV_blank>%s\" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . cname_in_addl_tkt && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"KRB5SignedPath<S2SV_blank>missing\" ) ; kdc_log ( context , config , 4 , \"Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s\" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>constrained<S2SV_blank>delegation<S2SV_blank>ticket\" ) ; kdc_log ( context , config , 4 , \"failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>\" \"constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>\" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; _kdc_audit_addkv ( ( kdc_request_t ) priv , 0 , \"impersonatee\" , \"%s\" , tpn ) ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>constrained<S2SV_blank>delegation\" ) ; kdc_log ( context , config , 4 , \"Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>\" \"constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>\" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Constrained<S2SV_blank>delegation<S2SV_blank>not<S2SV_blank>allowed\" ) ; kdc_log ( context , config , 4 , \"constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed\" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Constrained<S2SV_blank>delegation<S2SV_blank>ticket<S2SV_blank>expired<S2SV_blank>or<S2SV_blank>invalid\" ) ; goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Constrained<S2SV_blank>delegation<S2SV_blank>ticket<S2SV_blank>PAC<S2SV_blank>check<S2SV_blank>failed\" ) ; kdc_log ( context , config , 4 , \"Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client\" \"%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 4 , \"KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>\" \"for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)\" \"from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s\" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed\" ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 4 , \"Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>\" \"for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)\" \"from<S2SV_blank>%s\" , spn , tpn , dpn , cpn , from ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Constrained<S2SV_blank>delegation<S2SV_blank>ticket<S2SV_blank>not<S2SV_blank>signed\" ) ; goto out ; } kdc_log ( context , config , 4 , \"constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>\" \"from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s\" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( priv , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Inconsistent<S2SV_blank>request\" ) ; kdc_log ( context , config , 4 , \"Inconsistent<S2SV_blank>request.\" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( priv , tgt -> caddr , from_addr ) ) { if ( config -> check_ticket_addresses ) { ret = KRB5KRB_AP_ERR_BADADDR ; _kdc_audit_addkv ( ( kdc_request_t ) priv , 0 , \"wrongaddr\" , \"yes\" ) ; kdc_log ( context , config , 4 , \"Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address\" ) ; _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address\" ) ; goto out ; } else if ( config -> warn_ticket_addresses ) { _kdc_audit_addkv ( ( kdc_request_t ) priv , 0 , \"wrongaddr\" , \"yes\" ) ; } } if ( is_anon_tgs_request_p ( b , tgt ) ) { ret = _kdc_check_anon_policy ( priv ) ; if ( ret ) goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 3 , \"Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s\" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { _kdc_audit_addreason ( ( kdc_request_t ) priv , \"Referral<S2SV_blank>build<S2SV_blank>failed\" ) ; kdc_log ( context , config , 4 , \"Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral\" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 4 , \"Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed\" ) ; goto out ; } } ret = tgs_make_reply ( priv , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , client , cp , tgt_realm , krbtgt_out , tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }", "target": "<S2SV_ModStart> adtkt . crealm ; } else if ( s == NULL ) { ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; _kdc_set_e_text ( r , \"No<S2SV_blank>server<S2SV_blank>in<S2SV_blank>request\" ) ; goto out"}
{"source": "CWE-190 dnsc_load_local_data ( struct dnsc_env * dnscenv , struct config_file * cfg ) { size_t i , j ; if ( ! cfg_str2list_insert ( & cfg -> local_zones , strdup ( dnscenv -> provider_name ) , strdup ( \"deny\" ) ) ) { log_err ( \"Could<S2SV_blank>not<S2SV_blank>load<S2SV_blank>dnscrypt<S2SV_blank>local-zone:<S2SV_blank>%s<S2SV_blank>deny\" , dnscenv -> provider_name ) ; return - 1 ; } for ( i = 0 ; i < dnscenv -> signed_certs_count ; i ++ ) { const char * ttl_class_type = \"<S2SV_blank>86400<S2SV_blank>IN<S2SV_blank>TXT<S2SV_blank>\\\\\"\" ; int rotated_cert = 0 ; uint32_t serial ; uint16_t rrlen ; char * rr ; struct SignedCert * cert = dnscenv -> signed_certs + i ; for ( j = 0 ; j < dnscenv -> rotated_certs_count ; j ++ ) { if ( cert == dnscenv -> rotated_certs [ j ] ) { rotated_cert = 1 ; break ; } } memcpy ( & serial , cert -> serial , sizeof serial ) ; serial = htonl ( serial ) ; if ( rotated_cert ) { verbose ( VERB_OPS , \"DNSCrypt:<S2SV_blank>not<S2SV_blank>adding<S2SV_blank>cert<S2SV_blank>with<S2SV_blank>serial<S2SV_blank>#%\" PRIu32 \"<S2SV_blank>to<S2SV_blank>local-data<S2SV_blank>as<S2SV_blank>it<S2SV_blank>is<S2SV_blank>rotated\" , serial ) ; <S2SV_StartBug> continue ; <S2SV_EndBug> } rrlen = strlen ( dnscenv -> provider_name ) + strlen ( ttl_class_type ) + 4 * sizeof ( struct SignedCert ) + 1 + 1 ; rr = malloc ( rrlen ) ; if ( ! rr ) { log_err ( \"Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>memory\" ) ; return - 2 ; } snprintf ( rr , rrlen - 1 , \"%s<S2SV_blank>86400<S2SV_blank>IN<S2SV_blank>TXT<S2SV_blank>\\\\\"\" , dnscenv -> provider_name ) ; for ( j = 0 ; j < sizeof ( struct SignedCert ) ; j ++ ) { int c = ( int ) * ( ( const uint8_t * ) cert + j ) ; if ( isprint ( c ) && c != \\'\"\\' && c != '\\\\\\\\' ) { snprintf ( rr + strlen ( rr ) , rrlen - 1 - strlen ( rr ) , \"%c\" , c ) ; } else { snprintf ( rr + strlen ( rr ) , rrlen - 1 - strlen ( rr ) , \"\\\\\\\\%03d\" , c ) ; } } verbose ( VERB_OPS , \"DNSCrypt:<S2SV_blank>adding<S2SV_blank>cert<S2SV_blank>with<S2SV_blank>serial<S2SV_blank>#%\" PRIu32 \"<S2SV_blank>to<S2SV_blank>local-data<S2SV_blank>to<S2SV_blank>config:<S2SV_blank>%s\" , serial , rr ) ; snprintf ( rr + strlen ( rr ) , rrlen - 1 - strlen ( rr ) , \"\\\\\"\" ) ; cfg_strlist_insert ( & cfg -> local_data , strdup ( rr ) ) ; free ( rr ) ; } return dnscenv -> signed_certs_count ; }", "target": "<S2SV_ModStart> ; continue ; } if ( ( unsigned ) strlen ( dnscenv -> provider_name ) >= ( unsigned ) 0xffff0000 ) { verbose ( VERB_OPS , \"cert<S2SV_blank>#%\" PRIu32 \"<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\" , serial ) ; continue"}
{"source": "CWE-787 cmdline_insert_reg ( int * gotesc UNUSED ) { int i ; <S2SV_StartBug> int c ; <S2SV_EndBug> # ifdef USE_ON_FLY_SCROLL dont_scroll = TRUE ; # endif putcmdline ( \\'\"\\' , TRUE ) ; ++ no_mapping ; ++ allow_keys ; i = c = plain_vgetc ( ) ; if ( i == Ctrl_O ) i = Ctrl_R ; if ( i == Ctrl_R ) c = plain_vgetc ( ) ; extra_char = NUL ; -- no_mapping ; -- allow_keys ; # ifdef FEAT_EVAL new_cmdpos = - 1 ; if ( c == '=' ) { if ( ccline . cmdfirstc == '=' || cmdline_star > 0 ) { beep_flush ( ) ; c = ESC ; } else c = get_expr_register ( ) ; } # endif if ( c != ESC ) { cmdline_paste ( c , i == Ctrl_R , FALSE ) ; # ifdef FEAT_EVAL if ( aborting ( ) ) { * gotesc = TRUE ; return GOTO_NORMAL_MODE ; } # endif KeyTyped = FALSE ; # ifdef FEAT_EVAL if ( new_cmdpos >= 0 ) { if ( new_cmdpos > ccline . cmdlen ) ccline . cmdpos = ccline . cmdlen ; else ccline . cmdpos = new_cmdpos ; } # endif } <S2SV_StartBug> redrawcmd ( ) ; <S2SV_EndBug> return CMDLINE_NOT_CHANGED ; }", "target": "<S2SV_ModStart> ; int c ; int save_new_cmdpos = new_cmdpos <S2SV_ModStart> # endif } new_cmdpos = save_new_cmdpos ;"}
{"source": "CWE-415 <S2SV_StartBug> static RzList * relocs ( RzBinFile * bf ) { <S2SV_EndBug> rz_return_val_if_fail ( bf && bf -> o , NULL ) ; QnxObj * qo = bf -> o -> bin_obj ; <S2SV_StartBug> return rz_list_clone ( qo -> fixups ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> static RzList * maps <S2SV_ModEnd> ( RzBinFile * <S2SV_ModStart> ( qo -> maps <S2SV_ModEnd> ) ; }"}
{"source": "CWE-416 PHP_MINIT_FUNCTION ( snmp ) { netsnmp_log_handler * logh ; zend_class_entry ce , cex ; le_snmp_session = zend_register_list_destructors_ex ( php_snmp_session_destructor , NULL , PHP_SNMP_SESSION_RES_NAME , module_number ) ; init_snmp ( \"snmpapp\" ) ; # ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE netsnmp_ds_set_boolean ( NETSNMP_DS_LIBRARY_ID , NETSNMP_DS_LIB_DONT_PERSIST_STATE , 1 ) ; # endif shutdown_snmp_logging ( ) ; logh = netsnmp_register_loghandler ( NETSNMP_LOGHANDLER_NONE , LOG_ERR ) ; if ( logh ) { logh -> pri_max = LOG_ERR ; } memcpy ( & php_snmp_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; php_snmp_object_handlers . read_property = php_snmp_read_property ; php_snmp_object_handlers . write_property = php_snmp_write_property ; php_snmp_object_handlers . has_property = php_snmp_has_property ; php_snmp_object_handlers . get_properties = php_snmp_get_properties ; <S2SV_StartBug> <S2SV_EndBug> INIT_CLASS_ENTRY ( ce , \"SNMP\" , php_snmp_class_methods ) ; ce . create_object = php_snmp_object_new ; php_snmp_object_handlers . clone_obj = NULL ; php_snmp_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; zend_hash_init ( & php_snmp_properties , 0 , NULL , NULL , 1 ) ; PHP_SNMP_ADD_PROPERTIES ( & php_snmp_properties , php_snmp_property_entries ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OID_OUTPUT_SUFFIX\" , NETSNMP_OID_OUTPUT_SUFFIX , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OID_OUTPUT_MODULE\" , NETSNMP_OID_OUTPUT_MODULE , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OID_OUTPUT_FULL\" , NETSNMP_OID_OUTPUT_FULL , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OID_OUTPUT_NUMERIC\" , NETSNMP_OID_OUTPUT_NUMERIC , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OID_OUTPUT_UCD\" , NETSNMP_OID_OUTPUT_UCD , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OID_OUTPUT_NONE\" , NETSNMP_OID_OUTPUT_NONE , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_VALUE_LIBRARY\" , SNMP_VALUE_LIBRARY , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_VALUE_PLAIN\" , SNMP_VALUE_PLAIN , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_VALUE_OBJECT\" , SNMP_VALUE_OBJECT , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_BIT_STR\" , ASN_BIT_STR , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OCTET_STR\" , ASN_OCTET_STR , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OPAQUE\" , ASN_OPAQUE , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_NULL\" , ASN_NULL , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_OBJECT_ID\" , ASN_OBJECT_ID , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_IPADDRESS\" , ASN_IPADDRESS , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_COUNTER\" , ASN_GAUGE , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_UNSIGNED\" , ASN_UNSIGNED , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_TIMETICKS\" , ASN_TIMETICKS , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_UINTEGER\" , ASN_UINTEGER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_INTEGER\" , ASN_INTEGER , CONST_CS | CONST_PERSISTENT ) ; REGISTER_LONG_CONSTANT ( \"SNMP_COUNTER64\" , ASN_COUNTER64 , CONST_CS | CONST_PERSISTENT ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"VERSION_1\" , SNMP_VERSION_1 ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"VERSION_2c\" , SNMP_VERSION_2c ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"VERSION_2C\" , SNMP_VERSION_2c ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"VERSION_3\" , SNMP_VERSION_3 ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_NOERROR\" , PHP_SNMP_ERRNO_NOERROR ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_ANY\" , PHP_SNMP_ERRNO_ANY ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_GENERIC\" , PHP_SNMP_ERRNO_GENERIC ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_TIMEOUT\" , PHP_SNMP_ERRNO_TIMEOUT ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_ERROR_IN_REPLY\" , PHP_SNMP_ERRNO_ERROR_IN_REPLY ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_OID_NOT_INCREASING\" , PHP_SNMP_ERRNO_OID_NOT_INCREASING ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_OID_PARSING_ERROR\" , PHP_SNMP_ERRNO_OID_PARSING_ERROR ) ; REGISTER_SNMP_CLASS_CONST_LONG ( \"ERRNO_MULTIPLE_SET_QUERIES\" , PHP_SNMP_ERRNO_MULTIPLE_SET_QUERIES ) ; INIT_CLASS_ENTRY ( cex , \"SNMPException\" , NULL ) ; # ifdef HAVE_SPL php_snmp_exception_ce = zend_register_internal_class_ex ( & cex , spl_ce_RuntimeException , NULL TSRMLS_CC ) ; # else php_snmp_exception_ce = zend_register_internal_class_ex ( & cex , zend_exception_get_default ( TSRMLS_C ) , NULL TSRMLS_CC ) ; # endif return SUCCESS ; }", "target": "<S2SV_ModStart> = php_snmp_get_properties ; php_snmp_object_handlers . get_gc = php_snmp_get_gc ;"}
{"source": "CWE-416 R_API void r_core_anal_esil ( RCore * core , const char * str , const char * target ) { bool cfg_anal_strings = r_config_get_i ( core -> config , \"anal.strings\" ) ; bool emu_lazy = r_config_get_i ( core -> config , \"emu.lazy\" ) ; bool gp_fixed = r_config_get_i ( core -> config , \"anal.gpfixed\" ) ; RAnalEsil * ESIL = core -> anal -> esil ; ut64 refptr = 0LL ; <S2SV_StartBug> const char * pcname ; <S2SV_EndBug> RAnalOp op = R_EMPTY ; ut8 * buf = NULL ; bool end_address_set = false ; int iend ; int minopsize = 4 ; bool archIsArm = false ; ut64 addr = core -> offset ; ut64 start = addr ; ut64 end = 0LL ; ut64 cur ; if ( esil_anal_stop || r_cons_is_breaked ( ) ) { return ; } mycore = core ; if ( ! strcmp ( str , \"?\" ) ) { eprintf ( \"Usage:<S2SV_blank>aae[f]<S2SV_blank>[len]<S2SV_blank>[addr]<S2SV_blank>-<S2SV_blank>analyze<S2SV_blank>refs<S2SV_blank>in<S2SV_blank>function,<S2SV_blank>section<S2SV_blank>or<S2SV_blank>len<S2SV_blank>bytes<S2SV_blank>with<S2SV_blank>esil\\\\n\" ) ; eprintf ( \"<S2SV_blank><S2SV_blank>aae<S2SV_blank>$SS<S2SV_blank>@<S2SV_blank>$S<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>analyze<S2SV_blank>the<S2SV_blank>whole<S2SV_blank>section\\\\n\" ) ; eprintf ( \"<S2SV_blank><S2SV_blank>aae<S2SV_blank>$SS<S2SV_blank>str.Hello<S2SV_blank>@<S2SV_blank>$S<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>find<S2SV_blank>references<S2SV_blank>for<S2SV_blank>str.Hellow\\\\n\" ) ; eprintf ( \"<S2SV_blank><S2SV_blank>aaef<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>analyze<S2SV_blank>functions<S2SV_blank>discovered<S2SV_blank>with<S2SV_blank>esil\\\\n\" ) ; return ; } # define CHECKREF ( x ) ( ( refptr && ( x ) == refptr ) || ! refptr ) if ( target ) { const char * expr = r_str_trim_head_ro ( target ) ; if ( * expr ) { refptr = ntarget = r_num_math ( core -> num , expr ) ; if ( ! refptr ) { ntarget = refptr = addr ; } } else { ntarget = UT64_MAX ; refptr = 0LL ; } } else { ntarget = UT64_MAX ; refptr = 0LL ; } RAnalFunction * fcn = NULL ; if ( ! strcmp ( str , \"f\" ) ) { fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , 0 ) ; if ( fcn ) { start = r_anal_function_min_addr ( fcn ) ; addr = fcn -> addr ; end = r_anal_function_max_addr ( fcn ) ; end_address_set = true ; } } if ( ! end_address_set ) { if ( str [ 0 ] == '<S2SV_blank>' ) { end = addr + r_num_math ( core -> num , str + 1 ) ; } else { RIOMap * map = r_io_map_get_at ( core -> io , addr ) ; if ( map ) { end = r_io_map_end ( map ) ; } else { end = addr + core -> blocksize ; } } } iend = end - start ; if ( iend < 0 ) { return ; } if ( iend > MAX_SCAN_SIZE ) { eprintf ( \"Warning:<S2SV_blank>Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>analyze<S2SV_blank>0x%08\" PFMT64x \"<S2SV_blank>bytes.\\\\n\" , ( ut64 ) iend ) ; return ; } buf = malloc ( ( size_t ) iend + 2 ) ; if ( ! buf ) { perror ( \"malloc\" ) ; return ; } esilbreak_last_read = UT64_MAX ; r_io_read_at ( core -> io , start , buf , iend + 1 ) ; if ( ! ESIL ) { r_core_cmd0 ( core , \"aei\" ) ; ESIL = core -> anal -> esil ; if ( ! ESIL ) { eprintf ( \"ESIL<S2SV_blank>not<S2SV_blank>initialized\\\\n\" ) ; return ; } r_core_cmd0 ( core , \"aeim\" ) ; ESIL = core -> anal -> esil ; } <S2SV_StartBug> const char * spname = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_SP ) ; <S2SV_EndBug> if ( ! spname ) { eprintf ( \"Error:<S2SV_blank>No<S2SV_blank>=SP<S2SV_blank>defined<S2SV_blank>in<S2SV_blank>the<S2SV_blank>reg<S2SV_blank>profile.\\\\n\" ) ; return ; } EsilBreakCtx ctx = { & op , fcn , spname , r_reg_getv ( core -> anal -> reg , spname ) } ; ESIL -> cb . hook_reg_write = & esilbreak_reg_write ; ESIL -> user = & ctx ; ESIL -> cb . hook_mem_read = & esilbreak_mem_read ; ESIL -> cb . hook_mem_write = & esilbreak_mem_write ; if ( fcn && fcn -> reg_save_area ) { r_reg_setv ( core -> anal -> reg , ctx . spname , ctx . initial_sp - fcn -> reg_save_area ) ; } <S2SV_StartBug> pcname = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pcname || ! * pcname ) { <S2SV_EndBug> eprintf ( \"Cannot<S2SV_blank>find<S2SV_blank>program<S2SV_blank>counter<S2SV_blank>register<S2SV_blank>in<S2SV_blank>the<S2SV_blank>current<S2SV_blank>profile.\\\\n\" ) ; return ; } esil_anal_stop = false ; r_cons_break_push ( cccb , core ) ; int arch = - 1 ; if ( ! strcmp ( core -> anal -> cur -> arch , \"arm\" ) ) { switch ( core -> anal -> cur -> bits ) { case 64 : arch = R2_ARCH_ARM64 ; break ; case 32 : arch = R2_ARCH_ARM32 ; break ; case 16 : arch = R2_ARCH_THUMB ; break ; } archIsArm = true ; } ut64 gp = r_config_get_i ( core -> config , \"anal.gp\" ) ; const char * gp_reg = NULL ; if ( ! strcmp ( core -> anal -> cur -> arch , \"mips\" ) ) { gp_reg = \"gp\" ; arch = R2_ARCH_MIPS ; } const char * sn = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_SN ) ; if ( ! sn ) { eprintf ( \"Warning:<S2SV_blank>No<S2SV_blank>SN<S2SV_blank>reg<S2SV_blank>alias<S2SV_blank>for<S2SV_blank>current<S2SV_blank>architecture.\\\\n\" ) ; } r_reg_arena_push ( core -> anal -> reg ) ; IterCtx ictx = { start , end , fcn , NULL } ; size_t i = addr - start ; size_t i_old = 0 ; do { if ( esil_anal_stop || r_cons_is_breaked ( ) ) { break ; } cur = start + i ; if ( ! r_io_is_valid_offset ( core -> io , cur , 0 ) ) { break ; } # if 0 { RPVector * list = r_meta_get_all_in ( core -> anal , cur , R_META_TYPE_ANY ) ; void * * it ; r_pvector_foreach ( list , it ) { RIntervalNode * node = * it ; RAnalMetaItem * meta = node -> data ; switch ( meta -> type ) { case R_META_TYPE_DATA : case R_META_TYPE_STRING : case R_META_TYPE_FORMAT : # if 0 { int msz = r_meta_get_size ( core -> anal , meta -> type ) ; i += ( msz > 0 ) ? msz : minopsize ; } r_pvector_free ( list ) ; goto loopback ; # elif 0 { int msz = r_meta_get_size ( core -> anal , meta -> type ) ; i += ( msz > 0 ) ? msz : minopsize ; i -- ; } # else i += 4 ; goto repeat ; # endif default : break ; } } r_pvector_free ( list ) ; } # endif r_core_seek_arch_bits ( core , cur ) ; int opalign = core -> anal -> pcalign ; if ( opalign > 0 ) { cur -= ( cur % opalign ) ; } r_anal_op_fini ( & op ) ; r_asm_set_pc ( core -> rasm , cur ) ; i_old = i ; <S2SV_StartBug> # if 1 <S2SV_EndBug> if ( i > iend ) { goto repeat ; } <S2SV_StartBug> # endif <S2SV_EndBug> if ( ! r_anal_op ( core -> anal , & op , cur , buf + i , iend - i , R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT ) ) { i += minopsize - 1 ; } if ( op . type == R_ANAL_OP_TYPE_ILL || op . type == R_ANAL_OP_TYPE_UNK ) { r_anal_op_fini ( & op ) ; goto repeat ; } if ( op . size < 1 ) { i += minopsize - 1 ; goto repeat ; } if ( emu_lazy ) { if ( op . type & R_ANAL_OP_TYPE_REP ) { i += op . size - 1 ; goto repeat ; } switch ( op . type & R_ANAL_OP_TYPE_MASK ) { case R_ANAL_OP_TYPE_JMP : case R_ANAL_OP_TYPE_CJMP : case R_ANAL_OP_TYPE_CALL : case R_ANAL_OP_TYPE_RET : case R_ANAL_OP_TYPE_ILL : case R_ANAL_OP_TYPE_NOP : case R_ANAL_OP_TYPE_UJMP : case R_ANAL_OP_TYPE_IO : case R_ANAL_OP_TYPE_LEAVE : case R_ANAL_OP_TYPE_CRYPTO : case R_ANAL_OP_TYPE_CPL : case R_ANAL_OP_TYPE_SYNC : case R_ANAL_OP_TYPE_SWI : case R_ANAL_OP_TYPE_CMP : case R_ANAL_OP_TYPE_ACMP : case R_ANAL_OP_TYPE_NULL : case R_ANAL_OP_TYPE_CSWI : case R_ANAL_OP_TYPE_TRAP : i += op . size - 1 ; goto repeat ; case R_ANAL_OP_TYPE_PUSH : case R_ANAL_OP_TYPE_POP : i += op . size - 1 ; goto repeat ; } } if ( sn && op . type == R_ANAL_OP_TYPE_SWI ) { r_strf_buffer ( 64 ) ; r_flag_space_set ( core -> flags , R_FLAGS_FS_SYSCALLS ) ; int snv = ( arch == R2_ARCH_THUMB ) ? op . val : ( int ) r_reg_getv ( core -> anal -> reg , sn ) ; RSyscallItem * si = r_syscall_get ( core -> anal -> syscall , snv , - 1 ) ; if ( si ) { r_flag_set_next ( core -> flags , r_strf ( \"syscall.%s\" , si -> name ) , cur , 1 ) ; } else { r_flag_set_next ( core -> flags , r_strf ( \"syscall.%d\" , snv ) , cur , 1 ) ; } r_flag_space_set ( core -> flags , NULL ) ; r_syscall_item_free ( si ) ; } const char * esilstr = R_STRBUF_SAFEGET ( & op . esil ) ; i += op . size - 1 ; if ( R_STR_ISEMPTY ( esilstr ) ) { goto repeat ; } r_anal_esil_set_pc ( ESIL , cur ) ; r_reg_setv ( core -> anal -> reg , pcname , cur + op . size ) ; if ( gp_fixed && gp_reg ) { r_reg_setv ( core -> anal -> reg , gp_reg , gp ) ; } ( void ) r_anal_esil_parse ( ESIL , esilstr ) ; switch ( op . type ) { case R_ANAL_OP_TYPE_LEA : if ( core -> anal -> cur && arch == R2_ARCH_ARM64 ) { if ( CHECKREF ( ESIL -> cur ) ) { r_anal_xrefs_set ( core -> anal , cur , ESIL -> cur , R_ANAL_REF_TYPE_STRING ) ; } } else if ( ( target && op . ptr == ntarget ) || ! target ) { if ( CHECKREF ( ESIL -> cur ) ) { if ( op . ptr && r_io_is_valid_offset ( core -> io , op . ptr , ! core -> anal -> opt . noncode ) ) { r_anal_xrefs_set ( core -> anal , cur , op . ptr , R_ANAL_REF_TYPE_STRING ) ; } else { r_anal_xrefs_set ( core -> anal , cur , ESIL -> cur , R_ANAL_REF_TYPE_STRING ) ; } } } if ( cfg_anal_strings ) { add_string_ref ( core , op . addr , op . ptr ) ; } break ; case R_ANAL_OP_TYPE_ADD : if ( core -> anal -> cur && archIsArm ) { ut64 dst = ESIL -> cur ; if ( ( target && dst == ntarget ) || ! target ) { if ( CHECKREF ( dst ) ) { int type = core_type_by_addr ( core , dst ) ; r_anal_xrefs_set ( core -> anal , cur , dst , type ) ; } } if ( cfg_anal_strings ) { add_string_ref ( core , op . addr , dst ) ; } } else if ( ( core -> anal -> bits == 32 && core -> anal -> cur && arch == R2_ARCH_MIPS ) ) { ut64 dst = ESIL -> cur ; if ( ! op . src [ 0 ] || ! op . src [ 0 ] -> reg || ! op . src [ 0 ] -> reg -> name ) { break ; } if ( ! strcmp ( op . src [ 0 ] -> reg -> name , \"sp\" ) ) { break ; } if ( ! strcmp ( op . src [ 0 ] -> reg -> name , \"zero\" ) ) { break ; } if ( ( target && dst == ntarget ) || ! target ) { if ( dst > 0xffff && op . src [ 1 ] && ( dst & 0xffff ) == ( op . src [ 1 ] -> imm & 0xffff ) && myvalid ( mycore -> io , dst ) ) { RFlagItem * f ; char * str ; if ( CHECKREF ( dst ) || CHECKREF ( cur ) ) { r_anal_xrefs_set ( core -> anal , cur , dst , R_ANAL_REF_TYPE_DATA ) ; if ( cfg_anal_strings ) { add_string_ref ( core , op . addr , dst ) ; } if ( ( f = r_core_flag_get_by_spaces ( core -> flags , dst ) ) ) { r_meta_set_string ( core -> anal , R_META_TYPE_COMMENT , cur , f -> name ) ; } else if ( ( str = is_string_at ( mycore , dst , NULL ) ) ) { char * str2 = r_str_newf ( \"esilref:<S2SV_blank>\\'%s\\'\" , str ) ; r_str_replace_char ( str2 , '%' , '&' ) ; r_meta_set_string ( core -> anal , R_META_TYPE_COMMENT , cur , str2 ) ; free ( str2 ) ; free ( str ) ; } } } } } break ; case R_ANAL_OP_TYPE_LOAD : { ut64 dst = esilbreak_last_read ; if ( dst != UT64_MAX && CHECKREF ( dst ) ) { if ( myvalid ( mycore -> io , dst ) ) { r_anal_xrefs_set ( core -> anal , cur , dst , R_ANAL_REF_TYPE_DATA ) ; if ( cfg_anal_strings ) { add_string_ref ( core , op . addr , dst ) ; } } } dst = esilbreak_last_data ; if ( dst != UT64_MAX && CHECKREF ( dst ) ) { if ( myvalid ( mycore -> io , dst ) ) { r_anal_xrefs_set ( core -> anal , cur , dst , R_ANAL_REF_TYPE_DATA ) ; if ( cfg_anal_strings ) { add_string_ref ( core , op . addr , dst ) ; } } } } break ; case R_ANAL_OP_TYPE_JMP : { ut64 dst = op . jump ; if ( CHECKREF ( dst ) ) { if ( myvalid ( core -> io , dst ) ) { r_anal_xrefs_set ( core -> anal , cur , dst , R_ANAL_REF_TYPE_CODE ) ; } } } break ; case R_ANAL_OP_TYPE_CALL : { ut64 dst = op . jump ; if ( CHECKREF ( dst ) ) { if ( myvalid ( core -> io , dst ) ) { r_anal_xrefs_set ( core -> anal , cur , dst , R_ANAL_REF_TYPE_CALL ) ; } ESIL -> old = cur + op . size ; getpcfromstack ( core , ESIL ) ; } } break ; case R_ANAL_OP_TYPE_UJMP : case R_ANAL_OP_TYPE_UCALL : case R_ANAL_OP_TYPE_ICALL : case R_ANAL_OP_TYPE_RCALL : case R_ANAL_OP_TYPE_IRCALL : case R_ANAL_OP_TYPE_MJMP : { ut64 dst = core -> anal -> esil -> jump_target ; if ( dst == 0 || dst == UT64_MAX ) { dst = r_reg_getv ( core -> anal -> reg , pcname ) ; } if ( CHECKREF ( dst ) ) { if ( myvalid ( core -> io , dst ) ) { RAnalRefType ref = ( op . type & R_ANAL_OP_TYPE_MASK ) == R_ANAL_OP_TYPE_UCALL ? R_ANAL_REF_TYPE_CALL : R_ANAL_REF_TYPE_CODE ; r_anal_xrefs_set ( core -> anal , cur , dst , ref ) ; r_core_anal_fcn ( core , dst , UT64_MAX , R_ANAL_REF_TYPE_NULL , 1 ) ; # if 0 if ( op . type == R_ANAL_OP_TYPE_UCALL || op . type == R_ANAL_OP_TYPE_RCALL ) { eprintf ( \"0x%08\" PFMT64x \"<S2SV_blank><S2SV_blank>RCALL<S2SV_blank>TO<S2SV_blank>%llx\\\\n\" , cur , dst ) ; } # endif } } } break ; default : break ; } r_anal_esil_stack_free ( ESIL ) ; repeat : if ( ! r_anal_get_block_at ( core -> anal , cur ) ) { size_t fcn_i ; for ( fcn_i = i_old + 1 ; fcn_i <= i ; fcn_i ++ ) { if ( r_anal_get_function_at ( core -> anal , start + fcn_i ) ) { i = fcn_i - 1 ; break ; } } } if ( i >= iend ) { break ; } } while ( get_next_i ( & ictx , & i ) ) ; <S2SV_StartBug> r_list_free ( ictx . bbl ) ; <S2SV_EndBug> r_list_free ( ictx . path ) ; r_list_free ( ictx . switch_path ) ; free ( buf ) ; ESIL -> cb . hook_mem_read = NULL ; ESIL -> cb . hook_mem_write = NULL ; ESIL -> cb . hook_reg_write = NULL ; ESIL -> user = NULL ; r_anal_op_fini ( & op ) ; r_cons_break_pop ( ) ; r_reg_arena_pop ( core -> anal -> reg ) ; }", "target": "<S2SV_ModStart> = 0LL ; <S2SV_ModEnd> char * pcname <S2SV_ModStart> char * pcname = NULL <S2SV_ModStart> const char * kspname = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_SP ) ; if ( R_STR_ISEMPTY ( kspname ) ) { eprintf ( \"Error:<S2SV_blank>No<S2SV_blank>=SP<S2SV_blank>defined<S2SV_blank>in<S2SV_blank>the<S2SV_blank>reg<S2SV_blank>profile.\\\\n\" ) ; return ; } char * spname = strdup ( kspname ) ; <S2SV_ModEnd> EsilBreakCtx ctx = <S2SV_ModStart> ) ; } const char * kpcname <S2SV_ModEnd> = r_reg_get_name ( <S2SV_ModStart> if ( ! kpcname <S2SV_ModEnd> || ! * <S2SV_ModStart> || ! * kpcname ) { eprintf ( \"Cannot<S2SV_blank>find<S2SV_blank>program<S2SV_blank>counter<S2SV_blank>register<S2SV_blank>in<S2SV_blank>the<S2SV_blank>current<S2SV_blank>profile.\\\\n\" ) ; return ; } pcname = strdup ( kpcname ) ; <S2SV_ModEnd> esil_anal_stop = false <S2SV_ModStart> = i ; <S2SV_ModEnd> if ( i <S2SV_ModStart> repeat ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ) ; free ( pcname ) ; free ( spname ) ;"}
{"source": "CWE-416 getcmdline_int ( int firstc , long count UNUSED , int indent , int clear_ccline ) { static int depth = 0 ; int c ; int i ; int j ; int gotesc = FALSE ; int do_abbr ; char_u * lookfor = NULL ; int hiscnt ; int histype ; # ifdef FEAT_SEARCH_EXTRA incsearch_state_T is_state ; # endif int did_wild_list = FALSE ; int wim_index = 0 ; int res ; int save_msg_scroll = msg_scroll ; int save_State = State ; int some_key_typed = FALSE ; int ignore_drag_release = TRUE ; # ifdef FEAT_EVAL int break_ctrl_c = FALSE ; # endif expand_T xpc ; <S2SV_StartBug> long * b_im_ptr = NULL ; <S2SV_EndBug> cmdline_info_T save_ccline ; int did_save_ccline = FALSE ; int cmdline_type ; int wild_type ; ++ depth ; if ( ccline . cmdbuff != NULL ) { save_cmdline ( & save_ccline ) ; did_save_ccline = TRUE ; } if ( clear_ccline ) CLEAR_FIELD ( ccline ) ; # ifdef FEAT_EVAL if ( firstc == - 1 ) { firstc = NUL ; break_ctrl_c = TRUE ; } # endif # ifdef FEAT_RIGHTLEFT if ( firstc == ':' || firstc == '=' || firstc == '>' ) cmd_hkmap = 0 ; # endif # ifdef FEAT_SEARCH_EXTRA init_incsearch_state ( & is_state ) ; # endif if ( init_ccline ( firstc , indent ) != OK ) goto theend ; if ( depth == 50 ) { emsg ( _ ( e_command_too_recursive ) ) ; goto theend ; } ExpandInit ( & xpc ) ; ccline . xpc = & xpc ; # ifdef FEAT_RIGHTLEFT if ( curwin -> w_p_rl && * curwin -> w_p_rlc == 's' && ( firstc == '/' || firstc == '?' ) ) cmdmsg_rl = TRUE ; else cmdmsg_rl = FALSE ; # endif redir_off = TRUE ; if ( ! cmd_silent ) { i = msg_scrolled ; msg_scrolled = 0 ; gotocmdline ( TRUE ) ; msg_scrolled += i ; redrawcmdprompt ( ) ; set_cmdspos ( ) ; } xpc . xp_context = EXPAND_NOTHING ; xpc . xp_backslash = XP_BS_NONE ; # ifndef BACKSLASH_IN_FILENAME xpc . xp_shell = FALSE ; # endif # if defined ( FEAT_EVAL ) if ( ccline . input_fn ) { xpc . xp_context = ccline . xp_context ; xpc . xp_pattern = ccline . cmdbuff ; xpc . xp_arg = ccline . xp_arg ; } # endif msg_scroll = FALSE ; State = MODE_CMDLINE ; if ( firstc == '/' || firstc == '?' || firstc == '@' ) { if ( curbuf -> b_p_imsearch == B_IMODE_USE_INSERT ) b_im_ptr = & curbuf -> b_p_iminsert ; else <S2SV_StartBug> b_im_ptr = & curbuf -> b_p_imsearch ; <S2SV_EndBug> if ( * b_im_ptr == B_IMODE_LMAP ) State |= MODE_LANGMAP ; # ifdef HAVE_INPUT_METHOD im_set_active ( * b_im_ptr == B_IMODE_IM ) ; # endif } # ifdef HAVE_INPUT_METHOD else if ( p_imcmdline ) im_set_active ( TRUE ) ; # endif setmouse ( ) ; # ifdef CURSOR_SHAPE ui_cursor_shape ( ) ; # endif settmode ( TMODE_RAW ) ; cmdline_type = firstc == NUL ? '-' : firstc ; trigger_cmd_autocmd ( cmdline_type , EVENT_CMDLINEENTER ) ; # ifdef FEAT_EVAL if ( ! debug_mode ) may_trigger_modechanged ( ) ; # endif init_history ( ) ; hiscnt = get_hislen ( ) ; histype = hist_char2type ( firstc ) ; # ifdef FEAT_DIGRAPHS do_digraph ( - 1 ) ; # endif if ( did_emsg ) redrawcmd ( ) ; # ifdef FEAT_STL_OPT if ( ! cmd_silent && msg_scrolled == 0 ) { int found_one = FALSE ; win_T * wp ; FOR_ALL_WINDOWS ( wp ) if ( * p_stl != NUL || * wp -> w_p_stl != NUL ) { wp -> w_redr_status = TRUE ; found_one = TRUE ; } if ( * p_tal != NUL ) { redraw_tabline = TRUE ; found_one = TRUE ; } if ( found_one ) redraw_statuslines ( ) ; } # endif did_emsg = FALSE ; got_int = FALSE ; for ( ; ; ) { int trigger_cmdlinechanged = TRUE ; int end_wildmenu ; redir_off = TRUE ; # ifdef USE_ON_FLY_SCROLL dont_scroll = FALSE ; # endif quit_more = FALSE ; did_emsg = FALSE ; may_trigger_safestate ( xpc . xp_numfiles <= 0 ) ; do { cursorcmd ( ) ; c = safe_vgetc ( ) ; } while ( c == K_IGNORE || c == K_NOP ) ; if ( c == K_COMMAND || c == K_SCRIPT_COMMAND ) { int clen = ccline . cmdlen ; if ( do_cmdkey_command ( c , DOCMD_NOWAIT ) == OK ) { if ( clen == ccline . cmdlen ) trigger_cmdlinechanged = FALSE ; goto cmdline_changed ; } } if ( KeyTyped ) { some_key_typed = TRUE ; # ifdef FEAT_RIGHTLEFT if ( cmd_hkmap ) c = hkmap ( c ) ; if ( cmdmsg_rl && ! KeyStuffed ) { switch ( c ) { case K_RIGHT : c = K_LEFT ; break ; case K_S_RIGHT : c = K_S_LEFT ; break ; case K_C_RIGHT : c = K_C_LEFT ; break ; case K_LEFT : c = K_RIGHT ; break ; case K_S_LEFT : c = K_S_RIGHT ; break ; case K_C_LEFT : c = K_C_RIGHT ; break ; } } # endif } if ( ( c == Ctrl_C # ifdef UNIX || c == intr_char # endif ) # if defined ( FEAT_EVAL ) || defined ( FEAT_CRYPT ) && firstc != '@' # endif # ifdef FEAT_EVAL && ( ! break_ctrl_c || exmode_active ) # endif && ! global_busy ) got_int = FALSE ; if ( lookfor != NULL && c != K_S_DOWN && c != K_S_UP && c != K_DOWN && c != K_UP && c != K_PAGEDOWN && c != K_PAGEUP && c != K_KPAGEDOWN && c != K_KPAGEUP && c != K_LEFT && c != K_RIGHT && ( xpc . xp_numfiles > 0 || ( c != Ctrl_P && c != Ctrl_N ) ) ) VIM_CLEAR ( lookfor ) ; if ( c != p_wc && c == K_S_TAB && xpc . xp_numfiles > 0 ) c = Ctrl_P ; if ( p_wmnu ) c = wildmenu_translate_key ( & ccline , c , & xpc , did_wild_list ) ; if ( cmdline_pum_active ( ) ) { if ( c == Ctrl_E || c == Ctrl_Y ) { wild_type = ( c == Ctrl_E ) ? WILD_CANCEL : WILD_APPLY ; if ( nextwild ( & xpc , wild_type , WILD_NO_BEEP , firstc != '@' ) == FAIL ) break ; c = Ctrl_E ; } } end_wildmenu = ( ! ( c == p_wc && KeyTyped ) && c != p_wcm && c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L ) ; end_wildmenu = end_wildmenu && ( ! cmdline_pum_active ( ) || ( c != K_PAGEDOWN && c != K_PAGEUP && c != K_KPAGEDOWN && c != K_KPAGEUP ) ) ; if ( end_wildmenu ) { if ( cmdline_pum_active ( ) ) cmdline_pum_remove ( ) ; if ( xpc . xp_numfiles != - 1 ) ( void ) ExpandOne ( & xpc , NULL , NULL , 0 , WILD_FREE ) ; did_wild_list = FALSE ; if ( ! p_wmnu || ( c != K_UP && c != K_DOWN ) ) xpc . xp_context = EXPAND_NOTHING ; wim_index = 0 ; wildmenu_cleanup ( & ccline ) ; } if ( p_wmnu ) c = wildmenu_process_key ( & ccline , c , & xpc ) ; if ( c == Ctrl_BSL ) { res = cmdline_handle_backslash_key ( c , & gotesc ) ; if ( res == CMDLINE_CHANGED ) goto cmdline_changed ; else if ( res == CMDLINE_NOT_CHANGED ) goto cmdline_not_changed ; else if ( res == GOTO_NORMAL_MODE ) goto returncmd ; c = Ctrl_BSL ; } # ifdef FEAT_CMDWIN if ( c == cedit_key || c == K_CMDWIN ) { if ( ( c == K_CMDWIN || ex_normal_busy == 0 ) && got_int == FALSE ) { c = open_cmdwin ( ) ; some_key_typed = TRUE ; } } # ifdef FEAT_DIGRAPHS else # endif # endif # ifdef FEAT_DIGRAPHS c = do_digraph ( c ) ; # endif if ( c == '\\\\n' || c == '\\\\r' || c == K_KENTER || ( c == ESC && ( ! KeyTyped || vim_strchr ( p_cpo , CPO_ESC ) != NULL ) ) ) { if ( exmode_active && c != ESC && ccline . cmdpos == ccline . cmdlen && ccline . cmdpos > 0 && ccline . cmdbuff [ ccline . cmdpos - 1 ] == '\\\\\\\\' ) { if ( c == K_KENTER ) c = '\\\\n' ; } else { gotesc = FALSE ; if ( ccheck_abbr ( c + ABBR_OFF ) ) goto cmdline_changed ; if ( ! cmd_silent ) { windgoto ( msg_row , 0 ) ; out_flush ( ) ; } break ; } } if ( ( c == p_wc && ! gotesc && KeyTyped ) || c == p_wcm ) { res = cmdline_wildchar_complete ( c , firstc != '@' , & did_wild_list , & wim_index , & xpc , & gotesc ) ; if ( res == CMDLINE_CHANGED ) goto cmdline_changed ; } gotesc = FALSE ; if ( c == K_S_TAB && KeyTyped ) { if ( nextwild ( & xpc , WILD_EXPAND_KEEP , 0 , firstc != '@' ) == OK ) { if ( xpc . xp_numfiles > 1 && ( ( ! did_wild_list && ( wim_flags [ wim_index ] & WIM_LIST ) ) || p_wmnu ) ) { showmatches ( & xpc , p_wmnu && ( ( wim_flags [ wim_index ] & WIM_LIST ) == 0 ) ) ; } if ( nextwild ( & xpc , WILD_PREV , 0 , firstc != '@' ) == OK && nextwild ( & xpc , WILD_PREV , 0 , firstc != '@' ) == OK ) goto cmdline_changed ; } } if ( c == NUL || c == K_ZERO ) c = NL ; do_abbr = TRUE ; switch ( c ) { case K_BS : case Ctrl_H : case K_DEL : case K_KDEL : case Ctrl_W : res = cmdline_erase_chars ( c , indent # ifdef FEAT_SEARCH_EXTRA , & is_state # endif ) ; if ( res == CMDLINE_NOT_CHANGED ) goto cmdline_not_changed ; else if ( res == GOTO_NORMAL_MODE ) goto returncmd ; goto cmdline_changed ; case K_INS : case K_KINS : ccline . overstrike = ! ccline . overstrike ; # ifdef CURSOR_SHAPE ui_cursor_shape ( ) ; # endif goto cmdline_not_changed ; case Ctrl_HAT : <S2SV_StartBug> cmdline_toggle_langmap ( b_im_ptr ) ; <S2SV_EndBug> goto cmdline_not_changed ; case Ctrl_U : j = ccline . cmdpos ; ccline . cmdlen -= j ; i = ccline . cmdpos = 0 ; while ( i < ccline . cmdlen ) ccline . cmdbuff [ i ++ ] = ccline . cmdbuff [ j ++ ] ; ccline . cmdbuff [ ccline . cmdlen ] = NUL ; # ifdef FEAT_SEARCH_EXTRA if ( ccline . cmdlen == 0 ) is_state . search_start = is_state . save_cursor ; # endif redrawcmd ( ) ; goto cmdline_changed ; # ifdef FEAT_CLIPBOARD case Ctrl_Y : if ( clip_star . state != SELECT_CLEARED ) { if ( clip_star . state == SELECT_DONE ) clip_copy_modeless_selection ( TRUE ) ; goto cmdline_not_changed ; } break ; # endif case ESC : case Ctrl_C : if ( exmode_active && ( ex_normal_busy == 0 || typebuf . tb_len > 0 ) ) goto cmdline_not_changed ; gotesc = TRUE ; goto returncmd ; case Ctrl_R : res = cmdline_insert_reg ( & gotesc ) ; if ( res == CMDLINE_NOT_CHANGED ) goto cmdline_not_changed ; else if ( res == GOTO_NORMAL_MODE ) goto returncmd ; goto cmdline_changed ; case Ctrl_D : if ( showmatches ( & xpc , FALSE ) == EXPAND_NOTHING ) break ; redrawcmd ( ) ; continue ; case K_RIGHT : case K_S_RIGHT : case K_C_RIGHT : do { if ( ccline . cmdpos >= ccline . cmdlen ) break ; i = cmdline_charsize ( ccline . cmdpos ) ; if ( KeyTyped && ccline . cmdspos + i >= Columns * Rows ) break ; ccline . cmdspos += i ; if ( has_mbyte ) ccline . cmdpos += ( * mb_ptr2len ) ( ccline . cmdbuff + ccline . cmdpos ) ; else ++ ccline . cmdpos ; } while ( ( c == K_S_RIGHT || c == K_C_RIGHT || ( mod_mask & ( MOD_MASK_SHIFT | MOD_MASK_CTRL ) ) ) && ccline . cmdbuff [ ccline . cmdpos ] != '<S2SV_blank>' ) ; if ( has_mbyte ) set_cmdspos_cursor ( ) ; goto cmdline_not_changed ; case K_LEFT : case K_S_LEFT : case K_C_LEFT : if ( ccline . cmdpos == 0 ) goto cmdline_not_changed ; do { -- ccline . cmdpos ; if ( has_mbyte ) ccline . cmdpos -= ( * mb_head_off ) ( ccline . cmdbuff , ccline . cmdbuff + ccline . cmdpos ) ; ccline . cmdspos -= cmdline_charsize ( ccline . cmdpos ) ; } while ( ccline . cmdpos > 0 && ( c == K_S_LEFT || c == K_C_LEFT || ( mod_mask & ( MOD_MASK_SHIFT | MOD_MASK_CTRL ) ) ) && ccline . cmdbuff [ ccline . cmdpos - 1 ] != '<S2SV_blank>' ) ; if ( has_mbyte ) set_cmdspos_cursor ( ) ; goto cmdline_not_changed ; case K_IGNORE : goto cmdline_not_changed ; # ifdef FEAT_GUI_MSWIN case K_F4 : if ( mod_mask == MOD_MASK_ALT ) { redrawcmd ( ) ; goto cmdline_not_changed ; } break ; # endif case K_MIDDLEDRAG : case K_MIDDLERELEASE : goto cmdline_not_changed ; case K_MIDDLEMOUSE : # ifdef FEAT_GUI if ( ! gui . in_use ) # endif if ( ! mouse_has ( MOUSE_COMMAND ) ) goto cmdline_not_changed ; # ifdef FEAT_CLIPBOARD if ( clip_star . available ) cmdline_paste ( '*' , TRUE , TRUE ) ; else # endif cmdline_paste ( 0 , TRUE , TRUE ) ; redrawcmd ( ) ; goto cmdline_changed ; # ifdef FEAT_DND case K_DROP : cmdline_paste ( '~' , TRUE , FALSE ) ; redrawcmd ( ) ; goto cmdline_changed ; # endif case K_LEFTDRAG : case K_LEFTRELEASE : case K_RIGHTDRAG : case K_RIGHTRELEASE : if ( ignore_drag_release ) goto cmdline_not_changed ; case K_LEFTMOUSE : case K_RIGHTMOUSE : cmdline_left_right_mouse ( c , & ignore_drag_release ) ; goto cmdline_not_changed ; case K_MOUSEDOWN : case K_MOUSEUP : case K_MOUSELEFT : case K_MOUSERIGHT : case K_X1MOUSE : case K_X1DRAG : case K_X1RELEASE : case K_X2MOUSE : case K_X2DRAG : case K_X2RELEASE : case K_MOUSEMOVE : goto cmdline_not_changed ; # ifdef FEAT_GUI case K_LEFTMOUSE_NM : case K_LEFTRELEASE_NM : goto cmdline_not_changed ; case K_VER_SCROLLBAR : if ( msg_scrolled == 0 ) { gui_do_scroll ( ) ; redrawcmd ( ) ; } goto cmdline_not_changed ; case K_HOR_SCROLLBAR : if ( msg_scrolled == 0 ) { gui_do_horiz_scroll ( scrollbar_value , FALSE ) ; redrawcmd ( ) ; } goto cmdline_not_changed ; # endif # ifdef FEAT_GUI_TABLINE case K_TABLINE : case K_TABMENU : if ( gui_use_tabline ( ) ) gui_mch_set_curtab ( tabpage_index ( curtab ) ) ; goto cmdline_not_changed ; # endif case K_SELECT : goto cmdline_not_changed ; case Ctrl_B : case K_HOME : case K_KHOME : case K_S_HOME : case K_C_HOME : ccline . cmdpos = 0 ; set_cmdspos ( ) ; goto cmdline_not_changed ; case Ctrl_E : case K_END : case K_KEND : case K_S_END : case K_C_END : ccline . cmdpos = ccline . cmdlen ; set_cmdspos_cursor ( ) ; goto cmdline_not_changed ; case Ctrl_A : if ( cmdline_pum_active ( ) ) cmdline_pum_cleanup ( & ccline ) ; if ( nextwild ( & xpc , WILD_ALL , 0 , firstc != '@' ) == FAIL ) break ; xpc . xp_context = EXPAND_NOTHING ; did_wild_list = FALSE ; goto cmdline_changed ; case Ctrl_L : # ifdef FEAT_SEARCH_EXTRA if ( may_add_char_to_search ( firstc , & c , & is_state ) == OK ) goto cmdline_not_changed ; # endif if ( nextwild ( & xpc , WILD_LONGEST , 0 , firstc != '@' ) == FAIL ) break ; goto cmdline_changed ; case Ctrl_N : case Ctrl_P : if ( xpc . xp_numfiles > 0 ) { wild_type = ( c == Ctrl_P ) ? WILD_PREV : WILD_NEXT ; if ( nextwild ( & xpc , wild_type , 0 , firstc != '@' ) == FAIL ) break ; goto cmdline_not_changed ; } case K_UP : case K_DOWN : case K_S_UP : case K_S_DOWN : case K_PAGEUP : case K_KPAGEUP : case K_PAGEDOWN : case K_KPAGEDOWN : if ( cmdline_pum_active ( ) && ( c == K_PAGEUP || c == K_PAGEDOWN || c == K_KPAGEUP || c == K_KPAGEDOWN ) ) { wild_type = WILD_PAGEUP ; if ( c == K_PAGEDOWN || c == K_KPAGEDOWN ) wild_type = WILD_PAGEDOWN ; if ( nextwild ( & xpc , wild_type , 0 , firstc != '@' ) == FAIL ) break ; goto cmdline_not_changed ; } else { res = cmdline_browse_history ( c , firstc , & lookfor , histype , & hiscnt , & xpc ) ; if ( res == CMDLINE_CHANGED ) goto cmdline_changed ; else if ( res == GOTO_NORMAL_MODE ) goto returncmd ; } goto cmdline_not_changed ; # ifdef FEAT_SEARCH_EXTRA case Ctrl_G : case Ctrl_T : if ( may_adjust_incsearch_highlighting ( firstc , count , & is_state , c ) == FAIL ) goto cmdline_not_changed ; break ; # endif case Ctrl_V : case Ctrl_Q : { ignore_drag_release = TRUE ; putcmdline ( '^' , TRUE ) ; c = get_literal ( mod_mask & MOD_MASK_SHIFT ) ; do_abbr = FALSE ; extra_char = NUL ; if ( enc_utf8 && utf_iscomposing ( c ) && ! cmd_silent ) { draw_cmdline ( ccline . cmdpos , ccline . cmdlen - ccline . cmdpos ) ; msg_putchar ( '<S2SV_blank>' ) ; cursorcmd ( ) ; } } break ; # ifdef FEAT_DIGRAPHS case Ctrl_K : ignore_drag_release = TRUE ; putcmdline ( '?' , TRUE ) ; # ifdef USE_ON_FLY_SCROLL dont_scroll = TRUE ; # endif c = get_digraph ( TRUE ) ; extra_char = NUL ; if ( c != NUL ) break ; redrawcmd ( ) ; goto cmdline_not_changed ; # endif # ifdef FEAT_RIGHTLEFT case Ctrl__ : if ( ! p_ari ) break ; cmd_hkmap = ! cmd_hkmap ; goto cmdline_not_changed ; # endif case K_PS : bracketed_paste ( PASTE_CMDLINE , FALSE , NULL ) ; goto cmdline_changed ; default : # ifdef UNIX if ( c == intr_char ) { gotesc = TRUE ; goto returncmd ; } # endif if ( ! IS_SPECIAL ( c ) ) mod_mask = 0x0 ; break ; } if ( do_abbr && ( IS_SPECIAL ( c ) || ! vim_iswordc ( c ) ) && ( ccheck_abbr ( ( has_mbyte && c >= 0x100 ) ? ( c + ABBR_OFF ) : c ) || c == Ctrl_RSB ) ) goto cmdline_changed ; if ( IS_SPECIAL ( c ) || mod_mask != 0 ) put_on_cmdline ( get_special_key_name ( c , mod_mask ) , - 1 , TRUE ) ; else { if ( has_mbyte ) { j = ( * mb_char2bytes ) ( c , IObuff ) ; IObuff [ j ] = NUL ; put_on_cmdline ( IObuff , j , TRUE ) ; } else { IObuff [ 0 ] = c ; put_on_cmdline ( IObuff , 1 , TRUE ) ; } } goto cmdline_changed ; cmdline_not_changed : # ifdef FEAT_SEARCH_EXTRA if ( ! is_state . incsearch_postponed ) continue ; # endif cmdline_changed : # ifdef FEAT_SEARCH_EXTRA if ( is_state . winid != curwin -> w_id ) init_incsearch_state ( & is_state ) ; # endif if ( trigger_cmdlinechanged ) trigger_cmd_autocmd ( cmdline_type , EVENT_CMDLINECHANGED ) ; # ifdef FEAT_SEARCH_EXTRA if ( xpc . xp_context == EXPAND_NOTHING && ( KeyTyped || vpeekc ( ) == NUL ) ) may_do_incsearch_highlighting ( firstc , count , & is_state ) ; # endif # ifdef FEAT_RIGHTLEFT if ( cmdmsg_rl # ifdef FEAT_ARABIC || ( p_arshape && ! p_tbidi && cmdline_has_arabic ( 0 , ccline . cmdlen ) ) # endif ) if ( vpeekc ( ) == NUL ) redrawcmd ( ) ; # endif } returncmd : # ifdef FEAT_RIGHTLEFT cmdmsg_rl = FALSE ; # endif ExpandCleanup ( & xpc ) ; ccline . xpc = NULL ; # ifdef FEAT_SEARCH_EXTRA finish_incsearch_highlighting ( gotesc , & is_state , FALSE ) ; # endif if ( ccline . cmdbuff != NULL ) { if ( ccline . cmdlen && firstc != NUL && ( some_key_typed || histype == HIST_SEARCH ) ) { add_to_history ( histype , ccline . cmdbuff , TRUE , histype == HIST_SEARCH ? firstc : NUL ) ; if ( firstc == ':' ) { vim_free ( new_last_cmdline ) ; new_last_cmdline = vim_strsave ( ccline . cmdbuff ) ; } } if ( gotesc ) abandon_cmdline ( ) ; } msg_check ( ) ; msg_scroll = save_msg_scroll ; redir_off = FALSE ; if ( some_key_typed ) need_wait_return = FALSE ; trigger_cmd_autocmd ( cmdline_type , EVENT_CMDLINELEAVE ) ; State = save_State ; # ifdef FEAT_EVAL if ( ! debug_mode ) may_trigger_modechanged ( ) ; # endif # ifdef HAVE_INPUT_METHOD <S2SV_StartBug> if ( b_im_ptr != NULL && * b_im_ptr != B_IMODE_LMAP ) <S2SV_EndBug> im_save_status ( b_im_ptr ) ; im_set_active ( FALSE ) ; # endif setmouse ( ) ; # ifdef CURSOR_SHAPE ui_cursor_shape ( ) ; # endif sb_text_end_cmdline ( ) ; theend : { char_u * p = ccline . cmdbuff ; -- depth ; if ( did_save_ccline ) restore_cmdline ( & save_ccline ) ; else ccline . cmdbuff = NULL ; return p ; } }", "target": "<S2SV_ModStart> long * b_im_ptr = NULL ; buf_T * b_im_ptr_buf <S2SV_ModStart> curbuf -> b_p_imsearch ; b_im_ptr_buf = curbuf <S2SV_ModStart> : cmdline_toggle_langmap ( buf_valid ( b_im_ptr_buf ) ? b_im_ptr : NULL <S2SV_ModEnd> ) ; goto <S2SV_ModStart> != NULL && buf_valid ( b_im_ptr_buf ) &&"}
{"source": "CWE-416 PlayerGeneric : : ~ PlayerGeneric ( ) { <S2SV_StartBug> if ( mixer ) <S2SV_EndBug> delete mixer ; if ( player ) { <S2SV_StartBug> if ( mixer -> isActive ( ) && ! mixer -> isDeviceRemoved ( player ) ) <S2SV_EndBug> mixer -> removeDevice ( player ) ; delete player ; } <S2SV_StartBug> delete [ ] audioDriverName ; <S2SV_EndBug> delete listener ; }", "target": "<S2SV_ModStart> ( ) { <S2SV_ModEnd> if ( player <S2SV_ModStart> { if ( mixer && <S2SV_ModStart> player ; } if ( mixer ) delete mixer ;"}
{"source": "CWE-119 virNodeDeviceGetMdevTypesCaps ( const char * sysfspath , virMediatedDeviceTypePtr * * mdev_types , size_t * nmdev_types ) { virMediatedDeviceTypePtr * types = NULL ; size_t ntypes = 0 ; size_t i ; for ( i = 0 ; i < * nmdev_types ; i ++ ) <S2SV_StartBug> virMediatedDeviceTypeFree ( * mdev_types [ i ] ) ; <S2SV_EndBug> VIR_FREE ( * mdev_types ) ; * nmdev_types = 0 ; if ( virMediatedDeviceGetMdevTypes ( sysfspath , & types , & ntypes ) < 0 ) return - 1 ; * mdev_types = g_steal_pointer ( & types ) ; * nmdev_types = ntypes ; return 0 ; }", "target": "<S2SV_ModStart> ) virMediatedDeviceTypeFree ( ( * mdev_types ) <S2SV_ModEnd> [ i ]"}
{"source": "CWE-703 do_mouse ( oparg_T * oap , int c , int dir , long count , int fixindent ) { static int do_always = FALSE ; static int got_click = FALSE ; int which_button ; int is_click = FALSE ; int is_drag = FALSE ; int jump_flags = 0 ; pos_T start_visual ; int moved ; int in_status_line ; static int in_tab_line = FALSE ; int in_sep_line ; int c1 , c2 ; # if defined ( FEAT_FOLDING ) pos_T save_cursor ; # endif win_T * old_curwin = curwin ; static pos_T orig_cursor ; colnr_T leftcol , rightcol ; pos_T end_visual ; int diff ; int old_active = VIsual_active ; int old_mode = VIsual_mode ; int regname ; # if defined ( FEAT_FOLDING ) save_cursor = curwin -> w_cursor ; # endif if ( do_always ) do_always = FALSE ; else # ifdef FEAT_GUI if ( ! gui . in_use ) # endif { if ( VIsual_active ) { if ( ! mouse_has ( MOUSE_VISUAL ) ) return FALSE ; } else if ( State == MODE_NORMAL && ! mouse_has ( MOUSE_NORMAL ) ) return FALSE ; } for ( ; ; ) { which_button = get_mouse_button ( KEY2TERMCAP1 ( c ) , & is_click , & is_drag ) ; if ( is_drag ) { if ( ! KeyStuffed && vpeekc ( ) != NUL ) { int nc ; int save_mouse_row = mouse_row ; int save_mouse_col = mouse_col ; nc = safe_vgetc ( ) ; if ( c == nc ) continue ; vungetc ( nc ) ; mouse_row = save_mouse_row ; mouse_col = save_mouse_col ; } } break ; } if ( c == K_MOUSEMOVE ) { # ifdef FEAT_BEVAL_TERM ui_may_remove_balloon ( ) ; if ( p_bevalterm ) { profile_setlimit ( p_bdlay , & bevalexpr_due ) ; bevalexpr_due_set = TRUE ; } # endif # ifdef FEAT_PROP_POPUP popup_handle_mouse_moved ( ) ; # endif return FALSE ; } # ifdef FEAT_MOUSESHAPE if ( ! is_drag && drag_status_line ) { drag_status_line = FALSE ; update_mouseshape ( SHAPE_IDX_STATUS ) ; } if ( ! is_drag && drag_sep_line ) { drag_sep_line = FALSE ; update_mouseshape ( SHAPE_IDX_VSEP ) ; } # endif if ( is_click ) got_click = TRUE ; else { if ( ! got_click ) return FALSE ; if ( ! is_drag ) { got_click = FALSE ; if ( in_tab_line ) { in_tab_line = FALSE ; return FALSE ; } } } if ( is_click && ( mod_mask & MOD_MASK_CTRL ) && which_button == MOUSE_RIGHT ) { if ( State & MODE_INSERT ) stuffcharReadbuff ( Ctrl_O ) ; if ( count > 1 ) stuffnumReadbuff ( count ) ; stuffcharReadbuff ( Ctrl_T ) ; got_click = FALSE ; return FALSE ; } if ( ( mod_mask & MOD_MASK_CTRL ) && which_button != MOUSE_LEFT ) return FALSE ; if ( ( mod_mask & ( MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT | MOD_MASK_META ) ) && ( ! is_click || ( mod_mask & MOD_MASK_MULTI_CLICK ) || which_button == MOUSE_MIDDLE ) && ! ( ( mod_mask & ( MOD_MASK_SHIFT | MOD_MASK_ALT ) ) && mouse_model_popup ( ) && which_button == MOUSE_LEFT ) && ! ( ( mod_mask & MOD_MASK_ALT ) && ! mouse_model_popup ( ) && which_button == MOUSE_RIGHT ) ) return FALSE ; if ( ! is_click && which_button == MOUSE_MIDDLE ) return FALSE ; if ( oap != NULL ) regname = oap -> regname ; else regname = 0 ; if ( which_button == MOUSE_MIDDLE ) { if ( State == MODE_NORMAL ) { if ( oap != NULL && oap -> op_type != OP_NOP ) { clearopbeep ( oap ) ; return FALSE ; } if ( VIsual_active ) { if ( VIsual_select ) { stuffcharReadbuff ( Ctrl_G ) ; stuffReadbuff ( ( char_u * ) \"\\\\\"+p\" ) ; } else { stuffcharReadbuff ( 'y' ) ; stuffcharReadbuff ( K_MIDDLEMOUSE ) ; } do_always = TRUE ; return FALSE ; } } else if ( ( State & MODE_INSERT ) == 0 ) return FALSE ; if ( ( State & MODE_INSERT ) || ! mouse_has ( MOUSE_NORMAL ) ) { if ( regname == '.' ) insert_reg ( regname , TRUE ) ; else { # ifdef FEAT_CLIPBOARD if ( clip_star . available && regname == 0 ) regname = '*' ; # endif if ( ( State & REPLACE_FLAG ) && ! yank_register_mline ( regname ) ) insert_reg ( regname , TRUE ) ; else { do_put ( regname , NULL , BACKWARD , 1L , fixindent | PUT_CURSEND ) ; AppendCharToRedobuff ( Ctrl_R ) ; AppendCharToRedobuff ( fixindent ? Ctrl_P : Ctrl_O ) ; AppendCharToRedobuff ( regname == 0 ? \\'\"\\' : regname ) ; } } return FALSE ; } } if ( ! is_click ) jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE ; start_visual . lnum = 0 ; <S2SV_StartBug> <S2SV_EndBug> if ( mouse_row == 0 && firstwin -> w_winrow > 0 ) { if ( is_drag ) { if ( in_tab_line ) { c1 = TabPageIdxs [ mouse_col ] ; tabpage_move ( c1 <= 0 ? 9999 : c1 < tabpage_index ( curtab ) ? c1 - 1 : c1 ) ; } return FALSE ; } if ( is_click # ifdef FEAT_CMDWIN && cmdwin_type == 0 # endif && mouse_col < Columns ) { in_tab_line = TRUE ; c1 = TabPageIdxs [ mouse_col ] ; if ( c1 >= 0 ) { if ( ( mod_mask & MOD_MASK_MULTI_CLICK ) == MOD_MASK_2CLICK ) { end_visual_mode_keep_button ( ) ; tabpage_new ( ) ; tabpage_move ( c1 == 0 ? 9999 : c1 - 1 ) ; } else { goto_tabpage ( c1 ) ; if ( curwin != old_curwin ) end_visual_mode_keep_button ( ) ; } } else { tabpage_T * tp ; if ( c1 == - 999 ) tp = curtab ; else tp = find_tabpage ( - c1 ) ; if ( tp == curtab ) { if ( first_tabpage -> tp_next != NULL ) tabpage_close ( FALSE ) ; } else if ( tp != NULL ) tabpage_close_other ( tp , FALSE ) ; } } return TRUE ; } else if ( is_drag && in_tab_line ) { c1 = TabPageIdxs [ mouse_col ] ; tabpage_move ( c1 <= 0 ? 9999 : c1 - 1 ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } if ( mouse_model_popup ( ) ) { if ( which_button == MOUSE_RIGHT && ! ( mod_mask & ( MOD_MASK_SHIFT | MOD_MASK_CTRL ) ) ) { # ifdef USE_POPUP_SETPOS # ifdef FEAT_GUI if ( gui . in_use ) { # if defined ( FEAT_GUI_MOTIF ) || defined ( FEAT_GUI_GTK ) || defined ( FEAT_GUI_PHOTON ) if ( ! is_click ) return FALSE ; # endif # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_HAIKU ) if ( is_click || is_drag ) return FALSE ; # endif } # endif # if defined ( FEAT_GUI ) && defined ( FEAT_TERM_POPUP_MENU ) else # endif # if defined ( FEAT_TERM_POPUP_MENU ) if ( ! is_click ) return FALSE ; # endif jump_flags = 0 ; if ( STRCMP ( p_mousem , \"popup_setpos\" ) == 0 ) { if ( VIsual_active ) { pos_T m_pos ; if ( mouse_row < curwin -> w_winrow || mouse_row > ( curwin -> w_winrow + curwin -> w_height ) ) jump_flags = MOUSE_MAY_STOP_VIS ; else if ( get_fpos_of_mouse ( & m_pos ) != IN_BUFFER ) jump_flags = MOUSE_MAY_STOP_VIS ; else { if ( ( LT_POS ( curwin -> w_cursor , VIsual ) && ( LT_POS ( m_pos , curwin -> w_cursor ) || LT_POS ( VIsual , m_pos ) ) ) || ( LT_POS ( VIsual , curwin -> w_cursor ) && ( LT_POS ( m_pos , VIsual ) || LT_POS ( curwin -> w_cursor , m_pos ) ) ) ) { jump_flags = MOUSE_MAY_STOP_VIS ; } else if ( VIsual_mode == Ctrl_V ) { getvcols ( curwin , & curwin -> w_cursor , & VIsual , & leftcol , & rightcol ) ; getvcol ( curwin , & m_pos , NULL , & m_pos . col , NULL ) ; if ( m_pos . col < leftcol || m_pos . col > rightcol ) jump_flags = MOUSE_MAY_STOP_VIS ; } } } else jump_flags = MOUSE_MAY_STOP_VIS ; } if ( jump_flags ) { jump_flags = jump_to_mouse ( jump_flags , NULL , which_button ) ; update_curbuf ( VIsual_active ? UPD_INVERTED : UPD_VALID ) ; setcursor ( ) ; out_flush ( ) ; } # ifdef FEAT_MENU show_popupmenu ( ) ; got_click = FALSE ; # endif return ( jump_flags & CURSOR_MOVED ) != 0 ; # else return FALSE ; # endif } if ( which_button == MOUSE_LEFT && ( mod_mask & ( MOD_MASK_SHIFT | MOD_MASK_ALT ) ) ) { which_button = MOUSE_RIGHT ; mod_mask &= ~ MOD_MASK_SHIFT ; } } if ( ( State & ( MODE_NORMAL | MODE_INSERT ) ) && ! ( mod_mask & ( MOD_MASK_SHIFT | MOD_MASK_CTRL ) ) ) { if ( which_button == MOUSE_LEFT ) { if ( is_click ) { if ( VIsual_active ) jump_flags |= MOUSE_MAY_STOP_VIS ; } else if ( mouse_has ( MOUSE_VISUAL ) ) jump_flags |= MOUSE_MAY_VIS ; } else if ( which_button == MOUSE_RIGHT ) { if ( is_click && VIsual_active ) { if ( LT_POS ( curwin -> w_cursor , VIsual ) ) { start_visual = curwin -> w_cursor ; end_visual = VIsual ; } else { start_visual = VIsual ; end_visual = curwin -> w_cursor ; } } jump_flags |= MOUSE_FOCUS ; if ( mouse_has ( MOUSE_VISUAL ) ) jump_flags |= MOUSE_MAY_VIS ; } } if ( ! is_drag && oap != NULL && oap -> op_type != OP_NOP ) { got_click = FALSE ; oap -> motion_type = MCHAR ; } if ( ! is_click && ! is_drag ) jump_flags |= MOUSE_RELEASED ; jump_flags = jump_to_mouse ( jump_flags , oap == NULL ? NULL : & ( oap -> inclusive ) , which_button ) ; # ifdef FEAT_MENU if ( jump_flags & MOUSE_WINBAR ) return FALSE ; # endif moved = ( jump_flags & CURSOR_MOVED ) ; in_status_line = ( jump_flags & IN_STATUS_LINE ) ; in_sep_line = ( jump_flags & IN_SEP_LINE ) ; # ifdef FEAT_NETBEANS_INTG if ( isNetbeansBuffer ( curbuf ) && ! ( jump_flags & ( IN_STATUS_LINE | IN_SEP_LINE ) ) ) { int key = KEY2TERMCAP1 ( c ) ; if ( key == ( int ) KE_LEFTRELEASE || key == ( int ) KE_MIDDLERELEASE || key == ( int ) KE_RIGHTRELEASE ) netbeans_button_release ( which_button ) ; } # endif if ( curwin != old_curwin && oap != NULL && oap -> op_type != OP_NOP ) clearop ( oap ) ; # ifdef FEAT_FOLDING if ( mod_mask == 0 && ! is_drag && ( jump_flags & ( MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN ) ) && which_button == MOUSE_LEFT ) { if ( jump_flags & MOUSE_FOLD_OPEN ) openFold ( curwin -> w_cursor . lnum , 1L ) ; else closeFold ( curwin -> w_cursor . lnum , 1L ) ; if ( curwin == old_curwin ) curwin -> w_cursor = save_cursor ; } # endif # if defined ( FEAT_CLIPBOARD ) && defined ( FEAT_CMDWIN ) if ( ( jump_flags & IN_OTHER_WIN ) && ! VIsual_active && clip_star . available ) { clip_modeless ( which_button , is_click , is_drag ) ; return FALSE ; } # endif if ( VIsual_active && is_drag && get_scrolloff_value ( ) ) { if ( mouse_row == 0 ) mouse_dragging = 2 ; else mouse_dragging = 1 ; } if ( is_drag && mouse_row < 0 && ! in_status_line ) { scroll_redraw ( FALSE , 1L ) ; mouse_row = 0 ; } if ( start_visual . lnum ) { if ( mod_mask & MOD_MASK_ALT ) VIsual_mode = Ctrl_V ; if ( VIsual_mode == Ctrl_V ) { getvcols ( curwin , & start_visual , & end_visual , & leftcol , & rightcol ) ; if ( curwin -> w_curswant > ( leftcol + rightcol ) / 2 ) end_visual . col = leftcol ; else end_visual . col = rightcol ; if ( curwin -> w_cursor . lnum >= ( start_visual . lnum + end_visual . lnum ) / 2 ) end_visual . lnum = start_visual . lnum ; start_visual = curwin -> w_cursor ; curwin -> w_cursor = end_visual ; coladvance ( end_visual . col ) ; VIsual = curwin -> w_cursor ; curwin -> w_cursor = start_visual ; } else { if ( LT_POS ( curwin -> w_cursor , start_visual ) ) VIsual = end_visual ; else if ( LT_POS ( end_visual , curwin -> w_cursor ) ) VIsual = start_visual ; else { if ( end_visual . lnum == start_visual . lnum ) { if ( curwin -> w_cursor . col - start_visual . col > end_visual . col - curwin -> w_cursor . col ) VIsual = start_visual ; else VIsual = end_visual ; } else { diff = ( curwin -> w_cursor . lnum - start_visual . lnum ) - ( end_visual . lnum - curwin -> w_cursor . lnum ) ; if ( diff > 0 ) VIsual = start_visual ; else if ( diff < 0 ) VIsual = end_visual ; else { if ( curwin -> w_cursor . col < ( start_visual . col + end_visual . col ) / 2 ) VIsual = end_visual ; else VIsual = start_visual ; } } } } } else if ( ( State & MODE_INSERT ) && VIsual_active ) stuffcharReadbuff ( Ctrl_O ) ; if ( which_button == MOUSE_MIDDLE ) { # ifdef FEAT_CLIPBOARD if ( clip_star . available && regname == 0 ) regname = '*' ; # endif if ( yank_register_mline ( regname ) ) { if ( mouse_past_bottom ) dir = FORWARD ; } else if ( mouse_past_eol ) dir = FORWARD ; if ( fixindent ) { c1 = ( dir == BACKWARD ) ? '[' : ']' ; c2 = 'p' ; } else { c1 = ( dir == FORWARD ) ? 'p' : 'P' ; c2 = NUL ; } prep_redo ( regname , count , NUL , c1 , NUL , c2 , NUL ) ; if ( restart_edit != 0 ) where_paste_started = curwin -> w_cursor ; do_put ( regname , NULL , dir , count , fixindent | PUT_CURSEND ) ; } # if defined ( FEAT_QUICKFIX ) else if ( ( ( mod_mask & MOD_MASK_CTRL ) || ( mod_mask & MOD_MASK_MULTI_CLICK ) == MOD_MASK_2CLICK ) && bt_quickfix ( curbuf ) ) { if ( curwin -> w_llist_ref == NULL ) do_cmdline_cmd ( ( char_u * ) \".cc\" ) ; else do_cmdline_cmd ( ( char_u * ) \".ll\" ) ; got_click = FALSE ; } # endif else if ( ( mod_mask & MOD_MASK_CTRL ) || ( curbuf -> b_help && ( mod_mask & MOD_MASK_MULTI_CLICK ) == MOD_MASK_2CLICK ) ) { if ( State & MODE_INSERT ) stuffcharReadbuff ( Ctrl_O ) ; stuffcharReadbuff ( Ctrl_RSB ) ; got_click = FALSE ; } else if ( ( mod_mask & MOD_MASK_SHIFT ) ) { if ( ( State & MODE_INSERT ) || ( VIsual_active && VIsual_select ) ) stuffcharReadbuff ( Ctrl_O ) ; if ( which_button == MOUSE_LEFT ) stuffcharReadbuff ( '*' ) ; else stuffcharReadbuff ( '#' ) ; } else if ( in_status_line ) { # ifdef FEAT_MOUSESHAPE if ( ( is_drag || is_click ) && ! drag_status_line ) { drag_status_line = TRUE ; update_mouseshape ( - 1 ) ; } # endif } else if ( in_sep_line ) { # ifdef FEAT_MOUSESHAPE if ( ( is_drag || is_click ) && ! drag_sep_line ) { drag_sep_line = TRUE ; update_mouseshape ( - 1 ) ; } # endif } else if ( ( mod_mask & MOD_MASK_MULTI_CLICK ) && ( State & ( MODE_NORMAL | MODE_INSERT ) ) && mouse_has ( MOUSE_VISUAL ) ) { if ( is_click || ! VIsual_active ) { if ( VIsual_active ) orig_cursor = VIsual ; else { check_visual_highlight ( ) ; VIsual = curwin -> w_cursor ; orig_cursor = VIsual ; VIsual_active = TRUE ; VIsual_reselect = TRUE ; may_start_select ( 'o' ) ; setmouse ( ) ; } if ( ( mod_mask & MOD_MASK_MULTI_CLICK ) == MOD_MASK_2CLICK ) { if ( mod_mask & MOD_MASK_ALT ) VIsual_mode = Ctrl_V ; else VIsual_mode = 'v' ; } else if ( ( mod_mask & MOD_MASK_MULTI_CLICK ) == MOD_MASK_3CLICK ) VIsual_mode = 'V' ; else if ( ( mod_mask & MOD_MASK_MULTI_CLICK ) == MOD_MASK_4CLICK ) VIsual_mode = Ctrl_V ; # ifdef FEAT_CLIPBOARD clip_star . vmode = NUL ; # endif } if ( ( mod_mask & MOD_MASK_MULTI_CLICK ) == MOD_MASK_2CLICK ) { pos_T * pos = NULL ; int gc ; if ( is_click ) { end_visual = curwin -> w_cursor ; while ( gc = gchar_pos ( & end_visual ) , VIM_ISWHITE ( gc ) ) inc ( & end_visual ) ; if ( oap != NULL ) oap -> motion_type = MCHAR ; if ( oap != NULL && VIsual_mode == 'v' && ! vim_iswordc ( gchar_pos ( & end_visual ) ) && EQUAL_POS ( curwin -> w_cursor , VIsual ) && ( pos = findmatch ( oap , NUL ) ) != NULL ) { curwin -> w_cursor = * pos ; if ( oap -> motion_type == MLINE ) VIsual_mode = 'V' ; else if ( * p_sel == 'e' ) { if ( LT_POS ( curwin -> w_cursor , VIsual ) ) ++ VIsual . col ; else ++ curwin -> w_cursor . col ; } } } if ( pos == NULL && ( is_click || is_drag ) ) { if ( LT_POS ( curwin -> w_cursor , orig_cursor ) ) { find_start_of_word ( & curwin -> w_cursor ) ; find_end_of_word ( & VIsual ) ; } else { find_start_of_word ( & VIsual ) ; if ( * p_sel == 'e' && * ml_get_cursor ( ) != NUL ) curwin -> w_cursor . col += ( * mb_ptr2len ) ( ml_get_cursor ( ) ) ; find_end_of_word ( & curwin -> w_cursor ) ; } } curwin -> w_set_curswant = TRUE ; } if ( is_click ) redraw_curbuf_later ( UPD_INVERTED ) ; } else if ( VIsual_active && ! old_active ) { if ( mod_mask & MOD_MASK_ALT ) VIsual_mode = Ctrl_V ; else VIsual_mode = 'v' ; } if ( ( ! VIsual_active && old_active && mode_displayed ) || ( VIsual_active && p_smd && msg_silent == 0 && ( ! old_active || VIsual_mode != old_mode ) ) ) redraw_cmdline = TRUE ; return moved ; }", "target": "<S2SV_ModStart> = 0 ; if ( TabPageIdxs != NULL ) { <S2SV_ModStart> return FALSE ; }"}
{"source": "CWE-476 void jsP_dumpsyntax ( js_State * J , js_Ast * prog , int dominify ) { <S2SV_StartBug> minify = dominify ; <S2SV_EndBug> if ( prog -> type == AST_LIST ) pstmlist ( - 1 , prog ) ; else { pstm ( 0 , prog ) ; nl ( ) ; } <S2SV_StartBug> if ( minify > 1 ) <S2SV_EndBug> putchar ( '\\\\n' ) ; }", "target": "<S2SV_ModStart> = dominify ; if ( prog ) { <S2SV_ModStart> ) ; } }"}
{"source": "CWE-190 static PresentationContext * PresentationContext_new ( VideoClientContext * video , BYTE PresentationId , UINT32 x , UINT32 y , UINT32 width , UINT32 height ) { <S2SV_StartBug> VideoClientContextPriv * priv = video -> priv ; <S2SV_EndBug> <S2SV_StartBug> PresentationContext * ret = calloc ( 1 , sizeof ( * ret ) ) ; <S2SV_EndBug> if ( ! ret ) return NULL ; <S2SV_StartBug> ret -> video = video ; <S2SV_EndBug> ret -> PresentationId = PresentationId ; ret -> h264 = h264_context_new ( FALSE ) ; if ( ! ret -> h264 ) { WLog_ERR ( TAG , \"unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>a<S2SV_blank>h264<S2SV_blank>context\" ) ; goto error_h264 ; } h264_context_reset ( ret -> h264 , width , height ) ; ret -> currentSample = Stream_New ( NULL , 4096 ) ; if ( ! ret -> currentSample ) { WLog_ERR ( TAG , \"unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>current<S2SV_blank>packet<S2SV_blank>stream\" ) ; goto error_currentSample ; } <S2SV_StartBug> ret -> surfaceData = BufferPool_Take ( priv -> surfacePool , width * height * 4 ) ; <S2SV_EndBug> if ( ! ret -> surfaceData ) { WLog_ERR ( TAG , \"unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>surfaceData\" ) ; goto error_surfaceData ; } ret -> surface = video -> createSurface ( video , ret -> surfaceData , x , y , width , height ) ; if ( ! ret -> surface ) { WLog_ERR ( TAG , \"unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>surface\" ) ; goto error_surface ; } ret -> yuv = yuv_context_new ( FALSE ) ; if ( ! ret -> yuv ) { WLog_ERR ( TAG , \"unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>YUV<S2SV_blank>decoder\" ) ; goto error_yuv ; } yuv_context_reset ( ret -> yuv , width , height ) ; ret -> refCounter = 1 ; return ret ; error_yuv : video -> deleteSurface ( video , ret -> surface ) ; error_surface : BufferPool_Return ( priv -> surfacePool , ret -> surfaceData ) ; error_surfaceData : Stream_Free ( ret -> currentSample , TRUE ) ; error_currentSample : h264_context_free ( ret -> h264 ) ; error_h264 : free ( ret ) ; return NULL ; }", "target": "<S2SV_ModStart> height ) { size_t s ; <S2SV_ModStart> PresentationContext * ret ; s = width * height * 4ULL ; if ( s > INT32_MAX <S2SV_ModEnd> ) return NULL <S2SV_ModStart> NULL ; ret = calloc ( 1 , sizeof ( * ret ) ) ; if ( ! ret ) return NULL ; ret <S2SV_ModStart> -> surfacePool , s <S2SV_ModEnd> ) ; if"}
{"source": "CWE-476 struct iwl_trans * iwl_trans_pcie_alloc ( struct pci_dev * pdev , const struct pci_device_id * ent , const struct iwl_cfg_trans_params * cfg_trans ) { struct iwl_trans_pcie * trans_pcie ; struct iwl_trans * trans ; int ret , addr_size ; ret = pcim_enable_device ( pdev ) ; if ( ret ) return ERR_PTR ( ret ) ; if ( cfg_trans -> gen2 ) trans = iwl_trans_alloc ( sizeof ( struct iwl_trans_pcie ) , & pdev -> dev , & trans_ops_pcie_gen2 ) ; else trans = iwl_trans_alloc ( sizeof ( struct iwl_trans_pcie ) , & pdev -> dev , & trans_ops_pcie ) ; if ( ! trans ) return ERR_PTR ( - ENOMEM ) ; trans_pcie = IWL_TRANS_GET_PCIE_TRANS ( trans ) ; trans_pcie -> trans = trans ; trans_pcie -> opmode_down = true ; spin_lock_init ( & trans_pcie -> irq_lock ) ; spin_lock_init ( & trans_pcie -> reg_lock ) ; mutex_init ( & trans_pcie -> mutex ) ; init_waitqueue_head ( & trans_pcie -> ucode_write_waitq ) ; <S2SV_StartBug> trans_pcie -> tso_hdr_page = alloc_percpu ( struct iwl_tso_hdr_page ) ; <S2SV_EndBug> if ( ! trans_pcie -> tso_hdr_page ) { ret = - ENOMEM ; goto out_no_pci ; } trans_pcie -> debug_rfkill = - 1 ; if ( ! cfg_trans -> base_params -> pcie_l1_allowed ) { pci_disable_link_state ( pdev , PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 | PCIE_LINK_STATE_CLKPM ) ; } trans_pcie -> def_rx_queue = 0 ; if ( cfg_trans -> use_tfh ) { addr_size = 64 ; trans_pcie -> max_tbs = IWL_TFH_NUM_TBS ; trans_pcie -> tfd_size = sizeof ( struct iwl_tfh_tfd ) ; } else { addr_size = 36 ; trans_pcie -> max_tbs = IWL_NUM_OF_TBS ; trans_pcie -> tfd_size = sizeof ( struct iwl_tfd ) ; } trans -> max_skb_frags = IWL_PCIE_MAX_FRAGS ( trans_pcie ) ; pci_set_master ( pdev ) ; ret = pci_set_dma_mask ( pdev , DMA_BIT_MASK ( addr_size ) ) ; if ( ! ret ) ret = pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( addr_size ) ) ; if ( ret ) { ret = pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ; if ( ! ret ) ret = pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ; if ( ret ) { dev_err ( & pdev -> dev , \"No<S2SV_blank>suitable<S2SV_blank>DMA<S2SV_blank>available\\\\n\" ) ; goto out_no_pci ; } } ret = pcim_iomap_regions_request_all ( pdev , BIT ( 0 ) , DRV_NAME ) ; if ( ret ) { dev_err ( & pdev -> dev , \"pcim_iomap_regions_request_all<S2SV_blank>failed\\\\n\" ) ; goto out_no_pci ; } trans_pcie -> hw_base = pcim_iomap_table ( pdev ) [ 0 ] ; if ( ! trans_pcie -> hw_base ) { dev_err ( & pdev -> dev , \"pcim_iomap_table<S2SV_blank>failed\\\\n\" ) ; ret = - ENODEV ; goto out_no_pci ; } pci_write_config_byte ( pdev , PCI_CFG_RETRY_TIMEOUT , 0x00 ) ; trans_pcie -> pci_dev = pdev ; iwl_disable_interrupts ( trans ) ; trans -> hw_rev = iwl_read32 ( trans , CSR_HW_REV ) ; if ( trans -> hw_rev == 0xffffffff ) { dev_err ( & pdev -> dev , \"HW_REV=0xFFFFFFFF,<S2SV_blank>PCI<S2SV_blank>issues?\\\\n\" ) ; ret = - EIO ; goto out_no_pci ; } if ( cfg_trans -> device_family >= IWL_DEVICE_FAMILY_8000 ) { trans -> hw_rev = ( trans -> hw_rev & 0xfff0 ) | ( CSR_HW_REV_STEP ( trans -> hw_rev << 2 ) << 2 ) ; ret = iwl_pcie_prepare_card_hw ( trans ) ; if ( ret ) { IWL_WARN ( trans , \"Exit<S2SV_blank>HW<S2SV_blank>not<S2SV_blank>ready\\\\n\" ) ; goto out_no_pci ; } ret = iwl_finish_nic_init ( trans , cfg_trans ) ; if ( ret ) goto out_no_pci ; } IWL_DEBUG_INFO ( trans , \"HW<S2SV_blank>REV:<S2SV_blank>0x%0x\\\\n\" , trans -> hw_rev ) ; iwl_pcie_set_interrupt_capa ( pdev , trans , cfg_trans ) ; trans -> hw_id = ( pdev -> device << 16 ) + pdev -> subsystem_device ; snprintf ( trans -> hw_id_str , sizeof ( trans -> hw_id_str ) , \"PCI<S2SV_blank>ID:<S2SV_blank>0x%04X:0x%04X\" , pdev -> device , pdev -> subsystem_device ) ; init_waitqueue_head ( & trans_pcie -> wait_command_queue ) ; init_waitqueue_head ( & trans_pcie -> sx_waitq ) ; if ( trans_pcie -> msix_enabled ) { ret = iwl_pcie_init_msix_handler ( pdev , trans_pcie ) ; if ( ret ) goto out_no_pci ; } else { ret = iwl_pcie_alloc_ict ( trans ) ; if ( ret ) goto out_no_pci ; ret = devm_request_threaded_irq ( & pdev -> dev , pdev -> irq , iwl_pcie_isr , iwl_pcie_irq_handler , IRQF_SHARED , DRV_NAME , trans ) ; if ( ret ) { IWL_ERR ( trans , \"Error<S2SV_blank>allocating<S2SV_blank>IRQ<S2SV_blank>%d\\\\n\" , pdev -> irq ) ; goto out_free_ict ; } trans_pcie -> inta_mask = CSR_INI_SET_MASK ; } <S2SV_StartBug> trans_pcie -> rba . alloc_wq = alloc_workqueue ( \"rb_allocator\" , <S2SV_EndBug> WQ_HIGHPRI | WQ_UNBOUND , 1 ) ; INIT_WORK ( & trans_pcie -> rba . rx_alloc , iwl_pcie_rx_allocator_work ) ; # ifdef CONFIG_IWLWIFI_DEBUGFS trans_pcie -> fw_mon_data . state = IWL_FW_MON_DBGFS_STATE_CLOSED ; mutex_init ( & trans_pcie -> fw_mon_data . mutex ) ; # endif return trans ; out_free_ict : iwl_pcie_free_ict ( trans ) ; out_no_pci : free_percpu ( trans_pcie -> tso_hdr_page ) ; iwl_trans_free ( trans ) ; return ERR_PTR ( ret ) ; }", "target": "<S2SV_ModStart> ucode_write_waitq ) ; trans_pcie -> rba . alloc_wq = alloc_workqueue ( \"rb_allocator\" , WQ_HIGHPRI | WQ_UNBOUND , 1 ) ; if ( ! trans_pcie -> rba . alloc_wq ) { ret = - ENOMEM ; goto out_free_trans ; } INIT_WORK ( & trans_pcie -> rba . rx_alloc , iwl_pcie_rx_allocator_work ) ; <S2SV_ModStart> CSR_INI_SET_MASK ; } # ifdef CONFIG_IWLWIFI_DEBUGFS trans_pcie -> fw_mon_data . state = IWL_FW_MON_DBGFS_STATE_CLOSED ; mutex_init ( & trans_pcie -> fw_mon_data . mutex ) ; # endif return trans ; out_free_ict : iwl_pcie_free_ict ( trans ) ; out_no_pci : free_percpu ( trans_pcie -> tso_hdr_page ) ; destroy_workqueue ( <S2SV_ModStart> rba . alloc_wq ) ; out_free_trans : <S2SV_ModEnd> iwl_trans_free ( trans"}
{"source": "CWE-125 static void singlevar ( LexState * ls , expdesc * var ) { TString * varname = str_checkname ( ls ) ; FuncState * fs = ls -> fs ; singlevaraux ( fs , varname , var , 1 ) ; if ( var -> k == VVOID ) { expdesc key ; singlevaraux ( fs , ls -> envn , var , 1 ) ; lua_assert ( var -> k != VVOID ) ; <S2SV_StartBug> codestring ( & key , varname ) ; <S2SV_EndBug> luaK_indexed ( fs , var , & key ) ; } }", "target": "<S2SV_ModStart> VVOID ) ; luaK_exp2anyregup ( fs , var ) ;"}
{"source": "CWE-787 cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; size_t i , o4 , nelements , j , slen , left ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , cdf_offset ( sst -> sst_tab , offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } if ( cdf_check_stream_offset ( sst , h , shp , sh . sh_len , __LINE__ ) == - 1 ) goto out ; sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; DPRINTF ( ( \"section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\\\n\" , sh . sh_len , sh . sh_properties ) ) ; if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; inp = cdf_grow_info ( info , maxcount , sh . sh_properties ) ; if ( inp == NULL ) goto out ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , cdf_offset ( sst -> sst_tab , offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , cdf_offset ( shp , sh . sh_len ) ) ; if ( p >= e || cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { if ( ( q = cdf_get_property_info_pos ( sst , h , p , e , i ) ) == NULL ) goto out ; inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; left = CAST ( size_t , e - q ) ; if ( left < sizeof ( uint32_t ) ) { DPRINTF ( ( \"short<S2SV_blank>info<S2SV_blank>(no<S2SV_blank>type)_\\\\n\" ) ) ; goto out ; } inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( \"%\" SIZE_T_FORMAT \"u)<S2SV_blank>id=%#x<S2SV_blank>type=%#x<S2SV_blank>offs=%#tx,%#x\\\\n\" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { if ( left < sizeof ( uint32_t ) * 2 ) { DPRINTF ( ( \"missing<S2SV_blank>CDF_VECTOR<S2SV_blank>length\\\\n\" ) ) ; goto out ; } nelements = CDF_GETUINT32 ( q , 1 ) ; <S2SV_StartBug> if ( nelements == 0 ) { <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( \"CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\\n\" ) ) ; <S2SV_EndBug> goto out ; } slen = 2 ; } else { nelements = 1 ; slen = 1 ; } o4 = slen * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( ! cdf_copy_info ( & inp [ i ] , & q [ o4 ] , e , sizeof ( int16_t ) ) ) goto unknown ; break ; case CDF_SIGNED32 : case CDF_BOOL : case CDF_UNSIGNED32 : case CDF_FLOAT : if ( ! cdf_copy_info ( & inp [ i ] , & q [ o4 ] , e , sizeof ( int32_t ) ) ) goto unknown ; break ; case CDF_SIGNED64 : case CDF_UNSIGNED64 : case CDF_DOUBLE : case CDF_FILETIME : if ( ! cdf_copy_info ( & inp [ i ] , & q [ o4 ] , e , sizeof ( int64_t ) ) ) goto unknown ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; inp = cdf_grow_info ( info , maxcount , nelements ) ; if ( inp == NULL ) goto out ; inp += nelem ; } <S2SV_StartBug> DPRINTF ( ( \"nelements<S2SV_blank>=<S2SV_blank>%\" SIZE_T_FORMAT \"u\\\\n\" , <S2SV_EndBug> nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l ; if ( o4 + sizeof ( uint32_t ) > left ) goto out ; l = CDF_GETUINT32 ( q , slen ) ; o4 += sizeof ( uint32_t ) ; if ( o4 + l > left ) goto out ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = CAST ( const char * , CAST ( const void * , & q [ o4 ] ) ) ; DPRINTF ( ( \"o=%\" SIZE_T_FORMAT \"u<S2SV_blank>l=%d(%\" SIZE_T_FORMAT \"u),<S2SV_blank>t=%\" SIZE_T_FORMAT \"u<S2SV_blank>s=%s\\\\n\" , o4 , l , CDF_ROUND ( l , sizeof ( l ) ) , left , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; slen += l >> 1 ; o4 = slen * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : memset ( & inp [ i ] . pi_val , 0 , sizeof ( inp [ i ] . pi_val ) ) ; DPRINTF ( ( \"Don\\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%#x\\\\n\" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; * info = NULL ; * count = 0 ; * maxcount = 0 ; errno = EFTYPE ; return - 1 ; }", "target": "<S2SV_ModStart> if ( nelements > CDF_ELEMENT_LIMIT || nelements <S2SV_ModStart> DPRINTF ( ( \"CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>%\" SIZE_T_FORMAT \"u\\\\n\" , nelements <S2SV_ModEnd> ) ) ; <S2SV_ModStart> nelem ; } <S2SV_ModEnd> for ( j"}
{"source": "CWE-787 static void * seq_buf_alloc ( unsigned long size ) <S2SV_StartBug> { <S2SV_EndBug> return kvmalloc ( size , GFP_KERNEL_ACCOUNT ) ; }", "target": "<S2SV_ModStart> size ) { if ( unlikely ( size > MAX_RW_COUNT ) ) return NULL ;"}
{"source": "CWE-362 static struct nlattr * reserve_sfa_size ( struct sw_flow_actions * * sfa , int attr_len , bool log ) { struct sw_flow_actions * acts ; int new_acts_size ; size_t req_size = NLA_ALIGN ( attr_len ) ; int next_offset = offsetof ( struct sw_flow_actions , actions ) + ( * sfa ) -> actions_len ; if ( req_size <= ( ksize ( * sfa ) - next_offset ) ) goto out ; new_acts_size = max ( next_offset + req_size , ksize ( * sfa ) * 2 ) ; if ( new_acts_size > MAX_ACTIONS_BUFSIZE ) { <S2SV_StartBug> if ( ( MAX_ACTIONS_BUFSIZE - next_offset ) < req_size ) { <S2SV_EndBug> OVS_NLERR ( log , \"Flow<S2SV_blank>action<S2SV_blank>size<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>%u\" , MAX_ACTIONS_BUFSIZE ) ; return ERR_PTR ( - EMSGSIZE ) ; } new_acts_size = MAX_ACTIONS_BUFSIZE ; } acts = nla_alloc_flow_actions ( new_acts_size ) ; if ( IS_ERR ( acts ) ) return ( void * ) acts ; memcpy ( acts -> actions , ( * sfa ) -> actions , ( * sfa ) -> actions_len ) ; acts -> actions_len = ( * sfa ) -> actions_len ; acts -> orig_len = ( * sfa ) -> orig_len ; kfree ( * sfa ) ; * sfa = acts ; out : ( * sfa ) -> actions_len += req_size ; return ( struct nlattr * ) ( ( unsigned char * ) ( * sfa ) + next_offset ) ; }", "target": "<S2SV_ModStart> if ( ( next_offset + req_size ) > MAX_ACTIONS_BUFSIZE <S2SV_ModEnd> ) { OVS_NLERR"}
{"source": "CWE-400 gopherToHTML ( GopherStateData * gopherState , char * inbuf , int len ) { char * pos = inbuf ; char * lpos = NULL ; char * tline = NULL ; LOCAL_ARRAY ( char , line , TEMP_BUF_SIZE ) ; <S2SV_StartBug> LOCAL_ARRAY ( char , tmpbuf , TEMP_BUF_SIZE ) ; <S2SV_EndBug> char * name = NULL ; char * selector = NULL ; char * host = NULL ; char * port = NULL ; char * escaped_selector = NULL ; const char * icon_url = NULL ; char gtype ; StoreEntry * entry = NULL ; <S2SV_StartBug> memset ( tmpbuf , '\\\\0' , TEMP_BUF_SIZE ) ; <S2SV_EndBug> memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; entry = gopherState -> entry ; if ( gopherState -> conversion == GopherStateData : : HTML_INDEX_PAGE ) { char * html_url = html_quote ( entry -> url ( ) ) ; gopherHTMLHeader ( entry , \"Gopher<S2SV_blank>Index<S2SV_blank>%s\" , html_url ) ; storeAppendPrintf ( entry , \"<p>This<S2SV_blank>is<S2SV_blank>a<S2SV_blank>searchable<S2SV_blank>Gopher<S2SV_blank>index.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>search\\\\n\" \"function<S2SV_blank>of<S2SV_blank>your<S2SV_blank>browser<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>search<S2SV_blank>terms.\\\\n\" \"<ISINDEX>\\\\n\" ) ; gopherHTMLFooter ( entry ) ; entry -> flush ( ) ; gopherState -> HTML_header_added = 1 ; return ; } if ( gopherState -> conversion == GopherStateData : : HTML_CSO_PAGE ) { char * html_url = html_quote ( entry -> url ( ) ) ; gopherHTMLHeader ( entry , \"CSO<S2SV_blank>Search<S2SV_blank>of<S2SV_blank>%s\" , html_url ) ; storeAppendPrintf ( entry , \"<P>A<S2SV_blank>CSO<S2SV_blank>database<S2SV_blank>usually<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>phonebook<S2SV_blank>or\\\\n\" \"directory.<S2SV_blank><S2SV_blank>Use<S2SV_blank>the<S2SV_blank>search<S2SV_blank>function<S2SV_blank>of<S2SV_blank>your<S2SV_blank>browser<S2SV_blank>to<S2SV_blank>enter\\\\n\" \"search<S2SV_blank>terms.</P><ISINDEX>\\\\n\" ) ; gopherHTMLFooter ( entry ) ; entry -> flush ( ) ; gopherState -> HTML_header_added = 1 ; return ; } <S2SV_StartBug> String outbuf ; <S2SV_EndBug> if ( ! gopherState -> HTML_header_added ) { if ( gopherState -> conversion == GopherStateData : : HTML_CSO_RESULT ) gopherHTMLHeader ( entry , \"CSO<S2SV_blank>Search<S2SV_blank>Result\" , NULL ) ; else gopherHTMLHeader ( entry , \"Gopher<S2SV_blank>Menu\" , NULL ) ; outbuf . append ( \"<PRE>\" ) ; gopherState -> HTML_header_added = 1 ; gopherState -> HTML_pre = 1 ; } while ( pos < inbuf + len ) { int llen ; int left = len - ( pos - inbuf ) ; lpos = ( char * ) memchr ( pos , '\\\\n' , left ) ; if ( lpos ) { ++ lpos ; llen = lpos - pos ; } else { llen = left ; } if ( gopherState -> len + llen >= TEMP_BUF_SIZE ) { debugs ( 10 , DBG_IMPORTANT , \"GopherHTML:<S2SV_blank>Buffer<S2SV_blank>overflow.<S2SV_blank>Lost<S2SV_blank>some<S2SV_blank>data<S2SV_blank>on<S2SV_blank>URL:<S2SV_blank>\" << entry -> url ( ) ) ; llen = TEMP_BUF_SIZE - gopherState -> len - 1 ; } if ( ! lpos ) { memcpy ( gopherState -> buf + gopherState -> len , pos , llen ) ; gopherState -> len += llen ; break ; } if ( gopherState -> len != 0 ) { memcpy ( line , gopherState -> buf , gopherState -> len ) ; memcpy ( line + gopherState -> len , pos , llen ) ; llen += gopherState -> len ; gopherState -> len = 0 ; } else { memcpy ( line , pos , llen ) ; } line [ llen + 1 ] = '\\\\0' ; pos = lpos ; if ( * line == '.' ) { memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; continue ; } switch ( gopherState -> conversion ) { case GopherStateData : : HTML_INDEX_RESULT : case GopherStateData : : HTML_DIR : { tline = line ; gtype = * tline ; ++ tline ; name = tline ; selector = strchr ( tline , TAB ) ; if ( selector ) { * selector = '\\\\0' ; ++ selector ; host = strchr ( selector , TAB ) ; if ( host ) { * host = '\\\\0' ; ++ host ; port = strchr ( host , TAB ) ; if ( port ) { char * junk ; port [ 0 ] = ':' ; junk = strchr ( host , TAB ) ; if ( junk ) * junk ++ = 0 ; else { junk = strchr ( host , '\\\\r' ) ; if ( junk ) * junk ++ = 0 ; else { junk = strchr ( host , '\\\\n' ) ; if ( junk ) * junk ++ = 0 ; } } if ( ( port [ 1 ] == '0' ) && ( ! port [ 2 ] ) ) port [ 0 ] = 0 ; } escaped_selector = xstrdup ( rfc1738_escape_part ( selector ) ) ; switch ( gtype ) { case GOPHER_DIRECTORY : icon_url = mimeGetIconURL ( \"internal-menu\" ) ; break ; case GOPHER_HTML : case GOPHER_FILE : icon_url = mimeGetIconURL ( \"internal-text\" ) ; break ; case GOPHER_INDEX : case GOPHER_CSO : icon_url = mimeGetIconURL ( \"internal-index\" ) ; break ; case GOPHER_IMAGE : case GOPHER_GIF : case GOPHER_PLUS_IMAGE : icon_url = mimeGetIconURL ( \"internal-image\" ) ; break ; case GOPHER_SOUND : case GOPHER_PLUS_SOUND : icon_url = mimeGetIconURL ( \"internal-sound\" ) ; break ; case GOPHER_PLUS_MOVIE : icon_url = mimeGetIconURL ( \"internal-movie\" ) ; break ; case GOPHER_TELNET : case GOPHER_3270 : icon_url = mimeGetIconURL ( \"internal-telnet\" ) ; break ; case GOPHER_BIN : case GOPHER_MACBINHEX : case GOPHER_DOSBIN : case GOPHER_UUENCODED : icon_url = mimeGetIconURL ( \"internal-binary\" ) ; break ; case GOPHER_INFO : icon_url = NULL ; break ; default : icon_url = mimeGetIconURL ( \"internal-unknown\" ) ; break ; } <S2SV_StartBug> memset ( tmpbuf , '\\\\0' , TEMP_BUF_SIZE ) ; <S2SV_EndBug> if ( ( gtype == GOPHER_TELNET ) || ( gtype == GOPHER_3270 ) ) { if ( strlen ( escaped_selector ) != 0 ) <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s@%s%s%s/\\\\\">%s</A>\\\\n\" , <S2SV_EndBug> icon_url , escaped_selector , rfc1738_escape_part ( host ) , * port ? \":\" : \"\" , port , html_quote ( name ) ) ; else <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s%s%s/\\\\\">%s</A>\\\\n\" , <S2SV_EndBug> icon_url , rfc1738_escape_part ( host ) , * port ? \":\" : \"\" , port , html_quote ( name ) ) ; } else if ( gtype == GOPHER_INFO ) { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"\\\\t%s\\\\n\" , html_quote ( name ) ) ; <S2SV_EndBug> } else { if ( strncmp ( selector , \"GET<S2SV_blank>/\" , 5 ) == 0 ) { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"http://%s/%s\\\\\">%s</A>\\\\n\" , <S2SV_EndBug> icon_url , host , rfc1738_escape_unescaped ( selector + 5 ) , html_quote ( name ) ) ; <S2SV_StartBug> } else { <S2SV_EndBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"gopher://%s/%c%s\\\\\">%s</A>\\\\n\" , icon_url , host , gtype , escaped_selector , html_quote ( name ) ) ; } } safe_free ( escaped_selector ) ; outbuf . append ( tmpbuf ) ; } else { memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; continue ; } } else { memset ( line , '\\\\0' , TEMP_BUF_SIZE ) ; continue ; } break ; } case GopherStateData : : HTML_CSO_RESULT : { if ( line [ 0 ] == '-' ) { int code , recno ; char * s_code , * s_recno , * result ; s_code = strtok ( line + 1 , \":\\\\n\" ) ; s_recno = strtok ( NULL , \":\\\\n\" ) ; result = strtok ( NULL , \"\\\\n\" ) ; if ( ! result ) break ; code = atoi ( s_code ) ; recno = atoi ( s_recno ) ; if ( code != 200 ) break ; if ( gopherState -> cso_recno != recno ) { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>Record#<S2SV_blank>%d<br><i>%s</i></H2>\\\\n<PRE>\" , recno , html_quote ( result ) ) ; <S2SV_EndBug> gopherState -> cso_recno = recno ; } else { snprintf ( tmpbuf , TEMP_BUF_SIZE , \"%s\\\\n\" , html_quote ( result ) ) ; } outbuf . append ( tmpbuf ) ; break ; } else { int code ; char * s_code , * result ; s_code = strtok ( line , \":\" ) ; result = strtok ( NULL , \"\\\\n\" ) ; if ( ! result ) break ; code = atoi ( s_code ) ; switch ( code ) { case 200 : { break ; } case 102 : case 501 : case 502 : { <S2SV_StartBug> snprintf ( tmpbuf , TEMP_BUF_SIZE , \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>%s</H2>\\\\n<PRE>\" , html_quote ( result ) ) ; <S2SV_EndBug> outbuf . append ( tmpbuf ) ; break ; } } } } default : break ; } } <S2SV_StartBug> if ( outbuf . size ( ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> entry -> append ( outbuf . rawBuf ( ) , outbuf . size ( ) ) ; <S2SV_EndBug> entry -> flush ( ) ; } <S2SV_StartBug> outbuf . clean ( ) ; <S2SV_EndBug> return ; }", "target": "<S2SV_ModStart> TEMP_BUF_SIZE ) ; <S2SV_ModEnd> char * name <S2SV_ModStart> = NULL ; <S2SV_ModEnd> memset ( line <S2SV_ModStart> return ; } SBuf <S2SV_ModEnd> outbuf ; if <S2SV_ModStart> break ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> != 0 ) outbuf . appendf ( <S2SV_ModEnd> \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s@%s%s%s/\\\\\">%s</A>\\\\n\" , icon_url <S2SV_ModStart> ) ; else outbuf . appendf ( <S2SV_ModEnd> \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"telnet://%s%s%s/\\\\\">%s</A>\\\\n\" , icon_url <S2SV_ModStart> GOPHER_INFO ) { outbuf . appendf ( <S2SV_ModEnd> \"\\\\t%s\\\\n\" , html_quote <S2SV_ModStart> 0 ) { outbuf . appendf ( <S2SV_ModEnd> \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"http://%s/%s\\\\\">%s</A>\\\\n\" , icon_url <S2SV_ModStart> ; } else if ( gtype == GOPHER_WWW ) { outbuf . appendf ( \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"gopher://%s/%c%s\\\\\">%s</A>\\\\n\" , icon_url , rfc1738_escape_unescaped ( selector ) , html_quote ( name ) ) ; } else { outbuf . appendf ( \"<IMG<S2SV_blank>border=\\\\\"0\\\\\"<S2SV_blank>SRC=\\\\\"%s\\\\\"><S2SV_blank><A<S2SV_blank>HREF=\\\\\"gopher://%s/%c%s\\\\\">%s</A>\\\\n\" , icon_url , host , gtype , escaped_selector , html_quote ( name ) ) ; } } safe_free ( escaped_selector <S2SV_ModEnd> ) ; } <S2SV_ModStart> recno ) { outbuf . appendf ( \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>Record#<S2SV_blank>%d<br><i>%s</i></H2>\\\\n<PRE>\" , recno , html_quote ( result ) ) ; gopherState -> cso_recno = recno ; } else { outbuf . appendf ( \"%s\\\\n\" , html_quote ( result ) ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 502 : { outbuf . appendf ( \"</PRE><HR<S2SV_blank>noshade<S2SV_blank>size=\\\\\"1px\\\\\"><H2>%s</H2>\\\\n<PRE>\" , html_quote ( result ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( outbuf . length <S2SV_ModEnd> ( ) > <S2SV_ModStart> ( outbuf . rawContent <S2SV_ModEnd> ( ) , <S2SV_ModStart> , outbuf . length <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> return ; }"}
{"source": "CWE-787 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; ssize_t i ; Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , \"\\\\200\\\\052\\\\137\\\\327\" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.version\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.filename\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.create_date\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , \"dpx:file.create_time\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , \"dpx:image.orientation\" , \"%d\" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , \"dpx:image.label\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:origination.x_offset\" , \"%.20g\" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:origination.y_offset\" , \"%.20g\" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.filename\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.create_date\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.create_time\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.device\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.model\" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , \"dpx:origination.serial\" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , \"dpx:film.id\" , \"%d\" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , \"dpx:film.type\" , \"%d\" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , \"dpx:film.offset\" , \"%d\" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:film.prefix\" , \"%.20g\" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , \"dpx:film.format\" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , \"dpx:film.frame_position\" , \"%.20g\" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , \"dpx:film.frame_rate\" , \"%g\" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , \"dpx:film.frame_id\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , \"dpx:film.slate_info\" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , \"dpx:user.data\" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows / 8 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; SetQuantumQuantum ( quantum_info , 32 ) ; SetQuantumPack ( quantum_info , MagickFalse ) ; quantum_type = RGBQuantum ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } status = SetQuantumPad ( image , quantum_info , 0 ) ; pixels = GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { const void * stream ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; stream = ReadBlobStream ( image , length , pixels , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , ( unsigned char * ) stream , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> image ) ; if ( cin . file . image_offset < 712 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;"}
{"source": "CWE-787 sug_filltree ( spellinfo_T * spin , slang_T * slang ) { char_u * byts ; idx_T * idxs ; int depth ; idx_T arridx [ MAXWLEN ] ; int curi [ MAXWLEN ] ; char_u tword [ MAXWLEN ] ; char_u tsalword [ MAXWLEN ] ; int c ; idx_T n ; unsigned words_done = 0 ; int wordcount [ MAXWLEN ] ; spin -> si_foldroot = wordtree_alloc ( spin ) ; if ( spin -> si_foldroot == NULL ) return FAIL ; spin -> si_sugtree = TRUE ; byts = slang -> sl_fbyts ; <S2SV_StartBug> idxs = slang -> sl_fidxs ; <S2SV_EndBug> arridx [ 0 ] = 0 ; curi [ 0 ] = 1 ; wordcount [ 0 ] = 0 ; depth = 0 ; while ( depth >= 0 && ! got_int ) { if ( curi [ depth ] > byts [ arridx [ depth ] ] ) { idxs [ arridx [ depth ] ] = wordcount [ depth ] ; if ( depth > 0 ) wordcount [ depth - 1 ] += wordcount [ depth ] ; -- depth ; line_breakcheck ( ) ; } else { n = arridx [ depth ] + curi [ depth ] ; ++ curi [ depth ] ; c = byts [ n ] ; if ( c == 0 ) { tword [ depth ] = NUL ; spell_soundfold ( slang , tword , TRUE , tsalword ) ; if ( tree_add_word ( spin , tsalword , spin -> si_foldroot , words_done >> 16 , words_done & 0xffff , 0 ) == FAIL ) return FAIL ; ++ words_done ; ++ wordcount [ depth ] ; spin -> si_blocks_cnt = 0 ; while ( n + 1 < slang -> sl_fbyts_len && byts [ n + 1 ] == 0 ) { ++ n ; ++ curi [ depth ] ; } } else { tword [ depth ++ ] = c ; arridx [ depth ] = idxs [ n ] ; curi [ depth ] = 1 ; wordcount [ depth ] = 0 ; } } } smsg ( _ ( \"Total<S2SV_blank>number<S2SV_blank>of<S2SV_blank>words:<S2SV_blank>%d\" ) , words_done ) ; return OK ; }", "target": "<S2SV_ModStart> slang -> sl_fidxs ; if ( byts == NULL || idxs == NULL ) return FAIL"}
{"source": "CWE-617 createRandomCursorExecutor ( const CollectionPtr & coll , const boost : : intrusive_ptr < ExpressionContext > & expCtx , long long sampleSize , long long numRecords , boost : : optional < BucketUnpacker > bucketUnpacker ) { OperationContext * opCtx = expCtx -> opCtx ; invariant ( opCtx -> lockState ( ) -> isCollectionLockedForMode ( coll -> ns ( ) , MODE_IS ) ) ; static const double kMaxSampleRatioForRandCursor = 0.05 ; if ( ! expCtx -> ns . isTimeseriesBucketsCollection ( ) ) { if ( sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100 ) { return std : : pair { nullptr , false } ; } } else { static const double kCoefficient = 0.01 ; if ( sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount ) { return std : : pair { nullptr , false } ; } } auto rsRandCursor = coll -> getRecordStore ( ) -> getRandomCursor ( opCtx ) ; if ( ! rsRandCursor ) { return std : : pair { nullptr , false } ; } auto ws = std : : make_unique < WorkingSet > ( ) ; std : : unique_ptr < PlanStage > root = std : : make_unique < MultiIteratorStage > ( expCtx . get ( ) , ws . get ( ) , coll ) ; static_cast < MultiIteratorStage * > ( root . get ( ) ) -> addIterator ( std : : move ( rsRandCursor ) ) ; <S2SV_StartBug> auto collectionFilter = <S2SV_EndBug> CollectionShardingState : : get ( opCtx , coll -> ns ( ) ) -> getOwnershipFilter ( opCtx , CollectionShardingState : : OrphanCleanupPolicy : : kDisallowOrphanCleanup ) ; TrialStage * trialStage = nullptr ; static const size_t kMaxPresampleSize = 100 ; <S2SV_StartBug> if ( collectionFilter . isSharded ( ) && ! expCtx -> ns . isTimeseriesBucketsCollection ( ) ) { <S2SV_EndBug> const auto minAdvancedToWorkRatio = std : : max ( <S2SV_StartBug> sampleSize / ( numRecords * kMaxSampleRatioForRandCursor ) , kMaxSampleRatioForRandCursor ) ; <S2SV_EndBug> auto randomCursorPlan = std : : make_unique < ShardFilterStage > ( expCtx . get ( ) , collectionFilter , ws . get ( ) , std : : move ( root ) ) ; std : : unique_ptr < PlanStage > collScanPlan = std : : make_unique < CollectionScan > ( expCtx . get ( ) , coll , CollectionScanParams { } , ws . get ( ) , nullptr ) ; collScanPlan = std : : make_unique < ShardFilterStage > ( expCtx . get ( ) , collectionFilter , ws . get ( ) , std : : move ( collScanPlan ) ) ; root = std : : make_unique < TrialStage > ( expCtx . get ( ) , ws . get ( ) , std : : move ( randomCursorPlan ) , std : : move ( collScanPlan ) , kMaxPresampleSize , minAdvancedToWorkRatio ) ; trialStage = static_cast < TrialStage * > ( root . get ( ) ) ; } else if ( expCtx -> ns . isTimeseriesBucketsCollection ( ) ) { if ( ! ( bucketUnpacker && numRecords ) ) { return std : : pair { nullptr , false } ; } static const auto kCoefficient = 0.02 ; static const auto kMinBucketFullness = 0.25 ; const auto minAdvancedToWorkRatio = std : : max ( std : : min ( sampleSize / ( kCoefficient * numRecords * gTimeseriesBucketMaxCount ) , 1.0 ) , kMinBucketFullness ) ; auto arhashPlan = std : : make_unique < SampleFromTimeseriesBucket > ( expCtx . get ( ) , ws . get ( ) , std : : move ( root ) , * bucketUnpacker , kMaxPresampleSize + 5 , sampleSize , gTimeseriesBucketMaxCount ) ; std : : unique_ptr < PlanStage > collScanPlan = std : : make_unique < CollectionScan > ( expCtx . get ( ) , coll , CollectionScanParams { } , ws . get ( ) , nullptr ) ; auto topkSortPlan = std : : make_unique < UnpackTimeseriesBucket > ( expCtx . get ( ) , ws . get ( ) , std : : move ( collScanPlan ) , * bucketUnpacker ) ; root = std : : make_unique < TrialStage > ( expCtx . get ( ) , ws . get ( ) , std : : move ( arhashPlan ) , std : : move ( topkSortPlan ) , kMaxPresampleSize , minAdvancedToWorkRatio ) ; trialStage = static_cast < TrialStage * > ( root . get ( ) ) ; } auto execStatus = plan_executor_factory : : make ( expCtx , std : : move ( ws ) , std : : move ( root ) , & coll , opCtx -> inMultiDocumentTransaction ( ) ? PlanYieldPolicy : : YieldPolicy : : INTERRUPT_ONLY : PlanYieldPolicy : : YieldPolicy : : YIELD_AUTO , QueryPlannerParams : : RETURN_OWNED_DATA ) ; if ( ! execStatus . isOK ( ) ) { return execStatus . getStatus ( ) ; } return std : : pair { std : : move ( execStatus . getValue ( ) ) , ! trialStage || ! trialStage -> pickedBackupPlan ( ) } ; }", "target": "<S2SV_ModStart> ) ) ; <S2SV_ModEnd> TrialStage * trialStage <S2SV_ModStart> ; if ( auto css = CollectionShardingState : : get ( opCtx , coll -> ns ( ) ) ; css -> getCollectionDescription ( opCtx ) <S2SV_ModEnd> . isSharded ( <S2SV_ModStart> ) , kMaxSampleRatioForRandCursor ) ; auto collectionFilter = css -> getOwnershipFilter ( opCtx , CollectionShardingState : : OrphanCleanupPolicy : : kDisallowOrphanCleanup"}
{"source": "CWE-476 void qemu_ram_free ( struct uc_struct * uc , RAMBlock * block ) { if ( ! block ) { return ; } <S2SV_StartBug> QLIST_REMOVE ( block , next ) ; <S2SV_EndBug> uc -> ram_list . mru_block = NULL ; reclaim_ramblock ( uc , block ) ; }", "target": "<S2SV_ModStart> return ; } QLIST_REMOVE_RCU <S2SV_ModEnd> ( block ,"}
{"source": "CWE-125 static int i2c_ddc_rx ( I2CSlave * i2c ) { I2CDDCState * s = I2CDDC ( i2c ) ; int value ; <S2SV_StartBug> value = s -> edid_blob [ s -> reg ] ; <S2SV_EndBug> s -> reg ++ ; return value ; }", "target": "<S2SV_ModStart> s -> reg % sizeof ( s -> edid_blob )"}
{"source": "CWE-703 vhost_user_set_inflight_fd ( struct virtio_net * * pdev , struct vhu_msg_context * ctx , int main_fd __rte_unused ) { uint64_t mmap_size , mmap_offset ; uint16_t num_queues , queue_size ; struct virtio_net * dev = * pdev ; uint32_t pervq_inflight_size ; struct vhost_virtqueue * vq ; void * addr ; int fd , i ; <S2SV_StartBug> int numa_node = SOCKET_ID_ANY ; <S2SV_EndBug> fd = ctx -> fds [ 0 ] ; if ( ctx -> msg . size != sizeof ( ctx -> msg . payload . inflight ) || fd < 0 ) { VHOST_LOG_CONFIG ( ERR , \"(%s)<S2SV_blank>invalid<S2SV_blank>set_inflight_fd<S2SV_blank>message<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%d,fd<S2SV_blank>is<S2SV_blank>%d\\\\n\" , dev -> ifname , ctx -> msg . size , fd ) ; return RTE_VHOST_MSG_RESULT_ERR ; } mmap_size = ctx -> msg . payload . inflight . mmap_size ; mmap_offset = ctx -> msg . payload . inflight . mmap_offset ; num_queues = ctx -> msg . payload . inflight . num_queues ; queue_size = ctx -> msg . payload . inflight . queue_size ; if ( vq_is_packed ( dev ) ) pervq_inflight_size = get_pervq_shm_size_packed ( queue_size ) ; else pervq_inflight_size = get_pervq_shm_size_split ( queue_size ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>set_inflight_fd<S2SV_blank>mmap_size:<S2SV_blank>%\" PRIu64 \"\\\\n\" , dev -> ifname , mmap_size ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>set_inflight_fd<S2SV_blank>mmap_offset:<S2SV_blank>%\" PRIu64 \"\\\\n\" , dev -> ifname , mmap_offset ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>set_inflight_fd<S2SV_blank>num_queues:<S2SV_blank>%u\\\\n\" , dev -> ifname , num_queues ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>set_inflight_fd<S2SV_blank>queue_size:<S2SV_blank>%u\\\\n\" , dev -> ifname , queue_size ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>set_inflight_fd<S2SV_blank>fd:<S2SV_blank>%d\\\\n\" , dev -> ifname , fd ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>set_inflight_fd<S2SV_blank>pervq_inflight_size:<S2SV_blank>%d\\\\n\" , dev -> ifname , pervq_inflight_size ) ; if ( dev -> nr_vring > 0 ) numa_node = dev -> virtqueue [ 0 ] -> numa_node ; if ( ! dev -> inflight_info ) { dev -> inflight_info = rte_zmalloc_socket ( \"inflight_info\" , sizeof ( struct inflight_mem_info ) , 0 , numa_node ) ; if ( dev -> inflight_info == NULL ) { VHOST_LOG_CONFIG ( ERR , \"(%s)<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>dev<S2SV_blank>inflight<S2SV_blank>area\\\\n\" , dev -> ifname ) ; return RTE_VHOST_MSG_RESULT_ERR ; } dev -> inflight_info -> fd = - 1 ; } if ( dev -> inflight_info -> addr ) { munmap ( dev -> inflight_info -> addr , dev -> inflight_info -> size ) ; dev -> inflight_info -> addr = NULL ; } addr = mmap ( 0 , mmap_size , PROT_READ | PROT_WRITE , MAP_SHARED , fd , mmap_offset ) ; if ( addr == MAP_FAILED ) { VHOST_LOG_CONFIG ( ERR , \"(%s)<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>mmap<S2SV_blank>share<S2SV_blank>memory.\\\\n\" , dev -> ifname ) ; return RTE_VHOST_MSG_RESULT_ERR ; } if ( dev -> inflight_info -> fd >= 0 ) { close ( dev -> inflight_info -> fd ) ; dev -> inflight_info -> fd = - 1 ; } dev -> inflight_info -> fd = fd ; dev -> inflight_info -> addr = addr ; dev -> inflight_info -> size = mmap_size ; for ( i = 0 ; i < num_queues ; i ++ ) { vq = dev -> virtqueue [ i ] ; if ( ! vq ) continue ; if ( vq_is_packed ( dev ) ) { vq -> inflight_packed = addr ; vq -> inflight_packed -> desc_num = queue_size ; } else { vq -> inflight_split = addr ; vq -> inflight_split -> desc_num = queue_size ; } addr = ( void * ) ( ( char * ) addr + pervq_inflight_size ) ; } return RTE_VHOST_MSG_RESULT_OK ; }", "target": "<S2SV_ModStart> numa_node = SOCKET_ID_ANY ; if ( validate_msg_fds ( dev , ctx , 1 ) != 0 ) return RTE_VHOST_MSG_RESULT_ERR"}
{"source": "CWE-703 vhost_user_get_inflight_fd ( struct virtio_net * * pdev , struct vhu_msg_context * ctx , int main_fd __rte_unused ) { struct rte_vhost_inflight_info_packed * inflight_packed ; uint64_t pervq_inflight_size , mmap_size ; uint16_t num_queues , queue_size ; struct virtio_net * dev = * pdev ; int fd , i , j ; int numa_node = SOCKET_ID_ANY ; <S2SV_StartBug> void * addr ; <S2SV_EndBug> if ( ctx -> msg . size != sizeof ( ctx -> msg . payload . inflight ) ) { VHOST_LOG_CONFIG ( ERR , \"(%s)<S2SV_blank>invalid<S2SV_blank>get_inflight_fd<S2SV_blank>message<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%d\\\\n\" , dev -> ifname , ctx -> msg . size ) ; return RTE_VHOST_MSG_RESULT_ERR ; } if ( dev -> nr_vring > 0 ) numa_node = dev -> virtqueue [ 0 ] -> numa_node ; if ( dev -> inflight_info == NULL ) { dev -> inflight_info = rte_zmalloc_socket ( \"inflight_info\" , sizeof ( struct inflight_mem_info ) , 0 , numa_node ) ; if ( ! dev -> inflight_info ) { VHOST_LOG_CONFIG ( ERR , \"(%s)<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>dev<S2SV_blank>inflight<S2SV_blank>area\\\\n\" , dev -> ifname ) ; return RTE_VHOST_MSG_RESULT_ERR ; } dev -> inflight_info -> fd = - 1 ; } num_queues = ctx -> msg . payload . inflight . num_queues ; queue_size = ctx -> msg . payload . inflight . queue_size ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>get_inflight_fd<S2SV_blank>num_queues:<S2SV_blank>%u\\\\n\" , dev -> ifname , ctx -> msg . payload . inflight . num_queues ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>get_inflight_fd<S2SV_blank>queue_size:<S2SV_blank>%u\\\\n\" , dev -> ifname , ctx -> msg . payload . inflight . queue_size ) ; if ( vq_is_packed ( dev ) ) pervq_inflight_size = get_pervq_shm_size_packed ( queue_size ) ; else pervq_inflight_size = get_pervq_shm_size_split ( queue_size ) ; mmap_size = num_queues * pervq_inflight_size ; addr = inflight_mem_alloc ( dev , \"vhost-inflight\" , mmap_size , & fd ) ; if ( ! addr ) { VHOST_LOG_CONFIG ( ERR , \"(%s)<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>vhost<S2SV_blank>inflight<S2SV_blank>area\\\\n\" , dev -> ifname ) ; ctx -> msg . payload . inflight . mmap_size = 0 ; return RTE_VHOST_MSG_RESULT_ERR ; } memset ( addr , 0 , mmap_size ) ; if ( dev -> inflight_info -> addr ) { munmap ( dev -> inflight_info -> addr , dev -> inflight_info -> size ) ; dev -> inflight_info -> addr = NULL ; } if ( dev -> inflight_info -> fd >= 0 ) { close ( dev -> inflight_info -> fd ) ; dev -> inflight_info -> fd = - 1 ; } dev -> inflight_info -> addr = addr ; dev -> inflight_info -> size = ctx -> msg . payload . inflight . mmap_size = mmap_size ; dev -> inflight_info -> fd = ctx -> fds [ 0 ] = fd ; ctx -> msg . payload . inflight . mmap_offset = 0 ; ctx -> fd_num = 1 ; if ( vq_is_packed ( dev ) ) { for ( i = 0 ; i < num_queues ; i ++ ) { inflight_packed = ( struct rte_vhost_inflight_info_packed * ) addr ; inflight_packed -> used_wrap_counter = 1 ; inflight_packed -> old_used_wrap_counter = 1 ; for ( j = 0 ; j < queue_size ; j ++ ) inflight_packed -> desc [ j ] . next = j + 1 ; addr = ( void * ) ( ( char * ) addr + pervq_inflight_size ) ; } } VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>send<S2SV_blank>inflight<S2SV_blank>mmap_size:<S2SV_blank>%\" PRIu64 \"\\\\n\" , dev -> ifname , ctx -> msg . payload . inflight . mmap_size ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>send<S2SV_blank>inflight<S2SV_blank>mmap_offset:<S2SV_blank>%\" PRIu64 \"\\\\n\" , dev -> ifname , ctx -> msg . payload . inflight . mmap_offset ) ; VHOST_LOG_CONFIG ( INFO , \"(%s)<S2SV_blank>send<S2SV_blank>inflight<S2SV_blank>fd:<S2SV_blank>%d\\\\n\" , dev -> ifname , ctx -> fds [ 0 ] ) ; return RTE_VHOST_MSG_RESULT_REPLY ; }", "target": "<S2SV_ModStart> void * addr ; if ( validate_msg_fds ( dev , ctx , 0 ) != 0 ) return RTE_VHOST_MSG_RESULT_ERR"}
{"source": "CWE-416 do_arg_all ( int count , int forceit , int keep_tabs ) { int i ; win_T * wp , * wpnext ; char_u * opened ; int opened_len ; int use_firstwin = FALSE ; int tab_drop_empty_window = FALSE ; int split_ret = OK ; int p_ea_save ; alist_T * alist ; buf_T * buf ; tabpage_T * tpnext ; int had_tab = cmdmod . cmod_tab ; win_T * old_curwin , * last_curwin ; tabpage_T * old_curtab , * last_curtab ; win_T * new_curwin = NULL ; tabpage_T * new_curtab = NULL ; <S2SV_StartBug> <S2SV_EndBug> # ifdef FEAT_CMDWIN if ( cmdwin_type != 0 ) { emsg ( _ ( e_invalid_in_cmdline_window ) ) ; return ; } # endif if ( ARGCOUNT <= 0 ) { return ; } setpcmark ( ) ; opened_len = ARGCOUNT ; opened = alloc_clear ( opened_len ) ; if ( opened == NULL ) return ; alist = curwin -> w_alist ; <S2SV_StartBug> ++ alist -> al_refcount ; <S2SV_EndBug> old_curwin = curwin ; old_curtab = curtab ; # ifdef FEAT_GUI need_mouse_correct = TRUE ; # endif if ( had_tab > 0 ) goto_tabpage_tp ( first_tabpage , TRUE , TRUE ) ; for ( ; ; ) { tpnext = curtab -> tp_next ; for ( wp = firstwin ; wp != NULL ; wp = wpnext ) { wpnext = wp -> w_next ; buf = wp -> w_buffer ; if ( buf -> b_ffname == NULL || ( ! keep_tabs && ( buf -> b_nwindows > 1 || wp -> w_width != Columns ) ) ) i = opened_len ; else { for ( i = 0 ; i < opened_len ; ++ i ) { if ( i < alist -> al_ga . ga_len && ( AARGLIST ( alist ) [ i ] . ae_fnum == buf -> b_fnum || fullpathcmp ( alist_name ( & AARGLIST ( alist ) [ i ] ) , buf -> b_ffname , TRUE , TRUE ) & FPC_SAME ) ) { int weight = 1 ; if ( old_curtab == curtab ) { ++ weight ; if ( old_curwin == wp ) ++ weight ; } if ( weight > ( int ) opened [ i ] ) { opened [ i ] = ( char_u ) weight ; if ( i == 0 ) { if ( new_curwin != NULL ) new_curwin -> w_arg_idx = opened_len ; new_curwin = wp ; new_curtab = curtab ; } } else if ( keep_tabs ) i = opened_len ; if ( wp -> w_alist != alist ) { alist_unlink ( wp -> w_alist ) ; wp -> w_alist = alist ; ++ wp -> w_alist -> al_refcount ; } break ; } } } wp -> w_arg_idx = i ; if ( i == opened_len && ! keep_tabs ) { if ( buf_hide ( buf ) || forceit || buf -> b_nwindows > 1 || ! bufIsChanged ( buf ) ) { if ( ! buf_hide ( buf ) && buf -> b_nwindows <= 1 && bufIsChanged ( buf ) ) { bufref_T bufref ; set_bufref ( & bufref , buf ) ; ( void ) autowrite ( buf , FALSE ) ; if ( ! win_valid ( wp ) || ! bufref_valid ( & bufref ) ) { wpnext = firstwin ; continue ; } } if ( ONE_WINDOW && ( first_tabpage -> tp_next == NULL || ! had_tab ) ) use_firstwin = TRUE ; else { win_close ( wp , ! buf_hide ( buf ) && ! bufIsChanged ( buf ) ) ; if ( ! win_valid ( wpnext ) ) wpnext = firstwin ; } } } } if ( had_tab == 0 || tpnext == NULL ) break ; if ( ! valid_tabpage ( tpnext ) ) tpnext = first_tabpage ; goto_tabpage_tp ( tpnext , TRUE , TRUE ) ; } if ( count > opened_len || count <= 0 ) count = opened_len ; ++ autocmd_no_enter ; ++ autocmd_no_leave ; last_curwin = curwin ; last_curtab = curtab ; win_enter ( lastwin , FALSE ) ; if ( keep_tabs && BUFEMPTY ( ) && curbuf -> b_nwindows == 1 && curbuf -> b_ffname == NULL && ! curbuf -> b_changed ) { use_firstwin = TRUE ; tab_drop_empty_window = TRUE ; } for ( i = 0 ; i < count && ! got_int ; ++ i ) { if ( alist == & global_alist && i == global_alist . al_ga . ga_len - 1 ) arg_had_last = TRUE ; if ( opened [ i ] > 0 ) { if ( curwin -> w_arg_idx != i ) { FOR_ALL_WINDOWS ( wpnext ) { if ( wpnext -> w_arg_idx == i ) { if ( keep_tabs ) { new_curwin = wpnext ; new_curtab = curtab ; } else if ( wpnext -> w_frame -> fr_parent != curwin -> w_frame -> fr_parent ) { emsg ( _ ( \"E249:<S2SV_blank>window<S2SV_blank>layout<S2SV_blank>changed<S2SV_blank>unexpectedly\" ) ) ; i = count ; break ; } else win_move_after ( wpnext , curwin ) ; break ; } } } } else if ( split_ret == OK ) { if ( tab_drop_empty_window && i == count - 1 ) -- autocmd_no_enter ; if ( ! use_firstwin ) { p_ea_save = p_ea ; p_ea = TRUE ; split_ret = win_split ( 0 , WSP_ROOM | WSP_BELOW ) ; p_ea = p_ea_save ; if ( split_ret == FAIL ) continue ; } else -- autocmd_no_leave ; curwin -> w_arg_idx = i ; if ( i == 0 ) { new_curwin = curwin ; new_curtab = curtab ; } ( void ) do_ecmd ( 0 , alist_name ( & AARGLIST ( alist ) [ i ] ) , NULL , NULL , ECMD_ONE , ( ( buf_hide ( curwin -> w_buffer ) || bufIsChanged ( curwin -> w_buffer ) ) ? ECMD_HIDE : 0 ) + ECMD_OLDBUF , curwin ) ; if ( tab_drop_empty_window && i == count - 1 ) ++ autocmd_no_enter ; if ( use_firstwin ) ++ autocmd_no_leave ; use_firstwin = FALSE ; } ui_breakcheck ( ) ; if ( had_tab > 0 && tabpage_index ( NULL ) <= p_tpm ) cmdmod . cmod_tab = 9999 ; } alist_unlink ( alist ) ; <S2SV_StartBug> <S2SV_EndBug> -- autocmd_no_enter ; if ( last_curtab != new_curtab ) { if ( valid_tabpage ( last_curtab ) ) goto_tabpage_tp ( last_curtab , TRUE , TRUE ) ; if ( win_valid ( last_curwin ) ) win_enter ( last_curwin , FALSE ) ; } if ( valid_tabpage ( new_curtab ) ) goto_tabpage_tp ( new_curtab , TRUE , TRUE ) ; if ( win_valid ( new_curwin ) ) win_enter ( new_curwin , FALSE ) ; -- autocmd_no_leave ; vim_free ( opened ) ; }", "target": "<S2SV_ModStart> = NULL ; int prev_arglist_locked = arglist_locked ; <S2SV_ModStart> alist -> al_refcount ; arglist_locked = TRUE <S2SV_ModStart> alist ) ; arglist_locked = prev_arglist_locked ;"}
{"source": "CWE-119 <S2SV_StartBug> fill_threshhold_buffer ( byte * dest_strip , byte * src_strip , int src_width , <S2SV_EndBug> int left_offset , int left_width , int num_tiles , int right_width ) { byte * ptr_out_temp = dest_strip ; int ii ; memcpy ( dest_strip , src_strip + left_offset , left_width ) ; ptr_out_temp += left_width ; for ( ii = 0 ; ii < num_tiles ; ii ++ ) { memcpy ( ptr_out_temp , src_strip , src_width ) ; ptr_out_temp += src_width ; } memcpy ( ptr_out_temp , src_strip , right_width ) ; # ifdef PACIFY_VALGRIND ptr_out_temp += right_width ; ii = ( dest_strip - ptr_out_temp ) % ( LAND_BITS - 1 ) ; if ( ii > 0 ) memset ( ptr_out_temp , 0 , ii ) ; # endif }", "target": "<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> fill_threshold_buffer <S2SV_ModEnd> ( byte *"}
{"source": "CWE-120 jetp3852_print_page ( gx_device_printer * pdev , gp_file * prn_stream ) { # define DATA_SIZE ( LINE_SIZE * 8 ) unsigned int cnt_2prn ; unsigned int count , tempcnt ; unsigned char vtp , cntc1 , cntc2 ; int line_size_color_plane ; byte data [ DATA_SIZE ] ; <S2SV_StartBug> byte plane_data [ LINE_SIZE * 3 ] ; <S2SV_EndBug> gp_fputs ( \"\\\\033@\" , prn_stream ) ; { int lnum ; int line_size = gdev_mem_bytes_per_scan_line ( ( gx_device * ) pdev ) ; int num_blank_lines = 0 ; if ( line_size > DATA_SIZE ) { emprintf2 ( pdev -> memory , \"invalid<S2SV_blank>resolution<S2SV_blank>and/or<S2SV_blank>width<S2SV_blank>gives<S2SV_blank>line_size<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max.<S2SV_blank>is<S2SV_blank>%d\\\\n\" , line_size , DATA_SIZE ) ; return_error ( gs_error_rangecheck ) ; } for ( lnum = 0 ; lnum < pdev -> height ; lnum ++ ) { byte * end_data = data + line_size ; gdev_prn_copy_scan_lines ( pdev , lnum , ( byte * ) data , line_size ) ; while ( end_data > data && end_data [ - 1 ] == 0 ) end_data -- ; if ( end_data == data ) { num_blank_lines ++ ; } else { int i ; byte * odp ; byte * row ; <S2SV_StartBug> memset ( end_data , 0 , 7 ) ; <S2SV_EndBug> for ( i = 0 , odp = plane_data ; i < DATA_SIZE ; i += 8 , odp ++ ) { # define spread3 ( c ) { 0 , c , c * 0x100 , c * 0x101 , c * 0x10000L , c * 0x10001L , c * 0x10100L , c * 0x10101L } static ulong spr40 [ 8 ] = spread3 ( 0x40 ) ; static ulong spr8 [ 8 ] = spread3 ( 8 ) ; static ulong spr2 [ 8 ] = spread3 ( 2 ) ; register byte * dp = data + i ; register ulong pword = ( spr40 [ dp [ 0 ] ] << 1 ) + ( spr40 [ dp [ 1 ] ] ) + ( spr40 [ dp [ 2 ] ] >> 1 ) + ( spr8 [ dp [ 3 ] ] << 1 ) + ( spr8 [ dp [ 4 ] ] ) + ( spr8 [ dp [ 5 ] ] >> 1 ) + ( spr2 [ dp [ 6 ] ] ) + ( spr2 [ dp [ 7 ] ] >> 1 ) ; odp [ 0 ] = ( byte ) ( pword >> 16 ) ; odp [ LINE_SIZE ] = ( byte ) ( pword >> 8 ) ; odp [ LINE_SIZE * 2 ] = ( byte ) ( pword ) ; } if ( num_blank_lines > 0 ) { while ( num_blank_lines > 255 ) { gp_fputs ( \"\\\\033e\\\\377\" , prn_stream ) ; num_blank_lines -= 255 ; } vtp = num_blank_lines ; gp_fprintf ( prn_stream , \"\\\\033e%c\" , vtp ) ; num_blank_lines = 0 ; } count = line_size / 3 ; line_size_color_plane = count / 3 ; cnt_2prn = line_size_color_plane * 3 + 5 ; tempcnt = cnt_2prn ; cntc1 = ( tempcnt & 0xFF00 ) >> 8 ; cntc2 = ( tempcnt & 0x00FF ) ; gp_fprintf ( prn_stream , \"\\\\033[O%c%c\\\\200\\\\037\" , cntc2 , cntc1 ) ; gp_fputc ( '\\\\000' , prn_stream ) ; gp_fputs ( \"\\\\124\\\\124\" , prn_stream ) ; for ( row = plane_data + LINE_SIZE * 2 , i = 0 ; i < 3 ; row -= LINE_SIZE , i ++ ) { int jj ; byte ctemp ; odp = row ; for ( jj = 0 ; jj < line_size_color_plane ; jj ++ ) { ctemp = * odp ; * odp ++ = ~ ctemp ; } gp_fwrite ( row , sizeof ( byte ) , line_size_color_plane , prn_stream ) ; } } } } gp_fputs ( \"\\\\014\" , prn_stream ) ; return 0 ; }", "target": "<S2SV_ModStart> * 3 ] ; memset ( data , 0x00 , DATA_SIZE ) <S2SV_ModStart> * row ; <S2SV_ModEnd> for ( i"}
{"source": "CWE-125 static int io_read ( struct io_kiocb * req , unsigned int issue_flags ) { struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct kiocb * kiocb = & req -> rw . kiocb ; struct iov_iter __iter , * iter = & __iter ; struct io_async_rw * rw = req -> async_data ; ssize_t io_size , ret , ret2 ; bool force_nonblock = issue_flags & IO_URING_F_NONBLOCK ; if ( rw ) { iter = & rw -> iter ; iovec = NULL ; } else { ret = io_import_iovec ( READ , req , & iovec , iter , ! force_nonblock ) ; if ( ret < 0 ) return ret ; } io_size = iov_iter_count ( iter ) ; req -> result = io_size ; if ( ! force_nonblock ) kiocb -> ki_flags &= ~ IOCB_NOWAIT ; else kiocb -> ki_flags |= IOCB_NOWAIT ; if ( force_nonblock && ! io_file_supports_async ( req , READ ) ) { ret = io_setup_async_rw ( req , iovec , inline_vecs , iter , true ) ; return ret ? : - EAGAIN ; } ret = rw_verify_area ( READ , req -> file , io_kiocb_ppos ( kiocb ) , io_size ) ; if ( unlikely ( ret ) ) { kfree ( iovec ) ; return ret ; } ret = io_iter_do_read ( req , iter ) ; if ( ret == - EAGAIN || ( req -> flags & REQ_F_REISSUE ) ) { req -> flags &= ~ REQ_F_REISSUE ; if ( ! force_nonblock && ! ( req -> ctx -> flags & IORING_SETUP_IOPOLL ) ) goto done ; if ( req -> flags & REQ_F_NOWAIT ) goto done ; <S2SV_StartBug> iov_iter_revert ( iter , io_size - iov_iter_count ( iter ) ) ; <S2SV_EndBug> ret = 0 ; } else if ( ret == - EIOCBQUEUED ) { goto out_free ; } else if ( ret <= 0 || ret == io_size || ! force_nonblock || ( req -> flags & REQ_F_NOWAIT ) || ! ( req -> flags & REQ_F_ISREG ) ) { goto done ; } ret2 = io_setup_async_rw ( req , iovec , inline_vecs , iter , true ) ; if ( ret2 ) return ret2 ; iovec = NULL ; rw = req -> async_data ; iter = & rw -> iter ; do { io_size -= ret ; rw -> bytes_done += ret ; if ( ! io_rw_should_retry ( req ) ) { kiocb -> ki_flags &= ~ IOCB_WAITQ ; return - EAGAIN ; } ret = io_iter_do_read ( req , iter ) ; if ( ret == - EIOCBQUEUED ) return 0 ; kiocb -> ki_flags &= ~ IOCB_WAITQ ; } while ( ret > 0 && ret < io_size ) ; done : kiocb_done ( kiocb , ret , issue_flags ) ; out_free : if ( iovec ) kfree ( iovec ) ; return 0 ; }", "target": "<S2SV_ModStart> goto done ; iov_iter_reexpand ( iter , iter -> count + iter -> truncated ) ;"}
{"source": "CWE-125 get_lisp_indent ( void ) { pos_T * pos , realpos , paren ; int amount ; char_u * that ; colnr_T col ; colnr_T firsttry ; int parencount , quotecount ; int vi_lisp ; vi_lisp = ( vim_strchr ( p_cpo , CPO_LISP ) != NULL ) ; realpos = curwin -> w_cursor ; curwin -> w_cursor . col = 0 ; if ( ( pos = findmatch ( NULL , '(' ) ) == NULL ) pos = findmatch ( NULL , '[' ) ; else { paren = * pos ; pos = findmatch ( NULL , '[' ) ; if ( pos == NULL || LT_POSP ( pos , & paren ) ) pos = & paren ; } if ( pos != NULL ) { amount = - 1 ; parencount = 0 ; while ( -- curwin -> w_cursor . lnum >= pos -> lnum ) { if ( linewhite ( curwin -> w_cursor . lnum ) ) continue ; for ( that = ml_get_curline ( ) ; * that != NUL ; ++ that ) { if ( * that == ';' ) { while ( * ( that + 1 ) != NUL ) ++ that ; continue ; } if ( * that == '\\\\\\\\' ) { if ( * ( that + 1 ) != NUL ) ++ that ; continue ; } if ( * that == \\'\"\\' && * ( that + 1 ) != NUL ) { while ( * ++ that && * that != \\'\"\\' ) { if ( * that == '\\\\\\\\' ) { if ( * ++ that == NUL ) break ; if ( that [ 1 ] == NUL ) { ++ that ; break ; } } } if ( * that == NUL ) break ; } if ( * that == '(' || * that == '[' ) ++ parencount ; else if ( * that == ')' || * that == ']' ) -- parencount ; } if ( parencount == 0 ) { amount = get_indent ( ) ; break ; } } if ( amount == - 1 ) { curwin -> w_cursor . lnum = pos -> lnum ; curwin -> w_cursor . col = pos -> col ; col = pos -> col ; that = ml_get_curline ( ) ; if ( vi_lisp && get_indent ( ) == 0 ) amount = 2 ; else { char_u * line = that ; amount = 0 ; while ( * that && col ) { amount += lbr_chartabsize_adv ( line , & that , ( colnr_T ) amount ) ; col -- ; } if ( ! vi_lisp && ( * that == '(' || * that == '[' ) && lisp_match ( that + 1 ) ) amount += 2 ; else { <S2SV_StartBug> that ++ ; <S2SV_EndBug> amount ++ ; firsttry = amount ; while ( VIM_ISWHITE ( * that ) ) { amount += lbr_chartabsize ( line , that , ( colnr_T ) amount ) ; ++ that ; } if ( * that && * that != ';' ) { if ( ! vi_lisp && * that != '(' && * that != '[' ) firsttry ++ ; parencount = 0 ; quotecount = 0 ; if ( vi_lisp || ( * that != \\'\"\\' && * that != '\\\\'' && * that != '#' && ( * that < '0' || * that > '9' ) ) ) { while ( * that && ( ! VIM_ISWHITE ( * that ) || quotecount || parencount ) && ( ! ( ( * that == '(' || * that == '[' ) && ! quotecount && ! parencount && vi_lisp ) ) ) { if ( * that == \\'\"\\' ) quotecount = ! quotecount ; if ( ( * that == '(' || * that == '[' ) && ! quotecount ) ++ parencount ; if ( ( * that == ')' || * that == ']' ) && ! quotecount ) -- parencount ; if ( * that == '\\\\\\\\' && * ( that + 1 ) != NUL ) amount += lbr_chartabsize_adv ( line , & that , ( colnr_T ) amount ) ; amount += lbr_chartabsize_adv ( line , & that , ( colnr_T ) amount ) ; } } while ( VIM_ISWHITE ( * that ) ) { amount += lbr_chartabsize ( line , that , ( colnr_T ) amount ) ; that ++ ; } if ( ! * that || * that == ';' ) amount = firsttry ; } } } } } else amount = 0 ; curwin -> w_cursor = realpos ; return amount ; }", "target": "<S2SV_ModStart> ; else { if ( * that != NUL ) { that ++ ; amount ++ ; } <S2SV_ModEnd> firsttry = amount"}
{"source": "CWE-415 static netdev_tx_t mcba_usb_start_xmit ( struct sk_buff * skb , struct net_device * netdev ) { struct mcba_priv * priv = netdev_priv ( netdev ) ; struct can_frame * cf = ( struct can_frame * ) skb -> data ; struct mcba_usb_ctx * ctx = NULL ; struct net_device_stats * stats = & priv -> netdev -> stats ; u16 sid ; int err ; struct mcba_usb_msg_can usb_msg = { . cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV } ; if ( can_dropped_invalid_skb ( netdev , skb ) ) return NETDEV_TX_OK ; ctx = mcba_usb_get_free_ctx ( priv , cf ) ; if ( ! ctx ) return NETDEV_TX_BUSY ; if ( cf -> can_id & CAN_EFF_FLAG ) { sid = MCBA_SIDL_EXID_MASK ; sid |= ( cf -> can_id & 0x1ffc0000 ) >> 13 ; sid |= ( cf -> can_id & 0x30000 ) >> 16 ; put_unaligned_be16 ( sid , & usb_msg . sid ) ; put_unaligned_be16 ( cf -> can_id & 0xffff , & usb_msg . eid ) ; } else { put_unaligned_be16 ( ( cf -> can_id & CAN_SFF_MASK ) << 5 , & usb_msg . sid ) ; usb_msg . eid = 0 ; } usb_msg . dlc = cf -> len ; memcpy ( usb_msg . data , cf -> data , usb_msg . dlc ) ; if ( cf -> can_id & CAN_RTR_FLAG ) usb_msg . dlc |= MCBA_DLC_RTR_MASK ; can_put_echo_skb ( skb , priv -> netdev , ctx -> ndx , 0 ) ; err = mcba_usb_xmit ( priv , ( struct mcba_usb_msg * ) & usb_msg , ctx ) ; if ( err ) goto xmit_failed ; return NETDEV_TX_OK ; xmit_failed : can_free_echo_skb ( priv -> netdev , ctx -> ndx , NULL ) ; mcba_usb_free_ctx ( ctx ) ; <S2SV_StartBug> dev_kfree_skb ( skb ) ; <S2SV_EndBug> stats -> tx_dropped ++ ; return NETDEV_TX_OK ; }", "target": "<S2SV_ModStart> ctx ) ; <S2SV_ModEnd> stats -> tx_dropped"}
{"source": "CWE-125 expand_case_fold_string ( Node * node , regex_t * reg ) { # define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION 8 int r , n , len , alt_num ; <S2SV_StartBug> UChar * start , * end , * p ; <S2SV_EndBug> Node * top_root , * root , * snode , * prev_node ; OnigCaseFoldCodeItem items [ ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM ] ; <S2SV_StartBug> StrNode * sn = STR_ ( node ) ; <S2SV_EndBug> if ( NODE_STRING_IS_AMBIG ( node ) ) return 0 ; start = sn -> s ; end = sn -> end ; if ( start >= end ) return 0 ; r = 0 ; top_root = root = prev_node = snode = NULL_NODE ; alt_num = 1 ; p = start ; while ( p < end ) { n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR ( reg -> enc , reg -> case_fold_flag , p , end , items ) ; if ( n < 0 ) { r = n ; goto err ; } len = enclen ( reg -> enc , p ) ; <S2SV_StartBug> if ( n == 0 ) { <S2SV_EndBug> if ( IS_NULL ( snode ) ) { if ( IS_NULL ( root ) && IS_NOT_NULL ( prev_node ) ) { top_root = root = onig_node_list_add ( NULL_NODE , prev_node ) ; if ( IS_NULL ( root ) ) { onig_node_free ( prev_node ) ; goto mem_err ; } } prev_node = snode = onig_node_new_str ( NULL , NULL ) ; if ( IS_NULL ( snode ) ) goto mem_err ; if ( IS_NOT_NULL ( root ) ) { if ( IS_NULL ( onig_node_list_add ( root , snode ) ) ) { onig_node_free ( snode ) ; goto mem_err ; } } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> r = onig_node_str_cat ( snode , p , p + len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) goto err ; <S2SV_EndBug> } else { alt_num *= ( n + 1 ) ; if ( alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION ) break ; if ( IS_NULL ( root ) && IS_NOT_NULL ( prev_node ) ) { top_root = root = onig_node_list_add ( NULL_NODE , prev_node ) ; if ( IS_NULL ( root ) ) { onig_node_free ( prev_node ) ; goto mem_err ; } } r = expand_case_fold_string_alt ( n , items , p , len , end , reg , & prev_node ) ; if ( r < 0 ) goto mem_err ; if ( r == 1 ) { if ( IS_NULL ( root ) ) { top_root = prev_node ; } else { if ( IS_NULL ( onig_node_list_add ( root , prev_node ) ) ) { onig_node_free ( prev_node ) ; goto mem_err ; } } root = NODE_CAR ( prev_node ) ; } else { if ( IS_NOT_NULL ( root ) ) { if ( IS_NULL ( onig_node_list_add ( root , prev_node ) ) ) { onig_node_free ( prev_node ) ; goto mem_err ; } } } snode = NULL_NODE ; } p += len ; } if ( p < end ) { Node * srem ; r = expand_case_fold_make_rem_string ( & srem , p , end , reg ) ; if ( r != 0 ) goto mem_err ; if ( IS_NOT_NULL ( prev_node ) && IS_NULL ( root ) ) { top_root = root = onig_node_list_add ( NULL_NODE , prev_node ) ; if ( IS_NULL ( root ) ) { onig_node_free ( srem ) ; onig_node_free ( prev_node ) ; goto mem_err ; } } if ( IS_NULL ( root ) ) { prev_node = srem ; } else { if ( IS_NULL ( onig_node_list_add ( root , srem ) ) ) { onig_node_free ( srem ) ; goto mem_err ; } } } top_root = ( IS_NOT_NULL ( top_root ) ? top_root : prev_node ) ; swap_node ( node , top_root ) ; onig_node_free ( top_root ) ; return 0 ; mem_err : r = ONIGERR_MEMORY ; err : onig_node_free ( top_root ) ; return r ; }", "target": "<S2SV_ModStart> , alt_num ; int is_ambig , fold_len ; <S2SV_ModStart> , * p ; UChar * foldp <S2SV_ModStart> ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM ] ; UChar buf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; <S2SV_ModStart> n == 0 || IS_NOT_NULL ( snode ) || is_good_case_fold_items_for_search ( reg -> enc , len , n , items ) <S2SV_ModStart> ; } } is_ambig = - 1 ; } else { is_ambig = NODE_STRING_IS_AMBIG ( snode ) ; } if ( n != 0 ) { foldp = p ; fold_len = ONIGENC_MBC_CASE_FOLD ( reg -> enc , reg -> case_fold_flag , & foldp , end , buf ) ; foldp = buf ; } else { foldp = p ; fold_len = len ; } if ( ( n != 0 && is_ambig == 0 ) || ( n == 0 && is_ambig > 0 ) ) { if ( IS_NULL ( root ) ) { top_root = root = onig_node_list_add ( NULL_NODE , prev_node ) ; if ( IS_NULL ( root ) ) { onig_node_free ( prev_node ) ; goto mem_err ; } } prev_node = snode = onig_node_new_str ( foldp , foldp + fold_len ) ; if ( IS_NULL ( snode ) ) goto mem_err ; if ( IS_NULL ( onig_node_list_add ( root , snode ) ) ) { onig_node_free ( snode ) ; goto mem_err ; } } else { <S2SV_ModEnd> r = onig_node_str_cat <S2SV_ModStart> ( snode , foldp , foldp + fold_len <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) goto err ; } if ( n != 0 ) NODE_STRING_SET_AMBIG ( snode )"}
{"source": "CWE-787 static RCoreSymCacheElement * parseDragons ( RBinFile * bf , RBuffer * buf , int off , int bits , R_OWN char * file_name ) { D eprintf ( \"Dragons<S2SV_blank>at<S2SV_blank>0x%x\\\\n\" , off ) ; <S2SV_StartBug> ut64 size = r_buf_size ( buf ) ; <S2SV_EndBug> if ( off >= size ) { return NULL ; } size -= off ; <S2SV_StartBug> if ( ! size ) { <S2SV_EndBug> return NULL ; } ut8 * b = malloc ( size ) ; if ( ! b ) { return NULL ; } int available = r_buf_read_at ( buf , off , b , size ) ; if ( available != size ) { eprintf ( \"Warning:<S2SV_blank>r_buf_read_at<S2SV_blank>failed\\\\n\" ) ; return NULL ; } # if 0 0x00000138 | 1a2b b2a1 0300 0000 1a2b b2a1 e055 0000 | . + ... ... . + ... U . . n_segments -- -- . . -- - how many sections ? 0x00000148 | 0100 0000 ca55 0000 0400 0000 1800 0000 | ... . . U ... ... ... . . -- -- how many symbols ? 0xc7 0x00000158 | c700 0000 0000 0000 0000 0000 0104 0000 | ... ... ... ... ... . 0x00000168 | 250b e803 0000 0100 0000 0000 bd55 0000 | % ... ... ... ... U . . 0x00000178 | 91bb e903 e35a b42c 93a4 340a 8746 9489 | ... . . Z . , . .4..F.. 0x00000188 | 0cea 4c40 0c00 0000 0900 0000 0000 0000 | . . L @ ... ... ... ... 0x00000198 | 0000 0000 0000 0000 0000 0000 0000 0000 | ... ... ... ... ... . 0x000001a8 | 0080 0000 0000 0000 5f5f 5445 5854 0000 | ... ... . . __TEXT . . 0x000001b8 | 0000 0000 0000 0000 0080 0000 0000 0000 | ... ... ... ... ... . 0x000001c8 | 0040 0000 0000 0000 5f5f 4441 5441 0000 | . @ ... ... __DATA . . 0x000001d8 | 0000 0000 0000 0000 00c0 0000 0000 0000 | ... ... ... ... ... . 0x000001e8 | 0000 0100 0000 0000 5f5f 4c4c 564d 0000 | ... ... . . __LLVM . . 0x000001f8 | 0000 0000 0000 0000 00c0 0100 0000 0000 | ... ... ... ... ... . 0x00000208 | 00c0 0000 0000 0000 5f5f 4c49 4e4b 4544 | ... ... . . __LINKED 0x00000218 | 4954 0000 0000 0000 0000 0000 d069 0000 | IT ... ... ... . . i . . # endif int magicCombo = 0 ; if ( ! memcmp ( \"\\\\x1a\\\\x2b\\\\xb2\\\\xa1\" , b , 4 ) ) { magicCombo ++ ; } if ( ! memcmp ( \"\\\\x1a\\\\x2b\\\\xb2\\\\xa1\" , b + 8 , 4 ) ) { magicCombo ++ ; } if ( magicCombo != 2 ) { available = r_buf_read_at ( buf , off - 8 , b , size ) ; if ( available != size ) { eprintf ( \"Warning:<S2SV_blank>r_buf_read_at<S2SV_blank>failed\\\\n\" ) ; return NULL ; } if ( ! memcmp ( \"\\\\x1a\\\\x2b\\\\xb2\\\\xa1\" , b , 4 ) ) { off -= 8 ; } else { eprintf ( \"0x%08x<S2SV_blank><S2SV_blank>parsing<S2SV_blank>error:<S2SV_blank>invalid<S2SV_blank>magic<S2SV_blank>retry\\\\n\" , off ) ; } } D eprintf ( \"0x%08x<S2SV_blank><S2SV_blank>magic<S2SV_blank><S2SV_blank>OK\\\\n\" , off ) ; D { const int e0ss = r_read_le32 ( b + 12 ) ; eprintf ( \"0x%08x<S2SV_blank><S2SV_blank>eoss<S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\\\n\" , off + 12 , e0ss ) ; } free ( b ) ; return r_coresym_cache_element_new ( bf , buf , off + 16 , bits , file_name ) ; }", "target": "<S2SV_ModStart> off ) ; st64 <S2SV_ModEnd> size = r_buf_size <S2SV_ModStart> ( ! size ) { return NULL ; } if ( size < 32"}
{"source": "CWE-401 int cx23888_ir_probe ( struct cx23885_dev * dev ) { struct cx23888_ir_state * state ; struct v4l2_subdev * sd ; struct v4l2_subdev_ir_parameters default_params ; int ret ; state = kzalloc ( sizeof ( struct cx23888_ir_state ) , GFP_KERNEL ) ; if ( state == NULL ) return - ENOMEM ; spin_lock_init ( & state -> rx_kfifo_lock ) ; <S2SV_StartBug> if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> <S2SV_EndBug> state -> dev = dev ; sd = & state -> sd ; v4l2_subdev_init ( sd , & cx23888_ir_controller_ops ) ; v4l2_set_subdevdata ( sd , state ) ; snprintf ( sd -> name , sizeof ( sd -> name ) , \"%s/888-ir\" , dev -> name ) ; sd -> grp_id = CX23885_HW_888_IR ; ret = v4l2_device_register_subdev ( & dev -> v4l2_dev , sd ) ; if ( ret == 0 ) { cx23888_ir_write4 ( dev , CX23888_IR_IRQEN_REG , 0 ) ; mutex_init ( & state -> rx_params_lock ) ; default_params = default_rx_params ; v4l2_subdev_call ( sd , ir , rx_s_parameters , & default_params ) ; mutex_init ( & state -> tx_params_lock ) ; default_params = default_tx_params ; v4l2_subdev_call ( sd , ir , tx_s_parameters , & default_params ) ; } else { kfifo_free ( & state -> rx_kfifo ) ; } return ret ; }", "target": "<S2SV_ModStart> GFP_KERNEL ) ) { kfree ( state ) ; <S2SV_ModStart> - ENOMEM ; }"}
{"source": "CWE-415 static struct rpmsg_device * rpmsg_virtio_add_ctrl_dev ( struct virtio_device * vdev ) { struct virtproc_info * vrp = vdev -> priv ; struct virtio_rpmsg_channel * vch ; struct rpmsg_device * rpdev_ctrl ; int err = 0 ; vch = kzalloc ( sizeof ( * vch ) , GFP_KERNEL ) ; if ( ! vch ) return ERR_PTR ( - ENOMEM ) ; vch -> vrp = vrp ; rpdev_ctrl = & vch -> rpdev ; rpdev_ctrl -> ops = & virtio_rpmsg_ops ; rpdev_ctrl -> dev . parent = & vrp -> vdev -> dev ; rpdev_ctrl -> dev . release = virtio_rpmsg_release_device ; rpdev_ctrl -> little_endian = virtio_is_little_endian ( vrp -> vdev ) ; err = rpmsg_ctrldev_register_device ( rpdev_ctrl ) ; if ( err ) { <S2SV_StartBug> kfree ( vch ) ; <S2SV_EndBug> return ERR_PTR ( err ) ; } return rpdev_ctrl ; }", "target": "<S2SV_ModStart> err ) { <S2SV_ModEnd> return ERR_PTR ("}
{"source": "CWE-416 static void mkiss_close ( struct tty_struct * tty ) { struct mkiss * ax ; write_lock_irq ( & disc_data_lock ) ; ax = tty -> disc_data ; tty -> disc_data = NULL ; write_unlock_irq ( & disc_data_lock ) ; if ( ! ax ) return ; if ( ! refcount_dec_and_test ( & ax -> refcnt ) ) wait_for_completion ( & ax -> dead ) ; netif_stop_queue ( ax -> dev ) ; <S2SV_StartBug> ax -> tty = NULL ; <S2SV_EndBug> unregister_netdev ( ax -> dev ) ; kfree ( ax -> rbuff ) ; kfree ( ax -> xbuff ) ; <S2SV_StartBug> free_netdev ( ax -> dev ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> dev ) ; <S2SV_ModEnd> unregister_netdev ( ax <S2SV_ModStart> xbuff ) ; ax -> tty = NULL ;"}
{"source": "CWE-401 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register PixelPacket * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { LongPixelPacket shift ; PixelPacket quantum_bits ; if ( bmp_info . ba_offset == 0 ) start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , \"BA\" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c\" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , \"BM\" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , \"CI\" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>File_size<S2SV_blank>in<S2SV_blank>header:<S2SV_blank><S2SV_blank>%u<S2SV_blank>bytes\" , bmp_info . file_size ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u\" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , \"BMP2\" , MaxTextExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g\" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , \"NonOS2HeaderSizeError\" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g\" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g\" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB\" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4\" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8\" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS\" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG\" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG\" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)\" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u\" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , \"BMP3\" , MaxTextExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , \"LengthAndFilesizeDoNotMatch\" , \"`%s\\'\" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , \"LengthAndFilesizeDoNotMatch\" , \"`%s\\'\" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , \"StaticPlanesValueNotEqualToOne\" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedNumberOfColors\" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , \"JPEGCompressNotSupported\" ) ; case BI_PNG : ThrowReaderException ( CoderError , \"PNGCompressNotSupported\" ) ; default : ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> matte = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? MagickTrue : MagickFalse ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> x_resolution = ( double ) bmp_info . x_pixels / 100.0 ; image -> y_resolution = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors\" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( ( MagickSizeType ) length / 8 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)\" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToRunlengthDecodeImage\" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> matte == MagickFalse ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> matte = MagickTrue ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> matte != MagickFalse ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register size_t sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red > 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green > 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue > 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . opacity ) & 0x80000000UL ) == 0 ) { shift . opacity ++ ; if ( shift . opacity > 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . red = ClampToQuantum ( ( MagickRealType ) sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . green = ClampToQuantum ( ( MagickRealType ) sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . blue = ClampToQuantum ( ( MagickRealType ) sample - shift . blue ) ; sample = shift . opacity ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . opacity = ClampToQuantum ( ( MagickRealType ) sample - shift . opacity ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( IndexPacket ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ( void ) IsValidColormapIndex ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( indexes + x , index ) ; ( void ) IsValidColormapIndex ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ( void ) IsValidColormapIndex ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( indexes + ( x ++ ) , index ) ; p ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ( void ) IsValidColormapIndex ( image , ( ssize_t ) * p , & index , exception ) ; SetPixelIndex ( indexes , index ) ; indexes ++ ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( bmp_info . compression != BI_RGB && bmp_info . compression != BI_BITFIELDS ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( q , ScaleShortToQuantum ( ( unsigned short ) red ) ) ; SetPixelGreen ( q , ScaleShortToQuantum ( ( unsigned short ) green ) ) ; SetPixelBlue ( q , ScaleShortToQuantum ( ( unsigned short ) blue ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . opacity ) >> 16 ; if ( quantum_bits . opacity <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( q , ScaleShortToQuantum ( ( unsigned short ) alpha ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( q , ScaleShortToQuantum ( ( unsigned short ) red ) ) ; SetPixelGreen ( q , ScaleShortToQuantum ( ( unsigned short ) green ) ) ; SetPixelBlue ( q , ScaleShortToQuantum ( ( unsigned short ) blue ) ) ; SetPixelAlpha ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . opacity ) >> 16 ; if ( quantum_bits . opacity == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( q , ScaleShortToQuantum ( ( unsigned short ) alpha ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; * magick = '\\\\0' ; if ( bmp_info . ba_offset != 0 ) { offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; <S2SV_StartBug> return ( GetFirstImageInList ( image ) ) ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image <S2SV_ModStart> image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( <S2SV_ModEnd> GetFirstImageInList ( image"}
{"source": "CWE-835 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register PixelPacket * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { LongPixelPacket shift ; PixelPacket quantum_bits ; <S2SV_StartBug> if ( bmp_info . ba_offset == 0 ) <S2SV_EndBug> start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , \"BA\" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c\" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , \"BM\" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , \"CI\" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>File_size<S2SV_blank>in<S2SV_blank>header:<S2SV_blank><S2SV_blank>%u<S2SV_blank>bytes\" , bmp_info . file_size ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u\" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , \"BMP2\" , MaxTextExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g\" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , \"NonOS2HeaderSizeError\" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap\" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g\" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g\" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB\" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4\" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8\" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS\" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG\" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG\" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)\" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u\" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , \"BMP3\" , MaxTextExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , \"LengthAndFilesizeDoNotMatch\" , \"`%s\\'\" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , \"LengthAndFilesizeDoNotMatch\" , \"`%s\\'\" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , \"StaticPlanesValueNotEqualToOne\" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedNumberOfColors\" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , \"UnrecognizedBitsPerPixel\" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , \"JPEGCompressNotSupported\" ) ; case BI_PNG : ThrowReaderException ( CoderError , \"PNGCompressNotSupported\" ) ; default : ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> matte = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? MagickTrue : MagickFalse ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> x_resolution = ( double ) bmp_info . x_pixels / 100.0 ; image -> y_resolution = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors\" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( ( MagickSizeType ) length / 8 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)\" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToRunlengthDecodeImage\" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> matte == MagickFalse ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> matte = MagickTrue ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> matte != MagickFalse ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register size_t sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red > 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green > 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue > 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . opacity ) & 0x80000000UL ) == 0 ) { shift . opacity ++ ; if ( shift . opacity > 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . red = ClampToQuantum ( ( MagickRealType ) sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . green = ClampToQuantum ( ( MagickRealType ) sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . blue = ClampToQuantum ( ( MagickRealType ) sample - shift . blue ) ; sample = shift . opacity ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample > 32U ) break ; } quantum_bits . opacity = ClampToQuantum ( ( MagickRealType ) sample - shift . opacity ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( IndexPacket ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ( void ) IsValidColormapIndex ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( indexes + x , index ) ; ( void ) IsValidColormapIndex ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ( void ) IsValidColormapIndex ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( indexes + ( x ++ ) , index ) ; p ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ( void ) IsValidColormapIndex ( image , ( ssize_t ) * p , & index , exception ) ; SetPixelIndex ( indexes , index ) ; indexes ++ ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( bmp_info . compression != BI_RGB && bmp_info . compression != BI_BITFIELDS ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( q , ScaleShortToQuantum ( ( unsigned short ) red ) ) ; SetPixelGreen ( q , ScaleShortToQuantum ( ( unsigned short ) green ) ) ; SetPixelBlue ( q , ScaleShortToQuantum ( ( unsigned short ) blue ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . opacity ) >> 16 ; if ( quantum_bits . opacity <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( q , ScaleShortToQuantum ( ( unsigned short ) alpha ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnrecognizedImageCompression\" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( q , ScaleShortToQuantum ( ( unsigned short ) red ) ) ; SetPixelGreen ( q , ScaleShortToQuantum ( ( unsigned short ) green ) ) ; SetPixelBlue ( q , ScaleShortToQuantum ( ( unsigned short ) blue ) ) ; SetPixelAlpha ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . opacity ) >> 16 ; if ( quantum_bits . opacity == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( q , ScaleShortToQuantum ( ( unsigned short ) alpha ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; * magick = '\\\\0' ; if ( bmp_info . ba_offset != 0 ) { offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> PixelPacket quantum_bits ; <S2SV_ModEnd> start_position = TellBlob"}
{"source": "CWE-22 static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { squashfs_dir_header_2 dirh ; char buffer [ sizeof ( squashfs_dir_entry_2 ) + SQUASHFS_NAME_LEN + 1 ] __attribute__ ( ( aligned ) ) ; squashfs_dir_entry_2 * dire = ( squashfs_dir_entry_2 * ) buffer ; long long start ; int bytes ; int dir_count , size ; struct dir_ent * new_dir ; struct dir * dir ; TRACE ( \"squashfs_opendir:<S2SV_blank>inode<S2SV_blank>start<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>offset<S2SV_blank>%d\\\\n\" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>malloc<S2SV_blank>failed!\\\\n\" ) ; dir -> dir_count = 0 ; dir -> cur_entry = 0 ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; if ( ( * i ) -> data == 0 ) return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; bytes = lookup_entry ( directory_table_hash , start ) ; if ( bytes == - 1 ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>\" \"found!\\\\n\" , block_start ) ; bytes += ( * i ) -> offset ; size = ( * i ) -> data + bytes ; while ( bytes < size ) { if ( swap ) { squashfs_dir_header_2 sdirh ; memcpy ( & sdirh , directory_table + bytes , sizeof ( sdirh ) ) ; SQUASHFS_SWAP_DIR_HEADER_2 ( & dirh , & sdirh ) ; } else memcpy ( & dirh , directory_table + bytes , sizeof ( dirh ) ) ; dir_count = dirh . count + 1 ; TRACE ( \"squashfs_opendir:<S2SV_blank>Read<S2SV_blank>directory<S2SV_blank>header<S2SV_blank>@<S2SV_blank>byte<S2SV_blank>position<S2SV_blank>\" \"%d,<S2SV_blank>%d<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>directory\\\\n\" ) ; goto corrupted ; } while ( dir_count -- ) { if ( swap ) { squashfs_dir_entry_2 sdire ; memcpy ( & sdire , directory_table + bytes , sizeof ( sdire ) ) ; SQUASHFS_SWAP_DIR_ENTRY_2 ( dire , & sdire ) ; } else memcpy ( dire , directory_table + bytes , sizeof ( * dire ) ) ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long\\\\n\" ) ; goto corrupted ; } memcpy ( dire -> name , directory_table + bytes , dire -> size + 1 ) ; dire -> name [ dire -> size + 1 ] = '\\\\0' ; <S2SV_StartBug> TRACE ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>entry<S2SV_blank>%s,<S2SV_blank>inode<S2SV_blank>\" <S2SV_EndBug> \"%d:%d,<S2SV_blank>type<S2SV_blank>%d\\\\n\" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; if ( ( dir -> dir_count % DIR_ENT_SIZE ) == 0 ) { new_dir = realloc ( dir -> dirs , ( dir -> dir_count + DIR_ENT_SIZE ) * sizeof ( struct dir_ent ) ) ; if ( new_dir == NULL ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>\" \"realloc<S2SV_blank>failed!\\\\n\" ) ; dir -> dirs = new_dir ; } strcpy ( dir -> dirs [ dir -> dir_count ] . name , dire -> name ) ; dir -> dirs [ dir -> dir_count ] . start_block = dirh . start_block ; dir -> dirs [ dir -> dir_count ] . offset = dire -> offset ; dir -> dirs [ dir -> dir_count ] . type = dire -> type ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } return dir ; corrupted : free ( dir -> dirs ) ; free ( dir ) ; return NULL ; }", "target": "<S2SV_ModStart> = '\\\\0' ; if ( check_name ( dire -> name , dire -> size + 1 ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>invalid<S2SV_blank>characters<S2SV_blank>in<S2SV_blank>name\\\\n\" ) ; goto corrupted ; }"}
{"source": "CWE-22 static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { <S2SV_StartBug> squashfs_dir_header_3 dirh ; <S2SV_EndBug> <S2SV_StartBug> char buffer [ sizeof ( squashfs_dir_entry_3 ) + SQUASHFS_NAME_LEN + 1 ] <S2SV_EndBug> __attribute__ ( ( aligned ) ) ; <S2SV_StartBug> squashfs_dir_entry_3 * dire = ( squashfs_dir_entry_3 * ) buffer ; <S2SV_EndBug> long long start ; int bytes ; int dir_count , size ; struct dir_ent * new_dir ; struct dir * dir ; TRACE ( \"squashfs_opendir:<S2SV_blank>inode<S2SV_blank>start<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>offset<S2SV_blank>%d\\\\n\" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>malloc<S2SV_blank>failed!\\\\n\" ) ; dir -> dir_count = 0 ; dir -> cur_entry = 0 ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; <S2SV_StartBug> if ( ( * i ) -> data == 3 ) <S2SV_EndBug> return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; bytes = lookup_entry ( directory_table_hash , start ) ; if ( bytes == - 1 ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>\" \"found!\\\\n\" , block_start ) ; bytes += ( * i ) -> offset ; <S2SV_StartBug> size = ( * i ) -> data + bytes - 3 ; <S2SV_EndBug> while ( bytes < size ) { if ( swap ) { <S2SV_StartBug> squashfs_dir_header_3 sdirh ; <S2SV_EndBug> memcpy ( & sdirh , directory_table + bytes , sizeof ( sdirh ) ) ; <S2SV_StartBug> SQUASHFS_SWAP_DIR_HEADER_3 ( & dirh , & sdirh ) ; <S2SV_EndBug> } else memcpy ( & dirh , directory_table + bytes , sizeof ( dirh ) ) ; dir_count = dirh . count + 1 ; TRACE ( \"squashfs_opendir:<S2SV_blank>Read<S2SV_blank>directory<S2SV_blank>header<S2SV_blank>@<S2SV_blank>byte<S2SV_blank>position<S2SV_blank>\" \"%d,<S2SV_blank>%d<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>directory\\\\n\" ) ; goto corrupted ; } while ( dir_count -- ) { if ( swap ) { <S2SV_StartBug> squashfs_dir_entry_3 sdire ; <S2SV_EndBug> memcpy ( & sdire , directory_table + bytes , sizeof ( sdire ) ) ; <S2SV_StartBug> SQUASHFS_SWAP_DIR_ENTRY_3 ( dire , & sdire ) ; <S2SV_EndBug> } else memcpy ( dire , directory_table + bytes , sizeof ( * dire ) ) ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long\\\\n\" ) ; goto corrupted ; } memcpy ( dire -> name , directory_table + bytes , dire -> size + 1 ) ; dire -> name [ dire -> size + 1 ] = '\\\\0' ; <S2SV_StartBug> TRACE ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>entry<S2SV_blank>%s,<S2SV_blank>inode<S2SV_blank>\" <S2SV_EndBug> \"%d:%d,<S2SV_blank>type<S2SV_blank>%d\\\\n\" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; if ( ( dir -> dir_count % DIR_ENT_SIZE ) == 0 ) { new_dir = realloc ( dir -> dirs , ( dir -> dir_count + DIR_ENT_SIZE ) * sizeof ( struct dir_ent ) ) ; if ( new_dir == NULL ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>\" \"realloc<S2SV_blank>failed!\\\\n\" ) ; dir -> dirs = new_dir ; } strcpy ( dir -> dirs [ dir -> dir_count ] . name , dire -> name ) ; dir -> dirs [ dir -> dir_count ] . start_block = dirh . start_block ; dir -> dirs [ dir -> dir_count ] . offset = dire -> offset ; dir -> dirs [ dir -> dir_count ] . type = dire -> type ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } return dir ; corrupted : free ( dir -> dirs ) ; free ( dir ) ; return NULL ; }", "target": "<S2SV_ModStart> i ) { squashfs_dir_header_2 <S2SV_ModEnd> dirh ; char <S2SV_ModStart> [ sizeof ( squashfs_dir_entry_2 <S2SV_ModEnd> ) + SQUASHFS_NAME_LEN <S2SV_ModStart> ) ) ; squashfs_dir_entry_2 * dire = ( squashfs_dir_entry_2 <S2SV_ModEnd> * ) buffer <S2SV_ModStart> -> data == 0 <S2SV_ModEnd> ) return dir <S2SV_ModStart> data + bytes <S2SV_ModEnd> ; while ( <S2SV_ModStart> swap ) { squashfs_dir_header_2 <S2SV_ModEnd> sdirh ; memcpy <S2SV_ModStart> ) ) ; SQUASHFS_SWAP_DIR_HEADER_2 <S2SV_ModEnd> ( & dirh <S2SV_ModStart> swap ) { squashfs_dir_entry_2 <S2SV_ModEnd> sdire ; memcpy <S2SV_ModStart> ) ) ; SQUASHFS_SWAP_DIR_ENTRY_2 <S2SV_ModEnd> ( dire , <S2SV_ModStart> = '\\\\0' ; if ( check_name ( dire -> name , dire -> size + 1 ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>invalid<S2SV_blank>characters<S2SV_blank>in<S2SV_blank>name\\\\n\" ) ; goto corrupted ; }"}
{"source": "CWE-22 static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { struct squashfs_dir_header dirh ; char buffer [ sizeof ( struct squashfs_dir_entry ) + SQUASHFS_NAME_LEN + 1 ] __attribute__ ( ( aligned ) ) ; struct squashfs_dir_entry * dire = ( struct squashfs_dir_entry * ) buffer ; long long start ; long long bytes ; int dir_count , size ; struct dir_ent * new_dir ; struct dir * dir ; TRACE ( \"squashfs_opendir:<S2SV_blank>inode<S2SV_blank>start<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>offset<S2SV_blank>%d\\\\n\" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>malloc<S2SV_blank>failed!\\\\n\" ) ; dir -> dir_count = 0 ; dir -> cur_entry = 0 ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; if ( ( * i ) -> data == 3 ) return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; bytes = lookup_entry ( directory_table_hash , start ) ; if ( bytes == - 1 ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>block<S2SV_blank>%lld<S2SV_blank>not<S2SV_blank>\" \"found!\\\\n\" , start ) ; bytes += ( * i ) -> offset ; size = ( * i ) -> data + bytes - 3 ; while ( bytes < size ) { SQUASHFS_SWAP_DIR_HEADER ( directory_table + bytes , & dirh ) ; dir_count = dirh . count + 1 ; TRACE ( \"squashfs_opendir:<S2SV_blank>Read<S2SV_blank>directory<S2SV_blank>header<S2SV_blank>@<S2SV_blank>byte<S2SV_blank>position<S2SV_blank>\" \"%d,<S2SV_blank>%d<S2SV_blank>directory<S2SV_blank>entries\\\\n\" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>directory\\\\n\" ) ; goto corrupted ; } while ( dir_count -- ) { SQUASHFS_SWAP_DIR_ENTRY ( directory_table + bytes , dire ) ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long\\\\n\" ) ; goto corrupted ; } memcpy ( dire -> name , directory_table + bytes , dire -> size + 1 ) ; dire -> name [ dire -> size + 1 ] = '\\\\0' ; <S2SV_StartBug> TRACE ( \"squashfs_opendir:<S2SV_blank>directory<S2SV_blank>entry<S2SV_blank>%s,<S2SV_blank>inode<S2SV_blank>\" <S2SV_EndBug> \"%d:%d,<S2SV_blank>type<S2SV_blank>%d\\\\n\" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; if ( ( dir -> dir_count % DIR_ENT_SIZE ) == 0 ) { new_dir = realloc ( dir -> dirs , ( dir -> dir_count + DIR_ENT_SIZE ) * sizeof ( struct dir_ent ) ) ; if ( new_dir == NULL ) EXIT_UNSQUASH ( \"squashfs_opendir:<S2SV_blank>\" \"realloc<S2SV_blank>failed!\\\\n\" ) ; dir -> dirs = new_dir ; } strcpy ( dir -> dirs [ dir -> dir_count ] . name , dire -> name ) ; dir -> dirs [ dir -> dir_count ] . start_block = dirh . start_block ; dir -> dirs [ dir -> dir_count ] . offset = dire -> offset ; dir -> dirs [ dir -> dir_count ] . type = dire -> type ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } return dir ; corrupted : free ( dir -> dirs ) ; free ( dir ) ; return NULL ; }", "target": "<S2SV_ModStart> = '\\\\0' ; if ( check_name ( dire -> name , dire -> size + 1 ) == FALSE ) { ERROR ( \"File<S2SV_blank>system<S2SV_blank>corrupted:<S2SV_blank>invalid<S2SV_blank>characters<S2SV_blank>in<S2SV_blank>name\\\\n\" ) ; goto corrupted ; }"}
{"source": "CWE-863  ", "target": " "}
{"source": "CWE-191 SProcXkbSelectEvents ( ClientPtr client ) { REQUEST ( xkbSelectEventsReq ) ; swaps ( & stuff -> length ) ; REQUEST_AT_LEAST_SIZE ( xkbSelectEventsReq ) ; swaps ( & stuff -> deviceSpec ) ; swaps ( & stuff -> affectWhich ) ; swaps ( & stuff -> clear ) ; swaps ( & stuff -> selectAll ) ; swaps ( & stuff -> affectMap ) ; swaps ( & stuff -> map ) ; if ( ( stuff -> affectWhich & ( ~ XkbMapNotifyMask ) ) != 0 ) { union { BOOL * b ; CARD8 * c8 ; CARD16 * c16 ; CARD32 * c32 ; } from ; register unsigned bit , ndx , maskLeft , dataLeft , size ; from . c8 = ( CARD8 * ) & stuff [ 1 ] ; <S2SV_StartBug> dataLeft = ( stuff -> length * 4 ) - SIZEOF ( xkbSelectEventsReq ) ; <S2SV_EndBug> maskLeft = ( stuff -> affectWhich & ( ~ XkbMapNotifyMask ) ) ; for ( ndx = 0 , bit = 1 ; ( maskLeft != 0 ) ; ndx ++ , bit <<= 1 ) { if ( ( ( bit & maskLeft ) == 0 ) || ( ndx == XkbMapNotify ) ) continue ; maskLeft &= ~ bit ; if ( ( stuff -> selectAll & bit ) || ( stuff -> clear & bit ) ) continue ; switch ( ndx ) { case XkbNewKeyboardNotify : case XkbStateNotify : case XkbNamesNotify : case XkbAccessXNotify : case XkbExtensionDeviceNotify : size = 2 ; break ; case XkbControlsNotify : case XkbIndicatorStateNotify : case XkbIndicatorMapNotify : size = 4 ; break ; case XkbBellNotify : case XkbActionMessage : case XkbCompatMapNotify : size = 1 ; break ; default : client -> errorValue = _XkbErrCode2 ( 0x1 , bit ) ; return BadValue ; } if ( dataLeft < ( size * 2 ) ) return BadLength ; if ( size == 2 ) { swaps ( & from . c16 [ 0 ] ) ; swaps ( & from . c16 [ 1 ] ) ; } else if ( size == 4 ) { swapl ( & from . c32 [ 0 ] ) ; swapl ( & from . c32 [ 1 ] ) ; } else { size = 2 ; } from . c8 += ( size * 2 ) ; dataLeft -= ( size * 2 ) ; } if ( dataLeft > 2 ) { ErrorF ( \"[xkb]<S2SV_blank>Extra<S2SV_blank>data<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>after<S2SV_blank>SelectEvents\\\\n\" , dataLeft ) ; return BadLength ; } } return ProcXkbSelectEvents ( client ) ; }", "target": "<S2SV_ModStart> dataLeft = ( client -> req_len <S2SV_ModEnd> * 4 )"}
{"source": "CWE-835 e1000_send_packet ( E1000State * s , const uint8_t * buf , int size ) { static const int PTCregs [ 6 ] = { PTC64 , PTC127 , PTC255 , PTC511 , PTC1023 , PTC1522 } ; NetClientState * nc = qemu_get_queue ( s -> nic ) ; if ( s -> phy_reg [ PHY_CTRL ] & MII_CR_LOOPBACK ) { <S2SV_StartBug> nc -> info -> receive ( nc , buf , size ) ; <S2SV_EndBug> } else { qemu_send_packet ( nc , buf , size ) ; } inc_tx_bcast_or_mcast_count ( s , buf ) ; e1000x_increase_size_stats ( s -> mac_reg , PTCregs , size ) ; }", "target": "<S2SV_ModStart> MII_CR_LOOPBACK ) { qemu_receive_packet <S2SV_ModEnd> ( nc ,"}
{"source": "CWE-193 void * memslot_get_virt ( RedMemSlotInfo * info , QXLPHYSICAL addr , uint32_t add_size , int group_id ) { int slot_id ; int generation ; unsigned long h_virt ; MemSlot * slot ; <S2SV_StartBug> if ( group_id > info -> num_memslots_groups ) { <S2SV_EndBug> spice_critical ( \"group_id<S2SV_blank>too<S2SV_blank>big\" ) ; return NULL ; } slot_id = memslot_get_id ( info , addr ) ; <S2SV_StartBug> if ( slot_id > info -> num_memslots ) { <S2SV_EndBug> print_memslots ( info ) ; spice_critical ( \"slot_id<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>addr=%\" PRIx64 , slot_id , addr ) ; return NULL ; } slot = & info -> mem_slots [ group_id ] [ slot_id ] ; generation = memslot_get_generation ( info , addr ) ; if ( generation != slot -> generation ) { print_memslots ( info ) ; spice_critical ( \"address<S2SV_blank>generation<S2SV_blank>is<S2SV_blank>not<S2SV_blank>valid,<S2SV_blank>group_id<S2SV_blank>%d,<S2SV_blank>slot_id<S2SV_blank>%d,<S2SV_blank>\" \"gen<S2SV_blank>%d,<S2SV_blank>slot_gen<S2SV_blank>%d\" , group_id , slot_id , generation , slot -> generation ) ; return NULL ; } h_virt = __get_clean_virt ( info , addr ) ; h_virt += slot -> address_delta ; if ( ! memslot_validate_virt ( info , h_virt , slot_id , add_size , group_id ) ) { return NULL ; } return ( void * ) ( uintptr_t ) h_virt ; }", "target": "<S2SV_ModStart> if ( group_id >= <S2SV_ModEnd> info -> num_memslots_groups <S2SV_ModStart> if ( slot_id >= <S2SV_ModEnd> info -> num_memslots"}
{"source": "CWE-125 static void warnf ( struct Configurable * config , const char * fmt , ... ) { if ( ! ( config -> conf & CONF_MUTE ) ) { va_list ap ; int len ; char * ptr ; char print_buffer [ 256 ] ; va_start ( ap , fmt ) ; va_start ( ap , fmt ) ; len = vsnprintf ( print_buffer , sizeof ( print_buffer ) , fmt , ap ) ; va_end ( ap ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( WARN_PREFIX , config -> errors ) ; if ( len > ( int ) WARN_TEXTWIDTH ) { int cut = WARN_TEXTWIDTH - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } <S2SV_StartBug> <S2SV_EndBug> fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( \"\\\\n\" , config -> errors ) ; ptr += cut + 1 ; len -= cut ; } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } } }", "target": "<S2SV_ModStart> -- ; } if ( 0 == cut ) cut = WARN_TEXTWIDTH - 1 ;"}
{"source": "CWE-200 win_redr_status ( win_T * wp , int ignore_pum UNUSED ) { int row ; char_u * p ; int len ; int fillchar ; int attr ; int this_ru_col ; static int busy = FALSE ; if ( busy ) return ; busy = TRUE ; row = statusline_row ( wp ) ; wp -> w_redr_status = FALSE ; if ( wp -> w_status_height == 0 ) { redraw_cmdline = TRUE ; } else if ( ! redrawing ( ) || ( ! ignore_pum && pum_visible ( ) ) ) { wp -> w_redr_status = TRUE ; } # ifdef FEAT_STL_OPT else if ( * p_stl != NUL || * wp -> w_p_stl != NUL ) { redraw_custom_statusline ( wp ) ; } # endif else { fillchar = fillchar_status ( & attr , wp ) ; get_trans_bufname ( wp -> w_buffer ) ; p = NameBuff ; len = ( int ) STRLEN ( p ) ; <S2SV_StartBug> if ( bt_help ( wp -> w_buffer ) <S2SV_EndBug> # ifdef FEAT_QUICKFIX || wp -> w_p_pvw # endif || bufIsChanged ( wp -> w_buffer ) <S2SV_StartBug> || wp -> w_buffer -> b_p_ro ) <S2SV_EndBug> * ( p + len ++ ) = '<S2SV_blank>' ; if ( bt_help ( wp -> w_buffer ) ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , \"%s\" , _ ( \"[Help]\" ) ) ; len += ( int ) STRLEN ( p + len ) ; } # ifdef FEAT_QUICKFIX if ( wp -> w_p_pvw ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , \"%s\" , _ ( \"[Preview]\" ) ) ; len += ( int ) STRLEN ( p + len ) ; } # endif if ( bufIsChanged ( wp -> w_buffer ) # ifdef FEAT_TERMINAL && ! bt_terminal ( wp -> w_buffer ) # endif ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , \"%s\" , \"[+]\" ) ; len += ( int ) STRLEN ( p + len ) ; } if ( wp -> w_buffer -> b_p_ro ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , \"%s\" , _ ( \"[RO]\" ) ) ; len += ( int ) STRLEN ( p + len ) ; } this_ru_col = ru_col - ( Columns - wp -> w_width ) ; if ( this_ru_col < ( wp -> w_width + 1 ) / 2 ) this_ru_col = ( wp -> w_width + 1 ) / 2 ; if ( this_ru_col <= 1 ) { p = ( char_u * ) \"<\" ; len = 1 ; } else if ( has_mbyte ) { int clen = 0 , i ; clen = mb_string2cells ( p , - 1 ) ; for ( i = 0 ; p [ i ] != NUL && clen >= this_ru_col - 1 ; i += ( * mb_ptr2len ) ( p + i ) ) clen -= ( * mb_ptr2cells ) ( p + i ) ; len = clen ; if ( i > 0 ) { p = p + i - 1 ; * p = '<' ; ++ len ; } } else if ( len > this_ru_col - 1 ) { p += len - ( this_ru_col - 1 ) ; * p = '<' ; len = this_ru_col - 1 ; } screen_puts ( p , row , wp -> w_wincol , attr ) ; screen_fill ( row , row + 1 , len + wp -> w_wincol , this_ru_col + wp -> w_wincol , fillchar , fillchar , attr ) ; if ( get_keymap_str ( wp , ( char_u * ) \"<%s>\" , NameBuff , MAXPATHL ) && ( int ) ( this_ru_col - len ) > ( int ) ( STRLEN ( NameBuff ) + 1 ) ) screen_puts ( NameBuff , row , ( int ) ( this_ru_col - STRLEN ( NameBuff ) - 1 + wp -> w_wincol ) , attr ) ; # ifdef FEAT_CMDL_INFO win_redr_ruler ( wp , TRUE , ignore_pum ) ; # endif } if ( wp -> w_vsep_width != 0 && wp -> w_status_height != 0 && redrawing ( ) ) { if ( stl_connected ( wp ) ) fillchar = fillchar_status ( & attr , wp ) ; else fillchar = fillchar_vsep ( & attr ) ; screen_putchar ( fillchar , row , W_ENDCOL ( wp ) , attr ) ; } busy = FALSE ; }", "target": "<S2SV_ModStart> ; if ( ( <S2SV_ModStart> w_buffer -> b_p_ro ) && len < MAXPATHL - 1"}
{"source": "CWE-476 void jfs_evict_inode ( struct inode * inode ) { struct jfs_inode_info * ji = JFS_IP ( inode ) ; jfs_info ( \"In<S2SV_blank>jfs_evict_inode,<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p\" , inode ) ; if ( ! inode -> i_nlink && ! is_bad_inode ( inode ) ) { dquot_initialize ( inode ) ; if ( JFS_IP ( inode ) -> fileset == FILESYSTEM_I ) { <S2SV_StartBug> truncate_inode_pages_final ( & inode -> i_data ) ; <S2SV_EndBug> if ( test_cflag ( COMMIT_Freewmap , inode ) ) jfs_free_zero_link ( inode ) ; <S2SV_StartBug> if ( JFS_SBI ( inode -> i_sb ) -> ipimap ) <S2SV_EndBug> diFree ( inode ) ; dquot_free_inode ( inode ) ; } } else { truncate_inode_pages_final ( & inode -> i_data ) ; } clear_inode ( inode ) ; dquot_drop ( inode ) ; BUG_ON ( ! list_empty ( & ji -> anon_inode_list ) ) ; spin_lock_irq ( & ji -> ag_lock ) ; if ( ji -> active_ag != - 1 ) { struct bmap * bmap = JFS_SBI ( inode -> i_sb ) -> bmap ; atomic_dec ( & bmap -> db_active [ ji -> active_ag ] ) ; ji -> active_ag = - 1 ; } spin_unlock_irq ( & ji -> ag_lock ) ; }", "target": "<S2SV_ModStart> FILESYSTEM_I ) { struct inode * ipimap = JFS_SBI ( inode -> i_sb ) -> ipimap ; <S2SV_ModStart> ; if ( ipimap && JFS_IP ( ipimap ) -> i_imap <S2SV_ModEnd> ) diFree ("}
{"source": "CWE-416 do_cmdline ( char_u * cmdline , char_u * ( * fgetline ) ( int , void * , int , getline_opt_T ) , void * cookie , int flags ) { char_u * next_cmdline ; char_u * cmdline_copy = NULL ; int used_getline = FALSE ; static int recursive = 0 ; int msg_didout_before_start = 0 ; int count = 0 ; int did_inc = FALSE ; int retval = OK ; # ifdef FEAT_EVAL cstack_T cstack ; garray_T lines_ga ; int current_line = 0 ; int current_line_before = 0 ; char_u * fname = NULL ; linenr_T * breakpoint = NULL ; int * dbg_tick = NULL ; struct dbg_stuff debug_saved ; int initial_trylevel ; msglist_T * * saved_msg_list = NULL ; msglist_T * private_msg_list = NULL ; char_u * ( * cmd_getline ) ( int , void * , int , getline_opt_T ) ; void * cmd_cookie ; struct loop_cookie cmd_loop_cookie ; void * real_cookie ; int getline_is_func ; # else # define cmd_getline fgetline # define cmd_cookie cookie # endif static int call_depth = 0 ; # ifdef FEAT_EVAL saved_msg_list = msg_list ; msg_list = & private_msg_list ; # endif if ( call_depth >= 200 # ifdef FEAT_EVAL && call_depth >= p_mfd # endif ) { emsg ( _ ( e_command_too_recursive ) ) ; # ifdef FEAT_EVAL do_errthrow ( ( cstack_T * ) NULL , ( char_u * ) NULL ) ; msg_list = saved_msg_list ; # endif return FAIL ; } ++ call_depth ; # ifdef FEAT_EVAL CLEAR_FIELD ( cstack ) ; cstack . cs_idx = - 1 ; ga_init2 ( & lines_ga , sizeof ( wcmd_T ) , 10 ) ; real_cookie = getline_cookie ( fgetline , cookie ) ; getline_is_func = getline_equal ( fgetline , cookie , get_func_line ) ; if ( getline_is_func && ex_nesting_level == func_level ( real_cookie ) ) ++ ex_nesting_level ; if ( getline_is_func ) { fname = func_name ( real_cookie ) ; breakpoint = func_breakpoint ( real_cookie ) ; dbg_tick = func_dbg_tick ( real_cookie ) ; } else if ( getline_equal ( fgetline , cookie , getsourceline ) ) { fname = SOURCING_NAME ; breakpoint = source_breakpoint ( real_cookie ) ; dbg_tick = source_dbg_tick ( real_cookie ) ; } if ( ! recursive ) { force_abort = FALSE ; suppress_errthrow = FALSE ; } if ( flags & DOCMD_EXCRESET ) save_dbg_stuff ( & debug_saved ) ; else CLEAR_FIELD ( debug_saved ) ; initial_trylevel = trylevel ; did_throw = FALSE ; # endif # ifdef FEAT_EVAL did_emsg_cumul += did_emsg ; # endif did_emsg = FALSE ; if ( ! ( flags & DOCMD_KEYTYPED ) && ! getline_equal ( fgetline , cookie , getexline ) ) KeyTyped = FALSE ; next_cmdline = cmdline ; do { # ifdef FEAT_EVAL getline_is_func = getline_equal ( fgetline , cookie , get_func_line ) ; # endif if ( next_cmdline == NULL # ifdef FEAT_EVAL && ! force_abort && cstack . cs_idx < 0 && ! ( getline_is_func && func_has_abort ( real_cookie ) ) # endif ) { # ifdef FEAT_EVAL did_emsg_cumul += did_emsg ; # endif did_emsg = FALSE ; } # ifdef FEAT_EVAL if ( cstack . cs_looplevel > 0 && current_line < lines_ga . ga_len ) { VIM_CLEAR ( cmdline_copy ) ; if ( getline_is_func ) { # ifdef FEAT_PROFILE if ( do_profiling == PROF_YES ) func_line_end ( real_cookie ) ; # endif if ( func_has_ended ( real_cookie ) ) { retval = FAIL ; break ; } } # ifdef FEAT_PROFILE else if ( do_profiling == PROF_YES && getline_equal ( fgetline , cookie , getsourceline ) ) script_line_end ( ) ; # endif if ( source_finished ( fgetline , cookie ) ) { retval = FAIL ; break ; } if ( breakpoint != NULL && dbg_tick != NULL && * dbg_tick != debug_tick ) { * breakpoint = dbg_find_breakpoint ( getline_equal ( fgetline , cookie , getsourceline ) , fname , SOURCING_LNUM ) ; * dbg_tick = debug_tick ; } next_cmdline = ( ( wcmd_T * ) ( lines_ga . ga_data ) ) [ current_line ] . line ; SOURCING_LNUM = ( ( wcmd_T * ) ( lines_ga . ga_data ) ) [ current_line ] . lnum ; if ( breakpoint != NULL && * breakpoint != 0 && * breakpoint <= SOURCING_LNUM ) { dbg_breakpoint ( fname , SOURCING_LNUM ) ; * breakpoint = dbg_find_breakpoint ( getline_equal ( fgetline , cookie , getsourceline ) , fname , SOURCING_LNUM ) ; * dbg_tick = debug_tick ; } # ifdef FEAT_PROFILE if ( do_profiling == PROF_YES ) { if ( getline_is_func ) func_line_start ( real_cookie , SOURCING_LNUM ) ; else if ( getline_equal ( fgetline , cookie , getsourceline ) ) script_line_start ( ) ; } # endif } # endif if ( next_cmdline == NULL ) { if ( count == 1 && getline_equal ( fgetline , cookie , getexline ) ) msg_didout = TRUE ; if ( fgetline == NULL || ( next_cmdline = fgetline ( ':' , cookie , # ifdef FEAT_EVAL cstack . cs_idx < 0 ? 0 : ( cstack . cs_idx + 1 ) * 2 # else 0 # endif , in_vim9script ( ) ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT ) ) == NULL ) { if ( KeyTyped && ! ( flags & DOCMD_REPEAT ) ) need_wait_return = FALSE ; retval = FAIL ; break ; } used_getline = TRUE ; if ( flags & DOCMD_KEEPLINE ) { vim_free ( repeat_cmdline ) ; if ( count == 0 ) repeat_cmdline = vim_strsave ( next_cmdline ) ; else repeat_cmdline = NULL ; } } else if ( cmdline_copy == NULL ) { next_cmdline = vim_strsave ( next_cmdline ) ; if ( next_cmdline == NULL ) { emsg ( _ ( e_out_of_memory ) ) ; retval = FAIL ; break ; } } cmdline_copy = next_cmdline ; # ifdef FEAT_EVAL if ( ( cstack . cs_looplevel > 0 || has_loop_cmd ( next_cmdline ) ) ) { cmd_getline = get_loop_line ; cmd_cookie = ( void * ) & cmd_loop_cookie ; cmd_loop_cookie . lines_gap = & lines_ga ; cmd_loop_cookie . current_line = current_line ; cmd_loop_cookie . getline = fgetline ; cmd_loop_cookie . cookie = cookie ; cmd_loop_cookie . repeating = ( current_line < lines_ga . ga_len ) ; if ( current_line == lines_ga . ga_len && store_loop_line ( & lines_ga , next_cmdline ) == FAIL ) { retval = FAIL ; break ; } current_line_before = current_line ; } else { cmd_getline = fgetline ; cmd_cookie = cookie ; } did_endif = FALSE ; # endif if ( count ++ == 0 ) { if ( ! ( flags & DOCMD_NOWAIT ) && ! recursive ) { msg_didout_before_start = msg_didout ; msg_didany = FALSE ; msg_start ( ) ; msg_scroll = TRUE ; ++ no_wait_return ; ++ RedrawingDisabled ; did_inc = TRUE ; } } if ( ( p_verbose >= 15 && SOURCING_NAME != NULL ) || p_verbose >= 16 ) msg_verbose_cmd ( SOURCING_LNUM , cmdline_copy ) ; ++ recursive ; next_cmdline = do_one_cmd ( & cmdline_copy , flags , # ifdef FEAT_EVAL & cstack , # endif cmd_getline , cmd_cookie ) ; -- recursive ; # ifdef FEAT_EVAL if ( cmd_cookie == ( void * ) & cmd_loop_cookie ) current_line = cmd_loop_cookie . current_line ; # endif if ( next_cmdline == NULL ) { VIM_CLEAR ( cmdline_copy ) ; if ( getline_equal ( fgetline , cookie , getexline ) && new_last_cmdline != NULL ) { vim_free ( last_cmdline ) ; last_cmdline = new_last_cmdline ; new_last_cmdline = NULL ; } } else { STRMOVE ( cmdline_copy , next_cmdline ) ; next_cmdline = cmdline_copy ; } # ifdef FEAT_EVAL if ( did_emsg && ! force_abort && getline_equal ( fgetline , cookie , get_func_line ) && ! func_has_abort ( real_cookie ) ) { did_emsg = FALSE ; } if ( cstack . cs_looplevel > 0 ) { ++ current_line ; if ( cstack . cs_lflags & ( CSL_HAD_CONT | CSL_HAD_ENDLOOP ) ) { cstack . cs_lflags &= ~ ( CSL_HAD_CONT | CSL_HAD_ENDLOOP ) ; if ( ! did_emsg && ! got_int && ! did_throw && cstack . cs_idx >= 0 && ( cstack . cs_flags [ cstack . cs_idx ] & ( CSF_WHILE | CSF_FOR ) ) && cstack . cs_line [ cstack . cs_idx ] >= 0 && ( cstack . cs_flags [ cstack . cs_idx ] & CSF_ACTIVE ) ) { current_line = cstack . cs_line [ cstack . cs_idx ] ; cstack . cs_lflags |= CSL_HAD_LOOP ; line_breakcheck ( ) ; <S2SV_StartBug> if ( breakpoint != NULL ) <S2SV_EndBug> { * breakpoint = dbg_find_breakpoint ( getline_equal ( fgetline , cookie , getsourceline ) , fname , ( ( wcmd_T * ) lines_ga . ga_data ) [ current_line ] . lnum - 1 ) ; * dbg_tick = debug_tick ; } } else { if ( cstack . cs_idx >= 0 ) rewind_conditionals ( & cstack , cstack . cs_idx - 1 , CSF_WHILE | CSF_FOR , & cstack . cs_looplevel ) ; } } else if ( cstack . cs_lflags & CSL_HAD_LOOP ) { cstack . cs_lflags &= ~ CSL_HAD_LOOP ; cstack . cs_line [ cstack . cs_idx ] = current_line_before ; } } if ( breakpoint != NULL && has_watchexpr ( ) ) { * breakpoint = dbg_find_breakpoint ( FALSE , fname , SOURCING_LNUM ) ; * dbg_tick = debug_tick ; } if ( cstack . cs_looplevel == 0 ) { if ( lines_ga . ga_len > 0 ) { SOURCING_LNUM = ( ( wcmd_T * ) lines_ga . ga_data ) [ lines_ga . ga_len - 1 ] . lnum ; free_cmdlines ( & lines_ga ) ; } current_line = 0 ; } if ( cstack . cs_lflags & CSL_HAD_FINA ) { cstack . cs_lflags &= ~ CSL_HAD_FINA ; report_make_pending ( cstack . cs_pending [ cstack . cs_idx ] & ( CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW ) , did_throw ? ( void * ) current_exception : NULL ) ; did_emsg = got_int = did_throw = FALSE ; cstack . cs_flags [ cstack . cs_idx ] |= CSF_ACTIVE | CSF_FINALLY ; } trylevel = initial_trylevel + cstack . cs_trylevel ; if ( trylevel == 0 && ! did_emsg && ! got_int && ! did_throw ) force_abort = FALSE ; ( void ) do_intthrow ( & cstack ) ; # endif } while ( ! ( ( got_int # ifdef FEAT_EVAL || ( did_emsg && ( force_abort || in_vim9script ( ) ) ) || did_throw # endif ) # ifdef FEAT_EVAL && cstack . cs_trylevel == 0 # endif ) && ! ( did_emsg # ifdef FEAT_EVAL && ( cstack . cs_trylevel == 0 || did_emsg_syntax ) # endif && used_getline && ( getline_equal ( fgetline , cookie , getexmodeline ) || getline_equal ( fgetline , cookie , getexline ) ) ) && ( next_cmdline != NULL # ifdef FEAT_EVAL || cstack . cs_idx >= 0 # endif || ( flags & DOCMD_REPEAT ) ) ) ; vim_free ( cmdline_copy ) ; did_emsg_syntax = FALSE ; # ifdef FEAT_EVAL free_cmdlines ( & lines_ga ) ; ga_clear ( & lines_ga ) ; if ( cstack . cs_idx >= 0 ) { if ( ! got_int && ! did_throw && ! aborting ( ) && ! ( did_emsg && in_vim9script ( ) ) && ( ( getline_equal ( fgetline , cookie , getsourceline ) && ! source_finished ( fgetline , cookie ) ) || ( getline_equal ( fgetline , cookie , get_func_line ) && ! func_has_ended ( real_cookie ) ) ) ) { if ( cstack . cs_flags [ cstack . cs_idx ] & CSF_TRY ) emsg ( _ ( e_missing_endtry ) ) ; else if ( cstack . cs_flags [ cstack . cs_idx ] & CSF_WHILE ) emsg ( _ ( e_missing_endwhile ) ) ; else if ( cstack . cs_flags [ cstack . cs_idx ] & CSF_FOR ) emsg ( _ ( e_missing_endfor ) ) ; else emsg ( _ ( e_missing_endif ) ) ; } do { int idx = cleanup_conditionals ( & cstack , 0 , TRUE ) ; if ( idx >= 0 ) -- idx ; rewind_conditionals ( & cstack , idx , CSF_WHILE | CSF_FOR , & cstack . cs_looplevel ) ; } while ( cstack . cs_idx >= 0 ) ; trylevel = initial_trylevel ; } do_errthrow ( & cstack , getline_equal ( fgetline , cookie , get_func_line ) ? ( char_u * ) \"endfunction\" : ( char_u * ) NULL ) ; if ( trylevel == 0 ) { if ( current_exception == NULL ) did_throw = FALSE ; if ( did_throw ) handle_did_throw ( ) ; else if ( got_int || ( did_emsg && force_abort ) ) suppress_errthrow = TRUE ; } if ( did_throw ) need_rethrow = TRUE ; if ( ( getline_equal ( fgetline , cookie , getsourceline ) && ex_nesting_level > source_level ( real_cookie ) ) || ( getline_equal ( fgetline , cookie , get_func_line ) && ex_nesting_level > func_level ( real_cookie ) + 1 ) ) { if ( ! did_throw ) check_cstack = TRUE ; } else { if ( getline_equal ( fgetline , cookie , get_func_line ) ) -- ex_nesting_level ; if ( ( getline_equal ( fgetline , cookie , getsourceline ) || getline_equal ( fgetline , cookie , get_func_line ) ) && ex_nesting_level + 1 <= debug_break_level ) do_debug ( getline_equal ( fgetline , cookie , getsourceline ) ? ( char_u * ) _ ( \"End<S2SV_blank>of<S2SV_blank>sourced<S2SV_blank>file\" ) : ( char_u * ) _ ( \"End<S2SV_blank>of<S2SV_blank>function\" ) ) ; } if ( flags & DOCMD_EXCRESET ) restore_dbg_stuff ( & debug_saved ) ; msg_list = saved_msg_list ; if ( cstack . cs_emsg_silent_list != NULL ) { eslist_T * elem , * temp ; for ( elem = cstack . cs_emsg_silent_list ; elem != NULL ; elem = temp ) { temp = elem -> next ; vim_free ( elem ) ; } } # endif if ( did_inc ) { -- RedrawingDisabled ; -- no_wait_return ; msg_scroll = FALSE ; if ( retval == FAIL # ifdef FEAT_EVAL || ( did_endif && KeyTyped && ! did_emsg ) # endif ) { need_wait_return = FALSE ; msg_didany = FALSE ; } else if ( need_wait_return ) { msg_didout |= msg_didout_before_start ; wait_return ( FALSE ) ; } } # ifdef FEAT_EVAL did_endif = FALSE ; # else if_level = 0 ; # endif -- call_depth ; return retval ; }", "target": "<S2SV_ModStart> breakpoint != NULL && lines_ga . ga_len > current_line"}
{"source": "CWE-20 add_mtab ( char * devname , char * mountpoint , unsigned long flags , const char * fstype ) { <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> uid_t uid ; char * mount_user = NULL ; struct mntent mountent ; <S2SV_StartBug> FILE * pmntfile ; <S2SV_EndBug> sigset_t mask , oldmask ; uid = getuid ( ) ; if ( uid != 0 ) mount_user = getusername ( uid ) ; rc = setreuid ( geteuid ( ) , - 1 ) ; if ( rc != 0 ) { fprintf ( stderr , \"Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>real<S2SV_blank>uid<S2SV_blank>to<S2SV_blank>effective<S2SV_blank>uid:<S2SV_blank>%s\\\\n\" , strerror ( errno ) ) ; return EX_FILEIO ; } rc = sigfillset ( & mask ) ; if ( rc ) { fprintf ( stderr , \"Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>filled<S2SV_blank>signal<S2SV_blank>mask\\\\n\" ) ; return EX_FILEIO ; } rc = sigprocmask ( SIG_SETMASK , & mask , & oldmask ) ; if ( rc ) { fprintf ( stderr , \"Unable<S2SV_blank>to<S2SV_blank>make<S2SV_blank>process<S2SV_blank>ignore<S2SV_blank>signals\\\\n\" ) ; return EX_FILEIO ; } rc = toggle_dac_capability ( 1 , 1 ) ; if ( rc ) return EX_FILEIO ; atexit ( unlock_mtab ) ; rc = lock_mtab ( ) ; if ( rc ) { fprintf ( stderr , \"cannot<S2SV_blank>lock<S2SV_blank>mtab\" ) ; rc = EX_FILEIO ; goto add_mtab_exit ; } pmntfile = setmntent ( MOUNTED , \"a+\" ) ; if ( ! pmntfile ) { fprintf ( stderr , \"could<S2SV_blank>not<S2SV_blank>update<S2SV_blank>mount<S2SV_blank>table\\\\n\" ) ; unlock_mtab ( ) ; rc = EX_FILEIO ; goto add_mtab_exit ; } <S2SV_StartBug> mountent . mnt_fsname = devname ; <S2SV_EndBug> mountent . mnt_dir = mountpoint ; mountent . mnt_type = ( char * ) ( void * ) fstype ; mountent . mnt_opts = ( char * ) calloc ( MTAB_OPTIONS_LEN , 1 ) ; if ( mountent . mnt_opts ) { if ( flags & MS_RDONLY ) strlcat ( mountent . mnt_opts , \"ro\" , MTAB_OPTIONS_LEN ) ; else strlcat ( mountent . mnt_opts , \"rw\" , MTAB_OPTIONS_LEN ) ; if ( flags & MS_MANDLOCK ) strlcat ( mountent . mnt_opts , \",mand\" , MTAB_OPTIONS_LEN ) ; if ( flags & MS_NOEXEC ) strlcat ( mountent . mnt_opts , \",noexec\" , MTAB_OPTIONS_LEN ) ; if ( flags & MS_NOSUID ) strlcat ( mountent . mnt_opts , \",nosuid\" , MTAB_OPTIONS_LEN ) ; if ( flags & MS_NODEV ) strlcat ( mountent . mnt_opts , \",nodev\" , MTAB_OPTIONS_LEN ) ; if ( flags & MS_SYNCHRONOUS ) strlcat ( mountent . mnt_opts , \",sync\" , MTAB_OPTIONS_LEN ) ; if ( mount_user ) { strlcat ( mountent . mnt_opts , \",user=\" , MTAB_OPTIONS_LEN ) ; strlcat ( mountent . mnt_opts , mount_user , MTAB_OPTIONS_LEN ) ; } } mountent . mnt_freq = 0 ; mountent . mnt_passno = 0 ; rc = addmntent ( pmntfile , & mountent ) ; if ( rc ) { fprintf ( stderr , \"unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>mount<S2SV_blank>entry<S2SV_blank>to<S2SV_blank>mtab\\\\n\" ) ; <S2SV_StartBug> rc = EX_FILEIO ; <S2SV_EndBug> } endmntent ( pmntfile ) ; unlock_mtab ( ) ; SAFE_FREE ( mountent . mnt_opts ) ; add_mtab_exit : toggle_dac_capability ( 1 , 0 ) ; sigprocmask ( SIG_SETMASK , & oldmask , NULL ) ; return rc ; }", "target": "<S2SV_ModStart> rc = 0 , tmprc , fd <S2SV_ModStart> mntent mountent ; struct stat statbuf ; <S2SV_ModStart> add_mtab_exit ; } fd = fileno ( pmntfile ) ; if ( fd < 0 ) { fprintf ( stderr , \"mntent<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid\\\\n\" ) ; unlock_mtab ( ) ; rc = EX_FILEIO ; goto add_mtab_exit ; } rc = fstat ( fd , & statbuf ) ; if ( rc != 0 ) { fprintf ( stderr , \"unable<S2SV_blank>to<S2SV_blank>fstat<S2SV_blank>open<S2SV_blank>mtab\\\\n\" ) ; endmntent ( pmntfile ) ; unlock_mtab ( ) ; rc = EX_FILEIO ; goto add_mtab_exit ; } <S2SV_ModStart> \"unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>mount<S2SV_blank>entry<S2SV_blank>to<S2SV_blank>mtab\\\\n\" ) ; ftruncate ( fd , statbuf . st_size ) ; rc = EX_FILEIO ; } tmprc = my_endmntent ( pmntfile , statbuf . st_size ) ; if ( tmprc ) { fprintf ( stderr , \"error<S2SV_blank>%d<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>close<S2SV_blank>of<S2SV_blank>mtab\\\\n\" , tmprc ) ; rc = EX_FILEIO ; } <S2SV_ModEnd> unlock_mtab ( )"}
{"source": "CWE-22 extract_archive_thread ( GSimpleAsyncResult * result , GObject * object , GCancellable * cancellable ) { ExtractData * extract_data ; LoadData * load_data ; GHashTable * checked_folders ; struct archive * a ; struct archive_entry * entry ; int r ; extract_data = g_simple_async_result_get_op_res_gpointer ( result ) ; load_data = LOAD_DATA ( extract_data ) ; checked_folders = g_hash_table_new_full ( g_file_hash , ( GEqualFunc ) g_file_equal , g_object_unref , NULL ) ; fr_archive_progress_set_total_files ( load_data -> archive , extract_data -> n_files_to_extract ) ; a = archive_read_new ( ) ; archive_read_support_filter_all ( a ) ; archive_read_support_format_all ( a ) ; archive_read_open ( a , load_data , load_data_open , load_data_read , load_data_close ) ; while ( ( r = archive_read_next_header ( a , & entry ) ) == ARCHIVE_OK ) { const char * pathname ; char * fullpath ; <S2SV_StartBug> GFile * file ; <S2SV_EndBug> GFile * parent ; GOutputStream * ostream ; const void * buffer ; size_t buffer_size ; int64_t offset ; GError * local_error = NULL ; __LA_MODE_T filetype ; if ( g_cancellable_is_cancelled ( cancellable ) ) break ; pathname = archive_entry_pathname ( entry ) ; if ( ! extract_data_get_extraction_requested ( extract_data , pathname ) ) { archive_read_data_skip ( a ) ; continue ; } fullpath = ( * pathname == '/' ) ? g_strdup ( pathname ) : g_strconcat ( \"/\" , pathname , NULL ) ; <S2SV_StartBug> file = g_file_get_child ( extract_data -> destination , _g_path_get_relative_basename ( fullpath , extract_data -> base_dir , extract_data -> junk_paths ) ) ; <S2SV_EndBug> if ( extract_data -> skip_older || ! extract_data -> overwrite ) { GFileInfo * info ; info = g_file_query_info ( file , G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED , G_FILE_QUERY_INFO_NONE , cancellable , & local_error ) ; if ( info != NULL ) { gboolean skip = FALSE ; if ( ! extract_data -> overwrite ) { skip = TRUE ; } else if ( extract_data -> skip_older ) { GTimeVal modification_time ; g_file_info_get_modification_time ( info , & modification_time ) ; if ( archive_entry_mtime ( entry ) < modification_time . tv_sec ) skip = TRUE ; } g_object_unref ( info ) ; if ( skip ) { g_object_unref ( file ) ; archive_read_data_skip ( a ) ; fr_archive_progress_inc_completed_bytes ( load_data -> archive , archive_entry_size_is_set ( entry ) ? archive_entry_size ( entry ) : 0 ) ; if ( ( extract_data -> file_list != NULL ) && ( -- extract_data -> n_files_to_extract == 0 ) ) { r = ARCHIVE_EOF ; break ; } continue ; } } else { if ( ! g_error_matches ( local_error , G_IO_ERROR , G_IO_ERROR_NOT_FOUND ) ) { load_data -> error = local_error ; g_object_unref ( info ) ; break ; } g_error_free ( local_error ) ; } } fr_archive_progress_inc_completed_files ( load_data -> archive , 1 ) ; parent = g_file_get_parent ( file ) ; if ( ( parent != NULL ) && ( g_hash_table_lookup ( checked_folders , parent ) == NULL ) && ! g_file_query_exists ( parent , cancellable ) ) { if ( g_file_make_directory_with_parents ( parent , cancellable , & load_data -> error ) ) { GFile * grandparent ; grandparent = g_object_ref ( parent ) ; while ( grandparent != NULL ) { if ( g_hash_table_lookup ( checked_folders , grandparent ) == NULL ) g_hash_table_insert ( checked_folders , grandparent , GINT_TO_POINTER ( 1 ) ) ; grandparent = g_file_get_parent ( grandparent ) ; } } } g_object_unref ( parent ) ; filetype = archive_entry_filetype ( entry ) ; if ( load_data -> error == NULL ) { const char * linkname ; linkname = archive_entry_hardlink ( entry ) ; if ( linkname != NULL ) { char * link_fullpath ; <S2SV_StartBug> GFile * link_file ; <S2SV_EndBug> char * oldname ; char * newname ; int r ; link_fullpath = ( * linkname == '/' ) ? g_strdup ( linkname ) : g_strconcat ( \"/\" , linkname , NULL ) ; <S2SV_StartBug> link_file = g_file_get_child ( extract_data -> destination , _g_path_get_relative_basename ( link_fullpath , extract_data -> base_dir , extract_data -> junk_paths ) ) ; <S2SV_EndBug> oldname = g_file_get_path ( link_file ) ; newname = g_file_get_path ( file ) ; if ( ( oldname != NULL ) && ( newname != NULL ) ) r = link ( oldname , newname ) ; else r = - 1 ; if ( r == 0 ) { __LA_INT64_T filesize ; if ( archive_entry_size_is_set ( entry ) ) filesize = archive_entry_size ( entry ) ; else filesize = - 1 ; if ( filesize > 0 ) filetype = AE_IFREG ; } else { char * uri ; char * msg ; uri = g_file_get_uri ( file ) ; msg = g_strdup_printf ( \"Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>the<S2SV_blank>hard<S2SV_blank>link<S2SV_blank>%s\" , uri ) ; load_data -> error = g_error_new_literal ( G_IO_ERROR , G_IO_ERROR_FAILED , msg ) ; g_free ( msg ) ; g_free ( uri ) ; } g_free ( newname ) ; g_free ( oldname ) ; g_object_unref ( link_file ) ; g_free ( link_fullpath ) ; } } if ( load_data -> error == NULL ) { switch ( filetype ) { case AE_IFDIR : if ( ! g_file_make_directory ( file , cancellable , & local_error ) ) { if ( ! g_error_matches ( local_error , G_IO_ERROR , G_IO_ERROR_EXISTS ) ) load_data -> error = g_error_copy ( local_error ) ; g_error_free ( local_error ) ; } else _g_file_set_attributes_from_entry ( file , entry , extract_data , cancellable ) ; archive_read_data_skip ( a ) ; break ; case AE_IFREG : ostream = ( GOutputStream * ) g_file_replace ( file , NULL , FALSE , G_FILE_CREATE_REPLACE_DESTINATION , cancellable , & load_data -> error ) ; if ( ostream == NULL ) break ; while ( ( r = archive_read_data_block ( a , & buffer , & buffer_size , & offset ) ) == ARCHIVE_OK ) { if ( g_output_stream_write ( ostream , buffer , buffer_size , cancellable , & load_data -> error ) == - 1 ) break ; fr_archive_progress_inc_completed_bytes ( load_data -> archive , buffer_size ) ; } _g_object_unref ( ostream ) ; if ( r != ARCHIVE_EOF ) load_data -> error = g_error_new_literal ( FR_ERROR , FR_ERROR_COMMAND_ERROR , archive_error_string ( a ) ) ; else _g_file_set_attributes_from_entry ( file , entry , extract_data , cancellable ) ; break ; case AE_IFLNK : if ( ! g_file_make_symbolic_link ( file , archive_entry_symlink ( entry ) , cancellable , & local_error ) ) { if ( ! g_error_matches ( local_error , G_IO_ERROR , G_IO_ERROR_EXISTS ) ) load_data -> error = g_error_copy ( local_error ) ; g_error_free ( local_error ) ; } archive_read_data_skip ( a ) ; break ; default : archive_read_data_skip ( a ) ; break ; } } g_object_unref ( file ) ; g_free ( fullpath ) ; if ( load_data -> error != NULL ) break ; if ( ( extract_data -> file_list != NULL ) && ( -- extract_data -> n_files_to_extract == 0 ) ) { r = ARCHIVE_EOF ; break ; } } if ( ( load_data -> error == NULL ) && ( r != ARCHIVE_EOF ) ) load_data -> error = g_error_new_literal ( FR_ERROR , FR_ERROR_COMMAND_ERROR , archive_error_string ( a ) ) ; if ( load_data -> error == NULL ) g_cancellable_set_error_if_cancelled ( cancellable , & load_data -> error ) ; if ( load_data -> error != NULL ) g_simple_async_result_set_from_error ( result , load_data -> error ) ; g_hash_table_unref ( checked_folders ) ; archive_read_free ( a ) ; extract_data_free ( extract_data ) ; }", "target": "<S2SV_ModStart> * fullpath ; const char * relative_path ; <S2SV_ModStart> NULL ) ; relative_path = _g_path_get_relative_basename_safe ( fullpath , extract_data -> base_dir , extract_data -> junk_paths ) ; if ( relative_path == NULL ) { archive_read_data_skip ( a ) ; continue ; } <S2SV_ModStart> -> destination , relative_path <S2SV_ModEnd> ) ; if <S2SV_ModStart> * link_fullpath ; const char * relative_path ; <S2SV_ModStart> NULL ) ; relative_path = _g_path_get_relative_basename_safe ( link_fullpath , extract_data -> base_dir , extract_data -> junk_paths ) ; if ( relative_path == NULL ) { g_free ( link_fullpath ) ; archive_read_data_skip ( a ) ; continue ; } <S2SV_ModStart> -> destination , relative_path <S2SV_ModEnd> ) ; oldname"}
{"source": "CWE-22 _fr_window_ask_overwrite_dialog ( OverwriteData * odata ) <S2SV_StartBug> { <S2SV_EndBug> if ( ( odata -> edata -> overwrite == FR_OVERWRITE_ASK ) && ( odata -> current_file != NULL ) ) { const char * base_name ; GFile * destination ; <S2SV_StartBug> base_name = _g_path_get_relative_basename ( ( char * ) odata -> current_file -> data , odata -> edata -> base_dir , odata -> edata -> junk_paths ) ; <S2SV_EndBug> destination = g_file_get_child ( odata -> edata -> destination , base_name ) ; g_file_query_info_async ( destination , G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , G_PRIORITY_DEFAULT , odata -> window -> priv -> cancellable , query_info_ready_for_overwrite_dialog_cb , odata ) ; g_object_unref ( destination ) ; return ; } <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> if ( odata -> edata -> file_list != NULL ) { <S2SV_EndBug> if ( odata -> extract_all ) { _g_string_list_free ( odata -> edata -> file_list ) ; odata -> edata -> file_list = NULL ; } odata -> edata -> overwrite = FR_OVERWRITE_YES ; _fr_window_archive_extract_from_edata ( odata -> window , odata -> edata ) ; } else { GtkWidget * d ; d = _gtk_message_dialog_new ( GTK_WINDOW ( odata -> window ) , 0 , GTK_STOCK_DIALOG_WARNING , _ ( \"Extraction<S2SV_blank>not<S2SV_blank>performed\" ) , NULL , GTK_STOCK_OK , GTK_RESPONSE_OK , NULL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( d ) , GTK_RESPONSE_OK ) ; fr_window_show_error_dialog ( odata -> window , d , GTK_WINDOW ( odata -> window ) , _ ( \"Extraction<S2SV_blank>not<S2SV_blank>performed\" ) ) ; fr_window_stop_batch ( odata -> window ) ; } g_free ( odata ) ; }", "target": "<S2SV_ModStart> odata ) { gboolean perform_extraction = TRUE ; <S2SV_ModStart> ; base_name = _g_path_get_relative_basename_safe <S2SV_ModEnd> ( ( char <S2SV_ModStart> junk_paths ) ; if ( base_name != NULL ) { <S2SV_ModStart> return ; } else perform_extraction = FALSE ; } <S2SV_ModStart> edata -> file_list == NULL ) perform_extraction = FALSE ; if ( perform_extraction <S2SV_ModEnd> ) { if"}
{"source": "CWE-787 LZWDecodeCompat ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { static const char module [ ] = \"LZWDecodeCompat\" ; LZWCodecState * sp = DecoderState ( tif ) ; char * op = ( char * ) op0 ; long occ = ( long ) occ0 ; char * tp ; unsigned char * bp ; int code , nbits ; <S2SV_StartBug> long nextbits , nextdata , nbitsmask ; <S2SV_EndBug> code_t * codep , * free_entp , * maxcodep , * oldcodep ; ( void ) s ; assert ( sp != NULL ) ; if ( ( tmsize_t ) occ != occ0 ) return ( 0 ) ; if ( sp -> dec_restart ) { long residue ; codep = sp -> dec_codep ; residue = codep -> length - sp -> dec_restart ; if ( residue > occ ) { sp -> dec_restart += occ ; do { codep = codep -> next ; } while ( -- residue > occ ) ; tp = op + occ ; do { * -- tp = codep -> value ; codep = codep -> next ; } while ( -- occ ) ; return ( 1 ) ; } op += residue ; occ -= residue ; tp = op ; do { * -- tp = codep -> value ; codep = codep -> next ; } while ( -- residue ) ; sp -> dec_restart = 0 ; } bp = ( unsigned char * ) tif -> tif_rawcp ; # ifdef LZW_CHECKEOS sp -> dec_bitsleft = ( ( ( uint64 ) tif -> tif_rawcc ) << 3 ) ; # endif nbits = sp -> lzw_nbits ; nextdata = sp -> lzw_nextdata ; nextbits = sp -> lzw_nextbits ; nbitsmask = sp -> dec_nbitsmask ; oldcodep = sp -> dec_oldcodep ; free_entp = sp -> dec_free_entp ; maxcodep = sp -> dec_maxcodep ; while ( occ > 0 ) { NextCode ( tif , sp , bp , code , GetNextCodeCompat ) ; if ( code == CODE_EOI ) break ; if ( code == CODE_CLEAR ) { do { free_entp = sp -> dec_codetab + CODE_FIRST ; _TIFFmemset ( free_entp , 0 , ( CSIZE - CODE_FIRST ) * sizeof ( code_t ) ) ; nbits = BITS_MIN ; nbitsmask = MAXCODE ( BITS_MIN ) ; maxcodep = sp -> dec_codetab + nbitsmask ; NextCode ( tif , sp , bp , code , GetNextCodeCompat ) ; } while ( code == CODE_CLEAR ) ; if ( code == CODE_EOI ) break ; if ( code > CODE_CLEAR ) { TIFFErrorExt ( tif -> tif_clientdata , tif -> tif_name , \"LZWDecode:<S2SV_blank>Corrupted<S2SV_blank>LZW<S2SV_blank>table<S2SV_blank>at<S2SV_blank>scanline<S2SV_blank>%d\" , tif -> tif_row ) ; return ( 0 ) ; } * op ++ = ( char ) code ; occ -- ; oldcodep = sp -> dec_codetab + code ; continue ; } codep = sp -> dec_codetab + code ; if ( free_entp < & sp -> dec_codetab [ 0 ] || free_entp >= & sp -> dec_codetab [ CSIZE ] ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"Corrupted<S2SV_blank>LZW<S2SV_blank>table<S2SV_blank>at<S2SV_blank>scanline<S2SV_blank>%d\" , tif -> tif_row ) ; return ( 0 ) ; } free_entp -> next = oldcodep ; if ( free_entp -> next < & sp -> dec_codetab [ 0 ] || free_entp -> next >= & sp -> dec_codetab [ CSIZE ] ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"Corrupted<S2SV_blank>LZW<S2SV_blank>table<S2SV_blank>at<S2SV_blank>scanline<S2SV_blank>%d\" , tif -> tif_row ) ; return ( 0 ) ; } free_entp -> firstchar = free_entp -> next -> firstchar ; free_entp -> length = free_entp -> next -> length + 1 ; free_entp -> value = ( codep < free_entp ) ? codep -> firstchar : free_entp -> firstchar ; if ( ++ free_entp > maxcodep ) { if ( ++ nbits > BITS_MAX ) nbits = BITS_MAX ; nbitsmask = MAXCODE ( nbits ) ; maxcodep = sp -> dec_codetab + nbitsmask ; } oldcodep = codep ; if ( code >= 256 ) { if ( codep -> length == 0 ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"Wrong<S2SV_blank>length<S2SV_blank>of<S2SV_blank>decoded<S2SV_blank>\" \"string:<S2SV_blank>data<S2SV_blank>probably<S2SV_blank>corrupted<S2SV_blank>at<S2SV_blank>scanline<S2SV_blank>%d\" , tif -> tif_row ) ; return ( 0 ) ; } if ( codep -> length > occ ) { sp -> dec_codep = codep ; do { codep = codep -> next ; } while ( codep -> length > occ ) ; sp -> dec_restart = occ ; tp = op + occ ; do { * -- tp = codep -> value ; codep = codep -> next ; } while ( -- occ ) ; break ; } <S2SV_StartBug> assert ( occ >= codep -> length ) ; <S2SV_EndBug> <S2SV_StartBug> op += codep -> length ; <S2SV_EndBug> <S2SV_StartBug> occ -= codep -> length ; <S2SV_EndBug> tp = op ; do { * -- tp = codep -> value ; } while ( ( codep = codep -> next ) != NULL ) ; } else { * op ++ = ( char ) code ; occ -- ; } } tif -> tif_rawcc -= ( tmsize_t ) ( ( uint8 * ) bp - tif -> tif_rawcp ) ; tif -> tif_rawcp = ( uint8 * ) bp ; sp -> lzw_nbits = ( unsigned short ) nbits ; sp -> lzw_nextdata = nextdata ; sp -> lzw_nextbits = nextbits ; sp -> dec_nbitsmask = nbitsmask ; sp -> dec_oldcodep = oldcodep ; sp -> dec_free_entp = free_entp ; sp -> dec_maxcodep = maxcodep ; if ( occ > 0 ) { # if defined ( __WIN32__ ) && ( defined ( _MSC_VER ) || defined ( __MINGW32__ ) ) TIFFErrorExt ( tif -> tif_clientdata , module , \"Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>at<S2SV_blank>scanline<S2SV_blank>%d<S2SV_blank>(short<S2SV_blank>%I64d<S2SV_blank>bytes)\" , tif -> tif_row , ( unsigned __int64 ) occ ) ; # else TIFFErrorExt ( tif -> tif_clientdata , module , \"Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>at<S2SV_blank>scanline<S2SV_blank>%d<S2SV_blank>(short<S2SV_blank>%llu<S2SV_blank>bytes)\" , tif -> tif_row , ( unsigned long long ) occ ) ; # endif return ( 0 ) ; } return ( 1 ) ; }", "target": "<S2SV_ModStart> , nbits ; int len ; <S2SV_ModStart> break ; } len = codep -> length ; tp = op + len ; do { int t ; -- tp ; t = codep -> value ; codep = codep -> next ; * tp = ( char ) t ; } while ( codep && tp > op ) ; <S2SV_ModStart> ( occ >= len <S2SV_ModEnd> ) ; op <S2SV_ModStart> ; op += len <S2SV_ModEnd> ; occ -= <S2SV_ModStart> ; occ -= len <S2SV_ModEnd> ; } else"}
{"source": "CWE-416 static void atusb_disconnect ( struct usb_interface * interface ) { struct atusb * atusb = usb_get_intfdata ( interface ) ; dev_dbg ( & atusb -> usb_dev -> dev , \"%s\\\\n\" , __func__ ) ; atusb -> shutdown = 1 ; cancel_delayed_work_sync ( & atusb -> work ) ; usb_kill_anchored_urbs ( & atusb -> rx_urbs ) ; atusb_free_urbs ( atusb ) ; usb_kill_urb ( atusb -> tx_urb ) ; usb_free_urb ( atusb -> tx_urb ) ; ieee802154_unregister_hw ( atusb -> hw ) ; <S2SV_StartBug> ieee802154_free_hw ( atusb -> hw ) ; <S2SV_EndBug> usb_set_intfdata ( interface , NULL ) ; <S2SV_StartBug> usb_put_dev ( atusb -> usb_dev ) ; <S2SV_EndBug> pr_debug ( \"%s<S2SV_blank>done\\\\n\" , __func__ ) ; }", "target": "<S2SV_ModStart> hw ) ; usb_put_dev ( atusb -> usb_dev ) ; <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> pr_debug ( \"%s<S2SV_blank>done\\\\n\""}
{"source": "CWE-125 static MOBI_RET mobi_parse_index_entry ( MOBIIndx * indx , const MOBIIdxt idxt , const MOBITagx * tagx , const MOBIOrdt * ordt , MOBIBuffer * buf , const size_t curr_number ) { if ( indx == NULL ) { debug_print ( \"%s\" , \"INDX<S2SV_blank>structure<S2SV_blank>not<S2SV_blank>initialized\\\\n\" ) ; return MOBI_INIT_FAILED ; } const size_t entry_offset = indx -> entries_count ; const size_t entry_length = idxt . offsets [ curr_number + 1 ] - idxt . offsets [ curr_number ] ; mobi_buffer_setpos ( buf , idxt . offsets [ curr_number ] ) ; size_t entry_number = curr_number + entry_offset ; if ( entry_number >= indx -> total_entries_count ) { debug_print ( \"Entry<S2SV_blank>number<S2SV_blank>beyond<S2SV_blank>array:<S2SV_blank>%zu\\\\n\" , entry_number ) ; return MOBI_DATA_CORRUPT ; } const size_t buf_maxlen = buf -> maxlen ; if ( buf -> offset + entry_length >= buf_maxlen ) { debug_print ( \"Entry<S2SV_blank>length<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>%zu\\\\n\" , entry_length ) ; return MOBI_DATA_CORRUPT ; } buf -> maxlen = buf -> offset + entry_length ; size_t label_length = mobi_buffer_get8 ( buf ) ; if ( label_length > entry_length ) { debug_print ( \"Label<S2SV_blank>length<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>%zu\\\\n\" , label_length ) ; return MOBI_DATA_CORRUPT ; } <S2SV_StartBug> char text [ INDX_LABEL_SIZEMAX ] ; <S2SV_EndBug> if ( ordt -> ordt2 ) { label_length = mobi_getstring_ordt ( ordt , buf , ( unsigned char * ) text , label_length ) ; } else { <S2SV_StartBug> label_length = mobi_indx_get_label ( ( unsigned char * ) text , buf , label_length , indx -> ligt_entries_count ) ; <S2SV_EndBug> } indx -> entries [ entry_number ] . label = malloc ( label_length + 1 ) ; if ( indx -> entries [ entry_number ] . label == NULL ) { debug_print ( \"Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>(%zu<S2SV_blank>bytes)\\\\n\" , label_length ) ; return MOBI_MALLOC_FAILED ; } strncpy ( indx -> entries [ entry_number ] . label , text , label_length + 1 ) ; unsigned char * control_bytes ; control_bytes = buf -> data + buf -> offset ; mobi_buffer_seek ( buf , ( int ) tagx -> control_byte_count ) ; indx -> entries [ entry_number ] . tags_count = 0 ; indx -> entries [ entry_number ] . tags = NULL ; if ( tagx -> tags_count > 0 ) { typedef struct { uint8_t tag ; uint8_t tag_value_count ; uint32_t value_count ; uint32_t value_bytes ; } MOBIPtagx ; MOBIPtagx * ptagx = malloc ( tagx -> tags_count * sizeof ( MOBIPtagx ) ) ; if ( ptagx == NULL ) { debug_print ( \"Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>(%zu<S2SV_blank>bytes)\\\\n\" , tagx -> tags_count * sizeof ( MOBIPtagx ) ) ; return MOBI_MALLOC_FAILED ; } uint32_t ptagx_count = 0 ; size_t len ; size_t i = 0 ; while ( i < tagx -> tags_count ) { if ( tagx -> tags [ i ] . control_byte == 1 ) { control_bytes ++ ; i ++ ; continue ; } uint32_t value = control_bytes [ 0 ] & tagx -> tags [ i ] . bitmask ; if ( value != 0 ) { uint32_t value_count = MOBI_NOTSET ; uint32_t value_bytes = MOBI_NOTSET ; if ( value == tagx -> tags [ i ] . bitmask ) { if ( mobi_bitcount ( tagx -> tags [ i ] . bitmask ) > 1 ) { len = 0 ; value_bytes = mobi_buffer_get_varlen ( buf , & len ) ; } else { value_count = 1 ; } } else { uint8_t mask = tagx -> tags [ i ] . bitmask ; while ( ( mask & 1 ) == 0 ) { mask >>= 1 ; value >>= 1 ; } value_count = value ; } ptagx [ ptagx_count ] . tag = tagx -> tags [ i ] . tag ; ptagx [ ptagx_count ] . tag_value_count = tagx -> tags [ i ] . values_count ; ptagx [ ptagx_count ] . value_count = value_count ; ptagx [ ptagx_count ] . value_bytes = value_bytes ; ptagx_count ++ ; } i ++ ; } indx -> entries [ entry_number ] . tags = malloc ( tagx -> tags_count * sizeof ( MOBIIndexTag ) ) ; if ( indx -> entries [ entry_number ] . tags == NULL ) { debug_print ( \"Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>(%zu<S2SV_blank>bytes)\\\\n\" , tagx -> tags_count * sizeof ( MOBIIndexTag ) ) ; free ( ptagx ) ; return MOBI_MALLOC_FAILED ; } i = 0 ; while ( i < ptagx_count ) { uint32_t tagvalues_count = 0 ; uint32_t tagvalues [ INDX_TAGVALUES_MAX ] ; if ( ptagx [ i ] . value_count != MOBI_NOTSET ) { size_t count = ptagx [ i ] . value_count * ptagx [ i ] . tag_value_count ; while ( count -- && tagvalues_count < INDX_TAGVALUES_MAX ) { len = 0 ; const uint32_t value_bytes = mobi_buffer_get_varlen ( buf , & len ) ; tagvalues [ tagvalues_count ++ ] = value_bytes ; } } else { len = 0 ; while ( len < ptagx [ i ] . value_bytes && tagvalues_count < INDX_TAGVALUES_MAX ) { const uint32_t value_bytes = mobi_buffer_get_varlen ( buf , & len ) ; tagvalues [ tagvalues_count ++ ] = value_bytes ; } } if ( tagvalues_count ) { const size_t arr_size = tagvalues_count * sizeof ( * indx -> entries [ entry_number ] . tags [ i ] . tagvalues ) ; indx -> entries [ entry_number ] . tags [ i ] . tagvalues = malloc ( arr_size ) ; if ( indx -> entries [ entry_number ] . tags [ i ] . tagvalues == NULL ) { debug_print ( \"Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>(%zu<S2SV_blank>bytes)\\\\n\" , arr_size ) ; free ( ptagx ) ; return MOBI_MALLOC_FAILED ; } memcpy ( indx -> entries [ entry_number ] . tags [ i ] . tagvalues , tagvalues , arr_size ) ; } else { indx -> entries [ entry_number ] . tags [ i ] . tagvalues = NULL ; } indx -> entries [ entry_number ] . tags [ i ] . tagid = ptagx [ i ] . tag ; indx -> entries [ entry_number ] . tags [ i ] . tagvalues_count = tagvalues_count ; indx -> entries [ entry_number ] . tags_count ++ ; i ++ ; } free ( ptagx ) ; } buf -> maxlen = buf_maxlen ; return MOBI_SUCCESS ; }", "target": "<S2SV_ModStart> text [ INDX_LABEL_SIZEMAX + 1 <S2SV_ModStart> ligt_entries_count ) ; if ( buf -> error != MOBI_SUCCESS ) { debug_print ( \"Buffer<S2SV_blank>error<S2SV_blank>reading<S2SV_blank>label:<S2SV_blank>%d\\\\n\" , buf -> error ) ; return MOBI_DATA_CORRUPT ; }"}
{"source": "CWE-787 static RzDyldRebaseInfos * get_rebase_infos ( RzDyldCache * cache ) { RzDyldRebaseInfos * result = RZ_NEW0 ( RzDyldRebaseInfos ) ; if ( ! result ) { return NULL ; } if ( ! cache -> hdr -> slideInfoOffset || ! cache -> hdr -> slideInfoSize ) { <S2SV_StartBug> ut32 total_slide_infos = 0 ; <S2SV_EndBug> ut32 n_slide_infos [ MAX_N_HDR ] ; ut32 i ; for ( i = 0 ; i < cache -> n_hdr && i < MAX_N_HDR ; i ++ ) { ut64 hdr_offset = cache -> hdr_offset [ i ] ; if ( ! rz_buf_read_le32_at ( cache -> buf , 0x13c + hdr_offset , & n_slide_infos [ i ] ) ) { goto beach ; } <S2SV_StartBug> total_slide_infos += n_slide_infos [ i ] ; <S2SV_EndBug> } if ( ! total_slide_infos ) { goto beach ; } RzDyldRebaseInfosEntry * infos = RZ_NEWS0 ( RzDyldRebaseInfosEntry , total_slide_infos ) ; if ( ! infos ) { goto beach ; } ut32 k = 0 ; for ( i = 0 ; i < cache -> n_hdr && i < MAX_N_HDR ; i ++ ) { ut64 hdr_offset = cache -> hdr_offset [ i ] ; if ( ! n_slide_infos [ i ] ) { continue ; } ut32 sio ; if ( ! rz_buf_read_le32_at ( cache -> buf , 0x138 + hdr_offset , & sio ) ) { continue ; } ut64 slide_infos_offset = sio ; if ( ! slide_infos_offset ) { continue ; } slide_infos_offset += hdr_offset ; ut32 j ; RzDyldRebaseInfo * prev_info = NULL ; for ( j = 0 ; j < n_slide_infos [ i ] ; j ++ ) { ut64 offset = slide_infos_offset + j * sizeof ( cache_mapping_slide ) ; cache_mapping_slide entry ; if ( rz_buf_fread_at ( cache -> buf , offset , ( ut8 * ) & entry , \"6lii\" , 1 ) != sizeof ( cache_mapping_slide ) ) { break ; } if ( entry . slideInfoOffset && entry . slideInfoSize ) { infos [ k ] . start = entry . fileOffset + hdr_offset ; infos [ k ] . end = infos [ k ] . start + entry . size ; ut64 slide = prev_info ? prev_info -> slide : UT64_MAX ; infos [ k ] . info = get_rebase_info ( cache , entry . slideInfoOffset + hdr_offset , entry . slideInfoSize , entry . fileOffset + hdr_offset , slide ) ; prev_info = infos [ k ] . info ; k ++ ; } } } if ( ! k ) { free ( infos ) ; goto beach ; } if ( k < total_slide_infos ) { RzDyldRebaseInfosEntry * pruned_infos = RZ_NEWS0 ( RzDyldRebaseInfosEntry , k ) ; if ( ! pruned_infos ) { free ( infos ) ; goto beach ; } memcpy ( pruned_infos , infos , sizeof ( RzDyldRebaseInfosEntry ) * k ) ; free ( infos ) ; infos = pruned_infos ; } result -> entries = infos ; result -> length = k ; return result ; } if ( cache -> hdr -> mappingCount > 1 ) { RzDyldRebaseInfosEntry * infos = RZ_NEWS0 ( RzDyldRebaseInfosEntry , 1 ) ; if ( ! infos ) { goto beach ; } infos [ 0 ] . start = cache -> maps [ 1 ] . fileOffset ; infos [ 0 ] . end = infos [ 0 ] . start + cache -> maps [ 1 ] . size ; infos [ 0 ] . info = get_rebase_info ( cache , cache -> hdr -> slideInfoOffset , cache -> hdr -> slideInfoSize , infos [ 0 ] . start , UT64_MAX ) ; result -> entries = infos ; result -> length = 1 ; return result ; } beach : free ( result ) ; return NULL ; }", "target": "<S2SV_ModStart> slideInfoSize ) { size_t <S2SV_ModEnd> total_slide_infos = 0 <S2SV_ModStart> beach ; } ut32 total = total_slide_infos + <S2SV_ModEnd> n_slide_infos [ i <S2SV_ModStart> [ i ] ; if ( total < total_slide_infos ) { goto beach ; } total_slide_infos = total"}
{"source": "CWE-125 void Image : : printIFDStructure ( BasicIo & io , std : : ostream & out , Exiv2 : : PrintStructureOption option , uint32_t start , bool bSwap , char c , int depth ) { depth ++ ; bool bFirst = true ; const size_t dirSize = 32 ; DataBuf dir ( dirSize ) ; bool bPrint = option == kpsBasic || option == kpsRecursive ; do { io . seek ( start , BasicIo : : beg ) ; io . read ( dir . pData_ , 2 ) ; uint16_t dirLength = byteSwap2 ( dir , 0 , bSwap ) ; bool tooBig = dirLength > 500 ; if ( tooBig ) throw Error ( 55 ) ; if ( bFirst && bPrint ) { out << Internal : : indent ( depth ) << Internal : : stringFormat ( \"STRUCTURE<S2SV_blank>OF<S2SV_blank>TIFF<S2SV_blank>FILE<S2SV_blank>(%c%c):<S2SV_blank>\" , c , c ) << io . path ( ) << std : : endl ; if ( tooBig ) out << Internal : : indent ( depth ) << \"dirLength<S2SV_blank>=<S2SV_blank>\" << dirLength << std : : endl ; } for ( int i = 0 ; i < dirLength ; i ++ ) { if ( bFirst && bPrint ) { out << Internal : : indent ( depth ) << \"<S2SV_blank>address<S2SV_blank>|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>tag<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\" << \"<S2SV_blank>type<S2SV_blank>|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>count<S2SV_blank>|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset<S2SV_blank>|<S2SV_blank>value\\\\n\" ; } bFirst = false ; io . read ( dir . pData_ , 12 ) ; uint16_t tag = byteSwap2 ( dir , 0 , bSwap ) ; uint16_t type = byteSwap2 ( dir , 2 , bSwap ) ; uint32_t count = byteSwap4 ( dir , 4 , bSwap ) ; uint32_t offset = byteSwap4 ( dir , 8 , bSwap ) ; if ( ! typeValid ( type ) ) { std : : cerr << \"invalid<S2SV_blank>type<S2SV_blank>value<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>Image::printIFDStructure:<S2SV_blank><S2SV_blank>\" << type << std : : endl ; start = 0 ; throw Error ( 56 ) ; break ; } std : : string sp = \"\" ; uint32_t kount = isPrintXMP ( tag , option ) ? count : isPrintICC ( tag , option ) ? count : isStringType ( type ) ? ( count > 32 ? 32 : count ) : count > 5 ? 5 : count ; uint32_t pad = isStringType ( type ) ? 1 : 0 ; uint32_t size = isStringType ( type ) ? 1 : is2ByteType ( type ) ? 2 : is4ByteType ( type ) ? 4 : is8ByteType ( type ) ? 8 : 1 ; <S2SV_StartBug> DataBuf buf ( size * count + pad + 20 ) ; <S2SV_EndBug> std : : memcpy ( buf . pData_ , dir . pData_ + 8 , 4 ) ; const bool bOffsetIsPointer = count * size > 4 ; if ( bOffsetIsPointer ) { size_t restore = io . tell ( ) ; io . seek ( offset , BasicIo : : beg ) ; io . read ( buf . pData_ , count * size ) ; io . seek ( restore , BasicIo : : beg ) ; } if ( bPrint ) { const uint32_t address = start + 2 + i * 12 ; const std : : string offsetString = bOffsetIsPointer ? Internal : : stringFormat ( \"%10u\" , offset ) : \"\" ; out << Internal : : indent ( depth ) << Internal : : stringFormat ( \"%8u<S2SV_blank>|<S2SV_blank>%#06x<S2SV_blank>%-28s<S2SV_blank>|%10s<S2SV_blank>|%9u<S2SV_blank>|%10s<S2SV_blank>|<S2SV_blank>\" , address , tag , tagName ( tag ) . c_str ( ) , typeName ( type ) , count , offsetString . c_str ( ) ) ; if ( isShortType ( type ) ) { for ( size_t k = 0 ; k < kount ; k ++ ) { out << sp << byteSwap2 ( buf , k * size , bSwap ) ; sp = \"<S2SV_blank>\" ; } } else if ( isLongType ( type ) ) { for ( size_t k = 0 ; k < kount ; k ++ ) { out << sp << byteSwap4 ( buf , k * size , bSwap ) ; sp = \"<S2SV_blank>\" ; } } else if ( isRationalType ( type ) ) { for ( size_t k = 0 ; k < kount ; k ++ ) { uint32_t a = byteSwap4 ( buf , k * size + 0 , bSwap ) ; uint32_t b = byteSwap4 ( buf , k * size + 4 , bSwap ) ; out << sp << a << \"/\" << b ; sp = \"<S2SV_blank>\" ; } } else if ( isStringType ( type ) ) { out << sp << Internal : : binaryToString ( buf , kount ) ; } sp = kount == count ? \"\" : \"<S2SV_blank>...\" ; out << sp << std : : endl ; if ( option == kpsRecursive && ( tag == 0x8769 || tag == 0x014a || type == tiffIfd ) ) { for ( size_t k = 0 ; k < count ; k ++ ) { size_t restore = io . tell ( ) ; uint32_t offset = byteSwap4 ( buf , k * size , bSwap ) ; printIFDStructure ( io , out , option , offset , bSwap , c , depth ) ; io . seek ( restore , BasicIo : : beg ) ; } } else if ( option == kpsRecursive && tag == 0x83bb ) { size_t restore = io . tell ( ) ; io . seek ( offset , BasicIo : : beg ) ; byte * bytes = new byte [ count ] ; io . read ( bytes , count ) ; io . seek ( restore , BasicIo : : beg ) ; IptcData : : printStructure ( out , bytes , count , depth ) ; delete [ ] bytes ; } else if ( option == kpsRecursive && tag == 0x927c && count > 10 ) { size_t restore = io . tell ( ) ; uint32_t jump = 10 ; byte bytes [ 20 ] ; const char * chars = ( const char * ) & bytes [ 0 ] ; io . seek ( offset , BasicIo : : beg ) ; io . read ( bytes , jump ) ; bytes [ jump ] = 0 ; if ( : : strcmp ( \"Nikon\" , chars ) == 0 ) { byte * bytes = new byte [ count - jump ] ; io . read ( bytes , count - jump ) ; MemIo memIo ( bytes , count - jump ) ; printTiffStructure ( memIo , out , option , depth ) ; delete [ ] bytes ; } else { io . seek ( 0 , BasicIo : : beg ) ; printIFDStructure ( io , out , option , offset , bSwap , c , depth ) ; } io . seek ( restore , BasicIo : : beg ) ; } } if ( isPrintXMP ( tag , option ) ) { buf . pData_ [ count ] = 0 ; out << ( char * ) buf . pData_ ; } if ( isPrintICC ( tag , option ) ) { out . write ( ( const char * ) buf . pData_ , count ) ; } } if ( start ) { io . read ( dir . pData_ , 4 ) ; start = tooBig ? 0 : byteSwap4 ( dir , 0 , bSwap ) ; } } while ( start ) ; if ( bPrint ) { out << Internal : : indent ( depth ) << \"END<S2SV_blank>\" << io . path ( ) << std : : endl ; } out . flush ( ) ; depth -- ; }", "target": "<S2SV_ModStart> : 1 ; long long allocate = ( long long ) <S2SV_ModEnd> ( size * <S2SV_ModStart> pad + 20 ) ; if ( allocate > ( long long ) io . size ( ) ) { throw Error ( 57 ) ; } DataBuf buf ( allocate"}
{"source": "CWE-17 apprentice_load ( struct magic_set * ms , const char * fn , int action ) { int errs = 0 ; uint32_t i , j ; size_t files = 0 , maxfiles = 0 ; char * * filearr = NULL ; struct stat st ; struct magic_map * map ; struct magic_entry_set mset [ MAGIC_SETS ] ; php_stream * dir ; php_stream_dirent d ; TSRMLS_FETCH ( ) ; memset ( mset , 0 , sizeof ( mset ) ) ; ms -> flags |= MAGIC_CHECK ; if ( ( map = CAST ( struct magic_map * , ecalloc ( 1 , sizeof ( * map ) ) ) ) == NULL ) { file_oomem ( ms , sizeof ( * map ) ) ; return NULL ; } if ( action == FILE_CHECK ) ( void ) fprintf ( stderr , \"%s\\\\n\" , usg_hdr ) ; if ( php_sys_stat ( fn , & st ) == 0 && S_ISDIR ( st . st_mode ) ) { int mflen ; char mfn [ MAXPATHLEN ] ; dir = php_stream_opendir ( ( char * ) fn , REPORT_ERRORS , NULL ) ; if ( ! dir ) { errs ++ ; goto out ; } while ( php_stream_readdir ( dir , & d ) ) { if ( ( mflen = snprintf ( mfn , sizeof ( mfn ) , \"%s/%s\" , fn , d . d_name ) ) < 0 ) { file_oomem ( ms , strlen ( fn ) + strlen ( d . d_name ) + 2 ) ; errs ++ ; php_stream_closedir ( dir ) ; goto out ; } if ( stat ( mfn , & st ) == - 1 || ! S_ISREG ( st . st_mode ) ) { continue ; } if ( files >= maxfiles ) { size_t mlen ; maxfiles = ( maxfiles + 1 ) * 2 ; mlen = maxfiles * sizeof ( * filearr ) ; if ( ( filearr = CAST ( char * * , erealloc ( filearr , mlen ) ) ) == NULL ) { file_oomem ( ms , mlen ) ; <S2SV_StartBug> efree ( mfn ) ; <S2SV_EndBug> php_stream_closedir ( dir ) ; errs ++ ; goto out ; } } filearr [ files ++ ] = estrndup ( mfn , ( mflen > sizeof ( mfn ) - 1 ) ? sizeof ( mfn ) - 1 : mflen ) ; } php_stream_closedir ( dir ) ; qsort ( filearr , files , sizeof ( * filearr ) , cmpstrp ) ; for ( i = 0 ; i < files ; i ++ ) { load_1 ( ms , action , filearr [ i ] , & errs , mset ) ; efree ( filearr [ i ] ) ; } efree ( filearr ) ; } else load_1 ( ms , action , fn , & errs , mset ) ; if ( errs ) goto out ; for ( j = 0 ; j < MAGIC_SETS ; j ++ ) { for ( i = 0 ; i < mset [ j ] . count ; ) { if ( mset [ j ] . me [ i ] . mp -> cont_level != 0 ) { i ++ ; continue ; } i = set_text_binary ( ms , mset [ j ] . me , mset [ j ] . count , i ) ; } qsort ( mset [ j ] . me , mset [ j ] . count , sizeof ( * mset [ j ] . me ) , apprentice_sort ) ; set_last_default ( ms , mset [ j ] . me , mset [ j ] . count ) ; if ( coalesce_entries ( ms , mset [ j ] . me , mset [ j ] . count , & map -> magic [ j ] , & map -> nmagic [ j ] ) == - 1 ) { errs ++ ; goto out ; } } out : for ( j = 0 ; j < MAGIC_SETS ; j ++ ) magic_entry_free ( mset [ j ] . me , mset [ j ] . count ) ; if ( errs ) { for ( j = 0 ; j < MAGIC_SETS ; j ++ ) { if ( map -> magic [ j ] ) efree ( map -> magic [ j ] ) ; } efree ( map ) ; return NULL ; } return map ; }", "target": "<S2SV_ModStart> mlen ) ; <S2SV_ModEnd> php_stream_closedir ( dir"}
{"source": "CWE-125 static int bgp_capability_msg_parse ( struct peer * peer , uint8_t * pnt , bgp_size_t length ) { uint8_t * end ; struct capability_mp_data mpc ; struct capability_header * hdr ; uint8_t action ; iana_afi_t pkt_afi ; afi_t afi ; iana_safi_t pkt_safi ; safi_t safi ; end = pnt + length ; while ( pnt < end ) { if ( pnt + 3 > end ) { zlog_info ( \"%s<S2SV_blank>Capability<S2SV_blank>length<S2SV_blank>error\" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , BGP_NOTIFY_SUBCODE_UNSPECIFIC ) ; return BGP_Stop ; } action = * pnt ; hdr = ( struct capability_header * ) ( pnt + 1 ) ; if ( action != CAPABILITY_ACTION_SET && action != CAPABILITY_ACTION_UNSET ) { zlog_info ( \"%s<S2SV_blank>Capability<S2SV_blank>Action<S2SV_blank>Value<S2SV_blank>error<S2SV_blank>%d\" , peer -> host , action ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , BGP_NOTIFY_SUBCODE_UNSPECIFIC ) ; return BGP_Stop ; } if ( bgp_debug_neighbor_events ( peer ) ) zlog_debug ( \"%s<S2SV_blank>CAPABILITY<S2SV_blank>has<S2SV_blank>action:<S2SV_blank>%d,<S2SV_blank>code:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u\" , peer -> host , action , hdr -> code , hdr -> length ) ; <S2SV_StartBug> if ( ( pnt + hdr -> length + 3 ) > end ) { <S2SV_EndBug> zlog_info ( \"%s<S2SV_blank>Capability<S2SV_blank>length<S2SV_blank>error\" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , BGP_NOTIFY_SUBCODE_UNSPECIFIC ) ; return BGP_Stop ; } memcpy ( & mpc , pnt + 3 , sizeof ( struct capability_mp_data ) ) ; pnt += hdr -> length + 3 ; if ( hdr -> code == CAPABILITY_CODE_MP ) { pkt_afi = ntohs ( mpc . afi ) ; pkt_safi = mpc . safi ; if ( CHECK_FLAG ( peer -> flags , PEER_FLAG_OVERRIDE_CAPABILITY ) ) continue ; if ( bgp_map_afi_safi_iana2int ( pkt_afi , pkt_safi , & afi , & safi ) ) { if ( bgp_debug_neighbor_events ( peer ) ) zlog_debug ( \"%s<S2SV_blank>Dynamic<S2SV_blank>Capability<S2SV_blank>MP_EXT<S2SV_blank>afi/safi<S2SV_blank>invalid<S2SV_blank>(%s/%s)\" , peer -> host , iana_afi2str ( pkt_afi ) , iana_safi2str ( pkt_safi ) ) ; continue ; } if ( bgp_debug_neighbor_events ( peer ) ) zlog_debug ( \"%s<S2SV_blank>CAPABILITY<S2SV_blank>has<S2SV_blank>%s<S2SV_blank>MP_EXT<S2SV_blank>CAP<S2SV_blank>for<S2SV_blank>afi/safi:<S2SV_blank>%s/%s\" , peer -> host , action == CAPABILITY_ACTION_SET ? \"Advertising\" : \"Removing\" , iana_afi2str ( pkt_afi ) , iana_safi2str ( pkt_safi ) ) ; if ( action == CAPABILITY_ACTION_SET ) { peer -> afc_recv [ afi ] [ safi ] = 1 ; if ( peer -> afc [ afi ] [ safi ] ) { peer -> afc_nego [ afi ] [ safi ] = 1 ; bgp_announce_route ( peer , afi , safi , false ) ; } } else { peer -> afc_recv [ afi ] [ safi ] = 0 ; peer -> afc_nego [ afi ] [ safi ] = 0 ; if ( peer_active_nego ( peer ) ) bgp_clear_route ( peer , afi , safi ) ; else return BGP_Stop ; } } else { flog_warn ( EC_BGP_UNRECOGNIZED_CAPABILITY , \"%s<S2SV_blank>unrecognized<S2SV_blank>capability<S2SV_blank>code:<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>ignored\" , peer -> host , hdr -> code ) ; } } return BGP_PACKET_NOOP ; }", "target": "<S2SV_ModStart> ; if ( hdr -> length < sizeof ( struct capability_mp_data ) ) { zlog_info ( \"%pBP<S2SV_blank>Capability<S2SV_blank>structure<S2SV_blank>is<S2SV_blank>not<S2SV_blank>properly<S2SV_blank>filled<S2SV_blank>out,<S2SV_blank>expected<S2SV_blank>at<S2SV_blank>least<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>but<S2SV_blank>header<S2SV_blank>length<S2SV_blank>specified<S2SV_blank>is<S2SV_blank>%d\" , peer , sizeof ( struct capability_mp_data ) , hdr -> length ) ; return BGP_Stop ; } if ("}
{"source": "CWE-189 read_bitmap_file_data ( FILE * fstream , guint * width , guint * height , guchar * * data , int * x_hot , int * y_hot ) { guchar * bits = NULL ; char line [ MAX_SIZE ] ; int size ; char name_and_type [ MAX_SIZE ] ; char * type ; int value ; int version10p ; int padding ; int bytes_per_line ; guint ww = 0 ; guint hh = 0 ; int hx = - 1 ; int hy = - 1 ; if ( ! initialized ) { init_hex_table ( ) ; } # define RETURN ( code ) { g_free ( bits ) ; return code ; } while ( fgets ( line , MAX_SIZE , fstream ) ) { if ( strlen ( line ) == MAX_SIZE - 1 ) RETURN ( FALSE ) ; if ( sscanf ( line , \"#define<S2SV_blank>%s<S2SV_blank>%d\" , name_and_type , & value ) == 2 ) { if ( ! ( type = strrchr ( name_and_type , '_' ) ) ) type = name_and_type ; else { type ++ ; } <S2SV_StartBug> if ( ! strcmp ( \"width\" , type ) ) <S2SV_EndBug> ww = ( unsigned int ) value ; <S2SV_StartBug> if ( ! strcmp ( \"height\" , type ) ) <S2SV_EndBug> <S2SV_StartBug> hh = ( unsigned int ) value ; <S2SV_EndBug> if ( ! strcmp ( \"hot\" , type ) ) { if ( type -- == name_and_type || type -- == name_and_type ) continue ; if ( ! strcmp ( \"x_hot\" , type ) ) hx = value ; if ( ! strcmp ( \"y_hot\" , type ) ) hy = value ; } continue ; } if ( sscanf ( line , \"static<S2SV_blank>short<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{\" , name_and_type ) == 1 ) version10p = 1 ; else if ( sscanf ( line , \"static<S2SV_blank>const<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{\" , name_and_type ) == 1 ) version10p = 0 ; else if ( sscanf ( line , \"static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{\" , name_and_type ) == 1 ) version10p = 0 ; else if ( sscanf ( line , \"static<S2SV_blank>const<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{\" , name_and_type ) == 1 ) version10p = 0 ; else if ( sscanf ( line , \"static<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{\" , name_and_type ) == 1 ) version10p = 0 ; else continue ; if ( ! ( type = strrchr ( name_and_type , '_' ) ) ) type = name_and_type ; else type ++ ; if ( strcmp ( \"bits[]\" , type ) ) continue ; if ( ! ww || ! hh ) RETURN ( FALSE ) ; if ( ( ww % 16 ) && ( ( ww % 16 ) < 9 ) && version10p ) padding = 1 ; else padding = 0 ; bytes_per_line = ( ww + 7 ) / 8 + padding ; size = bytes_per_line * hh ; <S2SV_StartBug> bits = g_malloc ( size ) ; <S2SV_EndBug> if ( version10p ) { unsigned char * ptr ; int bytes ; for ( bytes = 0 , ptr = bits ; bytes < size ; ( bytes += 2 ) ) { if ( ( value = next_int ( fstream ) ) < 0 ) RETURN ( FALSE ) ; * ( ptr ++ ) = value ; if ( ! padding || ( ( bytes + 2 ) % bytes_per_line ) ) * ( ptr ++ ) = value >> 8 ; } } else { unsigned char * ptr ; int bytes ; for ( bytes = 0 , ptr = bits ; bytes < size ; bytes ++ , ptr ++ ) { if ( ( value = next_int ( fstream ) ) < 0 ) RETURN ( FALSE ) ; * ptr = value ; } } break ; } if ( ! bits ) RETURN ( FALSE ) ; * data = bits ; * width = ww ; * height = hh ; if ( x_hot ) * x_hot = hx ; if ( y_hot ) * y_hot = hy ; return TRUE ; }", "target": "<S2SV_ModStart> type ) ) { if ( value <= 0 ) RETURN ( FALSE ) ; <S2SV_ModStart> ) value ; } <S2SV_ModStart> type ) ) { if ( value <= 0 ) RETURN ( FALSE ) ; <S2SV_ModStart> ) value ; } <S2SV_ModStart> * hh ; if ( size / bytes_per_line != hh ) RETURN ( FALSE ) ;"}
{"source": "CWE-787 int ZEXPORT inflate ( strm , flush ) z_streamp strm ; int flush ; { struct inflate_state FAR * state ; z_const unsigned char FAR * next ; unsigned char FAR * put ; unsigned have , left ; unsigned long hold ; unsigned bits ; unsigned in , out ; unsigned copy ; unsigned char FAR * from ; code here ; code last ; unsigned len ; int ret ; # ifdef GUNZIP unsigned char hbuf [ 4 ] ; # endif static const unsigned short order [ 19 ] = { 16 , 17 , 18 , 0 , 8 , 7 , 9 , 6 , 10 , 5 , 11 , 4 , 12 , 3 , 13 , 2 , 14 , 1 , 15 } ; if ( inflateStateCheck ( strm ) || strm -> next_out == Z_NULL || ( strm -> next_in == Z_NULL && strm -> avail_in != 0 ) ) return Z_STREAM_ERROR ; state = ( struct inflate_state FAR * ) strm -> state ; if ( state -> mode == TYPE ) state -> mode = TYPEDO ; LOAD ( ) ; in = have ; out = left ; ret = Z_OK ; for ( ; ; ) switch ( state -> mode ) { case HEAD : if ( state -> wrap == 0 ) { state -> mode = TYPEDO ; break ; } NEEDBITS ( 16 ) ; # ifdef GUNZIP if ( ( state -> wrap & 2 ) && hold == 0x8b1f ) { if ( state -> wbits == 0 ) state -> wbits = 15 ; state -> check = crc32 ( 0L , Z_NULL , 0 ) ; CRC2 ( state -> check , hold ) ; INITBITS ( ) ; state -> mode = FLAGS ; break ; } if ( state -> head != Z_NULL ) state -> head -> done = - 1 ; if ( ! ( state -> wrap & 1 ) || # else if ( # endif ( ( BITS ( 8 ) << 8 ) + ( hold >> 8 ) ) % 31 ) { strm -> msg = ( char * ) \"incorrect<S2SV_blank>header<S2SV_blank>check\" ; state -> mode = BAD ; break ; } if ( BITS ( 4 ) != Z_DEFLATED ) { strm -> msg = ( char * ) \"unknown<S2SV_blank>compression<S2SV_blank>method\" ; state -> mode = BAD ; break ; } DROPBITS ( 4 ) ; len = BITS ( 4 ) + 8 ; if ( state -> wbits == 0 ) state -> wbits = len ; if ( len > 15 || len > state -> wbits ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>window<S2SV_blank>size\" ; state -> mode = BAD ; break ; } state -> dmax = 1U << len ; state -> flags = 0 ; Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank>zlib<S2SV_blank>header<S2SV_blank>ok\\\\n\" ) ) ; strm -> adler = state -> check = adler32 ( 0L , Z_NULL , 0 ) ; state -> mode = hold & 0x200 ? DICTID : TYPE ; INITBITS ( ) ; break ; # ifdef GUNZIP case FLAGS : NEEDBITS ( 16 ) ; state -> flags = ( int ) ( hold ) ; if ( ( state -> flags & 0xff ) != Z_DEFLATED ) { strm -> msg = ( char * ) \"unknown<S2SV_blank>compression<S2SV_blank>method\" ; state -> mode = BAD ; break ; } if ( state -> flags & 0xe000 ) { strm -> msg = ( char * ) \"unknown<S2SV_blank>header<S2SV_blank>flags<S2SV_blank>set\" ; state -> mode = BAD ; break ; } if ( state -> head != Z_NULL ) state -> head -> text = ( int ) ( ( hold >> 8 ) & 1 ) ; if ( ( state -> flags & 0x0200 ) && ( state -> wrap & 4 ) ) CRC2 ( state -> check , hold ) ; INITBITS ( ) ; state -> mode = TIME ; case TIME : NEEDBITS ( 32 ) ; if ( state -> head != Z_NULL ) state -> head -> time = hold ; if ( ( state -> flags & 0x0200 ) && ( state -> wrap & 4 ) ) CRC4 ( state -> check , hold ) ; INITBITS ( ) ; state -> mode = OS ; case OS : NEEDBITS ( 16 ) ; if ( state -> head != Z_NULL ) { state -> head -> xflags = ( int ) ( hold & 0xff ) ; state -> head -> os = ( int ) ( hold >> 8 ) ; } if ( ( state -> flags & 0x0200 ) && ( state -> wrap & 4 ) ) CRC2 ( state -> check , hold ) ; INITBITS ( ) ; state -> mode = EXLEN ; case EXLEN : if ( state -> flags & 0x0400 ) { NEEDBITS ( 16 ) ; state -> length = ( unsigned ) ( hold ) ; if ( state -> head != Z_NULL ) state -> head -> extra_len = ( unsigned ) hold ; if ( ( state -> flags & 0x0200 ) && ( state -> wrap & 4 ) ) CRC2 ( state -> check , hold ) ; INITBITS ( ) ; } else if ( state -> head != Z_NULL ) state -> head -> extra = Z_NULL ; state -> mode = EXTRA ; case EXTRA : if ( state -> flags & 0x0400 ) { copy = state -> length ; if ( copy > have ) copy = have ; if ( copy ) { <S2SV_StartBug> if ( state -> head != Z_NULL && <S2SV_EndBug> <S2SV_StartBug> state -> head -> extra != Z_NULL ) { <S2SV_EndBug> <S2SV_StartBug> len = state -> head -> extra_len - state -> length ; <S2SV_EndBug> zmemcpy ( state -> head -> extra + len , next , len + copy > state -> head -> extra_max ? state -> head -> extra_max - len : copy ) ; } if ( ( state -> flags & 0x0200 ) && ( state -> wrap & 4 ) ) state -> check = crc32 ( state -> check , next , copy ) ; have -= copy ; next += copy ; state -> length -= copy ; } if ( state -> length ) goto inf_leave ; } state -> length = 0 ; state -> mode = NAME ; case NAME : if ( state -> flags & 0x0800 ) { if ( have == 0 ) goto inf_leave ; copy = 0 ; do { len = ( unsigned ) ( next [ copy ++ ] ) ; if ( state -> head != Z_NULL && state -> head -> name != Z_NULL && state -> length < state -> head -> name_max ) state -> head -> name [ state -> length ++ ] = ( Bytef ) len ; } while ( len && copy < have ) ; if ( ( state -> flags & 0x0200 ) && ( state -> wrap & 4 ) ) state -> check = crc32 ( state -> check , next , copy ) ; have -= copy ; next += copy ; if ( len ) goto inf_leave ; } else if ( state -> head != Z_NULL ) state -> head -> name = Z_NULL ; state -> length = 0 ; state -> mode = COMMENT ; case COMMENT : if ( state -> flags & 0x1000 ) { if ( have == 0 ) goto inf_leave ; copy = 0 ; do { len = ( unsigned ) ( next [ copy ++ ] ) ; if ( state -> head != Z_NULL && state -> head -> comment != Z_NULL && state -> length < state -> head -> comm_max ) state -> head -> comment [ state -> length ++ ] = ( Bytef ) len ; } while ( len && copy < have ) ; if ( ( state -> flags & 0x0200 ) && ( state -> wrap & 4 ) ) state -> check = crc32 ( state -> check , next , copy ) ; have -= copy ; next += copy ; if ( len ) goto inf_leave ; } else if ( state -> head != Z_NULL ) state -> head -> comment = Z_NULL ; state -> mode = HCRC ; case HCRC : if ( state -> flags & 0x0200 ) { NEEDBITS ( 16 ) ; if ( ( state -> wrap & 4 ) && hold != ( state -> check & 0xffff ) ) { strm -> msg = ( char * ) \"header<S2SV_blank>crc<S2SV_blank>mismatch\" ; state -> mode = BAD ; break ; } INITBITS ( ) ; } if ( state -> head != Z_NULL ) { state -> head -> hcrc = ( int ) ( ( state -> flags >> 9 ) & 1 ) ; state -> head -> done = 1 ; } strm -> adler = state -> check = crc32 ( 0L , Z_NULL , 0 ) ; state -> mode = TYPE ; break ; # endif case DICTID : NEEDBITS ( 32 ) ; strm -> adler = state -> check = ZSWAP32 ( hold ) ; INITBITS ( ) ; state -> mode = DICT ; case DICT : if ( state -> havedict == 0 ) { RESTORE ( ) ; return Z_NEED_DICT ; } strm -> adler = state -> check = adler32 ( 0L , Z_NULL , 0 ) ; state -> mode = TYPE ; case TYPE : if ( flush == Z_BLOCK || flush == Z_TREES ) goto inf_leave ; case TYPEDO : if ( state -> last ) { BYTEBITS ( ) ; state -> mode = CHECK ; break ; } NEEDBITS ( 3 ) ; state -> last = BITS ( 1 ) ; DROPBITS ( 1 ) ; switch ( BITS ( 2 ) ) { case 0 : Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stored<S2SV_blank>block%s\\\\n\" , state -> last ? \"<S2SV_blank>(last)\" : \"\" ) ) ; state -> mode = STORED ; break ; case 1 : fixedtables ( state ) ; Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>fixed<S2SV_blank>codes<S2SV_blank>block%s\\\\n\" , state -> last ? \"<S2SV_blank>(last)\" : \"\" ) ) ; state -> mode = LEN_ ; if ( flush == Z_TREES ) { DROPBITS ( 2 ) ; goto inf_leave ; } break ; case 2 : Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>dynamic<S2SV_blank>codes<S2SV_blank>block%s\\\\n\" , state -> last ? \"<S2SV_blank>(last)\" : \"\" ) ) ; state -> mode = TABLE ; break ; case 3 : strm -> msg = ( char * ) \"invalid<S2SV_blank>block<S2SV_blank>type\" ; state -> mode = BAD ; } DROPBITS ( 2 ) ; break ; case STORED : BYTEBITS ( ) ; NEEDBITS ( 32 ) ; if ( ( hold & 0xffff ) != ( ( hold >> 16 ) ^ 0xffff ) ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>stored<S2SV_blank>block<S2SV_blank>lengths\" ; state -> mode = BAD ; break ; } state -> length = ( unsigned ) hold & 0xffff ; Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stored<S2SV_blank>length<S2SV_blank>%u\\\\n\" , state -> length ) ) ; INITBITS ( ) ; state -> mode = COPY_ ; if ( flush == Z_TREES ) goto inf_leave ; case COPY_ : state -> mode = COPY ; case COPY : copy = state -> length ; if ( copy ) { if ( copy > have ) copy = have ; if ( copy > left ) copy = left ; if ( copy == 0 ) goto inf_leave ; zmemcpy ( put , next , copy ) ; have -= copy ; next += copy ; left -= copy ; put += copy ; state -> length -= copy ; break ; } Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stored<S2SV_blank>end\\\\n\" ) ) ; state -> mode = TYPE ; break ; case TABLE : NEEDBITS ( 14 ) ; state -> nlen = BITS ( 5 ) + 257 ; DROPBITS ( 5 ) ; state -> ndist = BITS ( 5 ) + 1 ; DROPBITS ( 5 ) ; state -> ncode = BITS ( 4 ) + 4 ; DROPBITS ( 4 ) ; # ifndef PKZIP_BUG_WORKAROUND if ( state -> nlen > 286 || state -> ndist > 30 ) { strm -> msg = ( char * ) \"too<S2SV_blank>many<S2SV_blank>length<S2SV_blank>or<S2SV_blank>distance<S2SV_blank>symbols\" ; state -> mode = BAD ; break ; } # endif Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>table<S2SV_blank>sizes<S2SV_blank>ok\\\\n\" ) ) ; state -> have = 0 ; state -> mode = LENLENS ; case LENLENS : while ( state -> have < state -> ncode ) { NEEDBITS ( 3 ) ; state -> lens [ order [ state -> have ++ ] ] = ( unsigned short ) BITS ( 3 ) ; DROPBITS ( 3 ) ; } while ( state -> have < 19 ) state -> lens [ order [ state -> have ++ ] ] = 0 ; state -> next = state -> codes ; state -> lencode = ( const code FAR * ) ( state -> next ) ; state -> lenbits = 7 ; ret = inflate_table ( CODES , state -> lens , 19 , & ( state -> next ) , & ( state -> lenbits ) , state -> work ) ; if ( ret ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>code<S2SV_blank>lengths<S2SV_blank>set\" ; state -> mode = BAD ; break ; } Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>code<S2SV_blank>lengths<S2SV_blank>ok\\\\n\" ) ) ; state -> have = 0 ; state -> mode = CODELENS ; case CODELENS : while ( state -> have < state -> nlen + state -> ndist ) { for ( ; ; ) { here = state -> lencode [ BITS ( state -> lenbits ) ] ; if ( ( unsigned ) ( here . bits ) <= bits ) break ; PULLBYTE ( ) ; } if ( here . val < 16 ) { DROPBITS ( here . bits ) ; state -> lens [ state -> have ++ ] = here . val ; } else { if ( here . val == 16 ) { NEEDBITS ( here . bits + 2 ) ; DROPBITS ( here . bits ) ; if ( state -> have == 0 ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>repeat\" ; state -> mode = BAD ; break ; } len = state -> lens [ state -> have - 1 ] ; copy = 3 + BITS ( 2 ) ; DROPBITS ( 2 ) ; } else if ( here . val == 17 ) { NEEDBITS ( here . bits + 3 ) ; DROPBITS ( here . bits ) ; len = 0 ; copy = 3 + BITS ( 3 ) ; DROPBITS ( 3 ) ; } else { NEEDBITS ( here . bits + 7 ) ; DROPBITS ( here . bits ) ; len = 0 ; copy = 11 + BITS ( 7 ) ; DROPBITS ( 7 ) ; } if ( state -> have + copy > state -> nlen + state -> ndist ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>repeat\" ; state -> mode = BAD ; break ; } while ( copy -- ) state -> lens [ state -> have ++ ] = ( unsigned short ) len ; } } if ( state -> mode == BAD ) break ; if ( state -> lens [ 256 ] == 0 ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>code<S2SV_blank>--<S2SV_blank>missing<S2SV_blank>end-of-block\" ; state -> mode = BAD ; break ; } state -> next = state -> codes ; state -> lencode = ( const code FAR * ) ( state -> next ) ; state -> lenbits = 9 ; ret = inflate_table ( LENS , state -> lens , state -> nlen , & ( state -> next ) , & ( state -> lenbits ) , state -> work ) ; if ( ret ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>literal/lengths<S2SV_blank>set\" ; state -> mode = BAD ; break ; } state -> distcode = ( const code FAR * ) ( state -> next ) ; state -> distbits = 6 ; ret = inflate_table ( DISTS , state -> lens + state -> nlen , state -> ndist , & ( state -> next ) , & ( state -> distbits ) , state -> work ) ; if ( ret ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>distances<S2SV_blank>set\" ; state -> mode = BAD ; break ; } Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>codes<S2SV_blank>ok\\\\n\" ) ) ; state -> mode = LEN_ ; if ( flush == Z_TREES ) goto inf_leave ; case LEN_ : state -> mode = LEN ; case LEN : if ( have >= 6 && left >= 258 ) { RESTORE ( ) ; inflate_fast ( strm , out ) ; LOAD ( ) ; if ( state -> mode == TYPE ) state -> back = - 1 ; break ; } state -> back = 0 ; for ( ; ; ) { here = state -> lencode [ BITS ( state -> lenbits ) ] ; if ( ( unsigned ) ( here . bits ) <= bits ) break ; PULLBYTE ( ) ; } if ( here . op && ( here . op & 0xf0 ) == 0 ) { last = here ; for ( ; ; ) { here = state -> lencode [ last . val + ( BITS ( last . bits + last . op ) >> last . bits ) ] ; if ( ( unsigned ) ( last . bits + here . bits ) <= bits ) break ; PULLBYTE ( ) ; } DROPBITS ( last . bits ) ; state -> back += last . bits ; } DROPBITS ( here . bits ) ; state -> back += here . bits ; state -> length = ( unsigned ) here . val ; if ( ( int ) ( here . op ) == 0 ) { Tracevv ( ( stderr , here . val >= 0x20 && here . val < 0x7f ? \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>literal<S2SV_blank>\\'%c\\'\\\\n\" : \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>literal<S2SV_blank>0x%02x\\\\n\" , here . val ) ) ; state -> mode = LIT ; break ; } if ( here . op & 32 ) { Tracevv ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>block\\\\n\" ) ) ; state -> back = - 1 ; state -> mode = TYPE ; break ; } if ( here . op & 64 ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>literal/length<S2SV_blank>code\" ; state -> mode = BAD ; break ; } state -> extra = ( unsigned ) ( here . op ) & 15 ; state -> mode = LENEXT ; case LENEXT : if ( state -> extra ) { NEEDBITS ( state -> extra ) ; state -> length += BITS ( state -> extra ) ; DROPBITS ( state -> extra ) ; state -> back += state -> extra ; } Tracevv ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>length<S2SV_blank>%u\\\\n\" , state -> length ) ) ; state -> was = state -> length ; state -> mode = DIST ; case DIST : for ( ; ; ) { here = state -> distcode [ BITS ( state -> distbits ) ] ; if ( ( unsigned ) ( here . bits ) <= bits ) break ; PULLBYTE ( ) ; } if ( ( here . op & 0xf0 ) == 0 ) { last = here ; for ( ; ; ) { here = state -> distcode [ last . val + ( BITS ( last . bits + last . op ) >> last . bits ) ] ; if ( ( unsigned ) ( last . bits + here . bits ) <= bits ) break ; PULLBYTE ( ) ; } DROPBITS ( last . bits ) ; state -> back += last . bits ; } DROPBITS ( here . bits ) ; state -> back += here . bits ; if ( here . op & 64 ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>distance<S2SV_blank>code\" ; state -> mode = BAD ; break ; } state -> offset = ( unsigned ) here . val ; state -> extra = ( unsigned ) ( here . op ) & 15 ; state -> mode = DISTEXT ; case DISTEXT : if ( state -> extra ) { NEEDBITS ( state -> extra ) ; state -> offset += BITS ( state -> extra ) ; DROPBITS ( state -> extra ) ; state -> back += state -> extra ; } # ifdef INFLATE_STRICT if ( state -> offset > state -> dmax ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>distance<S2SV_blank>too<S2SV_blank>far<S2SV_blank>back\" ; state -> mode = BAD ; break ; } # endif Tracevv ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>distance<S2SV_blank>%u\\\\n\" , state -> offset ) ) ; state -> mode = MATCH ; case MATCH : if ( left == 0 ) goto inf_leave ; copy = out - left ; if ( state -> offset > copy ) { copy = state -> offset - copy ; if ( copy > state -> whave ) { if ( state -> sane ) { strm -> msg = ( char * ) \"invalid<S2SV_blank>distance<S2SV_blank>too<S2SV_blank>far<S2SV_blank>back\" ; state -> mode = BAD ; break ; } # ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR Trace ( ( stderr , \"inflate.c<S2SV_blank>too<S2SV_blank>far\\\\n\" ) ) ; copy -= state -> whave ; if ( copy > state -> length ) copy = state -> length ; if ( copy > left ) copy = left ; left -= copy ; state -> length -= copy ; do { * put ++ = 0 ; } while ( -- copy ) ; if ( state -> length == 0 ) state -> mode = LEN ; break ; # endif } if ( copy > state -> wnext ) { copy -= state -> wnext ; from = state -> window + ( state -> wsize - copy ) ; } else from = state -> window + ( state -> wnext - copy ) ; if ( copy > state -> length ) copy = state -> length ; } else { from = put - state -> offset ; copy = state -> length ; } if ( copy > left ) copy = left ; left -= copy ; state -> length -= copy ; do { * put ++ = * from ++ ; } while ( -- copy ) ; if ( state -> length == 0 ) state -> mode = LEN ; break ; case LIT : if ( left == 0 ) goto inf_leave ; * put ++ = ( unsigned char ) ( state -> length ) ; left -- ; state -> mode = LEN ; break ; case CHECK : if ( state -> wrap ) { NEEDBITS ( 32 ) ; out -= left ; strm -> total_out += out ; state -> total += out ; if ( ( state -> wrap & 4 ) && out ) strm -> adler = state -> check = UPDATE_CHECK ( state -> check , put - out , out ) ; out = left ; if ( ( state -> wrap & 4 ) && ( # ifdef GUNZIP state -> flags ? hold : # endif ZSWAP32 ( hold ) ) != state -> check ) { strm -> msg = ( char * ) \"incorrect<S2SV_blank>data<S2SV_blank>check\" ; state -> mode = BAD ; break ; } INITBITS ( ) ; Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank>check<S2SV_blank>matches<S2SV_blank>trailer\\\\n\" ) ) ; } # ifdef GUNZIP state -> mode = LENGTH ; case LENGTH : if ( state -> wrap && state -> flags ) { NEEDBITS ( 32 ) ; if ( ( state -> wrap & 4 ) && hold != ( state -> total & 0xffffffff ) ) { strm -> msg = ( char * ) \"incorrect<S2SV_blank>length<S2SV_blank>check\" ; state -> mode = BAD ; break ; } INITBITS ( ) ; Tracev ( ( stderr , \"inflate:<S2SV_blank><S2SV_blank><S2SV_blank>length<S2SV_blank>matches<S2SV_blank>trailer\\\\n\" ) ) ; } # endif state -> mode = DONE ; case DONE : ret = Z_STREAM_END ; goto inf_leave ; case BAD : ret = Z_DATA_ERROR ; goto inf_leave ; case MEM : return Z_MEM_ERROR ; case SYNC : default : return Z_STREAM_ERROR ; } inf_leave : RESTORE ( ) ; if ( state -> wsize || ( out != strm -> avail_out && state -> mode < BAD && ( state -> mode < CHECK || flush != Z_FINISH ) ) ) if ( updatewindow ( strm , strm -> next_out , out - strm -> avail_out ) ) { state -> mode = MEM ; return Z_MEM_ERROR ; } in -= strm -> avail_in ; out -= strm -> avail_out ; strm -> total_in += in ; strm -> total_out += out ; state -> total += out ; if ( ( state -> wrap & 4 ) && out ) strm -> adler = state -> check = UPDATE_CHECK ( state -> check , strm -> next_out - out , out ) ; strm -> data_type = ( int ) state -> bits + ( state -> last ? 64 : 0 ) + ( state -> mode == TYPE ? 128 : 0 ) + ( state -> mode == LEN_ || state -> mode == COPY_ ? 256 : 0 ) ; if ( ( ( in == 0 && out == 0 ) || flush == Z_FINISH ) && ret == Z_OK ) ret = Z_BUF_ERROR ; return ret ; }", "target": "<S2SV_ModStart> copy ) { len = state -> head -> extra_len - state -> length ; <S2SV_ModStart> extra != Z_NULL && len < <S2SV_ModEnd> state -> head <S2SV_ModStart> -> head -> extra_max ) { <S2SV_ModEnd> zmemcpy ( state"}
{"source": "CWE-122 n_start_visual_mode ( int c ) { # ifdef FEAT_CONCEAL int cursor_line_was_concealed = curwin -> w_p_cole > 0 && conceal_cursor_line ( curwin ) ; # endif VIsual_mode = c ; VIsual_active = TRUE ; <S2SV_StartBug> VIsual_reselect = TRUE ; <S2SV_EndBug> trigger_modechanged ( ) ; if ( c == Ctrl_V && ( get_ve_flags ( ) & VE_BLOCK ) && gchar_cursor ( ) == TAB ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } VIsual = curwin -> w_cursor ; # ifdef FEAT_FOLDING foldAdjustVisual ( ) ; # endif <S2SV_StartBug> <S2SV_EndBug> setmouse ( ) ; # ifdef FEAT_CONCEAL conceal_check_cursor_line ( cursor_line_was_concealed ) ; # endif if ( p_smd && msg_silent == 0 ) redraw_cmdline = TRUE ; # ifdef FEAT_CLIPBOARD clip_star . vmode = NUL ; # endif if ( curwin -> w_redr_type < INVERTED ) { curwin -> w_old_cursor_lnum = curwin -> w_cursor . lnum ; curwin -> w_old_visual_lnum = curwin -> w_cursor . lnum ; } }", "target": "<S2SV_ModStart> VIsual_reselect = TRUE <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; # endif trigger_modechanged ( ) ;"}
{"source": "CWE-189 static char * getsistring ( FILE * f , uint32_t ptr , uint32_t len ) { char * name ; uint32_t i ; if ( ! len ) return NULL ; if ( len > 400 ) len = 400 ; <S2SV_StartBug> name = cli_malloc ( len ) ; <S2SV_EndBug> if ( ! name ) { cli_dbgmsg ( \"SIS:<S2SV_blank>OOM\\\\n\" ) ; return NULL ; } fseek ( f , ptr , SEEK_SET ) ; if ( fread ( name , len , 1 , f ) != 1 ) { cli_dbgmsg ( \"SIS:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>string\\\\n\" ) ; free ( name ) ; return NULL ; } for ( i = 0 ; i < len ; i += 2 ) name [ i / 2 ] = name [ i ] ; name [ i / 2 ] = '\\\\0' ; return name ; }", "target": "<S2SV_ModStart> cli_malloc ( len + 1"}
{"source": "CWE-416 reg_match_visual ( void ) { pos_T top , bot ; linenr_T lnum ; colnr_T col ; win_T * wp = rex . reg_win == NULL ? curwin : rex . reg_win ; int mode ; colnr_T start , end ; colnr_T start2 , end2 ; colnr_T cols ; colnr_T curswant ; if ( rex . reg_buf != curbuf || VIsual . lnum == 0 ) return FALSE ; if ( VIsual_active ) { if ( LT_POS ( VIsual , wp -> w_cursor ) ) { top = VIsual ; bot = wp -> w_cursor ; } else { top = wp -> w_cursor ; bot = VIsual ; } mode = VIsual_mode ; curswant = wp -> w_curswant ; } else { if ( LT_POS ( curbuf -> b_visual . vi_start , curbuf -> b_visual . vi_end ) ) { top = curbuf -> b_visual . vi_start ; bot = curbuf -> b_visual . vi_end ; } else { top = curbuf -> b_visual . vi_end ; bot = curbuf -> b_visual . vi_start ; } mode = curbuf -> b_visual . vi_mode ; curswant = curbuf -> b_visual . vi_curswant ; } lnum = rex . lnum + rex . reg_firstlnum ; if ( lnum < top . lnum || lnum > bot . lnum ) return FALSE ; <S2SV_StartBug> if ( mode == 'v' ) <S2SV_EndBug> { <S2SV_StartBug> col = ( colnr_T ) ( rex . input - rex . line ) ; <S2SV_EndBug> if ( ( lnum == top . lnum && col < top . col ) || ( lnum == bot . lnum && col >= bot . col + ( * p_sel != 'e' ) ) ) return FALSE ; } else if ( mode == Ctrl_V ) { getvvcol ( wp , & top , & start , NULL , & end ) ; getvvcol ( wp , & bot , & start2 , NULL , & end2 ) ; if ( start2 < start ) start = start2 ; if ( end2 > end ) end = end2 ; if ( top . col == MAXCOL || bot . col == MAXCOL || curswant == MAXCOL ) end = MAXCOL ; <S2SV_StartBug> cols = win_linetabsize ( wp , rex . line , ( colnr_T ) ( rex . input - rex . line ) ) ; <S2SV_EndBug> if ( cols < start || cols > end - ( * p_sel == 'e' ) ) return FALSE ; } return TRUE ; }", "target": "<S2SV_ModStart> return FALSE ; <S2SV_ModEnd> col = ( <S2SV_ModStart> line ) ; if ( mode == 'v' ) { <S2SV_ModStart> = MAXCOL ; rex . line = reg_getline ( rex . lnum ) ; rex . input = rex . line + col ; <S2SV_ModStart> . line , col <S2SV_ModEnd> ) ; if"}
{"source": "CWE-119 glob ( const char * pattern , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) { const char * filename ; char * dirname = NULL ; size_t dirlen ; int status ; size_t oldcount ; int meta ; int dirname_modified ; int malloc_dirname = 0 ; glob_t dirs ; int retval = 0 ; size_t alloca_used = 0 ; if ( pattern == NULL || pglob == NULL || ( flags & ~ __GLOB_FLAGS ) != 0 ) { __set_errno ( EINVAL ) ; return - 1 ; } if ( pattern [ 0 ] && pattern [ strlen ( pattern ) - 1 ] == '/' ) flags |= GLOB_ONLYDIR ; if ( ! ( flags & GLOB_DOOFFS ) ) pglob -> gl_offs = 0 ; if ( ! ( flags & GLOB_APPEND ) ) { pglob -> gl_pathc = 0 ; if ( ! ( flags & GLOB_DOOFFS ) ) pglob -> gl_pathv = NULL ; else { size_t i ; if ( pglob -> gl_offs >= ~ ( ( size_t ) 0 ) / sizeof ( char * ) ) return GLOB_NOSPACE ; pglob -> gl_pathv = ( char * * ) malloc ( ( pglob -> gl_offs + 1 ) * sizeof ( char * ) ) ; if ( pglob -> gl_pathv == NULL ) return GLOB_NOSPACE ; for ( i = 0 ; i <= pglob -> gl_offs ; ++ i ) pglob -> gl_pathv [ i ] = NULL ; } } if ( flags & GLOB_BRACE ) { const char * begin ; if ( flags & GLOB_NOESCAPE ) begin = strchr ( pattern , '{' ) ; else { begin = pattern ; while ( 1 ) { if ( * begin == '\\\\0' ) { begin = NULL ; break ; } if ( * begin == '\\\\\\\\' && begin [ 1 ] != '\\\\0' ) ++ begin ; else if ( * begin == '{' ) break ; ++ begin ; } } if ( begin != NULL ) { size_t firstc ; char * alt_start ; const char * p ; const char * next ; const char * rest ; size_t rest_len ; char * onealt ; size_t pattern_len = strlen ( pattern ) - 1 ; int alloca_onealt = glob_use_alloca ( alloca_used , pattern_len ) ; if ( alloca_onealt ) onealt = alloca_account ( pattern_len , alloca_used ) ; else { onealt = malloc ( pattern_len ) ; if ( onealt == NULL ) return GLOB_NOSPACE ; } alt_start = mempcpy ( onealt , pattern , begin - pattern ) ; next = next_brace_sub ( begin + 1 , flags ) ; if ( next == NULL ) { illegal_brace : if ( __glibc_unlikely ( ! alloca_onealt ) ) free ( onealt ) ; flags &= ~ GLOB_BRACE ; goto no_brace ; } rest = next ; while ( * rest != '}' ) { rest = next_brace_sub ( rest + 1 , flags ) ; if ( rest == NULL ) goto illegal_brace ; } rest_len = strlen ( ++ rest ) + 1 ; firstc = pglob -> gl_pathc ; p = begin + 1 ; while ( 1 ) { int result ; mempcpy ( mempcpy ( alt_start , p , next - p ) , rest , rest_len ) ; result = glob ( onealt , ( ( flags & ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) | GLOB_APPEND ) , errfunc , pglob ) ; if ( result && result != GLOB_NOMATCH ) { if ( __glibc_unlikely ( ! alloca_onealt ) ) free ( onealt ) ; if ( ! ( flags & GLOB_APPEND ) ) { globfree ( pglob ) ; pglob -> gl_pathc = 0 ; } return result ; } if ( * next == '}' ) break ; p = next + 1 ; next = next_brace_sub ( p , flags ) ; assert ( next != NULL ) ; } if ( __glibc_unlikely ( ! alloca_onealt ) ) free ( onealt ) ; if ( pglob -> gl_pathc != firstc ) return 0 ; else if ( ! ( flags & ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) ) return GLOB_NOMATCH ; } } no_brace : oldcount = pglob -> gl_pathc + pglob -> gl_offs ; filename = strrchr ( pattern , '/' ) ; # if defined __MSDOS__ || defined WINDOWS32 if ( filename == NULL ) filename = strchr ( pattern , ':' ) ; # endif dirname_modified = 0 ; if ( filename == NULL ) { if ( ( flags & ( GLOB_TILDE | GLOB_TILDE_CHECK ) ) && pattern [ 0 ] == '~' ) { dirname = ( char * ) pattern ; dirlen = strlen ( pattern ) ; filename = NULL ; } else { if ( __glibc_unlikely ( pattern [ 0 ] == '\\\\0' ) ) { dirs . gl_pathv = NULL ; goto no_matches ; } filename = pattern ; dirname = ( char * ) \".\" ; dirlen = 0 ; } } else if ( filename == pattern || ( filename == pattern + 1 && pattern [ 0 ] == '\\\\\\\\' && ( flags & GLOB_NOESCAPE ) == 0 ) ) { dirname = ( char * ) \"/\" ; dirlen = 1 ; ++ filename ; } else { char * newp ; dirlen = filename - pattern ; # if defined __MSDOS__ || defined WINDOWS32 if ( * filename == ':' || ( filename > pattern + 1 && filename [ - 1 ] == ':' ) ) { char * drive_spec ; ++ dirlen ; drive_spec = __alloca ( dirlen + 1 ) ; * ( ( char * ) mempcpy ( drive_spec , pattern , dirlen ) ) = '\\\\0' ; if ( __glob_pattern_p ( drive_spec , ! ( flags & GLOB_NOESCAPE ) ) ) return GLOB_NOMATCH ; } # endif if ( glob_use_alloca ( alloca_used , dirlen + 1 ) ) newp = alloca_account ( dirlen + 1 , alloca_used ) ; else { newp = malloc ( dirlen + 1 ) ; if ( newp == NULL ) return GLOB_NOSPACE ; malloc_dirname = 1 ; } * ( ( char * ) mempcpy ( newp , pattern , dirlen ) ) = '\\\\0' ; dirname = newp ; ++ filename ; # if defined __MSDOS__ || defined WINDOWS32 bool drive_root = ( dirlen > 1 && ( dirname [ dirlen - 1 ] == ':' || ( dirlen > 2 && dirname [ dirlen - 2 ] == ':' && dirname [ dirlen - 1 ] == '/' ) ) ) ; # else bool drive_root = false ; # endif if ( filename [ 0 ] == '\\\\0' && dirlen > 1 && ! drive_root ) { int orig_flags = flags ; if ( ! ( flags & GLOB_NOESCAPE ) && dirname [ dirlen - 1 ] == '\\\\\\\\' ) { char * p = ( char * ) & dirname [ dirlen - 1 ] ; while ( p > dirname && p [ - 1 ] == '\\\\\\\\' ) -- p ; if ( ( & dirname [ dirlen ] - p ) & 1 ) { * ( char * ) & dirname [ -- dirlen ] = '\\\\0' ; flags &= ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ; } } int val = glob ( dirname , flags | GLOB_MARK , errfunc , pglob ) ; if ( val == 0 ) pglob -> gl_flags = ( ( pglob -> gl_flags & ~ GLOB_MARK ) | ( flags & GLOB_MARK ) ) ; else if ( val == GLOB_NOMATCH && flags != orig_flags ) { dirs . gl_pathv = NULL ; flags = orig_flags ; oldcount = pglob -> gl_pathc + pglob -> gl_offs ; goto no_matches ; } retval = val ; goto out ; } } if ( ( flags & ( GLOB_TILDE | GLOB_TILDE_CHECK ) ) && dirname [ 0 ] == '~' ) { if ( dirname [ 1 ] == '\\\\0' || dirname [ 1 ] == '/' || ( ! ( flags & GLOB_NOESCAPE ) && dirname [ 1 ] == '\\\\\\\\' && ( dirname [ 2 ] == '\\\\0' || dirname [ 2 ] == '/' ) ) ) { char * home_dir = getenv ( \"HOME\" ) ; int malloc_home_dir = 0 ; if ( home_dir == NULL || home_dir [ 0 ] == '\\\\0' ) { # ifdef WINDOWS32 const char * home_drive = getenv ( \"HOMEDRIVE\" ) ; const char * home_path = getenv ( \"HOMEPATH\" ) ; if ( home_drive != NULL && home_path != NULL ) { size_t home_drive_len = strlen ( home_drive ) ; size_t home_path_len = strlen ( home_path ) ; char * mem = alloca ( home_drive_len + home_path_len + 1 ) ; memcpy ( mem , home_drive , home_drive_len ) ; memcpy ( mem + home_drive_len , home_path , home_path_len + 1 ) ; home_dir = mem ; } else home_dir = \"c:/users/default\" ; # else int err ; struct passwd * p ; struct passwd pwbuf ; struct scratch_buffer s ; scratch_buffer_init ( & s ) ; while ( true ) { p = NULL ; err = __getlogin_r ( s . data , s . length ) ; if ( err == 0 ) { # if defined HAVE_GETPWNAM_R || defined _LIBC size_t ssize = strlen ( s . data ) + 1 ; err = getpwnam_r ( s . data , & pwbuf , s . data + ssize , s . length - ssize , & p ) ; # else p = getpwnam ( s . data ) ; if ( p == NULL ) err = errno ; # endif } if ( err != ERANGE ) break ; if ( ! scratch_buffer_grow ( & s ) ) { retval = GLOB_NOSPACE ; goto out ; } } if ( err == 0 ) { home_dir = strdup ( p -> pw_dir ) ; malloc_home_dir = 1 ; } scratch_buffer_free ( & s ) ; if ( err == 0 && home_dir == NULL ) { retval = GLOB_NOSPACE ; goto out ; } # endif } if ( home_dir == NULL || home_dir [ 0 ] == '\\\\0' ) { if ( __glibc_unlikely ( malloc_home_dir ) ) free ( home_dir ) ; if ( flags & GLOB_TILDE_CHECK ) { retval = GLOB_NOMATCH ; goto out ; } else { home_dir = ( char * ) \"~\" ; malloc_home_dir = 0 ; } } if ( dirname [ 1 ] == '\\\\0' ) { if ( __glibc_unlikely ( malloc_dirname ) ) free ( dirname ) ; dirname = home_dir ; dirlen = strlen ( dirname ) ; malloc_dirname = malloc_home_dir ; } else { char * newp ; size_t home_len = strlen ( home_dir ) ; int use_alloca = glob_use_alloca ( alloca_used , home_len + dirlen ) ; if ( use_alloca ) newp = alloca_account ( home_len + dirlen , alloca_used ) ; else { newp = malloc ( home_len + dirlen ) ; if ( newp == NULL ) { if ( __glibc_unlikely ( malloc_home_dir ) ) free ( home_dir ) ; retval = GLOB_NOSPACE ; goto out ; } } mempcpy ( mempcpy ( newp , home_dir , home_len ) , & dirname [ 1 ] , dirlen ) ; if ( __glibc_unlikely ( malloc_dirname ) ) free ( dirname ) ; dirname = newp ; dirlen += home_len - 1 ; malloc_dirname = ! use_alloca ; if ( __glibc_unlikely ( malloc_home_dir ) ) free ( home_dir ) ; } dirname_modified = 1 ; } else { # ifndef WINDOWS32 char * end_name = strchr ( dirname , '/' ) ; char * user_name ; int malloc_user_name = 0 ; char * unescape = NULL ; if ( ! ( flags & GLOB_NOESCAPE ) ) { if ( end_name == NULL ) { unescape = strchr ( dirname , '\\\\\\\\' ) ; if ( unescape ) end_name = strchr ( unescape , '\\\\0' ) ; } else unescape = memchr ( dirname , '\\\\\\\\' , end_name - dirname ) ; } if ( end_name == NULL ) user_name = dirname + 1 ; else { char * newp ; if ( glob_use_alloca ( alloca_used , end_name - dirname ) ) newp = alloca_account ( end_name - dirname , alloca_used ) ; else { newp = malloc ( end_name - dirname ) ; if ( newp == NULL ) { retval = GLOB_NOSPACE ; goto out ; } malloc_user_name = 1 ; } if ( unescape != NULL ) { char * p = mempcpy ( newp , dirname + 1 , unescape - dirname - 1 ) ; char * q = unescape ; while ( * q != '\\\\0' ) { if ( * q == '\\\\\\\\' ) { if ( q [ 1 ] == '\\\\0' ) { if ( filename == NULL ) * p ++ = '\\\\\\\\' ; break ; } ++ q ; } * p ++ = * q ++ ; } * p = '\\\\0' ; } else <S2SV_StartBug> * ( ( char * ) mempcpy ( newp , dirname + 1 , end_name - dirname ) ) <S2SV_EndBug> = '\\\\0' ; user_name = newp ; } { struct passwd * p ; struct scratch_buffer pwtmpbuf ; scratch_buffer_init ( & pwtmpbuf ) ; # if defined HAVE_GETPWNAM_R || defined _LIBC struct passwd pwbuf ; while ( getpwnam_r ( user_name , & pwbuf , pwtmpbuf . data , pwtmpbuf . length , & p ) == ERANGE ) { if ( ! scratch_buffer_grow ( & pwtmpbuf ) ) { retval = GLOB_NOSPACE ; goto out ; } } # else p = getpwnam ( user_name ) ; # endif if ( __glibc_unlikely ( malloc_user_name ) ) free ( user_name ) ; if ( p != NULL ) { size_t home_len = strlen ( p -> pw_dir ) ; size_t rest_len = end_name == NULL ? 0 : strlen ( end_name ) ; char * d ; if ( __glibc_unlikely ( malloc_dirname ) ) free ( dirname ) ; malloc_dirname = 0 ; if ( glob_use_alloca ( alloca_used , home_len + rest_len + 1 ) ) dirname = alloca_account ( home_len + rest_len + 1 , alloca_used ) ; else { dirname = malloc ( home_len + rest_len + 1 ) ; if ( dirname == NULL ) { scratch_buffer_free ( & pwtmpbuf ) ; retval = GLOB_NOSPACE ; goto out ; } malloc_dirname = 1 ; } d = mempcpy ( dirname , p -> pw_dir , home_len ) ; if ( end_name != NULL ) d = mempcpy ( d , end_name , rest_len ) ; * d = '\\\\0' ; dirlen = home_len + rest_len ; dirname_modified = 1 ; } else { if ( flags & GLOB_TILDE_CHECK ) { retval = GLOB_NOMATCH ; goto out ; } } scratch_buffer_free ( & pwtmpbuf ) ; } # endif } } if ( filename == NULL ) { size_t newcount = pglob -> gl_pathc + pglob -> gl_offs ; char * * new_gl_pathv ; if ( newcount > SIZE_MAX / sizeof ( char * ) - 2 ) { nospace : free ( pglob -> gl_pathv ) ; pglob -> gl_pathv = NULL ; pglob -> gl_pathc = 0 ; retval = GLOB_NOSPACE ; goto out ; } new_gl_pathv = realloc ( pglob -> gl_pathv , ( newcount + 2 ) * sizeof ( char * ) ) ; if ( new_gl_pathv == NULL ) goto nospace ; pglob -> gl_pathv = new_gl_pathv ; if ( flags & GLOB_MARK && is_dir ( dirname , flags , pglob ) ) { char * p ; pglob -> gl_pathv [ newcount ] = malloc ( dirlen + 2 ) ; if ( pglob -> gl_pathv [ newcount ] == NULL ) goto nospace ; p = mempcpy ( pglob -> gl_pathv [ newcount ] , dirname , dirlen ) ; p [ 0 ] = '/' ; p [ 1 ] = '\\\\0' ; if ( __glibc_unlikely ( malloc_dirname ) ) free ( dirname ) ; } else { if ( __glibc_unlikely ( malloc_dirname ) ) pglob -> gl_pathv [ newcount ] = dirname ; else { pglob -> gl_pathv [ newcount ] = strdup ( dirname ) ; if ( pglob -> gl_pathv [ newcount ] == NULL ) goto nospace ; } } pglob -> gl_pathv [ ++ newcount ] = NULL ; ++ pglob -> gl_pathc ; pglob -> gl_flags = flags ; return 0 ; } meta = __glob_pattern_type ( dirname , ! ( flags & GLOB_NOESCAPE ) ) ; if ( meta & ( GLOBPAT_SPECIAL | GLOBPAT_BRACKET ) ) { size_t i ; if ( ! ( flags & GLOB_NOESCAPE ) && dirlen > 0 && dirname [ dirlen - 1 ] == '\\\\\\\\' ) { char * p = ( char * ) & dirname [ dirlen - 1 ] ; while ( p > dirname && p [ - 1 ] == '\\\\\\\\' ) -- p ; if ( ( & dirname [ dirlen ] - p ) & 1 ) * ( char * ) & dirname [ -- dirlen ] = '\\\\0' ; } if ( __glibc_unlikely ( ( flags & GLOB_ALTDIRFUNC ) != 0 ) ) { dirs . gl_opendir = pglob -> gl_opendir ; dirs . gl_readdir = pglob -> gl_readdir ; dirs . gl_closedir = pglob -> gl_closedir ; dirs . gl_stat = pglob -> gl_stat ; dirs . gl_lstat = pglob -> gl_lstat ; } status = glob ( dirname , ( ( flags & ( GLOB_ERR | GLOB_NOESCAPE | GLOB_ALTDIRFUNC ) ) | GLOB_NOSORT | GLOB_ONLYDIR ) , errfunc , & dirs ) ; if ( status != 0 ) { if ( ( flags & GLOB_NOCHECK ) == 0 || status != GLOB_NOMATCH ) { retval = status ; goto out ; } goto no_matches ; } for ( i = 0 ; i < dirs . gl_pathc ; ++ i ) { size_t old_pathc ; old_pathc = pglob -> gl_pathc ; status = glob_in_dir ( filename , dirs . gl_pathv [ i ] , ( ( flags | GLOB_APPEND ) & ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) , errfunc , pglob , alloca_used ) ; if ( status == GLOB_NOMATCH ) continue ; if ( status != 0 ) { globfree ( & dirs ) ; globfree ( pglob ) ; pglob -> gl_pathc = 0 ; retval = status ; goto out ; } if ( prefix_array ( dirs . gl_pathv [ i ] , & pglob -> gl_pathv [ old_pathc + pglob -> gl_offs ] , pglob -> gl_pathc - old_pathc ) ) { globfree ( & dirs ) ; globfree ( pglob ) ; pglob -> gl_pathc = 0 ; retval = GLOB_NOSPACE ; goto out ; } } flags |= GLOB_MAGCHAR ; if ( pglob -> gl_pathc + pglob -> gl_offs == oldcount ) { no_matches : if ( flags & GLOB_NOCHECK ) { size_t newcount = pglob -> gl_pathc + pglob -> gl_offs ; char * * new_gl_pathv ; if ( newcount > SIZE_MAX / sizeof ( char * ) - 2 ) { nospace2 : globfree ( & dirs ) ; retval = GLOB_NOSPACE ; goto out ; } new_gl_pathv = realloc ( pglob -> gl_pathv , ( newcount + 2 ) * sizeof ( char * ) ) ; if ( new_gl_pathv == NULL ) goto nospace2 ; pglob -> gl_pathv = new_gl_pathv ; pglob -> gl_pathv [ newcount ] = strdup ( pattern ) ; if ( pglob -> gl_pathv [ newcount ] == NULL ) { globfree ( & dirs ) ; globfree ( pglob ) ; pglob -> gl_pathc = 0 ; retval = GLOB_NOSPACE ; goto out ; } ++ pglob -> gl_pathc ; ++ newcount ; pglob -> gl_pathv [ newcount ] = NULL ; pglob -> gl_flags = flags ; } else { globfree ( & dirs ) ; retval = GLOB_NOMATCH ; goto out ; } } globfree ( & dirs ) ; } else { size_t old_pathc = pglob -> gl_pathc ; int orig_flags = flags ; if ( meta & GLOBPAT_BACKSLASH ) { char * p = strchr ( dirname , '\\\\\\\\' ) , * q ; q = p ; do { if ( * p == '\\\\\\\\' ) { * q = * ++ p ; -- dirlen ; } else * q = * p ; ++ q ; } while ( * p ++ != '\\\\0' ) ; dirname_modified = 1 ; } if ( dirname_modified ) flags &= ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ; status = glob_in_dir ( filename , dirname , flags , errfunc , pglob , alloca_used ) ; if ( status != 0 ) { if ( status == GLOB_NOMATCH && flags != orig_flags && pglob -> gl_pathc + pglob -> gl_offs == oldcount ) { dirs . gl_pathv = NULL ; flags = orig_flags ; goto no_matches ; } retval = status ; goto out ; } if ( dirlen > 0 ) { if ( prefix_array ( dirname , & pglob -> gl_pathv [ old_pathc + pglob -> gl_offs ] , pglob -> gl_pathc - old_pathc ) ) { globfree ( pglob ) ; pglob -> gl_pathc = 0 ; retval = GLOB_NOSPACE ; goto out ; } } } if ( flags & GLOB_MARK ) { size_t i ; for ( i = oldcount ; i < pglob -> gl_pathc + pglob -> gl_offs ; ++ i ) if ( is_dir ( pglob -> gl_pathv [ i ] , flags , pglob ) ) { size_t len = strlen ( pglob -> gl_pathv [ i ] ) + 2 ; char * new = realloc ( pglob -> gl_pathv [ i ] , len ) ; if ( new == NULL ) { globfree ( pglob ) ; pglob -> gl_pathc = 0 ; retval = GLOB_NOSPACE ; goto out ; } strcpy ( & new [ len - 2 ] , \"/\" ) ; pglob -> gl_pathv [ i ] = new ; } } if ( ! ( flags & GLOB_NOSORT ) ) { qsort ( & pglob -> gl_pathv [ oldcount ] , pglob -> gl_pathc + pglob -> gl_offs - oldcount , sizeof ( char * ) , collated_compare ) ; } out : if ( __glibc_unlikely ( malloc_dirname ) ) free ( dirname ) ; return retval ; }", "target": "<S2SV_ModStart> end_name - dirname - 1"}
{"source": "CWE-120 int st21nfca_connectivity_event_received ( struct nfc_hci_dev * hdev , u8 host , u8 event , struct sk_buff * skb ) { int r = 0 ; struct device * dev = & hdev -> ndev -> dev ; struct nfc_evt_transaction * transaction ; pr_debug ( \"connectivity<S2SV_blank>gate<S2SV_blank>event:<S2SV_blank>%x\\\\n\" , event ) ; switch ( event ) { case ST21NFCA_EVT_CONNECTIVITY : r = nfc_se_connectivity ( hdev -> ndev , host ) ; break ; case ST21NFCA_EVT_TRANSACTION : if ( skb -> len < NFC_MIN_AID_LENGTH + 2 && skb -> data [ 0 ] != NFC_EVT_TRANSACTION_AID_TAG ) return - EPROTO ; transaction = devm_kzalloc ( dev , skb -> len - 2 , GFP_KERNEL ) ; if ( ! transaction ) return - ENOMEM ; transaction -> aid_len = skb -> data [ 1 ] ; <S2SV_StartBug> memcpy ( transaction -> aid , & skb -> data [ 2 ] , <S2SV_EndBug> transaction -> aid_len ) ; if ( skb -> data [ transaction -> aid_len + 2 ] != NFC_EVT_TRANSACTION_PARAMS_TAG ) return - EPROTO ; <S2SV_StartBug> transaction -> params_len = skb -> data [ transaction -> aid_len + 3 ] ; <S2SV_EndBug> memcpy ( transaction -> params , skb -> data + transaction -> aid_len + 4 , transaction -> params_len ) ; r = nfc_se_transaction ( hdev -> ndev , host , transaction ) ; break ; default : nfc_err ( & hdev -> ndev -> dev , \"Unexpected<S2SV_blank>event<S2SV_blank>on<S2SV_blank>connectivity<S2SV_blank>gate\\\\n\" ) ; return 1 ; } kfree_skb ( skb ) ; return r ; }", "target": "<S2SV_ModStart> 1 ] ; if ( transaction -> aid_len > sizeof ( transaction -> aid ) ) return - EINVAL ; <S2SV_ModStart> 3 ] ; if ( transaction -> params_len > ( ( skb -> len - 2 ) - sizeof ( struct nfc_evt_transaction ) ) ) return - EINVAL ;"}
{"source": "CWE-20 cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) { char * name ; char * value ; char output_raw ; int fmt ; l_fp lfp ; sockaddr_u hval ; u_long uval ; int narr ; size_t len ; l_fp lfparr [ 8 ] ; char b [ 12 ] ; char bn [ 2 * MAXVARLEN ] ; char bv [ 2 * MAXVALLEN ] ; UNUSED_ARG ( datatype ) ; if ( ! quiet ) fprintf ( fp , \"status=%04x<S2SV_blank>%s,\\\\n\" , status , statustoa ( datatype , status ) ) ; startoutput ( ) ; while ( nextvar ( & length , & data , & name , & value ) ) { fmt = varfmt ( name ) ; output_raw = 0 ; switch ( fmt ) { case PADDING : output_raw = '*' ; break ; case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ; else output ( fp , name , prettydate ( & lfp ) ) ; break ; case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) { output_raw = '?' ; } else if ( fmt == HA ) { output ( fp , name , nntohost ( & hval ) ) ; } else { output ( fp , name , stoa ( & hval ) ) ; } break ; case RF : if ( decodenetnum ( value , & hval ) ) { if ( ISREFCLOCKADR ( & hval ) ) output ( fp , name , refnumtoa ( & hval ) ) ; else output ( fp , name , stoa ( & hval ) ) ; } else if ( strlen ( value ) <= 4 ) { output ( fp , name , value ) ; } else { output_raw = '?' ; } break ; case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) { output_raw = '?' ; } else { b [ 0 ] = ( 0x2 & uval ) ? '1' : '0' ; b [ 1 ] = ( 0x1 & uval ) ? '1' : '0' ; b [ 2 ] = '\\\\0' ; output ( fp , name , b ) ; } break ; case OC : if ( ! decodeuint ( value , & uval ) ) { output_raw = '?' ; } else { snprintf ( b , sizeof ( b ) , \"%03lo\" , uval ) ; output ( fp , name , b ) ; } break ; case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ; else outputarr ( fp , name , narr , lfparr ) ; break ; case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ; else output ( fp , name , tstflags ( uval ) ) ; break ; default : fprintf ( stderr , \"Internal<S2SV_blank>error<S2SV_blank>in<S2SV_blank>cookedprint,<S2SV_blank>%s=%s,<S2SV_blank>fmt<S2SV_blank>%d\\\\n\" , name , value , fmt ) ; output_raw = '?' ; break ; } if ( output_raw != 0 ) { atoascii ( name , MAXVARLEN , bn , sizeof ( bn ) ) ; <S2SV_StartBug> atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output_raw != '*' ) { <S2SV_EndBug> len = strlen ( bv ) ; bv [ len ] = output_raw ; bv [ len + 1 ] = '\\\\0' ; <S2SV_StartBug> } <S2SV_EndBug> output ( fp , bn , bv ) ; } } endoutput ( fp ) ; }", "target": "<S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( output_raw <S2SV_ModStart> '*' ) { atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) - 1 ) ; <S2SV_ModStart> '\\\\0' ; } else { atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ; }"}
{"source": "CWE-20 static jpc_enc_cp_t * cp_create ( const char * optstr , jas_image_t * image ) { jpc_enc_cp_t * cp ; jas_tvparser_t * tvp ; int ret ; int numilyrrates ; double * ilyrrates ; int i ; int tagid ; jpc_enc_tcp_t * tcp ; jpc_enc_tccp_t * tccp ; jpc_enc_ccp_t * ccp ; uint_fast16_t rlvlno ; uint_fast16_t prcwidthexpn ; uint_fast16_t prcheightexpn ; bool enablemct ; uint_fast32_t jp2overhead ; uint_fast16_t lyrno ; uint_fast32_t hsteplcm ; uint_fast32_t vsteplcm ; bool mctvalid ; tvp = 0 ; cp = 0 ; ilyrrates = 0 ; numilyrrates = 0 ; if ( ! ( cp = jas_malloc ( sizeof ( jpc_enc_cp_t ) ) ) ) { goto error ; } prcwidthexpn = 15 ; prcheightexpn = 15 ; enablemct = true ; jp2overhead = 0 ; cp -> ccps = 0 ; cp -> debug = 0 ; cp -> imgareatlx = UINT_FAST32_MAX ; cp -> imgareatly = UINT_FAST32_MAX ; cp -> refgrdwidth = 0 ; cp -> refgrdheight = 0 ; cp -> tilegrdoffx = UINT_FAST32_MAX ; cp -> tilegrdoffy = UINT_FAST32_MAX ; cp -> tilewidth = 0 ; cp -> tileheight = 0 ; cp -> numcmpts = jas_image_numcmpts ( image ) ; hsteplcm = 1 ; vsteplcm = 1 ; for ( unsigned cmptno = 0 ; cmptno < jas_image_numcmpts ( image ) ; ++ cmptno ) { if ( jas_image_cmptbrx ( image , cmptno ) + jas_image_cmpthstep ( image , cmptno ) <= jas_image_brx ( image ) || jas_image_cmptbry ( image , cmptno ) + jas_image_cmptvstep ( image , cmptno ) <= jas_image_bry ( image ) ) { jas_eprintf ( \"unsupported<S2SV_blank>image<S2SV_blank>type\\\\n\" ) ; goto error ; } hsteplcm *= jas_image_cmpthstep ( image , cmptno ) ; vsteplcm *= jas_image_cmptvstep ( image , cmptno ) ; } if ( ! ( cp -> ccps = jas_alloc2 ( cp -> numcmpts , sizeof ( jpc_enc_ccp_t ) ) ) ) { goto error ; } unsigned cmptno ; for ( cmptno = 0 , ccp = cp -> ccps ; cmptno < cp -> numcmpts ; ++ cmptno , ++ ccp ) { ccp -> sampgrdstepx = jas_image_cmpthstep ( image , cmptno ) ; ccp -> sampgrdstepy = jas_image_cmptvstep ( image , cmptno ) ; ccp -> sampgrdsubstepx = 0 ; ccp -> sampgrdsubstepx = 0 ; ccp -> prec = jas_image_cmptprec ( image , cmptno ) ; ccp -> sgnd = jas_image_cmptsgnd ( image , cmptno ) ; ccp -> numstepsizes = 0 ; memset ( ccp -> stepsizes , 0 , sizeof ( ccp -> stepsizes ) ) ; } cp -> rawsize = jas_image_rawsize ( image ) ; if ( cp -> rawsize == 0 ) { goto error ; } cp -> totalsize = UINT_FAST32_MAX ; tcp = & cp -> tcp ; tcp -> csty = 0 ; tcp -> intmode = true ; tcp -> prg = JPC_COD_LRCPPRG ; tcp -> numlyrs = 1 ; tcp -> ilyrrates = 0 ; tccp = & cp -> tccp ; tccp -> csty = 0 ; tccp -> maxrlvls = 6 ; tccp -> cblkwidthexpn = 6 ; tccp -> cblkheightexpn = 6 ; tccp -> cblksty = 0 ; tccp -> numgbits = 2 ; if ( ! ( tvp = jas_tvparser_create ( optstr ? optstr : \"\" ) ) ) { goto error ; } while ( ! ( ret = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( encopts , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case OPT_DEBUG : cp -> debug = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_IMGAREAOFFX : cp -> imgareatlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_IMGAREAOFFY : cp -> imgareatly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_TILEGRDOFFX : cp -> tilegrdoffx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_TILEGRDOFFY : cp -> tilegrdoffy = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_TILEWIDTH : cp -> tilewidth = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_TILEHEIGHT : cp -> tileheight = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_PRCWIDTH : prcwidthexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ; break ; case OPT_PRCHEIGHT : prcheightexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ; break ; case OPT_CBLKWIDTH : tccp -> cblkwidthexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ; break ; case OPT_CBLKHEIGHT : tccp -> cblkheightexpn = jpc_floorlog2 ( atoi ( jas_tvparser_getval ( tvp ) ) ) ; break ; case OPT_MODE : if ( ( tagid = jas_taginfo_nonull ( jas_taginfos_lookup ( modetab , jas_tvparser_getval ( tvp ) ) ) -> id ) < 0 ) { jas_eprintf ( \"ignoring<S2SV_blank>invalid<S2SV_blank>mode<S2SV_blank>%s\\\\n\" , jas_tvparser_getval ( tvp ) ) ; } else { tcp -> intmode = ( tagid == MODE_INT ) ; } break ; case OPT_PRG : if ( ( tagid = jas_taginfo_nonull ( jas_taginfos_lookup ( prgordtab , jas_tvparser_getval ( tvp ) ) ) -> id ) < 0 ) { jas_eprintf ( \"ignoring<S2SV_blank>invalid<S2SV_blank>progression<S2SV_blank>order<S2SV_blank>%s\\\\n\" , jas_tvparser_getval ( tvp ) ) ; } else { tcp -> prg = tagid ; } break ; case OPT_NOMCT : enablemct = false ; break ; case OPT_MAXRLVLS : <S2SV_StartBug> tccp -> maxrlvls = atoi ( jas_tvparser_getval ( tvp ) ) ; <S2SV_EndBug> break ; case OPT_SOP : cp -> tcp . csty |= JPC_COD_SOP ; break ; case OPT_EPH : cp -> tcp . csty |= JPC_COD_EPH ; break ; case OPT_LAZY : tccp -> cblksty |= JPC_COX_LAZY ; break ; case OPT_TERMALL : tccp -> cblksty |= JPC_COX_TERMALL ; break ; case OPT_SEGSYM : tccp -> cblksty |= JPC_COX_SEGSYM ; break ; case OPT_VCAUSAL : tccp -> cblksty |= JPC_COX_VSC ; break ; case OPT_RESET : tccp -> cblksty |= JPC_COX_RESET ; break ; case OPT_PTERM : tccp -> cblksty |= JPC_COX_PTERM ; break ; case OPT_NUMGBITS : cp -> tccp . numgbits = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case OPT_RATE : if ( ratestrtosize ( jas_tvparser_getval ( tvp ) , cp -> rawsize , & cp -> totalsize ) ) { jas_eprintf ( \"ignoring<S2SV_blank>bad<S2SV_blank>rate<S2SV_blank>specifier<S2SV_blank>%s\\\\n\" , jas_tvparser_getval ( tvp ) ) ; } break ; case OPT_ILYRRATES : if ( jpc_atoaf ( jas_tvparser_getval ( tvp ) , & numilyrrates , & ilyrrates ) ) { jas_eprintf ( \"warning:<S2SV_blank>invalid<S2SV_blank>intermediate<S2SV_blank>layer<S2SV_blank>rates<S2SV_blank>specifier<S2SV_blank>ignored<S2SV_blank>(%s)\\\\n\" , jas_tvparser_getval ( tvp ) ) ; } break ; case OPT_JP2OVERHEAD : jp2overhead = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; default : jas_eprintf ( \"warning:<S2SV_blank>ignoring<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>%s\\\\n\" , jas_tvparser_gettag ( tvp ) ) ; break ; } } jas_tvparser_destroy ( tvp ) ; tvp = 0 ; if ( cp -> totalsize != UINT_FAST32_MAX ) { cp -> totalsize = ( cp -> totalsize > jp2overhead ) ? ( cp -> totalsize - jp2overhead ) : 0 ; } if ( cp -> imgareatlx == UINT_FAST32_MAX ) { cp -> imgareatlx = 0 ; } else { if ( hsteplcm != 1 ) { jas_eprintf ( \"warning:<S2SV_blank>overriding<S2SV_blank>imgareatlx<S2SV_blank>value\\\\n\" ) ; } cp -> imgareatlx *= hsteplcm ; } if ( cp -> imgareatly == UINT_FAST32_MAX ) { cp -> imgareatly = 0 ; } else { if ( vsteplcm != 1 ) { jas_eprintf ( \"warning:<S2SV_blank>overriding<S2SV_blank>imgareatly<S2SV_blank>value\\\\n\" ) ; } cp -> imgareatly *= vsteplcm ; } cp -> refgrdwidth = cp -> imgareatlx + jas_image_width ( image ) ; cp -> refgrdheight = cp -> imgareatly + jas_image_height ( image ) ; if ( cp -> tilegrdoffx == UINT_FAST32_MAX ) { cp -> tilegrdoffx = cp -> imgareatlx ; } if ( cp -> tilegrdoffy == UINT_FAST32_MAX ) { cp -> tilegrdoffy = cp -> imgareatly ; } if ( ! cp -> tilewidth ) { cp -> tilewidth = cp -> refgrdwidth - cp -> tilegrdoffx ; } if ( ! cp -> tileheight ) { cp -> tileheight = cp -> refgrdheight - cp -> tilegrdoffy ; } if ( cp -> numcmpts == 3 ) { mctvalid = true ; for ( cmptno = 0 ; cmptno < jas_image_numcmpts ( image ) ; ++ cmptno ) { if ( jas_image_cmptprec ( image , cmptno ) != jas_image_cmptprec ( image , 0 ) || jas_image_cmptsgnd ( image , cmptno ) != jas_image_cmptsgnd ( image , 0 ) || jas_image_cmptwidth ( image , cmptno ) != jas_image_cmptwidth ( image , 0 ) || jas_image_cmptheight ( image , cmptno ) != jas_image_cmptheight ( image , 0 ) ) { mctvalid = false ; } } } else { mctvalid = false ; } if ( mctvalid && enablemct && jas_clrspc_fam ( jas_image_clrspc ( image ) ) != JAS_CLRSPC_FAM_RGB ) { jas_eprintf ( \"warning:<S2SV_blank>color<S2SV_blank>space<S2SV_blank>apparently<S2SV_blank>not<S2SV_blank>RGB\\\\n\" ) ; } if ( mctvalid && enablemct && jas_clrspc_fam ( jas_image_clrspc ( image ) ) == JAS_CLRSPC_FAM_RGB ) { tcp -> mctid = ( tcp -> intmode ) ? ( JPC_MCT_RCT ) : ( JPC_MCT_ICT ) ; } else { tcp -> mctid = JPC_MCT_NONE ; } tccp -> qmfbid = ( tcp -> intmode ) ? ( JPC_COX_RFT ) : ( JPC_COX_INS ) ; for ( rlvlno = 0 ; rlvlno < tccp -> maxrlvls ; ++ rlvlno ) { tccp -> prcwidthexpns [ rlvlno ] = prcwidthexpn ; tccp -> prcheightexpns [ rlvlno ] = prcheightexpn ; } if ( prcwidthexpn != 15 || prcheightexpn != 15 ) { tccp -> csty |= JPC_COX_PRT ; } if ( ! cp -> tilewidth ) { jas_eprintf ( \"invalid<S2SV_blank>tile<S2SV_blank>width<S2SV_blank>%lu\\\\n\" , ( unsigned long ) cp -> tilewidth ) ; goto error ; } if ( ! cp -> tileheight ) { jas_eprintf ( \"invalid<S2SV_blank>tile<S2SV_blank>height<S2SV_blank>%lu\\\\n\" , ( unsigned long ) cp -> tileheight ) ; goto error ; } if ( cp -> tilegrdoffx > cp -> imgareatlx || cp -> tilegrdoffy > cp -> imgareatly || cp -> tilegrdoffx + cp -> tilewidth < cp -> imgareatlx || cp -> tilegrdoffy + cp -> tileheight < cp -> imgareatly ) { jas_eprintf ( \"invalid<S2SV_blank>tile<S2SV_blank>grid<S2SV_blank>offset<S2SV_blank>(%lu,<S2SV_blank>%lu)\\\\n\" , ( unsigned long ) cp -> tilegrdoffx , ( unsigned long ) cp -> tilegrdoffy ) ; goto error ; } cp -> numhtiles = JPC_CEILDIV ( cp -> refgrdwidth - cp -> tilegrdoffx , cp -> tilewidth ) ; cp -> numvtiles = JPC_CEILDIV ( cp -> refgrdheight - cp -> tilegrdoffy , cp -> tileheight ) ; cp -> numtiles = cp -> numhtiles * cp -> numvtiles ; if ( ilyrrates && numilyrrates > 0 ) { tcp -> numlyrs = numilyrrates + 1 ; if ( ! ( tcp -> ilyrrates = jas_alloc2 ( ( tcp -> numlyrs - 1 ) , sizeof ( jpc_fix_t ) ) ) ) { goto error ; } for ( i = 0 ; i < JAS_CAST ( int , tcp -> numlyrs - 1 ) ; ++ i ) { tcp -> ilyrrates [ i ] = jpc_dbltofix ( ilyrrates [ i ] ) ; } } if ( cp -> totalsize == UINT_FAST32_MAX && ( ! cp -> tcp . intmode ) ) { jas_eprintf ( \"cannot<S2SV_blank>use<S2SV_blank>real<S2SV_blank>mode<S2SV_blank>for<S2SV_blank>lossless<S2SV_blank>coding\\\\n\" ) ; goto error ; } if ( prcwidthexpn > 15 ) { jas_eprintf ( \"invalid<S2SV_blank>precinct<S2SV_blank>width\\\\n\" ) ; goto error ; } if ( prcheightexpn > 15 ) { jas_eprintf ( \"invalid<S2SV_blank>precinct<S2SV_blank>height\\\\n\" ) ; goto error ; } if ( cp -> tccp . cblkwidthexpn < 2 || cp -> tccp . cblkwidthexpn > 12 ) { jas_eprintf ( \"invalid<S2SV_blank>code<S2SV_blank>block<S2SV_blank>width<S2SV_blank>%d\\\\n\" , JPC_POW2 ( cp -> tccp . cblkwidthexpn ) ) ; goto error ; } if ( cp -> tccp . cblkheightexpn < 2 || cp -> tccp . cblkheightexpn > 12 ) { jas_eprintf ( \"invalid<S2SV_blank>code<S2SV_blank>block<S2SV_blank>height<S2SV_blank>%d\\\\n\" , JPC_POW2 ( cp -> tccp . cblkheightexpn ) ) ; goto error ; } if ( cp -> tccp . cblkwidthexpn + cp -> tccp . cblkheightexpn > 12 ) { jas_eprintf ( \"code<S2SV_blank>block<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\\\n\" ) ; goto error ; } if ( cp -> tcp . numlyrs > 16384 ) { jas_eprintf ( \"too<S2SV_blank>many<S2SV_blank>layers\\\\n\" ) ; goto error ; } if ( cp -> tccp . maxrlvls < 1 ) { jas_eprintf ( \"must<S2SV_blank>be<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>resolution<S2SV_blank>level\\\\n\" ) ; goto error ; } if ( cp -> tccp . numgbits > 8 ) { jas_eprintf ( \"invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>guard<S2SV_blank>bits\\\\n\" ) ; goto error ; } if ( cp -> totalsize != UINT_FAST32_MAX && cp -> totalsize > cp -> rawsize ) { jas_eprintf ( \"warning:<S2SV_blank>specified<S2SV_blank>rate<S2SV_blank>is<S2SV_blank>unreasonably<S2SV_blank>large<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%lu)\\\\n\" , ( unsigned long ) cp -> totalsize , ( unsigned long ) cp -> rawsize ) ; } if ( tcp -> numlyrs > 1 ) { for ( lyrno = 0 ; lyrno + 2 < tcp -> numlyrs ; ++ lyrno ) { if ( tcp -> ilyrrates [ lyrno ] >= tcp -> ilyrrates [ lyrno + 1 ] ) { jas_eprintf ( \"intermediate<S2SV_blank>layer<S2SV_blank>rates<S2SV_blank>must<S2SV_blank>increase<S2SV_blank>monotonically\\\\n\" ) ; goto error ; } } if ( cp -> totalsize != UINT_FAST32_MAX ) { for ( lyrno = 0 ; lyrno < tcp -> numlyrs - 1 ; ++ lyrno ) { if ( jpc_fixtodbl ( tcp -> ilyrrates [ lyrno ] ) > ( ( double ) cp -> totalsize ) / cp -> rawsize ) { jas_eprintf ( \"warning:<S2SV_blank>intermediate<S2SV_blank>layer<S2SV_blank>rates<S2SV_blank>must<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>overall<S2SV_blank>rate\\\\n\" ) ; goto error ; } } } } if ( ilyrrates ) { jas_free ( ilyrrates ) ; } return cp ; error : if ( ilyrrates ) { jas_free ( ilyrrates ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } if ( cp ) { jpc_enc_cp_destroy ( cp ) ; } return 0 ; }", "target": "<S2SV_ModStart> ) ) ; if ( tccp -> maxrlvls > JPC_MAXRLVLS ) { jas_eprintf ( \"invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>resolution<S2SV_blank>levels<S2SV_blank>upper<S2SV_blank>than<S2SV_blank>%d\\\\n\" , JPC_MAXRLVLS ) ; goto error ; }"}
{"source": "CWE-787 change_indent ( int type , int amount , int round , int replaced , int call_changed_bytes ) { int vcol ; int last_vcol ; int insstart_less ; int new_cursor_col ; int i ; char_u * ptr ; int save_p_list ; int start_col ; colnr_T vc ; colnr_T orig_col = 0 ; char_u * new_line , * orig_line = NULL ; if ( State & VREPLACE_FLAG ) { orig_line = vim_strsave ( ml_get_curline ( ) ) ; orig_col = curwin -> w_cursor . col ; } save_p_list = curwin -> w_p_list ; curwin -> w_p_list = FALSE ; vc = getvcol_nolist ( & curwin -> w_cursor ) ; vcol = vc ; start_col = curwin -> w_cursor . col ; new_cursor_col = curwin -> w_cursor . col ; beginline ( BL_WHITE ) ; new_cursor_col -= curwin -> w_cursor . col ; insstart_less = curwin -> w_cursor . col ; if ( new_cursor_col < 0 ) vcol = get_indent ( ) - vcol ; if ( new_cursor_col > 0 ) start_col = - 1 ; if ( type == INDENT_SET ) ( void ) set_indent ( amount , call_changed_bytes ? SIN_CHANGED : 0 ) ; else { int save_State = State ; if ( State & VREPLACE_FLAG ) State = INSERT ; shift_line ( type == INDENT_DEC , round , 1 , call_changed_bytes ) ; State = save_State ; } insstart_less -= curwin -> w_cursor . col ; if ( new_cursor_col >= 0 ) { if ( new_cursor_col == 0 ) insstart_less = MAXCOL ; new_cursor_col += curwin -> w_cursor . col ; } else if ( ! ( State & INSERT ) ) new_cursor_col = curwin -> w_cursor . col ; else { vcol = get_indent ( ) - vcol ; curwin -> w_virtcol = ( colnr_T ) ( ( vcol < 0 ) ? 0 : vcol ) ; vcol = last_vcol = 0 ; new_cursor_col = - 1 ; ptr = ml_get_curline ( ) ; while ( vcol <= ( int ) curwin -> w_virtcol ) { last_vcol = vcol ; if ( has_mbyte && new_cursor_col >= 0 ) new_cursor_col += ( * mb_ptr2len ) ( ptr + new_cursor_col ) ; else ++ new_cursor_col ; <S2SV_StartBug> vcol += lbr_chartabsize ( ptr , ptr + new_cursor_col , ( colnr_T ) vcol ) ; <S2SV_EndBug> } vcol = last_vcol ; if ( vcol != ( int ) curwin -> w_virtcol ) { curwin -> w_cursor . col = ( colnr_T ) new_cursor_col ; i = ( int ) curwin -> w_virtcol - vcol ; ptr = alloc ( i + 1 ) ; if ( ptr != NULL ) { new_cursor_col += i ; ptr [ i ] = NUL ; while ( -- i >= 0 ) ptr [ i ] = '<S2SV_blank>' ; ins_str ( ptr ) ; vim_free ( ptr ) ; } } insstart_less = MAXCOL ; } curwin -> w_p_list = save_p_list ; if ( new_cursor_col <= 0 ) curwin -> w_cursor . col = 0 ; else curwin -> w_cursor . col = ( colnr_T ) new_cursor_col ; curwin -> w_set_curswant = TRUE ; changed_cline_bef_curs ( ) ; if ( State & INSERT ) { if ( curwin -> w_cursor . lnum == Insstart . lnum && Insstart . col != 0 ) { if ( ( int ) Insstart . col <= insstart_less ) Insstart . col = 0 ; else Insstart . col -= insstart_less ; } if ( ( int ) ai_col <= insstart_less ) ai_col = 0 ; else ai_col -= insstart_less ; } if ( REPLACE_NORMAL ( State ) && start_col >= 0 ) { while ( start_col > ( int ) curwin -> w_cursor . col ) { replace_join ( 0 ) ; -- start_col ; } while ( start_col < ( int ) curwin -> w_cursor . col || replaced ) { replace_push ( NUL ) ; if ( replaced ) { replace_push ( replaced ) ; replaced = NUL ; } ++ start_col ; } } if ( State & VREPLACE_FLAG ) { if ( orig_line == NULL ) return ; new_line = vim_strsave ( ml_get_curline ( ) ) ; if ( new_line == NULL ) return ; new_line [ curwin -> w_cursor . col ] = NUL ; ml_replace ( curwin -> w_cursor . lnum , orig_line , FALSE ) ; curwin -> w_cursor . col = orig_col ; backspace_until_column ( 0 ) ; ins_bytes ( new_line ) ; vim_free ( new_line ) ; } }", "target": "<S2SV_ModStart> ++ new_cursor_col ; if ( ptr [ new_cursor_col ] == NUL ) break ;"}
{"source": "CWE-787 static Image * ReadTIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MaxPixelChannels 32 <S2SV_StartBug> # define ThrowTIFFException ( severity , message ) { if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; TIFFClose ( tiff ) ; ThrowReaderException ( severity , message ) ; } <S2SV_EndBug> const char * option ; float * chromaticity = ( float * ) NULL , x_position , y_position , x_resolution , y_resolution ; Image * image ; int tiff_status = 0 ; MagickBooleanType more_frames ; MagickStatusType status ; MemoryInfo * pixel_info = ( MemoryInfo * ) NULL ; QuantumInfo * quantum_info ; QuantumType quantum_type ; size_t number_pixels ; ssize_t i , scanline_size , y ; TIFF * tiff ; TIFFMethodType method ; uint16 compress_tag = 0 , bits_per_sample = 0 , endian = 0 , extra_samples = 0 , interlace = 0 , max_sample_value = 0 , min_sample_value = 0 , orientation = 0 , pages = 0 , photometric = 0 , * sample_info = NULL , sample_format = 0 , samples_per_pixel = 0 , units = 0 , value = 0 ; uint32 height , rows_per_strip , width ; unsigned char * pixels ; void * sans [ 8 ] = { NULL , NULL , NULL , NULL , NULL , NULL , NULL , NULL } ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; if ( IsEventLogging ( ) != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) SetMagickThreadValue ( tiff_exception , exception ) ; tiff = TIFFClientOpen ( image -> filename , \"rb\" , ( thandle_t ) image , TIFFReadBlob , TIFFWriteBlob , TIFFSeekBlob , TIFFCloseBlob , TIFFGetBlobSize , TIFFMapBlob , TIFFUnmapBlob ) ; if ( tiff == ( TIFF * ) NULL ) { if ( exception -> severity == UndefinedException ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( exception -> severity > ErrorException ) { TIFFClose ( tiff ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image_info -> number_scenes != 0 ) { if ( image_info -> scene < ( size_t ) TIFFNumberOfDirectories ( tiff ) ) { for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { status = TIFFReadDirectory ( tiff ) != 0 ? MagickTrue : MagickFalse ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { TIFFClose ( tiff ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } } } more_frames = MagickTrue ; do { photometric = PHOTOMETRIC_RGB ; if ( ( TIFFGetField ( tiff , TIFFTAG_IMAGEWIDTH , & width ) != 1 ) || ( TIFFGetField ( tiff , TIFFTAG_IMAGELENGTH , & height ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_PHOTOMETRIC , & photometric , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_COMPRESSION , & compress_tag , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_FILLORDER , & endian , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_PLANARCONFIG , & interlace , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_SAMPLESPERPIXEL , & samples_per_pixel , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_BITSPERSAMPLE , & bits_per_sample , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_SAMPLEFORMAT , & sample_format , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_MINSAMPLEVALUE , & min_sample_value , sans ) != 1 ) || ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_MAXSAMPLEVALUE , & max_sample_value , sans ) != 1 ) ) { TIFFClose ( tiff ) ; ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; } if ( ( ( sample_format != SAMPLEFORMAT_IEEEFP ) || ( bits_per_sample != 64 ) ) && ( ( bits_per_sample <= 0 ) || ( bits_per_sample > 32 ) ) ) { TIFFClose ( tiff ) ; ThrowReaderException ( CorruptImageError , \"UnsupportedBitsPerPixel\" ) ; } if ( samples_per_pixel > MaxPixelChannels ) { TIFFClose ( tiff ) ; ThrowReaderException ( CorruptImageError , \"MaximumChannelsExceeded\" ) ; } if ( sample_format == SAMPLEFORMAT_IEEEFP ) ( void ) SetImageProperty ( image , \"quantum:format\" , \"floating-point\" ) ; switch ( photometric ) { case PHOTOMETRIC_MINISBLACK : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"min-is-black\" ) ; break ; } case PHOTOMETRIC_MINISWHITE : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"min-is-white\" ) ; break ; } case PHOTOMETRIC_PALETTE : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"palette\" ) ; break ; } case PHOTOMETRIC_RGB : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"RGB\" ) ; break ; } case PHOTOMETRIC_CIELAB : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"CIELAB\" ) ; break ; } case PHOTOMETRIC_LOGL : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"CIE<S2SV_blank>Log2(L)\" ) ; break ; } case PHOTOMETRIC_LOGLUV : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"LOGLUV\" ) ; break ; } # if defined ( PHOTOMETRIC_MASK ) case PHOTOMETRIC_MASK : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"MASK\" ) ; break ; } # endif case PHOTOMETRIC_SEPARATED : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"separated\" ) ; break ; } case PHOTOMETRIC_YCBCR : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"YCBCR\" ) ; break ; } default : { ( void ) SetImageProperty ( image , \"tiff:photometric\" , \"unknown\" ) ; break ; } } if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Geometry:<S2SV_blank>%ux%u\" , ( unsigned int ) width , ( unsigned int ) height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Interlace:<S2SV_blank>%u\" , interlace ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Bits<S2SV_blank>per<S2SV_blank>sample:<S2SV_blank>%u\" , bits_per_sample ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Min<S2SV_blank>sample<S2SV_blank>value:<S2SV_blank>%u\" , min_sample_value ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Max<S2SV_blank>sample<S2SV_blank>value:<S2SV_blank>%u\" , max_sample_value ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Photometric<S2SV_blank>\" \"interpretation:<S2SV_blank>%s\" , GetImageProperty ( image , \"tiff:photometric\" ) ) ; } image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = ( size_t ) bits_per_sample ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Image<S2SV_blank>depth:<S2SV_blank>%.20g\" , ( double ) image -> depth ) ; image -> endian = MSBEndian ; if ( endian == FILLORDER_LSB2MSB ) image -> endian = LSBEndian ; # if defined ( MAGICKCORE_HAVE_TIFFISBIGENDIAN ) if ( TIFFIsBigEndian ( tiff ) == 0 ) { ( void ) SetImageProperty ( image , \"tiff:endian\" , \"lsb\" ) ; image -> endian = LSBEndian ; } else { ( void ) SetImageProperty ( image , \"tiff:endian\" , \"msb\" ) ; image -> endian = MSBEndian ; } # endif if ( ( photometric == PHOTOMETRIC_MINISBLACK ) || ( photometric == PHOTOMETRIC_MINISWHITE ) ) image -> colorspace = GRAYColorspace ; if ( photometric == PHOTOMETRIC_SEPARATED ) image -> colorspace = CMYKColorspace ; if ( photometric == PHOTOMETRIC_CIELAB ) image -> colorspace = LabColorspace ; if ( ( photometric == PHOTOMETRIC_YCBCR ) && ( compress_tag != COMPRESSION_OJPEG ) && ( compress_tag != COMPRESSION_JPEG ) ) image -> colorspace = YCbCrColorspace ; status = TIFFGetProfiles ( tiff , image ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status = TIFFGetProperties ( tiff , image ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } option = GetImageOption ( image_info , \"tiff:exif-properties\" ) ; if ( ( option == ( const char * ) NULL ) || ( IsMagickTrue ( option ) != MagickFalse ) ) ( void ) TIFFGetEXIFProperties ( tiff , image ) ; option = GetImageOption ( image_info , \"tiff:gps-properties\" ) ; if ( ( option == ( const char * ) NULL ) || ( IsMagickTrue ( option ) != MagickFalse ) ) ( void ) TIFFGetGPSProperties ( tiff , image ) ; if ( ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_XRESOLUTION , & x_resolution , sans ) == 1 ) && ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_YRESOLUTION , & y_resolution , sans ) == 1 ) ) { image -> x_resolution = x_resolution ; image -> y_resolution = y_resolution ; } if ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_RESOLUTIONUNIT , & units , sans , sans ) == 1 ) { if ( units == RESUNIT_INCH ) image -> units = PixelsPerInchResolution ; if ( units == RESUNIT_CENTIMETER ) image -> units = PixelsPerCentimeterResolution ; } if ( ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_XPOSITION , & x_position , sans ) == 1 ) && ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_YPOSITION , & y_position , sans ) == 1 ) ) { image -> page . x = CastDoubleToLong ( ceil ( x_position * image -> x_resolution - 0.5 ) ) ; image -> page . y = CastDoubleToLong ( ceil ( y_position * image -> y_resolution - 0.5 ) ) ; } if ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_ORIENTATION , & orientation , sans ) == 1 ) image -> orientation = ( OrientationType ) orientation ; if ( TIFFGetField ( tiff , TIFFTAG_WHITEPOINT , & chromaticity ) == 1 ) { if ( ( chromaticity != ( float * ) NULL ) && ( * chromaticity != 0.0 ) ) { image -> chromaticity . white_point . x = chromaticity [ 0 ] ; image -> chromaticity . white_point . y = chromaticity [ 1 ] ; } } if ( TIFFGetField ( tiff , TIFFTAG_PRIMARYCHROMATICITIES , & chromaticity ) == 1 ) { if ( ( chromaticity != ( float * ) NULL ) && ( * chromaticity != 0.0 ) ) { image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; } } # if defined ( MAGICKCORE_HAVE_TIFFISCODECCONFIGURED ) || ( TIFFLIB_VERSION > 20040919 ) if ( ( compress_tag != COMPRESSION_NONE ) && ( TIFFIsCODECConfigured ( compress_tag ) == 0 ) ) { TIFFClose ( tiff ) ; ThrowReaderException ( CoderError , \"CompressNotSupported\" ) ; } # endif switch ( compress_tag ) { case COMPRESSION_NONE : image -> compression = NoCompression ; break ; case COMPRESSION_CCITTFAX3 : image -> compression = FaxCompression ; break ; case COMPRESSION_CCITTFAX4 : image -> compression = Group4Compression ; break ; case COMPRESSION_JPEG : { image -> compression = JPEGCompression ; # if defined ( JPEG_SUPPORT ) { char sampling_factor [ MaxTextExtent ] ; int tiff_status ; uint16 horizontal , vertical ; tiff_status = TIFFGetField ( tiff , TIFFTAG_YCBCRSUBSAMPLING , & horizontal , & vertical ) ; if ( tiff_status == 1 ) { ( void ) FormatLocaleString ( sampling_factor , MaxTextExtent , \"%dx%d\" , horizontal , vertical ) ; ( void ) SetImageProperty ( image , \"jpeg:sampling-factor\" , sampling_factor ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"Sampling<S2SV_blank>Factors:<S2SV_blank>%s\" , sampling_factor ) ; } } # endif break ; } case COMPRESSION_OJPEG : image -> compression = JPEGCompression ; break ; # if defined ( COMPRESSION_LZMA ) case COMPRESSION_LZMA : image -> compression = LZMACompression ; break ; # endif case COMPRESSION_LZW : image -> compression = LZWCompression ; break ; case COMPRESSION_DEFLATE : image -> compression = ZipCompression ; break ; case COMPRESSION_ADOBE_DEFLATE : image -> compression = ZipCompression ; break ; # if defined ( COMPRESSION_WEBP ) case COMPRESSION_WEBP : image -> compression = WebPCompression ; break ; # endif # if defined ( COMPRESSION_ZSTD ) case COMPRESSION_ZSTD : image -> compression = ZstdCompression ; break ; # endif default : image -> compression = RLECompression ; break ; } quantum_info = ( QuantumInfo * ) NULL ; if ( ( photometric == PHOTOMETRIC_PALETTE ) && ( pow ( 2.0 , 1.0 * bits_per_sample ) <= MaxColormapSize ) ) { size_t colors ; colors = ( size_t ) GetQuantumRange ( bits_per_sample ) + 1 ; if ( AcquireImageColormap ( image , colors ) == MagickFalse ) { TIFFClose ( tiff ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } } if ( TIFFGetFieldDefaulted ( tiff , TIFFTAG_PAGENUMBER , & value , & pages , sans ) == 1 ) image -> scene = value ; if ( image -> storage_class == PseudoClass ) { int tiff_status ; size_t range ; uint16 * blue_colormap = ( uint16 * ) NULL , * green_colormap = ( uint16 * ) NULL , * red_colormap = ( uint16 * ) NULL ; tiff_status = TIFFGetField ( tiff , TIFFTAG_COLORMAP , & red_colormap , & green_colormap , & blue_colormap ) ; if ( tiff_status == 1 ) { if ( ( red_colormap != ( uint16 * ) NULL ) && ( green_colormap != ( uint16 * ) NULL ) && ( blue_colormap != ( uint16 * ) NULL ) ) { range = 255 ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( ( red_colormap [ i ] >= 256 ) || ( green_colormap [ i ] >= 256 ) || ( blue_colormap [ i ] >= 256 ) ) { range = 65535 ; break ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) QuantumRange * red_colormap [ i ] ) / range ) ; image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) QuantumRange * green_colormap [ i ] ) / range ) ; image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) QuantumRange * blue_colormap [ i ] ) / range ) ; } } } } if ( image_info -> ping != MagickFalse ) { if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; goto next_tiff_frame ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status = SetImageColorspace ( image , image -> colorspace ) ; status &= ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) { TIFFClose ( tiff ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; if ( sample_format == SAMPLEFORMAT_UINT ) status = SetQuantumFormat ( image , quantum_info , UnsignedQuantumFormat ) ; if ( sample_format == SAMPLEFORMAT_INT ) status = SetQuantumFormat ( image , quantum_info , SignedQuantumFormat ) ; if ( sample_format == SAMPLEFORMAT_IEEEFP ) status = SetQuantumFormat ( image , quantum_info , FloatingPointQuantumFormat ) ; if ( status == MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; status = MagickTrue ; switch ( photometric ) { case PHOTOMETRIC_MINISBLACK : { quantum_info -> min_is_white = MagickFalse ; break ; } case PHOTOMETRIC_MINISWHITE : { quantum_info -> min_is_white = MagickTrue ; break ; } default : break ; } extra_samples = 0 ; tiff_status = TIFFGetFieldDefaulted ( tiff , TIFFTAG_EXTRASAMPLES , & extra_samples , & sample_info , sans ) ; if ( tiff_status == 1 ) { ( void ) SetImageProperty ( image , \"tiff:alpha\" , \"unspecified\" ) ; if ( extra_samples == 0 ) { if ( ( samples_per_pixel == 4 ) && ( photometric == PHOTOMETRIC_RGB ) ) image -> matte = MagickTrue ; } else for ( i = 0 ; i < extra_samples ; i ++ ) { image -> matte = MagickTrue ; if ( sample_info [ i ] == EXTRASAMPLE_ASSOCALPHA ) { SetQuantumAlphaType ( quantum_info , AssociatedQuantumAlpha ) ; ( void ) SetImageProperty ( image , \"tiff:alpha\" , \"associated\" ) ; } else if ( sample_info [ i ] == EXTRASAMPLE_UNASSALPHA ) { SetQuantumAlphaType ( quantum_info , DisassociatedQuantumAlpha ) ; ( void ) SetImageProperty ( image , \"tiff:alpha\" , \"unassociated\" ) ; } } } if ( image -> matte != MagickFalse ) ( void ) SetImageAlphaChannel ( image , OpaqueAlphaChannel ) ; method = ReadGenericMethod ; rows_per_strip = ( uint32 ) image -> rows ; if ( TIFFGetField ( tiff , TIFFTAG_ROWSPERSTRIP , & rows_per_strip ) == 1 ) { char value [ MaxTextExtent ] ; ( void ) FormatLocaleString ( value , MaxTextExtent , \"%u\" , ( unsigned int ) rows_per_strip ) ; ( void ) SetImageProperty ( image , \"tiff:rows-per-strip\" , value ) ; method = ReadStripMethod ; if ( rows_per_strip > ( uint32 ) image -> rows ) rows_per_strip = ( uint32 ) image -> rows ; } if ( TIFFIsTiled ( tiff ) != MagickFalse ) { uint32 columns , rows ; if ( ( TIFFGetField ( tiff , TIFFTAG_TILEWIDTH , & columns ) != 1 ) || ( TIFFGetField ( tiff , TIFFTAG_TILELENGTH , & rows ) != 1 ) ) ThrowTIFFException ( CoderError , \"ImageIsNotTiled\" ) ; if ( ( AcquireMagickResource ( WidthResource , columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , rows ) == MagickFalse ) ) ThrowTIFFException ( ImageError , \"WidthOrHeightExceedsLimit\" ) ; method = ReadTileMethod ; } if ( ( photometric == PHOTOMETRIC_LOGLUV ) || ( compress_tag == COMPRESSION_CCITTFAX3 ) ) method = ReadGenericMethod ; if ( image -> compression == JPEGCompression ) method = GetJPEGMethod ( image , tiff , photometric , bits_per_sample , samples_per_pixel ) ; quantum_info -> endian = LSBEndian ; scanline_size = TIFFScanlineSize ( tiff ) ; if ( scanline_size <= 0 ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; number_pixels = MagickMax ( ( MagickSizeType ) image -> columns * samples_per_pixel * pow ( 2.0 , ceil ( log ( bits_per_sample ) / log ( 2.0 ) ) ) , image -> columns * rows_per_strip ) ; if ( ( double ) scanline_size > 1.5 * number_pixels ) ThrowTIFFException ( CorruptImageError , \"CorruptImage\" ) ; number_pixels = MagickMax ( ( MagickSizeType ) scanline_size , number_pixels ) ; pixel_info = AcquireVirtualMemory ( number_pixels , sizeof ( uint32 ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , number_pixels * sizeof ( uint32 ) ) ; quantum_type = GrayQuantum ; if ( image -> storage_class == PseudoClass ) quantum_type = IndexQuantum ; if ( interlace != PLANARCONFIG_SEPARATE ) { size_t pad ; pad = ( size_t ) MagickMax ( ( ssize_t ) samples_per_pixel - 1 , 0 ) ; if ( image -> matte != MagickFalse ) { if ( image -> storage_class == PseudoClass ) quantum_type = IndexAlphaQuantum ; else quantum_type = samples_per_pixel == 1 ? AlphaQuantum : GrayAlphaQuantum ; } if ( ( samples_per_pixel > 2 ) && ( interlace != PLANARCONFIG_SEPARATE ) ) { quantum_type = RGBQuantum ; pad = ( size_t ) MagickMax ( ( ssize_t ) samples_per_pixel + extra_samples - 3 , 0 ) ; if ( image -> matte != MagickFalse ) { quantum_type = RGBAQuantum ; pad = ( size_t ) MagickMax ( ( ssize_t ) samples_per_pixel + extra_samples - 4 , 0 ) ; } if ( image -> colorspace == CMYKColorspace ) { quantum_type = CMYKQuantum ; pad = ( size_t ) MagickMax ( ( ssize_t ) samples_per_pixel + extra_samples - 4 , 0 ) ; if ( image -> matte != MagickFalse ) { quantum_type = CMYKAQuantum ; pad = ( size_t ) MagickMax ( ( ssize_t ) samples_per_pixel + extra_samples - 5 , 0 ) ; } } status = SetQuantumPad ( image , quantum_info , pad * ( ( bits_per_sample + 7 ) >> 3 ) ) ; if ( status == MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; } } switch ( method ) { case ReadYCCKMethod : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { int status ; IndexPacket * indexes ; PixelPacket * magick_restrict q ; ssize_t x ; unsigned char * p ; status = TIFFReadPixels ( tiff , 0 , y , ( char * ) pixels ) ; if ( status == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; p = pixels ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelCyan ( q , ScaleCharToQuantum ( ClampYCC ( ( double ) * p + ( 1.402 * ( double ) * ( p + 2 ) ) - 179.456 ) ) ) ; SetPixelMagenta ( q , ScaleCharToQuantum ( ClampYCC ( ( double ) * p - ( 0.34414 * ( double ) * ( p + 1 ) ) - ( 0.71414 * ( double ) * ( p + 2 ) ) + 135.45984 ) ) ) ; SetPixelYellow ( q , ScaleCharToQuantum ( ClampYCC ( ( double ) * p + ( 1.772 * ( double ) * ( p + 1 ) ) - 226.816 ) ) ) ; SetPixelBlack ( indexes + x , ScaleCharToQuantum ( ( unsigned char ) * ( p + 3 ) ) ) ; q ++ ; p += 4 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case ReadStripMethod : { unsigned char * p ; size_t extent ; ssize_t stride , strip_id ; tsize_t strip_size ; unsigned char * strip_pixels ; <S2SV_StartBug> extent = 4 * ( samples_per_pixel + 1 ) * TIFFStripSize ( tiff ) ; <S2SV_EndBug> strip_pixels = ( unsigned char * ) AcquireQuantumMemory ( extent , sizeof ( * strip_pixels ) ) ; if ( strip_pixels == ( unsigned char * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( strip_pixels , 0 , extent * sizeof ( * strip_pixels ) ) ; stride = TIFFVStripSize ( tiff , 1 ) ; strip_id = 0 ; p = strip_pixels ; for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { size_t rows_remaining ; switch ( i ) { case 0 : break ; case 1 : quantum_type = GreenQuantum ; break ; case 2 : quantum_type = BlueQuantum ; break ; case 3 : { quantum_type = AlphaQuantum ; if ( image -> colorspace == CMYKColorspace ) quantum_type = BlackQuantum ; break ; } case 4 : quantum_type = AlphaQuantum ; break ; default : break ; } rows_remaining = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { PixelPacket * magick_restrict q ; q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; if ( rows_remaining == 0 ) { strip_size = TIFFReadEncodedStrip ( tiff , strip_id , strip_pixels , TIFFStripSize ( tiff ) ) ; if ( strip_size == - 1 ) break ; rows_remaining = rows_per_strip ; if ( ( y + rows_per_strip ) > ( ssize_t ) image -> rows ) rows_remaining = ( rows_per_strip - ( y + rows_per_strip - image -> rows ) ) ; p = strip_pixels ; strip_id ++ ; } ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , p , exception ) ; p += stride ; rows_remaining -- ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( ( samples_per_pixel > 1 ) && ( interlace != PLANARCONFIG_SEPARATE ) ) break ; } strip_pixels = ( unsigned char * ) RelinquishMagickMemory ( strip_pixels ) ; break ; } case ReadTileMethod : { unsigned char * p ; size_t extent ; uint32 columns , rows ; unsigned char * tile_pixels ; if ( ( TIFFGetField ( tiff , TIFFTAG_TILEWIDTH , & columns ) != 1 ) || ( TIFFGetField ( tiff , TIFFTAG_TILELENGTH , & rows ) != 1 ) ) ThrowTIFFException ( CoderError , \"ImageIsNotTiled\" ) ; number_pixels = ( MagickSizeType ) columns * rows ; if ( HeapOverflowSanityCheck ( rows , sizeof ( * tile_pixels ) ) != MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; extent = 4 * ( samples_per_pixel + 1 ) * MagickMax ( rows * TIFFTileRowSize ( tiff ) , TIFFTileSize ( tiff ) ) ; tile_pixels = ( unsigned char * ) AcquireQuantumMemory ( extent , sizeof ( * tile_pixels ) ) ; if ( tile_pixels == ( unsigned char * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) memset ( tile_pixels , 0 , extent * sizeof ( * tile_pixels ) ) ; for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { switch ( i ) { case 0 : break ; case 1 : quantum_type = GreenQuantum ; break ; case 2 : quantum_type = BlueQuantum ; break ; case 3 : { quantum_type = AlphaQuantum ; if ( image -> colorspace == CMYKColorspace ) quantum_type = BlackQuantum ; break ; } case 4 : quantum_type = AlphaQuantum ; break ; default : break ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += rows ) { ssize_t x ; size_t rows_remaining ; rows_remaining = image -> rows - y ; if ( ( ssize_t ) ( y + rows ) < ( ssize_t ) image -> rows ) rows_remaining = rows ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += columns ) { size_t columns_remaining , row ; columns_remaining = image -> columns - x ; if ( ( ssize_t ) ( x + columns ) < ( ssize_t ) image -> columns ) columns_remaining = columns ; tiff_status = TIFFReadTile ( tiff , tile_pixels , ( uint32 ) x , ( uint32 ) y , 0 , i ) ; if ( tiff_status == - 1 ) break ; p = tile_pixels ; for ( row = 0 ; row < rows_remaining ; row ++ ) { PixelPacket * magick_restrict q ; q = GetAuthenticPixels ( image , x , y + row , columns_remaining , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , p , exception ) ; p += TIFFTileRowSize ( tiff ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } } if ( ( samples_per_pixel > 1 ) && ( interlace != PLANARCONFIG_SEPARATE ) ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) i , samples_per_pixel ) ; if ( status == MagickFalse ) break ; } } tile_pixels = ( unsigned char * ) RelinquishMagickMemory ( tile_pixels ) ; break ; } case ReadGenericMethod : default : { MemoryInfo * generic_info = ( MemoryInfo * ) NULL ; uint32 * p ; uint32 * pixels ; if ( HeapOverflowSanityCheck ( image -> rows , sizeof ( * pixels ) ) != MagickFalse ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; generic_info = AcquireVirtualMemory ( number_pixels , sizeof ( * pixels ) ) ; if ( generic_info == ( MemoryInfo * ) NULL ) ThrowTIFFException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; pixels = ( uint32 * ) GetVirtualMemoryBlob ( generic_info ) ; tiff_status = TIFFReadRGBAImage ( tiff , ( uint32 ) image -> columns , ( uint32 ) image -> rows , ( uint32 * ) pixels , 0 ) ; if ( tiff_status == - 1 ) { generic_info = RelinquishVirtualMemory ( generic_info ) ; break ; } p = pixels + ( image -> columns * image -> rows ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { ssize_t x ; PixelPacket * magick_restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; q += image -> columns - 1 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) TIFFGetR ( * p ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) TIFFGetG ( * p ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) TIFFGetB ( * p ) ) ) ; if ( image -> matte == MagickFalse ) SetPixelOpacity ( q , OpaqueOpacity ) ; else SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) TIFFGetA ( * p ) ) ) ; p -- ; q -- ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } generic_info = RelinquishVirtualMemory ( generic_info ) ; break ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; SetQuantumImageType ( image , quantum_type ) ; next_tiff_frame : if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( tiff_status == - 1 ) { status = MagickFalse ; break ; } if ( photometric == PHOTOMETRIC_CIELAB ) DecodeLabImage ( image , exception ) ; if ( ( photometric == PHOTOMETRIC_LOGL ) || ( photometric == PHOTOMETRIC_MINISBLACK ) || ( photometric == PHOTOMETRIC_MINISWHITE ) ) { image -> type = GrayscaleType ; if ( bits_per_sample == 1 ) image -> type = BilevelType ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; more_frames = TIFFReadDirectory ( tiff ) != 0 ? MagickTrue : MagickFalse ; if ( more_frames != MagickFalse ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } } while ( ( status != MagickFalse ) && ( more_frames != MagickFalse ) ) ; TIFFClose ( tiff ) ; if ( ( image_info -> number_scenes != 0 ) && ( image_info -> scene >= GetImageListLength ( image ) ) ) status = MagickFalse ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; TIFFReadPhotoshopLayers ( image_info , image , exception ) ; return ( GetFirstImageInList ( image ) ) ; }", "target": "<S2SV_ModStart> , message ) \\\\\\n{ <S2SV_ModEnd> if ( pixel_info <S2SV_ModStart> message ) ; \\\\\\n} <S2SV_ModEnd> const char * <S2SV_ModStart> 4 * ( ( image -> depth + 7 ) / 8 ) * ("}
{"source": "CWE-269 struct nft_flow_rule * nft_flow_rule_create ( struct net * net , const struct nft_rule * rule ) { struct nft_offload_ctx * ctx ; struct nft_flow_rule * flow ; int num_actions = 0 , err ; struct nft_expr * expr ; expr = nft_expr_first ( rule ) ; while ( nft_expr_more ( rule , expr ) ) { <S2SV_StartBug> if ( expr -> ops -> offload_flags & NFT_OFFLOAD_F_ACTION ) <S2SV_EndBug> num_actions ++ ; expr = nft_expr_next ( expr ) ; } if ( num_actions == 0 ) return ERR_PTR ( - EOPNOTSUPP ) ; flow = nft_flow_rule_alloc ( num_actions ) ; if ( ! flow ) return ERR_PTR ( - ENOMEM ) ; expr = nft_expr_first ( rule ) ; ctx = kzalloc ( sizeof ( struct nft_offload_ctx ) , GFP_KERNEL ) ; if ( ! ctx ) { err = - ENOMEM ; goto err_out ; } ctx -> net = net ; ctx -> dep . type = NFT_OFFLOAD_DEP_UNSPEC ; while ( nft_expr_more ( rule , expr ) ) { if ( ! expr -> ops -> offload ) { err = - EOPNOTSUPP ; goto err_out ; } err = expr -> ops -> offload ( ctx , flow , expr ) ; if ( err < 0 ) goto err_out ; expr = nft_expr_next ( expr ) ; } nft_flow_rule_transfer_vlan ( ctx , flow ) ; flow -> proto = ctx -> dep . l3num ; kfree ( ctx ) ; return flow ; err_out : kfree ( ctx ) ; nft_flow_rule_destroy ( flow ) ; return ERR_PTR ( err ) ; }", "target": "<S2SV_ModStart> -> ops -> offload_action && expr -> ops -> offload_action ( expr ) <S2SV_ModEnd> ) num_actions ++"}
{"source": "CWE-668 addBinding ( XML_Parser parser , PREFIX * prefix , const ATTRIBUTE_ID * attId , const XML_Char * uri , BINDING * * bindingsPtr ) { static const XML_Char xmlNamespace [ ] = { ASCII_h , ASCII_t , ASCII_t , ASCII_p , ASCII_COLON , ASCII_SLASH , ASCII_SLASH , ASCII_w , ASCII_w , ASCII_w , ASCII_PERIOD , ASCII_w , ASCII_3 , ASCII_PERIOD , ASCII_o , ASCII_r , ASCII_g , ASCII_SLASH , ASCII_X , ASCII_M , ASCII_L , ASCII_SLASH , ASCII_1 , ASCII_9 , ASCII_9 , ASCII_8 , ASCII_SLASH , ASCII_n , ASCII_a , ASCII_m , ASCII_e , ASCII_s , ASCII_p , ASCII_a , ASCII_c , ASCII_e , '\\\\0' } ; static const int xmlLen = ( int ) sizeof ( xmlNamespace ) / sizeof ( XML_Char ) - 1 ; static const XML_Char xmlnsNamespace [ ] = { ASCII_h , ASCII_t , ASCII_t , ASCII_p , ASCII_COLON , ASCII_SLASH , ASCII_SLASH , ASCII_w , ASCII_w , ASCII_w , ASCII_PERIOD , ASCII_w , ASCII_3 , ASCII_PERIOD , ASCII_o , ASCII_r , ASCII_g , ASCII_SLASH , ASCII_2 , ASCII_0 , ASCII_0 , ASCII_0 , ASCII_SLASH , ASCII_x , ASCII_m , ASCII_l , ASCII_n , ASCII_s , ASCII_SLASH , '\\\\0' } ; static const int xmlnsLen = ( int ) sizeof ( xmlnsNamespace ) / sizeof ( XML_Char ) - 1 ; XML_Bool mustBeXML = XML_FALSE ; XML_Bool isXML = XML_TRUE ; XML_Bool isXMLNS = XML_TRUE ; BINDING * b ; int len ; if ( * uri == XML_T ( '\\\\0' ) && prefix -> name ) return XML_ERROR_UNDECLARING_PREFIX ; if ( prefix -> name && prefix -> name [ 0 ] == XML_T ( ASCII_x ) && prefix -> name [ 1 ] == XML_T ( ASCII_m ) && prefix -> name [ 2 ] == XML_T ( ASCII_l ) ) { if ( prefix -> name [ 3 ] == XML_T ( ASCII_n ) && prefix -> name [ 4 ] == XML_T ( ASCII_s ) && prefix -> name [ 5 ] == XML_T ( '\\\\0' ) ) return XML_ERROR_RESERVED_PREFIX_XMLNS ; if ( prefix -> name [ 3 ] == XML_T ( '\\\\0' ) ) mustBeXML = XML_TRUE ; } for ( len = 0 ; uri [ len ] ; len ++ ) { if ( isXML && ( len > xmlLen || uri [ len ] != xmlNamespace [ len ] ) ) isXML = XML_FALSE ; if ( ! mustBeXML && isXMLNS && ( len > xmlnsLen || uri [ len ] != xmlnsNamespace [ len ] ) ) isXMLNS = XML_FALSE ; <S2SV_StartBug> } <S2SV_EndBug> isXML = isXML && len == xmlLen ; isXMLNS = isXMLNS && len == xmlnsLen ; if ( mustBeXML != isXML ) return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML : XML_ERROR_RESERVED_NAMESPACE_URI ; if ( isXMLNS ) return XML_ERROR_RESERVED_NAMESPACE_URI ; if ( parser -> m_namespaceSeparator ) len ++ ; if ( parser -> m_freeBindingList ) { b = parser -> m_freeBindingList ; if ( len > b -> uriAlloc ) { if ( len > INT_MAX - EXPAND_SPARE ) { return XML_ERROR_NO_MEMORY ; } # if UINT_MAX >= SIZE_MAX if ( ( unsigned ) ( len + EXPAND_SPARE ) > ( size_t ) ( - 1 ) / sizeof ( XML_Char ) ) { return XML_ERROR_NO_MEMORY ; } # endif XML_Char * temp = ( XML_Char * ) REALLOC ( parser , b -> uri , sizeof ( XML_Char ) * ( len + EXPAND_SPARE ) ) ; if ( temp == NULL ) return XML_ERROR_NO_MEMORY ; b -> uri = temp ; b -> uriAlloc = len + EXPAND_SPARE ; } parser -> m_freeBindingList = b -> nextTagBinding ; } else { b = ( BINDING * ) MALLOC ( parser , sizeof ( BINDING ) ) ; if ( ! b ) return XML_ERROR_NO_MEMORY ; if ( len > INT_MAX - EXPAND_SPARE ) { return XML_ERROR_NO_MEMORY ; } # if UINT_MAX >= SIZE_MAX if ( ( unsigned ) ( len + EXPAND_SPARE ) > ( size_t ) ( - 1 ) / sizeof ( XML_Char ) ) { return XML_ERROR_NO_MEMORY ; } # endif b -> uri = ( XML_Char * ) MALLOC ( parser , sizeof ( XML_Char ) * ( len + EXPAND_SPARE ) ) ; if ( ! b -> uri ) { FREE ( parser , b ) ; return XML_ERROR_NO_MEMORY ; } b -> uriAlloc = len + EXPAND_SPARE ; } b -> uriLen = len ; memcpy ( b -> uri , uri , len * sizeof ( XML_Char ) ) ; if ( parser -> m_namespaceSeparator ) b -> uri [ len - 1 ] = parser -> m_namespaceSeparator ; b -> prefix = prefix ; b -> attId = attId ; b -> prevPrefixBinding = prefix -> binding ; if ( * uri == XML_T ( '\\\\0' ) && prefix == & parser -> m_dtd -> defaultPrefix ) prefix -> binding = NULL ; else prefix -> binding = b ; b -> nextTagBinding = * bindingsPtr ; * bindingsPtr = b ; if ( attId && parser -> m_startNamespaceDeclHandler ) parser -> m_startNamespaceDeclHandler ( parser -> m_handlerArg , prefix -> name , prefix -> binding ? uri : 0 ) ; return XML_ERROR_NONE ; }", "target": "<S2SV_ModStart> = XML_FALSE ; if ( parser -> m_ns && ( uri [ len ] == parser -> m_namespaceSeparator ) ) { return XML_ERROR_SYNTAX ; }"}
{"source": "CWE-125 jas_image_t * jp2_decode ( jas_stream_t * in , const char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; JAS_DBGLOG ( 100 , ( \"jp2_decode(%p,<S2SV_blank>\\\\\"%s\\\\\")\\\\n\" , in , optstr ) ) ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect<S2SV_blank>magic<S2SV_blank>number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( \"got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\\\n\" , box -> info -> name ) ; } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\\\n\" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( \"error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\\\n\" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( \"error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; for ( i = 1 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( \"error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\\\n\" ) ; goto error ; } if ( dec -> bpcc ) { if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\\n\" ) ; } if ( ! samedtype ) { for ( i = 0 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( \"warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\\\n\" ) ; } } } else { jas_eprintf ( \"warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\\\n\" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\\\n\" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( \"error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\\\n\" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( \"ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\\\n\" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; assert ( dec -> image -> cmprof_ ) ; jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( \"warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\\\n\" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\\\n\" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\\\n\" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>memory\\\\n\" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # endif } } } for ( i = 0 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { <S2SV_StartBug> for ( i = 0 ; i < dec -> numchans ; ++ i ) { <S2SV_EndBug> if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( \"error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\\\n\" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( \"error:<S2SV_blank>no<S2SV_blank>components\\\\n\" ) ; goto error ; } # if 0 jas_eprintf ( \"no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\\\n\" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }", "target": "<S2SV_ModStart> < dec -> cdef -> data . cdef ."}
{"source": "CWE-703 static int ismt_access ( struct i2c_adapter * adap , u16 addr , unsigned short flags , char read_write , u8 command , int size , union i2c_smbus_data * data ) { int ret ; unsigned long time_left ; dma_addr_t dma_addr = 0 ; u8 dma_size = 0 ; enum dma_data_direction dma_direction = 0 ; struct ismt_desc * desc ; struct ismt_priv * priv = i2c_get_adapdata ( adap ) ; struct device * dev = & priv -> pci_dev -> dev ; u8 * dma_buffer = PTR_ALIGN ( & priv -> buffer [ 0 ] , 16 ) ; desc = & priv -> hw [ priv -> head ] ; memset ( priv -> buffer , 0 , sizeof ( priv -> buffer ) ) ; memset ( desc , 0 , sizeof ( struct ismt_desc ) ) ; desc -> tgtaddr_rw = ISMT_DESC_ADDR_RW ( addr , read_write ) ; memset ( priv -> log , 0 , ISMT_LOG_ENTRIES * sizeof ( u32 ) ) ; if ( likely ( pci_dev_msi_enabled ( priv -> pci_dev ) ) ) desc -> control = ISMT_DESC_INT | ISMT_DESC_FAIR ; else desc -> control = ISMT_DESC_FAIR ; if ( ( flags & I2C_CLIENT_PEC ) && ( size != I2C_SMBUS_QUICK ) && ( size != I2C_SMBUS_I2C_BLOCK_DATA ) ) desc -> control |= ISMT_DESC_PEC ; switch ( size ) { case I2C_SMBUS_QUICK : dev_dbg ( dev , \"I2C_SMBUS_QUICK\\\\n\" ) ; break ; case I2C_SMBUS_BYTE : if ( read_write == I2C_SMBUS_WRITE ) { dev_dbg ( dev , \"I2C_SMBUS_BYTE:<S2SV_blank><S2SV_blank>WRITE\\\\n\" ) ; desc -> control |= ISMT_DESC_CWRL ; desc -> wr_len_cmd = command ; } else { dev_dbg ( dev , \"I2C_SMBUS_BYTE:<S2SV_blank><S2SV_blank>READ\\\\n\" ) ; dma_size = 1 ; dma_direction = DMA_FROM_DEVICE ; desc -> rd_len = 1 ; } break ; case I2C_SMBUS_BYTE_DATA : if ( read_write == I2C_SMBUS_WRITE ) { dev_dbg ( dev , \"I2C_SMBUS_BYTE_DATA:<S2SV_blank><S2SV_blank>WRITE\\\\n\" ) ; desc -> wr_len_cmd = 2 ; dma_size = 2 ; dma_direction = DMA_TO_DEVICE ; dma_buffer [ 0 ] = command ; dma_buffer [ 1 ] = data -> byte ; } else { dev_dbg ( dev , \"I2C_SMBUS_BYTE_DATA:<S2SV_blank><S2SV_blank>READ\\\\n\" ) ; desc -> control |= ISMT_DESC_CWRL ; desc -> wr_len_cmd = command ; desc -> rd_len = 1 ; dma_size = 1 ; dma_direction = DMA_FROM_DEVICE ; } break ; case I2C_SMBUS_WORD_DATA : if ( read_write == I2C_SMBUS_WRITE ) { dev_dbg ( dev , \"I2C_SMBUS_WORD_DATA:<S2SV_blank><S2SV_blank>WRITE\\\\n\" ) ; desc -> wr_len_cmd = 3 ; dma_size = 3 ; dma_direction = DMA_TO_DEVICE ; dma_buffer [ 0 ] = command ; dma_buffer [ 1 ] = data -> word & 0xff ; dma_buffer [ 2 ] = data -> word >> 8 ; } else { dev_dbg ( dev , \"I2C_SMBUS_WORD_DATA:<S2SV_blank><S2SV_blank>READ\\\\n\" ) ; desc -> wr_len_cmd = command ; desc -> control |= ISMT_DESC_CWRL ; desc -> rd_len = 2 ; dma_size = 2 ; dma_direction = DMA_FROM_DEVICE ; } break ; case I2C_SMBUS_PROC_CALL : dev_dbg ( dev , \"I2C_SMBUS_PROC_CALL\\\\n\" ) ; desc -> wr_len_cmd = 3 ; desc -> rd_len = 2 ; dma_size = 3 ; dma_direction = DMA_BIDIRECTIONAL ; dma_buffer [ 0 ] = command ; dma_buffer [ 1 ] = data -> word & 0xff ; dma_buffer [ 2 ] = data -> word >> 8 ; break ; case I2C_SMBUS_BLOCK_DATA : if ( read_write == I2C_SMBUS_WRITE ) { dev_dbg ( dev , \"I2C_SMBUS_BLOCK_DATA:<S2SV_blank><S2SV_blank>WRITE\\\\n\" ) ; dma_size = data -> block [ 0 ] + 1 ; dma_direction = DMA_TO_DEVICE ; desc -> wr_len_cmd = dma_size ; desc -> control |= ISMT_DESC_BLK ; dma_buffer [ 0 ] = command ; memcpy ( & dma_buffer [ 1 ] , & data -> block [ 1 ] , dma_size - 1 ) ; } else { dev_dbg ( dev , \"I2C_SMBUS_BLOCK_DATA:<S2SV_blank><S2SV_blank>READ\\\\n\" ) ; dma_size = I2C_SMBUS_BLOCK_MAX ; dma_direction = DMA_FROM_DEVICE ; desc -> rd_len = dma_size ; desc -> wr_len_cmd = command ; desc -> control |= ( ISMT_DESC_BLK | ISMT_DESC_CWRL ) ; } break ; case I2C_SMBUS_BLOCK_PROC_CALL : dev_dbg ( dev , \"I2C_SMBUS_BLOCK_PROC_CALL\\\\n\" ) ; <S2SV_StartBug> dma_size = I2C_SMBUS_BLOCK_MAX ; <S2SV_EndBug> desc -> tgtaddr_rw = ISMT_DESC_ADDR_RW ( addr , 1 ) ; desc -> wr_len_cmd = data -> block [ 0 ] + 1 ; desc -> rd_len = dma_size ; desc -> control |= ISMT_DESC_BLK ; dma_direction = DMA_BIDIRECTIONAL ; dma_buffer [ 0 ] = command ; memcpy ( & dma_buffer [ 1 ] , & data -> block [ 1 ] , data -> block [ 0 ] ) ; break ; case I2C_SMBUS_I2C_BLOCK_DATA : if ( data -> block [ 0 ] < 1 ) data -> block [ 0 ] = 1 ; if ( data -> block [ 0 ] > I2C_SMBUS_BLOCK_MAX ) data -> block [ 0 ] = I2C_SMBUS_BLOCK_MAX ; if ( read_write == I2C_SMBUS_WRITE ) { dev_dbg ( dev , \"I2C_SMBUS_I2C_BLOCK_DATA:<S2SV_blank><S2SV_blank>WRITE\\\\n\" ) ; dma_size = data -> block [ 0 ] + 1 ; dma_direction = DMA_TO_DEVICE ; desc -> wr_len_cmd = dma_size ; desc -> control |= ISMT_DESC_I2C ; dma_buffer [ 0 ] = command ; memcpy ( & dma_buffer [ 1 ] , & data -> block [ 1 ] , dma_size - 1 ) ; } else { dev_dbg ( dev , \"I2C_SMBUS_I2C_BLOCK_DATA:<S2SV_blank><S2SV_blank>READ\\\\n\" ) ; dma_size = data -> block [ 0 ] ; dma_direction = DMA_FROM_DEVICE ; desc -> rd_len = dma_size ; desc -> wr_len_cmd = command ; desc -> control |= ( ISMT_DESC_I2C | ISMT_DESC_CWRL ) ; desc -> tgtaddr_rw = ISMT_DESC_ADDR_RW ( addr , 0 ) ; } break ; default : dev_err ( dev , \"Unsupported<S2SV_blank>transaction<S2SV_blank>%d\\\\n\" , size ) ; return - EOPNOTSUPP ; } if ( dma_size != 0 ) { dev_dbg ( dev , \"<S2SV_blank>dev=%p\\\\n\" , dev ) ; dev_dbg ( dev , \"<S2SV_blank>data=%p\\\\n\" , data ) ; dev_dbg ( dev , \"<S2SV_blank>dma_buffer=%p\\\\n\" , dma_buffer ) ; dev_dbg ( dev , \"<S2SV_blank>dma_size=%d\\\\n\" , dma_size ) ; dev_dbg ( dev , \"<S2SV_blank>dma_direction=%d\\\\n\" , dma_direction ) ; dma_addr = dma_map_single ( dev , dma_buffer , dma_size , dma_direction ) ; if ( dma_mapping_error ( dev , dma_addr ) ) { dev_err ( dev , \"Error<S2SV_blank>in<S2SV_blank>mapping<S2SV_blank>dma<S2SV_blank>buffer<S2SV_blank>%p\\\\n\" , dma_buffer ) ; return - EIO ; } dev_dbg ( dev , \"<S2SV_blank>dma_addr<S2SV_blank>=<S2SV_blank>%pad\\\\n\" , & dma_addr ) ; desc -> dptr_low = lower_32_bits ( dma_addr ) ; desc -> dptr_high = upper_32_bits ( dma_addr ) ; } reinit_completion ( & priv -> cmp ) ; ismt_submit_desc ( priv ) ; time_left = wait_for_completion_timeout ( & priv -> cmp , HZ * 1 ) ; if ( dma_size != 0 ) dma_unmap_single ( dev , dma_addr , dma_size , dma_direction ) ; if ( unlikely ( ! time_left ) ) { dev_err ( dev , \"completion<S2SV_blank>wait<S2SV_blank>timed<S2SV_blank>out\\\\n\" ) ; ret = - ETIMEDOUT ; goto out ; } ret = ismt_process_desc ( desc , data , priv , size , read_write ) ; out : priv -> head ++ ; priv -> head %= ISMT_DESC_ENTRIES ; return ret ; }", "target": "<S2SV_ModStart> \"I2C_SMBUS_BLOCK_PROC_CALL\\\\n\" ) ; if ( data -> block [ 0 ] > I2C_SMBUS_BLOCK_MAX ) return - EINVAL ;"}
{"source": "CWE-119 MOBI_RET mobi_parse_huffdic ( const MOBIData * m , MOBIHuffCdic * huffcdic ) { MOBI_RET ret ; const size_t offset = mobi_get_kf8offset ( m ) ; if ( m -> mh == NULL || m -> mh -> huff_rec_index == NULL || m -> mh -> huff_rec_count == NULL ) { debug_print ( \"%s\" , \"HUFF/CDIC<S2SV_blank>records<S2SV_blank>metadata<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>MOBI<S2SV_blank>header\\\\n\" ) ; return MOBI_DATA_CORRUPT ; } const size_t huff_rec_index = * m -> mh -> huff_rec_index + offset ; const size_t huff_rec_count = * m -> mh -> huff_rec_count ; if ( huff_rec_count > HUFF_RECORD_MAXCNT ) { debug_print ( \"Too<S2SV_blank>many<S2SV_blank>HUFF<S2SV_blank>record<S2SV_blank>(%zu)\\\\n\" , huff_rec_count ) ; return MOBI_DATA_CORRUPT ; } const MOBIPdbRecord * curr = mobi_get_record_by_seqnumber ( m , huff_rec_index ) ; if ( curr == NULL || huff_rec_count < 2 ) { debug_print ( \"%s\" , \"HUFF/CDIC<S2SV_blank>record<S2SV_blank>not<S2SV_blank>found\\\\n\" ) ; return MOBI_DATA_CORRUPT ; } if ( curr -> size < HUFF_RECORD_MINSIZE ) { debug_print ( \"HUFF<S2SV_blank>record<S2SV_blank>too<S2SV_blank>short<S2SV_blank>(%zu<S2SV_blank>b)\\\\n\" , curr -> size ) ; return MOBI_DATA_CORRUPT ; } ret = mobi_parse_huff ( huffcdic , curr ) ; if ( ret != MOBI_SUCCESS ) { debug_print ( \"%s\" , \"HUFF<S2SV_blank>parsing<S2SV_blank>failed\\\\n\" ) ; return ret ; } curr = curr -> next ; huffcdic -> symbols = malloc ( ( huff_rec_count - 1 ) * sizeof ( * huffcdic -> symbols ) ) ; if ( huffcdic -> symbols == NULL ) { debug_print ( \"%s\\\\n\" , \"Memory<S2SV_blank>allocation<S2SV_blank>failed\" ) ; return MOBI_MALLOC_FAILED ; } size_t i = 0 ; while ( i < huff_rec_count - 1 ) { if ( curr == NULL ) { debug_print ( \"%s\\\\n\" , \"CDIC<S2SV_blank>record<S2SV_blank>not<S2SV_blank>found\" ) ; return MOBI_DATA_CORRUPT ; } ret = mobi_parse_cdic ( huffcdic , curr , i ++ ) ; if ( ret != MOBI_SUCCESS ) { debug_print ( \"%s\" , \"CDIC<S2SV_blank>parsing<S2SV_blank>failed\\\\n\" ) ; return ret ; } curr = curr -> next ; } <S2SV_StartBug> return MOBI_SUCCESS ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> next ; } if ( huffcdic -> index_count != huffcdic -> index_read ) { debug_print ( \"CDIC:<S2SV_blank>wrong<S2SV_blank>read<S2SV_blank>index<S2SV_blank>count:<S2SV_blank>%zu,<S2SV_blank>total:<S2SV_blank>%zu\\\\n\" , huffcdic -> index_read , huffcdic -> index_count ) ; return MOBI_DATA_CORRUPT ; }"}
{"source": "CWE-787 disable_priv_mode ( ) { int e ; <S2SV_StartBug> <S2SV_EndBug> <S2SV_StartBug> if ( setuid ( current_user . uid ) < 0 ) <S2SV_EndBug> { e = errno ; sys_error ( _ ( \"cannot<S2SV_blank>set<S2SV_blank>uid<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>effective<S2SV_blank>uid<S2SV_blank>%d\" ) , current_user . uid , current_user . euid ) ; # if defined ( EXIT_ON_SETUID_FAILURE ) if ( e == EAGAIN ) exit ( e ) ; # endif } <S2SV_StartBug> if ( setgid ( current_user . gid ) < 0 ) <S2SV_EndBug> sys_error ( _ ( \"cannot<S2SV_blank>set<S2SV_blank>gid<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>effective<S2SV_blank>gid<S2SV_blank>%d\" ) , current_user . gid , current_user . egid ) ; current_user . euid = current_user . uid ; current_user . egid = current_user . gid ; }", "target": "<S2SV_ModStart> int e ; # if HAVE_DECL_SETRESUID if ( setresuid ( current_user . uid , current_user . uid , current_user . uid ) < 0 ) # else <S2SV_ModStart> < 0 ) # endif <S2SV_ModStart> # endif } # if HAVE_DECL_SETRESGID if ( setresgid ( current_user . gid , current_user . gid , current_user . gid ) < 0 ) # else <S2SV_ModStart> < 0 ) # endif"}
{"source": "CWE-119 static size_t handle_returned_header ( void * ptr , size_t size , size_t nmemb , void * stream ) { auth_client * auth_user = stream ; <S2SV_StartBug> size_t bytes = size * nmemb ; <S2SV_EndBug> client_t * client = auth_user -> client ; if ( client ) { auth_t * auth = client -> auth ; auth_url * url = auth -> state ; <S2SV_StartBug> if ( strncasecmp ( ptr , url -> auth_header , url -> auth_header_len ) == 0 ) <S2SV_EndBug> client -> authenticated = 1 ; <S2SV_StartBug> if ( strncasecmp ( ptr , url -> timelimit_header , url -> timelimit_header_len ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> unsigned int limit = 0 ; <S2SV_StartBug> sscanf ( ( char * ) ptr + url -> timelimit_header_len , \"%u\\\\r\\\\n\" , & limit ) ; <S2SV_EndBug> client -> con -> discon_time = time ( NULL ) + limit ; } <S2SV_StartBug> if ( strncasecmp ( ptr , \"icecast-auth-message:<S2SV_blank>\" , 22 ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> char * eol ; <S2SV_StartBug> snprintf ( url -> errormsg , sizeof ( url -> errormsg ) , \"%s\" , ( char * ) ptr + 22 ) ; <S2SV_EndBug> <S2SV_StartBug> eol = strchr ( url -> errormsg , '\\\\r' ) ; <S2SV_EndBug> if ( eol == NULL ) <S2SV_StartBug> eol = strchr ( url -> errormsg , '\\\\n' ) ; <S2SV_EndBug> if ( eol ) * eol = '\\\\0' ; } } <S2SV_StartBug> return bytes ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> stream ; size_t len <S2SV_ModEnd> = size * <S2SV_ModStart> -> state ; if ( url -> auth_header && len >= url -> auth_header_len && <S2SV_ModEnd> strncasecmp ( ptr <S2SV_ModStart> = 1 ; if ( url -> timelimit_header && len > url -> timelimit_header_len && <S2SV_ModEnd> strncasecmp ( ptr <S2SV_ModStart> == 0 ) { const char * input = ptr ; <S2SV_ModEnd> unsigned int limit <S2SV_ModStart> = 0 ; if ( len >= 2 && input [ len - 2 ] == '\\\\r' && input [ len - 1 ] == '\\\\n' ) { input += url -> timelimit_header_len ; if ( sscanf ( input <S2SV_ModEnd> , \"%u\\\\r\\\\n\" , <S2SV_ModStart> & limit ) == 1 ) { <S2SV_ModEnd> client -> con <S2SV_ModStart> limit ; } else { ICECAST_LOG_ERROR ( \"Auth<S2SV_blank>backend<S2SV_blank>returned<S2SV_blank>invalid<S2SV_blank>timeline<S2SV_blank>header:<S2SV_blank>Can<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>limit\" ) ; } } else { ICECAST_LOG_ERROR ( \"Auth<S2SV_blank>backend<S2SV_blank>returned<S2SV_blank>invalid<S2SV_blank>timelimit<S2SV_blank>header.\" ) ; } } if ( len > 24 && <S2SV_ModEnd> strncasecmp ( ptr <S2SV_ModStart> == 0 ) { const char * input = ptr ; size_t copy_len = len - 24 + 1 ; if ( copy_len > sizeof <S2SV_ModEnd> ( url -> <S2SV_ModStart> url -> errormsg ) ) { copy_len = <S2SV_ModEnd> sizeof ( url <S2SV_ModStart> -> errormsg ) ; } if ( len >= 2 && input [ len - 2 ] == '\\\\r' && input [ len - 1 ] == '\\\\n' ) { input += 22 ; memcpy <S2SV_ModEnd> ( url -> <S2SV_ModStart> -> errormsg , input , copy_len ) ; <S2SV_ModEnd> url -> errormsg <S2SV_ModStart> url -> errormsg [ copy_len - 1 ] = 0 ; } else { ICECAST_LOG_ERROR ( \"Auth<S2SV_blank>backend<S2SV_blank>returned<S2SV_blank>invalid<S2SV_blank>message<S2SV_blank>header.\" ) ; } <S2SV_ModEnd> } } return <S2SV_ModStart> } } return len <S2SV_ModEnd> ; }"}
{"source": "CWE-703 http_isfiltered ( const struct http * fm , unsigned u , unsigned how ) { const char * e ; const struct http_hdrflg * f ; if ( fm -> hdf [ u ] & HDF_FILTER ) <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> e = strchr ( fm -> hd [ u ] . b , ':' ) ; if ( e == NULL ) return ( 0 ) ; f = http_hdr_flags ( fm -> hd [ u ] . b , e ) ; return ( f != NULL && f -> flag & how ) ; }", "target": "<S2SV_ModStart> return ( 1 ) ; if ( u < HTTP_HDR_FIRST ) return ( 0"}
{"source": "CWE-416 static int tc_new_tfilter ( struct sk_buff * skb , struct nlmsghdr * n , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( skb -> sk ) ; struct nlattr * tca [ TCA_MAX + 1 ] ; char name [ IFNAMSIZ ] ; struct tcmsg * t ; u32 protocol ; u32 prio ; bool prio_allocate ; u32 parent ; u32 chain_index ; <S2SV_StartBug> struct Qdisc * q = NULL ; <S2SV_EndBug> struct tcf_chain_info chain_info ; <S2SV_StartBug> struct tcf_chain * chain = NULL ; <S2SV_EndBug> struct tcf_block * block ; struct tcf_proto * tp ; unsigned long cl ; void * fh ; int err ; int tp_created ; bool rtnl_held = false ; u32 flags ; if ( ! netlink_ns_capable ( skb , net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; replay : tp_created = 0 ; err = nlmsg_parse_deprecated ( n , sizeof ( * t ) , tca , TCA_MAX , rtm_tca_policy , extack ) ; if ( err < 0 ) return err ; t = nlmsg_data ( n ) ; protocol = TC_H_MIN ( t -> tcm_info ) ; prio = TC_H_MAJ ( t -> tcm_info ) ; prio_allocate = false ; parent = t -> tcm_parent ; tp = NULL ; cl = 0 ; <S2SV_StartBug> block = NULL ; <S2SV_EndBug> flags = 0 ; if ( prio == 0 ) { if ( n -> nlmsg_flags & NLM_F_CREATE ) { prio = TC_H_MAKE ( 0x80000000U , 0U ) ; prio_allocate = true ; } else { NL_SET_ERR_MSG ( extack , \"Invalid<S2SV_blank>filter<S2SV_blank>command<S2SV_blank>with<S2SV_blank>priority<S2SV_blank>of<S2SV_blank>zero\" ) ; return - ENOENT ; } } err = __tcf_qdisc_find ( net , & q , & parent , t -> tcm_ifindex , false , extack ) ; if ( err ) return err ; if ( tcf_proto_check_kind ( tca [ TCA_KIND ] , name ) ) { NL_SET_ERR_MSG ( extack , \"Specified<S2SV_blank>TC<S2SV_blank>filter<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\" ) ; err = - EINVAL ; goto errout ; } if ( rtnl_held || ( q && ! ( q -> ops -> cl_ops -> flags & QDISC_CLASS_OPS_DOIT_UNLOCKED ) ) || ! tcf_proto_is_unlocked ( name ) ) { rtnl_held = true ; rtnl_lock ( ) ; } err = __tcf_qdisc_cl_find ( q , parent , & cl , t -> tcm_ifindex , extack ) ; if ( err ) goto errout ; block = __tcf_block_find ( net , q , cl , t -> tcm_ifindex , t -> tcm_block_index , extack ) ; if ( IS_ERR ( block ) ) { err = PTR_ERR ( block ) ; goto errout ; } block -> classid = parent ; chain_index = tca [ TCA_CHAIN ] ? nla_get_u32 ( tca [ TCA_CHAIN ] ) : 0 ; if ( chain_index > TC_ACT_EXT_VAL_MASK ) { NL_SET_ERR_MSG ( extack , \"Specified<S2SV_blank>chain<S2SV_blank>index<S2SV_blank>exceeds<S2SV_blank>upper<S2SV_blank>limit\" ) ; err = - EINVAL ; goto errout ; } chain = tcf_chain_get ( block , chain_index , true ) ; if ( ! chain ) { NL_SET_ERR_MSG ( extack , \"Cannot<S2SV_blank>create<S2SV_blank>specified<S2SV_blank>filter<S2SV_blank>chain\" ) ; err = - ENOMEM ; goto errout ; } mutex_lock ( & chain -> filter_chain_lock ) ; tp = tcf_chain_tp_find ( chain , & chain_info , protocol , prio , prio_allocate ) ; if ( IS_ERR ( tp ) ) { NL_SET_ERR_MSG ( extack , \"Filter<S2SV_blank>with<S2SV_blank>specified<S2SV_blank>priority/protocol<S2SV_blank>not<S2SV_blank>found\" ) ; err = PTR_ERR ( tp ) ; goto errout_locked ; } if ( tp == NULL ) { struct tcf_proto * tp_new = NULL ; if ( chain -> flushing ) { err = - EAGAIN ; goto errout_locked ; } if ( tca [ TCA_KIND ] == NULL || ! protocol ) { NL_SET_ERR_MSG ( extack , \"Filter<S2SV_blank>kind<S2SV_blank>and<S2SV_blank>protocol<S2SV_blank>must<S2SV_blank>be<S2SV_blank>specified\" ) ; err = - EINVAL ; goto errout_locked ; } if ( ! ( n -> nlmsg_flags & NLM_F_CREATE ) ) { NL_SET_ERR_MSG ( extack , \"Need<S2SV_blank>both<S2SV_blank>RTM_NEWTFILTER<S2SV_blank>and<S2SV_blank>NLM_F_CREATE<S2SV_blank>to<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>filter\" ) ; err = - ENOENT ; goto errout_locked ; } if ( prio_allocate ) prio = tcf_auto_prio ( tcf_chain_tp_prev ( chain , & chain_info ) ) ; mutex_unlock ( & chain -> filter_chain_lock ) ; tp_new = tcf_proto_create ( name , protocol , prio , chain , rtnl_held , extack ) ; if ( IS_ERR ( tp_new ) ) { err = PTR_ERR ( tp_new ) ; goto errout_tp ; } tp_created = 1 ; tp = tcf_chain_tp_insert_unique ( chain , tp_new , protocol , prio , rtnl_held ) ; if ( IS_ERR ( tp ) ) { err = PTR_ERR ( tp ) ; goto errout_tp ; } } else { mutex_unlock ( & chain -> filter_chain_lock ) ; } if ( tca [ TCA_KIND ] && nla_strcmp ( tca [ TCA_KIND ] , tp -> ops -> kind ) ) { NL_SET_ERR_MSG ( extack , \"Specified<S2SV_blank>filter<S2SV_blank>kind<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>existing<S2SV_blank>one\" ) ; err = - EINVAL ; goto errout ; } fh = tp -> ops -> get ( tp , t -> tcm_handle ) ; if ( ! fh ) { if ( ! ( n -> nlmsg_flags & NLM_F_CREATE ) ) { NL_SET_ERR_MSG ( extack , \"Need<S2SV_blank>both<S2SV_blank>RTM_NEWTFILTER<S2SV_blank>and<S2SV_blank>NLM_F_CREATE<S2SV_blank>to<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>filter\" ) ; err = - ENOENT ; goto errout ; } } else if ( n -> nlmsg_flags & NLM_F_EXCL ) { tfilter_put ( tp , fh ) ; NL_SET_ERR_MSG ( extack , \"Filter<S2SV_blank>already<S2SV_blank>exists\" ) ; err = - EEXIST ; goto errout ; } if ( chain -> tmplt_ops && chain -> tmplt_ops != tp -> ops ) { NL_SET_ERR_MSG ( extack , \"Chain<S2SV_blank>template<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>a<S2SV_blank>different<S2SV_blank>filter<S2SV_blank>kind\" ) ; err = - EINVAL ; goto errout ; } if ( ! ( n -> nlmsg_flags & NLM_F_CREATE ) ) flags |= TCA_ACT_FLAGS_REPLACE ; if ( ! rtnl_held ) flags |= TCA_ACT_FLAGS_NO_RTNL ; err = tp -> ops -> change ( net , skb , tp , cl , t -> tcm_handle , tca , & fh , flags , extack ) ; if ( err == 0 ) { tfilter_notify ( net , skb , n , tp , block , q , parent , fh , RTM_NEWTFILTER , false , rtnl_held ) ; tfilter_put ( tp , fh ) ; if ( q ) q -> flags &= ~ TCQ_F_CAN_BYPASS ; } errout : if ( err && tp_created ) tcf_chain_tp_delete_empty ( chain , tp , rtnl_held , NULL ) ; errout_tp : if ( chain ) { if ( tp && ! IS_ERR ( tp ) ) tcf_proto_put ( tp , rtnl_held , NULL ) ; if ( ! tp_created ) tcf_chain_put ( chain ) ; } tcf_block_release ( q , block , rtnl_held ) ; if ( rtnl_held ) rtnl_unlock ( ) ; if ( err == - EAGAIN ) { rtnl_held = true ; goto replay ; } return err ; errout_locked : mutex_unlock ( & chain -> filter_chain_lock ) ; goto errout ; }", "target": "<S2SV_ModStart> Qdisc * q <S2SV_ModEnd> ; struct tcf_chain_info <S2SV_ModStart> tcf_chain * chain <S2SV_ModEnd> ; struct tcf_block <S2SV_ModStart> 0 ; block = NULL ; q = NULL ; chain"}
{"source": "CWE-416 do_tag ( char_u * tag , int type , int count , int forceit , int verbose ) { taggy_T * tagstack = curwin -> w_tagstack ; int tagstackidx = curwin -> w_tagstackidx ; int tagstacklen = curwin -> w_tagstacklen ; int cur_match = 0 ; int cur_fnum = curbuf -> b_fnum ; int oldtagstackidx = tagstackidx ; int prevtagstackidx = tagstackidx ; int prev_num_matches ; int new_tag = FALSE ; int i ; int ic ; int no_regexp = FALSE ; int error_cur_match = 0 ; int save_pos = FALSE ; fmark_T saved_fmark ; # ifdef FEAT_CSCOPE int jumped_to_tag = FALSE ; # endif int new_num_matches ; char_u * * new_matches ; int use_tagstack ; int skip_msg = FALSE ; char_u * buf_ffname = curbuf -> b_ffname ; int use_tfu = 1 ; char_u * tofree = NULL ; static int num_matches = 0 ; static int max_num_matches = 0 ; static char_u * * matches = NULL ; static int flags ; # ifdef FEAT_EVAL if ( tfu_in_use ) { emsg ( _ ( e_cannot_modify_tag_stack_within_tagfunc ) ) ; return FALSE ; } # endif # ifdef EXITFREE if ( type == DT_FREE ) { FreeWild ( num_matches , matches ) ; # ifdef FEAT_CSCOPE cs_free_tags ( ) ; # endif num_matches = 0 ; return FALSE ; } # endif if ( type == DT_HELP ) { type = DT_TAG ; no_regexp = TRUE ; use_tfu = 0 ; } prev_num_matches = num_matches ; free_string_option ( nofile_fname ) ; nofile_fname = NULL ; CLEAR_POS ( & saved_fmark . mark ) ; saved_fmark . fnum = 0 ; if ( ( ! p_tgst && * tag != NUL ) ) { use_tagstack = FALSE ; new_tag = TRUE ; # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) { tagstack_clear_entry ( & ptag_entry ) ; if ( ( ptag_entry . tagname = vim_strsave ( tag ) ) == NULL ) goto end_do_tag ; } # endif } else { # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) use_tagstack = FALSE ; else # endif use_tagstack = TRUE ; if ( * tag != NUL && ( type == DT_TAG || type == DT_SELECT || type == DT_JUMP # ifdef FEAT_QUICKFIX || type == DT_LTAG # endif # ifdef FEAT_CSCOPE || type == DT_CSCOPE # endif ) ) { # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) { if ( ptag_entry . tagname != NULL && STRCMP ( ptag_entry . tagname , tag ) == 0 ) { cur_match = ptag_entry . cur_match ; cur_fnum = ptag_entry . cur_fnum ; } else { tagstack_clear_entry ( & ptag_entry ) ; if ( ( ptag_entry . tagname = vim_strsave ( tag ) ) == NULL ) goto end_do_tag ; } } else # endif { while ( tagstackidx < tagstacklen ) tagstack_clear_entry ( & tagstack [ -- tagstacklen ] ) ; if ( ++ tagstacklen > TAGSTACKSIZE ) { tagstacklen = TAGSTACKSIZE ; tagstack_clear_entry ( & tagstack [ 0 ] ) ; for ( i = 1 ; i < tagstacklen ; ++ i ) tagstack [ i - 1 ] = tagstack [ i ] ; -- tagstackidx ; } if ( ( tagstack [ tagstackidx ] . tagname = vim_strsave ( tag ) ) == NULL ) { curwin -> w_tagstacklen = tagstacklen - 1 ; goto end_do_tag ; } curwin -> w_tagstacklen = tagstacklen ; save_pos = TRUE ; } new_tag = TRUE ; } else { if ( # if defined ( FEAT_QUICKFIX ) g_do_tagpreview != 0 ? ptag_entry . tagname == NULL : # endif tagstacklen == 0 ) { emsg ( _ ( e_tag_stack_empty ) ) ; goto end_do_tag ; } if ( type == DT_POP ) { # ifdef FEAT_FOLDING int old_KeyTyped = KeyTyped ; # endif if ( ( tagstackidx -= count ) < 0 ) { emsg ( _ ( e_at_bottom_of_tag_stack ) ) ; if ( tagstackidx + count == 0 ) { tagstackidx = 0 ; goto end_do_tag ; } tagstackidx = 0 ; } else if ( tagstackidx >= tagstacklen ) { emsg ( _ ( e_at_top_of_tag_stack ) ) ; goto end_do_tag ; } saved_fmark = tagstack [ tagstackidx ] . fmark ; if ( saved_fmark . fnum != curbuf -> b_fnum ) { if ( buflist_getfile ( saved_fmark . fnum , saved_fmark . mark . lnum , GETF_SETMARK , forceit ) == FAIL ) { tagstackidx = oldtagstackidx ; goto end_do_tag ; } curwin -> w_cursor . lnum = saved_fmark . mark . lnum ; } else { setpcmark ( ) ; curwin -> w_cursor . lnum = saved_fmark . mark . lnum ; } curwin -> w_cursor . col = saved_fmark . mark . col ; curwin -> w_set_curswant = TRUE ; check_cursor ( ) ; # ifdef FEAT_FOLDING if ( ( fdo_flags & FDO_TAG ) && old_KeyTyped ) foldOpenCursor ( ) ; # endif FreeWild ( num_matches , matches ) ; # ifdef FEAT_CSCOPE cs_free_tags ( ) ; # endif num_matches = 0 ; tag_freematch ( ) ; goto end_do_tag ; } if ( type == DT_TAG # if defined ( FEAT_QUICKFIX ) || type == DT_LTAG # endif ) { # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) { cur_match = ptag_entry . cur_match ; cur_fnum = ptag_entry . cur_fnum ; } else # endif { save_pos = TRUE ; if ( ( tagstackidx += count - 1 ) >= tagstacklen ) { tagstackidx = tagstacklen - 1 ; emsg ( _ ( e_at_top_of_tag_stack ) ) ; save_pos = FALSE ; } else if ( tagstackidx < 0 ) { emsg ( _ ( e_at_bottom_of_tag_stack ) ) ; tagstackidx = 0 ; goto end_do_tag ; } cur_match = tagstack [ tagstackidx ] . cur_match ; cur_fnum = tagstack [ tagstackidx ] . cur_fnum ; } new_tag = TRUE ; } else { prevtagstackidx = tagstackidx ; # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) { cur_match = ptag_entry . cur_match ; cur_fnum = ptag_entry . cur_fnum ; } else # endif { if ( -- tagstackidx < 0 ) tagstackidx = 0 ; cur_match = tagstack [ tagstackidx ] . cur_match ; cur_fnum = tagstack [ tagstackidx ] . cur_fnum ; } switch ( type ) { case DT_FIRST : cur_match = count - 1 ; break ; case DT_SELECT : case DT_JUMP : # ifdef FEAT_CSCOPE case DT_CSCOPE : # endif case DT_LAST : cur_match = MAXCOL - 1 ; break ; case DT_NEXT : cur_match += count ; break ; case DT_PREV : cur_match -= count ; break ; } if ( cur_match >= MAXCOL ) cur_match = MAXCOL - 1 ; else if ( cur_match < 0 ) { emsg ( _ ( e_cannot_go_before_first_matching_tag ) ) ; skip_msg = TRUE ; cur_match = 0 ; cur_fnum = curbuf -> b_fnum ; } } } # if defined ( FEAT_QUICKFIX ) if ( g_do_tagpreview != 0 ) { if ( type != DT_SELECT && type != DT_JUMP ) { ptag_entry . cur_match = cur_match ; ptag_entry . cur_fnum = cur_fnum ; } } else # endif { saved_fmark = tagstack [ tagstackidx ] . fmark ; if ( save_pos ) { tagstack [ tagstackidx ] . fmark . mark = curwin -> w_cursor ; tagstack [ tagstackidx ] . fmark . fnum = curbuf -> b_fnum ; } curwin -> w_tagstackidx = tagstackidx ; if ( type != DT_SELECT && type != DT_JUMP ) { curwin -> w_tagstack [ tagstackidx ] . cur_match = cur_match ; curwin -> w_tagstack [ tagstackidx ] . cur_fnum = cur_fnum ; } } } if ( cur_fnum != curbuf -> b_fnum ) { buf_T * buf = buflist_findnr ( cur_fnum ) ; if ( buf != NULL ) buf_ffname = buf -> b_ffname ; } for ( ; ; ) { int other_name ; char_u * name ; if ( use_tagstack ) { name = vim_strsave ( tagstack [ tagstackidx ] . tagname ) ; vim_free ( tofree ) ; tofree = name ; } # if defined ( FEAT_QUICKFIX ) else if ( g_do_tagpreview != 0 ) name = ptag_entry . tagname ; # endif else name = tag ; other_name = ( tagmatchname == NULL || STRCMP ( tagmatchname , name ) != 0 ) ; if ( new_tag || ( cur_match >= num_matches && max_num_matches != MAXCOL ) || other_name ) { if ( other_name ) { vim_free ( tagmatchname ) ; tagmatchname = vim_strsave ( name ) ; } if ( type == DT_SELECT || type == DT_JUMP # if defined ( FEAT_QUICKFIX ) || type == DT_LTAG # endif ) cur_match = MAXCOL - 1 ; if ( type == DT_TAG ) max_num_matches = MAXCOL ; else max_num_matches = cur_match + 1 ; if ( ! no_regexp && * name == '/' ) { flags = TAG_REGEXP ; ++ name ; } else flags = TAG_NOIC ; # ifdef FEAT_CSCOPE if ( type == DT_CSCOPE ) flags = TAG_CSCOPE ; # endif if ( verbose ) flags |= TAG_VERBOSE ; if ( ! use_tfu ) flags |= TAG_NO_TAGFUNC ; if ( find_tags ( name , & new_num_matches , & new_matches , flags , max_num_matches , buf_ffname ) == OK && new_num_matches < max_num_matches ) max_num_matches = MAXCOL ; <S2SV_StartBug> if ( ! new_tag && ! other_name ) <S2SV_EndBug> { int j , k ; int idx = 0 ; tagptrs_T tagp , tagp2 ; for ( j = 0 ; j < num_matches ; ++ j ) { parse_match ( matches [ j ] , & tagp ) ; for ( i = idx ; i < new_num_matches ; ++ i ) { parse_match ( new_matches [ i ] , & tagp2 ) ; if ( STRCMP ( tagp . tagname , tagp2 . tagname ) == 0 ) { char_u * p = new_matches [ i ] ; for ( k = i ; k > idx ; -- k ) new_matches [ k ] = new_matches [ k - 1 ] ; new_matches [ idx ++ ] = p ; break ; } } } } FreeWild ( num_matches , matches ) ; num_matches = new_num_matches ; matches = new_matches ; } if ( num_matches <= 0 ) { if ( verbose ) semsg ( _ ( e_tag_not_found_str ) , name ) ; # if defined ( FEAT_QUICKFIX ) g_do_tagpreview = 0 ; # endif } else { int ask_for_selection = FALSE ; # ifdef FEAT_CSCOPE if ( type == DT_CSCOPE && num_matches > 1 ) { cs_print_tags ( ) ; ask_for_selection = TRUE ; } else # endif if ( type == DT_TAG && * tag != NUL ) cur_match = count > 0 ? count - 1 : 0 ; else if ( type == DT_SELECT || ( type == DT_JUMP && num_matches > 1 ) ) { print_tag_list ( new_tag , use_tagstack , num_matches , matches ) ; ask_for_selection = TRUE ; } # if defined ( FEAT_QUICKFIX ) && defined ( FEAT_EVAL ) else if ( type == DT_LTAG ) { if ( add_llist_tags ( tag , num_matches , matches ) == FAIL ) goto end_do_tag ; cur_match = 0 ; } # endif if ( ask_for_selection == TRUE ) { i = prompt_for_number ( NULL ) ; if ( i <= 0 || i > num_matches || got_int ) { if ( use_tagstack ) { tagstack [ tagstackidx ] . fmark = saved_fmark ; tagstackidx = prevtagstackidx ; } # ifdef FEAT_CSCOPE cs_free_tags ( ) ; jumped_to_tag = TRUE ; # endif break ; } cur_match = i - 1 ; } if ( cur_match >= num_matches ) { if ( ( type == DT_NEXT || type == DT_FIRST ) && nofile_fname == NULL ) { if ( num_matches == 1 ) emsg ( _ ( e_there_is_only_one_matching_tag ) ) ; else emsg ( _ ( e_cannot_go_beyond_last_matching_tag ) ) ; skip_msg = TRUE ; } cur_match = num_matches - 1 ; } if ( use_tagstack ) { tagptrs_T tagp ; tagstack [ tagstackidx ] . cur_match = cur_match ; tagstack [ tagstackidx ] . cur_fnum = cur_fnum ; if ( use_tfu && parse_match ( matches [ cur_match ] , & tagp ) == OK && tagp . user_data ) { VIM_CLEAR ( tagstack [ tagstackidx ] . user_data ) ; tagstack [ tagstackidx ] . user_data = vim_strnsave ( tagp . user_data , tagp . user_data_end - tagp . user_data ) ; } ++ tagstackidx ; } # if defined ( FEAT_QUICKFIX ) else if ( g_do_tagpreview != 0 ) { ptag_entry . cur_match = cur_match ; ptag_entry . cur_fnum = cur_fnum ; } # endif if ( nofile_fname != NULL && error_cur_match != cur_match ) smsg ( _ ( \"File<S2SV_blank>\\\\\"%s\\\\\"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist\" ) , nofile_fname ) ; ic = ( matches [ cur_match ] [ 0 ] & MT_IC_OFF ) ; if ( type != DT_TAG && type != DT_SELECT && type != DT_JUMP # ifdef FEAT_CSCOPE && type != DT_CSCOPE # endif && ( num_matches > 1 || ic ) && ! skip_msg ) { sprintf ( ( char * ) IObuff , _ ( \"tag<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d%s\" ) , cur_match + 1 , num_matches , max_num_matches != MAXCOL ? _ ( \"<S2SV_blank>or<S2SV_blank>more\" ) : \"\" ) ; if ( ic ) STRCAT ( IObuff , _ ( \"<S2SV_blank><S2SV_blank>Using<S2SV_blank>tag<S2SV_blank>with<S2SV_blank>different<S2SV_blank>case!\" ) ) ; if ( ( num_matches > prev_num_matches || new_tag ) && num_matches > 1 ) { if ( ic ) msg_attr ( ( char * ) IObuff , HL_ATTR ( HLF_W ) ) ; else msg ( ( char * ) IObuff ) ; msg_scroll = TRUE ; } else give_warning ( IObuff , ic ) ; if ( ic && ! msg_scrolled && msg_silent == 0 ) { out_flush ( ) ; ui_delay ( 1007L , TRUE ) ; } } # if defined ( FEAT_EVAL ) vim_snprintf ( ( char * ) IObuff , IOSIZE , \":ta<S2SV_blank>%s\\\\r\" , name ) ; set_vim_var_string ( VV_SWAPCOMMAND , IObuff , - 1 ) ; # endif i = jumpto_tag ( matches [ cur_match ] , forceit , type != DT_CSCOPE ) ; # if defined ( FEAT_EVAL ) set_vim_var_string ( VV_SWAPCOMMAND , NULL , - 1 ) ; # endif if ( i == NOTAGFILE ) { if ( ( type == DT_PREV && cur_match > 0 ) || ( ( type == DT_TAG || type == DT_NEXT || type == DT_FIRST ) && ( max_num_matches != MAXCOL || cur_match < num_matches - 1 ) ) ) { error_cur_match = cur_match ; if ( use_tagstack ) -- tagstackidx ; if ( type == DT_PREV ) -- cur_match ; else { type = DT_NEXT ; ++ cur_match ; } continue ; } semsg ( _ ( e_file_str_does_not_exist ) , nofile_fname ) ; } else { if ( use_tagstack && tagstackidx > curwin -> w_tagstacklen ) tagstackidx = curwin -> w_tagstackidx ; # ifdef FEAT_CSCOPE jumped_to_tag = TRUE ; # endif } } break ; } end_do_tag : if ( use_tagstack && tagstackidx <= curwin -> w_tagstacklen ) curwin -> w_tagstackidx = tagstackidx ; postponed_split = 0 ; # ifdef FEAT_QUICKFIX g_do_tagpreview = 0 ; # endif vim_free ( tofree ) ; # ifdef FEAT_CSCOPE return jumped_to_tag ; # else return FALSE ; # endif }", "target": "<S2SV_ModStart> ; if ( tagstack != curwin -> w_tagstack ) { emsg ( _ ( e_window_unexpectedly_close_while_searching_for_tags ) ) ; FreeWild ( new_num_matches , new_matches ) ; break ; } if ("}
{"source": "CWE-787 static int prealloc_elems_and_freelist ( struct bpf_stack_map * smap ) { <S2SV_StartBug> u32 elem_size = sizeof ( struct stack_map_bucket ) + smap -> map . value_size ; <S2SV_EndBug> int err ; smap -> elems = bpf_map_area_alloc ( elem_size * smap -> map . max_entries , smap -> map . numa_node ) ; if ( ! smap -> elems ) return - ENOMEM ; err = pcpu_freelist_init ( & smap -> freelist ) ; if ( err ) goto free_elems ; pcpu_freelist_populate ( & smap -> freelist , smap -> elems , elem_size , smap -> map . max_entries ) ; return 0 ; free_elems : bpf_map_area_free ( smap -> elems ) ; return err ; }", "target": "<S2SV_ModStart> smap ) { u64 <S2SV_ModEnd> elem_size = sizeof <S2SV_ModStart> stack_map_bucket ) + ( u64 )"}
{"source": "CWE-191 static pj_status_t decode_errcode_attr ( pj_pool_t * pool , const pj_uint8_t * buf , const pj_stun_msg_hdr * msghdr , void * * p_attr ) { pj_stun_errcode_attr * attr ; pj_str_t value ; PJ_UNUSED_ARG ( msghdr ) ; attr = PJ_POOL_ZALLOC_T ( pool , pj_stun_errcode_attr ) ; GETATTRHDR ( buf , & attr -> hdr ) ; attr -> err_code = buf [ 6 ] * 100 + buf [ 7 ] ; value . ptr = ( ( char * ) buf + ATTR_HDR_LEN + 4 ) ; value . slen = attr -> hdr . length - 4 ; <S2SV_StartBug> <S2SV_EndBug> pj_strdup ( pool , & attr -> reason , & value ) ; * p_attr = attr ; return PJ_SUCCESS ; }", "target": "<S2SV_ModStart> - 4 ; if ( value . slen < 0 ) value . slen = 0 ;"}
{"source": "CWE-787 pcl_status_read ( byte * data , uint max_data , pcl_state_t * pcs ) { uint count = min ( max_data , pcs -> status . write_pos - pcs -> status . read_pos ) ; if ( count ) memcpy ( data , pcs -> status . buffer + pcs -> status . read_pos , count ) ; pcs -> status . read_pos += count ; if ( pcs -> status . read_pos == pcs -> status . write_pos ) { gs_free_object ( pcs -> memory , pcs -> status . buffer , \"status<S2SV_blank>buffer\" ) ; <S2SV_StartBug> pcs -> status . write_pos = pcs -> status . read_pos = 0 ; <S2SV_EndBug> } return count ; }", "target": "<S2SV_ModStart> -> status . buffer = NULL ; pcs -> status ."}
{"source": "CWE-476 * / static void php_wddx_pop_element ( void * user_data , const XML_Char * name ) { st_entry * ent1 , * ent2 ; wddx_stack * stack = ( wddx_stack * ) user_data ; HashTable * target_hash ; zend_class_entry * * pce ; zval * obj ; zval * tmp ; TSRMLS_FETCH ( ) ; if ( stack -> top == 0 ) { return ; } if ( ! strcmp ( name , EL_STRING ) || ! strcmp ( name , EL_NUMBER ) || ! strcmp ( name , EL_BOOLEAN ) || ! strcmp ( name , EL_NULL ) || ! strcmp ( name , EL_ARRAY ) || ! strcmp ( name , EL_STRUCT ) || ! strcmp ( name , EL_RECORDSET ) || ! strcmp ( name , EL_BINARY ) || ! strcmp ( name , EL_DATETIME ) ) { wddx_stack_top ( stack , ( void * * ) & ent1 ) ; if ( ! ent1 -> data ) { if ( stack -> top > 1 ) { stack -> top -- ; } else { stack -> done = 1 ; } efree ( ent1 ) ; return ; } if ( ! strcmp ( name , EL_BINARY ) ) { int new_len = 0 ; unsigned char * new_str ; new_str = php_base64_decode ( Z_STRVAL_P ( ent1 -> data ) , Z_STRLEN_P ( ent1 -> data ) , & new_len ) ; STR_FREE ( Z_STRVAL_P ( ent1 -> data ) ) ; <S2SV_StartBug> Z_STRVAL_P ( ent1 -> data ) = new_str ; <S2SV_EndBug> <S2SV_StartBug> Z_STRLEN_P ( ent1 -> data ) = new_len ; <S2SV_EndBug> } if ( Z_TYPE_P ( ent1 -> data ) == IS_OBJECT ) { zval * fname , * retval = NULL ; MAKE_STD_ZVAL ( fname ) ; ZVAL_STRING ( fname , \"__wakeup\" , 1 ) ; call_user_function_ex ( NULL , & ent1 -> data , fname , & retval , 0 , 0 , 0 , NULL TSRMLS_CC ) ; zval_dtor ( fname ) ; FREE_ZVAL ( fname ) ; if ( retval ) { zval_ptr_dtor ( & retval ) ; } } if ( stack -> top > 1 ) { stack -> top -- ; wddx_stack_top ( stack , ( void * * ) & ent2 ) ; if ( ent2 -> type == ST_FIELD && ent2 -> data == NULL ) { zval_ptr_dtor ( & ent1 -> data ) ; efree ( ent1 ) ; return ; } if ( Z_TYPE_P ( ent2 -> data ) == IS_ARRAY || Z_TYPE_P ( ent2 -> data ) == IS_OBJECT ) { target_hash = HASH_OF ( ent2 -> data ) ; if ( ent1 -> varname ) { if ( ! strcmp ( ent1 -> varname , PHP_CLASS_NAME_VAR ) && Z_TYPE_P ( ent1 -> data ) == IS_STRING && Z_STRLEN_P ( ent1 -> data ) && ent2 -> type == ST_STRUCT && Z_TYPE_P ( ent2 -> data ) == IS_ARRAY ) { zend_bool incomplete_class = 0 ; zend_str_tolower ( Z_STRVAL_P ( ent1 -> data ) , Z_STRLEN_P ( ent1 -> data ) ) ; if ( zend_hash_find ( EG ( class_table ) , Z_STRVAL_P ( ent1 -> data ) , Z_STRLEN_P ( ent1 -> data ) + 1 , ( void * * ) & pce ) == FAILURE ) { incomplete_class = 1 ; pce = & PHP_IC_ENTRY ; } MAKE_STD_ZVAL ( obj ) ; object_init_ex ( obj , * pce ) ; zend_hash_merge ( Z_OBJPROP_P ( obj ) , Z_ARRVAL_P ( ent2 -> data ) , ( void ( * ) ( void * ) ) zval_add_ref , ( void * ) & tmp , sizeof ( zval * ) , 0 ) ; if ( incomplete_class ) { php_store_class_name ( obj , Z_STRVAL_P ( ent1 -> data ) , Z_STRLEN_P ( ent1 -> data ) ) ; } zval_ptr_dtor ( & ent2 -> data ) ; ent2 -> data = obj ; zval_ptr_dtor ( & ent1 -> data ) ; } else if ( Z_TYPE_P ( ent2 -> data ) == IS_OBJECT ) { zend_class_entry * old_scope = EG ( scope ) ; EG ( scope ) = Z_OBJCE_P ( ent2 -> data ) ; Z_DELREF_P ( ent1 -> data ) ; add_property_zval ( ent2 -> data , ent1 -> varname , ent1 -> data ) ; EG ( scope ) = old_scope ; } else { zend_symtable_update ( target_hash , ent1 -> varname , strlen ( ent1 -> varname ) + 1 , & ent1 -> data , sizeof ( zval * ) , NULL ) ; } efree ( ent1 -> varname ) ; } else { zend_hash_next_index_insert ( target_hash , & ent1 -> data , sizeof ( zval * ) , NULL ) ; } } efree ( ent1 ) ; } else { stack -> done = 1 ; } } else if ( ! strcmp ( name , EL_VAR ) && stack -> varname ) { efree ( stack -> varname ) ; stack -> varname = NULL ; } else if ( ! strcmp ( name , EL_FIELD ) ) { st_entry * ent ; wddx_stack_top ( stack , ( void * * ) & ent ) ; efree ( ent ) ; stack -> top -- ; }", "target": "<S2SV_ModStart> ) ) ; if ( new_str ) { <S2SV_ModStart> = new_len ; } else { ZVAL_EMPTY_STRING ( ent1 -> data ) ; }"}
{"source": "CWE-190 processDataRcvd ( ptcpsess_t * const __restrict__ pThis , char * * buff , const int buffLen , struct syslogTime * stTime , const time_t ttGenTime , multi_submit_t * pMultiSub , unsigned * const __restrict__ pnMsgs ) { DEFiRet ; char c = * * buff ; int octatesToCopy , octatesToDiscard ; if ( pThis -> inputState == eAtStrtFram ) { if ( pThis -> bSuppOctetFram && isdigit ( ( int ) c ) ) { pThis -> inputState = eInOctetCnt ; pThis -> iOctetsRemain = 0 ; pThis -> eFraming = TCP_FRAMING_OCTET_COUNTING ; } else if ( pThis -> bSPFramingFix && c == '<S2SV_blank>' ) { FINALIZE ; } else { pThis -> inputState = eInMsg ; pThis -> eFraming = TCP_FRAMING_OCTET_STUFFING ; } } if ( pThis -> inputState == eInOctetCnt ) { if ( isdigit ( c ) ) { <S2SV_StartBug> pThis -> iOctetsRemain = pThis -> iOctetsRemain * 10 + c - '0' ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> DBGPRINTF ( \"TCP<S2SV_blank>Message<S2SV_blank>with<S2SV_blank>octet-counter,<S2SV_blank>size<S2SV_blank>%d.\\\\n\" , pThis -> iOctetsRemain ) ; if ( c != '<S2SV_blank>' ) { errmsg . LogError ( 0 , NO_ERRCODE , \"Framing<S2SV_blank>Error<S2SV_blank>in<S2SV_blank>received<S2SV_blank>TCP<S2SV_blank>message:<S2SV_blank>\" <S2SV_StartBug> \"delimiter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>SP<S2SV_blank>but<S2SV_blank>has<S2SV_blank>ASCII<S2SV_blank>value<S2SV_blank>%d.\" , c ) ; <S2SV_EndBug> } if ( pThis -> iOctetsRemain < 1 ) { <S2SV_StartBug> DBGPRINTF ( \"Framing<S2SV_blank>Error:<S2SV_blank>invalid<S2SV_blank>octet<S2SV_blank>count\\\\n\" ) ; <S2SV_EndBug> errmsg . LogError ( 0 , NO_ERRCODE , \"Framing<S2SV_blank>Error<S2SV_blank>in<S2SV_blank>received<S2SV_blank>TCP<S2SV_blank>message:<S2SV_blank>\" <S2SV_StartBug> \"invalid<S2SV_blank>octet<S2SV_blank>count<S2SV_blank>%d.\" , pThis -> iOctetsRemain ) ; <S2SV_EndBug> } else if ( pThis -> iOctetsRemain > iMaxLine ) { DBGPRINTF ( \"truncating<S2SV_blank>message<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>octets<S2SV_blank>-<S2SV_blank>max<S2SV_blank>msg<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%d\\\\n\" , pThis -> iOctetsRemain , iMaxLine ) ; <S2SV_StartBug> errmsg . LogError ( 0 , NO_ERRCODE , \"received<S2SV_blank>oversize<S2SV_blank>message:<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>\" <S2SV_EndBug> \"max<S2SV_blank>msg<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>truncating...\" , pThis -> iOctetsRemain , iMaxLine ) ; } <S2SV_StartBug> pThis -> inputState = eInMsg ; <S2SV_EndBug> } } else { assert ( pThis -> inputState == eInMsg ) ; if ( pThis -> eFraming == TCP_FRAMING_OCTET_STUFFING ) { if ( pThis -> iMsg >= iMaxLine ) { int i = 1 ; char currBuffChar ; while ( i < buffLen && ( ( currBuffChar = ( * buff ) [ i ] ) != '\\\\n' && ( pThis -> pLstn -> pSrv -> iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER || currBuffChar != pThis -> pLstn -> pSrv -> iAddtlFrameDelim ) ) ) { i ++ ; } LogError ( 0 , NO_ERRCODE , \"error:<S2SV_blank>message<S2SV_blank>received<S2SV_blank>is<S2SV_blank>at<S2SV_blank>least<S2SV_blank>%d<S2SV_blank>byte<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>max<S2SV_blank>msg\" \"<S2SV_blank>size;<S2SV_blank>message<S2SV_blank>will<S2SV_blank>be<S2SV_blank>split<S2SV_blank>starting<S2SV_blank>at:<S2SV_blank>\\\\\"%.*s\\\\\"\\\\n\" , i , ( i < 32 ) ? i : 32 , * buff ) ; doSubmitMsg ( pThis , stTime , ttGenTime , pMultiSub ) ; ++ ( * pnMsgs ) ; } if ( ( c == '\\\\n' ) || ( ( pThis -> pLstn -> pSrv -> iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER ) && ( c == pThis -> pLstn -> pSrv -> iAddtlFrameDelim ) ) ) { doSubmitMsg ( pThis , stTime , ttGenTime , pMultiSub ) ; ++ ( * pnMsgs ) ; pThis -> inputState = eAtStrtFram ; } else { if ( pThis -> iMsg < iMaxLine ) { * ( pThis -> pMsg + pThis -> iMsg ++ ) = c ; } } } else { assert ( pThis -> eFraming == TCP_FRAMING_OCTET_COUNTING ) ; octatesToCopy = pThis -> iOctetsRemain ; octatesToDiscard = 0 ; if ( buffLen < octatesToCopy ) { octatesToCopy = buffLen ; } if ( octatesToCopy + pThis -> iMsg > iMaxLine ) { octatesToDiscard = octatesToCopy - ( iMaxLine - pThis -> iMsg ) ; octatesToCopy = iMaxLine - pThis -> iMsg ; } memcpy ( pThis -> pMsg + pThis -> iMsg , * buff , octatesToCopy ) ; pThis -> iMsg += octatesToCopy ; pThis -> iOctetsRemain -= ( octatesToCopy + octatesToDiscard ) ; * buff += ( octatesToCopy + octatesToDiscard - 1 ) ; if ( pThis -> iOctetsRemain == 0 ) { doSubmitMsg ( pThis , stTime , ttGenTime , pMultiSub ) ; ++ ( * pnMsgs ) ; pThis -> inputState = eAtStrtFram ; } } } finalize_it : RETiRet ; }", "target": "<S2SV_ModStart> ) ) { if ( pThis -> iOctetsRemain <= 200000000 ) { <S2SV_ModStart> ; } else <S2SV_ModEnd> { errmsg . <S2SV_ModStart> NO_ERRCODE , \"Framing<S2SV_blank>Error<S2SV_blank>in<S2SV_blank>received<S2SV_blank>TCP<S2SV_blank>message:<S2SV_blank>\" \"frame<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(at<S2SV_blank>least<S2SV_blank>%d%c),<S2SV_blank>change<S2SV_blank>to<S2SV_blank>octet<S2SV_blank>stuffing\" , pThis -> iOctetsRemain , c ) ; pThis -> eFraming = TCP_FRAMING_OCTET_STUFFING ; pThis -> inputState = eInMsg ; } * ( pThis -> pMsg + pThis -> iMsg ++ ) = c ; } else <S2SV_ModEnd> { DBGPRINTF ( <S2SV_ModStart> { DBGPRINTF ( \"TCP<S2SV_blank>Message<S2SV_blank>with<S2SV_blank>octet-counter,<S2SV_blank>size<S2SV_blank>%d.\\\\n\" , pThis -> iOctetsRemain ) ; if ( c != '<S2SV_blank>' ) { <S2SV_ModEnd> errmsg . LogError <S2SV_ModStart> NO_ERRCODE , \"Framing<S2SV_blank>Error<S2SV_blank>in<S2SV_blank>received<S2SV_blank>TCP<S2SV_blank>message:<S2SV_blank>\" \"delimiter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>SP<S2SV_blank>but<S2SV_blank>has<S2SV_blank>ASCII<S2SV_blank>value<S2SV_blank>%d.\" , c ) ; } if ( pThis -> iOctetsRemain < 1 ) { <S2SV_ModEnd> errmsg . LogError <S2SV_ModStart> , NO_ERRCODE , \"Framing<S2SV_blank>Error<S2SV_blank>in<S2SV_blank>received<S2SV_blank>TCP<S2SV_blank>message:<S2SV_blank>\" \"invalid<S2SV_blank>octet<S2SV_blank>count<S2SV_blank>%d.\" , pThis -> iOctetsRemain ) ; pThis -> eFraming = TCP_FRAMING_OCTET_STUFFING ; } else if ( pThis -> iOctetsRemain > iMaxLine ) { DBGPRINTF ( \"truncating<S2SV_blank>message<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>octets<S2SV_blank>-<S2SV_blank>max<S2SV_blank>msg<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%d\\\\n\" , pThis -> iOctetsRemain , iMaxLine ) ; errmsg . LogError ( 0 , NO_ERRCODE , <S2SV_ModStart> inputState = eInMsg ; pThis -> iMsg = 0"}
{"source": "CWE-416 qf_fill_buffer ( qf_list_T * qfl , buf_T * buf , qfline_T * old_last , int qf_winid ) { linenr_T lnum ; qfline_T * qfp ; int old_KeyTyped = KeyTyped ; list_T * qftf_list = NULL ; listitem_T * qftf_li = NULL ; if ( old_last == NULL ) { if ( buf != curbuf ) { internal_error ( \"qf_fill_buffer()\" ) ; return ; } while ( ( curbuf -> b_ml . ml_flags & ML_EMPTY ) == 0 ) ( void ) ml_delete ( ( linenr_T ) 1 ) ; } <S2SV_StartBug> if ( qfl != NULL ) <S2SV_EndBug> { char_u dirname [ MAXPATHL ] ; int invalid_val = FALSE ; int prev_bufnr = - 1 ; * dirname = NUL ; if ( old_last == NULL ) { qfp = qfl -> qf_start ; lnum = 0 ; } else { if ( old_last -> qf_next != NULL ) qfp = old_last -> qf_next ; else qfp = old_last ; lnum = buf -> b_ml . ml_line_count ; } qftf_list = call_qftf_func ( qfl , qf_winid , ( long ) ( lnum + 1 ) , ( long ) qfl -> qf_count ) ; if ( qftf_list != NULL ) qftf_li = qftf_list -> lv_first ; while ( lnum < qfl -> qf_count ) { char_u * qftf_str = NULL ; if ( qftf_li != NULL && ! invalid_val ) { qftf_str = tv_get_string_chk ( & qftf_li -> li_tv ) ; if ( qftf_str == NULL ) invalid_val = TRUE ; } if ( qf_buf_add_line ( buf , lnum , qfp , dirname , prev_bufnr != qfp -> qf_fnum , qftf_str ) == FAIL ) break ; prev_bufnr = qfp -> qf_fnum ; ++ lnum ; qfp = qfp -> qf_next ; if ( qfp == NULL ) break ; if ( qftf_li != NULL ) qftf_li = qftf_li -> li_next ; } if ( old_last == NULL ) ( void ) ml_delete ( lnum + 1 ) ; } check_lnums ( TRUE ) ; if ( old_last == NULL ) { ++ curbuf_lock ; set_option_value_give_err ( ( char_u * ) \"ft\" , 0L , ( char_u * ) \"qf\" , OPT_LOCAL ) ; curbuf -> b_p_ma = FALSE ; keep_filetype = TRUE ; apply_autocmds ( EVENT_BUFREADPOST , ( char_u * ) \"quickfix\" , NULL , FALSE , curbuf ) ; apply_autocmds ( EVENT_BUFWINENTER , ( char_u * ) \"quickfix\" , NULL , FALSE , curbuf ) ; keep_filetype = FALSE ; -- curbuf_lock ; redraw_curbuf_later ( UPD_NOT_VALID ) ; } KeyTyped = old_KeyTyped ; }", "target": "<S2SV_ModStart> qfl != NULL && qfl -> qf_start != NULL"}
{"source": "CWE-787 std : : string controller : : bookmark ( const std : : string & url , const std : : string & title , const std : : string & description , const std : : string & feed_title ) { std : : string bookmark_cmd = cfg . get_configvalue ( \"bookmark-cmd\" ) ; bool is_interactive = cfg . get_configvalue_as_bool ( \"bookmark-interactive\" ) ; if ( bookmark_cmd . length ( ) > 0 ) { <S2SV_StartBug> std : : string cmdline = strprintf : : fmt ( \"%s<S2SV_blank>\\'%s\\'<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\" , <S2SV_EndBug> bookmark_cmd , utils : : replace_all ( url , \"\\'\" , \"%27\" ) , <S2SV_StartBug> quote_empty ( stfl : : quote ( title ) ) , <S2SV_EndBug> quote_empty ( stfl : : quote ( description ) ) , quote_empty ( stfl : : quote ( feed_title ) ) ) ; LOG ( level : : DEBUG , \"controller::bookmark:<S2SV_blank>cmd<S2SV_blank>=<S2SV_blank>%s\" , cmdline ) ; if ( is_interactive ) { v -> push_empty_formaction ( ) ; stfl : : reset ( ) ; utils : : run_interactively ( cmdline , \"controller::bookmark\" ) ; v -> pop_current_formaction ( ) ; return \"\" ; } else { char * my_argv [ 4 ] ; my_argv [ 0 ] = const_cast < char * > ( \"/bin/sh\" ) ; my_argv [ 1 ] = const_cast < char * > ( \"-c\" ) ; my_argv [ 2 ] = const_cast < char * > ( cmdline . c_str ( ) ) ; my_argv [ 3 ] = nullptr ; return utils : : run_program ( my_argv , \"\" ) ; } } else { return _ ( \"bookmarking<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>configured.<S2SV_blank>Please<S2SV_blank>set<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>variable<S2SV_blank>`bookmark-cmd\\'<S2SV_blank>accordingly.\" ) ; } }", "target": "<S2SV_ModStart> : fmt ( \"%s<S2SV_blank>\\'%s\\'<S2SV_blank>\\'%s\\'<S2SV_blank>\\'%s\\'<S2SV_blank>\\'%s\\'\" <S2SV_ModEnd> , bookmark_cmd , <S2SV_ModStart> \"%27\" ) , utils : : replace_all ( title , \"\\'\" , \"%27\" ) , utils : : replace_all ( description , \"\\'\" , \"%27\" ) , utils : : replace_all ( feed_title , \"\\'\" , \"%27\" <S2SV_ModEnd> ) ) ;"}
{"source": "CWE-835 static void sungem_send_packet ( SunGEMState * s , const uint8_t * buf , int size ) { NetClientState * nc = qemu_get_queue ( s -> nic ) ; if ( s -> macregs [ MAC_XIFCFG >> 2 ] & MAC_XIFCFG_LBCK ) { <S2SV_StartBug> nc -> info -> receive ( nc , buf , size ) ; <S2SV_EndBug> } else { qemu_send_packet ( nc , buf , size ) ; } }", "target": "<S2SV_ModStart> MAC_XIFCFG_LBCK ) { qemu_receive_packet <S2SV_ModEnd> ( nc ,"}
{"source": "CWE-732 static int write_entry ( struct mailbox * mailbox , unsigned int uid , const char * entry , const char * userid , const struct buf * value , int ignorequota , int silent , const struct annotate_metadata * mdata , int maywrite ) { char key [ MAX_MAILBOX_PATH + 1 ] ; int keylen , r ; annotate_db_t * d = NULL ; struct buf oldval = BUF_INITIALIZER ; const char * mboxname = mailbox ? mailbox -> name : \"\" ; modseq_t modseq = mdata ? mdata -> modseq : 0 ; r = _annotate_getdb ( mboxname , uid , CYRUSDB_CREATE , & d ) ; if ( r ) return r ; annotate_begin ( d ) ; keylen = make_key ( mboxname , uid , entry , userid , key , sizeof ( key ) ) ; <S2SV_StartBug> if ( mailbox ) { <S2SV_EndBug> struct annotate_metadata oldmdata ; r = read_old_value ( d , key , keylen , & oldval , & oldmdata ) ; if ( r ) goto out ; if ( oldval . len == value -> len && ( ! value -> len || ! memcmp ( oldval . s , value -> s , value -> len ) ) ) goto out ; <S2SV_StartBug> <S2SV_EndBug> if ( ! ignorequota ) { quota_t qdiffs [ QUOTA_NUMRESOURCES ] = QUOTA_DIFFS_DONTCARE_INITIALIZER ; qdiffs [ QUOTA_ANNOTSTORAGE ] = value -> len - ( quota_t ) oldval . len ; r = mailbox_quota_check ( mailbox , qdiffs ) ; if ( r ) goto out ; } <S2SV_StartBug> if ( ! maywrite ) { <S2SV_EndBug> r = IMAP_PERMISSION_DENIED ; if ( r ) goto out ; } mailbox_annot_changed ( mailbox , uid , entry , userid , & oldval , value , silent ) ; if ( uid && ! mdata ) { modseq = mailbox -> i . highestmodseq ; } } if ( ! value -> len && ! uid ) { # if DEBUG syslog ( LOG_ERR , \"write_entry:<S2SV_blank>deleting<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s\" , key_as_string ( d , key , keylen ) , d -> filename ) ; # endif do { r = cyrusdb_delete ( d -> db , key , keylen , tid ( d ) , 1 ) ; } while ( r == CYRUSDB_AGAIN ) ; } else { struct buf data = BUF_INITIALIZER ; unsigned char flags = 0 ; if ( ! value -> len || value -> s == NULL ) { flags |= ANNOTATE_FLAG_DELETED ; } else { if ( ! userid ) goto out ; } make_entry ( & data , value , modseq , flags ) ; # if DEBUG syslog ( LOG_ERR , \"write_entry:<S2SV_blank>storing<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>(value:<S2SV_blank>%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(modseq=\" MODSEQ_FMT \")\" , key_as_string ( d , key , keylen ) , value -> s , d -> filename , modseq ) ; # endif do { r = cyrusdb_store ( d -> db , key , keylen , data . s , data . len , tid ( d ) ) ; } while ( r == CYRUSDB_AGAIN ) ; buf_free ( & data ) ; } if ( ! mailbox ) sync_log_annotation ( \"\" ) ; out : annotate_putdb ( & d ) ; buf_free ( & oldval ) ; return r ; }", "target": "<S2SV_ModStart> ) ) ; <S2SV_ModEnd> struct annotate_metadata oldmdata <S2SV_ModStart> goto out ; if ( ! maywrite ) { r = IMAP_PERMISSION_DENIED ; if ( r ) goto out ; } if ( mailbox ) { <S2SV_ModStart> out ; } <S2SV_ModEnd> mailbox_annot_changed ( mailbox"}
{"source": "CWE-476 static int ax25_release ( struct socket * sock ) { struct sock * sk = sock -> sk ; ax25_cb * ax25 ; ax25_dev * ax25_dev ; if ( sk == NULL ) return 0 ; sock_hold ( sk ) ; lock_sock ( sk ) ; sock_orphan ( sk ) ; ax25 = sk_to_ax25 ( sk ) ; ax25_dev = ax25 -> ax25_dev ; if ( sk -> sk_type == SOCK_SEQPACKET ) { switch ( ax25 -> state ) { case AX25_STATE_0 : release_sock ( sk ) ; ax25_disconnect ( ax25 , 0 ) ; lock_sock ( sk ) ; ax25_destroy_socket ( ax25 ) ; break ; case AX25_STATE_1 : case AX25_STATE_2 : ax25_send_control ( ax25 , AX25_DISC , AX25_POLLON , AX25_COMMAND ) ; release_sock ( sk ) ; ax25_disconnect ( ax25 , 0 ) ; lock_sock ( sk ) ; if ( ! sock_flag ( ax25 -> sk , SOCK_DESTROY ) ) ax25_destroy_socket ( ax25 ) ; break ; case AX25_STATE_3 : case AX25_STATE_4 : ax25_clear_queues ( ax25 ) ; ax25 -> n2count = 0 ; switch ( ax25 -> ax25_dev -> values [ AX25_VALUES_PROTOCOL ] ) { case AX25_PROTO_STD_SIMPLEX : case AX25_PROTO_STD_DUPLEX : ax25_send_control ( ax25 , AX25_DISC , AX25_POLLON , AX25_COMMAND ) ; ax25_stop_t2timer ( ax25 ) ; ax25_stop_t3timer ( ax25 ) ; ax25_stop_idletimer ( ax25 ) ; break ; # ifdef CONFIG_AX25_DAMA_SLAVE case AX25_PROTO_DAMA_SLAVE : ax25_stop_t3timer ( ax25 ) ; ax25_stop_idletimer ( ax25 ) ; break ; # endif } ax25_calculate_t1 ( ax25 ) ; ax25_start_t1timer ( ax25 ) ; ax25 -> state = AX25_STATE_2 ; sk -> sk_state = TCP_CLOSE ; sk -> sk_shutdown |= SEND_SHUTDOWN ; sk -> sk_state_change ( sk ) ; sock_set_flag ( sk , SOCK_DESTROY ) ; break ; default : break ; } } else { sk -> sk_state = TCP_CLOSE ; sk -> sk_shutdown |= SEND_SHUTDOWN ; sk -> sk_state_change ( sk ) ; ax25_destroy_socket ( ax25 ) ; } if ( ax25_dev ) { <S2SV_StartBug> dev_put_track ( ax25_dev -> dev , & ax25_dev -> dev_tracker ) ; <S2SV_EndBug> ax25_dev_put ( ax25_dev ) ; } sock -> sk = NULL ; release_sock ( sk ) ; sock_put ( sk ) ; return 0 ; }", "target": "<S2SV_ModStart> ax25_dev ) { del_timer_sync ( & ax25 -> timer ) ; del_timer_sync ( & ax25 -> t1timer ) ; del_timer_sync ( & ax25 -> t2timer ) ; del_timer_sync ( & ax25 -> t3timer ) ; del_timer_sync ( & ax25 -> idletimer ) ;"}
{"source": "CWE-125 mbfl_filt_conv_big5_wchar ( int c , mbfl_convert_filter * filter ) { int k ; int c1 , w , c2 ; switch ( filter -> status ) { case 0 : if ( filter -> from -> no_encoding == mbfl_no_encoding_cp950 ) { c1 = 0x80 ; } else { c1 = 0xa0 ; } if ( c >= 0 && c <= 0x80 ) { CK ( ( * filter -> output_function ) ( c , filter -> data ) ) ; } else if ( c == 0xff ) { CK ( ( * filter -> output_function ) ( 0xf8f8 , filter -> data ) ) ; } else if ( c > c1 && c < 0xff ) { filter -> status = 1 ; filter -> cache = c ; } else { w = c & MBFL_WCSGROUP_MASK ; w |= MBFL_WCSGROUP_THROUGH ; CK ( ( * filter -> output_function ) ( w , filter -> data ) ) ; } break ; case 1 : filter -> status = 0 ; c1 = filter -> cache ; if ( ( c > 0x39 && c < 0x7f ) | ( c > 0xa0 && c < 0xff ) ) { if ( c < 0x7f ) { w = ( c1 - 0xa1 ) * 157 + ( c - 0x40 ) ; } else { w = ( c1 - 0xa1 ) * 157 + ( c - 0xa1 ) + 0x3f ; } if ( w >= 0 && w < big5_ucs_table_size ) { w = big5_ucs_table [ w ] ; } else { w = 0 ; } if ( filter -> from -> no_encoding == mbfl_no_encoding_cp950 ) { if ( w <= 0 && <S2SV_StartBug> ( ( ( c1 >= 0xfa && c1 <= 0xfe ) || ( c1 >= 0x8e && c1 <= 0xa0 ) || <S2SV_EndBug> ( c1 >= 0x81 && c1 <= 0x8d ) || ( c1 >= 0xc7 && c1 <= 0xc8 ) ) && ( ( c > 0x39 && c < 0x7f ) || ( c > 0xa0 && c < 0xff ) ) ) || ( ( c1 == 0xc6 ) && ( c > 0xa0 && c < 0xff ) ) ) { c2 = c1 << 8 | c ; for ( k = 0 ; k < sizeof ( cp950_pua_tbl ) / ( sizeof ( unsigned short ) * 4 ) ; k ++ ) { if ( c2 >= cp950_pua_tbl [ k ] [ 2 ] && c2 <= cp950_pua_tbl [ k ] [ 3 ] ) { break ; } } if ( ( cp950_pua_tbl [ k ] [ 2 ] & 0xff ) == 0x40 ) { w = 157 * ( c1 - ( cp950_pua_tbl [ k ] [ 2 ] >> 8 ) ) + c - ( c >= 0xa1 ? 0x62 : 0x40 ) + cp950_pua_tbl [ k ] [ 0 ] ; } else { w = c2 - cp950_pua_tbl [ k ] [ 2 ] + cp950_pua_tbl [ k ] [ 0 ] ; } } } if ( w <= 0 ) { w = ( c1 << 8 ) | c ; w &= MBFL_WCSPLANE_MASK ; w |= MBFL_WCSPLANE_BIG5 ; } CK ( ( * filter -> output_function ) ( w , filter -> data ) ) ; } else if ( ( c >= 0 && c < 0x21 ) || c == 0x7f ) { CK ( ( * filter -> output_function ) ( c , filter -> data ) ) ; } else { w = ( c1 << 8 ) | c ; w &= MBFL_WCSGROUP_MASK ; w |= MBFL_WCSGROUP_THROUGH ; CK ( ( * filter -> output_function ) ( w , filter -> data ) ) ; } break ; default : filter -> status = 0 ; break ; } return c ; }", "target": "<S2SV_ModStart> <= 0 && is_in_cp950_pua ( c1 , c <S2SV_ModEnd> ) ) {"}
{"source": "CWE-416 void nfcmrvl_nci_unregister_dev ( struct nfcmrvl_private * priv ) { struct nci_dev * ndev = priv -> ndev ; <S2SV_StartBug> <S2SV_EndBug> if ( priv -> ndev -> nfc_dev -> fw_download_in_progress ) nfcmrvl_fw_dnld_abort ( priv ) ; nfcmrvl_fw_dnld_deinit ( priv ) ; if ( gpio_is_valid ( priv -> config . reset_n_io ) ) gpio_free ( priv -> config . reset_n_io ) ; <S2SV_StartBug> nci_unregister_device ( ndev ) ; <S2SV_EndBug> nci_free_device ( ndev ) ; kfree ( priv ) ; }", "target": "<S2SV_ModStart> -> ndev ; nci_unregister_device ( ndev ) ; <S2SV_ModStart> reset_n_io ) ; <S2SV_ModEnd> nci_free_device ( ndev"}
{"source": "CWE-754 g_socket_client_connected_callback ( GObject * source , GAsyncResult * result , gpointer user_data ) { ConnectionAttempt * attempt = user_data ; GSocketClientAsyncConnectData * data = attempt -> data ; GSList * l ; GError * error = NULL ; GProxy * proxy ; const gchar * protocol ; <S2SV_StartBug> if ( data && g_task_return_error_if_cancelled ( data -> task ) ) <S2SV_EndBug> { g_object_unref ( data -> task ) ; connection_attempt_unref ( attempt ) ; return ; } if ( attempt -> timeout_source ) { g_source_destroy ( attempt -> timeout_source ) ; g_clear_pointer ( & attempt -> timeout_source , g_source_unref ) ; } if ( ! g_socket_connection_connect_finish ( G_SOCKET_CONNECTION ( source ) , result , & error ) ) { if ( ! g_cancellable_is_cancelled ( attempt -> cancellable ) ) { clarify_connect_error ( error , data -> connectable , attempt -> address ) ; set_last_error ( data , error ) ; <S2SV_StartBug> } <S2SV_EndBug> else g_clear_error ( & error ) ; <S2SV_StartBug> if ( data ) <S2SV_EndBug> { connection_attempt_remove ( attempt ) ; enumerator_next_async ( data ) ; } else connection_attempt_unref ( attempt ) ; <S2SV_StartBug> <S2SV_EndBug> return ; } data -> socket = g_steal_pointer ( & attempt -> socket ) ; data -> connection = g_steal_pointer ( & attempt -> connection ) ; for ( l = data -> connection_attempts ; l ; l = g_slist_next ( l ) ) { ConnectionAttempt * attempt_entry = l -> data ; <S2SV_StartBug> g_cancellable_cancel ( attempt_entry -> cancellable ) ; <S2SV_EndBug> attempt_entry -> data = NULL ; connection_attempt_unref ( attempt_entry ) ; } g_slist_free ( data -> connection_attempts ) ; data -> connection_attempts = NULL ; connection_attempt_unref ( attempt ) ; g_socket_connection_set_cached_remote_address ( ( GSocketConnection * ) data -> connection , NULL ) ; g_socket_client_emit_event ( data -> client , G_SOCKET_CLIENT_CONNECTED , data -> connectable , data -> connection ) ; g_socket_set_blocking ( data -> socket , TRUE ) ; if ( ! data -> proxy_addr ) { g_socket_client_tls_handshake ( data ) ; return ; } protocol = g_proxy_address_get_protocol ( data -> proxy_addr ) ; if ( ! G_IS_TCP_CONNECTION ( data -> connection ) ) { g_critical ( \"Trying<S2SV_blank>to<S2SV_blank>proxy<S2SV_blank>over<S2SV_blank>non-TCP<S2SV_blank>connection,<S2SV_blank>this<S2SV_blank>is<S2SV_blank>\" \"most<S2SV_blank>likely<S2SV_blank>a<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>GLib<S2SV_blank>IO<S2SV_blank>library.\" ) ; g_set_error_literal ( & data -> last_error , G_IO_ERROR , G_IO_ERROR_NOT_SUPPORTED , _ ( \"Proxying<S2SV_blank>over<S2SV_blank>a<S2SV_blank>non-TCP<S2SV_blank>connection<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\" ) ) ; <S2SV_StartBug> enumerator_next_async ( data ) ; <S2SV_EndBug> } else if ( g_hash_table_contains ( data -> client -> priv -> app_proxies , protocol ) ) { g_socket_client_async_connect_complete ( data ) ; } else if ( ( proxy = g_proxy_get_default_for_protocol ( protocol ) ) ) { g_socket_client_emit_event ( data -> client , G_SOCKET_CLIENT_PROXY_NEGOTIATING , data -> connectable , data -> connection ) ; g_proxy_connect_async ( proxy , data -> connection , data -> proxy_addr , g_task_get_cancellable ( data -> task ) , g_socket_client_proxy_connect_callback , data ) ; g_object_unref ( proxy ) ; } else { g_clear_error ( & data -> last_error ) ; g_set_error ( & data -> last_error , G_IO_ERROR , G_IO_ERROR_NOT_SUPPORTED , _ ( \"Proxy<S2SV_blank>protocol<S2SV_blank>\u201c%s\u201d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\" ) , protocol ) ; <S2SV_StartBug> enumerator_next_async ( data ) ; <S2SV_EndBug> } }", "target": "<S2SV_ModStart> ; if ( g_cancellable_is_cancelled ( attempt -> cancellable ) || task_completed_or_cancelled <S2SV_ModEnd> ( data -> <S2SV_ModStart> error ) ; connection_attempt_remove ( attempt ) ; enumerator_next_async ( data , FALSE ) ; } else { <S2SV_ModEnd> g_clear_error ( & <S2SV_ModStart> error ) ; g_object_unref ( data -> task ) ; <S2SV_ModEnd> connection_attempt_unref ( attempt <S2SV_ModStart> attempt ) ; } <S2SV_ModStart> -> cancellable ) <S2SV_ModEnd> ; connection_attempt_unref ( <S2SV_ModStart> enumerator_next_async ( data , FALSE <S2SV_ModStart> enumerator_next_async ( data , FALSE"}
{"source": "CWE-787 spell_suggest ( int count ) { char_u * line ; pos_T prev_cursor = curwin -> w_cursor ; char_u wcopy [ MAXWLEN + 2 ] ; char_u * p ; int i ; int c ; suginfo_T sug ; suggest_T * stp ; int mouse_used ; int need_cap ; int limit ; int selected = count ; int badlen = 0 ; int msg_scroll_save = msg_scroll ; int wo_spell_save = curwin -> w_p_spell ; if ( ! curwin -> w_p_spell ) { did_set_spelllang ( curwin ) ; curwin -> w_p_spell = TRUE ; } if ( * curwin -> w_s -> b_p_spl == NUL ) { emsg ( _ ( e_spell_checking_is_not_possible ) ) ; return ; } if ( VIsual_active ) { if ( curwin -> w_cursor . lnum != VIsual . lnum ) { vim_beep ( BO_SPELL ) ; return ; } badlen = ( int ) curwin -> w_cursor . col - ( int ) VIsual . col ; if ( badlen < 0 ) badlen = - badlen ; else curwin -> w_cursor . col = VIsual . col ; ++ badlen ; end_visual_mode ( ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( spell_move_to ( curwin , FORWARD , TRUE , TRUE , NULL ) == 0 || curwin -> w_cursor . col > prev_cursor . col ) { curwin -> w_cursor = prev_cursor ; line = ml_get_curline ( ) ; p = line + curwin -> w_cursor . col ; while ( p > line && spell_iswordp_nmw ( p , curwin ) ) MB_PTR_BACK ( line , p ) ; while ( * p != NUL && ! spell_iswordp_nmw ( p , curwin ) ) MB_PTR_ADV ( p ) ; if ( ! spell_iswordp_nmw ( p , curwin ) ) { beep_flush ( ) ; return ; } curwin -> w_cursor . col = ( colnr_T ) ( p - line ) ; } need_cap = check_need_cap ( curwin -> w_cursor . lnum , curwin -> w_cursor . col ) ; line = vim_strsave ( ml_get_curline ( ) ) ; if ( line == NULL ) goto skip ; if ( sps_limit > ( int ) Rows - 2 ) limit = ( int ) Rows - 2 ; else limit = sps_limit ; spell_find_suggest ( line + curwin -> w_cursor . col , badlen , & sug , limit , TRUE , need_cap , TRUE ) ; if ( sug . su_ga . ga_len == 0 ) msg ( _ ( \"Sorry,<S2SV_blank>no<S2SV_blank>suggestions\" ) ) ; else if ( count > 0 ) { if ( count > sug . su_ga . ga_len ) smsg ( _ ( \"Sorry,<S2SV_blank>only<S2SV_blank>%ld<S2SV_blank>suggestions\" ) , ( long ) sug . su_ga . ga_len ) ; } else { # ifdef FEAT_RIGHTLEFT cmdmsg_rl = curwin -> w_p_rl ; if ( cmdmsg_rl ) msg_col = Columns - 1 ; # endif msg_start ( ) ; msg_row = Rows - 1 ; lines_left = Rows ; vim_snprintf ( ( char * ) IObuff , IOSIZE , _ ( \"Change<S2SV_blank>\\\\\"%.*s\\\\\"<S2SV_blank>to:\" ) , sug . su_badlen , sug . su_badptr ) ; # ifdef FEAT_RIGHTLEFT if ( cmdmsg_rl && STRNCMP ( IObuff , \"Change\" , 6 ) == 0 ) { vim_snprintf ( ( char * ) IObuff , IOSIZE , \":ot<S2SV_blank>\\\\\"%.*s\\\\\"<S2SV_blank>egnahC\" , sug . su_badlen , sug . su_badptr ) ; } # endif msg_puts ( ( char * ) IObuff ) ; msg_clr_eos ( ) ; msg_putchar ( '\\\\n' ) ; msg_scroll = TRUE ; for ( i = 0 ; i < sug . su_ga . ga_len ; ++ i ) { stp = & SUG ( sug . su_ga , i ) ; vim_strncpy ( wcopy , stp -> st_word , MAXWLEN ) ; if ( sug . su_badlen > stp -> st_orglen ) vim_strncpy ( wcopy + stp -> st_wordlen , sug . su_badptr + stp -> st_orglen , sug . su_badlen - stp -> st_orglen ) ; vim_snprintf ( ( char * ) IObuff , IOSIZE , \"%2d\" , i + 1 ) ; # ifdef FEAT_RIGHTLEFT if ( cmdmsg_rl ) rl_mirror ( IObuff ) ; # endif msg_puts ( ( char * ) IObuff ) ; vim_snprintf ( ( char * ) IObuff , IOSIZE , \"<S2SV_blank>\\\\\"%s\\\\\"\" , wcopy ) ; msg_puts ( ( char * ) IObuff ) ; if ( sug . su_badlen < stp -> st_orglen ) { vim_snprintf ( ( char * ) IObuff , IOSIZE , _ ( \"<S2SV_blank><<S2SV_blank>\\\\\"%.*s\\\\\"\" ) , stp -> st_orglen , sug . su_badptr ) ; msg_puts ( ( char * ) IObuff ) ; } if ( p_verbose > 0 ) { if ( sps_flags & ( SPS_DOUBLE | SPS_BEST ) ) vim_snprintf ( ( char * ) IObuff , IOSIZE , \"<S2SV_blank>(%s%d<S2SV_blank>-<S2SV_blank>%d)\" , stp -> st_salscore ? \"s<S2SV_blank>\" : \"\" , stp -> st_score , stp -> st_altscore ) ; else vim_snprintf ( ( char * ) IObuff , IOSIZE , \"<S2SV_blank>(%d)\" , stp -> st_score ) ; # ifdef FEAT_RIGHTLEFT if ( cmdmsg_rl ) rl_mirror ( IObuff + 1 ) ; # endif msg_advance ( 30 ) ; msg_puts ( ( char * ) IObuff ) ; } msg_putchar ( '\\\\n' ) ; } # ifdef FEAT_RIGHTLEFT cmdmsg_rl = FALSE ; msg_col = 0 ; # endif selected = prompt_for_number ( & mouse_used ) ; if ( mouse_used ) selected -= lines_left ; lines_left = Rows ; msg_scroll = msg_scroll_save ; } if ( selected > 0 && selected <= sug . su_ga . ga_len && u_save_cursor ( ) == OK ) { VIM_CLEAR ( repl_from ) ; VIM_CLEAR ( repl_to ) ; stp = & SUG ( sug . su_ga , selected - 1 ) ; if ( sug . su_badlen > stp -> st_orglen ) { repl_from = vim_strnsave ( sug . su_badptr , sug . su_badlen ) ; vim_snprintf ( ( char * ) IObuff , IOSIZE , \"%s%.*s\" , stp -> st_word , sug . su_badlen - stp -> st_orglen , sug . su_badptr + stp -> st_orglen ) ; repl_to = vim_strsave ( IObuff ) ; } else { repl_from = vim_strnsave ( sug . su_badptr , stp -> st_orglen ) ; repl_to = vim_strsave ( stp -> st_word ) ; } p = alloc ( STRLEN ( line ) - stp -> st_orglen + stp -> st_wordlen + 1 ) ; if ( p != NULL ) { c = ( int ) ( sug . su_badptr - line ) ; mch_memmove ( p , line , c ) ; STRCPY ( p + c , stp -> st_word ) ; STRCAT ( p , sug . su_badptr + stp -> st_orglen ) ; ResetRedobuff ( ) ; AppendToRedobuff ( ( char_u * ) \"ciw\" ) ; AppendToRedobuffLit ( p + c , stp -> st_wordlen + sug . su_badlen - stp -> st_orglen ) ; AppendCharToRedobuff ( ESC ) ; ml_replace ( curwin -> w_cursor . lnum , p , FALSE ) ; curwin -> w_cursor . col = c ; changed_bytes ( curwin -> w_cursor . lnum , c ) ; } } else curwin -> w_cursor = prev_cursor ; spell_find_cleanup ( & sug ) ; skip : vim_free ( line ) ; curwin -> w_p_spell = wo_spell_save ; }", "target": "<S2SV_ModStart> ( ) ; line = ml_get_curline ( ) ; if ( badlen > STRLEN ( line ) - curwin -> w_cursor . col ) badlen = STRLEN ( line ) - curwin -> w_cursor . col ;"}
{"source": "CWE-416 int cgroup1_parse_param ( struct fs_context * fc , struct fs_parameter * param ) { struct cgroup_fs_context * ctx = cgroup_fc2context ( fc ) ; struct cgroup_subsys * ss ; struct fs_parse_result result ; int opt , i ; opt = fs_parse ( fc , cgroup1_fs_parameters , param , & result ) ; if ( opt == - ENOPARAM ) { <S2SV_StartBug> if ( strcmp ( param -> key , \"source\" ) == 0 ) { <S2SV_EndBug> if ( fc -> source ) return invalf ( fc , \"Multiple<S2SV_blank>sources<S2SV_blank>not<S2SV_blank>supported\" ) ; fc -> source = param -> string ; param -> string = NULL ; return 0 ; } for_each_subsys ( ss , i ) { if ( strcmp ( param -> key , ss -> legacy_name ) ) continue ; if ( ! cgroup_ssid_enabled ( i ) || cgroup1_ssid_disabled ( i ) ) return invalfc ( fc , \"Disabled<S2SV_blank>controller<S2SV_blank>\\'%s\\'\" , param -> key ) ; ctx -> subsys_mask |= ( 1 << i ) ; return 0 ; } return invalfc ( fc , \"Unknown<S2SV_blank>subsys<S2SV_blank>name<S2SV_blank>\\'%s\\'\" , param -> key ) ; } if ( opt < 0 ) return opt ; switch ( opt ) { case Opt_none : ctx -> none = true ; break ; case Opt_all : ctx -> all_ss = true ; break ; case Opt_noprefix : ctx -> flags |= CGRP_ROOT_NOPREFIX ; break ; case Opt_clone_children : ctx -> cpuset_clone_children = true ; break ; case Opt_cpuset_v2_mode : ctx -> flags |= CGRP_ROOT_CPUSET_V2_MODE ; break ; case Opt_xattr : ctx -> flags |= CGRP_ROOT_XATTR ; break ; case Opt_release_agent : if ( ctx -> release_agent ) return invalfc ( fc , \"release_agent<S2SV_blank>respecified\" ) ; ctx -> release_agent = param -> string ; param -> string = NULL ; break ; case Opt_name : if ( cgroup_no_v1_named ) return - ENOENT ; if ( ! param -> size ) return invalfc ( fc , \"Empty<S2SV_blank>name\" ) ; if ( param -> size > MAX_CGROUP_ROOT_NAMELEN - 1 ) return invalfc ( fc , \"Name<S2SV_blank>too<S2SV_blank>long\" ) ; for ( i = 0 ; i < param -> size ; i ++ ) { char c = param -> string [ i ] ; if ( isalnum ( c ) ) continue ; if ( ( c == '.' ) || ( c == '-' ) || ( c == '_' ) ) continue ; return invalfc ( fc , \"Invalid<S2SV_blank>name\" ) ; } if ( ctx -> name ) return invalfc ( fc , \"name<S2SV_blank>respecified\" ) ; ctx -> name = param -> string ; param -> string = NULL ; break ; } return 0 ; }", "target": "<S2SV_ModStart> 0 ) { if ( param -> type != fs_value_is_string ) return invalf ( fc , \"Non-string<S2SV_blank>source\" ) ;"}
{"source": "CWE-119 FindEmptyObjectSlot ( TPMI_DH_OBJECT * handle ) { UINT32 i ; OBJECT * object ; for ( i = 0 ; i < MAX_LOADED_OBJECTS ; i ++ ) { object = & s_objects [ i ] ; if ( object -> attributes . occupied == CLEAR ) { if ( handle ) * handle = i + TRANSIENT_FIRST ; <S2SV_StartBug> MemorySet ( & object -> attributes , 0 , sizeof ( OBJECT_ATTRIBUTES ) ) ; <S2SV_EndBug> return object ; } } return NULL ; }", "target": "<S2SV_ModStart> ; MemorySet ( object <S2SV_ModEnd> , 0 , <S2SV_ModStart> , sizeof ( * object <S2SV_ModEnd> ) ) ;"}
{"source": "CWE-787 HandleCoRREBPP ( rfbClient * client , int rx , int ry , int rw , int rh ) { rfbRREHeader hdr ; int i ; CARDBPP pix ; uint8_t * ptr ; int x , y , w , h ; if ( ! ReadFromRFBServer ( client , ( char * ) & hdr , sz_rfbRREHeader ) ) return FALSE ; hdr . nSubrects = rfbClientSwap32IfLE ( hdr . nSubrects ) ; if ( ! ReadFromRFBServer ( client , ( char * ) & pix , sizeof ( pix ) ) ) return FALSE ; client -> GotFillRect ( client , rx , ry , rw , rh , pix ) ; <S2SV_StartBug> if ( hdr . nSubrects * ( 4 + ( BPP / 8 ) ) > RFB_BUFFER_SIZE || ! ReadFromRFBServer ( client , client -> buffer , hdr . nSubrects * ( 4 + ( BPP / 8 ) ) ) ) <S2SV_EndBug> return FALSE ; ptr = ( uint8_t * ) client -> buffer ; for ( i = 0 ; i < hdr . nSubrects ; i ++ ) { pix = * ( CARDBPP * ) ptr ; ptr += BPP / 8 ; x = * ptr ++ ; y = * ptr ++ ; w = * ptr ++ ; h = * ptr ++ ; client -> GotFillRect ( client , rx + x , ry + y , w , h , pix ) ; } return TRUE ; }", "target": "<S2SV_ModStart> hdr . nSubrects > RFB_BUFFER_SIZE / ( 4 + ( BPP / 8 ) ) <S2SV_ModEnd> || ! ReadFromRFBServer"}
{"source": "CWE-125 lzw_result lzw_decode ( struct lzw_ctx * ctx , const uint8_t * * const stack_pos_out ) { lzw_result res ; uint32_t code_new ; uint32_t code_out ; uint8_t last_value ; uint8_t * stack_pos = ctx -> stack_base ; uint32_t clear_code = ctx -> clear_code ; uint32_t current_entry = ctx -> current_entry ; struct lzw_dictionary_entry * const table = ctx -> table ; res = lzw__next_code ( & ctx -> input , ctx -> current_code_size , & code_new ) ; if ( res != LZW_OK ) { return res ; } if ( code_new == clear_code ) { return lzw__clear_codes ( ctx , stack_pos_out ) ; } else if ( code_new == ctx -> eoi_code ) { return LZW_EOI_CODE ; } else if ( code_new > current_entry ) { return LZW_BAD_CODE ; <S2SV_StartBug> } else if ( code_new < current_entry ) { <S2SV_EndBug> code_out = code_new ; last_value = table [ code_new ] . first_value ; } else { * stack_pos ++ = ctx -> previous_code_first ; code_out = ctx -> previous_code ; last_value = ctx -> previous_code_first ; } if ( current_entry < ( 1 << LZW_CODE_MAX ) ) { struct lzw_dictionary_entry * entry = table + current_entry ; entry -> last_value = last_value ; entry -> first_value = ctx -> previous_code_first ; entry -> previous_entry = ctx -> previous_code ; ctx -> current_entry ++ ; } if ( current_entry == ctx -> current_code_size_max ) { if ( ctx -> current_code_size < LZW_CODE_MAX ) { ctx -> current_code_size ++ ; ctx -> current_code_size_max = ( 1 << ctx -> current_code_size ) - 1 ; } } ctx -> previous_code_first = table [ code_new ] . first_value ; ctx -> previous_code = code_new ; while ( code_out > clear_code ) { struct lzw_dictionary_entry * entry = table + code_out ; * stack_pos ++ = entry -> last_value ; code_out = entry -> previous_entry ; } * stack_pos ++ = table [ code_out ] . last_value ; * stack_pos_out = stack_pos ; return LZW_OK ; }", "target": "<S2SV_ModStart> if ( code_new >= 1 << LZW_CODE_MAX ) { return LZW_BAD_CODE ; } else if ( code_new"}
{"source": "CWE-476 composite_setup ( struct usb_gadget * gadget , const struct usb_ctrlrequest * ctrl ) { struct usb_composite_dev * cdev = get_gadget_data ( gadget ) ; struct usb_request * req = cdev -> req ; int value = - EOPNOTSUPP ; int status = 0 ; u16 w_index = le16_to_cpu ( ctrl -> wIndex ) ; u8 intf = w_index & 0xFF ; u16 w_value = le16_to_cpu ( ctrl -> wValue ) ; u16 w_length = le16_to_cpu ( ctrl -> wLength ) ; struct usb_function * f = NULL ; u8 endp ; if ( w_length > USB_COMP_EP0_BUFSIZ ) { if ( ctrl -> bRequestType & USB_DIR_IN ) { __le16 * temp = ( __le16 * ) & ctrl -> wLength ; * temp = cpu_to_le16 ( USB_COMP_EP0_BUFSIZ ) ; w_length = USB_COMP_EP0_BUFSIZ ; } else { goto done ; } } req -> zero = 0 ; req -> context = cdev ; req -> complete = composite_setup_complete ; req -> length = 0 ; gadget -> ep0 -> driver_data = cdev ; if ( ( ctrl -> bRequestType & USB_TYPE_MASK ) != USB_TYPE_STANDARD ) goto unknown ; switch ( ctrl -> bRequest ) { case USB_REQ_GET_DESCRIPTOR : if ( ctrl -> bRequestType != USB_DIR_IN ) goto unknown ; switch ( w_value >> 8 ) { case USB_DT_DEVICE : cdev -> desc . bNumConfigurations = count_configs ( cdev , USB_DT_DEVICE ) ; cdev -> desc . bMaxPacketSize0 = cdev -> gadget -> ep0 -> maxpacket ; if ( gadget_is_superspeed ( gadget ) ) { if ( gadget -> speed >= USB_SPEED_SUPER ) { cdev -> desc . bcdUSB = cpu_to_le16 ( 0x0320 ) ; cdev -> desc . bMaxPacketSize0 = 9 ; } else { cdev -> desc . bcdUSB = cpu_to_le16 ( 0x0210 ) ; } } else { if ( gadget -> lpm_capable ) cdev -> desc . bcdUSB = cpu_to_le16 ( 0x0201 ) ; else cdev -> desc . bcdUSB = cpu_to_le16 ( 0x0200 ) ; } value = min ( w_length , ( u16 ) sizeof cdev -> desc ) ; memcpy ( req -> buf , & cdev -> desc , value ) ; break ; case USB_DT_DEVICE_QUALIFIER : if ( ! gadget_is_dualspeed ( gadget ) || gadget -> speed >= USB_SPEED_SUPER ) break ; device_qual ( cdev ) ; value = min_t ( int , w_length , sizeof ( struct usb_qualifier_descriptor ) ) ; break ; case USB_DT_OTHER_SPEED_CONFIG : if ( ! gadget_is_dualspeed ( gadget ) || gadget -> speed >= USB_SPEED_SUPER ) break ; fallthrough ; case USB_DT_CONFIG : value = config_desc ( cdev , w_value ) ; if ( value >= 0 ) value = min ( w_length , ( u16 ) value ) ; break ; case USB_DT_STRING : value = get_string ( cdev , req -> buf , w_index , w_value & 0xff ) ; if ( value >= 0 ) value = min ( w_length , ( u16 ) value ) ; break ; case USB_DT_BOS : if ( gadget_is_superspeed ( gadget ) || gadget -> lpm_capable ) { value = bos_desc ( cdev ) ; value = min ( w_length , ( u16 ) value ) ; } break ; case USB_DT_OTG : if ( gadget_is_otg ( gadget ) ) { struct usb_configuration * config ; int otg_desc_len = 0 ; if ( cdev -> config ) config = cdev -> config ; else config = list_first_entry ( & cdev -> configs , struct usb_configuration , list ) ; if ( ! config ) goto done ; if ( gadget -> otg_caps && ( gadget -> otg_caps -> otg_rev >= 0x0200 ) ) otg_desc_len += sizeof ( struct usb_otg20_descriptor ) ; else otg_desc_len += sizeof ( struct usb_otg_descriptor ) ; value = min_t ( int , w_length , otg_desc_len ) ; memcpy ( req -> buf , config -> descriptors [ 0 ] , value ) ; } break ; } break ; case USB_REQ_SET_CONFIGURATION : if ( ctrl -> bRequestType != 0 ) goto unknown ; if ( gadget_is_otg ( gadget ) ) { if ( gadget -> a_hnp_support ) DBG ( cdev , \"HNP<S2SV_blank>available\\\\n\" ) ; else if ( gadget -> a_alt_hnp_support ) DBG ( cdev , \"HNP<S2SV_blank>on<S2SV_blank>another<S2SV_blank>port\\\\n\" ) ; else VDBG ( cdev , \"HNP<S2SV_blank>inactive\\\\n\" ) ; } spin_lock ( & cdev -> lock ) ; value = set_config ( cdev , ctrl , w_value ) ; spin_unlock ( & cdev -> lock ) ; break ; case USB_REQ_GET_CONFIGURATION : if ( ctrl -> bRequestType != USB_DIR_IN ) goto unknown ; if ( cdev -> config ) * ( u8 * ) req -> buf = cdev -> config -> bConfigurationValue ; else * ( u8 * ) req -> buf = 0 ; value = min ( w_length , ( u16 ) 1 ) ; break ; case USB_REQ_SET_INTERFACE : if ( ctrl -> bRequestType != USB_RECIP_INTERFACE ) goto unknown ; if ( ! cdev -> config || intf >= MAX_CONFIG_INTERFACES ) break ; f = cdev -> config -> interface [ intf ] ; if ( ! f ) break ; if ( w_value && ! f -> get_alt ) break ; spin_lock ( & cdev -> lock ) ; value = f -> set_alt ( f , w_index , w_value ) ; if ( value == USB_GADGET_DELAYED_STATUS ) { DBG ( cdev , \"%s:<S2SV_blank>interface<S2SV_blank>%d<S2SV_blank>(%s)<S2SV_blank>requested<S2SV_blank>delayed<S2SV_blank>status\\\\n\" , __func__ , intf , f -> name ) ; cdev -> delayed_status ++ ; DBG ( cdev , \"delayed_status<S2SV_blank>count<S2SV_blank>%d\\\\n\" , cdev -> delayed_status ) ; } spin_unlock ( & cdev -> lock ) ; break ; case USB_REQ_GET_INTERFACE : if ( ctrl -> bRequestType != ( USB_DIR_IN | USB_RECIP_INTERFACE ) ) goto unknown ; if ( ! cdev -> config || intf >= MAX_CONFIG_INTERFACES ) break ; f = cdev -> config -> interface [ intf ] ; if ( ! f ) break ; value = f -> get_alt ? f -> get_alt ( f , w_index ) : 0 ; if ( value < 0 ) break ; * ( ( u8 * ) req -> buf ) = value ; value = min ( w_length , ( u16 ) 1 ) ; break ; case USB_REQ_GET_STATUS : if ( gadget_is_otg ( gadget ) && gadget -> hnp_polling_support && ( w_index == OTG_STS_SELECTOR ) ) { if ( ctrl -> bRequestType != ( USB_DIR_IN | USB_RECIP_DEVICE ) ) goto unknown ; * ( ( u8 * ) req -> buf ) = gadget -> host_request_flag ; value = 1 ; break ; } if ( ! gadget_is_superspeed ( gadget ) ) goto unknown ; if ( ctrl -> bRequestType != ( USB_DIR_IN | USB_RECIP_INTERFACE ) ) goto unknown ; value = 2 ; put_unaligned_le16 ( 0 , req -> buf ) ; if ( ! cdev -> config || intf >= MAX_CONFIG_INTERFACES ) break ; f = cdev -> config -> interface [ intf ] ; if ( ! f ) break ; status = f -> get_status ? f -> get_status ( f ) : 0 ; if ( status < 0 ) break ; put_unaligned_le16 ( status & 0x0000ffff , req -> buf ) ; break ; case USB_REQ_CLEAR_FEATURE : case USB_REQ_SET_FEATURE : if ( ! gadget_is_superspeed ( gadget ) ) goto unknown ; if ( ctrl -> bRequestType != ( USB_DIR_OUT | USB_RECIP_INTERFACE ) ) goto unknown ; switch ( w_value ) { case USB_INTRF_FUNC_SUSPEND : if ( ! cdev -> config || intf >= MAX_CONFIG_INTERFACES ) break ; f = cdev -> config -> interface [ intf ] ; if ( ! f ) break ; value = 0 ; if ( f -> func_suspend ) value = f -> func_suspend ( f , w_index >> 8 ) ; if ( value < 0 ) { ERROR ( cdev , \"func_suspend()<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>%d\\\\n\" , value ) ; value = 0 ; } break ; } break ; default : unknown : if ( cdev -> use_os_string && cdev -> os_desc_config && ( ctrl -> bRequestType & USB_TYPE_VENDOR ) && ctrl -> bRequest == cdev -> b_vendor_code ) { struct usb_configuration * os_desc_cfg ; u8 * buf ; int interface ; int count = 0 ; req = cdev -> os_desc_req ; req -> context = cdev ; req -> complete = composite_setup_complete ; buf = req -> buf ; os_desc_cfg = cdev -> os_desc_config ; w_length = min_t ( u16 , w_length , USB_COMP_EP0_OS_DESC_BUFSIZ ) ; memset ( buf , 0 , w_length ) ; buf [ 5 ] = 0x01 ; switch ( ctrl -> bRequestType & USB_RECIP_MASK ) { case USB_RECIP_DEVICE : if ( w_index != 0x4 || ( w_value >> 8 ) ) break ; buf [ 6 ] = w_index ; count = count_ext_compat ( os_desc_cfg ) ; buf [ 8 ] = count ; count *= 24 ; count += 16 ; put_unaligned_le32 ( count , buf ) ; value = w_length ; if ( w_length > 0x10 ) { value = fill_ext_compat ( os_desc_cfg , buf ) ; value = min_t ( u16 , w_length , value ) ; } break ; case USB_RECIP_INTERFACE : if ( w_index != 0x5 || ( w_value >> 8 ) ) break ; <S2SV_StartBug> interface = w_value & 0xFF ; <S2SV_EndBug> buf [ 6 ] = w_index ; count = count_ext_prop ( os_desc_cfg , interface ) ; put_unaligned_le16 ( count , buf + 8 ) ; count = len_ext_prop ( os_desc_cfg , interface ) ; put_unaligned_le32 ( count , buf ) ; value = w_length ; if ( w_length > 0x0A ) { value = fill_ext_prop ( os_desc_cfg , interface , buf ) ; if ( value >= 0 ) value = min_t ( u16 , w_length , value ) ; } break ; } goto check_value ; } VDBG ( cdev , \"non-core<S2SV_blank>control<S2SV_blank>req%02x.%02x<S2SV_blank>v%04x<S2SV_blank>i%04x<S2SV_blank>l%d\\\\n\" , ctrl -> bRequestType , ctrl -> bRequest , w_value , w_index , w_length ) ; if ( cdev -> config ) { list_for_each_entry ( f , & cdev -> config -> functions , list ) if ( f -> req_match && f -> req_match ( f , ctrl , false ) ) goto try_fun_setup ; } else { struct usb_configuration * c ; list_for_each_entry ( c , & cdev -> configs , list ) list_for_each_entry ( f , & c -> functions , list ) if ( f -> req_match && f -> req_match ( f , ctrl , true ) ) goto try_fun_setup ; } f = NULL ; switch ( ctrl -> bRequestType & USB_RECIP_MASK ) { case USB_RECIP_INTERFACE : if ( ! cdev -> config || intf >= MAX_CONFIG_INTERFACES ) break ; f = cdev -> config -> interface [ intf ] ; break ; case USB_RECIP_ENDPOINT : if ( ! cdev -> config ) break ; endp = ( ( w_index & 0x80 ) >> 3 ) | ( w_index & 0x0f ) ; list_for_each_entry ( f , & cdev -> config -> functions , list ) { if ( test_bit ( endp , f -> endpoints ) ) break ; } if ( & f -> list == & cdev -> config -> functions ) f = NULL ; break ; } try_fun_setup : if ( f && f -> setup ) value = f -> setup ( f , ctrl ) ; else { struct usb_configuration * c ; c = cdev -> config ; if ( ! c ) goto done ; if ( c -> setup ) { value = c -> setup ( c , ctrl ) ; goto done ; } if ( ! list_is_singular ( & c -> functions ) ) goto done ; f = list_first_entry ( & c -> functions , struct usb_function , list ) ; if ( f -> setup ) value = f -> setup ( f , ctrl ) ; } goto done ; } check_value : if ( value >= 0 && value != USB_GADGET_DELAYED_STATUS ) { req -> length = value ; req -> context = cdev ; req -> zero = value < w_length ; value = composite_ep0_queue ( cdev , req , GFP_ATOMIC ) ; if ( value < 0 ) { DBG ( cdev , \"ep_queue<S2SV_blank>--><S2SV_blank>%d\\\\n\" , value ) ; req -> status = 0 ; composite_setup_complete ( gadget -> ep0 , req ) ; } } else if ( value == USB_GADGET_DELAYED_STATUS && w_length != 0 ) { WARN ( cdev , \"%s:<S2SV_blank>Delayed<S2SV_blank>status<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>w_length<S2SV_blank>!=<S2SV_blank>0\" , __func__ ) ; } done : return value ; }", "target": "<S2SV_ModStart> w_value & 0xFF ; if ( interface >= MAX_CONFIG_INTERFACES || ! os_desc_cfg -> interface [ interface ] ) break"}
{"source": "CWE-20 static bool tipc_crypto_key_rcv ( struct tipc_crypto * rx , struct tipc_msg * hdr ) { struct tipc_crypto * tx = tipc_net ( rx -> net ) -> crypto_tx ; struct tipc_aead_key * skey = NULL ; u16 key_gen = msg_key_gen ( hdr ) ; u16 size = msg_data_sz ( hdr ) ; u8 * data = msg_data ( hdr ) ; <S2SV_StartBug> <S2SV_EndBug> spin_lock ( & rx -> lock ) ; if ( unlikely ( rx -> skey || ( key_gen == rx -> key_gen && rx -> key . keys ) ) ) { pr_err ( \"%s:<S2SV_blank>key<S2SV_blank>existed<S2SV_blank><%p>,<S2SV_blank>gen<S2SV_blank>%d<S2SV_blank>vs<S2SV_blank>%d\\\\n\" , rx -> name , rx -> skey , key_gen , rx -> key_gen ) ; <S2SV_StartBug> goto exit ; <S2SV_EndBug> } skey = kmalloc ( size , GFP_ATOMIC ) ; if ( unlikely ( ! skey ) ) { pr_err ( \"%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>skey\\\\n\" , rx -> name ) ; <S2SV_StartBug> goto exit ; <S2SV_EndBug> } skey -> keylen = ntohl ( * ( ( __be32 * ) ( data + TIPC_AEAD_ALG_NAME ) ) ) ; memcpy ( skey -> alg_name , data , TIPC_AEAD_ALG_NAME ) ; memcpy ( skey -> key , data + TIPC_AEAD_ALG_NAME + sizeof ( __be32 ) , skey -> keylen ) ; if ( unlikely ( size != tipc_aead_key_size ( skey ) ) ) { kfree ( skey ) ; skey = NULL ; goto exit ; } rx -> key_gen = key_gen ; rx -> skey_mode = msg_key_mode ( hdr ) ; rx -> skey = skey ; rx -> nokey = 0 ; <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> exit : <S2SV_StartBug> spin_unlock ( & rx -> lock ) ; <S2SV_EndBug> if ( likely ( skey && queue_delayed_work ( tx -> wq , & rx -> work , 0 ) ) ) return true ; return false ; }", "target": "<S2SV_ModStart> hdr ) ; unsigned int keylen ; if ( unlikely ( size < sizeof ( struct tipc_aead_key ) + TIPC_AEAD_KEYLEN_MIN ) ) { pr_debug ( \"%s:<S2SV_blank>message<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\\\n\" , rx -> name ) ; goto exit ; } keylen = ntohl ( * ( ( __be32 * ) ( data + TIPC_AEAD_ALG_NAME ) ) ) ; if ( unlikely ( size != keylen + sizeof ( struct tipc_aead_key ) || keylen > TIPC_AEAD_KEY_SIZE_MAX ) ) { pr_debug ( \"%s:<S2SV_blank>invalid<S2SV_blank>MSG_CRYPTO<S2SV_blank>key<S2SV_blank>size\\\\n\" , rx -> name ) ; goto exit ; } <S2SV_ModStart> ) ; goto exit_unlock <S2SV_ModEnd> ; } skey <S2SV_ModStart> ) ; goto exit_unlock ; } skey -> keylen = keylen ; memcpy ( skey -> alg_name , data , TIPC_AEAD_ALG_NAME ) ; memcpy ( skey -> key , data + TIPC_AEAD_ALG_NAME + sizeof ( __be32 ) , skey -> keylen ) ; <S2SV_ModEnd> rx -> key_gen <S2SV_ModStart> ; mb ( ) ; exit_unlock : spin_unlock ( & rx -> lock <S2SV_ModStart> ; exit : <S2SV_ModEnd> if ( likely"}
{"source": "CWE-787 R_API RBinJavaAttrInfo * r_bin_java_inner_classes_attr_new ( RBinJavaObj * bin , ut8 * buffer , ut64 sz , ut64 buf_offset ) { RBinJavaClassesAttribute * icattr ; RBinJavaAttrInfo * attr = NULL ; RBinJavaCPTypeObj * obj ; ut32 i = 0 ; ut64 offset = 0 , curpos ; attr = r_bin_java_default_attr_new ( bin , buffer , sz , buf_offset ) ; offset += 6 ; <S2SV_StartBug> if ( attr == NULL ) { <S2SV_EndBug> return attr ; } attr -> type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR ; attr -> info . inner_classes_attr . number_of_classes = R_BIN_JAVA_USHORT ( buffer , offset ) ; offset += 2 ; attr -> info . inner_classes_attr . classes = r_list_newf ( r_bin_java_inner_classes_attr_entry_free ) ; for ( i = 0 ; i < attr -> info . inner_classes_attr . number_of_classes ; i ++ ) { curpos = buf_offset + offset ; if ( offset + 8 > sz ) { eprintf ( \"Invalid<S2SV_blank>amount<S2SV_blank>of<S2SV_blank>inner<S2SV_blank>classes\\\\n\" ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } icattr = R_NEW0 ( RBinJavaClassesAttribute ) ; if ( ! icattr ) { break ; } icattr -> inner_class_info_idx = R_BIN_JAVA_USHORT ( buffer , offset ) ; offset += 2 ; <S2SV_StartBug> icattr -> outer_class_info_idx = R_BIN_JAVA_USHORT ( buffer , offset ) ; <S2SV_EndBug> offset += 2 ; <S2SV_StartBug> icattr -> inner_name_idx = R_BIN_JAVA_USHORT ( buffer , offset ) ; <S2SV_EndBug> offset += 2 ; <S2SV_StartBug> icattr -> inner_class_access_flags = R_BIN_JAVA_USHORT ( buffer , offset ) ; <S2SV_EndBug> offset += 2 ; <S2SV_StartBug> icattr -> flags_str = retrieve_class_method_access_string ( icattr -> inner_class_access_flags ) ; <S2SV_EndBug> icattr -> file_offset = curpos ; icattr -> size = 8 ; obj = r_bin_java_get_item_from_bin_cp_list ( R_BIN_JAVA_GLOBAL_BIN , icattr -> inner_name_idx ) ; if ( obj == NULL ) { eprintf ( \"BINCPLIS<S2SV_blank>IS<S2SV_blank>HULL<S2SV_blank>%d\\\\n\" , icattr -> inner_name_idx ) ; } icattr -> name = r_bin_java_get_item_name_from_bin_cp_list ( R_BIN_JAVA_GLOBAL_BIN , obj ) ; if ( ! icattr -> name ) { obj = r_bin_java_get_item_from_bin_cp_list ( R_BIN_JAVA_GLOBAL_BIN , icattr -> inner_class_info_idx ) ; if ( ! obj ) { eprintf ( \"BINCPLIST<S2SV_blank>IS<S2SV_blank>NULL<S2SV_blank>%d\\\\n\" , icattr -> inner_class_info_idx ) ; } icattr -> name = r_bin_java_get_item_name_from_bin_cp_list ( R_BIN_JAVA_GLOBAL_BIN , obj ) ; if ( ! icattr -> name ) { icattr -> name = r_str_dup ( NULL , \"NULL\" ) ; eprintf ( \"r_bin_java_inner_classes_attr:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>the<S2SV_blank>name<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>index.\\\\n\" , icattr -> inner_name_idx ) ; free ( icattr ) ; break ; } } IFDBG eprintf ( \"r_bin_java_inner_classes_attr:<S2SV_blank>Inner<S2SV_blank>class<S2SV_blank>name<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>%s.\\\\n\" , icattr -> inner_name_idx , icattr -> name ) ; r_list_append ( attr -> info . inner_classes_attr . classes , ( void * ) icattr ) ; } attr -> size = offset ; return attr ; }", "target": "<S2SV_ModStart> ; if ( buf_offset + <S2SV_ModEnd> offset + 8 <S2SV_ModStart> \"Invalid<S2SV_blank>amount<S2SV_blank>of<S2SV_blank>inner<S2SV_blank>classes\\\\n\" ) ; return NULL ; } if ( attr == NULL ) { return attr ; } attr -> type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR ; attr -> info . inner_classes_attr . number_of_classes <S2SV_ModEnd> = R_BIN_JAVA_USHORT ( <S2SV_ModStart> += 2 ; attr -> info . inner_classes_attr . classes = r_list_newf ( r_bin_java_inner_classes_attr_entry_free ) ; for ( i = 0 ; i < attr -> info . inner_classes_attr . number_of_classes ; i ++ ) { curpos = buf_offset + offset ; if ( buf_offset + offset + 8 > sz ) { eprintf ( \"Invalid<S2SV_blank>amount<S2SV_blank>of<S2SV_blank>inner<S2SV_blank>classes\\\\n\" ) ; break ; } icattr = R_NEW0 ( RBinJavaClassesAttribute ) ; if ( ! icattr ) { break ; } icattr -> inner_class_info_idx <S2SV_ModEnd> = R_BIN_JAVA_USHORT ( <S2SV_ModStart> ; icattr -> outer_class_info_idx <S2SV_ModEnd> = R_BIN_JAVA_USHORT ( <S2SV_ModStart> ; icattr -> inner_name_idx <S2SV_ModEnd> = R_BIN_JAVA_USHORT ( <S2SV_ModStart> ; icattr -> inner_class_access_flags = R_BIN_JAVA_USHORT ( buffer , offset ) ; offset += 2 ; icattr ->"}
{"source": "CWE-79 int RGWGetObj_ObjStore_S3 : : send_response_data ( bufferlist & bl , off_t bl_ofs , off_t bl_len ) { const char * content_type = NULL ; string content_type_str ; map < string , string > response_attrs ; map < string , string > : : iterator riter ; bufferlist metadata_bl ; string expires = get_s3_expiration_header ( s , lastmod ) ; if ( sent_header ) goto send_data ; if ( custom_http_ret ) { set_req_state_err ( s , 0 ) ; dump_errno ( s , custom_http_ret ) ; } else { set_req_state_err ( s , ( partial_content && ! op_ret ) ? STATUS_PARTIAL_CONTENT : op_ret ) ; dump_errno ( s ) ; } if ( op_ret ) goto done ; if ( range_str ) dump_range ( s , start , end , s -> obj_size ) ; if ( s -> system_request && s -> info . args . exists ( RGW_SYS_PARAM_PREFIX \"prepend-metadata\" ) ) { dump_header ( s , \"Rgwx-Object-Size\" , ( long long ) total_len ) ; if ( rgwx_stat ) { total_len = 0 ; } JSONFormatter jf ; jf . open_object_section ( \"obj_metadata\" ) ; encode_json ( \"attrs\" , attrs , & jf ) ; utime_t ut ( lastmod ) ; encode_json ( \"mtime\" , ut , & jf ) ; jf . close_section ( ) ; stringstream ss ; jf . flush ( ss ) ; metadata_bl . append ( ss . str ( ) ) ; dump_header ( s , \"Rgwx-Embedded-Metadata-Len\" , metadata_bl . length ( ) ) ; total_len += metadata_bl . length ( ) ; } if ( s -> system_request && ! real_clock : : is_zero ( lastmod ) ) { dump_epoch_header ( s , \"Rgwx-Mtime\" , lastmod ) ; uint64_t pg_ver = 0 ; int r = decode_attr_bl_single_value ( attrs , RGW_ATTR_PG_VER , & pg_ver , ( uint64_t ) 0 ) ; if ( r < 0 ) { ldpp_dout ( this , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>pg<S2SV_blank>ver<S2SV_blank>attr,<S2SV_blank>ignoring\" << dendl ; } dump_header ( s , \"Rgwx-Obj-PG-Ver\" , pg_ver ) ; uint32_t source_zone_short_id = 0 ; r = decode_attr_bl_single_value ( attrs , RGW_ATTR_SOURCE_ZONE , & source_zone_short_id , ( uint32_t ) 0 ) ; if ( r < 0 ) { ldpp_dout ( this , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>pg<S2SV_blank>ver<S2SV_blank>attr,<S2SV_blank>ignoring\" << dendl ; } if ( source_zone_short_id != 0 ) { dump_header ( s , \"Rgwx-Source-Zone-Short-Id\" , source_zone_short_id ) ; } } for ( auto & it : crypt_http_responses ) dump_header ( s , it . first , it . second ) ; dump_content_length ( s , total_len ) ; dump_last_modified ( s , lastmod ) ; dump_header_if_nonempty ( s , \"x-amz-version-id\" , version_id ) ; dump_header_if_nonempty ( s , \"x-amz-expiration\" , expires ) ; if ( attrs . find ( RGW_ATTR_APPEND_PART_NUM ) != attrs . end ( ) ) { dump_header ( s , \"x-rgw-object-type\" , \"Appendable\" ) ; dump_header ( s , \"x-rgw-next-append-position\" , s -> obj_size ) ; } else { dump_header ( s , \"x-rgw-object-type\" , \"Normal\" ) ; } if ( ! op_ret ) { if ( ! lo_etag . empty ( ) ) { dump_etag ( s , lo_etag ) ; } else { auto iter = attrs . find ( RGW_ATTR_ETAG ) ; if ( iter != attrs . end ( ) ) { dump_etag ( s , iter -> second . to_str ( ) ) ; } } for ( struct response_attr_param * p = resp_attr_params ; p -> param ; p ++ ) { bool exists ; string val = s -> info . args . get ( p -> param , & exists ) ; if ( exists ) { if ( s -> auth . identity -> is_anonymous ( ) ) { return - ERR_INVALID_REQUEST ; <S2SV_StartBug> } <S2SV_EndBug> if ( strcmp ( p -> param , \"response-content-type\" ) != 0 ) { response_attrs [ p -> http_attr ] = val ; } else { content_type_str = val ; content_type = content_type_str . c_str ( ) ; } } } for ( auto iter = attrs . begin ( ) ; iter != attrs . end ( ) ; ++ iter ) { const char * name = iter -> first . c_str ( ) ; map < string , string > : : iterator aiter = rgw_to_http_attrs . find ( name ) ; if ( aiter != rgw_to_http_attrs . end ( ) ) { if ( response_attrs . count ( aiter -> second ) == 0 ) { size_t len = iter -> second . length ( ) ; string s ( iter -> second . c_str ( ) , len ) ; while ( len && ! s [ len - 1 ] ) { -- len ; s . resize ( len ) ; } response_attrs [ aiter -> second ] = s ; } } else if ( iter -> first . compare ( RGW_ATTR_CONTENT_TYPE ) == 0 ) { if ( ! content_type ) { content_type_str = rgw_bl_str ( iter -> second ) ; content_type = content_type_str . c_str ( ) ; } } else if ( strcmp ( name , RGW_ATTR_SLO_UINDICATOR ) == 0 ) { dump_header ( s , \"X-Object-Meta-Static-Large-Object\" , \"True\" ) ; } else if ( strncmp ( name , RGW_ATTR_META_PREFIX , sizeof ( RGW_ATTR_META_PREFIX ) - 1 ) == 0 ) { name += sizeof ( RGW_ATTR_PREFIX ) - 1 ; dump_header ( s , name , iter -> second ) ; } else if ( iter -> first . compare ( RGW_ATTR_TAGS ) == 0 ) { RGWObjTags obj_tags ; try { auto it = iter -> second . cbegin ( ) ; obj_tags . decode ( it ) ; } catch ( buffer : : error & err ) { ldpp_dout ( this , 0 ) << \"Error<S2SV_blank>caught<S2SV_blank>buffer::error<S2SV_blank>couldn\\'t<S2SV_blank>decode<S2SV_blank>TagSet<S2SV_blank>\" << dendl ; } dump_header ( s , RGW_AMZ_TAG_COUNT , obj_tags . count ( ) ) ; } else if ( iter -> first . compare ( RGW_ATTR_OBJECT_RETENTION ) == 0 && get_retention ) { RGWObjectRetention retention ; try { decode ( retention , iter -> second ) ; dump_header ( s , \"x-amz-object-lock-mode\" , retention . get_mode ( ) ) ; dump_time_header ( s , \"x-amz-object-lock-retain-until-date\" , retention . get_retain_until_date ( ) ) ; } catch ( buffer : : error & err ) { ldpp_dout ( this , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>RGWObjectRetention\" << dendl ; } } else if ( iter -> first . compare ( RGW_ATTR_OBJECT_LEGAL_HOLD ) == 0 && get_legal_hold ) { RGWObjectLegalHold legal_hold ; try { decode ( legal_hold , iter -> second ) ; dump_header ( s , \"x-amz-object-lock-legal-hold\" , legal_hold . get_status ( ) ) ; } catch ( buffer : : error & err ) { ldpp_dout ( this , 0 ) << \"ERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>RGWObjectLegalHold\" << dendl ; } } } } done : for ( riter = response_attrs . begin ( ) ; riter != response_attrs . end ( ) ; ++ riter ) { dump_header ( s , riter -> first , riter -> second ) ; } if ( op_ret == - ERR_NOT_MODIFIED ) { end_header ( s , this ) ; } else { if ( ! content_type ) content_type = \"binary/octet-stream\" ; end_header ( s , this , content_type ) ; } if ( metadata_bl . length ( ) ) { dump_body ( s , metadata_bl ) ; } sent_header = true ; send_data : if ( get_data && ! op_ret ) { int r = dump_body ( s , bl . c_str ( ) + bl_ofs , bl_len ) ; if ( r < 0 ) return r ; } return 0 ; }", "target": "<S2SV_ModStart> ERR_INVALID_REQUEST ; } if ( str_has_cntrl ( val ) ) { return - ERR_INVALID_REQUEST ; }"}
{"source": "CWE-362 static int pfkey_register ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) { struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * supp_skb ; if ( hdr -> sadb_msg_satype > SADB_SATYPE_MAX ) return - EINVAL ; if ( hdr -> sadb_msg_satype != SADB_SATYPE_UNSPEC ) { if ( pfk -> registered & ( 1 << hdr -> sadb_msg_satype ) ) return - EEXIST ; pfk -> registered |= ( 1 << hdr -> sadb_msg_satype ) ; } <S2SV_StartBug> xfrm_probe_algs ( ) ; <S2SV_EndBug> supp_skb = compose_sadb_supported ( hdr , GFP_KERNEL | __GFP_ZERO ) ; <S2SV_StartBug> if ( ! supp_skb ) { <S2SV_EndBug> if ( hdr -> sadb_msg_satype != SADB_SATYPE_UNSPEC ) pfk -> registered &= ~ ( 1 << hdr -> sadb_msg_satype ) ; return - ENOBUFS ; } pfkey_broadcast ( supp_skb , GFP_KERNEL , BROADCAST_REGISTERED , sk , sock_net ( sk ) ) ; return 0 ; }", "target": "<S2SV_ModStart> ) ; } mutex_lock ( & pfkey_mutex ) ; <S2SV_ModStart> __GFP_ZERO ) ; mutex_unlock ( & pfkey_mutex ) ;"}
{"source": "CWE-787 int kvmppc_rtas_hcall ( struct kvm_vcpu * vcpu ) { struct rtas_token_definition * d ; struct rtas_args args ; rtas_arg_t * orig_rets ; gpa_t args_phys ; int rc ; args_phys = kvmppc_get_gpr ( vcpu , 4 ) & KVM_PAM ; vcpu -> srcu_idx = srcu_read_lock ( & vcpu -> kvm -> srcu ) ; rc = kvm_read_guest ( vcpu -> kvm , args_phys , & args , sizeof ( args ) ) ; srcu_read_unlock ( & vcpu -> kvm -> srcu , vcpu -> srcu_idx ) ; if ( rc ) goto fail ; orig_rets = args . rets ; <S2SV_StartBug> args . rets = & args . args [ be32_to_cpu ( args . nargs ) ] ; <S2SV_EndBug> mutex_lock ( & vcpu -> kvm -> arch . rtas_token_lock ) ; rc = - ENOENT ; list_for_each_entry ( d , & vcpu -> kvm -> arch . rtas_tokens , list ) { if ( d -> token == be32_to_cpu ( args . token ) ) { d -> handler -> handler ( vcpu , & args ) ; rc = 0 ; break ; } } mutex_unlock ( & vcpu -> kvm -> arch . rtas_token_lock ) ; if ( rc == 0 ) { args . rets = orig_rets ; rc = kvm_write_guest ( vcpu -> kvm , args_phys , & args , sizeof ( args ) ) ; if ( rc ) goto fail ; } return rc ; fail : return rc ; }", "target": "<S2SV_ModStart> . rets ; if ( be32_to_cpu ( args . nargs ) >= ARRAY_SIZE ( args . args ) ) { rc = - EINVAL ; goto fail ; }"}
{"source": "CWE-20 int qtm_decompress ( struct qtm_stream * qtm , off_t out_bytes ) { unsigned int frame_start , frame_end , window_posn , match_offset , range ; unsigned char * window , * i_ptr , * i_end , * runsrc , * rundest ; int i , j , selector , extra , sym , match_length , ret ; unsigned short H , L , C , symf ; register unsigned int bit_buffer ; register unsigned char bits_left ; unsigned char bits_needed , bit_run ; if ( ! qtm || ( out_bytes < 0 ) ) return CL_ENULLARG ; if ( qtm -> error ) return qtm -> error ; i = qtm -> o_end - qtm -> o_ptr ; if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; if ( i ) { if ( qtm -> wflag && ( ret = mspack_write ( qtm -> ofd , qtm -> o_ptr , i , qtm -> file ) ) != CL_SUCCESS ) { return qtm -> error = ret ; } qtm -> o_ptr += i ; out_bytes -= i ; } if ( out_bytes == 0 ) return CL_SUCCESS ; QTM_RESTORE_BITS ; window = qtm -> window ; window_posn = qtm -> window_posn ; frame_start = qtm -> frame_start ; H = qtm -> H ; L = qtm -> L ; C = qtm -> C ; while ( ( qtm -> o_end - qtm -> o_ptr ) < out_bytes ) { if ( ! qtm -> header_read ) { H = 0xFFFF ; L = 0 ; QTM_READ_BITS ( C , 16 ) ; qtm -> header_read = 1 ; } frame_end = window_posn + ( out_bytes - ( qtm -> o_end - qtm -> o_ptr ) ) ; if ( ( frame_start + QTM_FRAME_SIZE ) < frame_end ) { frame_end = frame_start + QTM_FRAME_SIZE ; } while ( window_posn < frame_end ) { QTM_GET_SYMBOL ( qtm -> model7 , selector ) ; if ( selector < 4 ) { struct qtm_model * mdl = ( selector == 0 ) ? & qtm -> model0 : ( ( selector == 1 ) ? & qtm -> model1 : ( ( selector == 2 ) ? & qtm -> model2 : & qtm -> model3 ) ) ; QTM_GET_SYMBOL ( ( * mdl ) , sym ) ; window [ window_posn ++ ] = sym ; } else { switch ( selector ) { case 4 : QTM_GET_SYMBOL ( qtm -> model4 , sym ) ; QTM_READ_BITS ( extra , qtm -> extra_bits [ sym ] ) ; match_offset = qtm -> position_base [ sym ] + extra + 1 ; match_length = 3 ; break ; case 5 : QTM_GET_SYMBOL ( qtm -> model5 , sym ) ; QTM_READ_BITS ( extra , qtm -> extra_bits [ sym ] ) ; match_offset = qtm -> position_base [ sym ] + extra + 1 ; match_length = 4 ; break ; case 6 : QTM_GET_SYMBOL ( qtm -> model6len , sym ) ; QTM_READ_BITS ( extra , qtm -> length_extra [ sym ] ) ; match_length = qtm -> length_base [ sym ] + extra + 5 ; QTM_GET_SYMBOL ( qtm -> model6 , sym ) ; QTM_READ_BITS ( extra , qtm -> extra_bits [ sym ] ) ; match_offset = qtm -> position_base [ sym ] + extra + 1 ; break ; default : return qtm -> error = CL_EFORMAT ; } <S2SV_StartBug> rundest = & window [ window_posn ] ; <S2SV_EndBug> i = match_length ; if ( match_offset > window_posn ) { j = match_offset - window_posn ; if ( j > ( int ) qtm -> window_size ) { cli_dbgmsg ( \"qtm_decompress:<S2SV_blank>match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>window<S2SV_blank>boundaries\\\\n\" ) ; return qtm -> error = CL_EFORMAT ; } runsrc = & window [ qtm -> window_size - j ] ; if ( j < i ) { i -= j ; while ( j -- > 0 ) * rundest ++ = * runsrc ++ ; runsrc = window ; } while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } else { runsrc = rundest - match_offset ; if ( i > ( int ) ( qtm -> window_size - window_posn ) ) i = qtm -> window_size - window_posn ; while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } window_posn += match_length ; } } qtm -> o_end = & window [ window_posn ] ; if ( ( window_posn - frame_start ) >= QTM_FRAME_SIZE ) { if ( ( window_posn - frame_start ) != QTM_FRAME_SIZE ) { cli_dbgmsg ( \"qtm_decompress:<S2SV_blank>overshot<S2SV_blank>frame<S2SV_blank>alignment\\\\n\" ) ; return qtm -> error = CL_EFORMAT ; } if ( bits_left & 7 ) QTM_REMOVE_BITS ( bits_left & 7 ) ; do { QTM_READ_BITS ( i , 8 ) ; } while ( i != 0xFF ) ; qtm -> header_read = 0 ; if ( window_posn == qtm -> window_size ) { i = ( qtm -> o_end - qtm -> o_ptr ) ; if ( qtm -> wflag && ( ret = mspack_write ( qtm -> ofd , qtm -> o_ptr , i , qtm -> file ) ) != CL_SUCCESS ) { return qtm -> error = ret ; } out_bytes -= i ; qtm -> o_ptr = & window [ 0 ] ; qtm -> o_end = & window [ 0 ] ; window_posn = 0 ; } frame_start = window_posn ; } } if ( out_bytes ) { i = ( int ) out_bytes ; if ( qtm -> wflag && ( ret = mspack_write ( qtm -> ofd , qtm -> o_ptr , i , qtm -> file ) ) != CL_SUCCESS ) { return qtm -> error = ret ; } qtm -> o_ptr += i ; } QTM_STORE_BITS ; qtm -> window_posn = window_posn ; qtm -> frame_start = frame_start ; qtm -> H = H ; qtm -> L = L ; qtm -> C = C ; return CL_SUCCESS ; }", "target": "<S2SV_ModStart> CL_EFORMAT ; } if ( window_posn + match_length > qtm -> window_size ) { cli_dbgmsg ( \"qtm_decompress:<S2SV_blank>match<S2SV_blank>ran<S2SV_blank>over<S2SV_blank>window<S2SV_blank>wrap\\\\n\" ) ; return qtm -> error = CL_EFORMAT ; }"}
{"source": "CWE-119 <S2SV_StartBug> void simplestring_addn ( simplestring * target , const char * source , int add_len ) { <S2SV_EndBug> if ( target && source ) { if ( ! target -> str ) { simplestring_init_str ( target ) ; } <S2SV_StartBug> if ( target -> len + add_len + 1 > target -> size ) { <S2SV_EndBug> <S2SV_StartBug> int newsize = target -> len + add_len + 1 ; <S2SV_EndBug> int incr = target -> size * 2 ; <S2SV_StartBug> newsize = newsize - ( newsize % incr ) + incr ; <S2SV_EndBug> target -> str = ( char * ) realloc ( target -> str , newsize ) ; target -> size = target -> str ? newsize : 0 ; } if ( target -> str ) { if ( add_len ) { memcpy ( target -> str + target -> len , source , add_len ) ; } target -> len += add_len ; target -> str [ target -> len ] = 0 ; } } }", "target": "<S2SV_ModStart> * source , size_t add_len ) { size_t newsize = target -> size , incr = 0 ; <S2SV_ModEnd> if ( target <S2SV_ModStart> ) ; } if ( ( SIZE_MAX - add_len ) < target -> len || ( SIZE_MAX - add_len - 1 ) < target -> len ) { return ; } <S2SV_ModStart> size ) { newsize = target -> len + add_len + 1 ; <S2SV_ModEnd> incr = target <S2SV_ModStart> * 2 ; if ( incr ) { <S2SV_ModStart> + incr ; } if ( newsize < ( target -> len + add_len + 1 ) ) { return ; }"}
{"source": "CWE-401 static int mlx5_fpga_conn_create_cq ( struct mlx5_fpga_conn * conn , int cq_size ) { struct mlx5_fpga_device * fdev = conn -> fdev ; struct mlx5_core_dev * mdev = fdev -> mdev ; u32 temp_cqc [ MLX5_ST_SZ_DW ( cqc ) ] = { 0 } ; u32 out [ MLX5_ST_SZ_DW ( create_cq_out ) ] ; struct mlx5_wq_param wqp ; struct mlx5_cqe64 * cqe ; int inlen , err , eqn ; unsigned int irqn ; void * cqc , * in ; __be64 * pas ; u32 i ; cq_size = roundup_pow_of_two ( cq_size ) ; MLX5_SET ( cqc , temp_cqc , log_cq_size , ilog2 ( cq_size ) ) ; wqp . buf_numa_node = mdev -> priv . numa_node ; wqp . db_numa_node = mdev -> priv . numa_node ; err = mlx5_cqwq_create ( mdev , & wqp , temp_cqc , & conn -> cq . wq , & conn -> cq . wq_ctrl ) ; if ( err ) return err ; for ( i = 0 ; i < mlx5_cqwq_get_size ( & conn -> cq . wq ) ; i ++ ) { cqe = mlx5_cqwq_get_wqe ( & conn -> cq . wq , i ) ; cqe -> op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK ; } inlen = MLX5_ST_SZ_BYTES ( create_cq_in ) + sizeof ( u64 ) * conn -> cq . wq_ctrl . buf . npages ; in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) { err = - ENOMEM ; goto err_cqwq ; } err = mlx5_vector2eqn ( mdev , smp_processor_id ( ) , & eqn , & irqn ) ; <S2SV_StartBug> if ( err ) <S2SV_EndBug> <S2SV_StartBug> goto err_cqwq ; <S2SV_EndBug> cqc = MLX5_ADDR_OF ( create_cq_in , in , cq_context ) ; MLX5_SET ( cqc , cqc , log_cq_size , ilog2 ( cq_size ) ) ; MLX5_SET ( cqc , cqc , c_eqn , eqn ) ; MLX5_SET ( cqc , cqc , uar_page , fdev -> conn_res . uar -> index ) ; MLX5_SET ( cqc , cqc , log_page_size , conn -> cq . wq_ctrl . buf . page_shift - MLX5_ADAPTER_PAGE_SHIFT ) ; MLX5_SET64 ( cqc , cqc , dbr_addr , conn -> cq . wq_ctrl . db . dma ) ; pas = ( __be64 * ) MLX5_ADDR_OF ( create_cq_in , in , pas ) ; mlx5_fill_page_frag_array ( & conn -> cq . wq_ctrl . buf , pas ) ; err = mlx5_core_create_cq ( mdev , & conn -> cq . mcq , in , inlen , out , sizeof ( out ) ) ; kvfree ( in ) ; if ( err ) goto err_cqwq ; conn -> cq . mcq . cqe_sz = 64 ; conn -> cq . mcq . set_ci_db = conn -> cq . wq_ctrl . db . db ; conn -> cq . mcq . arm_db = conn -> cq . wq_ctrl . db . db + 1 ; * conn -> cq . mcq . set_ci_db = 0 ; * conn -> cq . mcq . arm_db = 0 ; conn -> cq . mcq . vector = 0 ; conn -> cq . mcq . comp = mlx5_fpga_conn_cq_complete ; conn -> cq . mcq . event = mlx5_fpga_conn_cq_event ; conn -> cq . mcq . irqn = irqn ; conn -> cq . mcq . uar = fdev -> conn_res . uar ; tasklet_init ( & conn -> cq . tasklet , mlx5_fpga_conn_cq_tasklet , ( unsigned long ) conn ) ; mlx5_fpga_dbg ( fdev , \"Created<S2SV_blank>CQ<S2SV_blank>#0x%x\\\\n\" , conn -> cq . mcq . cqn ) ; goto out ; err_cqwq : mlx5_wq_destroy ( & conn -> cq . wq_ctrl ) ; out : return err ; }", "target": "<S2SV_ModStart> ( err ) { kvfree ( in ) ; <S2SV_ModStart> goto err_cqwq ; }"}
{"source": "CWE-476 static int qh_help ( int sd , char * buf , unsigned int len ) { struct query_handler * qh = NULL ; <S2SV_StartBug> if ( ! * buf || ! strcmp ( buf , \"help\" ) ) { <S2SV_EndBug> nsock_printf_nul ( sd , \"<S2SV_blank><S2SV_blank>help<S2SV_blank><name><S2SV_blank><S2SV_blank><S2SV_blank>show<S2SV_blank>help<S2SV_blank>for<S2SV_blank>handler<S2SV_blank><name>\\\\n\" \"<S2SV_blank><S2SV_blank>help<S2SV_blank>list<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>list<S2SV_blank>registered<S2SV_blank>handlers\\\\n\" ) ; return 0 ; } if ( ! strcmp ( buf , \"list\" ) ) { for ( qh = qhandlers ; qh != NULL ; qh = qh -> next_qh ) { nsock_printf ( sd , \"%-10s<S2SV_blank>%s\\\\n\" , qh -> name , qh -> description ? qh -> description : \"(No<S2SV_blank>description<S2SV_blank>available)\" ) ; } nsock_printf ( sd , \"%c\" , 0 ) ; return 0 ; } qh = qh_find_handler ( buf ) ; if ( qh == NULL ) { nsock_printf_nul ( sd , \"No<S2SV_blank>handler<S2SV_blank>named<S2SV_blank>\\'%s\\'<S2SV_blank>is<S2SV_blank>registered\\\\n\" , buf ) ; } else if ( qh -> handler ( sd , \"help\" , 4 ) > 200 ) { nsock_printf_nul ( sd , \"The<S2SV_blank>handler<S2SV_blank>%s<S2SV_blank>doesn\\'t<S2SV_blank>have<S2SV_blank>any<S2SV_blank>help<S2SV_blank>yet.\" , buf ) ; } return 0 ; }", "target": "<S2SV_ModStart> ; if ( buf == NULL <S2SV_ModEnd> || ! strcmp"}
{"source": "CWE-787 compileRule ( FileInfo * file , TranslationTableHeader * * table , DisplayTableHeader * * displayTable , const MacroList * * inScopeMacros ) { CharsString token ; TranslationTableOpcode opcode ; CharsString ruleChars ; CharsString ruleDots ; CharsString cells ; CharsString scratchPad ; CharsString emphClass ; TranslationTableCharacterAttributes after = 0 ; TranslationTableCharacterAttributes before = 0 ; int noback , nofor , nocross ; noback = nofor = nocross = 0 ; doOpcode : if ( ! getToken ( file , & token , NULL ) ) return 1 ; if ( token . chars [ 0 ] == '#' || token . chars [ 0 ] == '<' ) return 1 ; if ( file -> lineNumber == 1 && ( eqasc2uni ( ( unsigned char * ) \"ISO\" , token . chars , 3 ) || eqasc2uni ( ( unsigned char * ) \"UTF-8\" , token . chars , 5 ) ) ) { if ( table ) compileHyphenation ( file , & token , table ) ; else while ( _lou_getALine ( file ) ) ; return 1 ; } opcode = getOpcode ( file , & token ) ; switch ( opcode ) { case CTO_Macro : { const Macro * macro ; # ifdef ENABLE_MACROS if ( ! inScopeMacros ) { compileError ( file , \"Defining<S2SV_blank>macros<S2SV_blank>only<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>table<S2SV_blank>files.\" ) ; return 0 ; } if ( compileMacro ( file , & macro ) ) { * inScopeMacros = cons_macro ( macro , * inScopeMacros ) ; return 1 ; } return 0 ; # else compileError ( file , \"Macro<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled.\" ) ; return 0 ; # endif } case CTO_IncludeFile : { CharsString includedFile ; if ( ! getToken ( file , & token , \"include<S2SV_blank>file<S2SV_blank>name\" ) ) return 0 ; if ( ! parseChars ( file , & includedFile , & token ) ) return 0 ; return includeFile ( file , & includedFile , table , displayTable ) ; } case CTO_NoBack : if ( nofor ) { compileError ( file , \"%s<S2SV_blank>already<S2SV_blank>specified.\" , _lou_findOpcodeName ( CTO_NoFor ) ) ; return 0 ; } noback = 1 ; goto doOpcode ; case CTO_NoFor : if ( noback ) { compileError ( file , \"%s<S2SV_blank>already<S2SV_blank>specified.\" , _lou_findOpcodeName ( CTO_NoBack ) ) ; return 0 ; } nofor = 1 ; goto doOpcode ; case CTO_Space : return compileCharDef ( file , opcode , CTC_Space , noback , nofor , table , displayTable ) ; case CTO_Digit : return compileCharDef ( file , opcode , CTC_Digit , noback , nofor , table , displayTable ) ; case CTO_LitDigit : return compileCharDef ( file , opcode , CTC_LitDigit , noback , nofor , table , displayTable ) ; case CTO_Punctuation : return compileCharDef ( file , opcode , CTC_Punctuation , noback , nofor , table , displayTable ) ; case CTO_Math : return compileCharDef ( file , opcode , CTC_Math , noback , nofor , table , displayTable ) ; case CTO_Sign : return compileCharDef ( file , opcode , CTC_Sign , noback , nofor , table , displayTable ) ; case CTO_Letter : return compileCharDef ( file , opcode , CTC_Letter , noback , nofor , table , displayTable ) ; case CTO_UpperCase : return compileCharDef ( file , opcode , CTC_UpperCase , noback , nofor , table , displayTable ) ; case CTO_LowerCase : return compileCharDef ( file , opcode , CTC_LowerCase , noback , nofor , table , displayTable ) ; case CTO_Grouping : return compileGrouping ( file , noback , nofor , table , displayTable ) ; case CTO_Display : if ( ! displayTable ) return 1 ; if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ! getRuleDotsPattern ( file , & ruleDots ) ) return 0 ; if ( ruleChars . length != 1 || ruleDots . length != 1 ) { compileError ( file , \"Exactly<S2SV_blank>one<S2SV_blank>character<S2SV_blank>and<S2SV_blank>one<S2SV_blank>cell<S2SV_blank>are<S2SV_blank>required.\" ) ; return 0 ; } return putCharDotsMapping ( file , ruleChars . chars [ 0 ] , ruleDots . chars [ 0 ] , displayTable ) ; case CTO_UpLow : case CTO_None : { if ( inScopeMacros ) { const MacroList * macros = * inScopeMacros ; while ( macros ) { const Macro * m = macros -> head ; if ( token . length == strlen ( m -> name ) && eqasc2uni ( ( unsigned char * ) m -> name , token . chars , token . length ) ) { if ( ! inScopeMacros ) { compileError ( file , \"Calling<S2SV_blank>macros<S2SV_blank>only<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>table<S2SV_blank>files.\" ) ; return 0 ; } FileInfo tmpFile ; memset ( & tmpFile , 0 , sizeof ( tmpFile ) ) ; tmpFile . fileName = file -> fileName ; tmpFile . sourceFile = file -> sourceFile ; tmpFile . lineNumber = file -> lineNumber ; tmpFile . encoding = noEncoding ; tmpFile . status = 0 ; tmpFile . linepos = 0 ; tmpFile . linelen = 0 ; int argument_count = 0 ; CharsString * arguments = malloc ( m -> argument_count * sizeof ( CharsString ) ) ; while ( argument_count < m -> argument_count ) { if ( getToken ( file , & token , \"macro<S2SV_blank>argument\" ) ) arguments [ argument_count ++ ] = token ; else break ; } if ( argument_count < m -> argument_count ) { compileError ( file , \"Expected<S2SV_blank>%d<S2SV_blank>arguments\" , m -> argument_count ) ; return 0 ; } int i = 0 ; int subst = 0 ; int next = subst < m -> substitution_count ? m -> substitutions [ 2 * subst ] : m -> definition_length ; for ( ; ; ) { while ( i < next ) { widechar c = m -> definition [ i ++ ] ; if ( c == '\\\\n' ) { if ( ! compileRule ( & tmpFile , table , displayTable , inScopeMacros ) ) { _lou_logMessage ( LOU_LOG_ERROR , \"result<S2SV_blank>of<S2SV_blank>macro<S2SV_blank>expansion<S2SV_blank>was:<S2SV_blank>%s\" , _lou_showString ( tmpFile . line , tmpFile . linelen , 0 ) ) ; return 0 ; } tmpFile . linepos = 0 ; tmpFile . linelen = 0 ; } else if ( tmpFile . linelen >= MAXSTRING ) { compileError ( file , \"Line<S2SV_blank>exceeds<S2SV_blank>%d<S2SV_blank>characters<S2SV_blank>(post<S2SV_blank>macro<S2SV_blank>\" \"expansion)\" , MAXSTRING ) ; return 0 ; } else tmpFile . line [ tmpFile . linelen ++ ] = c ; } if ( subst < m -> substitution_count ) { CharsString arg = arguments [ m -> substitutions [ 2 * subst + 1 ] - 1 ] ; for ( int j = 0 ; j < arg . length ; j ++ ) tmpFile . line [ tmpFile . linelen ++ ] = arg . chars [ j ] ; subst ++ ; next = subst < m -> substitution_count ? m -> substitutions [ 2 * subst ] : m -> definition_length ; } else { if ( ! compileRule ( & tmpFile , table , displayTable , inScopeMacros ) ) { _lou_logMessage ( LOU_LOG_ERROR , \"result<S2SV_blank>of<S2SV_blank>macro<S2SV_blank>expansion<S2SV_blank>was:<S2SV_blank>%s\" , _lou_showString ( tmpFile . line , tmpFile . linelen , 0 ) ) ; return 0 ; } break ; } } return 1 ; } macros = macros -> tail ; } } if ( opcode == CTO_UpLow ) { compileError ( file , \"The<S2SV_blank>uplow<S2SV_blank>opcode<S2SV_blank>is<S2SV_blank>deprecated.\" ) ; return 0 ; } compileError ( file , \"opcode<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>defined.\" , _lou_showString ( token . chars , token . length , 0 ) ) ; return 0 ; } default : if ( ! table ) return 1 ; switch ( opcode ) { case CTO_Locale : compileWarning ( file , \"The<S2SV_blank>locale<S2SV_blank>opcode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>implemented.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>locale<S2SV_blank>meta<S2SV_blank>data<S2SV_blank>\" \"instead.\" ) ; return 1 ; case CTO_Undefined : { TranslationTableOffset ruleOffset = ( * table ) -> undefined ; if ( ! compileBrailleIndicator ( file , \"undefined<S2SV_blank>character<S2SV_blank>opcode\" , CTO_Undefined , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> undefined = ruleOffset ; return 1 ; } case CTO_Match : { int ok = 0 ; widechar * patterns = NULL ; TranslationTableRule * rule ; TranslationTableOffset ruleOffset ; CharsString ptn_before , ptn_after ; TranslationTableOffset patternsOffset ; int len , mrk ; size_t patternsByteSize = sizeof ( * patterns ) * 27720 ; patterns = ( widechar * ) malloc ( patternsByteSize ) ; if ( ! patterns ) _lou_outOfMemory ( ) ; memset ( patterns , 0xffff , patternsByteSize ) ; noback = 1 ; getCharacters ( file , & ptn_before ) ; getRuleCharsText ( file , & ruleChars ) ; getCharacters ( file , & ptn_after ) ; getRuleDotsPattern ( file , & ruleDots ) ; if ( ! addRule ( file , opcode , & ruleChars , & ruleDots , after , before , & ruleOffset , & rule , noback , nofor , table ) ) goto CTO_Match_cleanup ; if ( ptn_before . chars [ 0 ] == '-' && ptn_before . length == 1 ) len = _lou_pattern_compile ( & ptn_before . chars [ 0 ] , 0 , & patterns [ 1 ] , 13841 , * table , file ) ; else len = _lou_pattern_compile ( & ptn_before . chars [ 0 ] , ptn_before . length , & patterns [ 1 ] , 13841 , * table , file ) ; if ( ! len ) goto CTO_Match_cleanup ; mrk = patterns [ 0 ] = len + 1 ; _lou_pattern_reverse ( & patterns [ 1 ] ) ; if ( ptn_after . chars [ 0 ] == '-' && ptn_after . length == 1 ) len = _lou_pattern_compile ( & ptn_after . chars [ 0 ] , 0 , & patterns [ mrk ] , 13841 , * table , file ) ; else len = _lou_pattern_compile ( & ptn_after . chars [ 0 ] , ptn_after . length , & patterns [ mrk ] , 13841 , * table , file ) ; if ( ! len ) goto CTO_Match_cleanup ; len += mrk ; if ( ! allocateSpaceInTranslationTable ( file , & patternsOffset , len * sizeof ( widechar ) , table ) ) goto CTO_Match_cleanup ; rule = ( TranslationTableRule * ) & ( * table ) -> ruleArea [ ruleOffset ] ; memcpy ( & ( * table ) -> ruleArea [ patternsOffset ] , patterns , len * sizeof ( widechar ) ) ; rule -> patterns = patternsOffset ; ok = 1 ; CTO_Match_cleanup : free ( patterns ) ; return ok ; } case CTO_BackMatch : { int ok = 0 ; widechar * patterns = NULL ; TranslationTableRule * rule ; TranslationTableOffset ruleOffset ; CharsString ptn_before , ptn_after ; TranslationTableOffset patternOffset ; int len , mrk ; size_t patternsByteSize = sizeof ( * patterns ) * 27720 ; patterns = ( widechar * ) malloc ( patternsByteSize ) ; if ( ! patterns ) _lou_outOfMemory ( ) ; memset ( patterns , 0xffff , patternsByteSize ) ; nofor = 1 ; getCharacters ( file , & ptn_before ) ; getRuleCharsText ( file , & ruleChars ) ; getCharacters ( file , & ptn_after ) ; getRuleDotsPattern ( file , & ruleDots ) ; if ( ! addRule ( file , opcode , & ruleChars , & ruleDots , 0 , 0 , & ruleOffset , & rule , noback , nofor , table ) ) goto CTO_BackMatch_cleanup ; if ( ptn_before . chars [ 0 ] == '-' && ptn_before . length == 1 ) len = _lou_pattern_compile ( & ptn_before . chars [ 0 ] , 0 , & patterns [ 1 ] , 13841 , * table , file ) ; else len = _lou_pattern_compile ( & ptn_before . chars [ 0 ] , ptn_before . length , & patterns [ 1 ] , 13841 , * table , file ) ; if ( ! len ) goto CTO_BackMatch_cleanup ; mrk = patterns [ 0 ] = len + 1 ; _lou_pattern_reverse ( & patterns [ 1 ] ) ; if ( ptn_after . chars [ 0 ] == '-' && ptn_after . length == 1 ) len = _lou_pattern_compile ( & ptn_after . chars [ 0 ] , 0 , & patterns [ mrk ] , 13841 , * table , file ) ; else len = _lou_pattern_compile ( & ptn_after . chars [ 0 ] , ptn_after . length , & patterns [ mrk ] , 13841 , * table , file ) ; if ( ! len ) goto CTO_BackMatch_cleanup ; len += mrk ; if ( ! allocateSpaceInTranslationTable ( file , & patternOffset , len * sizeof ( widechar ) , table ) ) goto CTO_BackMatch_cleanup ; rule = ( TranslationTableRule * ) & ( * table ) -> ruleArea [ ruleOffset ] ; memcpy ( & ( * table ) -> ruleArea [ patternOffset ] , patterns , len * sizeof ( widechar ) ) ; rule -> patterns = patternOffset ; ok = 1 ; CTO_BackMatch_cleanup : free ( patterns ) ; return ok ; } case CTO_CapsLetter : case CTO_BegCapsWord : case CTO_EndCapsWord : case CTO_BegCaps : case CTO_EndCaps : case CTO_BegCapsPhrase : case CTO_EndCapsPhrase : case CTO_LenCapsPhrase : case CTO_ModeLetter : case CTO_BegModeWord : case CTO_EndModeWord : case CTO_BegMode : case CTO_EndMode : case CTO_BegModePhrase : case CTO_EndModePhrase : case CTO_LenModePhrase : { TranslationTableCharacterAttributes mode ; int i ; switch ( opcode ) { case CTO_CapsLetter : case CTO_BegCapsWord : case CTO_EndCapsWord : case CTO_BegCaps : case CTO_EndCaps : case CTO_BegCapsPhrase : case CTO_EndCapsPhrase : case CTO_LenCapsPhrase : mode = CTC_UpperCase ; i = 0 ; opcode += ( CTO_ModeLetter - CTO_CapsLetter ) ; break ; default : if ( ! getToken ( file , & token , \"attribute<S2SV_blank>name\" ) ) return 0 ; if ( ! ( * table ) -> characterClasses && ! allocateCharacterClasses ( * table ) ) { return 0 ; } const CharacterClass * characterClass = findCharacterClass ( & token , * table ) ; if ( ! characterClass ) { characterClass = addCharacterClass ( file , token . chars , token . length , * table , 1 ) ; if ( ! characterClass ) return 0 ; } mode = characterClass -> attribute ; if ( ! ( mode == CTC_UpperCase || mode == CTC_Digit ) && mode >= CTC_Space && mode <= CTC_LitDigit ) { compileError ( file , \"mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\\\"uppercase\\\\\",<S2SV_blank>\\\\\"digit\\\\\",<S2SV_blank>or<S2SV_blank>a<S2SV_blank>custom<S2SV_blank>\" \"attribute<S2SV_blank>name.\" ) ; return 0 ; } if ( mode == CTC_UpperCase ) i = 0 ; else { for ( i = 1 ; i < MAX_MODES && ( * table ) -> modes [ i ] . value ; i ++ ) { if ( ( * table ) -> modes [ i ] . mode == mode ) { break ; } } if ( i == MAX_MODES ) { compileError ( file , \"Max<S2SV_blank>number<S2SV_blank>of<S2SV_blank>modes<S2SV_blank>(%i)<S2SV_blank>reached\" , MAX_MODES ) ; return 0 ; } } } if ( ! ( * table ) -> modes [ i ] . value ) ( * table ) -> modes [ i ] = ( EmphasisClass ) { plain_text , mode , 0x1 << ( MAX_EMPH_CLASSES + i ) , MAX_EMPH_CLASSES + i } ; switch ( opcode ) { case CTO_BegModePhrase : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ begPhraseOffset ] ; if ( ! compileBrailleIndicator ( file , \"first<S2SV_blank>word<S2SV_blank>capital<S2SV_blank>sign\" , CTO_BegCapsPhraseRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ begPhraseOffset ] = ruleOffset ; return 1 ; } case CTO_EndModePhrase : { TranslationTableOffset ruleOffset ; switch ( compileBeforeAfter ( file ) ) { case 1 : if ( ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endPhraseAfterOffset ] ) { compileError ( file , \"Capital<S2SV_blank>sign<S2SV_blank>after<S2SV_blank>last<S2SV_blank>word<S2SV_blank>already<S2SV_blank>defined.\" ) ; return 0 ; } ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endPhraseBeforeOffset ] ; if ( ! compileBrailleIndicator ( file , \"capital<S2SV_blank>sign<S2SV_blank>before<S2SV_blank>last<S2SV_blank>word\" , CTO_EndCapsPhraseBeforeRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endPhraseBeforeOffset ] = ruleOffset ; return 1 ; case 2 : if ( ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endPhraseBeforeOffset ] ) { compileError ( file , \"Capital<S2SV_blank>sign<S2SV_blank>before<S2SV_blank>last<S2SV_blank>word<S2SV_blank>already<S2SV_blank>defined.\" ) ; return 0 ; } ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endPhraseAfterOffset ] ; if ( ! compileBrailleIndicator ( file , \"capital<S2SV_blank>sign<S2SV_blank>after<S2SV_blank>last<S2SV_blank>word\" , CTO_EndCapsPhraseAfterRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endPhraseAfterOffset ] = ruleOffset ; return 1 ; default : compileError ( file , \"Invalid<S2SV_blank>lastword<S2SV_blank>indicator<S2SV_blank>location.\" ) ; return 0 ; } return 0 ; } case CTO_BegMode : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ begOffset ] ; if ( ! compileBrailleIndicator ( file , \"first<S2SV_blank>letter<S2SV_blank>capital<S2SV_blank>sign\" , CTO_BegCapsRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ begOffset ] = ruleOffset ; return 1 ; } case CTO_EndMode : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endOffset ] ; if ( ! compileBrailleIndicator ( file , \"last<S2SV_blank>letter<S2SV_blank>capital<S2SV_blank>sign\" , CTO_EndCapsRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endOffset ] = ruleOffset ; return 1 ; } case CTO_ModeLetter : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ letterOffset ] ; if ( ! compileBrailleIndicator ( file , \"single<S2SV_blank>letter<S2SV_blank>capital<S2SV_blank>sign\" , CTO_CapsLetterRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ letterOffset ] = ruleOffset ; return 1 ; } case CTO_BegModeWord : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ begWordOffset ] ; if ( ! compileBrailleIndicator ( file , \"capital<S2SV_blank>word\" , CTO_BegCapsWordRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ begWordOffset ] = ruleOffset ; return 1 ; } case CTO_EndModeWord : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endWordOffset ] ; if ( ! compileBrailleIndicator ( file , \"capital<S2SV_blank>word<S2SV_blank>stop\" , CTO_EndCapsWordRule + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ endWordOffset ] = ruleOffset ; return 1 ; } case CTO_LenModePhrase : return ( * table ) -> emphRules [ MAX_EMPH_CLASSES + i ] [ lenPhraseOffset ] = compileNumber ( file ) ; default : break ; } break ; } case CTO_EmphClass : if ( ! getToken ( file , & emphClass , \"emphasis<S2SV_blank>class\" ) ) { compileError ( file , \"emphclass<S2SV_blank>must<S2SV_blank>be<S2SV_blank>followed<S2SV_blank>by<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>class<S2SV_blank>name.\" ) ; return 0 ; } int k , i ; char * s = malloc ( sizeof ( char ) * ( emphClass . length + 1 ) ) ; for ( k = 0 ; k < emphClass . length ; k ++ ) s [ k ] = ( char ) emphClass . chars [ k ] ; s [ k ++ ] = '\\\\0' ; for ( i = 0 ; i < MAX_EMPH_CLASSES && ( * table ) -> emphClassNames [ i ] ; i ++ ) if ( strcmp ( s , ( * table ) -> emphClassNames [ i ] ) == 0 ) { _lou_logMessage ( LOU_LOG_WARN , \"Duplicate<S2SV_blank>emphasis<S2SV_blank>class:<S2SV_blank>%s\" , s ) ; warningCount ++ ; free ( s ) ; return 1 ; } if ( i == MAX_EMPH_CLASSES ) { _lou_logMessage ( LOU_LOG_ERROR , \"Max<S2SV_blank>number<S2SV_blank>of<S2SV_blank>emphasis<S2SV_blank>classes<S2SV_blank>(%i)<S2SV_blank>reached\" , MAX_EMPH_CLASSES ) ; errorCount ++ ; free ( s ) ; return 0 ; } switch ( i ) { case 0 : if ( strcmp ( s , \"italic\" ) != 0 ) { _lou_logMessage ( LOU_LOG_ERROR , \"First<S2SV_blank>emphasis<S2SV_blank>class<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\\\"italic\\\\\"<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" \"%s\" , s ) ; errorCount ++ ; free ( s ) ; return 0 ; } break ; case 1 : if ( strcmp ( s , \"underline\" ) != 0 ) { _lou_logMessage ( LOU_LOG_ERROR , \"Second<S2SV_blank>emphasis<S2SV_blank>class<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\\\"underline\\\\\"<S2SV_blank>but<S2SV_blank>\" \"got<S2SV_blank>\" \"%s\" , s ) ; errorCount ++ ; free ( s ) ; return 0 ; } break ; case 2 : if ( strcmp ( s , \"bold\" ) != 0 ) { _lou_logMessage ( LOU_LOG_ERROR , \"Third<S2SV_blank>emphasis<S2SV_blank>class<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\\\"bold\\\\\"<S2SV_blank>but<S2SV_blank>got<S2SV_blank>\" \"%s\" , s ) ; errorCount ++ ; free ( s ) ; return 0 ; } break ; } ( * table ) -> emphClassNames [ i ] = s ; ( * table ) -> emphClasses [ i ] = ( EmphasisClass ) { emph_1 << i , 0 , 0x1 << i , i } ; return 1 ; case CTO_EmphLetter : case CTO_BegEmphWord : case CTO_EndEmphWord : case CTO_BegEmph : case CTO_EndEmph : case CTO_BegEmphPhrase : case CTO_EndEmphPhrase : case CTO_LenEmphPhrase : case CTO_EmphModeChars : case CTO_NoEmphChars : { if ( ! getToken ( file , & token , \"emphasis<S2SV_blank>class\" ) ) return 0 ; if ( ! parseChars ( file , & emphClass , & token ) ) return 0 ; char * s = malloc ( sizeof ( char ) * ( emphClass . length + 1 ) ) ; int k , i ; for ( k = 0 ; k < emphClass . length ; k ++ ) s [ k ] = ( char ) emphClass . chars [ k ] ; s [ k ++ ] = '\\\\0' ; for ( i = 0 ; i < MAX_EMPH_CLASSES && ( * table ) -> emphClassNames [ i ] ; i ++ ) if ( strcmp ( s , ( * table ) -> emphClassNames [ i ] ) == 0 ) break ; if ( i == MAX_EMPH_CLASSES || ! ( * table ) -> emphClassNames [ i ] ) { _lou_logMessage ( LOU_LOG_ERROR , \"Emphasis<S2SV_blank>class<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>declared\" , s ) ; errorCount ++ ; free ( s ) ; return 0 ; } int ok = 0 ; switch ( opcode ) { case CTO_EmphLetter : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ letterOffset ] ; if ( ! compileBrailleIndicator ( file , \"single<S2SV_blank>letter\" , CTO_Emph1LetterRule + letterOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ letterOffset ] = ruleOffset ; ok = 1 ; break ; } case CTO_BegEmphWord : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ begWordOffset ] ; if ( ! compileBrailleIndicator ( file , \"word\" , CTO_Emph1LetterRule + begWordOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ begWordOffset ] = ruleOffset ; ok = 1 ; break ; } case CTO_EndEmphWord : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ endWordOffset ] ; if ( ! compileBrailleIndicator ( file , \"word<S2SV_blank>stop\" , CTO_Emph1LetterRule + endWordOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ endWordOffset ] = ruleOffset ; ok = 1 ; break ; } case CTO_BegEmph : { if ( ( * table ) -> emphRules [ i ] [ begWordOffset ] || ( * table ) -> emphRules [ i ] [ begPhraseOffset ] ) { compileError ( file , \"Cannot<S2SV_blank>define<S2SV_blank>emphasis<S2SV_blank>for<S2SV_blank>both<S2SV_blank>no<S2SV_blank>context<S2SV_blank>and<S2SV_blank>word<S2SV_blank>or<S2SV_blank>\" \"phrase<S2SV_blank>context,<S2SV_blank>i.e.<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>both<S2SV_blank>begemph<S2SV_blank>and<S2SV_blank>\" \"begemphword<S2SV_blank>or<S2SV_blank>begemphphrase.\" ) ; break ; } TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ begOffset ] ; if ( ! compileBrailleIndicator ( file , \"first<S2SV_blank>letter\" , CTO_Emph1LetterRule + begOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ begOffset ] = ruleOffset ; ok = 1 ; break ; } case CTO_EndEmph : { if ( ( * table ) -> emphRules [ i ] [ endWordOffset ] || ( * table ) -> emphRules [ i ] [ endPhraseBeforeOffset ] || ( * table ) -> emphRules [ i ] [ endPhraseAfterOffset ] ) { compileError ( file , \"Cannot<S2SV_blank>define<S2SV_blank>emphasis<S2SV_blank>for<S2SV_blank>both<S2SV_blank>no<S2SV_blank>context<S2SV_blank>and<S2SV_blank>word<S2SV_blank>or<S2SV_blank>\" \"phrase<S2SV_blank>context,<S2SV_blank>i.e.<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>both<S2SV_blank>endemph<S2SV_blank>and<S2SV_blank>\" \"endemphword<S2SV_blank>or<S2SV_blank>endemphphrase.\" ) ; break ; } TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ endOffset ] ; if ( ! compileBrailleIndicator ( file , \"last<S2SV_blank>letter\" , CTO_Emph1LetterRule + endOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ endOffset ] = ruleOffset ; ok = 1 ; break ; } case CTO_BegEmphPhrase : { TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ begPhraseOffset ] ; if ( ! compileBrailleIndicator ( file , \"first<S2SV_blank>word\" , CTO_Emph1LetterRule + begPhraseOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ begPhraseOffset ] = ruleOffset ; ok = 1 ; break ; } case CTO_EndEmphPhrase : switch ( compileBeforeAfter ( file ) ) { case 1 : { if ( ( * table ) -> emphRules [ i ] [ endPhraseAfterOffset ] ) { compileError ( file , \"last<S2SV_blank>word<S2SV_blank>after<S2SV_blank>already<S2SV_blank>defined.\" ) ; break ; } TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ endPhraseBeforeOffset ] ; if ( ! compileBrailleIndicator ( file , \"last<S2SV_blank>word<S2SV_blank>before\" , CTO_Emph1LetterRule + endPhraseBeforeOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ endPhraseBeforeOffset ] = ruleOffset ; ok = 1 ; break ; } case 2 : { if ( ( * table ) -> emphRules [ i ] [ endPhraseBeforeOffset ] ) { compileError ( file , \"last<S2SV_blank>word<S2SV_blank>before<S2SV_blank>already<S2SV_blank>defined.\" ) ; break ; } TranslationTableOffset ruleOffset = ( * table ) -> emphRules [ i ] [ endPhraseAfterOffset ] ; if ( ! compileBrailleIndicator ( file , \"last<S2SV_blank>word<S2SV_blank>after\" , CTO_Emph1LetterRule + endPhraseAfterOffset + ( 8 * i ) , & ruleOffset , noback , nofor , table ) ) break ; ( * table ) -> emphRules [ i ] [ endPhraseAfterOffset ] = ruleOffset ; ok = 1 ; break ; } default : compileError ( file , \"Invalid<S2SV_blank>lastword<S2SV_blank>indicator<S2SV_blank>location.\" ) ; break ; } break ; case CTO_LenEmphPhrase : if ( ( ( * table ) -> emphRules [ i ] [ lenPhraseOffset ] = compileNumber ( file ) ) ) ok = 1 ; break ; case CTO_EmphModeChars : { if ( ! getRuleCharsText ( file , & ruleChars ) ) break ; widechar * emphmodechars = ( * table ) -> emphModeChars [ i ] ; int len ; for ( len = 0 ; len < EMPHMODECHARSSIZE && emphmodechars [ len ] ; len ++ ) ; if ( len + ruleChars . length > EMPHMODECHARSSIZE ) { compileError ( file , \"More<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>characters\" , EMPHMODECHARSSIZE ) ; break ; } ok = 1 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { if ( ! getChar ( ruleChars . chars [ k ] , * table , NULL ) ) { compileError ( file , \"Emphasis<S2SV_blank>mode<S2SV_blank>character<S2SV_blank>undefined\" ) ; ok = 0 ; break ; } emphmodechars [ len ++ ] = ruleChars . chars [ k ] ; } break ; } case CTO_NoEmphChars : { if ( ! getRuleCharsText ( file , & ruleChars ) ) break ; widechar * noemphchars = ( * table ) -> noEmphChars [ i ] ; int len ; for ( len = 0 ; len < NOEMPHCHARSSIZE && noemphchars [ len ] ; len ++ ) ; if ( len + ruleChars . length > NOEMPHCHARSSIZE ) { compileError ( file , \"More<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>characters\" , NOEMPHCHARSSIZE ) ; break ; } ok = 1 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { if ( ! getChar ( ruleChars . chars [ k ] , * table , NULL ) ) { compileError ( file , \"Character<S2SV_blank>undefined\" ) ; ok = 0 ; break ; } noemphchars [ len ++ ] = ruleChars . chars [ k ] ; } break ; } default : break ; } free ( s ) ; return ok ; } case CTO_LetterSign : { TranslationTableOffset ruleOffset = ( * table ) -> letterSign ; if ( ! compileBrailleIndicator ( file , \"letter<S2SV_blank>sign\" , CTO_LetterRule , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> letterSign = ruleOffset ; return 1 ; } case CTO_NoLetsignBefore : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ( ( * table ) -> noLetsignBeforeCount + ruleChars . length ) > LETSIGNBEFORESIZE ) { compileError ( file , \"More<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>characters\" , LETSIGNBEFORESIZE ) ; return 0 ; } for ( int k = 0 ; k < ruleChars . length ; k ++ ) ( * table ) -> noLetsignBefore [ ( * table ) -> noLetsignBeforeCount ++ ] = ruleChars . chars [ k ] ; return 1 ; case CTO_NoLetsign : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ( ( * table ) -> noLetsignCount + ruleChars . length ) > LETSIGNSIZE ) { compileError ( file , \"More<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>characters\" , LETSIGNSIZE ) ; return 0 ; } for ( int k = 0 ; k < ruleChars . length ; k ++ ) ( * table ) -> noLetsign [ ( * table ) -> noLetsignCount ++ ] = ruleChars . chars [ k ] ; return 1 ; case CTO_NoLetsignAfter : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ( ( * table ) -> noLetsignAfterCount + ruleChars . length ) > LETSIGNAFTERSIZE ) { compileError ( file , \"More<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>characters\" , LETSIGNAFTERSIZE ) ; return 0 ; } for ( int k = 0 ; k < ruleChars . length ; k ++ ) ( * table ) -> noLetsignAfter [ ( * table ) -> noLetsignAfterCount ++ ] = ruleChars . chars [ k ] ; return 1 ; case CTO_NumberSign : { TranslationTableOffset ruleOffset = ( * table ) -> numberSign ; if ( ! compileBrailleIndicator ( file , \"number<S2SV_blank>sign\" , CTO_NumberRule , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> numberSign = ruleOffset ; return 1 ; } case CTO_NumericModeChars : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! c ) { compileError ( file , \"Numeric<S2SV_blank>mode<S2SV_blank>character<S2SV_blank>undefined:<S2SV_blank>%s\" , _lou_showString ( & ruleChars . chars [ k ] , 1 , 0 ) ) ; return 0 ; } c -> attributes |= CTC_NumericMode ; ( * table ) -> usesNumericMode = 1 ; } return 1 ; case CTO_MidEndNumericModeChars : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! c ) { compileError ( file , \"Midendnumeric<S2SV_blank>mode<S2SV_blank>character<S2SV_blank>undefined\" ) ; return 0 ; } c -> attributes |= CTC_MidEndNumericMode ; ( * table ) -> usesNumericMode = 1 ; } return 1 ; case CTO_NumericNoContractChars : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! c ) { compileError ( file , \"Numeric<S2SV_blank>no<S2SV_blank>contraction<S2SV_blank>character<S2SV_blank>undefined\" ) ; return 0 ; } c -> attributes |= CTC_NumericNoContract ; ( * table ) -> usesNumericMode = 1 ; } return 1 ; case CTO_NoContractSign : { TranslationTableOffset ruleOffset = ( * table ) -> noContractSign ; if ( ! compileBrailleIndicator ( file , \"no<S2SV_blank>contractions<S2SV_blank>sign\" , CTO_NoContractRule , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> noContractSign = ruleOffset ; return 1 ; } case CTO_SeqDelimiter : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! c ) { compileError ( file , \"Sequence<S2SV_blank>delimiter<S2SV_blank>character<S2SV_blank>undefined\" ) ; return 0 ; } c -> attributes |= CTC_SeqDelimiter ; ( * table ) -> usesSequences = 1 ; } return 1 ; case CTO_SeqBeforeChars : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! c ) { compileError ( file , \"Sequence<S2SV_blank>before<S2SV_blank>character<S2SV_blank>undefined\" ) ; return 0 ; } c -> attributes |= CTC_SeqBefore ; } return 1 ; case CTO_SeqAfterChars : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! c ) { compileError ( file , \"Sequence<S2SV_blank>after<S2SV_blank>character<S2SV_blank>undefined\" ) ; return 0 ; } c -> attributes |= CTC_SeqAfter ; } return 1 ; case CTO_SeqAfterPattern : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ( ( * table ) -> seqPatternsCount + ruleChars . length + 1 ) > SEQPATTERNSIZE ) { compileError ( file , \"More<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>characters\" , SEQPATTERNSIZE ) ; return 0 ; } for ( int k = 0 ; k < ruleChars . length ; k ++ ) ( * table ) -> seqPatterns [ ( * table ) -> seqPatternsCount ++ ] = ruleChars . chars [ k ] ; ( * table ) -> seqPatterns [ ( * table ) -> seqPatternsCount ++ ] = 0 ; return 1 ; case CTO_SeqAfterExpression : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; <S2SV_StartBug> for ( ( * table ) -> seqAfterExpressionLength = 0 ; <S2SV_EndBug> <S2SV_StartBug> ( * table ) -> seqAfterExpressionLength < ruleChars . length ; <S2SV_EndBug> <S2SV_StartBug> ( * table ) -> seqAfterExpressionLength ++ ) <S2SV_EndBug> ( * table ) -> seqAfterExpression [ ( * table ) -> seqAfterExpressionLength ] = ruleChars . chars [ ( * table ) -> seqAfterExpressionLength ] ; ( * table ) -> seqAfterExpression [ ( * table ) -> seqAfterExpressionLength ] = 0 ; return 1 ; case CTO_CapsModeChars : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! c ) { compileError ( file , \"Capital<S2SV_blank>mode<S2SV_blank>character<S2SV_blank>undefined\" ) ; return 0 ; } c -> attributes |= CTC_CapsMode ; ( * table ) -> hasCapsModeChars = 1 ; } return 1 ; case CTO_BegComp : { TranslationTableOffset ruleOffset = ( * table ) -> begComp ; if ( ! compileBrailleIndicator ( file , \"begin<S2SV_blank>computer<S2SV_blank>braille\" , CTO_BegCompRule , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> begComp = ruleOffset ; return 1 ; } case CTO_EndComp : { TranslationTableOffset ruleOffset = ( * table ) -> endComp ; if ( ! compileBrailleIndicator ( file , \"end<S2SV_blank>computer<S2SV_blank>braslle\" , CTO_EndCompRule , & ruleOffset , noback , nofor , table ) ) return 0 ; ( * table ) -> endComp = ruleOffset ; return 1 ; } case CTO_NoCross : if ( nocross ) { compileError ( file , \"%s<S2SV_blank>already<S2SV_blank>specified.\" , _lou_findOpcodeName ( CTO_NoCross ) ) ; return 0 ; } nocross = 1 ; goto doOpcode ; case CTO_Syllable : ( * table ) -> syllables = 1 ; case CTO_Always : case CTO_LargeSign : case CTO_WholeWord : case CTO_PartWord : case CTO_JoinNum : case CTO_JoinableWord : case CTO_LowWord : case CTO_SuffixableWord : case CTO_PrefixableWord : case CTO_BegWord : case CTO_BegMidWord : case CTO_MidWord : case CTO_MidEndWord : case CTO_EndWord : case CTO_PrePunc : case CTO_PostPunc : case CTO_BegNum : case CTO_MidNum : case CTO_EndNum : case CTO_Repeated : case CTO_RepWord : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ! getRuleDotsPattern ( file , & ruleDots ) ) return 0 ; if ( ruleDots . length == 0 ) for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! ( c && ( c -> definitionRule || c -> basechar ) ) ) { compileError ( file , \"Character<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>defined\" , _lou_showString ( & ruleChars . chars [ k ] , 1 , 0 ) ) ; return 0 ; } } TranslationTableRule * r ; if ( ! addRule ( file , opcode , & ruleChars , & ruleDots , after , before , NULL , & r , noback , nofor , table ) ) return 0 ; if ( nocross ) r -> nocross = 1 ; return 1 ; case CTO_RepEndWord : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; CharsString dots ; if ( ! getToken ( file , & dots , \"dots,dots<S2SV_blank>operand\" ) ) return 0 ; int len = dots . length ; for ( int k = 0 ; k < len - 1 ; k ++ ) { if ( dots . chars [ k ] == ',' ) { dots . length = k ; if ( ! parseDots ( file , & ruleDots , & dots ) ) return 0 ; ruleDots . chars [ ruleDots . length ++ ] = ',' ; k ++ ; if ( k == len - 1 && dots . chars [ k ] == '=' ) { for ( int l = 0 ; l < ruleChars . length ; l ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ l ] , * table , NULL ) ; if ( ! ( c && ( c -> definitionRule || c -> basechar ) ) ) { compileError ( file , \"Character<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>defined\" , _lou_showString ( & ruleChars . chars [ l ] , 1 , 0 ) ) ; return 0 ; } } } else { CharsString x , y ; x . length = 0 ; while ( k < len ) x . chars [ x . length ++ ] = dots . chars [ k ++ ] ; if ( parseDots ( file , & y , & x ) ) for ( int l = 0 ; l < y . length ; l ++ ) ruleDots . chars [ ruleDots . length ++ ] = y . chars [ l ] ; } return addRule ( file , opcode , & ruleChars , & ruleDots , after , before , NULL , NULL , noback , nofor , table ) ; } } return 0 ; case CTO_CompDots : case CTO_Comp6 : { TranslationTableOffset ruleOffset ; if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ruleChars . length != 1 ) { compileError ( file , \"first<S2SV_blank>operand<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>character\" ) ; return 0 ; } if ( nofor || noback ) { compileWarning ( file , \"nofor<S2SV_blank>and<S2SV_blank>noback<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>on<S2SV_blank>comp6<S2SV_blank>rules\" ) ; } if ( ! getRuleDotsPattern ( file , & ruleDots ) ) return 0 ; if ( ! addRule ( file , opcode , & ruleChars , & ruleDots , after , before , & ruleOffset , NULL , noback , nofor , table ) ) return 0 ; return 1 ; } case CTO_ExactDots : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ruleChars . chars [ 0 ] != '@' ) { compileError ( file , \"The<S2SV_blank>operand<S2SV_blank>must<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>an<S2SV_blank>at<S2SV_blank>sign<S2SV_blank>(@)\" ) ; return 0 ; } for ( int k = 1 ; k < ruleChars . length ; k ++ ) scratchPad . chars [ k - 1 ] = ruleChars . chars [ k ] ; scratchPad . length = ruleChars . length - 1 ; if ( ! parseDots ( file , & ruleDots , & scratchPad ) ) return 0 ; return addRule ( file , opcode , & ruleChars , & ruleDots , before , after , NULL , NULL , noback , nofor , table ) ; case CTO_CapsNoCont : { TranslationTableOffset ruleOffset ; ruleChars . length = 1 ; ruleChars . chars [ 0 ] = 'a' ; if ( ! addRule ( file , CTO_CapsNoContRule , & ruleChars , NULL , after , before , & ruleOffset , NULL , noback , nofor , table ) ) return 0 ; ( * table ) -> capsNoCont = ruleOffset ; return 1 ; } case CTO_Replace : if ( getRuleCharsText ( file , & ruleChars ) ) { if ( atEndOfLine ( file ) ) ruleDots . length = ruleDots . chars [ 0 ] = 0 ; else { getRuleDotsText ( file , & ruleDots ) ; if ( ruleDots . chars [ 0 ] == '#' ) ruleDots . length = ruleDots . chars [ 0 ] = 0 ; else if ( ruleDots . chars [ 0 ] == '\\\\\\\\' && ruleDots . chars [ 1 ] == '#' ) memmove ( & ruleDots . chars [ 0 ] , & ruleDots . chars [ 1 ] , ruleDots . length -- * CHARSIZE ) ; } } for ( int k = 0 ; k < ruleChars . length ; k ++ ) putChar ( file , ruleChars . chars [ k ] , table , NULL ) ; for ( int k = 0 ; k < ruleDots . length ; k ++ ) putChar ( file , ruleDots . chars [ k ] , table , NULL ) ; return addRule ( file , opcode , & ruleChars , & ruleDots , after , before , NULL , NULL , noback , nofor , table ) ; case CTO_Correct : ( * table ) -> corrections = 1 ; goto doPass ; case CTO_Pass2 : if ( ( * table ) -> numPasses < 2 ) ( * table ) -> numPasses = 2 ; goto doPass ; case CTO_Pass3 : if ( ( * table ) -> numPasses < 3 ) ( * table ) -> numPasses = 3 ; goto doPass ; case CTO_Pass4 : if ( ( * table ) -> numPasses < 4 ) ( * table ) -> numPasses = 4 ; doPass : case CTO_Context : if ( ! ( nofor || noback ) ) { compileError ( file , \"%s<S2SV_blank>or<S2SV_blank>%s<S2SV_blank>must<S2SV_blank>be<S2SV_blank>specified.\" , _lou_findOpcodeName ( CTO_NoFor ) , _lou_findOpcodeName ( CTO_NoBack ) ) ; return 0 ; } return compilePassOpcode ( file , opcode , noback , nofor , table ) ; case CTO_Contraction : case CTO_NoCont : case CTO_CompBrl : case CTO_Literal : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; for ( int k = 0 ; k < ruleChars . length ; k ++ ) { TranslationTableCharacter * c = getChar ( ruleChars . chars [ k ] , * table , NULL ) ; if ( ! ( c && ( c -> definitionRule || c -> basechar ) ) ) { compileError ( file , \"Character<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>defined\" , _lou_showString ( & ruleChars . chars [ k ] , 1 , 0 ) ) ; return 0 ; } } return addRule ( file , opcode , & ruleChars , NULL , after , before , NULL , NULL , noback , nofor , table ) ; case CTO_MultInd : { ruleChars . length = 0 ; if ( ! getToken ( file , & token , \"multiple<S2SV_blank>braille<S2SV_blank>indicators\" ) || ! parseDots ( file , & cells , & token ) ) return 0 ; while ( getToken ( file , & token , \"multind<S2SV_blank>opcodes\" ) ) { opcode = getOpcode ( file , & token ) ; if ( opcode == CTO_None ) { compileError ( file , \"opcode<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>defined.\" , _lou_showString ( token . chars , token . length , 0 ) ) ; return 0 ; } if ( ! ( opcode >= CTO_CapsLetter && opcode < CTO_MultInd ) ) { compileError ( file , \"Not<S2SV_blank>a<S2SV_blank>braille<S2SV_blank>indicator<S2SV_blank>opcode.\" ) ; return 0 ; } ruleChars . chars [ ruleChars . length ++ ] = ( widechar ) opcode ; if ( atEndOfLine ( file ) ) break ; } return addRule ( file , CTO_MultInd , & ruleChars , & cells , after , before , NULL , NULL , noback , nofor , table ) ; } case CTO_Class : compileWarning ( file , \"class<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>use<S2SV_blank>attribute<S2SV_blank>instead\" ) ; case CTO_Attribute : { if ( nofor || noback ) { compileWarning ( file , \"nofor<S2SV_blank>and<S2SV_blank>noback<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>before<S2SV_blank>class/attribute\" ) ; } if ( ( opcode == CTO_Class && ( * table ) -> usesAttributeOrClass == 1 ) || ( opcode == CTO_Attribute && ( * table ) -> usesAttributeOrClass == 2 ) ) { compileError ( file , \"attribute<S2SV_blank>and<S2SV_blank>class<S2SV_blank>rules<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>both<S2SV_blank>present<S2SV_blank>in<S2SV_blank>a<S2SV_blank>table\" ) ; return 0 ; } if ( opcode == CTO_Class ) ( * table ) -> usesAttributeOrClass = 2 ; else ( * table ) -> usesAttributeOrClass = 1 ; if ( ! getToken ( file , & token , \"attribute<S2SV_blank>name\" ) ) { compileError ( file , \"Expected<S2SV_blank>%s\" , \"attribute<S2SV_blank>name\" ) ; return 0 ; } if ( ! ( * table ) -> characterClasses && ! allocateCharacterClasses ( * table ) ) { return 0 ; } TranslationTableCharacterAttributes attribute = 0 ; { int attrNumber = - 1 ; switch ( token . chars [ 0 ] ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : attrNumber = token . chars [ 0 ] - '0' ; break ; } if ( attrNumber >= 0 ) { if ( opcode == CTO_Class ) { compileError ( file , \"Invalid<S2SV_blank>class<S2SV_blank>name:<S2SV_blank>may<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>digits,<S2SV_blank>use<S2SV_blank>\" \"attribute<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>class\" ) ; return 0 ; } if ( token . length > 1 || attrNumber > 7 ) { compileError ( file , \"Invalid<S2SV_blank>attribute<S2SV_blank>name:<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>digit<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>7<S2SV_blank>\" \"or<S2SV_blank>a<S2SV_blank>word<S2SV_blank>containing<S2SV_blank>only<S2SV_blank>letters\" ) ; return 0 ; } if ( ! ( * table ) -> numberedAttributes [ attrNumber ] ) ( * table ) -> numberedAttributes [ attrNumber ] = getNextNumberedAttribute ( * table ) ; attribute = ( * table ) -> numberedAttributes [ attrNumber ] ; } else { const CharacterClass * namedAttr = findCharacterClass ( & token , * table ) ; if ( ! namedAttr ) { namedAttr = addCharacterClass ( file , & token . chars [ 0 ] , token . length , * table , 1 ) ; if ( ! namedAttr ) return 0 ; } attribute = namedAttr -> attribute ; if ( attribute == CTC_UpperCase || attribute == CTC_LowerCase ) attribute |= CTC_Letter ; } } CharsString characters ; if ( ! getCharacters ( file , & characters ) ) return 0 ; for ( int i = 0 ; i < characters . length ; i ++ ) { TranslationTableCharacter * character = putChar ( file , characters . chars [ i ] , table , NULL ) ; character -> attributes |= attribute ; if ( character -> basechar ) character = ( TranslationTableCharacter * ) & ( * table ) -> ruleArea [ character -> basechar ] ; if ( character -> definitionRule ) { TranslationTableRule * defRule = ( TranslationTableRule * ) & ( * table ) -> ruleArea [ character -> definitionRule ] ; if ( defRule -> dotslen == 1 ) { TranslationTableCharacter * dots = getDots ( defRule -> charsdots [ defRule -> charslen ] , * table ) ; if ( dots ) dots -> attributes |= attribute ; } } } return 1 ; } { TranslationTableCharacterAttributes * attributes ; const CharacterClass * class ; case CTO_After : attributes = & after ; goto doBeforeAfter ; case CTO_Before : attributes = & before ; doBeforeAfter : if ( ! ( * table ) -> characterClasses ) { if ( ! allocateCharacterClasses ( * table ) ) return 0 ; } if ( ! getToken ( file , & token , \"attribute<S2SV_blank>name\" ) ) return 0 ; if ( ! ( class = findCharacterClass ( & token , * table ) ) ) { compileError ( file , \"attribute<S2SV_blank>not<S2SV_blank>defined\" ) ; return 0 ; } * attributes |= class -> attribute ; goto doOpcode ; } case CTO_Base : if ( nofor || noback ) { compileWarning ( file , \"nofor<S2SV_blank>and<S2SV_blank>noback<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>before<S2SV_blank>base\" ) ; } if ( ! getToken ( file , & token , \"attribute<S2SV_blank>name\" ) ) { compileError ( file , \"base<S2SV_blank>opcode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>followed<S2SV_blank>by<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>attribute<S2SV_blank>name.\" ) ; return 0 ; } if ( ! ( * table ) -> characterClasses && ! allocateCharacterClasses ( * table ) ) { return 0 ; } const CharacterClass * mode = findCharacterClass ( & token , * table ) ; if ( ! mode ) { mode = addCharacterClass ( file , token . chars , token . length , * table , 1 ) ; if ( ! mode ) return 0 ; } if ( ! ( mode -> attribute == CTC_UpperCase || mode -> attribute == CTC_Digit ) && mode -> attribute >= CTC_Space && mode -> attribute <= CTC_LitDigit ) { compileError ( file , \"base<S2SV_blank>opcode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>followed<S2SV_blank>by<S2SV_blank>\\\\\"uppercase\\\\\",<S2SV_blank>\\\\\"digit\\\\\",<S2SV_blank>or<S2SV_blank>a<S2SV_blank>\" \"custom<S2SV_blank>attribute<S2SV_blank>name.\" ) ; return 0 ; } if ( ! getRuleCharsText ( file , & token ) ) return 0 ; if ( token . length != 1 ) { compileError ( file , \"Exactly<S2SV_blank>one<S2SV_blank>character<S2SV_blank>followed<S2SV_blank>by<S2SV_blank>one<S2SV_blank>base<S2SV_blank>character<S2SV_blank>is<S2SV_blank>\" \"required.\" ) ; return 0 ; } TranslationTableOffset characterOffset ; TranslationTableCharacter * character = putChar ( file , token . chars [ 0 ] , table , & characterOffset ) ; if ( ! getRuleCharsText ( file , & token ) ) return 0 ; if ( token . length != 1 ) { compileError ( file , \"Exactly<S2SV_blank>one<S2SV_blank>base<S2SV_blank>character<S2SV_blank>is<S2SV_blank>required.\" ) ; return 0 ; } if ( character -> definitionRule ) { TranslationTableRule * prevRule = ( TranslationTableRule * ) & ( * table ) -> ruleArea [ character -> definitionRule ] ; _lou_logMessage ( LOU_LOG_DEBUG , \"%s:%d:<S2SV_blank>Character<S2SV_blank>already<S2SV_blank>defined<S2SV_blank>(%s).<S2SV_blank>The<S2SV_blank>base<S2SV_blank>rule<S2SV_blank>will<S2SV_blank>take<S2SV_blank>\" \"precedence.\" , file -> fileName , file -> lineNumber , printSource ( file , prevRule -> sourceFile , prevRule -> sourceLine ) ) ; character -> definitionRule = 0 ; } TranslationTableOffset basechar ; putChar ( file , token . chars [ 0 ] , table , & basechar ) ; character = ( TranslationTableCharacter * ) & ( * table ) -> ruleArea [ characterOffset ] ; if ( character -> basechar ) { if ( character -> basechar == basechar && character -> mode == mode -> attribute ) { _lou_logMessage ( LOU_LOG_DEBUG , \"%s:%d:<S2SV_blank>Duplicate<S2SV_blank>base<S2SV_blank>rule.\" , file -> fileName , file -> lineNumber ) ; } else { _lou_logMessage ( LOU_LOG_DEBUG , \"%s:%d:<S2SV_blank>A<S2SV_blank>different<S2SV_blank>base<S2SV_blank>rule<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>for<S2SV_blank>this<S2SV_blank>\" \"character<S2SV_blank>(%s).<S2SV_blank>The<S2SV_blank>new<S2SV_blank>rule<S2SV_blank>will<S2SV_blank>take<S2SV_blank>precedence.\" , file -> fileName , file -> lineNumber , printSource ( file , character -> sourceFile , character -> sourceLine ) ) ; } } character -> basechar = basechar ; character -> mode = mode -> attribute ; character -> sourceFile = file -> sourceFile ; character -> sourceLine = file -> lineNumber ; return 1 ; case CTO_EmpMatchBefore : before |= CTC_EmpMatch ; goto doOpcode ; case CTO_EmpMatchAfter : after |= CTC_EmpMatch ; goto doOpcode ; case CTO_SwapCc : case CTO_SwapCd : case CTO_SwapDd : return compileSwap ( file , opcode , noback , nofor , table ) ; case CTO_Hyphen : case CTO_DecPoint : if ( ! getRuleCharsText ( file , & ruleChars ) ) return 0 ; if ( ! getRuleDotsPattern ( file , & ruleDots ) ) return 0 ; if ( ruleChars . length != 1 || ruleDots . length < 1 ) { compileError ( file , \"One<S2SV_blank>Unicode<S2SV_blank>character<S2SV_blank>and<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>cell<S2SV_blank>are<S2SV_blank>\" \"required.\" ) ; return 0 ; } return addRule ( file , opcode , & ruleChars , & ruleDots , after , before , NULL , NULL , noback , nofor , table ) ; default : compileError ( file , \"unimplemented<S2SV_blank>opcode.\" ) ; return 0 ; } } return 0 ; }", "target": "<S2SV_ModStart> return 0 ; if ( ( ruleChars . length + 1 ) > SEQPATTERNSIZE ) { compileError ( file , \"More<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>characters\" , SEQPATTERNSIZE ) ; return 0 ; } for ( int k = 0 ; k <S2SV_ModEnd> < ruleChars . <S2SV_ModStart> . length ; k ++ ) ( * table ) -> seqAfterExpression [ k ] = ruleChars . chars [ k ] ; ( * table ) -> seqAfterExpression [ ruleChars . length ] = 0 ; <S2SV_ModStart> ) -> seqAfterExpressionLength = ruleChars . length <S2SV_ModEnd> ; return 1"}
{"source": "CWE-125 gst_flxdec_chain ( GstPad * pad , GstObject * parent , GstBuffer * buf ) { GstCaps * caps ; guint avail ; GstFlowReturn res = GST_FLOW_OK ; GstFlxDec * flxdec ; FlxHeader * flxh ; g_return_val_if_fail ( buf != NULL , GST_FLOW_ERROR ) ; flxdec = ( GstFlxDec * ) parent ; g_return_val_if_fail ( flxdec != NULL , GST_FLOW_ERROR ) ; gst_adapter_push ( flxdec -> adapter , buf ) ; avail = gst_adapter_available ( flxdec -> adapter ) ; if ( flxdec -> state == GST_FLXDEC_READ_HEADER ) { if ( avail >= FlxHeaderSize ) { const guint8 * data = gst_adapter_map ( flxdec -> adapter , FlxHeaderSize ) ; GstCaps * templ ; memcpy ( ( gchar * ) & flxdec -> hdr , data , FlxHeaderSize ) ; FLX_HDR_FIX_ENDIANNESS ( & ( flxdec -> hdr ) ) ; gst_adapter_unmap ( flxdec -> adapter ) ; gst_adapter_flush ( flxdec -> adapter , FlxHeaderSize ) ; flxh = & flxdec -> hdr ; if ( flxh -> type != FLX_MAGICHDR_FLI && flxh -> type != FLX_MAGICHDR_FLC && flxh -> type != FLX_MAGICHDR_FLX ) goto wrong_type ; GST_LOG ( \"size<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> size ) ; GST_LOG ( \"frames<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> frames ) ; GST_LOG ( \"width<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> width ) ; GST_LOG ( \"height<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> height ) ; GST_LOG ( \"depth<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> depth ) ; GST_LOG ( \"speed<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> speed ) ; flxdec -> next_time = 0 ; if ( flxh -> type == FLX_MAGICHDR_FLI ) { flxdec -> frame_time = JIFFIE * flxh -> speed ; } else if ( flxh -> speed == 0 ) { flxdec -> frame_time = GST_SECOND / 70 ; } else { flxdec -> frame_time = flxh -> speed * GST_MSECOND ; } flxdec -> duration = flxh -> frames * flxdec -> frame_time ; GST_LOG ( \"duration<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>%\" GST_TIME_FORMAT , GST_TIME_ARGS ( flxdec -> duration ) ) ; templ = gst_pad_get_pad_template_caps ( flxdec -> srcpad ) ; caps = gst_caps_copy ( templ ) ; gst_caps_unref ( templ ) ; gst_caps_set_simple ( caps , \"width\" , G_TYPE_INT , flxh -> width , \"height\" , G_TYPE_INT , flxh -> height , \"framerate\" , GST_TYPE_FRACTION , ( gint ) GST_MSECOND , ( gint ) flxdec -> frame_time / 1000 , NULL ) ; gst_pad_set_caps ( flxdec -> srcpad , caps ) ; gst_caps_unref ( caps ) ; if ( flxh -> depth <= 8 ) flxdec -> converter = flx_colorspace_converter_new ( flxh -> width , flxh -> height ) ; if ( flxh -> type == FLX_MAGICHDR_FLC || flxh -> type == FLX_MAGICHDR_FLX ) { GST_LOG ( \"(FLC)<S2SV_blank>aspect_dx<S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> aspect_dx ) ; GST_LOG ( \"(FLC)<S2SV_blank>aspect_dy<S2SV_blank>:<S2SV_blank><S2SV_blank>%d\" , flxh -> aspect_dy ) ; GST_LOG ( \"(FLC)<S2SV_blank>oframe1<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>0x%08x\" , flxh -> oframe1 ) ; GST_LOG ( \"(FLC)<S2SV_blank>oframe2<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank><S2SV_blank>0x%08x\" , flxh -> oframe2 ) ; } flxdec -> size = ( ( guint ) flxh -> width * ( guint ) flxh -> height ) ; flxdec -> frame_data = g_malloc ( flxdec -> size ) ; flxdec -> delta_data = g_malloc ( flxdec -> size ) ; flxdec -> state = GST_FLXDEC_PLAYING ; } } else if ( flxdec -> state == GST_FLXDEC_PLAYING ) { GstBuffer * out ; while ( avail >= FlxFrameChunkSize && res == GST_FLOW_OK ) { FlxFrameChunk flxfh ; guchar * chunk ; const guint8 * data ; GstMapInfo map ; chunk = NULL ; data = gst_adapter_map ( flxdec -> adapter , FlxFrameChunkSize ) ; memcpy ( & flxfh , data , FlxFrameChunkSize ) ; FLX_FRAME_CHUNK_FIX_ENDIANNESS ( & flxfh ) ; gst_adapter_unmap ( flxdec -> adapter ) ; switch ( flxfh . id ) { case FLX_FRAME_TYPE : if ( avail < flxfh . size ) goto need_more_data ; gst_adapter_flush ( flxdec -> adapter , FlxFrameChunkSize ) ; chunk = gst_adapter_take ( flxdec -> adapter , flxfh . size - FlxFrameChunkSize ) ; FLX_FRAME_TYPE_FIX_ENDIANNESS ( ( FlxFrameType * ) chunk ) ; if ( ( ( FlxFrameType * ) chunk ) -> chunks == 0 ) break ; out = gst_buffer_new_and_alloc ( flxdec -> size * 4 ) ; if ( ! flx_decode_chunks ( flxdec , ( ( FlxFrameType * ) chunk ) -> chunks , chunk + FlxFrameTypeSize , flxdec -> frame_data ) ) { GST_ELEMENT_ERROR ( flxdec , STREAM , DECODE , ( \"%s\" , \"Could<S2SV_blank>not<S2SV_blank>decode<S2SV_blank>chunk\" ) , NULL ) ; return GST_FLOW_ERROR ; } memcpy ( flxdec -> delta_data , flxdec -> frame_data , flxdec -> size ) ; gst_buffer_map ( out , & map , GST_MAP_WRITE ) ; flx_colorspace_convert ( flxdec -> converter , flxdec -> frame_data , map . data ) ; gst_buffer_unmap ( out , & map ) ; GST_BUFFER_TIMESTAMP ( out ) = flxdec -> next_time ; flxdec -> next_time += flxdec -> frame_time ; res = gst_pad_push ( flxdec -> srcpad , out ) ; break ; default : if ( avail < flxfh . size ) goto need_more_data ; gst_adapter_flush ( flxdec -> adapter , flxfh . size ) ; break ; } g_free ( chunk ) ; avail = gst_adapter_available ( flxdec -> adapter ) ; } } need_more_data : return res ; wrong_type : { GST_ELEMENT_ERROR ( flxdec , STREAM , WRONG_TYPE , ( NULL ) , ( \"not<S2SV_blank>a<S2SV_blank>flx<S2SV_blank>file<S2SV_blank>(type<S2SV_blank>%x)\" , flxh -> type ) ) ; <S2SV_StartBug> gst_object_unref ( flxdec ) ; <S2SV_EndBug> return GST_FLOW_ERROR ; } }", "target": "<S2SV_ModStart> ) ) ; <S2SV_ModEnd> return GST_FLOW_ERROR ;"}
{"source": "CWE-269 static ssize_t cgroup_release_agent_write ( struct kernfs_open_file * of , char * buf , size_t nbytes , loff_t off ) { struct cgroup * cgrp ; <S2SV_StartBug> BUILD_BUG_ON ( sizeof ( cgrp -> root -> release_agent_path ) < PATH_MAX ) ; <S2SV_EndBug> cgrp = cgroup_kn_lock_live ( of -> kn , false ) ; if ( ! cgrp ) return - ENODEV ; spin_lock ( & release_agent_path_lock ) ; strlcpy ( cgrp -> root -> release_agent_path , strstrip ( buf ) , sizeof ( cgrp -> root -> release_agent_path ) ) ; spin_unlock ( & release_agent_path_lock ) ; cgroup_kn_unlock ( of -> kn ) ; return nbytes ; }", "target": "<S2SV_ModStart> < PATH_MAX ) ; if ( ( of -> file -> f_cred -> user_ns != & init_user_ns ) || ! capable ( CAP_SYS_ADMIN ) ) return - EPERM"}
{"source": "CWE-617 createRandomCursorExecutor ( const CollectionPtr & coll , const boost : : intrusive_ptr < ExpressionContext > & expCtx , long long sampleSize , long long numRecords , boost : : optional < BucketUnpacker > bucketUnpacker ) { OperationContext * opCtx = expCtx -> opCtx ; invariant ( opCtx -> lockState ( ) -> isCollectionLockedForMode ( coll -> ns ( ) , MODE_IS ) ) ; static const double kMaxSampleRatioForRandCursor = 0.05 ; if ( ! expCtx -> ns . isTimeseriesBucketsCollection ( ) ) { if ( sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100 ) { return std : : pair { nullptr , false } ; } } else { static const double kCoefficient = 0.01 ; if ( sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount ) { return std : : pair { nullptr , false } ; } } auto rsRandCursor = coll -> getRecordStore ( ) -> getRandomCursor ( opCtx ) ; if ( ! rsRandCursor ) { return std : : pair { nullptr , false } ; } auto ws = std : : make_unique < WorkingSet > ( ) ; std : : unique_ptr < PlanStage > root = std : : make_unique < MultiIteratorStage > ( expCtx . get ( ) , ws . get ( ) , coll ) ; static_cast < MultiIteratorStage * > ( root . get ( ) ) -> addIterator ( std : : move ( rsRandCursor ) ) ; <S2SV_StartBug> auto collectionFilter = <S2SV_EndBug> CollectionShardingState : : get ( opCtx , coll -> ns ( ) ) -> getOwnershipFilter ( opCtx , CollectionShardingState : : OrphanCleanupPolicy : : kDisallowOrphanCleanup ) ; TrialStage * trialStage = nullptr ; static const size_t kMaxPresampleSize = 100 ; <S2SV_StartBug> if ( collectionFilter . isSharded ( ) && ! expCtx -> ns . isTimeseriesBucketsCollection ( ) ) { <S2SV_EndBug> const auto minAdvancedToWorkRatio = std : : max ( <S2SV_StartBug> sampleSize / ( numRecords * kMaxSampleRatioForRandCursor ) , kMaxSampleRatioForRandCursor ) ; <S2SV_EndBug> auto randomCursorPlan = std : : make_unique < ShardFilterStage > ( expCtx . get ( ) , collectionFilter , ws . get ( ) , std : : move ( root ) ) ; std : : unique_ptr < PlanStage > collScanPlan = std : : make_unique < CollectionScan > ( expCtx . get ( ) , coll , CollectionScanParams { } , ws . get ( ) , nullptr ) ; collScanPlan = std : : make_unique < ShardFilterStage > ( expCtx . get ( ) , collectionFilter , ws . get ( ) , std : : move ( collScanPlan ) ) ; root = std : : make_unique < TrialStage > ( expCtx . get ( ) , ws . get ( ) , std : : move ( randomCursorPlan ) , std : : move ( collScanPlan ) , kMaxPresampleSize , minAdvancedToWorkRatio ) ; trialStage = static_cast < TrialStage * > ( root . get ( ) ) ; } else if ( expCtx -> ns . isTimeseriesBucketsCollection ( ) ) { static const auto kCoefficient = 0.02 ; static const auto kMinBucketFullness = 0.25 ; const auto minAdvancedToWorkRatio = std : : max ( std : : min ( sampleSize / ( kCoefficient * numRecords * gTimeseriesBucketMaxCount ) , 1.0 ) , kMinBucketFullness ) ; auto arhashPlan = std : : make_unique < SampleFromTimeseriesBucket > ( expCtx . get ( ) , ws . get ( ) , std : : move ( root ) , * bucketUnpacker , kMaxPresampleSize + 5 , sampleSize , gTimeseriesBucketMaxCount ) ; std : : unique_ptr < PlanStage > collScanPlan = std : : make_unique < CollectionScan > ( expCtx . get ( ) , coll , CollectionScanParams { } , ws . get ( ) , nullptr ) ; auto topkSortPlan = std : : make_unique < UnpackTimeseriesBucket > ( expCtx . get ( ) , ws . get ( ) , std : : move ( collScanPlan ) , * bucketUnpacker ) ; root = std : : make_unique < TrialStage > ( expCtx . get ( ) , ws . get ( ) , std : : move ( arhashPlan ) , std : : move ( topkSortPlan ) , kMaxPresampleSize , minAdvancedToWorkRatio ) ; trialStage = static_cast < TrialStage * > ( root . get ( ) ) ; } auto execStatus = plan_executor_factory : : make ( expCtx , std : : move ( ws ) , std : : move ( root ) , & coll , opCtx -> inMultiDocumentTransaction ( ) ? PlanYieldPolicy : : YieldPolicy : : INTERRUPT_ONLY : PlanYieldPolicy : : YieldPolicy : : YIELD_AUTO , QueryPlannerParams : : RETURN_OWNED_DATA ) ; if ( ! execStatus . isOK ( ) ) { return execStatus . getStatus ( ) ; } return std : : pair { std : : move ( execStatus . getValue ( ) ) , ! trialStage || ! trialStage -> pickedBackupPlan ( ) } ; }", "target": "<S2SV_ModStart> ) ) ; <S2SV_ModEnd> TrialStage * trialStage <S2SV_ModStart> ; if ( auto css = CollectionShardingState : : get ( opCtx , coll -> ns ( ) ) ; css -> getCollectionDescription ( opCtx ) <S2SV_ModEnd> . isSharded ( <S2SV_ModStart> ) , kMaxSampleRatioForRandCursor ) ; auto collectionFilter = css -> getOwnershipFilter ( opCtx , CollectionShardingState : : OrphanCleanupPolicy : : kDisallowOrphanCleanup"}
{"source": "CWE-703 setup_secureChannel ( void ) { TestingPolicy ( & dummyPolicy , dummyCertificate , & fCalled , & keySizes ) ; UA_SecureChannel_init ( & testChannel , & UA_ConnectionConfig_default ) ; UA_SecureChannel_setSecurityPolicy ( & testChannel , & dummyPolicy , & dummyCertificate ) ; <S2SV_StartBug> testingConnection = createDummyConnection ( 65535 , & sentData ) ; <S2SV_EndBug> UA_Connection_attachSecureChannel ( & testingConnection , & testChannel ) ; testChannel . connection = & testingConnection ; testChannel . state = UA_SECURECHANNELSTATE_OPEN ; }", "target": "<S2SV_ModStart> = createDummyConnection ( UA_ConnectionConfig_default . sendBufferSize <S2SV_ModEnd> , & sentData"}
{"source": "CWE-787 void mobi_buffer_move ( MOBIBuffer * buf , const int offset , const size_t len ) { size_t aoffset = ( size_t ) abs ( offset ) ; unsigned char * source = buf -> data + buf -> offset ; if ( offset >= 0 ) { if ( buf -> offset + aoffset + len > buf -> maxlen ) { debug_print ( \"%s\" , \"End<S2SV_blank>of<S2SV_blank>buffer\\\\n\" ) ; buf -> error = MOBI_BUFFER_END ; return ; } source += aoffset ; } else { <S2SV_StartBug> if ( buf -> offset < aoffset ) { <S2SV_EndBug> <S2SV_StartBug> debug_print ( \"%s\" , \"End<S2SV_blank>of<S2SV_blank>buffer\\\\n\" ) ; <S2SV_EndBug> buf -> error = MOBI_BUFFER_END ; return ; } source -= aoffset ; } memmove ( buf -> data + buf -> offset , source , len ) ; buf -> offset += len ; }", "target": "<S2SV_ModStart> { if ( ( <S2SV_ModStart> offset < aoffset ) || ( buf -> offset + len > buf -> maxlen ) <S2SV_ModStart> ( \"%s\" , \"Beyond<S2SV_blank>start/end<S2SV_blank>of<S2SV_blank>buffer\\\\n\" <S2SV_ModEnd> ) ; buf"}
{"source": "CWE-835 static void gem_transmit ( CadenceGEMState * s ) { uint32_t desc [ DESC_MAX_NUM_WORDS ] ; hwaddr packet_desc_addr ; uint8_t * p ; unsigned total_bytes ; int q = 0 ; if ( ! ( s -> regs [ GEM_NWCTRL ] & GEM_NWCTRL_TXENA ) ) { return ; } DB_PRINT ( \"\\\\n\" ) ; p = s -> tx_packet ; total_bytes = 0 ; for ( q = s -> num_priority_queues - 1 ; q >= 0 ; q -- ) { packet_desc_addr = gem_get_tx_desc_addr ( s , q ) ; DB_PRINT ( \"read<S2SV_blank>descriptor<S2SV_blank>0x%\" HWADDR_PRIx \"\\\\n\" , packet_desc_addr ) ; address_space_read ( & s -> dma_as , packet_desc_addr , MEMTXATTRS_UNSPECIFIED , desc , sizeof ( uint32_t ) * gem_get_desc_len ( s , false ) ) ; while ( tx_desc_get_used ( desc ) == 0 ) { if ( ! ( s -> regs [ GEM_NWCTRL ] & GEM_NWCTRL_TXENA ) ) { return ; } print_gem_tx_desc ( desc , q ) ; if ( ( tx_desc_get_buffer ( s , desc ) == 0 ) || ( tx_desc_get_length ( desc ) == 0 ) ) { DB_PRINT ( \"Invalid<S2SV_blank>TX<S2SV_blank>descriptor<S2SV_blank>@<S2SV_blank>0x%\" HWADDR_PRIx \"\\\\n\" , packet_desc_addr ) ; break ; } if ( tx_desc_get_length ( desc ) > gem_get_max_buf_len ( s , true ) - ( p - s -> tx_packet ) ) { qemu_log_mask ( LOG_GUEST_ERROR , \"TX<S2SV_blank>descriptor<S2SV_blank>@<S2SV_blank>0x%\" HWADDR_PRIx \"<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>size<S2SV_blank>0x%x<S2SV_blank>space<S2SV_blank>0x%zx\\\\n\" , packet_desc_addr , tx_desc_get_length ( desc ) , gem_get_max_buf_len ( s , true ) - ( p - s -> tx_packet ) ) ; gem_set_isr ( s , q , GEM_INT_AMBA_ERR ) ; break ; } address_space_read ( & s -> dma_as , tx_desc_get_buffer ( s , desc ) , MEMTXATTRS_UNSPECIFIED , p , tx_desc_get_length ( desc ) ) ; p += tx_desc_get_length ( desc ) ; total_bytes += tx_desc_get_length ( desc ) ; if ( tx_desc_get_last ( desc ) ) { uint32_t desc_first [ DESC_MAX_NUM_WORDS ] ; hwaddr desc_addr = gem_get_tx_desc_addr ( s , q ) ; address_space_read ( & s -> dma_as , desc_addr , MEMTXATTRS_UNSPECIFIED , desc_first , sizeof ( desc_first ) ) ; tx_desc_set_used ( desc_first ) ; address_space_write ( & s -> dma_as , desc_addr , MEMTXATTRS_UNSPECIFIED , desc_first , sizeof ( desc_first ) ) ; if ( tx_desc_get_wrap ( desc ) ) { s -> tx_desc_addr [ q ] = gem_get_tx_queue_base_addr ( s , q ) ; } else { s -> tx_desc_addr [ q ] = packet_desc_addr + 4 * gem_get_desc_len ( s , false ) ; } DB_PRINT ( \"TX<S2SV_blank>descriptor<S2SV_blank>next:<S2SV_blank>0x%08x\\\\n\" , s -> tx_desc_addr [ q ] ) ; s -> regs [ GEM_TXSTATUS ] |= GEM_TXSTATUS_TXCMPL ; gem_set_isr ( s , q , GEM_INT_TXCMPL ) ; gem_update_int_status ( s ) ; if ( s -> regs [ GEM_DMACFG ] & GEM_DMACFG_TXCSUM_OFFL ) { net_checksum_calculate ( s -> tx_packet , total_bytes , CSUM_ALL ) ; } gem_transmit_updatestats ( s , s -> tx_packet , total_bytes ) ; if ( s -> phy_loop || ( s -> regs [ GEM_NWCTRL ] & GEM_NWCTRL_LOCALLOOP ) ) { <S2SV_StartBug> gem_receive ( qemu_get_queue ( s -> nic ) , s -> tx_packet , <S2SV_EndBug> total_bytes ) ; } else { qemu_send_packet ( qemu_get_queue ( s -> nic ) , s -> tx_packet , total_bytes ) ; } p = s -> tx_packet ; total_bytes = 0 ; } if ( tx_desc_get_wrap ( desc ) ) { if ( s -> regs [ GEM_DMACFG ] & GEM_DMACFG_ADDR_64B ) { packet_desc_addr = s -> regs [ GEM_TBQPH ] ; packet_desc_addr <<= 32 ; } else { packet_desc_addr = 0 ; } packet_desc_addr |= gem_get_tx_queue_base_addr ( s , q ) ; } else { packet_desc_addr += 4 * gem_get_desc_len ( s , false ) ; } DB_PRINT ( \"read<S2SV_blank>descriptor<S2SV_blank>0x%\" HWADDR_PRIx \"\\\\n\" , packet_desc_addr ) ; address_space_read ( & s -> dma_as , packet_desc_addr , MEMTXATTRS_UNSPECIFIED , desc , sizeof ( uint32_t ) * gem_get_desc_len ( s , false ) ) ; } if ( tx_desc_get_used ( desc ) ) { s -> regs [ GEM_TXSTATUS ] |= GEM_TXSTATUS_USED ; if ( q == 0 ) { gem_set_isr ( s , 0 , GEM_INT_TXUSED ) ; } gem_update_int_status ( s ) ; } } }", "target": "<S2SV_ModStart> ) ) { qemu_receive_packet <S2SV_ModEnd> ( qemu_get_queue ("}
{"source": "CWE-120 STATIC SSize_t S_study_chunk ( pTHX_ RExC_state_t * pRExC_state , regnode * * scanp , SSize_t * minlenp , SSize_t * deltap , regnode * last , scan_data_t * data , I32 stopparen , U32 recursed_depth , regnode_ssc * and_withp , <S2SV_StartBug> U32 flags , U32 depth ) <S2SV_EndBug> { dVAR ; SSize_t min = 0 ; I32 pars = 0 , code ; regnode * scan = * scanp , * next ; SSize_t delta = 0 ; int is_inf = ( flags & SCF_DO_SUBSTR ) && ( data -> flags & SF_IS_INF ) ; int is_inf_internal = 0 ; I32 is_par = OP ( scan ) == OPEN ? ARG ( scan ) : 0 ; scan_data_t data_fake ; SV * re_trie_maxbuff = NULL ; regnode * first_non_open = scan ; SSize_t stopmin = SSize_t_MAX ; scan_frame * frame = NULL ; GET_RE_DEBUG_FLAGS_DECL ; PERL_ARGS_ASSERT_STUDY_CHUNK ; RExC_study_started = 1 ; Zero ( & data_fake , 1 , scan_data_t ) ; if ( depth == 0 ) { while ( first_non_open && OP ( first_non_open ) == OPEN ) first_non_open = regnext ( first_non_open ) ; } fake_study_recurse : DEBUG_r ( RExC_study_chunk_recursed_count ++ ; ) ; DEBUG_OPTIMISE_MORE_r ( { Perl_re_indentf ( aTHX_ \"study_chunk<S2SV_blank>stopparen=%ld<S2SV_blank>recursed_count=%lu<S2SV_blank>depth=%lu<S2SV_blank>recursed_depth=%lu<S2SV_blank>scan=%p<S2SV_blank>last=%p\" , depth , ( long ) stopparen , ( unsigned long ) RExC_study_chunk_recursed_count , ( unsigned long ) depth , ( unsigned long ) recursed_depth , scan , last ) ; if ( recursed_depth ) { U32 i ; U32 j ; for ( j = 0 ; j < recursed_depth ; j ++ ) { for ( i = 0 ; i < ( U32 ) RExC_total_parens ; i ++ ) { if ( PAREN_TEST ( RExC_study_chunk_recursed + ( j * RExC_study_chunk_recursed_bytes ) , i ) && ( ! j || ! PAREN_TEST ( RExC_study_chunk_recursed + ( ( j - 1 ) * RExC_study_chunk_recursed_bytes ) , i ) ) ) { Perl_re_printf ( aTHX_ \"<S2SV_blank>%d\" , ( int ) i ) ; break ; } } if ( j + 1 < recursed_depth ) { Perl_re_printf ( aTHX_ \",\" ) ; } } } Perl_re_printf ( aTHX_ \"\\\\n\" ) ; } ) ; while ( scan && OP ( scan ) != END && scan < last ) { UV min_subtract = 0 ; bool unfolded_multi_char = FALSE ; <S2SV_StartBug> DEBUG_STUDYDATA ( \"Peep\" , data , depth , is_inf ) ; <S2SV_EndBug> DEBUG_PEEP ( \"Peep\" , scan , depth , flags ) ; <S2SV_StartBug> <S2SV_EndBug> JOIN_EXACT ( scan , & min_subtract , & unfolded_multi_char , 0 ) ; rck_elide_nothing ( scan ) ; if ( OP ( scan ) == DEFINEP ) { SSize_t minlen = 0 ; SSize_t deltanext = 0 ; SSize_t fake_last_close = 0 ; I32 f = SCF_IN_DEFINE ; StructCopy ( & zero_scan_data , & data_fake , scan_data_t ) ; scan = regnext ( scan ) ; assert ( OP ( scan ) == IFTHEN ) ; DEBUG_PEEP ( \"expect<S2SV_blank>IFTHEN\" , scan , depth , flags ) ; data_fake . last_closep = & fake_last_close ; minlen = * minlenp ; next = regnext ( scan ) ; scan = NEXTOPER ( NEXTOPER ( scan ) ) ; DEBUG_PEEP ( \"scan\" , scan , depth , flags ) ; DEBUG_PEEP ( \"next\" , next , depth , flags ) ; ( void ) study_chunk ( pRExC_state , & scan , & minlen , & deltanext , next , & data_fake , stopparen , <S2SV_StartBug> recursed_depth , NULL , f , depth + 1 ) ; <S2SV_EndBug> scan = next ; } else if ( OP ( scan ) == BRANCH || OP ( scan ) == BRANCHJ || OP ( scan ) == IFTHEN ) { next = regnext ( scan ) ; code = OP ( scan ) ; if ( OP ( next ) == code || code == IFTHEN ) { SSize_t max1 = 0 , min1 = SSize_t_MAX , num = 0 ; regnode_ssc accum ; regnode * const startbranch = scan ; if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; } if ( flags & SCF_DO_STCLASS ) ssc_init_zero ( pRExC_state , & accum ) ; while ( OP ( scan ) == code ) { SSize_t deltanext , minnext , fake ; I32 f = 0 ; regnode_ssc this_class ; DEBUG_PEEP ( \"Branch\" , scan , depth , flags ) ; num ++ ; StructCopy ( & zero_scan_data , & data_fake , scan_data_t ) ; if ( data ) { data_fake . whilem_c = data -> whilem_c ; data_fake . last_closep = data -> last_closep ; } else data_fake . last_closep = & fake ; data_fake . pos_delta = delta ; next = regnext ( scan ) ; scan = NEXTOPER ( scan ) ; if ( code != BRANCH ) scan = NEXTOPER ( scan ) ; if ( flags & SCF_DO_STCLASS ) { ssc_init ( pRExC_state , & this_class ) ; data_fake . start_class = & this_class ; f = SCF_DO_STCLASS_AND ; } if ( flags & SCF_WHILEM_VISITED_POS ) f |= SCF_WHILEM_VISITED_POS ; minnext = study_chunk ( pRExC_state , & scan , minlenp , & deltanext , next , & data_fake , stopparen , <S2SV_StartBug> recursed_depth , NULL , f , depth + 1 ) ; <S2SV_EndBug> if ( min1 > minnext ) min1 = minnext ; if ( deltanext == SSize_t_MAX ) { is_inf = is_inf_internal = 1 ; max1 = SSize_t_MAX ; } else if ( max1 < minnext + deltanext ) max1 = minnext + deltanext ; scan = next ; if ( data_fake . flags & ( SF_HAS_PAR | SF_IN_PAR ) ) pars ++ ; if ( data_fake . flags & SCF_SEEN_ACCEPT ) { if ( stopmin > minnext ) stopmin = min + min1 ; flags &= ~ SCF_DO_SUBSTR ; if ( data ) data -> flags |= SCF_SEEN_ACCEPT ; } if ( data ) { if ( data_fake . flags & SF_HAS_EVAL ) data -> flags |= SF_HAS_EVAL ; data -> whilem_c = data_fake . whilem_c ; } if ( flags & SCF_DO_STCLASS ) ssc_or ( pRExC_state , & accum , ( regnode_charclass * ) & this_class ) ; } if ( code == IFTHEN && num < 2 ) min1 = 0 ; if ( flags & SCF_DO_SUBSTR ) { data -> pos_min += min1 ; if ( data -> pos_delta >= SSize_t_MAX - ( max1 - min1 ) ) data -> pos_delta = SSize_t_MAX ; else data -> pos_delta += max1 - min1 ; if ( max1 != min1 || is_inf ) data -> cur_is_floating = 1 ; } min += min1 ; if ( delta == SSize_t_MAX || SSize_t_MAX - delta - ( max1 - min1 ) < 0 ) delta = SSize_t_MAX ; else delta += max1 - min1 ; if ( flags & SCF_DO_STCLASS_OR ) { ssc_or ( pRExC_state , data -> start_class , ( regnode_charclass * ) & accum ) ; if ( min1 ) { ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; flags &= ~ SCF_DO_STCLASS ; } } else if ( flags & SCF_DO_STCLASS_AND ) { if ( min1 ) { ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) & accum ) ; flags &= ~ SCF_DO_STCLASS ; } else { INIT_AND_WITHP ; StructCopy ( data -> start_class , and_withp , regnode_ssc ) ; flags &= ~ SCF_DO_STCLASS_AND ; StructCopy ( & accum , data -> start_class , regnode_ssc ) ; flags |= SCF_DO_STCLASS_OR ; } } if ( PERL_ENABLE_TRIE_OPTIMISATION && <S2SV_StartBug> OP ( startbranch ) == BRANCH ) <S2SV_EndBug> { int made = 0 ; if ( ! re_trie_maxbuff ) { re_trie_maxbuff = get_sv ( RE_TRIE_MAXBUF_NAME , 1 ) ; if ( ! SvIOK ( re_trie_maxbuff ) ) sv_setiv ( re_trie_maxbuff , RE_TRIE_MAXBUF_INIT ) ; } if ( SvIV ( re_trie_maxbuff ) >= 0 ) { regnode * cur ; regnode * first = ( regnode * ) NULL ; regnode * last = ( regnode * ) NULL ; regnode * tail = scan ; U8 trietype = 0 ; U32 count = 0 ; while ( OP ( tail ) == TAIL ) { tail = regnext ( tail ) ; } DEBUG_TRIE_COMPILE_r ( { regprop ( RExC_rx , RExC_mysv , tail , NULL , pRExC_state ) ; Perl_re_indentf ( aTHX_ \"%s<S2SV_blank>%\" UVuf \":%s\\\\n\" , depth + 1 , \"Looking<S2SV_blank>for<S2SV_blank>TRIE\\'able<S2SV_blank>sequences.<S2SV_blank>Tail<S2SV_blank>node<S2SV_blank>is<S2SV_blank>\" , ( UV ) REGNODE_OFFSET ( tail ) , SvPV_nolen_const ( RExC_mysv ) ) ; } ) ; # define TRIE_TYPE ( X ) ( ( NOTHING == ( X ) ) ? NOTHING : ( EXACT == ( X ) || EXACT_ONLY8 == ( X ) ) ? EXACT : ( EXACTFU == ( X ) || EXACTFU_ONLY8 == ( X ) || EXACTFUP == ( X ) ) ? EXACTFU : ( EXACTFAA == ( X ) ) ? EXACTFAA : ( EXACTL == ( X ) ) ? EXACTL : ( EXACTFLU8 == ( X ) ) ? EXACTFLU8 : 0 ) for ( cur = startbranch ; cur != scan ; cur = regnext ( cur ) ) { regnode * const noper = NEXTOPER ( cur ) ; U8 noper_type = OP ( noper ) ; U8 noper_trietype = TRIE_TYPE ( noper_type ) ; # if defined ( DEBUGGING ) || defined ( NOJUMPTRIE ) regnode * const noper_next = regnext ( noper ) ; U8 noper_next_type = ( noper_next && noper_next < tail ) ? OP ( noper_next ) : 0 ; U8 noper_next_trietype = ( noper_next && noper_next < tail ) ? TRIE_TYPE ( noper_next_type ) : 0 ; # endif DEBUG_TRIE_COMPILE_r ( { regprop ( RExC_rx , RExC_mysv , cur , NULL , pRExC_state ) ; Perl_re_indentf ( aTHX_ \"-<S2SV_blank>%d:%s<S2SV_blank>(%d)\" , depth + 1 , REG_NODE_NUM ( cur ) , SvPV_nolen_const ( RExC_mysv ) , REG_NODE_NUM ( cur ) ) ; regprop ( RExC_rx , RExC_mysv , noper , NULL , pRExC_state ) ; Perl_re_printf ( aTHX_ \"<S2SV_blank>-><S2SV_blank>%d:%s\" , REG_NODE_NUM ( noper ) , SvPV_nolen_const ( RExC_mysv ) ) ; if ( noper_next ) { regprop ( RExC_rx , RExC_mysv , noper_next , NULL , pRExC_state ) ; Perl_re_printf ( aTHX_ \"\\\\t=><S2SV_blank>%d:%s\\\\t\" , REG_NODE_NUM ( noper_next ) , SvPV_nolen_const ( RExC_mysv ) ) ; } Perl_re_printf ( aTHX_ \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\\\n\" , REG_NODE_NUM ( first ) , REG_NODE_NUM ( last ) , REG_NODE_NUM ( cur ) , PL_reg_name [ trietype ] , PL_reg_name [ noper_trietype ] , PL_reg_name [ noper_next_trietype ] ) ; } ) ; if ( noper_trietype && ( ( noper_trietype == NOTHING ) || ( trietype == NOTHING ) || ( trietype == noper_trietype ) ) # ifdef NOJUMPTRIE && noper_next >= tail # endif && count < U16_MAX ) { if ( ! first ) { first = cur ; if ( noper_trietype == NOTHING ) { # if ! defined ( DEBUGGING ) && ! defined ( NOJUMPTRIE ) regnode * const noper_next = regnext ( noper ) ; U8 noper_next_type = ( noper_next && noper_next < tail ) ? OP ( noper_next ) : 0 ; U8 noper_next_trietype = noper_next_type ? TRIE_TYPE ( noper_next_type ) : 0 ; # endif if ( noper_next_trietype ) { trietype = noper_next_trietype ; } else if ( noper_next_type ) { first = NULL ; } } else { trietype = noper_trietype ; } } else { if ( trietype == NOTHING ) trietype = noper_trietype ; last = cur ; } if ( first ) count ++ ; } else { if ( last ) { if ( trietype && trietype != NOTHING ) make_trie ( pRExC_state , startbranch , first , cur , tail , count , trietype , depth + 1 ) ; last = NULL ; } if ( noper_trietype # ifdef NOJUMPTRIE && noper_next >= tail # endif ) { count = 1 ; first = cur ; trietype = noper_trietype ; } else if ( first ) { count = 0 ; first = NULL ; trietype = 0 ; } } } DEBUG_TRIE_COMPILE_r ( { regprop ( RExC_rx , RExC_mysv , cur , NULL , pRExC_state ) ; Perl_re_indentf ( aTHX_ \"-<S2SV_blank>%s<S2SV_blank>(%d)<S2SV_blank><SCAN<S2SV_blank>FINISHED><S2SV_blank>\" , depth + 1 , SvPV_nolen_const ( RExC_mysv ) , REG_NODE_NUM ( cur ) ) ; Perl_re_printf ( aTHX_ \"(First==%d,<S2SV_blank>Last==%d,<S2SV_blank>Cur==%d,<S2SV_blank>tt==%s)\\\\n\" , REG_NODE_NUM ( first ) , REG_NODE_NUM ( last ) , REG_NODE_NUM ( cur ) , PL_reg_name [ trietype ] ) ; } ) ; if ( last && trietype ) { if ( trietype != NOTHING ) { made = make_trie ( pRExC_state , startbranch , first , scan , tail , count , trietype , depth + 1 ) ; # ifdef TRIE_STUDY_OPT if ( ( ( made == MADE_EXACT_TRIE && startbranch == first ) || ( first_non_open == first ) ) && depth == 0 ) { flags |= SCF_TRIE_RESTUDY ; if ( startbranch == first && scan >= tail ) { RExC_seen &= ~ REG_TOP_LEVEL_BRANCHES_SEEN ; } } # endif } else { if ( startbranch == first ) { regnode * opt ; DEBUG_TRIE_COMPILE_r ( { regprop ( RExC_rx , RExC_mysv , cur , NULL , pRExC_state ) ; Perl_re_indentf ( aTHX_ \"-<S2SV_blank>%s<S2SV_blank>(%d)<S2SV_blank><NOTHING<S2SV_blank>BRANCH<S2SV_blank>SEQUENCE>\\\\n\" , depth + 1 , SvPV_nolen_const ( RExC_mysv ) , REG_NODE_NUM ( cur ) ) ; } ) ; OP ( startbranch ) = NOTHING ; NEXT_OFF ( startbranch ) = tail - startbranch ; for ( opt = startbranch + 1 ; opt < tail ; opt ++ ) OP ( opt ) = OPTIMIZED ; } } } } } } else if ( code == BRANCHJ ) { scan = NEXTOPER ( NEXTOPER ( scan ) ) ; } else scan = NEXTOPER ( scan ) ; continue ; } else if ( OP ( scan ) == SUSPEND || OP ( scan ) == GOSUB ) { I32 paren = 0 ; regnode * start = NULL ; regnode * end = NULL ; U32 my_recursed_depth = recursed_depth ; if ( OP ( scan ) != SUSPEND ) { paren = ARG ( scan ) ; RExC_recurse [ ARG2L ( scan ) ] = scan ; start = REGNODE_p ( RExC_open_parens [ paren ] ) ; end = REGNODE_p ( RExC_close_parens [ paren ] ) ; if ( ( flags & SCF_IN_DEFINE ) || ( ( is_inf_internal || is_inf || ( data && data -> flags & SF_IS_INF ) ) && ( ( flags & ( SCF_DO_STCLASS | SCF_DO_SUBSTR ) ) == 0 ) ) ) { scan = regnext ( scan ) ; continue ; } if ( ! recursed_depth || ! PAREN_TEST ( RExC_study_chunk_recursed + ( ( recursed_depth - 1 ) * RExC_study_chunk_recursed_bytes ) , paren ) ) { if ( ! recursed_depth ) { Zero ( RExC_study_chunk_recursed , RExC_study_chunk_recursed_bytes , U8 ) ; } else { Copy ( RExC_study_chunk_recursed + ( ( recursed_depth - 1 ) * RExC_study_chunk_recursed_bytes ) , RExC_study_chunk_recursed + ( recursed_depth * RExC_study_chunk_recursed_bytes ) , RExC_study_chunk_recursed_bytes , U8 ) ; } DEBUG_STUDYDATA ( \"gosub-set\" , data , depth , is_inf ) ; PAREN_SET ( RExC_study_chunk_recursed + ( recursed_depth * RExC_study_chunk_recursed_bytes ) , paren ) ; my_recursed_depth = recursed_depth + 1 ; } else { DEBUG_STUDYDATA ( \"gosub-inf\" , data , depth , is_inf ) ; if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; data -> cur_is_floating = 1 ; } is_inf = is_inf_internal = 1 ; if ( flags & SCF_DO_STCLASS_OR ) ssc_anything ( data -> start_class ) ; flags &= ~ SCF_DO_STCLASS ; start = NULL ; } } else { paren = stopparen ; start = scan + 2 ; end = regnext ( scan ) ; } if ( start ) { scan_frame * newframe ; assert ( end ) ; if ( ! RExC_frame_last ) { Newxz ( newframe , 1 , scan_frame ) ; SAVEDESTRUCTOR_X ( S_unwind_scan_frames , newframe ) ; RExC_frame_head = newframe ; RExC_frame_count ++ ; } else if ( ! RExC_frame_last -> next_frame ) { Newxz ( newframe , 1 , scan_frame ) ; RExC_frame_last -> next_frame = newframe ; newframe -> prev_frame = RExC_frame_last ; RExC_frame_count ++ ; } else { newframe = RExC_frame_last -> next_frame ; } RExC_frame_last = newframe ; newframe -> next_regnode = regnext ( scan ) ; newframe -> last_regnode = last ; newframe -> stopparen = stopparen ; newframe -> prev_recursed_depth = recursed_depth ; newframe -> this_prev_frame = frame ; <S2SV_StartBug> <S2SV_EndBug> DEBUG_STUDYDATA ( \"frame-new\" , data , depth , is_inf ) ; DEBUG_PEEP ( \"fnew\" , scan , depth , flags ) ; frame = newframe ; scan = start ; stopparen = paren ; last = end ; depth = depth + 1 ; recursed_depth = my_recursed_depth ; continue ; } } else if ( OP ( scan ) == EXACT || OP ( scan ) == EXACT_ONLY8 || OP ( scan ) == EXACTL ) { SSize_t l = STR_LEN ( scan ) ; UV uc ; assert ( l ) ; if ( UTF ) { const U8 * const s = ( U8 * ) STRING ( scan ) ; uc = utf8_to_uvchr_buf ( s , s + l , NULL ) ; l = utf8_length ( s , s + l ) ; } else { uc = * ( ( U8 * ) STRING ( scan ) ) ; } min += l ; if ( flags & SCF_DO_SUBSTR ) { if ( data -> last_end == - 1 ) { data -> last_start_min = data -> pos_min ; data -> last_start_max = is_inf ? SSize_t_MAX : data -> pos_min + data -> pos_delta ; } sv_catpvn ( data -> last_found , STRING ( scan ) , STR_LEN ( scan ) ) ; if ( UTF ) SvUTF8_on ( data -> last_found ) ; { SV * const sv = data -> last_found ; MAGIC * const mg = SvUTF8 ( sv ) && SvMAGICAL ( sv ) ? mg_find ( sv , PERL_MAGIC_utf8 ) : NULL ; if ( mg && mg -> mg_len >= 0 ) mg -> mg_len += utf8_length ( ( U8 * ) STRING ( scan ) , ( U8 * ) STRING ( scan ) + STR_LEN ( scan ) ) ; } data -> last_end = data -> pos_min + l ; data -> pos_min += l ; data -> flags &= ~ SF_BEFORE_EOL ; } if ( flags & SCF_DO_STCLASS_AND ) { ssc_cp_and ( data -> start_class , uc ) ; ANYOF_FLAGS ( data -> start_class ) &= ~ SSC_MATCHES_EMPTY_STRING ; ssc_clear_locale ( data -> start_class ) ; } else if ( flags & SCF_DO_STCLASS_OR ) { ssc_add_cp ( data -> start_class , uc ) ; ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; ANYOF_FLAGS ( data -> start_class ) &= ~ SSC_MATCHES_EMPTY_STRING ; } flags &= ~ SCF_DO_STCLASS ; } else if ( PL_regkind [ OP ( scan ) ] == EXACT ) { SSize_t l = STR_LEN ( scan ) ; const U8 * s = ( U8 * ) STRING ( scan ) ; if ( flags & SCF_DO_SUBSTR ) { assert ( data ) ; scan_commit ( pRExC_state , data , minlenp , is_inf ) ; } if ( UTF ) { l = utf8_length ( s , s + l ) ; } if ( unfolded_multi_char ) { RExC_seen |= REG_UNFOLDED_MULTI_SEEN ; } min += l - min_subtract ; assert ( min >= 0 ) ; delta += min_subtract ; if ( flags & SCF_DO_SUBSTR ) { data -> pos_min += l - min_subtract ; if ( data -> pos_min < 0 ) { data -> pos_min = 0 ; } data -> pos_delta += min_subtract ; if ( min_subtract ) { data -> cur_is_floating = 1 ; } } if ( flags & SCF_DO_STCLASS ) { SV * EXACTF_invlist = _make_exactf_invlist ( pRExC_state , scan ) ; assert ( EXACTF_invlist ) ; if ( flags & SCF_DO_STCLASS_AND ) { if ( OP ( scan ) != EXACTFL ) ssc_clear_locale ( data -> start_class ) ; ANYOF_FLAGS ( data -> start_class ) &= ~ SSC_MATCHES_EMPTY_STRING ; ANYOF_POSIXL_ZERO ( data -> start_class ) ; ssc_intersection ( data -> start_class , EXACTF_invlist , FALSE ) ; } else { ssc_union ( data -> start_class , EXACTF_invlist , FALSE ) ; ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; ANYOF_FLAGS ( data -> start_class ) &= ~ SSC_MATCHES_EMPTY_STRING ; } flags &= ~ SCF_DO_STCLASS ; SvREFCNT_dec ( EXACTF_invlist ) ; } } else if ( REGNODE_VARIES ( OP ( scan ) ) ) { SSize_t mincount , maxcount , minnext , deltanext , pos_before = 0 ; I32 fl = 0 , f = flags ; regnode * const oscan = scan ; regnode_ssc this_class ; regnode_ssc * oclass = NULL ; I32 next_is_eval = 0 ; switch ( PL_regkind [ OP ( scan ) ] ) { case WHILEM : scan = NEXTOPER ( scan ) ; goto finish ; case PLUS : if ( flags & ( SCF_DO_SUBSTR | SCF_DO_STCLASS ) ) { next = NEXTOPER ( scan ) ; if ( OP ( next ) == EXACT || OP ( next ) == EXACT_ONLY8 || OP ( next ) == EXACTL || ( flags & SCF_DO_STCLASS ) ) { mincount = 1 ; maxcount = REG_INFTY ; next = regnext ( scan ) ; scan = NEXTOPER ( scan ) ; goto do_curly ; } } if ( flags & SCF_DO_SUBSTR ) data -> pos_min ++ ; min ++ ; case STAR : next = NEXTOPER ( scan ) ; <S2SV_StartBug> if ( OP ( next ) == EXACTFU_S_EDGE ) { <S2SV_EndBug> OP ( next ) = EXACTFU ; } if ( STR_LEN ( next ) == 1 && isALPHA_A ( * STRING ( next ) ) && ( OP ( next ) == EXACTFAA || ( OP ( next ) == EXACTFU <S2SV_StartBug> && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE ( * STRING ( next ) ) ) ) ) <S2SV_EndBug> { U8 mask = ~ ( 'A' ^ 'a' ) ; assert ( isALPHA_A ( * STRING ( next ) ) ) ; OP ( next ) = ANYOFM ; ARG_SET ( next , * STRING ( next ) & mask ) ; FLAGS ( next ) = mask ; } if ( flags & SCF_DO_STCLASS ) { mincount = 0 ; maxcount = REG_INFTY ; next = regnext ( scan ) ; scan = NEXTOPER ( scan ) ; goto do_curly ; } if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; data -> cur_is_floating = 1 ; } is_inf = is_inf_internal = 1 ; scan = regnext ( scan ) ; goto optimize_curly_tail ; case CURLY : if ( stopparen > 0 && ( OP ( scan ) == CURLYN || OP ( scan ) == CURLYM ) && ( scan -> flags == stopparen ) ) { mincount = 1 ; maxcount = 1 ; } else { mincount = ARG1 ( scan ) ; maxcount = ARG2 ( scan ) ; } next = regnext ( scan ) ; if ( OP ( scan ) == CURLYX ) { I32 lp = ( data ? * ( data -> last_closep ) : 0 ) ; scan -> flags = ( ( lp <= ( I32 ) U8_MAX ) ? ( U8 ) lp : U8_MAX ) ; } scan = NEXTOPER ( scan ) + EXTRA_STEP_2ARGS ; next_is_eval = ( OP ( scan ) == EVAL ) ; do_curly : if ( flags & SCF_DO_SUBSTR ) { if ( mincount == 0 ) scan_commit ( pRExC_state , data , minlenp , is_inf ) ; pos_before = data -> pos_min ; } if ( data ) { fl = data -> flags ; data -> flags &= ~ ( SF_HAS_PAR | SF_IN_PAR | SF_HAS_EVAL ) ; if ( is_inf ) data -> flags |= SF_IS_INF ; } if ( flags & SCF_DO_STCLASS ) { ssc_init ( pRExC_state , & this_class ) ; oclass = data -> start_class ; data -> start_class = & this_class ; f |= SCF_DO_STCLASS_AND ; f &= ~ SCF_DO_STCLASS_OR ; } if ( ( mincount > 1 ) || ( maxcount > 1 && maxcount != REG_INFTY ) ) f &= ~ SCF_WHILEM_VISITED_POS ; minnext = study_chunk ( pRExC_state , & scan , minlenp , & deltanext , last , data , stopparen , recursed_depth , NULL , ( mincount == 0 ? ( f & ~ SCF_DO_SUBSTR ) : f ) <S2SV_StartBug> , depth + 1 ) ; <S2SV_EndBug> if ( flags & SCF_DO_STCLASS ) data -> start_class = oclass ; if ( mincount == 0 || minnext == 0 ) { if ( flags & SCF_DO_STCLASS_OR ) { ssc_or ( pRExC_state , data -> start_class , ( regnode_charclass * ) & this_class ) ; } else if ( flags & SCF_DO_STCLASS_AND ) { INIT_AND_WITHP ; StructCopy ( data -> start_class , and_withp , regnode_ssc ) ; flags &= ~ SCF_DO_STCLASS_AND ; StructCopy ( & this_class , data -> start_class , regnode_ssc ) ; flags |= SCF_DO_STCLASS_OR ; ANYOF_FLAGS ( data -> start_class ) |= SSC_MATCHES_EMPTY_STRING ; } } else { if ( flags & SCF_DO_STCLASS_OR ) { ssc_or ( pRExC_state , data -> start_class , ( regnode_charclass * ) & this_class ) ; ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; } else if ( flags & SCF_DO_STCLASS_AND ) ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) & this_class ) ; flags &= ~ SCF_DO_STCLASS ; } if ( ! scan ) scan = next ; if ( ( ( flags & ( SCF_TRIE_DOING_RESTUDY | SCF_DO_SUBSTR ) ) == SCF_DO_SUBSTR ) && ( next_is_eval || ! ( mincount == 0 && maxcount == 1 ) ) && ( minnext == 0 ) && ( deltanext == 0 ) && data && ! ( data -> flags & ( SF_HAS_PAR | SF_IN_PAR ) ) && maxcount <= REG_INFTY / 3 ) { _WARN_HELPER ( RExC_precomp_end , packWARN ( WARN_REGEXP ) , Perl_ck_warner ( aTHX_ packWARN ( WARN_REGEXP ) , \"Quantifier<S2SV_blank>unexpected<S2SV_blank>on<S2SV_blank>zero-length<S2SV_blank>expression<S2SV_blank>\" \"in<S2SV_blank>regex<S2SV_blank>m/%\" UTF8f \"/\" , UTF8fARG ( UTF , RExC_precomp_end - RExC_precomp , RExC_precomp ) ) ) ; } if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext ) || min >= SSize_t_MAX - minnext * mincount ) { FAIL ( \"Regexp<S2SV_blank>out<S2SV_blank>of<S2SV_blank>space\" ) ; } min += minnext * mincount ; is_inf_internal |= deltanext == SSize_t_MAX || ( maxcount == REG_INFTY && minnext + deltanext > 0 ) ; is_inf |= is_inf_internal ; if ( is_inf ) { delta = SSize_t_MAX ; } else { delta += ( minnext + deltanext ) * maxcount - minnext * mincount ; } if ( OP ( oscan ) == CURLYX && data && data -> flags & SF_IN_PAR && ! ( data -> flags & SF_HAS_EVAL ) <S2SV_StartBug> && ! deltanext && minnext == 1 ) { <S2SV_EndBug> regnode * nxt = NEXTOPER ( oscan ) + EXTRA_STEP_2ARGS ; regnode * const nxt1 = nxt ; # ifdef DEBUGGING regnode * nxt2 ; # endif nxt = regnext ( nxt ) ; if ( ! REGNODE_SIMPLE ( OP ( nxt ) ) && ! ( PL_regkind [ OP ( nxt ) ] == EXACT && STR_LEN ( nxt ) == 1 ) ) goto nogo ; # ifdef DEBUGGING nxt2 = nxt ; # endif nxt = regnext ( nxt ) ; if ( OP ( nxt ) != CLOSE ) goto nogo ; if ( RExC_open_parens ) { RExC_open_parens [ ARG ( nxt1 ) ] = REGNODE_OFFSET ( oscan ) ; RExC_close_parens [ ARG ( nxt1 ) ] = REGNODE_OFFSET ( nxt ) + 2 ; } oscan -> flags = ( U8 ) ARG ( nxt ) ; OP ( oscan ) = CURLYN ; OP ( nxt1 ) = NOTHING ; # ifdef DEBUGGING OP ( nxt1 + 1 ) = OPTIMIZED ; NEXT_OFF ( nxt1 + 1 ) = 0 ; NEXT_OFF ( nxt2 ) = 0 ; OP ( nxt ) = OPTIMIZED ; OP ( nxt + 1 ) = OPTIMIZED ; NEXT_OFF ( nxt + 1 ) = 0 ; # endif } nogo : if ( OP ( oscan ) == CURLYX && data && ! ( data -> flags & SF_HAS_PAR ) && ! ( data -> flags & SF_HAS_EVAL ) && ! deltanext && minnext != 0 <S2SV_StartBug> && ! ( RExC_seen & REG_UNFOLDED_MULTI_SEEN ) <S2SV_EndBug> ) { regnode * nxt = NEXTOPER ( oscan ) + EXTRA_STEP_2ARGS ; regnode * nxt2 ; OP ( oscan ) = CURLYM ; while ( ( nxt2 = regnext ( nxt ) ) && ( OP ( nxt2 ) != WHILEM ) ) nxt = nxt2 ; OP ( nxt2 ) = SUCCEED ; if ( ( data -> flags & SF_IN_PAR ) && OP ( nxt ) == CLOSE ) { regnode * nxt1 = NEXTOPER ( oscan ) + EXTRA_STEP_2ARGS ; oscan -> flags = ( U8 ) ARG ( nxt ) ; if ( RExC_open_parens ) { RExC_open_parens [ ARG ( nxt1 ) ] = REGNODE_OFFSET ( oscan ) ; RExC_close_parens [ ARG ( nxt1 ) ] = REGNODE_OFFSET ( nxt2 ) + 1 ; } OP ( nxt1 ) = OPTIMIZED ; OP ( nxt ) = OPTIMIZED ; # ifdef DEBUGGING OP ( nxt1 + 1 ) = OPTIMIZED ; OP ( nxt + 1 ) = OPTIMIZED ; NEXT_OFF ( nxt1 + 1 ) = 0 ; NEXT_OFF ( nxt + 1 ) = 0 ; # endif # if 0 while ( nxt1 && ( OP ( nxt1 ) != WHILEM ) ) { regnode * nnxt = regnext ( nxt1 ) ; if ( nnxt == nxt ) { if ( reg_off_by_arg [ OP ( nxt1 ) ] ) ARG_SET ( nxt1 , nxt2 - nxt1 ) ; else if ( nxt2 - nxt1 < U16_MAX ) NEXT_OFF ( nxt1 ) = nxt2 - nxt1 ; else OP ( nxt ) = NOTHING ; } nxt1 = nnxt ; } # endif study_chunk ( pRExC_state , & nxt1 , minlenp , & deltanext , nxt , NULL , stopparen , recursed_depth , NULL , 0 , <S2SV_StartBug> depth + 1 ) ; <S2SV_EndBug> } else oscan -> flags = 0 ; } else if ( ( OP ( oscan ) == CURLYX ) && ( flags & SCF_WHILEM_VISITED_POS ) && ( maxcount == REG_INFTY ) && data ) { regnode * nxt = oscan + NEXT_OFF ( oscan ) ; if ( OP ( PREVOPER ( nxt ) ) == NOTHING ) nxt += ARG ( nxt ) ; nxt = PREVOPER ( nxt ) ; if ( nxt -> flags & 0xf ) { } else if ( ++ data -> whilem_c < 16 ) { assert ( data -> whilem_c <= RExC_whilem_seen ) ; nxt -> flags = ( U8 ) ( data -> whilem_c | ( RExC_whilem_seen << 4 ) ) ; } } if ( data && fl & ( SF_HAS_PAR | SF_IN_PAR ) ) pars ++ ; if ( flags & SCF_DO_SUBSTR ) { SV * last_str = NULL ; STRLEN last_chrs = 0 ; int counted = mincount != 0 ; if ( data -> last_end > 0 && mincount != 0 ) { SSize_t b = pos_before >= data -> last_start_min ? pos_before : data -> last_start_min ; STRLEN l ; const char * const s = SvPV_const ( data -> last_found , l ) ; SSize_t old = b - data -> last_start_min ; assert ( old >= 0 ) ; if ( UTF ) old = utf8_hop_forward ( ( U8 * ) s , old , ( U8 * ) SvEND ( data -> last_found ) ) - ( U8 * ) s ; l -= old ; last_str = newSVpvn_utf8 ( s + old , l , UTF ) ; last_chrs = UTF ? utf8_length ( ( U8 * ) ( s + old ) , ( U8 * ) ( s + old + l ) ) : l ; if ( deltanext == 0 && pos_before == b ) { if ( mincount > 1 ) { SvGROW ( last_str , ( mincount * l ) + 1 ) ; repeatcpy ( SvPVX ( last_str ) + l , SvPVX_const ( last_str ) , l , mincount - 1 ) ; SvCUR_set ( last_str , SvCUR ( last_str ) * mincount ) ; SvCUR_set ( data -> last_found , SvCUR ( data -> last_found ) - l ) ; sv_catsv ( data -> last_found , last_str ) ; { SV * sv = data -> last_found ; MAGIC * mg = SvUTF8 ( sv ) && SvMAGICAL ( sv ) ? mg_find ( sv , PERL_MAGIC_utf8 ) : NULL ; if ( mg && mg -> mg_len >= 0 ) mg -> mg_len += last_chrs * ( mincount - 1 ) ; } last_chrs *= mincount ; data -> last_end += l * ( mincount - 1 ) ; } } else { data -> last_start_min += minnext * ( mincount - 1 ) ; data -> last_start_max = is_inf ? SSize_t_MAX : data -> last_start_max + ( maxcount - 1 ) * ( minnext + data -> pos_delta ) ; } } data -> pos_min += minnext * ( mincount - counted ) ; # if 0 Perl_re_printf ( aTHX_ \"counted=%\" UVuf \"<S2SV_blank>deltanext=%\" UVuf \"<S2SV_blank>SSize_t_MAX=%\" UVuf \"<S2SV_blank>minnext=%\" UVuf \"<S2SV_blank>maxcount=%\" UVuf \"<S2SV_blank>mincount=%\" UVuf \"\\\\n\" , ( UV ) counted , ( UV ) deltanext , ( UV ) SSize_t_MAX , ( UV ) minnext , ( UV ) maxcount , ( UV ) mincount ) ; if ( deltanext != SSize_t_MAX ) Perl_re_printf ( aTHX_ \"LHS=%\" UVuf \"<S2SV_blank>RHS=%\" UVuf \"\\\\n\" , ( UV ) ( - counted * deltanext + ( minnext + deltanext ) * maxcount - minnext * mincount ) , ( UV ) ( SSize_t_MAX - data -> pos_delta ) ) ; # endif if ( deltanext == SSize_t_MAX || - counted * deltanext + ( minnext + deltanext ) * maxcount - minnext * mincount >= SSize_t_MAX - data -> pos_delta ) data -> pos_delta = SSize_t_MAX ; else data -> pos_delta += - counted * deltanext + ( minnext + deltanext ) * maxcount - minnext * mincount ; if ( mincount != maxcount ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; if ( mincount && last_str ) { SV * const sv = data -> last_found ; MAGIC * const mg = SvUTF8 ( sv ) && SvMAGICAL ( sv ) ? mg_find ( sv , PERL_MAGIC_utf8 ) : NULL ; if ( mg ) mg -> mg_len = - 1 ; sv_setsv ( sv , last_str ) ; data -> last_end = data -> pos_min ; data -> last_start_min = data -> pos_min - last_chrs ; data -> last_start_max = is_inf ? SSize_t_MAX : data -> pos_min + data -> pos_delta - last_chrs ; } data -> cur_is_floating = 1 ; } SvREFCNT_dec ( last_str ) ; } if ( data && ( fl & SF_HAS_EVAL ) ) data -> flags |= SF_HAS_EVAL ; optimize_curly_tail : rck_elide_nothing ( oscan ) ; continue ; default : # ifdef DEBUGGING Perl_croak ( aTHX_ \"panic:<S2SV_blank>unexpected<S2SV_blank>varying<S2SV_blank>REx<S2SV_blank>opcode<S2SV_blank>%d\" , OP ( scan ) ) ; # endif case REF : case CLUMP : if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; data -> cur_is_floating = 1 ; } is_inf = is_inf_internal = 1 ; if ( flags & SCF_DO_STCLASS_OR ) { if ( OP ( scan ) == CLUMP ) { ssc_match_all_cp ( data -> start_class ) ; } else { ssc_anything ( data -> start_class ) ; } } flags &= ~ SCF_DO_STCLASS ; break ; } } else if ( OP ( scan ) == LNBREAK ) { if ( flags & SCF_DO_STCLASS ) { if ( flags & SCF_DO_STCLASS_AND ) { ssc_intersection ( data -> start_class , PL_XPosix_ptrs [ _CC_VERTSPACE ] , FALSE ) ; ssc_clear_locale ( data -> start_class ) ; ANYOF_FLAGS ( data -> start_class ) &= ~ SSC_MATCHES_EMPTY_STRING ; } else if ( flags & SCF_DO_STCLASS_OR ) { ssc_union ( data -> start_class , PL_XPosix_ptrs [ _CC_VERTSPACE ] , FALSE ) ; ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; ANYOF_FLAGS ( data -> start_class ) &= ~ SSC_MATCHES_EMPTY_STRING ; } flags &= ~ SCF_DO_STCLASS ; } min ++ ; if ( delta != SSize_t_MAX ) delta ++ ; if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; data -> pos_min += 1 ; if ( data -> pos_delta != SSize_t_MAX ) { data -> pos_delta += 1 ; } data -> cur_is_floating = 1 ; } } else if ( REGNODE_SIMPLE ( OP ( scan ) ) ) { if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; data -> pos_min ++ ; } min ++ ; if ( flags & SCF_DO_STCLASS ) { bool invert = 0 ; SV * my_invlist = NULL ; U8 namedclass ; ANYOF_FLAGS ( data -> start_class ) &= ~ SSC_MATCHES_EMPTY_STRING ; switch ( OP ( scan ) ) { default : # ifdef DEBUGGING Perl_croak ( aTHX_ \"panic:<S2SV_blank>unexpected<S2SV_blank>simple<S2SV_blank>REx<S2SV_blank>opcode<S2SV_blank>%d\" , OP ( scan ) ) ; # endif case SANY : if ( flags & SCF_DO_STCLASS_OR ) ssc_match_all_cp ( data -> start_class ) ; break ; case REG_ANY : { SV * REG_ANY_invlist = _new_invlist ( 2 ) ; REG_ANY_invlist = add_cp_to_invlist ( REG_ANY_invlist , '\\\\n' ) ; if ( flags & SCF_DO_STCLASS_OR ) { ssc_union ( data -> start_class , REG_ANY_invlist , TRUE ) ; } else if ( flags & SCF_DO_STCLASS_AND ) { ssc_intersection ( data -> start_class , REG_ANY_invlist , TRUE ) ; ssc_clear_locale ( data -> start_class ) ; } SvREFCNT_dec_NN ( REG_ANY_invlist ) ; } break ; case ANYOFD : case ANYOFL : case ANYOFPOSIXL : case ANYOFH : case ANYOF : if ( flags & SCF_DO_STCLASS_AND ) ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) scan ) ; else ssc_or ( pRExC_state , data -> start_class , ( regnode_charclass * ) scan ) ; break ; case NANYOFM : case ANYOFM : { SV * cp_list = get_ANYOFM_contents ( scan ) ; if ( flags & SCF_DO_STCLASS_OR ) { ssc_union ( data -> start_class , cp_list , invert ) ; } else if ( flags & SCF_DO_STCLASS_AND ) { ssc_intersection ( data -> start_class , cp_list , invert ) ; } SvREFCNT_dec_NN ( cp_list ) ; break ; } case NPOSIXL : invert = 1 ; case POSIXL : namedclass = classnum_to_namedclass ( FLAGS ( scan ) ) + invert ; if ( flags & SCF_DO_STCLASS_AND ) { bool was_there = cBOOL ( ANYOF_POSIXL_TEST ( data -> start_class , namedclass ) ) ; ANYOF_POSIXL_ZERO ( data -> start_class ) ; if ( was_there ) { ANYOF_POSIXL_SET ( data -> start_class , namedclass ) ; } data -> start_class -> invlist = sv_2mortal ( _new_invlist ( 0 ) ) ; } else { int complement = namedclass + ( ( invert ) ? - 1 : 1 ) ; assert ( flags & SCF_DO_STCLASS_OR ) ; if ( ANYOF_POSIXL_TEST ( data -> start_class , complement ) ) { ssc_match_all_cp ( data -> start_class ) ; ANYOF_POSIXL_CLEAR ( data -> start_class , namedclass ) ; ANYOF_POSIXL_CLEAR ( data -> start_class , complement ) ; } else { ANYOF_POSIXL_SET ( data -> start_class , namedclass ) ; } } break ; case NPOSIXA : invert = 1 ; case POSIXA : my_invlist = invlist_clone ( PL_Posix_ptrs [ FLAGS ( scan ) ] , NULL ) ; goto join_posix_and_ascii ; case NPOSIXD : case NPOSIXU : invert = 1 ; case POSIXD : case POSIXU : my_invlist = invlist_clone ( PL_XPosix_ptrs [ FLAGS ( scan ) ] , NULL ) ; if ( OP ( scan ) == NPOSIXD ) { _invlist_subtract ( my_invlist , PL_UpperLatin1 , & my_invlist ) ; } join_posix_and_ascii : if ( flags & SCF_DO_STCLASS_AND ) { ssc_intersection ( data -> start_class , my_invlist , invert ) ; ssc_clear_locale ( data -> start_class ) ; } else { assert ( flags & SCF_DO_STCLASS_OR ) ; ssc_union ( data -> start_class , my_invlist , invert ) ; } SvREFCNT_dec ( my_invlist ) ; } if ( flags & SCF_DO_STCLASS_OR ) ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; flags &= ~ SCF_DO_STCLASS ; } } else if ( PL_regkind [ OP ( scan ) ] == EOL && flags & SCF_DO_SUBSTR ) { data -> flags |= ( OP ( scan ) == MEOL ? SF_BEFORE_MEOL : SF_BEFORE_SEOL ) ; scan_commit ( pRExC_state , data , minlenp , is_inf ) ; } else if ( PL_regkind [ OP ( scan ) ] == BRANCHJ && ( scan -> flags || data || ( flags & SCF_DO_STCLASS ) ) && ( OP ( scan ) == IFMATCH || OP ( scan ) == UNLESSM ) ) { if ( ! PERL_ENABLE_POSITIVE_ASSERTION_STUDY || OP ( scan ) == UNLESSM ) { SSize_t deltanext , minnext , fake = 0 ; regnode * nscan ; regnode_ssc intrnl ; int f = 0 ; StructCopy ( & zero_scan_data , & data_fake , scan_data_t ) ; if ( data ) { data_fake . whilem_c = data -> whilem_c ; data_fake . last_closep = data -> last_closep ; } else data_fake . last_closep = & fake ; data_fake . pos_delta = delta ; if ( flags & SCF_DO_STCLASS && ! scan -> flags && OP ( scan ) == IFMATCH ) { ssc_init ( pRExC_state , & intrnl ) ; data_fake . start_class = & intrnl ; f |= SCF_DO_STCLASS_AND ; } if ( flags & SCF_WHILEM_VISITED_POS ) f |= SCF_WHILEM_VISITED_POS ; next = regnext ( scan ) ; nscan = NEXTOPER ( NEXTOPER ( scan ) ) ; minnext = study_chunk ( pRExC_state , & nscan , minlenp , & deltanext , last , & data_fake , stopparen , <S2SV_StartBug> recursed_depth , NULL , f , depth + 1 ) ; <S2SV_EndBug> if ( scan -> flags ) { if ( deltanext < 0 || deltanext > ( I32 ) U8_MAX || minnext > ( I32 ) U8_MAX || minnext + deltanext > ( I32 ) U8_MAX ) { FAIL2 ( \"Lookbehind<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>%\" UVuf \"<S2SV_blank>not<S2SV_blank>implemented\" , ( UV ) U8_MAX ) ; } if ( deltanext ) { scan -> next_off = deltanext ; ckWARNexperimental ( RExC_parse , WARN_EXPERIMENTAL__VLB , \"Variable<S2SV_blank>length<S2SV_blank>lookbehind<S2SV_blank>is<S2SV_blank>experimental\" ) ; } scan -> flags = ( U8 ) minnext + deltanext ; } if ( data ) { if ( data_fake . flags & ( SF_HAS_PAR | SF_IN_PAR ) ) pars ++ ; if ( data_fake . flags & SF_HAS_EVAL ) data -> flags |= SF_HAS_EVAL ; data -> whilem_c = data_fake . whilem_c ; } if ( f & SCF_DO_STCLASS_AND ) { if ( flags & SCF_DO_STCLASS_OR ) { ssc_init ( pRExC_state , data -> start_class ) ; } else { ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) & intrnl ) ; ANYOF_FLAGS ( data -> start_class ) |= SSC_MATCHES_EMPTY_STRING ; } } } # if PERL_ENABLE_POSITIVE_ASSERTION_STUDY else { SSize_t deltanext , fake = 0 ; regnode * nscan ; regnode_ssc intrnl ; int f = 0 ; SSize_t * minnextp ; Newx ( minnextp , 1 , SSize_t ) ; SAVEFREEPV ( minnextp ) ; if ( data ) { StructCopy ( data , & data_fake , scan_data_t ) ; if ( ( flags & SCF_DO_SUBSTR ) && data -> last_found ) { f |= SCF_DO_SUBSTR ; if ( scan -> flags ) scan_commit ( pRExC_state , & data_fake , minlenp , is_inf ) ; data_fake . last_found = newSVsv ( data -> last_found ) ; } } else data_fake . last_closep = & fake ; data_fake . flags = 0 ; data_fake . substrs [ 0 ] . flags = 0 ; data_fake . substrs [ 1 ] . flags = 0 ; data_fake . pos_delta = delta ; if ( is_inf ) data_fake . flags |= SF_IS_INF ; if ( flags & SCF_DO_STCLASS && ! scan -> flags && OP ( scan ) == IFMATCH ) { ssc_init ( pRExC_state , & intrnl ) ; data_fake . start_class = & intrnl ; f |= SCF_DO_STCLASS_AND ; } if ( flags & SCF_WHILEM_VISITED_POS ) f |= SCF_WHILEM_VISITED_POS ; next = regnext ( scan ) ; nscan = NEXTOPER ( NEXTOPER ( scan ) ) ; * minnextp = study_chunk ( pRExC_state , & nscan , minnextp , & deltanext , last , & data_fake , stopparen , recursed_depth , NULL , <S2SV_StartBug> f , depth + 1 ) ; <S2SV_EndBug> if ( scan -> flags ) { assert ( 0 ) ; if ( deltanext < 0 || deltanext > ( I32 ) U8_MAX || * minnextp > ( I32 ) U8_MAX || * minnextp + deltanext > ( I32 ) U8_MAX ) { FAIL2 ( \"Lookbehind<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>%\" UVuf \"<S2SV_blank>not<S2SV_blank>implemented\" , ( UV ) U8_MAX ) ; } if ( deltanext ) { scan -> next_off = deltanext ; } scan -> flags = ( U8 ) * minnextp + deltanext ; } * minnextp += min ; if ( f & SCF_DO_STCLASS_AND ) { ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) & intrnl ) ; ANYOF_FLAGS ( data -> start_class ) |= SSC_MATCHES_EMPTY_STRING ; } if ( data ) { if ( data_fake . flags & ( SF_HAS_PAR | SF_IN_PAR ) ) pars ++ ; if ( data_fake . flags & SF_HAS_EVAL ) data -> flags |= SF_HAS_EVAL ; data -> whilem_c = data_fake . whilem_c ; if ( ( flags & SCF_DO_SUBSTR ) && data_fake . last_found ) { int i ; if ( RExC_rx -> minlen < * minnextp ) RExC_rx -> minlen = * minnextp ; scan_commit ( pRExC_state , & data_fake , minnextp , is_inf ) ; SvREFCNT_dec_NN ( data_fake . last_found ) ; for ( i = 0 ; i < 2 ; i ++ ) { if ( data_fake . substrs [ i ] . minlenp != minlenp ) { data -> substrs [ i ] . min_offset = data_fake . substrs [ i ] . min_offset ; data -> substrs [ i ] . max_offset = data_fake . substrs [ i ] . max_offset ; data -> substrs [ i ] . minlenp = data_fake . substrs [ i ] . minlenp ; data -> substrs [ i ] . lookbehind += scan -> flags ; } } } } } # endif } else if ( OP ( scan ) == OPEN ) { if ( stopparen != ( I32 ) ARG ( scan ) ) pars ++ ; } else if ( OP ( scan ) == CLOSE ) { if ( stopparen == ( I32 ) ARG ( scan ) ) { break ; } if ( ( I32 ) ARG ( scan ) == is_par ) { next = regnext ( scan ) ; if ( next && ( OP ( next ) != WHILEM ) && next < last ) is_par = 0 ; } if ( data ) * ( data -> last_closep ) = ARG ( scan ) ; } else if ( OP ( scan ) == EVAL ) { if ( data ) data -> flags |= SF_HAS_EVAL ; } else if ( PL_regkind [ OP ( scan ) ] == ENDLIKE ) { if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; flags &= ~ SCF_DO_SUBSTR ; } if ( data && OP ( scan ) == ACCEPT ) { data -> flags |= SCF_SEEN_ACCEPT ; if ( stopmin > min ) stopmin = min ; } } else if ( OP ( scan ) == LOGICAL && scan -> flags == 2 ) { if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; data -> cur_is_floating = 1 ; } is_inf = is_inf_internal = 1 ; if ( flags & SCF_DO_STCLASS_OR ) ssc_anything ( data -> start_class ) ; flags &= ~ SCF_DO_STCLASS ; } else if ( OP ( scan ) == GPOS ) { if ( ! ( RExC_rx -> intflags & PREGf_GPOS_FLOAT ) && ! ( delta || is_inf || ( data && data -> pos_delta ) ) ) { if ( ! ( RExC_rx -> intflags & PREGf_ANCH ) && ( flags & SCF_DO_SUBSTR ) ) RExC_rx -> intflags |= PREGf_ANCH_GPOS ; if ( RExC_rx -> gofs < ( STRLEN ) min ) RExC_rx -> gofs = min ; } else { RExC_rx -> intflags |= PREGf_GPOS_FLOAT ; RExC_rx -> gofs = 0 ; } } # ifdef TRIE_STUDY_OPT # ifdef FULL_TRIE_STUDY else if ( PL_regkind [ OP ( scan ) ] == TRIE ) { regnode * trie_node = scan ; regnode * tail = regnext ( scan ) ; reg_trie_data * trie = ( reg_trie_data * ) RExC_rxi -> data -> data [ ARG ( scan ) ] ; SSize_t max1 = 0 , min1 = SSize_t_MAX ; regnode_ssc accum ; if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; } if ( flags & SCF_DO_STCLASS ) ssc_init_zero ( pRExC_state , & accum ) ; if ( ! trie -> jump ) { min1 = trie -> minlen ; max1 = trie -> maxlen ; } else { const regnode * nextbranch = NULL ; U32 word ; for ( word = 1 ; word <= trie -> wordcount ; word ++ ) { SSize_t deltanext = 0 , minnext = 0 , f = 0 , fake ; regnode_ssc this_class ; StructCopy ( & zero_scan_data , & data_fake , scan_data_t ) ; if ( data ) { data_fake . whilem_c = data -> whilem_c ; data_fake . last_closep = data -> last_closep ; } else data_fake . last_closep = & fake ; data_fake . pos_delta = delta ; if ( flags & SCF_DO_STCLASS ) { ssc_init ( pRExC_state , & this_class ) ; data_fake . start_class = & this_class ; f = SCF_DO_STCLASS_AND ; } if ( flags & SCF_WHILEM_VISITED_POS ) f |= SCF_WHILEM_VISITED_POS ; if ( trie -> jump [ word ] ) { if ( ! nextbranch ) nextbranch = trie_node + trie -> jump [ 0 ] ; scan = trie_node + trie -> jump [ word ] ; minnext = study_chunk ( pRExC_state , & scan , minlenp , & deltanext , ( regnode * ) nextbranch , & data_fake , <S2SV_StartBug> stopparen , recursed_depth , NULL , f , depth + 1 ) ; <S2SV_EndBug> } if ( nextbranch && PL_regkind [ OP ( nextbranch ) ] == BRANCH ) nextbranch = regnext ( ( regnode * ) nextbranch ) ; if ( min1 > ( SSize_t ) ( minnext + trie -> minlen ) ) min1 = minnext + trie -> minlen ; if ( deltanext == SSize_t_MAX ) { is_inf = is_inf_internal = 1 ; max1 = SSize_t_MAX ; } else if ( max1 < ( SSize_t ) ( minnext + deltanext + trie -> maxlen ) ) max1 = minnext + deltanext + trie -> maxlen ; if ( data_fake . flags & ( SF_HAS_PAR | SF_IN_PAR ) ) pars ++ ; if ( data_fake . flags & SCF_SEEN_ACCEPT ) { if ( stopmin > min + min1 ) stopmin = min + min1 ; flags &= ~ SCF_DO_SUBSTR ; if ( data ) data -> flags |= SCF_SEEN_ACCEPT ; } if ( data ) { if ( data_fake . flags & SF_HAS_EVAL ) data -> flags |= SF_HAS_EVAL ; data -> whilem_c = data_fake . whilem_c ; } if ( flags & SCF_DO_STCLASS ) ssc_or ( pRExC_state , & accum , ( regnode_charclass * ) & this_class ) ; } } if ( flags & SCF_DO_SUBSTR ) { data -> pos_min += min1 ; data -> pos_delta += max1 - min1 ; if ( max1 != min1 || is_inf ) data -> cur_is_floating = 1 ; } min += min1 ; if ( delta != SSize_t_MAX ) { if ( SSize_t_MAX - ( max1 - min1 ) >= delta ) delta += max1 - min1 ; else delta = SSize_t_MAX ; } if ( flags & SCF_DO_STCLASS_OR ) { ssc_or ( pRExC_state , data -> start_class , ( regnode_charclass * ) & accum ) ; if ( min1 ) { ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; flags &= ~ SCF_DO_STCLASS ; } } else if ( flags & SCF_DO_STCLASS_AND ) { if ( min1 ) { ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) & accum ) ; flags &= ~ SCF_DO_STCLASS ; } else { INIT_AND_WITHP ; StructCopy ( data -> start_class , and_withp , regnode_ssc ) ; flags &= ~ SCF_DO_STCLASS_AND ; StructCopy ( & accum , data -> start_class , regnode_ssc ) ; flags |= SCF_DO_STCLASS_OR ; } } scan = tail ; continue ; } # else else if ( PL_regkind [ OP ( scan ) ] == TRIE ) { reg_trie_data * trie = ( reg_trie_data * ) RExC_rxi -> data -> data [ ARG ( scan ) ] ; U8 * bang = NULL ; min += trie -> minlen ; delta += ( trie -> maxlen - trie -> minlen ) ; flags &= ~ SCF_DO_STCLASS ; if ( flags & SCF_DO_SUBSTR ) { scan_commit ( pRExC_state , data , minlenp , is_inf ) ; data -> pos_min += trie -> minlen ; data -> pos_delta += ( trie -> maxlen - trie -> minlen ) ; if ( trie -> maxlen != trie -> minlen ) data -> cur_is_floating = 1 ; } if ( trie -> jump ) flags &= ~ SCF_DO_SUBSTR ; } # endif # endif scan = regnext ( scan ) ; } finish : if ( frame ) { depth = depth - 1 ; DEBUG_STUDYDATA ( \"frame-end\" , data , depth , is_inf ) ; DEBUG_PEEP ( \"fend\" , scan , depth , flags ) ; last = frame -> last_regnode ; scan = frame -> next_regnode ; stopparen = frame -> stopparen ; recursed_depth = frame -> prev_recursed_depth ; RExC_frame_last = frame -> prev_frame ; frame = frame -> this_prev_frame ; goto fake_study_recurse ; } assert ( ! frame ) ; DEBUG_STUDYDATA ( \"pre-fin\" , data , depth , is_inf ) ; * scanp = scan ; * deltap = is_inf_internal ? SSize_t_MAX : delta ; if ( flags & SCF_DO_SUBSTR && is_inf ) data -> pos_delta = SSize_t_MAX - data -> pos_min ; if ( is_par > ( I32 ) U8_MAX ) is_par = 0 ; if ( is_par && pars == 1 && data ) { data -> flags |= SF_IN_PAR ; data -> flags &= ~ SF_HAS_PAR ; } else if ( pars && data ) { data -> flags |= SF_HAS_PAR ; data -> flags &= ~ SF_IN_PAR ; } if ( flags & SCF_DO_STCLASS_OR ) ssc_and ( pRExC_state , data -> start_class , ( regnode_charclass * ) and_withp ) ; if ( flags & SCF_TRIE_RESTUDY ) data -> flags |= SCF_TRIE_RESTUDY ; DEBUG_STUDYDATA ( \"post-fin\" , data , depth , is_inf ) ; { SSize_t final_minlen = min < stopmin ? min : stopmin ; if ( ! ( RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN ) ) { if ( final_minlen > SSize_t_MAX - delta ) RExC_maxlen = SSize_t_MAX ; else if ( RExC_maxlen < final_minlen + delta ) RExC_maxlen = final_minlen + delta ; } return final_minlen ; } NOT_REACHED ;", "target": "<S2SV_ModStart> , U32 depth , bool was_mutate_ok <S2SV_ModStart> = FALSE ; bool mutate_ok = was_mutate_ok && ! ( frame && frame -> in_gosub ) ; <S2SV_ModStart> flags ) ; if ( mutate_ok ) <S2SV_ModStart> depth + 1 , mutate_ok <S2SV_ModStart> depth + 1 , mutate_ok <S2SV_ModStart> ) == BRANCH && mutate_ok ) <S2SV_ModEnd> { int made <S2SV_ModStart> = frame ; newframe -> in_gosub = ( ( frame && frame -> in_gosub ) || OP ( scan ) == GOSUB ) ; <S2SV_ModStart> ) == EXACTFU_S_EDGE && mutate_ok <S2SV_ModStart> ) ) ) && mutate_ok ) <S2SV_ModEnd> { U8 mask <S2SV_ModStart> depth + 1 , mutate_ok <S2SV_ModStart> minnext == 1 && mutate_ok <S2SV_ModStart> & REG_UNFOLDED_MULTI_SEEN ) && mutate_ok <S2SV_ModStart> depth + 1 , mutate_ok <S2SV_ModStart> depth + 1 , mutate_ok <S2SV_ModStart> depth + 1 , mutate_ok <S2SV_ModStart> depth + 1 , mutate_ok"}
{"source": "CWE-20 asmlinkage long sys_setrlimit ( unsigned int resource , struct rlimit __user * rlim ) { struct rlimit new_rlim , * old_rlim ; unsigned long it_prof_secs ; int retval ; if ( resource >= RLIM_NLIMITS ) return - EINVAL ; if ( copy_from_user ( & new_rlim , rlim , sizeof ( * rlim ) ) ) return - EFAULT ; if ( new_rlim . rlim_cur > new_rlim . rlim_max ) return - EINVAL ; old_rlim = current -> signal -> rlim + resource ; if ( ( new_rlim . rlim_max > old_rlim -> rlim_max ) && ! capable ( CAP_SYS_RESOURCE ) ) return - EPERM ; if ( resource == RLIMIT_NOFILE && new_rlim . rlim_max > NR_OPEN ) return - EPERM ; retval = security_task_setrlimit ( resource , & new_rlim ) ; if ( retval ) return retval ; <S2SV_StartBug> task_lock ( current -> group_leader ) ; <S2SV_EndBug> * old_rlim = new_rlim ; task_unlock ( current -> group_leader ) ; if ( resource != RLIMIT_CPU ) goto out ; if ( new_rlim . rlim_cur == RLIM_INFINITY ) goto out ; it_prof_secs = cputime_to_secs ( current -> signal -> it_prof_expires ) ; if ( it_prof_secs == 0 || new_rlim . rlim_cur <= it_prof_secs ) { unsigned long rlim_cur = new_rlim . rlim_cur ; cputime_t cputime ; <S2SV_StartBug> if ( rlim_cur == 0 ) { <S2SV_EndBug> rlim_cur = 1 ; } cputime = secs_to_cputime ( rlim_cur ) ; read_lock ( & tasklist_lock ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; set_process_cpu_timer ( current , CPUCLOCK_PROF , & cputime , NULL ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; read_unlock ( & tasklist_lock ) ; } out : return 0 ; }", "target": "<S2SV_ModStart> return retval ; if ( resource == RLIMIT_CPU && new_rlim . rlim_cur == 0 ) { new_rlim . rlim_cur = 1 ; } <S2SV_ModStart> cputime_t cputime ; <S2SV_ModEnd> cputime = secs_to_cputime"}
{"source": "CWE-189 static int sctp_setsockopt_auth_key ( struct sock * sk , char __user * optval , int optlen ) { struct sctp_authkey * authkey ; struct sctp_association * asoc ; int ret ; if ( ! sctp_auth_enable ) return - EACCES ; if ( optlen <= sizeof ( struct sctp_authkey ) ) return - EINVAL ; authkey = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! authkey ) return - ENOMEM ; if ( copy_from_user ( authkey , optval , optlen ) ) { ret = - EFAULT ; goto out ; } <S2SV_StartBug> if ( authkey -> sca_keylength > optlen ) { <S2SV_EndBug> ret = - EINVAL ; goto out ; } asoc = sctp_id2assoc ( sk , authkey -> sca_assoc_id ) ; if ( ! asoc && authkey -> sca_assoc_id && sctp_style ( sk , UDP ) ) { ret = - EINVAL ; goto out ; } ret = sctp_auth_set_key ( sctp_sk ( sk ) -> ep , asoc , authkey ) ; out : kfree ( authkey ) ; return ret ; }", "target": "<S2SV_ModStart> sca_keylength > optlen - sizeof ( struct sctp_authkey )"}
{"source": "CWE-20 <S2SV_StartBug> static sctp_disposition_t sctp_sf_violation_paramlen ( <S2SV_EndBug> const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { <S2SV_StartBug> static const char err_str [ ] = \"The<S2SV_blank>following<S2SV_blank>parameter<S2SV_blank>had<S2SV_blank>invalid<S2SV_blank>length:\" ; <S2SV_EndBug> return sctp_sf_abort_violation ( ep , asoc , arg , commands , err_str , sizeof ( err_str ) ) ; }", "target": "<S2SV_ModStart> <S2SV_null> static sctp_disposition_t sctp_sf_violation_chunklen <S2SV_ModEnd> ( const struct <S2SV_ModStart> [ ] = \"The<S2SV_blank>following<S2SV_blank>chunk<S2SV_blank>had<S2SV_blank>invalid<S2SV_blank>length:\" <S2SV_ModEnd> ; return sctp_sf_abort_violation"}
{"source": "CWE-119 int hfsplus_find_cat ( struct super_block * sb , u32 cnid , struct hfs_find_data * fd ) { hfsplus_cat_entry tmp ; int err ; u16 type ; hfsplus_cat_build_key ( sb , fd -> search_key , cnid , NULL ) ; err = hfs_brec_read ( fd , & tmp , sizeof ( hfsplus_cat_entry ) ) ; if ( err ) return err ; type = be16_to_cpu ( tmp . type ) ; if ( type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD ) { printk ( KERN_ERR \"hfs:<S2SV_blank>found<S2SV_blank>bad<S2SV_blank>thread<S2SV_blank>record<S2SV_blank>in<S2SV_blank>catalog\\\\n\" ) ; return - EIO ; } <S2SV_StartBug> hfsplus_cat_build_key_uni ( fd -> search_key , be32_to_cpu ( tmp . thread . parentID ) , <S2SV_EndBug> & tmp . thread . nodeName ) ; return hfs_brec_find ( fd ) ; }", "target": "<S2SV_ModStart> EIO ; } if ( be16_to_cpu ( tmp . thread . nodeName . length ) > 255 ) { printk ( KERN_ERR \"hfs:<S2SV_blank>catalog<S2SV_blank>name<S2SV_blank>length<S2SV_blank>corrupted\\\\n\" ) ; return - EIO ; }"}
{"source": "CWE-20 int hfsplus_block_allocate ( struct super_block * sb , u32 size , u32 offset , u32 * max ) { struct page * page ; struct address_space * mapping ; __be32 * pptr , * curr , * end ; u32 mask , start , len , n ; __be32 val ; int i ; len = * max ; if ( ! len ) return size ; dprint ( DBG_BITMAP , \"block_allocate:<S2SV_blank>%u,%u,%u\\\\n\" , size , offset , len ) ; mutex_lock ( & HFSPLUS_SB ( sb ) . alloc_file -> i_mutex ) ; mapping = HFSPLUS_SB ( sb ) . alloc_file -> i_mapping ; page = read_mapping_page ( mapping , offset / PAGE_CACHE_BITS , NULL ) ; <S2SV_StartBug> pptr = kmap ( page ) ; <S2SV_EndBug> curr = pptr + ( offset & ( PAGE_CACHE_BITS - 1 ) ) / 32 ; i = offset % 32 ; offset &= ~ ( PAGE_CACHE_BITS - 1 ) ; if ( ( size ^ offset ) / PAGE_CACHE_BITS ) end = pptr + PAGE_CACHE_BITS / 32 ; else end = pptr + ( ( size + 31 ) & ( PAGE_CACHE_BITS - 1 ) ) / 32 ; val = * curr ; if ( ~ val ) { n = be32_to_cpu ( val ) ; mask = ( 1U << 31 ) >> i ; for ( ; i < 32 ; mask >>= 1 , i ++ ) { if ( ! ( n & mask ) ) goto found ; } } curr ++ ; while ( 1 ) { while ( curr < end ) { val = * curr ; if ( ~ val ) { n = be32_to_cpu ( val ) ; mask = 1 << 31 ; for ( i = 0 ; i < 32 ; mask >>= 1 , i ++ ) { if ( ! ( n & mask ) ) goto found ; } } curr ++ ; } kunmap ( page ) ; offset += PAGE_CACHE_BITS ; if ( offset >= size ) break ; page = read_mapping_page ( mapping , offset / PAGE_CACHE_BITS , NULL ) ; <S2SV_StartBug> curr = pptr = kmap ( page ) ; <S2SV_EndBug> if ( ( size ^ offset ) / PAGE_CACHE_BITS ) end = pptr + PAGE_CACHE_BITS / 32 ; else end = pptr + ( ( size + 31 ) & ( PAGE_CACHE_BITS - 1 ) ) / 32 ; } dprint ( DBG_BITMAP , \"bitmap<S2SV_blank>full\\\\n\" ) ; start = size ; goto out ; found : start = offset + ( curr - pptr ) * 32 + i ; if ( start >= size ) { dprint ( DBG_BITMAP , \"bitmap<S2SV_blank>full\\\\n\" ) ; goto out ; } len = min ( size - start , len ) ; while ( 1 ) { n |= mask ; if ( ++ i >= 32 ) break ; mask >>= 1 ; if ( ! -- len || n & mask ) goto done ; } if ( ! -- len ) goto done ; * curr ++ = cpu_to_be32 ( n ) ; while ( 1 ) { while ( curr < end ) { n = be32_to_cpu ( * curr ) ; if ( len < 32 ) goto last ; if ( n ) { len = 32 ; goto last ; } * curr ++ = cpu_to_be32 ( 0xffffffff ) ; len -= 32 ; } set_page_dirty ( page ) ; kunmap ( page ) ; offset += PAGE_CACHE_BITS ; page = read_mapping_page ( mapping , offset / PAGE_CACHE_BITS , <S2SV_StartBug> NULL ) ; <S2SV_EndBug> pptr = kmap ( page ) ; curr = pptr ; end = pptr + PAGE_CACHE_BITS / 32 ; } last : mask = 1U << 31 ; for ( i = 0 ; i < len ; i ++ ) { if ( n & mask ) break ; n |= mask ; mask >>= 1 ; } done : * curr = cpu_to_be32 ( n ) ; set_page_dirty ( page ) ; kunmap ( page ) ; * max = offset + ( curr - pptr ) * 32 + i - start ; HFSPLUS_SB ( sb ) . free_blocks -= * max ; sb -> s_dirt = 1 ; dprint ( DBG_BITMAP , \"-><S2SV_blank>%u,%u\\\\n\" , start , * max ) ; out : mutex_unlock ( & HFSPLUS_SB ( sb ) . alloc_file -> i_mutex ) ; return start ; }", "target": "<S2SV_ModStart> NULL ) ; if ( IS_ERR ( page ) ) { start = size ; goto out ; } <S2SV_ModStart> NULL ) ; if ( IS_ERR ( page ) ) { start = size ; goto out ; } <S2SV_ModStart> NULL ) ; if ( IS_ERR ( page ) ) { start = size ; goto out ; }"}
{"source": "CWE-189 int unlzw ( in , out ) int in , out ; { REG2 char_type * stackp ; REG3 code_int code ; REG4 int finchar ; REG5 code_int oldcode ; REG6 code_int incode ; REG7 long inbits ; REG8 long posbits ; REG9 int outpos ; REG11 unsigned bitmask ; REG12 code_int free_ent ; REG13 code_int maxcode ; REG14 code_int maxmaxcode ; REG15 int n_bits ; REG16 int rsize ; # ifdef MAXSEG_64K tab_prefix [ 0 ] = tab_prefix0 ; tab_prefix [ 1 ] = tab_prefix1 ; # endif maxbits = get_byte ( ) ; block_mode = maxbits & BLOCK_MODE ; if ( ( maxbits & LZW_RESERVED ) != 0 ) { WARN ( ( stderr , \"\\\\n%s:<S2SV_blank>%s:<S2SV_blank>warning,<S2SV_blank>unknown<S2SV_blank>flags<S2SV_blank>0x%x\\\\n\" , program_name , ifname , maxbits & LZW_RESERVED ) ) ; } maxbits &= BIT_MASK ; maxmaxcode = MAXCODE ( maxbits ) ; if ( maxbits > BITS ) { fprintf ( stderr , \"\\\\n%s:<S2SV_blank>%s:<S2SV_blank>compressed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>bits,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>%d<S2SV_blank>bits\\\\n\" , program_name , ifname , maxbits , BITS ) ; exit_code = ERROR ; return ERROR ; } rsize = insize ; maxcode = MAXCODE ( n_bits = INIT_BITS ) - 1 ; bitmask = ( 1 << n_bits ) - 1 ; oldcode = - 1 ; finchar = 0 ; outpos = 0 ; posbits = inptr << 3 ; free_ent = ( ( block_mode ) ? FIRST : 256 ) ; clear_tab_prefixof ( ) ; for ( code = 255 ; code >= 0 ; -- code ) { tab_suffixof ( code ) = ( char_type ) code ; } do { REG1 int i ; int e ; int o ; resetbuf : <S2SV_StartBug> e = insize - ( o = ( posbits >> 3 ) ) ; <S2SV_EndBug> for ( i = 0 ; i < e ; ++ i ) { inbuf [ i ] = inbuf [ i + o ] ; } insize = e ; posbits = 0 ; if ( insize < INBUF_EXTRA ) { rsize = read_buffer ( in , ( char * ) inbuf + insize , INBUFSIZ ) ; if ( rsize == - 1 ) { read_error ( ) ; } insize += rsize ; bytes_in += ( off_t ) rsize ; } inbits = ( ( rsize != 0 ) ? ( ( long ) insize - insize % n_bits ) << 3 : ( ( long ) insize << 3 ) - ( n_bits - 1 ) ) ; while ( inbits > posbits ) { if ( free_ent > maxcode ) { posbits = ( ( posbits - 1 ) + ( ( n_bits << 3 ) - ( posbits - 1 + ( n_bits << 3 ) ) % ( n_bits << 3 ) ) ) ; ++ n_bits ; if ( n_bits == maxbits ) { maxcode = maxmaxcode ; } else { maxcode = MAXCODE ( n_bits ) - 1 ; } bitmask = ( 1 << n_bits ) - 1 ; goto resetbuf ; } input ( inbuf , posbits , code , n_bits , bitmask ) ; Tracev ( ( stderr , \"%d<S2SV_blank>\" , code ) ) ; if ( oldcode == - 1 ) { if ( 256 <= code ) gzip_error ( \"corrupt<S2SV_blank>input.\" ) ; outbuf [ outpos ++ ] = ( char_type ) ( finchar = ( int ) ( oldcode = code ) ) ; continue ; } if ( code == CLEAR && block_mode ) { clear_tab_prefixof ( ) ; free_ent = FIRST - 1 ; posbits = ( ( posbits - 1 ) + ( ( n_bits << 3 ) - ( posbits - 1 + ( n_bits << 3 ) ) % ( n_bits << 3 ) ) ) ; maxcode = MAXCODE ( n_bits = INIT_BITS ) - 1 ; bitmask = ( 1 << n_bits ) - 1 ; goto resetbuf ; } incode = code ; stackp = de_stack ; if ( code >= free_ent ) { if ( code > free_ent ) { # ifdef DEBUG char_type * p ; posbits -= n_bits ; p = & inbuf [ posbits >> 3 ] ; fprintf ( stderr , \"code:%ld<S2SV_blank>free_ent:%ld<S2SV_blank>n_bits:%d<S2SV_blank>insize:%u\\\\n\" , code , free_ent , n_bits , insize ) ; fprintf ( stderr , \"posbits:%ld<S2SV_blank>inbuf:%02X<S2SV_blank>%02X<S2SV_blank>%02X<S2SV_blank>%02X<S2SV_blank>%02X\\\\n\" , posbits , p [ - 1 ] , p [ 0 ] , p [ 1 ] , p [ 2 ] , p [ 3 ] ) ; # endif if ( ! test && outpos > 0 ) { write_buf ( out , ( char * ) outbuf , outpos ) ; bytes_out += ( off_t ) outpos ; } gzip_error ( to_stdout ? \"corrupt<S2SV_blank>input.\" : \"corrupt<S2SV_blank>input.<S2SV_blank>Use<S2SV_blank>zcat<S2SV_blank>to<S2SV_blank>recover<S2SV_blank>some<S2SV_blank>data.\" ) ; } * -- stackp = ( char_type ) finchar ; code = oldcode ; } while ( ( cmp_code_int ) code >= ( cmp_code_int ) 256 ) { * -- stackp = tab_suffixof ( code ) ; code = tab_prefixof ( code ) ; } * -- stackp = ( char_type ) ( finchar = tab_suffixof ( code ) ) ; { REG1 int i ; if ( outpos + ( i = ( de_stack - stackp ) ) >= OUTBUFSIZ ) { do { if ( i > OUTBUFSIZ - outpos ) i = OUTBUFSIZ - outpos ; if ( i > 0 ) { memcpy ( outbuf + outpos , stackp , i ) ; outpos += i ; } if ( outpos >= OUTBUFSIZ ) { if ( ! test ) { write_buf ( out , ( char * ) outbuf , outpos ) ; bytes_out += ( off_t ) outpos ; } outpos = 0 ; } stackp += i ; } while ( ( i = ( de_stack - stackp ) ) > 0 ) ; } else { memcpy ( outbuf + outpos , stackp , i ) ; outpos += i ; } } if ( ( code = free_ent ) < maxmaxcode ) { tab_prefixof ( code ) = ( unsigned short ) oldcode ; tab_suffixof ( code ) = ( char_type ) finchar ; free_ent = code + 1 ; } oldcode = incode ; } } while ( rsize != 0 ) ; if ( ! test && outpos > 0 ) { write_buf ( out , ( char * ) outbuf , outpos ) ; bytes_out += ( off_t ) outpos ; } return OK ; }", "target": "<S2SV_ModStart> ; resetbuf : o = <S2SV_ModEnd> posbits >> 3 <S2SV_ModStart> posbits >> 3 ; e = o <= insize ? insize - o : 0 <S2SV_ModEnd> ; for ("}
{"source": "CWE-119 bmexec_trans ( kwset_t kwset , char const * text , size_t size ) { unsigned char const * d1 ; char const * ep , * sp , * tp ; int d ; int len = kwset -> mind ; char const * trans = kwset -> trans ; if ( len == 0 ) return 0 ; if ( len > size ) return - 1 ; if ( len == 1 ) { tp = memchr_kwset ( text , size , kwset ) ; return tp ? tp - text : - 1 ; } d1 = kwset -> delta ; sp = kwset -> target + len ; tp = text + len ; char gc1 = kwset -> gc1 ; char gc2 = kwset -> gc2 ; if ( size > 12 * len ) for ( ep = text + size - 11 * len ; tp <= ep ; ) { char const * tp0 = tp ; d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; if ( d != 0 ) { d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; if ( d != 0 ) { d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; if ( d != 0 ) { d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; d = d1 [ U ( tp [ - 1 ] ) ] , tp += d ; int advance_heuristic = 16 * sizeof ( long ) ; if ( advance_heuristic <= tp - tp0 ) goto big_advance ; tp -- ; tp = memchr_kwset ( tp , text + size - tp , kwset ) ; if ( ! tp ) return - 1 ; tp ++ ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( bm_delta2_search ( & tp , ep , sp , len , trans , gc1 , gc2 , d1 , kwset ) ) return tp - text ; big_advance : ; } ep = text + size ; d = d1 [ U ( tp [ - 1 ] ) ] ; while ( d <= ep - tp ) { d = d1 [ U ( ( tp += d ) [ - 1 ] ) ] ; if ( d != 0 ) continue ; if ( bm_delta2_search ( & tp , ep , sp , len , trans , gc1 , gc2 , NULL , kwset ) ) return tp - text ; } return - 1 ; }", "target": "<S2SV_ModStart> tp ++ ; if ( ep <= tp ) break ;"}
{"source": "CWE-310 ecc_256_modp ( const struct ecc_modulo * p , mp_limb_t * rp ) { mp_limb_t u1 , u0 ; mp_size_t n ; n = 2 * p -> size ; u1 = rp [ -- n ] ; u0 = rp [ n - 1 ] ; for ( ; n >= p -> size ; n -- ) { mp_limb_t q2 , q1 , q0 , t , cy ; q1 = u1 - ( u1 > u0 ) ; q0 = u0 - u1 ; t = u1 << 32 ; q0 += t ; t = ( u1 >> 32 ) + ( q0 < t ) + 1 ; q1 += t ; q2 = q1 < t ; u1 = u0 + ( q1 << 32 ) - q1 ; t = - ( mp_limb_t ) ( u1 > q0 ) ; u1 -= t & 0xffffffff ; q1 += t ; q2 += t + ( q1 < t ) ; assert ( q2 < 2 ) ; t = mpn_submul_1 ( rp + n - 4 , p -> m , 2 , q1 ) ; t += cnd_sub_n ( q2 , rp + n - 3 , p -> m , 1 ) ; t += ( - q2 ) & 0xffffffff ; u0 = rp [ n - 2 ] ; cy = ( u0 < t ) ; u0 -= t ; t = ( u1 < cy ) ; u1 -= cy ; <S2SV_StartBug> u1 += cnd_add_n ( t , rp + n - 4 , p -> m , 3 ) ; <S2SV_EndBug> u1 -= ( - t ) & 0xffffffff ; } rp [ 2 ] = u0 ; rp [ 3 ] = u1 ; }", "target": "<S2SV_ModStart> -= cy ; cy = <S2SV_ModEnd> cnd_add_n ( t <S2SV_ModStart> -> m , 2 ) ; u0 += cy ; u1 += ( u0 < cy <S2SV_ModEnd> ) ; u1"}
{"source": "CWE-476 pax_decode_header ( struct tar_sparse_file * file ) { if ( file -> stat_info -> sparse_major > 0 ) { uintmax_t u ; char nbuf [ UINTMAX_STRSIZE_BOUND ] ; union block * blk ; char * p ; size_t i ; off_t start ; <S2SV_StartBug> # define COPY_BUF ( b , buf , src ) do { char * endp = b -> buffer + BLOCKSIZE ; char * dst = buf ; do { if ( dst == buf + UINTMAX_STRSIZE_BOUND - 1 ) { ERROR ( ( 0 , 0 , _ ( \"%s:<S2SV_blank>numeric<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>sparse<S2SV_blank>archive<S2SV_blank>member\" ) , file -> stat_info -> orig_file_name ) ) ; return false ; } if ( src == endp ) { set_next_block_after ( b ) ; b = find_next_block ( ) ; src = b -> buffer ; endp = b -> buffer + BLOCKSIZE ; } * dst = * src ++ ; } while ( * dst ++ != '\\\\n' ) ; dst [ - 1 ] = 0 ; } while ( 0 ) <S2SV_EndBug> start = current_block_ordinal ( ) ; set_next_block_after ( current_header ) ; blk = find_next_block ( ) ; <S2SV_StartBug> p = blk -> buffer ; <S2SV_EndBug> COPY_BUF ( blk , nbuf , p ) ; if ( ! decode_num ( & u , nbuf , TYPE_MAXIMUM ( size_t ) ) ) { ERROR ( ( 0 , 0 , _ ( \"%s:<S2SV_blank>malformed<S2SV_blank>sparse<S2SV_blank>archive<S2SV_blank>member\" ) , file -> stat_info -> orig_file_name ) ) ; return false ; } file -> stat_info -> sparse_map_size = u ; file -> stat_info -> sparse_map = xcalloc ( file -> stat_info -> sparse_map_size , sizeof ( * file -> stat_info -> sparse_map ) ) ; file -> stat_info -> sparse_map_avail = 0 ; for ( i = 0 ; i < file -> stat_info -> sparse_map_size ; i ++ ) { struct sp_array sp ; COPY_BUF ( blk , nbuf , p ) ; if ( ! decode_num ( & u , nbuf , TYPE_MAXIMUM ( off_t ) ) ) { ERROR ( ( 0 , 0 , _ ( \"%s:<S2SV_blank>malformed<S2SV_blank>sparse<S2SV_blank>archive<S2SV_blank>member\" ) , file -> stat_info -> orig_file_name ) ) ; return false ; } sp . offset = u ; COPY_BUF ( blk , nbuf , p ) ; if ( ! decode_num ( & u , nbuf , TYPE_MAXIMUM ( off_t ) ) ) { ERROR ( ( 0 , 0 , _ ( \"%s:<S2SV_blank>malformed<S2SV_blank>sparse<S2SV_blank>archive<S2SV_blank>member\" ) , file -> stat_info -> orig_file_name ) ) ; return false ; } sp . numbytes = u ; sparse_add_map ( file -> stat_info , & sp ) ; } set_next_block_after ( blk ) ; file -> dumped_size += BLOCKSIZE * ( current_block_ordinal ( ) - start ) ; } return true ; }", "target": "<S2SV_ModStart> ( ) ; if ( ! b ) FATAL_ERROR ( ( 0 , 0 , _ ( \"Unexpected<S2SV_blank>EOF<S2SV_blank>in<S2SV_blank>archive\" ) ) ) ; <S2SV_ModStart> ( ) ; if ( ! blk ) FATAL_ERROR ( ( 0 , 0 , _ ( \"Unexpected<S2SV_blank>EOF<S2SV_blank>in<S2SV_blank>archive\" ) ) ) ;"}
{"source": "CWE-20 kssl_keytab_is_available ( KSSL_CTX * kssl_ctx ) { krb5_context krb5context = NULL ; krb5_keytab krb5keytab = NULL ; krb5_keytab_entry entry ; krb5_principal princ = NULL ; krb5_error_code krb5rc = KRB5KRB_ERR_GENERIC ; int rc = 0 ; if ( ( krb5rc = krb5_init_context ( & krb5context ) ) ) return ( 0 ) ; if ( kssl_ctx -> keytab_file ) { krb5rc = krb5_kt_resolve ( krb5context , kssl_ctx -> keytab_file , & krb5keytab ) ; if ( krb5rc ) goto exit ; } else { krb5rc = krb5_kt_default ( krb5context , & krb5keytab ) ; if ( krb5rc ) goto exit ; } krb5rc = krb5_sname_to_principal ( krb5context , NULL , kssl_ctx -> service_name ? kssl_ctx -> service_name : KRB5SVC , KRB5_NT_SRV_HST , & princ ) ; <S2SV_StartBug> krb5rc = krb5_kt_get_entry ( krb5context , krb5keytab , <S2SV_EndBug> princ , 0 , 0 , & entry ) ; if ( krb5rc == KRB5_KT_NOTFOUND ) { rc = 1 ; goto exit ; } else if ( krb5rc ) goto exit ; krb5_kt_free_entry ( krb5context , & entry ) ; rc = 1 ; exit : if ( krb5keytab ) krb5_kt_close ( krb5context , krb5keytab ) ; if ( princ ) krb5_free_principal ( krb5context , princ ) ; if ( krb5context ) krb5_free_context ( krb5context ) ; return ( rc ) ; }", "target": "<S2SV_ModStart> princ ) ; if ( krb5rc ) goto exit ;"}
{"source": "CWE-399 int sftp_mkdir ( sftp_session sftp , const char * directory , mode_t mode ) { sftp_status_message status = NULL ; sftp_message msg = NULL ; sftp_attributes errno_attr = NULL ; struct sftp_attributes_struct attr ; ssh_buffer buffer ; ssh_string path ; uint32_t id ; buffer = ssh_buffer_new ( ) ; if ( buffer == NULL ) { ssh_set_error_oom ( sftp -> session ) ; return - 1 ; } path = ssh_string_from_char ( directory ) ; if ( path == NULL ) { ssh_set_error_oom ( sftp -> session ) ; ssh_buffer_free ( buffer ) ; return - 1 ; } ZERO_STRUCT ( attr ) ; attr . permissions = mode ; attr . flags = SSH_FILEXFER_ATTR_PERMISSIONS ; id = sftp_get_new_id ( sftp ) ; if ( buffer_add_u32 ( buffer , id ) < 0 || buffer_add_ssh_string ( buffer , path ) < 0 || buffer_add_attributes ( buffer , & attr ) < 0 || sftp_packet_write ( sftp , SSH_FXP_MKDIR , buffer ) < 0 ) { ssh_buffer_free ( buffer ) ; ssh_string_free ( path ) ; <S2SV_StartBug> } <S2SV_EndBug> ssh_buffer_free ( buffer ) ; ssh_string_free ( path ) ; while ( msg == NULL ) { if ( sftp_read_and_dispatch ( sftp ) < 0 ) { return - 1 ; } msg = sftp_dequeue ( sftp , id ) ; } if ( msg -> packet_type == SSH_FXP_STATUS ) { status = parse_status_msg ( msg ) ; sftp_message_free ( msg ) ; if ( status == NULL ) { return - 1 ; } sftp_set_error ( sftp , status -> status ) ; switch ( status -> status ) { case SSH_FX_FAILURE : errno_attr = sftp_lstat ( sftp , directory ) ; if ( errno_attr != NULL ) { SAFE_FREE ( errno_attr ) ; sftp_set_error ( sftp , SSH_FX_FILE_ALREADY_EXISTS ) ; } break ; case SSH_FX_OK : status_msg_free ( status ) ; return 0 ; break ; default : break ; } ssh_set_error ( sftp -> session , SSH_REQUEST_DENIED , \"SFTP<S2SV_blank>server:<S2SV_blank>%s\" , status -> errormsg ) ; status_msg_free ( status ) ; return - 1 ; } else { ssh_set_error ( sftp -> session , SSH_FATAL , \"Received<S2SV_blank>message<S2SV_blank>%d<S2SV_blank>when<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>make<S2SV_blank>directory\" , msg -> packet_type ) ; sftp_message_free ( msg ) ; } return - 1 ; }", "target": "<S2SV_ModStart> path ) ; return - 1 ;"}
{"source": "CWE-362 int ssl3_get_new_session_ticket ( SSL * s ) { int ok , al , ret = 0 , ticklen ; long n ; const unsigned char * p ; unsigned char * d ; n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_SESSION_TICKET_A , SSL3_ST_CR_SESSION_TICKET_B , SSL3_MT_NEWSESSION_TICKET , 16384 , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( n < 6 ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } p = d = ( unsigned char * ) s -> init_msg ; <S2SV_StartBug> n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ; <S2SV_EndBug> n2s ( p , ticklen ) ; if ( ticklen + 6 != n ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } if ( s -> session -> tlsext_tick ) { OPENSSL_free ( s -> session -> tlsext_tick ) ; s -> session -> tlsext_ticklen = 0 ; } s -> session -> tlsext_tick = OPENSSL_malloc ( ticklen ) ; if ( ! s -> session -> tlsext_tick ) { SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto err ; } memcpy ( s -> session -> tlsext_tick , p , ticklen ) ; s -> session -> tlsext_ticklen = ticklen ; EVP_Digest ( p , ticklen , s -> session -> session_id , & s -> session -> session_id_length , # ifndef OPENSSL_NO_SHA256 EVP_sha256 ( ) , NULL ) ; # else EVP_sha1 ( ) , NULL ) ; # endif ret = 1 ; return ( ret ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : s -> state = SSL_ST_ERR ; return ( - 1 ) ; }", "target": "<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }"}
{"source": "CWE-275 SCM_DEFINE ( scm_mkdir , \"mkdir\" , 1 , 1 , 0 , ( SCM path , SCM mode ) , \"Create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>directory<S2SV_blank>named<S2SV_blank>by<S2SV_blank>@var{path}.<S2SV_blank><S2SV_blank>If<S2SV_blank>@var{mode}<S2SV_blank>is<S2SV_blank>omitted\\\\n\" <S2SV_StartBug> \"then<S2SV_blank>the<S2SV_blank>permissions<S2SV_blank>of<S2SV_blank>the<S2SV_blank>directory<S2SV_blank>file<S2SV_blank>are<S2SV_blank>set<S2SV_blank>using<S2SV_blank>the<S2SV_blank>current\\\\n\" <S2SV_EndBug> \"umask.<S2SV_blank><S2SV_blank>Otherwise<S2SV_blank>they<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>the<S2SV_blank>decimal<S2SV_blank>value<S2SV_blank>specified<S2SV_blank>with\\\\n\" \"@var{mode}.<S2SV_blank><S2SV_blank>The<S2SV_blank>return<S2SV_blank>value<S2SV_blank>is<S2SV_blank>unspecified.\" ) # define FUNC_NAME s_scm_mkdir { int rv ; <S2SV_StartBug> mode_t mask ; <S2SV_EndBug> <S2SV_StartBug> if ( SCM_UNBNDP ( mode ) ) <S2SV_EndBug> { mask = umask ( 0 ) ; umask ( mask ) ; <S2SV_StartBug> STRING_SYSCALL ( path , c_path , rv = mkdir ( c_path , 0777 ^ mask ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> else { STRING_SYSCALL ( path , c_path , rv = mkdir ( c_path , scm_to_uint ( mode ) ) ) ; } if ( rv != 0 ) SCM_SYSERROR ; return SCM_UNSPECIFIED ; }", "target": "<S2SV_ModStart> ) , \"Create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>directory<S2SV_blank>named<S2SV_blank>by<S2SV_blank>@var{path}.<S2SV_blank><S2SV_blank>If<S2SV_blank>@var{mode}<S2SV_blank>is<S2SV_blank>omitted\\\\n\" \"then<S2SV_blank>the<S2SV_blank>permissions<S2SV_blank>of<S2SV_blank>the<S2SV_blank>directory<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>@code{#o777}\\\\n\" \"masked<S2SV_blank>with<S2SV_blank>the<S2SV_blank>current<S2SV_blank>umask<S2SV_blank>(@pxref{Processes,<S2SV_blank>@code{umask}}).\\\\n\" \"Otherwise<S2SV_blank>they<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>the<S2SV_blank>value<S2SV_blank>specified<S2SV_blank>with<S2SV_blank>@var{mode}.\\\\n\" \"The<S2SV_blank>return<S2SV_blank>value<S2SV_blank>is<S2SV_blank>unspecified.\" <S2SV_ModEnd> ) # define <S2SV_ModStart> rv ; mode_t c_mode ; c_mode = <S2SV_ModEnd> SCM_UNBNDP ( mode <S2SV_ModStart> ( mode ) ? 0777 : scm_to_uint ( mode ) ; <S2SV_ModEnd> STRING_SYSCALL ( path <S2SV_ModStart> ( c_path , c_mode <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( rv"}
{"source": "CWE-20 auth_request_get_var_expand_table_full ( const struct auth_request * auth_request , auth_request_escape_func_t * escape_func , unsigned int * count ) { const unsigned int auth_count = N_ELEMENTS ( auth_request_var_expand_static_tab ) ; struct var_expand_table * tab , * ret_tab ; <S2SV_StartBug> const char * orig_user , * auth_user ; <S2SV_EndBug> if ( escape_func == NULL ) escape_func = escape_none ; tab = ret_tab = t_malloc ( ( * count + auth_count ) * sizeof ( * tab ) ) ; memset ( tab , 0 , * count * sizeof ( * tab ) ) ; tab += * count ; * count += auth_count ; memcpy ( tab , auth_request_var_expand_static_tab , auth_count * sizeof ( * tab ) ) ; <S2SV_StartBug> tab [ 0 ] . value = escape_func ( auth_request -> user , auth_request ) ; <S2SV_EndBug> <S2SV_StartBug> tab [ 1 ] . value = escape_func ( t_strcut ( auth_request -> user , '@' ) , <S2SV_EndBug> auth_request ) ; <S2SV_StartBug> tab [ 2 ] . value = strchr ( auth_request -> user , '@' ) ; <S2SV_EndBug> if ( tab [ 2 ] . value != NULL ) tab [ 2 ] . value = escape_func ( tab [ 2 ] . value + 1 , auth_request ) ; tab [ 3 ] . value = escape_func ( auth_request -> service , auth_request ) ; if ( auth_request -> local_ip . family != 0 ) tab [ 5 ] . value = net_ip2addr ( & auth_request -> local_ip ) ; if ( auth_request -> remote_ip . family != 0 ) tab [ 6 ] . value = net_ip2addr ( & auth_request -> remote_ip ) ; tab [ 7 ] . value = dec2str ( auth_request -> client_pid ) ; if ( auth_request -> mech_password != NULL ) { tab [ 8 ] . value = escape_func ( auth_request -> mech_password , auth_request ) ; } if ( auth_request -> userdb_lookup ) { tab [ 9 ] . value = auth_request -> userdb == NULL ? \"\" : dec2str ( auth_request -> userdb -> userdb -> id ) ; } else { tab [ 9 ] . value = auth_request -> passdb == NULL ? \"\" : dec2str ( auth_request -> passdb -> passdb -> id ) ; } tab [ 10 ] . value = auth_request -> mech_name == NULL ? \"\" : escape_func ( auth_request -> mech_name , auth_request ) ; tab [ 11 ] . value = auth_request -> secured ? \"secured\" : \"\" ; tab [ 12 ] . value = dec2str ( auth_request -> local_port ) ; tab [ 13 ] . value = dec2str ( auth_request -> remote_port ) ; tab [ 14 ] . value = auth_request -> valid_client_cert ? \"valid\" : \"\" ; if ( auth_request -> requested_login_user != NULL ) { const char * login_user = auth_request -> requested_login_user ; tab [ 15 ] . value = escape_func ( login_user , auth_request ) ; tab [ 16 ] . value = escape_func ( t_strcut ( login_user , '@' ) , auth_request ) ; tab [ 17 ] . value = strchr ( login_user , '@' ) ; if ( tab [ 17 ] . value != NULL ) { tab [ 17 ] . value = escape_func ( tab [ 17 ] . value + 1 , auth_request ) ; } } tab [ 18 ] . value = auth_request -> session_id == NULL ? NULL : escape_func ( auth_request -> session_id , auth_request ) ; if ( auth_request -> real_local_ip . family != 0 ) tab [ 19 ] . value = net_ip2addr ( & auth_request -> real_local_ip ) ; if ( auth_request -> real_remote_ip . family != 0 ) tab [ 20 ] . value = net_ip2addr ( & auth_request -> real_remote_ip ) ; tab [ 21 ] . value = dec2str ( auth_request -> real_local_port ) ; tab [ 22 ] . value = dec2str ( auth_request -> real_remote_port ) ; <S2SV_StartBug> tab [ 23 ] . value = strchr ( auth_request -> user , '@' ) ; <S2SV_EndBug> if ( tab [ 23 ] . value != NULL ) { tab [ 23 ] . value = escape_func ( t_strcut ( tab [ 23 ] . value + 1 , '@' ) , auth_request ) ; } <S2SV_StartBug> tab [ 24 ] . value = strrchr ( auth_request -> user , '@' ) ; <S2SV_EndBug> if ( tab [ 24 ] . value != NULL ) tab [ 24 ] . value = escape_func ( tab [ 24 ] . value + 1 , auth_request ) ; tab [ 25 ] . value = auth_request -> master_user == NULL ? NULL : escape_func ( auth_request -> master_user , auth_request ) ; tab [ 26 ] . value = auth_request -> session_pid == ( pid_t ) - 1 ? NULL : dec2str ( auth_request -> session_pid ) ; orig_user = auth_request -> original_username != NULL ? <S2SV_StartBug> auth_request -> original_username : auth_request -> user ; <S2SV_EndBug> tab [ 27 ] . value = escape_func ( orig_user , auth_request ) ; tab [ 28 ] . value = escape_func ( t_strcut ( orig_user , '@' ) , auth_request ) ; tab [ 29 ] . value = strchr ( orig_user , '@' ) ; if ( tab [ 29 ] . value != NULL ) tab [ 29 ] . value = escape_func ( tab [ 29 ] . value + 1 , auth_request ) ; if ( auth_request -> master_user != NULL ) auth_user = auth_request -> master_user ; else auth_user = orig_user ; tab [ 30 ] . value = escape_func ( auth_user , auth_request ) ; tab [ 31 ] . value = escape_func ( t_strcut ( auth_user , '@' ) , auth_request ) ; tab [ 32 ] . value = strchr ( auth_user , '@' ) ; if ( tab [ 32 ] . value != NULL ) tab [ 32 ] . value = escape_func ( tab [ 32 ] . value + 1 , auth_request ) ; if ( auth_request -> local_name != NULL ) tab [ 33 ] . value = escape_func ( auth_request -> local_name , auth_request ) ; else tab [ 33 ] . value = \"\" ; return ret_tab ; }", "target": "<S2SV_ModStart> , * auth_user , * username <S2SV_ModStart> ) ) ; username = auth_request -> user != NULL ? auth_request -> user : \"\" ; <S2SV_ModStart> = escape_func ( username <S2SV_ModEnd> , auth_request ) <S2SV_ModStart> ( t_strcut ( username <S2SV_ModEnd> , '@' ) <S2SV_ModStart> = strchr ( username <S2SV_ModEnd> , '@' ) <S2SV_ModStart> = strchr ( username <S2SV_ModEnd> , '@' ) <S2SV_ModStart> = strrchr ( username <S2SV_ModEnd> , '@' ) <S2SV_ModStart> -> original_username : username <S2SV_ModEnd> ; tab ["}
{"source": "CWE-770 static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit ( TIFF * tif , TIFFDirEntry * direntry , uint32 * count , uint32 desttypesize , void * * value , uint64 maxcount ) { int typesize ; uint32 datasize ; void * data ; uint64 target_count64 ; typesize = TIFFDataWidth ( direntry -> tdir_type ) ; target_count64 = ( direntry -> tdir_count > maxcount ) ? maxcount : direntry -> tdir_count ; if ( ( target_count64 == 0 ) || ( typesize == 0 ) ) { * value = 0 ; return ( TIFFReadDirEntryErrOk ) ; } ( void ) desttypesize ; if ( ( uint64 ) ( 2147483647 / typesize ) < target_count64 ) return ( TIFFReadDirEntryErrSizesan ) ; if ( ( uint64 ) ( 2147483647 / desttypesize ) < target_count64 ) return ( TIFFReadDirEntryErrSizesan ) ; * count = ( uint32 ) target_count64 ; datasize = ( * count ) * typesize ; assert ( ( tmsize_t ) datasize > 0 ) ; <S2SV_StartBug> data = _TIFFCheckMalloc ( tif , * count , typesize , \"ReadDirEntryArray\" ) ; <S2SV_EndBug> if ( data == 0 ) <S2SV_StartBug> return ( TIFFReadDirEntryErrAlloc ) ; <S2SV_EndBug> if ( ! ( tif -> tif_flags & TIFF_BIGTIFF ) ) { if ( datasize <= 4 ) _TIFFmemcpy ( data , & direntry -> tdir_offset , datasize ) ; else { enum TIFFReadDirEntryErr err ; uint32 offset = direntry -> tdir_offset . toff_long ; if ( tif -> tif_flags & TIFF_SWAB ) TIFFSwabLong ( & offset ) ; <S2SV_StartBug> err = TIFFReadDirEntryData ( tif , ( uint64 ) offset , ( tmsize_t ) datasize , data ) ; <S2SV_EndBug> if ( err != TIFFReadDirEntryErrOk ) { _TIFFfree ( data ) ; return ( err ) ; } } } else { if ( datasize <= 8 ) _TIFFmemcpy ( data , & direntry -> tdir_offset , datasize ) ; else { enum TIFFReadDirEntryErr err ; uint64 offset = direntry -> tdir_offset . toff_long8 ; if ( tif -> tif_flags & TIFF_SWAB ) TIFFSwabLong8 ( & offset ) ; <S2SV_StartBug> err = TIFFReadDirEntryData ( tif , offset , ( tmsize_t ) datasize , data ) ; <S2SV_EndBug> if ( err != TIFFReadDirEntryErrOk ) { _TIFFfree ( data ) ; return ( err ) ; } } } * value = data ; return ( TIFFReadDirEntryErrOk ) ; }", "target": "<S2SV_ModStart> 0 ) ; if ( isMapped ( tif ) && datasize > tif -> tif_size ) return TIFFReadDirEntryErrIo ; if ( ! isMapped ( tif ) && ( ( ( tif -> tif_flags & TIFF_BIGTIFF ) && datasize > 8 ) || ( ! ( tif -> tif_flags & TIFF_BIGTIFF ) && datasize > 4 ) ) ) { data = NULL ; } else { <S2SV_ModStart> TIFFReadDirEntryErrAlloc ) ; } <S2SV_ModStart> offset ) ; if ( isMapped ( tif ) ) <S2SV_ModStart> ) datasize , data ) ; else err = TIFFReadDirEntryDataAndRealloc ( tif , ( uint64 ) offset , ( tmsize_t ) datasize , & <S2SV_ModStart> offset ) ; if ( isMapped ( tif ) ) <S2SV_ModStart> ( tif , ( uint64 ) <S2SV_ModStart> ) datasize , data ) ; else err = TIFFReadDirEntryDataAndRealloc ( tif , ( uint64 ) offset , ( tmsize_t ) datasize , &"}
{"source": "CWE-327 static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) { EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ; switch ( type ) { case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( actx == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ; return 0 ; } actx -> len . aad = 0 ; actx -> len . text = 0 ; actx -> aad = 0 ; actx -> mac_inited = 0 ; actx -> tag_len = 0 ; actx -> nonce_len = 12 ; actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ; memset ( actx -> tls_aad , 0 , POLY1305_BLOCK_SIZE ) ; return 1 ; case EVP_CTRL_COPY : if ( actx ) { EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ; dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( dst -> cipher_data == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ; return 0 ; } } return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : <S2SV_StartBug> if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) <S2SV_EndBug> return 0 ; actx -> nonce_len = arg ; return 1 ; case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ; actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ; actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ; if ( ptr != NULL ) { memcpy ( actx -> tag , ptr , arg ) ; actx -> tag_len = arg ; } return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ; memcpy ( ptr , actx -> tag , arg ) ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; { unsigned int len ; unsigned char * aad = ptr ; memcpy ( actx -> tls_aad , ptr , EVP_AEAD_TLS1_AAD_LEN ) ; len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ; aad = actx -> tls_aad ; if ( ! ctx -> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ; len -= POLY1305_BLOCK_SIZE ; aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ; aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ; } actx -> tls_payload_length = len ; actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ; actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ; actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ; actx -> mac_inited = 0 ; return POLY1305_BLOCK_SIZE ; } case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ; default : return - 1 ; } }", "target": "<S2SV_ModStart> || arg > CHACHA20_POLY1305_MAX_IVLEN <S2SV_ModEnd> ) return 0"}
{"source": "CWE-835 static int smtp_command_parse_parameters ( struct smtp_command_parser * parser ) { const unsigned char * p , * mp ; uoff_t max_size = ( parser -> auth_response ? parser -> limits . max_auth_size : parser -> limits . max_parameters_size ) ; <S2SV_StartBug> <S2SV_EndBug> p = parser -> cur + parser -> state . poff ; while ( p < parser -> end ) { unichar_t ch ; <S2SV_StartBug> int nch = 1 ; <S2SV_EndBug> if ( parser -> auth_response ) ch = * p ; else { nch = uni_utf8_get_char_n ( p , ( size_t ) ( p - parser -> end ) , & ch ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( nch < 0 ) { smtp_command_parser_error ( parser , SMTP_COMMAND_PARSE_ERROR_BAD_COMMAND , \"Invalid<S2SV_blank>UTF-8<S2SV_blank>character<S2SV_blank>in<S2SV_blank>command<S2SV_blank>parameters\" ) ; return - 1 ; } if ( ( parser -> auth_response || ( ch & 0x80 ) == 0x00 ) && ! smtp_char_is_textstr ( ( unsigned char ) ch ) ) break ; p += nch ; } if ( max_size > 0 && ( uoff_t ) ( p - parser -> cur ) > max_size ) { smtp_command_parser_error ( parser , SMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG , \"%s<S2SV_blank>line<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\" , ( parser -> auth_response ? \"AUTH<S2SV_blank>response\" : \"Command\" ) ) ; return - 1 ; } parser -> state . poff = p - parser -> cur ; <S2SV_StartBug> if ( p == parser -> end ) <S2SV_EndBug> return 0 ; mp = p ; if ( mp > parser -> cur ) { while ( mp > parser -> cur && ( * ( mp - 1 ) == '<S2SV_blank>' || * ( mp - 1 ) == '\\\\t' ) ) mp -- ; } if ( ! parser -> auth_response && mp > parser -> cur && * parser -> cur == '<S2SV_blank>' ) { smtp_command_parser_error ( parser , SMTP_COMMAND_PARSE_ERROR_BAD_COMMAND , \"Duplicate<S2SV_blank>space<S2SV_blank>after<S2SV_blank>command<S2SV_blank>name\" ) ; return - 1 ; } parser -> state . cmd_params = i_strdup_until ( parser -> cur , mp ) ; parser -> cur = p ; parser -> state . poff = 0 ; return 1 ; }", "target": "<S2SV_ModStart> max_parameters_size ) ; int nch = 1 ; <S2SV_ModStart> unichar_t ch ; <S2SV_ModEnd> if ( parser <S2SV_ModStart> ) ; } if ( nch == 0 ) break ; <S2SV_ModStart> parser -> end || nch == 0"}
{"source": "CWE-125 rpa_read_buffer ( pool_t pool , const unsigned char * * data , const unsigned char * end , unsigned char * * buffer ) { const unsigned char * p = * data ; unsigned int len ; if ( p > end ) return 0 ; len = * p ++ ; <S2SV_StartBug> if ( p + len > end ) <S2SV_EndBug> return 0 ; * buffer = p_malloc ( pool , len ) ; memcpy ( * buffer , p , len ) ; * data += 1 + len ; return len ; }", "target": "<S2SV_ModStart> len > end || len == 0"}
{"source": "CWE-476 int setup_tests ( void ) { ADD_ALL_TESTS ( call_run_cert , OSSL_NELEM ( name_fns ) ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }", "target": "<S2SV_ModStart> ) ) ; ADD_TEST ( test_GENERAL_NAME_cmp ) ;"}
{"source": "CWE-125 EC_GROUP * EC_GROUP_new_from_ecparameters ( const ECPARAMETERS * params ) { int ok = 0 , tmp ; EC_GROUP * ret = NULL , * dup = NULL ; BIGNUM * p = NULL , * a = NULL , * b = NULL ; EC_POINT * point = NULL ; long field_bits ; int curve_name = NID_undef ; BN_CTX * ctx = NULL ; if ( ! params -> fieldID || ! params -> fieldID -> fieldType || ! params -> fieldID -> p . ptr ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_ASN1_ERROR ) ; goto err ; } if ( ! params -> curve || ! params -> curve -> a || ! params -> curve -> a -> data || ! params -> curve -> b || ! params -> curve -> b -> data ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_ASN1_ERROR ) ; goto err ; } a = BN_bin2bn ( params -> curve -> a -> data , params -> curve -> a -> length , NULL ) ; if ( a == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_BN_LIB ) ; goto err ; } b = BN_bin2bn ( params -> curve -> b -> data , params -> curve -> b -> length , NULL ) ; if ( b == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_BN_LIB ) ; goto err ; } tmp = OBJ_obj2nid ( params -> fieldID -> fieldType ) ; if ( tmp == NID_X9_62_characteristic_two_field ) # ifdef OPENSSL_NO_EC2M { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_GF2M_NOT_SUPPORTED ) ; goto err ; } # else { X9_62_CHARACTERISTIC_TWO * char_two ; char_two = params -> fieldID -> p . char_two ; field_bits = char_two -> m ; if ( field_bits > OPENSSL_ECC_MAX_FIELD_BITS ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_FIELD_TOO_LARGE ) ; goto err ; } if ( ( p = BN_new ( ) ) == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_MALLOC_FAILURE ) ; goto err ; } tmp = OBJ_obj2nid ( char_two -> type ) ; if ( tmp == NID_X9_62_tpBasis ) { long tmp_long ; if ( ! char_two -> p . tpBasis ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_ASN1_ERROR ) ; goto err ; } tmp_long = ASN1_INTEGER_get ( char_two -> p . tpBasis ) ; if ( ! ( char_two -> m > tmp_long && tmp_long > 0 ) ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_INVALID_TRINOMIAL_BASIS ) ; goto err ; } if ( ! BN_set_bit ( p , ( int ) char_two -> m ) ) goto err ; if ( ! BN_set_bit ( p , ( int ) tmp_long ) ) goto err ; if ( ! BN_set_bit ( p , 0 ) ) goto err ; } else if ( tmp == NID_X9_62_ppBasis ) { X9_62_PENTANOMIAL * penta ; penta = char_two -> p . ppBasis ; if ( ! penta ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_ASN1_ERROR ) ; goto err ; } if ( ! ( char_two -> m > penta -> k3 && penta -> k3 > penta -> k2 && penta -> k2 > penta -> k1 && penta -> k1 > 0 ) ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_INVALID_PENTANOMIAL_BASIS ) ; goto err ; } if ( ! BN_set_bit ( p , ( int ) char_two -> m ) ) goto err ; if ( ! BN_set_bit ( p , ( int ) penta -> k1 ) ) goto err ; if ( ! BN_set_bit ( p , ( int ) penta -> k2 ) ) goto err ; if ( ! BN_set_bit ( p , ( int ) penta -> k3 ) ) goto err ; if ( ! BN_set_bit ( p , 0 ) ) goto err ; } else if ( tmp == NID_X9_62_onBasis ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_NOT_IMPLEMENTED ) ; goto err ; } else { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_ASN1_ERROR ) ; goto err ; } ret = EC_GROUP_new_curve_GF2m ( p , a , b , NULL ) ; } # endif else if ( tmp == NID_X9_62_prime_field ) { if ( ! params -> fieldID -> p . prime ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_ASN1_ERROR ) ; goto err ; } p = ASN1_INTEGER_to_BN ( params -> fieldID -> p . prime , NULL ) ; if ( p == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_ASN1_LIB ) ; goto err ; } if ( BN_is_negative ( p ) || BN_is_zero ( p ) ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_INVALID_FIELD ) ; goto err ; } field_bits = BN_num_bits ( p ) ; if ( field_bits > OPENSSL_ECC_MAX_FIELD_BITS ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_FIELD_TOO_LARGE ) ; goto err ; } ret = EC_GROUP_new_curve_GFp ( p , a , b , NULL ) ; } else { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_INVALID_FIELD ) ; goto err ; } if ( ret == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_EC_LIB ) ; goto err ; } if ( params -> curve -> seed != NULL ) { OPENSSL_free ( ret -> seed ) ; if ( ( ret -> seed = OPENSSL_malloc ( params -> curve -> seed -> length ) ) == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_MALLOC_FAILURE ) ; goto err ; } memcpy ( ret -> seed , params -> curve -> seed -> data , params -> curve -> seed -> length ) ; ret -> seed_len = params -> curve -> seed -> length ; } <S2SV_StartBug> if ( ! params -> order || ! params -> base || ! params -> base -> data ) { <S2SV_EndBug> ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_ASN1_ERROR ) ; goto err ; } if ( ( point = EC_POINT_new ( ret ) ) == NULL ) goto err ; EC_GROUP_set_point_conversion_form ( ret , ( point_conversion_form_t ) ( params -> base -> data [ 0 ] & ~ 0x01 ) ) ; if ( ! EC_POINT_oct2point ( ret , point , params -> base -> data , params -> base -> length , NULL ) ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_EC_LIB ) ; goto err ; } if ( ( a = ASN1_INTEGER_to_BN ( params -> order , a ) ) == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_ASN1_LIB ) ; goto err ; } if ( BN_is_negative ( a ) || BN_is_zero ( a ) ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_INVALID_GROUP_ORDER ) ; goto err ; } if ( BN_num_bits ( a ) > ( int ) field_bits + 1 ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , EC_R_INVALID_GROUP_ORDER ) ; goto err ; } if ( params -> cofactor == NULL ) { BN_free ( b ) ; b = NULL ; } else if ( ( b = ASN1_INTEGER_to_BN ( params -> cofactor , b ) ) == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_ASN1_LIB ) ; goto err ; } if ( ! EC_GROUP_set_generator ( ret , point , a , b ) ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_EC_LIB ) ; goto err ; } if ( ( ctx = BN_CTX_new ( ) ) == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_BN_LIB ) ; goto err ; } if ( ( dup = EC_GROUP_dup ( ret ) ) == NULL || EC_GROUP_set_seed ( dup , NULL , 0 ) != 1 || ! EC_GROUP_set_generator ( dup , point , a , NULL ) ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_EC_LIB ) ; goto err ; } if ( ( curve_name = ec_curve_nid_from_params ( dup , ctx ) ) != NID_undef ) { EC_GROUP * named_group = NULL ; # ifndef OPENSSL_NO_EC_NISTP_64_GCC_128 if ( curve_name == NID_wap_wsg_idm_ecid_wtls12 ) curve_name = NID_secp224r1 ; # endif if ( ( named_group = EC_GROUP_new_by_curve_name ( curve_name ) ) == NULL ) { ECerr ( EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS , ERR_R_EC_LIB ) ; goto err ; } EC_GROUP_free ( ret ) ; ret = named_group ; EC_GROUP_set_asn1_flag ( ret , OPENSSL_EC_EXPLICIT_CURVE ) ; if ( params -> curve -> seed == NULL ) { if ( EC_GROUP_set_seed ( ret , NULL , 0 ) != 1 ) goto err ; } } ok = 1 ; err : if ( ! ok ) { EC_GROUP_free ( ret ) ; ret = NULL ; } EC_GROUP_free ( dup ) ; BN_free ( p ) ; BN_free ( a ) ; BN_free ( b ) ; EC_POINT_free ( point ) ; BN_CTX_free ( ctx ) ; return ret ; }", "target": "<S2SV_ModStart> } if ( <S2SV_ModEnd> params -> order <S2SV_ModStart> params -> order == NULL || <S2SV_ModEnd> params -> base <S2SV_ModStart> params -> base == NULL || <S2SV_ModEnd> params -> base <S2SV_ModStart> base -> data == NULL || params -> base -> length == 0"}
{"source": "CWE-476 bool st_select_lex : : optimize_unflattened_subqueries ( bool const_only ) { SELECT_LEX_UNIT * next_unit = NULL ; for ( SELECT_LEX_UNIT * un = first_inner_unit ( ) ; un ; un = next_unit ? next_unit : un -> next_unit ( ) ) { Item_subselect * subquery_predicate = un -> item ; next_unit = NULL ; if ( subquery_predicate ) { if ( ! subquery_predicate -> fixed ) { next_unit = un -> next_unit ( ) ; un -> exclude_level ( ) ; if ( next_unit ) continue ; break ; } if ( subquery_predicate -> substype ( ) == Item_subselect : : IN_SUBS ) { Item_in_subselect * in_subs = ( Item_in_subselect * ) subquery_predicate ; if ( in_subs -> is_jtbm_merged ) continue ; } if ( const_only && ! subquery_predicate -> const_item ( ) ) { continue ; } bool empty_union_result = true ; bool is_correlated_unit = false ; bool first = true ; bool union_plan_saved = false ; for ( SELECT_LEX * sl = un -> first_select ( ) ; sl ; sl = sl -> next_select ( ) ) { JOIN * inner_join = sl -> join ; if ( first ) first = false ; else { if ( ! union_plan_saved ) { union_plan_saved = true ; if ( un -> save_union_explain ( un -> thd -> lex -> explain ) ) return true ; } } if ( ! inner_join ) continue ; SELECT_LEX * save_select = un -> thd -> lex -> current_select ; ulonglong save_options ; int res ; un -> set_limit ( un -> global_parameters ( ) ) ; un -> thd -> lex -> current_select = sl ; save_options = inner_join -> select_options ; if ( options & SELECT_DESCRIBE ) { sl -> set_explain_type ( FALSE ) ; sl -> options |= SELECT_DESCRIBE ; inner_join -> select_options |= SELECT_DESCRIBE ; } if ( ( res = inner_join -> optimize ( ) ) ) return TRUE ; if ( ! inner_join -> cleaned ) sl -> update_used_tables ( ) ; sl -> update_correlated_cache ( ) ; is_correlated_unit |= sl -> is_correlated ; inner_join -> select_options = save_options ; un -> thd -> lex -> current_select = save_select ; Explain_query * eq ; if ( ( eq = inner_join -> thd -> lex -> explain ) ) { Explain_select * expl_sel ; if ( ( expl_sel = eq -> get_select ( inner_join -> select_lex -> select_number ) ) ) { sl -> set_explain_type ( TRUE ) ; expl_sel -> select_type = sl -> type ; } } if ( empty_union_result ) { empty_union_result = inner_join -> empty_result ( ) ; } if ( res ) return TRUE ; } if ( empty_union_result ) subquery_predicate -> no_rows_in_result ( ) ; <S2SV_StartBug> if ( ! is_correlated_unit ) <S2SV_EndBug> un -> uncacheable &= ~ UNCACHEABLE_DEPENDENT ; subquery_predicate -> is_correlated = is_correlated_unit ; } } return FALSE ; }", "target": "<S2SV_ModStart> ( ) ; if ( is_correlated_unit ) { for ( SELECT_LEX * sl = un -> first_select ( ) ; sl ; sl = sl -> next_select ( ) ) sl -> uncacheable |= UNCACHEABLE_DEPENDENT ; } else <S2SV_ModEnd> un -> uncacheable"}
{"source": "CWE-400 void ha_maria : : drop_table ( const char * name ) { <S2SV_StartBug> DBUG_ASSERT ( file -> s -> temporary ) ; <S2SV_EndBug> ( void ) ha_close ( ) ; ( void ) maria_delete_table_files ( name , 1 , MY_WME ) ; }", "target": "<S2SV_ModStart> { DBUG_ASSERT ( ! file ||"}
{"source": "CWE-416 bool open_table ( THD * thd , TABLE_LIST * table_list , Open_table_context * ot_ctx ) { TABLE * table ; const char * key ; uint key_length ; const char * alias = table_list -> alias . str ; uint flags = ot_ctx -> get_flags ( ) ; MDL_ticket * mdl_ticket ; TABLE_SHARE * share ; uint gts_flags ; bool from_share = false ; # ifdef WITH_PARTITION_STORAGE_ENGINE int part_names_error = 0 ; # endif DBUG_ENTER ( \"open_table\" ) ; DBUG_ASSERT ( ! table_list -> table ) ; if ( check_stack_overrun ( thd , STACK_MIN_SIZE_FOR_OPEN , ( uchar * ) & alias ) ) DBUG_RETURN ( TRUE ) ; if ( ! ( flags & MYSQL_OPEN_IGNORE_KILLED ) && thd -> killed ) { thd -> send_kill_message ( ) ; DBUG_RETURN ( TRUE ) ; } if ( table_list -> mdl_request . is_write_lock_request ( ) && thd -> tx_read_only && ! ( flags & ( MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK ) ) ) { my_error ( ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION , MYF ( 0 ) ) ; DBUG_RETURN ( true ) ; } if ( ! table_list -> db . str ) { my_error ( ER_NO_DB_ERROR , MYF ( 0 ) ) ; DBUG_RETURN ( true ) ; } key_length = get_table_def_key ( table_list , & key ) ; if ( thd -> locked_tables_mode && ! ( flags & MYSQL_OPEN_GET_NEW_TABLE ) ) { TABLE * best_table = 0 ; int best_distance = INT_MIN ; for ( table = thd -> open_tables ; table ; table = table -> next ) { if ( table -> s -> table_cache_key . length == key_length && ! memcmp ( table -> s -> table_cache_key . str , key , key_length ) ) { if ( ! my_strcasecmp ( system_charset_info , table -> alias . c_ptr ( ) , alias ) && table -> query_id != thd -> query_id && ( thd -> locked_tables_mode == LTM_LOCK_TABLES || table -> query_id == 0 ) ) { int distance = ( ( int ) table -> reginfo . lock_type - ( int ) table_list -> lock_type ) ; if ( ( best_distance < 0 && distance > best_distance ) || ( distance >= 0 && distance < best_distance ) ) { best_distance = distance ; best_table = table ; if ( best_distance == 0 ) { break ; } } } } } if ( best_table ) { table = best_table ; table -> query_id = thd -> query_id ; table -> init ( thd , table_list ) ; DBUG_PRINT ( \"info\" , ( \"Using<S2SV_blank>locked<S2SV_blank>table\" ) ) ; # ifdef WITH_PARTITION_STORAGE_ENGINE part_names_error = set_partitions_as_used ( table_list , table ) ; # endif goto reset ; } if ( is_locked_view ( thd , table_list ) ) { if ( table_list -> sequence ) { my_error ( ER_NOT_SEQUENCE , MYF ( 0 ) , table_list -> db . str , table_list -> alias . str ) ; DBUG_RETURN ( true ) ; } DBUG_RETURN ( FALSE ) ; } if ( thd -> locked_tables_mode == LTM_PRELOCKED ) my_error ( ER_NO_SUCH_TABLE , MYF ( 0 ) , table_list -> db . str , table_list -> alias . str ) ; else my_error ( ER_TABLE_NOT_LOCKED , MYF ( 0 ) , alias ) ; DBUG_RETURN ( TRUE ) ; } if ( ! ( flags & MYSQL_OPEN_HAS_MDL_LOCK ) ) { if ( table_list -> mdl_request . is_write_lock_request ( ) && ! ( flags & ( MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK | MYSQL_OPEN_FORCE_SHARED_MDL | MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL | MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK ) ) && ! ot_ctx -> has_protection_against_grl ( ) ) { MDL_request protection_request ; MDL_deadlock_handler mdl_deadlock_handler ( ot_ctx ) ; if ( thd -> global_read_lock . can_acquire_protection ( ) ) DBUG_RETURN ( TRUE ) ; protection_request . init ( MDL_key : : GLOBAL , \"\" , \"\" , MDL_INTENTION_EXCLUSIVE , MDL_STATEMENT ) ; thd -> push_internal_handler ( & mdl_deadlock_handler ) ; bool result = thd -> mdl_context . acquire_lock ( & protection_request , ot_ctx -> get_timeout ( ) ) ; thd -> pop_internal_handler ( ) ; if ( result ) DBUG_RETURN ( TRUE ) ; ot_ctx -> set_has_protection_against_grl ( ) ; } if ( open_table_get_mdl_lock ( thd , ot_ctx , & table_list -> mdl_request , flags , & mdl_ticket ) || mdl_ticket == NULL ) { DEBUG_SYNC ( thd , \"before_open_table_wait_refresh\" ) ; DBUG_RETURN ( TRUE ) ; } DEBUG_SYNC ( thd , \"after_open_table_mdl_shared\" ) ; } else { mdl_ticket = table_list -> mdl_request . ticket ; } if ( table_list -> open_strategy == TABLE_LIST : : OPEN_IF_EXISTS ) { if ( ! ha_table_exists ( thd , & table_list -> db , & table_list -> table_name ) ) DBUG_RETURN ( FALSE ) ; } else if ( table_list -> open_strategy == TABLE_LIST : : OPEN_STUB ) DBUG_RETURN ( FALSE ) ; if ( table_list -> i_s_requested_object & OPEN_TABLE_ONLY ) gts_flags = GTS_TABLE ; else if ( table_list -> i_s_requested_object & OPEN_VIEW_ONLY ) gts_flags = GTS_VIEW ; else gts_flags = GTS_TABLE | GTS_VIEW ; retry_share : share = tdc_acquire_share ( thd , table_list , gts_flags , & table ) ; if ( unlikely ( ! share ) ) { if ( thd -> is_error ( ) ) { if ( table_list -> parent_l ) { thd -> clear_error ( ) ; my_error ( ER_WRONG_MRG_TABLE , MYF ( 0 ) ) ; } else if ( table_list -> belong_to_view ) { TABLE_LIST * view = table_list -> belong_to_view ; thd -> clear_error ( ) ; my_error ( ER_VIEW_INVALID , MYF ( 0 ) , view -> view_db . str , view -> view_name . str ) ; } } DBUG_RETURN ( TRUE ) ; } if ( share -> is_view ) { if ( table_list -> parent_l ) { my_error ( ER_WRONG_MRG_TABLE , MYF ( 0 ) ) ; goto err_lock ; } if ( table_list -> sequence ) { my_error ( ER_NOT_SEQUENCE , MYF ( 0 ) , table_list -> db . str , table_list -> alias . str ) ; goto err_lock ; } if ( check_and_update_table_version ( thd , table_list , share ) ) goto err_lock ; if ( mysql_make_view ( thd , share , table_list , false ) ) goto err_lock ; tdc_release_share ( share ) ; DBUG_ASSERT ( table_list -> view ) ; DBUG_RETURN ( FALSE ) ; } # ifdef WITH_WSREP if ( ! ( ( flags & MYSQL_OPEN_IGNORE_FLUSH ) || ( thd -> wsrep_applier ) ) ) # else if ( ! ( flags & MYSQL_OPEN_IGNORE_FLUSH ) ) # endif { if ( share -> tdc -> flushed ) { DBUG_PRINT ( \"info\" , ( \"Found<S2SV_blank>old<S2SV_blank>share<S2SV_blank>version:<S2SV_blank>%lld<S2SV_blank><S2SV_blank>current:<S2SV_blank>%lld\" , share -> tdc -> version , tdc_refresh_version ( ) ) ) ; if ( table ) tc_release_table ( table ) ; else tdc_release_share ( share ) ; MDL_deadlock_handler mdl_deadlock_handler ( ot_ctx ) ; bool wait_result ; thd -> push_internal_handler ( & mdl_deadlock_handler ) ; wait_result = tdc_wait_for_old_version ( thd , table_list -> db . str , table_list -> table_name . str , ot_ctx -> get_timeout ( ) , mdl_ticket -> get_deadlock_weight ( ) ) ; thd -> pop_internal_handler ( ) ; if ( wait_result ) DBUG_RETURN ( TRUE ) ; goto retry_share ; } if ( thd -> open_tables && thd -> open_tables -> s -> tdc -> flushed ) { if ( table ) tc_release_table ( table ) ; else tdc_release_share ( share ) ; ( void ) ot_ctx -> request_backoff_action ( Open_table_context : : OT_REOPEN_TABLES , NULL ) ; DBUG_RETURN ( TRUE ) ; } } if ( table ) { DBUG_ASSERT ( table -> file != NULL ) ; MYSQL_REBIND_TABLE ( table -> file ) ; # ifdef WITH_PARTITION_STORAGE_ENGINE part_names_error = set_partitions_as_used ( table_list , table ) ; # endif } else { enum open_frm_error error ; if ( ! ( table = ( TABLE * ) my_malloc ( sizeof ( * table ) , MYF ( MY_WME ) ) ) ) goto err_lock ; error = open_table_from_share ( thd , share , & table_list -> alias , HA_OPEN_KEYFILE | HA_TRY_READ_ONLY , EXTRA_RECORD , thd -> open_options , table , FALSE , IF_PARTITIONING ( table_list -> partition_names , 0 ) ) ; if ( unlikely ( error ) ) { my_free ( table ) ; if ( error == OPEN_FRM_DISCOVER ) ( void ) ot_ctx -> request_backoff_action ( Open_table_context : : OT_DISCOVER , table_list ) ; else if ( share -> crashed ) { if ( ! ( flags & MYSQL_OPEN_IGNORE_REPAIR ) ) ( void ) ot_ctx -> request_backoff_action ( Open_table_context : : OT_REPAIR , table_list ) ; else table_list -> crashed = 1 ; } goto err_lock ; } if ( open_table_entry_fini ( thd , share , table ) ) { closefrm ( table ) ; my_free ( table ) ; goto err_lock ; } tc_add_table ( thd , table ) ; from_share = true ; } table -> mdl_ticket = mdl_ticket ; table -> reginfo . lock_type = TL_READ ; table -> init ( thd , table_list ) ; table -> next = thd -> open_tables ; thd -> set_open_tables ( table ) ; reset : DBUG_ASSERT ( table -> file -> pushed_cond == NULL ) ; table_list -> updatable = 1 ; table_list -> table = table ; if ( ! from_share && table -> vcol_fix_expr ( thd ) ) <S2SV_StartBug> goto err_lock ; <S2SV_EndBug> # ifdef WITH_PARTITION_STORAGE_ENGINE if ( unlikely ( table -> part_info ) ) { if ( part_names_error ) { table -> file -> print_error ( part_names_error , MYF ( 0 ) ) ; DBUG_RETURN ( true ) ; } } else if ( table_list -> partition_names ) { my_error ( ER_PARTITION_CLAUSE_ON_NONPARTITIONED , MYF ( 0 ) ) ; DBUG_RETURN ( true ) ; } # endif if ( table_list -> sequence && table -> s -> table_type != TABLE_TYPE_SEQUENCE ) { my_error ( ER_NOT_SEQUENCE , MYF ( 0 ) , table_list -> db . str , table_list -> alias . str ) ; DBUG_RETURN ( true ) ; } DBUG_RETURN ( FALSE ) ; err_lock : tdc_release_share ( share ) ; DBUG_PRINT ( \"exit\" , ( \"failed\" ) ) ; DBUG_RETURN ( TRUE ) ; }", "target": "<S2SV_ModStart> thd ) ) DBUG_RETURN ( true ) <S2SV_ModEnd> ; # ifdef"}
{"source": "CWE-617 bool Item_equal : : create_pushable_equalities ( THD * thd , List < Item > * equalities , Pushdown_checker checker , uchar * arg , bool clone_const ) { Item * item ; Item * left_item = NULL ; Item * right_item = get_const ( ) ; Item_equal_fields_iterator it ( * this ) ; while ( ( item = it ++ ) ) { left_item = item ; if ( checker && ! ( ( item -> * checker ) ( arg ) ) ) continue ; break ; } if ( ! left_item ) return false ; if ( right_item ) { Item_func_eq * eq = 0 ; Item * left_item_clone = left_item -> build_clone ( thd ) ; Item * right_item_clone = ! clone_const ? right_item : right_item -> build_clone ( thd ) ; if ( ! left_item_clone || ! right_item_clone ) return true ; eq = new ( thd -> mem_root ) Item_func_eq ( thd , left_item_clone , right_item_clone ) ; if ( ! eq || equalities -> push_back ( eq , thd -> mem_root ) ) return true ; if ( ! clone_const ) <S2SV_StartBug> right_item -> set_extraction_flag ( IMMUTABLE_FL ) ; <S2SV_EndBug> } while ( ( item = it ++ ) ) { if ( checker && ! ( ( item -> * checker ) ( arg ) ) ) continue ; Item_func_eq * eq = 0 ; Item * left_item_clone = left_item -> build_clone ( thd ) ; Item * right_item_clone = item -> build_clone ( thd ) ; if ( ! ( left_item_clone && right_item_clone ) ) return true ; left_item_clone -> set_item_equal ( NULL ) ; right_item_clone -> set_item_equal ( NULL ) ; eq = new ( thd -> mem_root ) Item_func_eq ( thd , right_item_clone , left_item_clone ) ; if ( ! eq || equalities -> push_back ( eq , thd -> mem_root ) ) return true ; } return false ; }", "target": "<S2SV_ModStart> ! clone_const ) { int new_flag = IMMUTABLE_FL ; right_item -> walk ( & Item : : set_extraction_flag_processor , false , ( void * ) & new_flag ) ; } <S2SV_ModEnd> } while ("}
{"source": "CWE-416 static void fix_dl_name ( MEM_ROOT * root , LEX_STRING * dl ) { const size_t so_ext_len = sizeof ( SO_EXT ) - 1 ; <S2SV_StartBug> if ( my_strcasecmp ( & my_charset_latin1 , dl -> str + dl -> length - so_ext_len , <S2SV_EndBug> SO_EXT ) ) { char * s = ( char * ) alloc_root ( root , dl -> length + so_ext_len + 1 ) ; memcpy ( s , dl -> str , dl -> length ) ; strcpy ( s + dl -> length , SO_EXT ) ; dl -> str = s ; dl -> length += so_ext_len ; } }", "target": "<S2SV_ModStart> ; if ( dl -> length < so_ext_len ||"}
{"source": "CWE-617 multi_update : : initialize_tables ( JOIN * join ) { TABLE_LIST * table_ref ; DBUG_ENTER ( \"initialize_tables\" ) ; if ( unlikely ( ( thd -> variables . option_bits & OPTION_SAFE_UPDATES ) && error_if_full_join ( join ) ) ) <S2SV_StartBug> DBUG_RETURN ( 1 ) ; <S2SV_EndBug> main_table = join -> join_tab -> table ; table_to_update = 0 ; DBUG_ASSERT ( fields -> elements ) ; TABLE * first_table_for_update = ( ( Item_field * ) fields -> head ( ) ) -> field -> table ; for ( table_ref = update_tables ; table_ref ; table_ref = table_ref -> next_local ) { TABLE * table = table_ref -> table ; uint cnt = table_ref -> shared ; List < Item > temp_fields ; ORDER group ; TMP_TABLE_PARAM * tmp_param ; if ( ignore ) table -> file -> extra ( HA_EXTRA_IGNORE_DUP_KEY ) ; if ( table == main_table ) { if ( safe_update_on_fly ( thd , join -> join_tab , table_ref , all_tables ) ) { table_to_update = table ; has_vers_fields = table -> vers_check_update ( * fields ) ; continue ; } } table -> prepare_for_position ( ) ; join -> map2table [ table -> tablenr ] -> keep_current_rowid = true ; if ( table_ref -> check_option && ! join -> select_lex -> uncacheable ) { SELECT_LEX_UNIT * tmp_unit ; SELECT_LEX * sl ; for ( tmp_unit = join -> select_lex -> first_inner_unit ( ) ; tmp_unit ; tmp_unit = tmp_unit -> next_unit ( ) ) { for ( sl = tmp_unit -> first_select ( ) ; sl ; sl = sl -> next_select ( ) ) { if ( sl -> master_unit ( ) -> item ) { join -> select_lex -> uncacheable |= UNCACHEABLE_CHECKOPTION ; goto loop_end ; } } } } loop_end : if ( table == first_table_for_update && table_ref -> check_option ) { table_map unupdated_tables = table_ref -> check_option -> used_tables ( ) & ~ first_table_for_update -> map ; List_iterator < TABLE_LIST > ti ( * leaves ) ; TABLE_LIST * tbl_ref ; while ( ( tbl_ref = ti ++ ) && unupdated_tables ) { if ( unupdated_tables & tbl_ref -> table -> map ) unupdated_tables &= ~ tbl_ref -> table -> map ; else continue ; if ( unupdated_check_opt_tables . push_back ( tbl_ref -> table ) ) DBUG_RETURN ( 1 ) ; } } tmp_param = tmp_table_param + cnt ; List_iterator_fast < TABLE > tbl_it ( unupdated_check_opt_tables ) ; TABLE * tbl = table ; do { LEX_CSTRING field_name ; field_name . str = tbl -> alias . c_ptr ( ) ; field_name . length = strlen ( field_name . str ) ; tbl -> prepare_for_position ( ) ; join -> map2table [ tbl -> tablenr ] -> keep_current_rowid = true ; Item_temptable_rowid * item = new ( thd -> mem_root ) Item_temptable_rowid ( tbl ) ; if ( ! item ) DBUG_RETURN ( 1 ) ; item -> fix_fields ( thd , 0 ) ; if ( temp_fields . push_back ( item , thd -> mem_root ) ) DBUG_RETURN ( 1 ) ; } while ( ( tbl = tbl_it ++ ) ) ; temp_fields . append ( fields_for_table [ cnt ] ) ; bzero ( ( char * ) & group , sizeof ( group ) ) ; group . direction = ORDER : : ORDER_ASC ; group . item = ( Item * * ) temp_fields . head_ref ( ) ; tmp_param -> quick_group = 1 ; tmp_param -> field_count = temp_fields . elements ; tmp_param -> func_count = temp_fields . elements - 1 ; calc_group_buffer ( tmp_param , & group ) ; my_bool save_big_tables = thd -> variables . big_tables ; thd -> variables . big_tables = FALSE ; tmp_tables [ cnt ] = create_tmp_table ( thd , tmp_param , temp_fields , ( ORDER * ) & group , 0 , 0 , TMP_TABLE_ALL_COLUMNS , HA_POS_ERROR , & empty_clex_str ) ; thd -> variables . big_tables = save_big_tables ; if ( ! tmp_tables [ cnt ] ) DBUG_RETURN ( 1 ) ; tmp_tables [ cnt ] -> file -> extra ( HA_EXTRA_WRITE_CACHE ) ; } join -> tmp_table_keep_current_rowid = TRUE ; DBUG_RETURN ( 0 ) ; }", "target": "<S2SV_ModStart> 1 ) ; if ( join -> implicit_grouping ) { my_error ( ER_INVALID_GROUP_FUNC_USE , MYF ( 0 ) ) ; DBUG_RETURN ( 1 ) ; }"}
{"source": "CWE-79 static void do_viewlog ( HttpRequest req , HttpResponse res ) { if ( is_readonly ( req ) ) { send_error ( req , res , SC_FORBIDDEN , \"You<S2SV_blank>do<S2SV_blank>not<S2SV_blank>have<S2SV_blank>sufficient<S2SV_blank>privileges<S2SV_blank>to<S2SV_blank>access<S2SV_blank>this<S2SV_blank>page\" ) ; return ; } do_head ( res , \"_viewlog\" , \"View<S2SV_blank>log\" , 100 ) ; if ( ( Run . flags & Run_Log ) && ! ( Run . flags & Run_UseSyslog ) ) { FILE * f = fopen ( Run . files . log , \"r\" ) ; if ( f ) { size_t n ; char buf [ 512 ] ; StringBuffer_append ( res -> outputbuffer , \"<br><p><form><textarea<S2SV_blank>cols=120<S2SV_blank>rows=30<S2SV_blank>readonly>\" ) ; while ( ( n = fread ( buf , sizeof ( char ) , sizeof ( buf ) - 1 , f ) ) > 0 ) { buf [ n ] = 0 ; <S2SV_StartBug> StringBuffer_append ( res -> outputbuffer , \"%s\" , buf ) ; <S2SV_EndBug> } fclose ( f ) ; StringBuffer_append ( res -> outputbuffer , \"</textarea></form>\" ) ; } else { StringBuffer_append ( res -> outputbuffer , \"Error<S2SV_blank>opening<S2SV_blank>logfile:<S2SV_blank>%s\" , STRERROR ) ; } } else { StringBuffer_append ( res -> outputbuffer , \"<b>Cannot<S2SV_blank>view<S2SV_blank>logfile:</b><br>\" ) ; if ( ! ( Run . flags & Run_Log ) ) StringBuffer_append ( res -> outputbuffer , \"Monit<S2SV_blank>was<S2SV_blank>started<S2SV_blank>without<S2SV_blank>logging\" ) ; else StringBuffer_append ( res -> outputbuffer , \"Monit<S2SV_blank>uses<S2SV_blank>syslog\" ) ; } do_foot ( res ) ; }", "target": "<S2SV_ModStart> = 0 ; escapeHTML ( res -> outputbuffer <S2SV_ModEnd> , buf )"}
{"source": "CWE-59 <S2SV_StartBug> Result ZipFile : : uncompressEntry ( int index , const File & targetDirectory , bool shouldOverwriteFiles ) <S2SV_EndBug> { auto * zei = entries . getUnchecked ( index ) ; # if JUCE_WINDOWS auto entryPath = zei -> entry . filename ; # else auto entryPath = zei -> entry . filename . replaceCharacter ( '\\\\\\\\' , '/' ) ; # endif if ( entryPath . isEmpty ( ) ) return Result : : ok ( ) ; <S2SV_StartBug> auto targetFile = targetDirectory . getChildFile ( entryPath ) ; <S2SV_EndBug> if ( entryPath . endsWithChar ( '/' ) || entryPath . endsWithChar ( '\\\\\\\\' ) ) return targetFile . createDirectory ( ) ; std : : unique_ptr < InputStream > in ( createStreamForEntry ( index ) ) ; if ( in == nullptr ) return Result : : fail ( \"Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>the<S2SV_blank>zip<S2SV_blank>file<S2SV_blank>for<S2SV_blank>reading\" ) ; if ( targetFile . exists ( ) ) { <S2SV_StartBug> if ( ! shouldOverwriteFiles ) <S2SV_EndBug> return Result : : ok ( ) ; if ( ! targetFile . deleteFile ( ) ) return Result : : fail ( \"Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>target<S2SV_blank>file:<S2SV_blank>\" + targetFile . getFullPathName ( ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! targetFile . getParentDirectory ( ) . createDirectory ( ) ) return Result : : fail ( \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>target<S2SV_blank>folder:<S2SV_blank>\" + targetFile . getParentDirectory ( ) . getFullPathName ( ) ) ; if ( zei -> entry . isSymbolicLink ) { String originalFilePath ( in -> readEntireStreamAsString ( ) . replaceCharacter ( L'/' , File : : getSeparatorChar ( ) ) ) ; if ( ! File : : createSymbolicLink ( targetFile , originalFilePath , true ) ) return Result : : fail ( \"Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symbolic<S2SV_blank>link:<S2SV_blank>\" + originalFilePath ) ; } else { FileOutputStream out ( targetFile ) ; if ( out . failedToOpen ( ) ) return Result : : fail ( \"Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>target<S2SV_blank>file:<S2SV_blank>\" + targetFile . getFullPathName ( ) ) ; out << * in ; } targetFile . setCreationTime ( zei -> entry . fileTime ) ; targetFile . setLastModificationTime ( zei -> entry . fileTime ) ; targetFile . setLastAccessTime ( zei -> entry . fileTime ) ; return Result : : ok ( ) ; }", "target": "<S2SV_ModStart> & targetDirectory , OverwriteFiles overwriteFiles , FollowSymlinks followSymlinks <S2SV_ModEnd> ) { auto <S2SV_ModStart> getChildFile ( entryPath ) ; if ( ! targetFile . isAChildOf ( targetDirectory ) ) return Result : : fail ( \"Entry<S2SV_blank>\" + entryPath + \"<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>target<S2SV_blank>directory\" <S2SV_ModStart> { if ( overwriteFiles == OverwriteFiles : : no ) return Result : : ok ( ) ; if ( ! <S2SV_ModEnd> targetFile . deleteFile <S2SV_ModStart> ) ; } if ( followSymlinks == FollowSymlinks : : no && hasSymbolicPart ( targetDirectory , targetFile . getParentDirectory ( ) ) ) return Result : : fail ( \"Parent<S2SV_blank>directory<S2SV_blank>leads<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>target<S2SV_blank>file:<S2SV_blank>\" + targetFile . getFullPathName ( ) ) ;"}
{"source": "CWE-120 int64_t GmfOpenMesh ( const char * FilNam , int mod , ... ) { int KwdCod , res , * PtrVer , * PtrDim , err ; int64_t MshIdx ; char str [ GmfStrSiz ] ; va_list VarArg ; GmfMshSct * msh ; if ( ! ( msh = calloc ( 1 , sizeof ( GmfMshSct ) ) ) ) return ( 0 ) ; MshIdx = ( int64_t ) msh ; if ( ( err = setjmp ( msh -> err ) ) != 0 ) { # ifdef GMFDEBUG printf ( \"libMeshb<S2SV_blank>:<S2SV_blank>mesh<S2SV_blank>%p<S2SV_blank>:<S2SV_blank>error<S2SV_blank>%d\\\\n\" , msh , err ) ; # endif if ( msh -> hdl != NULL ) fclose ( msh -> hdl ) ; if ( msh -> FilDes != 0 ) # ifdef GMF_WINDOWS _close ( msh -> FilDes ) ; # else close ( msh -> FilDes ) ; # endif free ( msh ) ; return ( 0 ) ; } if ( strlen ( FilNam ) + 7 >= GmfStrSiz ) longjmp ( msh -> err , - 4 ) ; strcpy ( msh -> FilNam , FilNam ) ; msh -> mod = mod ; msh -> buf = ( void * ) msh -> DblBuf ; msh -> FltBuf = ( void * ) msh -> DblBuf ; msh -> IntBuf = ( void * ) msh -> DblBuf ; if ( strstr ( msh -> FilNam , \".meshb\" ) ) msh -> typ |= ( Bin | MshFil ) ; else if ( strstr ( msh -> FilNam , \".mesh\" ) ) msh -> typ |= ( Asc | MshFil ) ; else if ( strstr ( msh -> FilNam , \".solb\" ) ) msh -> typ |= ( Bin | SolFil ) ; else if ( strstr ( msh -> FilNam , \".sol\" ) ) msh -> typ |= ( Asc | SolFil ) ; else longjmp ( msh -> err , - 5 ) ; if ( msh -> mod == GmfRead ) { va_start ( VarArg , mod ) ; PtrVer = va_arg ( VarArg , int * ) ; PtrDim = va_arg ( VarArg , int * ) ; va_end ( VarArg ) ; if ( msh -> typ & Bin ) { # ifdef WITH_GMF_AIO msh -> FilDes = open ( msh -> FilNam , OPEN_READ_FLAGS , OPEN_READ_MODE ) ; if ( msh -> FilDes <= 0 ) longjmp ( msh -> err , - 6 ) ; if ( read ( msh -> FilDes , & msh -> cod , WrdSiz ) != WrdSiz ) longjmp ( msh -> err , - 7 ) ; # else if ( ! ( msh -> hdl = fopen ( msh -> FilNam , \"rb\" ) ) ) longjmp ( msh -> err , - 8 ) ; safe_fread ( & msh -> cod , WrdSiz , 1 , msh -> hdl , msh -> err ) ; # endif if ( ( msh -> cod != 1 ) && ( msh -> cod != 16777216 ) ) longjmp ( msh -> err , - 9 ) ; ScaWrd ( msh , ( unsigned char * ) & msh -> ver ) ; if ( ( msh -> ver < 1 ) || ( msh -> ver > 4 ) ) longjmp ( msh -> err , - 10 ) ; if ( ( msh -> ver >= 3 ) && ( sizeof ( int64_t ) != 8 ) ) longjmp ( msh -> err , - 11 ) ; ScaWrd ( msh , ( unsigned char * ) & KwdCod ) ; if ( KwdCod != GmfDimension ) longjmp ( msh -> err , - 12 ) ; GetPos ( msh ) ; ScaWrd ( msh , ( unsigned char * ) & msh -> dim ) ; } else { if ( ! ( msh -> hdl = fopen ( msh -> FilNam , \"rb\" ) ) ) longjmp ( msh -> err , - 13 ) ; do { <S2SV_StartBug> res = fscanf ( msh -> hdl , \"%s\" , str ) ; <S2SV_EndBug> } while ( ( res != EOF ) && strcmp ( str , \"MeshVersionFormatted\" ) ) ; if ( res == EOF ) longjmp ( msh -> err , - 14 ) ; safe_fscanf ( msh -> hdl , \"%d\" , & msh -> ver , msh -> err ) ; if ( ( msh -> ver < 1 ) || ( msh -> ver > 4 ) ) longjmp ( msh -> err , - 15 ) ; do { <S2SV_StartBug> res = fscanf ( msh -> hdl , \"%s\" , str ) ; <S2SV_EndBug> } while ( ( res != EOF ) && strcmp ( str , \"Dimension\" ) ) ; if ( res == EOF ) longjmp ( msh -> err , - 16 ) ; safe_fscanf ( msh -> hdl , \"%d\" , & msh -> dim , msh -> err ) ; } if ( ( msh -> dim != 2 ) && ( msh -> dim != 3 ) ) longjmp ( msh -> err , - 17 ) ; ( * PtrVer ) = msh -> ver ; ( * PtrDim ) = msh -> dim ; if ( msh -> ver == 1 ) msh -> FltSiz = 32 ; else msh -> FltSiz = 64 ; if ( ! ScaKwdTab ( msh ) ) return ( 0 ) ; return ( MshIdx ) ; } else if ( msh -> mod == GmfWrite ) { msh -> cod = 1 ; va_start ( VarArg , mod ) ; msh -> ver = va_arg ( VarArg , int ) ; msh -> dim = va_arg ( VarArg , int ) ; va_end ( VarArg ) ; if ( ( msh -> ver < 1 ) || ( msh -> ver > 4 ) ) longjmp ( msh -> err , - 18 ) ; if ( ( msh -> ver >= 3 ) && ( sizeof ( int64_t ) != 8 ) ) longjmp ( msh -> err , - 19 ) ; if ( ( msh -> dim != 2 ) && ( msh -> dim != 3 ) ) longjmp ( msh -> err , - 20 ) ; if ( msh -> ver == 1 ) msh -> FltSiz = 32 ; else msh -> FltSiz = 64 ; if ( msh -> typ & Bin ) { # ifdef WITH_GMF_AIO msh -> FilDes = open ( msh -> FilNam , OPEN_WRITE_FLAGS , OPEN_WRITE_MODE ) ; if ( msh -> FilDes <= 0 ) longjmp ( msh -> err , - 21 ) ; # else if ( ! ( msh -> hdl = fopen ( msh -> FilNam , \"wb\" ) ) ) longjmp ( msh -> err , - 22 ) ; # endif } else if ( ! ( msh -> hdl = fopen ( msh -> FilNam , \"wb\" ) ) ) longjmp ( msh -> err , - 23 ) ; if ( msh -> typ & Asc ) { fprintf ( msh -> hdl , \"%s<S2SV_blank>%d\\\\n\\\\n\" , GmfKwdFmt [ GmfVersionFormatted ] [ 0 ] , msh -> ver ) ; fprintf ( msh -> hdl , \"%s<S2SV_blank>%d\\\\n\" , GmfKwdFmt [ GmfDimension ] [ 0 ] , msh -> dim ) ; } else { RecWrd ( msh , ( unsigned char * ) & msh -> cod ) ; RecWrd ( msh , ( unsigned char * ) & msh -> ver ) ; GmfSetKwd ( MshIdx , GmfDimension , 0 ) ; RecWrd ( msh , ( unsigned char * ) & msh -> dim ) ; } return ( MshIdx ) ; } else { free ( msh ) ; return ( 0 ) ; } }", "target": "<S2SV_ModStart> -> hdl , \"%100s\" <S2SV_ModEnd> , str ) <S2SV_ModStart> -> hdl , \"%100s\" <S2SV_ModEnd> , str )"}
{"source": "CWE-125 int parse ( char * elf ) { int fd ; struct stat st ; uint8_t * elf_map ; int count ; char * tmp ; char * name ; char flag [ 4 ] ; MODE = get_elf_class ( elf ) ; fd = open ( elf , O_RDONLY ) ; if ( fd < 0 ) { perror ( \"open\" ) ; return - 1 ; } if ( fstat ( fd , & st ) < 0 ) { perror ( \"fstat\" ) ; return - 1 ; } elf_map = mmap ( 0 , st . st_size , PROT_READ | PROT_WRITE , MAP_PRIVATE , fd , 0 ) ; if ( elf_map == MAP_FAILED ) { perror ( \"mmap\" ) ; return - 1 ; } if ( MODE == ELFCLASS32 ) { Elf32_Ehdr * ehdr ; ehdr = ( Elf32_Ehdr * ) elf_map ; INFO ( \"ELF<S2SV_blank>Header\\\\n\" ) ; switch ( ehdr -> e_type ) { case ET_NONE : tmp = \"An<S2SV_blank>unknown<S2SV_blank>type\" ; break ; case ET_REL : tmp = \"A<S2SV_blank>relocatable<S2SV_blank>file\" ; break ; case ET_EXEC : tmp = \"An<S2SV_blank>executable<S2SV_blank>file\" ; break ; case ET_DYN : tmp = \"A<S2SV_blank>shared<S2SV_blank>object\" ; break ; case ET_CORE : tmp = \"A<S2SV_blank>core<S2SV_blank>file\" ; break ; default : tmp = \"An<S2SV_blank>unknown<S2SV_blank>type\" ; break ; } PRINT_HEADER_EXP ( \"e_type:\" , ehdr -> e_type , tmp ) ; switch ( ehdr -> e_type ) { case EM_NONE : tmp = \"An<S2SV_blank>unknown<S2SV_blank>machine\" ; break ; case EM_M32 : tmp = \"AT&T<S2SV_blank>WE<S2SV_blank>32100\" ; break ; case EM_SPARC : tmp = \"Sun<S2SV_blank>Microsystems<S2SV_blank>SPARC\" ; break ; case EM_386 : tmp = \"Intel<S2SV_blank>80386\" ; break ; case EM_68K : tmp = \"Motorola<S2SV_blank>68000\" ; break ; case EM_88K : tmp = \"Motorola<S2SV_blank>88000\" ; break ; case EM_860 : tmp = \"Intel<S2SV_blank>80860\" ; break ; case EM_MIPS : tmp = \"MIPS<S2SV_blank>RS3000<S2SV_blank>(big-endian<S2SV_blank>only)\" ; break ; case EM_PARISC : tmp = \"HP/PA\" ; break ; case EM_SPARC32PLUS : tmp = \"SPARC<S2SV_blank>with<S2SV_blank>enhanced<S2SV_blank>instruction<S2SV_blank>set\" ; break ; case EM_PPC : tmp = \"PowerPC\" ; break ; case EM_PPC64 : tmp = \"PowerPC<S2SV_blank>64-bit\" ; break ; case EM_S390 : tmp = \"IBM<S2SV_blank>S/390\" ; break ; case EM_ARM : tmp = \"Advanced<S2SV_blank>RISC<S2SV_blank>Machines\" ; break ; case EM_SH : tmp = \"Renesas<S2SV_blank>SuperH\" ; break ; case EM_SPARCV9 : tmp = \"SPARC<S2SV_blank>v9<S2SV_blank>64-bit\" ; break ; case EM_IA_64 : tmp = \"Intel<S2SV_blank>Itanium\" ; break ; case EM_X86_64 : tmp = \"AMD<S2SV_blank>x86-64\" ; break ; case EM_VAX : tmp = \"DEC<S2SV_blank>Vax\" ; break ; default : tmp = \"An<S2SV_blank>unknown<S2SV_blank>machine\" ; break ; } PRINT_HEADER_EXP ( \"e_machine:\" , ehdr -> e_machine , tmp ) ; switch ( ehdr -> e_version ) { case EV_NONE : tmp = \"Invalid<S2SV_blank>version\" ; break ; case EV_CURRENT : tmp = \"Current<S2SV_blank>version\" ; break ; default : tmp = \"Known<S2SV_blank>version\" ; break ; } PRINT_HEADER_EXP ( \"e_version:\" , ehdr -> e_version , tmp ) ; PRINT_HEADER ( \"e_entry:\" , ehdr -> e_entry ) ; PRINT_HEADER ( \"e_phoff:\" , ehdr -> e_phoff ) ; PRINT_HEADER ( \"e_shoff:\" , ehdr -> e_shoff ) ; PRINT_HEADER ( \"e_flags:\" , ehdr -> e_flags ) ; PRINT_HEADER ( \"e_ehsize:\" , ehdr -> e_ehsize ) ; PRINT_HEADER ( \"e_phentsize:\" , ehdr -> e_phentsize ) ; PRINT_HEADER ( \"e_phnum:\" , ehdr -> e_phnum ) ; PRINT_HEADER ( \"e_shentsize:\" , ehdr -> e_shentsize ) ; PRINT_HEADER ( \"e_shentsize:\" , ehdr -> e_shentsize ) ; PRINT_HEADER ( \"e_shstrndx:\" , ehdr -> e_shstrndx ) ; Elf32_Shdr * shdr ; Elf32_Phdr * phdr ; Elf32_Shdr shstrtab ; shdr = ( Elf32_Shdr * ) & elf_map [ ehdr -> e_shoff ] ; phdr = ( Elf32_Phdr * ) & elf_map [ ehdr -> e_phoff ] ; shstrtab = shdr [ ehdr -> e_shstrndx ] ; INFO ( \"Section<S2SV_blank>Header<S2SV_blank>Table\\\\n\" ) ; PRINT_SECTION_TITLE ( \"Nr\" , \"Name\" , \"Type\" , \"Addr\" , \"Off\" , \"Size\" , \"Es\" , \"Flg\" , \"Lk\" , \"Inf\" , \"Al\" ) ; for ( int i = 0 ; i < ehdr -> e_shnum ; i ++ ) { <S2SV_StartBug> name = elf_map + shstrtab . sh_offset + shdr [ i ] . sh_name ; <S2SV_EndBug> switch ( shdr [ i ] . sh_type ) { case SHT_NULL : tmp = \"SHT_NULL\" ; break ; case SHT_PROGBITS : tmp = \"SHT_PROGBITS\" ; break ; case SHT_SYMTAB : tmp = \"SHT_SYMTAB\" ; break ; case SHT_STRTAB : tmp = \"SHT_STRTAB\" ; break ; case SHT_RELA : tmp = \"SHT_RELA\" ; break ; case SHT_HASH : tmp = \"SHT_HASH\" ; break ; case SHT_DYNAMIC : tmp = \"SHT_DYNAMIC\" ; break ; case SHT_NOTE : tmp = \"SHT_NOTE\" ; break ; case SHT_NOBITS : tmp = \"SHT_NOBITS\" ; break ; case SHT_REL : tmp = \"SHT_REL\" ; break ; case SHT_SHLIB : tmp = \"SHT_SHLIB\" ; break ; case SHT_DYNSYM : tmp = \"SHT_DYNSYM\" ; break ; case SHT_LOPROC : tmp = \"SHT_LOPROC\" ; break ; case SHT_HIPROC : tmp = \"SHT_HIPROC\" ; break ; case SHT_LOUSER : tmp = \"SHT_LOUSER\" ; break ; case SHT_HIUSER : tmp = \"SHT_HIUSER\" ; break ; default : break ; } if ( strlen ( name ) > 15 ) { strcpy ( & name [ 15 - 6 ] , \"[...]\" ) ; } strcpy ( flag , \"<S2SV_blank><S2SV_blank><S2SV_blank>\" ) ; flag2str_sh ( shdr [ i ] . sh_flags , flag ) ; PRINT_SECTION ( i , name , tmp , shdr [ i ] . sh_addr , shdr [ i ] . sh_offset , shdr [ i ] . sh_size , shdr [ i ] . sh_entsize , flag , shdr [ i ] . sh_link , shdr [ i ] . sh_info , shdr [ i ] . sh_addralign ) ; } INFO ( \"Program<S2SV_blank>Header<S2SV_blank>Table\\\\n\" ) ; PRINT_PROGRAM_TITLE ( \"Nr\" , \"Type\" , \"Offset\" , \"Virtaddr\" , \"Physaddr\" , \"Filesiz\" , \"Memsiz\" , \"Flg\" , \"Align\" ) ; for ( int i = 0 ; i < ehdr -> e_phnum ; i ++ ) { switch ( phdr [ i ] . p_type ) { case PT_NULL : tmp = \"PT_NULL\" ; break ; case PT_LOAD : tmp = \"PT_LOAD\" ; break ; case PT_DYNAMIC : tmp = \"PT_DYNAMIC\" ; break ; case PT_INTERP : tmp = \"PT_INTERP\" ; break ; case PT_NOTE : tmp = \"PT_NOTE\" ; break ; case PT_SHLIB : tmp = \"PT_SHLIB\" ; break ; case PT_PHDR : tmp = \"PT_PHDR\" ; break ; case PT_LOPROC : tmp = \"PT_LOPROC\" ; break ; case PT_HIPROC : tmp = \"PT_HIPROC\" ; break ; case PT_GNU_STACK : tmp = \"PT_GNU_STACK\" ; break ; default : break ; } strcpy ( flag , \"<S2SV_blank><S2SV_blank><S2SV_blank>\" ) ; flag2str ( phdr [ i ] . p_flags , flag ) ; PRINT_PROGRAM ( i , tmp , phdr [ i ] . p_offset , phdr [ i ] . p_vaddr , phdr [ i ] . p_paddr , phdr [ i ] . p_filesz , phdr [ i ] . p_memsz , flag , phdr [ i ] . p_align ) ; } INFO ( \"Section<S2SV_blank>to<S2SV_blank>segment<S2SV_blank>mapping\\\\n\" ) ; for ( int i = 0 ; i < ehdr -> e_phnum ; i ++ ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[%2d]\" , i ) ; for ( int j = 0 ; j < ehdr -> e_shnum ; j ++ ) { name = elf_map + shstrtab . sh_offset + shdr [ j ] . sh_name ; if ( shdr [ j ] . sh_addr >= phdr [ i ] . p_vaddr && shdr [ j ] . sh_addr + shdr [ j ] . sh_size <= phdr [ i ] . p_vaddr + phdr [ i ] . p_memsz && shdr [ j ] . sh_type != SHT_NULL ) { if ( shdr [ j ] . sh_flags >> 1 & 0x1 ) { printf ( \"<S2SV_blank>%s\" , name ) ; } } } printf ( \"\\\\n\" ) ; } INFO ( \"Dynamic<S2SV_blank>link<S2SV_blank>information\\\\n\" ) ; int dynstr ; int dynamic ; Elf32_Dyn * dyn ; for ( int i = 0 ; i < ehdr -> e_shnum ; i ++ ) { name = elf_map + shstrtab . sh_offset + shdr [ i ] . sh_name ; if ( ! strcmp ( name , \".dynstr\" ) ) { dynstr = i ; } if ( ! strcmp ( name , \".dynamic\" ) ) { dynamic = i ; } } char value [ 50 ] ; name = \"\" ; dyn = ( Elf32_Dyn * ) & elf_map [ shdr [ dynamic ] . sh_offset ] ; count = shdr [ dynamic ] . sh_size / sizeof ( Elf32_Dyn ) ; INFO ( \"Dynamic<S2SV_blank>section<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>0x%x<S2SV_blank>contains<S2SV_blank>%d<S2SV_blank>entries\\\\n\" , shdr [ dynamic ] . sh_offset , count ) ; PRINT_DYN_TITLE ( \"Tag\" , \"Type\" , \"Name/Value\" ) ; for ( int i = 0 ; i < count ; i ++ ) { tmp = \"\" ; memset ( value , 0 , 50 ) ; snprintf ( value , 50 , \"0x%x\" , dyn [ i ] . d_un . d_val ) ; switch ( dyn [ i ] . d_tag ) { case DT_NULL : tmp = \"DT_NULL\" ; break ; case DT_NEEDED : tmp = \"DT_NEEDED\" ; name = elf_map + shdr [ dynstr ] . sh_offset + dyn [ i ] . d_un . d_val ; snprintf ( value , 50 , \"Shared<S2SV_blank>library:<S2SV_blank>[%s]\" , name ) ; break ; case DT_PLTRELSZ : tmp = \"DT_PLTRELSZ\" ; break ; case DT_PLTGOT : tmp = \"DT_PLTGOT\" ; break ; case DT_HASH : tmp = \"DT_HASH\" ; break ; case DT_STRTAB : tmp = \"DT_STRTAB\" ; break ; case DT_SYMTAB : tmp = \"DT_SYMTAB\" ; break ; case DT_RELA : tmp = \"DT_RELA\" ; break ; case DT_RELASZ : tmp = \"DT_RELASZ\" ; break ; case DT_RELAENT : tmp = \"DT_RELAENT\" ; break ; case DT_STRSZ : tmp = \"DT_STRSZ\" ; break ; case DT_SYMENT : tmp = \"DT_SYMENT\" ; break ; case DT_INIT : tmp = \"DT_INIT\" ; break ; case DT_FINI : tmp = \"DT_FINI\" ; break ; case DT_SONAME : tmp = \"DT_SONAME\" ; break ; case DT_RPATH : tmp = \"DT_RPATH\" ; break ; case DT_SYMBOLIC : tmp = \"DT_SYMBOLIC\" ; break ; case DT_REL : tmp = \"DT_REL\" ; break ; case DT_RELSZ : tmp = \"DT_RELSZ\" ; break ; case DT_RELENT : tmp = \"DT_RELENT\" ; break ; case DT_PLTREL : tmp = \"DT_PLTREL\" ; break ; case DT_DEBUG : tmp = \"DT_DEBUG\" ; break ; case DT_TEXTREL : tmp = \"DT_TEXTREL\" ; break ; case DT_JMPREL : tmp = \"DT_JMPREL\" ; break ; case DT_BIND_NOW : tmp = \"DT_BIND_NOW\" ; break ; case DT_INIT_ARRAY : tmp = \"DT_INIT_ARRAY\" ; break ; case DT_FINI_ARRAY : tmp = \"DT_FINI_ARRAY\" ; break ; case DT_INIT_ARRAYSZ : tmp = \"DT_INIT_ARRAYSZ\" ; break ; case DT_FINI_ARRAYSZ : tmp = \"DT_FINI_ARRAYSZ\" ; break ; case DT_RUNPATH : tmp = \"DT_RUNPATH\" ; break ; case DT_FLAGS : tmp = \"DT_FLAGS\" ; snprintf ( value , 50 , \"Flags:<S2SV_blank>%d\" , dyn [ i ] . d_un . d_val ) ; break ; case DT_ENCODING : tmp = \"DT_ENCODING\" ; break ; case DT_PREINIT_ARRAYSZ : tmp = \"DT_PREINIT_ARRAYSZ\" ; break ; case DT_SYMTAB_SHNDX : tmp = \"DT_SYMTAB_SHNDX\" ; break ; case DT_NUM : tmp = \"DT_NUM\" ; break ; case DT_LOOS : tmp = \"DT_LOOS\" ; break ; case DT_HIOS : tmp = \"DT_HIOS\" ; break ; case DT_LOPROC : tmp = \"DT_LOPROC\" ; break ; case DT_HIPROC : tmp = \"DT_HIPROC\" ; break ; case DT_PROCNUM : tmp = \"DT_LOPROC\" ; break ; case DT_VALRNGLO : tmp = \"DT_VALRNGLO\" ; break ; case DT_GNU_PRELINKED : tmp = \"DT_GNU_PRELINKED\" ; break ; case DT_GNU_CONFLICTSZ : tmp = \"DT_GNU_CONFLICTSZ\" ; break ; case DT_GNU_LIBLISTSZ : tmp = \"DT_GNU_LIBLISTSZ\" ; break ; case DT_CHECKSUM : tmp = \"DT_CHECKSUM\" ; break ; case DT_PLTPADSZ : tmp = \"DT_PLTPADSZ\" ; break ; case DT_MOVEENT : tmp = \"DT_MOVEENT\" ; break ; case DT_MOVESZ : tmp = \"DT_MOVESZ\" ; break ; case DT_FEATURE_1 : tmp = \"DT_FEATURE_1\" ; break ; case DT_POSFLAG_1 : tmp = \"DT_POSFLAG_1\" ; break ; case DT_SYMINSZ : tmp = \"DT_SYMINSZ\" ; break ; case DT_SYMINENT : tmp = \"DT_SYMINENT\" ; break ; case DT_ADDRRNGLO : tmp = \"DT_ADDRRNGLO\" ; break ; case DT_GNU_HASH : tmp = \"DT_GNU_HASH\" ; break ; case DT_TLSDESC_PLT : tmp = \"DT_TLSDESC_PLT\" ; break ; case DT_TLSDESC_GOT : tmp = \"DT_TLSDESC_GOT\" ; break ; case DT_GNU_CONFLICT : tmp = \"DT_GNU_CONFLICT\" ; break ; case DT_GNU_LIBLIST : tmp = \"DT_GNU_LIBLIST\" ; break ; case DT_CONFIG : tmp = \"DT_CONFIG\" ; break ; case DT_DEPAUDIT : tmp = \"DT_DEPAUDIT\" ; break ; case DT_AUDIT : tmp = \"DT_AUDIT\" ; break ; case DT_PLTPAD : tmp = \"DT_PLTPAD\" ; break ; case DT_MOVETAB : tmp = \"DT_MOVETAB\" ; break ; case DT_SYMINFO : tmp = \"DT_SYMINFO\" ; break ; case DT_VERSYM : tmp = \"DT_VERSYM\" ; break ; case DT_RELACOUNT : tmp = \"DT_RELACOUNT\" ; break ; case DT_RELCOUNT : tmp = \"DT_RELCOUNT\" ; break ; case DT_FLAGS_1 : tmp = \"DT_FLAGS_1\" ; switch ( dyn [ i ] . d_un . d_val ) { case DF_1_PIE : snprintf ( value , 50 , \"Flags:<S2SV_blank>%s\" , \"PIE\" ) ; break ; default : snprintf ( value , 50 , \"Flags:<S2SV_blank>%d\" , dyn [ i ] . d_un . d_val ) ; break ; } break ; case DT_VERDEF : tmp = \"DT_VERDEF\" ; break ; case DT_VERDEFNUM : tmp = \"DT_VERDEFNUM\" ; break ; case DT_VERNEED : tmp = \"DT_VERNEED\" ; break ; case DT_VERNEEDNUM : tmp = \"DT_VERNEEDNUM\" ; break ; default : break ; } PRINT_DYN ( dyn [ i ] . d_tag , tmp , value ) ; } } if ( MODE == ELFCLASS64 ) { Elf64_Ehdr * ehdr ; ehdr = ( Elf64_Ehdr * ) elf_map ; INFO ( \"ELF<S2SV_blank>Header\\\\n\" ) ; switch ( ehdr -> e_type ) { case ET_NONE : tmp = \"An<S2SV_blank>unknown<S2SV_blank>type\" ; break ; case ET_REL : tmp = \"A<S2SV_blank>relocatable<S2SV_blank>file\" ; break ; case ET_EXEC : tmp = \"An<S2SV_blank>executable<S2SV_blank>file\" ; break ; case ET_DYN : tmp = \"A<S2SV_blank>shared<S2SV_blank>object\" ; break ; case ET_CORE : tmp = \"A<S2SV_blank>core<S2SV_blank>file\" ; break ; default : tmp = \"An<S2SV_blank>unknown<S2SV_blank>type\" ; break ; } PRINT_HEADER_EXP ( \"e_type:\" , ehdr -> e_type , tmp ) ; switch ( ehdr -> e_type ) { case EM_NONE : tmp = \"An<S2SV_blank>unknown<S2SV_blank>machine\" ; break ; case EM_M32 : tmp = \"AT&T<S2SV_blank>WE<S2SV_blank>32100\" ; break ; case EM_SPARC : tmp = \"Sun<S2SV_blank>Microsystems<S2SV_blank>SPARC\" ; break ; case EM_386 : tmp = \"Intel<S2SV_blank>80386\" ; break ; case EM_68K : tmp = \"Motorola<S2SV_blank>68000\" ; break ; case EM_88K : tmp = \"Motorola<S2SV_blank>88000\" ; break ; case EM_860 : tmp = \"Intel<S2SV_blank>80860\" ; break ; case EM_MIPS : tmp = \"MIPS<S2SV_blank>RS3000<S2SV_blank>(big-endian<S2SV_blank>only)\" ; break ; case EM_PARISC : tmp = \"HP/PA\" ; break ; case EM_SPARC32PLUS : tmp = \"SPARC<S2SV_blank>with<S2SV_blank>enhanced<S2SV_blank>instruction<S2SV_blank>set\" ; break ; case EM_PPC : tmp = \"PowerPC\" ; break ; case EM_PPC64 : tmp = \"PowerPC<S2SV_blank>64-bit\" ; break ; case EM_S390 : tmp = \"IBM<S2SV_blank>S/390\" ; break ; case EM_ARM : tmp = \"Advanced<S2SV_blank>RISC<S2SV_blank>Machines\" ; break ; case EM_SH : tmp = \"Renesas<S2SV_blank>SuperH\" ; break ; case EM_SPARCV9 : tmp = \"SPARC<S2SV_blank>v9<S2SV_blank>64-bit\" ; break ; case EM_IA_64 : tmp = \"Intel<S2SV_blank>Itanium\" ; break ; case EM_X86_64 : tmp = \"AMD<S2SV_blank>x86-64\" ; break ; case EM_VAX : tmp = \"DEC<S2SV_blank>Vax\" ; break ; default : tmp = \"An<S2SV_blank>unknown<S2SV_blank>machine\" ; break ; } PRINT_HEADER_EXP ( \"e_machine:\" , ehdr -> e_machine , tmp ) ; switch ( ehdr -> e_version ) { case EV_NONE : tmp = \"Invalid<S2SV_blank>version\" ; break ; case EV_CURRENT : tmp = \"Current<S2SV_blank>version\" ; break ; default : tmp = \"Known<S2SV_blank>version\" ; break ; } PRINT_HEADER_EXP ( \"e_version:\" , ehdr -> e_version , tmp ) ; PRINT_HEADER ( \"e_entry:\" , ehdr -> e_entry ) ; PRINT_HEADER ( \"e_phoff:\" , ehdr -> e_phoff ) ; PRINT_HEADER ( \"e_shoff:\" , ehdr -> e_shoff ) ; PRINT_HEADER ( \"e_flags:\" , ehdr -> e_flags ) ; PRINT_HEADER ( \"e_ehsize:\" , ehdr -> e_ehsize ) ; PRINT_HEADER ( \"e_phentsize:\" , ehdr -> e_phentsize ) ; PRINT_HEADER ( \"e_phnum:\" , ehdr -> e_phnum ) ; PRINT_HEADER ( \"e_shentsize:\" , ehdr -> e_shentsize ) ; PRINT_HEADER ( \"e_shentsize:\" , ehdr -> e_shentsize ) ; PRINT_HEADER ( \"e_shstrndx:\" , ehdr -> e_shstrndx ) ; Elf64_Shdr * shdr ; Elf64_Phdr * phdr ; Elf64_Shdr shstrtab ; shdr = ( Elf64_Shdr * ) & elf_map [ ehdr -> e_shoff ] ; phdr = ( Elf64_Phdr * ) & elf_map [ ehdr -> e_phoff ] ; shstrtab = shdr [ ehdr -> e_shstrndx ] ; INFO ( \"Section<S2SV_blank>Header<S2SV_blank>Table\\\\n\" ) ; PRINT_SECTION_TITLE ( \"Nr\" , \"Name\" , \"Type\" , \"Addr\" , \"Off\" , \"Size\" , \"Es\" , \"Flg\" , \"Lk\" , \"Inf\" , \"Al\" ) ; for ( int i = 0 ; i < ehdr -> e_shnum ; i ++ ) { name = elf_map + shstrtab . sh_offset + shdr [ i ] . sh_name ; <S2SV_StartBug> <S2SV_EndBug> switch ( shdr [ i ] . sh_type ) { case SHT_NULL : tmp = \"SHT_NULL\" ; break ; case SHT_PROGBITS : tmp = \"SHT_PROGBITS\" ; break ; case SHT_SYMTAB : tmp = \"SHT_SYMTAB\" ; break ; case SHT_STRTAB : tmp = \"SHT_STRTAB\" ; break ; case SHT_RELA : tmp = \"SHT_RELA\" ; break ; case SHT_HASH : tmp = \"SHT_HASH\" ; break ; case SHT_DYNAMIC : tmp = \"SHT_DYNAMIC\" ; break ; case SHT_NOTE : tmp = \"SHT_NOTE\" ; break ; case SHT_NOBITS : tmp = \"SHT_NOBITS\" ; break ; case SHT_REL : tmp = \"SHT_REL\" ; break ; case SHT_SHLIB : tmp = \"SHT_SHLIB\" ; break ; case SHT_DYNSYM : tmp = \"SHT_DYNSYM\" ; break ; case SHT_LOPROC : tmp = \"SHT_LOPROC\" ; break ; case SHT_HIPROC : tmp = \"SHT_HIPROC\" ; break ; case SHT_LOUSER : tmp = \"SHT_LOUSER\" ; break ; case SHT_HIUSER : tmp = \"SHT_HIUSER\" ; break ; default : break ; } if ( strlen ( name ) > 15 ) { strcpy ( & name [ 15 - 6 ] , \"[...]\" ) ; } strcpy ( flag , \"<S2SV_blank><S2SV_blank><S2SV_blank>\" ) ; flag2str_sh ( shdr [ i ] . sh_flags , flag ) ; PRINT_SECTION ( i , name , tmp , shdr [ i ] . sh_addr , shdr [ i ] . sh_offset , shdr [ i ] . sh_size , shdr [ i ] . sh_entsize , flag , shdr [ i ] . sh_link , shdr [ i ] . sh_info , shdr [ i ] . sh_addralign ) ; } INFO ( \"Program<S2SV_blank>Header<S2SV_blank>Table\\\\n\" ) ; PRINT_PROGRAM_TITLE ( \"Nr\" , \"Type\" , \"Offset\" , \"Virtaddr\" , \"Physaddr\" , \"Filesiz\" , \"Memsiz\" , \"Flg\" , \"Align\" ) ; for ( int i = 0 ; i < ehdr -> e_phnum ; i ++ ) { switch ( phdr [ i ] . p_type ) { case PT_NULL : tmp = \"PT_NULL\" ; break ; case PT_LOAD : tmp = \"PT_LOAD\" ; break ; case PT_DYNAMIC : tmp = \"PT_DYNAMIC\" ; break ; case PT_INTERP : tmp = \"PT_INTERP\" ; break ; case PT_NOTE : tmp = \"PT_NOTE\" ; break ; case PT_SHLIB : tmp = \"PT_SHLIB\" ; break ; case PT_PHDR : tmp = \"PT_PHDR\" ; break ; case PT_LOPROC : tmp = \"PT_LOPROC\" ; break ; case PT_HIPROC : tmp = \"PT_HIPROC\" ; break ; case PT_GNU_STACK : tmp = \"PT_GNU_STACK\" ; break ; default : break ; } strcpy ( flag , \"<S2SV_blank><S2SV_blank><S2SV_blank>\" ) ; flag2str ( phdr [ i ] . p_flags , flag ) ; PRINT_PROGRAM ( i , tmp , phdr [ i ] . p_offset , phdr [ i ] . p_vaddr , phdr [ i ] . p_paddr , phdr [ i ] . p_filesz , phdr [ i ] . p_memsz , flag , phdr [ i ] . p_align ) ; } INFO ( \"Section<S2SV_blank>to<S2SV_blank>segment<S2SV_blank>mapping\\\\n\" ) ; for ( int i = 0 ; i < ehdr -> e_phnum ; i ++ ) { printf ( \"<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[%2d]\" , i ) ; for ( int j = 0 ; j < ehdr -> e_shnum ; j ++ ) { name = elf_map + shstrtab . sh_offset + shdr [ j ] . sh_name ; if ( shdr [ j ] . sh_addr >= phdr [ i ] . p_vaddr && shdr [ j ] . sh_addr + shdr [ j ] . sh_size <= phdr [ i ] . p_vaddr + phdr [ i ] . p_memsz && shdr [ j ] . sh_type != SHT_NULL ) { if ( shdr [ j ] . sh_flags >> 1 & 0x1 ) { printf ( \"<S2SV_blank>%s\" , name ) ; } } } printf ( \"\\\\n\" ) ; } INFO ( \"Dynamic<S2SV_blank>link<S2SV_blank>information\\\\n\" ) ; int dynstr ; int dynamic ; Elf64_Dyn * dyn ; for ( int i = 0 ; i < ehdr -> e_shnum ; i ++ ) { name = elf_map + shstrtab . sh_offset + shdr [ i ] . sh_name ; if ( ! strcmp ( name , \".dynstr\" ) ) { dynstr = i ; } if ( ! strcmp ( name , \".dynamic\" ) ) { dynamic = i ; } } char value [ 50 ] ; name = \"\" ; dyn = ( Elf64_Dyn * ) & elf_map [ shdr [ dynamic ] . sh_offset ] ; count = shdr [ dynamic ] . sh_size / sizeof ( Elf64_Dyn ) ; INFO ( \"Dynamic<S2SV_blank>section<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>0x%x<S2SV_blank>contains<S2SV_blank>%d<S2SV_blank>entries\\\\n\" , shdr [ dynamic ] . sh_offset , count ) ; PRINT_DYN_TITLE ( \"Tag\" , \"Type\" , \"Name/Value\" ) ; for ( int i = 0 ; i < count ; i ++ ) { tmp = \"\" ; memset ( value , 0 , 50 ) ; snprintf ( value , 50 , \"0x%x\" , dyn [ i ] . d_un . d_val ) ; switch ( dyn [ i ] . d_tag ) { case DT_NULL : tmp = \"DT_NULL\" ; break ; case DT_NEEDED : tmp = \"DT_NEEDED\" ; name = elf_map + shdr [ dynstr ] . sh_offset + dyn [ i ] . d_un . d_val ; snprintf ( value , 50 , \"Shared<S2SV_blank>library:<S2SV_blank>[%s]\" , name ) ; break ; case DT_PLTRELSZ : tmp = \"DT_PLTRELSZ\" ; break ; case DT_PLTGOT : tmp = \"DT_PLTGOT\" ; break ; case DT_HASH : tmp = \"DT_HASH\" ; break ; case DT_STRTAB : tmp = \"DT_STRTAB\" ; break ; case DT_SYMTAB : tmp = \"DT_SYMTAB\" ; break ; case DT_RELA : tmp = \"DT_RELA\" ; break ; case DT_RELASZ : tmp = \"DT_RELASZ\" ; break ; case DT_RELAENT : tmp = \"DT_RELAENT\" ; break ; case DT_STRSZ : tmp = \"DT_STRSZ\" ; break ; case DT_SYMENT : tmp = \"DT_SYMENT\" ; break ; case DT_INIT : tmp = \"DT_INIT\" ; break ; case DT_FINI : tmp = \"DT_FINI\" ; break ; case DT_SONAME : tmp = \"DT_SONAME\" ; break ; case DT_RPATH : tmp = \"DT_RPATH\" ; break ; case DT_SYMBOLIC : tmp = \"DT_SYMBOLIC\" ; break ; case DT_REL : tmp = \"DT_REL\" ; break ; case DT_RELSZ : tmp = \"DT_RELSZ\" ; break ; case DT_RELENT : tmp = \"DT_RELENT\" ; break ; case DT_PLTREL : tmp = \"DT_PLTREL\" ; break ; case DT_DEBUG : tmp = \"DT_DEBUG\" ; break ; case DT_TEXTREL : tmp = \"DT_TEXTREL\" ; break ; case DT_JMPREL : tmp = \"DT_JMPREL\" ; break ; case DT_BIND_NOW : tmp = \"DT_BIND_NOW\" ; break ; case DT_INIT_ARRAY : tmp = \"DT_INIT_ARRAY\" ; break ; case DT_FINI_ARRAY : tmp = \"DT_FINI_ARRAY\" ; break ; case DT_INIT_ARRAYSZ : tmp = \"DT_INIT_ARRAYSZ\" ; break ; case DT_FINI_ARRAYSZ : tmp = \"DT_FINI_ARRAYSZ\" ; break ; case DT_RUNPATH : tmp = \"DT_RUNPATH\" ; break ; case DT_FLAGS : tmp = \"DT_FLAGS\" ; snprintf ( value , 50 , \"Flags:<S2SV_blank>%d\" , dyn [ i ] . d_un . d_val ) ; break ; case DT_ENCODING : tmp = \"DT_ENCODING\" ; break ; case DT_PREINIT_ARRAYSZ : tmp = \"DT_PREINIT_ARRAYSZ\" ; break ; case DT_SYMTAB_SHNDX : tmp = \"DT_SYMTAB_SHNDX\" ; break ; case DT_NUM : tmp = \"DT_NUM\" ; break ; case DT_LOOS : tmp = \"DT_LOOS\" ; break ; case DT_HIOS : tmp = \"DT_HIOS\" ; break ; case DT_LOPROC : tmp = \"DT_LOPROC\" ; break ; case DT_HIPROC : tmp = \"DT_HIPROC\" ; break ; case DT_PROCNUM : tmp = \"DT_LOPROC\" ; break ; case DT_VALRNGLO : tmp = \"DT_VALRNGLO\" ; break ; case DT_GNU_PRELINKED : tmp = \"DT_GNU_PRELINKED\" ; break ; case DT_GNU_CONFLICTSZ : tmp = \"DT_GNU_CONFLICTSZ\" ; break ; case DT_GNU_LIBLISTSZ : tmp = \"DT_GNU_LIBLISTSZ\" ; break ; case DT_CHECKSUM : tmp = \"DT_CHECKSUM\" ; break ; case DT_PLTPADSZ : tmp = \"DT_PLTPADSZ\" ; break ; case DT_MOVEENT : tmp = \"DT_MOVEENT\" ; break ; case DT_MOVESZ : tmp = \"DT_MOVESZ\" ; break ; case DT_FEATURE_1 : tmp = \"DT_FEATURE_1\" ; break ; case DT_POSFLAG_1 : tmp = \"DT_POSFLAG_1\" ; break ; case DT_SYMINSZ : tmp = \"DT_SYMINSZ\" ; break ; case DT_SYMINENT : tmp = \"DT_SYMINENT\" ; break ; case DT_ADDRRNGLO : tmp = \"DT_ADDRRNGLO\" ; break ; case DT_GNU_HASH : tmp = \"DT_GNU_HASH\" ; break ; case DT_TLSDESC_PLT : tmp = \"DT_TLSDESC_PLT\" ; break ; case DT_TLSDESC_GOT : tmp = \"DT_TLSDESC_GOT\" ; break ; case DT_GNU_CONFLICT : tmp = \"DT_GNU_CONFLICT\" ; break ; case DT_GNU_LIBLIST : tmp = \"DT_GNU_LIBLIST\" ; break ; case DT_CONFIG : tmp = \"DT_CONFIG\" ; break ; case DT_DEPAUDIT : tmp = \"DT_DEPAUDIT\" ; break ; case DT_AUDIT : tmp = \"DT_AUDIT\" ; break ; case DT_PLTPAD : tmp = \"DT_PLTPAD\" ; break ; case DT_MOVETAB : tmp = \"DT_MOVETAB\" ; break ; case DT_SYMINFO : tmp = \"DT_SYMINFO\" ; break ; case DT_VERSYM : tmp = \"DT_VERSYM\" ; break ; case DT_RELACOUNT : tmp = \"DT_RELACOUNT\" ; break ; case DT_RELCOUNT : tmp = \"DT_RELCOUNT\" ; break ; case DT_FLAGS_1 : tmp = \"DT_FLAGS_1\" ; switch ( dyn [ i ] . d_un . d_val ) { case DF_1_PIE : snprintf ( value , 50 , \"Flags:<S2SV_blank>%s\" , \"PIE\" ) ; break ; default : snprintf ( value , 50 , \"Flags:<S2SV_blank>%d\" , dyn [ i ] . d_un . d_val ) ; break ; } break ; case DT_VERDEF : tmp = \"DT_VERDEF\" ; break ; case DT_VERDEFNUM : tmp = \"DT_VERDEFNUM\" ; break ; case DT_VERNEED : tmp = \"DT_VERNEED\" ; break ; case DT_VERNEEDNUM : tmp = \"DT_VERNEEDNUM\" ; break ; default : break ; } PRINT_DYN ( dyn [ i ] . d_tag , tmp , value ) ; } } return 0 ; }", "target": "<S2SV_ModStart> . sh_name ; if ( validated_offset ( name , elf_map , elf_map + st . st_size ) ) { ERROR ( \"Corrupt<S2SV_blank>file<S2SV_blank>format\\\\n\" ) ; return - 1 ; } <S2SV_ModStart> . sh_name ; if ( validated_offset ( name , elf_map , elf_map + st . st_size ) ) { ERROR ( \"Corrupt<S2SV_blank>file<S2SV_blank>format\\\\n\" ) ; return - 1 ; }"}
