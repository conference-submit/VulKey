{"INPUT": "// bug_start\npublic OutputStream create(GridGgfsPath path,int bufSize,boolean overwrite,@Nullable GridUuid affKey,int replication,long blockSize,@Nullable Map<String,String> props) throws GridException ;\n// bug_end\n"}
{"INPUT": "private void createOrReplaceViewQuery(DBRProgressMonitor monitor,List<DBEPersistAction> actions,DBECommandComposite<OracleView,PropertyHandler> command) throws DBException {\n  final OracleView view=command.getObject();\n// bug_start\n  boolean hasComment=command.getProperty(\"comment\") != null;\n// bug_end\n  if (!hasComment || command.getProperties().size() > 1) {\n    String viewText=view.getViewText().trim();\n    while (viewText.endsWith(\";\")) {\n      viewText=viewText.substring(0,viewText.length() - 1);\n    }\n    actions.add(new SQLDatabasePersistAction(\"Create view\",viewText));\n  }\n// bug_start\n  String comment=view.getComment(monitor);\n  if (!CommonUtils.isEmpty(comment)) {\n    actions.add(new SQLDatabasePersistAction(\"Comment table\",\"COMMENT ON TABLE \" + view.getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS '\"+ view.getComment()+ \"'\"));\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public DisplayDeviceInfo getDisplayDeviceInfoLocked(){\n  if (mInfo == null) {\n    mInfo=new DisplayDeviceInfo();\n    mInfo.name=getContext().getResources().getString(com.android.internal.R.string.display_manager_built_in_display_name);\n    mInfo.width=640;\n    mInfo.height=480;\n    mInfo.refreshRate=60;\n    mInfo.densityDpi=DisplayMetrics.DENSITY_DEFAULT;\n    mInfo.xDpi=160;\n    mInfo.yDpi=160;\n// bug_start\n    mInfo.flags=DisplayDeviceInfo.FLAG_DEFAULT_DISPLAY | DisplayDeviceInfo.FLAG_SUPPORTS_SECURE_VIDEO_OUTPUT;\n// bug_end\n    mInfo.touch=DisplayDeviceInfo.TOUCH_NONE;\n  }\n  return mInfo;\n}\n"}
{"INPUT": "public void dump(PrintWriter pw){\n  int N=mStatusIcons.getChildCount();\n// bug_start\n  pw.println(\"  system icons: \" + N);\n// bug_end\n  for (int i=0; i < N; i++) {\n    StatusBarIconView ic=(StatusBarIconView)mStatusIcons.getChildAt(i);\n    pw.println(\"    [\" + i + \"] icon=\"+ ic);\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override protected void toXContent(XContentBuilder builder,boolean includeDefaults) throws IOException {\n  builder.field(\"analyzer\",this.analyzer.getValue().name());\n  if (Objects.equals(this.analyzer.getValue().name(),this.searchAnalyzer.getValue().name()) == false) {\n    builder.field(\"search_analyzer\",this.searchAnalyzer.getValue().name());\n  }\n  builder.field(this.preserveSeparators.name,this.preserveSeparators.getValue());\n  builder.field(this.preservePosInc.name,this.preservePosInc.getValue());\n  builder.field(this.maxInputLength.name,this.maxInputLength.getValue());\n  if (this.contexts.getValue() != null) {\n    builder.startArray(this.contexts.name);\n    this.contexts.getValue().toXContent(builder,ToXContent.EMPTY_PARAMS);\n    builder.endArray();\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public static WebApp createRootApp(){\n  RootWebApp app=WebAppGroup.root();\n  app.getRouter().generic(new AppHandler());\n  String menufile=\"menu.yaml\";\n  String firstMenuFile=Conf.configPath() + \"/\" + menufile;\n  String defaultMenuFile=Conf.configPathDefault() + \"/\" + menufile;\n  final Res menuRes=Res.from(menufile,true,firstMenuFile,defaultMenuFile).trackChanges();\n  final WebApp rootApp=app;\n  menuRes.getChangeListeners().add(new Runnable(){\n    @Override public void run(){\n      if (menuRes.exists()) {\n        Object menuData=YAML.parse(menuRes.getContent(),Object.class);\n        AppMenu menu=AppMenu.from(menuData);\n        rootApp.setMenu(menu);\n      }\n    }\n  }\n);\n// bug_start\n  menuRes.getBytes();\n// bug_end\n  String appfile=\"app.yaml\";\n  String firstAppFile=Conf.configPath() + \"/\" + appfile;\n  String defaultAppFile=Conf.configPathDefault() + \"/\" + appfile;\n  final Res confRes=Res.from(appfile,true,firstAppFile,defaultAppFile).trackChanges();\n  confRes.getChangeListeners().add(new Runnable(){\n    @Override public void run(){\n      if (confRes.exists()) {\n        Map<String,Object> conf=YAML.parseMap(confRes.getContent());\n        Conf.reset();\n        rootApp.getConfig().clear();\n        for (        Entry<String,Object> e : conf.entrySet()) {\n          String key=e.getKey();\n          Object value=e.getValue();\n          Log.info(\"Configuring\",key,value);\n          Conf.set(key,value);\n          rootApp.getConfig().put(key,value);\n        }\n      }\n    }\n  }\n);\n// bug_start\n  confRes.getBytes();\n// bug_end\n  return app;\n}\n"}
{"INPUT": "public static void validateTransition(IndexMetaData idxMeta,Step.StepKey currentStepKey,Step.StepKey newStepKey,PolicyStepsRegistry stepRegistry){\n  String indexName=idxMeta.getIndex().getName();\n  Settings indexSettings=idxMeta.getSettings();\n  String indexPolicySetting=LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexSettings);\n  if (Strings.isNullOrEmpty(indexPolicySetting)) {\n    throw new IllegalArgumentException(\"index [\" + indexName + \"] is not associated with an Index Lifecycle Policy\");\n  }\n  LifecycleExecutionState lifecycleState=LifecycleExecutionState.fromIndexMetadata(idxMeta);\n// bug_start\n  if (currentStepKey != null && currentStepKey.equals(LifecycleExecutionState.getCurrentStepKey(lifecycleState)) == false) {\n    throw new IllegalArgumentException(\"index [\" + indexName + \"] is not on current step [\"+ currentStepKey+ \"]\");\n// bug_end\n  }\n  if (stepRegistry.stepExists(indexPolicySetting,newStepKey) == false) {\n    throw new IllegalArgumentException(\"step [\" + newStepKey + \"] for index [\"+ idxMeta.getIndex().getName()+ \"] with policy [\"+ indexPolicySetting+ \"] does not exist\");\n  }\n}\n"}
{"INPUT": "private boolean isSingleValueMap(MethodParameter parameter){\n  if (!MultiValueMap.class.isAssignableFrom(parameter.getParameterType())) {\n    ResolvableType[] genericTypes=ResolvableType.forMethodParameter(parameter).getGenerics();\n    if (genericTypes.length == 2) {\n// bug_start\n      Class<?> declaredClass=genericTypes[1].getRawClass();\n      return (declaredClass == null || !List.class.isAssignableFrom(declaredClass));\n// bug_end\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "// bug_start\n@Override protected void overrideOfflineServerConf(Configuration configuration){\n// bug_end\n  configuration.setProperty(CommonConstants.Server.CONFIG_OF_REALTIME_OFFHEAP_ALLOCATION,\"true\");\n  configuration.setProperty(CommonConstants.Server.CONFIG_OF_CONSUMER_DIR,CONSUMER_DIRECTORY);\n}\n"}
{"INPUT": "// bug_start\n@Override protected PaymentTransactionInfoPlugin doPluginOperation() throws PaymentPluginApiException {\n// bug_end\n  logger.debug(\"Starting CAPTURE for payment {} ({} {})\",directPaymentStateContext.getDirectPaymentId(),directPaymentStateContext.getAmount(),directPaymentStateContext.getCurrency());\n  return plugin.capturePayment(directPaymentStateContext.getAccount().getId(),directPaymentStateContext.getDirectPaymentId(),directPaymentStateContext.getTransactionPaymentId(),directPaymentStateContext.getPaymentMethodId(),directPaymentStateContext.getAmount(),directPaymentStateContext.getCurrency(),directPaymentStateContext.getProperties(),directPaymentStateContext.getCallContext());\n}\n"}
{"INPUT": "@Test public void checkCodeAssistAfterMoveItem(){\n  projectExplorer.openItemByPath(pathToPackageInChePrefix + \"/org/eclipse/qa/examples/AppController.java\");\n  loader.waitOnClosed();\n// bug_start\n  editor.waitActiveEditor();\n// bug_end\n  editor.setCursorToLine(31);\n  editor.typeTextIntoEditor(Keys.TAB.toString());\n  loader.waitOnClosed();\n  editor.typeTextIntoEditor(\"A5 a = new A5();\");\n  loader.waitOnClosed();\n  editor.waitTextIntoEditor(\"A5 a = new A5();\");\n  editor.waitMarkerInPosition(ERROR_MARKER,31);\n  editor.typeTextIntoEditor(Keys.END.toString());\n  editor.launchPropositionAssistPanel();\n  loader.waitOnClosed();\n  editor.waitTextIntoFixErrorProposition(\"Import 'A5' (r)\");\n  editor.enterTextIntoFixErrorPropByDoubleClick(\"Import 'A5' (r)\");\n  loader.waitOnClosed();\n  editor.waitTextIntoEditor(\"import r.A5;\");\n  editor.waitMarkerDisappears(ERROR_MARKER,33);\n  projectExplorer.selectItem(pathToPackageInChePrefix + \"/r/A5.java\");\n  projectExplorer.launchRefactorMoveByKeyboard();\n  refactor.waitMoveItemFormIsOpen();\n  refactor.clickOnExpandIconTree(PROJECT_NAME);\n  refactor.clickOnExpandIconTree(\"/src/main/java\");\n  refactor.chooseDestinationForItem(\"p1\");\n  refactor.clickOkButtonRefactorForm();\n  refactor.waitMoveItemFormIsClosed();\n  loader.waitOnClosed();\n  projectExplorer.waitItem(pathToPackageInChePrefix + \"/p1/A5.java\");\n  projectExplorer.waitDisappearItemByPath(pathToPackageInChePrefix + \"/r/A5.java\");\n  editor.waitTextIntoEditor(\"import p1.A5;\");\n  editor.setCursorToLine(16);\n  editor.deleteCurrentLine();\n  loader.waitOnClosed();\n  editor.waitMarkerInPosition(ERROR_MARKER,32);\n// bug_start\n  editor.setCursorToDefinedLineAndChar(32,5);\n// bug_end\n  editor.launchPropositionAssistPanel();\n  loader.waitOnClosed();\n  editor.waitTextIntoFixErrorProposition(\"Import 'A5' (p1)\");\n  editor.enterTextIntoFixErrorPropByEnter(\"Import 'A5' (p1)\");\n  editor.waitTextIntoEditor(\"import p1.A5;\");\n}\n"}
{"INPUT": "// bug_start\nApkGenrule(BuildRuleParams params,SourcePathResolver resolver,SourcePathRuleFinder ruleFinder,List<SourcePath> srcs,Optional<Arg> cmd,Optional<Arg> bash,Optional<Arg> cmdExe,SourcePath apk){\n  super(params,resolver,srcs,cmd,bash,cmdExe,params.getBuildTarget().getShortNameAndFlavorPostfix() + \".apk\");\n// bug_end\n  Preconditions.checkState(apk instanceof BuildTargetSourcePath);\n  this.apk=(BuildTargetSourcePath)apk;\n  BuildRule rule=ruleFinder.getRuleOrThrow(this.apk);\n  Preconditions.checkState(rule instanceof InstallableApk);\n  this.installableApk=(InstallableApk)rule;\n}\n"}
{"INPUT": "// bug_start\n@SuppressWarnings(\"TypeMayBeWeakened\") private Thread runCacheOperations(Ignite node,TransactionIsolation isolation,long timeout,final int keys){\n// bug_end\n  Thread t=new Thread(){\n    @Override public void run(){\n      while (run) {\n        TreeMap<Integer,String> vals=generateValues(keys);\n        try {\n          try (Transaction tx=node.transactions().txStart(TransactionConcurrency.OPTIMISTIC,isolation,timeout,keys)){\n            IgniteCache<Object,Object> cache=node.cache(CACHE_NAME);\n            if (ThreadLocalRandom.current().nextDouble(1) < 0.65)             cache.putAll(vals);\n else             cache.removeAll(vals.keySet());\n            tx.commit();\n          }\n catch (          Exception e) {\n            U.error(log(),\"Failed cache operation.\",e);\n          }\n          U.sleep(100);\n        }\n catch (        Exception e) {\n          U.error(log(),\"Failed unlock.\",e);\n        }\n      }\n    }\n  }\n;\n  t.start();\n  return t;\n}\n"}
{"INPUT": "@Override public void postProcessBeanFactory(final ConfigurableListableBeanFactory beanFactory){\n  PlaceholderResolved placeholderResolved=new PlaceholderResolved(beanFactory);\n  getZkConfig().setServerLists(placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getServerLists()));\n  getZkConfig().setNamespace(placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getNamespace()));\n  getZkConfig().setBaseSleepTimeMilliseconds(Integer.parseInt(placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getBaseSleepTimeMilliseconds())));\n  getZkConfig().setMaxSleepTimeMilliseconds(Integer.parseInt(placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getMaxSleepTimeMilliseconds())));\n  getZkConfig().setMaxRetries(Integer.parseInt(placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getMaxRetries())));\n  String sessionTimeoutMilliseconds=placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getSessionTimeoutMilliseconds());\n  if (!Strings.isNullOrEmpty(sessionTimeoutMilliseconds)) {\n    getZkConfig().setSessionTimeoutMilliseconds(Integer.parseInt(sessionTimeoutMilliseconds));\n  }\n  String connectionTimeoutMilliseconds=placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getConnectionTimeoutMilliseconds());\n  if (!Strings.isNullOrEmpty(connectionTimeoutMilliseconds)) {\n    getZkConfig().setConnectionTimeoutMilliseconds(Integer.parseInt(connectionTimeoutMilliseconds));\n  }\n  String digest=placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getDigest());\n  if (!Strings.isNullOrEmpty(digest)) {\n    getZkConfig().setDigest(digest);\n  }\n// bug_start\n// bug_end\n  String localPropertiesPath=placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getLocalPropertiesPath());\n  if (!Strings.isNullOrEmpty(localPropertiesPath)) {\n    getZkConfig().setLocalPropertiesPath(localPropertiesPath);\n  }\n  String overwrite=placeholderResolved.getResolvePlaceholderText(springZookeeperConfigurationDto.getOverwrite());\n  if (!Strings.isNullOrEmpty(overwrite)) {\n    getZkConfig().setOverwrite(Boolean.valueOf(overwrite));\n  }\n  init();\n}\n"}
{"INPUT": "public final void setState(@State int state){\n// bug_start\n// bug_end\n  if (mViewRef == null) {\n    if (state == STATE_COLLAPSED || state == STATE_EXPANDED || (mHideable && state == STATE_HIDDEN)) {\n      mState=state;\n    }\n    return;\n  }\n  V child=mViewRef.get();\n  if (child == null) {\n    return;\n  }\n  int top;\n  if (state == STATE_COLLAPSED) {\n    top=mMaxOffset;\n  }\n else   if (state == STATE_EXPANDED) {\n    top=mMinOffset;\n  }\n else   if (mHideable && state == STATE_HIDDEN) {\n    top=mParentHeight;\n  }\n else {\n    throw new IllegalArgumentException(\"Illegal state argument: \" + state);\n  }\n  setStateInternal(STATE_SETTLING);\n  if (mViewDragHelper.smoothSlideViewTo(child,child.getLeft(),top)) {\n    ViewCompat.postOnAnimation(child,new SettleRunnable(child,state));\n  }\n}\n"}
{"INPUT": "@Test public void testTickerAdapter() throws IOException {\n  InputStream is=Bitcoin24TickerJSONTest.class.getResourceAsStream(\"/marketdata/example-ticker-data.json\");\n  ObjectMapper mapper=new ObjectMapper();\n  Bitcoin24Ticker Bitcoin24Ticker=mapper.readValue(is,Bitcoin24Ticker.class);\n  Ticker ticker=Bitcoin24Adapters.adaptTicker(Bitcoin24Ticker,\"BTC\",\"USD\");\n  assertEquals(\"last should be USD 30.50001\",ticker.getLast().toString(),\"USD 30.50001\");\n  assertEquals(\"low should be USD 30.00043\",ticker.getLow().toString(),\"USD 30.00043\");\n  assertEquals(\"high should be USD 34.39799\",ticker.getHigh().toString(),\"USD 34.39799\");\n// bug_start\n// bug_end\n  assertEquals(\"volume should be 12\",ticker.getVolume(),new BigDecimal(\"12\"));\n  assertEquals(\"Tradable Identifier should be BTC\",ticker.getTradableIdentifier(),\"BTC\");\n}\n"}
{"INPUT": "UriComponentsBuilder adaptFromForwardedHeaders(HttpHeaders headers){\n  String forwardedHeader=headers.getFirst(\"Forwarded\");\n  if (StringUtils.hasText(forwardedHeader)) {\n    String forwardedToUse=StringUtils.tokenizeToStringArray(forwardedHeader,\",\")[0];\n    Matcher matcher=FORWARDED_HOST_PATTERN.matcher(forwardedToUse);\n    if (matcher.find()) {\n      host(matcher.group(1).trim());\n    }\n    matcher=FORWARDED_PROTO_PATTERN.matcher(forwardedToUse);\n    if (matcher.find()) {\n      scheme(matcher.group(1).trim());\n    }\n  }\n else {\n    String hostHeader=headers.getFirst(\"X-Forwarded-Host\");\n    if (StringUtils.hasText(hostHeader)) {\n      String hostToUse=StringUtils.tokenizeToStringArray(hostHeader,\",\")[0];\n// bug_start\n      String[] hostAndPort=StringUtils.split(hostToUse,\":\");\n      if (hostAndPort != null) {\n        host(hostAndPort[0]);\n        port(Integer.parseInt(hostAndPort[1]));\n// bug_end\n      }\n else {\n        host(hostToUse);\n        port(null);\n      }\n    }\n    String portHeader=headers.getFirst(\"X-Forwarded-Port\");\n    if (StringUtils.hasText(portHeader)) {\n      port(Integer.parseInt(StringUtils.tokenizeToStringArray(portHeader,\",\")[0]));\n    }\n    String protocolHeader=headers.getFirst(\"X-Forwarded-Proto\");\n    if (StringUtils.hasText(protocolHeader)) {\n      scheme(StringUtils.tokenizeToStringArray(protocolHeader,\",\")[0]);\n    }\n  }\n  if ((this.scheme.equals(\"http\") && \"80\".equals(this.port)) || (this.scheme.equals(\"https\") && \"443\".equals(this.port))) {\n    this.port=null;\n  }\n  return this;\n}\n"}
{"INPUT": "@Override public void collect(int doc) throws IOException {\n  HashedBytesArray parentId=typeCache.parentIdByDoc(doc);\n  if (parentId == null) {\n    return;\n  }\n  for (  Tuple<AtomicReader,IdReaderTypeCache> tuple : readers) {\n// bug_start\n    IndexReader indexReader=tuple.v1();\n// bug_end\n    IdReaderTypeCache idReaderTypeCache=tuple.v2();\n    if (idReaderTypeCache == null) {\n      continue;\n    }\n    int parentDocId=idReaderTypeCache.docById(parentId);\n// bug_start\n    if (parentDocId != -1) {\n// bug_end\n      FixedBitSet docIdSet=parentDocs().get(indexReader.getCoreCacheKey());\n      if (docIdSet == null) {\n        docIdSet=new FixedBitSet(indexReader.maxDoc());\n        parentDocs.put(indexReader.getCoreCacheKey(),docIdSet);\n      }\n      docIdSet.set(parentDocId);\n      return;\n    }\n  }\n}\n"}
{"INPUT": "private void doBatchSendAndAdd(MessageImpl<T> msg,SendCallback callback,ByteBuf payload){\n  if (log.isDebugEnabled()) {\n    log.debug(\"[{}] [{}] Closing out batch to accommodate large message with size {}\",topic,producerName,msg.getDataBuffer().readableBytes());\n  }\n// bug_start\n  batchMessageAndSend();\n  batchMessageContainer.add(msg,callback);\n  lastSendFuture=callback.getFuture();\n  payload.release();\n// bug_end\n}\n"}
{"INPUT": "private void initSchemas(final Collection<String> localSchemaNames,final Map<String,Map<String,YamlDataSourceParameter>> schemaDataSources,final Map<String,RuleConfiguration> schemaRules,final boolean isUsingRegistry) throws SQLException {\n  if (schemaRules.isEmpty()) {\n// bug_start\n    logicSchemas.put(schemaDataSources.keySet().iterator().next(),LogicSchemaFactory.newInstance(schemaDataSources.keySet().iterator().next(),schemaDataSources,null,isUsingRegistry));\n// bug_end\n  }\n  for (  Entry<String,RuleConfiguration> entry : schemaRules.entrySet()) {\n    if (localSchemaNames.isEmpty() || localSchemaNames.contains(entry.getKey())) {\n      logicSchemas.put(entry.getKey(),LogicSchemaFactory.newInstance(entry.getKey(),schemaDataSources,entry.getValue(),isUsingRegistry));\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\npublic Rule answer(InvocationOnMock iom) throws Throwable {\n// bug_end\n  Rule rule=Rule.create((String)iom.getArguments()[0],(String)iom.getArguments()[1],(String)iom.getArguments()[1]);\n  rule.createParameter(\"format\");\n  rule.createParameter(\"message\");\n  return rule;\n}\n"}
{"INPUT": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (!(obj instanceof FieldArg) || !super.equals(obj)) {\n    return false;\n  }\n  FieldArg fieldArg=(FieldArg)obj;\n  if (!field.equals(fieldArg.field)) {\n    return false;\n  }\n// bug_start\n  if (instArg != null ? !instArg.equals(fieldArg.instArg) : fieldArg.instArg != null) {\n    return false;\n  }\n  return true;\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Test @Ignore(\"DSL generation to be implemented\") public void testFrom(){\n// bug_end\n  String str=\"import \" + Result.class.getCanonicalName() + \";\\n\"+ \"import \"+ Adult.class.getCanonicalName()+ \";\\n\"+ \"import \"+ Child.class.getCanonicalName()+ \";\\n\"+ \"rule R when\\n\"+ \"  $r : Result()\\n\"+ \"  $a : Adult()\\n\"+ \"  $c : Child( age > 8 ) from $a.children\\n\"+ \"then\\n\"+ \"  $r.setValue($c.getName());\\n\"+ \"end\";\n  KieSession ksession=getKieSession(str);\n  Result result=new Result();\n  ksession.insert(result);\n  Adult dad=new Adult(\"dad\",40);\n  dad.addChild(new Child(\"Alan\",10));\n  dad.addChild(new Child(\"Betty\",7));\n  ksession.insert(dad);\n  ksession.fireAllRules();\n  assertEquals(\"Alan\",result.getValue());\n}\n"}
{"INPUT": "public static void main(String[] args){\n// bug_start\n  System.out.println(\" Hello\" + new Object(){\n// bug_end\n    public String toString(){\n      return \"World\";\n    }\n  }\n);\n  new Object().toString().toString().toString().toString().toString();\n}\n"}
{"INPUT": "@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION') or hasPermission(#cube, 'MANAGEMENT')\") public String submitJob(CubeInstance cube,long startDate,long endDate,CubeBuildTypeEnum buildType) throws IOException, JobException, InvalidJobInstanceException {\n  List<JobInstance> jobInstances=this.getJobManager().listJobs(cube.getName(),null);\n  for (  JobInstance jobInstance : jobInstances) {\n    if (jobInstance.getStatus() == JobStatusEnum.PENDING || jobInstance.getStatus() == JobStatusEnum.RUNNING) {\n      throw new JobException(\"The cube \" + cube.getName() + \" has running job(\"+ jobInstance.getUuid()+ \") please discard it and try again.\");\n    }\n  }\n  String uuid=null;\n  try {\n    List<CubeSegment> cubeSegments=this.getCubeManager().allocateSegments(cube,buildType,startDate,endDate);\n    List<JobInstance> jobs=Lists.newArrayListWithExpectedSize(cubeSegments.size());\n    for (    CubeSegment segment : cubeSegments) {\n      uuid=segment.getUuid();\n      JobInstance job=this.getJobManager().createJob(cube.getName(),segment.getName(),segment.getUuid(),buildType);\n// bug_start\n      segment.setLastBuildJobID(uuid);\n// bug_end\n      jobs.add(job);\n    }\n// bug_start\n    getCubeManager().updateCube(cube);\n// bug_end\n    for (    JobInstance job : jobs) {\n      this.getJobManager().submitJob(job);\n      permissionService.init(job,null);\n      permissionService.inherit(job,cube);\n    }\n  }\n catch (  CubeIntegrityException e) {\n    throw new InternalErrorException(e.getLocalizedMessage(),e);\n  }\n  return uuid;\n}\n"}
{"INPUT": "public String generateJsonBuildReport() throws IOException {\n  Map<BuildRule,Optional<BuildResult>> ruleToResult=buildExecutionResult.getResults();\n  LinkedHashMap<String,Object> results=new LinkedHashMap<>();\n  LinkedHashMap<String,Object> failures=new LinkedHashMap<>();\n  boolean isOverallSuccess=true;\n  for (  Map.Entry<BuildRule,Optional<BuildResult>> entry : ruleToResult.entrySet()) {\n    BuildRule rule=entry.getKey();\n    Optional<BuildRuleSuccessType> success=Optional.empty();\n    Optional<BuildResult> result=entry.getValue();\n    if (result.isPresent()) {\n      success=result.get().getSuccessOptional();\n    }\n    Map<String,Object> value=new LinkedHashMap<>();\n    boolean isSuccess=success.isPresent();\n    value.put(\"success\",result.map(null).orElse(\"UNKNOWN\"));\n    if (!isSuccess) {\n      isOverallSuccess=false;\n    }\n    if (isSuccess) {\n      value.put(\"type\",success.get().name());\n      value.put(\"output\",getDefaultOutputPath(rule));\n      value.put(\"outputs\",getMultipleOutputPaths(rule));\n    }\n    results.put(rule.getFullyQualifiedName(),value);\n  }\n  for (  BuildResult failureResult : buildExecutionResult.getFailures()) {\n    Throwable failure=Objects.requireNonNull(failureResult.getFailure());\n    StringBuilder messageBuilder=new StringBuilder();\n    new ErrorLogger(new LogImpl(){\n      @Override public void logUserVisible(      String message){\n        messageBuilder.append(message);\n      }\n      @Override public void logUserVisibleInternalError(      String message){\n        messageBuilder.append(message);\n      }\n      @Override public void logVerbose(      Throwable e){\n      }\n    }\n// bug_start\n,new HumanReadableExceptionAugmentor(ImmutableMap.of())).setSuppressStackTraces(true).logException(failure);\n// bug_end\n    failures.put(failureResult.getRule().getFullyQualifiedName(),messageBuilder.toString());\n  }\n  Map<String,Object> report=new LinkedHashMap<>();\n  report.put(\"success\",isOverallSuccess);\n  report.put(\"results\",results);\n  report.put(\"failures\",failures);\n  return ObjectMappers.WRITER.withFeatures(SerializationFeature.INDENT_OUTPUT).writeValueAsString(report);\n}\n"}
{"INPUT": "@Override public GnssNavigationMessage createFromParcel(Parcel parcel){\n  GnssNavigationMessage navigationMessage=new GnssNavigationMessage();\n  navigationMessage.setType(parcel.readInt());\n  navigationMessage.setSvid(parcel.readInt());\n  navigationMessage.setMessageId(parcel.readInt());\n  navigationMessage.setSubmessageId(parcel.readInt());\n  int dataLength=parcel.readInt();\n  byte[] data=new byte[dataLength];\n  parcel.readByteArray(data);\n  navigationMessage.setData(data);\n// bug_start\n  if (parcel.dataAvail() >= Integer.SIZE) {\n    int status=parcel.readInt();\n    navigationMessage.setStatus(status);\n  }\n else {\n    navigationMessage.setStatus(STATUS_UNKNOWN);\n  }\n// bug_end\n  return navigationMessage;\n}\n"}
{"INPUT": "public static RedisURI create(URI uri){\n  RedisURI.Builder builder;\n  if (uri.getScheme().equals(URI_SCHEME_REDIS_SENTINEL)) {\n    builder=configureSentinel(uri);\n  }\n else {\n    builder=configureStandalone(uri);\n  }\n  String userInfo=uri.getUserInfo();\n  if (isEmpty(userInfo) && isNotEmpty(uri.getAuthority()) && uri.getAuthority().indexOf('@') > 0) {\n    userInfo=uri.getAuthority().substring(0,uri.getAuthority().indexOf('@'));\n  }\n  if (isNotEmpty(userInfo)) {\n    String password=userInfo;\n    if (password.startsWith(\":\")) {\n      password=password.substring(1);\n    }\n// bug_start\n    builder.withPassword(password);\n// bug_end\n  }\n  if (isNotEmpty(uri.getPath()) && builder.redisURI.getSocket() == null) {\n    String pathSuffix=uri.getPath().substring(1);\n    if (isNotEmpty(pathSuffix)) {\n      builder.withDatabase(Integer.parseInt(pathSuffix));\n    }\n  }\n  return builder.build();\n}\n"}
{"INPUT": "// bug_start\n@Override public void init(NamedList args){\n// bug_end\n  super.init(args);\n  params=args.toSolrParams();\n  this.hdfsDataDir=getConfig(HDFS_HOME,null);\n  if (this.hdfsDataDir != null && this.hdfsDataDir.length() == 0) {\n    this.hdfsDataDir=null;\n  }\n else {\n    log.info(\"{}={}\",HDFS_HOME,this.hdfsDataDir);\n  }\n  cacheMerges=getConfig(CACHE_MERGES,false);\n  cacheReadOnce=getConfig(CACHE_READONCE,false);\n  boolean kerberosEnabled=getConfig(KERBEROS_ENABLED,false);\n  if (log.isInfoEnabled()) {\n    log.info(\"Solr Kerberos Authentication {}\",(kerberosEnabled ? \"enabled\" : \"disabled\"));\n  }\n  if (kerberosEnabled) {\n    initKerberos();\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override public void reportStorageEvents(StatsStorage statsStorage,Collection<StatsStorageEvent> events){\n// bug_end\n  log.info(\"Received events: {}\",events);\n  for (  StatsStorageEvent sse : events) {\n    if (!knownSessionIDs.containsKey(sse.getSessionID())) {\n// bug_start\n      knownSessionIDs.put(sse.getSessionID(),statsStorage);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\nprotected boolean isHex(String input,int length){\n// bug_end\n  Pattern p=Pattern.compile(String.format(\"[0-9A-Fa-f]{%d}\",length));\n  return p.matcher(input).matches();\n}\n"}
{"INPUT": "// bug_start\n@Override public EpollServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead){\n// bug_end\n  super.setMaxMessagesPerRead(maxMessagesPerRead);\n  return this;\n}\n"}
{"INPUT": "@Override public JsonDeserializer<?> createContextual(DeserializationContext ctxt,BeanProperty property) throws JsonMappingException {\n  JsonDeserializer<?> deser=_elementDeserializer;\n  deser=findConvertingContentDeserializer(ctxt,property,deser);\n  if (deser == null) {\n    deser=ctxt.findContextualValueDeserializer(ctxt.constructType(String.class),property);\n  }\n else {\n// bug_start\n    if (deser instanceof ContextualDeserializer) {\n      deser=((ContextualDeserializer)deser).createContextual(ctxt,property);\n    }\n// bug_end\n  }\n  if (deser != null && this.isDefaultDeserializer(deser)) {\n    deser=null;\n  }\n  if (_elementDeserializer != deser) {\n    return new StringArrayDeserializer(deser);\n  }\n  return this;\n}\n"}
{"INPUT": "public void reschedule(JobEntity jobEntity,Date newDuedate){\n// bug_start\n  jobEntity.init(Context.getCommandContext());\n// bug_end\n  jobEntity.setSuspensionState(SuspensionState.ACTIVE.getStateCode());\n  jobEntity.setDuedate(newDuedate);\n  hintJobExecutorIfNeeded(jobEntity,newDuedate);\n}\n"}
{"INPUT": "public void configure(){\n// bug_start\n  from(\"pop3://james3@localhost?consumer.delay=1000\").convertBodyTo(String.class).to(\"mock:result\");\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@RequestMapping(value=\"/page\",method=RequestMethod.GET) @ResponseBody public TableResultResponse<User> page(int limit,int offset,String name){\n// bug_end\n  Example example=new Example(User.class);\n// bug_start\n  if (StringUtils.isNotBlank(name))   example.createCriteria().andLike(\"name\",\"%\" + name + \"%\");\n// bug_end\n  int count=baseBiz.selectCountByExample(example);\n  PageHelper.startPage(offset,limit);\n  return new TableResultResponse<User>(count,baseBiz.selectByExample(example));\n}\n"}
{"INPUT": "public void setPaths(String paths,String separator){\n// bug_start\n  List<String> list=new ArrayList<String>();\n  StringTokenizer tokenizer=new StringTokenizer(paths,separator);\n  while (tokenizer.hasMoreTokens()) {\n    list.add(tokenizer.nextToken());\n// bug_end\n  }\n  setPaths(list);\n}\n"}
{"INPUT": "@Override public void run(){\n  RandomAccessFile out=null;\n  try {\n    File dir=extractFile.getParentFile();\n    if (!dir.exists()) {\n      dir.mkdirs();\n    }\n// bug_start\n    if (!extractFile.exists()) {\n      if (!extractFile.createNewFile()) {\n        throw new RuntimeException(\"Failed to create file: \" + extractFile);\n// bug_end\n      }\n// bug_start\n// bug_end\n    }\n    InputStream is=zipFile.getInputStream(je);\n    out=new RandomAccessFile(extractFile,\"rw\");\n    byte[] buffer=new byte[8192];\n    int len;\n    while ((len=is.read(buffer,0,buffer.length)) != -1) {\n      out.write(buffer,0,len);\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n finally {\n    if (out != null) {\n      try {\n        out.close();\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\n@NonNull public TestFieldPropIgnoreRequireHashCodeOptionViewModel_ value(final OnModelClickListener<TestFieldPropIgnoreRequireHashCodeOptionViewModel_,TestFieldPropIgnoreRequireHashCodeOptionView> value){\n// bug_end\n  assignedAttributes_epoxyGeneratedModel.set(0);\n  onMutation();\n  if (value == null) {\n    this.value_OnClickListener=null;\n  }\n else {\n    this.value_OnClickListener=new WrappedEpoxyModelClickListener(value);\n  }\n  return this;\n}\n"}
{"INPUT": "static Optional<JupiterTestDescriptor> createDynamicDescriptor(JupiterTestDescriptor parent,DynamicNode node,int index,TestSource defaultTestSource,DynamicDescendantFilter dynamicDescendantFilter){\n  UniqueId uniqueId;\n  Supplier<JupiterTestDescriptor> descriptorCreator;\n// bug_start\n  Optional<TestSource> optionalTestSource=node.getTestSourceUri().map(null);\n  TestSource source=optionalTestSource.orElse(defaultTestSource);\n// bug_end\n  if (node instanceof DynamicTest) {\n    DynamicTest test=(DynamicTest)node;\n    uniqueId=parent.getUniqueId().append(DYNAMIC_TEST_SEGMENT_TYPE,\"#\" + index);\n    descriptorCreator=null;\n  }\n else {\n    DynamicContainer container=(DynamicContainer)node;\n    uniqueId=parent.getUniqueId().append(DYNAMIC_CONTAINER_SEGMENT_TYPE,\"#\" + index);\n    descriptorCreator=null;\n  }\n  if (dynamicDescendantFilter.test(uniqueId)) {\n    JupiterTestDescriptor descriptor=descriptorCreator.get();\n    parent.addChild(descriptor);\n    return Optional.of(descriptor);\n  }\n  return Optional.empty();\n}\n"}
{"INPUT": "// bug_start\npublic void testConcurrentDeleteByQueriesOnDifferentDocs() throws Throwable {\n// bug_end\n  final Thread[] threads=new Thread[scaledRandomIntBetween(2,5)];\n  final long docs=randomIntBetween(1,50);\n  List<IndexRequestBuilder> builders=new ArrayList<>();\n  for (int i=0; i < docs; i++) {\n    for (int t=0; t < threads.length; t++) {\n      builders.add(client().prepareIndex(\"test\",\"doc\").setSource(\"field\",t));\n    }\n  }\n  indexRandom(true,true,true,builders);\n  final CountDownLatch start=new CountDownLatch(1);\n  for (int t=0; t < threads.length; t++) {\n    final int threadNum=t;\n    assertHitCount(client().prepareSearch(\"test\").setSize(0).setQuery(QueryBuilders.termQuery(\"field\",threadNum)).get(),docs);\n    Runnable r=null;\n    threads[t]=new Thread(r);\n    threads[t].start();\n  }\n  start.countDown();\n  for (  Thread thread : threads) {\n    thread.join();\n  }\n  for (int t=0; t < threads.length; t++) {\n    assertHitCount(client().prepareSearch(\"test\").setSize(0).setQuery(QueryBuilders.termQuery(\"field\",t)).get(),0);\n  }\n}\n"}
{"INPUT": "@Override public void init() throws ServletException {\n  mBeanServer=Registry.getRegistry(null,null).getMBeanServer();\n  try {\n    String onStr=\"*:type=ProtocolHandler,*\";\n    ObjectName objectName=new ObjectName(onStr);\n    Set<ObjectInstance> set=mBeanServer.queryMBeans(objectName,null);\n    Iterator<ObjectInstance> iterator=set.iterator();\n    while (iterator.hasNext()) {\n      ObjectInstance oi=iterator.next();\n      protocolHandlers.addElement(oi.getObjectName());\n    }\n    onStr=\"*:type=ThreadPool,*\";\n    objectName=new ObjectName(onStr);\n    set=mBeanServer.queryMBeans(objectName,null);\n// bug_start\n    onStr=\"*:type=ThreadPool,*,subType=SocketProperties\";\n    objectName=new ObjectName(onStr);\n    Set<ObjectInstance> set2=mBeanServer.queryMBeans(objectName,null);\n// bug_end\n    iterator=set.iterator();\n    while (iterator.hasNext()) {\n      ObjectInstance oi=iterator.next();\n// bug_start\n      if (!set2.contains(oi)) {\n        threadPools.addElement(oi.getObjectName());\n      }\n// bug_end\n    }\n    onStr=\"*:type=GlobalRequestProcessor,*\";\n    objectName=new ObjectName(onStr);\n    set=mBeanServer.queryMBeans(objectName,null);\n    iterator=set.iterator();\n    while (iterator.hasNext()) {\n      ObjectInstance oi=iterator.next();\n      globalRequestProcessors.addElement(oi.getObjectName());\n    }\n    onStr=\"*:type=RequestProcessor,*\";\n    objectName=new ObjectName(onStr);\n    set=mBeanServer.queryMBeans(objectName,null);\n    iterator=set.iterator();\n    while (iterator.hasNext()) {\n      ObjectInstance oi=iterator.next();\n      requestProcessors.addElement(oi.getObjectName());\n    }\n    onStr=\"JMImplementation:type=MBeanServerDelegate\";\n    objectName=new ObjectName(onStr);\n    mBeanServer.addNotificationListener(objectName,this,null,null);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n"}
{"INPUT": "public static MockTransportService startTransport(final String id,final List<DiscoveryNode> knownNodes,final Version version,final ThreadPool threadPool,final Settings settings){\n  boolean success=false;\n  final Settings s=Settings.builder().put(settings).put(\"node.name\",id).build();\n  ClusterName clusterName=ClusterName.CLUSTER_NAME_SETTING.get(s);\n  MockTransportService newService=MockTransportService.createNewService(s,version,threadPool,null);\n  try {\n// bug_start\n    newService.registerRequestHandler(ClusterSearchShardsAction.NAME,null,ThreadPool.Names.SAME,null);\n    newService.registerRequestHandler(ClusterStateAction.NAME,null,ThreadPool.Names.SAME,null);\n// bug_end\n    newService.start();\n    newService.acceptIncomingRequests();\n    success=true;\n    return newService;\n  }\n  finally {\n    if (success == false) {\n      newService.close();\n    }\n  }\n}\n"}
{"INPUT": "public void testUpgradeOldMapping() throws IOException, ExecutionException, InterruptedException {\n  final String indexName=\"index-mapper-size-2.0.0\";\n  final String indexUUID=\"ENCw7sG0SWuTPcH60bHheg\";\n  InternalTestCluster.Async<String> master=internalCluster().startNodeAsync();\n  Path unzipDir=createTempDir();\n  Path unzipDataDir=unzipDir.resolve(\"data\");\n  Path backwardsIndex=getBwcIndicesPath().resolve(indexName + \".zip\");\n  try (InputStream stream=Files.newInputStream(backwardsIndex)){\n    TestUtil.unzip(stream,unzipDir);\n  }\n   assertTrue(Files.exists(unzipDataDir));\n  Path dataPath=createTempDir();\n  Settings settings=Settings.builder().put(Environment.PATH_DATA_SETTING.getKey(),dataPath).build();\n  final String node=internalCluster().startDataOnlyNode(settings);\n  Path[] nodePaths=internalCluster().getInstance(NodeEnvironment.class,node).nodeDataPaths();\n  assertEquals(1,nodePaths.length);\n  dataPath=nodePaths[0].resolve(NodeEnvironment.INDICES_FOLDER);\n  assertFalse(Files.exists(dataPath));\n  Path src=unzipDataDir.resolve(indexName + \"/nodes/0/indices\");\n  Files.move(src,dataPath);\n  Files.move(dataPath.resolve(indexName),dataPath.resolve(indexUUID));\n  master.get();\n  client().admin().cluster().prepareReroute().get();\n  ensureGreen(indexName);\n  final SearchResponse countResponse=client().prepareSearch(indexName).setSize(0).get();\n  ElasticsearchAssertions.assertHitCount(countResponse,3L);\n// bug_start\n  final SearchResponse sizeResponse=client().prepareSearch(indexName).addField(\"_source\").addField(\"_size\").get();\n// bug_end\n  ElasticsearchAssertions.assertHitCount(sizeResponse,3L);\n  for (  SearchHit hit : sizeResponse.getHits().getHits()) {\n    String source=hit.getSourceAsString();\n    assertNotNull(source);\n    Map<String,SearchHitField> fields=hit.getFields();\n    assertTrue(fields.containsKey(\"_size\"));\n    Number size=fields.get(\"_size\").getValue();\n    assertNotNull(size);\n    assertEquals(source.length(),size.longValue());\n  }\n}\n"}
{"INPUT": "// bug_start\n@POST @Path(\"private/cancelorder\") GateioBaseResponse cancelOrder(@FormParam(\"orderNumber\") String orderNumber,@HeaderParam(\"KEY\") String apiKey,@HeaderParam(\"SIGN\") ParamsDigest signer,@FormParam(\"nonce\") SynchronizedValueFactory<Long> nonce) throws IOException ;\n// bug_end\n"}
{"INPUT": "private void setActiveMenu(List<Content> menuContentList){\n  if (currentTaxonomys != null && currentTaxonomys.size() > 0) {\n    for (    Taxonomy taxonomy : currentTaxonomys) {\n      String routerWithoutPageNumber=TaxonomyRouter.getRouterWithoutPageNumber(taxonomy);\n      routerWithoutPageNumber=JFinal.me().getContextPath() + routerWithoutPageNumber;\n      if (StringUtils.isNotBlank(routerWithoutPageNumber)) {\n        for (        Content menuContent : menuContentList) {\n          if (menuContent.getText() != null && menuContent.getText().startsWith(StringUtils.urlDecode(routerWithoutPageNumber))) {\n// bug_start\n// bug_end\n            menuContent.setFlag(\"active\");\n          }\n        }\n      }\n    }\n  }\n  if (currentContent != null) {\n    String contentUrl=currentContent.getUrl();\n    for (    Content menuContent : menuContentList) {\n      if (contentUrl != null && contentUrl.equals(menuContent.getText())) {\n        menuContent.setFlag(\"active\");\n      }\n      String onlyModuleUrl=JFinal.me().getContextPath() + \"/\" + currentContent.getModule();\n      if (onlyModuleUrl.equals(menuContent.getText())) {\n        menuContent.setFlag(\"active\");\n      }\n    }\n  }\n  for (  Content menuContent : menuContentList) {\n    if (menuContent.getText() != null && menuContent.getText().equals(StringUtils.urlDecode(request.getRequestURI()))) {\n      menuContent.setFlag(\"active\");\n    }\n  }\n}\n"}
{"INPUT": "public void initialize(){\n  try {\n    clusterMap=new MockClusterMap();\n  }\n catch (  Exception e) {\n    fail(\"Should not get any exception.\");\n  }\n// bug_start\n  partition=clusterMap.getWritablePartitionIds(MockClusterMap.DEFAULT_PARTITION_CLASS).get(0);\n// bug_end\n  originalBlobId=new BlobId(CommonTestUtils.getCurrentBlobIdVersion(),BlobId.BlobIdType.NATIVE,clusterMap.getLocalDatacenterId(),Utils.getRandomShort(random),Utils.getRandomShort(random),partition,false,BlobId.BlobDataType.DATACHUNK);\n  blobIdStr=originalBlobId.getID();\n}\n"}
{"INPUT": "private void processLeaveRequest(LeaveRequestMessage incomingRequest){\n  logger.info(\"received leave request from {} for {}\",incomingRequest.getSender(),incomingRequest.getMemberID());\n  NetView v=currentView;\n  if (v == null) {\n    recordViewRequest(incomingRequest);\n    return;\n  }\n  InternalDistributedMember mbr=incomingRequest.getMemberID();\n  logger.info(null);\n  if (!v.contains(mbr) && mbr.getVmViewId() < v.getViewId()) {\n    logger.info(\"ignoring leave request from old member\");\n    return;\n  }\n  if (incomingRequest.getMemberID().equals(this.localAddress)) {\n    logger.info(\"I am being told to leave the distributed system by {}\",incomingRequest.getSender());\n    forceDisconnect(incomingRequest.getReason());\n    return;\n  }\n  if (!isCoordinator && !isStopping && !services.getCancelCriterion().isCancelInProgress()) {\n    logger.info(\"Checking to see if I should become coordinator\");\n    NetView check=new NetView(v,v.getViewId() + 1);\n    check.remove(mbr);\nsynchronized (removedMembers) {\n      check.removeAll(removedMembers);\n      check.addCrashedMembers(removedMembers);\n    }\nsynchronized (leftMembers) {\n      leftMembers.add(mbr);\n      check.removeAll(leftMembers);\n    }\n// bug_start\n// bug_end\n    if (check.getCoordinator().equals(localAddress)) {\nsynchronized (viewInstallationLock) {\n        becomeCoordinator(mbr);\n      }\n    }\n  }\n else {\n    if (!isStopping && !services.getCancelCriterion().isCancelInProgress()) {\n      recordViewRequest(incomingRequest);\n      this.viewProcessor.processLeaveRequest(incomingRequest.getMemberID());\n      this.prepareProcessor.processLeaveRequest(incomingRequest.getMemberID());\n    }\n  }\n}\n"}
{"INPUT": "public void disconnect(boolean force){\n  changeStatus(Account.STATUS_OFFLINE);\n  Log.d(LOGTAG,\"disconnecting\");\n  try {\n    if (force) {\n      socket.close();\n      return;\n    }\n    new Thread(new Runnable(){\n      @Override public void run(){\n        if (tagWriter.isActive()) {\n          tagWriter.finish();\n          try {\n            while (!tagWriter.finished()) {\n              Log.d(LOGTAG,\"not yet finished\");\n              Thread.sleep(100);\n            }\n            tagWriter.writeTag(Tag.end(\"stream:stream\"));\n          }\n catch (          IOException e) {\n            Log.d(LOGTAG,\"io exception during disconnect\");\n          }\ncatch (          InterruptedException e) {\n            Log.d(LOGTAG,\"interrupted\");\n          }\n        }\n      }\n    }\n// bug_start\n);\n// bug_end\n  }\n catch (  IOException e) {\n    Log.d(LOGTAG,\"io exception during disconnect\");\n  }\n}\n"}
{"INPUT": "@Before public void setUp(){\n  connMsg=MqttMessageBuilders.connect().protocolVersion(MqttVersion.MQTT_3_1).cleanSession(true);\n  mockAuthenticator=new MockAuthenticator(singleton(FAKE_CLIENT_ID),singletonMap(TEST_USER,TEST_PWD));\n  ISubscriptionsDirectory subscriptions=new CTrieSubscriptionDirectory();\n  ISubscriptionsRepository subscriptionsRepository=new MemorySubscriptionsRepository();\n  subscriptions.init(subscriptionsRepository);\n  queueRepository=new MemoryQueueRepository();\n// bug_start\n  sessionRegistry=new SessionRegistry(subscriptions,queueRepository);\n  postOffice=new PostOffice(subscriptions,new PermitAllAuthorizatorPolicy(),new MemoryRetainedRepository(),sessionRegistry,ConnectionTestUtils.NO_OBSERVERS_INTERCEPTOR);\n// bug_end\n  sut=createMQTTConnection(CONFIG);\n  channel=(EmbeddedChannel)sut.channel;\n}\n"}
{"INPUT": "// bug_start\n@Override public JavaType constructSpecializedType(JavaType baseType,Class<?> subclass){\n// bug_end\n  if (baseType.hasRawClass(subclass)) {\n    return baseType;\n  }\n  return getConfig().getTypeFactory().constructSpecializedType(baseType,subclass,true);\n}\n"}
{"INPUT": "public void predictMaximumSizeAndReset(int maximumSize){\n// bug_start\n// bug_end\n  for (int i=1; i < partValuesList.size(); i++) {\n    int proposedIndexLimit=(int)Math.pow(partValuesLength,i);\n    if (maximumSize <= proposedIndexLimit) {\n      filteredPartValuesList=new ArrayList<>(partValuesList);\n      while (i < filteredPartValuesList.size() && filteredPartValuesList.size() > requiredSize) {\n        int eliminationIndex=eliminationIndexMap.get(filteredPartValuesList.size() - 1);\n        filteredPartValuesList.remove(eliminationIndex);\n      }\n      indexLimit=proposedIndexLimit;\n      break;\n    }\n  }\n  index=0;\n}\n"}
{"INPUT": "@Override public boolean onContextItemSelected(MenuItem item){\n  Log.d(TAG,\"onContextItemSelected() called with: \" + \"item = [\" + item + \"]\");\n  if (!isVisible()) {\n    return false;\n  }\n  if (item.getItemId() == R.id.share_item) {\n    return true;\n  }\n// bug_start\n  int pos=listAdapter.getPosition();\n  if (pos < 0) {\n    return false;\n  }\n  FeedItem selectedItem=itemAccess.getItem(pos);\n// bug_end\n  if (selectedItem == null) {\n// bug_start\n    Log.i(TAG,\"Selected item at position \" + pos + \" was null, ignoring selection\");\n// bug_end\n    return super.onContextItemSelected(item);\n  }\n  if (R.id.mark_as_seen_item == item.getItemId()) {\n    markItemAsSeenWithUndo(selectedItem);\n    return true;\n  }\n  return FeedItemMenuHandler.onMenuItemClicked(getActivity(),item.getItemId(),selectedItem);\n}\n"}
{"INPUT": "// bug_start\nprivate void assertDiscoveryCompleted(List<String> nodes) throws InterruptedException {\n// bug_end\n  for (  final String node : nodes) {\n// bug_start\n    assertTrue(\"node [\" + node + \"] is still joining master\",awaitBusy(null,30,TimeUnit.SECONDS));\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void applySpecification(ExchangeSpecification exchangeSpecification){\n  super.applySpecification(exchangeSpecification);\n// bug_start\n  this.pollingMarketDataService=new EmpoExMarketDataService(exchangeSpecification);\n  this.pollingAccountService=new EmpoExAccountService(exchangeSpecification);\n  this.pollingTradeService=new EmpoExTradeService(exchangeSpecification);\n// bug_end\n}\n"}
{"INPUT": "private RowBasedColumnSelectorFactory(final Supplier<? extends Row> row,@Nullable final Map<String,ValueType> rowSignature){\n  this.row=row;\n// bug_start\n  this.rowSignature=rowSignature != null ? rowSignature : ImmutableMap.<String,ValueType>of();\n// bug_end\n}\n"}
{"INPUT": "@Inject public IgnoreDialog(){\n  super(Roles.getDialogRole());\n  dirChooser_=new DirectoryChooserTextBox(\"Directory:\",\"\",null);\n  dirChooser_.addStyleName(RES.styles().dirChooser());\n// bug_start\n  ignoresCaption_=new CaptionWithHelp(\"Ignore:\",\"Specifying ignored files\");\n  ignoresCaption_.setIncludeVersionInfo(false);\n  ignoresCaption_.addStyleName(RES.styles().ignoresCaption());\n// bug_end\n  editor_=new AceEditor();\n  editor_.setUseWrapMode(false);\n  editor_.setShowLineNumbers(false);\n// bug_start\n  ignoresCaption_.setFor(editor_.getWidget());\n// bug_end\n  saveButton_=new ThemedButton(\"Save\",(ClickHandler)null);\n  addButton(saveButton_);\n  addCancelButton();\n  setButtonAlignment(HasHorizontalAlignment.ALIGN_RIGHT);\n  progressIndicator_=addProgressIndicator();\n}\n"}
{"INPUT": "protected void applyColorsAndBackgrounds(StatusBarNotification sbn,NotificationData.Entry entry){\n  if (entry.expanded.getId() != com.android.internal.R.id.status_bar_latest_event_content) {\n    if (entry.targetSdk >= Build.VERSION_CODES.GINGERBREAD && entry.targetSdk < Build.VERSION_CODES.LOLLIPOP) {\n      entry.row.setShowingLegacyBackground(true);\n      entry.legacy=true;\n    }\n  }\n else {\n    final int color=sbn.getNotification().color;\n    if (isMediaNotification(entry)) {\n      entry.row.setTintColor(color == Notification.COLOR_DEFAULT ? mContext.getResources().getColor(R.color.notification_material_background_media_default_color) : color);\n    }\n  }\n  if (entry.icon != null) {\n// bug_start\n    if (entry.targetSdk >= Build.VERSION_CODES.LOLLIPOP) {\n      entry.icon.setColorFilter(mContext.getResources().getColor(android.R.color.white));\n    }\n else {\n      entry.icon.setColorFilter(null);\n    }\n// bug_end\n  }\n}\n"}
{"INPUT": "private void putUserInfoInSession(HttpServletRequest httpRequest){\n  final HttpSession session=httpRequest.getSession(false);\n  if (session == null) {\n    return;\n  }\n  if (session.getAttribute(SessionInformations.SESSION_COUNTRY_KEY) == null) {\n    final Locale locale=httpRequest.getLocale();\n    if (locale.getCountry().length() > 0) {\n      session.setAttribute(SessionInformations.SESSION_COUNTRY_KEY,locale.getCountry());\n    }\n else {\n      session.setAttribute(SessionInformations.SESSION_COUNTRY_KEY,locale.getLanguage());\n    }\n  }\n  if (session.getAttribute(SessionInformations.SESSION_REMOTE_ADDR) == null) {\n    final String forwardedFor=httpRequest.getHeader(\"X-Forwarded-For\");\n    final String remoteAddr;\n    if (forwardedFor == null) {\n      remoteAddr=httpRequest.getRemoteAddr();\n    }\n else {\n      remoteAddr=httpRequest.getRemoteAddr() + \" forwarded for \" + forwardedFor;\n    }\n    session.setAttribute(SessionInformations.SESSION_REMOTE_ADDR,remoteAddr);\n  }\n  if (session.getAttribute(SessionInformations.SESSION_REMOTE_USER) == null) {\n    final String remoteUser=httpRequest.getRemoteUser();\n    if (remoteUser != null) {\n      session.setAttribute(SessionInformations.SESSION_REMOTE_USER,remoteUser);\n    }\n  }\n  if (session.getAttribute(SessionInformations.SESSION_USER_AGENT) == null) {\n    final String userAgent=httpRequest.getHeader(\"User-Agent\");\n// bug_start\n    if (userAgent != null) {\n      session.setAttribute(SessionInformations.SESSION_USER_AGENT,userAgent);\n    }\n// bug_end\n  }\n}\n"}
{"INPUT": "public SocketState asyncDispatch(SocketStatus status){\n  RequestInfo rp=request.getRequestProcessor();\n  try {\n    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n    error=!adapter.asyncDispatch(request,response,status);\n  }\n catch (  InterruptedIOException e) {\n    error=true;\n  }\ncatch (  Throwable t) {\n    ExceptionUtils.handleThrowable(t);\n    log.error(sm.getString(\"http11processor.request.process\"),t);\n    response.setStatus(500);\n    adapter.log(request,response,0);\n    error=true;\n  }\n  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n  if (error) {\n    response.setStatus(500);\n  }\n  if (isAsync()) {\n    if (error) {\n      request.updateCounters();\n      return SocketState.CLOSED;\n    }\n else {\n      return SocketState.LONG;\n    }\n  }\n else {\n    request.updateCounters();\n// bug_start\n    return SocketState.CLOSED;\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void writeXML(XMLOutput xmlOutput,boolean disabled) throws IOException {\n  XMLAttributeList attributes=new XMLAttributeList().addAttribute(\"value\",Long.toString(version)).addAttribute(\"relOp\",relOp.getName());\n// bug_start\n  if (disabled)   attributes.addAttribute(\"disabled\",\"true\");\n// bug_end\n  xmlOutput.openCloseTag(\"FirstVersion\",attributes);\n}\n"}
{"INPUT": "// bug_start\n@Override public ImmutableMap<BuildTarget,Optional<TargetNode<?>>> filter(Iterable<TargetNode<?>> nodes){\n  Optional<TargetNode<?>> firstMatchingNode=StreamSupport.stream(nodes.spliterator(),false).filter(null).findFirst();\n// bug_end\n  return ImmutableMap.of(getBuildTarget(),firstMatchingNode);\n}\n"}
{"INPUT": "// bug_start\n@Specialization public Object executeIntrinsic(long size){\n// bug_end\n  if (size < 0) {\n    CompilerDirectives.transferToInterpreter();\n    throw new IllegalArgumentException(\"Can't truffle_managed_malloc less than zero bytes\");\n  }\n  long sizeInWords=(size + LLVMExpressionNode.ADDRESS_SIZE_IN_BYTES - 1) / LLVMExpressionNode.ADDRESS_SIZE_IN_BYTES;\n  if (sizeInWords > Integer.MAX_VALUE) {\n    CompilerDirectives.transferToInterpreter();\n    throw new IllegalArgumentException(\"Can't truffle_managed_malloc for more than 2^31 objects\");\n  }\n  return new LLVMTruffleObject(new ManagedMallocObject((int)sizeInWords),new PointerType(VoidType.INSTANCE));\n}\n"}
{"INPUT": "// bug_start\nprotected void update(Username currentUser,M pluginProfile,LocalizedOperationResult result,PluginProfileCommand command){\n// bug_end\n  try {\n// bug_start\n    validatePluginProperties(command,pluginProfile);\n// bug_end\n    goConfigService.updateConfig(command,currentUser);\n  }\n catch (  Exception e) {\n    if (e instanceof GoConfigInvalidException) {\n      result.unprocessableEntity(entityConfigValidationFailed(pluginProfile.getClass().getAnnotation(ConfigTag.class).value(),pluginProfile.getId(),e.getMessage()));\n    }\n else {\n      if (!result.hasMessage()) {\n        LOGGER.error(e.getMessage(),e);\n        result.internalServerError(saveFailedWithReason(\"An error occurred while saving the profile config. Please check the logs for more information.\"));\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override protected void configure(){\n  bind(SessionIdGenerator.class).to(DefaultSessionIdGenerator.class).in(Singleton.class);\n// bug_start\n  bind(SessionManager.class).to(DefaultSessionManager.class).in(Singleton.class);\n// bug_end\n  bind(SessionCookieConfig.class).toInstance(new DefaultSessionCookieConfig(cookieExpiresMins,cookieDomain,cookiePath));\n  Multibinder.newSetBinder(binder(),HandlerDecorator.class).addBinding().toInstance(HandlerDecorator.prepend(null));\n}\n"}
{"INPUT": "public FilterAndProjectOperator(OperatorContext operatorContext,Iterable<? extends Type> types,PageProcessor processor,MergingPageOutput mergingOutput){\n  this.processor=requireNonNull(processor,\"processor is null\");\n  this.operatorContext=requireNonNull(operatorContext,\"operatorContext is null\");\n// bug_start\n  this.outputMemoryContext=operatorContext.newLocalSystemMemoryContext();\n// bug_end\n  this.types=ImmutableList.copyOf(requireNonNull(types,\"types is null\"));\n  this.mergingOutput=requireNonNull(mergingOutput,\"mergingOutput is null\");\n}\n"}
{"INPUT": "@Override public void start(){\n  try {\n    jettyServer.start();\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  long timeout=System.currentTimeMillis() + 30000;\n  while (!jettyServer.isStarted()) {\n    try {\n// bug_start\n      Thread.currentThread().sleep(100);\n// bug_end\n    }\n catch (    InterruptedException e) {\n    }\n    if (System.currentTimeMillis() > timeout) {\n      throw new RuntimeException(\"Server took too long to start up.\");\n    }\n  }\n}\n"}
{"INPUT": "@Override protected CamelContext createCamelContext() throws Exception {\n  CamelContext context=super.createCamelContext();\n// bug_start\n  PropertiesComponent pc=new PropertiesComponent();\n  pc.setLocation(\"classpath:org/apache/camel/component/properties/myproperties.properties\");\n  context.addComponent(\"properties\",pc);\n// bug_end\n  return context;\n}\n"}
{"INPUT": "// bug_start\npublic <P extends Plugin>Iterator<P> load(Class<P> service){\n// bug_end\n  ArrayList<Iterator<P>> combinedIterators=new ArrayList<>(pluginDescriptors.size());\n  for (  PluginDescriptor pluginDescriptor : pluginDescriptors) {\n    PluginLoader pluginLoader=PluginLoader.create(pluginDescriptor,parentClassLoader,alwaysParentFirstPatterns);\n    combinedIterators.add(pluginLoader.load(service));\n  }\n  return Iterators.concat(combinedIterators.iterator());\n}\n"}
{"INPUT": "// bug_start\nprotected synchronized void updateCurrentCursor(int sourceAct,int targetAct,int status){\n// bug_end\n  if (useCustomCursor) {\n    return;\n  }\n  Cursor c=null;\nswitch (status) {\ndefault :\n    targetAct=DnDConstants.ACTION_NONE;\ncase ENTER:\ncase OVER:\ncase CHANGED:\n  int ra=sourceAct & targetAct;\nif (ra == DnDConstants.ACTION_NONE) {\n  if ((sourceAct & DnDConstants.ACTION_LINK) == DnDConstants.ACTION_LINK)   c=DragSource.DefaultLinkNoDrop;\n else   if ((sourceAct & DnDConstants.ACTION_MOVE) == DnDConstants.ACTION_MOVE)   c=DragSource.DefaultMoveNoDrop;\n else   c=DragSource.DefaultCopyNoDrop;\n}\n else {\n  if ((ra & DnDConstants.ACTION_LINK) == DnDConstants.ACTION_LINK)   c=DragSource.DefaultLinkDrop;\n else   if ((ra & DnDConstants.ACTION_MOVE) == DnDConstants.ACTION_MOVE)   c=DragSource.DefaultMoveDrop;\n else   c=DragSource.DefaultCopyDrop;\n}\n}\nsetCursorImpl(c);\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n// bug_start\n  int res=ToolRunner.run(NutchConfiguration.create(),new LinkDbReader(),args);\n  System.exit(res);\n// bug_end\n}\n"}
{"INPUT": "private boolean tryCutOffRuntimeExceptions(MethodCallTargetNode methodCallTargetNode){\n  if (methodCallTargetNode.targetMethod().isConstructor()) {\n    ResolvedJavaType runtimeException=providers.getMetaAccess().lookupJavaType(RuntimeException.class);\n// bug_start\n// bug_end\n    ResolvedJavaType controlFlowException=providers.getMetaAccess().lookupJavaType(ControlFlowException.class);\n    ResolvedJavaType exceptionType=Objects.requireNonNull(StampTool.typeOrNull(methodCallTargetNode.receiver().stamp()));\n// bug_start\n    if (runtimeException.isAssignableFrom(methodCallTargetNode.targetMethod().getDeclaringClass()) && !controlFlowException.isAssignableFrom(exceptionType)) {\n// bug_end\n      DeoptimizeNode deoptNode=methodCallTargetNode.graph().add(new DeoptimizeNode(DeoptimizationAction.InvalidateRecompile,DeoptimizationReason.UnreachedCode));\n      FixedNode invokeNode=methodCallTargetNode.invoke().asNode();\n      invokeNode.replaceAtPredecessor(deoptNode);\n      GraphUtil.killCFG(invokeNode);\n      return true;\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "@Test public void testNettyComponentUdpWithConfiguration() throws Exception {\n  NettyComponent comp=context.getComponent(\"netty4\",NettyComponent.class);\n  NettyConfiguration cfg=new NettyConfiguration();\n  comp.setConfiguration(cfg);\n  assertSame(cfg,comp.getConfiguration());\n  NettyEndpoint e1=(NettyEndpoint)comp.createEndpoint(\"netty4://udp://localhost:8601?sync=false\");\n// bug_start\n  NettyEndpoint e2=(NettyEndpoint)comp.createEndpoint(\"netty4://udp://localhost:8602?sync=false&udpConnectionlessSend=true\");\n// bug_end\n  assertNotSame(e1,e2);\n  assertNotSame(e1.getConfiguration(),e2.getConfiguration());\n  assertEquals(false,e1.getConfiguration().isSync());\n  assertEquals(false,e2.getConfiguration().isSync());\n// bug_start\n  assertEquals(false,e1.getConfiguration().isUdpConnectionlessSend());\n  assertEquals(true,e2.getConfiguration().isUdpConnectionlessSend());\n// bug_end\n  assertEquals(8601,e1.getConfiguration().getPort());\n  assertEquals(8602,e2.getConfiguration().getPort());\n}\n"}
{"INPUT": "@Override public void start() throws Exception {\n  VertxResteasyDeployment deployment=new VertxResteasyDeployment();\n  deployment.start();\n  deployment.getRegistry().addPerInstanceResource(Controller.class);\n// bug_start\n  vertx.createHttpServer().requestHandler(new VertxRequestHandler(vertx,deployment)).listen(8080);\n  System.out.println(\"started\");\n// bug_end\n}\n"}
{"INPUT": "@Override public void nullSafeMapToEntityFromMap(EnversService enversService,Object obj,Map data,Object primaryKey,AuditReaderImplementor versionsReader,Number revision){\n  final Object entityId=delegate.mapToIdFromMap(data);\n  Object value=null;\n  if (entityId != null) {\n    if (versionsReader.getFirstLevelCache().contains(referencedEntityName,revision,entityId)) {\n      value=versionsReader.getFirstLevelCache().get(referencedEntityName,revision,entityId);\n    }\n else {\n      final EntityInfo referencedEntity=getEntityInfo(enversService,referencedEntityName);\n      boolean ignoreNotFound=false;\n      if (!referencedEntity.isAudited()) {\n        final String referencingEntityName=enversService.getEntitiesConfigurations().getEntityNameForVersionsEntityName((String)data.get(\"$type$\"));\n// bug_start\n        ignoreNotFound=enversService.getEntitiesConfigurations().getRelationDescription(referencingEntityName,getPropertyData().getName()).isIgnoreNotFound();\n// bug_end\n      }\n      if (ignoreNotFound) {\n        value=ToOneEntityLoader.loadImmediate(versionsReader,referencedEntity.getEntityClass(),referencedEntityName,entityId,revision,RevisionType.DEL.equals(data.get(enversService.getAuditEntitiesConfiguration().getRevisionTypePropName())),enversService);\n      }\n else {\n        value=ToOneEntityLoader.createProxyOrLoadImmediate(versionsReader,referencedEntity.getEntityClass(),referencedEntityName,entityId,revision,RevisionType.DEL.equals(data.get(enversService.getAuditEntitiesConfiguration().getRevisionTypePropName())),enversService);\n      }\n    }\n  }\n  setPropertyValue(obj,value);\n}\n"}
{"INPUT": "@Override public String readValue(SerializableValue field,String parcel){\n// bug_start\n  String fieldName=field.getName();\n  String tmpFieldName=NameUtil.upperCaseFirstLetter(fieldName);\n  return String.format(\"long tmp%s = %s.readLong(); \" + \"%s = tmp%s == %s ? null : new java.util.Date(tmp%s);\",tmpFieldName,parcel,fieldName,tmpFieldName,NULL_VALUE,tmpFieldName);\n// bug_end\n}\n"}
{"INPUT": "public Map<String,SortedSet<PackageElement>> groupPackages(Set<PackageElement> packages){\n  Map<String,SortedSet<PackageElement>> groupPackageMap=new HashMap<>();\n  String defaultGroupName=(elementNameGroupMap.isEmpty() && regExpGroupMap.isEmpty()) ? configuration.getResources().getText(\"doclet.Packages\") : configuration.getResources().getText(\"doclet.Other_Packages\");\n  if (!groupList.contains(defaultGroupName)) {\n    groupList.add(defaultGroupName);\n  }\n  for (  PackageElement pkg : packages) {\n// bug_start\n    String pkgName=pkg.isUnnamed() ? null : configuration.utils.getPackageName(pkg);\n// bug_end\n    String groupName=pkg.isUnnamed() ? null : elementNameGroupMap.get(pkgName);\n    if (groupName == null) {\n      groupName=regExpGroupName(pkgName);\n    }\n    if (groupName == null) {\n      groupName=defaultGroupName;\n    }\n    getPkgList(groupPackageMap,groupName).add(pkg);\n  }\n  return groupPackageMap;\n}\n"}
{"INPUT": "private CallSite createPogoMetaClassGetPropertySite(GroovyObject receiver){\n  final MetaClass metaClass=receiver.getMetaClass();\n// bug_start\n// bug_end\n  CallSite site;\n  if (metaClass.getClass() != MetaClassImpl.class || GroovyCategorySupport.hasCategoryInCurrentThread()) {\n    site=new PogoMetaClassGetPropertySite(this,metaClass);\n  }\n else {\n    final MetaProperty effective=((MetaClassImpl)metaClass).getEffectiveGetMetaProperty(metaClass.getClass(),receiver,name,false);\n    if (effective != null) {\n      if (effective instanceof CachedField)       site=new GetEffectivePogoFieldSite(this,metaClass,(CachedField)effective);\n else       site=new GetEffectivePogoPropertySite(this,metaClass,effective);\n    }\n else {\n      site=new PogoMetaClassGetPropertySite(this,metaClass);\n    }\n  }\n  array.array[index]=site;\n  return site;\n}\n"}
{"INPUT": "public TaskContext addTaskContext(TaskStateMachine taskStateMachine,Session session,boolean verboseStats,boolean cpuTimerEnabled){\n// bug_start\n  TaskContext taskContext=new TaskContext(this,taskStateMachine,notificationExecutor,yieldExecutor,session,verboseStats,cpuTimerEnabled);\n// bug_end\n  taskContexts.put(taskStateMachine.getTaskId(),taskContext);\n  return taskContext;\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") @NonNull private NavArgument inflateArgument(@NonNull TypedArray a,@NonNull Resources res,int graphResId) throws XmlPullParserException {\n  NavArgument.Builder argumentBuilder=new NavArgument.Builder();\n  argumentBuilder.setIsNullable(a.getBoolean(R.styleable.NavArgument_nullable,false));\n  TypedValue value=sTmpValue.get();\n  if (value == null) {\n    value=new TypedValue();\n    sTmpValue.set(value);\n  }\n  Object defaultValue=null;\n  NavType navType=null;\n  String argType=a.getString(R.styleable.NavArgument_argType);\n  if (argType != null) {\n    navType=NavType.fromArgType(argType,res.getResourcePackageName(graphResId));\n  }\n  if (a.getValue(R.styleable.NavArgument_android_defaultValue,value)) {\n    if (navType == NavType.StringType) {\n      defaultValue=a.getString(R.styleable.NavArgument_android_defaultValue);\n// bug_start\n// bug_end\n    }\n else {\nswitch (value.type) {\ncase TypedValue.TYPE_STRING:\n        String stringValue=value.string.toString();\n      if (navType == null) {\n        navType=NavType.inferFromValue(stringValue);\n      }\n    defaultValue=navType.parseValue(stringValue);\n  break;\ncase TypedValue.TYPE_DIMENSION:\nnavType=checkNavType(value,navType,NavType.IntType,argType,\"dimension\");\ndefaultValue=(int)value.getDimension(res.getDisplayMetrics());\nbreak;\ncase TypedValue.TYPE_FLOAT:\nnavType=checkNavType(value,navType,NavType.FloatType,argType,\"float\");\ndefaultValue=value.getFloat();\nbreak;\ncase TypedValue.TYPE_REFERENCE:\nnavType=checkNavType(value,navType,NavType.IntType,argType,\"reference\");\ndefaultValue=value.data;\nbreak;\ncase TypedValue.TYPE_INT_BOOLEAN:\nnavType=checkNavType(value,navType,NavType.BoolType,argType,\"boolean\");\ndefaultValue=value.data != 0;\nbreak;\ndefault :\nif (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {\nnavType=checkNavType(value,navType,NavType.IntType,argType,\"integer\");\ndefaultValue=value.data;\n}\n else {\nthrow new XmlPullParserException(\"unsupported argument type \" + value.type);\n}\n}\n}\n}\nif (defaultValue != null) {\nargumentBuilder.setDefaultValue(defaultValue);\n}\nif (navType != null) {\nargumentBuilder.setType(navType);\n}\nreturn argumentBuilder.build();\n}\n"}
{"INPUT": "@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){\n  mFragments.noteStateNotSaved();\n  int requestIndex=requestCode >> 16;\n  if (requestIndex != 0) {\n    requestIndex--;\n    String who=mPendingFragmentActivityResults.get(requestIndex);\n    mPendingFragmentActivityResults.remove(requestIndex);\n    if (who == null) {\n      Log.w(TAG,\"Activity result delivered for unknown Fragment.\");\n      return;\n    }\n    Fragment targetFragment=mFragments.findFragmentByWho(who);\n    if (targetFragment == null) {\n      Log.w(TAG,\"Activity result no fragment exists for who: \" + who);\n    }\n else {\n      targetFragment.onActivityResult(requestCode & 0xffff,resultCode,data);\n    }\n    return;\n  }\n// bug_start\n// bug_end\n  super.onActivityResult(requestCode,resultCode,data);\n}\n"}
{"INPUT": "public Object answer(InvocationOnMock invocation){\n  if (methodsGuru.isToString(invocation.getMethod())) {\n    Object mock=invocation.getMock();\n    MockName name=new MockUtil().getMockName(mock);\n// bug_start\n    if (name.isSurrogate()) {\n// bug_end\n      return \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \"+ mock.hashCode();\n    }\n else {\n      return name.toString();\n    }\n  }\n else   if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n    return 1;\n  }\n  Class<?> returnType=invocation.getMethod().getReturnType();\n  return returnValueFor(returnType);\n}\n"}
{"INPUT": "@Test public void testRule() throws IOException {\n  assertCorrect(\"Estas son las sillas blancas de las que te habl.\");\n  assertCorrect(\"La casa del pueblo blanca.\");\n  assertCorrect(\"La casa del pueblo blanco.\");\n  assertCorrect(\"La casa de pueblo blanca.\");\n  assertCorrect(\"La casa de pueblo blanco.\");\n  assertCorrect(\"Debes aprender a ser cuidadosa.\");\n  assertCorrect(\"No encontr nada nuevo.\");\n  assertCorrect(\"Si no ocurre nada imprevisto, maana podr verte.\");\n  assertCorrect(\"No habla solamente ingls, tambin habla francs.\");\n  assertCorrect(\"Algunas personas mueren de hambre incluso en medio de la abundancia.\");\n  assertCorrect(\"No leen muchos libros debido a la televisin.\");\n  assertCorrect(\"Hablas italiano?\");\n  assertCorrect(\"Dices una cosa y despus haces otra.\");\n  assertCorrect(\"Sali de casa temprano para llegar a tiempo\");\n  assertCorrect(\"l cra vacas y caballos\");\n  assertCorrect(\"Juan cra vacas y caballos\");\n// bug_start\n// bug_end\n  assertIncorrect(\"Anlisis clnica.\");\n  assertIncorrect(\"Estas son las sillas blancos de las que te habl.\");\n  assertIncorrect(\"Son casas rojos.\");\n  assertIncorrect(\"La casa del pueblo blancas\");\n  assertIncorrect(\"La casa del pueblo blancos\");\n  assertIncorrect(\"La casa de pueblo blancas\");\n  assertIncorrect(\"La casa de pueblo blancos\");\n  assertIncorrect(\"Un loro puede imitar el habla humano.\");\n}\n"}
{"INPUT": "void visualizeDropLocation(View v,DragPreviewProvider outlineProvider,int cellX,int cellY,int spanX,int spanY,boolean resize,DropTarget.DragObject dragObject){\n  final int oldDragCellX=mDragCell[0];\n  final int oldDragCellY=mDragCell[1];\n  if (outlineProvider == null || outlineProvider.generatedDragOutline == null) {\n    return;\n  }\n  Bitmap dragOutline=outlineProvider.generatedDragOutline;\n  if (cellX != oldDragCellX || cellY != oldDragCellY) {\n    Point dragOffset=dragObject.dragView.getDragVisualizeOffset();\n    Rect dragRegion=dragObject.dragView.getDragRegion();\n    mDragCell[0]=cellX;\n    mDragCell[1]=cellY;\n    final int oldIndex=mDragOutlineCurrent;\n    mDragOutlineAnims[oldIndex].animateOut();\n    mDragOutlineCurrent=(oldIndex + 1) % mDragOutlines.length;\n    Rect r=mDragOutlines[mDragOutlineCurrent];\n    if (resize) {\n      cellToRect(cellX,cellY,spanX,spanY,r);\n    }\n else {\n      final int[] topLeft=mTmpPoint;\n      cellToPoint(cellX,cellY,topLeft);\n      int left=topLeft[0];\n      int top=topLeft[1];\n      if (v != null && dragOffset == null) {\n        MarginLayoutParams lp=(MarginLayoutParams)v.getLayoutParams();\n        left+=lp.leftMargin;\n        top+=lp.topMargin;\n// bug_start\n        top+=(v.getHeight() - dragOutline.getHeight()) / 2;\n// bug_end\n        left+=((mCellWidth * spanX) - dragOutline.getWidth()) / 2;\n      }\n else {\n        if (dragOffset != null && dragRegion != null) {\n          left+=dragOffset.x + ((mCellWidth * spanX) - dragRegion.width()) / 2;\n          int cHeight=getShortcutsAndWidgets().getCellContentHeight();\n          int cellPaddingY=(int)Math.max(0,((mCellHeight - cHeight) / 2f));\n          top+=dragOffset.y + cellPaddingY;\n        }\n else {\n          left+=((mCellWidth * spanX) - dragOutline.getWidth()) / 2;\n          top+=((mCellHeight * spanY) - dragOutline.getHeight()) / 2;\n        }\n      }\n      r.set(left,top,left + dragOutline.getWidth(),top + dragOutline.getHeight());\n    }\n    Utilities.scaleRectAboutCenter(r,getChildrenScale());\n    mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);\n    mDragOutlineAnims[mDragOutlineCurrent].animateIn();\n    if (dragObject.stateAnnouncer != null) {\n      String msg;\n      if (isHotseat()) {\n        msg=getContext().getString(R.string.move_to_hotseat_position,Math.max(cellX,cellY) + 1);\n      }\n else {\n        msg=getContext().getString(R.string.move_to_empty_cell,cellY + 1,cellX + 1);\n      }\n      dragObject.stateAnnouncer.announce(msg);\n    }\n  }\n}\n"}
{"INPUT": "@Test public void convertVarName() throws Exception {\n  Assert.assertEquals(fakeJavaCodegen.toVarName(\"name\"),\"name\");\n  Assert.assertEquals(fakeJavaCodegen.toVarName(\"$name\"),\"$name\");\n  Assert.assertEquals(fakeJavaCodegen.toVarName(\"nam$$e\"),\"nam$$e\");\n  Assert.assertEquals(fakeJavaCodegen.toVarName(\"user-name\"),\"userName\");\n  Assert.assertEquals(fakeJavaCodegen.toVarName(\"user_name\"),\"userName\");\n  Assert.assertEquals(fakeJavaCodegen.toVarName(\"user|name\"),\"userName\");\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "private static RoaringBitmap read(String classPathResource){\n  try {\n// bug_start\n    OrderedWriter writer=new OrderedWriter();\n// bug_end\n    Arrays.stream(Files.readFirstLine(new File(classPathResource),Charset.forName(\"UTF-8\")).split(\",\")).mapToInt(null).forEach(null);\n    writer.flush();\n    return writer.getUnderlying();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n"}
{"INPUT": "public Entry(Object message,Object multipleAtmoResources,BroadcasterFuture<?> future,boolean writeLocally){\n  this.message=message;\n  this.multipleAtmoResources=multipleAtmoResources;\n  this.future=future;\n  this.writeLocally=writeLocally;\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public MatchQuery getMatchQuery(){\n// bug_start\n  if (selectVars.isEmpty())   return Graql.match(pattern).withGraph(graph);\n else   return Graql.match(pattern).select(selectVars).withGraph(graph);\n// bug_end\n}\n"}
{"INPUT": "@Override protected void convertProperties(){\n  getUpdater().transfer(\"maxTotal\",\"maximumPoolSize\");\n// bug_start\n  getUpdater().transfer(\"maxIdle\",\"idleTimeout\");\n// bug_end\n  getUpdater().transfer(\"maxWaitMillis\",\"connectionTimeout\");\n  getUpdater().transfer(\"maxConnLifetimeMillis\",\"maxLifetime\");\n// bug_start\n// bug_end\n  getUpdater().getDelegateMap().put(\"proxyDatasourceType\",ProxyPoolType.TOMCAT_DBCP2);\n}\n"}
{"INPUT": "@Override public void close(ChannelHandlerContext ctx,ChannelPromise promise) throws Exception {\n  MessageMetrics metrics=ctx.attr(ATTR_KEY_METRICS).get();\n// bug_start\n  m_collector.addMetrics(metrics);\n// bug_end\n  super.close(ctx,promise);\n}\n"}
{"INPUT": "public void run(JobConf job,final TaskUmbilicalProtocol umbilical) throws IOException {\n  Class valueClass=job.getMapOutputValueClass();\n  Reducer reducer=(Reducer)ReflectionUtils.newInstance(job.getReducerClass(),job);\n  FileSystem lfs=FileSystem.getLocal(job);\n  copyPhase.complete();\n  List<Path> mapFilesList=new ArrayList();\n  for (int i=0; i < numMaps; i++) {\n    Path f=mapOutputFile.getInputFile(i,getTaskId());\n    if (lfs.exists(f))     mapFilesList.add(f);\n  }\n  Path[] mapFiles=new Path[mapFilesList.size()];\n  mapFiles=mapFilesList.toArray(mapFiles);\n  Thread sortProgress=new Thread(){\n    public void run(){\n      while (!sortComplete) {\n        try {\n          reportProgress(umbilical);\n          Thread.sleep(PROGRESS_INTERVAL);\n        }\n catch (        InterruptedException e) {\n          return;\n        }\ncatch (        Throwable e) {\n          System.out.println(\"Thread Exception in \" + \"reporting sort progress\\n\" + StringUtils.stringifyException(e));\n          continue;\n        }\n      }\n    }\n  }\n;\n  sortProgress.setName(\"Sort progress reporter for task \" + getTaskId());\n  Path tempDir=job.getLocalPath(getTaskId());\n  WritableComparator comparator=job.getOutputKeyComparator();\n  SequenceFile.Sorter.RawKeyValueIterator rIter;\n  try {\n    setPhase(TaskStatus.Phase.SORT);\n    sortProgress.start();\n    SequenceFile.Sorter sorter=new SequenceFile.Sorter(lfs,comparator,valueClass,job);\n    rIter=sorter.merge(mapFiles,tempDir,!conf.getKeepFailedTaskFiles());\n  }\n  finally {\n    sortComplete=true;\n  }\n  sortPhase.complete();\n  setPhase(TaskStatus.Phase.REDUCE);\n  Reporter reporter=getReporter(umbilical,getProgress());\n  String finalName=getOutputName(getPartition());\n  boolean runSpeculative=job.getSpeculativeExecution();\n  FileSystem fs=FileSystem.get(job);\n  if (runSpeculative) {\n    fs=new PhasedFileSystem(fs,getJobId(),getTipId(),getTaskId());\n  }\n  final RecordWriter out=job.getOutputFormat().getRecordWriter(fs,job,finalName,reporter);\n  OutputCollector collector=new OutputCollector(){\n    public void collect(    WritableComparable key,    Writable value) throws IOException {\n      out.write(key,value);\n      myMetrics.reduceOutput();\n      reportProgress(umbilical);\n    }\n  }\n;\n  try {\n    Class keyClass=job.getMapOutputKeyClass();\n    Class valClass=job.getMapOutputValueClass();\n    ReduceValuesIterator values=new ReduceValuesIterator(rIter,comparator,keyClass,valClass,umbilical,job);\n    values.informReduceProgress();\n    while (values.more()) {\n      myMetrics.reduceInput();\n      reducer.reduce(values.getKey(),values,collector,reporter);\n      values.nextKey();\n      values.informReduceProgress();\n    }\n// bug_start\n  }\n  finally {\n// bug_end\n    reducer.close();\n    out.close(reporter);\n    if (runSpeculative) {\n      ((PhasedFileSystem)fs).commit();\n    }\n  }\n// bug_start\n// bug_end\n  done(umbilical);\n}\n"}
{"INPUT": "// bug_start\n@Override public long generate(ByteBufferPool.Lease lease,Frame frame){\n// bug_end\n  lease.append(ByteBuffer.wrap(PrefaceFrame.PREFACE_BYTES),false);\n  return PrefaceFrame.PREFACE_BYTES.length;\n}\n"}
{"INPUT": "private void runDisruptorPass() throws InterruptedException {\n  CountDownLatch latch=new CountDownLatch(1);\n  stepThreeFunctionHandler.reset(latch,stepThreeBatchProcessor.getSequence().get() + ITERATIONS);\n  EXECUTOR.submit(stepOneBatchProcessor);\n  EXECUTOR.submit(stepTwoBatchProcessor);\n  EXECUTOR.submit(stepThreeBatchProcessor);\n  for (long i=0; i < ITERATIONS; i++) {\n// bug_start\n// bug_end\n    long sequence=ringBuffer.next();\n// bug_start\n    ringBuffer.getPreallocated(sequence).setValue(System.nanoTime());\n// bug_end\n    ringBuffer.publish(sequence);\n    long pauseStart=System.nanoTime();\n    while (PAUSE_NANOS > (System.nanoTime() - pauseStart)) {\n    }\n  }\n  latch.await();\n  stepOneBatchProcessor.halt();\n  stepTwoBatchProcessor.halt();\n  stepThreeBatchProcessor.halt();\n}\n"}
{"INPUT": "@Override public void init(WrappedRequest request){\n// bug_start\n  setCaption(getClass().getName());\n// bug_end\n  Label label=new Label(getTestDescription(),ContentMode.XHTML);\n  label.setWidth(\"100%\");\n  layout=new VerticalLayout();\n  getContent().addComponent(label);\n  getContent().addComponent(layout);\n  ((VerticalLayout)getContent()).setExpandRatio(layout,1);\n  setup(request);\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n  if (args.length != 2) {\n    System.err.println(\"Usage: \" + SecureChatClient.class.getSimpleName() + \" <host> <port>\");\n    return;\n  }\n  String host=args[0];\n  int port=Integer.parseInt(args[1]);\n  ChannelFactory factory=new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());\n  ClientBootstrap bootstrap=new ClientBootstrap(factory);\n  SecureChatClientHandler handler=new SecureChatClientHandler();\n  bootstrap.setPipelineFactory(new SecureChatPipelineFactory(handler));\n  bootstrap.setOption(\"tcpNoDelay\",true);\n  bootstrap.setOption(\"keepAlive\",true);\n  ChannelFuture future=bootstrap.connect(new InetSocketAddress(host,port));\n  Channel channel=future.awaitUninterruptibly().getChannel();\n  if (!future.isSuccess()) {\n    future.getCause().printStackTrace();\n    factory.releaseExternalResources();\n    return;\n  }\n  ChannelFuture lastWriteFuture=null;\n  BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n  for (; ; ) {\n    String line=in.readLine();\n    if (line == null) {\n      break;\n    }\n    lastWriteFuture=channel.write(line + '\\n');\n// bug_start\n// bug_end\n  }\n  if (lastWriteFuture != null) {\n    lastWriteFuture.awaitUninterruptibly();\n  }\n  channel.close().awaitUninterruptibly();\n  factory.releaseExternalResources();\n}\n"}
{"INPUT": "public void start(){\n  String datePattern=getFirstOption();\n  if (datePattern == null) {\n    datePattern=CoreGlobal.ISO8601_PATTERN;\n  }\n// bug_start\n  if (datePattern.equals(CoreGlobal.ISO8601_FORMAT)) {\n// bug_end\n    datePattern=CoreGlobal.ISO8601_PATTERN;\n// bug_start\n  }\n else   if (datePattern.equals(CoreGlobal.DATE_AND_TIME_FORMAT)) {\n    datePattern=CoreGlobal.DATE_AND_TIME_PATTERN;\n  }\n else   if (datePattern.equals(CoreGlobal.ABSOLUTE_FORMAT)) {\n    datePattern=CoreGlobal.ABSOLUTE_PATTERN;\n// bug_end\n  }\n  try {\n    simpleFormat=new SimpleDateFormat(datePattern);\n  }\n catch (  IllegalArgumentException e) {\n    addWarn(\"Could not instantiate SimpleDateFormat with pattern \" + datePattern,e);\n    simpleFormat=new SimpleDateFormat(CoreGlobal.ISO8601_PATTERN);\n  }\n  List optionList=getOptionList();\n  if (optionList != null && optionList.size() > 1) {\n    TimeZone tz=TimeZone.getTimeZone((String)optionList.get(1));\n    simpleFormat.setTimeZone(tz);\n  }\n}\n"}
{"INPUT": "private void verifyCreateFile(TestUser user,String path,boolean recursive) throws Exception {\n  try (Closeable r=new AuthenticatedUserRule(user.getUser(),ServerConfiguration.global()).toResource()){\n    CreateFileContext context=CreateFileContext.mergeFrom(CreateFilePOptions.newBuilder().setRecursive(recursive)).setOwner(SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global())).setGroup(SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global())).setPersisted(true);\n// bug_start\n    long fileId=mFileSystemMaster.createFile(new AlluxioURI(path),context);\n    FileInfo fileInfo=mFileSystemMaster.getFileInfo(fileId);\n// bug_end\n    String[] pathComponents=path.split(\"/\");\n    assertEquals(pathComponents[pathComponents.length - 1],fileInfo.getName());\n    assertEquals(user.getUser(),fileInfo.getOwner());\n  }\n }\n"}
{"INPUT": "@Test public void testSourceImage_differentSourceRepository() throws IOException, InterruptedException, GeneralSecurityException, URISyntaxException {\n// bug_start\n  try (TestWebServer server=new TestWebServer(false)){\n// bug_end\n    try {\n      RegistryEndpointRequestProperties registryEndpointRequestProperties=new RegistryEndpointRequestProperties(\"someserver\",\"someimage\",\"anotherimage\");\n      RegistryAuthenticator authenticator=RegistryAuthenticator.fromAuthenticationMethod(\"Bearer realm=\\\"\" + server.getEndpoint() + \"\\\"\",registryEndpointRequestProperties,\"Competent-Agent\").get();\n      authenticator.authenticatePush(null);\n    }\n catch (    RegistryAuthenticationFailedException ex) {\n    }\n// bug_start\n    Assert.assertThat(server.getInputRead(),CoreMatchers.containsString(\"scope=repository:someimage:pull,push&scope=repository:anotherimage:pull\"));\n// bug_end\n  }\n }\n"}
{"INPUT": "// bug_start\n@SuppressWarnings(\"unchecked\") @Override public SQLRouteResult route(final SQLStatement sqlStatement,final List<Object> parameters){\n  OptimizedStatement optimizedStatement=ShardingOptimizeEngineFactory.newInstance(sqlStatement).optimize(shardingRule,shardingMetaData.getTable(),sqlStatement,parameters);\n// bug_end\n  boolean needMergeShardingValues=isNeedMergeShardingValues(optimizedStatement);\n  if (optimizedStatement instanceof ShardingConditionOptimizedStatement && needMergeShardingValues) {\n    checkSubqueryShardingValues(optimizedStatement,((ShardingConditionOptimizedStatement)optimizedStatement).getShardingConditions());\n    mergeShardingConditions(((ShardingConditionOptimizedStatement)optimizedStatement).getShardingConditions());\n  }\n  RoutingResult routingResult=RoutingEngineFactory.newInstance(shardingRule,shardingMetaData.getDataSource(),optimizedStatement).route();\n  if (needMergeShardingValues) {\n    Preconditions.checkState(1 == routingResult.getRoutingUnits().size(),\"Must have one sharding with subquery.\");\n  }\n  if (optimizedStatement instanceof ShardingInsertOptimizedStatement) {\n    setGeneratedValues((ShardingInsertOptimizedStatement)optimizedStatement);\n  }\n  SQLRouteResult result=new SQLRouteResult(optimizedStatement);\n  result.setRoutingResult(routingResult);\n  return result;\n}\n"}
{"INPUT": "protected String asCode(String[] lines){\n// bug_start\n  StringBuffer buffer=new StringBuffer();\n// bug_end\n  for (int i=0; i < lines.length; i++) {\n    buffer.append(lines[i]);\n    buffer.append(\"\\n\");\n  }\n  return buffer.toString();\n}\n"}
{"INPUT": "private void fetchGitHubRepository(final int repositoryId){\n  Log.d(TAG,\"fetchGitHubRepository(\" + repositoryId + \")\");\n  if (requestMap.containsKey(repositoryId) && !requestMap.get(repositoryId).isUnsubscribed()) {\n    Log.d(TAG,\"Found an ongoing request for repository \" + repositoryId);\n    return;\n  }\n  final String uri=getUniqueId(repositoryId);\n// bug_start\n  Subscription subscription=createNetworkObservable(repositoryId).subscribeOn(Schedulers.computation()).doOnError(doOnError(uri)).doOnCompleted(null).subscribe(null,null);\n// bug_end\n  requestMap.put(repositoryId,subscription);\n// bug_start\n  startRequest(uri);\n// bug_end\n}\n"}
{"INPUT": "public synchronized <T>T output(@NonNull INDArray inputs,INDArray inputMasks,INDArray labelMasks,@NonNull OutputAdapter<T> outputAdapter){\n  try (val ws=Nd4j.getWorkspaceManager().getAndActivateWorkspace(WS_ALL_LAYERS_ACT_CONFIG,WS_OUTPUT_MEM)){\n// bug_start\n    return outputAdapter.apply(output(inputs,false,inputMasks,labelMasks,ws));\n// bug_end\n  }\n }\n"}
{"INPUT": "// bug_start\nprivate MultiTaskSlot(SlotRequestId slotRequestId,@Nullable AbstractID groupId,MultiTaskSlot parent,CompletableFuture<? extends SlotContext> slotContextFuture,SlotRequestId allocatedSlotRequestId){\n// bug_end\n  super(slotRequestId,groupId);\n  this.parent=parent;\n  this.slotContextFuture=Preconditions.checkNotNull(slotContextFuture);\n  this.allocatedSlotRequestId=allocatedSlotRequestId;\n  this.children=new HashMap<>(16);\n  this.releasingChildren=false;\n  slotContextFuture.whenComplete(null);\n}\n"}
{"INPUT": "public String getMethodSigureWithReturnTypeInMapping(String returnTypeWithNumber,String methodSignure){\n// bug_start\n// bug_end\n  return getMethodSignureWithReturnType(returnTypeWithNumber.substring(returnTypeWithNumber.lastIndexOf(\":\") + 1),methodSignure);\n}\n"}
{"INPUT": "private boolean rebalanceByMovingReplicasOut(Broker broker,ClusterModel clusterModel,Set<Goal> optimizedGoals,OptimizationOptions optimizationOptions){\n  Set<String> excludedTopics=optimizationOptions.excludedTopics();\n  SortedSet<Broker> candidateBrokers=new TreeSet<>(Comparator.comparingInt(null).thenComparingInt(null));\n  candidateBrokers.addAll(_selfHealingDeadBrokersOnly ? clusterModel.aliveBrokers() : clusterModel.aliveBrokers().stream().filter(null).collect(Collectors.toSet()));\n  List<Replica> replicasToMove=broker.trackedSortedReplicas(name()).sortedReplicas();\n// bug_start\n// bug_end\n  for (  Replica replica : replicasToMove) {\n    if (shouldExclude(replica,excludedTopics)) {\n      continue;\n    }\n    Broker b=maybeApplyBalancingAction(clusterModel,replica,candidateBrokers,ActionType.INTER_BROKER_REPLICA_MOVEMENT,optimizedGoals,optimizationOptions);\n    if (b != null) {\n      if (broker.replicas().size() <= (broker.isAlive() ? _balanceUpperLimit : 0)) {\n        return false;\n      }\n      candidateBrokers.remove(b);\n      if (b.replicas().size() < _balanceUpperLimit || _selfHealingDeadBrokersOnly) {\n        candidateBrokers.add(b);\n      }\n    }\n  }\n  return !broker.replicas().isEmpty();\n}\n"}
{"INPUT": "@Override public void run(){\n  try {\n    prepare();\n    futures=schedule(settings);\n    if (!futures.isEmpty()) {\n      logger.debug(\"waiting for {} futures...\",futures.size());\n      for (      Future future : futures) {\n        try {\n          Object o=future.get();\n          logger.debug(\"got future {}\",o);\n        }\n catch (        CancellationException e) {\n          logger.warn(\"schedule canceled\");\n        }\ncatch (        InterruptedException e) {\n          logger.error(e.getMessage());\n        }\ncatch (        ExecutionException e) {\n          logger.error(e.getMessage(),e);\n        }\n      }\n      logger.debug(\"futures complete\");\n    }\n else {\n      execute();\n    }\n  }\n catch (  Throwable e) {\n    logger.error(e.getMessage(),e);\n  }\n finally {\n    try {\n// bug_start\n// bug_end\n      if (context != null) {\n        context.shutdown();\n        context=null;\n      }\n    }\n catch (    Throwable e) {\n      logger.warn(e.getMessage(),e);\n    }\n  }\n}\n"}
{"INPUT": "public void testPersistentNodeId() throws IOException {\n// bug_start\n  String[] paths=tmpPaths();\n  NodeEnvironment env=newNodeEnvironment(paths,Settings.builder().put(\"node.local_storage\",false).put(\"node.master\",false).put(\"node.data\",false).build());\n// bug_end\n  String nodeID=env.nodeId();\n  env.close();\n// bug_start\n// bug_end\n  env=newNodeEnvironment(paths,Settings.EMPTY);\n  assertThat(\"previous node didn't have local storage enabled, id should change\",env.nodeId(),not(equalTo(nodeID)));\n  nodeID=env.nodeId();\n  env.close();\n  env=newNodeEnvironment(paths,Settings.EMPTY);\n  assertThat(env.nodeId(),equalTo(nodeID));\n  env.close();\n  env=newNodeEnvironment(Settings.EMPTY);\n  assertThat(env.nodeId(),not(equalTo(nodeID)));\n  env.close();\n}\n"}
{"INPUT": "@Test public void shouldBeAbleToBuildTopologyIncrementally(){\n  final StreamsBuilder builder=new StreamsBuilder();\n  final KStream<String,String> stream=builder.stream(\"topic\");\n  final KStream<String,String> streamII=builder.stream(\"other-topic\");\n  final ValueJoiner<String,String,String> valueJoiner=null;\n  final KStream<String,String> joinedStream=stream.join(streamII,valueJoiner,JoinWindows.of(5000));\n  assertEquals(expectedJoinedTopology,builder.build().describe().toString());\n// bug_start\n  KStream<String,String> filteredJoinStream=joinedStream.filter(null);\n// bug_end\n  assertEquals(expectedJoinedFilteredTopology,builder.build().describe().toString());\n  filteredJoinStream.mapValues(null).to(\"output-topic\");\n  assertEquals(expectedFullTopology,builder.build().describe().toString());\n}\n"}
{"INPUT": "public void testPrimaryResultIncludeOnlyAppliedOperations() throws Exception {\n  final Settings settings=Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(),true).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(),true).build();\n  final IndexShard oldPrimary=newStartedShard(true,settings,new FollowingEngineFactory());\n  final long oldPrimaryTerm=oldPrimary.getOperationPrimaryTerm();\n  long seqno=0;\n  List<Translog.Operation> firstBulk=new ArrayList<>();\n  List<Translog.Operation> secondBulk=new ArrayList<>();\n  for (int numOps=between(1,100), i=0; i < numOps; i++) {\n    final String id=Integer.toString(between(1,100));\n    final Translog.Operation op;\n    if (randomBoolean()) {\n      op=new Translog.Index(\"_doc\",id,seqno++,primaryTerm,0,SOURCE,null,-1);\n    }\n// bug_start\n// bug_end\n else {\n// bug_start\n      op=new Translog.Delete(\"_doc\",id,new Term(\"_id\",Uid.encodeId(id)),seqno++,primaryTerm,0);\n// bug_end\n    }\n    if (randomBoolean()) {\n      firstBulk.add(op);\n    }\n else {\n      secondBulk.add(op);\n    }\n    if (rarely()) {\n      oldPrimary.refresh(\"test\");\n    }\n    if (rarely()) {\n      oldPrimary.flush(new FlushRequest());\n    }\n  }\n  Randomness.shuffle(firstBulk);\n  Randomness.shuffle(secondBulk);\n  oldPrimary.advanceMaxSeqNoOfUpdatesOrDeletes(seqno);\n  final CcrWritePrimaryResult fullResult=TransportBulkShardOperationsAction.shardOperationOnPrimary(oldPrimary.shardId(),oldPrimary.getHistoryUUID(),firstBulk,seqno,oldPrimary,logger);\n  assertThat(fullResult.replicaRequest().getOperations(),equalTo(firstBulk.stream().map(null).collect(Collectors.toList())));\n  primaryTerm=randomLongBetween(primaryTerm,primaryTerm + 10);\n  final IndexShard newPrimary=reinitShard(oldPrimary);\n  DiscoveryNode localNode=new DiscoveryNode(\"foo\",buildNewFakeTransportAddress(),emptyMap(),emptySet(),Version.CURRENT);\n  newPrimary.markAsRecovering(\"store\",new RecoveryState(newPrimary.routingEntry(),localNode,null));\n  assertTrue(newPrimary.recoverFromStore());\n  IndexShardTestCase.updateRoutingEntry(newPrimary,newPrimary.routingEntry().moveToStarted());\n  newPrimary.advanceMaxSeqNoOfUpdatesOrDeletes(seqno);\n  final List<Translog.Operation> existingOps=randomSubsetOf(firstBulk);\n  final CcrWritePrimaryResult partialResult=TransportBulkShardOperationsAction.shardOperationOnPrimary(newPrimary.shardId(),newPrimary.getHistoryUUID(),Stream.concat(secondBulk.stream(),existingOps.stream()).collect(Collectors.toList()),seqno,newPrimary,logger);\n  final long newPrimaryTerm=newPrimary.getOperationPrimaryTerm();\n  final long globalCheckpoint=newPrimary.getGlobalCheckpoint();\n  final List<Translog.Operation> appliedOperations=Stream.concat(secondBulk.stream().map(null),existingOps.stream().filter(null).map(null)).collect(Collectors.toList());\n  assertThat(partialResult.replicaRequest().getOperations(),equalTo(appliedOperations));\n  closeShards(newPrimary);\n}\n"}
{"INPUT": "// bug_start\npublic List<XSAttributeUse> getAttributeUses(){\n// bug_end\n  List<XSAttributeUse> v=new ArrayList<XSAttributeUse>();\n  v.addAll(attributes.values());\n  for (  XSAttGroupDecl agd : getAttGroups())   v.addAll(agd.getAttributeUses());\n  return v;\n}\n"}
{"INPUT": "private MergedResult build() throws SQLException {\n  if (!optimizedStatement.getGroupBy().getItems().isEmpty() || !optimizedStatement.getAggregationSelectItems().isEmpty()) {\n    return getGroupByMergedResult();\n  }\n// bug_start\n  if (!optimizedStatement.getOrderByItems().isEmpty()) {\n    return new OrderByStreamMergedResult(queryResults,optimizedStatement.getOrderByItems());\n// bug_end\n  }\n  return new IteratorStreamMergedResult(queryResults);\n}\n"}
{"INPUT": "// bug_start\npublic static AllocationShape buildAllocationShape(DataBuffer array){\n// bug_end\n  AllocationShape shape=new AllocationShape();\n  shape.setStride(1);\n// bug_start\n  shape.setOffset(0);\n  shape.setDataType(array.dataType());\n  shape.setLength(array.length());\n// bug_end\n  return shape;\n}\n"}
{"INPUT": "private void checkViewExist(View view){\nsynchronized (doLoadingViews) {\n// bug_start\n    for (    View v : doLoadingViews) {\n      if (v.equals(view)) {\n        String url=(String)v.getTag();\n        if (!StringUtils.isEmpty(url)) {\n          cancle(url);\n          break;\n        }\n// bug_end\n      }\n    }\n    doLoadingViews.add(view);\n  }\n}\n"}
{"INPUT": "// bug_start\n@Inject public RestMoreLikeThisAction(Settings settings,Client client,RestController controller){\n  super(settings,client);\n// bug_end\n  controller.registerHandler(GET,\"/{index}/{type}/{id}/_mlt\",this);\n  controller.registerHandler(POST,\"/{index}/{type}/{id}/_mlt\",this);\n}\n"}
{"INPUT": "// bug_start\n@Override public RequestHeadersSpec<?> body(Object body){\n// bug_end\n  Assert.isTrue(!(body instanceof Publisher),\"Please specify the element class by \" + \"using body(Publisher, Class)\");\n  this.inserter=BodyInserters.fromObject(body);\n  return this;\n}\n"}
{"INPUT": "public byte[] modify(ClassLoader classLoader,String javassistClassName,ProtectionDomain protectedDomain,byte[] classFileBuffer){\n  if (logger.isLoggable(Level.INFO)) {\n    logger.info(\"Modifing. \" + javassistClassName);\n  }\n  byteCodeInstrumentor.checkLibrary(classLoader,javassistClassName);\n  try {\n// bug_start\n    Interceptor interceptor=newInterceptor(classLoader,protectedDomain,\"com.profiler.modifier.connector.interceptors.ExecuteMethodInterceptor\");\n// bug_end\n    InstrumentClass aClass=byteCodeInstrumentor.getClass(javassistClassName);\n    aClass.addInterceptor(\"execute\",new String[]{\"org.apache.http.HttpHost\",\"org.apache.http.HttpRequest\",\"org.apache.http.client.ResponseHandler\",\"org.apache.http.protocol.HttpContext\"},interceptor);\n    return aClass.toBytecode();\n  }\n catch (  InstrumentException e) {\n    return null;\n  }\n}\n"}
{"INPUT": "private GetClusterRequest(com.google.protobuf.CodedInputStream input,com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\n  this();\n// bug_start\n// bug_end\n  int mutable_bitField0_=0;\n  com.google.protobuf.UnknownFieldSet.Builder unknownFields=com.google.protobuf.UnknownFieldSet.newBuilder();\n  try {\n    boolean done=false;\n    while (!done) {\n      int tag=input.readTag();\nswitch (tag) {\ncase 0:\n        done=true;\n      break;\ndefault :\n{\n      if (!parseUnknownFieldProto3(input,unknownFields,extensionRegistry,tag)) {\n        done=true;\n      }\n      break;\n    }\ncase 10:\n{\n    java.lang.String s=input.readStringRequireUtf8();\n    projectId_=s;\n    break;\n  }\ncase 18:\n{\n  java.lang.String s=input.readStringRequireUtf8();\n  clusterName_=s;\n  break;\n}\ncase 26:\n{\njava.lang.String s=input.readStringRequireUtf8();\nregion_=s;\nbreak;\n}\n}\n}\n}\n catch (com.google.protobuf.InvalidProtocolBufferException e) {\nthrow e.setUnfinishedMessage(this);\n}\ncatch (java.io.IOException e) {\nthrow new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);\n}\n finally {\nthis.unknownFields=unknownFields.build();\nmakeExtensionsImmutable();\n}\n}\n"}
{"INPUT": "@ParameterizedTest @MethodSource(\"formContentSizeScenarios\") public void testMaxFormContentSizeExceeded(Integer maxFormContentSize,boolean withContentLength) throws Exception {\n  start(null);\n  byte[] key=\"foo=\".getBytes(StandardCharsets.US_ASCII);\n  int length=(maxFormContentSize == null || maxFormContentSize < 0) ? ContextHandler.DEFAULT_MAX_FORM_CONTENT_SIZE : maxFormContentSize;\n  length=length + 1;\n  byte[] value=new byte[length];\n  Arrays.fill(value,(byte)'x');\n  AsyncRequestContent content=new AsyncRequestContent(ByteBuffer.wrap(key),ByteBuffer.wrap(value));\n// bug_start\n  ContentResponse response=client.newRequest(\"localhost\",connector.getLocalPort()).method(HttpMethod.POST).path(contextPath + servletPath).header(HttpHeader.CONTENT_TYPE,MimeTypes.Type.FORM_ENCODED.asString()).body(content).onRequestBegin(null).onRequestCommit(null).send();\n// bug_end\n  int expected=(maxFormContentSize != null && maxFormContentSize < 0) ? HttpStatus.OK_200 : HttpStatus.BAD_REQUEST_400;\n  assertEquals(expected,response.getStatus());\n}\n"}
{"INPUT": "private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n  Thread indexThread=new Thread(){\n    @Override public void run(){\n      Random random=random();\n      int max=atLeast(random,200);\n      for (int id=101; id < max; id++) {\n        try {\n          doAddDoc(String.valueOf(id));\n        }\n catch (        Exception e) {\n          log.error(\"Exception while adding docs\",e);\n        }\n      }\n    }\n  }\n;\n  indexThread.start();\n  try (SolrClient client=createNewSolrClient(\"\",getBaseUrl((HttpSolrClient)clients.get(0)))){\n    SplitShard splitShardRequest=CollectionAdminRequest.splitShard(\"collection1\").setShardName(SHARD1);\n    splitShardRequest.processAsync(\"2000\",client);\n    RequestStatusState state=getRequestState(\"2000\",client);\n    while (state == RequestStatusState.SUBMITTED) {\n      state=getRequestState(\"2000\",client);\n      Thread.sleep(10);\n    }\n    assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",RequestStatusState.RUNNING,state);\n    ModifiableSolrParams params=new ModifiableSolrParams();\n    params.set(\"action\",CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n    params.set(\"collection\",\"collection1\");\n// bug_start\n    SolrRequest request=new QueryRequest(params);\n// bug_end\n    request.setPath(\"/admin/collections\");\n    client.request(request);\n    state=getRequestState(\"2000\",client);\n    assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \" + \"isn't. It is [\" + state + \"]\",RequestStatusState.RUNNING,state);\n  }\n  finally {\n    try {\n      indexThread.join();\n    }\n catch (    InterruptedException e) {\n      log.warn(\"Indexing thread interrupted.\");\n    }\n  }\n}\n"}
{"INPUT": "public boolean isValid(){\n  if (maxValidTime > 0) {\n    long timeNow=System.currentTimeMillis();\n    int timeIdle=(int)((timeNow - creationTime) / 1000L);\n    if (timeIdle > maxValidTime) {\n      cleanup();\n// bug_start\n      if (file.exists())       file.delete();\n// bug_end\n      return false;\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "private MessageBase createDashboard(User user,String dashString,int msgId) throws IOException {\n  DashBoard newDash=JsonParser.parseDashboard(dashString,msgId);\n  newDash.id=max(user.profile.dashBoards) + 1;\n// bug_start\n// bug_end\n  if (user.profile.dashBoards.length >= dashMaxLimit) {\n    log.debug(\"Dashboards limit reached.\");\n    return quotaLimit(msgId);\n  }\n  for (  DashBoard dashBoard : user.profile.dashBoards) {\n    if (dashBoard.id == newDash.id) {\n      log.debug(\"Dashboard already exists.\");\n      return notAllowed(msgId);\n    }\n  }\n  log.info(\"Creating new cloned dashboard.\");\n  if (newDash.createdAt == 0) {\n    newDash.createdAt=System.currentTimeMillis();\n  }\n  int price=newDash.energySum();\n  if (user.notEnoughEnergy(price)) {\n    log.debug(\"Not enough energy.\");\n    return energyLimit(msgId);\n  }\n  user.subtractEnergy(price);\n  user.profile.dashBoards=ArrayUtil.add(user.profile.dashBoards,newDash,DashBoard.class);\n  if (newDash.devices != null) {\n    for (    Device device : newDash.devices) {\n      String token=TokenGeneratorUtil.generateNewToken();\n      tokenManager.assignToken(user,newDash,device,token);\n    }\n  }\n  user.lastModifiedTs=System.currentTimeMillis();\n  newDash.addTimers(timerWorker,new UserKey(user));\n  byte[] data=ByteUtils.compress(dashString);\n  return makeBinaryMessage(GET_PROJECT_BY_CLONE_CODE,msgId,data);\n}\n"}
{"INPUT": "// bug_start\n@Test @Ignore public void testSumAsGivenValue(){\n// bug_end\n  String expected=\"\" + \"rule \\\"my rule\\\" \\n\" + \"  dialect \\\"mvel\\\"\\n\"+ \"  when\\n\"+ \"    m:Message()\\n\"+ \"  then\\n\"+ \"    m.setText( \\\"Hello \\\" + \\\"world\\\" );\\n\"+ \"    update(m);\\n\"+ \"end\\n\";\n  final RuleModel m=new RuleModel();\n  FactPattern factPattern=new FactPattern();\n  factPattern.setFactType(\"Message\");\n  factPattern.setBoundName(\"m\");\n  m.lhs=new IPattern[]{factPattern};\n  ActionUpdateField actionUpdateField=new ActionUpdateField();\n  actionUpdateField.setVariable(\"m\");\n  ActionFieldValue actionFieldValue=new ActionFieldValue();\n  actionFieldValue.setField(\"text\");\n  actionFieldValue.setType(\"String\");\n  actionFieldValue.setNature(FieldNatureType.TYPE_FORMULA);\n  actionFieldValue.setValue(\"\\\"Hello \\\" + \\\"world\\\"\");\n  actionUpdateField.setFieldValues(new ActionFieldValue[]{actionFieldValue});\n  m.rhs=new IAction[]{actionUpdateField};\n  m.name=\"my rule\";\n  checkMarshallUnmarshall(expected,m);\n}\n"}
{"INPUT": "// bug_start\npublic String getRootPOM(){\n// bug_end\n  if (rootPOM == null)   return \"pom.xml\";\n// bug_start\n  return rootPOM;\n// bug_end\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n  System.out.println(\"\\nTest5\\n\");\n  ScriptEngineManager m=new ScriptEngineManager();\n// bug_start\n  ScriptEngine engine=m.getEngineByName(\"js\");\n// bug_end\n  Bindings g=new SimpleBindings();\n  Bindings e=new SimpleBindings();\n  g.put(\"key\",\"value in global\");\n  e.put(\"key\",\"value in engine\");\n  ScriptContext ctxt=new SimpleScriptContext();\n  ctxt.setBindings(e,ScriptContext.ENGINE_SCOPE);\n  System.out.println(\"engine scope only\");\n  e.put(\"count\",new Integer(1));\n  Reader reader=new FileReader(new File(System.getProperty(\"test.src\",\".\"),\"Test5.js\"));\n  engine.eval(reader,ctxt);\n  System.out.println(\"both scopes\");\n  ctxt.setBindings(g,ScriptContext.GLOBAL_SCOPE);\n  e.put(\"count\",new Integer(2));\n  engine.eval(reader,ctxt);\n  System.out.println(\"only global\");\n  e.put(\"count\",new Integer(3));\n  ctxt.setAttribute(\"key\",null,ScriptContext.ENGINE_SCOPE);\n  engine.eval(reader,ctxt);\n}\n"}
{"INPUT": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n// bug_start\n// bug_end\n  setTitle(R.string.select_room_directory);\n  setContentView(R.layout.activity_room_directory_picker);\n  ButterKnife.bind(this);\n  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);\n  if (toolbar != null) {\n    setSupportActionBar(toolbar);\n    if (getSupportActionBar() != null) {\n      getSupportActionBar().setDisplayShowHomeEnabled(true);\n      getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n    }\n  }\n  final Intent intent=getIntent();\n  String sessionId=intent.getStringExtra(EXTRA_SESSION_ID);\n  if (null != sessionId) {\n    mSession=Matrix.getInstance(this).getSession(sessionId);\n  }\n  if (null == mSession) {\n    this.finish();\n    return;\n  }\n  initViews();\n}\n"}
{"INPUT": "// bug_start\nprivate byte[] loadImgFromNet(String imagePath){\n// bug_end\n  byte[] data=null;\n  HttpURLConnection con=null;\n  try {\n    URL url=new URL(imagePath);\n    con=(HttpURLConnection)url.openConnection();\n    con.setConnectTimeout(config.timeOut);\n    con.setReadTimeout(config.timeOut * 2);\n    con.setRequestMethod(\"GET\");\n    con.setDoInput(true);\n    con.connect();\n    data=FileUtils.input2byte(con.getInputStream());\n    if (config.openDiskCache) {\n      FileUtils.saveFileCache(data,FileUtils.getSavePath(config.cachePath),CipherUtils.md5(imagePath));\n    }\n    if (config.isDEBUG) {\n      KJLoger.debugLog(getClass().getName(),\"download success, from be net\\n\" + imagePath);\n    }\n  }\n catch (  Exception e) {\n    if (config.callBack != null) {\n      config.callBack.imgLoadFailure(imagePath,e.getMessage());\n    }\n    e.printStackTrace();\n  }\n finally {\n    if (con != null) {\n      con.disconnect();\n    }\n  }\n  return data;\n}\n"}
{"INPUT": "private void ignoreRSForSchemaChange(SchemaChangeTracker.SchemaAlterStatus schemaAlterStatus){\n  LOG.debug(\"Removing RS \" + schemaAlterStatus.getHostName() + \" from schema change process.\");\n// bug_start\n  hostsToProcess=new String(hostsToProcess).replaceAll(schemaAlterStatus.getHostName(),\"\");\n// bug_end\n  int ignoreRegionsCount=schemaAlterStatus.getNumberOfOnlineRegions();\n  LOG.debug(\"Current number of regions processed = \" + this.numberOfRegionsProcessed + \" deducting ignored = \"+ ignoreRegionsCount+ \" final = \"+ (this.numberOfRegionsToProcess - ignoreRegionsCount));\n  if (this.numberOfRegionsToProcess > 0) {\n    this.numberOfRegionsToProcess-=ignoreRegionsCount;\n  }\n else {\n    LOG.debug(\"Number of regions to process is less than zero. This is odd\");\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override protected void startInternal() throws LifecycleException {\n// bug_end\n  failedUsers=new LinkedHashMap<String,LockRecord>(cacheSize,0.75f,true){\n    private static final long serialVersionUID=1L;\n    @Override protected boolean removeEldestEntry(    Map.Entry<String,LockRecord> eldest){\n      if (size() > cacheSize) {\n        long timeInCache=(System.currentTimeMillis() - eldest.getValue().getLastFailureTime()) / 1000;\n        if (timeInCache < cacheRemovalWarningTime) {\n          log.warn(sm.getString(\"lockOutRealm.removeWarning\",eldest.getKey(),Long.valueOf(timeInCache)));\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n;\n  super.startInternal();\n}\n"}
{"INPUT": "static public long longCast(Object x){\n  if (x instanceof Integer || x instanceof Long)   return ((Number)x).longValue();\n else   if (x instanceof BigInt) {\n    BigInt bi=(BigInt)x;\n    if (bi.bipart == null)     return bi.lpart;\n else     throw new IllegalArgumentException(\"Value out of range for long: \" + x);\n  }\n else   if (x instanceof BigInteger) {\n    BigInteger bi=(BigInteger)x;\n    if (bi.bitLength() < 64)     return bi.longValue();\n else     throw new IllegalArgumentException(\"Value out of range for long: \" + x);\n  }\n// bug_start\n  return ((Number)x).longValue();\n// bug_end\n}\n"}
{"INPUT": "protected void leaked(LeakDetector<ByteBuffer>.LeakInfo leakInfo){\n// bug_start\n  LOG.warn(\"ByteBuffer \" + leakInfo.getResourceDescription() + \" leaked at:\",leakInfo.getStackFrames());\n// bug_end\n}\n"}
{"INPUT": "private int processPage(WebURL curURL){\n  if (curURL == null) {\n    return -1;\n  }\n  try {\n    int statusCode=pageFetcher.fetchHeader(curURL);\n    if (statusCode != PageFetchStatus.OK) {\n      if (statusCode == PageFetchStatus.Moved) {\n        if (myController.getConfig().isFollowRedirects()) {\n          String movedToUrl=curURL.getURL();\n          if (movedToUrl == null) {\n            return PageFetchStatus.MovedToUnknownLocation;\n          }\n          int newDocId=docIdServer.getDocId(movedToUrl);\n          if (newDocId > 0) {\n            return PageFetchStatus.RedirectedPageIsSeen;\n          }\n else {\n            WebURL webURL=new WebURL();\n            webURL.setURL(movedToUrl);\n            webURL.setParentDocid(curURL.getParentDocid());\n            webURL.setDepth(curURL.getDepth());\n            webURL.setDocid(-1);\n            if (shouldVisit(webURL) && robotstxtServer.allows(webURL)) {\n              webURL.setDocid(docIdServer.getNewDocID(movedToUrl));\n              frontier.schedule(webURL);\n            }\n          }\n        }\n        return PageFetchStatus.Moved;\n      }\n else       if (statusCode == PageFetchStatus.PageTooBig) {\n        logger.info(\"Skipping a page which was bigger than max allowed size: \" + curURL.getURL());\n      }\n      return statusCode;\n    }\n    if (!curURL.getURL().equals(pageFetcher.getFetchedUrl())) {\n      if (docIdServer.isSeenBefore(pageFetcher.getFetchedUrl())) {\n        return PageFetchStatus.RedirectedPageIsSeen;\n      }\n      curURL.setURL(pageFetcher.getFetchedUrl());\n      curURL.setDocid(docIdServer.getNewDocID(pageFetcher.getFetchedUrl()));\n    }\n    Page page=new Page(curURL);\n    int docid=curURL.getDocid();\n    if (pageFetcher.fetchContent(page) && parser.parse(page,curURL.getURL())) {\n      ParseData parseData=page.getParseData();\n      if (parseData instanceof HtmlParseData) {\n        HtmlParseData htmlParseData=(HtmlParseData)parseData;\n        List<WebURL> toSchedule=new ArrayList<WebURL>();\n        int maxCrawlDepth=myController.getConfig().getMaxDepthOfCrawling();\n        for (        WebURL webURL : htmlParseData.getOutgoingUrls()) {\n          webURL.setParentDocid(docid);\n          int newdocid=docIdServer.getDocId(webURL.getURL());\n          if (newdocid > 0) {\n            webURL.setDepth((short)-1);\n            webURL.setDocid(newdocid);\n          }\n else {\n            webURL.setDocid(-1);\n            webURL.setDepth((short)(curURL.getDepth() + 1));\n// bug_start\n            if (shouldVisit(webURL) && robotstxtServer.allows(webURL)) {\n              if (maxCrawlDepth == -1 || curURL.getDepth() < maxCrawlDepth) {\n// bug_end\n                webURL.setDocid(docIdServer.getNewDocID(webURL.getURL()));\n                toSchedule.add(webURL);\n              }\n            }\n          }\n        }\n        frontier.scheduleAll(toSchedule);\n      }\n      visit(page);\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    logger.error(e.getMessage() + \", while processing: \" + curURL.getURL());\n  }\n finally {\n    pageFetcher.discardContentIfNotConsumed();\n  }\n  return 0;\n}\n"}
{"INPUT": "// bug_start\n@Override public void setCustomSelectionActionModeCallback(ActionMode.Callback actionModeCallback){\n// bug_end\n  super.setCustomSelectionActionModeCallback(TextViewCompat.wrapCustomSelectionActionModeCallback(this,actionModeCallback));\n}\n"}
{"INPUT": "private void validateApexSignature(PackageInfo newApexPkg,int installFlags) throws PackageManagerException {\n  final String apexPath=newApexPkg.applicationInfo.sourceDir;\n  final String packageName=newApexPkg.packageName;\n  final SigningDetails signingDetails;\n  try {\n    signingDetails=ApkSignatureVerifier.verify(apexPath,SignatureSchemeVersion.JAR);\n  }\n catch (  PackageParserException e) {\n    throw new PackageManagerException(SessionInfo.STAGED_SESSION_VERIFICATION_FAILED,\"Failed to parse APEX package \" + apexPath,e);\n  }\n  final PackageInfo existingApexPkg=mApexManager.getPackageInfo(packageName,ApexManager.MATCH_ACTIVE_PACKAGE);\n  if (existingApexPkg == null) {\n    throw new IllegalStateException(\"Unknown apex package \" + packageName);\n  }\n  final SigningDetails existingSigningDetails;\n  try {\n    existingSigningDetails=ApkSignatureVerifier.verify(existingApexPkg.applicationInfo.sourceDir,SignatureSchemeVersion.JAR);\n  }\n catch (  PackageParserException e) {\n    throw new PackageManagerException(SessionInfo.STAGED_SESSION_VERIFICATION_FAILED,\"Failed to parse APEX package \" + existingApexPkg.applicationInfo.sourceDir,e);\n  }\n  if (signingDetails.checkCapability(existingSigningDetails,PackageParser.SigningDetails.CertCapabilities.INSTALLED_DATA)) {\n    return;\n  }\n// bug_start\n// bug_end\n  throw new PackageManagerException(SessionInfo.STAGED_SESSION_VERIFICATION_FAILED,\"APK-container signature of APEX package \" + packageName + \" with version \"+ newApexPkg.versionCodeMajor+ \" and path \"+ apexPath+ \" is not\"+ \" compatible with the one currently installed on device\");\n}\n"}
{"INPUT": "public void shutdown(){\n// bug_start\n  final Collection<MemberImpl> memberList=getContext().getClusterService().getMemberList();\n  for (  MemberImpl member : memberList) {\n    ShutdownRequest request=new ShutdownRequest(name,member.getAddress());\n    invoke(request,member.getAddress());\n  }\n// bug_end\n}\n"}
{"INPUT": "public PVector getVertex(int index,PVector vec){\n  if (vec == null) {\n    vec=new PVector();\n  }\n// bug_start\n  vec.x=vertices[index][X];\n  vec.y=vertices[index][Y];\n  vec.z=vertices[index][Z];\n// bug_end\n  return vec;\n}\n"}
{"INPUT": "private void printDetails(DataTree dataTree,Map<Long,Integer> sessions,boolean dumpData,long fileNameZxid){\n  long dtZxid=printZnodeDetails(dataTree,dumpData);\n  printSessionDetails(dataTree,sessions);\n// bug_start\n// bug_end\n  System.out.println(String.format(\"----%nLast zxid: 0x%s\",Long.toHexString(Math.max(fileNameZxid,dtZxid))));\n}\n"}
{"INPUT": "@Override public ClusterState execute(final ClusterState currentState){\n  ImmutableSettings.Builder transientSettings=ImmutableSettings.settingsBuilder();\n  transientSettings.put(currentState.metaData().transientSettings());\n  for (  Map.Entry<String,String> entry : request.transientSettings().getAsMap().entrySet()) {\n// bug_start\n    if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n// bug_end\n      String error=dynamicSettings.validateDynamicSetting(entry.getKey(),entry.getValue());\n      if (error == null) {\n        transientSettings.put(entry.getKey(),entry.getValue());\n        transientUpdates.put(entry.getKey(),entry.getValue());\n        changed=true;\n      }\n else {\n        logger.warn(\"ignoring transient setting [{}], [{}]\",entry.getKey(),error);\n      }\n    }\n else {\n      logger.warn(\"ignoring transient setting [{}], not dynamically updateable\",entry.getKey());\n    }\n  }\n  ImmutableSettings.Builder persistentSettings=ImmutableSettings.settingsBuilder();\n  persistentSettings.put(currentState.metaData().persistentSettings());\n  for (  Map.Entry<String,String> entry : request.persistentSettings().getAsMap().entrySet()) {\n// bug_start\n    if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n// bug_end\n      String error=dynamicSettings.validateDynamicSetting(entry.getKey(),entry.getValue());\n      if (error == null) {\n        persistentSettings.put(entry.getKey(),entry.getValue());\n        persistentUpdates.put(entry.getKey(),entry.getValue());\n        changed=true;\n      }\n else {\n        logger.warn(\"ignoring persistent setting [{}], [{}]\",entry.getKey(),error);\n      }\n    }\n else {\n      logger.warn(\"ignoring persistent setting [{}], not dynamically updateable\",entry.getKey());\n    }\n  }\n  if (!changed) {\n    return currentState;\n  }\n  MetaData.Builder metaData=MetaData.builder(currentState.metaData()).persistentSettings(persistentSettings.build()).transientSettings(transientSettings.build());\n  ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());\n  boolean updatedReadOnly=metaData.persistentSettings().getAsBoolean(MetaData.SETTING_READ_ONLY,false) || metaData.transientSettings().getAsBoolean(MetaData.SETTING_READ_ONLY,false);\n  if (updatedReadOnly) {\n    blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);\n  }\n else {\n    blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);\n  }\n  return builder(currentState).metaData(metaData).blocks(blocks).build();\n}\n"}
{"INPUT": "private void ok(){\n  if (Const.isEmpty(wName.getText())) {\n    MessageBox mb=new MessageBox(shell,SWT.OK | SWT.ICON_ERROR);\n// bug_start\n    mb.setMessage(\"Veuillez svp donner un nom  cette entre tche!\");\n    mb.setText(\"Entre tche non nomme\");\n// bug_end\n    mb.open();\n    return;\n  }\n  jobEntry.setName(wName.getText());\n  jobEntry.setResultFilenamesWildcard(wResultFilenamesWildcard.getText());\n  jobEntry.setResultFieldFile(wResultFieldFile.getText());\n  jobEntry.setResultFieldWildcard(wResultFieldWildcard.getText());\n  jobEntry.setResultFieldIncludeSubfolders(wResultFieldIncludeSubFolders.getText());\n  jobEntry.sourceFiles=JobEntryEvalFilesMetrics.getSourceFilesByDesc(wSourceFiles.getText());\n  jobEntry.evaluationType=JobEntryEvalFilesMetrics.getEvaluationTypeByDesc(wEvaluationType.getText());\n  jobEntry.scale=JobEntryEvalFilesMetrics.getScaleByDesc(wScale.getText());\n  jobEntry.successnumbercondition=JobEntrySimpleEval.getSuccessNumberConditionByDesc(wSuccessNumberCondition.getText());\n  jobEntry.setCompareValue(wCompareValue.getText());\n  jobEntry.setMinValue(wMinValue.getText());\n  jobEntry.setMaxValue(wMaxValue.getText());\n  int nritems=wFields.nrNonEmpty();\n  int nr=0;\n  for (int i=0; i < nritems; i++) {\n    String arg=wFields.getNonEmpty(i).getText(1);\n    if (arg != null && arg.length() != 0)     nr++;\n  }\n  jobEntry.source_filefolder=new String[nr];\n  jobEntry.wildcard=new String[nr];\n  jobEntry.includeSubFolders=new String[nr];\n  nr=0;\n  for (int i=0; i < nritems; i++) {\n    String source=wFields.getNonEmpty(i).getText(1);\n    String wild=wFields.getNonEmpty(i).getText(2);\n    String includeSubFolders=wFields.getNonEmpty(i).getText(3);\n    if (source != null && source.length() != 0) {\n      jobEntry.source_filefolder[nr]=source;\n      jobEntry.wildcard[nr]=wild;\n      jobEntry.includeSubFolders[nr]=JobEntryEvalFilesMetrics.getIncludeSubFolders(includeSubFolders);\n      nr++;\n    }\n  }\n  dispose();\n}\n"}
{"INPUT": "private static ColumnDefinition createColumnFromColumnRow(UntypedResultSet.Row row,String keyspace,String table,AbstractType<?> rawComparator,AbstractType<?> rawSubComparator,boolean isSuper,boolean isCQLTable,boolean isStaticCompactTable,boolean needsUpgrade){\n// bug_start\n  ColumnDefinition.Kind kind=deserializeKind(row.getString(\"type\"));\n// bug_end\n  if (needsUpgrade && isStaticCompactTable && kind == ColumnDefinition.Kind.REGULAR)   kind=ColumnDefinition.Kind.STATIC;\n  int componentIndex=ColumnDefinition.NO_POSITION;\n  if (kind.isPrimaryKeyKind())   componentIndex=row.has(\"component_index\") ? row.getInt(\"component_index\") : 0;\n// bug_start\n  AbstractType<?> comparator=isCQLTable ? UTF8Type.instance : CompactTables.columnDefinitionComparator(kind,isSuper,rawComparator,rawSubComparator);\n// bug_end\n  ColumnIdentifier name=ColumnIdentifier.getInterned(comparator.fromString(row.getString(\"column_name\")),comparator);\n  AbstractType<?> validator=parseType(row.getString(\"validator\"));\n  return new ColumnDefinition(keyspace,table,name,validator,componentIndex,kind);\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") private <T>Flux<DataBuffer> encodePart(byte[] boundary,String name,T value){\n  MultipartHttpOutputMessage outputMessage=new MultipartHttpOutputMessage(this.bufferFactory,getCharset());\n  T body;\n  ResolvableType resolvableType=null;\n  if (value instanceof HttpEntity) {\n    HttpEntity<T> httpEntity=(HttpEntity<T>)value;\n    outputMessage.getHeaders().putAll(httpEntity.getHeaders());\n    body=httpEntity.getBody();\n    Assert.state(body != null,\"MultipartHttpMessageWriter only supports HttpEntity with body\");\n    if (httpEntity instanceof MultipartBodyBuilder.PublisherEntity<?,?>) {\n      MultipartBodyBuilder.PublisherEntity<?,?> publisherEntity=(MultipartBodyBuilder.PublisherEntity<?,?>)httpEntity;\n      resolvableType=publisherEntity.getResolvableType();\n    }\n  }\n else {\n    body=value;\n  }\n  if (resolvableType == null) {\n    resolvableType=ResolvableType.forClass(body.getClass());\n  }\n// bug_start\n  String filename=(body instanceof Resource ? ((Resource)body).getFilename() : null);\n  outputMessage.getHeaders().setContentDispositionFormData(name,filename);\n// bug_end\n  MediaType contentType=outputMessage.getHeaders().getContentType();\n  final ResolvableType finalBodyType=resolvableType;\n  Optional<HttpMessageWriter<?>> writer=this.partWriters.stream().filter(null).findFirst();\n  if (!writer.isPresent()) {\n    return Flux.error(new CodecException(\"No suitable writer found for part: \" + name));\n  }\n  Publisher<T> bodyPublisher=body instanceof Publisher ? (Publisher<T>)body : Mono.just(body);\n  Mono<Void> partContentReady=((HttpMessageWriter<T>)writer.get()).write(bodyPublisher,resolvableType,contentType,outputMessage,Collections.emptyMap());\n  Flux<DataBuffer> partContent=partContentReady.thenMany(Flux.defer(null));\n  return Flux.concat(Mono.just(generateBoundaryLine(boundary)),partContent,Mono.just(generateNewLine()));\n}\n"}
{"INPUT": "public Observable<ResponseType> toObservable(Scheduler observeOn){\n// bug_start\n  if (getProperties().requestCachingEnabled().get()) {\n// bug_end\n    Observable<ResponseType> fromCache=requestCache.get(getCacheKey());\n    if (fromCache != null) {\n      metrics.markResponseFromCache();\n      return fromCache;\n    }\n  }\n  RequestCollapser<BatchReturnType,ResponseType,RequestArgumentType> requestCollapser=collapserFactory.getRequestCollapser(collapserInstanceWrapper);\n  Observable<ResponseType> response=requestCollapser.submitRequest(getRequestArgument());\n  metrics.markRequestBatched();\n// bug_start\n  if (getProperties().requestCachingEnabled().get()) {\n// bug_end\n    Observable<ResponseType> o=response.cache();\n    Observable<ResponseType> fromCache=requestCache.putIfAbsent(getCacheKey(),o);\n    if (fromCache == null) {\n      response=o;\n    }\n else {\n      response=fromCache;\n    }\n  }\n  return response;\n}\n"}
{"INPUT": "// bug_start\npublic boolean saveFile() throws KettleException {\n  EngineMetaInterface meta=getActiveMeta();\n  if (meta != null) {\n    return saveToFile(meta);\n// bug_end\n  }\n  return false;\n}\n"}
{"INPUT": "public void runAutoOffsetResetTest() throws Exception {\n  final String topic=\"auto-offset-reset-test\";\n  final int parallelism=1;\n  final int elementsPerPartition=50000;\n  Properties tprops=new Properties();\n  tprops.setProperty(\"retention.ms\",\"250\");\n  kafkaServer.createTestTopic(topic,parallelism,1,tprops);\n  final StreamExecutionEnvironment env=StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\",flink.getLeaderRPCPort());\n  env.setParallelism(parallelism);\n  env.setRestartStrategy(RestartStrategies.noRestart());\n  env.getConfig().disableSysoutLogging();\n  DataStream<String> stream=env.addSource(new RichParallelSourceFunction<String>(){\n    private boolean running=true;\n    @Override public void run(    SourceContext<String> ctx) throws InterruptedException {\n      int cnt=getRuntimeContext().getIndexOfThisSubtask() * elementsPerPartition;\n      int limit=cnt + elementsPerPartition;\n      while (running && !stopProducer && cnt < limit) {\n        ctx.collect(\"element-\" + cnt);\n        cnt++;\n        Thread.sleep(10);\n      }\n      LOG.info(\"Stopping producer\");\n    }\n    @Override public void cancel(){\n      running=false;\n    }\n  }\n);\n  Properties props=new Properties();\n  props.putAll(standardProps);\n  props.putAll(secureProps);\n// bug_start\n  stream.addSink(kafkaServer.getProducer(topic,new KeyedSerializationSchemaWrapper<>(new SimpleStringSchema()),props,null));\n// bug_end\n  NonContinousOffsetsDeserializationSchema deserSchema=new NonContinousOffsetsDeserializationSchema();\n  FlinkKafkaConsumerBase<String> source=kafkaServer.getConsumer(topic,deserSchema,props);\n  DataStreamSource<String> consuming=env.addSource(source);\n  consuming.addSink(new DiscardingSink<String>());\n  tryExecute(env,\"run auto offset reset test\");\n  kafkaServer.deleteTestTopic(topic);\n}\n"}
{"INPUT": "@Override public QueryBuilder getFilterBuilder(){\n  if (op.getOperator().equals(Operators.EQUALS.value())) {\n    return QueryBuilders.queryStringQuery(name.getName() + \":\" + value.getValue().toString());\n  }\n else   if (op.getOperator().equals(Operators.BETWEEN.value())) {\n    return QueryBuilders.rangeQuery(name.getName()).from(range.getLow()).to(range.getHigh());\n  }\n else   if (op.getOperator().equals(Operators.IN.value())) {\n    return QueryBuilders.termsQuery(name.getName(),valueList.getList());\n  }\n else   if (op.getOperator().equals(Operators.NOT_EQUALS.value())) {\n    return QueryBuilders.queryStringQuery(\"NOT \" + name.getName() + \":\"+ value.getValue().toString());\n  }\n else   if (op.getOperator().equals(Operators.GREATER_THAN.value())) {\n    return QueryBuilders.rangeQuery(name.getName()).from(value.getValue()).includeLower(false).includeUpper(false);\n  }\n else   if (op.getOperator().equals(Operators.IS.value())) {\n    if (value.getSysConstant().equals(ConstValue.SystemConsts.NULL)) {\n      return QueryBuilders.boolQuery().mustNot(QueryBuilders.boolQuery().must(QueryBuilders.matchAllQuery()).mustNot(QueryBuilders.existsQuery(name.getName())));\n    }\n else     if (value.getSysConstant().equals(ConstValue.SystemConsts.NOT_NULL)) {\n      return QueryBuilders.boolQuery().mustNot(QueryBuilders.boolQuery().must(QueryBuilders.matchAllQuery()).must(QueryBuilders.existsQuery(name.getName())));\n    }\n  }\n else   if (op.getOperator().equals(Operators.LESS_THAN.value())) {\n    return QueryBuilders.rangeQuery(name.getName()).to(value.getValue()).includeLower(false).includeUpper(false);\n  }\n// bug_start\n// bug_end\n  throw new IllegalStateException(\"Incorrect/unsupported operators\");\n}\n"}
{"INPUT": "@Nullable @Override protected ObjectStatus getObjectStatus(String key){\n  try {\n    FileInfo fileInfo=mKodoClinet.getFileInfo(key);\n    if (fileInfo == null) {\n      return null;\n    }\n    return new ObjectStatus(key,fileInfo.hash,fileInfo.fsize,fileInfo.putTime / 10000);\n  }\n catch (  QiniuException e) {\n// bug_start\n    LOG.warn(\"Failed to get Object {}, Msg: {}\",key,e);\n// bug_end\n  }\n// bug_start\n  return null;\n// bug_end\n}\n"}
{"INPUT": "public List<AgentEventBo> map(final PAgentStatBatch agentStatBatch,final AgentHeaderFactory.Header header){\n// bug_start\n  if (agentStatBatch == null) {\n    return Collections.emptyList();\n  }\n// bug_end\n  final String agentId=header.getAgentId();\n  final long startTimestamp=header.getAgentStartTime();\n  final List<PAgentStat> agentStats=agentStatBatch.getAgentStatList();\n  if (CollectionUtils.isEmpty(agentStats)) {\n    return Collections.emptyList();\n  }\n  final List<AgentEventBo> agentEventBoList=new ArrayList<>(agentStats.size());\n// bug_start\n  for (  PAgentStat tAgentStat : agentStats) {\n    final long timestamp=tAgentStat.getTimestamp();\n    final PDeadlock deadlock=tAgentStat.getDeadlock();\n    if (deadlock != null && CollectionUtils.hasLength(deadlock.getThreadDumpList())) {\n      agentEventBoList.add(deadlockEventBoMapper.map(agentId,startTimestamp,timestamp,deadlock));\n// bug_end\n    }\n  }\n  return agentEventBoList;\n}\n"}
{"INPUT": "// bug_start\npublic String mergeJavaFile(String newFileSource,String existingFileFullPath,String[] javadocTags) throws ShellException {\n  JavaFileMerger merger=new JavaFileMerger(newFileSource,existingFileFullPath,javadocTags);\n// bug_end\n  return merger.getMergedSource();\n}\n"}
{"INPUT": "// bug_start\n@Override public boolean run(){\n// bug_end\n  while (true) {\n    long cursor=subSeq.next();\n    if (cursor == -1) {\n      return false;\n    }\n    if (cursor == -2) {\n      continue;\n    }\n    final VectorAggregateTask queueItem=queue.get(cursor);\n    final VectorAggregateEntry entry=queueItem.entry;\n    subSeq.done(cursor);\n// bug_start\n    return entry.run();\n// bug_end\n  }\n}\n"}
{"INPUT": "public Conversion getConversion(Type sourceType,Type targetType){\n  if (sourceType.isEnumType() && targetType.equals(typeUtil.getType(stringType))) {\n    sourceType=typeUtil.getType(enumType);\n  }\n// bug_start\n// bug_end\n  return conversions.get(new Key(sourceType,targetType));\n}\n"}
{"INPUT": "@Override public void run(){\n  if (!owner.isOnline()) {\n    resetWorkUnit(\"went off-line before the task's worker thread started\");\n    owner.removeExecutor(this);\n    queue.scheduleMaintenance();\n    return;\n  }\n  if (owner.getNode() == null) {\n    resetWorkUnit(\"was removed before the task's worker thread started\");\n    owner.removeExecutor(this);\n    queue.scheduleMaintenance();\n    return;\n  }\n  final WorkUnit workUnit;\n  lock.writeLock().lock();\n  try {\n    startTime=System.currentTimeMillis();\n    workUnit=this.workUnit;\n  }\n  finally {\n    lock.writeLock().unlock();\n  }\n  ACL.impersonate(ACL.SYSTEM);\n  try {\n    SubTask task;\n    task=Queue.withLock(new java.util.concurrent.Callable<SubTask>(){\n      @Override public SubTask call() throws Exception {\n        if (!owner.isOnline()) {\n          resetWorkUnit(\"went off-line before the task's worker thread was ready to execute\");\n          return null;\n        }\n        if (owner.getNode() == null) {\n          resetWorkUnit(\"was removed before the task's worker thread was ready to execute\");\n          return null;\n        }\n        workUnit.setExecutor(Executor.this);\n        queue.onStartExecuting(Executor.this);\n        if (LOGGER.isLoggable(FINE))         LOGGER.log(FINE,getName() + \" grabbed \" + workUnit+ \" from queue\");\n        SubTask task=workUnit.work;\n        Executable executable=task.createExecutable();\n        lock.writeLock().lock();\n        try {\n          Executor.this.executable=executable;\n        }\n  finally {\n          lock.writeLock().unlock();\n        }\n        workUnit.setExecutable(executable);\n        return task;\n      }\n    }\n);\n    Executable executable;\n    lock.readLock().lock();\n    try {\n      if (this.workUnit == null) {\n        return;\n      }\n      executable=this.executable;\n    }\n  finally {\n      lock.readLock().unlock();\n    }\n    if (LOGGER.isLoggable(FINE))     LOGGER.log(FINE,getName() + \" is going to execute \" + executable);\n    Throwable problems=null;\n    try {\n      workUnit.context.synchronizeStart();\n      if (executable == null) {\n        throw new Error(\"The null Executable has been created for \" + workUnit + \". The task cannot be executed\");\n      }\n      if (executable instanceof Actionable) {\n// bug_start\n// bug_end\n        for (        Action action : workUnit.context.actions) {\n          ((Actionable)executable).addAction(action);\n        }\n      }\n      ACL.impersonate(workUnit.context.item.authenticate());\n      setName(getName() + \" : executing \" + executable.toString());\n      if (LOGGER.isLoggable(FINE))       LOGGER.log(FINE,getName() + \" is now executing \" + executable);\n      queue.execute(executable,task);\n    }\n catch (    AsynchronousExecution x) {\n      lock.writeLock().lock();\n      try {\n        x.setExecutor(this);\n        this.asynchronousExecution=x;\n      }\n  finally {\n        lock.writeLock().unlock();\n      }\n    }\ncatch (    Throwable e) {\n      problems=e;\n    }\n finally {\n      boolean needFinish1;\n      lock.readLock().lock();\n      try {\n        needFinish1=asynchronousExecution == null;\n      }\n  finally {\n        lock.readLock().unlock();\n      }\n      if (needFinish1) {\n        finish1(problems);\n      }\n    }\n  }\n catch (  InterruptedException e) {\n    LOGGER.log(FINE,getName() + \" interrupted\",e);\n  }\ncatch (  Exception|Error e) {\n    LOGGER.log(SEVERE,\"Unexpected executor death\",e);\n  }\n finally {\n    if (asynchronousExecution == null) {\n      finish2();\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\n@WorkerThread @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE) public boolean isIccLockEnabled(){\n// bug_end\n  try {\n    ITelephony telephony=getITelephony();\n    if (telephony != null) {\n      return telephony.isIccLockEnabled(getSubId());\n    }\n  }\n catch (  RemoteException e) {\n    Log.e(TAG,\"isIccLockEnabled RemoteException\",e);\n  }\n  return false;\n}\n"}
{"INPUT": "// bug_start\nprotected long selectEventId(PreparedStatement insertStatement,Connection connection) throws SQLException, InvocationTargetException {\n// bug_end\n  ResultSet rs=null;\n  Statement idStatement=null;\n  try {\n    boolean gotGeneratedKeys=false;\n    if (cnxSupportsGetGeneratedKeys) {\n      try {\n        rs=(ResultSet)getGeneratedKeysMethod().invoke(insertStatement,(Object[])null);\n        gotGeneratedKeys=true;\n      }\n catch (      InvocationTargetException ex) {\n        Throwable target=ex.getTargetException();\n        if (target instanceof SQLException) {\n          throw (SQLException)target;\n        }\n        throw ex;\n      }\ncatch (      IllegalAccessException ex) {\n        addWarn(\"IllegalAccessException invoking PreparedStatement.getGeneratedKeys\",ex);\n      }\n    }\n    if (!gotGeneratedKeys) {\n      idStatement=connection.createStatement();\n      idStatement.setMaxRows(1);\n      String selectInsertIdStr=sqlDialect.getSelectInsertId();\n      rs=idStatement.executeQuery(selectInsertIdStr);\n    }\n    rs.next();\n    long eventId=rs.getLong(1);\n    return eventId;\n  }\n  finally {\n    if (rs != null) {\n      try {\n        rs.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n    DBHelper.closeStatement(idStatement);\n  }\n}\n"}
{"INPUT": "protected void onCreateCommon(final Runnable postDrawCallback){\n  mDrawCallback=new Runnable(){\n    @Override public void run(){\n      mRedrewFlag=true;\n      mHandler.post(postDrawCallback);\n    }\n  }\n;\n  getWindow().setBackgroundDrawable(new ColorDrawable(0xffefefef));\n  ResourceModifiers.init(getResources());\n// bug_start\n  mHardwareView=(MainView)findViewById(R.id.hardware_view);\n// bug_end\n  mHardwareView.setLayerType(View.LAYER_TYPE_HARDWARE,null);\n  mHardwareView.setBackgroundColor(Color.WHITE);\n  mHardwareView.addDrawCallback(mDrawCallback);\n  int width=getResources().getDimensionPixelSize(R.dimen.layer_width);\n  int height=getResources().getDimensionPixelSize(R.dimen.layer_height);\n  mSoftwareBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);\n  mHardwareBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);\n  mErrorCalculator=new ErrorCalculator(getApplicationContext(),getResources());\n  mHandler=new Handler();\n}\n"}
{"INPUT": "// bug_start\npublic GeoHashGridAggregatorFactory(String name,ValuesSourceConfig<GeoPoint> config,int precision,int requiredSize,int shardSize,SearchContext context,AggregatorFactory<?> parent,AggregatorFactories.Builder subFactoriesBuilder,Map<String,Object> metaData) throws IOException {\n// bug_end\n  super(name,config,context,parent,subFactoriesBuilder,metaData);\n  this.precision=precision;\n  this.requiredSize=requiredSize;\n  this.shardSize=shardSize;\n}\n"}
{"INPUT": "public MethodInvocation createInvocation(Object pojo,Exchange exchange) throws RuntimeCamelException, AmbiguousMethodCallException {\n  MethodInfo methodInfo=null;\n  String name=exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME,String.class);\n  if (name != null) {\n// bug_start\n    if (operations.get(name).size() == 1) {\n      methodInfo=operations.get(name).get(0);\n// bug_end\n    }\n  }\n  if (methodInfo == null) {\n    methodInfo=chooseMethod(pojo,exchange);\n  }\n  if (methodInfo == null) {\n    methodInfo=defaultMethod;\n  }\n  if (methodInfo != null) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Choosed method to invoke: \" + methodInfo + \" on bean: \"+ pojo);\n    }\n    return methodInfo.createMethodInvocation(pojo,exchange);\n  }\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Cannot find suitable method to invoke on bean: \" + pojo);\n  }\n  return null;\n}\n"}
{"INPUT": "public static int[] HSLtoRGB(final float h,final float s,final float l,final float alpha){\n  if (s < 0.0f || s > 100.0f) {\n    Log_OC.w(TAG,\"Color parameter outside of expected range - Saturation\");\n  }\n  if (l < 0.0f || l > 100.0f) {\n    Log_OC.w(TAG,\"Color parameter outside of expected range - Luminance\");\n  }\n  if (alpha < 0.0f || alpha > 1.0f) {\n    Log_OC.w(TAG,\"Color parameter outside of expected range - Alpha\");\n  }\n  final float hr=(h % 360.0f) / 360f;\n// bug_start\n  final float sr=fixRawHSLValue(s,100f,100f);\n  final float lr=fixRawHSLValue(s,100f,100f);\n// bug_end\n  final float q=(lr < 0.5) ? lr * (1 + sr) : (lr + sr) - (lr * sr);\n  final float p=2 * lr - q;\n  final int r=Math.round(Math.max(0,HueToRGB(p,q,hr + (1.0f / 3.0f)) * 256));\n  final int g=Math.round(Math.max(0,HueToRGB(p,q,hr) * 256));\n  final int b=Math.round(Math.max(0,HueToRGB(p,q,hr - (1.0f / 3.0f)) * 256));\n  return new int[]{r,g,b};\n}\n"}
{"INPUT": "private void scanAllNodes(Parent parent,PseudoClass pseudoClass){\n  parent.getChildrenUnmodifiable().addListener(new ListChangeListener<Node>(){\n    @Override public void onChanged(    javafx.collections.ListChangeListener.Change<? extends Node> c){\n      while (c.next())       if (!c.wasPermutated() && !c.wasUpdated())       for (      Node addedNode : c.getAddedSubList())       if (addedNode instanceof Parent)       scanAllNodes((Parent)addedNode,pseudoClass);\n    }\n  }\n);\n  for (  Node component : parent.getChildrenUnmodifiable()) {\n    if (component instanceof Pane) {\n      ((Pane)component).getChildren().addListener(new ListChangeListener<Node>(){\n        @Override public void onChanged(        javafx.collections.ListChangeListener.Change<? extends Node> c){\n          while (c.next()) {\n            if (!c.wasPermutated() && !c.wasUpdated()) {\n              for (              Node addedNode : c.getAddedSubList()) {\n                if (addedNode instanceof Parent)                 scanAllNodes((Parent)addedNode,pseudoClass);\n              }\n            }\n          }\n        }\n      }\n);\n      scanAllNodes((Pane)component,pseudoClass);\n    }\n else     if (component instanceof ScrollPane) {\n      ((ScrollPane)component).contentProperty().addListener(null);\n      if (((ScrollPane)component).getContent() instanceof Parent) {\n        scanAllNodes((Parent)((ScrollPane)component).getContent(),pseudoClass);\n      }\n    }\n else     if (component instanceof Control) {\n// bug_start\n      ((Control)component).pseudoClassStateChanged(PSEUDO_CLASS_EX_SMALL,pseudoClass == PSEUDO_CLASS_EX_SMALL);\n      ((Control)component).pseudoClassStateChanged(PSEUDO_CLASS_SMALL,pseudoClass == PSEUDO_CLASS_SMALL);\n      ((Control)component).pseudoClassStateChanged(PSEUDO_CLASS_MEDIUM,pseudoClass == PSEUDO_CLASS_MEDIUM);\n      ((Control)component).pseudoClassStateChanged(PSEUDO_CLASS_LARGE,pseudoClass == PSEUDO_CLASS_LARGE);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "public void create(){\n  pixmap=new Pixmap(800,480,Pixmap.Format.RGBA8888);\n  texture=new Texture(1024,1024,Pixmap.Format.RGBA8888);\n  texture.setFilter(Texture.TextureFilter.Nearest,Texture.TextureFilter.Linear);\n  texture.setWrap(Texture.TextureWrap.ClampToEdge,Texture.TextureWrap.ClampToEdge);\n  pixmap.setColor(1.0f,0.0f,0.0f,1.0f);\n  pixmap.drawLine(0,0,100,100);\n  pixmap.setColor(0.0f,0.0f,1.0f,1.0f);\n  pixmap.drawLine(100,100,200,0);\n  pixmap.setColor(0.0f,1.0f,0.0f,1.0f);\n  pixmap.drawLine(100,0,100,100);\n  pixmap.setColor(1.0f,1.0f,1.0f,1.0f);\n  pixmap.drawCircle(400,300,100);\n  texture.draw(pixmap,0,0);\n  region=new TextureRegion(texture,0,0,800,480);\n  batch=new SpriteBatch();\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public void moveContact(Contact contact,MetaContact newParentMetaContact) throws MetaContactListException {\n  if (contact.getPersistableAddress() == null) {\n    logger.info(\"Contact cannot be moved! This contact doesn't have \" + \"persistant address.\");\n    return;\n  }\n  ProtocolProviderService provider=contact.getProtocolProvider();\n  OperationSetMultiUserChat opSetMUC=provider.getOperationSet(OperationSetMultiUserChat.class);\n  if (opSetMUC != null && opSetMUC.isPrivateMessagingContact(contact.getAddress())) {\n    addNewContactToMetaContact(provider,newParentMetaContact,contact.getPersistableAddress());\n    return;\n  }\n  OperationSetPersistentPresence opSetPresence=provider.getOperationSet(OperationSetPersistentPresence.class);\n  if (opSetPresence == null) {\n  }\n  if (!(newParentMetaContact instanceof MetaContactImpl)) {\n    throw new IllegalArgumentException(newParentMetaContact + \" is not a MetaContactImpl instance.\");\n  }\n  MetaContactImpl currentParentMetaContact=(MetaContactImpl)this.findMetaContactByContact(contact);\n// bug_start\n  currentParentMetaContact.removeProtoContact(contact);\n// bug_end\n  MetaContactGroup newParentGroup=findParentMetaContactGroup(newParentMetaContact);\n  ContactGroup parentProtoGroup=resolveProtoPath(contact.getProtocolProvider(),(MetaContactGroupImpl)newParentGroup);\n// bug_start\n  if (contact.getParentContactGroup() != parentProtoGroup && opSetPresence != null)   opSetPresence.moveContactToGroup(contact,parentProtoGroup);\n// bug_end\n  ((MetaContactImpl)newParentMetaContact).addProtoContact(contact);\n  fireProtoContactEvent(contact,ProtoContactEvent.PROTO_CONTACT_MOVED,currentParentMetaContact,newParentMetaContact);\n  if (currentParentMetaContact.getContactCount() == 0) {\n    MetaContactGroupImpl parentMetaGroup=currentParentMetaContact.getParentGroup();\n    parentMetaGroup.removeMetaContact(currentParentMetaContact);\n    fireMetaContactEvent(currentParentMetaContact,parentMetaGroup,MetaContactEvent.META_CONTACT_REMOVED);\n  }\n}\n"}
{"INPUT": "// bug_start\n@Inject public RestCountAction(Settings settings,Client client,RestController controller){\n  super(settings,client);\n// bug_end\n  controller.registerHandler(POST,\"/_count\",this);\n  controller.registerHandler(GET,\"/_count\",this);\n  controller.registerHandler(POST,\"/{index}/_count\",this);\n  controller.registerHandler(GET,\"/{index}/_count\",this);\n  controller.registerHandler(POST,\"/{index}/{type}/_count\",this);\n  controller.registerHandler(GET,\"/{index}/{type}/_count\",this);\n}\n"}
{"INPUT": "// bug_start\n@JsonCreator public IndexingWorkerInfo(@JsonProperty(\"worker\") IndexingWorker worker,@JsonProperty(\"currCapacityUsed\") int currCapacityUsed,@JsonProperty(\"availabilityGroups\") Set<String> availabilityGroups,@JsonProperty(\"runningTasks\") Collection<String> runningTasks,@JsonProperty(\"lastCompletedTaskTime\") DateTime lastCompletedTaskTime,@Nullable @JsonProperty(\"blacklistedUntil\") DateTime blacklistedUntil){\n// bug_end\n  this.worker=worker;\n  this.currCapacityUsed=currCapacityUsed;\n  this.availabilityGroups=availabilityGroups;\n  this.runningTasks=runningTasks;\n  this.lastCompletedTaskTime=lastCompletedTaskTime;\n  this.blacklistedUntil=blacklistedUntil;\n}\n"}
{"INPUT": "@Override public InputStreamCreator getInputStreamCreator(){\n  if (inputStreamCreator == null) {\n// bug_start\n    if (request.getOptions().isEnableDiskCache()) {\n// bug_end\n      cacheFile=configuration.getBitmapCacher().getDiskCacheFile(configuration.getContext(),ImageLoaderUtils.encodeUrl(request.getImageUri()));\n// bug_start\n      if (HttpBitmapLoadTask.isAvailableOfFile(cacheFile,request.getOptions().getDiskCachePeriodOfValidity(),configuration,request.getName())) {\n// bug_end\n        inputStreamCreator=new FileInputStreamCreator(cacheFile);\n      }\n else {\n        inputStreamCreator=getNetInputStreamCreator(configuration,request,cacheFile);\n      }\n    }\n else {\n      inputStreamCreator=getNetInputStreamCreator(configuration,request,null);\n    }\n  }\n  return inputStreamCreator;\n}\n"}
{"INPUT": "// bug_start\nprotected static StringBuilder getWrappedQuery(DatabaseAdapter dbAdaper,String sqlQuery,String tableName){\n  return new StringBuilder(\"SELECT * FROM (\" + sqlQuery + \") \"+ dbAdaper.getTableAliasClause(tableName));\n// bug_end\n}\n"}
{"INPUT": "private void visitMethodDef(DetailAST method){\n// bug_start\n  if (classDepth != 1) {\n    return;\n  }\n  if (checkClassName() && checkName(method) && checkModifiers(method)&& checkType(method)&& checkParams(method)) {\n// bug_end\n    log(method.getLineNo(),MSG_KEY);\n  }\n}\n"}
{"INPUT": "// bug_start\npublic SnapshotClusterStateProvider(Map<String,Object> snapshot){\n// bug_end\n  Objects.requireNonNull(snapshot);\n  liveNodes=Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\",Collections.emptySet()));\n  clusterProperties=(Map<String,Object>)snapshot.getOrDefault(\"clusterProperties\",Collections.emptyMap());\n  Map<String,Object> stateMap=new HashMap<>((Map<String,Object>)snapshot.getOrDefault(\"clusterState\",Collections.emptyMap()));\n  Map<String,DocCollection> collectionStates=new HashMap<>();\n  Integer stateVersion=Integer.valueOf(String.valueOf(stateMap.getOrDefault(\"version\",0)));\n  stateMap.remove(\"version\");\n  stateMap.forEach(null);\n  clusterState=new ClusterState(stateVersion,liveNodes,collectionStates);\n}\n"}
{"INPUT": "public void splitParameters(Parameters matcher,Parameters matched){\n  if (matcher != null && matched != null) {\n    for (    Parameter matcherEntry : matcher.getEntries()) {\n// bug_start\n      if (matcherEntry.getName().getStyle() != null && matcherEntry.getName().getStyle().isExploded()) {\n// bug_end\n        for (        Parameter matchedEntry : matched.getEntries()) {\n// bug_start\n          if (matcherEntry.getName().getValue().equals(matchedEntry.getName().getValue())) {\n            matchedEntry.replaceValues(new ExpandedParameterDecoder(mockServerLogger).splitOnDelimiter(matcherEntry.getName().getStyle(),matcherEntry.getName().getValue(),matchedEntry.getValues()));\n// bug_end\n            matched.replaceEntry(matchedEntry);\n          }\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "protected void setImage(byte[] image){\n// bug_start\n  if (logger.isDebugEnabled())   if (logger.isInfoEnabled())   logger.info(\"setting image \" + image);\n// bug_end\n  this.image=image;\n}\n"}
{"INPUT": "void reset(SegmentInfo src){\n  clearFiles();\n  name=src.name;\n  docCount=src.docCount;\n  dir=src.dir;\n  delGen=src.delGen;\n  docStoreOffset=src.docStoreOffset;\n  docStoreIsCompoundFile=src.docStoreIsCompoundFile;\n  hasVectors=src.hasVectors;\n// bug_start\n// bug_end\n  if (src.normGen == null) {\n    normGen=null;\n  }\n else {\n    normGen=new long[src.normGen.length];\n    System.arraycopy(src.normGen,0,normGen,0,src.normGen.length);\n  }\n  isCompoundFile=src.isCompoundFile;\n  delCount=src.delCount;\n  segmentCodecs=src.segmentCodecs;\n}\n"}
{"INPUT": "private List<String> load(){\n// bug_start\n  Predicate<String> predicate=userRoles.indices().allowedIndicesMatcher(action);\n// bug_end\n  List<String> indicesAndAliases=new ArrayList<>();\n  for (  Map.Entry<String,AliasOrIndex> entry : metaData.getAliasAndIndexLookup().entrySet()) {\n    String aliasOrIndex=entry.getKey();\n    if (predicate.test(aliasOrIndex)) {\n      indicesAndAliases.add(aliasOrIndex);\n    }\n  }\n  return Collections.unmodifiableList(indicesAndAliases);\n}\n"}
{"INPUT": "@Test public void testTokensNotNull(){\n  final SuperCloneCheck check=new SuperCloneCheck();\n// bug_start\n  Assert.assertNotNull(check.getAcceptableTokens());\n  Assert.assertNotNull(check.getDefaultTokens());\n  Assert.assertNotNull(check.getRequiredTokens());\n// bug_end\n}\n"}
{"INPUT": "@Test public void testStringStartedFromDigit() throws Exception {\n  String cfgJson=\"{source: { content: { value: 'address\\n\\\"401 Congress Ave, Suite 2450\\\"' }  }, extractor : { row: {} }, transformers : [{ csv: {} }], loader: { test: {} } }\";\n  process(cfgJson);\n  List<ODocument> res=getResult();\n  ODocument doc=res.get(0);\n// bug_start\n  String text=doc.field(\"address\");\n  assertEquals(\"401 Congress Ave, Suite 2450\",text);\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Override protected SimpleDecoder<VideoDecoderInputBuffer,? extends VideoDecoderOutputBuffer,? extends VideoDecoderException> createDecoder(Format format,ExoMediaCrypto mediaCrypto) throws VideoDecoderException {\n// bug_end\n  TraceUtil.beginSection(\"createVpxDecoder\");\n  int initialInputBufferSize=format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;\n  decoder=new VpxDecoder(numInputBuffers,numOutputBuffers,initialInputBufferSize,mediaCrypto,disableLoopFilter,enableRowMultiThreadMode,threads);\n  decoder.setOutputMode(outputMode);\n  TraceUtil.endSection();\n  return decoder;\n}\n"}
{"INPUT": "private static String getTitle(Context context,Uri uri,boolean followSettingsUri){\n  Cursor cursor=null;\n  ContentResolver res=context.getContentResolver();\n  String title=null;\n  if (uri != null) {\n    String authority=uri.getAuthority();\n    if (Settings.AUTHORITY.equals(authority)) {\n      if (followSettingsUri) {\n        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));\n        String actualTitle=getTitle(context,actualUri,false);\n        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);\n      }\n    }\n else {\n      if (DrmStore.AUTHORITY.equals(authority)) {\n        cursor=res.query(uri,DRM_COLUMNS,null,null,null);\n      }\n else       if (MediaStore.AUTHORITY.equals(authority)) {\n        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);\n      }\n// bug_start\n      if (cursor != null && cursor.getCount() == 1) {\n        cursor.moveToFirst();\n        return cursor.getString(2);\n// bug_end\n      }\n// bug_start\n else {\n        title=uri.getLastPathSegment();\n// bug_end\n      }\n    }\n  }\n  if (title == null) {\n    title=context.getString(com.android.internal.R.string.ringtone_unknown);\n    if (title == null) {\n      title=\"\";\n    }\n  }\n  return title;\n}\n"}
{"INPUT": "// bug_start\npublic DataConnectionCreator(BootStrapContext context,WorkEventBus workBus,WorkerBee bee,boolean allowPortHunting){\n// bug_end\n  super();\n  this.context=context;\n  this.workBus=workBus;\n  this.bee=bee;\n  this.allowPortHunting=allowPortHunting;\n// bug_start\n  this.dataAllocator=context.getAllocator().newChildAllocator(\"rpc-data\",0,Long.MAX_VALUE);\n// bug_end\n}\n"}
{"INPUT": "public Transaction payFee(StatefulAsset statefulAsset,long listingFee) throws InsufficientMoneyException, TxException {\n  checkArgument(!statefulAsset.wasRemovedByVoting(),\"Asset must not have been removed\");\n  checkArgument(listingFee >= getFeePerDay().value,\"Fee must not be less then listing fee for 1 day.\");\n  checkArgument(listingFee % 100 == 0,\"Fee must be a multiple of 1 BSQ (100 satoshi).\");\n  try {\n// bug_start\n    final Transaction preparedBurnFeeTx=bsqWalletService.getPreparedBurnFeeTx(Coin.valueOf(listingFee));\n// bug_end\n    byte[] hash=AssetConsensus.getHash(statefulAsset);\n    byte[] opReturnData=AssetConsensus.getOpReturnData(hash);\n// bug_start\n    final Transaction txWithBtcFee=btcWalletService.completePreparedBurnBsqTx(preparedBurnFeeTx,opReturnData);\n// bug_end\n    Transaction transaction=bsqWalletService.signTx(txWithBtcFee);\n    log.info(\"Asset listing fee tx: \" + transaction);\n    return transaction;\n  }\n catch (  WalletException|TransactionVerificationException e) {\n    throw new TxException(e);\n  }\n}\n"}
{"INPUT": "public void setTree(BehaviorTree tree){\n  this.tree=tree;\n  selectedNode=null;\n  if (selectionBinding != null) {\n    selectionBinding.set(null);\n  }\n  removeAll();\n// bug_start\n  for (  RenderableNode widget : tree.getRenderableNodes(behaviorNodeFactory)) {\n    addWidget(widget);\n  }\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Override protected void run(OptionSet options) throws Exception {\n// bug_end\n  List<?> nonOptionArguments=new ArrayList<Object>(options.nonOptionArguments());\n  Assert.isTrue(nonOptionArguments.size() >= 2,\"The name of the resulting jar and at least one source file must be specified\");\n  File output=new File((String)nonOptionArguments.remove(0));\n  Assert.isTrue(output.getName().toLowerCase().endsWith(\".jar\"),\"The output '\" + output + \"' is not a JAR file.\");\n  deleteIfExists(output);\n  GroovyCompiler compiler=createCompiler(options);\n  List<URL> classpath=getClassPathUrls(compiler);\n  List<MatchedResource> classpathEntries=findMatchingClasspathEntries(classpath,options);\n  String[] sources=new SourceOptions(nonOptionArguments).getSourcesArray();\n  Class<?>[] compiledClasses=compiler.compile(sources);\n  List<URL> dependencies=getClassPathUrls(compiler);\n  dependencies.removeAll(classpath);\n  writeJar(output,compiledClasses,classpathEntries,dependencies);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "private BlobKey putBuffer(@Nullable JobID jobId,byte[] value,BlobKey.BlobType blobType) throws IOException {\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Received PUT call for BLOB of job {}.\",jobId);\n  }\n  File incomingFile=createTemporaryFilename();\n  MessageDigest md=BlobUtils.createMessageDigest();\n  BlobKey blobKey=null;\n  try (FileOutputStream fos=new FileOutputStream(incomingFile)){\n    md.update(value);\n    fos.write(value);\n// bug_start\n// bug_end\n    blobKey=moveTempFileToStore(incomingFile,jobId,md.digest(),blobType);\n    return blobKey;\n  }\n  finally {\n    if (!incomingFile.delete() && incomingFile.exists()) {\n      LOG.warn(\"Could not delete the staging file {} for blob key {} and job {}.\",incomingFile,blobKey,jobId);\n    }\n  }\n}\n"}
{"INPUT": "protected String getUpNextAndQueueTime(){\n// bug_start\n  return getResources().getString(R.string.up_next) + \"    \" + MusicUtil.getReadableDurationString(MusicPlayerRemote.getQueueDurationMillis(MusicPlayerRemote.getPosition()));\n// bug_end\n}\n"}
{"INPUT": "private void runCompletenessCheck(String dataset,Map<String,Long> bucketNameToBucketValueMS,Map<String,Long> bucketNameToCount,DataCompletenessAlgorithm dataCompletenessAlgorithm,Double expectedCompleteness){\n  for (  Entry<String,Long> entry : bucketNameToBucketValueMS.entrySet()) {\n    String bucketName=entry.getKey();\n    Long bucketValue=entry.getValue();\n// bug_start\n    Long currentCount=bucketNameToCount.getOrDefault(bucketName,0L);\n// bug_end\n    LOG.info(\"Bucket name:{} Current count:{}\",bucketName,currentCount);\n    List<Long> baselineCounts=dataCompletenessAlgorithm.getBaselineCounts(dataset,bucketValue);\n    LOG.info(\"Baseline counts:{}\",baselineCounts);\n    double percentComplete=dataCompletenessAlgorithm.getPercentCompleteness(baselineCounts,currentCount);\n    LOG.info(\"Percent complete:{}\",percentComplete);\n    boolean dataComplete=dataCompletenessAlgorithm.isDataComplete(percentComplete,expectedCompleteness);\n    LOG.info(\"IsDataComplete:{}\",dataComplete);\n    DataCompletenessConfigDTO configToUpdate=DAO_REGISTRY.getDataCompletenessConfigDAO().findByDatasetAndDateSDF(dataset,bucketName);\n    configToUpdate.setCountStar(currentCount);\n    configToUpdate.setDataComplete(dataComplete);\n    configToUpdate.setPercentComplete(Double.parseDouble(new DecimalFormat(\"##.##\").format(percentComplete)));\n    configToUpdate.setNumAttempts(configToUpdate.getNumAttempts() + 1);\n    DAO_REGISTRY.getDataCompletenessConfigDAO().update(configToUpdate);\n    LOG.info(\"Updated data completeness config id:{} with count *:{} dataComplete:{} percentComplete:{} \" + \"and numAttempts:{}\",configToUpdate.getId(),configToUpdate.getCountStar(),configToUpdate.isDataComplete(),configToUpdate.getPercentComplete(),configToUpdate.getNumAttempts());\n  }\n}\n"}
{"INPUT": "// bug_start\nprivate static Condition ruleItem2Condition(RuleItem ruleItem){\n// bug_end\n  if (ruleItem instanceof PatternDefImpl) {\n    PatternDefImpl<?> patternDef=(PatternDefImpl)ruleItem;\n    Variable<?> patternVariable=patternDef.getFirstVariable();\n    PatternImpl pattern=new PatternImpl(patternVariable,patternVariable instanceof Exchange ? Condition.Type.RECEIVER : Condition.Type.PATTERN);\n    for (    PatternItem patternItem : patternDef.getItems()) {\n      if (patternItem instanceof PatternExprImpl) {\n        pattern.addConstraint(((PatternExprImpl)patternItem).asConstraint(patternDef));\n      }\n else       if (patternItem instanceof PatternBindingImpl) {\n        pattern.addBinding(((PatternBindingImpl)patternItem).asBinding(patternDef));\n      }\n else {\n        throw new UnsupportedOperationException(\"Unknown pattern item type: \" + patternItem);\n      }\n    }\n    pattern.addWatchedProps(patternDef.getWatch());\n    return pattern;\n  }\n  if (ruleItem instanceof FixedValueItem) {\n    return new EvalImpl(((FixedValueItem)ruleItem).isValue());\n  }\n  if (ruleItem instanceof QueryCallViewItem) {\n    return new QueryCallPattern((QueryCallViewItem)ruleItem);\n  }\n  if (ruleItem instanceof CombinedExprViewItem) {\n    CombinedExprViewItem combined=(CombinedExprViewItem)ruleItem;\n    List<Condition> conditions=new ArrayList<>();\n    for (    ViewItem expr : combined.getExpressions()) {\n      conditions.add(ruleItem2Condition(expr));\n    }\n    return new CompositePatterns(combined.getType(),conditions);\n  }\n  if (ruleItem instanceof ExistentialExprViewItem) {\n    ExistentialExprViewItem existential=(ExistentialExprViewItem)ruleItem;\n    return new ExistentialPatternImpl(ruleItem2Condition(existential.getExpression()),existential.getType());\n  }\n  if (ruleItem instanceof GroupByExprViewItem) {\n    GroupByExprViewItem groupBy=(GroupByExprViewItem)ruleItem;\n    return new GroupByPatternImpl(ruleItem2Condition(groupBy.getExpr()),groupBy.getVars(),groupBy.getVarKey(),groupBy.getGroupingFunction(),groupBy.getAccumulateFunctions());\n  }\n  if (ruleItem instanceof AccumulateExprViewItem) {\n    AccumulateExprViewItem acc=(AccumulateExprViewItem)ruleItem;\n    return new AccumulatePatternImpl(ruleItem2Condition(acc.getExpr()),acc.getAccumulateFunctions());\n  }\n  if (ruleItem instanceof ExprViewItem) {\n    return new EvalImpl(createConstraint((ExprViewItem)ruleItem));\n  }\n  if (ruleItem instanceof ExchangeDefImpl) {\n    ExchangeDefImpl<?> exchangeDef=(ExchangeDefImpl)ruleItem;\n    return new PatternImpl(exchangeDef.getFirstVariable(),Condition.Type.SENDER);\n  }\n  throw new UnsupportedOperationException(\"Unknown \" + ruleItem);\n}\n"}
{"INPUT": "@Override public List<int[]> calculateOutputShape(){\n  List<int[]> ret=new ArrayList<>(1);\n// bug_start\n// bug_end\n  val arr=sameDiff.getArrForVarName(arg().getVarName());\n  if (arr == null)   throw new ND4JIllegalStateException(\"Array must not be null for argument!\");\n  ret.add(arr.shape());\n  this.n=arr.length();\n  return ret;\n}\n"}
{"INPUT": "@Override public Integer getValue(Keyframe<Integer> keyframe,float keyframeProgress){\n// bug_start\n// bug_end\n  int startColor=keyframe.startValue;\n  int endColor=keyframe.endValue;\n  return GammaEvaluator.evaluate(keyframeProgress,startColor,endColor);\n}\n"}
{"INPUT": "private void runAndAssertDataCorrect(String... args){\n  run(args);\n  try (GraknGraph graph=session.open(GraknTxType.READ)){\n    EntityType personType=graph.getEntityType(\"person\");\n    assertEquals(1,personType.instances().size());\n    Entity person=personType.instances().iterator().next();\n    Entity address=getProperty(graph,person,\"has-address\").asEntity();\n    Entity streetAddress=getProperty(graph,address,\"address-has-street\").asEntity();\n// bug_start\n    Resource number=getResource(graph,streetAddress,Label.of(\"number\")).asResource();\n// bug_end\n    assertEquals(21L,number.getValue());\n    Collection<Thing> phoneNumbers=getProperties(graph,person,\"has-phone\");\n    assertEquals(2,phoneNumbers.size());\n  }\n }\n"}
{"INPUT": "private byte[] toBulkBytes(final MonitoringDoc doc) throws IOException {\n  final XContentType xContentType=XContentType.JSON;\n  final XContent xContent=xContentType.xContent();\n  try (BytesStreamOutput out=new BytesStreamOutput()){\n    MonitoringIndexNameResolver<MonitoringDoc> resolver=registry.getResolver(doc);\n    if (resolver != null) {\n      String index=resolver.index(doc);\n// bug_start\n      String type=resolver.type(doc);\n      String id=resolver.id(doc);\n// bug_end\n      try (XContentBuilder builder=new XContentBuilder(xContent,out)){\n        builder.startObject();\n        builder.startObject(\"index\");\n        builder.field(\"_index\",index);\n        builder.field(\"_type\",type);\n        if (id != null) {\n          builder.field(\"_id\",id);\n        }\n        builder.endObject();\n        builder.endObject();\n      }\n       out.write(xContent.streamSeparator());\n      BytesRef bytesRef=resolver.source(doc,xContentType).toBytesRef();\n      out.write(bytesRef.bytes,bytesRef.offset,bytesRef.length);\n      out.write(xContent.streamSeparator());\n      logger.trace(\"added index request [index={}, type={}, id={}]\",index,type,id);\n    }\n else {\n// bug_start\n      logger.error(\"no resolver found for monitoring document [class={}, id={}, version={}]\",doc.getClass().getName(),doc.getMonitoringId(),doc.getMonitoringVersion());\n// bug_end\n    }\n    return BytesReference.toBytes(out.bytes());\n  }\n catch (  Exception e) {\n    logger.warn((Supplier<?>)null,e);\n    return BytesRef.EMPTY_BYTES;\n  }\n}\n"}
{"INPUT": "// bug_start\npublic static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry){\n  valuesSourceRegistry.registerAny(ValueCountAggregationBuilder.NAME,new ValueCountAggregatorSupplier(){\n// bug_end\n    @Override public Aggregator build(    String name,    ValuesSource valuesSource,    SearchContext aggregationContext,    Aggregator parent,    Map<String,Object> metadata) throws IOException {\n      return new ValueCountAggregator(name,valuesSource,aggregationContext,parent,metadata);\n    }\n  }\n);\n}\n"}
{"INPUT": "public void run(){\n  if (mStopTicking) {\n    return;\n  }\n  onTimeChanged();\n  long now=SystemClock.uptimeMillis();\n  long next=now + (1000 - now % 1000);\n// bug_start\n  getHandler().postAtTime(mTicker,next);\n// bug_end\n}\n"}
{"INPUT": "public List<FeedCategory> findByParent(User user,FeedCategory parent){\n  EasyCriteria<FeedCategory> criteria=createCriteria();\n  criteria.andEquals(FeedCategory_.user.getName(),user);\n// bug_start\n  criteria.andEquals(FeedCategory_.parent.getName(),parent);\n// bug_end\n  return criteria.getResultList();\n}\n"}
{"INPUT": "public void updateIdentityAfterCommit(final ORID oldRid,final ORID newRid){\n  if (oldRid.equals(newRid))   return;\n  final List<KeyChangesUpdateRecord> keyRecordsToReinsert=new ArrayList<KeyChangesUpdateRecord>();\n  final OIndexManager indexManager=getDatabase().getMetadata().getIndexManager();\n  for (  Entry<String,OTransactionIndexChanges> entry : indexEntries.entrySet()) {\n    final OIndex<?> index=indexManager.getIndex(entry.getKey());\n    if (index == null)     throw new OTransactionException(\"Cannot find index '\" + entry.getValue() + \"' while committing transaction\");\n    final Dependency[] fieldRidDependencies=getIndexFieldRidDependencies(index);\n    if (!isIndexMayDependOnRids(fieldRidDependencies))     continue;\n    final OTransactionIndexChanges indexChanges=entry.getValue();\n    for (final Iterator<OTransactionIndexChangesPerKey> iterator=indexChanges.changesPerKey.values().iterator(); iterator.hasNext(); ) {\n      final OTransactionIndexChangesPerKey keyChanges=iterator.next();\n      if (isIndexKeyMayDependOnRid(keyChanges.key,oldRid,fieldRidDependencies)) {\n        keyRecordsToReinsert.add(new KeyChangesUpdateRecord(keyChanges,indexChanges));\n        iterator.remove();\n      }\n    }\n  }\n  final ORecordOperation rec=getRecordEntry(oldRid);\n  if (rec != null) {\n    updatedRids.put(newRid.copy(),oldRid.copy());\n    if (!rec.getRecord().getIdentity().equals(newRid)) {\n      ORecordInternal.onBeforeIdentityChanged(rec.getRecord());\n      final ORecordId recordId=(ORecordId)rec.getRecord().getIdentity();\n      if (recordId == null) {\n        ORecordInternal.setIdentity(rec.getRecord(),new ORecordId(newRid));\n      }\n else {\n// bug_start\n        recordId.clusterPosition=newRid.getClusterPosition();\n        recordId.clusterId=newRid.getClusterId();\n// bug_end\n      }\n      ORecordInternal.onAfterIdentityChanged(rec.getRecord());\n    }\n  }\n  for (  KeyChangesUpdateRecord record : keyRecordsToReinsert)   record.indexChanges.changesPerKey.put(record.keyChanges.key,record.keyChanges);\n  final List<OTransactionRecordIndexOperation> transactionIndexOperations=recordIndexOperations.get(translateRid(oldRid));\n  if (transactionIndexOperations != null) {\n    for (    final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {\n      OTransactionIndexChanges indexEntryChanges=indexEntries.get(indexOperation.index);\n      if (indexEntryChanges == null)       continue;\n      final OTransactionIndexChangesPerKey keyChanges=indexEntryChanges.changesPerKey.get(indexOperation.key);\n      if (keyChanges != null)       updateChangesIdentity(oldRid,newRid,keyChanges);\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\npublic OrchestrationListenerManager(final String name,final RegistryRepository registryRepository,final ConfigurationRepository configurationRepository,final Collection<String> shardingSchemaNames){\n  configurationListenerManager=new ConfigurationListenerManager(name,configurationRepository,shardingSchemaNames);\n// bug_end\n  registryListenerManager=new RegistryListenerManager(name,registryRepository);\n// bug_start\n  metaDataListenerManager=new MetaDataListenerManager(name,configurationRepository,shardingSchemaNames);\n// bug_end\n}\n"}
{"INPUT": "public static ValueNode toValueNode(Object o){\n  if (o == null)   return ValueNode.NULL_NODE;\n  if (o instanceof ValueNode)   return (ValueNode)o;\n  if (o instanceof Class)   return createClassNode((Class)o);\n else   if (isPath(o))   return new PathNode(o.toString(),false,false);\n// bug_start\n else   if (isJson(o))   return createStringNode(o.toString(),false);\n else   if (o instanceof String)   return createStringNode(o.toString(),false);\n// bug_end\n else   if (o instanceof Character)   return createStringNode(o.toString(),false);\n else   if (o instanceof Number)   return createNumberNode(o.toString());\n else   if (o instanceof Boolean)   return createBooleanNode(o.toString());\n else   if (o instanceof Pattern)   return createPatternNode((Pattern)o);\n else   throw new JsonPathException(\"Could not determine value type\");\n}\n"}
{"INPUT": "public final SQLExpr primaryRest(SQLExpr expr){\n  if (expr == null) {\n    throw new IllegalArgumentException(\"expr\");\n  }\n  if (lexer.token() == Token.LITERAL_CHARS) {\n    if (expr instanceof SQLIdentifierExpr) {\n      SQLIdentifierExpr identExpr=(SQLIdentifierExpr)expr;\n      String ident=identExpr.getName();\n      if (ident.equalsIgnoreCase(\"x\")) {\n        String charValue=lexer.stringVal();\n        lexer.nextToken();\n        expr=new SQLHexExpr(charValue);\n        return primaryRest(expr);\n      }\n else       if (ident.startsWith(\"_\")) {\n        String charValue=lexer.stringVal();\n        lexer.nextToken();\n        MySqlCharExpr mysqlCharExpr=new MySqlCharExpr(charValue);\n        mysqlCharExpr.setCharset(identExpr.getName());\n        if (lexer.identifierEquals(FnvHash.Constants.COLLATE)) {\n          lexer.nextToken();\n          String collate=lexer.stringVal();\n          mysqlCharExpr.setCollate(collate);\n          accept(Token.IDENTIFIER);\n        }\n        expr=mysqlCharExpr;\n        return primaryRest(expr);\n      }\n    }\n else     if (expr instanceof SQLCharExpr) {\n      String text2=((SQLCharExpr)expr).getText();\n      do {\n        String chars=lexer.stringVal();\n        text2+=chars;\n        lexer.nextToken();\n      }\n while (lexer.token() == Token.LITERAL_CHARS || lexer.token() == Token.LITERAL_ALIAS);\n      expr=new SQLCharExpr(text2);\n// bug_start\n// bug_end\n    }\n  }\n else   if (lexer.token() == Token.IDENTIFIER) {\n    if (expr instanceof SQLHexExpr) {\n      if (\"USING\".equalsIgnoreCase(lexer.stringVal())) {\n        lexer.nextToken();\n        if (lexer.token() != Token.IDENTIFIER) {\n          throw new ParserException(\"syntax error, illegal hex. \" + lexer.info());\n        }\n        String charSet=lexer.stringVal();\n        lexer.nextToken();\n        expr.getAttributes().put(\"USING\",charSet);\n        return primaryRest(expr);\n      }\n    }\n else     if (lexer.identifierEquals(FnvHash.Constants.COLLATE)) {\n      lexer.nextToken();\n      if (lexer.token() == Token.EQ) {\n        lexer.nextToken();\n      }\n      if (lexer.token() != Token.IDENTIFIER && lexer.token() != Token.LITERAL_CHARS) {\n        throw new ParserException(\"syntax error. \" + lexer.info());\n      }\n      String collate=lexer.stringVal();\n      lexer.nextToken();\n      SQLBinaryOpExpr binaryExpr=new SQLBinaryOpExpr(expr,SQLBinaryOperator.COLLATE,new SQLIdentifierExpr(collate),JdbcConstants.MYSQL);\n      expr=binaryExpr;\n      return primaryRest(expr);\n    }\n else     if (expr instanceof SQLVariantRefExpr) {\n      if (lexer.identifierEquals(FnvHash.Constants.COLLATE)) {\n        lexer.nextToken();\n        if (lexer.token() != Token.IDENTIFIER && lexer.token() != Token.LITERAL_CHARS) {\n          throw new ParserException(\"syntax error. \" + lexer.info());\n        }\n        String collate=lexer.stringVal();\n        lexer.nextToken();\n        expr.putAttribute(\"COLLATE\",collate);\n        return primaryRest(expr);\n      }\n    }\n  }\n  if (lexer.token() == Token.VARIANT && \"@\".equals(lexer.stringVal())) {\n    return userNameRest(expr);\n  }\n  if (lexer.token() == Token.ERROR) {\n    throw new ParserException(\"syntax error. \" + lexer.info());\n  }\n  return super.primaryRest(expr);\n}\n"}
{"INPUT": "@Override public void hide(){\n  if (closing || dialog.getMainArea().isDisposed() || getParentShell(getParent()).isDisposed()|| (getParent() instanceof SwtDialog && ((SwtDialog)getParent()).isDisposing())) {\n    return;\n  }\n  WindowProperty windowProperty=new WindowProperty(getShell());\n  PropsUI.getInstance().setScreen(windowProperty);\n  super.hide();\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "protected final static Number coerceToNumber(final Number number,final Class type) throws IllegalArgumentException {\n  if (Long.TYPE == type || Long.class.equals(type)) {\n    return new Long(number.longValue());\n  }\n  if (Double.TYPE == type || Double.class.equals(type)) {\n    return new Double(number.doubleValue());\n  }\n  if (Integer.TYPE == type || Integer.class.equals(type)) {\n    return new Integer(number.intValue());\n  }\n  if (BigInteger.class.equals(type)) {\n    if (number instanceof BigDecimal) {\n      return ((BigDecimal)number).toBigInteger();\n    }\n// bug_start\n// bug_end\n    return BigInteger.valueOf(number.longValue());\n  }\n  if (BigDecimal.class.equals(type)) {\n// bug_start\n// bug_end\n    if (number instanceof BigInteger) {\n      return new BigDecimal((BigInteger)number);\n    }\n    return new BigDecimal(number.doubleValue());\n  }\n  if (Byte.TYPE == type || Byte.class.equals(type)) {\n    return new Byte(number.byteValue());\n  }\n  if (Short.TYPE == type || Short.class.equals(type)) {\n    return new Short(number.shortValue());\n  }\n  if (Float.TYPE == type || Float.class.equals(type)) {\n    return new Float(number.floatValue());\n  }\n  throw new IllegalArgumentException(MessageFactory.get(\"error.convert\",number,number.getClass(),type));\n}\n"}
{"INPUT": "// bug_start\nstatic float measurePara(TextPaint paint,CharSequence text,int start,int end,TextDirectionHeuristic textDir){\n// bug_end\n  MeasuredText mt=MeasuredText.obtain();\n  TextLine tl=TextLine.obtain();\n  try {\n    mt.setPara(text,start,end,textDir,null);\n    Directions directions;\n    int dir;\n    if (mt.mEasy) {\n      directions=DIRS_ALL_LEFT_TO_RIGHT;\n      dir=Layout.DIR_LEFT_TO_RIGHT;\n    }\n else {\n      directions=AndroidBidi.directions(mt.mDir,mt.mLevels,0,mt.mChars,0,mt.mLen);\n      dir=mt.mDir;\n    }\n    char[] chars=mt.mChars;\n    int len=mt.mLen;\n    boolean hasTabs=false;\n    TabStops tabStops=null;\n    int margin=0;\n    if (text instanceof Spanned) {\n      Spanned spanned=(Spanned)text;\n      LeadingMarginSpan[] spans=getParagraphSpans(spanned,start,end,LeadingMarginSpan.class);\n      for (      LeadingMarginSpan lms : spans) {\n        margin+=lms.getLeadingMargin(true);\n      }\n    }\n    for (int i=0; i < len; ++i) {\n      if (chars[i] == '\\t') {\n        hasTabs=true;\n        if (text instanceof Spanned) {\n          Spanned spanned=(Spanned)text;\n          int spanEnd=spanned.nextSpanTransition(start,end,TabStopSpan.class);\n          TabStopSpan[] spans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);\n          if (spans.length > 0) {\n            tabStops=new TabStops(TAB_INCREMENT,spans);\n          }\n        }\n        break;\n      }\n    }\n    tl.set(paint,text,start,end,dir,directions,hasTabs,tabStops);\n    return margin + Math.abs(tl.metrics(null));\n  }\n  finally {\n    TextLine.recycle(tl);\n    MeasuredText.recycle(mt);\n  }\n}\n"}
{"INPUT": "public void testActiveXObject(){\n// bug_start\n  testSame(CompilerTypeTestCase.ACTIVE_X_OBJECT_DEF,\"var x = new ActiveXObject();\",null);\n// bug_end\n  assertEquals(\"?\",findNameType(\"x\",globalScope).toString());\n}\n"}
{"INPUT": "static InputStream connect(URL url,Proxy proxy,EventHandler eventHandler) throws IOException, InterruptedException {\n  checkNotNull(proxy);\n  checkNotNull(eventHandler);\n  if (isProtocol(url,\"file\")) {\n    return url.openConnection().getInputStream();\n  }\n  if (!isHttp(url)) {\n    throw new IOException(\"Protocol must be http, https, or file\");\n  }\n  List<Throwable> suppressions=new ArrayList<>();\n  int retries=0;\n  int redirects=0;\n  int connectTimeout=CONNECT_TIMEOUT_MS;\n  while (true) {\n    HttpURLConnection connection=null;\n    try {\n      connection=(HttpURLConnection)url.openConnection(proxy);\n      connection.setRequestProperty(\"Accept-Encoding\",\"gzip\");\n      connection.setConnectTimeout(connectTimeout);\n      connection.setReadTimeout(READ_TIMEOUT_MS);\n      int code;\n      try {\n        connection.connect();\n        code=connection.getResponseCode();\n      }\n catch (      FileNotFoundException ignored) {\n        code=connection.getResponseCode();\n// bug_start\n// bug_end\n      }\ncatch (      IOException e) {\n        if (!e.getMessage().startsWith(\"Server returned\")) {\n          throw e;\n        }\n        code=connection.getResponseCode();\n      }\n      if (code == 200) {\n        return getInputStream(connection);\n      }\n else       if (code == 301 || code == 302) {\n        readAllBytesAndClose(connection.getInputStream());\n        if (++redirects == MAX_REDIRECTS) {\n          throw new UnrecoverableHttpException(\"Redirect loop detected\");\n        }\n        url=getLocation(connection);\n      }\n else       if (code < 500) {\n        readAllBytesAndClose(connection.getErrorStream());\n        throw new UnrecoverableHttpException(describeHttpResponse(connection));\n      }\n else {\n        throw new IOException(describeHttpResponse(connection));\n      }\n    }\n catch (    InterruptedIOException e) {\n      throw new InterruptedException();\n    }\ncatch (    UnrecoverableHttpException e) {\n      throw e;\n    }\ncatch (    UnknownHostException e) {\n      throw new IOException(\"Unknown host: \" + e.getMessage());\n    }\ncatch (    IOException e) {\n      if (connection != null) {\n        connection.disconnect();\n      }\n      if (e instanceof SocketTimeoutException) {\n        connectTimeout=Math.min(connectTimeout * 2,MAX_CONNECT_TIMEOUT_MS);\n      }\n      if (++retries == MAX_RETRIES) {\n        for (        Throwable suppressed : suppressions) {\n          e.addSuppressed(suppressed);\n        }\n        throw e;\n      }\n      suppressions.add(e);\n      int timeout=IntMath.pow(2,retries) * MIN_RETRY_DELAY_MS;\n      eventHandler.handle(Event.progress(String.format(\"Failed to connect to %s trying again in %,dms: %s\",url,timeout,e)));\n      TimeUnit.MILLISECONDS.sleep(timeout);\n    }\ncatch (    RuntimeException e) {\n      if (connection != null) {\n        connection.disconnect();\n      }\n      throw e;\n    }\n  }\n}\n"}
{"INPUT": "private void deleteCategories(){\n  if (mDeleteCategoryLabelList != null && mDeleteCategoryLabelList.size() > 0) {\n    for (    String label : mDeleteCategoryLabelList) {\n      Category category=CategoryDBModel.getInstance().findByCategoryLabel(label);\n      boolean isCheck=category.isCheck();\n      CategoryDBModel.getInstance().delete(category);\n      if (isCheck) {\n        if (mCategoryList.size() > 0) {\n          Category newCategory=mCategoryList.get(0);\n          newCategory.setCheck(true);\n// bug_start\n          sendDataUpdateBroadcast(true,null,false,false,false);\n// bug_end\n        }\n else {\n        }\n      }\n// bug_start\n else {\n        sendDataUpdateBroadcast(true,null,false,false,false);\n      }\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "private void appendFactoryAccessKeyInfo(Writer w) throws IOException {\n  w.append(\"    @Override\").append(\"\\n\");\n  w.append(\"    public CallTarget accessKeyInfo() {\").append(\"\\n\");\n// bug_start\n  appendOptionalDefaultHandlerBody(w,Message.KEY_INFO,\"0b111\");\n// bug_end\n  w.append(\"    }\").append(\"\\n\");\n}\n"}
{"INPUT": "@Test public void testReconfiguration() throws Exception {\n  File trustStoreFile=File.createTempFile(\"truststore\",\".jks\");\n  Map<String,Object> sslConfig=TestSslUtils.createSslConfig(false,true,Mode.SERVER,trustStoreFile,\"server\");\n  SslFactory sslFactory=new SslFactory(Mode.SERVER);\n  sslFactory.configure(sslConfig);\n  SSLContext sslContext=sslFactory.sslContext();\n  assertNotNull(\"SSL context not created\",sslContext);\n  assertSame(\"SSL context recreated unnecessarily\",sslContext,sslFactory.sslContext());\n  assertFalse(sslFactory.createSslEngine(\"localhost\",0).getUseClientMode());\n  sslFactory.reconfigure(sslConfig);\n  assertSame(\"SSL context recreated unnecessarily\",sslContext,sslFactory.sslContext());\n  trustStoreFile=File.createTempFile(\"truststore\",\".jks\");\n  sslConfig=TestSslUtils.createSslConfig(false,true,Mode.SERVER,trustStoreFile,\"server\");\n  sslFactory.reconfigure(sslConfig);\n  assertNotSame(\"SSL context not recreated\",sslContext,sslFactory.sslContext());\n  sslContext=sslFactory.sslContext();\n  trustStoreFile.setLastModified(System.currentTimeMillis() + 10000);\n  sslFactory.reconfigure(sslConfig);\n  assertNotSame(\"SSL context not recreated\",sslContext,sslFactory.sslContext());\n  sslContext=sslFactory.sslContext();\n  File keyStoreFile=new File((String)sslConfig.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG));\n  keyStoreFile.setLastModified(System.currentTimeMillis() + 10000);\n  sslFactory.reconfigure(sslConfig);\n  assertNotSame(\"SSL context not recreated\",sslContext,sslFactory.sslContext());\n  sslContext=sslFactory.sslContext();\n// bug_start\n// bug_end\n  keyStoreFile.setLastModified(System.currentTimeMillis() + 20000);\n  Files.delete(keyStoreFile.toPath());\n  sslFactory.reconfigure(sslConfig);\n  assertSame(\"SSL context recreated unnecessarily\",sslContext,sslFactory.sslContext());\n}\n"}
{"INPUT": "public static BitmapFactory.Options calculateInSampleSize(final BitmapFactory.Options options,final int reqWidth,final int reqHeight){\n  final int height=options.outHeight;\n  final int width=options.outWidth;\n  int inSampleSize=1;\n// bug_start\n  if (height > 400 || width > 450) {\n    if (height > reqHeight || width > reqWidth) {\n      final int heightRatio=Math.round((float)height / (float)reqHeight);\n      final int widthRatio=Math.round((float)width / (float)reqWidth);\n      inSampleSize=heightRatio < widthRatio ? heightRatio : widthRatio;\n    }\n// bug_end\n  }\n  options.inSampleSize=inSampleSize;\n  options.inJustDecodeBounds=false;\n  return options;\n}\n"}
{"INPUT": "private float enterPauseDuration(Element boundary,Element previous,Voice maryVoice){\n  if (!boundary.getTagName().equals(MaryXML.BOUNDARY))   throw new IllegalArgumentException(\"cannot call enterPauseDuration for non-pause element\");\n// bug_start\n  if (boundary.hasAttribute(\"dur\")) {\n// bug_end\n    try {\n// bug_start\n      return Float.parseFloat(boundary.getAttribute(\"dur\")) * 0.001f;\n// bug_end\n    }\n catch (    NumberFormatException nfe) {\n    }\n  }\n  float duration=0.4f;\n  if (previous == null || !previous.getTagName().equals(MaryXML.PHONE))   return duration;\n  if (null == this.pausetree)   return duration;\n  String phone=previous.getAttribute(\"p\");\n  Target t=new Target(phone,previous);\n  t.setFeatureVector(this.pauseFeatureComputer.computeFeatureVector(t));\n  String durationString=this.pausetree.getMostProbableString(t);\n  durationString=durationString.substring(0,durationString.length() - 2);\n  try {\n    duration=Float.parseFloat(durationString);\n  }\n catch (  NumberFormatException nfe) {\n  }\n  if (duration > 2000) {\n    logger.debug(\"Cutting long duration to 2000 ms -- was \" + duration);\n    duration=2000;\n  }\n  return duration;\n}\n"}
{"INPUT": "// bug_start\npublic static long randomPositiveLong(){\n// bug_end\n  long randomLong;\n  do {\n    randomLong=randomLong();\n  }\n while (randomLong == Long.MIN_VALUE);\n  return Math.abs(randomLong);\n}\n"}
{"INPUT": "// bug_start\npublic static DeviceTypeLoader s_instance(){\n// bug_end\n  if (s_deviceTypeLoader == null) {\n    s_deviceTypeLoader=new DeviceTypeLoader();\n    InputStream input=DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");\n    try {\n      s_deviceTypeLoader.loadDeviceTypesXML(input);\n    }\n catch (    ParserConfigurationException e) {\n      logger.error(\"parser config error when reading device types xml file: \",e);\n    }\ncatch (    SAXException e) {\n      logger.error(\"SAX exception when reading device types xml file: \",e);\n    }\ncatch (    IOException e) {\n      logger.error(\"I/O exception when reading device types xml file: \",e);\n    }\n    logger.debug(\"loaded {} devices: \",s_deviceTypeLoader.getDeviceTypes().size());\n    s_deviceTypeLoader.logDeviceTypes();\n  }\n  return s_deviceTypeLoader;\n}\n"}
{"INPUT": "@Override public String toString(){\n  if (isEmpty())   return \"[]\";\n  StringBuilder buf=new StringBuilder();\n  buf.append(\"[\");\n  for (int i=0; i < invokingStates.length; i++) {\n// bug_start\n    if (i > 0)     buf.append(\",\");\n// bug_end\n    buf.append(invokingStates[i]);\n    if (parents[i] != null) {\n// bug_start\n// bug_end\n      buf.append(parents[i].toString());\n    }\n else {\n      buf.append(\"null\");\n    }\n  }\n  buf.append(\"]\");\n  return buf.toString();\n}\n"}
{"INPUT": "public Tethering(TetheringDependencies deps){\n  mLog.mark(\"Tethering.constructed\");\n  mDeps=deps;\n  mContext=mDeps.getContext();\n  mNetd=mDeps.getINetd(mContext);\n  mLooper=mDeps.getTetheringLooper();\n  mNotificationUpdater=mDeps.getNotificationUpdater(mContext,mLooper);\n  mPublicSync=new Object();\n  mTetherStates=new ArrayMap<>();\n  mConnectedClientsTracker=new ConnectedClientsTracker();\n  mTetherMainSM=new TetherMainSM(\"TetherMain\",mLooper,deps);\n  mTetherMainSM.start();\n  mHandler=mTetherMainSM.getHandler();\n  mOffloadController=mDeps.getOffloadController(mHandler,mLog,new OffloadController.Dependencies(){\n    @Override public TetheringConfiguration getTetherConfig(){\n      return mConfig;\n    }\n  }\n);\n  mUpstreamNetworkMonitor=mDeps.getUpstreamNetworkMonitor(mContext,mTetherMainSM,mLog,TetherMainSM.EVENT_UPSTREAM_CALLBACK);\n  mForwardedDownstreams=new LinkedHashSet<>();\n  IntentFilter filter=new IntentFilter();\n  filter.addAction(ACTION_CARRIER_CONFIG_CHANGED);\n  mEntitlementMgr=mDeps.getEntitlementManager(mContext,mHandler,mLog,null);\n  mEntitlementMgr.setOnUiEntitlementFailedListener(null);\n  mEntitlementMgr.setTetheringConfigurationFetcher(null);\n  mCarrierConfigChange=new VersionedBroadcastListener(\"CarrierConfigChangeListener\",mContext,mHandler,filter,null);\n  mStateReceiver=new StateReceiver();\n  mUserManager=(UserManager)mContext.getSystemService(Context.USER_SERVICE);\n  mTetheringRestriction=new UserRestrictionActionListener(mUserManager,this,mNotificationUpdater);\n  mExecutor=new TetheringThreadExecutor(mHandler);\n  mActiveDataSubIdListener=new ActiveDataSubIdListener(mExecutor);\n  mNetdCallback=new NetdCallback();\n  updateConfiguration();\n// bug_start\n  mPrivateAddressCoordinator=new PrivateAddressCoordinator(mContext,mConfig);\n// bug_end\n  mBpfCoordinator=mDeps.getBpfCoordinator(new BpfCoordinator.Dependencies(){\n    @NonNull public Handler getHandler(){\n      return mHandler;\n    }\n    @NonNull public INetd getNetd(){\n      return mNetd;\n    }\n    @NonNull public NetworkStatsManager getNetworkStatsManager(){\n      return mContext.getSystemService(NetworkStatsManager.class);\n    }\n    @NonNull public SharedLog getSharedLog(){\n      return mLog;\n    }\n    @Nullable public TetheringConfiguration getTetherConfig(){\n      return mConfig;\n    }\n  }\n);\n  startStateMachineUpdaters();\n}\n"}
{"INPUT": "final View inflate(@NonNull ViewGroup parent){\n// bug_start\n// bug_end\n  if (mView == null) {\n    for (    LifecycleListener lifecycleListener : mLifecycleListeners) {\n      lifecycleListener.preCreateView(this);\n    }\n    mView=onCreateView(LayoutInflater.from(parent.getContext()),parent);\n    restoreViewState(mView);\n    mView.addOnAttachStateChangeListener(new OnAttachStateChangeListener(){\n      @Override public void onViewAttachedToWindow(      View v){\n        if (v == mView) {\n          mViewIsAttached=true;\n        }\n        attach(v);\n      }\n      @Override public void onViewDetachedFromWindow(      View v){\n        mViewIsAttached=false;\n        detach(v,true);\n      }\n    }\n);\n    for (    LifecycleListener lifecycleListener : mLifecycleListeners) {\n      lifecycleListener.postCreateView(this,mView);\n    }\n  }\n  return mView;\n}\n"}
{"INPUT": "void initialize(){\n// bug_start\n// bug_end\n  int i=mAdapter.size() - 1;\n  while (i >= 0) {\n    Row item=(Row)mAdapter.get(i);\n    if (item.isRenderedAsRowView()) {\n      mLastVisibleRowIndex=i;\n      break;\n    }\n    i--;\n  }\n}\n"}
{"INPUT": "// bug_start\npublic boolean apply(@Nullable ItemStack target){\n  if (target == null)   return false;\n  for (  ItemStack ore : this.ores)   if (OreDictionary.itemMatches(target,ore,false))   return true;\n// bug_end\n  return false;\n}\n"}
{"INPUT": "static ParsedBucket fromXContent(final XContentParser parser,final boolean keyed) throws IOException {\n  final ParsedBucket bucket=new ParsedBucket();\n  bucket.setKeyed(keyed);\n  XContentParser.Token token=parser.currentToken();\n  String currentFieldName=parser.currentName();\n  String rangeKey=null;\n  if (keyed) {\n    ensureExpectedToken(XContentParser.Token.FIELD_NAME,token,null);\n    rangeKey=currentFieldName;\n    ensureExpectedToken(XContentParser.Token.START_OBJECT,parser.nextToken(),null);\n  }\n  List<Aggregation> aggregations=new ArrayList<>();\n  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n    if (token == XContentParser.Token.FIELD_NAME) {\n      currentFieldName=parser.currentName();\n    }\n else     if (token.isValue()) {\n      if (CommonFields.KEY.getPreferredName().equals(currentFieldName)) {\n        bucket.key=parser.text();\n      }\n else       if (CommonFields.DOC_COUNT.getPreferredName().equals(currentFieldName)) {\n        bucket.setDocCount(parser.longValue());\n      }\n else       if (CommonFields.FROM.getPreferredName().equals(currentFieldName)) {\n        bucket.from=parser.text();\n      }\n else       if (CommonFields.TO.getPreferredName().equals(currentFieldName)) {\n        bucket.to=parser.text();\n      }\n    }\n else     if (token == XContentParser.Token.START_OBJECT) {\n// bug_start\n      aggregations.add(XContentParserUtils.parseTypedKeysObject(parser,Aggregation.TYPED_KEYS_DELIMITER,Aggregation.class));\n// bug_end\n    }\n  }\n  bucket.setAggregations(new Aggregations(aggregations));\n  if (keyed) {\n    if (rangeKey(bucket.from,bucket.to).equals(rangeKey)) {\n      bucket.key=null;\n    }\n else {\n      bucket.key=rangeKey;\n    }\n  }\n  return bucket;\n}\n"}
{"INPUT": "// bug_start\n@NoWarning(\"VA_FORMAT_STRING_BAD_CONVERSION\") public static void main(String[] args){\n// bug_end\n  java.sql.Time time=new java.sql.Time(System.currentTimeMillis());\n  java.sql.Timestamp ts=new java.sql.Timestamp(System.currentTimeMillis());\n  System.out.println(String.format(\"%tc\",time));\n  System.out.println(String.format(\"%tc\",ts));\n  System.out.println(String.format(\"%Tc\",time));\n  System.out.println(String.format(\"%Tc\",ts));\n}\n"}
{"INPUT": "@Override public RemoteInterpreterResult interpret(String sessionId,String className,String st,RemoteInterpreterContext interpreterContext) throws TException {\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"st:\\n{}\",st);\n  }\n  Interpreter intp=getInterpreter(sessionId,className);\n  InterpreterContext context=convert(interpreterContext);\n  context.setInterpreterClassName(intp.getClassName());\n  Scheduler scheduler=intp.getScheduler();\n  InterpretJobListener jobListener=new InterpretJobListener();\n  InterpretJob job=new InterpretJob(interpreterContext.getParagraphId(),\"RemoteInterpretJob_\" + System.currentTimeMillis(),jobListener,JobProgressPoller.DEFAULT_INTERVAL_MSEC,intp,st,context);\n  scheduler.submit(job);\n  while (!job.isTerminated()) {\nsynchronized (jobListener) {\n      try {\n        jobListener.wait(1000);\n      }\n catch (      InterruptedException e) {\n        logger.info(\"Exception in RemoteInterpreterServer while interpret, jobListener.wait\",e);\n      }\n    }\n  }\n  progressMap.remove(interpreterContext.getParagraphId());\n// bug_start\n  InterpreterResult result;\n  if (job.getStatus() == Status.ERROR) {\n    result=new InterpreterResult(Code.ERROR,Job.getStack(job.getException()));\n  }\n else {\n    result=(InterpreterResult)job.getReturn();\n    if (result == null) {\n      result=new InterpreterResult(Code.KEEP_PREVIOUS_RESULT);\n    }\n// bug_end\n  }\n  return convert(result,context.getConfig(),context.getGui(),context.getNoteGui());\n}\n"}
{"INPUT": "private static URL[] getJavadocRoots(JavaPlatform platform){\n  Set<URL> result=new HashSet<URL>();\n  List<ClassPath.Entry> l=platform.getBootstrapLibraries().entries();\n// bug_start\n  for (Iterator it=l.iterator(); it.hasNext(); ) {\n    ClassPath.Entry e=(ClassPath.Entry)it.next();\n// bug_end\n    result.addAll(Arrays.asList(JavadocForBinaryQuery.findJavadoc(e.getURL()).getRoots()));\n  }\n  return result.toArray(new URL[result.size()]);\n}\n"}
{"INPUT": "protected static String condensePackageString(String classname){\n// bug_start\n  String parts[]=classname.split(\"\\\\.\");\n// bug_end\n  StringBuilder dense=new StringBuilder();\n  for (int i=0; i < (parts.length - 1); i++) {\n// bug_start\n    dense.append(parts[i].charAt(0));\n// bug_end\n  }\n  if (dense.length() > 0) {\n    dense.append('.');\n  }\n  dense.append(parts[parts.length - 1]);\n  return dense.toString();\n}\n"}
{"INPUT": "@VisibleForTesting public static void registerSerde(){\n// bug_start\n  ComplexMetrics.registerSerde(TYPE_NAME,null);\n  ComplexMetrics.registerSerde(BUILD_TYPE_NAME,null);\n  ComplexMetrics.registerSerde(MERGE_TYPE_NAME,null);\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Override public void onSuccess(String result){\n// bug_end\n  try {\n// bug_start\n    JsonObject version=new JsonParser().parse(result).getAsJsonObject();\n// bug_end\n    JsonArray assets=version.get(\"assets\").getAsJsonArray();\n    if (assets.size() > 0) {\n      String oldVersion=HViewerApplication.getVersionName();\n      String newVersion=version.get(\"tag_name\").getAsString().substring(1);\n      String url=assets.get(0).getAsJsonObject().get(\"browser_download_url\").getAsString();\n      String detail=version.get(\"body\").getAsString();\n      new UpdateManager(activity,url,newVersion + \"\",detail).checkUpdateInfo(oldVersion,newVersion);\n    }\n else {\n      activity.showSnackBar(\"\");\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    activity.showSnackBar(\"\");\n  }\n}\n"}
{"INPUT": "public static <T>T getObjectInstanceFromGroovyResource(final Resource resource,final Class[] constructorArgs,final Object[] args,final Class<T> expectedType){\n  try {\n    if (resource == null) {\n      LOGGER.debug(\"No groovy script is defined\");\n      return null;\n    }\n    final String script=IOUtils.toString(resource.getInputStream(),StandardCharsets.UTF_8);\n// bug_start\n    final GroovyClassLoader classLoader=new GroovyClassLoader(ScriptingUtils.class.getClassLoader(),new CompilerConfiguration(),true);\n    final Class<T> clazz=classLoader.parseClass(script);\n// bug_end\n    LOGGER.debug(\"Preparing constructor arguments [{}] for resource [{}]\",args,resource);\n    final Constructor<T> ctor=clazz.getDeclaredConstructor(constructorArgs);\n    final T result=ctor.newInstance(args);\n    if (result != null && !expectedType.isAssignableFrom(result.getClass())) {\n      throw new ClassCastException(\"Result [\" + result + \" is of type \"+ result.getClass()+ \" when we were expecting \"+ expectedType);\n    }\n    return result;\n  }\n catch (  final Exception e) {\n    LOGGER.error(e.getMessage(),e);\n  }\n  return null;\n}\n"}
{"INPUT": "// bug_start\npublic void beforeIssue(Component component,DefaultIssue issue){\n// bug_end\n  for (  IssueListener listener : listeners) {\n// bug_start\n    listener.beforeIssue(component,issue);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Test public void test1Merge() throws Exception {\n  String stage1Mapping=XContentFactory.jsonBuilder().startObject().startObject(\"person\").startObject(\"properties\").startObject(\"name\").field(\"type\",\"string\").endObject().endObject().endObject().endObject().string();\n  DocumentMapperParser parser=createIndex(\"test\").mapperService().documentMapperParser();\n  DocumentMapper stage1=parser.parse(stage1Mapping);\n  String stage2Mapping=XContentFactory.jsonBuilder().startObject().startObject(\"person\").startObject(\"properties\").startObject(\"name\").field(\"type\",\"string\").endObject().startObject(\"age\").field(\"type\",\"integer\").endObject().startObject(\"obj1\").startObject(\"properties\").startObject(\"prop1\").field(\"type\",\"integer\").endObject().endObject().endObject().endObject().endObject().endObject().string();\n  DocumentMapper stage2=parser.parse(stage2Mapping);\n  DocumentMapper.MergeResult mergeResult=stage1.merge(stage2,mergeFlags().simulate(true));\n  assertThat(mergeResult.hasConflicts(),equalTo(false));\n// bug_start\n  assertThat(stage1.mappers().smartName(\"age\"),nullValue());\n  assertThat(stage1.mappers().smartName(\"obj1.prop1\"),nullValue());\n// bug_end\n  mergeResult=stage1.merge(stage2,mergeFlags().simulate(false));\n  assertThat(mergeResult.hasConflicts(),equalTo(false));\n// bug_start\n  assertThat(stage1.mappers().smartName(\"age\"),notNullValue());\n  assertThat(stage1.mappers().smartName(\"obj1.prop1\"),notNullValue());\n// bug_end\n}\n"}
{"INPUT": "private void updateDelta(Applications delta){\n  int deltaCount=0;\n  for (  Application app : delta.getRegisteredApplications()) {\n    for (    InstanceInfo instance : app.getInstances()) {\n      Applications applications=getApplications();\n      String instanceRegion=instanceRegionChecker.getInstanceRegion(instance);\n      if (!instanceRegionChecker.isLocalRegion(instanceRegion)) {\n        Applications remoteApps=remoteRegionVsApps.get(instanceRegion);\n        if (null == remoteApps) {\n          remoteApps=new Applications();\n          remoteRegionVsApps.put(instanceRegion,remoteApps);\n        }\n        applications=remoteApps;\n      }\n      ++deltaCount;\n      if (ActionType.ADDED.equals(instance.getActionType())) {\n        Application existingApp=applications.getRegisteredApplications(instance.getAppName());\n        if (existingApp == null) {\n          applications.addApplication(app);\n        }\n        logger.debug(\"Added instance {} to the existing apps in region {}\",instance.getId(),instanceRegion);\n        applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);\n      }\n else       if (ActionType.MODIFIED.equals(instance.getActionType())) {\n        Application existingApp=applications.getRegisteredApplications(instance.getAppName());\n        if (existingApp == null) {\n          applications.addApplication(app);\n        }\n        logger.debug(\"Modified instance {} to the existing apps \",instance.getId());\n        applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);\n      }\n else       if (ActionType.DELETED.equals(instance.getActionType())) {\n        Application existingApp=applications.getRegisteredApplications(instance.getAppName());\n// bug_start\n        if (existingApp == null) {\n          applications.addApplication(app);\n// bug_end\n        }\n// bug_start\n        logger.debug(\"Deleted instance {} to the existing apps \",instance.getId());\n        applications.getRegisteredApplications(instance.getAppName()).removeInstance(instance);\n// bug_end\n      }\n    }\n  }\n  logger.debug(\"The total number of instances fetched by the delta processor : {}\",deltaCount);\n  getApplications().setVersion(delta.getVersion());\n  getApplications().shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());\n  for (  Applications applications : remoteRegionVsApps.values()) {\n    applications.setVersion(delta.getVersion());\n    applications.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override protected void channelRead0(ChannelHandlerContext ctx,FullHttpRequest request) throws Exception {\n// bug_end\n  if (HttpUtil.is100ContinueExpected(request)) {\n    ctx.write(new DefaultFullHttpResponse(HTTP_1_1,CONTINUE,Unpooled.EMPTY_BUFFER));\n  }\n// bug_start\n  super.channelRead0(ctx,request);\n// bug_end\n}\n"}
{"INPUT": "@Override public String serializeTicket(final Ticket ticket){\n  try {\n    val serializer=ticketSerializationExecutionPlan.getTicketSerializer(ticket);\n    if (serializer == null) {\n      throw new IllegalArgumentException(\"Unable to find ticket serializer for \" + ticket.getId());\n    }\n    return serializer.toString(ticket);\n  }\n catch (  final Exception e) {\n// bug_start\n    LOGGER.error(e.getMessage(),e);\n// bug_end\n    throw e;\n  }\n}\n"}
{"INPUT": "private void awaitTopologyVersion(AffinityTopologyVersion topVer){\n  GridAffinityAssignment aff=head.get();\n  if (aff.topologyVersion().compareTo(topVer) >= 0)   return;\n  try {\n    if (log.isDebugEnabled())     log.debug(\"Will wait for topology version [locNodeId=\" + ctx.localNodeId() + \", topVer=\"+ topVer+ ']');\n    IgniteInternalFuture<AffinityTopologyVersion> fut=readyFuture(topVer);\n// bug_start\n    if (fut != null)     fut.get();\n// bug_end\n  }\n catch (  IgniteCheckedException e) {\n    throw new IgniteException(\"Failed to wait for affinity ready future for topology version: \" + topVer,e);\n  }\n}\n"}
{"INPUT": "// bug_start\npublic static Process setupTunnel(boolean verbose,String tunnelHost,int tunnelPort,String destHost,int destPort){\n// bug_end\n  if (destHost == null || destHost.isEmpty() || \"localhost\".equals(destHost) || \"127.0.0.1\".equals(destHost)) {\n    throw new RuntimeException(\"Trying to open tunnel to localhost.\");\n  }\n  return ShellUtils.runASyncProcess(verbose,new String[]{\"ssh\",String.format(\"-NL%d:%s:%d\",tunnelPort,destHost,destPort),tunnelHost},new File(\".\"));\n}\n"}
{"INPUT": "private String getBaseRepoPath(final String path){\n// bug_start\n  int pos=path.indexOf(\"repository\") + 10;\n// bug_end\n  if (pos < 0) {\n    return path;\n  }\n  int tmp=path.indexOf(File.separator,pos);\n  if (tmp <= 0) {\n    return path;\n  }\n  if (tmp > 0) {\n    pos=tmp + 1;\n  }\n  tmp=path.indexOf(File.separator,pos);\n  if (tmp > 0) {\n    pos=tmp + 1;\n  }\n  return path.substring(0,pos);\n}\n"}
{"INPUT": "private static void findAnnotatedClasses(BufferedWriter writer,File dir,int level) throws SQLException, IOException {\n  for (  File file : dir.listFiles()) {\n    if (file.isDirectory()) {\n      if (level < maxFindSourceLevel) {\n        findAnnotatedClasses(writer,file,level + 1);\n      }\n      continue;\n    }\n    if (!file.getName().endsWith(\".java\")) {\n      continue;\n    }\n    String packageName=getPackageOfClass(file);\n    if (packageName == null) {\n      System.err.println(\"Could not find package name for: \" + file);\n      continue;\n    }\n    String name=file.getName();\n    name=name.substring(0,name.length() - \".java\".length());\n    String className=packageName + \".\" + name;\n    Class<?> clazz;\n    try {\n      clazz=Class.forName(className);\n    }\n catch (    Throwable t) {\n      System.err.println(\"Could not load class file for: \" + file);\n      System.err.println(\"     \" + t);\n      continue;\n    }\n// bug_start\n    if (classHasAnnotations(clazz)) {\n// bug_end\n      writeConfigForTable(writer,clazz);\n// bug_start\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "private boolean ensureExists(final String znode){\n  try {\n    zooKeeper.create(znode,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n    LOG.debug(\"Created ZNode \" + znode);\n    return true;\n  }\n catch (  KeeperException.NodeExistsException e) {\n    return true;\n  }\ncatch (  KeeperException.NoNodeException e) {\n    return ensureParentExists(znode) && ensureExists(znode);\n  }\ncatch (  KeeperException e) {\n// bug_start\n    LOG.warn(\"Failed to create \" + znode + \":\",e);\n// bug_end\n  }\ncatch (  InterruptedException e) {\n// bug_start\n    LOG.warn(\"Failed to create \" + znode + \":\",e);\n// bug_end\n  }\n  return false;\n}\n"}
{"INPUT": "public LocalQueueStats createLocalQueueStats(String name,int partitionId){\n  LocalQueueStatsImpl stats=getLocalQueueStatsImpl(name);\n  QueueContainer container=containerMap.get(name);\n  if (container == null) {\n    return stats;\n  }\n  Address thisAddress=nodeEngine.getClusterService().getThisAddress();\n  PartitionInfo info=nodeEngine.getPartitionService().getPartitionInfo(partitionId);\n  if (thisAddress.equals(info.getOwner())) {\n    stats.setOwnedItemCount(container.size());\n// bug_start\n    System.out.println(\"I am owner : \" + nodeEngine.getLocalMember().getAddress());\n// bug_end\n  }\n else {\n    stats.setBackupItemCount(container.size());\n// bug_start\n    System.out.println(\"I am backup : \" + nodeEngine.getLocalMember().getAddress());\n// bug_end\n  }\n  container.setStats(stats);\n  return stats;\n}\n"}
{"INPUT": "// bug_start\n@Support({ASE,CUBRID,DB2,DERBY,H2,HSQLDB,INGRES,MYSQL,ORACLE,POSTGRES,SQLSERVER,SYBASE}) public static Field<String> currentUser(){\n// bug_end\n  return new CurrentUser();\n}\n"}
{"INPUT": "@Test public void shouldWriteEventToBuffer(){\n  final SubscribedEventWriter eventWriter=new SubscribedEventWriter(singleMessageWriter);\n// bug_start\n  eventWriter.channelId(123).event(BUFFER,1,BUFFER.capacity() - 1).eventType(EventType.RAFT_EVENT).longKey(123L).position(546L).topicId(876).subscriptionId(4L).subscriptionType(SubscriptionType.TOPIC_SUBSCRIPTION);\n// bug_end\n  final UnsafeBuffer buffer=new UnsafeBuffer(new byte[eventWriter.getLength() + 2]);\n  eventWriter.write(buffer,2);\n  headerDecoder.wrap(buffer,2);\n  bodyDecoder.wrap(buffer,2 + headerDecoder.encodedLength(),headerDecoder.blockLength(),headerDecoder.version());\n  assertThat(bodyDecoder.eventType()).isEqualTo(EventType.RAFT_EVENT);\n  assertThat(bodyDecoder.longKey()).isEqualTo(123L);\n  assertThat(bodyDecoder.position()).isEqualTo(546L);\n  assertThat(bodyDecoder.topicId()).isEqualTo(876);\n// bug_start\n  assertThat(bodyDecoder.subscriptionId()).isEqualTo(4L);\n// bug_end\n  final UnsafeBuffer eventBuffer=new UnsafeBuffer(new byte[bodyDecoder.eventLength()]);\n  bodyDecoder.getEvent(eventBuffer,0,eventBuffer.capacity());\n  assertThatBuffer(eventBuffer).hasBytes(BUFFER,1,BUFFER.capacity() - 1);\n}\n"}
{"INPUT": "private static void skip(XmlPullParser parser) throws XmlPullParserException, IOException {\n  if (parser.getEventType() != XmlPullParser.START_TAG) {\n    throw new IllegalStateException();\n  }\n  int depth=1;\n  while (depth != 0) {\nswitch (parser.next()) {\ncase XmlPullParser.END_TAG:\n      depth--;\n    break;\ncase XmlPullParser.START_TAG:\n  depth++;\nbreak;\n// bug_start\n// bug_end\n}\n}\n}\n"}
{"INPUT": "public static Memory valueOf(Memory key,Memory value,String arrayKey){\n  KeyValueMemory memory=new KeyValueMemory(key,value);\n// bug_start\n  memory.arrayKey=arrayKey;\n// bug_end\n  return memory;\n}\n"}
{"INPUT": "// bug_start\n@Test public void test(){\n// bug_end\n  final String stackName=\"dynamodb-\" + this.random8String();\n  try {\n    this.createStack(stackName,\"state/dynamodb.yaml\",new Parameter().withParameterKey(\"PartitionKeyName\").withParameterValue(\"id\").withParameterKey(\"SortKeyName\").withParameterValue(\"timestamp\").withParameterKey(\"Attribute1Name\").withParameterValue(\"organisation\").withParameterKey(\"Attribute2Name\").withParameterValue(\"category\").withParameterKey(\"Index1PartitionKeyName\").withParameterValue(\"timestamp\").withParameterKey(\"Index2PartitionKeyName\").withParameterValue(\"organisation\").withParameterKey(\"Index2SortKeyName\").withParameterValue(\"timestamp\"));\n  }\n  finally {\n    this.deleteStack(stackName);\n  }\n}\n"}
{"INPUT": "public UnpackedBakedQuad build(){\n  if (!full) {\n    throw new IllegalStateException(\"not enough data\");\n  }\n  if (texture == null) {\n    throw new IllegalStateException(\"texture not set\");\n  }\n  if (contractUVs) {\n// bug_start\n    float tX=texture.getOriginX() / texture.getMinU();\n    float tY=texture.getOriginY() / texture.getMinV();\n// bug_end\n    float tS=tX > tY ? tX : tY;\n    float ep=1f / (tS * 0x100);\n    int uve=0;\n    while (uve < format.getElementCount()) {\n      VertexFormatElement e=format.getElement(uve);\n      if (e.getUsage() == VertexFormatElement.EnumUsage.UV && e.getIndex() == 0) {\n        break;\n      }\n      uve++;\n    }\n    if (uve == format.getElementCount()) {\n      throw new IllegalStateException(\"Can't contract UVs: format doesn't contain UVs\");\n    }\n    float[] uvc=new float[4];\n    for (int v=0; v < 4; v++) {\n      for (int i=0; i < 4; i++) {\n        uvc[i]+=unpackedData[v][uve][i] / 4;\n      }\n    }\n    for (int v=0; v < 4; v++) {\n      for (int i=0; i < 4; i++) {\n        float uo=unpackedData[v][uve][i];\n        float un=uo * (1 - eps) + uvc[i] * eps;\n        float ud=uo - un;\n        float aud=ud;\n        if (aud < 0)         aud=-aud;\n        if (aud < ep) {\n          float udc=uo - uvc[i];\n          if (udc < 0)           udc=-udc;\n          if (udc < 2 * ep) {\n            un=(uo + uvc[i]) / 2;\n          }\n else {\n            un=uo + (ud < 0 ? ep : -ep);\n          }\n        }\n        unpackedData[v][uve][i]=un;\n      }\n    }\n  }\n  return new UnpackedBakedQuad(unpackedData,tint,orientation,texture,applyDiffuseLighting,format);\n}\n"}
{"INPUT": "static void addMaxHeap(final List<String> commandLine,final String maxHeap){\n  if (StringUtils.isNotBlank(maxHeap)) {\n    commandLine.add(\"-Xmx\" + maxHeap);\n// bug_start\n    commandLine.add(\"-XX:+UseConcMarkSweepGC\");\n    commandLine.add(\"-XX:CMSInitiatingOccupancyFraction=\" + CMS_INITIAL_OCCUPANCY_FRACTION);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Test public void testScanArtifacts() throws DatabaseException, InvalidSettingException {\n  if (canRun()) {\n    MavenProject project=new MockUp<MavenProject>(){\n      @Mock public Set<Artifact> getArtifacts(){\n        Set<Artifact> artifacts=new HashSet<Artifact>();\n        Artifact a=new ArtifactStub();\n        try {\n          File file=new File(Test.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n          a.setFile(file);\n          artifacts.add(a);\n        }\n catch (        URISyntaxException ex) {\n          Logger.getLogger(BaseDependencyCheckMojoTest.class.getName()).log(Level.SEVERE,null,ex);\n        }\n        return artifacts;\n      }\n      @Mock public String getName(){\n        return \"test-project\";\n      }\n    }\n.getMockInstance();\n    boolean autoUpdate=Settings.getBoolean(Settings.KEYS.AUTO_UPDATE);\n    Settings.setBoolean(Settings.KEYS.AUTO_UPDATE,false);\n// bug_start\n    Engine engine=new Engine(null,null);\n// bug_end\n    Settings.setBoolean(Settings.KEYS.AUTO_UPDATE,autoUpdate);\n    assertTrue(engine.getDependencies().isEmpty());\n    BaseDependencyCheckMojoImpl instance=new BaseDependencyCheckMojoImpl();\n    instance.scanArtifacts(project,engine);\n    assertFalse(engine.getDependencies().isEmpty());\n    engine.cleanup();\n  }\n}\n"}
{"INPUT": "private void restoreLastJobIdMap() throws IOException {\n  FileSystem fs=FileSystem.get(URI.create(this.properties.getProperty(ConfigurationKeys.STATE_STORE_FS_URI_KEY)),new Configuration());\n  Path taskStateStoreRootDir=new Path(this.properties.getProperty(ConfigurationKeys.STATE_STORE_ROOT_DIR_KEY));\n// bug_start\n// bug_end\n  FileStatus[] rootStatuses=fs.listStatus(taskStateStoreRootDir);\n  if (rootStatuses == null || rootStatuses.length == 0) {\n    return;\n  }\n  LOG.info(\"Restoring the mapping between jobs and IDs of their last runs\");\n  for (  FileStatus status : rootStatuses) {\n    FileStatus[] statuses=fs.listStatus(status.getPath(),new PathFilter(){\n      @Override public boolean accept(      Path path){\n        return !path.getName().startsWith(\"current\") && path.getName().endsWith(TASK_STATE_STORE_TABLE_SUFFIX);\n      }\n    }\n);\n    if (statuses == null || statuses.length == 0) {\n      continue;\n    }\n    Arrays.sort(statuses,new Comparator<FileStatus>(){\n      @Override public int compare(      FileStatus fileStatus1,      FileStatus fileStatus2){\n        String fileName1=fileStatus1.getPath().getName();\n        String taskId1=fileName1.substring(0,fileName1.indexOf('.'));\n        String fileName2=fileStatus2.getPath().getName();\n        String taskId2=fileName2.substring(0,fileName2.indexOf('.'));\n        Long ts1=Long.parseLong(taskId1.substring(taskId1.lastIndexOf('_') + 1));\n        Long ts2=Long.parseLong(taskId2.substring(taskId2.lastIndexOf('_') + 1));\n        return -ts1.compareTo(ts2);\n      }\n    }\n);\n    String jobName=status.getPath().getName();\n    String fileName=statuses[0].getPath().getName();\n    String lastJobId=fileName.substring(0,fileName.indexOf('.'));\n    LOG.info(String.format(\"Restored last job ID %s for job %s\",lastJobId,jobName));\n    this.lastJobIdMap.put(jobName,lastJobId);\n  }\n}\n"}
{"INPUT": "public synchronized void checkAndUpdateJobStatus(final ExecutionState latestStateChange){\nswitch (this.jobStatus) {\ncase CREATED:\n    if (jobHasScheduledStatus()) {\n      this.jobStatus=InternalJobStatus.SCHEDULED;\n    }\n else     if (latestStateChange == ExecutionState.CANCELED) {\n      if (jobHasFailedOrCanceledStatus()) {\n        this.jobStatus=InternalJobStatus.CANCELED;\n      }\n    }\n  break;\ncase SCHEDULED:\nif (latestStateChange == ExecutionState.RUNNING) {\n  this.jobStatus=InternalJobStatus.RUNNING;\n  return;\n}\n else if (latestStateChange == ExecutionState.CANCELED) {\n  if (jobHasFailedOrCanceledStatus()) {\n    this.jobStatus=InternalJobStatus.CANCELED;\n  }\n}\nbreak;\ncase RUNNING:\nif (latestStateChange == ExecutionState.CANCELING || latestStateChange == ExecutionState.CANCELED) {\nthis.jobStatus=InternalJobStatus.CANCELING;\nreturn;\n}\nif (latestStateChange == ExecutionState.FAILED) {\nfinal Iterator<ExecutionVertex> it=new ExecutionGraphIterator(this,true);\nwhile (it.hasNext()) {\nfinal ExecutionVertex vertex=it.next();\n// bug_start\nif (vertex.getExecutionState() == ExecutionState.FAILED && !vertex.hasRetriesLeft()) {\nthis.jobStatus=InternalJobStatus.FAILING;\nreturn;\n// bug_end\n}\n else {\n// bug_start\nthis.jobStatus=InternalJobStatus.RECOVERING;\nreturn;\n// bug_end\n}\n}\n}\nif (latestStateChange == ExecutionState.RECOVERING) {\nthis.jobStatus=InternalJobStatus.RECOVERING;\nreturn;\n}\nif (jobHasFinishedStatus()) {\nthis.jobStatus=InternalJobStatus.FINISHED;\n}\nbreak;\ncase RECOVERING:\nif (latestStateChange == ExecutionState.RERUNNING) {\nif (this.recovering.isEmpty()) {\nthis.jobStatus=InternalJobStatus.RUNNING;\nbreak;\n}\n}\nif (latestStateChange == ExecutionState.FAILED) {\nLOG.info(\"Another Failed Vertex while recovering\");\n}\nbreak;\ncase FAILING:\nif (jobHasFailedOrCanceledStatus()) {\nthis.jobStatus=InternalJobStatus.FAILED;\n}\nbreak;\ncase FAILED:\nLOG.error(\"Received update of execute state in job status FAILED\");\nbreak;\ncase CANCELING:\nif (jobHasFailedOrCanceledStatus()) {\nthis.jobStatus=InternalJobStatus.CANCELED;\n}\nbreak;\ncase CANCELED:\nLOG.error(\"Received update of execute state in job status CANCELED\");\nbreak;\ncase FINISHED:\nLOG.error(\"Received update of execute state in job status FINISHED\");\nbreak;\n}\n}\n"}
{"INPUT": "// bug_start\n@Inject protected RestActivateWatchAction(Settings settings,RestController controller,Client client){\n// bug_end\n  super(settings,controller,client);\n  controller.registerHandler(RestRequest.Method.PUT,URI_BASE + \"/watch/{id}/_activate\",this);\n  controller.registerHandler(RestRequest.Method.POST,URI_BASE + \"/watch/{id}/_activate\",this);\n  DeactivateRestHandler deactivateRestHandler=new DeactivateRestHandler(settings,controller,client);\n  controller.registerHandler(RestRequest.Method.PUT,URI_BASE + \"/watch/{id}/_deactivate\",deactivateRestHandler);\n  controller.registerHandler(RestRequest.Method.POST,URI_BASE + \"/watch/{id}/_deactivate\",deactivateRestHandler);\n}\n"}
{"INPUT": "// bug_start\nprivate void runDMNModelInvokingPMML(final DMNRuntime runtime){\n// bug_end\n  final DMNModel dmnModel=runtime.getModel(\"http://www.trisotech.com/definitions/_ca466dbe-20b4-4e88-a43f-4ce3aff26e4f\",\"KiePMMLScoreCard\");\n  assertThat(dmnModel,notNullValue());\n  assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()),dmnModel.hasErrors(),is(false));\n  final DMNContext emptyContext=DMNFactory.newContext();\n  final DMNResult dmnResult=runtime.evaluateAll(dmnModel,emptyContext);\n  LOG.debug(\"{}\",dmnResult);\n  assertThat(DMNRuntimeUtil.formatMessages(dmnResult.getMessages()),dmnResult.hasErrors(),is(false));\n  final DMNContext result=dmnResult.getContext();\n  assertThat((Map<String,Object>)result.get(\"my decision\"),hasEntry(\"calculatedScore\",new BigDecimal(\"41.345\")));\n  Map<String,DMNImportPMMLInfo> pmmlImportInfo=((DMNModelImpl)dmnModel).getPmmlImportInfo();\n  assertThat(pmmlImportInfo.keySet(),hasSize(1));\n  DMNImportPMMLInfo p0=pmmlImportInfo.values().iterator().next();\n  assertThat(p0.getImportName(),is(\"iris\"));\n  assertThat(p0.getModels(),hasSize(1));\n  DMNPMMLModelInfo m0=p0.getModels().iterator().next();\n  assertThat(m0.getName(),is(\"Sample Score\"));\n  assertThat(m0.getInputFields(),hasEntry(is(\"age\"),anything()));\n  assertThat(m0.getInputFields(),hasEntry(is(\"occupation\"),anything()));\n  assertThat(m0.getInputFields(),hasEntry(is(\"residenceState\"),anything()));\n  assertThat(m0.getInputFields(),hasEntry(is(\"validLicense\"),anything()));\n  assertThat(m0.getInputFields(),not(hasEntry(is(\"overallScore\"),anything())));\n  assertThat(m0.getInputFields(),not(hasEntry(is(\"calculatedScore\"),anything())));\n}\n"}
{"INPUT": "private ProtocolProviderServiceSipImpl findTargetFor(Request request){\n  if (request == null) {\n    logger.error(\"request shouldn't be null.\");\n    return null;\n  }\n  Set<ProtocolProviderServiceSipImpl> currentListeners=this.getSipListeners();\n  if (currentListeners.size() == 0) {\n    logger.error(\"no listeners\");\n    return null;\n  }\n  URI requestURI=request.getRequestURI();\n  if (requestURI.isSipURI()) {\n    String requestUser=((SipURI)requestURI).getUser();\n    List<ProtocolProviderServiceSipImpl> candidates=new ArrayList<ProtocolProviderServiceSipImpl>();\n    for (    ProtocolProviderServiceSipImpl listener : currentListeners) {\n// bug_start\n      String ourUserID=(String)listener.getAccountID().getUserID();\n// bug_end\n      if (ourUserID.equals(requestUser)) {\n        logger.trace(\"suitable candidate found: \" + listener.getAccountID());\n        candidates.add(listener);\n      }\n    }\n    if (candidates.size() == 1) {\n      ProtocolProviderServiceSipImpl perfectMatch=candidates.get(0);\n      logger.trace(\"Will dispatch to \\\"\" + perfectMatch.getAccountID() + \"\\\"\");\n      return perfectMatch;\n    }\n    if (candidates.size() > 1) {\n      for (      ProtocolProviderServiceSipImpl candidate : candidates) {\n        String hostValue=((SipURI)requestURI).getParameter(SipStackSharing.CONTACT_ADDRESS_CUSTOM_PARAM_NAME);\n        if (hostValue == null)         continue;\n        if (hostValue.equals(candidate.getContactAddressCustomParamValue())) {\n          logger.trace(\"Will dispatch to \\\"\" + candidate.getAccountID() + \"\\\" because \"+ \"\\\" the custom param was set\");\n          return candidate;\n        }\n      }\n      for (      ProtocolProviderServiceSipImpl candidate : candidates) {\n        URI fromURI=((FromHeader)request.getHeader(FromHeader.NAME)).getAddress().getURI();\n        if (fromURI.isSipURI() == false)         continue;\n        SipURI ourURI=(SipURI)candidate.getOurSipAddress((SipURI)fromURI).getURI();\n        String ourHost=ourURI.getHost();\n        URI toURI=((ToHeader)request.getHeader(ToHeader.NAME)).getAddress().getURI();\n        if (toURI.isSipURI() == false)         continue;\n        String toHost=((SipURI)toURI).getHost();\n        if (toHost.equals(ourHost)) {\n          logger.trace(\"Will dispatch to \\\"\" + candidate.getAccountID() + \"\\\" because \"+ \"host in the To: is the same as in our AOR\");\n          return candidate;\n        }\n      }\n      ProtocolProviderServiceSipImpl target=candidates.iterator().next();\n      logger.warn(\"Will randomly dispatch to \\\"\" + target.getAccountID() + \"\\\" because there is ambiguity on the username from\"+ \" the Request-URI\");\n      logger.trace(\"\\n\" + request);\n      return target;\n    }\n    ProtocolProviderServiceSipImpl target=currentListeners.iterator().next();\n    logger.info(\"Will randomly dispatch to \\\"\" + target.getAccountID() + \"\\\" because the username in the Request-URI \"+ \"is unknown or empty\");\n    logger.trace(\"\\n\" + request);\n    return target;\n  }\n else {\n    logger.error(\"Request-URI is not a SIP URI, dropping\");\n  }\n  return null;\n}\n"}
{"INPUT": "public void testMulticast(Bootstrap sb,Bootstrap cb) throws Throwable {\n  MulticastTestHandler mhandler=new MulticastTestHandler();\n  sb.handler(new SimpleChannelInboundHandler<Object>(){\n    @Override public void channelRead0(    ChannelHandlerContext ctx,    Object msg) throws Exception {\n    }\n  }\n);\n  cb.handler(mhandler);\n  sb.option(ChannelOption.IP_MULTICAST_IF,NetUtil.LOOPBACK_IF);\n  sb.option(ChannelOption.SO_REUSEADDR,true);\n  cb.option(ChannelOption.IP_MULTICAST_IF,NetUtil.LOOPBACK_IF);\n  cb.option(ChannelOption.SO_REUSEADDR,true);\n// bug_start\n// bug_end\n  cb.localAddress(addr.getPort());\n// bug_start\n  Channel sc=sb.bind().sync().channel();\n// bug_end\n  if (sc instanceof OioDatagramChannel) {\n    sc.close().awaitUninterruptibly();\n    return;\n  }\n  DatagramChannel cc=(DatagramChannel)cb.bind().sync().channel();\n  String group=\"230.0.0.1\";\n  InetSocketAddress groupAddress=SocketUtils.socketAddress(group,addr.getPort());\n  cc.joinGroup(groupAddress,NetUtil.LOOPBACK_IF).sync();\n  sc.writeAndFlush(new DatagramPacket(Unpooled.copyInt(1),groupAddress)).sync();\n  assertTrue(mhandler.await());\n  cc.leaveGroup(groupAddress,NetUtil.LOOPBACK_IF).sync();\n  Thread.sleep(1000);\n  sc.writeAndFlush(new DatagramPacket(Unpooled.copyInt(1),groupAddress)).sync();\n  mhandler.await();\n  sc.close().awaitUninterruptibly();\n  cc.close().awaitUninterruptibly();\n}\n"}
{"INPUT": "// bug_start\n@Override public void cleanFiles(int totalTranslogOps,Store.MetadataSnapshot sourceMetaData) throws IOException {\n  target.cleanFiles(totalTranslogOps,sourceMetaData);\n// bug_end\n}\n"}
{"INPUT": "@Override public AuthenticationTransactionManager handle(final AuthenticationTransaction authenticationTransaction,final AuthenticationResultBuilder authenticationResult) throws AuthenticationException {\n  if (!authenticationTransaction.getCredentials().isEmpty()) {\n    final Authentication authentication=this.authenticationManager.authenticate(authenticationTransaction);\n    LOGGER.debug(\"Successful authentication; Collecting authentication result [{}]\",authentication);\n    authenticationResult.collect(authentication);\n  }\n// bug_start\n  LOGGER.debug(\"Transaction ignored since there are no credentials to authenticate\");\n// bug_end\n  return this;\n}\n"}
{"INPUT": "private static ResultSet buildCasFailureResultSet(RowIterator partition,Iterable<ColumnDefinition> columnsWithConditions,boolean isBatch,QueryOptions options) throws InvalidRequestException {\n  CFMetaData cfm=partition.metadata();\n  Selection selection;\n  if (columnsWithConditions == null) {\n    selection=Selection.wildcard(cfm);\n  }\n else {\n    Set<ColumnDefinition> defs=new LinkedHashSet<>();\n    if (isBatch) {\n      defs.addAll(cfm.partitionKeyColumns());\n      defs.addAll(cfm.clusteringColumns());\n    }\n// bug_start\n    for (    ColumnDefinition def : columnsWithConditions)     defs.add(def);\n// bug_end\n    selection=Selection.forColumns(cfm,new ArrayList<>(defs));\n  }\n  Selection.ResultSetBuilder builder=selection.resultSetBuilder(false);\n  SelectStatement.forSelection(cfm,selection).processPartition(partition,options,builder,FBUtilities.nowInSeconds());\n  return builder.build(options.getProtocolVersion());\n}\n"}
{"INPUT": "public LBHttpSolrClient build(){\n  final String[] baseUrlArray=new String[baseSolrUrls.size()];\n  String[] solrServerUrls=baseSolrUrls.toArray(baseUrlArray);\n// bug_start\n  return httpSolrClientBuilder != null ? new LBHttpSolrClient(httpSolrClientBuilder,httpClient,solrServerUrls) : new LBHttpSolrClient(httpClient,responseParser,solrServerUrls);\n// bug_end\n}\n"}
{"INPUT": "private boolean connect() throws RestApiConnectionException {\n  if (autoEstablishAuthToken) {\n    if (authTokenTimeout <= 0) {\n      return false;\n    }\n else     if ((System.currentTimeMillis() - createdAt) > authTokenTimeout) {\n      return false;\n    }\n  }\n  HttpEntity httpEntity=null;\n  try {\n    httpEntity=this.getAuthentication();\n    if (httpEntity != null) {\n      JsonElement json=gson.fromJson(EntityUtils.toString(httpEntity),JsonObject.class);\n// bug_start\n// bug_end\n      JsonObject jsonRet=json.getAsJsonObject();\n      if (!this.hasId(jsonRet)) {\n// bug_start\n        throw new RestApiConnectionException(this.getFirstErrorMessage(\"Failed to establish auth token.\",json));\n// bug_end\n      }\n      this.instanceUrl=jsonRet.get(\"instance_url\").getAsString();\n      this.accessToken=jsonRet.get(\"access_token\").getAsString();\n      this.createdAt=System.currentTimeMillis();\n    }\n  }\n catch (  Exception e) {\n    throw new RestApiConnectionException(\"Failed to get rest api connection; error - \" + e.getMessage(),e);\n  }\n finally {\n    if (httpEntity != null) {\n      try {\n        EntityUtils.consume(httpEntity);\n      }\n catch (      Exception e) {\n        throw new RestApiConnectionException(\"Failed to consume httpEntity; error - \" + e.getMessage(),e);\n      }\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "JSONObject toJson() throws JSONException {\n  JSONObject metadata=new JSONObject();\nswitch (currentJsonVersion) {\ncase JSON_VERSION_1:\n    metadata.put(JSON_VERSION_KEY,JSON_VERSION_1);\n  metadata.put(CONTAINER_ID_KEY,id);\nmetadata.put(CONTAINER_NAME_KEY,name);\n// bug_start\nmetadata.put(STATUS_KEY,status);\n// bug_end\nmetadata.put(DESCRIPTION_KEY,description);\nmetadata.put(IS_PRIVATE_KEY,!cacheable);\nmetadata.put(PARENT_ACCOUNT_ID_KEY,parentAccountId);\nbreak;\ncase JSON_VERSION_2:\nmetadata.put(Container.JSON_VERSION_KEY,JSON_VERSION_2);\nmetadata.put(CONTAINER_ID_KEY,id);\nmetadata.put(CONTAINER_NAME_KEY,name);\n// bug_start\nmetadata.put(Container.STATUS_KEY,status);\n// bug_end\nmetadata.put(DESCRIPTION_KEY,description);\nmetadata.put(ENCRYPTED_KEY,encrypted);\nmetadata.put(PREVIOUSLY_ENCRYPTED_KEY,previouslyEncrypted);\nmetadata.put(CACHEABLE_KEY,cacheable);\nmetadata.put(MEDIA_SCAN_DISABLED_KEY,mediaScanDisabled);\nmetadata.putOpt(REPLICATION_POLICY_KEY,replicationPolicy);\nbreak;\ndefault :\nthrow new IllegalStateException(\"Unsupported container json version=\" + currentJsonVersion);\n}\nreturn metadata;\n}\n"}
{"INPUT": "@Override public boolean onDraggedDown(View startingChild,int dragLengthY){\n  if (hasActiveNotifications()) {\n    EventLogTags.writeSysuiLockscreenGesture(EventLogConstants.SYSUI_LOCKSCREEN_GESTURE_SWIPE_DOWN_FULL_SHADE,(int)(dragLengthY / mDisplayMetrics.density),0);\n    goToLockedShade(startingChild);\n// bug_start\n// bug_end\n    return true;\n  }\n else {\n    return false;\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override public void open(FileInputSplit split) throws IOException {\n  super.open(split);\n// bug_end\n  @SuppressWarnings(\"unchecked\") FieldParser<Object>[] fieldParsers=(FieldParser<Object>[])getFieldParsers();\n  this.parsedValues=new Object[fieldParsers.length];\n  for (int i=0; i < fieldParsers.length; i++) {\n    this.parsedValues[i]=fieldParsers[i].createValue();\n  }\n  if (this.getDelimiter().length == 1 && this.getDelimiter()[0] == '\\n') {\n    this.lineDelimiterIsLinebreak=true;\n  }\n  this.commentCount=0;\n  this.invalidLineCount=0;\n}\n"}
{"INPUT": "public void foo4(){\n  int prog, user;\n  prog=(int)(Math.random() * 10) + 1;\n  Scanner input=new Scanner(System.in,\"utf-8\");\n  if (input.hasNextInt()) {\n    do {\n      user=input.nextInt();\n      if (user == prog) {\n        String.CASE_INSENSITIVE_ORDER.equals(\"Good!\");\n      }\n else {\n        if (user > 0 && user <= 10) {\n          String.CASE_INSENSITIVE_ORDER.equals(\"Bad! \");\n          if (prog < user) {\n            String.CASE_INSENSITIVE_ORDER.equals(\"My number is less than yours.\");\n          }\n else {\n            String.CASE_INSENSITIVE_ORDER.equals(\"My number is greater than yours\");\n          }\n        }\n else {\n// bug_start\n          String.CASE_INSENSITIVE_ORDER.equals(\"Error!\");\n// bug_end\n        }\n      }\n    }\n while (user != prog);\n  }\n else {\n// bug_start\n    String.CASE_INSENSITIVE_ORDER.equals(\"Error!\");\n// bug_end\n  }\n  String.CASE_INSENSITIVE_ORDER.equals(\"Goodbye!\");\n}\n"}
{"INPUT": "protected static void appendProperties(Object config,Properties properties,String prefix){\n  if (config == null) {\n    return;\n  }\n  Method[] methods=config.getClass().getMethods();\n  for (  Method method : methods) {\n    try {\n      String name=method.getName();\n// bug_start\n      if (name.startsWith(\"set\") && Modifier.isPublic(method.getModifiers()) && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {\n        String key=name.substring(3);\n// bug_end\n        if (prefix != null && prefix.length() > 0) {\n          key=prefix + \".\" + key;\n        }\n        String value=properties.getProperty(key);\n        if (value != null && value.length() > 0) {\n          method.invoke(config,new Object[]{convertPrimitive(method.getParameterTypes()[0],value)});\n        }\n      }\n    }\n catch (    Exception e) {\n      logger.error(e.getMessage(),e);\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\nprotected ForwardingRuleKeyHasher(RuleKeyHasher<HASH> firstHasher,RuleKeyHasher<HASH2> secondHasher){\n// bug_end\n  this.secondHasher=secondHasher;\n  this.delegate=firstHasher;\n}\n"}
{"INPUT": "public void snapToWidget(boolean animate){\n  final DragLayer.LayoutParams lp=(DragLayer.LayoutParams)getLayoutParams();\n// bug_start\n  int xOffset=mCellLayout.getLeft() + mCellLayout.getPaddingLeft() - mWorkspace.getScrollX();\n  int yOffset=mCellLayout.getTop() + mCellLayout.getPaddingTop() - mWorkspace.getScrollY();\n// bug_end\n  int newWidth=mWidgetView.getWidth() + 2 * mBackgroundPadding - mWidgetPaddingLeft - mWidgetPaddingRight;\n  int newHeight=mWidgetView.getHeight() + 2 * mBackgroundPadding - mWidgetPaddingTop - mWidgetPaddingBottom;\n  int newX=mWidgetView.getLeft() - mBackgroundPadding + xOffset + mWidgetPaddingLeft;\n  int newY=mWidgetView.getTop() - mBackgroundPadding + yOffset + mWidgetPaddingTop;\n  if (newY < 0) {\n    mTopTouchRegionAdjustment=-newY;\n  }\n else {\n    mTopTouchRegionAdjustment=0;\n  }\n  if (newY + newHeight > mDragLayer.getHeight()) {\n    mBottomTouchRegionAdjustment=-(newY + newHeight - mDragLayer.getHeight());\n  }\n else {\n    mBottomTouchRegionAdjustment=0;\n  }\n  if (!animate) {\n    lp.width=newWidth;\n    lp.height=newHeight;\n    lp.x=newX;\n    lp.y=newY;\n    mLeftHandle.setAlpha(1.0f);\n    mRightHandle.setAlpha(1.0f);\n    mTopHandle.setAlpha(1.0f);\n    mBottomHandle.setAlpha(1.0f);\n    requestLayout();\n  }\n else {\n    PropertyValuesHolder width=PropertyValuesHolder.ofInt(\"width\",lp.width,newWidth);\n    PropertyValuesHolder height=PropertyValuesHolder.ofInt(\"height\",lp.height,newHeight);\n    PropertyValuesHolder x=PropertyValuesHolder.ofInt(\"x\",lp.x,newX);\n    PropertyValuesHolder y=PropertyValuesHolder.ofInt(\"y\",lp.y,newY);\n    ObjectAnimator oa=LauncherAnimUtils.ofPropertyValuesHolder(lp,width,height,x,y);\n    ObjectAnimator leftOa=LauncherAnimUtils.ofFloat(mLeftHandle,\"alpha\",1.0f);\n    ObjectAnimator rightOa=LauncherAnimUtils.ofFloat(mRightHandle,\"alpha\",1.0f);\n    ObjectAnimator topOa=LauncherAnimUtils.ofFloat(mTopHandle,\"alpha\",1.0f);\n    ObjectAnimator bottomOa=LauncherAnimUtils.ofFloat(mBottomHandle,\"alpha\",1.0f);\n    oa.addUpdateListener(new AnimatorUpdateListener(){\n      public void onAnimationUpdate(      ValueAnimator animation){\n        requestLayout();\n      }\n    }\n);\n    AnimatorSet set=LauncherAnimUtils.createAnimatorSet();\n    if (mResizeMode == AppWidgetProviderInfo.RESIZE_VERTICAL) {\n      set.playTogether(oa,topOa,bottomOa);\n    }\n else     if (mResizeMode == AppWidgetProviderInfo.RESIZE_HORIZONTAL) {\n      set.playTogether(oa,leftOa,rightOa);\n    }\n else {\n      set.playTogether(oa,leftOa,rightOa,topOa,bottomOa);\n    }\n    set.setDuration(SNAP_DURATION);\n    set.start();\n  }\n}\n"}
{"INPUT": "private static void addAsyncRedefineClasses(){\n  StringSet redefineClasses=new StringSet();\n  if (conf._hook_map_impl_enabled) {\n    redefineClasses.put(\"java.util.HashMap\");\n    redefineClasses.put(\"java.util.LinkedHashMap\");\n    redefineClasses.put(\"java.util.concurrent.ConcurrentHashMap\");\n    redefineClasses.put(\"java.util.HashTable\");\n  }\n// bug_start\n// bug_end\n  AsyncRunner.getInstance().add(redefineClasses);\n}\n"}
{"INPUT": "@Test public void shouldDisallowDirectoryListings() throws Exception {\n  server=CommunityServerBuilder.server().build();\n  server.start();\n// bug_start\n  HTTP.Response okResource=HTTP.GET(server.baseUri().resolve(\"/browser/content/help/create.html\").toString());\n  HTTP.Response illegalResource=HTTP.GET(server.baseUri().resolve(\"/browser/content/help/\").toString());\n// bug_end\n  assertEquals(200,okResource.status());\n  assertEquals(403,illegalResource.status());\n}\n"}
{"INPUT": "// bug_start\n@Override public void writeString(int fieldNumber,String value,boolean repeated) throws IOException {\n  generator.pushValue(schema,fieldNumber,new ImmutableStringValueImpl(value),repeated);\n// bug_end\n}\n"}
{"INPUT": "private void append(StringBuilder sb,List<Object> list,Object target){\n  for (  Object object : list) {\n    if (object instanceof FieldExtractor) {\n      Object field=((FieldExtractor)object).field(target);\n      if (field == NOT_FOUND) {\n        throw new EsHadoopIllegalArgumentException(String.format(\"Cannot find match for %s\",pattern));\n      }\n else {\n// bug_start\n        sb.append(field);\n// bug_end\n      }\n    }\n else {\n// bug_start\n      sb.append(object.toString());\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "@Override void addChild(WindowContainer child,int index){\n  boolean hadChild=hasChild();\n// bug_start\n// bug_end\n  index=getAdjustedChildPosition(child,index);\n  super.addChild(child,index);\n  ProtoLog.v(WM_DEBUG_ADD_REMOVE,\"addChild: %s at top.\",this);\n  if (mTaskOrganizer != null && mCreatedByOrganizer && child.asTask() != null) {\n    getDisplayArea().addStackReferenceIfNeeded((ActivityStack)child);\n  }\n  mRootWindowContainer.updateUIDsPresentOnDisplay();\n  final ActivityRecord r=child.asActivityRecord();\n  if (r == null)   return;\n  r.inHistory=true;\n  if (!hadChild) {\n    if (r.getActivityType() == ACTIVITY_TYPE_UNDEFINED) {\n      r.setActivityType(ACTIVITY_TYPE_STANDARD);\n    }\n    setActivityType(r.getActivityType());\n    isPersistable=r.isPersistable();\n    mCallingUid=r.launchedFromUid;\n    mCallingPackage=r.launchedFromPackage;\n    mCallingFeatureId=r.launchedFromFeatureId;\n    maxRecents=Math.min(Math.max(r.info.maxRecents,1),ActivityTaskManager.getMaxAppRecentsLimitStatic());\n  }\n else {\n// bug_start\n    r.setActivityType(getActivityType());\n// bug_end\n  }\n  updateEffectiveIntent();\n}\n"}
{"INPUT": "// bug_start\npublic static List<Rule> compose(Collection<ExternalDependency> dependencies){\n// bug_end\n  return dependencies.stream().filter(null).sorted(null).map(null).flatMap(null).collect(Collectors.toList());\n}\n"}
{"INPUT": "protected void parse(){\n  final String[] t=text.split(\"\\n\");\n  String[] tds;\n  final StringBuffer sb=new StringBuffer();\n  sb.append(\"<table\");\n  if (t[0].length() > 2)   sb.append(parseTableProperties(t[0].substring(2)));\n  sb.append(\">\\n\");\n  boolean trOpen=false;\n  for (int i=1, j, a; i < t.length - 1; i++) {\n    if (t[i].startsWith(\"|-\")) {\n      if (trOpen)       sb.append(\"\\t</tr>\\n\");\n// bug_start\n      if (trOpen=(i < t.length - 2))       sb.append(\"\\t<tr>\\n\");\n// bug_end\n    }\n else     if (t[i].startsWith(\"||\")) {\n      tds=t[i].split(\"\\\\|\\\\|\");\n      for (j=0; j < tds.length; j++) {\n        if (tds[j].length() > (a=tds[j].indexOf('|')) + 1) {\n          sb.append(\"\\t\\t<td\");\n          if (a > -1)           sb.append(parseTableProperties(tds[j].substring(0,a)));\n          sb.append(\">\").append(tds[j].substring(a + 1)).append(\"</td>\\n\");\n        }\n      }\n    }\n  }\n  if (trOpen)   sb.append(\"\\t</tr>\\n\");\n  this.markup=new String(sb.append(\"</table>\"));\n  this.parsed=true;\n}\n"}
{"INPUT": "// bug_start\npublic void addCellValue(int row,int column,String content){\n  int idx=content.indexOf(\"\\\"\");\n  if (idx > 0 && content.indexOf(\"\\\"\",idx) > -1) {\n    content=content.replace(\"\\\"\",\"\\\\\\\"\");\n// bug_end\n  }\n  this.sourceBuilder.addCellValue(row,column,content);\n}\n"}
{"INPUT": "OkHttpClient(Builder builder){\n  this.dispatcher=builder.dispatcher;\n  this.proxy=builder.proxy;\n  this.protocols=builder.protocols;\n  this.connectionSpecs=builder.connectionSpecs;\n  this.interceptors=Util.immutableList(builder.interceptors);\n  this.networkInterceptors=Util.immutableList(builder.networkInterceptors);\n  this.eventListenerFactory=builder.eventListenerFactory;\n  this.proxySelector=builder.proxySelector;\n  this.cookieJar=builder.cookieJar;\n  this.cache=builder.cache;\n  this.internalCache=builder.internalCache;\n  this.socketFactory=builder.socketFactory;\n  boolean isTLS=false;\n  for (  ConnectionSpec spec : connectionSpecs) {\n    isTLS=isTLS || spec.isTls();\n  }\n  if (builder.sslSocketFactory != null || !isTLS) {\n    this.sslSocketFactory=builder.sslSocketFactory;\n    this.certificateChainCleaner=builder.certificateChainCleaner;\n  }\n else {\n    X509TrustManager trustManager=systemDefaultTrustManager();\n    this.sslSocketFactory=systemDefaultSslSocketFactory(trustManager);\n    this.certificateChainCleaner=CertificateChainCleaner.get(trustManager);\n  }\n// bug_start\n// bug_end\n  this.hostnameVerifier=builder.hostnameVerifier;\n  this.certificatePinner=builder.certificatePinner.withCertificateChainCleaner(certificateChainCleaner);\n  this.proxyAuthenticator=builder.proxyAuthenticator;\n  this.authenticator=builder.authenticator;\n  this.connectionPool=builder.connectionPool;\n  this.dns=builder.dns;\n  this.followSslRedirects=builder.followSslRedirects;\n  this.followRedirects=builder.followRedirects;\n  this.retryOnConnectionFailure=builder.retryOnConnectionFailure;\n  this.connectTimeout=builder.connectTimeout;\n  this.readTimeout=builder.readTimeout;\n  this.writeTimeout=builder.writeTimeout;\n  this.pingInterval=builder.pingInterval;\n  if (interceptors.contains(null)) {\n    throw new IllegalStateException(\"Null interceptor: \" + interceptors);\n  }\n  if (networkInterceptors.contains(null)) {\n    throw new IllegalStateException(\"Null network interceptor: \" + networkInterceptors);\n  }\n}\n"}
{"INPUT": "private static String[] readSequenceFromPageObjects(String sequenceStatement,PageSpecHandler pageSpecHandler){\n// bug_start\n  String[] objectPatterns=sequenceStatement.split(\",\");\n  ArrayList<String> matchingObjects=new ArrayList<String>();\n  List<String> allObjectNames=pageSpecHandler.getSortedObjectNames();\n  for (  String objectPattern : objectPatterns) {\n    Pattern regex=GalenUtils.convertObjectNameRegex(objectPattern);\n    for (    String objectName : allObjectNames) {\n      if (regex.matcher(objectName).matches()) {\n        matchingObjects.add(objectName);\n      }\n    }\n  }\n// bug_end\n  Collections.sort(matchingObjects,new AlphanumericComparator());\n  return matchingObjects.toArray(new String[]{});\n}\n"}
{"INPUT": "// bug_start\npublic void loadSystems(String packageName,Reflections reflections,NetworkMode netMode){\n// bug_end\n  Set<Class<?>> systems=reflections.getTypesAnnotatedWith(RegisterSystem.class);\n  for (  Class<?> system : systems) {\n    if (!ComponentSystem.class.isAssignableFrom(system)) {\n      logger.error(\"Cannot load {}, must be a subclass of ComponentSystem\",system.getSimpleName());\n      continue;\n    }\n    RegisterSystem registerInfo=system.getAnnotation(RegisterSystem.class);\n    if (registerInfo.value().isValidFor(netMode,false)) {\n// bug_start\n      String id=packageName + \":\" + system.getSimpleName();\n// bug_end\n      logger.debug(\"Registering system {}\",id);\n      try {\n        ComponentSystem newSystem=(ComponentSystem)system.newInstance();\n        InjectionHelper.share(newSystem);\n        register(newSystem,id);\n        logger.debug(\"Loaded system {}\",id);\n      }\n catch (      InstantiationException|IllegalAccessException e) {\n        logger.error(\"Failed to load system {}\",id,e);\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override public void validate(KerberosCredentials credentials,WebContext context){\n  logger.trace(\"Try to validate Kerberos Token:\" + credentials.getKerberosTicketAsString());\n  KerberosTicketValidation ticketValidation=this.ticketValidator.validateTicket(credentials.getKerberosTicket());\n  logger.debug(\"Kerberos Token validated\");\n  String subject=ticketValidation.username();\n  logger.debug(\"Succesfully validated \" + subject);\n// bug_start\n  KerberosProfile profile=new KerberosProfile();\n// bug_end\n  profile.setId(subject);\n// bug_start\n  profile.gssContext=ticketValidation.getGssContext();\n// bug_end\n  credentials.setUserProfile(profile);\n}\n"}
{"INPUT": "@Override public void runTestProcedures(){\n  final GeoPoint geoPoint=new GeoPoint(40.886788,-73.959232);\n// bug_start\n  while (mMapView.getZoomLevel() < mMapView.getMaxZoomLevel()) {\n// bug_end\n    getActivity().runOnUiThread(new Runnable(){\n      @Override public void run(){\n        mMapView.getController().animateTo(geoPoint);\n        mMapView.getController().zoomIn();\n      }\n    }\n);\n    try {\n      Thread.sleep(1000);\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n  final GeoPoint geoPoint2=new GeoPoint(40.796788,-73.949232);\n// bug_start\n  while (mMapView.getZoomLevel() < mMapView.getMaxZoomLevel()) {\n// bug_end\n    getActivity().runOnUiThread(new Runnable(){\n      @Override public void run(){\n        mMapView.getController().animateTo(geoPoint2);\n        mMapView.getController().zoomIn();\n      }\n    }\n);\n    try {\n      Thread.sleep(1000);\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\nstatic ActivityScenario<JumpToPluginActivity> launch(Intent pluginIntent){\n// bug_end\n  Intent intent=new Intent(ApplicationProvider.getApplicationContext(),JumpToPluginActivity.class);\n// bug_start\n// bug_end\n  intent.putExtra(Constant.KEY_ACTIVITY_CLASSNAME,pluginIntent.getComponent().getClassName());\n  intent.putExtra(Constant.KEY_EXTRAS,pluginIntent.getExtras());\n  return ActivityScenario.launch(intent);\n}\n"}
{"INPUT": "@Override public void onClick(DialogInterface dialog,int which){\n  if (which == 0) {\n    settings.setPointToNavigate(lat,lon,true,name);\n  }\n else   if (which == 2) {\n    int sz=targetPointsHelper.getIntermediatePoints().size();\n    LatLon pt=targetPointsHelper.getPointToNavigate();\n// bug_start\n    settings.insertIntermediatePoint(pt.getLatitude(),pt.getLongitude(),settings.getPointNavigateDescription(),sz,true);\n    settings.setPointToNavigate(lat,lon,true,name);\n// bug_end\n  }\n else {\n    settings.insertIntermediatePoint(lat,lon,name,0,true);\n  }\n  targetPointsHelper.updatePointsFromSettings();\n  MapActivity.launchMapActivityMoveToTop(act);\n}\n"}
{"INPUT": "@Override public void openTask() throws Exception {\n  final Configuration stubConfig=this.config.getStubParameters();\n  RegularPactTask.openUserCode(this.combiner,stubConfig);\n  this.memManager=this.parent.getEnvironment().getMemoryManager();\n// bug_start\n  final long availableMemory=this.config.getMemoryDriver();\n// bug_end\n  final TypeSerializerFactory<T> serializerFactory=this.config.getInputSerializer(0,this.userCodeClassLoader);\n  final TypeComparatorFactory<T> comparatorFactory=this.config.getDriverComparator(0,this.userCodeClassLoader);\n  this.serializer=serializerFactory.getSerializer();\n  this.comparator=comparatorFactory.createComparator();\n// bug_start\n  final List<MemorySegment> memory=this.memManager.allocatePages(this.parent,availableMemory);\n// bug_end\n  if (this.comparator.supportsSerializationWithKeyNormalization() && this.serializer.getLength() > 0 && this.serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING) {\n    this.sorter=new FixedLengthRecordSorter<T>(this.serializer,this.comparator,memory);\n  }\n else {\n    this.sorter=new NormalizedKeySorter<T>(this.serializer,this.comparator.duplicate(),memory);\n  }\n}\n"}
{"INPUT": "public Object replace(Object original,Object target,SessionImplementor session,Object owner,Map copyCache) throws HibernateException {\n  if (original == null) {\n    return null;\n  }\n  Object cached=copyCache.get(original);\n  if (cached != null) {\n    return cached;\n  }\n else {\n    if (original == target) {\n      return target;\n    }\n    if (session.getContextEntityIdentifier(original) == null && ForeignKeys.isTransient(associatedEntityName,original,Boolean.FALSE,session)) {\n// bug_start\n      final Object copy=session.getFactory().getEntityPersister(associatedEntityName).instantiate(null,session);\n// bug_end\n      copyCache.put(original,copy);\n      return copy;\n    }\n else {\n      Object id=getIdentifier(original,session);\n      if (id == null) {\n        throw new AssertionFailure(\"non-transient entity has a null id\");\n      }\n      id=getIdentifierOrUniqueKeyType(session.getFactory()).replace(id,null,session,owner,copyCache);\n      return resolve(id,session,owner);\n    }\n  }\n}\n"}
{"INPUT": "public InetAddress resolveInetAddress(String host,String defaultValue1,String defaultValue2) throws UnknownHostException, IOException {\n  if (host == null) {\n    host=defaultValue1;\n  }\n  if (host == null) {\n    host=defaultValue2;\n  }\n  if (host == null) {\n    for (    CustomNameResolver customNameResolver : customNameResolvers) {\n      InetAddress inetAddress=customNameResolver.resolveDefault();\n      if (inetAddress != null) {\n        return inetAddress;\n      }\n    }\n    return null;\n  }\n  String origHost=host;\n  if ((host.startsWith(\"#\") && host.endsWith(\"#\")) || (host.startsWith(\"_\") && host.endsWith(\"_\"))) {\n    host=host.substring(1,host.length() - 1);\n    for (    CustomNameResolver customNameResolver : customNameResolvers) {\n      InetAddress inetAddress=customNameResolver.resolveIfPossible(host);\n      if (inetAddress != null) {\n        return inetAddress;\n      }\n    }\n    if (host.equals(\"local\")) {\n      return NetworkUtils.getLocalAddress();\n    }\n else     if (host.startsWith(\"non_loopback\")) {\n      if (host.toLowerCase().endsWith(\":ipv4\")) {\n        return NetworkUtils.getFirstNonLoopbackAddress(NetworkUtils.StackType.IPv4);\n      }\n else       if (host.toLowerCase().endsWith(\":ipv6\")) {\n        return NetworkUtils.getFirstNonLoopbackAddress(NetworkUtils.StackType.IPv6);\n      }\n else {\n        return NetworkUtils.getFirstNonLoopbackAddress(NetworkUtils.getIpStackType());\n      }\n    }\n else {\n      NetworkUtils.StackType stackType=NetworkUtils.getIpStackType();\n      if (host.toLowerCase().endsWith(\":ipv4\")) {\n        stackType=NetworkUtils.StackType.IPv4;\n        host=host.substring(0,host.length() - 5);\n      }\n else       if (host.toLowerCase().endsWith(\":ipv6\")) {\n        stackType=NetworkUtils.StackType.IPv6;\n        host=host.substring(0,host.length() - 5);\n      }\n      Collection<NetworkInterface> allInterfs=NetworkUtils.getAllAvailableInterfaces();\n      for (      NetworkInterface ni : allInterfs) {\n// bug_start\n        if (!ni.isUp() || ni.isLoopback()) {\n// bug_end\n          continue;\n        }\n        if (host.equals(ni.getName()) || host.equals(ni.getDisplayName())) {\n// bug_start\n          return NetworkUtils.getFirstNonLoopbackAddress(ni,stackType);\n// bug_end\n        }\n      }\n    }\n    throw new IOException(\"Failed to find network interface for [\" + origHost + \"]\");\n  }\n  return InetAddress.getByName(host);\n}\n"}
{"INPUT": "@Override public ShapeValues getValues(LeafReaderContext readerContext) throws IOException {\n  final ShapeValues targetFuncValues=targetValueSource.getValues(readerContext);\n// bug_start\n  final SolrCache<PerSegCacheKey,Shape> cache=SolrRequestInfo.getRequestInfo().getReq().getSearcher().getCache(CACHE_KEY_PREFIX + fieldName);\n// bug_end\n  if (cache == null) {\n    return targetFuncValues;\n  }\n  return new ShapeValues(){\n    int docId=-1;\n    @Override public Shape value() throws IOException {\n      IndexReader.CacheHelper cacheHelper=readerContext.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        throw new IllegalStateException(\"Leaf \" + readerContext.reader() + \" is not suited for caching\");\n      }\n      PerSegCacheKey key=new PerSegCacheKey(cacheHelper.getKey(),docId);\n      Shape shape=cache.computeIfAbsent(key,null);\n      if (shape != null) {\n        if (shape instanceof JtsGeometry) {\n          ((JtsGeometry)shape).index();\n        }\n      }\n      return shape;\n    }\n    @Override public boolean advanceExact(    int doc) throws IOException {\n      this.docId=doc;\n      return targetFuncValues.advanceExact(doc);\n    }\n  }\n;\n}\n"}
{"INPUT": "// bug_start\n@AwaitsFix(bugUrl=\"https://github.com/elastic/elasticsearch/issues/37165\") public void testUnfollowInjectedBeforeShrink() throws Exception {\n// bug_end\n  final String indexName=\"shrink-test\";\n  final String shrunkenIndexName=\"shrink-\" + indexName;\n  final String policyName=\"shrink-test-policy\";\n  if (\"leader\".equals(targetCluster)) {\n    Settings indexSettings=Settings.builder().put(\"index.soft_deletes.enabled\",true).put(\"index.number_of_shards\",3).put(\"index.number_of_replicas\",0).put(\"index.lifecycle.name\",policyName).build();\n    createIndex(indexName,indexSettings,\"\",\"\");\n    ensureGreen(indexName);\n  }\n else   if (\"follow\".equals(targetCluster)) {\n    putShrinkOnlyPolicy(client(),policyName);\n    followIndex(indexName,indexName);\n    assertBusy(null);\n    assertBusy(null);\n    try (RestClient leaderClient=buildLeaderClient()){\n      updateIndexSettings(leaderClient,indexName,Settings.builder().put(\"index.lifecycle.indexing_complete\",true).build());\n    }\n     assertBusy(null);\n    assertBusy(null);\n    assertBusy(null);\n  }\n}\n"}
{"INPUT": "private PendingIntent getMediaButtonReceiverPendingIntent(ComponentName componentName){\n  Intent mediaButtonIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);\n  mediaButtonIntent.setComponent(componentName);\n// bug_start\n  mediaButtonIntent.putExtra(RECEIVER_EXTRA_CLASS,mediaServiceClass);\n  return PendingIntent.getBroadcast(context,0,mediaButtonIntent,0);\n// bug_end\n}\n"}
{"INPUT": "public static void handleUnexpectedException(ChannelHandlerContext ctx,Throwable cause){\n  if (cause instanceof DecoderException) {\n    Throwable t=cause.getCause();\n    if (t instanceof UnsupportedCommandException) {\n      log.debug(\"Input command is invalid. Closing socket. Reason {}. Address {}\",cause.getMessage(),ctx.channel().remoteAddress());\n    }\n else     if (t instanceof SSLException) {\n      log.debug(\"Unsecured connection attempt or not supported protocol. Channel : {}. Reason : {}\",ctx.channel().remoteAddress(),cause.getMessage());\n    }\n else {\n// bug_start\n      log.error(\"DecoderException.\",cause);\n// bug_end\n    }\n    ctx.close();\n  }\n else   if (cause instanceof SSLException) {\n    log.debug(\"SSL exception. {}. {}\",cause.getMessage(),ctx.channel().remoteAddress());\n    ctx.close();\n  }\n else   if (cause instanceof IOException) {\n    log.trace(\"Blynk server IOException.\",cause);\n  }\n else {\n    String message=cause == null ? \"\" : cause.getMessage();\n    if (message != null && message.contains(\"OutOfDirectMemoryError\")) {\n      log.error(\"OutOfDirectMemoryError!!!\");\n    }\n else {\n      log.error(\"Unexpected error! Handler class : {}. Name : {}. Reason : {}. Channel : {}.\",ctx.handler().getClass(),ctx.name(),message,ctx.channel());\n      if (message == null) {\n        log.error(\"Error.\",cause);\n      }\n else {\n        log.debug(cause);\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Test public void testUnloadForever() throws Exception {\n  File solrHomeDirectory=createTempDir(\"solr-home\").toFile();\n  copySolrHomeToTemp(solrHomeDirectory,\"corex\");\n  File corex=new File(solrHomeDirectory,\"corex\");\n  FileUtils.write(new File(corex,\"core.properties\"),\"\",StandardCharsets.UTF_8);\n  JettySolrRunner runner=new JettySolrRunner(solrHomeDirectory.getAbsolutePath(),buildJettyConfig(\"/solr\"));\n  runner.start();\n  try (HttpSolrClient client=getHttpSolrClient(runner.getBaseUrl() + \"/corex\",DEFAULT_CONNECTION_TIMEOUT,DEFAULT_CONNECTION_TIMEOUT)){\n    SolrInputDocument doc=new SolrInputDocument();\n    doc.addField(\"id\",\"123\");\n    client.add(doc);\n    client.commit();\n  }\n   try (HttpSolrClient client=getHttpSolrClient(runner.getBaseUrl() + \"/corex\",DEFAULT_CONNECTION_TIMEOUT,DEFAULT_CONNECTION_TIMEOUT)){\n    QueryResponse result=client.query(new SolrQuery(\"id:*\"));\n    assertEquals(1,result.getResults().getNumFound());\n  }\n   try (HttpSolrClient client=getHttpSolrClient(runner.getBaseUrl().toString(),DEFAULT_CONNECTION_TIMEOUT,DEFAULT_CONNECTION_TIMEOUT)){\n    CoreAdminRequest.Unload req=new CoreAdminRequest.Unload(false);\n    req.setDeleteInstanceDir(false);\n    req.setCoreName(\"corex\");\n    req.process(client);\n  }\n   HttpSolrClient.RemoteSolrException rse=expectThrows(HttpSolrClient.RemoteSolrException.class,null);\n// bug_start\n  assertTrue(rse.getMessage().contains(\"Can not find: /solr/corex/select\"));\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Override public void methodAchieved(DependencyAgent agent,MethodDependency method,CallLocation location){\n// bug_end\n  MethodDependency addMethod=agent.linkMethod(new MethodReference(PlatformQueue.class,\"wrap\",Object.class,PlatformObject.class),null);\n  addMethod.getVariable(1).connect(method.getResult());\n}\n"}
{"INPUT": "private void parseXmlSource(InputStream inputStream,ContentHandler handler){\n  InputSource inputSource=new InputSource(inputStream);\n  try {\n    SAXParserFactory saxFactory=SAXParserFactory.newInstance();\n    saxFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\",true);\n    saxFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\",false);\n    saxFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\",false);\n    SAXParser saxParser=saxFactory.newSAXParser();\n    XMLReader xmlReader=saxParser.getXMLReader();\n    xmlReader.setContentHandler(handler);\n    xmlReader.parse(inputSource);\n    inputStream.close();\n  }\n// bug_start\n catch (  Exception e) {\n// bug_end\n    throw new ExcelAnalysisException(e);\n  }\n finally {\n    if (inputStream != null) {\n      try {\n        inputStream.close();\n      }\n catch (      IOException e) {\n        throw new ExcelAnalysisException(\"Can not close 'inputStream'!\");\n      }\n    }\n  }\n}\n"}
{"INPUT": "private void manageFolderFeedback(CellLayout targetLayout,int[] targetCell,float distance,DragObject dragObject){\n// bug_start\n  if (distance > mMaxDistanceForFolderCreation)   return;\n// bug_end\n  final View dragOverView=mDragTargetLayout.getChildAt(mTargetCell[0],mTargetCell[1]);\n  ItemInfo info=dragObject.dragInfo;\n  boolean userFolderPending=willCreateUserFolder(info,dragOverView,false);\n  if (mDragMode == DRAG_MODE_NONE && userFolderPending && !mFolderCreationAlarm.alarmPending()) {\n    FolderCreationAlarmListener listener=new FolderCreationAlarmListener(targetLayout,targetCell[0],targetCell[1]);\n    if (!dragObject.accessibleDrag) {\n      mFolderCreationAlarm.setOnAlarmListener(listener);\n      mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);\n    }\n else {\n      listener.onAlarm(mFolderCreationAlarm);\n    }\n    if (dragObject.stateAnnouncer != null) {\n      dragObject.stateAnnouncer.announce(WorkspaceAccessibilityHelper.getDescriptionForDropOver(dragOverView,getContext()));\n    }\n    return;\n  }\n  boolean willAddToFolder=willAddToExistingUserFolder(info,dragOverView);\n  if (willAddToFolder && mDragMode == DRAG_MODE_NONE) {\n    mDragOverFolderIcon=((FolderIcon)dragOverView);\n    mDragOverFolderIcon.onDragEnter(info);\n    if (targetLayout != null) {\n      targetLayout.clearDragOutlines();\n    }\n    setDragMode(DRAG_MODE_ADD_TO_FOLDER);\n    if (dragObject.stateAnnouncer != null) {\n      dragObject.stateAnnouncer.announce(WorkspaceAccessibilityHelper.getDescriptionForDropOver(dragOverView,getContext()));\n    }\n    return;\n  }\n  if (mDragMode == DRAG_MODE_ADD_TO_FOLDER && !willAddToFolder) {\n    setDragMode(DRAG_MODE_NONE);\n  }\n  if (mDragMode == DRAG_MODE_CREATE_FOLDER && !userFolderPending) {\n    setDragMode(DRAG_MODE_NONE);\n  }\n}\n"}
{"INPUT": "Response getResponse(Request request,boolean forWebSocket) throws IOException {\n  RequestBody body=request.body();\n  if (body != null) {\n    Request.Builder requestBuilder=request.newBuilder();\n    MediaType contentType=body.contentType();\n    if (contentType != null) {\n      requestBuilder.header(\"Content-Type\",contentType.toString());\n    }\n    long contentLength=body.contentLength();\n    if (contentLength != -1) {\n      requestBuilder.header(\"Content-Length\",Long.toString(contentLength));\n      requestBuilder.removeHeader(\"Transfer-Encoding\");\n    }\n else {\n      requestBuilder.header(\"Transfer-Encoding\",\"chunked\");\n      requestBuilder.removeHeader(\"Content-Length\");\n    }\n    request=requestBuilder.build();\n  }\n  engine=new HttpEngine(client,request,false,false,forWebSocket,null,null,null);\n  int followUpCount=0;\n  while (true) {\n    if (canceled) {\n      engine.releaseStreamAllocation();\n      throw new IOException(\"Canceled\");\n    }\n    boolean releaseConnection=true;\n    try {\n      engine.sendRequest();\n      engine.readResponse();\n      releaseConnection=false;\n    }\n catch (    RequestException e) {\n      throw e.getCause();\n    }\ncatch (    RouteException e) {\n// bug_start\n      HttpEngine retryEngine=engine.recover(e);\n// bug_end\n      if (retryEngine != null) {\n        releaseConnection=false;\n        engine=retryEngine;\n        continue;\n      }\n      throw e.getLastConnectException();\n    }\ncatch (    IOException e) {\n      HttpEngine retryEngine=engine.recover(e,null);\n      if (retryEngine != null) {\n        releaseConnection=false;\n        engine=retryEngine;\n        continue;\n      }\n      throw e;\n    }\n finally {\n      if (releaseConnection) {\n        StreamAllocation streamAllocation=engine.close();\n        streamAllocation.release();\n      }\n    }\n    Response response=engine.getResponse();\n    Request followUp=engine.followUpRequest();\n    if (followUp == null) {\n      if (!forWebSocket) {\n        engine.releaseStreamAllocation();\n      }\n      return response;\n    }\n    StreamAllocation streamAllocation=engine.close();\n    if (++followUpCount > MAX_FOLLOW_UPS) {\n      streamAllocation.release();\n      throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n    }\n    if (!engine.sameConnection(followUp.url())) {\n      streamAllocation.release();\n      streamAllocation=null;\n    }\n    request=followUp;\n    engine=new HttpEngine(client,request,false,false,forWebSocket,streamAllocation,null,response);\n  }\n}\n"}
{"INPUT": "@Override public Object getSystemService(String name){\n  if (FLOW_SERVICE.equals(name)) {\n    if (flow == null) {\n// bug_start\n      flow=InternalLifecycleIntegration.find(activity).flow;\n// bug_end\n    }\n    return flow;\n  }\n else   if (CONTEXT_MANAGER_SERVICE.equals(name)) {\n    if (keyManager == null) {\n// bug_start\n      keyManager=InternalLifecycleIntegration.find(activity).keyManager;\n// bug_end\n    }\n    return keyManager;\n  }\n  return super.getSystemService(name);\n}\n"}
{"INPUT": "@Test public void contextLoads(){\n  Environment environment=new TestRestTemplate().getForObject(\"http://localhost:\" + this.port + \"/foo/development/\",Environment.class);\n  assertThat(environment.getPropertySources().isEmpty()).isFalse();\n  assertThat(environment.getPropertySources().get(0).getName()).isEqualTo(\"overrides\");\n// bug_start\n  assertThat(environment.getPropertySources().get(0).getSource().toString()).isEqualTo(\"{spring.cloud.config.enabled=true}\");\n// bug_end\n}\n"}
{"INPUT": "@Nullable public static RegistryAuthenticator forOther(String serverUrl,String repository) throws RegistryAuthenticationFailedException, IOException, RegistryException {\n  try {\n// bug_start\n    RegistryClient registryClient=new RegistryClient(null,serverUrl,repository);\n    return registryClient.getRegistryAuthenticator();\n// bug_end\n  }\n catch (  MalformedURLException ex) {\n    throw new RegistryAuthenticationFailedException(ex);\n  }\n}\n"}
{"INPUT": "public void testToMethods() throws Exception {\n  Number n=7L;\n  assertEquals(DefaultGroovyMethods.toInteger(\"1\"),new Integer(1));\n  assertEquals(DefaultGroovyMethods.toInteger(n),new Integer(7));\n  assertEquals(DefaultGroovyMethods.toLong(\"1\"),new Long(1));\n  assertEquals(DefaultGroovyMethods.toLong(n),new Long(7));\n  assertEquals(DefaultGroovyMethods.toFloat(\"1\"),new Float(1));\n  assertEquals(DefaultGroovyMethods.toFloat(n),new Float(7));\n  assertEquals(DefaultGroovyMethods.toDouble(\"1\"),new Double(1));\n  assertEquals(DefaultGroovyMethods.toDouble(n),new Double(7));\n  assertEquals(DefaultGroovyMethods.toBigInteger(\"1\"),new BigInteger(\"1\"));\n  assertEquals(DefaultGroovyMethods.toBigInteger(n),new BigInteger(\"7\"));\n  assertEquals(DefaultGroovyMethods.toBigDecimal(\"1\"),new BigDecimal(\"1\"));\n  assertEquals(DefaultGroovyMethods.toBigDecimal(n),new BigDecimal(\"7\"));\n  assertEquals(new BigDecimal(\"0.1\"),DefaultGroovyMethods.toBigDecimal(0.1));\n  assertEquals(DefaultGroovyMethods.toURL(\"http://example.org/\"),new URL(\"http://example.org/\"));\n  assertEquals(DefaultGroovyMethods.toURI(\"http://example.org/\"),new URI(\"http://example.org/\"));\n  assertEquals(DefaultGroovyMethods.toBoolean(\"True\"),Boolean.TRUE);\n  assertEquals(DefaultGroovyMethods.toBoolean(\"Y\"),Boolean.TRUE);\n  assertEquals(DefaultGroovyMethods.toBoolean(\" y \"),Boolean.TRUE);\n  assertEquals(DefaultGroovyMethods.toBoolean(\"1\"),Boolean.TRUE);\n  assertEquals(DefaultGroovyMethods.toBoolean(\"false\"),Boolean.FALSE);\n  assertEquals(DefaultGroovyMethods.toBoolean(\"n\"),Boolean.FALSE);\n  assertEquals(DefaultGroovyMethods.toBoolean(\"0\"),Boolean.FALSE);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "private boolean testReloadSuccess(SolrQueryRequest req,SolrQueryResponse rsp,ContentStream stream){\n  File home=null;\n  try {\n    home=new File(FileUtils.getTempDirectory(),\"SOLR_5459\");\n// bug_start\n    FileUtils.writeStringToFile(new File(home,\"solr.xml\"),\"<solr></solr>\");\n// bug_end\n    File coll=new File(home,\"SOLR_5459\");\n    SolrCore core=req.getCore();\n    CoreDescriptor desc=core.getCoreDescriptor();\n    CoreContainer coreContainer=desc.getCoreContainer();\n    if (coreContainer.isZooKeeperAware()) {\n      try {\n        String confPath=((ZkSolrResourceLoader)core.getResourceLoader()).getCollectionZkPath();\n        ZkController.downloadConfigDir(coreContainer.getZkController().getZkClient(),confPath,new File(coll,\"conf\"));\n      }\n catch (      Exception ex) {\n        log.error(\"Error when attempting to download conf from ZooKeeper: \" + ex.getMessage());\n        rsp.setException(new SolrException(ErrorCode.BAD_REQUEST,\"Error when attempting to download conf from ZooKeeper\" + ex.getMessage()));\n        return false;\n      }\n    }\n else {\n      FileUtils.copyDirectory(new File(desc.getInstanceDir(),\"conf\"),new File(coll,\"conf\"));\n    }\n// bug_start\n    FileUtils.writeStringToFile(new File(coll,\"core.properties\"),\"name=SOLR_5459\");\n// bug_end\n    FileUtils.copyInputStreamToFile(stream.getStream(),new File(new File(coll,\"conf\"),req.getParams().get(\"file\",null)));\n    return tryReloading(rsp,home);\n  }\n catch (  IOException ex) {\n    log.warn(\"Caught IO exception when trying to verify configs. \" + ex.getMessage());\n    rsp.setException(new SolrException(ErrorCode.SERVER_ERROR,\"Caught IO exception when trying to verify configs. \" + ex.getMessage()));\n    return false;\n  }\n finally {\n    if (home != null) {\n      try {\n        FileUtils.deleteDirectory(home);\n      }\n catch (      IOException e) {\n        log.warn(\"Caught IO exception trying to delete temporary directory \" + home + e.getMessage());\n        return true;\n      }\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\n@Nullable public Typeface getFont(@StyleableRes int index,int style,@Nullable ResourcesCompat.FontCallback fontCallback){\n// bug_end\n  final int resourceId=mWrapped.getResourceId(index,0);\n  if (resourceId == 0) {\n    return null;\n  }\n  if (mTypedValue == null) {\n    mTypedValue=new TypedValue();\n  }\n// bug_start\n  return ResourcesCompat.getFont(mContext,resourceId,mTypedValue,style,fontCallback);\n// bug_end\n}\n"}
{"INPUT": "Expression transformConstructorCall(final ConstructorCallExpression expr){\n  ConstructorNode node=(ConstructorNode)expr.getNodeMetaData(DIRECT_METHOD_CALL_TARGET);\n  if (node == null)   return expr;\n  if (node.getParameters().length == 1 && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node.getParameters()[0].getType(),ClassHelper.MAP_TYPE)) {\n    Expression arguments=expr.getArguments();\n    if (arguments instanceof TupleExpression) {\n      TupleExpression tupleExpression=(TupleExpression)arguments;\n      List<Expression> expressions=tupleExpression.getExpressions();\n      if (expressions.size() == 1) {\n        Expression expression=expressions.get(0);\n        if (expression instanceof MapExpression) {\n          MapExpression map=(MapExpression)expression;\n          ClassNode declaringClass=node.getDeclaringClass();\n          for (          ConstructorNode constructorNode : declaringClass.getDeclaredConstructors()) {\n            if (constructorNode == node) {\n              return staticCompilationTransformer.superTransform(expr);\n            }\n          }\n          VariableExpression vexp=new VariableExpression(\"obj\" + System.currentTimeMillis(),declaringClass);\n          ConstructorNode cn=new ConstructorNode(Opcodes.ACC_PUBLIC,Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,EmptyStatement.INSTANCE);\n          cn.setDeclaringClass(declaringClass);\n          ConstructorCallExpression call=new ConstructorCallExpression(declaringClass,new ArgumentListExpression());\n          call.putNodeMetaData(DIRECT_METHOD_CALL_TARGET,cn);\n          DeclarationExpression declaration=new DeclarationExpression(vexp,Token.newSymbol(\"=\",expr.getLineNumber(),expr.getColumnNumber()),call);\n          BlockStatement stmt=new BlockStatement();\n          stmt.addStatement(new ExpressionStatement(declaration));\n          for (          MapEntryExpression entryExpression : map.getMapEntryExpressions()) {\n            int line=entryExpression.getLineNumber();\n            int col=entryExpression.getColumnNumber();\n            Expression keyExpression=staticCompilationTransformer.transform(entryExpression.getKeyExpression());\n            Expression valueExpression=staticCompilationTransformer.transform(entryExpression.getValueExpression());\n            BinaryExpression bexp=new BinaryExpression(new PropertyExpression(vexp,keyExpression),Token.newSymbol(\"=\",line,col),valueExpression);\n// bug_start\n// bug_end\n            stmt.addStatement(new ExpressionStatement(bexp));\n          }\n          stmt.addStatement(new ReturnStatement(vexp));\n          ClosureExpression cl=new ClosureExpression(Parameter.EMPTY_ARRAY,stmt);\n// bug_start\n// bug_end\n          MethodCallExpression result=new MethodCallExpression(cl,\"call\",ArgumentListExpression.EMPTY_ARGUMENTS);\n          result.setMethodTarget(StaticTypeCheckingVisitor.CLOSURE_CALL_NO_ARG);\n          VariableScopeVisitor visitor=new VariableScopeVisitor(staticCompilationTransformer.getSourceUnit());\n          visitor.prepareVisit(staticCompilationTransformer.getClassNode());\n          visitor.visitClosureExpression(cl);\n          return result;\n        }\n      }\n    }\n  }\n  return staticCompilationTransformer.superTransform(expr);\n}\n"}
{"INPUT": "// bug_start\nprivate CachedConstructor findDefaultConstructor(CachedClass mixinClass){\n// bug_end\n  for (  CachedConstructor constr : mixinClass.getConstructors()) {\n    if (!Modifier.isPublic(constr.getModifiers()))     continue;\n    CachedClass[] classes=constr.getParameterTypes();\n    if (classes.length == 0)     return constr;\n  }\n  throw new GroovyRuntimeException(\"No default constructor for class \" + mixinClass.getName() + \"! Can't be mixed in.\");\n}\n"}
{"INPUT": "@Test public void testDisplayMessages() throws IOException {\n  List<ViolationMessage> messages=new ArrayList<>();\n// bug_start\n  messages.add(new ViolationMessage(Rules.LOWER_CAMEL_CASE,inputFile.getCanonicalPath(),10,12,Severity.WARNING,WARNING_MSG));\n  messages.add(new ViolationMessage(Rules.UPPER_CAMEL_CASE,inputFile.getCanonicalPath(),11,14,Severity.ERROR,ERROR_MSG));\n// bug_end\n  Collections.sort(messages);\n  formatter.displayViolationMessages(messages,inputFile);\n  assertEquals(expectedOutput(messages),outContent.toString(Charset.defaultCharset().name()));\n}\n"}
{"INPUT": "public static Map<String,Object> addSerializerToConfig(Map<String,Object> configs,Serializer<?> keySerializer,Serializer<?> valueSerializer){\n// bug_start\n  Map<String,Object> newConfigs=new HashMap<>();\n  newConfigs.putAll(configs);\n// bug_end\n  if (keySerializer != null)   newConfigs.put(KEY_SERIALIZER_CLASS_CONFIG,keySerializer.getClass());\n  if (valueSerializer != null)   newConfigs.put(VALUE_SERIALIZER_CLASS_CONFIG,valueSerializer.getClass());\n  return newConfigs;\n}\n"}
{"INPUT": "public void testDeleteDataStreamDuringSnapshot() throws Exception {\n  Client client=client();\n  logger.info(\"-->  creating repository\");\n  assertAcked(client.admin().cluster().preparePutRepository(\"test-repo\").setType(\"mock\").setSettings(Settings.builder().put(\"location\",randomRepoPath()).put(\"compress\",randomBoolean()).put(\"chunk_size\",randomIntBetween(100,1000),ByteSizeUnit.BYTES).put(\"block_on_data\",true)));\n// bug_start\n  String dataStream=\"test-ds\";\n// bug_end\n  DataStreamIT.createIndexTemplate(\"dst\",\"@timestamp\",dataStream);\n  logger.info(\"--> indexing some data\");\n  for (int i=0; i < 100; i++) {\n    client.prepareIndex(dataStream).setOpType(DocWriteRequest.OpType.CREATE).setId(Integer.toString(i)).setSource(Collections.singletonMap(\"k\",\"v\")).execute().actionGet();\n  }\n  refresh();\n  assertThat(client.prepareSearch(dataStream).setSize(0).get().getHits().getTotalHits().value,equalTo(100L));\n  logger.info(\"--> snapshot\");\n  ActionFuture<CreateSnapshotResponse> future=client.admin().cluster().prepareCreateSnapshot(\"test-repo\",\"test-snap\").setIndices(dataStream).setWaitForCompletion(true).setPartial(false).execute();\n  logger.info(\"--> wait for block to kick in\");\n  waitForBlockOnAnyDataNode(\"test-repo\",TimeValue.timeValueMinutes(1));\n  try {\n    logger.info(\"--> delete index while non-partial snapshot is running\");\n    client.admin().indices().deleteDataStream(new DeleteDataStreamAction.Request(dataStream)).actionGet();\n    fail(\"Expected deleting index to fail during snapshot\");\n  }\n catch (  SnapshotInProgressException e) {\n// bug_start\n    assertThat(e.getMessage(),containsString(\"Cannot delete data streams that are being snapshotted: [test-ds\"));\n// bug_end\n  }\n finally {\n    logger.info(\"--> unblock all data nodes\");\n    unblockAllDataNodes(\"test-repo\");\n  }\n  logger.info(\"--> waiting for snapshot to finish\");\n  CreateSnapshotResponse createSnapshotResponse=future.get();\n  logger.info(\"Snapshot successfully completed\");\n  SnapshotInfo snapshotInfo=createSnapshotResponse.getSnapshotInfo();\n  assertThat(snapshotInfo.state(),equalTo((SnapshotState.SUCCESS)));\n  assertThat(snapshotInfo.dataStreams(),contains(dataStream));\n  assertThat(snapshotInfo.indices(),contains(DataStream.getDefaultBackingIndexName(dataStream,1)));\n}\n"}
{"INPUT": "public void fireNodeDataChanged(GTreeNode changedNode){\n  if (!eventsEnabled) {\n    return;\n  }\n  SystemUtilities.assertThisIsTheSwingThread(\"GTreeModel.fireNodeDataChanged() must be \" + \"called from the AWT thread\");\n// bug_start\n  TreeModelEvent event=new TreeModelEvent(this,(TreePath)null);\n// bug_end\n  for (  TreeModelListener listener : listeners) {\n    listener.treeNodesChanged(event);\n  }\n}\n"}
{"INPUT": "@Override public boolean handle(AnnotationValues<EqualsAndHashCode> annotation,JCAnnotation ast,Node annotationNode){\n  EqualsAndHashCode ann=annotation.getInstance();\n  List<String> excludes=List.from(ann.exclude());\n  List<String> includes=List.from(ann.of());\n  Node typeNode=annotationNode.up();\n  checkForBogusFieldNames(typeNode,annotation);\n  Boolean callSuper=ann.callSuper();\n  if (!annotation.isExplicit(\"callSuper\"))   callSuper=null;\n  if (!annotation.isExplicit(\"exclude\"))   excludes=null;\n  if (!annotation.isExplicit(\"of\"))   includes=null;\n// bug_start\n// bug_end\n  return generateMethods(typeNode,annotationNode,excludes,includes,callSuper,true);\n}\n"}
{"INPUT": "@Test public void testReport() throws Exception {\n  MetricRegistry metricRegistry=new MetricRegistry();\n  metricRegistry.counter(\"test-counter\").inc(100);\n  Slf4jReporter slf4jReporter=Slf4jReporter.forRegistry(metricRegistry).shutdownExecutorOnStop(false).scheduleOn(executor).outputTo(logger).markWith(marker).prefixedWith(\"us-nw\").convertRatesTo(TimeUnit.SECONDS).convertDurationsTo(TimeUnit.MILLISECONDS).filter(MetricFilter.ALL).withLoggingLevel(Slf4jReporter.LoggingLevel.INFO).build();\n  slf4jReporter.report();\n// bug_start\n  verify(logger).info(marker,\"type={}, name={}, count={}\",\"COUNTER\",\"us-nw.test-counter\",100L);\n// bug_end\n}\n"}
{"INPUT": "@Test public void importFailWithExistingDiskStore(){\n  lsRule.startServerVM(1,locatorVM.getPort());\n// bug_start\n  gfshConnector.executeAndAssertThat(\"create disk-store --name=diskStore1 --dir=testStore\").statusIsSuccess();\n  locatorVM.waitUntilDiskStoreIsReadyOnExactlyThisManyServers(\"diskStore1\",1);\n// bug_end\n  gfshConnector.executeAndAssertThat(\"import cluster-configuration --zip-file-name=\" + clusterConfigZipPath).statusIsError().containsOutput(\"Can not configure servers that are already configured.\");\n}\n"}
{"INPUT": "// bug_start\n@AwaitsFix(bugUrl=\"https://github.com/elastic/elasticsearch/issues/41967\") public void testDiscoveryUsesNodesFromLastClusterState(){\n// bug_end\n  final Cluster cluster=new Cluster(randomIntBetween(3,5));\n  cluster.runRandomly();\n  cluster.stabilise();\n  final ClusterNode partitionedNode=cluster.getAnyNode();\n  if (randomBoolean()) {\n    logger.info(\"--> blackholing {}\",partitionedNode);\n    partitionedNode.blackhole();\n  }\n else {\n    logger.info(\"--> disconnecting {}\",partitionedNode);\n    partitionedNode.disconnect();\n  }\n  cluster.setEmptySeedHostsList();\n  cluster.stabilise();\n  partitionedNode.heal();\n  cluster.runRandomly(false);\n  cluster.stabilise();\n}\n"}
{"INPUT": "@SuppressWarnings({\"unchecked\"}) @Override protected GridConfiguration getConfiguration(String gridName) throws Exception {\n  GridConfiguration c=super.getConfiguration(gridName);\n// bug_start\n// bug_end\n  GridCacheConfiguration cc=defaultCacheConfiguration();\n  cc.setCacheMode(REPLICATED);\n// bug_start\n  cc.setTxSerializableEnabled(true);\n// bug_end\n  cc.setEvictionPolicy(null);\n  cc.setWriteSynchronizationMode(FULL_SYNC);\n  c.setCacheConfiguration(cc);\n  GridTcpDiscoverySpi spi=new GridTcpDiscoverySpi();\n  spi.setIpFinder(ipFinder);\n  c.setDiscoverySpi(spi);\n  if (CACHE_DEBUG)   resetLog4j(Level.DEBUG,LOG_TO_FILE,GridCacheProcessor.class.getPackage().getName());\n  return c;\n}\n"}
{"INPUT": "public OperationQuota getQuota(final UserGroupInformation ugi,final TableName table){\n  if (isQuotaEnabled() && !table.isSystemTable()) {\n    UserQuotaState userQuotaState=quotaCache.getUserQuotaState(ugi);\n    QuotaLimiter userLimiter=userQuotaState.getTableLimiter(table);\n    boolean useNoop=userLimiter.isBypass();\n    if (userQuotaState.hasBypassGlobals()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"get quota for ugi=\" + ugi + \" table=\"+ table+ \" userLimiter=\"+ userLimiter);\n      }\n      if (!useNoop) {\n// bug_start\n        return new DefaultOperationQuota(userLimiter);\n// bug_end\n      }\n    }\n else {\n      QuotaLimiter nsLimiter=quotaCache.getNamespaceLimiter(table.getNamespaceAsString());\n      QuotaLimiter tableLimiter=quotaCache.getTableLimiter(table);\n      useNoop&=tableLimiter.isBypass() && nsLimiter.isBypass();\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"get quota for ugi=\" + ugi + \" table=\"+ table+ \" userLimiter=\"+ userLimiter+ \" tableLimiter=\"+ tableLimiter+ \" nsLimiter=\"+ nsLimiter);\n      }\n      if (!useNoop) {\n// bug_start\n        return new DefaultOperationQuota(userLimiter,tableLimiter,nsLimiter);\n// bug_end\n      }\n    }\n  }\n  return NoopOperationQuota.get();\n}\n"}
{"INPUT": "protected void reset(){\n// bug_start\n  topicId=(int)ExecuteCommandResponseEncoder.topicIdNullValue();\n// bug_end\n  longKey=ExecuteCommandResponseEncoder.longKeyNullValue();\n  bytesKey.wrap(0,0);\n  eventWriter=null;\n  metadata=null;\n}\n"}
{"INPUT": "private Queue<ImageConfiguration> prepareStart(ServiceHub hub,QueryService queryService,RunService runService,Set<String> imageAliases) throws DockerAccessException, MojoExecutionException {\n  final Queue<ImageConfiguration> imagesWaitingToStart=new ArrayDeque<>();\n  for (  StartOrderResolver.Resolvable resolvable : runService.getImagesConfigsInOrder(queryService,getResolvedImages())) {\n    final ImageConfiguration imageConfig=(ImageConfiguration)resolvable;\n    RunImageConfiguration runConfig=imageConfig.getRunConfiguration();\n    RegistryService.RegistryConfig registryConfig=getRegistryConfig(pullRegistry);\n    ImagePullManager pullManager=getImagePullManager(determinePullPolicy(runConfig),autoPull);\n    hub.getRegistryService().pullImageWithPolicy(imageConfig.getName(),pullManager,registryConfig,queryService.hasImage(imageConfig.getName()));\n    NetworkConfig config=runConfig.getNetworkingConfig();\n    List<String> bindMounts=extractBindMounts(runConfig.getVolumeConfiguration());\n// bug_start\n    if (!bindMounts.isEmpty()) {\n      List<VolumeConfiguration> volumes=getVolumes();\n// bug_end\n      runService.createVolumesAsPerVolumeBinds(hub,bindMounts,volumes);\n    }\n    if (autoCreateCustomNetworks && config.isCustomNetwork()) {\n      runService.createCustomNetworkIfNotExistant(config.getCustomNetwork());\n    }\n    imagesWaitingToStart.add(imageConfig);\n    updateAliasesSet(imageAliases,imageConfig.getAlias());\n  }\n  return imagesWaitingToStart;\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") public T getExtension(String name){\n  if (StringUtils.isEmpty(name)) {\n    throw new IllegalArgumentException(\"Extension name == null\");\n  }\n  if (\"true\".equals(name)) {\n    return getDefaultExtension();\n  }\n// bug_start\n  Holder<Object> holder=getOrCreateHolder(name);\n// bug_end\n  Object instance=holder.get();\n  if (instance == null) {\nsynchronized (holder) {\n      instance=holder.get();\n      if (instance == null) {\n        instance=createExtension(name);\n        holder.set(instance);\n      }\n    }\n  }\n  return (T)instance;\n}\n"}
{"INPUT": "@Override public synchronized IndexInput openInput(String name,IOContext context) throws IOException {\n  maybeYield();\n  if (failOnOpenInput) {\n    maybeThrowDeterministicException();\n  }\n  if (!delegate.fileExists(name)) {\n    throw new FileNotFoundException(name + \" in dir=\" + delegate);\n  }\n  if (openFilesForWrite.contains(name) && !name.startsWith(\"segments\")) {\n    throw fillOpenTrace(new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open for writing\"),name,false);\n  }\n// bug_start\n  IndexInput ii=new MockIndexInputWrapper(this,name,delegate.openInput(name,LuceneTestCase.newIOContext(randomState,context)));\n// bug_end\n  addFileHandle(ii,name,Handle.Input);\n  return ii;\n}\n"}
{"INPUT": "private void drawSelectedFilesSegments(Canvas canvas,RotatedTileBox tileBox,List<SelectedGpxFile> selectedGPXFiles,DrawSettings settings){\n  for (  SelectedGpxFile g : selectedGPXFiles) {\n    List<TrkSegment> segments=g.getPointsToDisplay();\n    for (    TrkSegment ts : segments) {\n      if (ts.renders.isEmpty() && !ts.points.isEmpty()) {\n        if (g.isShowCurrentTrack()) {\n          ts.renders.add(new Renderable.CurrentTrack(ts.points));\n        }\n else {\n// bug_start\n          ts.renders.add(new Renderable.Altitude(ts.points,10));\n// bug_end\n          ts.renders.add(new Renderable.StandardTrack(ts.points,17.2));\n// bug_start\n          ts.renders.add(new Renderable.Conveyor(ts.points,view,5,250));\n          ts.renders.add(new Renderable.Arrows(ts.points,view,10,250));\n          ts.renders.add(new Renderable.DistanceMarker(ts.points,1000));\n// bug_end\n        }\n      }\n      updatePaints(ts.getColor(cachedColor),g.isRoutePoints(),g.isShowCurrentTrack(),settings,tileBox);\n      ts.drawRenderers(view.getZoom(),paint,canvas,tileBox);\n    }\n  }\n}\n"}
{"INPUT": "@Override public void processOpts(){\n  super.processOpts();\n  if (additionalProperties.containsKey(USE_BEANVALIDATION)) {\n    boolean useBeanValidationProp=convertPropertyToBooleanAndWriteBack(USE_BEANVALIDATION);\n    this.setUseBeanValidation(useBeanValidationProp);\n  }\n  if (additionalProperties.containsKey(USE_GENERIC_RESPONSE)) {\n    this.setUseGenericResponse(convertPropertyToBoolean(USE_GENERIC_RESPONSE));\n  }\n  if (useGenericResponse) {\n    writePropertyBack(USE_GENERIC_RESPONSE,useGenericResponse);\n  }\n  this.setUseGzipFeatureForTests(convertPropertyToBooleanAndWriteBack(USE_GZIP_FEATURE_FOR_TESTS));\n  this.setUseLoggingFeatureForTests(convertPropertyToBooleanAndWriteBack(USE_LOGGING_FEATURE_FOR_TESTS));\n  supportingFiles.clear();\n// bug_start\n  writeOptional(outputFolder,new SupportingFile(\"pom.mustache\",\"\",\"pom.xml\"));\n// bug_end\n}\n"}
{"INPUT": "@Override public Duration convert(String value){\n// bug_start\n// bug_end\n  if (DIGITS.asPredicate().test(value)) {\n    return Duration.ofSeconds(Long.valueOf(value));\n  }\n  try {\n    if (START_WITH_DIGITS.asPredicate().test(value)) {\n      return Duration.parse(PERIOD_OF_TIME + value);\n    }\n    return Duration.parse(value);\n  }\n catch (  DateTimeParseException e) {\n    throw new IllegalArgumentException(e);\n  }\n}\n"}
{"INPUT": "public URL(String protocol,String username,String password,String host,int port,String path,Map<String,String> parameters){\n  if ((username == null || username.length() == 0) && password != null && password.length() > 0) {\n    throw new IllegalArgumentException(\"Invalid url, password without username!\");\n  }\n  this.protocol=protocol;\n  this.username=username;\n  this.password=password;\n  this.host=host != null && host.length() > 0 ? NetUtils.filterLocalHost(host) : host;\n  this.port=(port < 0 ? 0 : port);\n  this.path=path;\n  while (path != null && path.startsWith(\"/\")) {\n    path=path.substring(1);\n  }\n  if (parameters == null) {\n    parameters=new HashMap<String,String>();\n  }\n// bug_start\n// bug_end\n  if (NetUtils.isAnyHost(host)) {\n    parameters.put(\"anyhost\",\"true\");\n  }\n else   if (NetUtils.isLocalHost(host)) {\n    parameters.put(\"localhost\",\"true\");\n  }\n// bug_start\n  this.parameters=Collections.unmodifiableMap(new HashMap<String,String>(parameters));\n// bug_end\n}\n"}
{"INPUT": "private final void fullAddCount(long x,CounterHashCode hc,boolean wasUncontended){\n  int h;\n  if (hc == null) {\n    hc=new CounterHashCode();\n    int s=counterHashCodeGenerator.addAndGet(SEED_INCREMENT);\n    h=hc.code=(s == 0) ? 1 : s;\n    threadCounterHashCode.set(hc);\n  }\n else   h=hc.code;\n  boolean collide=false;\n  for (; ; ) {\n    CounterCell[] as;\n    CounterCell a;\n    int n;\n    long v;\n    if ((as=counterCells) != null && (n=as.length) > 0) {\n      if ((a=as[(n - 1) & h]) == null) {\n        if (cellsBusy == 0) {\n          CounterCell r=new CounterCell(x);\n          if (cellsBusy == 0 && U.compareAndSwapInt(this,CELLSBUSY,0,1)) {\n            boolean created=false;\n            try {\n              CounterCell[] rs;\n              int m, j;\n              if ((rs=counterCells) != null && (m=rs.length) > 0 && rs[j=(m - 1) & h] == null) {\n                rs[j]=r;\n                created=true;\n              }\n            }\n  finally {\n              cellsBusy=0;\n            }\n            if (created)             break;\n            continue;\n          }\n        }\n        collide=false;\n      }\n else       if (!wasUncontended)       wasUncontended=true;\n else       if (U.compareAndSwapLong(a,CELLVALUE,v=a.value,v + x))       break;\n else       if (counterCells != as || n >= NCPU)       collide=false;\n else       if (!collide)       collide=true;\n else       if (cellsBusy == 0 && U.compareAndSwapInt(this,CELLSBUSY,0,1)) {\n        try {\n          if (counterCells == as) {\n            CounterCell[] rs=new CounterCell[n << 1];\n// bug_start\n            for (int i=0; i < n; ++i)             rs[i]=as[i];\n// bug_end\n            counterCells=rs;\n          }\n        }\n  finally {\n          cellsBusy=0;\n        }\n        collide=false;\n        continue;\n      }\n      h^=h << 13;\n      h^=h >>> 17;\n      h^=h << 5;\n    }\n else     if (cellsBusy == 0 && counterCells == as && U.compareAndSwapInt(this,CELLSBUSY,0,1)) {\n      boolean init=false;\n      try {\n        if (counterCells == as) {\n          CounterCell[] rs=new CounterCell[2];\n          rs[h & 1]=new CounterCell(x);\n          counterCells=rs;\n          init=true;\n        }\n      }\n  finally {\n        cellsBusy=0;\n      }\n      if (init)       break;\n    }\n else     if (U.compareAndSwapLong(this,BASECOUNT,v=baseCount,v + x))     break;\n  }\n  hc.code=h;\n}\n"}
{"INPUT": "private void parseConf(String propertyValue){\n  if (propertyValue == null || propertyValue.trim().length() == 0) {\n    return;\n  }\n  Pattern hostPattern=Pattern.compile(\".*\");\n  Pattern urlPattern=null;\n  Matcher lineMatcher=LINE_SPLIT.matcher(propertyValue);\n  while (lineMatcher.find()) {\n    String line=lineMatcher.group();\n    if (line != null && line.length() > 0) {\n      Matcher nameValueMatcher=NAME_VALUE_SPLIT.matcher(line.trim());\n      if (nameValueMatcher.find()) {\n        String fieldName=nameValueMatcher.group(1).trim();\n        String value=nameValueMatcher.group(2);\n        if (fieldName != null && value != null) {\n          if (HOSTMATCH.equals(fieldName)) {\n            urlPattern=null;\n            try {\n              hostPattern=Pattern.compile(value);\n            }\n catch (            PatternSyntaxException pse) {\n              LOG.error(\"hostmatch pattern \" + value + \" does not compile: \"+ pse.getMessage());\n              hostPattern=Pattern.compile(\"willnotmatchanyhost\");\n            }\n          }\n else           if (URLMATCH.equals(fieldName)) {\n            try {\n              urlPattern=Pattern.compile(value);\n            }\n catch (            PatternSyntaxException pse) {\n              LOG.error(\"urlmatch pattern \" + value + \" does not compile: \"+ pse.getMessage());\n              urlPattern=Pattern.compile(\"willnotmatchanyurl\");\n            }\n          }\n else           if (value.length() > 3) {\n            String toFieldName=fieldName;\n            if (fieldName.indexOf(':') > 0) {\n              toFieldName=fieldName.substring(fieldName.indexOf(':') + 1);\n              fieldName=fieldName.substring(0,fieldName.indexOf(':'));\n            }\n            String sep=value.substring(0,1);\n            value=value.substring(1);\n            if (!value.contains(sep)) {\n              LOG.error(\"Pattern '\" + line + \"', not parseable.  Missing separator \"+ sep);\n              continue;\n            }\n            String pattern=value.substring(0,value.indexOf(sep));\n            value=value.substring(pattern.length() + 1);\n            String replacement=value;\n            if (value.contains(sep)) {\n              replacement=value.substring(0,value.indexOf(sep));\n            }\n            int flags=0;\n            if (value.length() > replacement.length() + 1) {\n              value=value.substring(replacement.length() + 1).trim();\n              try {\n                flags=Integer.parseInt(value);\n              }\n catch (              NumberFormatException e) {\n                LOG.error(\"Pattern \" + line + \", has invalid flags component\");\n                continue;\n              }\n            }\n// bug_start\n            Integer iFlags=(flags > 0) ? new Integer(flags) : null;\n// bug_end\n            FieldReplacer fr=new FieldReplacer(fieldName,toFieldName,pattern,replacement,iFlags);\n            if (urlPattern != null) {\n              List<FieldReplacer> lfp=FIELDREPLACERS_BY_URL.get(urlPattern);\n              if (lfp == null) {\n                lfp=new ArrayList<FieldReplacer>();\n              }\n              lfp.add(fr);\n              FIELDREPLACERS_BY_URL.put(urlPattern,lfp);\n            }\n else {\n              List<FieldReplacer> lfp=FIELDREPLACERS_BY_HOST.get(hostPattern);\n              if (lfp == null) {\n                lfp=new ArrayList<FieldReplacer>();\n              }\n              lfp.add(fr);\n              FIELDREPLACERS_BY_HOST.put(hostPattern,lfp);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\npublic void onClose(final Connection connection){\n// bug_end\n  final Address endPoint=connection.getEndPoint();\n  if (mapConnections.remove(endPoint,connection)) {\n    logger.info(\"Removed connection to endpoint: \" + endPoint + \", connection: \"+ connection);\n    ioService.getEventService().executeEventCallback(new StripedRunnable(){\n      @Override public void run(){\n        for (        ConnectionListener listener : connectionListeners) {\n          listener.connectionRemoved(connection);\n        }\n      }\n      @Override public int getKey(){\n        return endPoint.hashCode();\n      }\n    }\n);\n  }\n}\n"}
{"INPUT": "public Iterable<?> simpleExport(){\n  final OperationChain<CloseableIterable<? extends Element>> opChain;\n// bug_start\n  AccumuloProperties storeProperties=new AccumuloProperties();\n// bug_end\n  try {\n    storeProperties.getProperties().load(StreamUtil.openStream(getClass(),\"othermockaccumulostore.properties\"));\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n  opChain=new OperationChain.Builder().first(new GetAllElements()).then(new ExportToOtherGraph.Builder<CloseableIterable<? extends Element>>().graphId(\"graphId\").storeProperties(storeProperties).build()).build();\n  return runExample(opChain,null);\n}\n"}
{"INPUT": "private Map<String,ValidateIndexesPartitionResult> processIndex(GridCacheContext ctx,Index idx){\n  Object consId=ignite.context().discovery().localNode().consistentId();\n  ValidateIndexesPartitionResult idxValidationRes=new ValidateIndexesPartitionResult(-1,-1,true,consId,idx.getName());\n  boolean enoughIssues=false;\n  Cursor cursor=null;\n  try {\n    cursor=idx.find((Session)null,null,null);\n    if (cursor == null)     throw new IgniteCheckedException(\"Can't iterate through index: \" + idx);\n  }\n catch (  Throwable t) {\n    IndexValidationIssue is=new IndexValidationIssue(null,ctx.name(),idx.getName(),t);\n    log.error(\"Find in index failed: \" + is.toString());\n    enoughIssues=true;\n  }\n  final boolean skipConditions=checkFirst > 0 || checkThrough > 0;\n  final boolean bothSkipConditions=checkFirst > 0 && checkThrough > 0;\n  long current=0;\n  long processedNumber=0;\n  KeyCacheObject previousKey=null;\n  while (!enoughIssues) {\n    KeyCacheObject h2key=null;\n    try {\n      try {\n        if (!cursor.next())         break;\n      }\n catch (      DbException e) {\n        if (X.hasCause(e,CorruptedTreeException.class))         throw new IgniteCheckedException(\"Key is present in SQL index, but is missing in corresponding \" + \"data page. Previous successfully read key: \" + CacheObjectUtils.unwrapBinaryIfNeeded(ctx.cacheObjectContext(),previousKey,true,true),X.cause(e,CorruptedTreeException.class));\n        throw e;\n      }\n      H2CacheRow h2Row=(H2CacheRow)cursor.get();\n      if (skipConditions) {\n        if (bothSkipConditions) {\n          if (processedNumber > checkFirst)           break;\n else           if (current++ % checkThrough > 0)           continue;\n else           processedNumber++;\n        }\n else {\n          if (checkFirst > 0) {\n            if (current++ > checkFirst)             break;\n          }\n else {\n            if (current++ % checkThrough > 0)             continue;\n          }\n        }\n      }\n      h2key=(KeyCacheObject)h2Row.key();\n      if (h2Row.link() != 0L) {\n        CacheDataRow cacheDataStoreRow=ctx.group().offheap().read(ctx,h2key);\n        if (cacheDataStoreRow == null)         throw new IgniteCheckedException(\"Key is present in SQL index, but can't be found in CacheDataTree.\");\n      }\n else       throw new IgniteCheckedException(\"Invalid index row, possibly deleted \" + h2Row);\n    }\n catch (    Throwable t) {\n      Object o=CacheObjectUtils.unwrapBinaryIfNeeded(ctx.cacheObjectContext(),h2key,true,true);\n      IndexValidationIssue is=new IndexValidationIssue(String.valueOf(o),ctx.name(),idx.getName(),t);\n      log.error(\"Failed to lookup key: \" + is.toString());\n      enoughIssues|=idxValidationRes.reportIssue(is);\n    }\n finally {\n      previousKey=h2key;\n    }\n  }\n// bug_start\n  String uniqueIdxName=\"[cache=\" + ctx.name() + \", idx=\"+ idx.getName()+ \"]\";\n// bug_end\n  processedIndexes.incrementAndGet();\n  printProgressOfIndexValidationIfNeeded();\n  return Collections.singletonMap(uniqueIdxName,idxValidationRes);\n}\n"}
{"INPUT": "@Override public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n  ValidationUtil.isNotNull(unit,\"unit\");\n// bug_start\n  latch.await(timeout,unit);\n  if (!isDone()) {\n// bug_end\n    throw new TimeoutException(\"timeout reached\");\n  }\n  return getResult();\n}\n"}
{"INPUT": "@Override public void notifyListeners(OneRowAnalysisFinishEvent event){\n  analysisContext.setCurrentRowAnalysisResult(event.getData());\n  if (analysisContext.getCurrentRowNum() < analysisContext.getCurrentSheet().getHeadLineMun()) {\n    if (analysisContext.getCurrentRowNum() <= analysisContext.getCurrentSheet().getHeadLineMun() - 1) {\n      analysisContext.buildExcelHeadProperty(null,(List<String>)analysisContext.getCurrentRowAnalysisResult());\n    }\n  }\n else {\n// bug_start\n    analysisContext.setCurrentRowAnalysisResult(event.getData());\n// bug_end\n    if (listeners.size() == 1) {\n// bug_start\n      analysisContext.setCurrentRowAnalysisResult(converter((List<String>)event.getData()));\n// bug_end\n    }\n    for (    Map.Entry<String,AnalysisEventListener> entry : listeners.entrySet()) {\n      entry.getValue().invoke(analysisContext.getCurrentRowAnalysisResult(),analysisContext);\n    }\n  }\n}\n"}
{"INPUT": "public void setDataFilter(final DBDDataFilter dataFilter,boolean refreshData){\n// bug_start\n  if (!model.getDataFilter().equals(dataFilter)) {\n// bug_end\n    if (refreshData) {\n      refreshWithFilter(dataFilter);\n    }\n else {\n      model.setDataFilter(dataFilter);\n      activePresentation.refreshData(true,false,true);\n      updateFiltersText();\n    }\n  }\n}\n"}
{"INPUT": "@Override public boolean onTouchEvent(MotionEvent me){\n  if (me.getY() < -mExtensionKeyboardPopupOffset && !isPopupShowing() && !mExtensionVisible && me.getAction() != MotionEvent.ACTION_UP) {\n    if (mExtensionKeyboardAreaEntranceTime <= 0)     mExtensionKeyboardAreaEntranceTime=System.currentTimeMillis();\n    if (System.currentTimeMillis() - mExtensionKeyboardAreaEntranceTime > DELAY_BEFORE_POPING_UP_EXTENSION_KBD) {\n      int extensionResId=((ExternalAnyKeyboard)getKeyboard()).getExtensionResId();\n      if (extensionResId <= 0) {\n        return super.onTouchEvent(me);\n      }\n else {\n        MotionEvent cancel=MotionEvent.obtain(me.getDownTime(),me.getEventTime(),MotionEvent.ACTION_CANCEL,me.getX(),me.getY(),0);\n        super.onTouchEvent(cancel);\n        cancel.recycle();\n        mExtensionVisible=true;\n        if (mExtensionKey == null) {\n          mExtensionKey=new Key(new Row(getKeyboard()));\n          mExtensionKey.codes=new int[]{0};\n          mExtensionKey.edgeFlags=Keyboard.EDGE_TOP;\n          mExtensionKey.height=0;\n          mExtensionKey.width=0;\n          mExtensionKey.popupResId=extensionResId;\n          mExtensionKey.x=getWidth() / 2;\n          mExtensionKey.y=-mExtensionKeyboardPopupOffset;\n        }\n        onLongPress(getContext(),mExtensionKey);\n        mMiniKeyboard.setPreviewEnabled(true);\n        Keyboard miniKeyboardObject=mMiniKeyboard.getKeyboard();\n// bug_start\n        if (miniKeyboardObject instanceof AnyPopupKeyboard)         ((AnyPopupKeyboard)miniKeyboardObject).setIsOnKeyEventPopup(false);\n// bug_end\n        return true;\n      }\n    }\n else {\n      return super.onTouchEvent(me);\n    }\n  }\n else   if (mExtensionVisible && me.getY() > mExtensionKeyboardPopupOffset) {\n    dismissPopupKeyboard();\n    return true;\n  }\n else {\n    mExtensionKeyboardAreaEntranceTime=-1;\n    return super.onTouchEvent(me);\n  }\n}\n"}
{"INPUT": "@Test public void testNullDimensionTransform() throws IndexSizeExceededException {\n  IncrementalIndex<?> index=closer.closeLater(indexCreator.createIndex());\n  index.add(new MapBasedInputRow(System.currentTimeMillis() - 1,Lists.newArrayList(\"string\",\"float\",\"long\",\"double\"),ImmutableMap.<String,Object>of(\"string\",Arrays.asList(\"A\",null,\"\"),\"float\",Arrays.asList(Float.POSITIVE_INFINITY,null,\"\"),\"long\",Arrays.asList(Long.MIN_VALUE,null,\"\"),\"double\",\"\")));\n  Row row=index.iterator().next();\n  Assert.assertEquals(Arrays.asList(new String[]{\"\",\"\",\"A\"}),row.getRaw(\"string\"));\n  Assert.assertEquals(Arrays.asList(new String[]{\"\",\"\",String.valueOf(Float.POSITIVE_INFINITY)}),row.getRaw(\"float\"));\n  Assert.assertEquals(Arrays.asList(new String[]{\"\",\"\",String.valueOf(Long.MIN_VALUE)}),row.getRaw(\"long\"));\n// bug_start\n  Assert.assertEquals(0.0,row.getRaw(\"double\"));\n// bug_end\n}\n"}
{"INPUT": "private boolean processUnsafeStore(RawStoreNode store,PEReadEliminationBlockState state,GraphEffectList effects){\n  ResolvedJavaType type=StampTool.typeOrNull(store.object());\n  if (type != null && type.isArray()) {\n    JavaKind accessKind=store.accessKind();\n    JavaKind componentKind=type.getComponentType().getJavaKind();\n    LocationIdentity location=NamedLocationIdentity.getArrayLocation(componentKind);\n    if (store.offset().isConstant()) {\n      long offset=store.offset().asJavaConstant().asLong();\n      boolean overflowAccess=isOverflowAccess(accessKind,componentKind);\n      int index=overflowAccess ? -1 : VirtualArrayNode.entryIndexForOffset(tool.getMetaAccess(),offset,accessKind,type.getComponentType(),Integer.MAX_VALUE);\n// bug_start\n      return processStore(store,store.object(),location,index,accessKind,overflowAccess,store.value(),state,effects);\n// bug_end\n    }\n else {\n      processIdentity(state,location);\n    }\n  }\n else {\n    state.killReadCache();\n  }\n  return false;\n}\n"}
{"INPUT": "@Test public void testCustomerService() throws Exception {\n  ClassPathXmlApplicationContext serverContext=null;\n  ClassPathXmlApplicationContext clientContext=null;\n  try {\n    serverContext=new ClassPathXmlApplicationContext(new String[]{\"spring-config/server-WsAddressingContext.xml\"});\n    Object server=serverContext.getBean(\"org.apache.camel.itest.customerrelations.CustomerServiceV1\");\n    assertNotNull(\"We should get server here\",server);\n    clientContext=new ClassPathXmlApplicationContext(new String[]{\"spring-config/client-WsAddressingContext.xml\"});\n// bug_start\n    CustomerServiceV1 customerService=(CustomerServiceV1)clientContext.getBean(\"org.apache.camel.itest.customerrelations.CustomerServiceV1\");\n// bug_end\n    Customer customer=customerService.getCustomer(\"12345\");\n    assertNotNull(\"We should get Customer here\",customer);\n  }\n  finally {\n    if (clientContext != null) {\n      clientContext.destroy();\n    }\n    if (serverContext != null) {\n      serverContext.destroy();\n    }\n  }\n}\n"}
{"INPUT": "public List<Metadata> getMetadatas(){\n  if (metadatas == null) {\n    String metadataString=get(\"metadatas\");\n    if (StringUtils.isNotBlank(metadataString)) {\n      metadatas=new ArrayList<Metadata>();\n      String medadataStrings[]=metadataString.split(\",\");\n// bug_start\n      if (medadataStrings != null && medadataStrings.length > 0) {\n        for (        String metadataStr : medadataStrings) {\n          String[] propertes=metadataStr.split(\":\");\n          Metadata md=new Metadata();\n          md.setId(new BigInteger(propertes[0]));\n          md.setObjectType(METADATA_TYPE);\n          md.setMetaKey(propertes[1]);\n          md.setMetaValue(propertes[2]);\n          metadatas.add(md);\n        }\n// bug_end\n      }\n    }\n  }\n  return metadatas;\n}\n"}
{"INPUT": "public static void main(String[] args){\n  int sizes[]={1000,10000,100000,1000000};\n// bug_start\n  HeapMonitor.setSamplingInterval(0);\n  HeapMonitor.enableSamplingEvents();\n// bug_end\n  for (  int currentSize : sizes) {\n    System.out.println(\"Testing size \" + currentSize);\n    HeapMonitor.resetEventStorage();\n    allocate(currentSize);\n    if (!HeapMonitor.statsHaveExpectedNumberSamples(maxIteration,10)) {\n      throw new RuntimeException(\"Statistics should show about \" + maxIteration + \" samples.\");\n    }\n  }\n}\n"}
{"INPUT": "protected StreamRecord<IN> readNext(){\n  this.nextRecord=inSerializer.createInstance();\n  try {\n    nextRecord=recordIterator.next(nextRecord);\n    try {\n      nextObject=nextRecord.getObject();\n    }\n catch (    NullPointerException e) {\n    }\n    return nextRecord;\n  }\n catch (  IOException e) {\n    if (isRunning) {\n      throw new RuntimeException(\"Could not read next record due to: \" + StringUtils.stringifyException(e));\n    }\n else {\n      return null;\n    }\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "protected String resolveDriverVersion(String driverVersion){\n  String preferenceKey=getKeyForResolutionCache();\n  Optional<String> optionalBrowserVersion=Optional.ofNullable(getBrowserVersion()).filter(null);\n  if (!optionalBrowserVersion.isPresent()) {\n    optionalBrowserVersion=getValueFromResolutionCache(preferenceKey);\n  }\n  if (!optionalBrowserVersion.isPresent()) {\n    optionalBrowserVersion=detectBrowserVersion();\n  }\n  if (optionalBrowserVersion.isPresent()) {\n    preferenceKey=getKeyForResolutionCache() + optionalBrowserVersion.get();\n    Optional<String> optionalDriverVersion=getValueFromResolutionCache(preferenceKey);\n    if (!optionalDriverVersion.isPresent()) {\n      optionalDriverVersion=getDriverVersionFromRepository(optionalBrowserVersion);\n    }\n    if (!optionalDriverVersion.isPresent()) {\n      optionalDriverVersion=versionDetector.getDriverVersionFromProperties(preferenceKey);\n    }\n    if (optionalDriverVersion.isPresent()) {\n      driverVersion=optionalDriverVersion.get();\n      log.info(\"Using {} {} (since {} {} is installed in your machine)\",getDriverName(),driverVersion,getDriverManagerType(),optionalBrowserVersion.get());\n      storeInResolutionCache(preferenceKey,driverVersion,optionalBrowserVersion.get());\n    }\n// bug_start\n else {\n      log.debug(\"The driver version for {} {} is unknown ... trying with latest\",getDriverManagerType(),optionalBrowserVersion.get());\n    }\n// bug_end\n  }\n  if (isUnknown(driverVersion)) {\n// bug_start\n// bug_end\n    Optional<String> latestDriverVersionFromRepository=getLatestDriverVersionFromRepository();\n    if (latestDriverVersionFromRepository.isPresent()) {\n      driverVersion=latestDriverVersionFromRepository.get();\n    }\n  }\n  return driverVersion;\n}\n"}
{"INPUT": "public void executeOnPostUpgrade(List<UpgradeCatalog> upgradeCatalogs) throws AmbariException {\n  LOG.info(\"Finalizing catalog upgrade.\");\n  if (upgradeCatalogs != null && !upgradeCatalogs.isEmpty()) {\n    for (    UpgradeCatalog upgradeCatalog : upgradeCatalogs) {\n      try {\n        upgradeCatalog.onPostUpgrade();\n// bug_start\n        ;\n// bug_end\n      }\n catch (      Exception e) {\n        LOG.error(\"Upgrade failed. \",e);\n        throw new AmbariException(e.getMessage(),e);\n      }\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\nprivate void handleGBDeviceEvent(GBDeviceEventMusicControl musicEvent){\n// bug_end\n  Context context=getContext();\n  LOG.info(\"Got event for MUSIC_CONTROL\");\n  Intent musicIntent=new Intent(GBMusicControlReceiver.ACTION_MUSICCONTROL);\n  musicIntent.putExtra(\"event\",musicEvent.event.ordinal());\n  musicIntent.setPackage(context.getPackageName());\n  context.sendBroadcast(musicIntent);\n}\n"}
{"INPUT": "protected boolean hasMagic(){\n// bug_start\n  if (buffer[offset + 4] == zrtpMagic[0] && buffer[offset + 5] == zrtpMagic[1] && buffer[offset + 6] == zrtpMagic[2] && buffer[offset + 7] == zrtpMagic[3]) {\n    return true;\n  }\n  return false;\n// bug_end\n}\n"}
{"INPUT": "private void visitParameterList(NodeTraversal t,Node call,FunctionType functionType){\n  Iterator<Node> arguments=call.children().iterator();\n  arguments.next();\n  Iterator<Node> parameters=functionType.getParameters().iterator();\n  int ordinal=0;\n// bug_start\n  while (arguments.hasNext() && parameters.hasNext()) {\n    Node parameter=parameters.next();\n    Node argument=arguments.next();\n// bug_end\n    ordinal++;\n    validator.expectArgumentMatchesParameter(t,argument,getJSType(argument),getJSType(parameter),call,ordinal);\n  }\n  int numArgs=call.getChildCount() - 1;\n  int minArgs=functionType.getMinArguments();\n  int maxArgs=functionType.getMaxArguments();\n  if (minArgs > numArgs || maxArgs < numArgs) {\n    report(t,call,WRONG_ARGUMENT_COUNT,validator.getReadableJSTypeName(call.getFirstChild(),false),String.valueOf(numArgs),String.valueOf(minArgs),maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n  }\n}\n"}
{"INPUT": "// bug_start\nprivate static Bitmap.Config getConfig(InputStream is,DecodeFormat format){\n// bug_end\n  if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888 || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {\n    return Bitmap.Config.ARGB_8888;\n  }\n  boolean hasAlpha=false;\n  is.mark(1024);\n  try {\n    hasAlpha=new ImageHeaderParser(is).hasAlpha();\n  }\n catch (  IOException e) {\n    if (Log.isLoggable(TAG,Log.WARN)) {\n      Log.w(TAG,\"Cannot determine whether the image has alpha or not from header for format \" + format,e);\n    }\n  }\n finally {\n    try {\n      is.reset();\n    }\n catch (    IOException e) {\n      if (Log.isLoggable(TAG,Log.WARN)) {\n        Log.w(TAG,\"Cannot reset the input stream\",e);\n      }\n    }\n  }\n  return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;\n}\n"}
{"INPUT": "public void setStyles(){\n  String expression=expressionEditor.getText();\n  int expressionLength=expression.length();\n  Map<String,FormulaMessage> messages=evaluator.evaluateFormula(expression);\n  Vector<StyleRange> styles=new Vector<StyleRange>();\n  StringBuffer report=new StringBuffer();\n  for (  FormulaMessage message : messages.values()) {\n    ParsePosition position=message.getPosition();\n    PositionAndLength positionAndLength=PositionAndLength.calculatePositionAndLength(expression,position);\n    int pos=positionAndLength.getPosition();\n    int length=positionAndLength.getLength();\n    if (pos < expressionLength) {\nswitch (message.getType()) {\ncase FormulaMessage.TYPE_ERROR:\n        report.append(message.toString()).append(Const.CR);\n      StyleRange styleRangeRed=new StyleRange(pos,length,red,null,SWT.BOLD);\n    styleRangeRed.underline=true;\n  styles.add(styleRangeRed);\nbreak;\ncase FormulaMessage.TYPE_FUNCTION:\nstyles.add(new StyleRange(pos,length,black,null,SWT.BOLD));\nbreak;\ncase FormulaMessage.TYPE_FIELD:\nbreak;\ncase FormulaMessage.TYPE_STATIC_NUMBER:\ncase FormulaMessage.TYPE_STATIC_STRING:\ncase FormulaMessage.TYPE_STATIC_DATE:\ncase FormulaMessage.TYPE_STATIC_LOGICAL:\nstyles.add(new StyleRange(pos,length,blue,gray,SWT.BOLD | SWT.ITALIC));\nbreak;\n// bug_start\n// bug_end\n}\n}\n}\nmessage.setText(report.toString());\nCollections.sort(styles,new Comparator<StyleRange>(){\npublic int compare(StyleRange o1,StyleRange o2){\nreturn o1.start - o2.start;\n}\n}\n);\nStyleRange[] styleRanges=new StyleRange[styles.size()];\nstyles.copyInto(styleRanges);\nexpressionEditor.setStyleRanges(styleRanges);\n}\n"}
{"INPUT": "@Override public SingleFieldConstraint getLHSBoundField(final String var){\n  for (  CompositeColumn<? extends BaseColumn> col : dtable.getConditions()) {\n    if (col instanceof Pattern52) {\n      final Pattern52 p=(Pattern52)col;\n      for (      ConditionCol52 cc : p.getChildColumns()) {\n        if (cc.isBound() && cc.getBinding().equals(var)) {\n// bug_start\n          return new ConditionCol52FieldConstraintAdaptor(cc);\n// bug_end\n        }\n      }\n    }\n else     if (col instanceof BRLConditionColumn) {\n      final BRLConditionColumn brl=(BRLConditionColumn)col;\n      for (      IPattern p : brl.getDefinition()) {\n        if (p instanceof FactPattern) {\n          final FactPattern fp=(FactPattern)p;\n          for (          FieldConstraint fc : fp.getFieldConstraints()) {\n            if (fc instanceof SingleFieldConstraint) {\n              final List<String> fieldBindings=getFieldBinding(fc);\n              if (fieldBindings.contains(var)) {\n                return (SingleFieldConstraint)fc;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return super.getLHSBoundField(var);\n}\n"}
{"INPUT": "@Override @SuppressWarnings(\"unchecked\") public Object transformRow(Map<String,Object> row,Context context){\n  for (  Map<String,String> fld : context.getAllEntityFields()) {\n    String style=context.replaceTokens(fld.get(FORMAT_STYLE));\n    if (style != null) {\n      String column=fld.get(DataImporter.COLUMN);\n      String srcCol=fld.get(RegexTransformer.SRC_COL_NAME);\n      String localeStr=context.replaceTokens(fld.get(LOCALE));\n      if (srcCol == null)       srcCol=column;\n      Locale locale=Locale.ROOT;\n      if (localeStr != null) {\n        try {\n          locale=new Locale.Builder().setLanguageTag(localeStr).build();\n        }\n catch (        IllformedLocaleException e) {\n          throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\"Invalid Locale '\" + localeStr + \"' specified for field: \"+ fld,e);\n        }\n      }\n      Object val=row.get(srcCol);\n      String styleSmall=style.toLowerCase(Locale.ROOT);\n      if (val instanceof List) {\n        List<String> inputs=(List)val;\n// bug_start\n        List results=new ArrayList();\n// bug_end\n        for (        String input : inputs) {\n          try {\n            results.add(process(input,styleSmall,locale));\n          }\n catch (          ParseException e) {\n            throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\"Failed to apply NumberFormat on column: \" + column,e);\n          }\n        }\n        row.put(column,results);\n      }\n else {\n        if (val == null || val.toString().trim().equals(\"\"))         continue;\n        try {\n          row.put(column,process(val.toString(),styleSmall,locale));\n        }\n catch (        ParseException e) {\n          throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\"Failed to apply NumberFormat on column: \" + column,e);\n        }\n      }\n    }\n  }\n  return row;\n}\n"}
{"INPUT": "// bug_start\n@Override public FragmentTransaction postOnCommit(Runnable runnable){\n// bug_end\n  if (runnable == null) {\n    throw new IllegalArgumentException(\"runnable cannot be null\");\n  }\n  disallowAddToBackStack();\n  if (mCommitRunnables == null) {\n    mCommitRunnables=new ArrayList<>();\n  }\n  mCommitRunnables.add(runnable);\n  return this;\n}\n"}
{"INPUT": "@Override protected void onInitialize(){\n  super.onInitialize();\n  PasswordEditBean bean=new PasswordEditBean();\n  Set<String> excludedProperties=new HashSet<>();\n  if (SecurityUtils.isAdministrator())   excludedProperties.add(\"oldPassword\");\n  Form<?> form=new Form<Void>(\"form\"){\n    @Override protected void onSubmit(){\n      super.onSubmit();\n      getUser().setPassword(AppLoader.getInstance(PasswordService.class).encryptPassword(bean.getNewPassword()));\n      OneDev.getInstance(UserManager.class).save(getUser(),null);\n      Session.get().success(\"Password has been changed\");\n      bean.setOldPassword(null);\n// bug_start\n      replace(BeanContext.editBean(\"editor\",bean,excludedProperties));\n// bug_end\n    }\n  }\n;\n  add(form);\n// bug_start\n  form.add(BeanContext.editBean(\"editor\",bean,excludedProperties));\n// bug_end\n}\n"}
{"INPUT": "@Override protected void updateHeaderViewPosition(View headerView){\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n    super.updateHeaderViewPosition(headerView);\n  }\n// bug_start\n else {\n// bug_end\n    super.updateHeaderViewPosition(mHeaderViewWrapper);\n  }\n}\n"}
{"INPUT": "@Override public void afterThrowing(ClassLoader loader,Class<?> clazz,ArthasMethod method,Object target,Object[] args,Throwable throwable) throws Throwable {\n// bug_start\n  threadBoundEntity.get().view.begin(\"throw:\" + throwable.getClass().getName() + \"()\").end().end();\n// bug_end\n  final Advice advice=Advice.newForAfterThrowing(loader,clazz,method,target,args,throwable);\n  finishing(advice);\n}\n"}
{"INPUT": "public StringLiteralExpr(final String value){\n// bug_start\n  if (value.contains(\"\\n\") || value.contains(\"\\t\")) {\n    throw new IllegalArgumentException(\"Illegal literal expression: some characters have to be escaped\");\n// bug_end\n  }\n  this.value=value;\n}\n"}
{"INPUT": "// bug_start\npublic void testPersistDatafeedTimingStats(){\n// bug_end\n  Client client=mockClient(ArgumentCaptor.forClass(BulkRequest.class));\n  doAnswer(null).when(client).index(any(),any(ActionListener.class));\n  JobResultsPersister persister=new JobResultsPersister(client);\n  DatafeedTimingStats timingStats=new DatafeedTimingStats(\"foo\",6,666.0);\n  persister.persistDatafeedTimingStats(timingStats,WriteRequest.RefreshPolicy.IMMEDIATE);\n  ArgumentCaptor<IndexRequest> indexRequestCaptor=ArgumentCaptor.forClass(IndexRequest.class);\n  verify(client,times(1)).index(indexRequestCaptor.capture(),any(ActionListener.class));\n  IndexRequest indexRequest=indexRequestCaptor.getValue();\n  assertThat(indexRequest.index(),equalTo(\".ml-anomalies-.write-foo\"));\n  assertThat(indexRequest.id(),equalTo(\"foo_datafeed_timing_stats\"));\n  assertThat(indexRequest.getRefreshPolicy(),equalTo(WriteRequest.RefreshPolicy.IMMEDIATE));\n  assertThat(indexRequest.sourceAsMap(),equalTo(Map.of(\"job_id\",\"foo\",\"search_count\",6,\"total_search_time_ms\",666.0)));\n  verify(client,times(1)).threadPool();\n  verifyNoMoreInteractions(client);\n}\n"}
{"INPUT": "private void reserveSpace(){\n  Map<String,Long> usedBytesOnTiers=mBlockWorker.getStoreMeta().getUsedBytesOnTiers();\n  for (int ordinal=mStorageTierAssoc.size() - 1; ordinal >= 0; ordinal--) {\n    String tierAlias=mStorageTierAssoc.getAlias(ordinal);\n    long reservedSpace=mReservedSpaces.get(tierAlias);\n    if (mHighWatermarks.containsKey(tierAlias)) {\n      long highWatermark=mHighWatermarks.get(tierAlias);\n      if (highWatermark > reservedSpace && usedBytesOnTiers.get(tierAlias) >= highWatermark) {\n        try {\n          mBlockWorker.freeSpace(Sessions.MIGRATE_DATA_SESSION_ID,reservedSpace,tierAlias);\n        }\n catch (        WorkerOutOfSpaceException|BlockDoesNotExistException|BlockAlreadyExistsException|InvalidWorkerStateException|IOException e) {\n// bug_start\n          LOG.warn(\"SpaceReserver failed to free tier {} to {} bytes used\",tierAlias,reservedSpace,e.getMessage());\n// bug_end\n        }\n      }\n    }\n else {\n      try {\n        mBlockWorker.freeSpace(Sessions.MIGRATE_DATA_SESSION_ID,reservedSpace,tierAlias);\n      }\n catch (      WorkerOutOfSpaceException|BlockDoesNotExistException|BlockAlreadyExistsException|InvalidWorkerStateException|IOException e) {\n// bug_start\n        LOG.warn(e.getMessage());\n// bug_end\n      }\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\n@Test public void geomFromTextRectangleTest(){\n// bug_end\n  ODocument polygon=rectangle();\n  checkFromText(polygon,\"select ST_GeomFromText('\" + RECTANGLEWKT + \"') as geom\");\n}\n"}
{"INPUT": "public boolean addMethod(Method method,boolean skipConflicts,CallbackW<MemoryOperation,Class<?>,Type> unknownTypeFetcher){\n  if (skipConflicts && function.find(method.getParameterTypes().length) != null) {\n    return false;\n  }\n  method.setAccessible(true);\n  CompileMethod.Method compileMethod=function.addMethod(method);\n  compileMethod.setUnknownTypeFetcher(unknownTypeFetcher);\n  int mods=method.getModifiers();\n  String name=method.getName();\n  if (method.isAnnotationPresent(Reflection.Name.class)) {\n    name=method.getAnnotation(Reflection.Name.class).value();\n  }\n  setName(name);\n  setStatic(Modifier.isStatic(mods));\n  setDeprecated(method.getAnnotation(Deprecated.class) != null);\n  if (Modifier.isProtected(mods)) {\n    setModifier(php.runtime.common.Modifier.PROTECTED);\n  }\n else   if (Modifier.isPrivate(mods)) {\n    setModifier(php.runtime.common.Modifier.PRIVATE);\n  }\n else {\n    setModifier(php.runtime.common.Modifier.PUBLIC);\n  }\n  setReturnReference(method.getAnnotation(Reflection.Reference.class) != null);\n  setFinal(method.isAnnotationPresent(Reflection.Final.class));\n  setAbstract(Modifier.isAbstract(mods));\n  setInternalName(method.getName());\n  ParameterEntity[] parameters=new ParameterEntity[method.getParameterTypes().length];\n  Annotation[][] annotations=method.getParameterAnnotations();\n  int i=0, k=0;\n// bug_start\n  int paramCount=method.getParameterCount();\n// bug_end\n  Class<?>[] parameterTypes=method.getParameterTypes();\n// bug_start\n// bug_end\n  for (int x=0; x < paramCount; x++) {\n    Class<?> elType=parameterTypes[x];\n    if (elType == Environment.class || elType == TraceInfo.class) {\n      k++;\n      continue;\n    }\n    ParameterEntity param=new ParameterEntity(context);\n    param.setName(\"arg\" + i);\n    param.setTrace(TraceInfo.UNKNOWN);\n    Annotation[] argAnnotations=annotations[k];\n    if (ReflectionUtils.getAnnotation(argAnnotations,Reflection.Nullable.class) != null) {\n      param.setNullable(true);\n    }\n    Reflection.Arg arg=ReflectionUtils.getAnnotation(argAnnotations,Reflection.Arg.class);\n    if (arg != null) {\n      if (!arg.value().isEmpty()) {\n        param.setName(arg.value());\n      }\n      param.setType(arg.type());\n      param.setReference(arg.reference());\n      if (arg.nativeType() != IObject.class) {\n        param.setTypeNativeClass(arg.nativeType());\n      }\n      if (!arg.typeClass().isEmpty()) {\n        param.setTypeClass(arg.typeClass());\n      }\n      if (arg.optional().exists() || !arg.optional().value().isEmpty() || (arg.type() != HintType.STRING && !arg.optional().value().isEmpty())) {\n        param.setDefaultValue(MemoryUtils.valueOf(arg.optional().value(),arg.optional().type()));\n      }\n    }\n    Reflection.Optional optAnn=ReflectionUtils.getAnnotation(argAnnotations,Reflection.Optional.class);\n    if (optAnn != null) {\n      param.setDefaultValue(MemoryUtils.valueOf(optAnn.value(),optAnn.type()));\n    }\n    parameters[i++]=param;\n    k++;\n  }\n  if (i < parameters.length) {\n    parameters=Arrays.copyOf(parameters,i);\n  }\n  if (this.parameters == null || this.parameters.length < parameters.length) {\n    this.parameters=parameters;\n  }\n  try {\n    compileMethod.setParameters(parameters);\n  }\n catch (  CriticalException e) {\n    if (skipConflicts) {\n      function.delete(parameters.length);\n      return false;\n    }\n    throw e;\n  }\n  return true;\n}\n"}
{"INPUT": "public static void clearInitStack(){\n  final ThreadLocal<Deque<OrientBaseGraph>> is=initializationStack;\n  if (is != null)   is.get().clear();\n  final ThreadLocal<OrientBaseGraph> ag=activeGraph;\n// bug_start\n  if (ag != null)   ag.set(null);\n  final ODatabaseRecordThreadLocal dbtl=ODatabaseRecordThreadLocal.INSTANCE;\n  if (dbtl != null)   dbtl.set(null);\n// bug_end\n}\n"}
{"INPUT": "@Test public void testBrokerConfigAttribute(){\n  BrokerConfig brokerConfig=new BrokerConfig();\n  brokerConfig.setNamesrvAddr(\"127.0.0.1:9876\");\n  brokerConfig.setAutoCreateTopicEnable(false);\n  brokerConfig.setAutoTraceBrokerEnable(true);\n  brokerConfig.setBrokerName(\"broker-a\");\n  brokerConfig.setBrokerId(0);\n  brokerConfig.setBrokerClusterName(\"DefaultCluster\");\n// bug_start\n  brokerConfig.setMsgTrackTopicName(\"RMQ_SYS_TRACK_TRACE_TOPIC4\");\n// bug_end\n  assertThat(brokerConfig.getBrokerClusterName()).isEqualTo(\"DefaultCluster\");\n  assertThat(brokerConfig.getNamesrvAddr()).isEqualTo(\"127.0.0.1:9876\");\n// bug_start\n  assertThat(brokerConfig.getMsgTrackTopicName()).isEqualTo(\"RMQ_SYS_TRACK_TRACE_TOPIC4\");\n// bug_end\n  assertThat(brokerConfig.getBrokerId()).isEqualTo(0);\n  assertThat(brokerConfig.getBrokerName()).isEqualTo(\"broker-a\");\n  assertThat(brokerConfig.isAutoCreateTopicEnable()).isEqualTo(false);\n  assertThat(brokerConfig.isAutoTraceBrokerEnable()).isEqualTo(true);\n}\n"}
{"INPUT": "// bug_start\n@SuppressWarnings(\"unchecked\") public <A>Path<A> get(Path<A> path){\n// bug_end\n  return getSimple(toString(path),(Class<A>)path.getType());\n}\n"}
{"INPUT": "private void readAddFieldPath(AddFieldPathUpdate update,TokenBuffer buffer){\n  expectObjectStart(buffer.currentToken());\n  int localNesting=buffer.nesting();\n  JsonToken t=buffer.next();\n  while (localNesting <= buffer.nesting()) {\nswitch (buffer.currentName()) {\ncase \"items\":\n// bug_start\n      DataType dt=new ArrayDataType(update.getFieldPath().getResultingDataType());\n// bug_end\n    FieldValue fv=CompositeReader.createComposite(buffer,dt);\n  update.setNewValues((Array)fv);\nbreak;\ndefault :\nthrow new RuntimeException(\"Unknown attribute for add fieldpath update: \" + buffer.currentName());\n}\nt=buffer.next();\n}\nexpectObjectEnd(t);\n}\n"}
{"INPUT": "@Test public void zscore(){\n  jedis.zadd(\"foo\",1d,\"a\");\n  jedis.zadd(\"foo\",10d,\"b\");\n  jedis.zadd(\"foo\",0.1d,\"c\");\n  jedis.zadd(\"foo\",2d,\"a\");\n  Double score=jedis.zscore(\"foo\",\"b\");\n// bug_start\n  assertEquals(10d,score);\n// bug_end\n  score=jedis.zscore(\"foo\",\"c\");\n// bug_start\n  assertEquals(0.1d,score);\n// bug_end\n  score=jedis.zscore(\"foo\",\"s\");\n  assertNull(score);\n}\n"}
{"INPUT": "@Override public void readFrom(StreamInput in) throws IOException {\n  index=in.readString();\n  numberOfShards=in.readVInt();\n  numberOfReplicas=in.readVInt();\n  activePrimaryShards=in.readVInt();\n  activeShards=in.readVInt();\n  relocatingShards=in.readVInt();\n  initializingShards=in.readVInt();\n  unassignedShards=in.readVInt();\n  status=ClusterHealthStatus.fromValue(in.readByte());\n  int size=in.readVInt();\n  for (int i=0; i < size; i++) {\n    ClusterShardHealth shardHealth=readClusterShardHealth(in);\n    shards.put(shardHealth.getId(),shardHealth);\n  }\n// bug_start\n  size=in.readVInt();\n  if (size == 0) {\n    validationFailures=ImmutableList.of();\n  }\n else {\n    for (int i=0; i < size; i++) {\n      validationFailures.add(in.readString());\n    }\n  }\n// bug_end\n}\n"}
{"INPUT": "public static Entity parseURN(String urn,double score){\n  if (DimensionEntity.TYPE.isType(urn)) {\n    return DimensionEntity.fromURN(urn,score);\n  }\n else   if (MetricEntity.TYPE.isType(urn)) {\n    return MetricEntity.fromURN(urn,score);\n  }\n else   if (TimeRangeEntity.TYPE.isType(urn)) {\n    return TimeRangeEntity.fromURN(urn,score);\n  }\n else   if (ServiceEntity.TYPE.isType(urn)) {\n    return ServiceEntity.fromURN(urn,score);\n  }\n// bug_start\n// bug_end\n  throw new IllegalArgumentException(String.format(\"Could not parse URN '%s'\",urn));\n}\n"}
{"INPUT": "@Override public String getLongForm(){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"[\").append(getID());\n  sb.append(\":\").append(version);\nswitch (version) {\ncase BLOB_ID_V1:\n    break;\ncase BLOB_ID_V2:\ncase BLOB_ID_V3:\ncase BLOB_ID_V4:\n// bug_start\n// bug_end\n  sb.append(\":\").append(type);\nsb.append(\":\").append(datacenterId);\nsb.append(\":\").append(accountId);\nsb.append(\":\").append(containerId);\nbreak;\ndefault :\nthrow new IllegalArgumentException(\"blobId version=\" + version + \" not supported\");\n}\nsb.append(\":\").append(partitionId);\nsb.append(\":\").append(uuid).append(\"]\");\nreturn sb.toString();\n}\n"}
{"INPUT": "@Override public void stmtExecute(byte[] data){\n  m_sessionManager.getSession().setDatabase(getSchema());\n  try {\n    MySQLMessage mm=new MySQLMessage(data);\n    Long stmtId;\n    mm.position(5);\n    stmtId=mm.readUB4();\n    byte flag=mm.read();\n    int iterationCount=mm.readInt();\n    if (queryHandler != null) {\n      PreparedStatement stmt=((SimpleServerQueryHandler)queryHandler).getStatement(stmtId);\n      if (stmt == null) {\n        writeErrMessage(ErrorCode.ER_YES,\"Invalid Statement Identifier\");\n      }\n      int parameterSize=stmt.getParameterSize();\n      List<Object> parameters=new ArrayList<Object>(parameterSize);\n      int nullBitMapSize=(parameterSize + 7) / 8;\n      for (int i=0; i < nullBitMapSize; i++) {\n        byte null_bits_map=mm.read();\n      }\n// bug_start\n      byte new_bound=mm.read();\n      for (int i=0; i < parameterSize; i++) {\n        byte[] typeArray=mm.readBytes(2);\n      }\n      for (int i=0; i < parameterSize; i++) {\n        byte length=mm.read();\n        byte[] value=mm.readBytes(length);\n        parameters.add(new String(value));\n// bug_end\n      }\n      ((SimpleServerQueryHandler)queryHandler).stmtExecute(stmtId,parameters);\n    }\n else {\n      writeErrMessage(ErrorCode.ER_YES,\"Empty QueryHandler\");\n    }\n  }\n  finally {\n    m_sessionManager.removeSession();\n  }\n}\n"}
{"INPUT": "public Bitmap createIconBitmap(Drawable icon,float scale,int size){\n  Bitmap bitmap=Bitmap.createBitmap(size,size,Bitmap.Config.ARGB_8888);\n// bug_start\n// bug_end\n  mCanvas.setBitmap(bitmap);\n  mOldBounds.set(icon.getBounds());\n  if (ATLEAST_OREO && icon instanceof AdaptiveIconDrawable) {\n    int offset=Math.max((int)Math.ceil(BLUR_FACTOR * size),Math.round(size * (1 - scale) / 2));\n    icon.setBounds(offset,offset,size - offset,size - offset);\n    icon.draw(mCanvas);\n  }\n else {\n    if (icon instanceof BitmapDrawable) {\n      BitmapDrawable bitmapDrawable=(BitmapDrawable)icon;\n      Bitmap b=bitmapDrawable.getBitmap();\n      if (bitmap != null && b.getDensity() == Bitmap.DENSITY_NONE) {\n        bitmapDrawable.setTargetDensity(mContext.getResources().getDisplayMetrics());\n      }\n    }\n    int width=size;\n    int height=size;\n    int intrinsicWidth=icon.getIntrinsicWidth();\n    int intrinsicHeight=icon.getIntrinsicHeight();\n    if (intrinsicWidth > 0 && intrinsicHeight > 0) {\n      final float ratio=(float)intrinsicWidth / intrinsicHeight;\n      if (intrinsicWidth > intrinsicHeight) {\n        height=(int)(width / ratio);\n      }\n else       if (intrinsicHeight > intrinsicWidth) {\n        width=(int)(height * ratio);\n      }\n    }\n    final int left=(size - width) / 2;\n    final int top=(size - height) / 2;\n    icon.setBounds(left,top,left + width,top + height);\n    mCanvas.save();\n    mCanvas.scale(scale,scale,size / 2,size / 2);\n    icon.draw(mCanvas);\n    mCanvas.restore();\n  }\n  icon.setBounds(mOldBounds);\n  mCanvas.setBitmap(null);\n  return bitmap;\n}\n"}
{"INPUT": "@ConsoleCommand(description=\"Delete the specified database\") public void dropDatabase(@ConsoleParameter(name=\"database-url\",description=\"The url of the database to drop in the format '<mode>:<path>'\") String iDatabaseURL,@ConsoleParameter(name=\"user\",description=\"Server administrator name\") String iUserName,@ConsoleParameter(name=\"password\",description=\"Server administrator password\") String iUserPassword) throws IOException {\n  if (iDatabaseURL.startsWith(OEngineRemote.NAME)) {\n    final String dbURL=iDatabaseURL.substring(OEngineRemote.NAME.length() + 1);\n// bug_start\n    new OServerAdmin(dbURL).connect(iUserName,iUserPassword).deleteDatabase();\n// bug_end\n    disconnect();\n  }\n else {\n    currentDatabase=new ODatabaseDocumentTx(iDatabaseURL);\n    currentDatabase.delete();\n    currentDatabase=null;\n  }\n  out.println(\"\\nDatabase '\" + iDatabaseURL + \"' deleted successfully\");\n}\n"}
{"INPUT": "@Override protected Boolean executeOnLocalNode(final OStorageSynchronizer dbSynchronizer){\n// bug_start\n  ODistributedServerLog.info(this,getDistributedServerManager().getLocalNodeId(),getNodeSource(),DIRECTION.IN,\"DELETE RECORD %s/%s v.%s\",databaseName,rid.toString(),version.toString());\n// bug_end\n  final ODatabaseDocumentTx database=openDatabase();\n  try {\n    final ORecordInternal<?> record=database.load(rid);\n    if (record != null) {\n      record.getRecordVersion().copyFrom(version);\n      record.delete();\n      return Boolean.TRUE;\n    }\n    return Boolean.FALSE;\n  }\n  finally {\n    closeDatabase(database);\n  }\n}\n"}
{"INPUT": "static MultiLineStringBuilder createRandomShape(){\n// bug_start\n  if (true) {\n    return new MultiLineStringBuilder();\n  }\n  return (MultiLineStringBuilder)RandomShapeGenerator.createShape(getRandom(),ShapeType.MULTILINESTRING);\n// bug_end\n}\n"}
{"INPUT": "@Override public void serialize(final EntityType model,SerializerConfig serializerConfig,CodeWriter writer) throws IOException {\n  intro(model,writer);\n  String localName=writer.getRawName(model);\n  for (  Constructor c : model.getConstructors()) {\n    writer.beginConstructor(c.getParameters(),new Transformer<Parameter,Parameter>(){\n      @Override public Parameter transform(      Parameter p){\n        return new Parameter(p.getName(),typeMappings.getExprType(p.getType(),model,false,false,true));\n      }\n    }\n);\n    writer.beginLine(\"super(\" + localName + \".class\");\n    writer.append(\", new Class[]{\");\n    boolean first=true;\n    for (    Parameter p : c.getParameters()) {\n      if (!first) {\n        writer.append(\", \");\n      }\n// bug_start\n      if (p.getType().getPrimitiveName() != null) {\n        writer.append(p.getType().getPrimitiveName() + \".class\");\n// bug_end\n      }\n else {\n        writer.append(writer.getRawName(p.getType()));\n        writer.append(\".class\");\n      }\n      first=false;\n    }\n    writer.append(\"}\");\n    for (    Parameter p : c.getParameters()) {\n      writer.append(\", \" + p.getName());\n    }\n    writer.append(\");\\n\");\n    writer.end();\n  }\n  outro(model,writer);\n}\n"}
{"INPUT": "public void test_error_2() throws Exception {\n  JSONObject json=new JSONObject();\n  json.put(\"id\",1);\n  Method method=TypeUtilsTest.class.getMethod(\"f\",List.class);\n// bug_start\n  JSONException error=null;\n  try {\n    TypeUtils.cast(json,method.getGenericParameterTypes()[0],ParserConfig.getGlobalInstance());\n  }\n catch (  JSONException e) {\n    error=e;\n  }\n  Assert.assertNotNull(error);\n// bug_end\n}\n"}
{"INPUT": "@Override public void initDokitViewLayoutParams(DokitViewLayoutParams params){\n// bug_start\n  params.x=UIUtils.getWidthPixels(getContext()) / 2;\n  params.y=UIUtils.getHeightPixels(getContext()) / 2;\n// bug_end\n  params.height=DokitViewLayoutParams.WRAP_CONTENT;\n  params.width=DokitViewLayoutParams.WRAP_CONTENT;\n}\n"}
{"INPUT": "// bug_start\n@RequestMapping(\"publish\") public String publish(String path,String _csrf,HttpServletRequest request,HttpSession session,ModelMap model){\n// bug_end\n  if (ControllerUtils.verifyNotEquals(\"_csrf\",ControllerUtils.getAdminToken(request),_csrf,model)) {\n    return CommonConstants.TEMPLATE_ERROR;\n  }\n  try {\n    SysSite site=getSite(request);\n    publish(site,path);\n    return CommonConstants.TEMPLATE_DONE;\n  }\n catch (  IOException|TemplateException e) {\n    model.addAttribute(CommonConstants.ERROR,e.getMessage());\n    log.error(e.getMessage(),e);\n    return CommonConstants.TEMPLATE_ERROR;\n  }\n}\n"}
{"INPUT": "@Test public void shouldRegisterASingleUri() throws Exception {\n  WebServer webServer=mock(WebServer.class);\n  Map<String,String> params=new HashMap();\n  String path=\"/db/data\";\n  params.put(ServerSettings.rest_api_path.name(),path);\n// bug_start\n  Config config=new Config(params);\n// bug_end\n  Dependencies deps=new Dependencies();\n  deps.satisfyDependency(new UsageData(mock(JobScheduler.class)));\n  Database db=mock(Database.class);\n  RESTApiModule module=new RESTApiModule(webServer,config,deps,NullLogProvider.getInstance());\n  module.start();\n  verify(webServer).addJAXRSClasses(any(List.class),anyString(),anyCollection());\n}\n"}
{"INPUT": "// bug_start\n@AwaitsFix(bugUrl=\"https://github.com/elastic/elasticsearch/issues/53236\") public void testSingleNumericFeatureAndMixedTrainingAndNonTrainingRows() throws Exception {\n// bug_end\n  initialize(\"classification_single_numeric_feature_and_mixed_data_set\");\n  String predictedClassField=KEYWORD_FIELD + \"_prediction\";\n  indexData(sourceIndex,300,50,KEYWORD_FIELD);\n  DataFrameAnalyticsConfig config=buildAnalytics(jobId,sourceIndex,destIndex,null,new Classification(KEYWORD_FIELD,BoostedTreeParams.builder().setNumTopFeatureImportanceValues(1).build(),null,null,null,null,null));\n  registerAnalytics(config);\n  putAnalytics(config);\n  assertIsStopped(jobId);\n  assertProgress(jobId,0,0,0,0);\n  startAnalytics(jobId);\n  waitUntilAnalyticsIsStopped(jobId);\n  client().admin().indices().refresh(new RefreshRequest(destIndex));\n  SearchResponse sourceData=client().prepareSearch(sourceIndex).setTrackTotalHits(true).setSize(1000).get();\n  for (  SearchHit hit : sourceData.getHits()) {\n    Map<String,Object> destDoc=getDestDoc(config,hit);\n    Map<String,Object> resultsObject=getFieldValue(destDoc,\"ml\");\n    assertThat(getFieldValue(resultsObject,predictedClassField),is(in(KEYWORD_FIELD_VALUES)));\n    assertThat(getFieldValue(resultsObject,\"is_training\"),is(destDoc.containsKey(KEYWORD_FIELD)));\n    assertTopClasses(resultsObject,2,KEYWORD_FIELD,KEYWORD_FIELD_VALUES);\n// bug_start\n    assertThat(resultsObject.keySet().stream().filter(null).findAny().isPresent(),is(true));\n// bug_end\n  }\n  assertProgress(jobId,100,100,100,100);\n  assertThat(searchStoredProgress(jobId).getHits().getTotalHits().value,equalTo(1L));\n  assertModelStatePersisted(stateDocId());\n  assertInferenceModelPersisted(jobId);\n  assertMlResultsFieldMappings(destIndex,predictedClassField,\"keyword\");\n  assertThatAuditMessagesMatch(jobId,\"Created analytics with analysis type [classification]\",\"Estimated memory usage for this analytics to be\",\"Starting analytics on node\",\"Started analytics\",expectedDestIndexAuditMessage(),\"Started reindexing to destination index [\" + destIndex + \"]\",\"Finished reindexing to destination index [\" + destIndex + \"]\",\"Started loading data\",\"Started analyzing\",\"Started writing results\",\"Finished analysis\");\n  assertEvaluation(KEYWORD_FIELD,KEYWORD_FIELD_VALUES,\"ml.\" + predictedClassField);\n}\n"}
{"INPUT": "@Before public void setup(){\n  mouseDone=false;\n  mouseSuccess=false;\n  channel=new EmbeddedChannel();\n  writeQueue=new CoalescingBufferQueue(channel,16,true);\n  catPromise=newPromise();\n// bug_start\n  mouseListener=new ChannelFutureListener(){\n    @Override public void operationComplete(    ChannelFuture future) throws Exception {\n      mouseDone=true;\n      mouseSuccess=future.isSuccess();\n    }\n  }\n;\n// bug_end\n  emptyPromise=newPromise();\n  voidPromise=channel.voidPromise();\n  cat=Unpooled.wrappedBuffer(\"cat\".getBytes(CharsetUtil.US_ASCII));\n  mouse=Unpooled.wrappedBuffer(\"mouse\".getBytes(CharsetUtil.US_ASCII));\n}\n"}
{"INPUT": "@Nullable private static Label maybeGetConfiguredTargetCycleCulprit(Label labelToLoad,Iterable<CycleInfo> cycleInfos){\n  for (  CycleInfo cycleInfo : cycleInfos) {\n    SkyKey culprit=Iterables.getFirst(cycleInfo.getCycle(),null);\n    if (culprit == null) {\n      continue;\n    }\n    if (culprit.functionName().equals(SkyFunctions.CONFIGURED_TARGET)) {\n      return ((ConfiguredTargetKey)culprit.argument()).getLabel();\n    }\n// bug_start\n// bug_end\n else {\n      return labelToLoad;\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "public static <T,R>Observable<R> createFrom(Observable<? extends T> source,Func1<? super T,? extends Iterable<? extends R>> mapper,int prefetch){\n  if (source instanceof ScalarSynchronousObservable) {\n    T scalar=((ScalarSynchronousObservable<? extends T>)source).get();\n// bug_start\n    return Observable.create(new OnSubscribeScalarFlattenIterable<T,R>(scalar,mapper));\n// bug_end\n  }\n// bug_start\n  return Observable.create(new OnSubscribeFlattenIterable<T,R>(source,mapper,prefetch));\n// bug_end\n}\n"}
{"INPUT": "private static void parseClassesToLoad(XmlPullParser parser,boolean optional,Collection<Exception> exceptions) throws XmlPullParserException, IOException, Exception {\n  final String startName=parser.getName();\n  int eventType;\n  String name;\n  do {\n    eventType=parser.next();\n    name=parser.getName();\n    if (eventType == XmlPullParser.START_TAG && \"className\".equals(name)) {\n// bug_start\n      if (disabledSmackClasses.contains(name)) {\n        LOGGER.info(\"Not loading disabled Smack class \" + name);\n// bug_end\n      }\n else {\n// bug_start\n        String classToLoad=parser.nextText();\n// bug_end\n        try {\n          loadSmackClass(classToLoad,optional);\n        }\n catch (        Exception e) {\n          if (exceptions != null) {\n            exceptions.add(e);\n          }\n else {\n            throw e;\n          }\n        }\n      }\n    }\n  }\n while (!(eventType == XmlPullParser.END_TAG && startName.equals(name)));\n}\n"}
{"INPUT": "@Nullable public VS toValuesSource(QueryShardContext context) throws IOException {\n  if (!valid()) {\n    throw new IllegalStateException(\"value source config is invalid; must have either a field context or a script or marked as unwrapped\");\n  }\n  final VS vs;\n  if (unmapped()) {\n    if (missing() == null) {\n      vs=null;\n    }\n else     if (valueSourceType() == ValuesSourceType.NUMERIC) {\n      vs=(VS)ValuesSource.Numeric.EMPTY;\n    }\n else     if (valueSourceType() == ValuesSourceType.GEOPOINT) {\n      vs=(VS)ValuesSource.GeoPoint.EMPTY;\n    }\n else     if (valueSourceType() == ValuesSourceType.ANY || valueSourceType() == ValuesSourceType.BYTES) {\n      vs=(VS)ValuesSource.Bytes.WithOrdinals.EMPTY;\n    }\n else {\n      throw new IllegalArgumentException(\"Can't deal with unmapped ValuesSource type \" + valueSourceType());\n    }\n  }\n else {\n    vs=originalValuesSource();\n  }\n  if (missing() == null) {\n    return vs;\n  }\n  if (vs instanceof ValuesSource.Bytes) {\n    final BytesRef missing=format.parseBytesRef(missing().toString());\n    if (vs instanceof ValuesSource.Bytes.WithOrdinals) {\n      return (VS)MissingValues.replaceMissing((ValuesSource.Bytes.WithOrdinals)vs,missing);\n    }\n else {\n      return (VS)MissingValues.replaceMissing((ValuesSource.Bytes)vs,missing);\n    }\n  }\n else   if (vs instanceof ValuesSource.Numeric) {\n    Number missing=format.parseDouble(missing().toString(),false,null);\n    return (VS)MissingValues.replaceMissing((ValuesSource.Numeric)vs,missing);\n  }\n else   if (vs instanceof ValuesSource.GeoPoint) {\n// bug_start\n    final GeoPoint missing=GeoUtils.parseGeoPoint(missing().toString(),new GeoPoint());\n// bug_end\n    return (VS)MissingValues.replaceMissing((ValuesSource.GeoPoint)vs,missing);\n  }\n else {\n    throw new IllegalArgumentException(\"Can't apply missing values on a \" + vs.getClass());\n  }\n}\n"}
{"INPUT": "@Override public void handleMethodException(EnhancedInstance enhancedInstance,Method method,Object[] objects,Class<?>[] classes,Throwable throwable){\n  if (ContextManager.isActive()) {\n// bug_start\n    ContextManager.activeSpan().errorOccurred().log(throwable);\n// bug_end\n  }\n}\n"}
{"INPUT": "public void testDefaultField() throws Exception {\n  assumeTrue(\"test runs only when at least a type is registered\",getCurrentTypes().length > 0);\n  QueryShardContext context=createShardContext();\n// bug_start\n  context.getIndexSettings().updateIndexMetaData(newIndexMeta(\"index\",context.getIndexSettings().getSettings(),Settings.builder().putArray(\"index.query.default_field\",STRING_FIELD_NAME,STRING_FIELD_NAME_2 + \"^5\").build()));\n// bug_end\n  Query query=new QueryStringQueryBuilder(\"hello\").toQuery(context);\n  Query expected=new DisjunctionMaxQuery(Arrays.asList(new TermQuery(new Term(STRING_FIELD_NAME,\"hello\")),new BoostQuery(new TermQuery(new Term(STRING_FIELD_NAME_2,\"hello\")),5.0f)),0.0f);\n  assertEquals(expected,query);\n// bug_start\n  context.getIndexSettings().updateIndexMetaData(newIndexMeta(\"index\",context.getIndexSettings().getSettings(),Settings.builder().putArray(\"index.query.default_field\",\"*\").build()));\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Override public ValueFetcher valueFetcher(MapperService mapperService,SearchLookup lookup,String format){\n// bug_end\n  throw new UnsupportedOperationException(\"Cannot fetch values for internal field [\" + name() + \"].\");\n}\n"}
{"INPUT": "// bug_start\nprivate OptionalInt toBucketNumber(ConnectorPartitionHandle partitionHandle){\n// bug_end\n  if (partitionHandle == NOT_PARTITIONED) {\n    return OptionalInt.empty();\n  }\n  return OptionalInt.of(((HivePartitionHandle)partitionHandle).getBucket());\n}\n"}
{"INPUT": "void document(PrintWriter writer){\n// bug_start\n  docRowStart(writer);\n  writer.println(\"<td colspan=\" + (maxStructIndent - structIndent) + \">\");\n  writer.println(docType() + \"<td><i>\" + name()+ \"</i><td>\"+ comment()+ \"&nbsp;\");\n// bug_end\n}\n"}
{"INPUT": "// bug_start\npublic Client testClassname(Client client) throws RestClientException {\n  Object postBody=client;\n  if (client == null) {\n    throw new HttpClientErrorException(HttpStatus.BAD_REQUEST,\"Missing the required parameter 'client' when calling testClassname\");\n// bug_end\n  }\n  String path=UriComponentsBuilder.fromPath(\"/fake_classname_test\").build().toUriString();\n  final MultiValueMap<String,String> queryParams=new LinkedMultiValueMap<String,String>();\n  final HttpHeaders headerParams=new HttpHeaders();\n  final MultiValueMap<String,Object> formParams=new LinkedMultiValueMap<String,Object>();\n  final String[] accepts={\"application/json\"};\n  final List<MediaType> accept=apiClient.selectHeaderAccept(accepts);\n  final String[] contentTypes={\"application/json\"};\n  final MediaType contentType=apiClient.selectHeaderContentType(contentTypes);\n  String[] authNames=new String[]{\"api_key_query\"};\n  ParameterizedTypeReference<Client> returnType=new ParameterizedTypeReference<Client>(){\n  }\n;\n  return apiClient.invokeAPI(path,HttpMethod.PATCH,queryParams,postBody,headerParams,formParams,accept,contentType,authNames,returnType);\n}\n"}
{"INPUT": "@Override public RawResponseTime mapRow(Result result,int rowNum) throws Exception {\n  if (result.isEmpty()) {\n    return null;\n  }\n  final byte[] rowKey=result.getRow();\n  RawResponseTime rawResponseTime=createRawResponseTime(rowKey);\n  for (  KeyValue keyValue : result.raw()) {\n// bug_start\n    if (!Bytes.equals(keyValue.getFamily(),HBaseTables.APPLICATION_MAP_STATISTICS_SELF_CF_COUNTER)) {\n      return rawResponseTime;\n// bug_end\n    }\n    byte[] qualifier=keyValue.getQualifier();\n    byte[] value=keyValue.getValue();\n    recordColumn(rawResponseTime,qualifier,value);\n  }\n  return rawResponseTime;\n}\n"}
{"INPUT": "// bug_start\n@Override public void writeString(int fieldNumber,String value,boolean repeated) throws IOException {\n  byte[] strbytes=value.getBytes(\"UTF-8\");\n// bug_end\n  writeByteArray(fieldNumber,strbytes,repeated);\n}\n"}
{"INPUT": "@Override public void evaluated(SkyKey skyKey,@Nullable SkyValue value,Supplier<EvaluationSuccessState> evaluationSuccessState,EvaluationState state){\n  SkyFunctionName type=skyKey.functionName();\n  if (type.equals(SkyFunctions.TARGET_COMPLETION)) {\n    if (evaluationSuccessState.get().succeeded()) {\n// bug_start\n      builtTargets.add(((TargetCompletionValue.TargetCompletionKey)skyKey).configuredTargetKey());\n// bug_end\n    }\n  }\n else   if (type.equals(SkyFunctions.ASPECT_COMPLETION)) {\n    if (evaluationSuccessState.get().succeeded()) {\n// bug_start\n      builtAspects.add(((AspectCompletionValue.AspectCompletionKey)skyKey).aspectKey());\n// bug_end\n    }\n  }\n else   if (type.equals(SkyFunctions.ACTION_EXECUTION)) {\n    actionCompleted((ActionLookupData)skyKey.argument());\n  }\n}\n"}
{"INPUT": "@Test public void test_simple_scope(){\n  Ioc2 ioc=I(J(\"f1\",\"scope:'app',fields:{name:'F1'}\"),J(\"f2\",\"scope:'MyScope',fields:{name:'F2'}\"));\n  Animal f1=ioc.get(Animal.class,\"f1\");\n  assertEquals(\"F1\",f1.getName());\n  Animal f2=ioc.get(Animal.class,\"f2\");\n  assertEquals(\"F2\",f2.getName());\n  Animal f22=ioc.get(Animal.class,\"f2\");\n  assertEquals(\"F2\",f22.getName());\n  assertFalse(f2 == f22);\n  ScopeContext ic=new ScopeContext(\"MyScope\");\n  Map<String,ObjectProxy> map=ic.getObjs();\n  f2=ioc.get(Animal.class,\"f2\",ic);\n  assertEquals(\"F2\",f2.getName());\n  f22=ioc.get(Animal.class,\"f2\",ic);\n  assertEquals(\"F2\",f22.getName());\n  assertTrue(f2 == f22);\n  assertEquals(1,map.size());\n// bug_start\n  f1=ioc.get(Animal.class,\"f1\",ic);\n// bug_end\n  assertEquals(1,map.size());\n}\n"}
{"INPUT": "// bug_start\npublic void testTimeFields() throws Exception {\n// bug_end\n  PutWatchResponse putWatchResponse=new PutWatchRequestBuilder(client(),\"_id\").setSource(watchBuilder().trigger(schedule(interval(\"5s\"))).input(simpleInput()).condition(InternalAlwaysCondition.INSTANCE).addAction(\"_logging\",loggingAction(\"foobar\"))).get();\n  assertThat(putWatchResponse.isCreated(),is(true));\n  timeWarp().trigger(\"_id\");\n  assertWatchWithMinimumActionsCount(\"_id\",ExecutionState.EXECUTED,1);\n  assertBusy(null);\n}\n"}
{"INPUT": "// bug_start\nprivate double getValFromUpperTriangularMatrix(Map<String,HashMap<String,Double>> map,String fieldX,String fieldY){\n// bug_end\n  if (map.containsKey(fieldX) == false && map.containsKey(fieldY) == false) {\n    throw new IllegalArgumentException(\"neither field \" + fieldX + \" nor \"+ fieldY+ \" exist\");\n  }\n else   if (map.containsKey(fieldX)) {\n    if (map.get(fieldX).containsKey(fieldY)) {\n      return map.get(fieldX).get(fieldY);\n    }\n else {\n      return map.get(fieldY).get(fieldX);\n    }\n  }\n else   if (map.containsKey(fieldY)) {\n    return map.get(fieldY).get(fieldX);\n  }\n  throw new IllegalArgumentException(\"Coefficient not computed between fields: \" + fieldX + \" and \"+ fieldY);\n}\n"}
{"INPUT": "@Test public void testInfo(){\n  HMaster master=TEST_UTIL.getHBaseCluster().getMaster();\n  MetricsMasterWrapperImpl info=new MetricsMasterWrapperImpl(master);\n// bug_start\n  assertEquals(master.getSplitPlanCount(),info.getSplitPlanCount(),0);\n  assertEquals(master.getMergePlanCount(),info.getMergePlanCount(),0);\n// bug_end\n  assertEquals(master.getAverageLoad(),info.getAverageLoad(),0);\n  assertEquals(master.getClusterId(),info.getClusterId());\n  assertEquals(master.getMasterActiveTime(),info.getActiveTime());\n  assertEquals(master.getMasterStartTime(),info.getStartTime());\n  assertEquals(master.getMasterCoprocessors().length,info.getCoprocessors().length);\n  assertEquals(master.getServerManager().getOnlineServersList().size(),info.getNumRegionServers());\n  int regionServerCount=NUM_RS + (LoadBalancer.isTablesOnMaster(TEST_UTIL.getConfiguration()) ? 1 : 0);\n  assertEquals(regionServerCount,info.getNumRegionServers());\n  String zkServers=info.getZookeeperQuorum();\n  assertEquals(zkServers.split(\",\").length,TEST_UTIL.getZkCluster().getZooKeeperServerNum());\n  final int index=3;\n  LOG.info(\"Stopping \" + TEST_UTIL.getMiniHBaseCluster().getRegionServer(index));\n  TEST_UTIL.getMiniHBaseCluster().stopRegionServer(index,false);\n  TEST_UTIL.getMiniHBaseCluster().waitOnRegionServer(index);\n  while (TEST_UTIL.getHBaseCluster().getMaster().getServerManager().getOnlineServers().size() == regionServerCount) {\n    Threads.sleep(10);\n  }\n  assertEquals(regionServerCount - 1,info.getNumRegionServers());\n  assertEquals(1,info.getNumDeadRegionServers());\n  assertEquals(0,info.getNumWALFiles());\n}\n"}
{"INPUT": "static final boolean isDocStoreFile(String fileName){\n// bug_start\n// bug_end\n  for (int i=0; i < STORE_INDEX_EXTENSIONS.length; i++)   if (fileName.endsWith(STORE_INDEX_EXTENSIONS[i]))   return true;\n  return false;\n}\n"}
{"INPUT": "@Override public void init(){\n  registerBeanDefinitionParser(\"config\",new HazelcastConfigBeanDefinitionParser());\n  registerBeanDefinitionParser(\"hazelcast\",new HazelcastInstanceDefinitionParser());\n  registerBeanDefinitionParser(\"client\",new HazelcastClientBeanDefinitionParser());\n  registerBeanDefinitionParser(\"hibernate-region-factory\",new RegionFactoryBeanDefinitionParser());\n  registerBeanDefinitionParser(\"cache-manager\",new CacheManagerBeanDefinitionParser());\n// bug_start\n  String[] types={\"map\",\"multiMap\",\"replicatedMap\",\"queue\",\"topic\",\"set\",\"list\",\"executorService\",\"durableExecutorService\",\"scheduledExecutorService\",\"ringBuffer\",\"cardinalityEstimator\",\"idGenerator\",\"flakeIdGenerator\",\"atomicLong\",\"atomicReference\",\"countDownLatch\",\"semaphore\",\"lock\"};\n// bug_end\n  for (  String type : types) {\n    registerBeanDefinitionParser(type,new HazelcastTypeBeanDefinitionParser(type));\n  }\n}\n"}
{"INPUT": "@SuppressWarnings({\"WeakerAccess\",\"unchecked\"}) void handleCallComplete(MediaPlayer2 mp,final MediaItem item,int what,int status){\n  PendingCommand expected;\nsynchronized (mPendingCommands) {\n    expected=mPendingCommands.pollFirst();\n  }\n  if (expected == null) {\n    Log.i(TAG,\"No matching call type for \" + what + \". Possibly because of reset().\");\n    return;\n  }\n  final TrackInfo trackInfo=expected.mTrackInfo;\n  if (what != expected.mCallType) {\n    Log.w(TAG,\"Call type does not match. expeced:\" + expected.mCallType + \" actual:\"+ what);\n    status=MediaPlayer2.CALL_STATUS_ERROR_UNKNOWN;\n  }\n  if (status == MediaPlayer2.CALL_STATUS_NO_ERROR) {\nswitch (what) {\ncase MediaPlayer2.CALL_COMPLETED_PREPARE:\ncase MediaPlayer2.CALL_COMPLETED_PAUSE:\n      setState(PLAYER_STATE_PAUSED);\n    break;\ncase MediaPlayer2.CALL_COMPLETED_PLAY:\n  setState(PLAYER_STATE_PLAYING);\nbreak;\ncase MediaPlayer2.CALL_COMPLETED_SEEK_TO:\nfinal long pos=getCurrentPosition();\nnotifySessionPlayerCallback(new SessionPlayerCallbackNotifier(){\n@Override public void callCallback(SessionPlayer.PlayerCallback callback){\ncallback.onSeekCompleted(MediaPlayer.this,pos);\n}\n}\n);\nbreak;\ncase MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE:\n// bug_start\n// bug_end\nnotifySessionPlayerCallback(new SessionPlayerCallbackNotifier(){\n@Override public void callCallback(SessionPlayer.PlayerCallback callback){\ncallback.onCurrentMediaItemChanged(MediaPlayer.this,item);\n}\n}\n);\nbreak;\ncase MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS:\nfinal float speed=mPlayer.getPlaybackParams().getSpeed();\nnotifySessionPlayerCallback(new SessionPlayerCallbackNotifier(){\n@Override public void callCallback(SessionPlayer.PlayerCallback callback){\ncallback.onPlaybackSpeedChanged(MediaPlayer.this,speed);\n}\n}\n);\nbreak;\ncase MediaPlayer2.CALL_COMPLETED_SET_AUDIO_ATTRIBUTES:\nfinal AudioAttributesCompat attr=mPlayer.getAudioAttributes();\nnotifySessionPlayerCallback(new SessionPlayerCallbackNotifier(){\n@Override public void callCallback(SessionPlayer.PlayerCallback callback){\ncallback.onAudioAttributesChanged(MediaPlayer.this,attr);\n}\n}\n);\nbreak;\ncase MediaPlayer2.CALL_COMPLETED_SELECT_TRACK:\nnotifySessionPlayerCallback(new SessionPlayerCallbackNotifier(){\n@Override public void callCallback(SessionPlayer.PlayerCallback callback){\ncallback.onTrackSelected(MediaPlayer.this,createTrackInfoInternal(trackInfo));\n}\n}\n);\nbreak;\ncase MediaPlayer2.CALL_COMPLETED_DESELECT_TRACK:\nnotifySessionPlayerCallback(new SessionPlayerCallbackNotifier(){\n@Override public void callCallback(SessionPlayer.PlayerCallback callback){\ncallback.onTrackDeselected(MediaPlayer.this,createTrackInfoInternal(trackInfo));\n}\n}\n);\nbreak;\n}\n}\nif (what != MediaPlayer2.CALL_COMPLETED_PREPARE_DRM) {\nInteger resultCode=sResultCodeMap.containsKey(status) ? sResultCodeMap.get(status) : RESULT_ERROR_UNKNOWN;\nexpected.mFuture.set(new PlayerResult(resultCode,item));\n}\n else {\nInteger resultCode=sPrepareDrmStatusMap.containsKey(status) ? sPrepareDrmStatusMap.get(status) : DrmResult.RESULT_ERROR_PREPARATION_ERROR;\nexpected.mFuture.set(new DrmResult(resultCode,item));\n}\nexecutePendingFutures();\n}\n"}
{"INPUT": "// bug_start\n@Test public void testFindByClusterAndCommandCriteriaNoCriteria(){\n// bug_end\n  final Specification<ClusterEntity> spec=JpaClusterSpecs.findByClusterAndCommandCriteria(null,null);\n  spec.toPredicate(this.root,this.cq,this.cb);\n  Mockito.verify(this.cq,Mockito.times(1)).distinct(true);\n  Mockito.verify(this.commands,Mockito.times(1)).get(CommandEntity_.status);\n  Mockito.verify(this.cb,Mockito.times(1)).equal(this.commands.get(CommandEntity_.status),CommandStatus.ACTIVE);\n  Mockito.verify(this.root,Mockito.times(1)).get(ClusterEntity_.status);\n  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(ClusterEntity_.status),ClusterStatus.UP);\n  Mockito.verify(this.cb,Mockito.never()).isMember(Mockito.any(String.class),Mockito.any(Expression.class));\n}\n"}
{"INPUT": "// bug_start\n@Override public Object evaluate(Object... args){\n// bug_end\n  if (args.length != 2) {\n    throw new KsqlFunctionException(\"IfNull udf should have two input argument.\");\n  }\n  if (args[0] == null) {\n    return args[1];\n  }\n else {\n    return args[0];\n  }\n}\n"}
{"INPUT": "private void initAssetManager(){\n  if (settings != null) {\n    String assetCfg=settings.getString(\"AssetConfigURL\");\n    if (assetCfg != null) {\n      URL url=null;\n      try {\n        url=new URL(assetCfg);\n      }\n catch (      MalformedURLException ex) {\n      }\n      if (url == null) {\n// bug_start\n        url=Application.class.getResource(assetCfg);\n// bug_end\n        if (url == null) {\n          logger.log(Level.SEVERE,\"Unable to access AssetConfigURL in asset config:{0}\",assetCfg);\n          return;\n        }\n      }\n      assetManager=JmeSystem.newAssetManager(url);\n    }\n  }\n  if (assetManager == null) {\n    assetManager=JmeSystem.newAssetManager(Thread.currentThread().getContextClassLoader().getResource(\"com/jme3/asset/Desktop.cfg\"));\n  }\n}\n"}
{"INPUT": "@Before public void setUp(){\n// bug_start\n  this.mutableList=Lists.mutable.<String>of(METALLICA,\"Bon Jovi\",\"Europe\",\"Scorpions\");\n// bug_end\n  this.unmodifiableList=UnmodifiableMutableList.of(this.mutableList);\n}\n"}
{"INPUT": "protected void doTest(String pathSuffix){\n// bug_start\n  myFixture.configureByFile(getBasePath() + pathSuffix + getTestName(true)+ \".java\");\n// bug_end\n  myFixture.type('\\t');\n// bug_start\n  myFixture.checkResultByFile(getBasePath() + pathSuffix + getTestName(true)+ \"_after.java\",true);\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Test public void nonAsciiPasswordHasCorrectHash(){\n// bug_end\n  Md5PasswordEncoder md5=new Md5PasswordEncoder();\n  String encodedPassword=md5.encodePassword(\"\\u4F60\\u597d\",null);\n  assertEquals(\"7eca689f0d3389d9dea66ae112e5cfd7\",encodedPassword);\n}\n"}
{"INPUT": "@Override public Object call(ODistributedConfiguration cfg){\n  ODistributedServerLog.info(this,nodeName,null,DIRECTION.NONE,\"Current node started as %s for database '%s'\",cfg.getServerRole(nodeName),databaseName);\n// bug_start\n  if (!configurationMap.containsKey(CONFIG_DATABASE_PREFIX + databaseName))   updateCachedDatabaseConfiguration(databaseName,cfg.getDocument(),false,true);\n// bug_end\n  final ODistributedDatabaseImpl ddb=messageService.registerDatabase(databaseName);\n  cfg.addNewNodeInServerList(nodeName);\n  final Set<String> clustersWithNotAvailableOwner=new HashSet<String>();\n  final Set<String> servers=cfg.getAllConfiguredServers();\n  for (  String server : servers) {\n    if (!nodeName.equals(server)) {\n      clustersWithNotAvailableOwner.addAll(cfg.getClustersOwnedByServer(server));\n    }\n  }\n  if (reassignClustersOwnership(nodeName,databaseName,clustersWithNotAvailableOwner,false))   updateCachedDatabaseConfiguration(databaseName,cfg.getDocument(),true,true);\n  ddb.setOnline();\n  return null;\n}\n"}
{"INPUT": "@Override CapturingFuncRefNode write(){\n  CapturingFuncRefNode capturingFuncRefNode=new CapturingFuncRefNode();\n  capturingFuncRefNode.setLocation(location);\n  capturingFuncRefNode.setExpressionType(actual);\n// bug_start\n  capturingFuncRefNode.setCaptured(captured);\n// bug_end\n  capturingFuncRefNode.setName(call);\n  capturingFuncRefNode.setPointer(defPointer);\n  capturingFuncRefNode.setFuncRef(ref);\n  ;\n  return capturingFuncRefNode;\n}\n"}
{"INPUT": "@Test public void nestedRetriesShouldWork() throws Exception {\n  Supplier<Backoff> s=null;\n  Retrier r=new Retrier(s,RETRY_ALL,retryService,alwaysOpen);\n  AtomicInteger attemptsLvl0=new AtomicInteger();\n  AtomicInteger attemptsLvl1=new AtomicInteger();\n  AtomicInteger attemptsLvl2=new AtomicInteger();\n  try {\n    r.execute(null);\n  }\n catch (  RetryException outer) {\n    assertThat(outer.getAttempts()).isEqualTo(2);\n// bug_start\n    assertThat(outer).hasCauseThat().hasMessageThat().isEqualTo(\"call failed\");\n// bug_end\n    assertThat(attemptsLvl0.get()).isEqualTo(2);\n    assertThat(attemptsLvl1.get()).isEqualTo(4);\n    assertThat(attemptsLvl2.get()).isEqualTo(8);\n  }\n}\n"}
{"INPUT": "public static Object fromJava(Object o){\n// bug_start\n  if (o instanceof Function) {\n// bug_end\n    return o;\n  }\n else   if (o instanceof List) {\n    return new JsList((List)o);\n  }\n else   if (o instanceof Map) {\n    return new JsMap((Map)o);\n  }\n else   if (o instanceof Node) {\n    return new JsXml((Node)o);\n  }\n else {\n    return o;\n  }\n}\n"}
{"INPUT": "private void installApp(){\n  String apkUrl=mUpdateApp.getApkFileUrl();\n  final String appName=apkUrl.substring(apkUrl.lastIndexOf(\"/\") + 1,apkUrl.length());\n  File appFile=new File(mUpdateApp.getTargetPath().concat(File.separator + mUpdateApp.getNewVersion()).concat(File.separator + appName));\n  if (!TextUtils.isEmpty(mUpdateApp.getNewMd5()) && appFile.exists() && Md5Util.getFileMD5(appFile).equalsIgnoreCase(mUpdateApp.getNewMd5())) {\n    Uri fileUri=FileProvider.getUriForFile(this,getApplicationContext().getPackageName() + \".fileProvider\",appFile);\n    Intent intent=new Intent(Intent.ACTION_VIEW);\n    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n      intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n      intent.setDataAndType(fileUri,\"application/vnd.android.package-archive\");\n    }\n else {\n      intent.setDataAndType(Uri.fromFile(appFile),\"application/vnd.android.package-archive\");\n    }\n    if (getPackageManager().queryIntentActivities(intent,0).size() > 0) {\n      startActivity(intent);\n    }\n    onBackPressed();\n  }\n else {\n    downloadApp();\n// bug_start\n// bug_end\n  }\n}\n"}
{"INPUT": "public static Vector toVector(INDArray arr){\n  if (!arr.isVector()) {\n    throw new IllegalArgumentException(\"passed in array must be a vector\");\n  }\n// bug_start\n  return Vectors.dense(arr.data().asDouble());\n// bug_end\n}\n"}
{"INPUT": "public EffectFilterAdapter(Context context,List<FilterType> filterTypes,List<String> filterNames){\n  mContext=context;\n  mFilterTypes=filterTypes;\n  mFilterNames=filterNames;\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "// bug_start\npublic static Object typeConvert(String tableName,String columnName,String value,int sqlType,String mysqlType){\n// bug_end\n  if (value == null || value.equals(\"\")) {\n    return null;\n  }\n  try {\n    Object res;\nswitch (sqlType) {\ncase Types.INTEGER:\n      res=Integer.parseInt(value);\n    break;\ncase Types.SMALLINT:\n  res=Short.parseShort(value);\nbreak;\ncase Types.BIT:\ncase Types.TINYINT:\nres=Byte.parseByte(value);\nbreak;\ncase Types.BIGINT:\nif (mysqlType.startsWith(\"bigint\") && mysqlType.endsWith(\"unsigned\")) {\nres=new BigInteger(value);\n}\n else {\nres=Long.parseLong(value);\n}\nbreak;\ncase Types.BOOLEAN:\nres=!\"0\".equals(value);\nbreak;\ncase Types.DOUBLE:\ncase Types.FLOAT:\nres=Double.parseDouble(value);\nbreak;\ncase Types.REAL:\nres=Float.parseFloat(value);\nbreak;\ncase Types.DECIMAL:\ncase Types.NUMERIC:\nres=new BigDecimal(value);\nbreak;\ncase Types.BINARY:\ncase Types.VARBINARY:\ncase Types.LONGVARBINARY:\ncase Types.BLOB:\nres=value.getBytes(\"ISO-8859-1\");\nbreak;\ncase Types.DATE:\nif (!value.startsWith(\"0000-00-00\")) {\nvalue=value.trim().replace(\" \",\"T\");\nDateTime dt=new DateTime(value);\nres=new Date(dt.toDate().getTime());\n}\n else {\nres=null;\n}\nbreak;\ncase Types.TIME:\nvalue=\"T\" + value;\nDateTime dt=new DateTime(value);\nres=new Time(dt.toDate().getTime());\nbreak;\ncase Types.TIMESTAMP:\nif (!value.startsWith(\"0000-00-00\")) {\nvalue=value.trim().replace(\" \",\"T\");\ndt=new DateTime(value);\nres=new Timestamp(dt.toDate().getTime());\n}\n else {\nres=null;\n}\nbreak;\ncase Types.CLOB:\ndefault :\nres=value;\n}\nreturn res;\n}\n catch (Exception e) {\n// bug_start\nlogger.error(\"table: {} column: {}, failed convert type {} to {}\",tableName,columnName,value,sqlType);\n// bug_end\nreturn value;\n}\n}\n"}
{"INPUT": "private UndertowWebServer.Port getPortFromChannel(BoundChannel channel){\n  SocketAddress socketAddress=channel.getLocalAddress();\n  if (socketAddress instanceof InetSocketAddress) {\n    Field sslField=ReflectionUtils.findField(channel.getClass(),\"ssl\");\n// bug_start\n    String protocol=(sslField != null ? \"https\" : \"http\");\n// bug_end\n    return new UndertowWebServer.Port(((InetSocketAddress)socketAddress).getPort(),protocol);\n  }\n  return null;\n}\n"}
{"INPUT": "protected void parseName(String author){\n  Vector<String> v=new Vector<String>();\n// bug_start\n  String authorMod=AuthorList.fixAuthor_firstNameFirst(author);\n// bug_end\n  XMLChars xmlChars=new XMLChars();\n// bug_start\n  authorMod=xmlChars.format(authorMod);\n  WSITools.tokenize(v,authorMod,\" \\n\\r\");\n// bug_end\n  int amountOfNames=v.size();\n  if (amountOfNames == 1)   surname=v.get(0);\n else   if (amountOfNames == 2) {\n    givenName=v.get(0);\n    surname=v.get(1);\n  }\n else {\n    givenName=v.get(0);\n    middleName=\"\";\n    for (int i=1; i < amountOfNames - 1; i++)     middleName+=\" \" + v.get(i);\n    middleName=middleName.trim();\n    surname=v.get(amountOfNames - 1);\n  }\n}\n"}
{"INPUT": "// bug_start\n@CheckForNull public PermissionTemplateDto selectTemplateById(Long templateId){\n// bug_end\n  SqlSession session=myBatis.openSession();\n  try {\n    PermissionTemplateMapper mapper=session.getMapper(PermissionTemplateMapper.class);\n// bug_start\n    return mapper.selectById(templateId);\n// bug_end\n  }\n  finally {\n    MyBatis.closeQuietly(session);\n  }\n}\n"}
{"INPUT": "public void setContent(final IMetaMember member){\n  offsetMismatchDetected=false;\n  instructions.clear();\n  ClassBC metaClassBytecode=member.getMetaClass().getClassBytecode();\n  if (metaClassBytecode != null) {\n    MemberBytecode memberBytecode=metaClassBytecode.getMemberBytecode(member);\n    if (memberBytecode != null) {\n// bug_start\n      instructions=memberBytecode.getInstructions();\n// bug_end\n    }\n  }\n  BytecodeAnnotations bcAnnotations=null;\n  lineAnnotations.clear();\n  lastScrollIndex=-1;\n  List<Label> labels=new ArrayList<>();\n  if (instructions != null && instructions.size() > 0) {\n    try {\n      bcAnnotations=new BytecodeAnnotationBuilder().buildBytecodeAnnotations(member,model);\n    }\n catch (    AnnotationException annoEx) {\n      logger.error(\"class bytecode mismatch: {}\",annoEx.getMessage());\n      logger.error(\"Member was {}\",member);\n      offsetMismatchDetected=true;\n    }\n    int maxOffset=instructions.get(instructions.size() - 1).getOffset();\n    int lineIndex=0;\n    for (    final BytecodeInstruction instruction : instructions) {\n      int labelLines=instruction.getLabelLines();\n      if (labelLines == 0) {\n        BytecodeLabel lblLine=createLabel(instruction,maxOffset,0,bcAnnotations,member,lineIndex++);\n        labels.add(lblLine);\n      }\n else {\n        for (int i=0; i < labelLines; i++) {\n          BytecodeLabel lblLine=createLabel(instruction,maxOffset,i,bcAnnotations,member,lineIndex++);\n          labels.add(lblLine);\n        }\n      }\n    }\n  }\n  setContent(labels);\n  checkIfExistingSuggestionForMember(member);\n}\n"}
{"INPUT": "public boolean listenerStart(){\n  if (log.isDebugEnabled())   log.debug(\"Configuring application event listeners\");\n  String listeners[]=findApplicationListeners();\n  Object results[]=new Object[listeners.length];\n  boolean ok=true;\n  for (int i=0; i < results.length; i++) {\n    if (getLogger().isDebugEnabled())     getLogger().debug(\" Configuring event listener class '\" + listeners[i] + \"'\");\n    try {\n      results[i]=instanceManager.newInstance(listeners[i]);\n    }\n// bug_start\n catch (    Throwable t) {\n// bug_end\n      getLogger().error(sm.getString(\"standardContext.applicationListener\",listeners[i]),t);\n      ok=false;\n    }\n  }\n  if (!ok) {\n    getLogger().error(sm.getString(\"standardContext.applicationSkipped\"));\n    return (false);\n  }\n  ArrayList<Object> eventListeners=new ArrayList<Object>();\n  ArrayList<Object> lifecycleListeners=new ArrayList<Object>();\n  for (int i=0; i < results.length; i++) {\n    if ((results[i] instanceof ServletContextAttributeListener) || (results[i] instanceof ServletRequestAttributeListener) || (results[i] instanceof ServletRequestListener)|| (results[i] instanceof HttpSessionAttributeListener)) {\n      eventListeners.add(results[i]);\n    }\n    if ((results[i] instanceof ServletContextListener) || (results[i] instanceof HttpSessionListener)) {\n      lifecycleListeners.add(results[i]);\n    }\n  }\n  setApplicationEventListeners(eventListeners.toArray());\n  setApplicationLifecycleListeners(lifecycleListeners.toArray());\n  if (getLogger().isDebugEnabled())   getLogger().debug(\"Sending application start events\");\n  Object instances[]=getApplicationLifecycleListeners();\n  if (instances == null)   return (ok);\n  ServletContextEvent event=new ServletContextEvent(getServletContext());\n  for (int i=0; i < instances.length; i++) {\n    if (instances[i] == null)     continue;\n    if (!(instances[i] instanceof ServletContextListener))     continue;\n    ServletContextListener listener=(ServletContextListener)instances[i];\n    try {\n      fireContainerEvent(\"beforeContextInitialized\",listener);\n      listener.contextInitialized(event);\n      fireContainerEvent(\"afterContextInitialized\",listener);\n    }\n catch (    Throwable t) {\n      fireContainerEvent(\"afterContextInitialized\",listener);\n      getLogger().error(sm.getString(\"standardContext.listenerStart\",instances[i].getClass().getName()),t);\n      ok=false;\n    }\n  }\n  return (ok);\n}\n"}
{"INPUT": "@Test public void testJustAndRetry() throws Exception {\n  final AtomicBoolean throwException=new AtomicBoolean(true);\n  int value=Observable.just(1).map(new Function<Integer,Integer>(){\n    @Override public Integer apply(    Integer t1){\n      if (throwException.compareAndSet(true,false)) {\n        throw new TestException();\n      }\n      return t1;\n    }\n  }\n// bug_start\n).retry(1).toBlocking().single();\n// bug_end\n  assertEquals(1,value);\n}\n"}
{"INPUT": "public void popFromActivityStack(Activity activity){\n  if (sReminderDialog != null && sReminderDialog.getContext() == activity) {\n    try {\n      sReminderDialog.dismiss();\n// bug_start\n// bug_end\n    }\n catch (    Throwable e) {\n    }\n  }\n  for (int x=0; x < activityList.size(); x++) {\n    WeakReference<Activity> ref=activityList.get(x);\n    if (ref != null && ref.get() != null && ref.get() == activity) {\n      activityList.remove(ref);\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\npublic static List<InclusiveByteRange> satisfiableRanges(Enumeration headers,long size){\n// bug_end\n  Object satRanges=null;\n  headers:   while (headers.hasMoreElements()) {\n// bug_start\n    String header=(String)headers.nextElement();\n// bug_end\n    StringTokenizer tok=new StringTokenizer(header,\"=,\",false);\n    String t=null;\n    try {\n      while (tok.hasMoreTokens()) {\n        try {\n          t=tok.nextToken().trim();\n          long first=-1;\n          long last=-1;\n          int d=t.indexOf('-');\n          if (d < 0 || t.indexOf(\"-\",d + 1) >= 0) {\n            if (\"bytes\".equals(t))             continue;\n            LOG.warn(\"Bad range format: {}\",t);\n            continue headers;\n          }\n else           if (d == 0) {\n            if (d + 1 < t.length())             last=Long.parseLong(t.substring(d + 1).trim());\n else {\n              LOG.warn(\"Bad range format: {}\",t);\n              continue;\n            }\n          }\n else           if (d + 1 < t.length()) {\n            first=Long.parseLong(t.substring(0,d).trim());\n            last=Long.parseLong(t.substring(d + 1).trim());\n          }\n else           first=Long.parseLong(t.substring(0,d).trim());\n          if (first == -1 && last == -1)           continue headers;\n          if (first != -1 && last != -1 && (first > last))           continue headers;\n          if (first < size) {\n            InclusiveByteRange range=new InclusiveByteRange(first,last);\n            satRanges=LazyList.add(satRanges,range);\n          }\n        }\n catch (        NumberFormatException e) {\n          LOG.warn(\"Bad range format: {}\",t);\n          LOG.ignore(e);\n          continue;\n        }\n      }\n    }\n catch (    Exception e) {\n      LOG.warn(\"Bad range format: {}\",t);\n      LOG.ignore(e);\n    }\n  }\n  return LazyList.getList(satRanges,true);\n}\n"}
{"INPUT": "@NonNull @Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"[\");\n  sb.append(ImsConferenceState.class.getSimpleName());\n  sb.append(\" \");\n  if (mParticipants.size() > 0) {\n    Set<Entry<String,Bundle>> entries=mParticipants.entrySet();\n    if (entries != null) {\n      Iterator<Entry<String,Bundle>> iterator=entries.iterator();\n      sb.append(\"<\");\n      while (iterator.hasNext()) {\n        Entry<String,Bundle> entry=iterator.next();\n        sb.append(Rlog.pii(TAG,entry.getKey()));\n        sb.append(\": \");\n        Bundle participantData=entry.getValue();\n        for (        String key : participantData.keySet()) {\n          sb.append(key);\n          sb.append(\"=\");\n// bug_start\n          if (ENDPOINT.equals(key) || USER.equals(key)) {\n            sb.append(Rlog.pii(TAG,participantData.get(key)));\n// bug_end\n          }\n else {\n// bug_start\n            sb.append(participantData.get(key));\n// bug_end\n          }\n          sb.append(\", \");\n        }\n      }\n      sb.append(\">\");\n    }\n  }\n  sb.append(\"]\");\n  return sb.toString();\n}\n"}
{"INPUT": "@Test public void testHealth(){\n  Node node1=startNode(\"node1\");\n  logger.info(\"--> running cluster health on an index that does not exists\");\n  ClusterHealthResponse healthResponse=node1.client().admin().cluster().prepareHealth(\"test\").setWaitForYellowStatus().setTimeout(\"1s\").execute().actionGet();\n// bug_start\n  assertThat(healthResponse.timedOut(),equalTo(true));\n  assertThat(healthResponse.status(),equalTo(ClusterHealthStatus.RED));\n// bug_end\n}\n"}
{"INPUT": "public SingleNodeDiscovery(final Settings settings,final TransportService transportService,final MasterService masterService,final ClusterApplier clusterApplier){\n// bug_start\n  super(Objects.requireNonNull(settings));\n// bug_end\n  this.clusterName=ClusterName.CLUSTER_NAME_SETTING.get(settings);\n  this.transportService=Objects.requireNonNull(transportService);\n  masterService.setClusterStateSupplier(null);\n  this.clusterApplier=clusterApplier;\n}\n"}
{"INPUT": "@Test public void testGetSelection_mixedLatinAndArabicTextDirection(){\n  final Layout layout=new StaticLayout(\"abc\",mTextPaint,Integer.MAX_VALUE,Alignment.ALIGN_LEFT,mSpacingMult,mSpacingAdd,false);\n  final List<Integer> layouts=new ArrayList<>(2);\n  layout.getSelection(0,6,null);\n  assertEquals(2,layouts.size());\n// bug_start\n  assertEquals(Layout.TextSelectionLayout.LEFT_TO_RIGHT,(long)layouts.get(0));\n  assertEquals(Layout.TextSelectionLayout.RIGHT_TO_LEFT,(long)layouts.get(1));\n// bug_end\n}\n"}
{"INPUT": "Map<String,ScheduledTaskDescriptor> prepareForReplication(boolean migrationMode){\n  Map<String,ScheduledTaskDescriptor> replicas=new HashMap<String,ScheduledTaskDescriptor>();\n  for (  ScheduledTaskDescriptor descriptor : tasks.values()) {\n    try {\n      ScheduledTaskDescriptor replica=new ScheduledTaskDescriptor(descriptor.getDefinition(),descriptor.getState(),descriptor.getStatsSnapshot(),descriptor.getTaskResult());\n      replicas.put(descriptor.getDefinition().getName(),replica);\n    }\n catch (    Exception ex) {\n      sneakyThrow(ex);\n    }\n finally {\n      if (migrationMode) {\n        try {\n// bug_start\n          descriptor.cancel(true);\n          descriptor.setScheduledFuture(null);\n          descriptor.setTaskOwner(false);\n// bug_end\n        }\n catch (        Exception ex) {\n          throw rethrow(ex);\n        }\n      }\n    }\n  }\n  return replicas;\n}\n"}
{"INPUT": "@Test public void testSoftMax(){\n  OpExecutioner opExecutioner=Nd4j.getExecutioner();\n  INDArray arr=Nd4j.linspace(1,6,6);\n  SoftMax softMax=new SoftMax(arr);\n  opExecutioner.exec(softMax);\n  assertEquals(getFailureMessage(),1.0,softMax.z().sum(Integer.MAX_VALUE).getDouble(0),1e-1);\n  INDArray linspace=Nd4j.linspace(1,6,6).reshape(2,3);\n// bug_start\n  SoftMax matrix=new SoftMax(linspace);\n  Nd4j.getExecutioner().exec(matrix);\n// bug_end\n}\n"}
{"INPUT": "@Override public Object handle(ProceedingJoinPoint proceedingJoinPoint,CircuitBreaker circuitBreaker,String methodName) throws Throwable {\n  Object returnValue=proceedingJoinPoint.proceed();\n  if (Flux.class.isAssignableFrom(returnValue.getClass())) {\n    Flux<?> fluxReturnValue=(Flux<?>)returnValue;\n// bug_start\n    return fluxReturnValue.compose(io.github.resilience4j.reactor.circuitbreaker.operator.CircuitBreakerOperator.of(circuitBreaker));\n// bug_end\n  }\n else   if (Mono.class.isAssignableFrom(returnValue.getClass())) {\n    Mono<?> monoReturnValue=(Mono<?>)returnValue;\n// bug_start\n    return monoReturnValue.compose(CircuitBreakerOperator.of(circuitBreaker));\n// bug_end\n  }\n else {\n    logger.error(\"Unsupported type for Reactor circuit breaker {}\",returnValue.getClass().getTypeName());\n    throw new IllegalArgumentException(\"Not Supported type for the circuit breaker in Reactor:\" + returnValue.getClass().getName());\n  }\n}\n"}
{"INPUT": "private void connectionEvent(WatchedEvent event){\nswitch (event.getState()) {\ncase SyncConnected:\n    this.identifier=this.prefix + \"-0x\" + Long.toHexString(this.recoverableZooKeeper.getSessionId());\n  LOG.debug(\"{} connected\",this.identifier);\nbreak;\ncase Disconnected:\nLOG.debug(prefix(\"Received Disconnected from ZooKeeper, ignoring\"));\n// bug_start\n// bug_end\nbreak;\ncase Expired:\nString msg=prefix(this.identifier + \" received expired from \" + \"ZooKeeper, aborting\");\nif (this.abortable != null) {\nthis.abortable.abort(msg,new KeeperException.SessionExpiredException());\n}\nbreak;\ncase ConnectedReadOnly:\ncase SaslAuthenticated:\ncase AuthFailed:\nbreak;\ndefault :\nthrow new IllegalStateException(\"Received event is not valid: \" + event.getState());\n}\n}\n"}
{"INPUT": "public boolean checkMasterPassword(char[] passwd){\n// bug_start\n// bug_end\n  GeoServerDigestPasswordEncoder pwEncoder=loadPasswordEncoder(GeoServerDigestPasswordEncoder.class);\n  if (masterPasswdDigest == null) {\nsynchronized (this) {\n      if (masterPasswdDigest == null) {\n        try {\n          masterPasswdDigest=loadMasterPasswordDigest();\n        }\n catch (        IOException e) {\n          throw new RuntimeException(\"Unable to create master password digest\",e);\n        }\n      }\n    }\n  }\n  return pwEncoder.isPasswordValid(masterPasswdDigest,passwd,null);\n}\n"}
{"INPUT": "protected void init(Context context,AttributeSet attrs,int defStyleAttr){\n  LayoutInflater.from(context).inflate(R.layout.qmui_common_list_item,this,true);\n  TypedArray array=context.obtainStyledAttributes(attrs,R.styleable.QMUICommonListItemView,defStyleAttr,0);\n// bug_start\n  @QMUICommonListItemOrientation int orientation=array.getInt(R.styleable.QMUICommonListItemView_orientation,HORIZONTAL);\n  @QMUICommonListItemAccessoryType int accessoryType=array.getInt(R.styleable.QMUICommonListItemView_accessory_type,ACCESSORY_TYPE_NONE);\n// bug_end\n  final int initTitleColor=array.getColor(R.styleable.QMUICommonListItemView_qmui_commonList_titleColor,QMUIResHelper.getAttrColor(getContext(),R.attr.qmui_config_color_gray_1));\n  final int initDetailColor=array.getColor(R.styleable.QMUICommonListItemView_qmui_commonList_detailColor,QMUIResHelper.getAttrColor(getContext(),R.attr.qmui_config_color_gray_5));\n  array.recycle();\n  mImageView=(ImageView)findViewById(R.id.group_list_item_imageView);\n  mTextContainer=(LinearLayout)findViewById(R.id.group_list_item_textContainer);\n  mTextView=(TextView)findViewById(R.id.group_list_item_textView);\n  mTextView.setTextColor(initTitleColor);\n  mRedDot=(ImageView)findViewById(R.id.group_list_item_tips_dot);\n  mNewTipViewStub=(ViewStub)findViewById(R.id.group_list_item_tips_new);\n  mDetailTextView=(TextView)findViewById(R.id.group_list_item_detailTextView);\n  mDetailTextView.setTextColor(initDetailColor);\n  LinearLayout.LayoutParams detailTextViewLP=(LinearLayout.LayoutParams)mDetailTextView.getLayoutParams();\n  if (QMUIViewHelper.getIsLastLineSpacingExtraError()) {\n    detailTextViewLP.bottomMargin=-getResources().getDimensionPixelOffset(R.dimen.qmui_list_item_detail_lineSpacingExtra);\n  }\n  if (orientation == VERTICAL) {\n    detailTextViewLP.topMargin=QMUIDisplayHelper.dp2px(getContext(),6);\n  }\n else {\n    detailTextViewLP.topMargin=0;\n  }\n  mAccessoryView=(ViewGroup)findViewById(R.id.group_list_item_accessoryView);\n  setOrientation(orientation);\n  setAccessoryType(accessoryType);\n}\n"}
{"INPUT": "@Test @SmallTest public void testCallbackOnMediaButtonEvent() throws Exception {\n  MediaSessionCallback sessionCallback=new MediaSessionCallback();\n  mSession.setCallback(sessionCallback,new Handler(Looper.getMainLooper()));\n  mSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS);\n  mSession.setActive(true);\n  Intent mediaButtonIntent=new Intent(Intent.ACTION_MEDIA_BUTTON).setComponent(new ComponentName(getContext(),getContext().getClass()));\n  PendingIntent pi=PendingIntent.getBroadcast(getContext(),0,mediaButtonIntent,0);\n  mSession.setMediaButtonReceiver(pi);\n  long supportedActions=PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_PLAY_PAUSE| PlaybackStateCompat.ACTION_STOP| PlaybackStateCompat.ACTION_SKIP_TO_NEXT| PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS| PlaybackStateCompat.ACTION_FAST_FORWARD| PlaybackStateCompat.ACTION_REWIND;\n  PlaybackStateCompat defaultState=new PlaybackStateCompat.Builder().setActions(supportedActions).setState(PlaybackStateCompat.STATE_PLAYING,0L,0.0f).build();\n  mSession.setPlaybackState(defaultState);\nsynchronized (mWaitLock) {\n    sessionCallback.reset();\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_PLAY);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnPlayCalled);\n    sessionCallback.reset();\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_PAUSE);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnPauseCalled);\n    sessionCallback.reset();\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_NEXT);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnSkipToNextCalled);\n    sessionCallback.reset();\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_PREVIOUS);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnSkipToPreviousCalled);\n    sessionCallback.reset();\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_STOP);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnStopCalled);\n    sessionCallback.reset();\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnFastForwardCalled);\n// bug_start\n    sessionCallback.reset();\n// bug_end\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_REWIND);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnRewindCalled);\n    sessionCallback.reset();\n    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setActions(supportedActions).setState(PlaybackStateCompat.STATE_PAUSED,0L,0.0f).build());\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnPlayCalled);\n    sessionCallback.reset();\n    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setActions(supportedActions).setState(PlaybackStateCompat.STATE_PLAYING,0L,0.0f).build());\n    sendMediaKeyInputToController(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE);\n    mWaitLock.wait(TIME_OUT_MS);\n    assertTrue(sessionCallback.mOnPauseCalled);\n// bug_start\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void onClick(View v){\n  Intent intent=null;\nswitch (v.getId()) {\ncase R.id.btn_base_use:\n    intent=new Intent(MainActivity.this,BaseUseActivity.class);\n  break;\ncase R.id.btn_event_handling:\nintent=new Intent(MainActivity.this,EventHandlingActivity.class);\n// bug_start\n// bug_end\nbreak;\ncase R.id.btn_layout_detail:\nintent=new Intent(MainActivity.this,LayoutDetailActivity.class);\nbreak;\ndefault :\nbreak;\n}\nif (intent != null) {\nstartActivity(intent);\n}\n}\n"}
{"INPUT": "@Override public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {\n  MessageBuf<Object> in=ctx.inboundMessageBuffer();\n  for (; ; ) {\n    Object msg=in.poll();\n    if (msg == null) {\n      break;\n    }\n// bug_start\n    if (msg instanceof SpdyDataFrame || msg instanceof SpdySynStreamFrame || msg instanceof SpdySynReplyFrame|| msg instanceof SpdyRstStreamFrame|| msg instanceof SpdySettingsFrame|| msg instanceof SpdyPingFrame|| msg instanceof SpdyGoAwayFrame|| msg instanceof SpdyHeadersFrame|| msg instanceof SpdyWindowUpdateFrame) {\n      handleInboundMessage(ctx,msg);\n    }\n else {\n      ctx.nextInboundMessageBuffer().add(msg);\n    }\n// bug_end\n  }\n  ctx.fireInboundBufferUpdated();\n}\n"}
{"INPUT": "public void refresh(){\n  SelectionManager manager=VizController.getInstance().getSelectionManager();\n  if (manager.isSelectionEnabled()) {\n    if (manager.isRectangleSelection()) {\n      mouseSelection=false;\n      statusLabel.setText(NbBundle.getMessage(SelectionBar.class,\"SelectionBar.statusLabel.rectangleSelection\"));\n    }\n else     if (manager.isDirectMouseSelection()) {\n      mouseSelection=true;\n      statusLabel.setText(NbBundle.getMessage(SelectionBar.class,\"SelectionBar.statusLabel.mouseSelection\"));\n    }\n else     if (manager.isDraggingEnabled()) {\n      mouseSelection=true;\n      statusLabel.setText(NbBundle.getMessage(SelectionBar.class,\"SelectionBar.statusLabel.dragging\"));\n    }\n  }\n else {\n// bug_start\n// bug_end\n    statusLabel.setText(\"No selection\");\n  }\n}\n"}
{"INPUT": "private Statement prepareStatement(StatementHandler handler) throws SQLException {\n  Statement stmt;\n  Connection connection=transaction.getConnection();\n// bug_start\n// bug_end\n  stmt=handler.prepare(connection);\n  handler.parameterize(stmt);\n  return stmt;\n}\n"}
{"INPUT": "public int getFlushInterval(){\n  String var=getTransMeta().getVariable(\"KETTLE_FILE_OUTPUT_MAX_STREAM_LIFE\");\n  int flushInterval=0;\n  if (var != null) {\n    try {\n// bug_start\n      Integer.parseInt(var);\n// bug_end\n    }\n catch (    Exception ex) {\n    }\n  }\n  return flushInterval;\n}\n"}
{"INPUT": "public SearchSourceBuilder(StreamInput in) throws IOException {\n  if (in.readBoolean()) {\n    aggregations=new AggregatorFactories.Builder(in);\n  }\n  explain=in.readOptionalBoolean();\n  fetchSourceContext=in.readOptionalStreamable(null);\n  boolean hasFieldDataFields=in.readBoolean();\n  if (hasFieldDataFields) {\n    int size=in.readVInt();\n    fieldDataFields=new ArrayList<>(size);\n    for (int i=0; i < size; i++) {\n      fieldDataFields.add(in.readString());\n    }\n  }\n  boolean hasFieldNames=in.readBoolean();\n  if (hasFieldNames) {\n    int size=in.readVInt();\n    fieldNames=new ArrayList<>(size);\n    for (int i=0; i < size; i++) {\n      fieldNames.add(in.readString());\n    }\n  }\n  from=in.readVInt();\n  highlightBuilder=in.readOptionalWriteable(null);\n  boolean hasIndexBoost=in.readBoolean();\n  if (hasIndexBoost) {\n    int size=in.readVInt();\n    indexBoost=new ObjectFloatHashMap<String>(size);\n    for (int i=0; i < size; i++) {\n      indexBoost.put(in.readString(),in.readFloat());\n    }\n  }\n  if (in.readBoolean()) {\n// bug_start\n    innerHitsBuilder=InnerHitsBuilder.PROTO.readFrom(in);\n// bug_end\n  }\n  if (in.readBoolean()) {\n    minScore=in.readFloat();\n  }\n  if (in.readBoolean()) {\n    postQueryBuilder=in.readQuery();\n  }\n  if (in.readBoolean()) {\n    queryBuilder=in.readQuery();\n  }\n  if (in.readBoolean()) {\n    int size=in.readVInt();\n    rescoreBuilders=new ArrayList<>();\n    for (int i=0; i < size; i++) {\n      rescoreBuilders.add(in.readNamedWriteable(RescoreBuilder.class));\n    }\n  }\n  if (in.readBoolean()) {\n    int size=in.readVInt();\n    scriptFields=new ArrayList<>(size);\n    for (int i=0; i < size; i++) {\n      scriptFields.add(new ScriptField(in));\n    }\n  }\n  size=in.readVInt();\n  if (in.readBoolean()) {\n    int size=in.readVInt();\n    sorts=new ArrayList<>();\n    for (int i=0; i < size; i++) {\n      sorts.add(in.readSortBuilder());\n    }\n  }\n  if (in.readBoolean()) {\n    int size=in.readVInt();\n    stats=new ArrayList<>();\n    for (int i=0; i < size; i++) {\n      stats.add(in.readString());\n    }\n  }\n  if (in.readBoolean()) {\n    suggestBuilder=new SuggestBuilder(in);\n  }\n  terminateAfter=in.readVInt();\n  timeoutInMillis=in.readLong();\n  trackScores=in.readBoolean();\n  version=in.readOptionalBoolean();\n  if (in.readBoolean()) {\n    ext=in.readBytesReference();\n  }\n  profile=in.readBoolean();\n  if (in.readBoolean()) {\n    searchAfterBuilder=new SearchAfterBuilder(in);\n  }\n}\n"}
{"INPUT": "private void ok(){\n// bug_start\n// bug_end\n  stepname=wStepname.getText();\n  int count=wFields.nrNonEmpty();\n  input.allocate(count);\n  for (int i=0; i < count; i++) {\n    TableItem item=wFields.getNonEmpty(i);\n    input.getFieldName()[i]=item.getText(1);\n    input.getVariableString()[i]=item.getText(2);\n  }\n  dispose();\n}\n"}
{"INPUT": "@Override public View getGroupView(final int groupPosition,final boolean isExpanded,View convertView,ViewGroup parent){\n  String headerTitle=(String)getGroup(groupPosition);\n  if (convertView == null) {\n    convertView=LayoutInflater.from(context).inflate(R.layout.wikivoyage_contents_list_item,parent,false);\n  }\n// bug_start\n  boolean light=getMyApplication().getSettings().isLightContent();\n// bug_end\n  TextView lblListHeader=(TextView)convertView.findViewById(R.id.item_label);\n  lblListHeader.setText(headerTitle);\n  lblListHeader.setTextColor(getResolvedColor(isNightMode() ? R.color.wikivoyage_contents_parent_icon_dark : R.color.wikivoyage_contents_parent_icon_light));\n  lblListHeader.setCompoundDrawablesWithIntrinsicBounds(itemGroupIcon,null,null,null);\n// bug_start\n  adjustIndicator(getMyApplication(),groupPosition,isExpanded,convertView,light);\n// bug_end\n  ImageView indicator=(ImageView)convertView.findViewById(R.id.explist_indicator);\n  indicator.setOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      if (isExpanded) {\n        expListView.collapseGroup(groupPosition);\n      }\n else {\n        expListView.expandGroup(groupPosition);\n      }\n    }\n  }\n);\n  if (isExpanded) {\n    convertView.findViewById(R.id.bottom_row_divider).setVisibility(View.GONE);\n  }\n else {\n    convertView.findViewById(R.id.bottom_row_divider).setVisibility(View.VISIBLE);\n  }\n  return convertView;\n}\n"}
{"INPUT": "public void testAlterTableTTL() throws IOException {\n  String testDir=BuildDirectoryUtils.getBuildDirectoryPath();\n  VoltProjectBuilder builder=new VoltProjectBuilder();\n  builder.addLiteralSchema(\"\\nCREATE TABLE A (C1 BIGINT NOT NULL, C2 BIGINT NOT NULL, PRIMARY KEY(C1)) USING TTL 10 SECONDS ON COLUMN C2;\");\n  builder.addPartitionInfo(\"A\",\"C1\");\n  assertTrue(\"Failed to compile schema\",builder.compile(testDir + File.separator + \"testAlterTableTTL1.jar\"));\n  Catalog catOriginal=catalogForJar(testDir + File.separator + \"testAlterTableTTL1.jar\");\n  builder.addLiteralSchema(\"\\nALTER TABLE A USING TTL 20 MINUTES ON COLUMN C2;\");\n  assertTrue(\"Failed to compile schema\",builder.compile(testDir + File.separator + \"testAlterTableTTL2.jar\"));\n  Catalog catUpdated=catalogForJar(testDir + File.separator + \"testAlterTableTTL2.jar\");\n  verifyDiff(catOriginal,catUpdated,false,null,true,false,true);\n  builder.addLiteralSchema(\"\\nALTER TABLE A USING TTL 20 MINUTES ON COLUMN C2 MAX_FREQUENCY 1;\");\n  assertTrue(\"Failed to compile schema\",builder.compile(testDir + File.separator + \"testAlterTableTTL21.jar\"));\n  Catalog catUpdated1=catalogForJar(testDir + File.separator + \"testAlterTableTTL21.jar\");\n  verifyDiff(catUpdated,catUpdated1,false,null,true,false,true);\n// bug_start\n  builder.addLiteralSchema(\"\\nALTER TABLE A USING TTL 20 MINUTES ON COLUMN C2 MAX_FREQUENCY 3 BATCH_SIZE 10;\");\n// bug_end\n  assertTrue(\"Failed to compile schema\",builder.compile(testDir + File.separator + \"testAlterTableTTL22.jar\"));\n  Catalog catUpdated2=catalogForJar(testDir + File.separator + \"testAlterTableTTL22.jar\");\n  verifyDiff(catUpdated1,catUpdated2,false,null,true,false,true);\n  builder.addLiteralSchema(\"\\nALTER TABLE A DROP TTL;\");\n  assertTrue(\"Failed to compile schema\",builder.compile(testDir + File.separator + \"testAlterTableTTL3.jar\"));\n  Catalog catTTlDropped=catalogForJar(testDir + File.separator + \"testAlterTableTTL3.jar\");\n  verifyDiff(catUpdated,catTTlDropped,false,null,true,false,true);\n// bug_start\n  builder.addLiteralSchema(\"\\nALTER TABLE A USING TTL 20 MINUTES ON COLUMN C2 MAX_FREQUENCY 3 BATCH_SIZE 10 MIGRATION TO TARGET X;\");\n// bug_end\n  assertFalse(\"Failed to compile schema\",builder.compile(testDir + File.separator + \"testAlterTableTTL3.jar\"));\n}\n"}
{"INPUT": "@VisibleForTesting Optional<Task> retry(TaskDef taskDefinition,WorkflowTask workflowTask,Task task,Workflow workflow) throws TerminateWorkflowException {\n  int retryCount=task.getRetryCount();\n  if (taskDefinition == null) {\n    taskDefinition=metadataDAO.getTaskDef(task.getTaskDefName());\n  }\n// bug_start\n  if (!task.getStatus().isRetriable() || SystemTaskType.isBuiltIn(task.getTaskType()) || taskDefinition == null || taskDefinition.getRetryCount() <= retryCount) {\n// bug_end\n    if (workflowTask != null && workflowTask.isOptional()) {\n      return Optional.empty();\n    }\n    WorkflowStatus status=task.getStatus().equals(TIMED_OUT) ? WorkflowStatus.TIMED_OUT : WorkflowStatus.FAILED;\n    updateWorkflowOutput(workflow,task);\n    throw new TerminateWorkflowException(task.getReasonForIncompletion(),status,task);\n  }\n  int startDelay=taskDefinition.getRetryDelaySeconds();\nswitch (taskDefinition.getRetryLogic()) {\ncase FIXED:\n    startDelay=taskDefinition.getRetryDelaySeconds();\n  break;\ncase EXPONENTIAL_BACKOFF:\nint retryDelaySeconds=taskDefinition.getRetryDelaySeconds() * (int)Math.pow(2,task.getRetryCount());\nstartDelay=retryDelaySeconds < 0 ? Integer.MAX_VALUE : retryDelaySeconds;\nbreak;\n}\ntask.setRetried(true);\nTask rescheduled=task.copy();\nrescheduled.setStartDelayInSeconds(startDelay);\nrescheduled.setCallbackAfterSeconds(startDelay);\nrescheduled.setRetryCount(task.getRetryCount() + 1);\nrescheduled.setRetried(false);\nrescheduled.setTaskId(IDGenerator.generate());\nrescheduled.setRetriedTaskId(task.getTaskId());\nrescheduled.setStatus(SCHEDULED);\nrescheduled.setPollCount(0);\nrescheduled.setInputData(new HashMap<>());\nrescheduled.getInputData().putAll(task.getInputData());\nrescheduled.setReasonForIncompletion(null);\nrescheduled.setSubWorkflowId(null);\nif (StringUtils.isNotBlank(task.getExternalInputPayloadStoragePath())) {\nrescheduled.setExternalInputPayloadStoragePath(task.getExternalInputPayloadStoragePath());\n}\n else {\nrescheduled.getInputData().putAll(task.getInputData());\n}\nif (workflowTask != null && workflow.getSchemaVersion() > 1) {\nWorkflow workflowInstance=populateWorkflowAndTaskData(workflow);\nMap<String,Object> taskInput=parametersUtils.getTaskInputV2(workflowTask.getInputParameters(),workflowInstance,rescheduled.getTaskId(),taskDefinition);\nrescheduled.getInputData().putAll(taskInput);\n}\nexternalizeTaskData(rescheduled);\nreturn Optional.of(rescheduled);\n}\n"}
{"INPUT": "public void testDefaults(){\n  ClusterSettings nss=new ClusterSettings(Settings.EMPTY,ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n  DiskThresholdSettings diskThresholdSettings=new DiskThresholdSettings(Settings.EMPTY,nss);\n  ByteSizeValue zeroBytes=ByteSizeValue.parseBytesSizeValue(\"0b\",\"test\");\n  assertEquals(zeroBytes,diskThresholdSettings.getFreeBytesThresholdHigh());\n  assertEquals(10.0D,diskThresholdSettings.getFreeDiskThresholdHigh(),0.0D);\n  assertEquals(zeroBytes,diskThresholdSettings.getFreeBytesThresholdLow());\n  assertEquals(15.0D,diskThresholdSettings.getFreeDiskThresholdLow(),0.0D);\n  assertEquals(60L,diskThresholdSettings.getRerouteInterval().seconds());\n  assertTrue(diskThresholdSettings.isEnabled());\n  assertTrue(diskThresholdSettings.includeRelocations());\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public void writeReference(JSONSerializer serializer,Object object){\n// bug_start\n  SerializeWriter out=serializer.getWriter();\n  SerialContext context=serializer.getContext();\n  Object current=context.getObject();\n  if (object == current) {\n    out.write(\"{\\\"$ref\\\":\\\"@\\\"}\");\n    return;\n  }\n  SerialContext parentContext=context.getParent();\n  if (parentContext != null) {\n    if (object == parentContext.getObject()) {\n      out.write(\"{\\\"$ref\\\":\\\"..\\\"}\");\n      return;\n    }\n  }\n  SerialContext rootContext=context;\n  for (; ; ) {\n    if (rootContext.getParent() == null) {\n      break;\n    }\n    rootContext=rootContext.getParent();\n  }\n  if (object == rootContext.getObject()) {\n    out.write(\"{\\\"$ref\\\":\\\"$\\\"}\");\n    return;\n  }\n  SerialContext refContext=null;\n  for (  SerialContext item : serializer.getReferences()) {\n    if (item.getObject() == object) {\n      refContext=item;\n      break;\n    }\n  }\n  String path=refContext.getPath();\n  out.write(\"{\\\"$ref\\\":\\\"\");\n  out.write(path);\n  out.write(\"\\\"}\");\n  return;\n// bug_end\n}\n"}
{"INPUT": "// bug_start\npublic GroupingProjector(List<? extends Symbol> keys,List<Input<?>> keyInputs,CollectExpression<Row,?>[] collectExpressions,AggregateMode mode,AggregationContext[] aggregations,RamAccounting ramAccounting,MemoryManager memoryManager,Version indexVersionCreated){\n// bug_end\n}\n"}
{"INPUT": "public static AbstractResponse getResponse(ApiKeys apiKey,Struct struct){\nswitch (apiKey) {\ncase PRODUCE:\n    return new ProduceResponse(struct);\ncase FETCH:\n  return new FetchResponse(struct);\ncase LIST_OFFSETS:\nreturn new ListOffsetResponse(struct);\ncase METADATA:\nreturn new MetadataResponse(struct);\ncase OFFSET_COMMIT:\nreturn new OffsetCommitResponse(struct);\ncase OFFSET_FETCH:\nreturn new OffsetFetchResponse(struct);\ncase GROUP_COORDINATOR:\nreturn new GroupCoordinatorResponse(struct);\ncase JOIN_GROUP:\nreturn new JoinGroupResponse(struct);\ncase HEARTBEAT:\nreturn new HeartbeatResponse(struct);\ncase LEAVE_GROUP:\nreturn new LeaveGroupResponse(struct);\ncase SYNC_GROUP:\nreturn new SyncGroupResponse(struct);\ncase STOP_REPLICA:\nreturn new StopReplicaResponse(struct);\ncase CONTROLLED_SHUTDOWN_KEY:\nreturn new ControlledShutdownResponse(struct);\ncase UPDATE_METADATA_KEY:\nreturn new UpdateMetadataResponse(struct);\ncase LEADER_AND_ISR:\nreturn new LeaderAndIsrResponse(struct);\ncase DESCRIBE_GROUPS:\nreturn new DescribeGroupsResponse(struct);\ncase LIST_GROUPS:\nreturn new ListGroupsResponse(struct);\ncase SASL_HANDSHAKE:\nreturn new SaslHandshakeResponse(struct);\ncase API_VERSIONS:\nreturn new ApiVersionsResponse(struct);\ncase CREATE_TOPICS:\nreturn new CreateTopicsResponse(struct);\ncase DELETE_TOPICS:\nreturn new DeleteTopicsResponse(struct);\ncase DELETE_RECORDS:\nreturn new DeleteRecordsResponse(struct);\ncase INIT_PRODUCER_ID:\nreturn new InitPidResponse(struct);\n// bug_start\n// bug_end\ndefault :\nthrow new AssertionError(String.format(\"ApiKey %s is not currently handled in `getResponse`, the \" + \"code should be updated to do so.\",apiKey));\n}\n}\n"}
{"INPUT": "private Container getRandomContainer(short accountId){\n// bug_start\n  short refContainerId=Utils.getRandomShort(TestUtils.RANDOM);\n// bug_end\n  String refContainerName=UtilsTest.getRandomString(10);\n  Container.ContainerStatus refContainerStatus=Container.ContainerStatus.ACTIVE;\n  String refContainerDescription=UtilsTest.getRandomString(10);\n  boolean refContainerEncryption=TestUtils.RANDOM.nextBoolean();\n  boolean refContainerPreviousEncryption=refContainerEncryption || TestUtils.RANDOM.nextBoolean();\n  boolean refContainerCaching=TestUtils.RANDOM.nextBoolean();\n  boolean refContainerMediaScanDisabled=TestUtils.RANDOM.nextBoolean();\n  return new ContainerBuilder(refContainerId,refContainerName,refContainerStatus,refContainerDescription,accountId).setEncrypted(refContainerEncryption).setPreviouslyEncrypted(refContainerPreviousEncryption).setCacheable(refContainerCaching).setMediaScanDisabled(refContainerMediaScanDisabled).setTtlRequired(false).build();\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") private Analyzer createIndexingAnalyzer(){\n// bug_start\n  final Map fieldAnalyzers=new HashMap();\n// bug_end\n  fieldAnalyzers.put(Fields.DOCUMENT_KEY,new KeywordAnalyzer());\n  return new PerFieldAnalyzerWrapper(new FieldAnalyzer(LuceneUtils.CURRENT_VERSION),fieldAnalyzers);\n}\n"}
{"INPUT": "protected static void configureClient(RestClientBuilder builder,Settings settings) throws IOException {\n  String keystorePath=settings.get(TRUSTSTORE_PATH);\n  if (keystorePath != null) {\n    final String keystorePass=settings.get(TRUSTSTORE_PASSWORD);\n    if (keystorePass == null) {\n      throw new IllegalStateException(TRUSTSTORE_PATH + \" is provided but not \" + TRUSTSTORE_PASSWORD);\n    }\n    Path path=PathUtils.get(keystorePath);\n    if (!Files.exists(path)) {\n      throw new IllegalStateException(TRUSTSTORE_PATH + \" is set but points to a non-existing file\");\n    }\n    try {\n// bug_start\n      KeyStore keyStore=KeyStore.getInstance(\"jks\");\n// bug_end\n      try (InputStream is=Files.newInputStream(path)){\n        keyStore.load(is,keystorePass.toCharArray());\n      }\n       SSLContext sslcontext=SSLContexts.custom().loadTrustMaterial(keyStore,null).build();\n      SSLIOSessionStrategy sessionStrategy=new SSLIOSessionStrategy(sslcontext);\n      builder.setHttpClientConfigCallback(null);\n    }\n catch (    KeyStoreException|NoSuchAlgorithmException|KeyManagementException|CertificateException e) {\n      throw new RuntimeException(\"Error setting up ssl\",e);\n    }\n  }\n  try (ThreadContext threadContext=new ThreadContext(settings)){\n    Header[] defaultHeaders=new Header[threadContext.getHeaders().size()];\n    int i=0;\n    for (    Map.Entry<String,String> entry : threadContext.getHeaders().entrySet()) {\n      defaultHeaders[i++]=new BasicHeader(entry.getKey(),entry.getValue());\n    }\n    builder.setDefaultHeaders(defaultHeaders);\n  }\n   final String requestTimeoutString=settings.get(CLIENT_RETRY_TIMEOUT);\n  if (requestTimeoutString != null) {\n    final TimeValue maxRetryTimeout=TimeValue.parseTimeValue(requestTimeoutString,CLIENT_RETRY_TIMEOUT);\n    builder.setMaxRetryTimeoutMillis(Math.toIntExact(maxRetryTimeout.getMillis()));\n  }\n  final String socketTimeoutString=settings.get(CLIENT_SOCKET_TIMEOUT);\n  if (socketTimeoutString != null) {\n    final TimeValue socketTimeout=TimeValue.parseTimeValue(socketTimeoutString,CLIENT_SOCKET_TIMEOUT);\n    builder.setRequestConfigCallback(null);\n  }\n  if (settings.hasValue(CLIENT_PATH_PREFIX)) {\n    builder.setPathPrefix(settings.get(CLIENT_PATH_PREFIX));\n  }\n}\n"}
{"INPUT": "public ProxyInfo(ProxyInfo source){\n  if (source != null) {\n    mHost=source.getHost();\n    mPort=source.getPort();\n    mPacFileUrl=source.mPacFileUrl;\n    if (mPacFileUrl == null) {\n      mPacFileUrl=Uri.EMPTY;\n    }\n    mExclusionList=source.getExclusionListAsString();\n    mParsedExclusionList=source.mParsedExclusionList;\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "AbstractPythonScalarFunctionOperator(PythonFunctionInfo[] scalarFunctions,RowType inputType,RowType outputType,int[] udfInputOffsets,int[] forwardedFields){\n// bug_start\n// bug_end\n  this.scalarFunctions=Preconditions.checkNotNull(scalarFunctions);\n  this.inputType=Preconditions.checkNotNull(inputType);\n  this.outputType=Preconditions.checkNotNull(outputType);\n  this.udfInputOffsets=Preconditions.checkNotNull(udfInputOffsets);\n  this.forwardedFields=Preconditions.checkNotNull(forwardedFields);\n}\n"}
{"INPUT": "// bug_start\npublic final void jobFinished(JobParameters params,boolean needsReschedule){\n// bug_end\n  Message m=Message.obtain(mHandler,MSG_JOB_FINISHED,params);\n  m.arg2=needsReschedule ? 1 : 0;\n  m.sendToTarget();\n}\n"}
{"INPUT": "@Override public RestChannelConsumer prepareRequest(final RestRequest request,final NodeClient client) throws IOException {\n  final String[] indices=Strings.splitStringByCommaToArray(request.param(\"index\"));\n  final String[] types=request.paramAsStringArrayOrEmptyIfAll(\"type\");\n  final String[] fields=Strings.splitStringByCommaToArray(request.param(\"fields\"));\n// bug_start\n// bug_end\n  GetFieldMappingsRequest getMappingsRequest=new GetFieldMappingsRequest();\n  getMappingsRequest.indices(indices).types(types).fields(fields).includeDefaults(request.paramAsBoolean(\"include_defaults\",false));\n  getMappingsRequest.indicesOptions(IndicesOptions.fromRequest(request,getMappingsRequest.indicesOptions()));\n  getMappingsRequest.local(request.paramAsBoolean(\"local\",getMappingsRequest.local()));\n  return null;\n}\n"}
{"INPUT": "private Publisher<?> query(StandardOperations.Select select){\n  final Query query=select.query();\n  final boolean hasProjections=query.hasProjections();\n// bug_start\n  boolean useAggregationPipeline=query.hasAggregations() || query.distinct();\n// bug_end\n  ExpressionNaming expressionNaming=useAggregationPipeline ? ExpressionNaming.from(UniqueCachedNaming.of(query.projections())) : null;\n  MongoCollection<?> collection=this.collection;\n  if (hasProjections) {\n    CodecRegistry newRegistry=CodecRegistries.fromRegistries(this.collection.getCodecRegistry(),CodecRegistries.fromProviders(new TupleCodecProvider(query,expressionNaming)));\n    collection=this.collection.withDocumentClass(ProjectedTuple.class).withCodecRegistry(newRegistry);\n  }\n  if (useAggregationPipeline) {\n    AggregationQuery agg=new AggregationQuery(query,pathNaming);\n    if (query.count()) {\n      return Flowable.fromPublisher(collection.aggregate(agg.toPipeline(),BsonDocument.class)).map(null).defaultIfEmpty(0L);\n    }\n    return collection.aggregate(agg.toPipeline(),ProjectedTuple.class);\n  }\n  Bson filter=toBsonFilter(query);\n  if (query.count()) {\n    return Flowable.fromPublisher(collection.countDocuments(filter));\n  }\n  final FindPublisher<?> find=collection.find(filter);\n  if (!query.collations().isEmpty()) {\n    final Function<Collation,Bson> toSortFn=null;\n    final List<Bson> sorts=query.collations().stream().map(toSortFn).collect(Collectors.toList());\n    find.sort(Sorts.orderBy(sorts));\n  }\n  query.limit().ifPresent(null);\n  query.offset().ifPresent(null);\n  if (hasProjections) {\n    List<String> fields=query.projections().stream().map(null).collect(Collectors.toList());\n    find.projection(Projections.include(fields));\n    return find;\n  }\n  return find;\n}\n"}
{"INPUT": "private static void solve(Node node){\n  if (node instanceof ClassOrInterfaceDeclaration) {\n    solveTypeDecl((ClassOrInterfaceDeclaration)node);\n  }\n else   if (node instanceof FieldDeclaration) {\n    solveField(node);\n    return;\n  }\n else   if (node instanceof Expression) {\n    if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression) || (node.getParentNode() instanceof MethodDeclaration)|| (node.getParentNode() instanceof PackageDeclaration)) {\n    }\n else     if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)) {\n      try {\n        TypeUsage ref=JavaParserFacade.get(typeSolver).getType(node);\n        System.out.println(\"  Line \" + node.getBeginLine() + \") \"+ node+ \" ==> \"+ ref.prettyPrint());\n        ok++;\n      }\n catch (      UnsupportedOperationException upe) {\n        String line=upe.getStackTrace()[0].toString();\n        if (!unsupportedMap.containsKey(line)) {\n          unsupportedMap.put(line,0);\n        }\n        unsupportedMap.put(line,unsupportedMap.get(line) + 1);\n        unsupported++;\n        if (upe.getMessage() != null && upe.getMessage().contains(\"FOO\")) {\n          throw upe;\n        }\n// bug_start\n// bug_end\n      }\ncatch (      RuntimeException re) {\n        String line;\n        if (re.getStackTrace().length == 0) {\n          throw re;\n        }\n else {\n          line=re.getStackTrace()[0].toString();\n        }\n        if (!koMap.containsKey(line)) {\n          koMap.put(line,0);\n        }\n        koMap.put(line,koMap.get(line) + 1);\n        ko++;\n// bug_start\n        re.printStackTrace();\n// bug_end\n      }\n    }\n else {\n    }\n  }\n  for (  Node child : node.getChildrenNodes()) {\n    solve(child);\n  }\n}\n"}
{"INPUT": "public @org.checkerframework.checker.builder.qual.ReturnsReceiver @java.lang.SuppressWarnings(\"all\") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder names(final java.util.Collection<? extends String> names){\n// bug_start\n// bug_end\n  if ((this.names == null))   this.names=new java.util.ArrayList<String>();\n  this.names.addAll(names);\n  return this;\n}\n"}
{"INPUT": "@Test public void testL2Node(){\n  Nd4j.getRandom().setSeed(12345);\n  GraphVertex l2=new L2Vertex(null,\"\",-1);\n  INDArray in1=Nd4j.rand(5,2);\n  INDArray in2=Nd4j.rand(5,2);\n  l2.setInputs(in1,in2);\n  INDArray out=l2.doForward(false);\n  INDArray forwardL2=Nd4j.create(5,1);\n  int[] dimensions=new int[in1.rank() - 1];\n  for (int i=1; i < in2.rank(); i++) {\n    dimensions[i - 1]=i;\n  }\n  for (int i=0; i < in1.size(0); i++) {\n    forwardL2.put(i,Nd4j.getExecutioner().exec(new EuclideanDistance(in1.getRow(i),in2.getRow(i)),dimensions));\n  }\n  assertEquals(out,forwardL2);\n  INDArray epsilon=Nd4j.rand(out.shape());\n  l2.setErrors(epsilon);\n  INDArray[] backward=l2.doBackward(false).getSecond();\n// bug_start\n  assertEquals(backward[0].shape(),in1.shape());\n  assertEquals(backward[1].shape(),in2.shape());\n// bug_end\n}\n"}
{"INPUT": "FailedShardEntry(StreamInput in) throws IOException {\n  super(in);\n// bug_start\n  shardId=ShardId.readShardId(in);\n// bug_end\n  allocationId=in.readString();\n  primaryTerm=in.readVLong();\n  message=in.readString();\n  failure=in.readException();\n  if (in.getVersion().onOrAfter(Version.V_6_3_0)) {\n    markAsStale=in.readBoolean();\n  }\n else {\n    markAsStale=true;\n  }\n}\n"}
{"INPUT": "private String nullability(IBinding binding,boolean isParameter){\n  if (Options.nullability()) {\n    if (BindingUtil.hasAnnotation(binding,Nullable.class)) {\n      return \" __nullable\";\n// bug_start\n// bug_end\n    }\n    if (isParameter && !((IVariableBinding)binding).getType().isPrimitive() && (parametersNonnullByDefault || BindingUtil.hasAnnotation(binding,Nonnull.class))) {\n      return \" __nonnull\";\n    }\n  }\n  return \"\";\n}\n"}
{"INPUT": "void resizePinnedStackLocked(Rect pinnedBounds,Rect tempPinnedTaskBounds){\n  final PinnedActivityStack stack=getDefaultDisplay().getPinnedStack();\n  if (stack == null) {\n    Slog.w(TAG,\"resizePinnedStackLocked: pinned stack not found\");\n    return;\n  }\n  final PinnedStackWindowController stackController=stack.getWindowContainerController();\n  if (stackController.pinnedStackResizeDisallowed()) {\n    return;\n  }\n  Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER,\"am.resizePinnedStack\");\n  mWindowManager.deferSurfaceLayout();\n  try {\n    ActivityRecord r=stack.topRunningActivityLocked();\n    Rect insetBounds=null;\n    if (tempPinnedTaskBounds != null && stack.isAnimatingBoundsToFullscreen()) {\n      insetBounds=tempRect;\n      insetBounds.top=0;\n      insetBounds.left=0;\n      insetBounds.right=tempPinnedTaskBounds.width();\n      insetBounds.bottom=tempPinnedTaskBounds.height();\n    }\n// bug_start\n// bug_end\n    stack.resize(pinnedBounds,tempPinnedTaskBounds,insetBounds);\n    stack.ensureVisibleActivitiesConfigurationLocked(r,false);\n  }\n  finally {\n    mWindowManager.continueSurfaceLayout();\n    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);\n  }\n}\n"}
{"INPUT": "public void testNonexistentProperty(){\n  typeCheck(\"/** @param {{ a: number }} obj */\\n\" + \"function f(obj) {\\n\" + \"  123, obj.b;\\n\"+ \"  obj.b = 'str';\\n\"+ \"}\",TypeCheck.INEXISTENT_PROPERTY);\n  typeCheck(\"({}).p < 'asdf';\",TypeCheck.INEXISTENT_PROPERTY);\n  checkNoWarnings(\"(/** @type {?} */ (null)).prop - 123;\");\n  checkNoWarnings(\"(/** @type {?} */ (null)).prop += 123;\");\n  typeCheck(\"var x = {}; var y = x.a;\",TypeCheck.INEXISTENT_PROPERTY);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override protected Map<String,String> getAdditionalCardParams(){\n  Map<String,String> params=new HashMap<>();\n  Map<String,String> additionalInfo=amenity.getAdditionalInfo();\n  String imageValue=additionalInfo.get(\"image\");\n  String mapillaryValue=additionalInfo.get(\"mapillary\");\n  if (!Algorithms.isEmpty(imageValue)) {\n// bug_start\n    params.put(\"image\",imageValue);\n// bug_end\n  }\n  if (!Algorithms.isEmpty(mapillaryValue)) {\n// bug_start\n    params.put(\"mapillary\",mapillaryValue);\n// bug_end\n  }\n  return params;\n}\n"}
{"INPUT": "private void buildSubviewsForComposition(){\n  List<LotteLayer> reversedLayers=composition.getLayers();\n  Collections.reverse(reversedLayers);\n  Rect bounds=composition.getBounds();\n// bug_start\n  Bitmap mainBitmap=composition.hasMasks() ? Bitmap.createBitmap(bounds.width(),bounds.height(),Bitmap.Config.ARGB_8888) : null;\n// bug_end\n  Bitmap maskBitmap=composition.hasMasks() ? Bitmap.createBitmap(bounds.width(),bounds.height(),Bitmap.Config.ALPHA_8) : null;\n  Bitmap matteBitmap=composition.hasMattes() ? Bitmap.createBitmap(bounds.width(),bounds.height(),Bitmap.Config.ARGB_8888) : null;\n  Bitmap mainBitmapForMatte=null;\n  Bitmap maskBitmapForMatte=null;\n  Bitmap matteBitmapForMatte=null;\n  LotteLayerView maskedLayer=null;\n  for (int i=0; i < reversedLayers.size(); i++) {\n    LotteLayer layer=reversedLayers.get(i);\n    LotteLayerView layerView;\n    if (maskedLayer == null) {\n      layerView=new LotteLayerView(layer,composition,this,mainBitmap,maskBitmap,matteBitmap);\n    }\n else {\n      if (mainBitmapForMatte == null) {\n        mainBitmapForMatte=Bitmap.createBitmap(bounds.width(),bounds.height(),Bitmap.Config.ALPHA_8);\n        maskBitmapForMatte=Bitmap.createBitmap(bounds.width(),bounds.height(),Bitmap.Config.ALPHA_8);\n        matteBitmapForMatte=Bitmap.createBitmap(bounds.width(),bounds.height(),Bitmap.Config.ALPHA_8);\n      }\n      layerView=new LotteLayerView(layer,composition,this,mainBitmapForMatte,maskBitmapForMatte,matteBitmapForMatte);\n    }\n    layerMap.put(layerView.getId(),layerView);\n    if (maskedLayer != null) {\n      maskedLayer.setMatte(layerView);\n      maskedLayer=null;\n    }\n else {\n      if (layer.getMatteType() == LotteLayer.MatteType.Add) {\n        maskedLayer=layerView;\n      }\n      rootAnimatableLayer.addLayer(layerView);\n    }\n  }\n}\n"}
{"INPUT": "private boolean canExit(){\n  if (backPressTimer + 2000 > System.currentTimeMillis()) {\n    return true;\n  }\n else {\n// bug_start\n    Toast.makeText(App.getInstance(),R.string.press_again_to_exit,Toast.LENGTH_SHORT).show();\n// bug_end\n  }\n  backPressTimer=System.currentTimeMillis();\n  return false;\n}\n"}
{"INPUT": "public <K,V>Map<K,V> selectMap(String statement,Object parameter,String mapKey,RowBounds rowBounds){\n  final List<?> list=selectList(statement,parameter,rowBounds);\n// bug_start\n  final DefaultMapResultHandler mapResultHandler=new DefaultMapResultHandler(mapKey);\n// bug_end\n  final DefaultResultContext context=new DefaultResultContext();\n  for (  Object o : list) {\n    context.nextResultObject(o);\n    mapResultHandler.handleResult(context);\n  }\n// bug_start\n  @SuppressWarnings(\"unchecked\") Map<K,V> selectedMap=mapResultHandler.getMappedResults();\n// bug_end\n  return selectedMap;\n}\n"}
{"INPUT": "public CellTowerMarker(Context context,MapView mapView,String aTitle,String aSnippet,GeoPoint aGeoPoint,MarkerData data){\n  super(mapView);\n  mContext=context;\n  mTitle=aTitle;\n  mSnippet=aSnippet;\n  mPosition=aGeoPoint;\n  mMarkerData=data;\n  mOnMarkerClickListener=new OnCellTowerMarkerClickListener();\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public static Map<PropertyKey,String> getNestedProperties(PropertyKey prefixKey){\n// bug_start\n  int prefixKeyLen=prefixKey.length();\n// bug_end\n  Map<PropertyKey,String> ret=Maps.newHashMap();\n  for (  Map.Entry<String,String> entry : PROPERTIES.entrySet()) {\n    String key=entry.getKey();\n// bug_start\n    if (key.length() > prefixKeyLen + 1 && key.startsWith(prefixKey.toString()) && key.charAt(prefixKeyLen) == '.') {\n      String suffixKey=key.substring(prefixKeyLen + 1);\n// bug_end\n      if (PropertyKey.isValid(suffixKey)) {\n        ret.put(PropertyKey.fromString(suffixKey),entry.getValue());\n      }\n    }\n  }\n  return ret;\n}\n"}
{"INPUT": "@MarshalsPointer public static long toNative(List<CFURLFileSystemProperty> l,long flags){\n  if (l == null) {\n    return 0L;\n  }\n  CFArray array=CFMutableArray.create();\n// bug_start\n  for (  CFURLFileSystemProperty i : l) {\n    array.add(i.value());\n// bug_end\n  }\n  return CFType.Marshaler.toNative(array,flags);\n}\n"}
{"INPUT": "public String getPasswordValue(Object o){\n  if (o == null)   return null;\n  if (o instanceof Secret)   return ((Secret)o).getEncryptedValue();\n// bug_start\n// bug_end\n  return o.toString();\n}\n"}
{"INPUT": "// bug_start\nvoid startPreview(TransferImage targetImage,String imgUrl,TransferConfig config,int position){\n// bug_end\n  targetImage.enable();\n  if (imgUrl.endsWith(\"gif\")) {\n// bug_start\n    File cache=config.getImageLoader().getCache(imgUrl);\n    try {\n      targetImage.setImageDrawable(new GifDrawable(cache.getPath()));\n    }\n catch (    IOException ignored) {\n// bug_end\n    }\n  }\n  transfer.bindOnOperationListener(targetImage,imgUrl,position);\n}\n"}
{"INPUT": "private void initializeMulticastSocket(){\n  try {\n    int port=getOrDefault(MulticastProperties.PORT,DEFAULT_MULTICAST_PORT);\n    PortValueValidator validator=new PortValueValidator();\n    validator.validate(port);\n    String group=getOrDefault(MulticastProperties.GROUP,DEFAULT_MULTICAST_GROUP);\n    multicastSocket=new MulticastSocket(null);\n    multicastSocket.bind(new InetSocketAddress(port));\n// bug_start\n// bug_end\n    multicastSocket.setReuseAddress(true);\n    multicastSocket.setTimeToLive(SOCKET_TIME_TO_LIVE);\n    multicastSocket.setReceiveBufferSize(DATA_OUTPUT_BUFFER_SIZE);\n    multicastSocket.setSendBufferSize(DATA_OUTPUT_BUFFER_SIZE);\n    multicastSocket.setSoTimeout(SOCKET_TIMEOUT);\n    multicastSocket.joinGroup(InetAddress.getByName(group));\n    multicastDiscoverySender=new MulticastDiscoverySender(discoveryNode,multicastSocket,logger,group,port);\n    multicastDiscoveryReceiver=new MulticastDiscoveryReceiver(multicastSocket,logger);\n    if (discoveryNode == null) {\n      isClient=true;\n    }\n  }\n catch (  Exception e) {\n    logger.finest(e.getMessage());\n    rethrow(e);\n  }\n}\n"}
{"INPUT": "@Override public ListenableFuture<byte[]> processRequest(ChannelHandlerContext channelHandlerContext,ByteBuf request){\n  long queryStartTimeNs=System.nanoTime();\n  _serverMetrics.addMeteredGlobalValue(ServerMeter.QUERIES,1);\n  LOGGER.debug(\"processing request : {}\",request);\n  DataTable instanceResponse=null;\n  byte[] byteArray=new byte[request.readableBytes()];\n  request.readBytes(byteArray);\n  SerDe serDe=new SerDe(new TCompactProtocol.Factory());\n  InstanceRequest instanceRequest=null;\n  TimerContext timerContext=null;\n  QueryRequest queryRequest=null;\n  try {\n    instanceRequest=new InstanceRequest();\n    if (!serDe.deserialize(instanceRequest,byteArray)) {\n      LOGGER.error(\"Failed to deserialize query request from broker ip: {}\",((InetSocketAddress)channelHandlerContext.channel().remoteAddress()).getAddress().getHostAddress());\n      DataTable result=new DataTable();\n      result.addException(QueryException.INTERNAL_ERROR);\n      _serverMetrics.addMeteredGlobalValue(ServerMeter.REQUEST_DESERIALIZATION_EXCEPTIONS,1);\n      queryRequest=new QueryRequest(null,_serverMetrics);\n      queryRequest.getTimerContext().setQueryArrivalTimeNs(queryStartTimeNs);\n      return Futures.immediateFuture(ScheduledRequestHandler.serializeDataTable(queryRequest,instanceResponse));\n    }\n    queryRequest=new QueryRequest(instanceRequest,_serverMetrics);\n    timerContext=queryRequest.getTimerContext();\n    timerContext.setQueryArrivalTimeNs(queryStartTimeNs);\n    TimerContext.Timer deserializeTimer=timerContext.startNewPhaseTimerAtNs(ServerQueryPhase.REQUEST_DESERIALIZATION,queryStartTimeNs);\n    deserializeTimer.stopAndRecord();\n    LOGGER.debug(\"Processing requestId: {},request: {}\",instanceRequest.getRequestId(),instanceRequest);\n    instanceResponse=_queryExecutor.processQuery(queryRequest);\n  }\n catch (  Exception e) {\n    LOGGER.error(\"Got exception while processing request. Returning error response for requestId: {}, brokerId: {}\",instanceRequest.getRequestId(),instanceRequest.getBrokerId(),e);\n    _serverMetrics.addMeteredGlobalValue(ServerMeter.UNCAUGHT_EXCEPTIONS,1);\n// bug_start\n    DataTableBuilder dataTableBuilder=new DataTableBuilder(null);\n    List<ProcessingException> exceptions=new ArrayList<ProcessingException>();\n    ProcessingException exception=QueryException.INTERNAL_ERROR.deepCopy();\n    exception.setMessage(e.getMessage());\n    exceptions.add(exception);\n    instanceResponse=dataTableBuilder.buildExceptions();\n// bug_end\n  }\n  byte[] responseBytes=ScheduledRequestHandler.serializeDataTable(queryRequest,instanceResponse);\n  ListenableFuture<byte[]> responseFuture=Futures.immediateFuture(responseBytes);\n  return responseFuture;\n}\n"}
{"INPUT": "@Test public void getDirectoryHistoryParser(){\n  Class<? extends HistoryParser> expResult=CVSHistoryParser.class;\n// bug_start\n  Class<? extends HistoryParser> result=instance.getDirectoryHistoryParser();\n// bug_end\n  assertEquals(expResult,result);\n}\n"}
{"INPUT": "// bug_start\npublic HeatmapJsonFacet(NamedList<Object> heatmapNL){\n// bug_end\n  gridLevel=(int)heatmapNL.get(\"gridLevel\");\n  columns=(int)heatmapNL.get(\"columns\");\n  rows=(int)heatmapNL.get(\"rows\");\n  minX=(double)heatmapNL.get(\"minX\");\n  maxX=(double)heatmapNL.get(\"maxX\");\n  minY=(double)heatmapNL.get(\"minY\");\n  maxY=(double)heatmapNL.get(\"maxY\");\n  log.debug(\"Rows is: {}\",rows);\n  log.debug(\"Cols is {}\",columns);\n  log.debug(\"Whole deal is: {}\",heatmapNL);\n  if (heatmapNL.get(\"counts_ints2D\") == null) {\n    countEncodedAsBase64PNG=(String)heatmapNL.get(\"counts_png\");\n  }\n else {\n    countGrid=(List<List<Integer>>)heatmapNL.get(\"counts_ints2D\");\n  }\n}\n"}
{"INPUT": "public void populateExchangeFromRestletRequest(Request request,Response response,Exchange exchange) throws Exception {\n  Message inMessage=exchange.getIn();\n  inMessage.setHeader(RestletConstants.RESTLET_REQUEST,request);\n  inMessage.setHeader(RestletConstants.RESTLET_RESPONSE,response);\n  for (  Map.Entry<String,Object> entry : request.getAttributes().entrySet()) {\n    if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(),entry.getValue(),exchange)) {\n      String key=entry.getKey();\n      Object value=entry.getValue();\n      inMessage.setHeader(key,value);\n      LOG.debug(\"Populate exchange from Restlet request header: {} value: {}\",key,value);\n// bug_start\n// bug_end\n    }\n  }\n  String query=request.getResourceRef().getQuery();\n  if (query != null) {\n    inMessage.setHeader(Exchange.HTTP_QUERY,query);\n  }\n  inMessage.setHeader(Exchange.HTTP_URI,request.getResourceRef().getIdentifier(true));\n  inMessage.setHeader(Exchange.HTTP_METHOD,request.getMethod().toString());\n  if (!request.isEntityAvailable()) {\n    return;\n  }\n  if (request.getEntity().getMediaType() != null && request.getEntity().getMediaType().equals(MediaType.APPLICATION_WWW_FORM)) {\n    Form form=new Form(request.getEntity());\n    for (    Map.Entry<String,String> entry : form.getValuesMap().entrySet()) {\n      String key=entry.getKey();\n      String value=entry.getValue();\n      if (value == null) {\n        inMessage.setBody(key);\n        LOG.debug(\"Populate exchange from Restlet request body: {}\",key);\n      }\n else {\n        if (!headerFilterStrategy.applyFilterToExternalHeaders(key,value,exchange)) {\n          inMessage.setHeader(key,value);\n          LOG.debug(\"Populate exchange from Restlet request user header: {} value: {}\",key,value);\n        }\n      }\n    }\n  }\n else {\n    inMessage.setBody(request.getEntity().getStream());\n  }\n}\n"}
{"INPUT": "@Test void findNestedClassesWithSeeminglyRecursiveHierarchies(){\n  assertThat(findNestedClasses(AbstractOuterClass.class)).containsExactly(AbstractOuterClass.InnerClass.class);\n// bug_start\n// bug_end\n  assertThat(findNestedClasses(StaticNestedSiblingClass.class)).containsExactly(AbstractOuterClass.InnerClass.class);\n  assertThat(findNestedClasses(InnerSiblingClass.class)).containsExactly(AbstractOuterClass.InnerClass.class);\n  assertThat(findNestedClasses(OuterClassImplementingInterface.class)).containsExactly(InnerClassImplementingInterface.class,Nested4.class);\n  assertThat(findNestedClasses(InnerClassImplementingInterface.class)).containsExactly(Nested4.class);\n}\n"}
{"INPUT": "protected void parseSetting(final String option,final List<String> items){\n  if (option.equalsIgnoreCase(\"-excludeAll\")) {\n// bug_start\n    includeClasses=new HashSet<String>();\n    excludeClasses=null;\n    includeClusters=new HashSet<String>();\n    excludeClusters=null;\n// bug_end\n    includeInfo=false;\n    includeClusterDefinitions=false;\n    includeSchema=false;\n    includeSecurity=false;\n    includeRecords=false;\n    includeIndexDefinitions=false;\n    includeManualIndexes=false;\n  }\n else   if (option.equalsIgnoreCase(\"-includeClass\")) {\n    includeClasses=new HashSet<String>();\n    for (    String item : items)     includeClasses.add(item.toUpperCase());\n    includeRecords=true;\n  }\n else   if (option.equalsIgnoreCase(\"-excludeClass\")) {\n    excludeClasses=new HashSet<String>(items);\n    for (    String item : items)     excludeClasses.add(item.toUpperCase());\n  }\n else   if (option.equalsIgnoreCase(\"-includeCluster\")) {\n    includeClusters=new HashSet<String>(items);\n    for (    String item : items)     includeClusters.add(item.toUpperCase());\n    includeRecords=true;\n  }\n else   if (option.equalsIgnoreCase(\"-excludeCluster\")) {\n    excludeClusters=new HashSet<String>(items);\n    for (    String item : items)     excludeClusters.add(item.toUpperCase());\n  }\n else   if (option.equalsIgnoreCase(\"-includeInfo\")) {\n    includeInfo=Boolean.parseBoolean(items.get(0));\n  }\n else   if (option.equalsIgnoreCase(\"-includeClusterDefinitions\")) {\n    includeClusterDefinitions=Boolean.parseBoolean(items.get(0));\n  }\n else   if (option.equalsIgnoreCase(\"-includeSchema\")) {\n    includeSchema=Boolean.parseBoolean(items.get(0));\n// bug_start\n// bug_end\n  }\n else   if (option.equalsIgnoreCase(\"-includeSecurity\")) {\n    includeSecurity=Boolean.parseBoolean(items.get(0));\n  }\n else   if (option.equalsIgnoreCase(\"-includeRecords\")) {\n    includeRecords=Boolean.parseBoolean(items.get(0));\n  }\n else   if (option.equalsIgnoreCase(\"-includeIndexDefinitions\")) {\n    includeIndexDefinitions=Boolean.parseBoolean(items.get(0));\n  }\n else   if (option.equalsIgnoreCase(\"-includeManualIndexes\")) {\n    includeManualIndexes=Boolean.parseBoolean(items.get(0));\n  }\n else   if (option.equalsIgnoreCase(\"-useLineFeedForRecords\")) {\n    useLineFeedForRecords=Boolean.parseBoolean(items.get(0));\n  }\n}\n"}
{"INPUT": "private static void testClientTimeoutAdd(RestTemplate template,String cseUrlPrefix){\n  Map<String,String> params=new HashMap<>();\n  params.put(\"a\",\"5\");\n  params.put(\"b\",\"20\");\n  boolean isExcep=false;\n  try {\n    template.postForObject(cseUrlPrefix + \"add\",params,Integer.class);\n  }\n catch (  InvocationException e) {\n    isExcep=true;\n// bug_start\n    TestMgr.check(490,e.getStatus().getStatusCode());\n    TestMgr.check(\"CommonExceptionData [message=Cse Internal Bad Request]\",e.getErrorData());\n// bug_end\n  }\n  TestMgr.check(true,isExcep);\n}\n"}
{"INPUT": "public SchemaFactory newFactory(String schemaLanguage){\n// bug_start\n  if (schemaLanguage == null)   throw new NullPointerException();\n// bug_end\n  SchemaFactory f=_newFactory(schemaLanguage);\n  if (debug) {\n    if (f != null) {\n      debugPrintln(\"factory '\" + f.getClass().getName() + \"' was found for \"+ schemaLanguage);\n    }\n else {\n      debugPrintln(\"unable to find a factory for \" + schemaLanguage);\n    }\n  }\n  return f;\n}\n"}
{"INPUT": "@Override public Optional<MultifactorAuthenticationProvider> isActivated(final Authentication authentication,final RegisteredService registeredService,final HttpServletRequest httpServletRequest,final Service service){\n  if (this.scriptCache == null) {\n    this.scriptCache=new LinkedHashMap<>(1);\n  }\n  if (authentication == null || registeredService == null) {\n    LOGGER.debug(\"No authentication or service is available to determine event for principal\");\n    return Optional.empty();\n  }\n  val policy=registeredService.getMultifactorPolicy();\n  if (policy == null || StringUtils.isBlank(policy.getScript())) {\n    LOGGER.trace(\"Multifactor authentication policy is absent or does not define a script to trigger multifactor authentication\");\n    return Optional.empty();\n  }\n  val mfaScript=policy.getScript();\n  val providerMap=MultifactorAuthenticationUtils.getAvailableMultifactorAuthenticationProviders(this.applicationContext);\n  if (providerMap.isEmpty()) {\n    LOGGER.error(\"No multifactor authentication providers are available in the application context\");\n    throw new AuthenticationException(new MultifactorAuthenticationProviderAbsentException());\n  }\n  LOGGER.trace(\"Locating multifactor authentication trigger script [{}] in script cache...\",mfaScript);\n  if (!scriptCache.containsKey(mfaScript)) {\n    val matcherInline=ScriptingUtils.getMatcherForInlineGroovyScript(mfaScript);\n    val matcherFile=ScriptingUtils.getMatcherForExternalGroovyScript(mfaScript);\n    if (matcherInline.find()) {\n      val script=new GroovyShellScript(matcherInline.group(1));\n      scriptCache.put(mfaScript,script);\n      LOGGER.trace(\"Caching multifactor authentication trigger script as an executable shell script\");\n    }\n else     if (matcherFile.find()) {\n      try {\n        val scriptPath=SpringExpressionLanguageValueResolver.getInstance().resolve(matcherFile.group());\n        val resource=ResourceUtils.getRawResourceFrom(scriptPath);\n        val script=new WatchableGroovyScriptResource(resource);\n        scriptCache.put(mfaScript,script);\n        LOGGER.trace(\"Caching multifactor authentication trigger script as script resource [{}]\",resource);\n      }\n catch (      final Exception e) {\n// bug_start\n        LOGGER.error(e.getMessage(),e);\n// bug_end\n      }\n    }\n  }\n  val executableScript=scriptCache.get(mfaScript);\n  LOGGER.debug(\"Executing multifactor authentication trigger script [{}]\",executableScript);\n  val result=executableScript.execute(new Object[]{authentication,registeredService,httpServletRequest,service,applicationContext,LOGGER},String.class);\n  LOGGER.debug(\"Multifactor authentication provider delivered by trigger script is [{}]\",result);\n  if (StringUtils.isBlank(result)) {\n    LOGGER.debug(\"No multifactor authentication is returned from trigger script\");\n    return Optional.empty();\n  }\n  val providerResult=providerMap.values().stream().filter(null).findFirst();\n  if (providerResult.isEmpty()) {\n    LOGGER.error(\"Unable to locate multifactor authentication provider [{}] in the application context\",result);\n    throw new AuthenticationException(new MultifactorAuthenticationProviderAbsentException());\n  }\n  return providerResult;\n}\n"}
{"INPUT": "public DefaultImpl(){\n  ClassLoader cl=Thread.currentThread().getContextClassLoader();\n  try {\n// bug_start\n    Class<?> mgmtFactory=Class.forName(\"java.lang.management.ManagementFactory\",true,cl);\n    Class<?> runtimeClass=Class.forName(\"java.lang.management.RuntimeMXBean\",true,cl);\n    Class<?>[] noParams=new Class<?>[0];\n    Method mxBeanMethod=mgmtFactory.getMethod(\"getRuntimeMXBean\",noParams);\n// bug_end\n    if (mxBeanMethod == null) {\n      throw new UnsupportedOperationException(\"method getRuntimeMXBean() not found\");\n    }\n    mxBean=mxBeanMethod.invoke(mgmtFactory);\n    if (mxBean == null) {\n      throw new UnsupportedOperationException(\"getRuntimeMXBean() method returned null\");\n    }\n    uptimeMethod=runtimeClass.getMethod(\"getUptime\",noParams);\n    if (mxBean == null) {\n      throw new UnsupportedOperationException(\"method getUptime() not found\");\n    }\n  }\n catch (  ClassNotFoundException|NoClassDefFoundError|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {\n    throw new UnsupportedOperationException(\"Implementation not available in this environment\",e);\n  }\n}\n"}
{"INPUT": "public static List<BibEntry> getSortedEntries(BibDatabaseContext bibDatabaseContext,List<BibEntry> entriesToSort,SavePreferences preferences){\n  if (bibDatabaseContext.getMetaData() == null) {\n    List<BibEntry> result=new LinkedList<>();\n// bug_start\n    result.addAll(bibDatabaseContext.getDatabase().getEntries());\n// bug_end\n    return result;\n  }\n  List<Comparator<BibEntry>> comparators=BibDatabaseWriter.getSaveComparators(preferences,bibDatabaseContext.getMetaData());\n  FieldComparatorStack<BibEntry> comparatorStack=new FieldComparatorStack<>(comparators);\n  List<BibEntry> sorted=new ArrayList<>();\n// bug_start\n  sorted.addAll(entriesToSort);\n// bug_end\n  Collections.sort(sorted,comparatorStack);\n  return sorted;\n}\n"}
{"INPUT": "@Implementation public static Bitmap createBitmap(Bitmap src,int x,int y,int width,int height,Matrix matrix,boolean filter){\n  if (x == 0 && y == 0 && width == src.getWidth() && height == src.getHeight() && (matrix == null || matrix.isIdentity())) {\n    return src;\n  }\n  if (x + width > src.getWidth()) {\n    throw new IllegalArgumentException(\"x + width must be <= bitmap.width()\");\n  }\n  if (y + height > src.getHeight()) {\n    throw new IllegalArgumentException(\"y + height must be <= bitmap.height()\");\n  }\n  Bitmap newBitmap=ReflectionHelpers.callConstructor(Bitmap.class);\n  ShadowBitmap shadowNewBitmap=Shadow.extract(newBitmap);\n  ShadowBitmap shadowSrcBitmap=Shadow.extract(src);\n  shadowNewBitmap.appendDescription(shadowSrcBitmap.getDescription());\n  shadowNewBitmap.appendDescription(\" at (\" + x + \",\"+ y+ \")\");\n  shadowNewBitmap.appendDescription(\" with width \" + width + \" and height \"+ height);\n// bug_start\n// bug_end\n  if (matrix != null) {\n    ShadowMatrix shadowMatrix=Shadow.extract(matrix);\n    shadowNewBitmap.appendDescription(\" using matrix \" + shadowMatrix.getDescription());\n    RectF mappedRect=new RectF();\n    matrix.mapRect(mappedRect,new RectF(0,0,width,height));\n    width=Math.round(mappedRect.width());\n    height=Math.round(mappedRect.height());\n  }\n  if (filter) {\n    shadowNewBitmap.appendDescription(\" with filter\");\n  }\n// bug_start\n  shadowNewBitmap.createdFromBitmap=src;\n  shadowNewBitmap.createdFromX=x;\n  shadowNewBitmap.createdFromY=y;\n  shadowNewBitmap.createdFromWidth=width;\n  shadowNewBitmap.createdFromHeight=height;\n  shadowNewBitmap.createdFromMatrix=matrix;\n  shadowNewBitmap.createdFromFilter=filter;\n// bug_end\n  shadowNewBitmap.width=width;\n  shadowNewBitmap.height=height;\n  return newBitmap;\n}\n"}
{"INPUT": "static BufferedImage getRadioButtonSizerImage(){\n// bug_start\n  final BufferedImage img=new BufferedImage(20,20,BufferedImage.TYPE_INT_ARGB);\n// bug_end\n  Graphics g=img.getGraphics();\n  g.setColor(Color.pink);\n  g.fillRect(0,0,20,20);\n// bug_start\n// bug_end\n  return img;\n}\n"}
{"INPUT": "@Test public void testOrdered() throws Exception {\n  Main main=new Main();\n// bug_start\n  main.addRouteBuilder(new BarRouteBuilder());\n  main.addRouteBuilder(new FooRouteBuilder());\n// bug_end\n  main.start();\n  CamelContext camelContext=main.getCamelContext();\n  assertEquals(2,camelContext.getRoutes().size());\n  assertEquals(\"foo\",camelContext.getRoutes().get(0).getId());\n  assertEquals(\"bar\",camelContext.getRoutes().get(1).getId());\n  main.stop();\n}\n"}
{"INPUT": "ScanResultsScoreCacheFilter(Supplier<List<ScanResult>> resultsSupplier){\n  List<ScanResult> scanResults=resultsSupplier.get();\n  final int size=scanResults.size();\n  mScanResultKeys=new ArraySet<>(size);\n  for (int i=0; i < size; i++) {\n    ScanResult scanResult=scanResults.get(i);\n// bug_start\n    mScanResultKeys.add(NetworkKey.createFromScanResult(scanResult));\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override protected PrivateKey createInstance() throws Exception {\n// bug_start\n  try (final InputStream privKey=this.location.getInputStream()){\n// bug_end\n    final byte[] bytes=new byte[privKey.available()];\n    privKey.read(bytes);\n    final PKCS8EncodedKeySpec privSpec=new PKCS8EncodedKeySpec(bytes);\n    final KeyFactory factory=KeyFactory.getInstance(this.algorithm);\n    return factory.generatePrivate(privSpec);\n  }\n }\n"}
{"INPUT": "public void emit(HttpField field) throws HpackException.SessionException {\n  HttpHeader header=field.getHeader();\n  String name=field.getName();\n  String value=field.getValue();\n  int field_size=name.length() + (value == null ? 0 : value.length());\n  _size+=field_size + 32;\n  if (_size > _maxSize)   throw new HpackException.SessionException(\"Header Size %d > %d\",_size,_maxSize);\n  if (field instanceof StaticTableHttpField) {\n    StaticTableHttpField staticField=(StaticTableHttpField)field;\nswitch (header) {\ncase C_STATUS:\n// bug_start\n      if (checkPseudoHeader(header,_status))       _status=(Integer)staticField.getStaticValue();\n// bug_end\n    _response=true;\n  break;\ncase C_METHOD:\nif (checkPseudoHeader(header,_method)) _method=value;\n_request=true;\nbreak;\ncase C_SCHEME:\nif (checkPseudoHeader(header,_scheme)) _scheme=(HttpScheme)staticField.getStaticValue();\n_request=true;\nbreak;\ndefault :\nthrow new IllegalArgumentException(name);\n}\n}\n else if (header != null) {\nswitch (header) {\ncase C_STATUS:\n// bug_start\nif (checkPseudoHeader(header,_status)) _status=Integer.valueOf(field.getIntValue());\n// bug_end\n_response=true;\nbreak;\ncase C_METHOD:\nif (checkPseudoHeader(header,_method)) _method=value;\n_request=true;\nbreak;\ncase C_SCHEME:\nif (checkPseudoHeader(header,_scheme) && value != null) _scheme=HttpScheme.CACHE.get(value);\n_request=true;\nbreak;\ncase C_AUTHORITY:\nif (checkPseudoHeader(header,_authority)) {\nif (field instanceof HostPortHttpField) _authority=(HostPortHttpField)field;\n else if (value != null) _authority=new AuthorityHttpField(value);\n}\n_request=true;\nbreak;\ncase HOST:\nif (_authority == null) {\nif (field instanceof HostPortHttpField) _authority=(HostPortHttpField)field;\n else if (value != null) _authority=new AuthorityHttpField(value);\n}\n_fields.add(field);\nbreak;\ncase C_PATH:\nif (checkPseudoHeader(header,_path)) {\nif (value != null && value.length() > 0) _path=value;\n else streamException(\"No Path\");\n}\n_request=true;\nbreak;\ncase CONTENT_LENGTH:\n_contentLength=field.getLongValue();\n_fields.add(field);\nbreak;\ncase TE:\nif (\"trailers\".equalsIgnoreCase(value)) _fields.add(field);\n else streamException(\"Unsupported TE value '%s'\",value);\nbreak;\ncase CONNECTION:\nif (\"TE\".equalsIgnoreCase(value)) _fields.add(field);\n else streamException(\"Connection specific field '%s'\",header);\nbreak;\ndefault :\nif (name.charAt(0) == ':') streamException(\"Unknown pseudo header '%s'\",name);\n else _fields.add(field);\nbreak;\n}\n}\n else {\nif (name.charAt(0) == ':') streamException(\"Unknown pseudo header '%s'\",name);\n else _fields.add(field);\n}\n}\n"}
{"INPUT": "@Override protected RestChannelConsumer prepareRequest(RestRequest restRequest,NodeClient client) throws IOException {\n  String id=restRequest.param(DataFrameField.ID.getPreferredName());\n// bug_start\n  StartDataFrameTransformAction.Request request=new StartDataFrameTransformAction.Request(id);\n// bug_end\n  request.timeout(restRequest.paramAsTime(DataFrameField.TIMEOUT.getPreferredName(),AcknowledgedRequest.DEFAULT_ACK_TIMEOUT));\n  return null;\n}\n"}
{"INPUT": "Language autoDetectLanguage(String text){\n  final LanguageIdentifier langIdentifier=new LanguageIdentifier(text);\n  Language lang;\n  try {\n    lang=Language.getLanguageForShortName(langIdentifier.getLanguage());\n  }\n catch (  IllegalArgumentException e) {\n    lang=Language.getLanguageForLocale(Locale.getDefault());\n  }\n  if (lang.hasVariant()) {\n// bug_start\n    lang=lang.getDefaultVariant();\n// bug_end\n  }\n  return lang;\n}\n"}
{"INPUT": "public void testRandomSortedBytes() throws IOException {\n  Directory dir=newDirectory();\n  IndexWriterConfig cfg=newIndexWriterConfig(new MockAnalyzer(random()));\n  if (!codecSupportsDocsWithField()) {\n    cfg.setMergePolicy(newLogMergePolicy());\n  }\n  RandomIndexWriter w=new RandomIndexWriter(random(),dir,cfg);\n  int numDocs=atLeast(100);\n  BytesRefHash hash=new BytesRefHash();\n  Map<String,String> docToString=new HashMap<>();\n  int maxLength=TestUtil.nextInt(random(),1,50);\n  for (int i=0; i < numDocs; i++) {\n    Document doc=new Document();\n    doc.add(newTextField(\"id\",\"\" + i,Field.Store.YES));\n    String string=TestUtil.randomRealisticUnicodeString(random(),1,maxLength);\n    BytesRef br=new BytesRef(string);\n    doc.add(new SortedDocValuesField(\"field\",br));\n    hash.add(br);\n    docToString.put(\"\" + i,string);\n    w.addDocument(doc);\n  }\n  if (rarely()) {\n    w.commit();\n  }\n  int numDocsNoValue=atLeast(10);\n  for (int i=0; i < numDocsNoValue; i++) {\n    Document doc=new Document();\n    doc.add(newTextField(\"id\",\"noValue\",Field.Store.YES));\n    w.addDocument(doc);\n  }\n  if (!codecSupportsDocsWithField()) {\n    BytesRef bytesRef=new BytesRef();\n    hash.add(bytesRef);\n  }\n  if (rarely()) {\n    w.commit();\n  }\n  if (!codecSupportsDocsWithField()) {\n    w.forceMerge(1);\n  }\n  for (int i=0; i < numDocs; i++) {\n    Document doc=new Document();\n    String id=\"\" + i + numDocs;\n    doc.add(newTextField(\"id\",id,Field.Store.YES));\n    String string=TestUtil.randomRealisticUnicodeString(random(),1,maxLength);\n    BytesRef br=new BytesRef(string);\n    hash.add(br);\n    docToString.put(id,string);\n    doc.add(new SortedDocValuesField(\"field\",br));\n    w.addDocument(doc);\n  }\n  w.commit();\n  IndexReader reader=w.getReader();\n  SortedDocValues docValues=MultiDocValues.getSortedValues(reader,\"field\");\n  int[] sort=hash.sort(BytesRef.getUTF8SortedAsUnicodeComparator());\n  BytesRef expected=new BytesRef();\n  assertEquals(hash.size(),docValues.getValueCount());\n  for (int i=0; i < hash.size(); i++) {\n    hash.get(sort[i],expected);\n    final BytesRef actual=docValues.lookupOrd(i);\n    assertEquals(expected.utf8ToString(),actual.utf8ToString());\n    int ord=docValues.lookupTerm(expected);\n    assertEquals(i,ord);\n  }\n  LeafReader slowR=SlowCompositeReaderWrapper.wrap(reader);\n  Set<Entry<String,String>> entrySet=docToString.entrySet();\n  for (  Entry<String,String> entry : entrySet) {\n// bug_start\n    PostingsEnum termPostingsEnum=slowR.termDocsEnum(new Term(\"id\",entry.getKey()));\n// bug_end\n    int docId=termPostingsEnum.nextDoc();\n    expected=new BytesRef(entry.getValue());\n    final BytesRef actual=docValues.get(docId);\n    assertEquals(expected,actual);\n  }\n  reader.close();\n  w.close();\n  dir.close();\n}\n"}
{"INPUT": "@Test public void serializationBasic(){\n  List<Mutation> mutations=Arrays.asList(Mutation.newInsertBuilder(\"T\").set(\"C\").to(\"V\").build(),Mutation.newUpdateBuilder(\"T\").set(\"C\").to(\"V\").build(),Mutation.newInsertOrUpdateBuilder(\"T\").set(\"C\").to(\"V\").build(),Mutation.newReplaceBuilder(\"T\").set(\"C\").to(\"V\").build(),Mutation.delete(\"T\",KeySet.singleKey(Key.of(\"k\"))));\n  List<com.google.spanner.v1.Mutation> proto=new ArrayList<>();\n  com.google.spanner.v1.Mutation existingProto=com.google.spanner.v1.Mutation.getDefaultInstance();\n  proto.add(existingProto);\n  Mutation.toProto(mutations,proto);\n  assertThat(proto.size()).isAtLeast(1);\n// bug_start\n  assertThat(proto.get(0)).isSameAs(existingProto);\n// bug_end\n  proto.remove(0);\n  assertThat(proto.size()).isEqualTo(5);\n  MatcherAssert.assertThat(proto.get(0),matchesProto(\"insert { table: 'T' columns: 'C' values { values { string_value: 'V' } } }\"));\n  MatcherAssert.assertThat(proto.get(1),matchesProto(\"update { table: 'T' columns: 'C' values { values { string_value: 'V' } } }\"));\n  MatcherAssert.assertThat(proto.get(2),matchesProto(\"insert_or_update { table: 'T' columns: 'C'\" + \" values { values { string_value: 'V' } } }\"));\n  MatcherAssert.assertThat(proto.get(3),matchesProto(\"replace { table: 'T' columns: 'C' values { values { string_value: 'V' } } }\"));\n  MatcherAssert.assertThat(proto.get(4),matchesProto(\"delete { table: 'T' key_set { keys { values { string_value: 'k' } } } }\"));\n}\n"}
{"INPUT": "@Override protected boolean addDeclaration(PsiElement declaration,PsiElement child){\n  String name=PsiUtilCore.getName(child);\n  GoPsiElement goPsi=(GoPsiElement)declaration;\n  GoPsiElement goChildPsi=(GoPsiElement)child;\n// bug_start\n  variants.add(createLookupElement(goPsi,name,goChildPsi).setTypeText(\"builtin\",true));\n// bug_end\n  return true;\n}\n"}
{"INPUT": "public void testConfigurationBuilder() throws Exception {\n  deleteFile(\"./twitter4j.properties\");\n  ConfigurationBuilder builder;\n  Configuration conf;\n  builder=new ConfigurationBuilder();\n  conf=builder.build();\n  Configuration t=(Configuration)serializeDeserialize(conf);\n// bug_start\n  assertSame(conf,(Configuration)serializeDeserialize(conf));\n// bug_end\n  assertTrue(0 == conf.getRestBaseURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getSearchBaseURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAuthenticationURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAuthorizationURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAccessTokenURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthRequestTokenURL().indexOf(\"http://\"));\n  builder=new ConfigurationBuilder();\n  builder.setUseSSL(true);\n  conf=builder.build();\n  assertTrue(0 == conf.getRestBaseURL().indexOf(\"https://\"));\n  assertTrue(0 == conf.getSearchBaseURL().indexOf(\"https://\"));\n  assertTrue(0 == conf.getOAuthAuthenticationURL().indexOf(\"https://\"));\n  assertTrue(0 == conf.getOAuthAuthorizationURL().indexOf(\"https://\"));\n  assertTrue(0 == conf.getOAuthAccessTokenURL().indexOf(\"https://\"));\n  assertTrue(0 == conf.getOAuthRequestTokenURL().indexOf(\"https://\"));\n  builder=new ConfigurationBuilder();\n  builder.setUseSSL(false);\n  conf=builder.build();\n  assertTrue(0 == conf.getRestBaseURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getSearchBaseURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAuthenticationURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAuthorizationURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAccessTokenURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthRequestTokenURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getUserStreamBaseURL().indexOf(\"https://\"));\n  builder=new ConfigurationBuilder();\n  builder.setOAuthConsumerKey(\"key\");\n  builder.setOAuthConsumerSecret(\"secret\");\n  conf=builder.build();\n  assertTrue(0 == conf.getRestBaseURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getSearchBaseURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAuthenticationURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAuthorizationURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAccessTokenURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthRequestTokenURL().indexOf(\"http://\"));\n  RequestToken rt=new RequestToken(\"key\",\"secret\");\n  assertTrue(0 == rt.getAuthenticationURL().indexOf(\"http://\"));\n  assertTrue(0 == rt.getAuthorizationURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthAccessTokenURL().indexOf(\"http://\"));\n  assertTrue(0 == conf.getOAuthRequestTokenURL().indexOf(\"http://\"));\n  writeFile(\"./twitter4j.properties\",\"twitter4j.restBaseURL=http://somewhere.com/\" + \"\\n\" + \"twitter4j.debug=true\"+ \"\\n\"+ \"media.providerParameters=debug=true&foo=bar\");\n  conf=new ConfigurationBuilder().build();\n  assertEquals(\"http://somewhere.com/\",conf.getRestBaseURL());\n  assertTrue(conf.isDebugEnabled());\n  Properties mediaProps=conf.getMediaProviderParameters();\n  assertNotNull(mediaProps);\n  assertNull(mediaProps.getProperty(\"hoge\"));\n  assertEquals(\"true\",mediaProps.getProperty(\"debug\"));\n  assertEquals(\"bar\",mediaProps.getProperty(\"foo\"));\n  deleteFile(\"./twitter4j.properties\");\n}\n"}
{"INPUT": "@Before public void init() throws Exception {\n  authcService=mock(AuthenticationService.class);\n  authzService=mock(AuthorizationService.class);\n  cryptoService=mock(CryptoService.class);\n  auditTrail=mock(AuditTrail.class);\n  shieldLicenseState=mock(ShieldLicenseState.class);\n  when(shieldLicenseState.securityEnabled()).thenReturn(true);\n  when(shieldLicenseState.statsAndHealthEnabled()).thenReturn(true);\n  ThreadPool threadPool=mock(ThreadPool.class);\n  when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n// bug_start\n  filter=new ShieldActionFilter(Settings.EMPTY,authcService,authzService,cryptoService,auditTrail,shieldLicenseState,new ShieldActionMapper(),new HashSet<RequestInterceptor>(),threadPool);\n// bug_end\n}\n"}
{"INPUT": "public synchronized static Set<String> getDefaultSupportedTlsProtocols(){\n  if (defaultSupportedTlsProtocols != null) {\n    return defaultSupportedTlsProtocols;\n  }\n  final Set<String> tlsProtocols=Sets.newHashSet(DEFAULT_TLS_PROTOCOLS);\n  try {\n// bug_start\n    final Set<String> supportedProtocols=ImmutableSet.copyOf(SSLContext.getDefault().createSSLEngine().getEnabledProtocols());\n// bug_end\n    if (tlsProtocols.retainAll(supportedProtocols)) {\n      LOG.warn(\"JRE doesn't support all default TLS protocols. Changing <{}> to <{}>\",DEFAULT_TLS_PROTOCOLS,tlsProtocols);\n    }\n    defaultSupportedTlsProtocols=tlsProtocols;\n  }\n catch (  NoSuchAlgorithmException e) {\n    LOG.error(\"Failed to detect supported TLS protocols. Keeping default <{}>\",DEFAULT_TLS_PROTOCOLS,e);\n    defaultSupportedTlsProtocols=DEFAULT_TLS_PROTOCOLS;\n  }\n  return defaultSupportedTlsProtocols;\n}\n"}
{"INPUT": "@Override public boolean callback(IDownloadEvent event){\n  if (!(event instanceof FileDownloadEvent)) {\n    return false;\n  }\n  final FileDownloadEvent downloaderEvent=((FileDownloadEvent)event);\nswitch (downloaderEvent.getStatus()) {\ncase FileDownloadStatus.pending:\n    pending(downloaderEvent.getDownloader(),downloaderEvent.getDownloader().getSmallFileSoFarBytes(),downloaderEvent.getDownloader().getSmallFileTotalBytes());\n  break;\ncase FileDownloadStatus.connected:\n// bug_start\nconnected(downloaderEvent.getDownloader(),downloaderEvent.getDownloader().getEtag(),downloaderEvent.getDownloader().isContinue(),downloaderEvent.getDownloader().getSmallFileSoFarBytes(),downloaderEvent.getDownloader().getSmallFileTotalBytes());\n// bug_end\nbreak;\ncase FileDownloadStatus.progress:\nprogress(downloaderEvent.getDownloader(),downloaderEvent.getDownloader().getSmallFileSoFarBytes(),downloaderEvent.getDownloader().getSmallFileTotalBytes());\nbreak;\ncase FileDownloadStatus.blockComplete:\nblockComplete(downloaderEvent.getDownloader());\nbreak;\ncase FileDownloadStatus.retry:\nretry(downloaderEvent.getDownloader(),downloaderEvent.getDownloader().getEx(),downloaderEvent.getDownloader().getRetryingTimes(),downloaderEvent.getDownloader().getSmallFileSoFarBytes());\nbreak;\ncase FileDownloadStatus.completed:\ncompleted(downloaderEvent.getDownloader());\nbreak;\ncase FileDownloadStatus.error:\nerror(downloaderEvent.getDownloader(),downloaderEvent.getDownloader().getEx());\nbreak;\ncase FileDownloadStatus.paused:\npaused(downloaderEvent.getDownloader(),downloaderEvent.getDownloader().getSmallFileSoFarBytes(),downloaderEvent.getDownloader().getSmallFileTotalBytes());\nbreak;\ncase FileDownloadStatus.warn:\nwarn(downloaderEvent.getDownloader());\nbreak;\n}\nreturn false;\n}\n"}
{"INPUT": "private boolean areSrcsBlacklisted(){\n// bug_start\n  return !new ProtoSourceFileBlacklist(ruleContext,getProtoToolchainProvider().blacklistedProtos()).checkSrcs(protoInfo.getOriginalDirectProtoSources(),\"cc_proto_library\");\n// bug_end\n}\n"}
{"INPUT": "public static WritableBatch get(RecordBatch batch){\n// bug_start\n  if (batch.getSchema() != null && batch.getSchema().getSelectionVector() != SelectionVectorMode.NONE)   throw new UnsupportedOperationException(\"Only batches without selections vectors are writable.\");\n// bug_end\n  return getBatchNoSV(batch.getRecordCount(),batch);\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n  Options options=PipelineOptionsFactory.fromArgs(args).withValidation().as(Options.class);\n  Pipeline p=Pipeline.create(options);\n  List<TableFieldSchema> fields=new ArrayList<>();\n  fields.add(new TableFieldSchema().setName(\"month\").setType(\"INTEGER\"));\n  fields.add(new TableFieldSchema().setName(\"max_mean_temp\").setType(\"FLOAT\"));\n  TableSchema schema=new TableSchema().setFields(fields);\n// bug_start\n  p.apply(BigQueryIO.read().from(options.getInput())).apply(new MaxMeanTemp()).apply(BigQueryIO.write().to(options.getOutput()).withSchema(schema).withCreateDisposition(BigQueryIO.Write.CreateDisposition.CREATE_IF_NEEDED).withWriteDisposition(BigQueryIO.Write.WriteDisposition.WRITE_TRUNCATE));\n// bug_end\n  p.run().waitUntilFinish();\n}\n"}
{"INPUT": "@Override public void cmdExecute(final Message clientMessage,final ServerConnection serverConnection,final SecurityService securityService,long start) throws IOException, ClassNotFoundException, InterruptedException {\n  serverConnection.setAsTrue(REQUIRES_RESPONSE);\n  InternalDistributedMember client=(InternalDistributedMember)serverConnection.getProxyID().getDistributedMember();\n  int uniqId=clientMessage.getTransactionId();\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"TX: Transaction {} from {} is failing over to this server\",uniqId,client);\n  }\n  TXId txId=createTXId(client,uniqId);\n  TXManagerImpl mgr=(TXManagerImpl)serverConnection.getCache().getCacheTransactionManager();\n  mgr.waitForCompletingTransaction(txId);\n  if (mgr.isHostedTxRecentlyCompleted(txId)) {\n    writeReply(clientMessage,serverConnection);\n    serverConnection.setAsTrue(RESPONDED);\n    mgr.removeHostedTXState(txId);\n    return;\n  }\n  boolean wasInProgress=mgr.setInProgress(true);\n  TXStateProxy tx=mgr.getTXState();\n  Assert.assertTrue(tx != null);\n  if (!tx.isRealDealLocal()) {\n    FindRemoteTXMessageReplyProcessor processor=sendFindRemoteTXMessage(serverConnection.getCache(),txId);\n    try {\n      processor.waitForRepliesUninterruptibly();\n    }\n catch (    ReplyException e) {\n// bug_start\n      e.handleAsUnexpected();\n// bug_end\n    }\n    InternalDistributedMember hostingMember=processor.getHostingMember();\n    if (hostingMember != null) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"TX: txState is not local, bootstrapping PeerTXState stub for targetNode: {}\",hostingMember);\n      }\n      if (tx.getTarget() == null) {\n        tx.setTarget(hostingMember);\n      }\n      tx.setLocalTXState(new PeerTXStateStub(tx,hostingMember,client));\n    }\n else {\n      InternalCache cache=serverConnection.getCache();\n      try {\n        WaitForViewInstallation.send((ClusterDistributionManager)cache.getDistributionManager());\n      }\n catch (      InterruptedException e) {\n        cache.getDistributionManager().getCancelCriterion().checkCancelInProgress(e);\n        Thread.currentThread().interrupt();\n      }\n      if (processor.getTxCommitMessage() != null) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"TX: for txId: {} rebuilt a recently completed tx\",txId);\n        }\n        mgr.saveTXCommitMessageForClientFailover(txId,processor.getTxCommitMessage());\n      }\n else {\n        writeException(clientMessage,new TransactionDataNodeHasDepartedException(\"Could not find transaction host for \" + txId),false,serverConnection);\n        serverConnection.setAsTrue(RESPONDED);\n        mgr.removeHostedTXState(txId);\n        return;\n      }\n    }\n  }\n  if (!wasInProgress) {\n    mgr.setInProgress(false);\n  }\n  writeReply(clientMessage,serverConnection);\n  serverConnection.setAsTrue(RESPONDED);\n}\n"}
{"INPUT": "@Override public void handleMessage(Message msg){\n  Bundle msgData=msg.getData();\n  if (msg.what == MSG_SHOW_COLLECTION_LOADING_ERROR_DIALOG) {\n    ((DeckPicker)mActivity.get()).showDatabaseErrorDialog(DatabaseErrorDialog.DIALOG_LOAD_FAILED);\n  }\n else   if (msg.what == MSG_SHOW_COLLECTION_IMPORT_REPLACE_DIALOG) {\n    ((DeckPicker)mActivity.get()).showImportDialog(ImportDialog.DIALOG_IMPORT_REPLACE_CONFIRM,msgData.getString(\"importPath\"));\n  }\n else   if (msg.what == MSG_SHOW_COLLECTION_IMPORT_ADD_DIALOG) {\n    ((DeckPicker)mActivity.get()).showImportDialog(ImportDialog.DIALOG_IMPORT_ADD_CONFIRM,msgData.getString(\"importPath\"));\n  }\n else   if (msg.what == MSG_SHOW_SYNC_ERROR_DIALOG) {\n    int id=msgData.getInt(\"dialogType\");\n    String message=msgData.getString(\"dialogMessage\");\n    ((DeckPicker)mActivity.get()).showSyncErrorDialog(id,message);\n  }\n else   if (msg.what == MSG_SHOW_EXPORT_COMPLETE_DIALOG) {\n    AsyncDialogFragment f=DeckPickerExportCompleteDialog.newInstance(msgData.getString(\"exportPath\"));\n    mActivity.get().showAsyncDialogFragment(f);\n  }\n else   if (msg.what == MSG_SHOW_MEDIA_CHECK_COMPLETE_DIALOG) {\n    int id=msgData.getInt(\"dialogType\");\n    if (id != MediaCheckDialog.DIALOG_CONFIRM_MEDIA_CHECK) {\n// bug_start\n      List<List<String>> checkList=new ArrayList<List<String>>();\n// bug_end\n      checkList.add(msgData.getStringArrayList(\"nohave\"));\n      checkList.add(msgData.getStringArrayList(\"unused\"));\n      checkList.add(msgData.getStringArrayList(\"invalid\"));\n      ((DeckPicker)mActivity.get()).showMediaCheckDialog(id,checkList);\n    }\n  }\n else   if (msg.what == MSG_SHOW_DATABASE_ERROR_DIALOG) {\n    ((DeckPicker)mActivity.get()).showDatabaseErrorDialog(msgData.getInt(\"dialogType\"));\n  }\n else   if (msg.what == MSG_SHOW_FORCE_FULL_SYNC_DIALOG) {\n    ConfirmationDialog dialog=new ConfirmationDialog(){\n      @Override public void confirm(){\n        ((AnkiActivity)getActivity()).getCol().modSchemaNoCheck();\n      }\n    }\n;\n    dialog.setArgs(msgData.getString(\"message\"));\n    (mActivity.get()).showDialogFragment(dialog);\n  }\n else   if (msg.what == MSG_DO_SYNC) {\n    SharedPreferences preferences=AnkiDroidApp.getSharedPrefs(mActivity.get());\n    Resources res=mActivity.get().getResources();\n    String hkey=preferences.getString(\"hkey\",\"\");\n    boolean limited=Utils.intNow(1000) - preferences.getLong(\"lastSyncTime\",0) < INTENT_SYNC_MIN_INTERVAL;\n    if (!limited && hkey.length() > 0 && Connection.isOnline()) {\n      ((DeckPicker)mActivity.get()).sync();\n    }\n else {\n      String err=res.getString(R.string.sync_error);\n      if (limited) {\n        mActivity.get().showSimpleNotification(err,res.getString(R.string.sync_too_busy));\n      }\n else {\n        mActivity.get().showSimpleNotification(err,res.getString(R.string.youre_offline));\n      }\n    }\n    mActivity.get().finishWithoutAnimation();\n  }\n}\n"}
{"INPUT": "private Resource.Builder doCreateResourceBuilder(final boolean skipAcceptableCheck){\n  if (!skipAcceptableCheck && !Resource.isAcceptable(handlerClass)) {\n// bug_start\n    Errors.fatal(handlerClass,LocalizationMessages.NON_INSTANTIABLE_CLASS(handlerClass));\n// bug_end\n  }\n  checkForNonPublicMethodIssues();\n  final Class<?> annotatedResourceClass=getAnnotatedResourceClass(handlerClass);\n  final Path rPathAnnotation=annotatedResourceClass.getAnnotation(Path.class);\n  final boolean keepEncodedParams=(null != annotatedResourceClass.getAnnotation(Encoded.class));\n  final List<MediaType> defaultConsumedTypes=extractMediaTypes(annotatedResourceClass.getAnnotation(Consumes.class));\n  final List<MediaType> defaultProducedTypes=extractMediaTypes(annotatedResourceClass.getAnnotation(Produces.class));\n  final Collection<Class<? extends Annotation>> defaultNameBindings=ReflectionHelper.getAnnotationTypes(annotatedResourceClass,NameBinding.class);\n  final MethodList methodList=new MethodList(handlerClass);\n  checkResourceClassSetters(methodList,keepEncodedParams);\n  checkResourceClassFields(keepEncodedParams,InvocableValidator.isSingleton(handlerClass));\n  Resource.Builder resourceBuilder;\n  if (null != rPathAnnotation) {\n    resourceBuilder=Resource.builder(rPathAnnotation.value());\n  }\n else {\n    resourceBuilder=Resource.builder();\n  }\n  resourceBuilder.name(handlerClass.getName());\n  addResourceMethods(resourceBuilder,methodList,keepEncodedParams,defaultConsumedTypes,defaultProducedTypes,defaultNameBindings);\n  addSubResourceMethods(resourceBuilder,methodList,keepEncodedParams,defaultConsumedTypes,defaultProducedTypes,defaultNameBindings);\n  addSubResourceLocators(resourceBuilder,methodList,keepEncodedParams);\n  if (LOGGER.isLoggable(Level.FINEST)) {\n    LOGGER.finest(LocalizationMessages.NEW_AR_CREATED_BY_INTROSPECTION_MODELER(resourceBuilder.toString()));\n  }\n  return resourceBuilder;\n}\n"}
{"INPUT": "@Override public Completable writeDescriptor(@NonNull final UUID serviceUuid,@NonNull final UUID characteristicUuid,@NonNull final UUID descriptorUuid,@NonNull final byte[] data){\n  return discoverServices().flatMap(new Function<RxBleDeviceServices,SingleSource<BluetoothGattDescriptor>>(){\n    @Override public SingleSource<BluetoothGattDescriptor> apply(    RxBleDeviceServices rxBleDeviceServices){\n      return rxBleDeviceServices.getDescriptor(serviceUuid,characteristicUuid,descriptorUuid);\n    }\n  }\n).doOnSuccess(new Consumer<BluetoothGattDescriptor>(){\n    @Override public void accept(    BluetoothGattDescriptor bluetoothGattDescriptor) throws Exception {\n      bluetoothGattDescriptor.setValue(data);\n    }\n  }\n// bug_start\n).toCompletable();\n// bug_end\n}\n"}
{"INPUT": "@BeforeClass public static void beforeTest() throws Exception {\n  JettyConfig jettyConfig=JettyConfig.builder().withServlet(new ServletHolder(TestServlet.class),\"/cuss/*\").withSSLConfig(sslConfig).build();\n// bug_start\n  createJetty(legacyExampleCollection1SolrHome(),jettyConfig);\n// bug_end\n}\n"}
{"INPUT": "@Override public ImmutableList<Step> getBuildSteps(BuildContext context,BuildableContext buildableContext){\n  buildableContext.recordArtifact(YaccStep.getHeaderOutputPath(outputPrefix));\n  buildableContext.recordArtifact(YaccStep.getSourceOutputPath(outputPrefix));\n// bug_start\n  return ImmutableList.of(new MkdirStep(getProjectFilesystem(),outputPrefix.getParent()),new RmStep(getProjectFilesystem(),getHeaderOutputPath(outputPrefix),true),new RmStep(getProjectFilesystem(),getSourceOutputPath(outputPrefix),true),new YaccStep(getProjectFilesystem(),yacc.getCommandPrefix(getResolver()),flags,outputPrefix,getResolver().getPath(input)));\n// bug_end\n}\n"}
{"INPUT": "@Test public void shouldDieOnInvalidOffsetException() throws Exception {\n  initializeConsumer();\n  globalStreamThread.start();\n  TestUtils.waitForCondition(new TestCondition(){\n    @Override public boolean conditionMet(){\n      return globalStreamThread.state() == RUNNING;\n    }\n  }\n,10 * 1000,\"Thread never started.\");\n  mockConsumer.updateEndOffsets(Collections.singletonMap(topicPartition,1L));\n  mockConsumer.addRecord(new ConsumerRecord<>(GLOBAL_STORE_TOPIC_NAME,0,0L,\"K1\".getBytes(),\"V1\".getBytes()));\n  TestUtils.waitForCondition(new TestCondition(){\n    @Override public boolean conditionMet(){\n      return mockConsumer.position(topicPartition) == 1L;\n    }\n  }\n,10 * 1000,\"Input record never consumed\");\n// bug_start\n  mockConsumer.setException(new InvalidOffsetException(\"Try Again!\"){\n// bug_end\n    @Override public Set<TopicPartition> partitions(){\n      return Collections.singleton(topicPartition);\n    }\n  }\n);\n  mockConsumer.addRecord(new ConsumerRecord<>(GLOBAL_STORE_TOPIC_NAME,0,0L,\"K1\".getBytes(),\"V1\".getBytes()));\n  TestUtils.waitForCondition(new TestCondition(){\n    @Override public boolean conditionMet(){\n      return globalStreamThread.state() == DEAD;\n    }\n  }\n,10 * 1000,\"GlobalStreamThread should have died.\");\n}\n"}
{"INPUT": "@Override public URLCollection load(Triple<String,URL,Charset> triple) throws Exception {\n  final String cssContent=triple.getLeft();\n  final URL baseUrl=triple.getMiddle();\n  final Charset charset=triple.getRight();\n  final CSSReaderSettings readerSettings=new CSSReaderSettings().setBrowserCompliantMode(true).setFallbackCharset(charset).setCSSVersion(ECSSVersion.CSS30).setCustomErrorHandler(new LoggingCSSParseErrorHandler()).setCustomExceptionHandler(new CSSParseExceptionCallback(baseUrl));\n  if (IGNORE_ALL_CSS_ERRORS) {\n    readerSettings.setInterpretErrorHandler(new DoNothingCSSInterpretErrorHandler());\n  }\n  final CascadingStyleSheet aCSS=CSSReader.readFromStringReader(cssContent,readerSettings);\n// bug_start\n  final URLCollection urls=new URLCollection(new ArrayList<URLString>());\n// bug_end\n  if (aCSS == null) {\n    LOG.warn(\"Failed parsing CSS: \" + baseUrl + \", got null CascadingStyleSheet\");\n    return urls;\n  }\n  CSSVisitor.visitCSSUrl(aCSS,new DefaultCSSUrlVisitor(){\n    @Override public void onImport(    CSSImportRule rule){\n      final String location=rule.getLocationString();\n      if (!StringUtils.isEmpty(location)) {\n        urls.addURL(location,baseUrl);\n      }\n    }\n    @Override public void onUrlDeclaration(    final ICSSTopLevelRule aTopLevelRule,    final CSSDeclaration aDeclaration,    final CSSExpressionMemberTermURI aURITerm){\n    }\n  }\n);\n  return urls;\n}\n"}
{"INPUT": "@Audit(action=\"TRUSTED_AUTHENTICATION\",actionResolverName=\"TRUSTED_AUTHENTICATION_ACTION_RESOLVER\",resourceResolverName=\"TRUSTED_AUTHENTICATION_RESOURCE_RESOLVER\") @Override public MultifactorAuthenticationTrustRecord set(final MultifactorAuthenticationTrustRecord record){\n  LOGGER.debug(\"Stored authentication trust record for [{}]\",record);\n// bug_start\n  record.setKey(generateKey(record));\n// bug_end\n  return setInternal(record);\n}\n"}
{"INPUT": "public long read(ByteBuffer buffer) throws IOException {\n// bug_start\n  chunk=new byte[buffer.capacity() - 10];\n// bug_end\n  int read=-1;\n  try {\n    read=inputStream.read(chunk);\n  }\n catch (  IOException ex) {\n    logger.warn(\"Unable to read\",ex);\n  }\n  if (patchNettyChunkingIssue) {\n    if (read == -1) {\n      if (!eof) {\n        endDataCount++;\n        if (endDataCount == 2)         eof=true;\n        if (endDataCount == 1)         buffer.put(ZERO);\n        buffer.put(END_PADDING);\n        return buffer.position();\n      }\n else {\n        if (inputStream.markSupported()) {\n          inputStream.reset();\n        }\n        eof=false;\n      }\n      return -1;\n    }\n    buffer.put(Integer.toHexString(read).getBytes());\n    buffer.put(END_PADDING);\n    buffer.put(chunk,0,read);\n    buffer.put(END_PADDING);\n  }\n else {\n    if (read > 0) {\n      buffer.put(chunk,0,read);\n    }\n  }\n  return read;\n}\n"}
{"INPUT": "@Test public void testFilterDependenciesDynamicConfiguration() throws Exception {\n  NestedSet<ResourceContainer> resourceContainers=getResourceContainers(getResources(\"values-en/foo.xml\",\"values-fr/foo.xml\"),getResources(\"drawable-hdpi/foo.png\",\"drawable-ldpi/foo.png\"));\n// bug_start\n  assertThat(makeResourceFilter(\"en\",\"hdpi\",FilterBehavior.FILTER_IN_ANALYSIS_WITH_DYNAMIC_CONFIGURATION).filterDependencies(errorConsumer,resourceContainers)).isSameAs(resourceContainers);\n// bug_end\n}\n"}
{"INPUT": "@TaskAction public void buildDocker() throws InvalidImageReferenceException {\n  if (!new DockerClient().isDockerInstalled()) {\n    throw new GradleException(HelpfulSuggestions.forDockerNotInstalled(HELPFUL_SUGGESTIONS_PREFIX));\n  }\n  Preconditions.checkNotNull(jibExtension);\n  AbsoluteUnixPath appRoot=PluginConfigurationProcessor.getAppRootChecked(jibExtension);\n  GradleProjectProperties gradleProjectProperties=GradleProjectProperties.getForProject(getProject(),getLogger(),jibExtension.getExtraDirectoryPath(),appRoot);\n  GradleHelpfulSuggestionsBuilder gradleHelpfulSuggestionsBuilder=new GradleHelpfulSuggestionsBuilder(HELPFUL_SUGGESTIONS_PREFIX,jibExtension);\n// bug_start\n  ImageReference targetImage=ConfigurationPropertyValidator.getGeneratedTargetDockerTag(jibExtension.getTargetImage(),gradleProjectProperties.getEventEmitter(),getProject().getName(),getProject().getVersion().toString(),gradleHelpfulSuggestionsBuilder.build());\n// bug_end\n  PluginConfigurationProcessor pluginConfigurationProcessor=PluginConfigurationProcessor.processCommonConfiguration(getLogger(),jibExtension,gradleProjectProperties);\n  BuildConfiguration buildConfiguration=pluginConfigurationProcessor.getBuildConfigurationBuilder().setBaseImageConfiguration(pluginConfigurationProcessor.getBaseImageConfigurationBuilder().build()).setTargetImageConfiguration(ImageConfiguration.builder(targetImage).build()).setAdditionalTargetImageTags(jibExtension.getTo().getTags()).setContainerConfiguration(pluginConfigurationProcessor.getContainerConfigurationBuilder().build()).build();\n  HelpfulSuggestions helpfulSuggestions=gradleHelpfulSuggestionsBuilder.setBaseImageReference(buildConfiguration.getBaseImageConfiguration().getImage()).setBaseImageHasConfiguredCredentials(pluginConfigurationProcessor.isBaseImageCredentialPresent()).setTargetImageReference(buildConfiguration.getTargetImageConfiguration().getImage()).build();\n  try {\n    BuildStepsRunner.forBuildToDockerDaemon(buildConfiguration).build(helpfulSuggestions);\n  }\n catch (  CacheDirectoryCreationException|BuildStepsExecutionException ex) {\n    throw new GradleException(ex.getMessage(),ex.getCause());\n  }\n}\n"}
{"INPUT": "public void mergeBundleInfos(AppVariantContext appVariantContext,InjectParam injectParam){\n  if (appVariantContext.getAtlasExtension().getTBuildConfig().isIncremental()) {\n    File atlasFrameworkPropertiesFile=new File(appVariantContext.apContext.getApExploredFolder(),\"atlasFrameworkProperties.json\");\n    if (!atlasFrameworkPropertiesFile.exists()) {\n      return;\n    }\n    List<BasicBundleInfo> basicBundleInfos=JSON.parseObject(injectParam.bundleInfo,new TypeReference<List<BasicBundleInfo>>(){\n    }\n);\n    FrameworkProperties atlasFrameworkProperties;\n    try {\n      atlasFrameworkProperties=JSON.parseObject(Files.toString(atlasFrameworkPropertiesFile,Charsets.UTF_8),FrameworkProperties.class);\n    }\n catch (    IOException e) {\n      throw new UncheckedIOException(e);\n    }\n    List<BasicBundleInfo> baseBundleInfos=atlasFrameworkProperties.bundleInfo;\n    List<BasicBundleInfo> mergeBasicBundleInfos=Lists.newArrayList(baseBundleInfos);\n    for (    BasicBundleInfo basicBundleInfo : basicBundleInfos) {\n      BasicBundleInfo baseBasicBundleInfo=Iterables.find(baseBundleInfos,null);\n      if (baseBasicBundleInfo == null) {\n        mergeBasicBundleInfos.add(basicBundleInfo);\n        continue;\n      }\n// bug_start\n      basicBundleInfo.setIsMBundle(baseBasicBundleInfo.isMBundle());\n// bug_end\n      basicBundleInfo.getActivities().addAll(baseBasicBundleInfo.getActivities());\n      basicBundleInfo.getContentProviders().addAll(baseBasicBundleInfo.getContentProviders());\n      basicBundleInfo.getDependency().addAll(baseBasicBundleInfo.getDependency());\n      basicBundleInfo.getReceivers().addAll(baseBasicBundleInfo.getReceivers());\n      basicBundleInfo.getServices().addAll(baseBasicBundleInfo.getServices());\n      if (!baseBasicBundleInfo.getRemoteFragments().isEmpty()) {\n        basicBundleInfo.getRemoteFragments().putAll(baseBasicBundleInfo.getRemoteFragments());\n      }\n      if (!baseBasicBundleInfo.getRemoteViews().isEmpty()) {\n        basicBundleInfo.getRemoteViews().putAll(baseBasicBundleInfo.getRemoteViews());\n      }\n      if (!baseBasicBundleInfo.getRemoteTransactors().isEmpty()) {\n        basicBundleInfo.getRemoteTransactors().putAll(baseBasicBundleInfo.getRemoteTransactors());\n      }\n      mergeBasicBundleInfos.remove(baseBasicBundleInfo);\n      mergeBasicBundleInfos.add(basicBundleInfo);\n    }\n    injectParam.bundleInfo=JSON.toJSONString(mergeBasicBundleInfos);\n    if (Strings.isNullOrEmpty(injectParam.autoStartBundles)) {\n      injectParam.autoStartBundles=atlasFrameworkProperties.autoStartBundles;\n    }\n else {\n      if (!Strings.isNullOrEmpty(atlasFrameworkProperties.autoStartBundles)) {\n        injectParam.autoStartBundles=injectParam.autoStartBundles + \",\" + atlasFrameworkProperties.autoStartBundles;\n      }\n    }\n    injectParam.preLaunch=atlasFrameworkProperties.preLaunch;\n  }\n}\n"}
{"INPUT": "public static void addComments(CodeWriter code,AttrNode node){\n  for (  String comment : node.getAll(AType.COMMENTS)) {\n// bug_start\n    code.startLine(\"/* \").add(comment).add(\" */\");\n// bug_end\n  }\n}\n"}
{"INPUT": "private Path getRuntimeAllJar(BuildContext buildContext){\n  if (skipCopyLibsFromDist) {\n    return null;\n  }\n  String balHomePath=buildContext.get(BuildContextField.HOME_REPO).toString();\n// bug_start\n  String ballerinaVersion=RepoUtils.getBallerinaVersion();\n// bug_end\n  String runtimeJarName=\"ballerina-rt-\" + ballerinaVersion + BLANG_COMPILED_JAR_EXT;\n  return Paths.get(balHomePath,\"bre\",\"lib\",runtimeJarName);\n}\n"}
{"INPUT": "@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {\n  if (compare(ISCLOSED_VAL,method)) {\n    return Boolean.valueOf(isClosed());\n  }\n  if (compare(CLOSE_VAL,method)) {\n    if (connection == null)     return null;\n    PooledConnection poolc=this.connection;\n    this.connection=null;\n    pool.returnConnection(poolc);\n    return null;\n  }\n else   if (compare(TOSTRING_VAL,method)) {\n    return this.toString();\n  }\n else   if (compare(GETCONNECTION_VAL,method) && connection != null) {\n    return connection.getConnection();\n  }\n// bug_start\n else   if (method.getDeclaringClass().equals(XAConnection.class)) {\n// bug_end\n    try {\n      return method.invoke(connection.getXAConnection(),args);\n    }\n catch (    Throwable t) {\n      if (t instanceof InvocationTargetException) {\n        throw t.getCause() != null ? t.getCause() : t;\n      }\n else {\n        throw t;\n      }\n    }\n  }\n  if (isClosed())   throw new SQLException(\"Connection has already been closed.\");\n  if (compare(UNWRAP_VAL,method)) {\n    return unwrap((Class<?>)args[0]);\n  }\n else   if (compare(ISWRAPPERFOR_VAL,method)) {\n    return Boolean.valueOf(this.isWrapperFor((Class<?>)args[0]));\n  }\n  try {\n    PooledConnection poolc=connection;\n    if (poolc != null) {\n      return method.invoke(poolc.getConnection(),args);\n    }\n else {\n      throw new SQLException(\"Connection has already been closed.\");\n    }\n  }\n catch (  Throwable t) {\n    if (t instanceof InvocationTargetException) {\n      throw t.getCause() != null ? t.getCause() : t;\n    }\n else {\n      throw t;\n    }\n  }\n}\n"}
{"INPUT": "@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) @WorkerThread @Nullable @Override public NullPaddedList<Value> loadInitial(Integer position,int initialLoadSize,boolean enablePlaceholders){\n  final int convertPosition=position == null ? 0 : position;\n  final int loadPosition=Math.max(0,(convertPosition - initialLoadSize / 2));\n  int count=COUNT_UNDEFINED;\n  if (enablePlaceholders) {\n// bug_start\n    count=loadCount();\n// bug_end\n  }\n  List<Value> data=loadAfter(loadPosition,initialLoadSize);\n  if (count == COUNT_UNDEFINED) {\n    return new NullPaddedList<>(loadPosition,data);\n  }\n else {\n    return new NullPaddedList<>(loadPosition,count,data);\n  }\n}\n"}
{"INPUT": "private AgentInformation getAgentInfo(){\n// bug_start\n  AgentInformation agentInfo=new AgentInformation(\"agentId\",\"appName\",System.currentTimeMillis(),1111,\"hostname\",\"127.0.0.1\",ServiceType.USER,JvmUtils.getSystemProperty(SystemPropertyKey.JAVA_VERSION),Version.VERSION);\n// bug_end\n  return agentInfo;\n}\n"}
{"INPUT": "static public void main(String[] args) throws Exception {\n  if (args.length != 1) {\n    usage(\"Wrong number of arguments.\");\n  }\n  String configFile=args[0];\n  if (configFile.endsWith(\".xml\")) {\n    LoggerContext lc=(LoggerContext)LoggerFactory.getILoggerFactory();\n    JoranConfigurator configurator=new JoranConfigurator();\n// bug_start\n    lc.reset();\n// bug_end\n    configurator.setContext(lc);\n    configurator.doConfigure(configFile);\n  }\n  Logger logger=LoggerFactory.getLogger(SocketClient2.class);\n  BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n  while (true) {\n    System.out.println(\"Type a message to send to log server. Type 'q' to quit.\");\n    String s=reader.readLine();\n    if (s.equals(\"q\")) {\n      break;\n    }\n else {\n      logger.debug(s);\n    }\n  }\n}\n"}
{"INPUT": "private void runBashCommand(String bisqCmd) throws IOException, InterruptedException {\n  String cmdDescription=config.runSubprojectJars ? \"java -> \" + bisqAppConfig.mainClassName + \" -> \"+ bisqAppConfig.appName : bisqAppConfig.startupScript + \" -> \" + bisqAppConfig.appName;\n  BashCommand bashCommand=new BashCommand(bisqCmd);\n  log.info(\"Starting {} ...\\n$ {}\",cmdDescription,bashCommand.getCommand());\n// bug_start\n  bashCommand.run();\n// bug_end\n  if (bashCommand.getExitStatus() != 0)   throw new IllegalStateException(format(\"Error starting BisqApp\\n%s\\nError: %s\",bashCommand.getError()));\n  for (int i=0; i < 4; i++) {\n    pid=findBisqAppPid();\n    if (pid != -1)     break;\n    MILLISECONDS.sleep(500L);\n  }\n  if (!isAlive(pid))   throw new IllegalStateException(format(\"Error finding pid for %s\",this.name));\n  log.info(\"{} running with pid {}\",cmdDescription,pid);\n  log.info(\"Log {}\",config.rootAppDataDir + \"/\" + bisqAppConfig.appName+ \"/bisq.log\");\n}\n"}
{"INPUT": "private void onSave(@Nullable List<Notification> notificationThreadModels){\n  if (notificationThreadModels != null) {\n// bug_start\n    RxHelper.saveObserable(Notification.save(notificationThreadModels)).subscribe();\n// bug_end\n    onNotifyUser(notificationThreadModels);\n  }\n}\n"}
{"INPUT": "public void testNoOps() throws IOException {\n  engine.close();\n  InternalEngine noOpEngine=null;\n  final int maxSeqNo=randomIntBetween(0,128);\n  final int localCheckpoint=randomIntBetween(0,maxSeqNo);\n  final int globalCheckpoint=randomIntBetween(0,localCheckpoint);\n  try {\n    final SequenceNumbersService seqNoService=new SequenceNumbersService(shardId,defaultSettings,maxSeqNo,localCheckpoint,globalCheckpoint){\n      @Override public long generateSeqNo(){\n        throw new UnsupportedOperationException();\n      }\n    }\n;\n    noOpEngine=createEngine(defaultSettings,store,primaryTranslogDir,newMergePolicy(),null,null);\n    final long primaryTerm=randomNonNegativeLong();\n// bug_start\n    final String reason=randomAsciiOfLength(16);\n// bug_end\n    noOpEngine.noOp(new Engine.NoOp(null,maxSeqNo + 1,primaryTerm,0,VersionType.INTERNAL,randomFrom(PRIMARY,REPLICA,PEER_RECOVERY,LOCAL_TRANSLOG_RECOVERY),System.nanoTime(),reason));\n    assertThat(noOpEngine.seqNoService().getLocalCheckpoint(),equalTo((long)(maxSeqNo + 1)));\n    assertThat(noOpEngine.getTranslog().totalOperations(),equalTo(1));\n    final Translog.Operation op=noOpEngine.getTranslog().newSnapshot().next();\n    assertThat(op,instanceOf(Translog.NoOp.class));\n    final Translog.NoOp noOp=(Translog.NoOp)op;\n    assertThat(noOp.seqNo(),equalTo((long)(maxSeqNo + 1)));\n    assertThat(noOp.primaryTerm(),equalTo(primaryTerm));\n    assertThat(noOp.reason(),equalTo(reason));\n  }\n  finally {\n    IOUtils.close(noOpEngine);\n  }\n}\n"}
{"INPUT": "public static void appendNewRegisterInterestResponseChunk(LocalRegion region,VersionedObjectList values,Object riKeys,Set<Map.Entry> set,ServerConnection servConn) throws IOException {\n  for (  Entry entry : set) {\n    if (entry instanceof Region.Entry) {\n      VersionTag vt;\n      Object key;\n      Object value;\n      if (entry instanceof EntrySnapshot) {\n        vt=((EntrySnapshot)entry).getVersionTag();\n        key=((EntrySnapshot)entry).getRegionEntry().getKey();\n        value=((EntrySnapshot)entry).getRegionEntry().getValue(null);\n        updateValues(values,key,value,vt);\n      }\n else {\n        VersionStamp vs=((NonTXEntry)entry).getRegionEntry().getVersionStamp();\n        vt=vs == null ? null : vs.asVersionTag();\n        key=entry.getKey();\n// bug_start\n        value=((NonTXEntry)entry).getRegionEntry()._getValueRetain(region,true);\n// bug_end\n        try {\n          updateValues(values,key,value,vt);\n        }\n  finally {\n          OffHeapHelper.release(value);\n        }\n      }\n    }\n else {\n      List list=(List)entry.getValue();\n      Object value=list.get(0);\n      VersionTag tag=(VersionTag)list.get(1);\n      updateValues(values,entry.getKey(),value,tag);\n    }\n    if (values.size() == MAXIMUM_CHUNK_SIZE) {\n      sendNewRegisterInterestResponseChunk(region,riKeys != null ? riKeys : \"ALL_KEYS\",values,false,servConn);\n      values.clear();\n    }\n  }\n}\n"}
{"INPUT": "public GuardDebugLoggingRule(){\n// bug_start\n  super.guardStmtByLogLevel=new HashMap<String,String>(1);\n// bug_end\n  super.guardStmtByLogLevel.put(\".debug\",\"isDebugEnabled\");\n}\n"}
{"INPUT": "public static void main(String[] args){\n  Logger logger=LoggerFactory.getLogger(ExceptionEvaluatorExample.class);\n  LoggerContext lc=(LoggerContext)LoggerFactory.getILoggerFactory();\n  try {\n    JoranConfigurator configurator=new JoranConfigurator();\n    configurator.setContext(lc);\n// bug_start\n    lc.shutdownAndReset();\n// bug_end\n    configurator.doConfigure(args[0]);\n  }\n catch (  JoranException je) {\n    StatusPrinter.print(lc);\n  }\n  for (int i=0; i < 5; i++) {\n    if (i == 3) {\n      logger.debug(\"logging statement \" + i,new TestException(\"do not display this\"));\n    }\n else {\n      logger.debug(\"logging statement \" + i,new Exception(\"display\"));\n    }\n  }\n}\n"}
{"INPUT": "@Override public Publisher<HealthResult> getResult(){\n// bug_start\n  Collection<BeanRegistration<RedisClient>> registrations=beanContext.getBeanRegistrations(RedisClient.class);\n// bug_end\n  Flux<BeanRegistration<RedisClient>> redisClients=Flux.fromIterable(registrations);\n  Flux<HealthResult> healthResultFlux=redisClients.flatMap(null);\n  return this.healthAggregator.aggregate(NAME,healthResultFlux);\n}\n"}
{"INPUT": "private List<ExistingEvent> toExistingEvents(final Catalog catalog,final long activeVersion,final ProductCategory category,final List<SubscriptionBaseEvent> events) throws CatalogApiException {\n  final List<ExistingEvent> result=new LinkedList<SubscriptionBaseTimeline.ExistingEvent>();\n  String prevPlanName=null;\n  String prevProductName=null;\n  BillingPeriod prevBillingPeriod=null;\n  String prevPriceListName=null;\n  PhaseType prevPhaseType=null;\n  DateTime startDate=null;\n  for (  final SubscriptionBaseEvent cur : events) {\n    if (cur.getActiveVersion() != activeVersion || !cur.isActive()) {\n      continue;\n    }\n    startDate=(startDate == null) ? cur.getEffectiveDate() : startDate;\n    String productName=null;\n    BillingPeriod billingPeriod=null;\n    String priceListName=null;\n    PhaseType phaseType=null;\n    String planName=null;\n    String planPhaseName=null;\n    ApiEventType apiType=null;\nswitch (cur.getType()) {\ncase PHASE:\n      final PhaseEvent phaseEV=(PhaseEvent)cur;\n    planPhaseName=phaseEV.getPhase();\n  phaseType=catalog.findPhase(phaseEV.getPhase(),cur.getEffectiveDate(),startDate).getPhaseType();\nplanName=prevPlanName;\nproductName=prevProductName;\nbillingPeriod=getBillingPeriod(catalog,phaseEV.getPhase(),cur.getEffectiveDate(),startDate);\npriceListName=prevPriceListName;\nbreak;\ncase API_USER:\nfinal ApiEvent userEV=(ApiEvent)cur;\n// bug_start\napiType=userEV.getEventType();\n// bug_end\nplanName=userEV.getEventPlan();\nplanPhaseName=userEV.getEventPlanPhase();\nfinal Plan plan=(userEV.getEventPlan() != null) ? catalog.findPlan(userEV.getEventPlan(),cur.getRequestedDate(),startDate) : null;\nphaseType=(userEV.getEventPlanPhase() != null) ? catalog.findPhase(userEV.getEventPlanPhase(),cur.getEffectiveDate(),startDate).getPhaseType() : prevPhaseType;\nproductName=(plan != null) ? plan.getProduct().getName() : prevProductName;\nbillingPeriod=(userEV.getEventPlanPhase() != null) ? getBillingPeriod(catalog,userEV.getEventPlanPhase(),cur.getEffectiveDate(),startDate) : prevBillingPeriod;\npriceListName=(userEV.getPriceList() != null) ? userEV.getPriceList() : prevPriceListName;\nbreak;\n}\nfinal SubscriptionBaseTransitionType transitionType=SubscriptionBaseTransitionData.toSubscriptionTransitionType(cur.getType(),apiType);\nfinal String planNameWithClosure=planName;\nfinal String planPhaseNameWithClosure=planPhaseName;\nfinal PlanPhaseSpecifier spec=new PlanPhaseSpecifier(productName,category,billingPeriod,priceListName,phaseType);\nresult.add(new ExistingEvent(){\n@Override public SubscriptionBaseTransitionType getSubscriptionTransitionType(){\nreturn transitionType;\n}\n@Override public DateTime getRequestedDate(){\nreturn cur.getRequestedDate();\n}\n@Override public PlanPhaseSpecifier getPlanPhaseSpecifier(){\nreturn spec;\n}\n@Override public UUID getEventId(){\nreturn cur.getId();\n}\n@Override public DateTime getEffectiveDate(){\nreturn cur.getEffectiveDate();\n}\n@Override public String getPlanName(){\nreturn planNameWithClosure;\n}\n@Override public String getPlanPhaseName(){\nreturn planPhaseNameWithClosure;\n}\n}\n);\nprevPlanName=planName;\nprevProductName=productName;\nprevBillingPeriod=billingPeriod;\nprevPriceListName=priceListName;\nprevPhaseType=phaseType;\n}\nsortExistingEvent(result);\nreturn result;\n}\n"}
{"INPUT": "public static Position getFavoredServerPosition(List<ServerName> favoredNodes,ServerName server){\n  if (favoredNodes == null || server == null || favoredNodes.size() != FavoredNodeAssignmentHelper.FAVORED_NODES_NUM) {\n    return null;\n  }\n  for (  Position p : Position.values()) {\n// bug_start\n    if (ServerName.isSameHostnameAndPort(favoredNodes.get(p.ordinal()),server)) {\n// bug_end\n      return p;\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "public void validate(){\n  if (poolName == null) {\n    poolName=\"HikariPool-\" + generatePoolNumber();\n  }\n else   if (isRegisterMbeans && poolName.contains(\":\")) {\n    throw new IllegalArgumentException(\"poolName cannot contain ':' when used with JMX\");\n  }\n  catalog=getNullIfEmpty(catalog);\n  connectionInitSql=getNullIfEmpty(connectionInitSql);\n  connectionTestQuery=getNullIfEmpty(connectionTestQuery);\n  transactionIsolationName=getNullIfEmpty(transactionIsolationName);\n  dataSourceClassName=getNullIfEmpty(dataSourceClassName);\n  dataSourceJndiName=getNullIfEmpty(dataSourceJndiName);\n  driverClassName=getNullIfEmpty(driverClassName);\n  jdbcUrl=getNullIfEmpty(jdbcUrl);\n  if (dataSource != null) {\n    if (dataSourceClassName != null) {\n      LOGGER.warn(\"{} - using dataSource and ignoring dataSourceClassName.\",poolName);\n    }\n  }\n else   if (dataSourceClassName != null) {\n    if (driverClassName != null) {\n      LOGGER.error(\"{} - cannot use driverClassName and dataSourceClassName together.\",poolName);\n// bug_start\n      throw new IllegalArgumentException(\"cannot use driverClassName and dataSourceClassName together.\");\n// bug_end\n    }\n else     if (jdbcUrl != null) {\n      LOGGER.warn(\"{} - using dataSourceClassName and ignoring jdbcUrl.\",poolName);\n    }\n  }\n else   if (jdbcUrl != null) {\n  }\n else   if (driverClassName != null) {\n    LOGGER.error(\"{} - jdbcUrl is required with driverClassName.\",poolName);\n    throw new IllegalArgumentException(\"jdbcUrl is required with driverClassName.\");\n  }\n else {\n    LOGGER.error(\"{} - dataSource or dataSourceClassName or jdbcUrl is required.\",poolName);\n    throw new IllegalArgumentException(\"dataSource or dataSourceClassName or jdbcUrl is required.\");\n  }\n  validateNumerics();\n  if (LOGGER.isDebugEnabled() || unitTest) {\n    logConfiguration();\n  }\n}\n"}
{"INPUT": "@TaskAction public void buildImage() throws InvalidImageReferenceException, IOException, BuildStepsExecutionException, CacheDirectoryCreationException {\n  Preconditions.checkNotNull(jibExtension);\n  AbsoluteUnixPath appRoot=PluginConfigurationProcessor.getAppRootChecked(jibExtension);\n  GradleProjectProperties gradleProjectProperties=GradleProjectProperties.getForProject(getProject(),getLogger(),jibExtension.getExtraDirectoryPath(),appRoot);\n  if (Strings.isNullOrEmpty(jibExtension.getTo().getImage())) {\n    throw new GradleException(HelpfulSuggestions.forToNotConfigured(\"Missing target image parameter\",\"'jib.to.image'\",\"build.gradle\",\"gradle jib --image <your image name>\"));\n  }\n  ImageReference targetImageReference=ImageReference.parse(jibExtension.getTo().getImage());\n  EventDispatcher eventDispatcher=new DefaultEventDispatcher(gradleProjectProperties.getEventHandlers());\n  DefaultCredentialRetrievers defaultCredentialRetrievers=DefaultCredentialRetrievers.init(CredentialRetrieverFactory.forImage(targetImageReference,eventDispatcher));\n  Optional<Credential> optionalToCredential=ConfigurationPropertyValidator.getImageCredential(eventDispatcher,PropertyNames.TO_AUTH_USERNAME,PropertyNames.TO_AUTH_PASSWORD,jibExtension.getTo().getAuth());\n  optionalToCredential.ifPresent(null);\n// bug_start\n  defaultCredentialRetrievers.setCredentialHelperSuffix(jibExtension.getTo().getCredHelper());\n// bug_end\n  RegistryImage targetImage=RegistryImage.named(targetImageReference);\n  defaultCredentialRetrievers.asList().forEach(null);\n  PluginConfigurationProcessor pluginConfigurationProcessor=PluginConfigurationProcessor.processCommonConfiguration(getLogger(),jibExtension,gradleProjectProperties);\n  JibContainerBuilder jibContainerBuilder=pluginConfigurationProcessor.getJibContainerBuilder().setFormat(jibExtension.getContainer().getFormat());\n  Containerizer containerizer=Containerizer.to(targetImage);\n  PluginConfigurationProcessor.configureContainerizer(containerizer,jibExtension,gradleProjectProperties);\n  HelpfulSuggestions helpfulSuggestions=new GradleHelpfulSuggestionsBuilder(HELPFUL_SUGGESTIONS_PREFIX,jibExtension).setBaseImageReference(pluginConfigurationProcessor.getBaseImageReference()).setBaseImageHasConfiguredCredentials(pluginConfigurationProcessor.isBaseImageCredentialPresent()).setTargetImageReference(targetImageReference).setTargetImageHasConfiguredCredentials(optionalToCredential.isPresent()).build();\n  BuildStepsRunner.forBuildImage(targetImageReference,jibExtension.getTo().getTags()).build(jibContainerBuilder,containerizer,eventDispatcher,gradleProjectProperties.getJavaLayerConfigurations().getLayerConfigurations(),helpfulSuggestions);\n}\n"}
{"INPUT": "public DefaultCacheMethodDetails(Method method,A cacheAnnotation,String cacheName){\n  this.method=method;\n// bug_start\n  this.annotations=Collections.unmodifiableSet(new LinkedHashSet<Annotation>(asList(method.getAnnotations())));\n// bug_end\n  this.cacheAnnotation=cacheAnnotation;\n  this.cacheName=cacheName;\n}\n"}
{"INPUT": "boolean restoreRecentTaskLocked(TaskRecord task,ActivityOptions aOptions,boolean onTop){\n  final ActivityStack stack=mRootActivityContainer.getLaunchStack(null,aOptions,task,onTop);\n  final ActivityStack currentStack=task.getStack();\n  if (currentStack != null) {\n    if (currentStack == stack) {\n      return true;\n    }\n    currentStack.removeTask(task,\"restoreRecentTaskLocked\",REMOVE_TASK_MODE_MOVING);\n  }\n  stack.addTask(task,onTop,\"restoreRecentTask\");\n// bug_start\n  task.createWindowContainer(onTop,true);\n// bug_end\n  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,\"Added restored task=\" + task + \" to stack=\"+ stack);\n  final ArrayList<ActivityRecord> activities=task.mActivities;\n  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {\n    activities.get(activityNdx).createAppWindowToken();\n  }\n  return true;\n}\n"}
{"INPUT": "@Override public void insert(TSqlMetaData sqlMetaData){\n  if (sqlMetaData == null) {\n    throw new NullPointerException(\"sqlMetaData must not be null\");\n  }\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"insert:{}\",sqlMetaData);\n  }\n// bug_start\n  SqlMetaDataBo sqlMetaDataBo=new SqlMetaDataBo(sqlMetaData.getAgentId(),sqlMetaData.getAgentStartTime(),sqlMetaData.getHashCode());\n// bug_end\n  final byte[] rowKey=getDistributedKey(sqlMetaDataBo.toRowKey());\n  Put put=new Put(rowKey);\n  String sql=sqlMetaData.getSql();\n  byte[] sqlBytes=Bytes.toBytes(sql);\n  put.add(HBaseTables.SQL_METADATA_CF_SQL,sqlBytes,null);\n  hbaseTemplate.put(HBaseTables.SQL_METADATA,put);\n}\n"}
{"INPUT": "public ScriptMetaData(StreamInput in) throws IOException {\n  Map<String,StoredScriptSource> scripts=new HashMap<>();\n  StoredScriptSource source;\n  int size=in.readVInt();\n  for (int i=0; i < size; i++) {\n    String id=in.readString();\n    if (in.getVersion().before(Version.V_5_3_0)) {\n      int split=id.indexOf('#');\n      if (split == -1) {\n        throw new IllegalArgumentException(\"illegal stored script id [\" + id + \"], does not contain lang\");\n      }\n else {\n        source=new StoredScriptSource(in);\n// bug_start\n        source=new StoredScriptSource(id.substring(0,split),source.getCode(),Collections.emptyMap());\n// bug_end\n      }\n    }\n else {\n      source=new StoredScriptSource(in);\n    }\n    scripts.put(id,source);\n  }\n  this.scripts=Collections.unmodifiableMap(scripts);\n}\n"}
{"INPUT": "@Test public void currentSpanVisibleToUserInterceptors() throws Exception {\n  server.enqueue(new MockResponse());\n  closeClient(client);\n  client=TracingCallFactory.create(httpTracing,new OkHttpClient.Builder().addInterceptor(null).build());\n// bug_start\n  TraceContext parent=newParentContext(SamplingFlags.SAMPLED);\n// bug_end\n  try (Scope scope=currentTraceContext.newScope(parent)){\n    get(client,\"/foo\");\n  }\n   RecordedRequest request=takeRequest();\n  assertThat(request.getHeader(\"x-b3-traceId\")).isEqualTo(request.getHeader(\"my-id\"));\n  takeRemoteSpan(Span.Kind.CLIENT);\n}\n"}
{"INPUT": "@Override public Snapshot snapshot(Snapshot snapshot){\nsynchronized (mutex) {\n    MemorySnapshot memorySnapshot=(MemorySnapshot)snapshot;\n    if (currentId() != snapshot.translogId()) {\n      return snapshot();\n    }\n    MemorySnapshot newSnapshot=new MemorySnapshot(currentId(),operations,operationCounter.get());\n// bug_start\n    newSnapshot.seekForward(memorySnapshot.length());\n// bug_end\n    return newSnapshot;\n  }\n}\n"}
{"INPUT": "protected SubscriptionJsonNoEvents createSubscription(final String bundleId,final String productName,final String productCategory,final String billingPeriod,final boolean waitCompletion) throws Exception {\n  SubscriptionJsonNoEvents input=new SubscriptionJsonNoEvents(null,bundleId,null,productName,productCategory,billingPeriod,PriceListSet.DEFAULT_PRICELIST_NAME,null);\n  String baseJson=mapper.writeValueAsString(input);\n  Map<String,String> queryParams=waitCompletion ? getQueryParamsForCallCompletion(\"5\") : DEFAULT_EMPTY_QUERY;\n  Response response=doPost(JaxrsResource.SUBSCRIPTIONS_PATH,baseJson,queryParams,DEFAULT_HTTP_TIMEOUT_SEC);\n  Assert.assertEquals(response.getStatusCode(),Status.CREATED.getStatusCode());\n  String location=response.getHeader(\"Location\");\n  Assert.assertNotNull(location);\n  response=doGetWithUrl(location,DEFAULT_EMPTY_QUERY,DEFAULT_HTTP_TIMEOUT_SEC);\n  Assert.assertEquals(response.getStatusCode(),Status.OK.getStatusCode());\n  baseJson=response.getResponseBody();\n  SubscriptionJsonNoEvents objFromJson=mapper.readValue(baseJson,SubscriptionJsonNoEvents.class);\n// bug_start\n  Assert.assertTrue(objFromJson.equalsNoId(input));\n// bug_end\n  return objFromJson;\n}\n"}
{"INPUT": "@Override public synchronized void shutdown(){\n  if (active) {\n    active=false;\n    for (    ExecuteThread thread : threads) {\n      thread.shutdown();\n    }\nsynchronized (ticket) {\n// bug_start\n      ticket.notify();\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "private String getFileName(){\n// bug_start\n  String fname=getFileContents().getFilename();\n// bug_end\n  fname=fname.substring(fname.lastIndexOf(File.separatorChar) + 1);\n  fname=fname.replaceAll(\"\\\\.[^\\\\.]*$\",\"\");\n  return fname;\n}\n"}
{"INPUT": "@Test public void testNoTransferEncoding() throws Exception {\n  String url=\"http://localhost:\" + port + \"/test\";\n// bug_start\n  AsyncHttpClientConfig config=new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setFollowRedirects(false).setConnectionTimeoutInMs(15000).setRequestTimeoutInMs(15000).setAllowPoolingConnection(false).setDisableUrlEncodingForBoundRequests(true).setIOThreadMultiplier(2).build();\n// bug_end\n  AsyncHttpClient client=new DefaultAsyncHttpClient(new GrizzlyAsyncHttpProvider(config),config);\n  try {\n    Future<org.asynchttpclient.Response> f=client.prepareGet(url).execute();\n    org.asynchttpclient.Response r=f.get(10,TimeUnit.SECONDS);\n    Assert.assertEquals(TEST_MESSAGE,r.getResponseBody());\n  }\n  finally {\n    client.close();\n  }\n}\n"}
{"INPUT": "public Object decode(Object object){\n  if (object instanceof JSONArray) {\n    return convertJSONArrayToList((JSONArray)object);\n  }\n  if (object == JSONObject.NULL) {\n    return null;\n  }\n  if (!(object instanceof JSONObject)) {\n    return object;\n  }\n  JSONObject jsonObject=(JSONObject)object;\n  String opString=jsonObject.optString(\"__op\",null);\n  if (opString != null) {\n    try {\n      return ParseFieldOperations.decode(jsonObject,this);\n    }\n catch (    JSONException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  String typeString=jsonObject.optString(\"__type\",null);\n  if (typeString == null) {\n    return convertJSONObjectToMap(jsonObject);\n  }\n  if (typeString.equals(\"Date\")) {\n    String iso=jsonObject.optString(\"iso\");\n    return ParseDateFormat.getInstance().parse(iso);\n  }\n  if (typeString.equals(\"Bytes\")) {\n    String base64=jsonObject.optString(\"base64\");\n    return Base64.decode(base64,Base64.NO_WRAP);\n  }\n  if (typeString.equals(\"Pointer\")) {\n    return decodePointer(jsonObject.optString(\"className\"),jsonObject.optString(\"objectId\"));\n  }\n  if (typeString.equals(\"File\")) {\n    return new ParseFile(jsonObject,this);\n  }\n  if (typeString.equals(\"GeoPoint\")) {\n    double latitude, longitude;\n    try {\n      latitude=jsonObject.getDouble(\"latitude\");\n      longitude=jsonObject.getDouble(\"longitude\");\n    }\n catch (    JSONException e) {\n      throw new RuntimeException(e);\n    }\n    return new ParseGeoPoint(latitude,longitude);\n  }\n  if (typeString.equals(\"Polygon\")) {\n// bug_start\n    List<ParseGeoPoint> coordinates=new ArrayList<ParseGeoPoint>();\n// bug_end\n    try {\n      JSONArray array=jsonObject.getJSONArray(\"coordinates\");\n      for (int i=0; i < array.length(); ++i) {\n        JSONArray point=array.getJSONArray(i);\n        coordinates.add(new ParseGeoPoint(point.getDouble(0),point.getDouble(1)));\n      }\n    }\n catch (    JSONException e) {\n      throw new RuntimeException(e);\n    }\n    return new ParsePolygon(coordinates);\n  }\n  if (typeString.equals(\"Object\")) {\n    return ParseObject.fromJSON(jsonObject,null,this);\n  }\n  if (typeString.equals(\"Relation\")) {\n    return new ParseRelation<>(jsonObject,this);\n  }\n  if (typeString.equals(\"OfflineObject\")) {\n    throw new RuntimeException(\"An unexpected offline pointer was encountered.\");\n  }\n  return null;\n}\n"}
{"INPUT": "private <N,V>StateTable<K,N,V> tryRegisterStateTable(String stateName,StateDescriptor.Type stateType,TypeSerializer<N> namespaceSerializer,TypeSerializer<V> valueSerializer){\n  final RegisteredBackendStateMetaInfo<N,V> newMetaInfo=new RegisteredBackendStateMetaInfo<>(stateType,stateName,namespaceSerializer,valueSerializer);\n  @SuppressWarnings(\"unchecked\") StateTable<K,N,V> stateTable=(StateTable<K,N,V>)stateTables.get(stateName);\n  if (stateTable == null) {\n    stateTable=newStateTable(newMetaInfo);\n    stateTables.put(stateName,stateTable);\n  }\n else {\n// bug_start\n    if (!newMetaInfo.isCompatibleWith(stateTable.getMetaInfo())) {\n// bug_end\n      throw new RuntimeException(\"Trying to access state using incompatible meta info, was \" + stateTable.getMetaInfo() + \" trying access with \"+ newMetaInfo);\n    }\n    stateTable.setMetaInfo(newMetaInfo);\n  }\n  return stateTable;\n}\n"}
{"INPUT": "static void sendBatchRequest(SimpleURI uri,Keyspace keyspace,Path graqlPath,PrintStream sout,PrintStream serr) throws IOException {\n  AtomicInteger queriesExecuted=new AtomicInteger(0);\n  try (FileInputStream inputStream=new FileInputStream(graqlPath.toFile());Reader queryReader=new InputStreamReader(inputStream,Charsets.UTF_8);BatchExecutorClient batchExecutorClient=loaderClient(uri)){\n    batchExecutorClient.onNext(null);\n    batchExecutorClient.onError(null);\n// bug_start\n    Graql.parser().parseList(queryReader).forEach(null);\n// bug_end\n  }\n   sout.println(\"Statements executed: \" + queriesExecuted.get());\n}\n"}
{"INPUT": "@Test public void test(){\n  ClientMessage message=ClientMessage.createForEncode();\n// bug_start\n  message.addFrame(new ClientMessage.Frame(new byte[100],UNFRAGMENTED_MESSAGE | FINAL));\n// bug_end\n  message.setMessageType((short)MapPutCodec.REQUEST_MESSAGE_TYPE);\n  AtomicReference<ClientMessage> reference=new AtomicReference<>(message);\n  ClientMessageEncoder encoder=new ClientMessageEncoder();\n  encoder.src(null);\n  ByteBuffer buffer=ByteBuffer.allocate(1000);\n  buffer.flip();\n  encoder.dst(buffer);\n  HandlerStatus result=encoder.onWrite();\n  assertEquals(CLEAN,result);\n  AtomicReference<ClientMessage> resultingMessage=new AtomicReference<>();\n  ClientMessageDecoder decoder=new ClientMessageDecoder(null,null);\n  decoder.setNormalPacketsRead(SwCounter.newSwCounter());\n  buffer.position(buffer.limit());\n  decoder.src(buffer);\n  decoder.onRead();\n  assertEquals(message.getMessageType(),resultingMessage.get().getMessageType());\n}\n"}
{"INPUT": "@Ignore @Test public void test() throws IOException {\n  DiaoyuwengProcessor diaoyuwengProcessor=new DiaoyuwengProcessor();\n  FreemarkerPipeline pipeline=new FreemarkerPipeline(\"wordpress.ftl\");\n// bug_start\n  Spider.create(diaoyuwengProcessor).pipeline(new FilePipeline()).pipeline(pipeline).schedular(new FileCacheQueueScheduler(\"/data/temp/webmagic/cache/\")).run();\n// bug_end\n}\n"}
{"INPUT": "@Test public final void testUnSubscribeForScheduler() throws InterruptedException {\n  final AtomicInteger countReceived=new AtomicInteger();\n  final AtomicInteger countGenerated=new AtomicInteger();\n  final CountDownLatch latch=new CountDownLatch(1);\n  Flowable.interval(50,TimeUnit.MILLISECONDS).map(new Function<Long,Long>(){\n    @Override public Long apply(    Long aLong){\n      countGenerated.incrementAndGet();\n      return aLong;\n    }\n  }\n// bug_start\n).subscribeOn(getScheduler()).observeOn(getScheduler()).subscribe(new DefaultObserver<Long>(){\n// bug_end\n    @Override public void onComplete(){\n      System.out.println(\"--- completed\");\n    }\n    @Override public void onError(    Throwable e){\n      System.out.println(\"--- onError\");\n    }\n    @Override public void onNext(    Long args){\n      if (countReceived.incrementAndGet() == 2) {\n        cancel();\n        latch.countDown();\n      }\n      System.out.println(\"==> Received \" + args);\n    }\n  }\n);\n  latch.await(1000,TimeUnit.MILLISECONDS);\n  System.out.println(\"----------- it thinks it is finished ------------------ \");\n  Thread.sleep(100);\n  assertEquals(2,countGenerated.get());\n}\n"}
{"INPUT": "private EnumValueMapper interpretParameters(Properties parameters){\n  if (parameters.containsKey(NAMED)) {\n    final boolean useNamed=ConfigurationHelper.getBoolean(NAMED,parameters);\n    if (useNamed) {\n      return new NamedEnumValueMapper();\n    }\n else {\n      return new OrdinalEnumValueMapper();\n    }\n  }\n  if (parameters.containsKey(TYPE)) {\n    final int type=Integer.decode((String)parameters.get(TYPE));\n    if (isNumericType(type)) {\n      return new OrdinalEnumValueMapper();\n    }\n else     if (isCharacterType(type)) {\n// bug_start\n      return new OrdinalEnumValueMapper();\n// bug_end\n    }\n else {\n      throw new HibernateException(String.format(Locale.ENGLISH,\"Passed JDBC type code [%s] not recognized as numeric nor character\",type));\n    }\n  }\n  return new OrdinalEnumValueMapper();\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  Timber.plant(new Timber.DebugTree());\n// bug_start\n  getSupportFragmentManager().beginTransaction().addToBackStack(this.toString()).replace(R.id.activity_main,new PseudoCacheConcatFragment(),this.toString()).commit();\n// bug_end\n}\n"}
{"INPUT": "@Override public FunctionValues getValues(Map context,LeafReaderContext readerContext) throws IOException {\n// bug_start\n  return new ConstIntDocValues(ReaderUtil.getTopLevelContext(readerContext).reader().numDocs(),this);\n// bug_end\n}\n"}
{"INPUT": "@Override public void updateSearchItem(int index){\n  if (index < searchBookAdapter.getItemcount()) {\n    int startIndex=((LinearLayoutManager)rfRvSearchBooks.getRecyclerView().getLayoutManager()).findFirstVisibleItemPosition();\n    TextView tvAddShelf=rfRvSearchBooks.getRecyclerView().getChildAt(index - startIndex).findViewById(R.id.tv_addshelf);\n    if (tvAddShelf != null) {\n// bug_start\n      if (searchBookAdapter.getSearchBooks().get(index).getAdd()) {\n// bug_end\n        tvAddShelf.setText(\"\");\n        tvAddShelf.setEnabled(false);\n      }\n else {\n        tvAddShelf.setText(\"+\");\n        tvAddShelf.setEnabled(true);\n      }\n    }\n  }\n}\n"}
{"INPUT": "public static List<SortBuilder<?>> randomSortBuilderList(){\n  int size=randomIntBetween(1,5);\n  List<SortBuilder<?>> list=new ArrayList<>(size);\n  for (int i=0; i < size; i++) {\nswitch (randomIntBetween(0,3)) {\ncase 0:\n      list.add(new ScoreSortBuilder());\n    break;\ncase 1:\n// bug_start\n  String fieldName=rarely() ? FieldSortBuilder.DOC_FIELD_NAME : randomAsciiOfLengthBetween(1,10);\n// bug_end\nlist.add(new FieldSortBuilder(fieldName));\nbreak;\ncase 2:\nlist.add(GeoDistanceSortBuilderTests.randomGeoDistanceSortBuilder());\nbreak;\ncase 3:\nlist.add(ScriptSortBuilderTests.randomScriptSortBuilder());\nbreak;\ndefault :\nthrow new IllegalStateException(\"unexpected randomization in tests\");\n}\n}\nreturn list;\n}\n"}
{"INPUT": "public synchronized Map<String,String> getImportedClasses(String name) throws ClassNotFoundException {\n// bug_start\n  if (dontBother.containsValue(name)) {\n// bug_end\n    throw new ClassNotFoundException(name);\n  }\n  try (InputStream classResource=getResourceAsStream(name.replace('.','/') + \".class\")){\n    ClassReader reader=new ClassReader(classResource);\n    PMDASMVisitor asmVisitor=new PMDASMVisitor(name);\n    reader.accept(asmVisitor,0);\n    List<String> inner=asmVisitor.getInnerClasses();\n    if (inner != null && !inner.isEmpty()) {\n      inner=new ArrayList<>(inner);\n      for (      String str : inner) {\n        try (InputStream innerClassStream=getResourceAsStream(str.replace('.','/') + \".class\")){\n          if (innerClassStream != null) {\n            reader=new ClassReader(innerClassStream);\n            reader.accept(asmVisitor,0);\n          }\n        }\n       }\n    }\n    return asmVisitor.getPackages();\n  }\n catch (  IOException e) {\n    dontBother.put(name,Boolean.TRUE);\n    throw new ClassNotFoundException(name,e);\n  }\n}\n"}
{"INPUT": "private static String isKnownProperty(String propertyName,Collection<String> knownOptions){\n  if (knownOptions.contains(propertyName)) {\n    return null;\n  }\n// bug_start\n  return \"Unknown parameter [\" + propertyName + \"] ; did you mean \"+ StringUtils.findSimiliar(propertyName,knownOptions);\n// bug_end\n}\n"}
{"INPUT": "public void validate(ValidationContext validationContext){\n  if (!isValidTypeValue()) {\n    errors.add(TYPE,String.format(\"You have defined approval type as '%s'. Approval can only be of the type '%s' or '%s'.\",type,MANUAL,SUCCESS));\n  }\n  if (validationContext.isWithinPipelines()) {\n    PipelineConfigs group=validationContext.getPipelineGroup();\n// bug_start\n    if (!group.hasAuthorizationDefined()) {\n// bug_end\n      return;\n    }\n    AdminsConfig groupOperators=group.getAuthorization().getOperationConfig();\n    SecurityConfig serverSecurityConfig=validationContext.getServerSecurityConfig();\n    RolesConfig roles=serverSecurityConfig.getRoles();\n    for (    Admin approver : authConfig) {\n      boolean approverIsASuperAdmin=serverSecurityConfig.isAdmin(approver);\n      boolean approverIsAGroupAdmin=group.isUserAnAdmin(approver.getName(),roles.memberRoles(approver));\n      boolean approverIsNotAnAdmin=!(approverIsASuperAdmin || approverIsAGroupAdmin);\n      boolean approverIsNotAGroupOperator=!groupOperators.has(approver,roles.memberRoles(approver));\n      if (approverIsNotAnAdmin && approverIsNotAGroupOperator) {\n        approver.addError(String.format(\"%s \\\"%s\\\" who is not authorized to operate pipeline group can not be authorized to approve stage\",approver.describe(),approver,group.getGroup()));\n      }\n    }\n  }\n}\n"}
{"INPUT": "public User getUser(String accountName){\n  SearchResult ldapUser;\n  User user=new User();\n  try {\n    ldapUser=lookupUser(accountName);\n    if (ldapUser != null) {\n      Attribute attribute=ldapUser.getAttributes().get(idAttribute);\n      if (attribute != null) {\n        user.setLogin((String)attribute.get());\n      }\n else {\n        user.setLogin(accountName);\n      }\n      attribute=ldapUser.getAttributes().get(nameAttribute);\n      if (attribute != null) {\n        user.setName((String)attribute.get());\n      }\n else {\n        user.setName(accountName);\n      }\n      attribute=ldapUser.getAttributes().get(mailAttribute);\n      if (attribute != null) {\n        user.setEmail((String)attribute.get());\n      }\n else {\n        user.setEmail(accountName);\n      }\n    }\n// bug_start\n    user.setAdmin(isAdmin(accountName));\n// bug_end\n  }\n catch (  NamingException e) {\n    user.setLogin(accountName);\n    user.setName(accountName);\n    user.setEmail(accountName);\n    Log.warning(e);\n  }\n  return user;\n}\n"}
{"INPUT": "@Override protected Bitmap doInBackground(String... url){\n  data=url[0];\n  if (!isCancelled()) {\n// bug_start\n    return ImageTool.getAvatarBitmap(data);\n// bug_end\n  }\n  return null;\n}\n"}
{"INPUT": "@Nullable @Override public TimelineLookup<String,ServerSelector> getTimeline(DataSource dataSource){\n// bug_start\n  final String table=Iterables.getOnlyElement(dataSource.getNames());\n// bug_end\n  return timelines.get(table);\n}\n"}
{"INPUT": "@Override public Set<ItemType> getCategorisedByName(String category){\n// bug_start\n  return Optional.ofNullable(ItemTags.getContainer().get(new Identifier(category))).map(null).orElse(Collections.emptySet()).stream().map(null).collect(Collectors.toSet());\n// bug_end\n}\n"}
{"INPUT": "public void testSingleStringArrayRead() throws Exception {\n  String json=aposToQuotes(\"{ 'values': 'first' }\");\n  StringArrayWrapper result=MAPPER.readValue(json,StringArrayWrapper.class);\n  assertNotNull(result.values);\n  assertEquals(1,result.values.length);\n  assertEquals(\"first\",result.values[0]);\n// bug_start\n  ObjectMapper mapper=objectMapperBuilder().withConfigOverride(String[].class,null).build();\n// bug_end\n  StringArrayNotAnnoted result2=mapper.readValue(json,StringArrayNotAnnoted.class);\n  assertNotNull(result2.values);\n  assertEquals(1,result2.values.length);\n  assertEquals(\"first\",result2.values[0]);\n}\n"}
{"INPUT": "@Override public void invalidate(){\n  Screen top=mTestCarContext.getCarService(TestScreenManager.class).getTop();\n// bug_start\n  mTestCarContext.getCarService(TestAppManager.class).addTemplateReturned(top,top.getTemplate());\n// bug_end\n}\n"}
{"INPUT": "@Override public synchronized void save(Note note,AuthenticationInfo subject) throws IOException {\n  GsonBuilder gsonBuilder=new GsonBuilder();\n  gsonBuilder.setPrettyPrinting();\n  Gson gson=gsonBuilder.create();\n  String json=gson.toJson(note);\n  FileObject rootDir=getRootDir();\n// bug_start\n  FileObject noteDir=rootDir.resolveFile(note.id(),NameScope.CHILD);\n// bug_end\n  if (!noteDir.exists()) {\n    noteDir.createFolder();\n  }\n  if (!isDirectory(noteDir)) {\n    throw new IOException(noteDir.getName().toString() + \" is not a directory\");\n  }\n  FileObject noteJson=noteDir.resolveFile(\".note.json\",NameScope.CHILD);\n  OutputStream out=noteJson.getContent().getOutputStream(false);\n  out.write(json.getBytes(conf.getString(ConfVars.ZEPPELIN_ENCODING)));\n  out.close();\n  noteJson.moveTo(noteDir.resolveFile(\"note.json\",NameScope.CHILD));\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") private void initInternal(final InternalProcessorContext context){\n  this.context=context;\n  final String topic=ProcessorStateManager.storeChangelogTopic(context.applicationId(),name());\n  bytesSerdes=new StateSerdes<>(topic,Serdes.Bytes(),Serdes.ByteArray());\n  name=context.taskId() + \"-\" + name();\n// bug_start\n  cache=this.context.getCache();\n// bug_end\n  cache.addDirtyEntryFlushListener(name,null);\n}\n"}
{"INPUT": "@Override public Result<SearchResultValue> apply(Result<SearchResultValue> input){\n  if (isBySegment) {\n    BySegmentSearchResultValue value=(BySegmentSearchResultValue)input.getValue();\n    return new Result<SearchResultValue>(input.getTimestamp(),new BySegmentSearchResultValue(Lists.transform(value.getResults(),new Function<Result<SearchResultValue>,Result<SearchResultValue>>(){\n      @Override public Result<SearchResultValue> apply(      @Nullable Result<SearchResultValue> input){\n        return new Result<SearchResultValue>(input.getTimestamp(),new SearchResultValue(Lists.newArrayList(Iterables.limit(input.getValue(),query.getLimit()))));\n      }\n    }\n// bug_start\n),value.getSegmentId(),value.getIntervalString()));\n// bug_end\n  }\n  return new Result<SearchResultValue>(input.getTimestamp(),new SearchResultValue(Lists.<SearchHit>newArrayList(Iterables.limit(input.getValue(),query.getLimit()))));\n}\n"}
{"INPUT": "private static VaadinRequest createRequestMock(ClassLoader classloader){\n  VaadinService configurationMock=EasyMock.createMock(VaadinService.class);\n  EasyMock.expect(configurationMock.getClassLoader()).andReturn(classloader);\n  VaadinRequest requestMock=EasyMock.createMock(VaadinRequest.class);\n// bug_start\n  EasyMock.expect(requestMock.getVaadinService()).andReturn(configurationMock);\n// bug_end\n  EasyMock.replay(configurationMock,requestMock);\n  return requestMock;\n}\n"}
{"INPUT": "@Before public final void setUp() throws Exception {\n  Path testRoot=createTestRoot();\n  Path workspaceDir=testRoot.getRelative(\"workspace-name\");\n  workspaceDir.createDirectory();\n  outErr=new FileOutErr(testRoot.getRelative(\"stdout\"),testRoot.getRelative(\"stderr\"));\n  Path outputBase=testRoot.getRelative(\"outputBase\");\n  outputBase.createDirectory();\n  BlazeDirectories directories=new BlazeDirectories(new ServerDirectories(outputBase,outputBase),workspaceDir,\"mock-product-name\");\n  IntegrationMock.get().getIntegrationBinTools(fileSystem,directories,TestConstants.WORKSPACE_NAME);\n  OptionsParser optionsParser=OptionsParser.newOptionsParser(ExecutionOptions.class);\n  optionsParser.parse(\"--verbose_failures\");\n  LocalExecutionOptions localExecutionOptions=Options.getDefaults(LocalExecutionOptions.class);\n  EventBus bus=new EventBus();\n  ResourceManager resourceManager=ResourceManager.instanceForTestingOnly();\n  resourceManager.setAvailableResources(ResourceSet.create(1,1,1,1));\n  Path execRoot=directories.getExecRoot(TestConstants.WORKSPACE_NAME);\n  this.executor=new BlazeExecutor(fileSystem,execRoot,reporter,bus,BlazeClock.instance(),optionsParser,ImmutableList.<ActionContext>of(),ImmutableMap.<String,SpawnActionContext>of(\"\",new StandaloneSpawnStrategy(execRoot,new LocalSpawnRunner(execRoot,localExecutionOptions,resourceManager,\"mock-product-name\",LocalEnvProvider.UNMODIFIED))),ImmutableList.<ActionContextProvider>of());\n// bug_start\n  executor.getExecRoot().createDirectory();\n// bug_end\n}\n"}
{"INPUT": "static public junit.framework.Test suite() throws Exception {\n  final MultiConfigSuiteBuilder builder=new MultiConfigSuiteBuilder(TestPrepareShutdown.class);\n  Map<String,String> additionalEnv=new HashMap<String,String>();\n  String bundleLocation=System.getProperty(\"user.dir\") + \"/bundles\";\n  additionalEnv.put(\"voltdbbundlelocation\",bundleLocation);\n  VoltProjectBuilder project=new VoltProjectBuilder();\n  project.addSchema(ArbitraryDurationProc.class.getResource(\"clientfeatures.sql\"));\n// bug_start\n  project.addProcedures(ArbitraryDurationProc.class);\n// bug_end\n  project.setUseDDLSchema(true);\n  project.addPartitionInfo(\"indexme\",\"pkey\");\n  Properties props=buildProperties(\"port\",\"7001\",\"decode\",\"true\",\"procedure\",\"indexme.insert\");\n  Properties formatConfig=buildProperties(\"nullstring\",\"test\",\"separator\",\",\",\"blank\",\"empty\",\"escape\",\"\\\\\",\"quotechar\",\"\\\"\",\"nowhitespace\",\"true\");\n  project.addImport(true,\"custom\",\"csv\",\"socketstream.jar\",props,formatConfig);\n  LocalCluster config=new LocalCluster(\"prepare_shutdown_importer.jar\",4,1,0,BackendTarget.NATIVE_EE_JNI,LocalCluster.FailureState.ALL_RUNNING,true,false,additionalEnv);\n  config.setHasLocalServer(false);\n  boolean compile=config.compileWithAdminMode(project,-1,false);\n  assertTrue(compile);\n  builder.addServerConfig(config);\n  return builder;\n}\n"}
{"INPUT": "public void testSingleValueFieldDatatField() throws ExecutionException, InterruptedException {\n  assertAcked(client().admin().indices().prepareCreate(\"test\").addMapping(\"type\",\"test_field\",\"type=keyword\").get());\n  indexRandom(true,client().prepareIndex(\"test\",\"type\",\"1\").setSource(\"test_field\",\"foobar\"));\n  refresh();\n// bug_start\n  SearchResponse searchResponse=client().prepareSearch(\"test\").setTypes(\"type\").setSource(new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()).fieldDataField(\"test_field\")).get();\n// bug_end\n  assertHitCount(searchResponse,1);\n  Map<String,DocumentField> fields=searchResponse.getHits().getHits()[0].getFields();\n  assertThat(fields.get(\"test_field\").getValue(),equalTo(\"foobar\"));\n}\n"}
{"INPUT": "@Override public boolean fix() throws KafkaCruiseControlException {\n  boolean hasProposalsToFix=false;\n  if (!_fixable) {\n    return hasProposalsToFix;\n  }\n  if (_removeBrokersRunnable != null) {\n// bug_start\n    _optimizationResult=new OptimizationResult(_removeBrokersRunnable.removeBrokers(),null);\n// bug_end\n    hasProposalsToFix=hasProposalsToFix();\n    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n  }\n else   if (_demoteBrokerRunnable != null) {\n    _optimizationResult=new OptimizationResult(_demoteBrokerRunnable.demoteBrokers(),null);\n    hasProposalsToFix=hasProposalsToFix();\n    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n  }\n  return hasProposalsToFix;\n}\n"}
{"INPUT": "public Set<TaskId> cachedTasksIds(){\n  final HashSet<TaskId> tasks=new HashSet<>();\n// bug_start\n  final File[] stateDirs=taskCreator.stateDirectory().listTaskDirectories();\n// bug_end\n  if (stateDirs != null) {\n    for (    final File dir : stateDirs) {\n      try {\n        final TaskId id=TaskId.parse(dir.getName());\n        if (new File(dir,StateManagerUtil.CHECKPOINT_FILE_NAME).exists()) {\n          tasks.add(id);\n        }\n      }\n catch (      final TaskIdFormatException e) {\n      }\n    }\n  }\n  return tasks;\n}\n"}
{"INPUT": "@Override public void onRender(Env env,Scope scope,Writer writer){\n  Controller controller=JbootControllerContext.get();\n  int page=controller.getParaToInt(1,1);\n  int pageSize=getParaToInt(\"pageSize\",scope,10);\n// bug_start\n  Long categoryId=getParaToLang(\"categoryId\",scope,0L);\n// bug_end\n  ArticleCategory category=controller.getAttr(\"category\");\n  if (categoryId == 0 && category != null) {\n    categoryId=category.getId();\n  }\n  Page<Article> articlePage=categoryId == 0 ? service.paginateInNormal(page,pageSize) : service.paginateByCategoryIdInNormal(page,pageSize,categoryId,null);\n  scope.setGlobal(\"articlePage\",articlePage);\n  renderBody(env,scope,writer);\n}\n"}
{"INPUT": "@Override public EndpointPair<N> incidentNodes(E edge){\n  N nodeU=checkedReferenceNode(edge);\n// bug_start\n  N nodeV=nodeConnections.get(nodeU).oppositeNode(edge);\n// bug_end\n  return EndpointPair.of(this,nodeU,nodeV);\n}\n"}
{"INPUT": "@Override public ListenableFuture<WebSocketSession> connect(TransportRequest request,WebSocketHandler handler){\n// bug_start\n  final SettableListenableFuture<WebSocketSession> future=new SettableListenableFuture<WebSocketSession>();\n// bug_end\n  WebSocketClientSockJsSession session=new WebSocketClientSockJsSession(request,handler,future);\n  handler=new ClientSockJsWebSocketHandler(session);\n  request.addTimeoutTask(session.getTimeoutTask());\n  URI url=request.getTransportUrl();\n  WebSocketHttpHeaders headers=new WebSocketHttpHeaders(request.getHandshakeHeaders());\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"Starting WebSocket session url=\" + url);\n  }\n  this.webSocketClient.doHandshake(handler,headers,url).addCallback(new ListenableFutureCallback<WebSocketSession>(){\n    @Override public void onSuccess(    WebSocketSession webSocketSession){\n    }\n    @Override public void onFailure(    Throwable ex){\n      future.setException(ex);\n    }\n  }\n);\n  return future;\n}\n"}
{"INPUT": "private Map<String,Set<Resource>> createMap(final Resource[] resources){\n  final Map<String,Set<Resource>> resourcesMap=new HashMap<>();\n  for (  final Resource resource : resources) {\n    final String parentFolderName=determineGroupName(resource);\n    if (resourcesMap.get(parentFolderName) == null) {\n// bug_start\n      resourcesMap.put(parentFolderName,new HashSet<Resource>());\n// bug_end\n    }\n    resourcesMap.get(parentFolderName).add(resource);\n  }\n  return resourcesMap;\n}\n"}
{"INPUT": "public static byte[] verifyJwsSignature(final Key signingKey,final byte[] value){\n  try {\n    final String asString=new String(value,StandardCharsets.UTF_8);\n    final JsonWebSignature jws=new JsonWebSignature();\n    jws.setCompactSerialization(asString);\n    jws.setKey(signingKey);\n    final boolean verified=jws.verifySignature();\n    if (verified) {\n      final String payload=jws.getPayload();\n// bug_start\n      LOGGER.debug(\"Successfully decoded value. Result in Base64-encoding is [{}]\",payload);\n// bug_end\n      return EncodingUtils.decodeBase64(payload);\n    }\n    return null;\n  }\n catch (  final Exception e) {\n    throw Throwables.propagate(e);\n  }\n}\n"}
{"INPUT": "private AbstractExpression processFilters(AbstractExpression filters,List<TupleValueExpression> needReAggTVEs,List<AbstractExpression> aggPostExprs){\n  if (filters == null) {\n    return null;\n  }\n  List<AbstractExpression> remaningExprs=new ArrayList<AbstractExpression>();\n// bug_start\n  List<AbstractExpression> exprs=ExpressionUtil.uncombine(filters);\n// bug_end\n  for (  AbstractExpression expr : exprs) {\n    ArrayList<AbstractExpression> tves=expr.findBaseTVEs();\n    boolean canPushdown=true;\n    for (    TupleValueExpression needReAggTVE : needReAggTVEs) {\n      if (tves.contains(needReAggTVE)) {\n        m_edgeCaseQueryNoFixNeeded=false;\n        if (fromMVTableOnly(tves)) {\n          canPushdown=false;\n        }\n        break;\n      }\n    }\n    if (canPushdown) {\n      remaningExprs.add(expr);\n    }\n else {\n      aggPostExprs.add(expr);\n    }\n  }\n  AbstractExpression remaningFilters=ExpressionUtil.combinePredicates(remaningExprs);\n  return remaningFilters;\n}\n"}
{"INPUT": "@Override public Node visitPrintTopic(final SqlBaseParser.PrintTopicContext context){\n  final boolean fromBeginning=context.printClause().FROM() != null;\n  final QualifiedName topicName;\n  if (context.STRING() != null) {\n    topicName=QualifiedName.of(ParserUtil.unquote(context.STRING().getText(),\"'\"));\n  }\n else {\n// bug_start\n    topicName=ParserUtil.getQualifiedName(context.qualifiedName());\n// bug_end\n  }\n  final IntervalClauseContext intervalContext=context.printClause().intervalClause();\n  final OptionalInt interval=intervalContext == null ? OptionalInt.empty() : OptionalInt.of(processIntegerNumber(intervalContext.number(),\"INTERVAL\"));\n  final OptionalInt limit=getLimit(context.printClause().limitClause());\n  return new PrintTopic(getLocation(context),topicName,fromBeginning,interval,limit);\n}\n"}
{"INPUT": "public void assertMembersOf(ClusterSpec requestedCluster,Collection<HostSpec> hosts){\n  Set<Integer> indices=new HashSet<>();\n  for (  HostSpec host : hosts) {\n    ClusterSpec nodeCluster=host.membership().get().cluster();\n// bug_start\n    assertTrue(requestedCluster.equalsIgnoringGroupAndVespaVersion(nodeCluster));\n// bug_end\n    if (requestedCluster.group().isPresent())     assertEquals(requestedCluster.group(),nodeCluster.group());\n else     assertEquals(0,nodeCluster.group().get().index());\n    indices.add(host.membership().get().index());\n  }\n  assertEquals(\"Indexes in \" + requestedCluster + \" are disjunct\",hosts.size(),indices.size());\n}\n"}
{"INPUT": "public List<PermissionInfo> getAllPermission(){\n  List<Menu> menus=menuBiz.selectListAll();\n  List<PermissionInfo> result=new ArrayList<PermissionInfo>();\n  PermissionInfo info=null;\n  menu2permission(menus,result);\n// bug_start\n  List<Element> elements=elementBiz.selectListAll();\n// bug_end\n  element2permission(result,elements);\n  return result;\n}\n"}
{"INPUT": "private void writeSuiteToFile(File suiteFile,ISuite suite){\n  XMLStringBuffer xmlBuffer=new XMLStringBuffer();\n  writeSuiteToBuffer(xmlBuffer,suite);\n  File parentDir=suiteFile.getParentFile();\n  suiteFile.getParentFile().mkdirs();\n  if (parentDir.exists() || suiteFile.getParentFile().exists()) {\n// bug_start\n    Utils.writeFile(parentDir.getAbsolutePath(),FILE_NAME,xmlBuffer.toXML());\n// bug_end\n  }\n}\n"}
{"INPUT": "public void testRun(){\n  solo.waitForActivity(MainActivity.class,4000);\n  Timeout.setSmallTimeout(30522);\n// bug_start\n  solo.clickOnView(solo.getView(it.feio.android.omninotes.R.id.fab_expand_menu_button));\n// bug_end\n  EditText titleEditText=(EditText)solo.getView(it.feio.android.omninotes.R.id.detail_title);\n  solo.clickOnView(titleEditText);\n  setTextViewContent(titleEditText,NOTE_TITLE);\n  EditText contentEditText=(EditText)solo.getView(it.feio.android.omninotes.R.id.detail_content);\n  solo.clickOnView(contentEditText);\n  setTextViewContent(contentEditText,NOTE_CONTENT);\n  solo.clickOnView(solo.getView(android.widget.ImageButton.class,0));\n  solo.sleep(1500);\n  List<Note> retrievedNotes=DbHelper.getInstance().getNotesByPattern(NOTE_CONTENT);\n  assertEquals(retrievedNotes.size(),1);\n  assertEquals(retrievedNotes.get(0).getTitle(),NOTE_TITLE);\n}\n"}
{"INPUT": "@Override protected ScoreFunction doToFunction(QueryShardContext context){\n  final int salt=(context.index().getName().hashCode() << 10) | context.getShardId();\n  if (seed == null) {\n    return new RandomScoreFunction(hash(context.nowInMillis()),salt,null);\n  }\n else {\n    String fieldName;\n    if (field == null) {\n      deprecationLogger.deprecate(\"seed_requires_field\",\"As of version 7.0 Elasticsearch will require that a [field] parameter is provided when a [seed] is set\");\n      fieldName=IdFieldMapper.NAME;\n    }\n else {\n      fieldName=field;\n    }\n    if (context.isFieldMapped(fieldName) == false) {\n      if (context.getMapperService().documentMapper() == null) {\n        return new RandomScoreFunction(hash(context.nowInMillis()),salt,null);\n      }\n      throw new IllegalArgumentException(\"Field [\" + field + \"] is not mapped on [\"+ context.index()+ \"] and cannot be used as a source of random numbers.\");\n    }\n    int seed;\n    if (this.seed == null) {\n      seed=hash(context.nowInMillis());\n    }\n else {\n      seed=this.seed;\n    }\n// bug_start\n    return new RandomScoreFunction(seed,salt,context.getForField(context.fieldMapper(fieldName)));\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public Result invoke(Invocation invocation) throws RpcException {\n  Result asyncResult=filterInvoker.invoke(invocation);\n// bug_start\n  asyncResult.thenApplyWithContext(null);\n// bug_end\n  return asyncResult;\n}\n"}
{"INPUT": "protected void execute(DeploymentProcessorTarget processorTarget){\n  processorTarget.addDeploymentProcessor(JSFExtension.SUBSYSTEM_NAME,Phase.PARSE,Phase.PARSE_JSF_VERSION,new JSFVersionProcessor(model));\n  processorTarget.addDeploymentProcessor(JSFExtension.SUBSYSTEM_NAME,Phase.PARSE,Phase.PARSE_JSF_SHARED_TLDS,new JSFSharedTldsProcessor());\n// bug_start\n  processorTarget.addDeploymentProcessor(JSFExtension.SUBSYSTEM_NAME,Phase.PARSE,Phase.POST_MODULE_JSF_MANAGED_BEANS,new JSFManagedBeanProcessor());\n// bug_end\n  processorTarget.addDeploymentProcessor(JSFExtension.SUBSYSTEM_NAME,Phase.DEPENDENCIES,Phase.DEPENDENCIES_JSF,new JSFDependencyProcessor());\n  processorTarget.addDeploymentProcessor(JSFExtension.SUBSYSTEM_NAME,Phase.POST_MODULE,Phase.POST_MODULE_JSF_MANAGED_BEANS,new JSFManagedBeanProcessor());\n  processorTarget.addDeploymentProcessor(JSFExtension.SUBSYSTEM_NAME,Phase.INSTALL,Phase.INSTALL_JSF_ANNOTATIONS,new JSFAnnotationProcessor());\n}\n"}
{"INPUT": "public static void setup(RequestContext ctx,AttributeKey<Boolean> requestMetricsSetKey,MeterIdPrefixFunction meterIdPrefixFunction,boolean server){\n  final Boolean isRequestMetricsSet=ctx.attr(requestMetricsSetKey);\n  if (Boolean.TRUE.equals(isRequestMetricsSet)) {\n    return;\n  }\n  ctx.setAttr(requestMetricsSetKey,true);\n// bug_start\n  ctx.log().whenAvailable(RequestLogProperty.REQUEST_START_TIME,RequestLogProperty.REQUEST_HEADERS,RequestLogProperty.REQUEST_CONTENT,RequestLogProperty.SESSION).thenAccept(null);\n// bug_end\n}\n"}
{"INPUT": "@Test public void verifyAuthentication() throws Exception {\n// bug_start\n  final HandlerResult result=this.authenticationHandler.authenticate(TestUtils.getCredentialsWithDifferentUsernameAndPassword(\"u1\",\"p1\"));\n// bug_end\n  assertEquals(result.getPrincipal().getId(),\"u1\");\n  assertTrue(result.getPrincipal().getAttributes().containsKey(\"loc\"));\n  assertTrue(result.getPrincipal().getAttributes().containsKey(\"state\"));\n}\n"}
{"INPUT": "private void checkPlan(OptimizedPlan plan){\n  OptimizerPlanNodeResolver or=getOptimizerPlanNodeResolver(plan);\n  final SinkPlanNode sink=or.getNode(SINK);\n  final SingleInputPlanNode reducer=or.getNode(REDUCER_NAME);\n  final SingleInputPlanNode combiner=(SingleInputPlanNode)reducer.getPredecessor();\n  final SingleInputPlanNode mapper=or.getNode(MAPPER_NAME);\n  assertEquals(1,mapper.getBroadcastInputs().size());\n  assertEquals(ShipStrategyType.FORWARD,mapper.getInput().getShipStrategy());\n  assertEquals(ShipStrategyType.BROADCAST,mapper.getBroadcastInputs().get(0).getShipStrategy());\n  assertEquals(LocalStrategy.NONE,mapper.getInput().getLocalStrategy());\n  assertEquals(LocalStrategy.NONE,mapper.getBroadcastInputs().get(0).getLocalStrategy());\n// bug_start\n  assertEquals(DriverStrategy.MAP,mapper.getDriverStrategy());\n// bug_end\n  assertNull(mapper.getInput().getLocalStrategyKeys());\n  assertNull(mapper.getInput().getLocalStrategySortOrder());\n  assertNull(mapper.getBroadcastInputs().get(0).getLocalStrategyKeys());\n  assertNull(mapper.getBroadcastInputs().get(0).getLocalStrategySortOrder());\n  Assert.assertNotNull(combiner);\n  assertEquals(ShipStrategyType.FORWARD,combiner.getInput().getShipStrategy());\n  assertEquals(LocalStrategy.NONE,combiner.getInput().getLocalStrategy());\n  assertEquals(DriverStrategy.PARTIAL_GROUP,combiner.getDriverStrategy());\n  assertNull(combiner.getInput().getLocalStrategyKeys());\n  assertNull(combiner.getInput().getLocalStrategySortOrder());\n  assertEquals(set0,combiner.getKeys());\n  assertEquals(ShipStrategyType.PARTITION_HASH,reducer.getInput().getShipStrategy());\n  assertEquals(LocalStrategy.COMBININGSORT,reducer.getInput().getLocalStrategy());\n  assertEquals(DriverStrategy.SORTED_GROUP,reducer.getDriverStrategy());\n  assertEquals(set0,reducer.getKeys());\n  assertEquals(set0,reducer.getInput().getLocalStrategyKeys());\n  assertTrue(Arrays.equals(reducer.getInput().getLocalStrategySortOrder(),reducer.getSortOrders()));\n  assertEquals(ShipStrategyType.FORWARD,sink.getInput().getShipStrategy());\n  assertEquals(LocalStrategy.NONE,sink.getInput().getLocalStrategy());\n}\n"}
{"INPUT": "@Test public void test() throws SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, IOException {\n  QCat cat=QCat.cat;\n  ColQueryImpl query=new ColQueryImpl();\n  query.from(cat,Collections.<Cat>emptyList());\n// bug_start\n  Mutability.test(query,cat.id,cat.name);\n// bug_end\n}\n"}
{"INPUT": "@Override public IntArrayRef getOrds(int docId){\n  int ordinal=ordinals[docId];\n  if (ordinal == 0)   return IntArrayRef.EMPTY;\n// bug_start\n  intsScratch.values[0]=docId;\n// bug_end\n  return intsScratch;\n}\n"}
{"INPUT": "@Subscribe public void buildStarting(BuildStartingEvent event){\n  RemoteOptions options=event.getRequest().getOptions(RemoteOptions.class);\n// bug_start\n  if (ConcurrentMapFactory.isRemoteCacheOptions(options) || GrpcActionCache.isRemoteCacheOptions(options)) {\n// bug_end\n    HashFunction hf=FileSystem.getDigestFunction();\n    if (hf != HashFunction.SHA1) {\n      env.getBlazeModuleEnvironment().exit(new AbruptExitException(\"Remote cache/execution requires SHA1 digests, got \" + hf + \", run with --host_jvm_args=-Dbazel.DigestFunction=SHA1\",ExitCode.COMMAND_LINE_ERROR));\n    }\n  }\n}\n"}
{"INPUT": "public BugInstance addFoundAndExpectedType(String foundType,String expectedType){\n  add(new TypeAnnotation(foundType)).describe(TypeAnnotation.FOUND_ROLE);\n// bug_start\n  add(new TypeAnnotation(expectedType)).describe(TypeAnnotation.FOUND_ROLE);\n// bug_end\n  return this;\n}\n"}
{"INPUT": "@Override public void drawBackground(Canvas canvas,Rect rect,Integer position,Paint paint){\n  paint.setStyle(Paint.Style.FILL);\n// bug_start\n  paint.setColor(ContextCompat.getColor(SeatModeActivity.this,R.color.base_black_title_color));\n// bug_end\n  canvas.drawRect(rect,paint);\n}\n"}
{"INPUT": "public void onClick(View v){\n  ViewGroup.MarginLayoutParams lp;\n  lp=(ViewGroup.MarginLayoutParams)mInnerList.getLayoutParams();\n// bug_start\n  lp.height=lp.FILL_PARENT;\n// bug_end\n  mInnerList.setLayoutParams(lp);\n  mInnerList.setAdapter(mAdapter);\n  mOuterLayout.setVisibility(View.VISIBLE);\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_practice_repast);\n  final Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);\n  toolbar.setNavigationOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      finish();\n    }\n  }\n);\n// bug_start\n  final RefreshLayout refreshLayout=(RefreshLayout)findViewById(R.id.smartLayout);\n// bug_end\n  if (isFirstEnter) {\n    isFirstEnter=false;\n    refreshLayout.autoRefresh();\n  }\n  View view=findViewById(R.id.recyclerView);\n  if (view instanceof RecyclerView) {\n    RecyclerView recyclerView=(RecyclerView)view;\n    recyclerView.setLayoutManager(new LinearLayoutManager(this));\n    recyclerView.setItemAnimator(new DefaultItemAnimator());\n    recyclerView.setAdapter(mAdapter=new BaseRecyclerAdapter<Model>(loadModels(),R.layout.listitem_practive_repast){\n      @Override protected void onBindViewHolder(      SmartViewHolder holder,      Model model,      int position){\n        holder.text(R.id.name,model.name);\n        holder.text(R.id.nickname,model.nickname);\n        holder.image(R.id.image,model.imageId);\n        holder.image(R.id.avatar,model.avatarId);\n      }\n    }\n);\n    refreshLayout.setOnRefreshLoadmoreListener(new OnRefreshLoadmoreListener(){\n      @Override public void onRefresh(      final RefreshLayout refreshlayout){\n        refreshLayout.getLayout().postDelayed(new Runnable(){\n          @Override public void run(){\n            refreshlayout.finishRefresh();\n          }\n        }\n,2000);\n      }\n      @Override public void onLoadmore(      final RefreshLayout refreshlayout){\n        refreshLayout.getLayout().postDelayed(new Runnable(){\n          @Override public void run(){\n            mAdapter.loadmore(loadModels());\n            refreshlayout.finishLoadmore();\n            if (mAdapter.getCount() > 12) {\n              Toast.makeText(getBaseContext(),\"\",Toast.LENGTH_SHORT).show();\n              refreshlayout.setLoadmoreFinished(true);\n            }\n          }\n        }\n,1000);\n      }\n    }\n);\n  }\n  StatusBarUtil.darkMode(this);\n  StatusBarUtil.setPaddingSmart(this,view);\n  StatusBarUtil.setPaddingSmart(this,toolbar);\n  StatusBarUtil.setPaddingSmart(this,findViewById(R.id.blurview));\n  StatusBarUtil.setMargin(this,findViewById(R.id.gifview));\n}\n"}
{"INPUT": "private void parseSinglePattern(String pattern){\n  final String[] parts=pattern.split(\"\\\\s\");\n  int offset=0;\n  if (parts.length == 6 || parts.length == 7) {\n    offset=1;\n  }\n else   if (parts.length != 5) {\n    throw new CronException(\"Pattern [{}] is invalid, it must be 5-7 parts!\",pattern);\n  }\n  if (1 == offset) {\n    try {\n      this.secondMatchers.add(ValueMatcherBuilder.build(parts[0],SECOND_VALUE_PARSER));\n    }\n catch (    Exception e) {\n      throw new CronException(e,\"Invalid pattern [{}], parsing 'second' field error!\",pattern);\n    }\n  }\n else {\n    this.secondMatchers.add(ValueMatcherBuilder.build(String.valueOf(DateUtil.date().second()),SECOND_VALUE_PARSER));\n  }\n  try {\n    this.minuteMatchers.add(ValueMatcherBuilder.build(parts[offset],MINUTE_VALUE_PARSER));\n  }\n catch (  Exception e) {\n    throw new CronException(e,\"Invalid pattern [{}], parsing 'minute' field error!\",pattern);\n  }\n  try {\n    this.hourMatchers.add(ValueMatcherBuilder.build(parts[1 + offset],HOUR_VALUE_PARSER));\n  }\n catch (  Exception e) {\n    throw new CronException(e,\"Invalid pattern [{}], parsing 'hour' field error!\",pattern);\n  }\n  try {\n    this.dayOfMonthMatchers.add(ValueMatcherBuilder.build(parts[2 + offset],DAY_OF_MONTH_VALUE_PARSER));\n  }\n catch (  Exception e) {\n    throw new CronException(e,\"Invalid pattern [{}], parsing 'day of month' field error!\",pattern);\n  }\n  try {\n    this.monthMatchers.add(ValueMatcherBuilder.build(parts[3 + offset],MONTH_VALUE_PARSER));\n  }\n catch (  Exception e) {\n    throw new CronException(e,\"Invalid pattern [{}], parsing 'month' field error!\",pattern);\n  }\n  try {\n    this.dayOfWeekMatchers.add(ValueMatcherBuilder.build(parts[4 + offset],DAY_OF_WEEK_VALUE_PARSER));\n  }\n catch (  Exception e) {\n    throw new CronException(e,\"Invalid pattern [{}], parsing 'day of week' field error!\",pattern);\n  }\n  if (parts.length == 7) {\n    try {\n      this.yearMatchers.add(ValueMatcherBuilder.build(parts[6],YEAR_VALUE_PARSER));\n    }\n catch (    Exception e) {\n      throw new CronException(e,\"Invalid pattern [{}], parsing 'year' field error!\",pattern);\n    }\n  }\n else {\n// bug_start\n    this.secondMatchers.add(new AlwaysTrueValueMatcher());\n// bug_end\n  }\n  matcherSize++;\n}\n"}
{"INPUT": "private final void interruptableRun(){\n  try {\n    String host=uri.getHost();\n    int port=getPort();\n    tryToConnect(new InetSocketAddress(host,port));\n    conn=(WebSocketImpl)wf.createWebSocket(this,draft,channel.socket());\n    conn.channel=wrappedchannel=wf.wrapChannel(channel,null,host,port);\n    timeout=0;\n    sendHandshake();\n    readthread=new Thread(new WebsocketWriteThread());\n    readthread.start();\n  }\n catch (  ClosedByInterruptException e) {\n    onWebsocketError(null,e);\n    return;\n  }\ncatch (  Exception e) {\n    onWebsocketError(conn,e);\n    conn.closeConnection(CloseFrame.NEVER_CONNECTED,e.getMessage());\n    return;\n  }\n// bug_start\n  ByteBuffer buff=ByteBuffer.allocate(WebSocket.RCVBUF);\n// bug_end\n  try {\n    while (channel.isOpen()) {\n      if (SocketChannelIOHelper.read(buff,this.conn,wrappedchannel)) {\n        conn.decode(buff);\n      }\n else {\n        conn.eot();\n      }\n      if (wrappedchannel instanceof WrappedByteChannel) {\n        WrappedByteChannel w=(WrappedByteChannel)wrappedchannel;\n        if (w.isNeedRead()) {\n          while (SocketChannelIOHelper.read(buff,conn,w)) {\n            conn.decode(buff);\n          }\n        }\n      }\n    }\n  }\n catch (  CancelledKeyException e) {\n    conn.eot();\n  }\ncatch (  IOException e) {\n    conn.eot();\n  }\ncatch (  RuntimeException e) {\n    onError(e);\n    conn.closeConnection(CloseFrame.ABNORMAL_CLOSE,e.getMessage());\n  }\n}\n"}
{"INPUT": "@Override public TokenStream create(TokenStream tokenStream){\n// bug_start\n  if (this.version.onOrAfter(Version.LUCENE_42)) {\n// bug_end\n    return new XNGramTokenFilter(version,tokenStream,minGram,maxGram);\n  }\n  return new NGramTokenFilter(tokenStream,minGram,maxGram);\n}\n"}
{"INPUT": "void openDetails(){\n  if (gpxItem != null) {\n    LatLon location=null;\n    WptPt wpt=null;\n    gpxItem.chartTypes=new GPXDataSetType[]{GPXDataSetType.ALTITUDE,GPXDataSetType.SLOPE};\n    if (gpxItem.chartHighlightPos != -1) {\n      TrkSegment segment=gpx.tracks.get(0).segments.get(0);\n      if (segment != null) {\n        float distance=gpxItem.chartHighlightPos * elevationDataSet.getDivX();\n        for (        WptPt p : segment.points) {\n          if (p.distance >= distance) {\n            wpt=p;\n            break;\n          }\n        }\n        if (wpt != null) {\n          location=new LatLon(wpt.lat,wpt.lon);\n        }\n      }\n    }\n    if (location == null) {\n      location=new LatLon(gpxItem.locationStart.lat,gpxItem.locationStart.lon);\n    }\n    if (wpt != null) {\n      gpxItem.locationOnMap=wpt;\n    }\n else {\n      gpxItem.locationOnMap=gpxItem.locationStart;\n    }\n    final MapActivity activity=(MapActivity)getActivity();\n    if (activity != null) {\n      dismiss();\n      final OsmandSettings settings=activity.getMyApplication().getSettings();\n      settings.setMapLocationToShow(location.getLatitude(),location.getLongitude(),settings.getLastKnownMapZoom(),new PointDescription(PointDescription.POINT_TYPE_WPT,gpxItem.name),false,gpxItem);\n      final MapRouteInfoMenu mapRouteInfoMenu=activity.getMapLayers().getMapControlsLayer().getMapRouteInfoMenu();\n// bug_start\n      if (mapRouteInfoMenu.isVisible()) {\n// bug_end\n        mapRouteInfoMenu.setOnDismissListener(new OnDismissListener(){\n          @Override public void onDismiss(          DialogInterface dialog){\n            mapRouteInfoMenu.setOnDismissListener(null);\n            MapActivity.launchMapActivityMoveToTop(activity);\n          }\n        }\n);\n        mapRouteInfoMenu.hide();\n      }\n else {\n        MapActivity.launchMapActivityMoveToTop(activity);\n      }\n    }\n  }\n}\n"}
{"INPUT": "@SuppressWarnings(\"ConstantConditions\") static void compare(final Context ctx,Schema original,Schema update){\n  if (original == null && update == null) {\n    return;\n  }\n else   if (original == null) {\n    throw new IllegalArgumentException(\"Original schema not provided\");\n  }\n else   if (update == null) {\n    ctx.addDifference(Type.SCHEMA_REMOVED);\n    return;\n  }\n  original=normalizeEmptySchema(original);\n  update=normalizeEmptySchema(update);\n  if (!(original instanceof CombinedSchema) && update instanceof CombinedSchema) {\n    CombinedSchema combinedSchema=(CombinedSchema)update;\n    if (combinedSchema.getSubschemas().size() == 1) {\n      final Context subctx=ctx.getSubcontext();\n      compare(subctx,original,combinedSchema.getSubschemas().iterator().next());\n      if (subctx.isCompatible()) {\n        ctx.addDifferences(subctx.getDifferences());\n        return;\n      }\n    }\n// bug_start\n else     if (combinedSchema.getCriterion() == CombinedSchema.ONE_CRITERION || combinedSchema.getCriterion() == CombinedSchema.ONE_CRITERION) {\n// bug_end\n      for (      Schema subschema : combinedSchema.getSubschemas()) {\n        final Context subctx=ctx.getSubcontext();\n        compare(subctx,original,subschema);\n        if (subctx.isCompatible()) {\n          ctx.addDifferences(subctx.getDifferences());\n          ctx.addDifference(Type.SUM_TYPE_EXTENDED);\n          return;\n        }\n      }\n    }\n  }\n else   if (original instanceof CombinedSchema && !(update instanceof CombinedSchema)) {\n    CombinedSchema combinedSchema=(CombinedSchema)original;\n    if (combinedSchema.getSubschemas().size() == 1) {\n      final Context subctx=ctx.getSubcontext();\n      compare(subctx,combinedSchema.getSubschemas().iterator().next(),update);\n      if (subctx.isCompatible()) {\n        ctx.addDifferences(subctx.getDifferences());\n        return;\n      }\n    }\n  }\n  if (!original.getClass().equals(update.getClass())) {\n    ctx.addDifference(Type.TYPE_CHANGED);\n    return;\n  }\n  try (Context.SchemaScope schemaScope=ctx.enterSchema(original)){\n    if (schemaScope != null) {\n      if (!Objects.equals(original.getId(),update.getId())) {\n        ctx.addDifference(Type.ID_CHANGED);\n      }\n      if (!Objects.equals(original.getTitle(),update.getTitle())) {\n        ctx.addDifference(Type.TITLE_CHANGED);\n      }\n      if (!Objects.equals(original.getDescription(),update.getDescription())) {\n        ctx.addDifference(Type.DESCRIPTION_CHANGED);\n      }\n      if (!Objects.equals(original.getDefaultValue(),update.getDefaultValue())) {\n        ctx.addDifference(Type.DEFAULT_CHANGED);\n      }\n      if (original instanceof StringSchema) {\n        StringSchemaDiff.compare(ctx,(StringSchema)original,(StringSchema)update);\n      }\n else       if (original instanceof NumberSchema) {\n        NumberSchemaDiff.compare(ctx,(NumberSchema)original,(NumberSchema)update);\n      }\n else       if (original instanceof EnumSchema) {\n        EnumSchemaDiff.compare(ctx,(EnumSchema)original,(EnumSchema)update);\n      }\n else       if (original instanceof CombinedSchema) {\n        CombinedSchemaDiff.compare(ctx,(CombinedSchema)original,(CombinedSchema)update);\n      }\n else       if (original instanceof ObjectSchema) {\n        ObjectSchemaDiff.compare(ctx,(ObjectSchema)original,(ObjectSchema)update);\n      }\n else       if (original instanceof ArraySchema) {\n        ArraySchemaDiff.compare(ctx,(ArraySchema)original,(ArraySchema)update);\n      }\n else       if (original instanceof ReferenceSchema) {\n        ReferenceSchemaDiff.compare(ctx,(ReferenceSchema)original,(ReferenceSchema)update);\n      }\n    }\n  }\n }\n"}
{"INPUT": "@Override public void stamp(BType type){\n  if (type.getTag() == TypeTags.ANYDATA_TAG) {\n// bug_start\n    type=CPU.resolveMatchingTypeForUnion(this,type);\n// bug_end\n  }\n  this.type=type;\n}\n"}
{"INPUT": "@Override public void clientDisConnected(Connection connect){\n// bug_start\n  Loggers.GRPC.info(\"client disconnected,clear config listen context, connetionId is {}\",connect.getConnectionId());\n// bug_end\n  configChangeListenContext.removeConnectionId(connect.getConnectionId());\n}\n"}
{"INPUT": "@Override public HFileBlock decode(CachedData d){\n  try {\n    ByteBuff buf=new SingleByteBuff(ByteBuffer.wrap(d.getData()));\n// bug_start\n    return (HFileBlock)HFileBlock.blockDeserializer.deserialize(buf,true,MemoryType.EXCLUSIVE);\n// bug_end\n  }\n catch (  IOException e) {\n    LOG.warn(\"Error deserializing data from memcached\",e);\n  }\n  return null;\n}\n"}
{"INPUT": "@Test public void shouldDebugCppProject(){\n  projectExplorer.openItemByPath(PATH_TO_PROGRAM);\n  editor.setInactiveBreakpoint(22);\n  editor.closeAllTabs();\n  commandsPalette.openCommandPalette();\n  commandsPalette.startCommandByDoubleClick(MAKE_AND_DEBUG_COMMAND_NAME);\n  consoles.waitExpectedTextIntoConsole(\"Listening on port 8001\");\n  menu.runCommandByXpath(TestMenuCommandsConstants.Run.RUN_MENU,TestMenuCommandsConstants.Run.DEBUG,getXpathForDebugConfigurationMenuItem());\n  notifications.waitExpectedMessageOnProgressPanelAndClosed(String.format(\"Remote debugger connected\\nConnected to: localhost:%s.\",DEBUG_PORT));\n  editor.waitTabFileWithSavedStatus(\"hello.cc\");\n  debugPanel.waitDebugHighlightedText(\"  return \\\"Hello World, \\\" + name + \\\"!\\\";\");\n  debugPanel.waitTextInVariablesPanel(\"name =\");\n  debugPanel.waitTextInVariablesPanel(\"\\\"man\\\"\");\n// bug_start\n  debugPanel.clickOnButton(DebugPanel.DebuggerButtonsPanel.STEP_OUT);\n// bug_end\n  debugPanel.waitDebugHighlightedText(\"  std::cout << hello.sayHello(\\\"man\\\") << std::endl;\");\n  debugPanel.waitTextInVariablesPanel(\"hello: {<No data fields>}\");\n}\n"}
{"INPUT": "@Override public void notifyNewMessage(HttpMessage msg){\n  HistoryReference hRef=msg.getHistoryRef();\n  if (hRef == null) {\n    try {\n// bug_start\n      hRef=new HistoryReference(Model.getSingleton().getSession(),HistoryReference.TYPE_TEMPORARY,msg);\n// bug_end\n      msg.setHistoryRef(null);\n      hRefs.add(Integer.valueOf(hRef.getHistoryId()));\n    }\n catch (    HttpMalformedHeaderException|SQLException e) {\n      log.error(e.getMessage(),e);\n    }\n  }\n else {\n    hRefs.add(Integer.valueOf(hRef.getHistoryId()));\n  }\n}\n"}
{"INPUT": "protected void bridgeBrokers(BrokerService localBroker,BrokerService remoteBroker) throws Exception {\n  List remoteTransports=remoteBroker.getTransportConnectors();\n  List localTransports=localBroker.getTransportConnectors();\n  URI remoteURI, localURI;\n  if (!remoteTransports.isEmpty() && !localTransports.isEmpty()) {\n    remoteURI=((TransportConnector)remoteTransports.get(0)).getConnectUri();\n    localURI=((TransportConnector)localTransports.get(0)).getConnectUri();\n    if (remoteURI.toString().startsWith(\"tcp:\") && localURI.toString().startsWith(\"tcp:\")) {\n      NetworkBridgeConfiguration config=new NetworkBridgeConfiguration();\n      config.setBrokerName(localBroker.getBrokerName());\n      DemandForwardingBridge bridge=new DemandForwardingBridge(config,TransportFactory.connect(localURI),TransportFactory.connect(remoteURI));\n      bridges.add(bridge);\n      bridge.start();\n    }\n else {\n      throw new Exception(\"Remote broker or local broker is not using tcp connectors\");\n    }\n  }\n else {\n    throw new Exception(\"Remote broker or local broker has no registered connectors.\");\n  }\n// bug_start\n  MAX_SETUP_TIME=2000;\n// bug_end\n}\n"}
{"INPUT": "@Override public void onBindViewHolder(final RecyclerView.ViewHolder holder,int position){\n  final int p=position;\n  Photo photo=dataList.get(position);\n  String path=photo.path;\n  String type=photo.type;\n  long duration=photo.duration;\n  final boolean isGif=path.endsWith(Type.GIF) || type.endsWith(Type.GIF);\n  if (Setting.showGif && isGif) {\n    Setting.imageEngine.loadGifAsBitmap(((PhotoViewHolder)holder).ivPhoto.getContext(),path,((PhotoViewHolder)holder).ivPhoto);\n    ((PhotoViewHolder)holder).tvType.setText(R.string.gif_easy_photos);\n    ((PhotoViewHolder)holder).tvType.setVisibility(View.VISIBLE);\n  }\n// bug_start\n else   if (Setting.showVideo && type.contains(Type.video)) {\n// bug_end\n    Setting.imageEngine.loadPhoto(((PhotoViewHolder)holder).ivPhoto.getContext(),path,((PhotoViewHolder)holder).ivPhoto);\n    ((PhotoViewHolder)holder).tvType.setText(DurationUtils.format(duration));\n    ((PhotoViewHolder)holder).tvType.setVisibility(View.VISIBLE);\n  }\n else {\n    Setting.imageEngine.loadPhoto(((PhotoViewHolder)holder).ivPhoto.getContext(),path,((PhotoViewHolder)holder).ivPhoto);\n    ((PhotoViewHolder)holder).tvType.setVisibility(View.GONE);\n  }\n  ((PhotoViewHolder)holder).ivPhoto.setOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      listener.onPhotoClick(p);\n    }\n  }\n);\n}\n"}
{"INPUT": "private void infoLinks(final HTMLElement span) throws IOException {\n// bug_start\n  span.a(context.getSessionsPageLink(folder),Styles.EL_SESSIONS).text(\"Sessions\");\n// bug_end\n}\n"}
{"INPUT": "public Graph configureGraphInstance(final GraphConfigurationContext context) throws GraphConfigurationException {\n  final String graphFile=context.getProperties().getString(Tokens.REXSTER_GRAPH_LOCATION);\n  if (graphFile == null || graphFile.length() == 0) {\n    throw new GraphConfigurationException(\"Check graph configuration. Missing or empty configuration element: \" + Tokens.REXSTER_GRAPH_LOCATION);\n  }\n  final HierarchicalConfiguration graphSectionConfig=(HierarchicalConfiguration)context.getProperties();\n  SubnodeConfiguration orientDbSpecificConfiguration;\n  try {\n    orientDbSpecificConfiguration=graphSectionConfig.configurationAt(Tokens.REXSTER_GRAPH_PROPERTIES);\n  }\n catch (  IllegalArgumentException iae) {\n    throw new GraphConfigurationException(\"Check graph configuration. Missing or empty configuration element: \" + Tokens.REXSTER_GRAPH_PROPERTIES);\n  }\n  try {\n    final String username=orientDbSpecificConfiguration.getString(\"username\",\"\");\n    final String password=orientDbSpecificConfiguration.getString(\"password\",\"\");\n// bug_start\n    OGlobalConfiguration.CACHE_LEVEL1_ENABLED.setValue(false);\n// bug_end\n    return new OrientGraph(graphFile,username,password);\n  }\n catch (  Exception ex) {\n    throw new GraphConfigurationException(ex);\n  }\n}\n"}
{"INPUT": "public void testReindexFailover() throws Throwable {\n  int scrollTimeout=randomIntBetween(5,15);\n  logger.info(\"--> start 4 nodes, 1 master, 3 data\");\n  final Settings sharedSettings=Settings.builder().put(\"cluster.join.timeout\",\"10s\").build();\n  internalCluster().startMasterOnlyNodes(1,sharedSettings);\n  internalCluster().startDataOnlyNodes(3,sharedSettings);\n  logger.info(\"--> wait for all nodes to join the cluster\");\n  ensureStableCluster(4);\n  ClusterStateResponse clusterState=client().admin().cluster().prepareState().setNodes(true).get();\n  Map<String,String> nodeIdToName=new HashMap<>();\n  for (  ObjectObjectCursor<String,DiscoveryNode> node : clusterState.getState().nodes().getDataNodes()) {\n    nodeIdToName.put(node.key,node.value.getName());\n  }\n  Settings.Builder indexSettings=Settings.builder().put(\"index.number_of_shards\",1).put(\"index.number_of_replicas\",1);\n  client().admin().indices().prepareCreate(\"source\").setSettings(indexSettings).get();\n  ensureGreen(\"source\");\n  List<IndexRequestBuilder> docs=new ArrayList<>();\n  int docCount=between(1500,5000);\n  for (int i=0; i < docCount; i++) {\n    docs.add(client().prepareIndex(\"source\").setId(Integer.toString(i)).setSource(\"foo\",\"a\"));\n  }\n  indexRandom(true,docs);\n  assertHitCount(client().prepareSearch(\"source\").setSize(0).get(),docCount);\n  ensureGreen(\"source\");\n  ReindexRequestBuilder copy=reindex().source(\"source\").destination(\"dest\").refresh(true);\n  ReindexRequest reindexRequest=copy.request();\n  reindexRequest.setScroll(TimeValue.timeValueSeconds(scrollTimeout));\n  reindexRequest.setCheckpointInterval(TimeValue.timeValueMillis(100));\n  StartReindexJobAction.Request request=new StartReindexJobAction.Request(reindexRequest,false);\n  copy.source().setSize(10);\n  copy.setRequestsPerSecond(1000);\n  StartReindexJobAction.Response response=client().execute(StartReindexJobAction.INSTANCE,request).get();\n  TaskId taskId=new TaskId(response.getTaskId());\n  String nodeId=taskId.getNodeId();\n  String nodeName=nodeIdToName.get(nodeId);\n  assertBusy(null);\n  client().admin().indices().prepareRefresh(\"dest\").get();\n  assertThat(client().prepareSearch(\"dest\").get().getHits().getTotalHits().value,greaterThanOrEqualTo(10L));\n  logger.info(\"--> restarting node: \" + nodeName);\n// bug_start\n  ensureGreen(ReindexIndexClient.REINDEX_INDEX);\n// bug_end\n  internalCluster().restartNode(nodeName,new InternalTestCluster.RestartCallback());\n  client().admin().indices().prepareRefresh(\"dest\").get();\n  long hitsAfterRestart=client().prepareSearch(\"dest\").get().getHits().getTotalHits().value;\n  ensureYellow(\"dest\");\n  assertBusy(null,30,TimeUnit.SECONDS);\n  for (int i=0; i < docCount; i++) {\n    int docId=i;\n    assertBusy(null);\n  }\n  assertBusy(null);\n  assertBusy(null,10 + scrollTimeout,TimeUnit.SECONDS);\n}\n"}
{"INPUT": "public VerifyNodeRepositoryAction(Settings settings,TransportService transportService,ClusterService clusterService,RepositoriesService repositoriesService){\n  super(settings);\n  this.transportService=transportService;\n  this.clusterService=clusterService;\n  this.repositoriesService=repositoriesService;\n// bug_start\n  transportService.registerRequestHandler(ACTION_NAME,null,ThreadPool.Names.SAME,new VerifyNodeRepositoryRequestHandler());\n// bug_end\n}\n"}
{"INPUT": "protected void loadStandardKeywords(){\n// bug_start\n  Collections.addAll(reservedWords,SQLConstants.SQL92_KEYWORDS);\n// bug_end\n  Collections.addAll(reservedWords,SQLConstants.SQL_EX_KEYWORDS);\n  Collections.addAll(tableQueryWords,SQLConstants.TABLE_KEYWORDS);\n  Collections.addAll(columnQueryWords,SQLConstants.COLUMN_KEYWORDS);\n  final Collection<String> executeKeywords=getExecuteKeywords();\n  addKeywords(executeKeywords,DBPKeywordType.KEYWORD);\n  Collections.addAll(types,SQLConstants.DEFAULT_TYPES);\n  addKeywords(types,DBPKeywordType.TYPE);\n  addKeywords(reservedWords,DBPKeywordType.KEYWORD);\n}\n"}
{"INPUT": "@Test public void nextSpan_makes_child(){\n  producer=createTracingProducer();\n  consumer=createTracingConsumer();\n  send(new ProducerRecord<>(testName.getMethodName(),TEST_KEY,TEST_VALUE));\n  ConsumerRecords<String,String> records=consumer.poll(10000);\n  assertThat(records).hasSize(1);\n  MutableSpan producerSpan=takeProducerSpan();\n  MutableSpan consumerSpan=takeConsumerSpan();\n  for (  ConsumerRecord<String,String> record : records) {\n    brave.Span processor=kafkaTracing.nextSpan(record);\n    assertThat(consumerSpan.tags()).containsEntry(KAFKA_TOPIC_TAG,record.topic());\n    assertThat(processor.context().traceIdString()).isEqualTo(consumerSpan.traceId());\n    assertThat(processor.context().parentIdString()).isEqualTo(consumerSpan.id());\n    processor.start().name(\"processor\").finish();\n// bug_start\n    MutableSpan processorSpan=spanHandler.takeLocalSpan();\n// bug_end\n    assertThat(processorSpan.id()).isNotEqualTo(consumerSpan.id());\n  }\n}\n"}
{"INPUT": "private void setShowAction(final long signatureKeyId){\n  mSignatureAction.setText(R.string.decrypt_result_action_show);\n// bug_start\n  mSignatureAction.setCompoundDrawablesWithIntrinsicBounds(0,0,R.drawable.ic_action_accounts,0);\n// bug_end\n  mSignatureLayout.setOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      showKey(signatureKeyId);\n    }\n  }\n);\n}\n"}
{"INPUT": "public void testBackwardCompatibility() throws Exception {\n  Path baseDir=createTempDir();\n  Node node=new Node(Settings.builder().put(\"path.home\",baseDir.toString()).build(),false);\n  try {\n    try (BufferedReader reader=new BufferedReader(new InputStreamReader(RoutingBackwardCompatibilityTests.class.getResourceAsStream(\"/org/elasticsearch/cluster/routing/shard_routes.txt\"),\"UTF-8\"))){\n      for (String line=reader.readLine(); line != null; line=reader.readLine()) {\n        if (line.startsWith(\"#\")) {\n          continue;\n        }\n        String[] parts=line.split(\"\\t\");\n        assertEquals(Arrays.toString(parts),7,parts.length);\n        final String index=parts[0];\n        final int numberOfShards=Integer.parseInt(parts[1]);\n        final String type=parts[2];\n        final String id=parts[3];\n        final String routing=\"null\".equals(parts[4]) ? null : parts[4];\n        final int pre20ExpectedShardId=Integer.parseInt(parts[5]);\n        final int currentExpectedShard=Integer.parseInt(parts[6]);\n        OperationRouting operationRouting=node.injector().getInstance(OperationRouting.class);\n        for (        Version version : VersionUtils.allVersions()) {\n          final Settings settings=settings(version).build();\n          IndexMetaData indexMetaData=IndexMetaData.builder(index).settings(settings).numberOfShards(numberOfShards).numberOfReplicas(randomInt(3)).build();\n          MetaData.Builder metaData=MetaData.builder().put(indexMetaData,false);\n          RoutingTable routingTable=RoutingTable.builder().addAsNew(indexMetaData).build();\n          ClusterState clusterState=ClusterState.builder(ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n          final int shardId=operationRouting.indexShards(clusterState,index,type,id,routing).shardId().getId();\n// bug_start\n          if (version.before(Version.V_2_0_0)) {\n// bug_end\n            assertEquals(pre20ExpectedShardId,shardId);\n          }\n else {\n            assertEquals(currentExpectedShard,shardId);\n          }\n        }\n      }\n    }\n   }\n  finally {\n    node.close();\n  }\n}\n"}
{"INPUT": "public void setupGame(){\n  Configuration conf=getConfiguration();\n  game.setViZDoomPath(DOOM_ROOT + \"/vizdoom\");\n  game.setDoomGamePath(DOOM_ROOT + \"/scenarios/freedoom2.wad\");\n  game.setDoomScenarioPath(DOOM_ROOT + \"/scenarios/\" + conf.getScenario()+ \".wad\");\n  game.setDoomMap(\"map01\");\n  game.setScreenFormat(ScreenFormat.RGB24);\n  game.setScreenResolution(ScreenResolution.RES_800X600);\n  game.setRenderHud(false);\n  game.setRenderCrosshair(false);\n  game.setRenderWeapon(true);\n  game.setRenderDecals(false);\n  game.setRenderParticles(false);\n  GameVariable[] gameVar=new GameVariable[]{GameVariable.KILLCOUNT,GameVariable.ITEMCOUNT,GameVariable.SECRETCOUNT,GameVariable.FRAGCOUNT,GameVariable.HEALTH,GameVariable.ARMOR,GameVariable.DEAD,GameVariable.ON_GROUND,GameVariable.ATTACK_READY,GameVariable.ALTATTACK_READY,GameVariable.SELECTED_WEAPON,GameVariable.SELECTED_WEAPON_AMMO,GameVariable.AMMO1,GameVariable.AMMO2,GameVariable.AMMO3,GameVariable.AMMO4,GameVariable.AMMO5,GameVariable.AMMO6,GameVariable.AMMO7,GameVariable.AMMO8,GameVariable.AMMO9,GameVariable.AMMO0};\n  for (int i=0; i < gameVar.length; i++) {\n    game.addAvailableGameVariable(gameVar[i]);\n  }\n  game.setEpisodeTimeout(conf.getTimeout());\n  game.setEpisodeStartTime(conf.getStartTime());\n  game.setWindowVisible(render);\n  game.setSoundEnabled(false);\n// bug_start\n  game.setMode(Mode.SPECTATOR);\n// bug_end\n  game.setLivingReward(conf.getLivingReward());\n  List<Button> buttons=conf.getButtons();\n  int size=buttons.size();\n  actions.add(new int[size + 1]);\n  for (int i=0; i < size; i++) {\n    game.addAvailableButton(buttons.get(i));\n    int[] action=new int[size + 1];\n    action[i]=1;\n    actions.add(action);\n  }\n  game.init();\n}\n"}
{"INPUT": "public static Icon getIcon(File file){\n  Icon fileIcon=null;\n  try {\n    sun.awt.shell.ShellFolder shellFolder=sun.awt.shell.ShellFolder.getShellFolder(file);\n    fileIcon=new ImageIcon(shellFolder.getIcon(true),shellFolder.getFolderType());\n  }\n catch (  Exception e) {\n    logger.debug(\"Failed to obtain file icon from ShellFolder.\",e);\n    try {\n      fileIcon=new JFileChooser().getIcon(file);\n    }\n catch (    Exception e1) {\n// bug_start\n      logger.debug(\"Failed to obtain file icon from JFileChooser.\",e);\n// bug_end\n    }\n  }\n  return fileIcon;\n}\n"}
{"INPUT": "@Override public void onBindViewHolder(TestViewHolder holder,int position){\n  assertNotNull(holder.mOwnerRecyclerView);\n  assertEquals(position,holder.getAdapterPosition());\n  final Item item=mItems.get(position);\n// bug_start\n  ((TextView)(holder.itemView)).setText(item.mText + \"(\" + item.mAdapterIndex+ \")\");\n// bug_end\n  holder.mBoundItem=item;\n}\n"}
{"INPUT": "private void queryBasedPercolating(Engine.Searcher percolatorSearcher,PercolateContext context,QueryCollector percolateCollector) throws IOException {\n  Filter percolatorTypeFilter=context.indexService().mapperService().documentMapper(TYPE_NAME).typeFilter();\n  percolatorTypeFilter=context.indexService().cache().filter().cache(percolatorTypeFilter);\n  FilteredQuery query=new FilteredQuery(context.percolateQuery(),percolatorTypeFilter);\n  percolatorSearcher.searcher().search(query,percolateCollector);\n// bug_start\n  for (  Collector queryCollector : percolateCollector.facetCollectors) {\n// bug_end\n    if (queryCollector instanceof XCollector) {\n      ((XCollector)queryCollector).postCollection();\n    }\n  }\n  if (context.facets() != null) {\n    facetPhase.execute(context);\n  }\n  if (context.aggregations() != null) {\n    aggregationPhase.execute(context);\n  }\n}\n"}
{"INPUT": "private void deployPerJob(Configuration configuration,JobGraph jobGraph,boolean withDist) throws Exception {\n  try (final YarnClusterDescriptor yarnClusterDescriptor=withDist ? createYarnClusterDescriptor(configuration) : createYarnClusterDescriptorWithoutLibDir(configuration)){\n    final int masterMemory=yarnClusterDescriptor.getFlinkConfiguration().get(JobManagerOptions.TOTAL_PROCESS_MEMORY).getMebiBytes();\n    final ClusterSpecification clusterSpecification=new ClusterSpecification.ClusterSpecificationBuilder().setMasterMemoryMB(masterMemory).setTaskManagerMemoryMB(1024).setSlotsPerTaskManager(1).createClusterSpecification();\n// bug_start\n    File testingJar=YarnTestBase.findFile(\"..\",new TestUtils.TestJarFinder(\"flink-yarn-tests\"));\n// bug_end\n    jobGraph.addJar(new org.apache.flink.core.fs.Path(testingJar.toURI()));\n    try (ClusterClient<ApplicationId> clusterClient=yarnClusterDescriptor.deployJobCluster(clusterSpecification,jobGraph,false).getClusterClient()){\n      ApplicationId applicationId=clusterClient.getClusterId();\n      final CompletableFuture<JobResult> jobResultCompletableFuture=clusterClient.requestJobResult(jobGraph.getJobID());\n      final JobResult jobResult=jobResultCompletableFuture.get();\n      assertThat(jobResult,is(notNullValue()));\n      assertThat(jobResult.getSerializedThrowable().isPresent(),is(false));\n      checkStagingDirectory(configuration,applicationId);\n      waitApplicationFinishedElseKillIt(applicationId,yarnAppTerminateTimeout,yarnClusterDescriptor,sleepIntervalInMS);\n    }\n   }\n }\n"}
{"INPUT": "public static String createFileNameFromPattern(BibDatabase database,BibEntry entry,JournalAbbreviationLoader repositoryLoader,JabRefPreferences prefs){\n  String targetName=entry.getCiteKeyOptional().orElse(\"default\");\n// bug_start\n  StringReader sr=new StringReader(prefs.get(JabRefPreferences.PREF_IMPORT_FILENAMEPATTERN));\n// bug_end\n  Layout layout=null;\n  try {\n    layout=new LayoutHelper(sr,LayoutFormatterPreferences.fromPreferences(prefs,repositoryLoader)).getLayoutFromText();\n  }\n catch (  IOException e) {\n    LOGGER.info(\"Wrong format \" + e.getMessage(),e);\n  }\n  if (layout != null) {\n    targetName=layout.doLayout(entry,database);\n  }\n  targetName=FileNameCleaner.cleanFileName(targetName);\n  return targetName;\n}\n"}
{"INPUT": "public void pulse(@NonNull DozeHost.PulseCallback callback){\n  if (callback == null) {\n    throw new IllegalArgumentException(\"callback must not be null\");\n  }\n  if (!mDozing || mPulseCallback != null) {\n// bug_start\n    mPulseCallback.onPulseFinished();\n// bug_end\n    return;\n  }\n  mPulseCallback=callback;\n  mScrimInFront.post(mPulseIn);\n}\n"}
{"INPUT": "void getAllRunningVisibleActivitiesLocked(ArrayList<ActivityRecord> outActivities){\n  if (mStack != null) {\n    for (int activityNdx=mActivities.size() - 1; activityNdx >= 0; --activityNdx) {\n      ActivityRecord r=mActivities.get(activityNdx);\n// bug_start\n      if (!r.finishing && r.okToShowLocked() && r.visible) {\n// bug_end\n        outActivities.add(r);\n      }\n    }\n  }\n}\n"}
{"INPUT": "private void putToAllPartitionsAndWaitForCompletion(List<Map.Entry<Data,Data>>[] entriesPerPartition,ExpiryPolicy expiryPolicy,long start) throws ExecutionException, InterruptedException {\n  Data expiryPolicyData=toData(expiryPolicy);\n  List<FutureEntriesTuple> futureEntriesTuples=new ArrayList<FutureEntriesTuple>(entriesPerPartition.length);\n  for (int partitionId=0; partitionId < entriesPerPartition.length; partitionId++) {\n    List<Map.Entry<Data,Data>> entries=entriesPerPartition[partitionId];\n    if (entries != null) {\n      int completionId=nextCompletionId();\n// bug_start\n      ClientMessage request=CachePutAllCodec.encodeRequest(nameWithPrefix,entries,expiryPolicyData,partitionId);\n// bug_end\n      Future f=invoke(request,partitionId,completionId);\n      futureEntriesTuples.add(new FutureEntriesTuple(f,entries));\n      if (nearCache != null) {\n        if (cacheOnUpdate) {\n          for (          Map.Entry<Data,Data> entry : entries) {\n            storeInNearCache(entry.getKey(),entry.getValue(),null);\n          }\n        }\n else {\n          for (          Map.Entry<Data,Data> entry : entries) {\n            invalidateNearCache(entry.getKey());\n          }\n        }\n      }\n    }\n  }\n  waitResponseFromAllPartitionsForPutAll(futureEntriesTuples,start);\n}\n"}
{"INPUT": "public SuppressedInternal(final String name,final Duration suppressionTime,final BufferConfig bufferConfig,final TimeDefinition<K> timeDefinition,final boolean safeToDropTombstones){\n  this.name=name;\n  this.timeToWaitForMoreEvents=suppressionTime == null ? DEFAULT_SUPPRESSION_TIME : suppressionTime;\n// bug_start\n  this.timeDefinition=timeDefinition == null ? TimeDefinitions.RecordTimeDefintion.instance() : timeDefinition;\n// bug_end\n  this.bufferConfig=bufferConfig == null ? DEFAULT_BUFFER_CONFIG : (BufferConfigInternal)bufferConfig;\n  this.safeToDropTombstones=safeToDropTombstones;\n}\n"}
{"INPUT": "@Override public INDArray backprop(INDArray output,int miniBatchSize,LayerWorkspaceMgr workspaceMgr){\n  if (output == null)   return null;\n  if (output.rank() != 2)   throw new IllegalArgumentException(\"Invalid input: expect NDArray with rank 2 (i.e., epsilons from feed forward layer)\");\n// bug_start\n  if (output.ordering() != 'f' || !Shape.hasDefaultStridesForShape(output))   output=workspaceMgr.dup(ArrayType.ACTIVATIONS,output,'f');\n// bug_end\n  val shape=output.shape();\n  INDArray reshaped=output.reshape('f',miniBatchSize,shape[0] / miniBatchSize,shape[1]);\n  return workspaceMgr.leverageTo(ArrayType.ACTIVATION_GRAD,reshaped.permute(0,2,1));\n}\n"}
{"INPUT": "public Map<String,Object> deleteProcessInstanceById(User loginUser,String projectName,Integer processInstanceId,ITaskQueue tasksQueue){\n  Map<String,Object> result=new HashMap<>(5);\n  Project project=projectMapper.queryByName(projectName);\n  Map<String,Object> checkResult=projectService.checkProjectAndAuth(loginUser,project,projectName);\n  Status resultEnum=(Status)checkResult.get(Constants.STATUS);\n  if (resultEnum != Status.SUCCESS) {\n    return checkResult;\n  }\n  ProcessInstance processInstance=processDao.findProcessInstanceDetailById(processInstanceId);\n  List<TaskInstance> taskInstanceList=processDao.findValidTaskListByProcessId(processInstanceId);\n  int processInstancePriority=processInstance.getProcessInstancePriority().ordinal();\n  if (processInstance == null) {\n    putMsg(result,Status.PROCESS_INSTANCE_NOT_EXIST,processInstanceId);\n    return result;\n  }\n  if (CollectionUtils.isNotEmpty(taskInstanceList)) {\n    for (    TaskInstance taskInstance : taskInstanceList) {\n      int taskInstancePriority=taskInstance.getTaskInstancePriority().ordinal();\n      StringBuilder nodeValueSb=new StringBuilder(100);\n      nodeValueSb.append(processInstancePriority).append(UNDERLINE).append(processInstanceId).append(UNDERLINE).append(taskInstancePriority).append(UNDERLINE).append(taskInstance.getId()).append(UNDERLINE);\n      int taskWorkerGroupId=processDao.getTaskWorkerGroupId(taskInstance);\n      WorkerGroup workerGroup=workerGroupMapper.selectById(taskWorkerGroupId);\n      if (workerGroup == null) {\n        nodeValueSb.append(DEFAULT_WORKER_ID);\n      }\n else {\n        String ips=workerGroup.getIpList();\n        StringBuilder ipSb=new StringBuilder(100);\n        String[] ipArray=ips.split(COMMA);\n        for (        String ip : ipArray) {\n          long ipLong=IpUtils.ipToLong(ip);\n          ipSb.append(ipLong).append(COMMA);\n        }\n        if (ipSb.length() > 0) {\n          ipSb.deleteCharAt(ipSb.length() - 1);\n        }\n        nodeValueSb.append(ipSb);\n      }\n      try {\n        logger.info(\"delete task queue node : {}\",nodeValueSb.toString());\n// bug_start\n        tasksQueue.removeNode(org.apache.dolphinscheduler.common.Constants.SCHEDULER_TASKS_QUEUE,nodeValueSb.toString());\n// bug_end\n      }\n catch (      Exception e) {\n        logger.error(\"delete task queue node : {}\",nodeValueSb.toString());\n      }\n    }\n  }\n  int delete=processDao.deleteWorkProcessInstanceById(processInstanceId);\n  processDao.deleteAllSubWorkProcessByParentId(processInstanceId);\n  processDao.deleteWorkProcessMapByParentId(processInstanceId);\n  if (delete > 0) {\n    putMsg(result,Status.SUCCESS);\n  }\n else {\n    putMsg(result,Status.DELETE_PROCESS_INSTANCE_BY_ID_ERROR);\n  }\n  return result;\n}\n"}
{"INPUT": "@Override protected void decryptStart(String passphrase){\n  Log.d(Constants.TAG,\"decryptStart\");\n  Intent intent=new Intent(getActivity(),KeychainIntentService.class);\n  Bundle data=new Bundle();\n  intent.setAction(KeychainIntentService.ACTION_DECRYPT_VERIFY);\n// bug_start\n  data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_URI);\n// bug_end\n  Log.d(Constants.TAG,\"mInputFilename=\" + mInputFilename + \", mOutputFilename=\"+ mOutputFilename);\n  data.putString(KeychainIntentService.ENCRYPT_INPUT_FILE,mInputFilename);\n  data.putString(KeychainIntentService.ENCRYPT_OUTPUT_FILE,mOutputFilename);\n  data.putString(KeychainIntentService.DECRYPT_PASSPHRASE,passphrase);\n  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);\n  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(getActivity(),getString(R.string.progress_decrypting),ProgressDialog.STYLE_HORIZONTAL){\n    public void handleMessage(    Message message){\n      super.handleMessage(message);\n      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {\n        Bundle returnData=message.getData();\n        PgpDecryptVerifyResult decryptVerifyResult=returnData.getParcelable(KeychainIntentService.RESULT_DECRYPT_VERIFY_RESULT);\n        if (PgpDecryptVerifyResult.KEY_PASSHRASE_NEEDED == decryptVerifyResult.getStatus()) {\n          showPassphraseDialog(decryptVerifyResult.getKeyIdPassphraseNeeded());\n        }\n else         if (PgpDecryptVerifyResult.SYMMETRIC_PASSHRASE_NEEDED == decryptVerifyResult.getStatus()) {\n          showPassphraseDialog(Constants.key.symmetric);\n        }\n else {\n          onResult(decryptVerifyResult);\n          if (mDeleteAfter.isChecked()) {\n            DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(mInputFilename);\n            deleteFileDialog.show(getActivity().getSupportFragmentManager(),\"deleteDialog\");\n          }\n        }\n      }\n    }\n  }\n;\n  Messenger messenger=new Messenger(saveHandler);\n  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);\n  saveHandler.showProgressDialog(getActivity());\n  getActivity().startService(intent);\n}\n"}
{"INPUT": "@Test public void testDifferentStateModelDefs(){\n  AmbryStateModelFactory factory=new AmbryStateModelFactory(stateModelDef,new PartitionStateChangeListener(){\n    @Override public void onPartitionStateChangeToLeaderFromStandby(    String partitionName){\n    }\n    @Override public void onPartitionStateChangeToStandbyFromLeader(    String partitionName){\n    }\n  }\n);\n  StateModel stateModel;\nswitch (stateModelDef) {\n// bug_start\ncase ClusterMapConfig.DEFAULT_STATE_MODEL_DEF:\n// bug_end\n    stateModel=factory.createNewStateModel(\"0\",\"1\");\n  assertTrue(\"Unexpected state model def\",stateModel instanceof DefaultLeaderStandbyStateModel);\nbreak;\ncase ClusterMapConfig.AMBRY_STATE_MODEL_DEF:\nstateModel=factory.createNewStateModel(\"0\",\"1\");\nassertTrue(\"Unexpected state model def\",stateModel instanceof AmbryPartitionStateModel);\nbreak;\ndefault :\ntry {\nfactory.createNewStateModel(\"0\",\"1\");\nfail(\"should fail due to invalid state model def\");\n}\n catch (IllegalArgumentException e) {\n}\n}\n}\n"}
{"INPUT": "@Override public void preProcessLine(INDArray gradient){\n  INDArray gLast=(INDArray)searchState.get(GRADIENT_KEY);\n  INDArray searchDirLast=(INDArray)searchState.get(SEARCH_DIR);\n  double dgg=Nd4j.getBlasWrapper().dot(gradient.sub(gLast),gradient);\n  double gg=Nd4j.getBlasWrapper().dot(gLast,gLast);\n// bug_start\n  double gamma=Double.max(dgg / gg,0.0);\n// bug_end\n  INDArray searchDir=searchDirLast.muli(gamma).subi(gradient);\n  searchState.put(GRADIENT_KEY,gradient);\n  searchState.put(SEARCH_DIR,searchDir);\n}\n"}
{"INPUT": "public void dimUpdate(RowMetaInterface rowMeta,Object[] row,Long dimkey) throws KettleDatabaseException {\n  if (data.prepStatementDimensionUpdate == null) {\n    data.dimensionUpdateRowMeta=new RowMeta();\n    String sql=\"UPDATE \" + data.schemaTable + Const.CR+ \"SET \";\n    for (int i=0; i < meta.getFieldLookup().length; i++) {\n      if (i > 0)       sql+=\", \";\n else       sql+=\"  \";\n      sql+=meta.getDatabaseMeta().quoteField(meta.getFieldLookup()[i]) + \" = ?\" + Const.CR;\n// bug_start\n      data.dimensionUpdateRowMeta.addValueMeta(rowMeta.getValueMeta(data.keynrs[i]));\n// bug_end\n    }\n    sql+=\"WHERE  \" + meta.getDatabaseMeta().quoteField(meta.getKeyField()) + \" = ?\";\n    data.dimensionUpdateRowMeta.addValueMeta(new ValueMeta(meta.getKeyField(),ValueMetaInterface.TYPE_INTEGER));\n    try {\n      if (log.isDebug())       log.logDebug(toString(),\"Preparing statement: [\" + sql + \"]\");\n      data.prepStatementDimensionUpdate=data.db.getConnection().prepareStatement(meta.getDatabaseMeta().stripCR(sql));\n    }\n catch (    SQLException ex) {\n      throw new KettleDatabaseException(\"Couldn't prepare statement :\" + Const.CR + sql,ex);\n    }\n  }\n  Object[] dimensionUpdateRow=new Object[data.dimensionUpdateRowMeta.size()];\n  for (int i=0; i < data.fieldnrs.length; i++) {\n    dimensionUpdateRow[i]=row[data.fieldnrs[i]];\n  }\n  dimensionUpdateRow[data.fieldnrs.length]=dimkey;\n  data.db.setValues(data.dimensionUpdateRowMeta,dimensionUpdateRow,data.prepStatementDimensionUpdate);\n  data.db.insertRow(data.prepStatementDimensionUpdate);\n}\n"}
{"INPUT": "@GET @Path(\"/exists\") @Produces(\"application/json\") public Response pathExists(@QueryParam(\"path\") String path){\n  try {\n    return Response.status(Response.Status.OK).entity(workspace.exists(new String(Base64.getDecoder().decode(path),Charset.defaultCharset()))).header(\"Access-Control-Allow-Origin\",'*').type(MediaType.APPLICATION_JSON).build();\n  }\n catch (  Throwable throwable) {\n// bug_start\n    logger.error(\"/exists service error\",throwable.getMessage(),path);\n// bug_end\n    return getErrorResponse(throwable);\n  }\n}\n"}
{"INPUT": "public final <R>Mono<T> doOnDiscard(final Class<R> type,final Consumer<? super R> discardHook){\n// bug_start\n  return subscriberContext(Hooks.discardLocalAdapter(type,discardHook));\n// bug_end\n}\n"}
{"INPUT": "@Override public void bind(@NonNull MasterSecret masterSecret,@NonNull ThreadRecord thread,@NonNull Locale locale,@NonNull Set<Long> selectedThreads,boolean batchMode){\n// bug_start\n  this.description.setText(getContext().getString(R.string.ConversationListItemAction_archived_conversations_s,thread.getCount()));\n// bug_end\n}\n"}
{"INPUT": "public void connect(DBRProgressMonitor monitor,boolean initialize,boolean reflect) throws DBException {\n  if (this.isConnected()) {\n    return;\n  }\n  DBPConnectionInfo savedConnectionInfo=null;\n  tunnelConnectionInfo=null;\n  try {\n    this.tunnel=null;\n    DBWHandlerConfiguration handlerConfiguration=connectionInfo.getHandler(DBWHandlerType.TUNNEL);\n    if (handlerConfiguration != null) {\n      tunnel=handlerConfiguration.createHandler(DBWTunnel.class);\n      try {\n        tunnelConnectionInfo=tunnel.initializeTunnel(monitor,handlerConfiguration,connectionInfo);\n      }\n catch (      Exception e) {\n        throw new DBCException(\"Can't initialize tunnel\",e);\n      }\n    }\n    if (tunnelConnectionInfo != null) {\n      savedConnectionInfo=connectionInfo;\n      connectionInfo=tunnelConnectionInfo;\n    }\n    dataSource=getDriver().getDataSourceProvider().openDataSource(monitor,this);\n    if (initialize) {\n      dataSource.initialize(monitor);\n// bug_start\n      DBCSession session=dataSource.openSession(monitor,DBCExecutionPurpose.META,\"Set session defaults ...\");\n// bug_end\n      try {\n        DBCTransactionManager txnManager=session.getTransactionManager();\n        boolean autoCommit=txnManager.isAutoCommit();\n        AbstractPreferenceStore store=getPreferenceStore();\n        boolean newAutoCommit;\n        if (!store.contains(PrefConstants.DEFAULT_AUTO_COMMIT)) {\n          newAutoCommit=connectionInfo.getConnectionType().isAutocommit();\n        }\n else {\n          newAutoCommit=store.getBoolean(PrefConstants.DEFAULT_AUTO_COMMIT);\n        }\n        if (autoCommit != newAutoCommit) {\n          txnManager.setAutoCommit(newAutoCommit);\n        }\n        if (store.contains(PrefConstants.DEFAULT_ISOLATION)) {\n          int isolationCode=store.getInt(PrefConstants.DEFAULT_ISOLATION);\n          Collection<DBPTransactionIsolation> supportedLevels=dataSource.getInfo().getSupportedTransactionsIsolation();\n          if (!CommonUtils.isEmpty(supportedLevels)) {\n            for (            DBPTransactionIsolation level : supportedLevels) {\n              if (level.getCode() == isolationCode) {\n                txnManager.setTransactionIsolation(level);\n                break;\n              }\n            }\n          }\n        }\n      }\n catch (      DBCException e) {\n        log.error(\"Can't set session transactions state\",e);\n      }\n finally {\n        session.close();\n      }\n    }\n    connectFailed=false;\n    connectTime=new Date();\n    if (reflect) {\n      getRegistry().fireDataSourceEvent(DBPEvent.Action.OBJECT_UPDATE,DataSourceDescriptor.this,true);\n    }\n    firePropertyChange();\n  }\n catch (  Exception e) {\n    connectFailed=true;\n    getRegistry().fireDataSourceEvent(DBPEvent.Action.OBJECT_UPDATE,DataSourceDescriptor.this,false);\n    if (e instanceof DBException) {\n      throw (DBException)e;\n    }\n else {\n      throw new DBException(\"Internal error connecting to \" + getName(),e);\n    }\n  }\n finally {\n    if (savedConnectionInfo != null) {\n      connectionInfo=savedConnectionInfo;\n    }\n  }\n}\n"}
{"INPUT": "@Before public void init() throws IOException {\n  assertThat(\"we don't need this branch if we aren't compatible with 6.0\",Version.CURRENT.minimumIndexCompatibilityVersion().onOrBefore(Version.V_6_0_0),equalTo(true));\n// bug_start\n  if (isRunningAgainstOldCluster() && getOldClusterVersion().before(Version.V_7_0_0_alpha1)) {\n// bug_end\n    XContentBuilder template=jsonBuilder();\n    template.startObject();\n{\n      template.field(\"index_patterns\",\"*\");\n      template.field(\"order\",\"0\");\n      template.startObject(\"settings\");\n      template.field(\"number_of_shards\",5);\n      template.endObject();\n    }\n    template.endObject();\n    Request createTemplate=new Request(\"PUT\",\"/_template/template\");\n    createTemplate.setJsonEntity(Strings.toString(template));\n    client().performRequest(createTemplate);\n  }\n}\n"}
{"INPUT": "private Message<AtomicBroadcastMessage> message(int id){\n// bug_start\n  return to(failed,uri(id),\"some payload\").setHeader(Message.CONVERSATION_ID,\"some id\");\n// bug_end\n}\n"}
{"INPUT": "private void initAndAddViewsToMainView(){\n  RelativeLayout mainContent=new RelativeLayout(context);\n  centreBackgroundView=new RelativeLayout(context);\n  leftContent=new LinearLayout(context);\n  rightContent=new LinearLayout(context);\n  centreContent=buildBezierView();\n  centreButton=new CentreButton(context);\n  centreButton.setSize(FloatingActionButton.SIZE_NORMAL);\n  centreButton.setUseCompatPadding(false);\n  centreButton.setRippleColor(centreButtonRippleColor);\n  centreButton.setBackgroundTintList(ColorStateList.valueOf(centreButtonColor));\n  centreButton.setImageResource(centreButtonIcon);\n// bug_start\n  if (isCentreButtonIconColorFilterEnabled || isCentreButtonSelectable)   centreButton.getDrawable().setColorFilter(inActiveSpaceItemColor,PorterDuff.Mode.SRC_IN);\n// bug_end\n  centreButton.setOnClickListener(new OnClickListener(){\n    @Override public void onClick(    View view){\n      if (spaceOnClickListener != null)       spaceOnClickListener.onCentreButtonClick();\n      if (isCentreButtonSelectable)       updateSpaceItems(-1);\n    }\n  }\n);\n  centreButton.setOnLongClickListener(new OnLongClickListener(){\n    @Override public boolean onLongClick(    View v){\n      if (spaceOnLongClickListener != null)       spaceOnLongClickListener.onCentreButtonLongClick();\n      return true;\n    }\n  }\n);\n  LayoutParams fabParams=new LayoutParams(centreButtonSize,centreButtonSize);\n  fabParams.addRule(RelativeLayout.CENTER_IN_PARENT);\n  LayoutParams mainContentParams=new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,mainContentHeight);\n  mainContentParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\n  LayoutParams centreContentParams=new LayoutParams(centreContentWight,spaceNavigationHeight);\n  centreContentParams.addRule(RelativeLayout.CENTER_HORIZONTAL);\n  centreContentParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\n  LayoutParams centreBackgroundViewParams=new LayoutParams(centreContentWight,mainContentHeight);\n  centreBackgroundViewParams.addRule(RelativeLayout.CENTER_HORIZONTAL);\n  centreBackgroundViewParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\n  LayoutParams leftContentParams=new LayoutParams(contentWidth,ViewGroup.LayoutParams.MATCH_PARENT);\n  leftContentParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);\n  leftContentParams.addRule(LinearLayout.HORIZONTAL);\n  LayoutParams rightContentParams=new LayoutParams(contentWidth,ViewGroup.LayoutParams.MATCH_PARENT);\n  rightContentParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);\n  rightContentParams.addRule(LinearLayout.HORIZONTAL);\n  setBackgroundColors();\n  centreContent.addView(centreButton,fabParams);\n  mainContent.addView(leftContent,leftContentParams);\n  mainContent.addView(rightContent,rightContentParams);\n  addView(centreBackgroundView,centreBackgroundViewParams);\n  addView(centreContent,centreContentParams);\n  addView(mainContent,mainContentParams);\n  restoreChangedIconsAndTexts();\n  addSpaceItems(leftContent,rightContent);\n}\n"}
{"INPUT": "@Test public void shouldDecorateExternalPropertiesInParallelProcessingCsvInput() throws Exception {\n  int processors=5;\n  Collector collector=mock(Collector.class);\n  int count=1000;\n// bug_start\n  Configuration config=new Configuration.Overriden(Configuration.COMMAS){\n// bug_end\n    @Override public int bufferSize(){\n      return 300;\n    }\n  }\n;\n  IdType idType=IdType.STRING;\n  Decorator<InputNode> decorator=new ExternalPropertiesDecorator(data(NO_NODE_DECORATOR,null),defaultFormatNodeFileHeader(),config,idType,UpdateBehaviour.ADD,collector);\n  Input input=new CsvInput(nodeData(data(decorator,null)),defaultFormatNodeFileHeader(),null,null,idType,config,collector,processors);\n  try (InputIterator<InputNode> nodes=input.nodes().iterator()){\n    int i=0;\n    for (; i < count; i++) {\n      assertTrue(nodes.hasNext());\n      InputNode node=nodes.next();\n      assertHasProperty(node,\"extra\",node.id() + \"-decorated\");\n      if (i == 0) {\n        nodes.processors(processors - nodes.processors(0));\n      }\n    }\n    assertEquals(count,i);\n    assertFalse(nodes.hasNext());\n  }\n }\n"}
{"INPUT": "private void init(AttributeSet attrs){\n  if (attributes == null)   attributes=new Attributes(this);\n  if (attrs != null) {\n    TypedArray a=getContext().obtainStyledAttributes(attrs,com.cengalabs.flatui.R.styleable.FlatSeekBar);\n    int customTheme=a.getResourceId(com.cengalabs.flatui.R.styleable.FlatSeekBar_theme,Attributes.DEFAULT_THEME);\n    attributes.setThemeSilent(customTheme,getResources());\n// bug_start\n    attributes.setSize(a.getDimensionPixelSize(com.cengalabs.flatui.R.styleable.FlatSeekBar_size,Attributes.DEFAULT_SIZE));\n// bug_end\n    a.recycle();\n  }\n  PaintDrawable thumb=new PaintDrawable(attributes.getColor(0));\n  thumb.setCornerRadius(attributes.getSize() * 9 / 8);\n  thumb.setIntrinsicWidth(attributes.getSize() * 9 / 4);\n  thumb.setIntrinsicHeight(attributes.getSize() * 9 / 4);\n  setThumb(thumb);\n  PaintDrawable progress=new PaintDrawable(attributes.getColor(1));\n  progress.setCornerRadius(attributes.getSize());\n  progress.setIntrinsicHeight(attributes.getSize());\n  progress.setIntrinsicWidth(attributes.getSize());\n  progress.setDither(true);\n  ClipDrawable progressClip=new ClipDrawable(progress,Gravity.LEFT,ClipDrawable.HORIZONTAL);\n  PaintDrawable secondary=new PaintDrawable(attributes.getColor(2));\n  secondary.setCornerRadius(attributes.getSize());\n  secondary.setIntrinsicHeight(attributes.getSize());\n  ClipDrawable secondaryProgressClip=new ClipDrawable(secondary,Gravity.LEFT,ClipDrawable.HORIZONTAL);\n  PaintDrawable background=new PaintDrawable(attributes.getColor(3));\n  background.setCornerRadius(attributes.getSize());\n  background.setIntrinsicHeight(attributes.getSize());\n  LayerDrawable ld=(LayerDrawable)getProgressDrawable();\n  ld.setDrawableByLayerId(R.id.background,background);\n  ld.setDrawableByLayerId(R.id.progress,progressClip);\n  ld.setDrawableByLayerId(R.id.secondaryProgress,secondaryProgressClip);\n}\n"}
{"INPUT": "public static void rebootWipeUserData(Context context,boolean shutdown,String reason) throws IOException {\n  UserManager um=(UserManager)context.getSystemService(Context.USER_SERVICE);\n  if (um.hasUserRestriction(UserManager.DISALLOW_FACTORY_RESET)) {\n    throw new SecurityException(\"Wiping data is not allowed for this user.\");\n  }\n  final ConditionVariable condition=new ConditionVariable();\n  Intent intent=new Intent(\"android.intent.action.MASTER_CLEAR_NOTIFICATION\");\n  intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n// bug_start\n  context.sendOrderedBroadcastAsUser(intent,UserHandle.OWNER,android.Manifest.permission.MASTER_CLEAR,new BroadcastReceiver(){\n// bug_end\n    @Override public void onReceive(    Context context,    Intent intent){\n      condition.open();\n    }\n  }\n,null,0,null,null);\n  condition.block();\n  String shutdownArg=null;\n  if (shutdown) {\n    shutdownArg=\"--shutdown_after\";\n  }\n  String reasonArg=null;\n  if (!TextUtils.isEmpty(reason)) {\n    reasonArg=\"--reason=\" + sanitizeArg(reason);\n  }\n  final String localeArg=\"--locale=\" + Locale.getDefault().toString();\n  bootCommand(context,shutdownArg,\"--wipe_data\",reasonArg,localeArg);\n}\n"}
{"INPUT": "@Override public BlueOrganization get(String name){\n  BlueOrganization o=OrganizationResolver.getInstance().get(name);\n// bug_start\n  if (o == null)   throw new ServiceException.UnprocessableEntityException(String.format(\"Organization %s not found\",name));\n// bug_end\n  return o;\n}\n"}
{"INPUT": "@Override public DataObject execute(CommandContext commandContext){\n  if (executionId == null) {\n    throw new FlowableIllegalArgumentException(\"executionId is null\");\n  }\n  if (dataObjectName == null) {\n    throw new FlowableIllegalArgumentException(\"dataObjectName is null\");\n  }\n  ExecutionEntity execution=CommandContextUtil.getExecutionEntityManager(commandContext).findById(executionId);\n  if (execution == null) {\n    throw new FlowableObjectNotFoundException(\"execution \" + executionId + \" doesn't exist\",Execution.class);\n  }\n  DataObject dataObject=null;\n  VariableInstance variableEntity=null;\n  if (Flowable5Util.isFlowable5ProcessDefinitionId(commandContext,execution.getProcessDefinitionId())) {\n    Flowable5CompatibilityHandler compatibilityHandler=Flowable5Util.getFlowable5CompatibilityHandler();\n    variableEntity=compatibilityHandler.getExecutionVariableInstance(executionId,dataObjectName,isLocal);\n  }\n else {\n    if (isLocal) {\n      variableEntity=execution.getVariableInstanceLocal(dataObjectName,false);\n    }\n else {\n      variableEntity=execution.getVariableInstance(dataObjectName,false);\n    }\n  }\n  String localizedName=null;\n  String localizedDescription=null;\n  if (variableEntity != null) {\n    ExecutionEntity executionEntity=CommandContextUtil.getExecutionEntityManager(commandContext).findById(variableEntity.getExecutionId());\n    while (!executionEntity.isScope()) {\n      executionEntity=executionEntity.getParent();\n    }\n    BpmnModel bpmnModel=ProcessDefinitionUtil.getBpmnModel(executionEntity.getProcessDefinitionId());\n    ValuedDataObject foundDataObject=null;\n    if (executionEntity.getParentId() == null) {\n      for (      ValuedDataObject dataObjectDefinition : bpmnModel.getMainProcess().getDataObjects()) {\n        if (dataObjectDefinition.getName().equals(variableEntity.getName())) {\n          foundDataObject=dataObjectDefinition;\n          break;\n        }\n      }\n    }\n else {\n// bug_start\n      SubProcess subProcess=(SubProcess)bpmnModel.getFlowElement(execution.getActivityId());\n// bug_end\n      for (      ValuedDataObject dataObjectDefinition : subProcess.getDataObjects()) {\n        if (dataObjectDefinition.getName().equals(variableEntity.getName())) {\n          foundDataObject=dataObjectDefinition;\n          break;\n        }\n      }\n    }\n    if (locale != null && foundDataObject != null) {\n      ObjectNode languageNode=BpmnOverrideContext.getLocalizationElementProperties(locale,foundDataObject.getId(),execution.getProcessDefinitionId(),withLocalizationFallback);\n      if (languageNode != null) {\n        JsonNode nameNode=languageNode.get(DynamicBpmnConstants.LOCALIZATION_NAME);\n        if (nameNode != null) {\n          localizedName=nameNode.asText();\n        }\n        JsonNode descriptionNode=languageNode.get(DynamicBpmnConstants.LOCALIZATION_DESCRIPTION);\n        if (descriptionNode != null) {\n          localizedDescription=descriptionNode.asText();\n        }\n      }\n    }\n    if (foundDataObject != null) {\n      dataObject=new DataObjectImpl(variableEntity.getId(),variableEntity.getProcessInstanceId(),variableEntity.getExecutionId(),variableEntity.getName(),variableEntity.getValue(),foundDataObject.getDocumentation(),foundDataObject.getType(),localizedName,localizedDescription,foundDataObject.getId());\n    }\n  }\n  return dataObject;\n}\n"}
{"INPUT": "public static byte[] readBytes(InputStream in,int length) throws IORuntimeException {\n  if (null == in) {\n    return null;\n  }\n  if (length <= 0) {\n    return new byte[0];\n  }\n  byte[] b=new byte[length];\n  int readLength;\n  try {\n    readLength=in.read(b);\n  }\n catch (  IOException e) {\n    throw new IORuntimeException(e);\n  }\n  if (readLength > 0 && readLength < length) {\n// bug_start\n    byte[] b2=new byte[length];\n// bug_end\n    System.arraycopy(b,0,b2,0,readLength);\n    return b2;\n  }\n else {\n    return b;\n  }\n}\n"}
{"INPUT": "@Override public Expression optimize(Session session){\n  super.optimize(session);\n  if (args.length == 1) {\n    type=args[0].getType();\n  }\n  if (orderByList != null) {\n    for (    SelectOrderBy o : orderByList) {\n      o.expression=o.expression.optimize(session);\n    }\n    int offset;\nswitch (aggregateType) {\ncase ARRAY_AGG:\ncase GROUP_CONCAT:\n      offset=1;\n    break;\ndefault :\n  offset=0;\n}\norderBySort=createOrder(session,orderByList,offset);\n}\nswitch (aggregateType) {\ncase GROUP_CONCAT:\n// bug_start\ntype=TypeInfo.TYPE_STRING_DEFAULT;\n// bug_end\nbreak;\ncase COUNT_ALL:\ncase COUNT:\ntype=TypeInfo.TYPE_LONG;\nbreak;\ncase SELECTIVITY:\ntype=TypeInfo.TYPE_INT;\nbreak;\ncase HISTOGRAM:\ntype=TypeInfo.TYPE_ARRAY;\nbreak;\ncase SUM:\n{\nint dataType=type.getValueType();\nif (dataType == Value.BOOLEAN) {\ntype=TypeInfo.TYPE_LONG;\n}\n else if (!DataType.supportsAdd(dataType)) {\nthrow DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1,getSQL());\n}\n else {\ntype=TypeInfo.getTypeInfo(DataType.getAddProofType(dataType));\n}\nbreak;\n}\ncase AVG:\nif (!DataType.supportsAdd(type.getValueType())) {\nthrow DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1,getSQL());\n}\nbreak;\ncase MIN:\ncase MAX:\nbreak;\ncase RANK:\ncase DENSE_RANK:\ntype=TypeInfo.TYPE_LONG;\nbreak;\ncase PERCENT_RANK:\ncase CUME_DIST:\ntype=TypeInfo.TYPE_DOUBLE;\nbreak;\ncase PERCENTILE_CONT:\ntype=orderByList.get(0).expression.getType();\ncase MEDIAN:\nswitch (type.getValueType()) {\ncase Value.BYTE:\ncase Value.SHORT:\ncase Value.INT:\ncase Value.LONG:\ncase Value.DECIMAL:\ncase Value.DOUBLE:\ncase Value.FLOAT:\ntype=TypeInfo.TYPE_DECIMAL_DEFAULT;\nbreak;\n}\nbreak;\ncase PERCENTILE_DISC:\ncase MODE:\ntype=orderByList.get(0).expression.getType();\nbreak;\ncase STDDEV_POP:\ncase STDDEV_SAMP:\ncase VAR_POP:\ncase VAR_SAMP:\ntype=TypeInfo.TYPE_DOUBLE;\nbreak;\ncase EVERY:\ncase ANY:\ntype=TypeInfo.TYPE_BOOLEAN;\nbreak;\ncase BIT_AND:\ncase BIT_OR:\nif (!DataType.supportsAdd(type.getValueType())) {\nthrow DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1,getSQL());\n}\nbreak;\ncase ARRAY_AGG:\ntype=TypeInfo.TYPE_ARRAY;\nbreak;\ncase ENVELOPE:\ntype=TypeInfo.TYPE_GEOMETRY;\nbreak;\ndefault :\nDbException.throwInternalError(\"type=\" + aggregateType);\n}\nreturn this;\n}\n"}
{"INPUT": "protected String sqlWhereEntityWrapper(boolean newLine,TableInfo table){\n// bug_start\n  String sqlScript=table.getAllSqlWhere(false,true,WRAPPER_ENTITY_SPOT);\n// bug_end\n  sqlScript=SqlScriptUtils.convertIf(sqlScript,String.format(\"%s != null\",WRAPPER_ENTITY),true);\n  sqlScript+=NEWLINE;\n  sqlScript+=SqlScriptUtils.convertIf(String.format(\"AND ${%s}\",WRAPPER_SQLSEGMENT),String.format(\"%s != null and %s != '' and %s\",WRAPPER_SQLSEGMENT,WRAPPER_SQLSEGMENT,WRAPPER_NONEMPTYOFWHERE),true);\n  sqlScript=SqlScriptUtils.convertWhere(sqlScript) + NEWLINE;\n  sqlScript+=SqlScriptUtils.convertIf(String.format(\" ${%s}\",WRAPPER_SQLSEGMENT),String.format(\"%s != null and %s != '' and %s\",WRAPPER_SQLSEGMENT,WRAPPER_SQLSEGMENT,WRAPPER_EMPTYOFWHERE),true);\n  sqlScript=SqlScriptUtils.convertIf(sqlScript,String.format(\"%s != null\",WRAPPER),true);\n  return newLine ? NEWLINE + sqlScript : sqlScript;\n}\n"}
{"INPUT": "@Override public void stamp(BType type){\n  if (type.getTag() == TypeTags.TUPLE_TAG) {\n    BRefType<?>[] arrayValues=this.getValues();\n    for (int i=0; i < this.size(); i++) {\n      if (arrayValues[i] != null) {\n        arrayValues[i].stamp(((BTupleType)type).getTupleTypes().get(i));\n      }\n    }\n  }\n else   if (type.getTag() == TypeTags.JSON_TAG) {\n    BRefType<?>[] arrayValues=this.getValues();\n    for (int i=0; i < this.size(); i++) {\n      if (arrayValues[i] != null) {\n        arrayValues[i].stamp(type);\n      }\n    }\n  }\n else   if (type.getTag() == TypeTags.UNION_TAG) {\n    for (    BType memberType : ((BUnionType)type).getMemberTypes()) {\n// bug_start\n      if (CPU.checkIsLikeType(this,memberType)) {\n// bug_end\n        this.stamp(memberType);\n        type=memberType;\n        break;\n      }\n    }\n  }\n else   if (type.getTag() != TypeTags.ANYDATA_TAG) {\n    BType arrayElementType=((BArrayType)type).getElementType();\n    BRefType<?>[] arrayValues=this.getValues();\n    for (int i=0; i < this.size(); i++) {\n      if (arrayValues[i] != null) {\n        arrayValues[i].stamp(arrayElementType);\n      }\n    }\n  }\n  this.arrayType=type;\n}\n"}
{"INPUT": "@Override public long notifyANR(InputApplicationHandle inputApplicationHandle,InputWindowHandle inputWindowHandle,String reason){\n  AppWindowToken appWindowToken=null;\n  WindowState windowState=null;\n  boolean aboveSystem=false;\nsynchronized (mService.mWindowMap) {\n    if (inputWindowHandle != null) {\n      windowState=(WindowState)inputWindowHandle.windowState;\n      if (windowState != null) {\n        appWindowToken=windowState.mAppToken;\n      }\n    }\n    if (appWindowToken == null && inputApplicationHandle != null) {\n      appWindowToken=(AppWindowToken)inputApplicationHandle.appWindowToken;\n    }\n    if (windowState != null) {\n      Slog.i(TAG_WM,\"Input event dispatching timed out \" + \"sending to \" + windowState.mAttrs.getTitle() + \".  Reason: \"+ reason);\n      int systemAlertLayer=mService.mPolicy.getWindowLayerFromTypeLw(TYPE_APPLICATION_OVERLAY,windowState.mOwnerCanAddInternalSystemWindow);\n      aboveSystem=windowState.mBaseLayer > systemAlertLayer;\n    }\n else     if (appWindowToken != null) {\n      Slog.i(TAG_WM,\"Input event dispatching timed out \" + \"sending to application \" + appWindowToken.stringName + \".  Reason: \"+ reason);\n    }\n else {\n      Slog.i(TAG_WM,\"Input event dispatching timed out \" + \".  Reason: \" + reason);\n    }\n    mService.saveANRStateLocked(appWindowToken,windowState,reason);\n  }\n  mService.mAtmInternal.saveANRState(reason);\n  if (appWindowToken != null && appWindowToken.appToken != null) {\n    final AppWindowContainerController controller=appWindowToken.getController();\n    final boolean abort=controller != null && controller.keyDispatchingTimedOut(reason,(windowState != null) ? windowState.mSession.mPid : -1);\n    if (!abort) {\n      return appWindowToken.mInputDispatchingTimeoutNanos;\n    }\n  }\n else   if (windowState != null) {\n// bug_start\n    long timeout=mService.mAtmInternal.inputDispatchingTimedOut(windowState.mSession.mPid,aboveSystem,reason);\n// bug_end\n    if (timeout >= 0) {\n      return timeout * 1000000L;\n    }\n  }\n  return 0;\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_using_assign_code);\n  final Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);\n  toolbar.setNavigationOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      finish();\n    }\n  }\n);\n// bug_start\n  final RefreshLayout refreshLayout=(RefreshLayout)findViewById(R.id.smartLayout);\n// bug_end\n  refreshLayout.setRefreshHeader(new MaterialHeader(this).setShowBezierWave(true));\n  refreshLayout.setRefreshFooter(new BallPulseFooter(this).setSpinnerStyle(SpinnerStyle.Scale));\n  refreshLayout.setPrimaryColorsId(R.color.colorPrimary,android.R.color.white);\n  if (isFirstEnter) {\n    isFirstEnter=false;\n    refreshLayout.autoLoadmore();\n    refreshLayout.setOnMultiPurposeListener(new SimpleMultiPurposeListener(){\n      @Override public void onStateChanged(      RefreshLayout refreshLayout,      RefreshState oldState,      RefreshState newState){\n        if (oldState == RefreshState.LoadingFinish && newState == RefreshState.None) {\n          refreshLayout.autoRefresh();\n          refreshLayout.setOnMultiPurposeListener(null);\n        }\n      }\n    }\n);\n  }\n}\n"}
{"INPUT": "public void actionPerformed(ActionEvent e){\n  JButton button=(JButton)e.getSource();\n  String buttonName=button.getName();\n  if (buttonName.equals(\"add\")) {\n    AddContactWizard wizard=new AddContactWizard(mainFrame);\n    wizard.setVisible(true);\n  }\n else   if (buttonName.equals(\"config\")) {\n    configDialog=GuiActivator.getUIService().getConfigurationWindow();\n    configDialog.setVisible(true);\n  }\n else   if (buttonName.equals(\"search\")) {\n    ContactList contactList=mainFrame.getContactListPanel().getContactList();\n    ContactListModel listModel=(ContactListModel)contactList.getModel();\n    Object selectedObject=null;\n    int currentlySelectedIndex=contactList.getSelectedIndex();\n    if (currentlySelectedIndex != -1) {\n      selectedObject=listModel.getElementAt(currentlySelectedIndex);\n    }\n// bug_start\n    contactList.setShowOffline(!contactList.isShowOffline());\n// bug_end\n    if (selectedObject != null) {\n      if (selectedObject instanceof MetaContact) {\n        contactList.setSelectedIndex(listModel.indexOf((MetaContact)selectedObject));\n      }\n else {\n        contactList.setSelectedIndex(listModel.indexOf((MetaContactGroup)selectedObject));\n      }\n    }\n  }\n else   if (buttonName.equals(\"info\")) {\n    MetaContact selectedMetaContact=(MetaContact)mainFrame.getContactListPanel().getContactList().getSelectedValue();\n    if (selectedMetaContact != null) {\n      OperationSetWebContactInfo wContactInfo=null;\n      Iterator protocolContacts=selectedMetaContact.getContacts();\n      while (protocolContacts.hasNext()) {\n        Contact protoContact=(Contact)protocolContacts.next();\n        wContactInfo=mainFrame.getWebContactInfoOpSet(protoContact.getProtocolProvider());\n        if (wContactInfo != null)         break;\n      }\n      if (wContactInfo != null) {\n        Contact defaultContact=selectedMetaContact.getDefaultContact();\n        GuiActivator.getBrowserLauncher().openURL(wContactInfo.getWebContactInfo(defaultContact).toString());\n      }\n else {\n        new ErrorDialog(mainFrame,Messages.getI18NString(\"selectContactSupportingInfo\").getText(),Messages.getI18NString(\"warning\").getText(),ErrorDialog.WARNING).showDialog();\n      }\n    }\n  }\n else   if (buttonName.equals(\"sound\")) {\n    if (GuiActivator.getAudioNotifier().isMute()) {\n      updateMuteButton(false);\n      GuiActivator.getAudioNotifier().setMute(false);\n    }\n else {\n      updateMuteButton(true);\n      GuiActivator.getAudioNotifier().setMute(true);\n    }\n  }\n}\n"}
{"INPUT": "@Override public String buildURL(String baseURL,String contextPath,String path){\n  String base=StringUtils.strip(baseURL,\"/\");\n  String cp=\"/\" + StringUtils.strip(contextPath,\"/\");\n  String rest=cp + \"/\" + StringUtils.stripStart(path,\"/\");\n// bug_start\n  return ResponseUtils.buildURL(base,rest,null,URLType.RESOURCE);\n// bug_end\n}\n"}
{"INPUT": "@Test public void testCollectWithPartitionedColumns() throws Throwable {\n  RelationName relationName=new RelationName(Schemas.DOC_SCHEMA_NAME,PARTITIONED_TABLE_NAME);\n  Routing routing=schemas.getTableInfo(relationName).getRouting(clusterService().state(),new RoutingProvider(Randomness.get().nextInt(),Collections.emptyList()),WhereClause.MATCH_ALL,RoutingProvider.ShardSelection.ANY,SessionContext.systemSessionContext());\n// bug_start\n  RoutedCollectPhase collectNode=getCollectNode(Arrays.asList(new Reference(new ReferenceIdent(relationName,\"id\"),RowGranularity.DOC,DataTypes.INTEGER,null),new Reference(new ReferenceIdent(relationName,\"date\"),RowGranularity.SHARD,DataTypes.TIMESTAMP,null)),routing,WhereClause.MATCH_ALL);\n// bug_end\n  Bucket result=collect(collectNode);\n  for (  Row row : result) {\n    System.out.println(\"Row:\" + Arrays.toString(row.materialize()));\n  }\n  assertThat(result,containsInAnyOrder(isRow(1,0L),isRow(2,1L)));\n}\n"}
{"INPUT": "protected final void insertPerson(String firstName){\n  String INSERT_PERSON=\"INSERT INTO PERSON (ID, FIRST_NAME, LAST_NAME) VALUES (?, ?, ?)\";\n// bug_start\n  simpleJdbcTemplate.update(INSERT_PERSON,1,firstName,\"Blair\");\n// bug_end\n}\n"}
{"INPUT": "@Override public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n  Object obj=ingestDocument.getFieldValue(field,Object.class);\n  String date=null;\n  if (obj != null) {\n    date=obj.toString();\n  }\n  ZonedDateTime dateTime=null;\n  Exception lastException=null;\n  for (  Function<String,ZonedDateTime> dateParser : dateFormats) {\n    try {\n      dateTime=dateParser.apply(date);\n    }\n catch (    Exception e) {\n      lastException=ExceptionsHelper.useOrSuppress(lastException,e);\n    }\n  }\n  if (dateTime == null) {\n    throw new IllegalArgumentException(\"unable to parse date [\" + date + \"]\",lastException);\n  }\n  String indexNamePrefix=ingestDocument.renderTemplate(indexNamePrefixTemplate);\n  String indexNameFormat=ingestDocument.renderTemplate(indexNameFormatTemplate);\n  String dateRounding=ingestDocument.renderTemplate(dateRoundingTemplate);\n  DateFormatter formatter=DateFormatter.forPattern(indexNameFormat);\n  String zone=timezone.equals(ZoneOffset.UTC) ? \"UTC\" : timezone.getId();\n  StringBuilder builder=new StringBuilder().append('<').append(indexNamePrefix).append('{').append(formatter.format(dateTime)).append(\"||/\").append(dateRounding).append('{').append(indexNameFormat).append('|').append(zone).append('}').append('}').append('>');\n  String dynamicIndexName=builder.toString();\n// bug_start\n  ingestDocument.setFieldValue(IngestDocument.MetaData.INDEX.getFieldName(),dynamicIndexName);\n// bug_end\n  return ingestDocument;\n}\n"}
{"INPUT": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n// bug_start\n  mActionBarProgressView=getLayoutInflater().inflate(R.layout.actionbar_indeterminate_progress,null);\n// bug_end\n  initializeActionBar();\n  setContentView(R.layout.folder_list);\n  mListView=getListView();\n  mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);\n  mListView.setLongClickable(true);\n  mListView.setFastScrollEnabled(true);\n  mListView.setScrollingCacheEnabled(false);\n  mListView.setOnItemClickListener(new OnItemClickListener(){\n    public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){\n      onOpenFolder(((FolderInfoHolder)mAdapter.getItem(position)).name);\n    }\n  }\n);\n  registerForContextMenu(mListView);\n  mListView.setSaveEnabled(true);\n  mInflater=getLayoutInflater();\n  onNewIntent(getIntent());\n  context=this;\n}\n"}
{"INPUT": "private static <T>T doMock(Class<T> type,boolean isStatic,MockStrategy mockStrategy,ConstructorArgs constructorArgs,Method... methods){\n  if (type == null) {\n    throw new IllegalArgumentException(\"The class to mock cannot be null\");\n  }\n  IMocksControl control=mockStrategy.createMockControl(type);\n  T mock=null;\n  if (type.isInterface()) {\n    mock=control.createMock(type);\n  }\n else   if (type.getName().startsWith(\"java.\") && Modifier.isFinal(type.getModifiers())) {\n    Class<?> replicaType=createReplicaType(type,isStatic,constructorArgs);\n    final Object replica=doCreateMock(replicaType,constructorArgs,control,methods);\n    control=mockStrategy.createMockControl(replicaType);\n    MockInvocationHandler h=new MockInvocationHandler((MocksControl)control);\n    final Set<Method> methodsToMock=toSet(methods);\n    if (isStatic) {\n      MockRepository.putStaticMethodInvocationControl(type,new EasyMockMethodInvocationControl<Object>(h,methodsToMock,replica));\n      MockRepository.addObjectsToAutomaticallyReplayAndVerify(type);\n      return null;\n    }\n else {\n      T newInstance=Whitebox.newInstance(type);\n      MockRepository.putInstanceMethodInvocationControl(newInstance,new EasyMockMethodInvocationControl<Object>(h,methodsToMock,replica));\n// bug_start\n      if (mock instanceof InvocationSubstitute<?> == false) {\n// bug_end\n        MockRepository.addObjectsToAutomaticallyReplayAndVerify(newInstance);\n      }\n      return newInstance;\n    }\n  }\n else {\n    mock=doCreateMock(type,constructorArgs,control,methods);\n  }\n  MockInvocationHandler h=new MockInvocationHandler((MocksControl)control);\n  final Set<Method> methodsToMock=toSet(methods);\n  if (isStatic) {\n    MockRepository.putStaticMethodInvocationControl(type,new EasyMockMethodInvocationControl<T>(h,methodsToMock,mock));\n    MockRepository.addObjectsToAutomaticallyReplayAndVerify(type);\n  }\n else {\n    MockRepository.putInstanceMethodInvocationControl(mock,new EasyMockMethodInvocationControl<T>(h,methodsToMock));\n    if (mock instanceof InvocationSubstitute<?> == false) {\n      MockRepository.addObjectsToAutomaticallyReplayAndVerify(mock);\n    }\n  }\n  return mock;\n}\n"}
{"INPUT": "@Test public void testCPU(){\n  System.out.println(\"CPU\");\n  ArffParser parser=new ArffParser();\n  parser.setResponseIndex(6);\n  try {\n    AttributeDataset data=parser.parse(smile.data.parser.IOUtils.getTestDataFile(\"weka/cpu.arff\"));\n    double[] datay=data.toArray(new double[data.size()]);\n    double[][] datax=data.toArray(new double[data.size()][]);\n    MathEx.standardize(datax);\n    int n=datax.length;\n    int k=10;\n    CrossValidation cv=new CrossValidation(n,k);\n    double rss=0.0;\n    for (int i=0; i < k; i++) {\n      double[][] trainx=MathEx.slice(datax,cv.train[i]);\n      double[] trainy=MathEx.slice(datay,cv.train[i]);\n      double[][] testx=MathEx.slice(datax,cv.test[i]);\n      double[] testy=MathEx.slice(datay,cv.test[i]);\n      SVR<double[]> svr=new SVR<>(trainx,trainy,new PolynomialKernel(3,1.0,1.0),0.1,1.0);\n      for (int j=0; j < testx.length; j++) {\n        double r=testy[j] - svr.predict(testx[j]);\n        rss+=r * r;\n      }\n    }\n// bug_start\n    System.out.println(\"10-CV RMSE = \" + MathEx.sqrt(rss / n));\n// bug_end\n  }\n catch (  Exception ex) {\n    System.err.println(ex);\n  }\n}\n"}
{"INPUT": "public static FavoriteItem fromMessage(Message message){\n  FavoriteItem item=new FavoriteItem();\n  item.conversation=message.conversation;\n  item.favType=message.content.getMessageContentType();\n  item.sender=message.sender;\nswitch (message.conversation.type) {\ncase Group:\n    GroupInfo groupInfo=ChatManager.Instance().getGroupInfo(message.conversation.target,false);\n  item.origin=groupInfo.name;\nbreak;\ncase Single:\nitem.origin=ChatManager.Instance().getUserDisplayName(message.sender);\nbreak;\ncase Channel:\nChannelInfo channelInfo=ChatManager.Instance().getChannelInfo(message.conversation.target,false);\nitem.origin=channelInfo.name;\nbreak;\ncase ChatRoom:\nbreak;\ndefault :\nbreak;\n}\nMap<String,Object> data=new HashMap<>();\nswitch (message.content.getMessageContentType()) {\ncase MessageContentType.ContentType_Text:\nTextMessageContent textMessageContent=(TextMessageContent)message.content;\nitem.title=textMessageContent.getContent();\nbreak;\ncase MessageContentType.ContentType_Image:\nImageMessageContent imageMessageContent=(ImageMessageContent)message.content;\nitem.url=imageMessageContent.remoteUrl;\nif (imageMessageContent.getThumbnail() != null) {\nByteArrayOutputStream out=new ByteArrayOutputStream();\nimageMessageContent.getThumbnail().compress(Bitmap.CompressFormat.PNG,100,out);\nString thumb=Base64.encodeToString(out.toByteArray(),Base64.DEFAULT);\ndata.put(\"thumb\",thumb);\nitem.data=new Gson().toJson(data);\n}\nbreak;\ncase MessageContentType.ContentType_Video:\nVideoMessageContent videoMessageContent=(VideoMessageContent)message.content;\nitem.url=videoMessageContent.remoteUrl;\nif (videoMessageContent.getThumbnail() != null) {\nByteArrayOutputStream out=new ByteArrayOutputStream();\nvideoMessageContent.getThumbnail().compress(Bitmap.CompressFormat.PNG,100,out);\nString thumb=Base64.encodeToString(out.toByteArray(),Base64.DEFAULT);\ndata.put(\"thumb\",thumb);\ndata.put(\"duration\",0);\nitem.data=new Gson().toJson(data);\n}\nbreak;\ncase MessageContentType.ContentType_File:\nFileMessageContent fileMessageContent=(FileMessageContent)message.content;\nitem.url=fileMessageContent.remoteUrl;\nitem.title=fileMessageContent.getName();\ndata.put(\"size\",fileMessageContent.getSize());\nitem.data=new Gson().toJson(data);\nbreak;\ncase MessageContentType.ContentType_Composite_Message:\nCompositeMessageContent compositeMessageContent=(CompositeMessageContent)message.content;\nitem.title=compositeMessageContent.getTitle();\nMessagePayload payload=compositeMessageContent.encode();\nitem.data=Base64.encodeToString(payload.binaryContent,Base64.DEFAULT);\nbreak;\ncase MessageContentType.ContentType_Voice:\nSoundMessageContent soundMessageContent=(SoundMessageContent)message.content;\n// bug_start\nitem.title=soundMessageContent.remoteUrl;\n// bug_end\ndata.put(\"duration\",soundMessageContent.getDuration());\nitem.data=new Gson().toJson(data);\nbreak;\ncase MessageContentType.ContentType_Link:\nLinkMessageContent linkMessageContent=(LinkMessageContent)message.content;\nitem.title=linkMessageContent.getTitle();\nitem.thumbUrl=linkMessageContent.getThumbnailUrl();\nitem.url=linkMessageContent.getUrl();\nbreak;\ndefault :\nbreak;\n}\nreturn item;\n}\n"}
{"INPUT": "public void commitTask(TaskAttemptContext context) throws IOException {\n  TaskAttemptID attemptId=context.getTaskAttemptID();\n  if (workPath != null) {\n    context.progress();\n    if (outputFileSystem.exists(workPath)) {\n      Path jobOutputPath=new Path(outputPath,getJobAttemptBaseDirName(context));\n      moveTaskOutputs(context,outputFileSystem,jobOutputPath,workPath);\n      if (!outputFileSystem.delete(workPath,true)) {\n        LOG.warn(\"Failed to delete the temporary output\" + \" directory of task: \" + attemptId + \" - \"+ workPath);\n      }\n// bug_start\n      LOG.info(\"Saved output of task '\" + attemptId + \"' to \"+ outputPath);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "@Override public TaskResult run(){\n  try {\n    logger.info(String.format(\"Waiting for a single task process to finish. job name: %s. job id: %s\",this.jobName,this.jobId));\n    int exitCode=this.taskProcess.waitFor();\n    if (exitCode == 0) {\n      logger.info(\"Task process finished. job name: {}. job id: {}\",this.jobName,this.jobId);\n      return new TaskResult(TaskResult.Status.COMPLETED,\"\");\n    }\n else {\n      logger.warn(\"Task process failed with exitcode ({}). job name: {}. job id: {}\",exitCode,this.jobName,this.jobId);\n// bug_start\n      return new TaskResult(TaskResult.Status.FAILED,\"Exit code: \" + exitCode);\n// bug_end\n    }\n  }\n catch (  final Throwable t) {\n    logger.error(\"SingleHelixTask failed due to \" + t.getMessage(),t);\n    return new TaskResult(TaskResult.Status.FAILED,Throwables.getStackTraceAsString(t));\n  }\n}\n"}
{"INPUT": "private void verifyTermDocs(Directory dir,Term term,int numDocs) throws IOException {\n  IndexReader reader=DirectoryReader.open(dir);\n// bug_start\n  PostingsEnum postingsEnum=TestUtil.docs(random(),reader,term.field,term.bytes,null,null,PostingsEnum.FLAG_NONE);\n// bug_end\n  int count=0;\n  while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS)   count++;\n  assertEquals(numDocs,count);\n  reader.close();\n}\n"}
{"INPUT": "@Override protected Object afterInitialization(ConfigurableApplicationContext applicationContext,Object bean,String beanName) throws BeansException {\n  if (bean instanceof NacosServiceRegistry) {\n    NacosServiceRegistry nacosServiceRegistry=(NacosServiceRegistry)bean;\n    NacosDiscoveryProperties nacosDiscoveryProperties=applicationContext.getBean(NacosDiscoveryProperties.class);\n    return new NacosServiceRegistryDecorator(nacosDiscoveryProperties,nacosServiceRegistry,applicationContext);\n  }\n else   if (bean instanceof NacosDiscoveryProperties) {\n    ConfigurableEnvironment environment=applicationContext.getEnvironment();\n    NacosDiscoveryProperties nacosDiscoveryProperties=(NacosDiscoveryProperties)bean;\n    Map<String,String> metadata=nacosDiscoveryProperties.getMetadata();\n    String groupKey=PluginContextAware.getGroupKey(environment);\n    if (!metadata.containsKey(groupKey)) {\n      metadata.put(groupKey,DiscoveryConstant.DEFAULT);\n    }\n    if (!metadata.containsKey(DiscoveryConstant.VERSION)) {\n      metadata.put(DiscoveryConstant.VERSION,DiscoveryConstant.DEFAULT);\n    }\n    if (!metadata.containsKey(DiscoveryConstant.REGION)) {\n      metadata.put(DiscoveryConstant.REGION,DiscoveryConstant.DEFAULT);\n    }\n    String prefixGroup=getPrefixGroup(applicationContext);\n    if (StringUtils.isNotEmpty(prefixGroup)) {\n      metadata.put(groupKey,prefixGroup);\n    }\n    String gitVersion=getGitVersion(applicationContext);\n    if (StringUtils.isNotEmpty(gitVersion)) {\n      metadata.put(DiscoveryConstant.VERSION,gitVersion);\n    }\n    metadata.put(DiscoveryConstant.SPRING_BOOT_VERSION,SpringBootVersion.getVersion());\n// bug_start\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_ID,UUID.randomUUID().toString());\n// bug_end\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_NAME,PluginContextAware.getApplicationName(environment));\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_TYPE,PluginContextAware.getApplicationType(environment));\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_DISCOVERY_PLUGIN,NacosConstant.NACOS_TYPE);\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_DISCOVERY_VERSION,DiscoveryConstant.DISCOVERY_VERSION);\n    String agentVersion=System.getProperty(DiscoveryConstant.SPRING_APPLICATION_DISCOVERY_AGENT_VERSION);\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_DISCOVERY_AGENT_VERSION,StringUtils.isEmpty(agentVersion) ? DiscoveryConstant.UNKNOWN : agentVersion);\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_REGISTER_CONTROL_ENABLED,PluginContextAware.isRegisterControlEnabled(environment).toString());\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_DISCOVERY_CONTROL_ENABLED,PluginContextAware.isDiscoveryControlEnabled(environment).toString());\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_CONFIG_REST_CONTROL_ENABLED,PluginContextAware.isConfigRestControlEnabled(environment).toString());\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_GROUP_KEY,groupKey);\n    metadata.put(DiscoveryConstant.SPRING_APPLICATION_CONTEXT_PATH,PluginContextAware.getContextPath(environment));\n    try {\n      ApplicationInfoAdapter applicationInfoAdapter=applicationContext.getBean(ApplicationInfoAdapter.class);\n      if (applicationInfoAdapter != null) {\n        metadata.put(DiscoveryConstant.APP_ID,applicationInfoAdapter.getAppId());\n      }\n    }\n catch (    Exception e) {\n    }\n    MetadataUtil.filter(metadata);\n    return bean;\n  }\n else {\n    return bean;\n  }\n}\n"}
{"INPUT": "@Override protected void configure(){\n// bug_start\n  bind(TemplatedHttpRequest.Parser.class).asEagerSingleton();\n// bug_end\n  bind(HttpRequest.Parser.class).asEagerSingleton();\n  bind(HttpClient.class).asEagerSingleton();\n}\n"}
{"INPUT": "private void performTest() throws Exception {\n  startLauncher();\n  final UiObject2 appsContainer=openAllApps();\n  assertTrue(Wait.atMost(Condition.minChildCount(appsContainer,2),DEFAULT_UI_TIMEOUT));\n  UiObject2 icon=scrollAndFind(appsContainer,By.text(mSettingsApp.getLabel().toString()));\n  Point iconCenter=icon.getVisibleCenter();\n  sendPointer(MotionEvent.ACTION_DOWN,iconCenter);\n  UiObject2 deepShortcutsContainer=findViewById(R.id.deep_shortcuts_container);\n  assertNotNull(deepShortcutsContainer);\n  sendPointer(MotionEvent.ACTION_UP,iconCenter);\n  assertTrue(deepShortcutsContainer.getChildCount() > 0);\n// bug_start\n  UiObject2 shortcut=deepShortcutsContainer.getChildren().get(0).findObject(getSelectorForId(R.id.deep_shortcut));\n// bug_end\n  shortcut.click();\n  assertTrue(mDevice.wait(Until.hasObject(By.pkg(mSettingsApp.getComponentName().getPackageName()).text(shortcut.getText())),DEFAULT_UI_TIMEOUT));\n}\n"}
{"INPUT": "@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);\n  final int columnWidth=(widthSize != 0) ? (widthSize - mPaddingLeft - mPaddingRight) / mColumnCount : 0;\n  int width=0;\n  int height=0;\n  int childState=0;\n  final int childCount=getChildCount();\n  final int rowCount=childCount / mColumnCount + childCount % mColumnCount;\n  for (int row=0; row < rowCount; row++) {\n    int rowWidth=0;\n    int rowHeight=0;\n    for (int col=0; col < mColumnCount; col++) {\n      final int childIndex=row * mColumnCount + col;\n      if (childIndex >= childCount) {\n        break;\n      }\n      View child=getChildAt(childIndex);\n      if (child.getVisibility() == GONE) {\n        continue;\n      }\n      MarginLayoutParams childParams=(MarginLayoutParams)child.getLayoutParams();\n      final int childWidthMeasureSpec;\n      if (columnWidth > 0) {\n        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(columnWidth - childParams.getMarginStart() - childParams.getMarginEnd(),MeasureSpec.EXACTLY);\n      }\n else {\n// bug_start\n        childWidthMeasureSpec=getChildMeasureSpec(heightMeasureSpec,getPaddingStart() + getPaddingEnd() + width,childParams.width);\n// bug_end\n      }\n      final int childHeightMeasureSpec=getChildMeasureSpec(heightMeasureSpec,getPaddingTop() + getPaddingBottom() + height,childParams.height);\n      child.measure(childWidthMeasureSpec,childHeightMeasureSpec);\n      childState=combineMeasuredStates(childState,child.getMeasuredState());\n      rowWidth+=child.getMeasuredWidth() + childParams.getMarginStart() + childParams.getMarginEnd();\n      rowHeight=Math.max(rowHeight,child.getMeasuredHeight() + childParams.topMargin + childParams.bottomMargin);\n    }\n    width=Math.max(width,rowWidth);\n    height+=rowHeight;\n  }\n  width+=getPaddingStart() + getPaddingEnd();\n  width=Math.max(width,getMinimumWidth());\n  height+=getPaddingTop() + getPaddingBottom();\n  height=Math.max(height,getMinimumHeight());\n  setMeasuredDimension(resolveSizeAndState(width,widthMeasureSpec,childState),resolveSizeAndState(height,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));\n}\n"}
{"INPUT": "public void testExecuteSuccessfullyMoved() throws IOException {\n  StepKey currentStepKey=new StepKey(\"current-phase\",\"current-action\",\"current-name\");\n  StepKey nextStepKey=new StepKey(\"next-phase\",\"next-action\",\"next-step-name\");\n  long now=randomNonNegativeLong();\n  Exception cause=new ElasticsearchException(\"THIS IS AN EXPECTED CAUSE\");\n  setStateToKey(currentStepKey);\n  MoveToErrorStepUpdateTask task=new MoveToErrorStepUpdateTask(index,policy,currentStepKey,cause,null,null);\n  ClusterState newState=task.execute(clusterState);\n  LifecycleExecutionState lifecycleState=LifecycleExecutionState.fromIndexMetadata(newState.getMetaData().index(index));\n// bug_start\n  StepKey actualKey=IndexLifecycleRunner.getCurrentStepKey(lifecycleState);\n// bug_end\n  assertThat(actualKey,equalTo(new StepKey(currentStepKey.getPhase(),currentStepKey.getAction(),ErrorStep.NAME)));\n  assertThat(lifecycleState.getFailedStep(),equalTo(currentStepKey.getName()));\n  assertThat(lifecycleState.getPhaseTime(),nullValue());\n  assertThat(lifecycleState.getActionTime(),nullValue());\n  assertThat(lifecycleState.getStepTime(),equalTo(now));\n  XContentBuilder causeXContentBuilder=JsonXContent.contentBuilder();\n  causeXContentBuilder.startObject();\n  ElasticsearchException.generateThrowableXContent(causeXContentBuilder,ToXContent.EMPTY_PARAMS,cause);\n  causeXContentBuilder.endObject();\n  String expectedCauseValue=BytesReference.bytes(causeXContentBuilder).utf8ToString();\n  assertThat(lifecycleState.getStepInfo(),containsString(\"{\\\"type\\\":\\\"exception\\\",\\\"reason\\\":\\\"THIS IS AN EXPECTED CAUSE\\\",\\\"stack_trace\\\":\\\"\"));\n}\n"}
{"INPUT": "@Override public void warm(IndexShard indexShard,IndexMetaData indexMetaData,IndicesWarmer.WarmerContext warmerContext){\n  IndexWarmersMetaData custom=indexMetaData.custom(IndexWarmersMetaData.TYPE);\n  if (custom == null) {\n    return;\n  }\n  for (  IndexWarmersMetaData.Entry entry : custom.entries()) {\n    SearchContext context=null;\n    try {\n      long now=System.nanoTime();\n// bug_start\n      ShardSearchRequest request=new ShardSearchRequest(indexShard.shardId().index().name(),indexShard.shardId().id(),indexMetaData.numberOfShards(),SearchType.COUNT).source(entry.source()).types(entry.types());\n// bug_end\n      context=createContext(request,warmerContext.newSearcher());\n      queryPhase.execute(context);\n      long took=System.nanoTime() - now;\n      if (indexShard.warmerService().logger().isTraceEnabled()) {\n        indexShard.warmerService().logger().trace(\"warmed [{}], took [{}]\",entry.name(),TimeValue.timeValueNanos(took));\n      }\n    }\n catch (    Throwable t) {\n      indexShard.warmerService().logger().warn(\"warmer [{}] failed\",t,entry.name());\n    }\n finally {\n      if (context != null) {\n        freeContext(context);\n        cleanContext(context);\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override public void onServiceDisconnected(ComponentName name){\n  if (isEncryptOpen && encryptBaseFile != null) {\n    if (mainFragment != null) {\nswitch (mainFragment.openMode) {\ncase OTG:\n// bug_start\n        getFutils().openFile(RootHelper.getDocumentFile(encryptBaseFile.getPath(),MainActivity.this,false),MainActivity.this);\n// bug_end\n      break;\ncase SMB:\n    try {\n      MainFragment.launchSMB(new SmbFile(encryptBaseFile.getPath()),encryptBaseFile.getSize(),MainActivity.this);\n    }\n catch (    MalformedURLException e) {\n      e.printStackTrace();\n    }\ndefault :\n  getFutils().openFile(new File(encryptBaseFile.getPath()),MainActivity.this);\n}\n}\n else getFutils().openFile(new File(encryptBaseFile.getPath()),MainActivity.this);\nisEncryptOpen=false;\n}\n}\n"}
{"INPUT": "@Override public Map<String,DataObject> execute(CommandContext commandContext){\n  if (executionId == null) {\n    throw new FlowableIllegalArgumentException(\"executionId is null\");\n  }\n  ExecutionEntity execution=CommandContextUtil.getExecutionEntityManager(commandContext).findById(executionId);\n  if (execution == null) {\n    throw new FlowableObjectNotFoundException(\"execution \" + executionId + \" doesn't exist\",Execution.class);\n  }\n  Map<String,VariableInstance> variables=null;\n  if (Flowable5Util.isFlowable5ProcessDefinitionId(commandContext,execution.getProcessDefinitionId())) {\n    Flowable5CompatibilityHandler compatibilityHandler=Flowable5Util.getFlowable5CompatibilityHandler();\n    variables=compatibilityHandler.getExecutionVariableInstances(executionId,dataObjectNames,isLocal);\n  }\n else {\n    if (dataObjectNames == null || dataObjectNames.isEmpty()) {\n      if (isLocal) {\n        variables=execution.getVariableInstancesLocal();\n      }\n else {\n        variables=execution.getVariableInstances();\n      }\n    }\n else {\n      if (isLocal) {\n        variables=execution.getVariableInstancesLocal(dataObjectNames,false);\n      }\n else {\n        variables=execution.getVariableInstances(dataObjectNames,false);\n      }\n    }\n  }\n  Map<String,DataObject> dataObjects=null;\n  if (variables != null) {\n    dataObjects=new HashMap<>(variables.size());\n    for (    Entry<String,VariableInstance> entry : variables.entrySet()) {\n      String name=entry.getKey();\n      VariableInstance variableEntity=entry.getValue();\n      ExecutionEntity executionEntity=CommandContextUtil.getExecutionEntityManager(commandContext).findById(variableEntity.getExecutionId());\n      while (!executionEntity.isScope()) {\n        executionEntity=executionEntity.getParent();\n      }\n      BpmnModel bpmnModel=ProcessDefinitionUtil.getBpmnModel(execution.getProcessDefinitionId());\n      ValuedDataObject foundDataObject=null;\n      if (executionEntity.getParentId() == null) {\n        for (        ValuedDataObject dataObject : bpmnModel.getMainProcess().getDataObjects()) {\n          if (dataObject.getName().equals(variableEntity.getName())) {\n            foundDataObject=dataObject;\n            break;\n          }\n        }\n      }\n else {\n// bug_start\n        SubProcess subProcess=(SubProcess)bpmnModel.getFlowElement(execution.getActivityId());\n// bug_end\n        for (        ValuedDataObject dataObject : subProcess.getDataObjects()) {\n          if (dataObject.getName().equals(variableEntity.getName())) {\n            foundDataObject=dataObject;\n            break;\n          }\n        }\n      }\n      String localizedName=null;\n      String localizedDescription=null;\n      if (locale != null && foundDataObject != null) {\n        ObjectNode languageNode=BpmnOverrideContext.getLocalizationElementProperties(locale,foundDataObject.getId(),execution.getProcessDefinitionId(),withLocalizationFallback);\n        if (languageNode != null) {\n          JsonNode nameNode=languageNode.get(DynamicBpmnConstants.LOCALIZATION_NAME);\n          if (nameNode != null) {\n            localizedName=nameNode.asText();\n          }\n          JsonNode descriptionNode=languageNode.get(DynamicBpmnConstants.LOCALIZATION_DESCRIPTION);\n          if (descriptionNode != null) {\n            localizedDescription=descriptionNode.asText();\n          }\n        }\n      }\n      if (foundDataObject != null) {\n        dataObjects.put(name,new DataObjectImpl(variableEntity.getId(),variableEntity.getProcessInstanceId(),variableEntity.getExecutionId(),variableEntity.getName(),variableEntity.getValue(),foundDataObject.getDocumentation(),foundDataObject.getType(),localizedName,localizedDescription,foundDataObject.getId()));\n      }\n    }\n  }\n  return dataObjects;\n}\n"}
{"INPUT": "@Before public void setup(){\n  LOG.info(\"---------------------------------\");\n  LOG.info(\"Testing QOP:\" + expectedQop);\n  LOG.info(\"---------------------------------\");\n  conf=new Configuration();\n// bug_start\n  conf.set(HADOOP_SECURITY_AUTHENTICATION,KERBEROS.toString());\n// bug_end\n  conf.set(\"hadoop.rpc.protection\",expectedQop.name().toLowerCase());\n  UserGroupInformation.setConfiguration(conf);\n  enableSecretManager=null;\n  forceSecretManager=null;\n  clientFallBackToSimpleAllowed=true;\n}\n"}
{"INPUT": "public IpFieldType(String name,boolean indexed,boolean stored,boolean hasDocValues,InetAddress nullValue,Map<String,String> meta){\n// bug_start\n  super(name,indexed,stored,hasDocValues,TextSearchInfo.SIMPLE_MATCH_ONLY,meta);\n// bug_end\n  this.nullValue=nullValue;\n}\n"}
{"INPUT": "@Override @TargetApi(Build.VERSION_CODES.N) public void onProvideKeyboardShortcuts(List<KeyboardShortcutGroup> data,Menu menu,int deviceId){\n  ArrayList<KeyboardShortcutInfo> shortcutInfos=new ArrayList<>();\n  if (isInState(NORMAL)) {\n    shortcutInfos.add(new KeyboardShortcutInfo(getString(R.string.all_apps_button_label),KeyEvent.KEYCODE_A,KeyEvent.META_CTRL_ON));\n  }\n  View currentFocus=getCurrentFocus();\n  if (new CustomActionsPopup(this,currentFocus).canShow()) {\n    shortcutInfos.add(new KeyboardShortcutInfo(getString(R.string.custom_actions),KeyEvent.KEYCODE_O,KeyEvent.META_CTRL_ON));\n  }\n  if (currentFocus.getTag() instanceof ItemInfo && DeepShortcutManager.supportsShortcuts((ItemInfo)currentFocus.getTag())) {\n// bug_start\n    shortcutInfos.add(new KeyboardShortcutInfo(getString(R.string.action_deep_shortcut),KeyEvent.KEYCODE_S,KeyEvent.META_CTRL_ON));\n// bug_end\n  }\n  if (!shortcutInfos.isEmpty()) {\n    data.add(new KeyboardShortcutGroup(getString(R.string.home_screen),shortcutInfos));\n  }\n  super.onProvideKeyboardShortcuts(data,menu,deviceId);\n}\n"}
{"INPUT": "private void printSegment(PrintWriter out,SegmentCommitInfo si) throws Exception {\n  SegmentReader reader=new SegmentReader(si,newIOContext(random()));\n  for (int i=0; i < reader.numDocs(); i++)   out.println(reader.document(i));\n  Fields fields=reader.fields();\n  for (  String field : fields) {\n    Terms terms=fields.terms(field);\n    assertNotNull(terms);\n    TermsEnum tis=terms.iterator(null);\n    while (tis.next() != null) {\n      out.print(\"  term=\" + field + \":\"+ tis.term());\n      out.println(\"    DF=\" + tis.docFreq());\n// bug_start\n      PostingsEnum positions=tis.postings(reader.getLiveDocs(),null,PostingsEnum.FLAG_POSITIONS);\n// bug_end\n      while (positions.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        out.print(\" doc=\" + positions.docID());\n        out.print(\" TF=\" + positions.freq());\n        out.print(\" pos=\");\n        out.print(positions.nextPosition());\n        for (int j=1; j < positions.freq(); j++)         out.print(\",\" + positions.nextPosition());\n        out.println(\"\");\n      }\n    }\n  }\n  reader.close();\n}\n"}
{"INPUT": "private void measureChildHorizontal(View child,LayoutParams params,int myWidth,int myHeight){\n  final int childWidthMeasureSpec=getChildMeasureSpec(params.mLeft,params.mRight,params.width,params.leftMargin,params.rightMargin,mPaddingLeft,mPaddingRight,myWidth);\n  final int childHeightMeasureSpec;\n  if (myHeight < 0 && !mAllowBrokenMeasureSpecs) {\n    if (params.height >= 0) {\n      childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(params.height,MeasureSpec.EXACTLY);\n    }\n else {\n      childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);\n    }\n  }\n else {\n    final int maxHeight;\n    if (mMeasureVerticalWithPaddingMargin) {\n      maxHeight=Math.max(0,myHeight - mPaddingTop - mPaddingBottom- params.topMargin- params.bottomMargin);\n    }\n else {\n      maxHeight=Math.max(0,myHeight);\n    }\n    final int heightMode;\n// bug_start\n    if (params.width == LayoutParams.MATCH_PARENT) {\n// bug_end\n      heightMode=MeasureSpec.EXACTLY;\n    }\n else {\n      heightMode=MeasureSpec.AT_MOST;\n    }\n    childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(maxHeight,heightMode);\n  }\n  child.measure(childWidthMeasureSpec,childHeightMeasureSpec);\n}\n"}
{"INPUT": "@Test public void testGetWithUnsatisfiableRange() throws IOException {\n  final HttpClient client=new HttpClient();\n  final byte[] testContent=\"hello world\".getBytes();\n  try (WritableFile w=fs.file(\"foo.txt\").openWritable()){\n    w.write(ByteBuffer.wrap(testContent));\n  }\n   final HttpMethod getMethod=new GetMethod(servletRoot + \"/foo.txt\");\n  getMethod.addRequestHeader(\"Range\",\"chunks=1-2\");\n  final int statusCode=client.executeMethod(getMethod);\n// bug_start\n  Assert.assertEquals(416,statusCode);\n// bug_end\n  Assert.assertArrayEquals(testContent,getMethod.getResponseBody());\n  getMethod.releaseConnection();\n}\n"}
{"INPUT": "@Override public void configure() throws Exception {\n  ZipkinTracer zipkin=new ZipkinTracer();\n// bug_start\n  zipkin.setHostName(\"192.168.99.100\");\n// bug_end\n  zipkin.setPort(9410);\n  zipkin.setServiceName(\"service2\");\n  zipkin.setRate(1.0f);\n  zipkin.setIncludeMessageBodyStreams(true);\n  zipkin.init(getContext());\n  from(\"undertow:http://0.0.0.0:7070/service2\").routeId(\"service2\").streamCaching().log(\" Service2 request: ${body}\").delay(simple(\"${random(1000,2000)}\")).transform(simple(\"Service2-${body}\")).log(\"Service2 response: ${body}\");\n}\n"}
{"INPUT": "public void performRestartWordSuggestion(final InputConnection ic){\n  if (canRestartWordSuggestion()) {\n    ic.beginBatchEdit();\n    abortCorrection(true,false);\n    CharSequence toLeft=\"\";\n    CharSequence toRight=\"\";\n    while (true) {\n      CharSequence newToLeft=ic.getTextBeforeCursor(toLeft.length() + 1,0);\n      if (TextUtils.isEmpty(newToLeft) || isWordSeparator(newToLeft.charAt(0)) || newToLeft.length() == toLeft.length()) {\n        break;\n      }\n      toLeft=newToLeft;\n    }\n    while (true) {\n      CharSequence newToRight=ic.getTextAfterCursor(toRight.length() + 1,0);\n      if (TextUtils.isEmpty(newToRight) || isWordSeparator(newToRight.charAt(newToRight.length() - 1)) || newToRight.length() == toRight.length()) {\n        break;\n      }\n      toRight=newToRight;\n    }\n    CharSequence word=toLeft.toString() + toRight.toString();\n// bug_start\n    Log.d(TAG,\"Starting new prediction on word '%d'.\",word);\n// bug_end\n    mPredicting=word.length() > 0;\n    mUndoCommitCursorPosition=-2;\n    mWord.reset();\n    final int[] tempNearByKeys=new int[1];\n    for (int index=0; index < word.length(); index++) {\n      final char c=word.charAt(index);\n      if (index == 0)       mWord.setFirstCharCapitalized(Character.isUpperCase(c));\n      tempNearByKeys[0]=c;\n      mWord.add(c,tempNearByKeys);\n      TextEntryState.typedCharacter(c,false);\n    }\n    ic.deleteSurroundingText(toLeft.length(),toRight.length());\n    ic.setComposingText(word,1);\n    if (toRight.length() > 0) {\n      final int cursorPosition=getCursorPosition(ic) - toRight.length();\n      Log.d(TAG,\"Repositioning the cursor inside the word to position %d\",cursorPosition);\n      ic.setSelection(cursorPosition,cursorPosition);\n    }\n    mWord.setCursorPosition(toLeft.length());\n    ic.endBatchEdit();\n    postUpdateSuggestions();\n  }\n else {\n    Log.d(TAG,\"performRestartWordSuggestion canRestartWordSuggestion == false\");\n  }\n}\n"}
{"INPUT": "@Implementation public long executeInsert(){\n  try {\n    actualDBstatement.executeUpdate();\n    ResultSet resultSet=actualDBstatement.getGeneratedKeys();\n    if (resultSet.next()) {\n      return resultSet.getLong(1);\n    }\n else {\n// bug_start\n      throw new RuntimeException(\"Could not retrive generatedKeys\");\n// bug_end\n    }\n  }\n catch (  SQLException e) {\n    throw new RuntimeException(e);\n  }\n}\n"}
{"INPUT": "public static Object verifyRsaMd5Signature(Strand strand,ArrayValue dataValue,ArrayValue signatureValue,MapValue<?,?> publicKey){\n  byte[] data=dataValue.getBytes();\n  byte[] signature=signatureValue.getBytes();\n  try {\n    PublicKey key=(PublicKey)publicKey.getNativeData(Constants.NATIVE_DATA_PUBLIC_KEY);\n    return CryptoUtils.verify(\"MD5withRSA\",key,data,signature);\n  }\n catch (  InvalidKeyException e) {\n// bug_start\n    return CryptoUtils.createCryptoError(\"invalid uninitialized key\");\n// bug_end\n  }\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") @Test public void testExecuteRedirected() throws Exception {\n  final RedirectModifier<Object> modifier=mock(RedirectModifier.class);\n  final Object source1=new Object();\n  final Object source2=new Object();\n  when(modifier.apply(argThat(hasProperty(\"source\",is(source))))).thenReturn(Lists.newArrayList(source1,source2));\n  subject.register(literal(\"actual\").executes(command));\n  subject.register(literal(\"redirected\").redirect(subject.getRoot(),modifier));\n  final String input=\"redirected actual\";\n  final ParseResults<Object> parse=subject.parse(input,source);\n  assertThat(parse.getContext().getRange().get(input),equalTo(\"redirected\"));\n  assertThat(parse.getContext().getNodes().size(),is(1));\n  assertThat(parse.getContext().getSource(),is(source));\n  final CommandContextBuilder<Object> parent=parse.getContext().getChild();\n  assertThat(parent,is(notNullValue()));\n  assertThat(parent.getRange().get(input),equalTo(\"actual\"));\n  assertThat(parent.getNodes().size(),is(2));\n  assertThat(parent.getSource(),is(source));\n// bug_start\n  assertThat(subject.execute(parse),is(84));\n// bug_end\n  verify(command).run(argThat(hasProperty(\"source\",is(source1))));\n  verify(command).run(argThat(hasProperty(\"source\",is(source2))));\n}\n"}
{"INPUT": "public void test_DENORMALISER_01_MULTIKEY() throws Exception {\n// bug_start\n  TimedTransRunner timedTransRunner=new TimedTransRunner(\"test/org/pentaho/di/run/denormaliser/DenormaliserMultiKey.ktr\",LogWriter.LOG_LEVEL_ERROR,AllRunTests.getOldTargetDatabase(),AllRunTests.getNewTargetDatabase(),rowCount * 10);\n// bug_end\n  assertTrue(timedTransRunner.runOldAndNew());\n  be.ibridge.kettle.core.Result oldResult=timedTransRunner.getOldResult();\n  assertTrue(oldResult.getNrErrors() == 0);\n  Result newResult=timedTransRunner.getNewResult();\n  assertTrue(newResult.getNrErrors() == 0);\n}\n"}
{"INPUT": "private void initialize(Vector2f effectsTextureWidth){\n  Vector2f texPos=new Vector2f(0.0f,0.0f);\n  Tessellator tessellator=new Tessellator();\n  TessellatorHelper.addBlockMesh(tessellator,new Vector4f(1,1,1,1f),texPos,effectsTextureWidth,1.001f,1.0f,1.0f,0.0f,0.0f,0.0f);\n  overlayMesh=tessellator.generateMesh();\n  tessellator=new Tessellator();\n  TessellatorHelper.addBlockMesh(tessellator,new Vector4f(1,1,1,.2f),texPos,effectsTextureWidth,1.001f,1.0f,1.0f,0.0f,0.0f,0.0f);\n  overlayMesh2=tessellator.generateMesh();\n// bug_start\n  defaultTextured=Assets.getMaterial(\"engine:defaultTextured\");\n// bug_end\n}\n"}
{"INPUT": "@Test public void testWeatherDataset(){\n// bug_start\n  testBalanceWithCrossValidation(\"smalldata/weather/weather.csv\",23,ari(0,1,22),2,10);\n// bug_end\n}\n"}
{"INPUT": "private void swapClusters(ODatabaseDocumentTx databaseDocumentTx,int i){\n// bug_start\n  databaseDocumentTx.command(new OCommandSQL(\"CREATE CLASS TestRenameClusterNew extends TestRenameClusterOriginal\")).execute();\n// bug_end\n  databaseDocumentTx.command(new OCommandSQL(\"INSERT INTO TestRenameClusterNew (iteration) VALUES(\" + i + \")\")).execute();\n  databaseDocumentTx.command(new OCommandSQL(\"ALTER CLASS TestRenameClusterOriginal removecluster TestRenameClusterOriginal\")).execute();\n  databaseDocumentTx.command(new OCommandSQL(\"ALTER CLASS TestRenameClusterNew removecluster TestRenameClusterNew\")).execute();\n  databaseDocumentTx.command(new OCommandSQL(\"DROP CLASS TestRenameClusterNew\")).execute();\n  databaseDocumentTx.command(new OCommandSQL(\"ALTER CLASS TestRenameClusterOriginal addcluster TestRenameClusterNew\")).execute();\n  databaseDocumentTx.command(new OCommandSQL(\"DROP CLUSTER TestRenameClusterOriginal\")).execute();\n  databaseDocumentTx.command(new OCommandSQL(\"ALTER CLUSTER TestRenameClusterNew name TestRenameClusterOriginal\")).execute();\n  databaseDocumentTx.getLocalCache().clear();\n  List<ODocument> result=databaseDocumentTx.query(new OSQLSynchQuery<ODocument>(\"select * from TestRenameClusterOriginal\"));\n  Assert.assertEquals(result.size(),1);\n  ODocument document=result.get(0);\n  Assert.assertEquals(document.<Object>field(\"iteration\"),i);\n}\n"}
{"INPUT": "public void foo4(){\n  int prog, user;\n  prog=(int)(Math.random() * 10) + 1;\n  Scanner input=new Scanner(System.in,\"utf-8\");\n  if (input.hasNextInt()) {\n    do {\n      user=input.nextInt();\n      if (user == prog) {\n        String.CASE_INSENSITIVE_ORDER.equals(\"Good!\");\n      }\n else {\n        if (user > 0 && user <= 10) {\n          String.CASE_INSENSITIVE_ORDER.equals(\"Bad! \");\n          if (prog < user) {\n            String.CASE_INSENSITIVE_ORDER.equals(\"My number is less than yours.\");\n          }\n else {\n// bug_start\n            String.CASE_INSENSITIVE_ORDER.equals(\"My number is greater than yours.\");\n// bug_end\n          }\n        }\n else {\n          String.CASE_INSENSITIVE_ORDER.equals(\"Error!\");\n        }\n      }\n    }\n while (user != prog);\n  }\n else {\n    String.CASE_INSENSITIVE_ORDER.equals(\"Error!\");\n  }\n  String.CASE_INSENSITIVE_ORDER.equals(\"Goodbye!\");\n}\n"}
{"INPUT": "@Test public void testAsciiFunc(){\n  tester.setFor(SqlStdOperatorTable.ASCII);\n  tester.checkScalarExact(\"ASCII('')\",\"0\");\n  tester.checkScalarExact(\"ASCII('a')\",\"97\");\n  tester.checkScalarExact(\"ASCII('1')\",\"49\");\n  tester.checkScalarExact(\"ASCII('abc')\",\"97\");\n  tester.checkScalarExact(\"ASCII('ABC')\",\"65\");\n  tester.checkScalarExact(\"ASCII(_UTF8'\\u0082')\",\"130\");\n  tester.checkScalarExact(\"ASCII(_UTF8'\\u5B57')\",\"23383\");\n// bug_start\n  tester.checkScalarExact(\"ASCII(_UTF8'')\",\"937\");\n// bug_end\n  tester.checkNull(\"ASCII(cast(null as varchar(1)))\");\n}\n"}
{"INPUT": "@Test public void testFemaleFather(){\n// bug_start\n  String queryString=\"match (father: $x) isa parentship; $x has gender $g; $g val 'female'; get;\";\n// bug_end\n  GetQuery query=iqb.parse(queryString);\n  List<Answer> answers=query.execute();\n  List<Answer> answers2=genealogyKB.tx().graql().infer(true).<GetQuery>parse(queryString).execute();\n  assertThat(answers,empty());\n  assertThat(answers2,empty());\n}\n"}
{"INPUT": "public String reqAPI(String api,Map<String,String> params,String body,List<String> servers,String method) throws NacosException {\n  params.put(CommonParams.NAMESPACE_ID,getNamespaceId());\n  if (CollectionUtils.isEmpty(servers) && StringUtils.isEmpty(nacosDomain)) {\n    throw new NacosException(NacosException.INVALID_PARAM,\"no server available\");\n  }\n  NacosException exception=new NacosException();\n  if (servers != null && !servers.isEmpty()) {\n    Random random=new Random(System.currentTimeMillis());\n    int index=random.nextInt(servers.size());\n    for (int i=0; i < servers.size(); i++) {\n      String server=servers.get(index);\n      try {\n        return callServer(api,params,body,server,method);\n      }\n catch (      NacosException e) {\n        exception=e;\n        if (NAMING_LOGGER.isDebugEnabled()) {\n          NAMING_LOGGER.debug(\"request {} failed.\",server,e);\n        }\n      }\n      index=(index + 1) % servers.size();\n    }\n  }\n  if (StringUtils.isNotBlank(nacosDomain)) {\n    for (int i=0; i < UtilAndComs.REQUEST_DOMAIN_RETRY_COUNT; i++) {\n      try {\n        return callServer(api,params,body,nacosDomain,method);\n      }\n catch (      NacosException e) {\n        exception=e;\n        if (NAMING_LOGGER.isDebugEnabled()) {\n          NAMING_LOGGER.debug(\"request {} failed.\",nacosDomain,e);\n        }\n      }\n    }\n  }\n  NAMING_LOGGER.error(\"request: {} failed, servers: {}, code: {}, msg: {}\",api,servers,exception.getErrCode(),exception.getErrMsg());\n// bug_start\n  throw new NacosException(exception.getErrCode(),\"failed to req API:/api/\" + api + \" after all servers(\"+ servers+ \") tried: \"+ exception.getMessage());\n// bug_end\n}\n"}
{"INPUT": "private boolean buildDirectoryChunks(String dirName) throws IOException {\n  final StringBuilder sb=new StringBuilder(dirName.length());\n// bug_start\n  final String[] dirs=dirName.split(\"\\\\/\");\n// bug_end\n  boolean success=false;\n  for (  String dir : dirs) {\n    sb.append(dir).append('/');\n    String directory=sb.toString();\n    if (!directory.equals(\"/\")) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Trying to build remote directory by chunk: \" + directory);\n      }\n      success=client.makeDirectory(directory);\n    }\n  }\n  return success;\n}\n"}
{"INPUT": "@Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n  IgniteConfiguration cfg=super.getConfiguration(igniteInstanceName);\n  cfg.setConsistentId(igniteInstanceName);\n// bug_start\n  cfg.setDataStorageConfiguration(new DataStorageConfiguration().setWalMode(WALMode.LOG_ONLY).setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true).setMaxSize(100L * 1024 * 1024)));\n// bug_end\n  cfg.setCacheConfiguration(new CacheConfiguration<>(CACHE_NAME).setAtomicityMode(atomicityMode()).setBackups(2).setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC).setIndexedTypes(Integer.class,Integer.class).setPartitionLossPolicy(PartitionLossPolicy.READ_WRITE_SAFE).setAffinity(new RendezvousAffinityFunction(false,PARTITIONS_CNT)));\n  return cfg;\n}\n"}
{"INPUT": "public ListRepresentation pagedTraverse(String traverserId,TraverserReturnType returnType){\n  Lease lease=leases.getLeaseById(traverserId);\n  if (lease == null) {\n    throw new NotFoundException(String.format(\"The traverser with id [%s] was not found\",traverserId));\n  }\n  PagedTraverser traverser=lease.getLeasedItemAndRenewLease();\n  List<Path> paths=traverser.next();\n  List<Representation> result=new ArrayList<Representation>();\n  if (paths != null) {\n    for (    Path p : paths) {\n      result.add(returnType.toRepresentation(p));\n    }\n  }\n else {\n    leases.remove(traverserId);\n// bug_start\n    throw new NotFoundException(String.format(\"The results for traveser with id [%s] have been fully paged]\",traverserId));\n// bug_end\n  }\n  return new ListRepresentation(returnType.repType,result);\n}\n"}
{"INPUT": "@Test public void testGetServers() throws Exception {\n  ArrayList<Instance> instances=new ArrayList<>();\n  HashMap<String,String> map=new HashMap<>();\n  map.put(\"test-key\",\"test-value\");\n  map.put(\"secure\",\"true\");\n// bug_start\n  instances.add(serviceInstance(serviceName,false,host,port,map));\n// bug_end\n  NacosDiscoveryProperties nacosDiscoveryProperties=mock(NacosDiscoveryProperties.class);\n  NamingService namingService=mock(NamingService.class);\n  when(nacosDiscoveryProperties.namingServiceInstance()).thenReturn(namingService);\n  when(namingService.selectInstances(eq(serviceName),eq(true))).thenReturn(instances);\n  NacosDiscoveryClient discoveryClient=new NacosDiscoveryClient(nacosDiscoveryProperties);\n  List<ServiceInstance> serviceInstances=discoveryClient.getInstances(serviceName);\n  assertThat(serviceInstances.size()).isEqualTo(1);\n  ServiceInstance serviceInstance=serviceInstances.get(0);\n  assertThat(serviceInstance.getServiceId()).isEqualTo(serviceName);\n  assertThat(serviceInstance.getHost()).isEqualTo(host);\n  assertThat(serviceInstance.getPort()).isEqualTo(port);\n  assertThat(serviceInstance.isSecure()).isEqualTo(true);\n  assertThat(serviceInstance.getUri().toString()).isEqualTo(getUri(serviceInstance));\n  assertThat(serviceInstance.getMetadata().get(\"test-key\")).isEqualTo(\"test-value\");\n}\n"}
{"INPUT": "@Override @Nullable public View onCreateView(@NonNull LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){\n  setSubtitle(R.string.title_advanced_manage_certificates);\n  setHasOptionsMenu(true);\n  View view=inflater.inflate(R.layout.fragment_certificates,container,false);\n  rvCertificate=view.findViewById(R.id.rvCertificate);\n  pbWait=view.findViewById(R.id.pbWait);\n  grpReady=view.findViewById(R.id.grpReady);\n  fab=view.findViewById(R.id.fab);\n// bug_start\n  rvCertificate.setHasFixedSize(false);\n// bug_end\n  LinearLayoutManager llm=new LinearLayoutManager(getContext());\n  rvCertificate.setLayoutManager(llm);\n  DividerItemDecoration itemDecorator=new DividerItemDecoration(getContext(),llm.getOrientation());\n  itemDecorator.setDrawable(getContext().getDrawable(R.drawable.divider));\n  rvCertificate.addItemDecoration(itemDecorator);\n  adapter=new AdapterCertificate(this);\n  rvCertificate.setAdapter(adapter);\n  fab.setOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      LocalBroadcastManager lbm=LocalBroadcastManager.getInstance(getContext());\n      lbm.sendBroadcast(new Intent(ActivitySetup.ACTION_IMPORT_CERTIFICATE));\n    }\n  }\n);\n  grpReady.setVisibility(View.GONE);\n  pbWait.setVisibility(View.VISIBLE);\n  return view;\n}\n"}
{"INPUT": "@Override public void start(Stage stage) throws IOException {\n  BitsquareApp.primaryStage=stage;\n  String logPath=Paths.get(env.getProperty(BitsquareEnvironment.APP_DATA_DIR_KEY),\"bitsquare\").toString();\n  Log.setup(logPath);\n  log.info(\"Log files under: \" + logPath);\n  Version.printVersion();\n  Utilities.printSysInfo();\n  Log.setLevel(Level.toLevel(env.getRequiredProperty(CommonOptionKeys.LOG_LEVEL_KEY)));\n  UserThread.setExecutor(null);\n  UserThread.setTimerClass(UITimer.class);\n  Thread.UncaughtExceptionHandler handler=null;\n  Thread.setDefaultUncaughtExceptionHandler(handler);\n  Thread.currentThread().setUncaughtExceptionHandler(handler);\n  if (Utilities.isRestrictedCryptography())   Utilities.removeCryptographyRestrictions();\n  Security.addProvider(new BouncyCastleProvider());\n  shutDownHandler=null;\n  try {\n    bitsquareAppModule=new BitsquareAppModule(env,primaryStage);\n    injector=Guice.createInjector(bitsquareAppModule);\n    injector.getInstance(InjectorViewFactory.class).setInjector(injector);\n    Version.setBtcNetworkId(injector.getInstance(BitsquareEnvironment.class).getBitcoinNetwork().ordinal());\n    if (Utilities.isLinux())     System.setProperty(\"prism.lcdtext\",\"false\");\n    Storage.setDatabaseCorruptionHandler(null);\n    CachingViewLoader viewLoader=injector.getInstance(CachingViewLoader.class);\n    mainView=(MainView)viewLoader.load(MainView.class);\n    mainView.setPersistedFilesCorrupted(corruptedDatabaseFiles);\n    scene=new Scene(mainView.getRoot(),1200,740);\n    Font.loadFont(getClass().getResource(\"/fonts/Verdana.ttf\").toExternalForm(),13);\n    Font.loadFont(getClass().getResource(\"/fonts/VerdanaBold.ttf\").toExternalForm(),13);\n    Font.loadFont(getClass().getResource(\"/fonts/VerdanaItalic.ttf\").toExternalForm(),13);\n    Font.loadFont(getClass().getResource(\"/fonts/VerdanaBoldItalic.ttf\").toExternalForm(),13);\n// bug_start\n    scene.getStylesheets().setAll(\"/io/bitsquare/gui/bitsquare.css\",\"/io/bitsquare/gui/images.css\",\"/io/bitsquare/gui/components/candlestick/CandleStickChart.css\");\n// bug_end\n    SystemTray.create(primaryStage,shutDownHandler);\n    primaryStage.setOnCloseRequest(null);\n    scene.addEventHandler(KeyEvent.KEY_RELEASED,null);\n    primaryStage.setTitle(env.getRequiredProperty(APP_NAME_KEY));\n    primaryStage.setScene(scene);\n    primaryStage.setMinWidth(1190);\n    primaryStage.setMinHeight(620);\n    String iconPath;\n    if (Utilities.isOSX())     iconPath=ImageUtil.isRetina() ? \"/images/window_icon@2x.png\" : \"/images/window_icon.png\";\n else     if (Utilities.isWindows())     iconPath=\"/images/task_bar_icon_windows.png\";\n else     iconPath=\"/images/task_bar_icon_linux.png\";\n    primaryStage.getIcons().add(new Image(getClass().getResourceAsStream(iconPath)));\n    primaryStage.show();\n    if (!Utilities.isCorrectOSArchitecture()) {\n      String osArchitecture=Utilities.getOSArchitecture();\n      new Popup<>().warning(\"You have probably the wrong version installed for the architecture of your computer.\\n\" + \"Your computers architecture is: \" + osArchitecture + \".\\n\"+ \"The Bitsquare binary you installed is: \"+ Utilities.getJVMArchitecture()+ \".\\n\"+ \"Please shut down and re-install the correct version (\"+ osArchitecture+ \").\").show();\n    }\n  }\n catch (  Throwable throwable) {\n    showErrorPopup(throwable,false);\n  }\n}\n"}
{"INPUT": "private static boolean matchPath(String path,String name){\n  List<String> pathSplit=StrUtils.splitSmart(path,'/');\n  List<String> nameSplit=StrUtils.splitSmart(name,'/');\n  for (int i=0; i < nameSplit.size(); i++) {\n    String s=nameSplit.get(i);\n    String ps=pathSplit.size() > i ? pathSplit.get(i) : null;\n    if (ps == null)     return false;\n    if (s.equals(ps))     continue;\n    if (\"*\".equals(ps) && nameSplit.size() == i + 1)     return true;\n    if (\"**\".equals(ps))     return true;\n    return false;\n  }\n// bug_start\n  return true;\n// bug_end\n}\n"}
{"INPUT": "private String buildConsoleURI(String boltURI) throws IncorrectUsage {\n// bug_start\n  Pattern pattern=Pattern.compile(\"bolt\\\\+routing://([^-]+)(-(.+))?.databases.neo4j.io$\");\n// bug_end\n  Matcher matcher=pattern.matcher(boltURI);\n  if (!matcher.matches()) {\n    throw new IncorrectUsage(\"Invalid Bolt URI '\" + boltURI + \"'\");\n  }\n  String databaseId=matcher.group(1);\n  String environment=matcher.group(2);\n  return String.format(\"https://console%s.neo4j.io/v1/databases/%s\",environment == null ? \"\" : environment,databaseId);\n}\n"}
{"INPUT": "public void testMany() throws Exception {\n  createKeystore(\"\",\"foo\",\"1\",\"bar\",\"2\",\"baz\",\"3\");\n  execute(\"foo\",\"baz\");\n  Set<String> settings=loadKeystore(\"\").getSettingNames();\n  assertFalse(settings.contains(\"foo\"));\n  assertFalse(settings.contains(\"baz\"));\n  assertTrue(settings.contains(\"bar\"));\n// bug_start\n  assertEquals(1,settings.size());\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@GET(\"/post/{disscussionId}/comment?start=0&limit=30\") Observable<CommentList> getDisscussionComments(@Path(\"disscussionId\") String disscussionId,@Query(\"start\") String start,@Query(\"limit\") String limit);\n// bug_end\n"}
{"INPUT": "@Test public void testCantFindModule(Path base) throws Exception {\n  Path src=base.resolve(\"src\");\n  Path src_m1=src.resolve(\"m1x\");\n  tb.writeJavaFiles(src_m1,\"module m1x { }\");\n  Path misc=base.resolve(\"misc\");\n  tb.writeJavaFiles(misc,\"package p; class C { }\");\n  Path classes=base.resolve(\"classes\");\n  tb.createDirectories(classes);\n  String log=new JavacTask(tb).options(\"-XDrawDiagnostics\",\"--module-source-path\",src.toString()).outdir(classes).files(join(findJavaFiles(src),findJavaFiles(misc))).run(Task.Expect.FAIL).writeAll().getOutput(Task.OutputKind.DIRECT);\n// bug_start\n  if (!log.contains(\"C.java:1:1: compiler.err.unnamed.pkg.not.allowed.named.modules\"))   throw new Exception(\"expected output not found\");\n// bug_end\n}\n"}
{"INPUT": "void findMissingKeys(Set<String> codeStrings,Set<String> resourceKeys){\n  for (  String cs : codeStrings) {\n    if (cs.matches(\"[A-Za-z][^.]*\\\\..*\")) {\n      if (cs.matches(\".*\\\\.java\"))       continue;\n// bug_start\n      if (cs.matches(\"(com|java|javax|sun)\\\\.[A-Za-z.]+\"))       continue;\n// bug_end\n      if (noResourceRequired.contains(cs))       continue;\n      if (hasMatch(resourceKeys,cs))       continue;\n      error(\"no match for \\\"\" + cs + \"\\\"\");\n    }\n  }\n}\n"}
{"INPUT": "public NearCacheConfig setInMemoryFormat(InMemoryFormat inMemoryFormat){\n// bug_start\n  this.inMemoryFormat=isNotNull(inMemoryFormat,\"In-Memory format cannot be null !\");\n// bug_end\n  return this;\n}\n"}
{"INPUT": "@Test public void testSizeInMemory(){\n  Assume.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo(\"4.0.0\") > 0);\n  RBucket<Integer> al=redisson.getBucket(\"test\");\n  al.set(1234);\n// bug_start\n  assertThat(al.sizeInMemory()).isEqualTo(56);\n// bug_end\n}\n"}
{"INPUT": "protected void setUp() throws Exception {\n  Assert.assertEquals(0,DruidDataSourceStatManager.getInstance().getDataSourceList().size());\n  driver=new MockDriver(){\n  }\n;\n  dataSource=new DruidDataSource();\n// bug_start\n  dataSource.setUrl(\"jdbc:mock:xxx\");\n// bug_end\n  dataSource.setDriver(driver);\n  dataSource.setInitialSize(1);\n  dataSource.setMaxActive(2);\n  dataSource.setMaxIdle(2);\n  dataSource.setMinIdle(1);\n  dataSource.setMinEvictableIdleTimeMillis(300 * 1000);\n  dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000);\n  dataSource.setTestWhileIdle(true);\n  dataSource.setTestOnBorrow(false);\n  dataSource.setValidationQuery(\"SELECT 1\");\n  dataSource.setFilters(\"trace\");\n  filter=(TraceFilter)dataSource.getProxyFilters().get(0);\n  JdbcStatContext statContext=new JdbcStatContext();\n  statContext.setTraceEnable(true);\n  JdbcStatManager.getInstance().setStatContext(statContext);\n}\n"}
{"INPUT": "public static String formatHtml(String html){\n  if (TextUtils.isEmpty(html))   return html;\n// bug_start\n  return html.replaceAll(\"(?i)<(br[\\\\s/]*|/*p.*?|/*div.*?)>\",\"\\n\").replaceAll(\"<[script>]*.*?>|&nbsp;\",\"\").replaceAll(\"\\\\s*\\\\n+\\\\s*\",\"\\n\").replaceAll(\"^[\\\\n\\\\s]+\",\"\").replaceAll(\"[\\\\n\\\\s]*$\",\"\");\n// bug_end\n}\n"}
{"INPUT": "private void testIfEdgeSuccessfullyAdded(String node1,String node2,String edgeName,String value) throws ExecutionException, InterruptedException {\n  Set<FlowEdge> edgeSet=this.flowGraph.getEdges(node1);\n  Assert.assertEquals(edgeSet.size(),1);\n  FlowEdge flowEdge=edgeSet.iterator().next();\n// bug_start\n  Assert.assertEquals(flowEdge.getId(),Joiner.on(\":\").join(node1,node2,edgeName));\n// bug_end\n  Assert.assertEquals(flowEdge.getSrc(),node1);\n  Assert.assertEquals(flowEdge.getDest(),node2);\n  Assert.assertEquals(flowEdge.getExecutors().get(0).getConfig().get().getString(\"specStore.fs.dir\"),\"/tmp1\");\n  Assert.assertEquals(flowEdge.getExecutors().get(0).getConfig().get().getString(\"specExecInstance.capabilities\"),\"s1:d1\");\n  Assert.assertEquals(flowEdge.getExecutors().get(0).getClass().getSimpleName(),\"InMemorySpecExecutor\");\n  Assert.assertEquals(flowEdge.getExecutors().get(1).getConfig().get().getString(\"specStore.fs.dir\"),\"/tmp2\");\n  Assert.assertEquals(flowEdge.getExecutors().get(1).getConfig().get().getString(\"specExecInstance.capabilities\"),\"s2:d2\");\n  Assert.assertEquals(flowEdge.getExecutors().get(1).getClass().getSimpleName(),\"InMemorySpecExecutor\");\n  Assert.assertEquals(flowEdge.getConfig().getString(\"key1\"),value);\n}\n"}
{"INPUT": "@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){\n  if (oldVersion < newVersion) {\n    if (oldVersion < 31) {\n      handle314AriaUpdate(db);\n    }\n else     if (oldVersion < 45) {\n      handle360AriaUpdate(db);\n    }\n// bug_start\n else     if (oldVersion < 48) {\n// bug_end\n      handle365Update(db);\n    }\n else {\n      handleDbUpdate(db,null,null);\n    }\n  }\n}\n"}
{"INPUT": "@Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n  IgniteConfiguration cfg=super.getConfiguration(gridName);\n  cfg.setClientMode(client);\n  cfg.setConsistentId(\"NODE$\" + gridName.charAt(gridName.length() - 1));\n  cfg.setFailureHandler(new StopNodeFailureHandler());\n// bug_start\n  DataStorageConfiguration memCfg=new DataStorageConfiguration().setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(200 * 1024 * 1024).setPersistenceEnabled(true)).setWalMode(WALMode.LOG_ONLY).setWalSegmentSize(512 * 1024);\n// bug_end\n  cfg.setDataStorageConfiguration(memCfg);\n  CacheConfiguration ccfg1=new CacheConfiguration();\n  ccfg1.setName(\"cache1\");\n  ccfg1.setBackups(1);\n  ccfg1.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL);\n  ccfg1.setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC);\n  ccfg1.setAffinity(new RendezvousAffinityFunction(false,32));\n  cfg.setCacheConfiguration(ccfg1);\n  return cfg;\n}\n"}
{"INPUT": "@Override public DatabaseDataType toDatabaseDataType(Database database){\n  if (database instanceof MSSQLDatabase) {\n// bug_start\n    return new DatabaseDataType(\"FLOAT\");\n// bug_end\n  }\n  if (database instanceof MySQLDatabase) {\n    return new DatabaseDataType(\"DOUBLE\",getParameters());\n  }\n  if (database instanceof DB2Database || database instanceof DerbyDatabase || database instanceof HsqlDatabase) {\n    return new DatabaseDataType(\"DOUBLE\");\n  }\n  if (database instanceof OracleDatabase) {\n    return new DatabaseDataType(\"FLOAT\",24);\n  }\n  if (database instanceof PostgresDatabase) {\n    return new DatabaseDataType(\"DOUBLE PRECISION\");\n  }\n  if (database instanceof InformixDatabase) {\n    return new DatabaseDataType(\"DOUBLE PRECISION\");\n  }\n  if (database instanceof FirebirdDatabase) {\n    return new DatabaseDataType(\"DOUBLE PRECISION\");\n  }\n  return super.toDatabaseDataType(database);\n}\n"}
{"INPUT": "@Test public void computeSyntaxHighlightingOnBigFiles() throws IOException {\n  File baseDir=temp.newFolder();\n  File srcDir=new File(baseDir,\"src\");\n  srcDir.mkdir();\n  int nbFiles=100;\n  int ruleCount=100000;\n  int nblines=1000;\n  int linesize=ruleCount / nblines;\n  for (int nb=1; nb <= nbFiles; nb++) {\n    File xooFile=new File(srcDir,\"sample\" + nb + \".xoo\");\n    File xoohighlightingFile=new File(srcDir,\"sample\" + nb + \".xoo.highlighting\");\n    FileUtils.write(xooFile,StringUtils.repeat(StringUtils.repeat(\"a\",linesize) + \"\\n\",nblines));\n    StringBuilder sb=new StringBuilder(16 * ruleCount);\n    for (int i=0; i < ruleCount; i++) {\n      sb.append(i).append(\":\").append(i + 1).append(\":s\\n\");\n    }\n    FileUtils.write(xoohighlightingFile,sb.toString());\n  }\n  SonarScanner scanner=SonarScanner.create().setProperties(\"sonar.projectKey\",\"highlighting\",\"sonar.projectName\",\"highlighting\",\"sonar.projectVersion\",\"1.0\",\"sonar.sources\",\"src\",\"sonar.showProfiling\",\"true\");\n  scanner.setEnvironmentVariable(\"SONAR_RUNNER_OPTS\",\"-Xmx512m -server\").setProjectDir(baseDir);\n  BuildResult result=orchestrator.executeBuild(scanner);\n  System.out.println(\"Total time: \" + MavenLogs.extractTotalTime(result.getLogs()));\n  perfRule.assertDurationAround(MavenLogs.extractTotalTime(result.getLogs()),25700L);\n  Properties prof=readProfiling(baseDir,\"highlighting\");\n// bug_start\n  perfRule.assertDurationAround(Long.valueOf(prof.getProperty(\"Xoo Highlighting Sensor\")),9700L);\n// bug_end\n}\n"}
{"INPUT": "@Override public DynamicResultSet inspect(PersistencePackage persistencePackage,DynamicEntityDao dynamicEntityDao,InspectHelper helper) throws ServiceException {\n  String ceilingEntityFullyQualifiedClassname=persistencePackage.getCeilingEntityFullyQualifiedClassname();\n  try {\n// bug_start\n    String structuredContentTypeId=persistencePackage.getCustomCriteria()[1];\n// bug_end\n    StructuredContentType structuredContentType=structuredContentService.findStructuredContentTypeById(Long.valueOf(structuredContentTypeId));\n    ClassMetadata metadata=new ClassMetadata();\n    metadata.setCeilingType(StructuredContentType.class.getName());\n    ClassTree entities=new ClassTree(StructuredContentTypeImpl.class.getName());\n    metadata.setPolymorphicEntities(entities);\n    Property[] properties=dynamicFieldUtil.buildDynamicPropertyList(structuredContentType.getStructuredContentFieldTemplate().getFieldGroups(),StructuredContentTypeImpl.class);\n    metadata.setProperties(properties);\n    DynamicResultSet results=new DynamicResultSet(metadata);\n    return results;\n  }\n catch (  Exception e) {\n    throw new ServiceException(\"Unable to perform inspect for entity: \" + ceilingEntityFullyQualifiedClassname,e);\n  }\n}\n"}
{"INPUT": "@Override public List<AgentStat> scanAgentStatList(String agentId,Range range){\n  List<AgentStat> AgentStatList=new LinkedList<AgentStat>();\n  for (int i=0; i < 36; i++) {\n    AgentStatCpuLoadBo.Builder cpuLoadBoBuilder=new AgentStatCpuLoadBo.Builder(\"AGETNT_NAME\",0L,1L);\n// bug_start\n    cpuLoadBoBuilder.jvmCpuLoad(60);\n// bug_end\n    AgentStatCpuLoadBo cpuLoadBo=cpuLoadBoBuilder.build();\n    AgentStatMemoryGcBo.Builder memoryGcBobuilder=new AgentStatMemoryGcBo.Builder(\"AGETNT_NAME\",0L,1L);\n    AgentStatMemoryGcBo memoryGcBo=memoryGcBobuilder.build();\n    AgentStat stat=new AgentStat();\n    stat.setCpuLoad(cpuLoadBo);\n    stat.setMemoryGc(memoryGcBo);\n    AgentStatList.add(stat);\n  }\n  return AgentStatList;\n}\n"}
{"INPUT": "@Test(timeout=100000) public void testKeyOwnerDies() throws Exception {\n  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(3);\n  final Config config=new Config();\n  final HazelcastInstance keyOwner=nodeFactory.newHazelcastInstance(config);\n  final HazelcastInstance instance1=nodeFactory.newHazelcastInstance(config);\n  final HazelcastInstance instance2=nodeFactory.newHazelcastInstance(config);\n  final int key=generateKeyOwnedBy(keyOwner);\n  final ILock lock1=instance1.getLock(key);\n  lock1.lock();\n  final CountDownLatch latch=new CountDownLatch(1);\n  new Thread(new Runnable(){\n    public void run(){\n      final ILock lock=instance2.getLock(key);\n      lock.lock();\n      latch.countDown();\n    }\n  }\n).start();\n  keyOwner.getLifecycleService().shutdown();\n  Assert.assertTrue(lock1.isLocked());\n  Assert.assertTrue(lock1.tryLock());\n  lock1.unlock();\n  lock1.unlock();\n// bug_start\n  Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));\n// bug_end\n}\n"}
{"INPUT": "@Test void convertFromJsonToObjectTest() throws IOException {\n  String content=FileUtils.readFileToString(new File(\"./src/test/resources/stats/statistic_data.json\"),StandardCharsets.UTF_8);\n  List<StatisticsJsonStringObject> statsDTO=SerializationUtils.deserializeJson(content,null);\n// bug_start\n  assertThat(statsDTO.size()).isEqualTo(3);\n// bug_end\n}\n"}
{"INPUT": "private String getNotifyOptions(RedisConnection connection){\n  try {\n    Properties config=connection.getConfig(CONFIG_NOTIFY_KEYSPACE_EVENTS);\n    if (config.isEmpty()) {\n      return \"\";\n    }\n    return config.getProperty(config.stringPropertyNames().iterator().next());\n  }\n catch (  InvalidDataAccessApiUsageException ex) {\n// bug_start\n    throw new IllegalStateException(\"Unable to configure Redis to keyspace notifications. See http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent\",ex);\n// bug_end\n  }\n}\n"}
{"INPUT": "public final TokenStream tokenStream(String fieldName,Reader reader){\n  if (fieldName == null)   throw new IllegalArgumentException(\"fieldName must not be null\");\n// bug_start\n  if (reader == null)   throw new IllegalArgumentException(\"readermust not be null\");\n// bug_end\n  TokenStream result=new StandardTokenizer(reader);\n  result=new StandardFilter(result);\n  result=new StopFilter(result,stoptable);\n  result=new FrenchStemFilter(result,excltable);\n  result=new LowerCaseFilter(result);\n  return result;\n}\n"}
{"INPUT": "@Test public void testA() throws Exception {\n  startOneNewExecutorList();\n  Thread.sleep(1000);\n  SimpleJavaJob.lock.set(false);\n  JobConfiguration jobConfiguration=new JobConfiguration(\"testA\");\n  jobConfiguration.setCron(\"0/2 * * * * ?\");\n  jobConfiguration.setJobType(JobType.JAVA_JOB.toString());\n  jobConfiguration.setJobClass(SimpleJavaJob.class.getCanonicalName());\n  jobConfiguration.setShardingTotalCount(1);\n  jobConfiguration.setShardingItemParameters(\"0=0\");\n  addJob(jobConfiguration);\n// bug_start\n  Thread.sleep(1000);\n// bug_end\n  assertThat(SimpleJavaJob.enabled.get()).isFalse();\n  enableJob(jobConfiguration.getJobName());\n  Thread.sleep(1000);\n  assertThat(SimpleJavaJob.enabled.get()).isTrue();\n  disableJob(jobConfiguration.getJobName());\n  Thread.sleep(1000);\n  assertThat(SimpleJavaJob.enabled.get()).isFalse();\n  removeJob(jobConfiguration.getJobName());\n  Thread.sleep(1000);\n  forceRemoveJob(jobConfiguration.getJobName());\n}\n"}
{"INPUT": "private static String substitute(String text){\n// bug_start\n  return DECIMAL_COMMA_PATTERN.matcher(text).replaceAll(\"$1\" + DECIMAL_COMMA_SUBST + \"2\");\n// bug_end\n}\n"}
{"INPUT": "@Test public void testIllegalAttemptToApproveWithoutUsingAuthorizationRequest() throws Exception {\n  String cookie=loginAndGrabCookie();\n  HttpHeaders headers=new HttpHeaders();\n  headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));\n  headers.set(\"Cookie\",cookie);\n// bug_start\n  String authorizeUrl=getAuthorizeUrl(\"my-less-trusted-client\",\"http://anywhere.com\",\"read\");\n// bug_end\n  authorizeUrl=authorizeUrl + \"&user_oauth_approval=true\";\n  ResponseEntity<Void> response=serverRunning.postForStatus(authorizeUrl,headers,new LinkedMultiValueMap<String,String>());\n  assertEquals(HttpStatus.BAD_REQUEST,response.getStatusCode());\n}\n"}
{"INPUT": "public MultimapAggregationFunction(){\n// bug_start\n  super(NAME,ImmutableList.of(comparableTypeParameter(\"K\"),typeParameter(\"V\")),\"map<K,array<V>>\",ImmutableList.of(\"K\",\"V\"));\n// bug_end\n}\n"}
{"INPUT": "@Test public void testCreateTable() throws Exception {\n// bug_start\n  String queryStr=\"CREATE TABLE users (usertime bigint, userid varchar, regionid varchar, gender varchar) \" + \"WITH (kafka_topic = 'users_topic', value_format='json');\";\n// bug_end\n  Statement statement=KSQL_PARSER.buildAst(queryStr,metaStore).get(0);\n  Assert.assertTrue(\"testRegisterTopic failed.\",statement instanceof CreateTable);\n  CreateTable createTable=(CreateTable)statement;\n  Assert.assertTrue(\"testCreateTable failed.\",createTable.getName().toString().equalsIgnoreCase(\"USERS\"));\n  Assert.assertTrue(\"testCreateTable failed.\",createTable.getElements().size() == 4);\n  Assert.assertTrue(\"testCreateTable failed.\",createTable.getElements().get(0).getName().toString().equalsIgnoreCase(\"usertime\"));\n  Assert.assertTrue(\"testCreateTable failed.\",createTable.getProperties().get(DdlConfig.KAFKA_TOPIC_NAME_PROPERTY).toString().equalsIgnoreCase(\"'users_topic'\"));\n  Assert.assertTrue(\"testCreateTable failed.\",createTable.getProperties().get(DdlConfig.VALUE_FORMAT_PROPERTY).toString().equalsIgnoreCase(\"'json'\"));\n}\n"}
{"INPUT": "private void processClientAcknowledgement(Element ack){\n  if (isEnabled()) {\n    if (ack.attribute(\"h\") != null) {\n      final long h=Long.valueOf(ack.attributeValue(\"h\"));\n      Log.debug(\"Received acknowledgement from client: h={}\",h);\nsynchronized (this) {\n        if (!unacknowledgedServerStanzas.isEmpty() && h > unacknowledgedServerStanzas.getLast().x) {\n// bug_start\n          Log.warn(\"Client acknowledges stanzas that we didn't sent! Client Ack h: {}, our last stanza: {}\",h,unacknowledgedServerStanzas.getLast().x);\n// bug_end\n        }\n        clientProcessedStanzas=h;\n        Log.trace(\"Before processing client Ack (h={}): {} unacknowledged stanzas.\",h,unacknowledgedServerStanzas.size());\n        while (!unacknowledgedServerStanzas.isEmpty() && unacknowledgedServerStanzas.getFirst().x <= h) {\n          unacknowledgedServerStanzas.removeFirst();\n        }\n        final int maxUnacked=getMaximumUnacknowledgedStanzas();\n        final boolean clientHadRollOver=h < maxUnacked && !unacknowledgedServerStanzas.isEmpty() && unacknowledgedServerStanzas.getLast().x > mask - maxUnacked;\n        if (clientHadRollOver) {\n          Log.info(\"Client rolled over 'h'. Purging high-numbered unacknowledged stanzas.\");\n          while (!unacknowledgedServerStanzas.isEmpty() && unacknowledgedServerStanzas.getLast().x > mask - maxUnacked) {\n            unacknowledgedServerStanzas.removeLast();\n          }\n        }\n        Log.trace(\"After processing client Ack (h={}): {} unacknowledged stanzas.\",h,unacknowledgedServerStanzas.size());\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Test public void deleteJoin(){\n  SqlInfo sqlInfo=tenantSqlParser.optimizeSql(null,\"DELETE gc FROM guide_category AS gc LEFT JOIN guide AS g ON g.id_guide = gc.id_guide WHERE g.title IS NULL LIMIT 5\");\n// bug_start\n  Assert.assertEquals(\"DELETE gc FROM guide_category AS gc LEFT JOIN guide AS g ON g.id_guide = gc.id_guide WHERE gc.tenant_id = 1000 LIMIT 5\",sqlInfo.getSql());\n// bug_end\n}\n"}
{"INPUT": "@Override protected void onCreate(@Nullable Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  this.mContext=this;\n  rootView=getLayoutInflater().from(this).inflate(R.layout.activity_h,null);\n  setContentView(rootView);\n  rootView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){\n    @Override public void onGlobalLayout(){\n      int heightDiff=rootView.getRootView().getHeight() - rootView.getHeight();\n      if (heightDiff > 100) {\n        rootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);\n      }\n else {\n        rootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);\n      }\n    }\n  }\n);\n  PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);\n  wakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,\"liveTAG\");\n  wakeLock.acquire();\n  list=new ArrayList<VideoijkBean>();\n  String url1=getLocalVideoPath(\"my_video.mp4\");\n  if (!new File(url1).exists()) {\n    url1=\"http://9890.vod.myqcloud.com/9890_4e292f9a3dd011e6b4078980237cc3d3.f20.mp4\";\n  }\n  String url2=\"http://9890.vod.myqcloud.com/9890_4e292f9a3dd011e6b4078980237cc3d3.f30.mp4\";\n  VideoijkBean m1=new VideoijkBean();\n  m1.setStream(\"\");\n  m1.setUrl(url1);\n  VideoijkBean m2=new VideoijkBean();\n  m2.setStream(\"\");\n  m2.setUrl(url2);\n  list.add(m1);\n  list.add(m2);\n  player=new PlayerView(this,rootView){\n    @Override public PlayerView toggleProcessDurationOrientation(){\n      hideSteam(getScreenOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n      return setProcessDurationOrientation(getScreenOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT ? PlayStateParams.PROCESS_PORTRAIT : PlayStateParams.PROCESS_LANDSCAPE);\n    }\n    @Override public PlayerView setPlaySource(    List<VideoijkBean> list){\n      return super.setPlaySource(list);\n    }\n  }\n.setTitle(\"\").setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT).setScaleType(PlayStateParams.fillparent).forbidTouch(false).hideSteam(true).hideCenterPlayer(true).showThumbnail(new OnShowThumbnailListener(){\n    @Override public void onShowThumbnail(    ImageView ivThumbnail){\n      Glide.with(mContext).load(\"http://pic2.nipic.com/20090413/406638_125424003_2.jpg\").placeholder(R.color.cl_default).error(R.color.cl_error).into(ivThumbnail);\n    }\n  }\n// bug_start\n).setPlaySource(list).setChargeTie(true,5).startPlay();\n// bug_end\n}\n"}
{"INPUT": "public void configure() throws Exception {\n// bug_start\n  from(\"mina2:tcp://127.0.0.1:\" + getPort() + \"?sync=true&codec=#hl7codec\").unmarshal().hl7().process(new Processor(){\n// bug_end\n    public void process(    Exchange exchange) throws Exception {\n      Message input=exchange.getIn().getBody(Message.class);\n      Message response=input.generateACK();\n      exchange.getOut().setBody(response);\n      Thread.sleep(50);\n    }\n  }\n).to(\"mock:result\");\n}\n"}
{"INPUT": "private KafkaLog4jAppender createKafkaAppender() throws UndefinedPropertyException {\n  KafkaLog4jAppender kafkaProducer=new KafkaLog4jAppender();\n// bug_start\n  kafkaProducer.setSyncSend(true);\n// bug_end\n  kafkaProducer.setBrokerList(azkabanProps.getString(ServerProperties.AZKABAN_SERVER_LOGGING_KAFKA_BROKERLIST));\n  kafkaProducer.setTopic(azkabanProps.getString(ServerProperties.AZKABAN_SERVER_LOGGING_KAFKA_TOPIC));\n  JSONObject layout=new JSONObject();\n  layout.put(\"category\",\"%c{1}\");\n  layout.put(\"level\",\"%p\");\n  layout.put(\"message\",\"%m\");\n  layout.put(\"projectname\",props.getString(FlowProperties.AZKABAN_FLOW_PROJECT_NAME));\n  layout.put(\"flowid\",props.getString(FlowProperties.AZKABAN_FLOW_FLOW_ID));\n  layout.put(\"jobid\",this.jobId);\n  layout.put(\"submituser\",props.getString(FlowProperties.AZKABAN_FLOW_SUBMIT_USER));\n  layout.put(\"execid\",props.getString(FlowProperties.AZKABAN_FLOW_EXEC_ID));\n  layout.put(\"projectversion\",props.getString(FlowProperties.AZKABAN_FLOW_PROJECT_VERSION));\n  layout.put(\"logsource\",\"userJob\");\n  kafkaProducer.setLayout(new PatternLayoutEscaped(layout.toString()));\n  kafkaProducer.activateOptions();\n  flowLogger.info(\"Created kafka appender for \" + this.jobId);\n  return kafkaProducer;\n}\n"}
{"INPUT": "@Test public void shouldReturnErroneousProperty7CheckResultIfGenFails(){\n// bug_start\n  final Arbitrary<Object> failingGen=Gen.fail(\"woops\").arbitrary();\n// bug_end\n  final CheckResult result=new Property(\"test\").forAll(failingGen,OBJECTS,OBJECTS,OBJECTS,OBJECTS,OBJECTS,OBJECTS).suchThat(null).check();\n  assertThat(result.isErroneous()).isTrue();\n}\n"}
{"INPUT": "private void initViewPager(){\n  if (mViewPager != null && this.equals(mViewPager.getParent())) {\n    this.removeView(mViewPager);\n    mViewPager=null;\n  }\n  mViewPager=new XBannerViewPager(getContext());\n  mViewPager.setAdapter(new XBannerPageAdapter());\n  mViewPager.addOnPageChangeListener(this);\n  mViewPager.setOverScrollMode(mSlideScrollMode);\n  mViewPager.setIsAllowUserScroll(mIsAllowUserScroll);\n  mViewPager.setPageTransformer(true,BasePageTransformer.getPageTransformer(mTransformer));\n  setPageChangeDuration(mPageChangeDuration);\n  LayoutParams layoutParams=new LayoutParams(RMP,RMP);\n  if (mIsClipChildrenMode) {\n    mViewPager.setClipChildren(false);\n// bug_start\n    if (!(mDatas.get(0) instanceof Integer) && mDatas.size() > 3) {\n// bug_end\n      mViewPager.setOffscreenPageLimit(3);\n    }\n    mViewPager.setPageMargin(mViewPagerMargin);\n    setClipChildren(false);\n    layoutParams.leftMargin=mClipChildrenLeftRightMargin;\n    layoutParams.rightMargin=mClipChildrenLeftRightMargin;\n    layoutParams.topMargin=mClipChildrenTopBottomMargin;\n    layoutParams.bottomMargin=mClipChildrenTopBottomMargin;\n    setPageTransformer(Transformer.Scale);\n  }\n  addView(mViewPager,0,layoutParams);\n  if (!mIsOneImg && mIsAutoPlay && getRealCount() != 0) {\n    mViewPager.setAutoPlayDelegate(this);\n    int zeroItem=Integer.MAX_VALUE / 2 - (Integer.MAX_VALUE / 2) % getRealCount();\n    mViewPager.setCurrentItem(zeroItem,false);\n    startAutoPlay();\n  }\n else {\n    if (mIsHandLoop && getRealCount() != 0) {\n      int zeroItem=Integer.MAX_VALUE / 2 - (Integer.MAX_VALUE / 2) % getRealCount();\n      mViewPager.setCurrentItem(zeroItem,false);\n    }\n    switchToPoint(0);\n  }\n}\n"}
{"INPUT": "@Override public TGetColumnsResp body() throws HiveClientException {\n  TGetColumnsReq req=new TGetColumnsReq(session);\n  req.setSchemaName(db);\n  req.setTableName(table);\n  req.setColumnName(finalLike);\n  try {\n    return connection.getClient().GetColumns(req);\n  }\n catch (  TException e) {\n// bug_start\n    throw new HiveClientException(\"Unable to get table columns\",e);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Test public void testSetup(){\n  assertEquals(\"We have all the blocks via GameData\",236,Block.REGISTRY.getKeys().size());\n// bug_start\n  assertEquals(\"We have all the items via GameData\",391,Item.REGISTRY.getKeys().size());\n// bug_end\n  final IForgeRegistry<Block> blocks=PersistentRegistryManager.findRegistry(Blocks.AIR);\n  assertEquals(\"We have the right blocks for a block\",blocks,Block.REGISTRY);\n  Block bl=blocks.getValue(new ResourceLocation(\"minecraft:air\"));\n  assertEquals(\"We got air when we asked for it\",Blocks.AIR,bl);\n  Block blch=blocks.getValue(new ResourceLocation(\"minecraft:cheese\"));\n  assertEquals(\"We got air when we asked for cheese\",Blocks.AIR,blch);\n  final IForgeRegistry<Item> items=PersistentRegistryManager.findRegistry(Items.BED);\n  assertEquals(\"We have the right items for an item\",items,Item.REGISTRY);\n  Item it=items.getValue(new ResourceLocation(\"minecraft:bed\"));\n  assertEquals(\"We got a bed item when we asked for it\",Items.BED,it);\n  Item none=items.getValue(new ResourceLocation(\"minecraft:cheese\"));\n  assertEquals(\"We got nothing (items) when we asked for cheese\",null,none);\n}\n"}
{"INPUT": "@Override public void run(Transaction tx,Key userKey,String... args){\n  Entity user=tx.get(userKey);\n  if (user == null) {\n// bug_start\n    System.out.println(\"Nothing to delete, user does not exists.\");\n// bug_end\n    return;\n  }\n  Query<Key> query=Query.keyQueryBuilder().namespace(NAMESPACE).kind(COMMENT_KIND).filter(PropertyFilter.hasAncestor(userKey)).build();\n  QueryResults<Key> comments=tx.run(query);\n  int count=0;\n  while (comments.hasNext()) {\n    tx.delete(comments.next());\n    count++;\n  }\n  tx.delete(userKey);\n  System.out.printf(\"Deleting user '%s' and %d comment[s].%n\",userKey.name(),count);\n}\n"}
{"INPUT": "public void testParsesEs6BooleansStrict() throws IOException {\n  String mapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\").startObject(\"properties\").startObject(\"field\").field(\"type\",\"boolean\").endObject().endObject().endObject().endObject());\n  DocumentMapper defaultMapper=parser.parse(\"type\",new CompressedXContent(mapping));\n  BytesReference source=BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field(\"field\",randomFrom(\"off\",\"no\",\"0\",\"on\",\"yes\",\"1\")).endObject());\n  MapperParsingException ex=expectThrows(MapperParsingException.class,null);\n// bug_start\n  assertEquals(\"failed to parse field [field] of type [boolean]\",ex.getMessage());\n// bug_end\n}\n"}
{"INPUT": "public Request<DeleteVpnConnectionRequest> marshall(DeleteVpnConnectionRequest deleteVpnConnectionRequest){\n  Request<DeleteVpnConnectionRequest> request=new DefaultRequest<DeleteVpnConnectionRequest>(deleteVpnConnectionRequest,\"AmazonEC2\");\n  request.addParameter(\"Action\",\"DeleteVpnConnection\");\n// bug_start\n  request.addParameter(\"Version\",\"2010-08-31\");\n// bug_end\n  if (deleteVpnConnectionRequest != null) {\n    if (deleteVpnConnectionRequest.getVpnConnectionId() != null) {\n      request.addParameter(\"VpnConnectionId\",StringUtils.fromString(deleteVpnConnectionRequest.getVpnConnectionId()));\n    }\n  }\n  return request;\n}\n"}
{"INPUT": "@Test public void testConsumerMoreThanChannel() throws IllegalAccessException, InterruptedException {\n  final DataCarrier<SampleData> carrier=new DataCarrier<SampleData>(2,100);\n  for (int i=0; i < 200; i++) {\n    Assert.assertTrue(carrier.produce(new SampleData().setName(\"data\" + i)));\n  }\n  SampleConsumer consumer=new SampleConsumer();\n  carrier.consume(SampleConsumer.class,5);\n  Thread.sleep(2000);\n  List<SampleData> result=new ArrayList<SampleData>();\n  BUFFER.drainTo(result);\n  Assert.assertEquals(200,result.size());\n  HashSet<Integer> consumerCounter=new HashSet<Integer>();\n  for (  SampleData data : result) {\n    consumerCounter.add(data.getIntValue());\n  }\n// bug_start\n  Assert.assertEquals(5,consumerCounter.size());\n// bug_end\n}\n"}
{"INPUT": "void write(PrintWriter out){\n  int max=-1;\n  int maxIndex=-1;\n  int index=0;\n  for (  Set<String> c : columnContents) {\n    if (c.size() > max || c.size() == max && index == nameColumn) {\n      max=c.size();\n      maxIndex=index;\n    }\n    index++;\n  }\n  boolean updateEndTd=false;\n  Pattern styleAttr=Pattern.compile(\"(?<before>.*style=\\\")(?<style>[^\\\"]*)(?<after>\\\".*)\");\n  for (  Entry e : entries) {\n    if (simple && e.column == maxIndex) {\n      String attrs=e.html.substring(3,e.html.length() - 1);\n      out.write(\"<th\");\n      Matcher m=styleAttr.matcher(attrs);\n      if (m.matches()) {\n        out.write(m.group(\"before\"));\n        out.write(\"font-weight: normal; \");\n        String style=m.group(\"style\");\n        if (!style.contains(\"text-align\")) {\n          out.write(\"text-align: left; \");\n        }\n        out.write(style);\n        out.write(m.group(\"after\"));\n      }\n else {\n// bug_start\n        out.write(\" style=\\\"font-weight: normal; text-align:left\\\"; \");\n// bug_end\n        out.write(attrs);\n      }\n      out.write(\" scope=\\\"row\\\"\");\n      out.write(\">\");\n      updateEndTd=true;\n    }\n else     if (updateEndTd && e.html.equalsIgnoreCase(\"</td>\")) {\n      out.write(\"</th>\");\n      updateEndTd=false;\n    }\n else {\n      out.write(e.html);\n      if (updateEndTd && e.html.regionMatches(true,0,\"<td\",0,3)) {\n        updateEndTd=false;\n      }\n    }\n  }\n}\n"}
{"INPUT": "public static void generate() throws IOException {\n  List<MetricKey> defaultKeys=new ArrayList<>(MetricKey.allMetricKeys());\n  Collections.sort(defaultKeys);\n  String homeDir=new InstancedConfiguration(ConfigurationUtils.defaults()).get(PropertyKey.HOME);\n  Map<String,String> metricTypeMap=new HashMap<>();\n  for (  MetricsSystem.InstanceType type : MetricsSystem.InstanceType.values()) {\n    String typeStr=type.toString();\n    String category=typeStr.toLowerCase();\n    metricTypeMap.put(typeStr,category);\n  }\n  try (Closer closer=Closer.create()){\n    Map<FileWriterKey,FileWriter> fileWriterMap=new HashMap<>();\n    String csvFolder=PathUtils.concatPath(homeDir,CSV_FILE_DIR);\n    String ymlFolder=PathUtils.concatPath(homeDir,YML_FILE_DIR);\n    FileWriter csvFileWriter;\n    FileWriter ymlFileWriter;\n    for (    String category : CATEGORIES) {\n      csvFileWriter=new FileWriter(PathUtils.concatPath(csvFolder,category + \"-metrics.\" + CSV_SUFFIX));\n      csvFileWriter.append(CSV_FILE_HEADER + \"\\n\");\n      ymlFileWriter=new FileWriter(PathUtils.concatPath(ymlFolder,category + \"-metrics.\" + YML_SUFFIX));\n      fileWriterMap.put(new FileWriterKey(category,CSV_SUFFIX),csvFileWriter);\n      fileWriterMap.put(new FileWriterKey(category,YML_SUFFIX),ymlFileWriter);\n      closer.register(csvFileWriter);\n      closer.register(ymlFileWriter);\n    }\n    for (    MetricKey metricKey : defaultKeys) {\n      String key=metricKey.toString();\n      String[] components=key.split(\"\\\\.\");\n      if (components.length < 2) {\n        throw new IOException(String.format(\"The given metric key %s doesn't have two or more components\",key));\n      }\n      if (metricTypeMap.containsKey(components[0])) {\n        csvFileWriter=fileWriterMap.get(new FileWriterKey(metricTypeMap.get(components[0]),CSV_SUFFIX));\n        ymlFileWriter=fileWriterMap.get(new FileWriterKey(metricTypeMap.get(components[0]),YML_SUFFIX));\n        csvFileWriter.append(String.format(\"%s,%s%n\",key,metricKey.getMetricType().toString()));\n// bug_start\n        ymlFileWriter.append(String.format(\"%s,%s%n\",key,StringEscapeUtils.escapeHtml(metricKey.getDescription().replace(\"'\",\"''\"))));\n// bug_end\n      }\n else {\n        throw new IOException(String.format(\"The metric key starts with invalid instance type %s\",components[0]));\n      }\n    }\n  }\n   LOG.info(\"Metrics CSV/YML files were created successfully.\");\n}\n"}
{"INPUT": "private ElementsShouldBeAtLeast(Object actual,int times,Condition<?> condition){\n// bug_start\n  super(\"\\nExpecting elements:\\n<%s>\\n to be at least %s times <%s>\",actual,times,condition);\n// bug_end\n}\n"}
{"INPUT": "@Test @OAuth2ContextConfiguration(resource=MyClientWithRegisteredRedirect.class,initialize=false) public void testRegisteredRedirectWithWrongOneInTokenEndpoint() throws Exception {\n  approveAccessTokenGrant(\"https://anywhere?key=value\",true);\n// bug_start\n  context.getAccessTokenRequest().set(\"redirect_uri\",\"http://nowhere.com\");\n// bug_end\n  try {\n    assertNotNull(context.getAccessToken());\n    fail(\"Expected RedirectMismatchException\");\n  }\n catch (  RedirectMismatchException e) {\n    assertEquals(HttpStatus.BAD_REQUEST.value(),e.getHttpErrorCode());\n    assertEquals(\"invalid_grant\",e.getOAuth2ErrorCode());\n  }\n}\n"}
{"INPUT": "@Test public void parsingTest() throws Exception {\n  Map<String,KafkaVersion> map=new HashMap<>();\n  KafkaVersion defaultVersion=KafkaVersion.parseKafkaVersions(new StringReader(KafkaVersionTestUtils.getKafkaVersionYaml()),map);\n  assertThat(defaultVersion.version(),is(KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION));\n// bug_start\n  assertThat(map.size(),is(4));\n// bug_end\n  assertThat(map.containsKey(KafkaVersionTestUtils.LATEST_KAFKA_VERSION),is(true));\n  assertThat(map.get(KafkaVersionTestUtils.LATEST_KAFKA_VERSION).version(),is(KafkaVersionTestUtils.LATEST_KAFKA_VERSION));\n  assertThat(map.get(KafkaVersionTestUtils.LATEST_KAFKA_VERSION).protocolVersion(),is(KafkaVersionTestUtils.LATEST_PROTOCOL_VERSION));\n  assertThat(map.get(KafkaVersionTestUtils.LATEST_KAFKA_VERSION).messageVersion(),is(KafkaVersionTestUtils.LATEST_FORMAT_VERSION));\n  assertThat(map.containsKey(KafkaVersionTestUtils.PREVIOUS_KAFKA_VERSION),is(true));\n  assertThat(map.get(KafkaVersionTestUtils.PREVIOUS_KAFKA_VERSION).version(),is(KafkaVersionTestUtils.PREVIOUS_KAFKA_VERSION));\n  assertThat(map.get(KafkaVersionTestUtils.PREVIOUS_KAFKA_VERSION).protocolVersion(),is(KafkaVersionTestUtils.PREVIOUS_PROTOCOL_VERSION));\n  assertThat(map.get(KafkaVersionTestUtils.PREVIOUS_KAFKA_VERSION).messageVersion(),is(KafkaVersionTestUtils.PREVIOUS_FORMAT_VERSION));\n}\n"}
{"INPUT": "public static ObjectInspector createConstantObjectInspector(String className,Object value){\n  try {\n    Constructor<?> method=Class.forName(className).getDeclaredConstructor(value.getClass());\n    method.setAccessible(true);\n    return (ObjectInspector)method.newInstance(value);\n  }\n catch (  ClassNotFoundException|NoSuchMethodException|InstantiationException|IllegalAccessException|InvocationTargetException e) {\n// bug_start\n    throw new FlinkHiveUDFException(\"Failed to instantiate JavaConstantDateObjectInspector\",e);\n// bug_end\n  }\n}\n"}
{"INPUT": "CommentMetaModel(JavaParserMetaModel parent,Optional<ClassMetaModel> superClassMetaModel){\n  super(superClassMetaModel,parent,com.github.javaparser.ast.comments.Comment.class,\"Comment\",\"com.github.javaparser.ast.comments.Comment\",\"com.github.javaparser.ast.comments\",true);\n// bug_start\n  fieldMetaModels.add(new FieldMetaModel(this,\"getCommentedNode\",\"setCommentedNode\",\"commentedNode\",int.class,null,true,false,false,false));\n// bug_end\n  fieldMetaModels.add(new FieldMetaModel(this,\"getContent\",\"setContent\",\"content\",int.class,null,true,false,false,false));\n}\n"}
{"INPUT": "@Test public void testKeyPressNative(){\n// bug_start\n  selenium.open(\"/selenium-server/tests/html/test_type_page1.html\");\n// bug_end\n  selenium.focus(\"username\");\n  selenium.keyPressNative(Integer.toString(KeyEvent.VK_H));\n  Assert.assertEquals(selenium.getValue(\"username\"),\"h\");\n}\n"}
{"INPUT": "@Override public void configure() throws Exception {\n  port1=getPort();\n  port2=getNextPort();\n// bug_start\n  fromF(\"netty4:tcp://localhost:%s?sync=true&textline=true\",port1).to(\"mock:before\").toF(\"netty:tcp://localhost:%s?sync=true&textline=true\",port2).to(\"mock:after\");\n// bug_end\n  fromF(\"netty4:tcp://localhost:%s?sync=true&textline=true\",port2).to(\"mock:proxy\").transform().simple(\"Bye ${body}\\n\");\n}\n"}
{"INPUT": "// bug_start\n@Test(timeout=8000) public void testDeadlockDetected_ThreeThreadsInVector() throws InterruptedException {\n// bug_end\n  final PessimisticLockFactory lock=PessimisticLockFactory.builder().build();\n  final CountDownLatch starter=new CountDownLatch(3);\n  final CountDownLatch cdl=new CountDownLatch(1);\n  final AtomicBoolean deadlockInThread=new AtomicBoolean(false);\n  Thread t1=createThread(starter,cdl,deadlockInThread,lock,\"id1\",lock,\"id2\");\n  Thread t2=createThread(starter,cdl,deadlockInThread,lock,\"id2\",lock,\"id3\");\n  Thread t3=createThread(starter,cdl,deadlockInThread,lock,\"id3\",lock,\"id4\");\n  t1.start();\n  t2.start();\n  t3.start();\n  lock.obtainLock(\"id4\");\n  starter.await();\n  cdl.countDown();\n  try {\n    lock.obtainLock(\"id1\");\n    assertTrue(deadlockInThread.get());\n  }\n catch (  DeadlockException e) {\n  }\n}\n"}
{"INPUT": "@Test public void testDuplicateArrayList(){\n  A a=new A();\n  a.list1=new ArrayList<String>();\n  a.list1.add(\"aaa\");\n  a.list2=new ArrayList<String>();\n  a.list2.add(\"aaa\");\n  String json=Json.toJson(a,JsonFormat.compact().setQuoteName(false));\n// bug_start\n  String exp=\"{list2:[\\\"aaa\\\"],list1:[\\\"aaa\\\"]}\";\n// bug_end\n  assertEquals(exp,json);\n}\n"}
{"INPUT": "public static void main(String[] args){\n// bug_start\n  String usage=\"java org.apache.lucene.demo.IndexFiles <root_directory>\" + \" [-index INDEX_PATH] [-docs DOCS_PATH] [-update]\\n\\n\" + \"See http://lucene.apache.org/java/4_0/demo.html for details.\";\n// bug_end\n  String indexPath=\"index\";\n  String docsPath=null;\n  boolean create=true;\n  for (int i=0; i < args.length; i++) {\n    if (\"-index\".equals(args[i])) {\n      indexPath=args[i + 1];\n      i++;\n    }\n else     if (\"-docs\".equals(args[i])) {\n      docsPath=args[i + 1];\n      i++;\n    }\n else     if (\"-update\".equals(args[i])) {\n      create=false;\n    }\n  }\n  if (docsPath == null) {\n    System.err.println(\"Usage: \" + usage);\n    System.exit(1);\n  }\n  final File docDir=new File(docsPath);\n  if (!docDir.exists() || !docDir.canRead()) {\n    System.out.println(\"Document directory '\" + docDir.getAbsolutePath() + \"' does not exist or is not readable, please check the path\");\n    System.exit(1);\n  }\n  Date start=new Date();\n  try {\n    System.out.println(\"Indexing to directory '\" + indexPath + \"'...\");\n    Directory dir=FSDirectory.open(new File(indexPath));\n    Analyzer analyzer=new StandardAnalyzer(Version.LUCENE_40);\n    IndexWriterConfig iwc=new IndexWriterConfig(Version.LUCENE_40,analyzer);\n    if (create) {\n      iwc.setOpenMode(OpenMode.CREATE);\n    }\n else {\n      iwc.setOpenMode(OpenMode.CREATE_OR_APPEND);\n    }\n    IndexWriter writer=new IndexWriter(dir,iwc);\n    indexDocs(writer,docDir);\n    writer.close();\n    Date end=new Date();\n    System.out.println(end.getTime() - start.getTime() + \" total milliseconds\");\n  }\n catch (  IOException e) {\n    System.out.println(\" caught a \" + e.getClass() + \"\\n with message: \"+ e.getMessage());\n  }\n}\n"}
{"INPUT": "@Test public void truncateReportingDataWorks() throws Exception {\n  ReportingTruncateWorker truncateWorker=new ReportingTruncateWorker(holder.reportingDiskDao);\n  String tempDir=holder.props.getProperty(\"data.folder\");\n  Path userReportFolder=Paths.get(tempDir,\"data\",getUserName());\n  if (Files.notExists(userReportFolder)) {\n    Files.createDirectories(userReportFolder);\n  }\n  Path pinReportingDataPath1=Paths.get(tempDir,\"data\",getUserName(),ReportingDiskDao.generateFilename(1,0,PinType.ANALOG,(byte)7,GraphGranularityType.MINUTE));\n  Path pinReportingDataPath2=Paths.get(tempDir,\"data\",getUserName(),ReportingDiskDao.generateFilename(1,0,PinType.VIRTUAL,(byte)7,GraphGranularityType.MINUTE));\n  FileUtils.write(pinReportingDataPath2,1.11D,1);\n  Path pinReportingDataPath3=Paths.get(tempDir,\"data\",getUserName(),ReportingDiskDao.generateFilename(1,0,PinType.VIRTUAL,(byte)7,GraphGranularityType.HOURLY));\n// bug_start\n  int STORAGE_PERIOD=15;\n// bug_end\n  for (int i=0; i < STORAGE_PERIOD * 24 * 60 + 1; i++) {\n    FileUtils.write(pinReportingDataPath1,1.11D,i);\n    FileUtils.write(pinReportingDataPath3,1.11D,i);\n  }\n  assertEquals((STORAGE_PERIOD * 24 * 60 + 1) * ReportingUtil.REPORTING_RECORD_SIZE,Files.size(pinReportingDataPath1));\n  assertEquals(16,Files.size(pinReportingDataPath2));\n  assertEquals((STORAGE_PERIOD * 24 * 60 + 1) * ReportingUtil.REPORTING_RECORD_SIZE,Files.size(pinReportingDataPath3));\n  truncateWorker.run();\n  assertEquals(STORAGE_PERIOD * 24 * 60* ReportingUtil.REPORTING_RECORD_SIZE,Files.size(pinReportingDataPath1));\n  assertEquals(16,Files.size(pinReportingDataPath2));\n  assertEquals((STORAGE_PERIOD * 24 * 60 + 1) * ReportingUtil.REPORTING_RECORD_SIZE,Files.size(pinReportingDataPath3));\n  ByteBuffer bb=FileUtils.read(pinReportingDataPath1,STORAGE_PERIOD * 24 * 60);\n  for (int i=1; i < STORAGE_PERIOD * 24 * 60 + 1; i++) {\n    assertEquals(1.11D,bb.getDouble(),0.001D);\n    assertEquals(i,bb.getLong());\n  }\n  bb=FileUtils.read(pinReportingDataPath3,STORAGE_PERIOD * 24 * 60 + 1);\n  for (int i=0; i < STORAGE_PERIOD * 24 * 60 + 1; i++) {\n    assertEquals(1.11D,bb.getDouble(),0.001D);\n    assertEquals(i,bb.getLong());\n  }\n}\n"}
{"INPUT": "private static boolean createSymlinkJava7(File baseDir,String targetPath,String symlinkPath) throws IOException {\n  try {\n    Object path=File.class.getMethod(\"toPath\").invoke(new File(baseDir,symlinkPath));\n    Object target=Class.forName(\"java.nio.file.Paths\").getMethod(\"get\",String.class,String[].class).invoke(null,targetPath,new String[0]);\n    Class<?> filesC=Class.forName(\"java.nio.file.Files\");\n    Class<?> pathC=Class.forName(\"java.nio.file.Path\");\n    filesC.getMethod(\"deleteIfExists\",pathC).invoke(null,path);\n    Object noAttrs=Array.newInstance(Class.forName(\"java.nio.file.attribute.FileAttribute\"),0);\n    filesC.getMethod(\"createSymbolicLink\",pathC,pathC,noAttrs.getClass()).invoke(null,path,target,noAttrs);\n    return true;\n  }\n catch (  NoSuchMethodException x) {\n    return false;\n  }\ncatch (  InvocationTargetException x) {\n    Throwable x2=x.getCause();\n    if (x2 instanceof UnsupportedOperationException) {\n      return true;\n    }\n// bug_start\n    if (Functions.isWindows() && String.valueOf(x2).contains(\"A required privilege is not held by the client.\")) {\n// bug_end\n      if (warnedSymlinks.compareAndSet(false,true)) {\n        LOGGER.warning(\"Symbolic links enabled on this platform but disabled for this user; run as administrator or use Local Security Policy > Security Settings > Local Policies > User Rights Assignment > Create symbolic links\");\n      }\n      return true;\n    }\n    if (x2 instanceof IOException) {\n      throw (IOException)x2;\n    }\n    throw (IOException)new IOException(x.toString()).initCause(x);\n  }\ncatch (  Exception x) {\n    throw (IOException)new IOException(x.toString()).initCause(x);\n  }\n}\n"}
{"INPUT": "public SizeWidget(){\n// bug_start\n  super(\"size\",\"Size metrics\",\"/Users/julienlancelot/Dev/Sources/sonar/plugins/sonar-core-plugin/src/main/resources/org/sonar/plugins/core/widgets/size.html.erb\");\n// bug_end\n}\n"}
{"INPUT": "@BeforeClass public static void beforeClass() throws Exception {\n  dir=newDirectory();\n  RandomIndexWriter iw=new RandomIndexWriter(random(),dir);\n  final int numDocs;\n  if (TEST_NIGHTLY) {\n    numDocs=TestUtil.nextInt(random(),2049,4000);\n  }\n else {\n// bug_start\n    numDocs=atLeast(545);\n// bug_end\n  }\n  for (int i=0; i < numDocs; i++) {\n    Document document=new Document();\n    document.add(newTextField(\"english\",English.intToEnglish(i),Field.Store.NO));\n    document.add(newTextField(\"oddeven\",(i % 2 == 0) ? \"even\" : \"odd\",Field.Store.NO));\n    document.add(new NumericDocValuesField(\"int\",random().nextInt()));\n    document.add(new NumericDocValuesField(\"long\",random().nextLong()));\n    document.add(new FloatDocValuesField(\"float\",random().nextFloat()));\n    document.add(new DoubleDocValuesField(\"double\",random().nextDouble()));\n    if (i == 545)     document.add(new DoubleDocValuesField(\"onefield\",LEAST_DOUBLE_VALUE));\n    iw.addDocument(document);\n  }\n  reader=iw.getReader();\n  iw.close();\n  searcher=newSearcher(reader);\n}\n"}
{"INPUT": "@Override public void put(String key,Object newVal,Configuration configuration){\n  if (configuration.jsonProvider().isMap(parent)) {\n    configuration.jsonProvider().setProperty(parent,key,newVal);\n  }\n else {\n// bug_start\n    throw new InvalidModificationException(\"Invalid add operation. $ is not an array\");\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public ExchangeSpecification getDefaultExchangeSpecification(){\n  ExchangeSpecification exchangeSpecification=new ExchangeSpecification(this.getClass().getCanonicalName());\n// bug_start\n  exchangeSpecification.setPlainTextUri(\"rest://api.bitcoincharts.com\");\n// bug_end\n  exchangeSpecification.setHost(\"api.bitcoincharts.com\");\n  exchangeSpecification.setPort(80);\n  exchangeSpecification.setExchangeName(\"BitcoinCharts\");\n  exchangeSpecification.setExchangeDescription(\"Bitcoin charts provides financial and technical data related to the Bitcoin network.\");\n  return exchangeSpecification;\n}\n"}
{"INPUT": "@Override public void migrate(SupportSQLiteDatabase database){\n// bug_start\n  database.execSQL(\"CREATE TABLE IF NOT EXISTS \" + MigrationDb.Entity4.TABLE_NAME + \" (`id` INTEGER NOT NULL, `name` TEXT, PRIMARY KEY(`id`),\"+ \" FOREIGN KEY(`name`) REFERENCES `Entity1`(`name`)\"+ \" ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED)\");\n// bug_end\n}\n"}
{"INPUT": "public void addURI(String authority,String path,int code){\n  if (code < 0) {\n    throw new IllegalArgumentException(\"code \" + code + \" is invalid: it must be positive\");\n  }\n  String[] tokens=null;\n  if (path != null) {\n    String newPath=path;\n// bug_start\n    if (path.length() > 0 && path.charAt(0) == '/') {\n// bug_end\n      newPath=path.substring(1);\n    }\n    tokens=newPath.split(\"/\");\n  }\n  int numTokens=tokens != null ? tokens.length : 0;\n  UriMatcher node=this;\n  for (int i=-1; i < numTokens; i++) {\n    String token=i < 0 ? authority : tokens[i];\n    ArrayList<UriMatcher> children=node.mChildren;\n    int numChildren=children.size();\n    UriMatcher child;\n    int j;\n    for (j=0; j < numChildren; j++) {\n      child=children.get(j);\n      if (token.equals(child.mText)) {\n        node=child;\n        break;\n      }\n    }\n    if (j == numChildren) {\n      child=new UriMatcher();\n      if (token.equals(\"#\")) {\n        child.mWhich=NUMBER;\n      }\n else       if (token.equals(\"*\")) {\n        child.mWhich=TEXT;\n      }\n else {\n        child.mWhich=EXACT;\n      }\n      child.mText=token;\n      node.mChildren.add(child);\n      node=child;\n    }\n  }\n  node.mCode=code;\n}\n"}
{"INPUT": "LiveData<DownloadEntity> getHttpDownloadInfo(Context context){\n// bug_start\n  String url=\"https://imtt.dd.qq.com/16891/apk/70BFFDB05AB8686F2A4CF3E07588A377.apk?fsname=com.tencent.tmgp.speedmobile_1.16.0.33877_1160033877.apk&csr=1bbd\";\n// bug_end\n  String filePath=\"/mnt/sdcard/update.mp4\";\n  singDownloadInfo=Aria.download(context).getFirstDownloadEntity(url);\n  if (singDownloadInfo == null) {\n    singDownloadInfo=new DownloadEntity();\n    singDownloadInfo.setUrl(url);\n    File file=new File(filePath);\n    singDownloadInfo.setFilePath(filePath);\n    singDownloadInfo.setFileName(file.getName());\n  }\n else {\n    AppUtil.setConfigValue(context,HTTP_PATH_KEY,singDownloadInfo.getFilePath());\n    AppUtil.setConfigValue(context,HTTP_URL_KEY,singDownloadInfo.getUrl());\n  }\n  liveData.postValue(singDownloadInfo);\n  return liveData;\n}\n"}
{"INPUT": "public HikeFlagEncoder(PMap properties){\n  this((int)properties.getLong(\"speedBits\",4),properties.getDouble(\"speedFactor\",1));\n  this.properties=properties;\n// bug_start\n  this.setBlockFords(properties.getBool(\"block_fords\",true));\n// bug_end\n}\n"}
{"INPUT": "private Settings(Context context){\n  SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(context);\n  this.editor=preferences.edit();\n  this.scrollingPauseLoad=preferences.getBoolean(PREFERENCE_SCROLLING_PAUSE_LOAD,false);\n  this.showImageDownloadProgress=preferences.getBoolean(PREFERENCE_SHOW_IMAGE_DOWNLOAD_PROGRESS,false);\n  this.mobileNetworkPauseDownload=preferences.getBoolean(PREFERENCE_MOBILE_NETWORK_PAUSE_DOWNLOAD,true);\n// bug_start\n  this.showImageFromFlag=preferences.getBoolean(PREFERENCE_SHOW_IMAGE_FROM_FLAG,true);\n// bug_end\n  this.clickDisplayOnPauseDownload=preferences.getBoolean(PREFERENCE_CLICK_DISPLAY_ON_PAUSE_DOWNLOAD,true);\n  this.clickDisplayOnFailed=preferences.getBoolean(PREFERENCE_CLICK_DISPLAY_ON_FAILED,true);\n  this.showClickRipple=preferences.getBoolean(PREFERENCE_CLICK_SHOW_CLICK_RIPPLE,true);\n  this.enableMemoryCache=preferences.getBoolean(PREFERENCE_ENABLE_MEMORY_CACHE,true);\n  this.enableDiskCache=preferences.getBoolean(PREFERENCE_ENABLE_DISK_CACHE,true);\n  this.imagesOfLowQuality=preferences.getBoolean(PREFERENCE_IMAGES_OF_LOW_QUALITY,false);\n}\n"}
{"INPUT": "public SecondaryNameNode(Configuration conf) throws IOException {\n  JvmMetrics.init(\"SecondaryNameNode\",conf.get(\"session.id\"));\n  initializeErrorSimulationEvent(2);\n  shouldRun=true;\n  nameNodeAddr=NetUtils.createSocketAddr(conf.get(\"fs.default.name\",\"local\"));\n  this.conf=conf;\n  this.namenode=(ClientProtocol)RPC.waitForProxy(ClientProtocol.class,ClientProtocol.versionID,nameNodeAddr,conf);\n  String infoAddr=NetUtils.getServerAddress(conf,\"dfs.secondary.info.bindAddress\",\"dfs.secondary.info.port\",\"dfs.secondary.http.address\");\n  InetSocketAddress infoSocAddr=NetUtils.createSocketAddr(infoAddr);\n  infoBindAddress=infoSocAddr.getHostName();\n  int tmpInfoPort=infoSocAddr.getPort();\n  infoServer=new StatusHttpServer(\"dfs\",infoBindAddress,tmpInfoPort,tmpInfoPort == 0);\n  infoServer.setAttribute(\"name.secondary\",this);\n  this.infoServer.setAttribute(\"name.conf\",conf);\n  infoServer.addServlet(\"getimage\",\"/getimage\",GetImageServlet.class);\n  infoServer.start();\n  infoPort=infoServer.getPort();\n// bug_start\n  conf.set(\"dfs.secondary.http.bindAddress\",infoBindAddress + \":\" + infoPort);\n// bug_end\n  LOG.info(\"Secondary Web-server up at: \" + infoBindAddress + \":\"+ infoPort);\n  String[] dirName=conf.getStrings(\"fs.checkpoint.dir\");\n  checkpointDir=new File(dirName[0]);\n  checkpointPeriod=conf.getLong(\"fs.checkpoint.period\",3600);\n  checkpointSize=conf.getLong(\"fs.checkpoint.size\",4194304);\n  doSetup();\n  LOG.warn(\"Checkpoint Directory:\" + checkpointDir);\n  LOG.warn(\"Checkpoint Period   :\" + checkpointPeriod + \" secs \"+ \"(\"+ checkpointPeriod / 60 + \" min)\");\n  LOG.warn(\"Log Size Trigger    :\" + checkpointSize + \" bytes \"+ \"(\"+ checkpointSize / 1024 + \" KB)\");\n}\n"}
{"INPUT": "static void test(SocketAddress sa,final boolean closeChannel,final boolean shutdownGroup) throws Exception {\n  final AsynchronousChannelGroup group=AsynchronousChannelGroup.withFixedThreadPool(1,new ThreadFactory(){\n    @Override public Thread newThread(    final Runnable r){\n      return new Thread(r);\n    }\n  }\n);\n  final AsynchronousSocketChannel ch=AsynchronousSocketChannel.open(group);\n  final CountDownLatch latch=new CountDownLatch(2);\n  ch.connect(sa,(Void)null,new CompletionHandler<Void,Void>(){\n    public void completed(    Void result,    Void att){\n      System.out.println(\"Connected\");\n      ByteBuffer buf=ByteBuffer.allocate(100);\n      ch.read(buf,(Void)null,new CompletionHandler<Integer,Void>(){\n        public void completed(        Integer bytesRead,        Void att){\n          throw new RuntimeException();\n        }\n        public void failed(        Throwable exc,        Void att){\n          if (!(exc instanceof AsynchronousCloseException))           throw new RuntimeException(exc);\n          System.out.println(\"Read failed (expected)\");\n          latch.countDown();\n        }\n      }\n);\n      try {\n        if (closeChannel) {\n          System.out.print(\"Close channel ...\");\n          ch.close();\n          System.out.println(\" done.\");\n        }\n        if (shutdownGroup) {\n          System.out.print(\"Shutdown group ...\");\n          group.shutdownNow();\n          System.out.println(\" done.\");\n        }\n        latch.countDown();\n      }\n catch (      IOException e) {\n        throw new RuntimeException();\n      }\n    }\n    public void failed(    Throwable exc,    Void att){\n      throw new RuntimeException(exc);\n    }\n  }\n);\n  latch.await();\n  group.shutdown();\n// bug_start\n  boolean terminated=group.awaitTermination(5,TimeUnit.SECONDS);\n// bug_end\n  if (!terminated)   throw new RuntimeException(\"Group did not terminate\");\n  System.out.println(\"TEST OKAY\");\n}\n"}
{"INPUT": "private static String getAndIncrementJmxId(){\n  int current=factoryJmxId;\n  factoryJmxId++;\n// bug_start\n  return (0 == current ? \"\" : \"\" + current);\n// bug_end\n}\n"}
{"INPUT": "@Override public ChannelPipeline getPipeline() throws Exception {\n  ChannelPipeline pipeline=Channels.pipeline();\n  addLengthFieldPipes(pipeline,frameLength);\n// bug_start\n  BlockingReadHandler<ChannelBuffer> reader=new BlockingReadHandler<>(new ArrayBlockingQueue<ChannelEvent>(3,false));\n// bug_end\n  pipeline.addLast(\"blockingHandler\",reader);\n  return pipeline;\n}\n"}
{"INPUT": "@Test public void testUnmarshal() throws IOException {\n// bug_start\n  InputStream is=WalletJSONTest.class.getResourceAsStream(\"/account/example-accountinfo-data.json\");\n// bug_end\n  ObjectMapper mapper=new ObjectMapper();\n  TaurusBalance taurusBalance=mapper.readValue(is,TaurusBalance.class);\n  assertThat(taurusBalance.getBtcAvailable()).isEqualTo(new BigDecimal(\"0.02350921\"));\n  assertThat(taurusBalance.getBtcReserved()).isEqualTo(new BigDecimal(\"0.00000000\"));\n  assertThat(taurusBalance.getBtcBalance()).isEqualTo(new BigDecimal(\"0.02350921\"));\n  assertThat(taurusBalance.getCadAvailable()).isEqualTo(new BigDecimal(\"6.16\"));\n  assertThat(taurusBalance.getCadBalance()).isEqualTo(new BigDecimal(\"6.16\"));\n  assertThat(taurusBalance.getCadReserved()).isEqualTo(new BigDecimal(\"0.00\"));\n  assertThat(taurusBalance.getFee()).isEqualTo(new BigDecimal(\"0.5000\"));\n}\n"}
{"INPUT": "public static Object signRsaSha256(Strand strand,ArrayValue inputValue,MapValue<?,?> privateKey){\n  byte[] input=inputValue.getBytes();\n  try {\n    PrivateKey key=(PrivateKey)privateKey.getNativeData(Constants.NATIVE_DATA_PRIVATE_KEY);\n    return new ArrayValue(CryptoUtils.sign(\"SHA256withRSA\",key,input));\n  }\n catch (  InvalidKeyException e) {\n// bug_start\n    return CryptoUtils.createCryptoError(\"invalid uninitialized key\");\n// bug_end\n  }\n}\n"}
{"INPUT": "@Test public void isSwaggerRunning() throws Exception {\n  assertResponse(client.get(\"/management/swagger-ui.html\")).hasStatusCode(200);\n// bug_start\n  JsonNode json=assertResponse(client.get(\"/management/v2/api-docs\")).hasStatusCode(200).getJsonObject();\n// bug_end\n  assertThat(json.get(\"swagger\").asText(),is(\"2.0\"));\n  JsonNode info=json.get(\"info\");\n  assertThat(info.get(\"description\").asText(),is(\"REST API and interface to manage Geode components.\"));\n  assertThat(info.get(\"title\").asText(),is(\"Apache Geode Management REST API\"));\n  JsonNode license=info.get(\"license\");\n  assertThat(license.get(\"name\").asText(),is(\"Apache License, version 2.0\"));\n  assertThat(license.get(\"url\").asText(),is(\"http://www.apache.org/licenses/\"));\n}\n"}
{"INPUT": "public NamespaceOutputManager(final String baseDirectoryName,final String namespaceName) throws IOException {\n  Verify.notNull(baseDirectoryName,\"baseDirectoryName\");\n// bug_start\n  Verify.notNull(namespaceName,\"namespaceName\");\n// bug_end\n  final String dirName=(baseDirectoryName.endsWith(\"\" + File.separatorChar) ? baseDirectoryName : baseDirectoryName + File.separatorChar) + namespaceName.replace('.','_');\n  outputDir=new File(dirName);\n  if (!outputDir.exists()) {\n    if (!outputDir.mkdirs()) {\n      throw new IllegalStateException(\"Unable to create directory: \" + dirName);\n    }\n  }\n}\n"}
{"INPUT": "private final void generateRecordGetter0(TypedElementDefinition<?> column,int index,JavaWriter out){\n  final String getter=getStrategy().getJavaGetterName(column,Mode.RECORD);\n  final String typeFull=getJavaType(column.getType(resolver(out)),out);\n  final String type=out.ref(typeFull);\n  final String name=column.getQualifiedOutputName();\n  if (!kotlin && !printDeprecationIfUnknownType(out,typeFull))   out.javadoc(\"Getter for <code>%s</code>.[[before= ][%s]]\",name,list(escapeEntities(comment(column))));\n  if (column instanceof ColumnDefinition)   printColumnJPAAnnotation(out,(ColumnDefinition)column);\n  printValidationAnnotation(out,column);\n  printNullableOrNonnullAnnotation(out,column);\n  boolean override=generateInterfaces();\n  if (scala) {\n// bug_start\n    out.println(\"def %s: %s = get(%s).asInstanceOf[%s]\",getter,type,index,type);\n// bug_end\n  }\n else   if (kotlin) {\n    out.tab(1).println(\"get() = get(%s) as %s%s\",index,type,column instanceof EmbeddableDefinition ? \"\" : \"?\");\n  }\n else {\n    out.overrideIf(override);\n    out.println(\"public %s %s() {\",type,getter);\n    if (Object.class.getName().equals(typeFull))     out.println(\"return get(%s);\",index);\n else     out.println(\"return (%s) get(%s);\",type,index);\n    out.println(\"}\");\n  }\n}\n"}
{"INPUT": "public void testSetSchema() throws Exception {\n  try (Connection conn=DriverManager.getConnection(URL)){\n    GridTestUtils.assertThrows(log,new Callable<Object>(){\n      @Override public Object call() throws Exception {\n        Statement stmt=conn.createStatement();\n        stmt.execute(\"select t._key, t._val from Integer t\");\n        return null;\n      }\n    }\n// bug_start\n,SQLException.class,\"Failed to parse query\");\n// bug_end\n    conn.setSchema(\"\\\"cache1\\\"\");\n    Statement stmt=conn.createStatement();\n    conn.setSchema(\"invalid_schema\");\n    stmt.execute(\"select t._key, t._val from Integer t\");\n    ResultSet rs=stmt.getResultSet();\n    while (rs.next())     assertEquals(rs.getInt(2),rs.getInt(1) * 2);\n  }\n }\n"}
{"INPUT": "@Test @Network public void testConnectTimeout(){\n// bug_start\n  String ldapUrl=\"ldap://elasticsearch.com:389\";\n// bug_end\n  String groupSearchBase=\"o=sevenSeas\";\n  String[] userTemplates=new String[]{\"cn={0},ou=people,o=sevenSeas\"};\n  Settings settings=ImmutableSettings.builder().put(buildLdapSettings(ldapUrl,userTemplates,groupSearchBase,LdapSearchScope.SUB_TREE)).put(SessionFactory.TIMEOUT_TCP_CONNECTION_SETTING,\"1ms\").build();\n  RealmConfig config=new RealmConfig(\"ldap_realm\",settings);\n  LdapSessionFactory sessionFactory=new LdapSessionFactory(config,null);\n  String user=\"Horatio Hornblower\";\n  SecuredString userPass=SecuredStringTests.build(\"pass\");\n  long start=System.currentTimeMillis();\n  try (LdapSession session=sessionFactory.session(user,userPass)){\n    fail(\"expected connection timeout error here\");\n  }\n catch (  Throwable t) {\n    long time=System.currentTimeMillis() - start;\n    assertThat(time,lessThan(10000l));\n    assertThat(t,instanceOf(ShieldLdapException.class));\n    assertThat(t.getCause().getCause().getMessage(),containsString(\"within the configured timeout of\"));\n  }\n}\n"}
{"INPUT": "public void updateData(final FileDownloadTransferModel transfer){\nswitch (transfer.getStatus()) {\ncase FileDownloadStatus.pending:\n    if (getStatus() == FileDownloadStatus.pending) {\n      FileDownloadLog.w(this,\"already pending %d\",getDownloadId());\n      break;\n    }\n  this.setStatus(transfer.getStatus());\nthis.setSoFarBytes(transfer.getSoFarBytes());\nthis.setTotalBytes(transfer.getTotalBytes());\ngetDriver().notifyPending();\nbreak;\ncase FileDownloadStatus.connected:\nif (getStatus() == FileDownloadStatus.connected) {\nFileDownloadLog.w(this,\"already connected %d\",transfer.getDownloadId());\nbreak;\n}\nsetStatus(transfer.getStatus());\nsetTotalBytes(transfer.getTotalBytes());\nsetSoFarBytes(transfer.getSoFarBytes());\nthis.isContinue=transfer.isContinue();\nthis.etag=transfer.getEtag();\n// bug_start\n// bug_end\nbreak;\ncase FileDownloadStatus.progress:\nif (getStatus() == FileDownloadStatus.progress && transfer.getSoFarBytes() == getSoFarBytes()) {\nFileDownloadLog.w(this,\"unused values! by process callback\");\nbreak;\n}\nsetStatus(transfer.getStatus());\nsetSoFarBytes(transfer.getSoFarBytes());\ngetDriver().notifyProgress();\nbreak;\ncase FileDownloadStatus.blockComplete:\nbreak;\ncase FileDownloadStatus.error:\nif (getStatus() == FileDownloadStatus.error) {\nFileDownloadLog.w(this,\"already err , callback by other status same transfer\");\nbreak;\n}\nsetStatus(transfer.getStatus());\nsetEx(transfer.getThrowable());\nsetSoFarBytes(transfer.getSoFarBytes());\nFileDownloadList.getImpl().removeByError(this);\nbreak;\ncase FileDownloadStatus.paused:\nbreak;\ncase FileDownloadStatus.completed:\nif (getStatus() == FileDownloadStatus.completed) {\nFileDownloadLog.w(this,\"already completed , callback by process whith same transfer\");\nbreak;\n}\nsetStatus(transfer.getStatus());\nsetSoFarBytes(getTotalBytes());\nFileDownloadList.getImpl().removeByCompleted(this);\nbreak;\ncase FileDownloadStatus.warn:\nbreak;\n}\n}\n"}
{"INPUT": "public void testKill() throws TimeoutException {\n  AutodetectResult autodetectResult=mock(AutodetectResult.class);\n  @SuppressWarnings(\"unchecked\") Iterator<AutodetectResult> iterator=mock(Iterator.class);\n  when(iterator.hasNext()).thenReturn(true).thenReturn(false);\n  when(iterator.next()).thenReturn(autodetectResult);\n  AutodetectProcess process=mock(AutodetectProcess.class);\n  when(process.readAutodetectResults()).thenReturn(iterator);\n  processorUnderTest.setProcessKilled();\n  processorUnderTest.process(process);\n  processorUnderTest.awaitCompletion();\n  assertEquals(0,processorUnderTest.completionLatch.getCount());\n  assertEquals(1,processorUnderTest.updateModelSnapshotIdSemaphore.availablePermits());\n  verify(persister,never()).commitResultWrites(JOB_ID);\n  verify(persister,never()).commitStateWrites(JOB_ID);\n  verify(renormalizer,never()).renormalize(any());\n// bug_start\n// bug_end\n  verify(renormalizer,never()).waitUntilIdle();\n  verify(flushListener,times(1)).clear();\n}\n"}
{"INPUT": "Configuration(Configuration conf){\n  setBossThreads(conf.getBossThreads());\n  setWorkerThreads(conf.getWorkerThreads());\n  setCloseTimeout(conf.getCloseTimeout());\n  setHeartbeatInterval(conf.getHeartbeatInterval());\n  setHeartbeatTimeout(conf.getHeartbeatTimeout());\n  setHostname(conf.getHostname());\n  setPort(conf.getPort());\n  setJsonSupport(new JsonSupportWrapper(conf.getJsonSupport()));\n  setJsonTypeFieldName(conf.getJsonTypeFieldName());\n  setContext(conf.getContext());\n  setAllowCustomRequests(conf.isAllowCustomRequests());\n  setPollingDuration(conf.getPollingDuration());\n  setKeyStorePassword(conf.getKeyStorePassword());\n  setKeyStore(conf.getKeyStore());\n  setTransports(conf.getTransports());\n  setMaxHttpContentLength(conf.getMaxHttpContentLength());\n  setPackagePrefix(conf.getPackagePrefix());\n  setPreferDirectBuffer(conf.isPreferDirectBuffer());\n  setStoreFactory(conf.getStoreFactory());\n  setAuthorizationListener(conf.getAuthorizationListener());\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public EJBComponentDescription(final String componentName,final String componentClassName,final EjbJarDescription ejbJarDescription,final ServiceName deploymentUnitServiceName,final EnterpriseBeanMetaData descriptorData){\n  super(componentName,componentClassName,ejbJarDescription.getEEModuleDescription(),deploymentUnitServiceName);\n  this.descriptorData=descriptorData;\n  if (ejbJarDescription.isWar()) {\n    setNamingMode(ComponentNamingMode.USE_MODULE);\n  }\n else {\n    setNamingMode(ComponentNamingMode.CREATE);\n  }\n  getConfigurators().addFirst(new NamespaceConfigurator());\n  getConfigurators().add(new EjbJarConfigurationConfigurator());\n  this.addDependency(EJBUtilities.SERVICE_NAME,ServiceBuilder.DependencyType.REQUIRED);\n  this.addCurrentInvocationContextFactory();\n  this.addRemoteTransactionsRepositoryDependency();\n  this.transactionAttributes=new ApplicableMethodInformation<TransactionAttributeType>(componentName,TransactionAttributeType.REQUIRED);\n  this.transactionTimeouts=new ApplicableMethodInformation<Integer>(componentName,null);\n  this.descriptorMethodPermissions=new ApplicableMethodInformation<EJBMethodSecurityAttribute>(componentName,null);\n  this.annotationMethodPermissions=new ApplicableMethodInformation<EJBMethodSecurityAttribute>(componentName,null);\n  addDependency(deploymentUnitServiceName.append(ModuleDeployment.SERVICE_NAME),ServiceBuilder.DependencyType.REQUIRED);\n// bug_start\n// bug_end\n  getConfigurators().add(new ComponentConfigurator(){\n    @Override public void configure(    final DeploymentPhaseContext context,    final ComponentDescription description,    final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n      if (description.getNamingMode() == ComponentNamingMode.CREATE) {\n        description.getBindingConfigurations().add(new BindingConfiguration(\"java:comp/env\",new ContextInjectionSource(\"env\",\"java:comp/env\")));\n      }\n      final List<SetupAction> ejbSetupActions=context.getDeploymentUnit().getAttachmentList(Attachments.OTHER_EE_SETUP_ACTIONS);\n      if (description.isTimerServiceApplicable()) {\n        if (!ejbSetupActions.isEmpty()) {\n          configuration.addTimeoutViewInterceptor(AdditionalSetupInterceptor.factory(ejbSetupActions),InterceptorOrder.View.EE_SETUP);\n        }\n        configuration.addTimeoutViewInterceptor(shutDownInterceptorFactory,InterceptorOrder.View.SHUTDOWN_INTERCEPTOR);\n        configuration.addTimeoutViewInterceptor(new ImmediateInterceptorFactory(new TCCLInterceptor(configuration.getModuleClassLoader())),InterceptorOrder.View.TCCL_INTERCEPTOR);\n        configuration.addTimeoutViewInterceptor(configuration.getNamespaceContextInterceptorFactory(),InterceptorOrder.View.JNDI_NAMESPACE_INTERCEPTOR);\n        configuration.addTimeoutViewInterceptor(CurrentInvocationContextInterceptor.FACTORY,InterceptorOrder.View.INVOCATION_CONTEXT_INTERCEPTOR);\n        if (isSecurityEnabled()) {\n          configuration.addTimeoutViewInterceptor(new SecurityContextInterceptorFactory(),InterceptorOrder.View.SECURITY_CONTEXT);\n        }\n        for (        final Method method : configuration.getClassIndex().getClassMethods()) {\n          configuration.addTimeoutViewInterceptor(method,new ImmediateInterceptorFactory(new ComponentDispatcherInterceptor(method)),InterceptorOrder.View.COMPONENT_DISPATCHER);\n        }\n      }\n      if (!ejbSetupActions.isEmpty()) {\n        configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>(){\n          @Override public void configureDependency(          final ServiceBuilder<?> serviceBuilder,          final ComponentStartService service) throws DeploymentUnitProcessingException {\n            for (            final SetupAction setupAction : ejbSetupActions) {\n              serviceBuilder.addDependencies(setupAction.dependencies());\n            }\n          }\n        }\n);\n      }\n      configuration.addComponentInterceptor(ExecutionTimeInterceptor.FACTORY,InterceptorOrder.Component.EJB_EXECUTION_TIME_INTERCEPTOR,true);\n    }\n  }\n);\n}\n"}
{"INPUT": "private static void importFolder(SharedPreferences.Editor editor,int contentVersion,String uuid,ImportedFolder folder,boolean overwrite,Preferences prefs){\n  Map<String,Object> validatedSettings=FolderSettings.validate(contentVersion,folder.settings.settings,!overwrite);\n  if (contentVersion != Settings.VERSION) {\n    FolderSettings.upgrade(contentVersion,validatedSettings);\n  }\n  Map<String,String> stringSettings=FolderSettings.convert(validatedSettings);\n  Map<String,String> writeSettings;\n  if (overwrite) {\n    writeSettings=FolderSettings.getFolderSettings(prefs.getPreferences(),uuid,folder.name);\n    writeSettings.putAll(stringSettings);\n  }\n else {\n    writeSettings=stringSettings;\n  }\n  String prefix=uuid + \".\" + folder.name+ \".\";\n  for (  Map.Entry<String,String> setting : writeSettings.entrySet()) {\n    String key=prefix + setting.getKey();\n    String value=setting.getValue();\n// bug_start\n// bug_end\n    putString(editor,key,value);\n  }\n}\n"}
{"INPUT": "@Test public void testAll(){\n  TestRobot.testAnimation(getActivity(),\"9squares-AlBoardman.json\");\n  TestRobot.testAnimation(getActivity(),\"EmptyState.json\");\n  TestRobot.testAnimation(getActivity(),\"HamburgerArrow.json\");\n  TestRobot.testAnimation(getActivity(),\"LottieLogo1.json\");\n  TestRobot.testAnimation(getActivity(),\"LottieLogo2.json\");\n  TestRobot.testAnimation(getActivity(),\"MotionCorpse-Jrcanest.json\");\n  TestRobot.testAnimation(getActivity(),\"PinJump.json\");\n  TestRobot.testAnimation(getActivity(),\"TwitterHeart.json\");\n  TestRobot.testAnimation(getActivity(),\"Tests/Hosts.json\");\n  TestRobot.testAnimation(getActivity(),\"Tests/LightBulb.json\",new float[]{0f,0.05f,0.10f,0.2f,0.3f,0.4f,0.5f,1f});\n  TestRobot.testAnimation(getActivity(),\"Tests/LoopPlayOnce.json\");\n  TestRobot.testAnimation(getActivity(),\"Tests/Alarm.json\");\n  TestRobot.testAnimation(getActivity(),\"Tests/CheckSwitch.json\");\n  TestRobot.testAnimation(getActivity(),\"Tests/EllipseTrimPath.json\");\n  TestRobot.testAnimation(getActivity(),\"Tests/SplitDimensions.json\");\n  TestRobot.testAnimation(getActivity(),\"Tests/TrimPathsFull.json\");\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override public void onAnimationEnd(Animator animation){\n  if (!LauncherApplication.isScreenLarge()) {\n    mAppsCustomizePane.flashScrollingIndicator();\n  }\n  mAppsCustomizePane.loadAssociatedPages(mAppsCustomizePane.getCurrentPage());\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override public ListenableFuture<ChannelStats> getStats(){\n  SettableFuture<ChannelStats> ret=SettableFuture.create();\n  ChannelStats.Builder builder=new ChannelStats.Builder();\nsynchronized (lock) {\n    builder.setTarget(addressGroup.toString()).setState(getState());\n// bug_start\n// bug_end\n  }\n  callsTracer.updateBuilder(builder);\n  ret.set(builder.build());\n  return ret;\n}\n"}
{"INPUT": "@Override public boolean test(ReplicableEntry e){\n// bug_start\n// bug_end\n  if (shutdown)   return false;\n  if (e instanceof MapAbsentEntry) {\n    long deleteTimeout=systemTimeIntervalBetween(e.originTimestamp(),currentTime(),cleanupTimeoutUnit);\n    if (deleteTimeout > cleanupTimeout && !e.isChanged()) {\n      e.doRemoveCompletely();\n      removedCompletely++;\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") private <T>Optional<ConsumerBase<T>> subscriptionExist(ConsumerConfigurationData<?> conf){\nsynchronized (consumers) {\n    Optional<ConsumerBase<?>> subscriber=consumers.keySet().stream().filter(null).filter(null).filter(null).filter(null).findFirst();\n// bug_start\n// bug_end\n    return subscriber.map(null);\n  }\n}\n"}
{"INPUT": "@Test public void patternComparator(){\n  Comparator<String> comparator=pathMatcher.getPatternComparator(\"/hotels/new\");\n  assertEquals(0,comparator.compare(null,null));\n  assertEquals(1,comparator.compare(null,\"/hotels/new\"));\n  assertEquals(-1,comparator.compare(\"/hotels/new\",null));\n  assertEquals(0,comparator.compare(\"/hotels/new\",\"/hotels/new\"));\n  assertEquals(-1,comparator.compare(\"/hotels/new\",\"/hotels/*\"));\n  assertEquals(1,comparator.compare(\"/hotels/*\",\"/hotels/new\"));\n  assertEquals(0,comparator.compare(\"/hotels/*\",\"/hotels/*\"));\n  assertEquals(-1,comparator.compare(\"/hotels/new\",\"/hotels/{hotel}\"));\n  assertEquals(1,comparator.compare(\"/hotels/{hotel}\",\"/hotels/new\"));\n  assertEquals(0,comparator.compare(\"/hotels/{hotel}\",\"/hotels/{hotel}\"));\n  assertEquals(-1,comparator.compare(\"/hotels/{hotel}/booking\",\"/hotels/{hotel}/bookings/{booking}\"));\n  assertEquals(1,comparator.compare(\"/hotels/{hotel}/bookings/{booking}\",\"/hotels/{hotel}/booking\"));\n  assertEquals(-1,comparator.compare(\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\",\"/**\"));\n  assertEquals(1,comparator.compare(\"/**\",\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\"));\n  assertEquals(0,comparator.compare(\"/**\",\"/**\"));\n  assertEquals(-1,comparator.compare(\"/hotels/{hotel}\",\"/hotels/*\"));\n  assertEquals(1,comparator.compare(\"/hotels/*\",\"/hotels/{hotel}\"));\n  assertEquals(-1,comparator.compare(\"/hotels/*\",\"/hotels/*/**\"));\n  assertEquals(1,comparator.compare(\"/hotels/*/**\",\"/hotels/*\"));\n  assertEquals(-1,comparator.compare(\"/hotels/new\",\"/hotels/new.*\"));\n// bug_start\n// bug_end\n  assertEquals(-1,comparator.compare(\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\",\"/hotels/**\"));\n  assertEquals(1,comparator.compare(\"/hotels/**\",\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\"));\n  assertEquals(1,comparator.compare(\"/hotels/foo/bar/**\",\"/hotels/{hotel}\"));\n  assertEquals(-1,comparator.compare(\"/hotels/{hotel}\",\"/hotels/foo/bar/**\"));\n  assertEquals(2,comparator.compare(\"/hotels/**/bookings/**\",\"/hotels/**\"));\n  assertEquals(-2,comparator.compare(\"/hotels/**\",\"/hotels/**/bookings/**\"));\n  assertEquals(1,comparator.compare(\"/**\",\"/hotels/{hotel}\"));\n  assertEquals(1,comparator.compare(\"/hotels\",\"/hotels2\"));\n}\n"}
{"INPUT": "private void startServer(){\n  try {\n    mOnionServer=new WebServer();\n// bug_start\n// bug_end\n  }\n catch (  IOException ioe) {\n    Log.e(\"OnioNServer\",\"unable to start onion server\",ioe);\n  }\n}\n"}
{"INPUT": "public SIPCommToggleButton(Image bgImage,Image rolloverImage,Image iconImage,Image pressedImage){\n  this.bgImage=bgImage;\n  this.bgRolloverImage=rolloverImage;\n  this.iconImage=iconImage;\n  this.pressedImage=pressedImage;\n// bug_start\n// bug_end\n  this.setPreferredSize(new Dimension(this.bgImage.getWidth(null),this.bgImage.getHeight(null)));\n  this.setIcon(new ImageIcon(this.iconImage));\n}\n"}
{"INPUT": "private void worker(String destination,AtomicBoolean destinationRunning){\n  while (!running || !destinationRunning.get()) {\n    try {\n      Thread.sleep(100);\n    }\n catch (    InterruptedException e) {\n    }\n  }\n  logger.info(\"## start the MQ producer: {}.\",destination);\n  MDC.put(\"destination\",destination);\n  final ClientIdentity clientIdentity=new ClientIdentity(destination,(short)1001,\"\");\n  while (running && destinationRunning.get()) {\n    try {\n      CanalInstance canalInstance=canalServer.getCanalInstances().get(destination);\n      if (canalInstance == null) {\n        try {\n          Thread.sleep(3000);\n        }\n catch (        InterruptedException e) {\n        }\n        continue;\n      }\n      MQDestination canalDestination=new MQDestination();\n      canalDestination.setCanalDestination(destination);\n      CanalMQConfig mqConfig=canalInstance.getMqConfig();\n      canalDestination.setTopic(mqConfig.getTopic());\n      canalDestination.setPartition(mqConfig.getPartition());\n      canalDestination.setDynamicTopic(mqConfig.getDynamicTopic());\n      canalDestination.setPartitionsNum(mqConfig.getPartitionsNum());\n      canalDestination.setPartitionHash(mqConfig.getPartitionHash());\n// bug_start\n// bug_end\n      canalServer.subscribe(clientIdentity);\n      logger.info(\"## the MQ producer: {} is running now ......\",destination);\n      Integer getTimeout=mqProperties.getFetchTimeout();\n      Integer getBatchSize=mqProperties.getBatchSize();\n      while (running && destinationRunning.get()) {\n        Message message;\n        if (getTimeout != null && getTimeout > 0) {\n          message=canalServer.getWithoutAck(clientIdentity,getBatchSize,getTimeout.longValue(),TimeUnit.MILLISECONDS);\n        }\n else {\n          message=canalServer.getWithoutAck(clientIdentity,getBatchSize);\n        }\n        final long batchId=message.getId();\n        try {\n          int size=message.isRaw() ? message.getRawEntries().size() : message.getEntries().size();\n          if (batchId != -1 && size != 0) {\n            canalMQProducer.send(canalDestination,message,new Callback(){\n              @Override public void commit(){\n                canalServer.ack(clientIdentity,batchId);\n              }\n              @Override public void rollback(){\n                canalServer.rollback(clientIdentity,batchId);\n              }\n            }\n);\n          }\n else {\n            try {\n              Thread.sleep(100);\n            }\n catch (            InterruptedException e) {\n            }\n          }\n        }\n catch (        Exception e) {\n          logger.error(e.getMessage(),e);\n        }\n      }\n    }\n catch (    Exception e) {\n      logger.error(\"process error!\",e);\n    }\n  }\n}\n"}
{"INPUT": "public AmqpConnection(AmqpTransport transport,BrokerService brokerService){\n  this.amqpTransport=transport;\n  AmqpInactivityMonitor monitor=transport.getInactivityMonitor();\n  if (monitor != null) {\n    monitor.setAmqpTransport(amqpTransport);\n  }\n  this.amqpWireFormat=transport.getWireFormat();\n  this.brokerService=brokerService;\n  int maxFrameSize=amqpWireFormat.getMaxAmqpFrameSize();\n  if (maxFrameSize > AmqpWireFormat.NO_AMQP_MAX_FRAME_SIZE) {\n    this.protonTransport.setMaxFrameSize(maxFrameSize);\n  }\n  this.protonTransport.bind(this.protonConnection);\n  this.protonTransport.setChannelMax(CHANNEL_MAX);\n// bug_start\n// bug_end\n  this.protonConnection.collect(eventCollector);\n  updateTracer();\n}\n"}
{"INPUT": "private DataProviderInfo createDataProvider(FeatureInfo feature,MethodInfo method){\n  DataProviderMetadata metadata=method.getAnnotation(DataProviderMetadata.class);\n  DataProviderInfo provider=new DataProviderInfo();\n  provider.setParent(feature);\n  provider.setLine(metadata.line());\n  provider.setDataVariables(Arrays.asList(metadata.dataVariables()));\n// bug_start\n// bug_end\n  provider.setDataProviderMethod(method);\n  return provider;\n}\n"}
{"INPUT": "public StartArgs processCommandLine(String[] cmdLine) throws Exception {\n  CommandLineConfigSource cmdLineSource=new CommandLineConfigSource(cmdLine);\n  baseHome=new BaseHome(cmdLineSource);\n  StartLog.debug(\"jetty.home=%s\",baseHome.getHome());\n  StartLog.debug(\"jetty.base=%s\",baseHome.getBase());\n  StartLog.debug(\"Parsing collected arguments\");\n  StartArgs args=new StartArgs(baseHome);\n  args.parse(baseHome.getConfigSources());\n  Modules modules=new Modules(baseHome,args);\n  StartLog.debug(\"Registering all modules\");\n  modules.registerAll();\n  for (  String enabledModule : args.getEnabledModules()) {\n    for (    String source : args.getSources(enabledModule)) {\n      String shortForm=baseHome.toShortForm(source);\n      modules.enable(enabledModule,shortForm);\n    }\n  }\n  args.setAllModules(modules);\n  List<Module> activeModules=modules.getEnabled();\n  final Version START_VERSION=new Version(StartArgs.VERSION);\n  for (  Module enabled : activeModules) {\n    if (enabled.getVersion().isNewerThan(START_VERSION)) {\n      throw new UsageException(UsageException.ERR_BAD_GRAPH,\"Module [\" + enabled.getName() + \"] specifies jetty version [\"+ enabled.getVersion()+ \"] which is newer than this version of jetty [\"+ START_VERSION+ \"]\");\n    }\n  }\n  for (  String name : args.getSkipFileValidationModules()) {\n    Module module=modules.get(name);\n    module.setSkipFilesValidation(true);\n  }\n// bug_start\n// bug_end\n  args.expandLibs();\n  args.expandModules(activeModules);\n  args.resolveExtraXmls();\n  args.resolvePropertyFiles();\n  return args;\n}\n"}
{"INPUT": "public void testMultiWordSynonymsPhrase() throws Exception {\n// bug_start\n// bug_end\n  final MatchQuery matchQuery=new MatchQuery(createShardContext());\n  matchQuery.setAnalyzer(new MockSynonymAnalyzer());\n  final Query actual=matchQuery.parse(Type.PHRASE,STRING_FIELD_NAME,\"guinea pig dogs\");\n  Query expected=SpanNearQuery.newOrderedNearQuery(STRING_FIELD_NAME).addClause(new SpanOrQuery(new SpanQuery[]{SpanNearQuery.newOrderedNearQuery(STRING_FIELD_NAME).addClause(new SpanTermQuery(new Term(STRING_FIELD_NAME,\"guinea\"))).addClause(new SpanTermQuery(new Term(STRING_FIELD_NAME,\"pig\"))).setSlop(0).build(),new SpanTermQuery(new Term(STRING_FIELD_NAME,\"cavy\"))})).addClause(new SpanOrQuery(new SpanQuery[]{new SpanTermQuery(new Term(STRING_FIELD_NAME,\"dogs\")),new SpanTermQuery(new Term(STRING_FIELD_NAME,\"dog\"))})).build();\n  assertEquals(expected,actual);\n}\n"}
{"INPUT": "public CircularGauge setData(View view){\n  if (isChain) {\n    js.append(\";\");\n    isChain=false;\n  }\n  js.append(view.generateJs());\n  js.append(String.format(Locale.US,\"var setData1\" + ++variableIndex + \" = \"+ jsBase+ \".data(%s);\",view.getJsBase()));\n  if (isRendered) {\n// bug_start\n// bug_end\n    onChangeListener.onChange(String.format(Locale.US,jsBase + \".data(%s);\",view.getJsBase()));\n    js.setLength(0);\n  }\n  return this;\n}\n"}
{"INPUT": "@Override @TargetApi(Build.VERSION_CODES.KITKAT) public void sendRequest() throws IOException {\n  isLoading=false;\n  URL url=new URL(queryUrl);\n{\n    Proxy proxy=params.getProxy();\n    if (proxy != null) {\n      connection=(HttpURLConnection)url.openConnection(proxy);\n    }\n else {\n      connection=(HttpURLConnection)url.openConnection();\n    }\n    connection.setReadTimeout(params.getConnectTimeout());\n    connection.setConnectTimeout(params.getConnectTimeout());\n    connection.setInstanceFollowRedirects(params.getRedirectHandler() == null);\n    if (connection instanceof HttpsURLConnection) {\n      SSLSocketFactory sslSocketFactory=params.getSslSocketFactory();\n      if (sslSocketFactory != null) {\n        ((HttpsURLConnection)connection).setSSLSocketFactory(sslSocketFactory);\n      }\n    }\n  }\n{\n    try {\n      Map<String,List<String>> singleMap=COOKIE_MANAGER.get(url.toURI(),new HashMap<String,List<String>>(0));\n      List<String> cookies=singleMap.get(\"Cookie\");\n      if (cookies != null) {\n        connection.setRequestProperty(\"Cookie\",TextUtils.join(\";\",cookies));\n      }\n    }\n catch (    Throwable ex) {\n      LogUtil.e(ex.getMessage(),ex);\n    }\n    HashMap<String,String> headers=params.getHeaders();\n    if (headers != null) {\n      for (      Map.Entry<String,String> entry : headers.entrySet()) {\n        String name=entry.getKey();\n        String value=entry.getValue();\n        if (!TextUtils.isEmpty(name) && !TextUtils.isEmpty(value)) {\n          connection.setRequestProperty(name,value);\n        }\n      }\n    }\n  }\n{\n    HttpMethod method=params.getMethod();\n    connection.setRequestMethod(method.toString());\n    if (HttpMethod.permitsRequestBody(method)) {\n      RequestBody body=params.getRequestBody();\n      if (body != null) {\n        if (body instanceof ProgressBody) {\n          ((ProgressBody)body).setProgressHandler(progressHandler);\n        }\n        String contentType=body.getContentType();\n        if (!TextUtils.isEmpty(contentType)) {\n          connection.setRequestProperty(\"Content-Type\",contentType);\n        }\n        long contentLength=body.getContentLength();\n        if (contentLength < 0) {\n          connection.setChunkedStreamingMode(256 * 1024);\n        }\n else {\n          if (contentLength < Integer.MAX_VALUE) {\n            connection.setFixedLengthStreamingMode((int)contentLength);\n          }\n else           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n            connection.setFixedLengthStreamingMode(contentLength);\n          }\n else {\n            connection.setChunkedStreamingMode(256 * 1024);\n          }\n        }\n        connection.setRequestProperty(\"Content-Length\",String.valueOf(contentLength));\n        connection.setDoOutput(true);\n        body.writeTo(connection.getOutputStream());\n      }\n    }\n  }\n  int code=connection.getResponseCode();\n  if (code >= 300) {\n    HttpException httpException=new HttpException(code,this.getResponseMessage());\n    try {\n      httpException.setResult(IOUtil.readStr(connection.getInputStream(),params.getCharset()));\n    }\n catch (    Throwable ignored) {\n    }\n// bug_start\n// bug_end\n    throw httpException;\n  }\n{\n    try {\n      Map<String,List<String>> headers=connection.getHeaderFields();\n      if (headers != null) {\n        COOKIE_MANAGER.put(url.toURI(),headers);\n      }\n    }\n catch (    Throwable ex) {\n      LogUtil.e(ex.getMessage(),ex);\n    }\n  }\n  isLoading=true;\n}\n"}
{"INPUT": "@Test public void testOne() throws IOException, ExecutionException, InterruptedException {\n  Table table1=Table.open(\"Keyspace1\");\n  Table table2=Table.open(\"Keyspace2\");\n  RowMutation rm;\n  DecoratedKey dk=Util.dk(\"keymulti\");\n  ColumnFamily cf;\n  rm=new RowMutation(\"Keyspace1\",dk.key);\n  cf=ColumnFamily.create(\"Keyspace1\",\"Standard1\");\n  cf.addColumn(column(\"col1\",\"val1\",1L));\n  rm.add(cf);\n  rm.apply();\n  rm=new RowMutation(\"Keyspace2\",dk.key);\n  cf=ColumnFamily.create(\"Keyspace2\",\"Standard3\");\n  cf.addColumn(column(\"col2\",\"val2\",1L));\n  rm.add(cf);\n  rm.apply();\n  table1.getColumnFamilyStore(\"Standard1\").clearUnsafe();\n  table2.getColumnFamilyStore(\"Standard3\").clearUnsafe();\n// bug_start\n// bug_end\n  CommitLog.recover();\n  assertColumns(Util.getColumnFamily(table1,dk,\"Standard1\"),\"col1\");\n  assertColumns(Util.getColumnFamily(table2,dk,\"Standard3\"),\"col2\");\n}\n"}
{"INPUT": "@Override public byte[] modify(ClassLoader classLoader,String className,ProtectionDomain protectedDomain,byte[] classFileBuffer){\n  if (logger.isInfoEnabled()) {\n    logger.info(\"Modifing. {}\",className);\n  }\n// bug_start\n// bug_end\n  try {\n    final InstrumentClass instrumentClass=byteCodeInstrumentor.getClass(className);\n    instrumentClass.addTraceValue(MapTraceValue.class);\n    final Interceptor constructorInterceptor=byteCodeInstrumentor.newInterceptor(classLoader,protectedDomain,\"com.nhn.pinpoint.profiler.modifier.redis.interceptor.RedisClusterConstructorInterceptor\");\n    instrumentClass.addConstructorInterceptor(new String[]{\"java.lang.String\"},constructorInterceptor);\n    instrumentClass.addConstructorInterceptor(new String[]{\"java.lang.String\",\"int\"},constructorInterceptor);\n    instrumentClass.addConstructorInterceptor(new String[]{\"java.lang.String\",\"int\",\"int\"},constructorInterceptor);\n    final List<Method> declaredMethods=instrumentClass.getDeclaredMethods(new NameBasedMethodFilter(RedisClusterMethodNames.get()));\n    for (    Method method : declaredMethods) {\n      final Interceptor methodInterceptor=byteCodeInstrumentor.newInterceptor(classLoader,protectedDomain,\"com.nhn.pinpoint.profiler.modifier.redis.interceptor.RedisClusterMethodInterceptor\");\n      instrumentClass.addInterceptor(method.getMethodName(),method.getMethodParams(),methodInterceptor);\n    }\n    return instrumentClass.toBytecode();\n  }\n catch (  Exception e) {\n    if (logger.isWarnEnabled()) {\n      logger.warn(\"redis.RedisClusterModifier(nBase-ARC) fail. Target class is \" + getTargetClass() + \", Caused \"+ e.getMessage(),e);\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "@Override protected void install(String projectName,String variantName,String appPackageName,IDevice device,Collection<File> apkFiles) throws Exception {\n  String patchInstallDirectory=getPatchInstallDirectory();\n  if (apkFiles != null) {\n    for (    File apkFile : apkFiles) {\n      getLogger().lifecycle(\"Installing awb '{}' on '{}' for {}:{}\",apkFile,device.getName(),projectName,variantName);\n      installPatch(device,apkFile,apkFile.getName(),patchInstallDirectory,getAppPackageName());\n    }\n// bug_start\n// bug_end\n  }\n}\n"}
{"INPUT": "public void stop(){\n  try {\n    if (useShutdownHook) {\n      Runtime.getRuntime().removeShutdownHook(shutdownHook);\n      LogManager logManager=LogManager.getLogManager();\n      if (logManager instanceof ClassLoaderLogManager) {\n        ((ClassLoaderLogManager)logManager).setUseShutdownHook(true);\n      }\n    }\n  }\n catch (  Throwable t) {\n    ExceptionUtils.handleThrowable(t);\n  }\n  try {\n    Server s=getServer();\n    LifecycleState state=s.getState();\n    if (LifecycleState.STOPPING_PREP.compareTo(state) <= 0 && LifecycleState.DESTROYED.compareTo(state) >= 0) {\n    }\n else {\n      s.stop();\n// bug_start\n// bug_end\n    }\n  }\n catch (  LifecycleException e) {\n    log.error(\"Catalina.stop\",e);\n  }\n}\n"}
{"INPUT": "@Test public void test_inflate_impl(){\n  for (int l=0; l < 2; ++l) {\n    NewChunk nc=new NewChunk(null,0);\n    int[] vals=new int[]{-2147483647,0,2147483647};\n    if (l == 1)     nc.addNA();\n    for (    int v : vals)     nc.addNum(v,0);\n    nc.addNA();\n    Chunk cc=nc.compress();\n    Assert.assertEquals(vals.length + 1 + l,cc.len());\n    Assert.assertTrue(cc instanceof C4Chunk);\n    for (int i=0; i < vals.length; ++i)     Assert.assertEquals(vals[i],cc.at80(l + i));\n    for (int i=0; i < vals.length; ++i)     Assert.assertEquals(vals[i],cc.at8(l + i));\n    Assert.assertTrue(cc.isNA0(vals.length + l));\n    Assert.assertTrue(cc.isNA(vals.length + l));\n    nc=new NewChunk(null,0);\n    cc.inflate_impl(nc);\n// bug_start\n// bug_end\n    if (l == 1)     Assert.assertTrue(cc.isNA0(0));\n    Assert.assertEquals(vals.length + l + 1,nc.sparseLen());\n    Assert.assertEquals(vals.length + l + 1,nc.len());\n    Iterator<NewChunk.Value> it=nc.values(0,vals.length + 1 + l);\n    for (int i=0; i < vals.length + 1 + l; ++i)     Assert.assertTrue(it.next().rowId0() == i);\n    Assert.assertTrue(!it.hasNext());\n    for (int i=0; i < vals.length; ++i)     Assert.assertEquals(vals[i],nc.at80(l + i));\n    for (int i=0; i < vals.length; ++i)     Assert.assertEquals(vals[i],nc.at8(l + i));\n    Assert.assertTrue(cc.isNA0(vals.length + l));\n    Chunk cc2=nc.compress();\n    Assert.assertEquals(vals.length + 1 + l,cc.len());\n    Assert.assertTrue(cc2 instanceof C4Chunk);\n    for (int i=0; i < vals.length; ++i)     Assert.assertEquals(vals[i],cc2.at80(l + i));\n    for (int i=0; i < vals.length; ++i)     Assert.assertEquals(vals[i],cc2.at8(l + i));\n    Assert.assertTrue(cc2.isNA0(vals.length + l));\n    Assert.assertTrue(cc2.isNA(vals.length + l));\n    Assert.assertTrue(Arrays.equals(cc._mem,cc2._mem));\n  }\n}\n"}
{"INPUT": "private ModDiscoverer identifyMods(List<String> additionalContainers){\n  injectedContainers.addAll(additionalContainers);\n  FMLLog.fine(\"Building injected Mod Containers %s\",injectedContainers);\n// bug_start\n// bug_end\n  mods.add(new InjectedModContainer(mcp,new File(\"minecraft.jar\")));\n  for (  String cont : injectedContainers) {\n    ModContainer mc;\n    try {\n      mc=(ModContainer)Class.forName(cont,true,modClassLoader).newInstance();\n    }\n catch (    Exception e) {\n      FMLLog.log(Level.ERROR,e,\"A problem occurred instantiating the injected mod container %s\",cont);\n      throw new LoaderException(e);\n    }\n    mods.add(new InjectedModContainer(mc,mc.getSource()));\n  }\n  ModDiscoverer discoverer=new ModDiscoverer();\n  FMLLog.fine(\"Attempting to load mods contained in the minecraft jar file and associated classes\");\n  discoverer.findClasspathMods(modClassLoader);\n  FMLLog.fine(\"Minecraft jar mods loaded successfully\");\n  FMLLog.getLogger().log(Level.INFO,\"Found {} mods from the command line. Injecting into mod discoverer\",ModListHelper.additionalMods.size());\n  FMLLog.info(\"Searching %s for mods\",canonicalModsDir.getAbsolutePath());\n  discoverer.findModDirMods(canonicalModsDir,ModListHelper.additionalMods.values().toArray(new File[0]));\n  File versionSpecificModsDir=new File(canonicalModsDir,mccversion);\n  if (versionSpecificModsDir.isDirectory()) {\n    FMLLog.info(\"Also searching %s for mods\",versionSpecificModsDir);\n    discoverer.findModDirMods(versionSpecificModsDir);\n  }\n  mods.addAll(discoverer.identifyMods());\n  identifyDuplicates(mods);\n  namedMods=Maps.uniqueIndex(mods,new ModIdFunction());\n  FMLLog.info(\"Forge Mod Loader has identified %d mod%s to load\",mods.size(),mods.size() != 1 ? \"s\" : \"\");\n  return discoverer;\n}\n"}
{"INPUT": "public static Test suite(){\n  TestSuite suite=new TestSuite();\n  suite.addTestSuite(LoggerContextTest.class);\n  suite.addTest(new JUnit4TestAdapter(LoggerPerfTest.class));\n  suite.addTest(new JUnit4TestAdapter(DynamicLoggerContextTest.class));\n  suite.addTest(new JUnit4TestAdapter(PatternLayoutTest.class));\n  suite.addTestSuite(BasicLoggerTest.class);\n// bug_start\n// bug_end\n  suite.addTestSuite(MessageFormattingTest.class);\n  suite.addTestSuite(MDCTest.class);\n  suite.addTestSuite(TurboFilteringInLoggerTest.class);\n  return suite;\n}\n"}
{"INPUT": "SamplerWindow(){\n  VerticalLayout mainExpand=new VerticalLayout();\n  setLayout(mainExpand);\n  setSizeFull();\n  mainExpand.setSizeFull();\n  HorizontalLayout nav=new HorizontalLayout();\n  mainExpand.addComponent(nav);\n  nav.setHeight(\"50px\");\n  nav.setWidth(\"100%\");\n  nav.setStyleName(\"topbar\");\n  nav.setSpacing(true);\n  nav.setMargin(false,true,false,true);\n  Component logo=createLogo();\n  nav.addComponent(logo);\n  nav.setComponentAlignment(logo,Alignment.MIDDLE_LEFT);\n  nav.addComponent(breadcrumbs);\n  nav.setExpandRatio(breadcrumbs,1);\n  nav.setComponentAlignment(breadcrumbs,Alignment.MIDDLE_LEFT);\n  nav.addComponent(webAnalytics);\n  nav.addComponent(uriFragmentUtility);\n  uriFragmentUtility.addListener(new FragmentChangedListener(){\n    public void fragmentChanged(    FragmentChangedEvent source){\n      String frag=source.getUriFragmentUtility().getFragment();\n      setFeature(frag);\n    }\n  }\n);\n  Button b=createPrevButton();\n  nav.addComponent(b);\n  nav.setComponentAlignment(b,Alignment.MIDDLE_LEFT);\n  b=createNextButton();\n  nav.addComponent(b);\n  nav.setComponentAlignment(b,Alignment.MIDDLE_LEFT);\n  Component search=createSearch();\n  nav.addComponent(search);\n  nav.setComponentAlignment(search,Alignment.MIDDLE_LEFT);\n  mainExpand.addComponent(toggleBar);\n  toggleBar.setHeight(\"40px\");\n  toggleBar.setWidth(\"100%\");\n  toggleBar.setStyleName(\"togglebar\");\n  toggleBar.setSpacing(true);\n  toggleBar.setMargin(false,true,false,true);\n  mainSplit=new SplitPanel(SplitPanel.ORIENTATION_HORIZONTAL);\n  mainSplit.setSizeFull();\n  mainExpand.addComponent(mainSplit);\n  mainExpand.setExpandRatio(mainSplit,1);\n  navigationTree=createMenuTree();\n  mainSplit.addComponent(navigationTree);\n  mainSplit.addComponent(mainArea);\n  Component treeSwitch=createTreeSwitch();\n  toggleBar.addComponent(treeSwitch);\n  toggleBar.setExpandRatio(treeSwitch,1);\n  toggleBar.setComponentAlignment(treeSwitch,Alignment.MIDDLE_RIGHT);\n  Component mode=createModeSwitch();\n  toggleBar.addComponent(mode);\n  toggleBar.setComponentAlignment(mode,Alignment.MIDDLE_RIGHT);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Test public void testExcept(){\n  assertQuery(\"SELECT regionkey FROM nation WHERE nationkey < 7 \" + \"EXCEPT select regionkey FROM nation WHERE nationkey > 21\");\n  assertQuery(\"SELECT regionkey FROM nation WHERE nationkey < 7 \" + \"EXCEPT DISTINCT SELECT regionkey FROM nation WHERE nationkey > 21\",\"VALUES 0, 4\");\n  assertQuery(\"WITH wnation AS (SELECT nationkey, regionkey FROM nation) \" + \"SELECT regionkey FROM wnation WHERE nationkey < 7 \" + \"EXCEPT SELECT regionkey FROM wnation WHERE nationkey > 21\",\"VALUES 0, 4\");\n  assertQuery(\"SELECT num FROM (SELECT 1 as num FROM nation WHERE nationkey=10 \" + \"EXCEPT SELECT 2 FROM nation WHERE nationkey=20) T\");\n  assertQuery(\"SELECT nationkey, nationkey / 2 FROM (SELECT nationkey FROM nation WHERE nationkey < 10 \" + \"EXCEPT SELECT nationkey FROM nation WHERE nationkey > 4) T WHERE nationkey % 2 = 0\");\n  assertQuery(\"SELECT regionkey FROM (SELECT regionkey FROM nation WHERE nationkey < 7 \" + \"EXCEPT SELECT regionkey FROM nation WHERE nationkey > 21) \" + \"UNION SELECT 3\");\n  assertQuery(\"SELECT regionkey FROM (SELECT regionkey FROM nation WHERE nationkey < 7 \" + \"UNION SELECT regionkey FROM nation WHERE nationkey > 21) \" + \"EXCEPT SELECT 1\");\n  assertQuery(\"SELECT regionkey FROM (SELECT regionkey FROM nation WHERE nationkey < 7 \" + \"EXCEPT SELECT regionkey FROM nation WHERE nationkey > 21) \" + \"UNION ALL SELECT 4\");\n  assertQuery(\"SELECT * FROM (VALUES 1, 2) \" + \"EXCEPT SELECT * FROM (VALUES 3.0, 2)\");\n  assertQuery(\"SELECT NULL, NULL EXCEPT SELECT NULL, NULL FROM nation\");\n// bug_start\n// bug_end\n  MaterializedResult emptyResult=computeActual(\"SELECT 0 EXCEPT (SELECT regionkey FROM nation WHERE nationkey <10)\");\n  assertEquals(emptyResult.getMaterializedRows().size(),0);\n}\n"}
{"INPUT": "public void ackCompleteness(ReasonerAtomicQuery query){\n// bug_start\n// bug_end\n  if (query.getAtom().getPredicates(IdPredicate.class).findFirst().isPresent()) {\n    completeQueries.add(query);\n  }\n else {\n    completeEntries.add(queryToKey(query));\n  }\n}\n"}
{"INPUT": "@Override protected void inBetween(ZContext ctx,Socket client){\n  ZMQ.Poller poller=ctx.createPoller(1);\n  poller.register(client,ZMQ.Poller.POLLIN);\n  int rc=poller.poll(REQUEST_TIMEOUT);\n  assertThat(rc,is(1));\n  boolean readable=poller.pollin(0);\n  assertThat(readable,is(true));\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Inject public QuartzSchedulerService(ZeppelinConfiguration zeppelinConfiguration,Notebook notebook) throws SchedulerException {\n  this.zeppelinConfiguration=zeppelinConfiguration;\n  this.notebook=notebook;\n  this.scheduler=getScheduler();\n// bug_start\n// bug_end\n  this.scheduler.start();\n  this.loadingNotesThread=new Thread(null);\n  loadingNotesThread.setName(\"Init CronJob Thread\");\n  loadingNotesThread.setDaemon(true);\n  loadingNotesThread.start();\n}\n"}
{"INPUT": "public static serverObjects respond(@SuppressWarnings(\"unused\") final RequestHeader header,final serverObjects post,final serverSwitch env){\n  final serverObjects prop=new serverObjects();\n  final Switchboard sb=(Switchboard)env;\n  boolean edit=post != null && post.containsKey(\"edit\");\n  prop.put(\"servertable_edit\",edit ? 1 : 0);\n  prop.put(\"embedded\",post == null ? 0 : post.containsKey(\"embedded\") ? 1 : 0);\n  prop.put(\"servertable\",0);\n  if (Scanner.scancacheSize() > 0) {\n    final Map<byte[],String> apiCommentCache=WorkTables.commentCache(sb);\n    prop.put(\"servertable\",1);\n    String urlString;\n    DigestURI u;\n    table:     while (true) {\n      try {\n        int i=0;\n        final Iterator<Map.Entry<Scanner.Service,Scanner.Access>> se=Scanner.scancacheEntries();\n        Map.Entry<Scanner.Service,Scanner.Access> host;\n        while (se.hasNext()) {\n          host=se.next();\n          try {\n            u=host.getKey().url();\n            urlString=u.toNormalform(true);\n            prop.put(\"servertable_list_\" + i + \"_edit\",edit ? 1 : 0);\n            prop.put(\"servertable_list_\" + i + \"_edit_pk\",ASCII.String(u.hash()));\n            prop.put(\"servertable_list_\" + i + \"_edit_count\",i);\n            prop.putHTML(\"servertable_list_\" + i + \"_protocol\",u.getProtocol());\n            prop.putHTML(\"servertable_list_\" + i + \"_ip\",host.getKey().getInetAddress().getHostAddress());\n            prop.putHTML(\"servertable_list_\" + i + \"_url\",urlString);\n            prop.put(\"servertable_list_\" + i + \"_accessUnknown\",host.getValue() == Access.unknown ? 1 : 0);\n            prop.put(\"servertable_list_\" + i + \"_accessEmpty\",host.getValue() == Access.empty ? 1 : 0);\n            prop.put(\"servertable_list_\" + i + \"_accessGranted\",host.getValue() == Access.granted ? 1 : 0);\n            prop.put(\"servertable_list_\" + i + \"_accessDenied\",host.getValue() == Access.denied ? 1 : 0);\n            prop.put(\"servertable_list_\" + i + \"_process\",Scanner.inIndex(apiCommentCache,urlString) == null ? 0 : 1);\n            prop.put(\"servertable_list_\" + i + \"_edit_preselected\",host.getValue() == Access.granted && Scanner.inIndex(apiCommentCache,urlString) == null ? 1 : 0);\n            i++;\n          }\n catch (          final MalformedURLException e) {\n            ConcurrentLog.logException(e);\n          }\n        }\n        prop.put(\"servertable_list\",i);\n        prop.put(\"servertable_edit_num\",i);\n        break table;\n      }\n catch (      final ConcurrentModificationException e) {\n// bug_start\n// bug_end\n        continue table;\n      }\n    }\n  }\n  return prop;\n}\n"}
{"INPUT": "public void process(Exchange exchange) throws Exception {\n  Message in=exchange.getIn();\n  assertEquals(\"Get a wrong attachement size\",1,in.getAttachments().size());\n  DataHandler data=in.getAttachment(\"NOTICE.txt\");\n  assertNotNull(\"Should get the DataHandle NOTICE.txt\",data);\n  assertEquals(\"Get a wrong content type\",\"text/plain\",data.getContentType());\n// bug_start\n// bug_end\n  exchange.getOut().setBody(in.getHeader(\"comment\"));\n}\n"}
{"INPUT": "private MockResponse postRequest(RecordedRequest request,String expectedRequestContent,String location,String contentType,byte[] responseBody){\n// bug_start\n// bug_end\n  assertTrue(\"Invalid request content-length\",Integer.parseInt(request.getHeader(\"Content-Length\")) > 0);\n  String requestContentType=request.getHeader(\"Content-Type\");\n  assertNotNull(\"No content-type\",requestContentType);\n  Charset charset=StandardCharsets.ISO_8859_1;\n  if (requestContentType.contains(\"charset=\")) {\n    String charsetName=requestContentType.split(\"charset=\")[1];\n    charset=Charset.forName(charsetName);\n  }\n  assertEquals(\"Invalid request body\",expectedRequestContent,request.getBody().readString(charset));\n  Buffer buf=new Buffer();\n  buf.write(responseBody);\n  return new MockResponse().setHeader(\"Location\",baseUrl + location).setHeader(\"Content-Type\",contentType).setHeader(\"Content-Length\",responseBody.length).setBody(buf).setResponseCode(201);\n}\n"}
{"INPUT": "public void testCreateRemove() throws Exception {\n  final String name=IgniteUuid.randomUuid().toString();\n  final Ignite ignite=ignite(0);\n  assertNull(ignite.atomicLong(name,0,false));\n  IgniteAtomicReference<Integer> ref=ignite.atomicReference(name,0,true);\n  assertNotNull(ref);\n  assertSame(ref,ignite.atomicReference(name,0,true));\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.atomicLong(name,0,false);\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.atomicLong(name,0,true);\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  ref.close();\n  IgniteAtomicLong atomicLong=ignite.atomicLong(name,0,true);\n  assertNotNull(atomicLong);\n  assertSame(atomicLong,ignite.atomicLong(name,0,true));\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.atomicReference(name,0,false);\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.queue(name,0,config(false));\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.queue(name,0,null);\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.set(name,config(false));\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.set(name,null);\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  atomicLong.close();\n  IgniteQueue<Integer> q=ignite.queue(name,0,config(false));\n  assertNotNull(q);\n  assertSame(q,ignite.queue(name,0,config(false)));\n  assertSame(q,ignite.queue(name,0,null));\n  q.close();\n  assertNull(ignite.set(name,null));\n  IgniteSet<Integer> set=ignite.set(name,config(false));\n  assertNotNull(set);\n  assertSame(set,ignite.set(name,config(false)));\n  assertSame(set,ignite.set(name,null));\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.atomicReference(name,0,false);\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.queue(name,0,config(false));\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  GridTestUtils.assertThrows(log,new Callable<Void>(){\n    @Override public Void call() throws Exception {\n      ignite.queue(name,0,null);\n      return null;\n    }\n  }\n,IgniteException.class,null);\n  set.close();\n  ref=ignite.atomicReference(name,0,true);\n  assertNotNull(ref);\n  assertSame(ref,ignite.atomicReference(name,0,true));\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n  XContentParser parser=parseContext.parser();\n  XContentParser.Token token=parser.nextToken();\n  if (token != XContentParser.Token.FIELD_NAME) {\n    throw new QueryParsingException(parseContext.index(),\"[wrapper] filter malformed\");\n  }\n  String fieldName=parser.currentName();\n  if (!fieldName.equals(\"filter\")) {\n    throw new QueryParsingException(parseContext.index(),\"[wrapper] filter malformed\");\n  }\n  parser.nextToken();\n  byte[] querySource=parser.binaryValue();\n  try (XContentParser qSourceParser=XContentFactory.xContent(querySource).createParser(querySource)){\n    final QueryParseContext context=new QueryParseContext(parseContext.index(),parseContext.indexQueryParserService());\n    context.reset(qSourceParser);\n    Filter result=context.parseInnerFilter();\n    parser.nextToken();\n// bug_start\n// bug_end\n    return result;\n  }\n }\n"}
{"INPUT": "@Override public void onReceive(Context context,Intent intent){\n  String accountName=intent.getStringExtra(FileUploader.ACCOUNT_NAME);\n  if (!isEmpty() && accountName.equals(mAccount.name)) {\n    boolean uploadWasFine=intent.getBooleanExtra(FileUploader.EXTRA_UPLOAD_RESULT,false);\n    String uploadRemotePath=intent.getStringExtra(FileUploader.EXTRA_REMOTE_PATH);\n    boolean renamedInUpload=mFile.getRemotePath().equals(intent.getStringExtra(FileUploader.EXTRA_OLD_REMOTE_PATH));\n    if (mFile.getRemotePath().equals(uploadRemotePath) || renamedInUpload) {\n      if (uploadWasFine) {\n        mFile=mStorageManager.getFileByPath(mFile.getRemotePath());\n      }\n      if (renamedInUpload) {\n        String newName=(new File(uploadRemotePath)).getName();\n        Toast msg=Toast.makeText(getActivity().getApplicationContext(),String.format(getString(R.string.filedetails_renamed_in_upload_msg),newName),Toast.LENGTH_LONG);\n        msg.show();\n// bug_start\n// bug_end\n      }\n      updateFileDetails(false);\n    }\n  }\n}\n"}
{"INPUT": "@Override public INDArray[] executeGraph(SameDiff sd,ExecutorConfiguration configuration){\n  Map<Integer,Node> intermediate=new HashMap<>();\n  ByteBuffer buffer=convertToFlatBuffers(sd,configuration,intermediate);\n  BytePointer bPtr=new BytePointer(buffer);\n  log.info(\"Buffer length: {}\",buffer.limit());\n  Pointer res=NativeOpsHolder.getInstance().getDeviceNativeOps().executeFlatGraphFloat(null,bPtr);\n  if (res == null)   throw new ND4JIllegalStateException(\"Graph execution failed\");\n  PagedPointer pagedPointer=new PagedPointer(res,1024 * 1024L);\n  FlatResult fr=FlatResult.getRootAsFlatResult(pagedPointer.asBytePointer().asByteBuffer());\n  log.info(\"VarMap: {}\",sd.variableMap());\n  INDArray[] results=new INDArray[fr.variablesLength()];\n  for (int e=0; e < fr.variablesLength(); e++) {\n    FlatVariable var=fr.variables(e);\n// bug_start\n// bug_end\n    FlatArray ndarray=var.ndarray();\n    INDArray val=Nd4j.createFromFlatArray(ndarray);\n    results[e]=val;\n    if (var.name() != null && sd.variableMap().containsKey(var.name())) {\n      sd.associateArrayWithVariable(val,sd.variableMap().get(var.name()));\n    }\n else {\n      if (sd.variableMap().get(var.name()) != null) {\n        sd.associateArrayWithVariable(val,sd.getVariable(var.name()));\n      }\n else {\n        throw new ND4JIllegalStateException(\"Unknown variable received as result: [\" + var.name() + \"]\");\n      }\n    }\n  }\n  return results;\n}\n"}
{"INPUT": "public static ImmutableDoubleArray of(double first,double... rest){\n// bug_start\n// bug_end\n  double[] array=new double[rest.length + 1];\n  array[0]=first;\n  System.arraycopy(rest,0,array,1,rest.length);\n  return new ImmutableDoubleArray(array);\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") @Override public <K,V>MVCCTransactionMap<K,V> openMap(String name,String mapType,DataType keyType,DataType valueType,Storage storage){\n  if (keyType == null)   keyType=new ObjectDataType();\n  if (valueType == null)   valueType=new ObjectDataType();\n  checkNotClosed();\n  StorageMap<K,VersionedValue> map=storage.openMap(name,mapType,keyType,new VersionedValueType(valueType),null);\n// bug_start\n// bug_end\n  transactionEngine.addMap((StorageMap<Object,VersionedValue>)map);\n  return new MVCCTransactionMap<>(this,map);\n}\n"}
{"INPUT": "@SuppressWarnings(\"try\") protected StructuredGraph partialEval(OptimizedCallTarget compilable,Object[] arguments,AllowAssumptions allowAssumptions,CompilationIdentifier compilationId){\n  try {\n    compilable.call(arguments);\n  }\n catch (  IgnoreError e) {\n  }\n  try {\n    compilable.call(arguments);\n  }\n catch (  IgnoreError e) {\n  }\n  try {\n    compilable.call(arguments);\n  }\n catch (  IgnoreError e) {\n  }\n// bug_start\n// bug_end\n  OptionValues options=getOptions();\n  DebugContext debug=getDebugContext(options);\n  lastDebug=debug;\n  try (DebugContext.Scope s=debug.scope(\"TruffleCompilation\",new TruffleDebugJavaMethod(compilable))){\n    TruffleInlining inliningDecision=new TruffleInlining(compilable,new DefaultInliningPolicy());\n    SpeculationLog speculationLog=compilable.getCompilationSpeculationLog();\n    if (speculationLog != null) {\n      speculationLog.collectFailedSpeculations();\n    }\n    return truffleCompiler.getPartialEvaluator().createGraph(compilable.getOptionValues(),debug,compilable,inliningDecision,allowAssumptions,compilationId,speculationLog,null);\n  }\n catch (  Throwable e) {\n    throw debug.handle(e);\n  }\n}\n"}
{"INPUT": "public void animateOverScrollToAmount(float targetAmount,final boolean onTop){\n  final float startOverScrollAmount=mHostLayout.getCurrentOverScrollAmount(onTop);\n  if (targetAmount == startOverScrollAmount) {\n    return;\n  }\n  cancelOverScrollAnimators(onTop);\n  ValueAnimator overScrollAnimator=ValueAnimator.ofFloat(startOverScrollAmount,targetAmount);\n  overScrollAnimator.setDuration(ANIMATION_DURATION_STANDARD);\n  overScrollAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){\n    @Override public void onAnimationUpdate(    ValueAnimator animation){\n      float currentOverScroll=(float)animation.getAnimatedValue();\n      mHostLayout.setOverScrollAmount(currentOverScroll,onTop,false,false);\n    }\n  }\n);\n  overScrollAnimator.setInterpolator(mFastOutSlowInInterpolator);\n// bug_start\n// bug_end\n  overScrollAnimator.start();\n  if (onTop) {\n    mTopOverScrollAnimator=overScrollAnimator;\n  }\n else {\n    mBottomOverScrollAnimator=overScrollAnimator;\n  }\n}\n"}
{"INPUT": "@Override protected void configure(){\n  GinMapBinder.newMapBinder(binder(),String.class,Component.class).addBinding(\"Project templates\").to(ProjectTemplatesComponent.class);\n  GinMapBinder.newMapBinder(binder(),String.class,WsAgentComponent.class).addBinding(\"Project types\").to(ProjectTypeComponent.class);\n  bind(ProjectTypeServiceClient.class).to(ProjectTypeServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectTemplateServiceClient.class).to(ProjectTemplateServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectServiceClient.class).to(ProjectServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectTypeRegistry.class).to(ProjectTypeRegistryImpl.class).in(Singleton.class);\n  bind(ProjectTemplateRegistry.class).to(ProjectTemplateRegistryImpl.class).in(Singleton.class);\n  GinMultibinder.newSetBinder(binder(),ProjectWizardRegistrar.class).addBinding().to(BlankProjectWizardRegistrar.class);\n  bind(ProjectWizardRegistry.class).to(ProjectWizardRegistryImpl.class).in(Singleton.class);\n  install(new GinFactoryModuleBuilder().build(ProjectWizardFactory.class));\n  bind(PreSelectedProjectTypeManager.class).to(PreSelectedProjectTypeManagerImpl.class).in(Singleton.class);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public LoggerServer(){\n  this.serverConfig=new NettyServerConfig();\n  this.serverConfig.setListenPort(Constants.RPC_PORT);\n  this.server=new NettyRemotingServer(serverConfig);\n  this.requestProcessor=new LoggerRequestProcessor();\n  this.server.registerProcessor(CommandType.GET_LOG_BYTES_REQUEST,requestProcessor,requestProcessor.getExecutor());\n  this.server.registerProcessor(CommandType.ROLL_VIEW_LOG_REQUEST,requestProcessor,requestProcessor.getExecutor());\n  this.server.registerProcessor(CommandType.VIEW_WHOLE_LOG_REQUEST,requestProcessor,requestProcessor.getExecutor());\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override protected boolean fitSystemWindows(Rect insets){\n  pullChildren();\n  final int vis=ViewCompat.getWindowSystemUiVisibility(this);\n  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;\n  final Rect systemInsets=insets;\n  boolean changed=applyInsets(mActionBarTop,systemInsets,true,true,false,true);\n  if (mActionBarBottom != null) {\n    changed|=applyInsets(mActionBarBottom,systemInsets,true,false,true,true);\n  }\n  mBaseInnerInsets.set(systemInsets);\n// bug_start\n// bug_end\n  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {\n    changed=true;\n    mLastBaseContentInsets.set(mBaseContentInsets);\n  }\n  if (changed) {\n    requestLayout();\n  }\n  return true;\n}\n"}
{"INPUT": "private void revisitIndexDeletionPolicyOnTranslogSynced() throws IOException {\n  if (combinedDeletionPolicy.hasUnreferencedCommits()) {\n    indexWriter.deleteUnusedFiles();\n// bug_start\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void processTokenFilters(TokenFiltersBindings tokenFiltersBindings){\n  tokenFiltersBindings.processTokenFilter(\"snowball\",SnowballTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"stemmer\",StemmerTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"word_delimiter\",WordDelimiterTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"synonym\",SynonymTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"elision\",ElisionTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"keep\",KeepWordFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"pattern_replace\",PatternReplaceTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"dictionary_decompounder\",DictionaryCompoundWordTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"hyphenation_decompounder\",HyphenationCompoundWordTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"arabic_stem\",ArabicStemTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"brazilian_stem\",BrazilianStemTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"czech_stem\",CzechStemTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"dutch_stem\",DutchStemTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"french_stem\",FrenchStemTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"german_stem\",GermanStemTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"russian_stem\",RussianStemTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"keyword_marker\",KeywordMarkerTokenFilterFactory.class);\n  tokenFiltersBindings.processTokenFilter(\"stemmer_override\",StemmerOverrideTokenFilterFactory.class);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public static InternalSearchRequest internalSearchRequest(ShardRouting shardRouting,SearchRequest request){\n  InternalSearchRequest internalRequest=new InternalSearchRequest(shardRouting,request.source());\n// bug_start\n// bug_end\n  internalRequest.from(request.from()).size(request.size());\n  internalRequest.scroll(request.scroll());\n  internalRequest.timeout(request.timeout());\n  internalRequest.types(request.types());\n  return internalRequest;\n}\n"}
{"INPUT": "@Override public void bindAppInfosRemoved(final ArrayList<AppInfo> appInfos){\n  Runnable r=new Runnable(){\n    public void run(){\n      bindAppInfosRemoved(appInfos);\n    }\n  }\n;\n  if (waitUntilResume(r)) {\n    return;\n  }\n  if (mAppsView != null) {\n    mAppsView.removeApps(appInfos);\n// bug_start\n// bug_end\n  }\n}\n"}
{"INPUT": "private void updateResolutions(){\n  final T currentDate=getValue();\n  Map<String,Integer> resolutions=getState().resolutions;\n  resolutions.clear();\n  for (  R resolution : getResolutionsHigherOrEqualTo(getResolution())) {\n    String resolutionName=resolution.name();\n    Integer value=getValuePart(currentDate,resolution);\n    resolutions.put(resolutionName,value);\n    Integer defaultValuePart=getValuePart(defaultValue,resolution);\n    resolutions.put(\"default-\" + resolutionName,defaultValuePart);\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Test public void testTransfersByToRoute(){\n  assertTrue(anotherSampleFeed.hasNoRouteSpecificArrivalTransferRules(\"MUSEUM\"),\"Transfer model says we don't have route-dependent arrival platform at from-stop\");\n  assertTrue(anotherSampleFeed.hasNoRouteSpecificDepartureTransferRules(\"NEXT_TO_MUSEUM\"),\"Transfer model says we don't have route-dependent departure platform at to-stop\");\n  List<Transfer> transfersToStop=anotherSampleFeed.getTransfersToStop(\"NEXT_TO_MUSEUM\",null);\n  assertEquals(2,transfersToStop.size());\n  Transfer transfer=transfersToStop.get(0);\n  assertEquals(\"MUSEUM\",transfer.from_stop_id);\n  assertEquals(\"NEXT_TO_MUSEUM\",transfer.to_stop_id);\n  Assertions.assertNull(transfer.from_route_id);\n  Assertions.assertNull(transfer.to_route_id);\n// bug_start\n// bug_end\n  Transfer withinStationTransfer=transfersToStop.get(1);\n  assertEquals(\"NEXT_TO_MUSEUM\",withinStationTransfer.from_stop_id);\n  assertEquals(\"NEXT_TO_MUSEUM\",withinStationTransfer.to_stop_id);\n  assertNull(withinStationTransfer.from_route_id);\n  assertNull(withinStationTransfer.to_route_id);\n}\n"}
{"INPUT": "public void testReadOnlyEngine() throws Exception {\n  IOUtils.close(engine,store);\n  Engine readOnlyEngine=null;\n  final AtomicLong globalCheckpoint=new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n  try (Store store=createStore()){\n    EngineConfig config=config(defaultSettings,store,createTempDir(),newMergePolicy(),null,null,null);\n    int numDocs=scaledRandomIntBetween(10,1000);\n    final SeqNoStats lastSeqNoStats;\n    final List<DocIdSeqNoAndTerm> lastDocIds;\n    try (InternalEngine engine=createEngine(config)){\n      Engine.Get get=null;\n      for (int i=0; i < numDocs; i++) {\n        if (rarely()) {\n          continue;\n        }\n        ParsedDocument doc=testParsedDocument(Integer.toString(i),null,testDocument(),new BytesArray(\"{}\"),null);\n        engine.index(new Engine.Index(newUid(doc),doc,i,primaryTerm.get(),1,null,Engine.Operation.Origin.REPLICA,System.nanoTime(),-1,false));\n        if (get == null || rarely()) {\n          get=newGet(randomBoolean(),doc);\n        }\n        if (rarely()) {\n          engine.flush();\n        }\n        globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(),engine.getLocalCheckpoint()));\n      }\n      engine.syncTranslog();\n      engine.flush();\n      readOnlyEngine=new ReadOnlyEngine(engine.engineConfig,engine.getSeqNoStats(globalCheckpoint.get()),engine.getTranslogStats(),false,Function.identity());\n      lastSeqNoStats=engine.getSeqNoStats(globalCheckpoint.get());\n      lastDocIds=getDocIds(engine,true);\n      assertThat(readOnlyEngine.getLocalCheckpoint(),equalTo(lastSeqNoStats.getLocalCheckpoint()));\n      assertThat(readOnlyEngine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo(),equalTo(lastSeqNoStats.getMaxSeqNo()));\n      assertThat(getDocIds(readOnlyEngine,false),equalTo(lastDocIds));\n      for (int i=0; i < numDocs; i++) {\n        if (randomBoolean()) {\n          String delId=Integer.toString(i);\n          engine.delete(new Engine.Delete(\"test\",delId,newUid(delId),primaryTerm.get()));\n        }\n        if (rarely()) {\n          engine.flush();\n        }\n      }\n      Engine.Searcher external=readOnlyEngine.acquireSearcher(\"test\",Engine.SearcherScope.EXTERNAL);\n      Engine.Searcher internal=readOnlyEngine.acquireSearcher(\"test\",Engine.SearcherScope.INTERNAL);\n      assertSame(external.reader(),internal.reader());\n      IOUtils.close(external,internal);\n      assertThat(readOnlyEngine.getLocalCheckpoint(),equalTo(lastSeqNoStats.getLocalCheckpoint()));\n      assertThat(readOnlyEngine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo(),equalTo(lastSeqNoStats.getMaxSeqNo()));\n      assertThat(getDocIds(readOnlyEngine,false),equalTo(lastDocIds));\n      try (Engine.GetResult getResult=readOnlyEngine.get(get,null)){\n        assertTrue(getResult.exists());\n      }\n     }\n     InternalEngineTests.trimUnsafeCommits(config);\n    try (InternalEngine recoveringEngine=new InternalEngine(config)){\n// bug_start\n// bug_end\n      recoveringEngine.recoverFromTranslog(translogHandler,Long.MAX_VALUE);\n      assertThat(readOnlyEngine.getLocalCheckpoint(),equalTo(lastSeqNoStats.getLocalCheckpoint()));\n      assertThat(readOnlyEngine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo(),equalTo(lastSeqNoStats.getMaxSeqNo()));\n      assertThat(getDocIds(readOnlyEngine,false),equalTo(lastDocIds));\n    }\n   }\n  finally {\n    IOUtils.close(readOnlyEngine);\n  }\n}\n"}
{"INPUT": "private void initComponents(){\n  treeCellRenderer.setLeafIcon(null);\n  treeCellRenderer.setClosedIcon(null);\n  treeCellRenderer.setOpenIcon(null);\n  if (retainedSizeSupported)   instancesListTableModel.setRealColumnVisibility(2,instancesListController.getInstancesController().getHeapFragmentWalker().getRetainedSizesStatus() == HeapFragmentWalker.RETAINED_SIZES_COMPUTED);\n  instancesListTable=new JTreeTable(instancesListTableModel){\n    public void doLayout(){\n      int columnsWidthsSum=0;\n      int realFirstColumn=-1;\n      TableColumnModel colModel=getColumnModel();\n      for (int i=0; i < instancesListTableModel.getColumnCount(); i++) {\n        if (instancesListTableModel.getRealColumn(i) == 0) {\n          realFirstColumn=i;\n        }\n else {\n          columnsWidthsSum+=colModel.getColumn(i).getPreferredWidth();\n        }\n      }\n      if (realFirstColumn != -1) {\n        colModel.getColumn(realFirstColumn).setPreferredWidth(getWidth() - columnsWidthsSum);\n      }\n      super.doLayout();\n    }\n  }\n;\n  instancesListTable.getTree().setRootVisible(false);\n  instancesListTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  instancesListTable.setGridColor(UIConstants.TABLE_VERTICAL_GRID_COLOR);\n  instancesListTable.setSelectionBackground(UIConstants.TABLE_SELECTION_BACKGROUND_COLOR);\n  instancesListTable.setSelectionForeground(UIConstants.TABLE_SELECTION_FOREGROUND_COLOR);\n  instancesListTable.setShowHorizontalLines(UIConstants.SHOW_TABLE_HORIZONTAL_GRID);\n  instancesListTable.setShowVerticalLines(UIConstants.SHOW_TABLE_VERTICAL_GRID);\n  instancesListTable.setRowMargin(UIConstants.TABLE_ROW_MARGIN);\n  instancesListTable.setRowHeight(UIUtils.getDefaultRowHeight() + 2);\n// bug_start\n// bug_end\n  Set keys=new HashSet(instancesListTable.getFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));\n  keys.add(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,0));\n  instancesListTable.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,keys);\n  keys=new HashSet(instancesListTable.getFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));\n  keys.add(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,InputEvent.SHIFT_MASK));\n  instancesListTable.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,keys);\n  setColumnsData();\n  cornerPopup=new JPopupMenu();\n  JTreeTablePanel tablePanel=new JTreeTablePanel(instancesListTable);\n  tablePanel.setCorner(JScrollPane.UPPER_RIGHT_CORNER,createHeaderPopupCornerButton(cornerPopup));\n  setLayout(new BorderLayout());\n  add(tablePanel,BorderLayout.CENTER);\n  instancesListTable.getSelectionModel().addListSelectionListener(new ListSelectionListener(){\n    public void valueChanged(    ListSelectionEvent e){\n      if (sorting || e.getValueIsAdjusting()) {\n        return;\n      }\n      Instance selectedInstance=null;\n      int selectedRow=instancesListTable.getSelectedRow();\n      if (selectedRow != -1) {\n        HeapWalkerNode selectedNode=(HeapWalkerNode)instancesListTable.getTree().getPathForRow(selectedRow).getLastPathComponent();\n        if (selectedNode instanceof InstancesListController.InstancesListInstanceNode) {\n          selectedInstance=((InstancesListController.InstancesListInstanceNode)selectedNode).getInstance();\n        }\n      }\n      instancesListController.instanceSelected(selectedInstance);\n    }\n  }\n);\n  setPreferredSize(new Dimension(225,500));\n}\n"}
{"INPUT": "@Override protected void configure(){\n  addMigration(V20151210140600_ElasticsearchConfigMigration.class);\n  addMigration(V20161116172100_DefaultIndexSetMigration.class);\n  addMigration(V20161116172200_CreateDefaultStreamMigration.class);\n  addMigration(V20161122174500_AssignIndexSetsToStreamsMigration.class);\n  addMigration(V20161124104700_AddRetentionRotationAndDefaultFlagToIndexSetMigration.class);\n  addMigration(V20161125142400_EmailAlarmCallbackMigration.class);\n  addMigration(V20161125161400_AlertReceiversMigration.class);\n  addMigration(V20161130141500_DefaultStreamRecalcIndexRanges.class);\n  addMigration(V20161215163900_MoveIndexSetDefaultConfig.class);\n  addMigration(V20161216123500_DefaultIndexSetMigration.class);\n  addMigration(V20170110150100_FixAlertConditionsMigration.class);\n  addMigration(V20170607164210_MigrateReopenedIndicesToAliases.class);\n  addMigration(Migration.class);\n  addMigration(V2018070614390000_EnforceUniqueGrokPatterns.class);\n  addMigration(V20180718155800_AddContentPackIdAndRev.class);\n  addMigration(V20180924111644_AddDefaultGrokPatterns.class);\n  addMigration(V20190705071400_AddEventIndexSetsMigration.class);\n  addMigration(V20190730100900_AddAlertsManagerRole.class);\n  addMigration(V20190730000000_CreateDefaultEventsConfiguration.class);\n  addMigration(V20191121145100_FixDefaultGrokPatterns.class);\n  addMigration(V20191129134600_CreateInitialUrlWhitelist.class);\n  addMigration(V20191219090834_AddSourcesPage.class);\n  addMigration(V20200102140000_UnifyEventSeriesId.class);\n  addMigration(V20200226181600_EncryptAccessTokensMigration.class);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override public void inflate(Resources r,XmlPullParser parser,AttributeSet attrs,Theme theme) throws XmlPullParserException, IOException {\n  final TypedArray a=obtainAttributes(r,theme,attrs,R.styleable.AnimationDrawable);\n  super.inflateWithAttributes(r,parser,a,R.styleable.AnimationDrawable_visible);\n  updateStateFromTypedArray(a);\n// bug_start\n// bug_end\n  a.recycle();\n  inflateChildElements(r,parser,attrs,theme);\n  setFrame(0,true,false);\n}\n"}
{"INPUT": "public void deleteHistoricTaskInstanceById(String taskId){\n  HistoricTaskInstanceEntity historicTaskInstance=findHistoricTaskInstanceById(taskId);\n  if (historicTaskInstance != null) {\n    CommandContext commandContext=Context.getCommandContext();\n    commandContext.getHistoricDetailManager().deleteHistoricDetailsByTaskId(taskId);\n    commandContext.getCommentManager().deleteCommentsByTaskId(taskId);\n// bug_start\n// bug_end\n    getDbSqlSession().delete(HistoricTaskInstanceEntity.class,taskId);\n  }\n}\n"}
{"INPUT": "@Bean(\"mybatisSqlSession\") public SqlSessionFactory sqlSessionFactory(DataSource dataSource,GlobalConfig globalConfig,PaginationInterceptor paginationInterceptor) throws Exception {\n  MybatisSqlSessionFactoryBean sqlSessionFactory=new MybatisSqlSessionFactoryBean();\n  sqlSessionFactory.setDataSource(dataSource);\n  sqlSessionFactory.setTypeEnumsPackage(\"com.baomidou.mybatisplus.test.base.enums\");\n  sqlSessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:/mapper/*.xml\"));\n// bug_start\n// bug_end\n  MybatisConfiguration configuration=new MybatisConfiguration();\n  configuration.setJdbcTypeForNull(JdbcType.NULL);\n  configuration.setMapUnderscoreToCamelCase(true);\n  configuration.addInterceptor(paginationInterceptor);\n  configuration.addInterceptor(new OptimisticLockerInterceptor());\n  sqlSessionFactory.setConfiguration(configuration);\n  globalConfig.setMetaObjectHandler(new MysqlMetaObjectHandler());\n  sqlSessionFactory.setGlobalConfig(globalConfig);\n  return sqlSessionFactory.getObject();\n}\n"}
{"INPUT": "public AddJobFlowStepsResult unmarshall(JsonUnmarshallerContext context) throws Exception {\n  AddJobFlowStepsResult addJobFlowStepsResult=new AddJobFlowStepsResult();\n  int originalDepth=context.getCurrentDepth();\n  String currentParentElement=context.getCurrentParentElement();\n  int targetDepth=originalDepth + 1;\n  JsonToken token=context.currentToken;\n  if (token == null)   token=context.nextToken();\n  if (token == VALUE_NULL)   return null;\n  while (true) {\n    if (token == null)     break;\n    if (token == FIELD_NAME || token == START_OBJECT) {\n      if (context.testExpression(\"StepIds\",targetDepth)) {\n// bug_start\n// bug_end\n        addJobFlowStepsResult.setStepIds(new ListUnmarshaller<String>(StringJsonUnmarshaller.getInstance()).unmarshall(context));\n      }\n    }\n else     if (token == END_ARRAY || token == END_OBJECT) {\n      if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n        if (context.getCurrentDepth() <= originalDepth)         break;\n      }\n    }\n    token=context.nextToken();\n  }\n  return addJobFlowStepsResult;\n}\n"}
{"INPUT": "@Test public void testServletRequestLogout() throws Exception {\n  driver.navigate().to(\"http://localhost:8081/customer-portal\");\n  Assert.assertTrue(driver.getCurrentUrl().startsWith(LOGIN_URL));\n  loginPage.login(\"bburke@redhat.com\",\"password\");\n  Assert.assertEquals(driver.getCurrentUrl(),\"http://localhost:8081/customer-portal\");\n  Assert.assertTrue(driver.getPageSource().contains(\"Bill Burke\"));\n  driver.navigate().to(\"http://localhost:8081/product-portal\");\n  Assert.assertEquals(driver.getCurrentUrl(),\"http://localhost:8081/product-portal\");\n  Assert.assertTrue(driver.getPageSource().contains(\"iPhone\"));\n  driver.navigate().to(\"http://localhost:8081/customer-portal/logout\");\n// bug_start\n// bug_end\n  driver.navigate().to(\"http://localhost:8081/customer-portal\");\n  String currentUrl=driver.getCurrentUrl();\n  Assert.assertTrue(currentUrl.startsWith(LOGIN_URL));\n  driver.navigate().to(\"http://localhost:8081/product-portal\");\n  Assert.assertTrue(driver.getCurrentUrl().startsWith(LOGIN_URL));\n}\n"}
{"INPUT": "@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){\n  spiedContext.sendOrderedBroadcastAsUser(intent,user,receiverPermission,resultReceiver,scheduler,initialCode,initialData,initialExtras);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public HttpPanelRequest(boolean isEditable,String configurationKey){\n  super(isEditable,configurationKey + REQUEST_KEY);\n  HttpPanelManager.getInstance().addRequestPanel(this);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Test public void testRITAssignmentManagerMetrics() throws Exception {\n  final TableName TABLENAME=TableName.valueOf(name.getMethodName());\n  final byte[] FAMILY=Bytes.toBytes(\"family\");\n  try (Table table=TEST_UTIL.createTable(TABLENAME,FAMILY)){\n    final byte[] row=Bytes.toBytes(\"row\");\n    final byte[] qualifier=Bytes.toBytes(\"qualifier\");\n    final byte[] value=Bytes.toBytes(\"value\");\n    Put put=new Put(row);\n    put.addColumn(FAMILY,qualifier,value);\n    table.put(put);\n    Thread.sleep(MSG_INTERVAL * 3);\n    MetricsAssignmentManagerSource amSource=MASTER.getAssignmentManager().getAssignmentManagerMetrics().getMetricsProcSource();\n    METRICS_HELPER.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME,0,amSource);\n    METRICS_HELPER.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME,0,amSource);\n    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TABLENAME).setColumnFamily(ColumnFamilyDescriptorBuilder.of(FAMILY)).setCoprocessor(CoprocessorDescriptorBuilder.newBuilder(\"com.foo.FooRegionObserver\").setJarPath(\"hdfs:///foo.jar\").setPriority(1001).setProperty(\"arg1\",\"1\").setProperty(\"arg2\",\"2\").build()).build();\n    try {\n      TEST_UTIL.getAdmin().modifyTable(htd);\n      fail(\"Expected region failed to open\");\n    }\n catch (    IOException e) {\n      LOG.info(\"Expected error\",e);\n    }\n    TEST_UTIL.waitUntilNoRegionsInTransition();\n    Thread.sleep(MSG_INTERVAL * 5);\n    METRICS_HELPER.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME,1,amSource);\n    METRICS_HELPER.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME,1,amSource);\n// bug_start\n// bug_end\n  }\n }\n"}
{"INPUT": "@Override public void visit(final GroovyCodeVisitor visitor){\n  if (visitor instanceof AsmClassGenerator) {\n    AsmClassGenerator acg=(AsmClassGenerator)visitor;\n    WriterController controller=acg.getController();\n    if (type == ClassHelper.boolean_TYPE) {\n      expression.visit(visitor);\n// bug_start\n// bug_end\n      return;\n    }\n    if (type == ClassHelper.Boolean_TYPE) {\n      expression.visit(visitor);\n      MethodVisitor mv=controller.getMethodVisitor();\n      mv.visitMethodInsn(INVOKEVIRTUAL,\"java/lang/Boolean\",\"booleanValue\",\"()Z\");\n      controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n      return;\n    }\n    if (type == ClassHelper.int_TYPE || type == ClassHelper.byte_TYPE || type == ClassHelper.short_TYPE || type == ClassHelper.char_TYPE) {\n      expression.visit(visitor);\n      return;\n    }\n else     if (type == ClassHelper.long_TYPE) {\n      expression.visit(visitor);\n      MethodVisitor mv=controller.getMethodVisitor();\n      mv.visitInsn(L2I);\n      controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n      return;\n    }\n else     if (type == ClassHelper.float_TYPE) {\n      expression.visit(visitor);\n      MethodVisitor mv=controller.getMethodVisitor();\n      mv.visitInsn(F2I);\n      controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n      return;\n    }\n else     if (type == ClassHelper.double_TYPE) {\n      expression.visit(visitor);\n      MethodVisitor mv=controller.getMethodVisitor();\n      mv.visitInsn(D2I);\n      controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n      return;\n    }\n    List<MethodNode> asBoolean=findDGMMethodsByNameAndArguments(type,\"asBoolean\",ClassNode.EMPTY_ARRAY);\n    if (asBoolean.size() == 1) {\n      MethodNode node=asBoolean.get(0);\n      if (node instanceof ExtensionMethodNode) {\n        MethodNode dgmNode=((ExtensionMethodNode)node).getExtensionMethodNode();\n        ClassNode owner=dgmNode.getParameters()[0].getType();\n        if (ClassHelper.OBJECT_TYPE.equals(owner)) {\n          if (Modifier.isFinal(type.getModifiers()) || (type instanceof InnerClassNode && Modifier.isPrivate(type.getModifiers()) && !isExtended(type,type.getOuterClass().getInnerClasses()))) {\n            CompareToNullExpression expr=new CompareToNullExpression(expression,false);\n            expr.visit(acg);\n            return;\n          }\n        }\n      }\n    }\n    super.visit(visitor);\n  }\n else {\n    super.visit(visitor);\n  }\n}\n"}
{"INPUT": "public SingleConnectionManager(SingleConnectionConfig cfg,Config config){\n  MasterSlaveConnectionConfig newconfig=new MasterSlaveConnectionConfig();\n  String addr=cfg.getAddress().getHost() + \":\" + cfg.getAddress().getPort();\n// bug_start\n// bug_end\n  newconfig.setMasterAddress(addr);\n  newconfig.setMasterConnectionPoolSize(cfg.getConnectionPoolSize());\n  newconfig.setSubscriptionsPerConnection(cfg.getSubscriptionsPerConnection());\n  subscribeConnectionsSemaphore=new Semaphore(cfg.getSubscriptionConnectionPoolSize());\n  init(newconfig,config);\n}\n"}
{"INPUT": "@Test public void testFortranReshapeMatrix(){\n  double[][] data=new double[][]{{1,2,3,4},{5,6,7,8}};\n// bug_start\n// bug_end\n  DoubleMatrix d=new DoubleMatrix(data);\n  INDArray d2=NDArrays.create(data);\n  assertEquals(d.rows,d2.rows());\n  assertEquals(d.columns,d2.columns());\n  verifyElements(d,d2);\n  DoubleMatrix reshapedD=d.reshape(4,2);\n  INDArray reshapedD2=d2.reshape(4,2);\n  verifyElements(reshapedD,reshapedD2);\n}\n"}
{"INPUT": "private static SkaffoldSyncMapTemplate generateTemplate(TestProject project,@Nullable String moduleName,@Nullable List<String> params) throws IOException {\n  String taskName=\":\" + (moduleName == null ? \"\" : moduleName + \":\") + JibPlugin.SKAFFOLD_SYNC_MAP_TASK_NAME;\n  List<String> buildParams=new ArrayList<>();\n  buildParams.add(taskName);\n  buildParams.add(\"-q\");\n// bug_start\n// bug_end\n  buildParams.add(\"--stacktrace\");\n  if (params != null) {\n    buildParams.addAll(params);\n  }\n  BuildResult buildResult=project.build(buildParams);\n  BuildTask jibTask=buildResult.task(taskName);\n  Assert.assertNotNull(jibTask);\n  Assert.assertEquals(TaskOutcome.SUCCESS,jibTask.getOutcome());\n  List<String> outputLines=Splitter.on(System.lineSeparator()).omitEmptyStrings().splitToList(buildResult.getOutput());\n  Assert.assertEquals(2,outputLines.size());\n  Assert.assertEquals(\"BEGIN JIB JSON: SYNCMAP/1\",outputLines.get(0));\n  return SkaffoldSyncMapTemplate.from(outputLines.get(1));\n}\n"}
{"INPUT": "private View addNotificationIconForInfo(NotificationInfo info){\n  View icon=new View(getContext());\n  icon.setBackground(info.getIconForBackground(getContext(),mBackgroundColor));\n  icon.setOnClickListener(info);\n  icon.setTag(info);\n// bug_start\n// bug_end\n  mIconRow.addView(icon,0,mIconLayoutParams);\n  return icon;\n}\n"}
{"INPUT": "public Pair<Map<SDVariable,Op>,List<Op>> exec(){\n  allocate();\n  List<Op> ops=new ArrayList<>();\n  List<OpExecAction> opExecActions=graph().getOpOrder().getActions();\n  Map<SDVariable,Op> opMap=new HashMap<>();\n  for (int i=0; i < opExecActions.size(); i++) {\n    OpExecAction opExecAction=opExecActions.get(i);\n    Op op=createOp(opExecAction.getOpState().getOpType(),opExecAction);\n    ops.add(op);\n    if (opExecAction.getOpState().getAxes() == null)     Nd4j.getExecutioner().exec(op);\n else {\n      int[] axes=opExecAction.getOpState().getAxes();\n      if (op instanceof Accumulation) {\n        Accumulation accumulation=(Accumulation)op;\n        Nd4j.getExecutioner().exec(accumulation,axes);\n      }\n else       if (op instanceof BroadcastOp) {\n        BroadcastOp broadcastOp=(BroadcastOp)op;\n        Nd4j.getExecutioner().exec(broadcastOp,axes);\n      }\n else       if (op instanceof GradientOp) {\n        Nd4j.getExecutioner().exec(op);\n      }\n else       if (op instanceof IndexAccumulation) {\n        IndexAccumulation indexAccumulation=(IndexAccumulation)op;\n        Nd4j.getExecutioner().exec(indexAccumulation,axes);\n      }\n    }\n    SDVariable currVariable=getVertexIdToVariable().get(opExecAction.getOutputId());\n// bug_start\n// bug_end\n    opMap.put(currVariable,op);\n  }\n  return new Pair<>(opMap,ops);\n}\n"}
{"INPUT": "@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\n  rootView=inflater.inflate(R.layout.main_frag,container,false);\n  listview=(ListView)rootView.findViewById(R.id.listView);\n  rootView.findViewById(R.id.buttonbarframe).setVisibility(View.GONE);\n// bug_start\n// bug_end\n  return rootView;\n}\n"}
{"INPUT": "@Override protected void createControls(Composite parent){\n  Group optionsGroup=UIUtils.createControlGroup(parent,PostgreMessages.tool_truncate_group_option,1,0,0);\n  optionsGroup.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n// bug_start\n// bug_end\n  onlyCheck=UIUtils.createCheckbox(optionsGroup,PostgreMessages.tool_truncate_checkbox_only,PostgreMessages.tool_truncate_checkbox_only_tooltip,false,0);\n  onlyCheck.addSelectionListener(SQL_CHANGE_LISTENER);\n  restartIdentityCheck=UIUtils.createCheckbox(optionsGroup,PostgreMessages.tool_truncate_checkbox_restart,PostgreMessages.tool_truncate_checkbox_restart_tooltip,false,0);\n  restartIdentityCheck.addSelectionListener(SQL_CHANGE_LISTENER);\n  cascadeCheck=UIUtils.createCheckbox(optionsGroup,PostgreMessages.tool_truncate_checkbox_cascade,PostgreMessages.tool_truncate_checkbox_cascade_tooltip,false,0);\n  cascadeCheck.addSelectionListener(SQL_CHANGE_LISTENER);\n  createObjectsSelector(parent);\n}\n"}
{"INPUT": "@Override protected Map<Integer,SaturnJobReturn> handleJob(final SaturnExecutionContext shardingContext){\n  final Map<Integer,SaturnJobReturn> retMap=new HashMap<Integer,SaturnJobReturn>();\n  final String jobName=shardingContext.getJobName();\n  final int timeoutSeconds=getTimeoutSeconds();\n  ExecutorService executorService=getExecutorService();\n  futureTaskMap=new HashMap<Integer,ShardingItemFutureTask>();\n  String jobParameter=shardingContext.getJobParameter();\n  Map<Integer,String> shardingItemParameters=shardingContext.getShardingItemParameters();\n  for (  final Entry<Integer,String> shardingItem : shardingItemParameters.entrySet()) {\n    final Integer key=shardingItem.getKey();\n    try {\n      String jobValue=shardingItem.getValue();\n      final String itemVal=getRealItemValue(jobParameter,jobValue);\n      ShardingItemFutureTask shardingItemFutureTask=new ShardingItemFutureTask(createCallable(jobName,key,itemVal,timeoutSeconds,shardingContext,this),null);\n// bug_start\n// bug_end\n      Future<?> callFuture=executorService.submit(shardingItemFutureTask);\n      if (timeoutSeconds > 0) {\n        TimeoutSchedulerExecutor.scheduleTimeoutJob(shardingContext.getExecutorName(),timeoutSeconds,shardingItemFutureTask);\n      }\n      shardingItemFutureTask.setCallFuture(callFuture);\n      futureTaskMap.put(key,shardingItemFutureTask);\n    }\n catch (    Throwable t) {\n      log.error(String.format(SaturnConstant.ERROR_LOG_FORMAT,jobName,t.getMessage()),t);\n      retMap.put(key,new SaturnJobReturn(SaturnSystemReturnCode.SYSTEM_FAIL,t.getMessage(),SaturnSystemErrorGroup.FAIL));\n    }\n  }\n  for (  Entry<Integer,ShardingItemFutureTask> entry : futureTaskMap.entrySet()) {\n    Integer item=entry.getKey();\n    ShardingItemFutureTask futureTask=entry.getValue();\n    try {\n      futureTask.getCallFuture().get();\n    }\n catch (    Exception e) {\n      log.error(String.format(SaturnConstant.ERROR_LOG_FORMAT,jobName,e.getMessage()),e);\n      retMap.put(item,new SaturnJobReturn(SaturnSystemReturnCode.SYSTEM_FAIL,e.getMessage(),SaturnSystemErrorGroup.FAIL));\n      continue;\n    }\n    retMap.put(item,futureTask.getCallable().getSaturnJobReturn());\n  }\n  return retMap;\n}\n"}
{"INPUT": "@Override public void run(){\n  final ViewGroup contentViewRoot=activity.findViewById(android.R.id.content);\n  final View contentView=contentViewRoot.getChildAt(0);\n// bug_start\n// bug_end\n  contentViewRoot.removeView(contentView);\n  final HyperionOverlayLayout overlayLayout=new HyperionOverlayLayout(activity);\n  overlayLayout.setId(R.id.hyperion_overlay);\n  overlayLayout.addView(contentView);\n  final HyperionMenuLayout menuLayout=new HyperionMenuLayout(activity);\n  menuLayout.setId(R.id.hyperion_menu);\n  contentViewRoot.addView(menuLayout);\n  FragmentManagerCompat fragmentManager=FragmentManagerCompat.create(activity);\n  ActivityResults results=fragmentManager.findFragmentByTag(ACTIVITY_RESULT_TAG);\n  if (results == null) {\n    results=fragmentManager.isSupport() ? new ActivityResultsSupportFragment() : new ActivityResultsFragment();\n    fragmentManager.beginTransaction().add(results,ACTIVITY_RESULT_TAG).commit();\n  }\n  CoreComponent component=DaggerCoreComponent.builder().appComponent(AppComponent.Holder.getInstance()).coreModule(new CoreModule()).activityModule(new ActivityModule(activity)).overlayModule(new OverlayModule(overlayLayout)).activityResultModule(new ActivityResultModule(results)).build();\n  components.put(activity,component);\n  final Context coreContext=new ComponentContextThemeWrapper(activity,component);\n  final HyperionPluginView pluginView=new HyperionPluginView(coreContext);\n  pluginView.setId(R.id.hyperion_plugins);\n  menuLayout.addView(pluginView);\n  menuLayout.addView(overlayLayout);\n}\n"}
{"INPUT": "@Override public void applyTo(BlockHound.Builder builder){\n  builder.allowBlockingCallsInside(\"io.netty.channel.nio.NioEventLoop\",\"handleLoopException\");\n  builder.allowBlockingCallsInside(\"io.netty.channel.kqueue.KQueueEventLoop\",\"handleLoopException\");\n  builder.allowBlockingCallsInside(\"io.netty.channel.epoll.EpollEventLoop\",\"handleLoopException\");\n  builder.allowBlockingCallsInside(\"io.netty.util.HashedWheelTimer$Worker\",\"waitForNextTick\");\n  builder.allowBlockingCallsInside(\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"confirmShutdown\");\n  builder.allowBlockingCallsInside(\"io.netty.handler.ssl.SslHandler\",\"handshake\");\n  builder.allowBlockingCallsInside(\"io.netty.handler.ssl.SslHandler\",\"runAllDelegatedTasks\");\n  builder.allowBlockingCallsInside(\"io.netty.util.concurrent.GlobalEventExecutor\",\"takeTask\");\n// bug_start\n// bug_end\n  builder.allowBlockingCallsInside(\"io.netty.util.concurrent.SingleThreadEventExecutor\",\"takeTask\");\n  builder.nonBlockingThreadPredicate(new Function<Predicate<Thread>,Predicate<Thread>>(){\n    @Override public Predicate<Thread> apply(    final Predicate<Thread> p){\n      return new Predicate<Thread>(){\n        @Override @SuppressJava6Requirement(reason=\"Predicate#test\") public boolean test(        Thread thread){\n          return p.test(thread) || thread instanceof FastThreadLocalThread;\n        }\n      }\n;\n    }\n  }\n);\n}\n"}
{"INPUT": "public void testParsedAsFilter() throws IOException {\n  IndexReader indexReader=new MultiReader();\n  IndexSearcher indexSearcher=newSearcher(indexReader);\n  QueryBuilder filter=QueryBuilders.boolQuery().must(QueryBuilders.termQuery(\"field\",\"foo\")).should(QueryBuilders.termQuery(\"field\",\"bar\"));\n  FilterAggregationBuilder builder=new FilterAggregationBuilder(\"test\",filter);\n  AggregatorFactory<?> factory=createAggregatorFactory(builder,indexSearcher,fieldType);\n  assertThat(factory,Matchers.instanceOf(FilterAggregatorFactory.class));\n  FilterAggregatorFactory filterFactory=(FilterAggregatorFactory)factory;\n  Query parsedQuery=filterFactory.getWeight().getQuery();\n  assertThat(parsedQuery,Matchers.instanceOf(BooleanQuery.class));\n  assertEquals(2,((BooleanQuery)parsedQuery).clauses().size());\n  assertEquals(1,((BooleanQuery)parsedQuery).getMinimumNumberShouldMatch());\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override protected Throwable doInBackground(String... params){\n  List<String> installedAppIds=new ArrayList<>();\n  Map<String,App> appMap=new HashMap<>();\n  for (  App installedApp : getFilteredInstalledApps(context)) {\n    String packageName=installedApp.getPackageInfo().packageName;\n    installedAppIds.add(packageName);\n    appMap.put(packageName,installedApp);\n  }\n  PlayStoreApiWrapper wrapper=new PlayStoreApiWrapper(this.context);\n  List<App> appsFromPlayMarket=new ArrayList<>();\n  try {\n    appsFromPlayMarket.addAll(wrapper.getDetails(installedAppIds));\n  }\n catch (  Throwable e) {\n    return e;\n  }\n  for (  App appFromMarket : appsFromPlayMarket) {\n    String packageName=appFromMarket.getPackageName();\n    if (null == packageName || packageName.isEmpty()) {\n      continue;\n    }\n    App installedApp=appMap.get(packageName);\n    if (installedApp.getVersionCode() < appFromMarket.getVersionCode()) {\n      installedApp.setUpdated(appFromMarket.getUpdated());\n      installedApp.setVersionCode(appFromMarket.getVersionCode());\n      installedApp.setOfferType(appFromMarket.getOfferType());\n// bug_start\n// bug_end\n      apps.add(installedApp);\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "@Test public void testServingLayerSecure() throws Exception {\n  Path keystoreFile=SecureAPIConfigIT.buildKeystoreFile();\n  Map<String,Object> overlay=buildOverlay();\n  overlay.put(\"oryx.serving.api.keystore-file\",\"\\\"\" + keystoreFile + \"\\\"\");\n  overlay.put(\"oryx.serving.api.keystore-password\",\"oryxpass\");\n// bug_start\n// bug_end\n  Config config=ConfigUtils.overlayOn(overlay,ConfigUtils.getDefault());\n  try {\n    doTestServingLayer(config);\n  }\n  finally {\n    Files.delete(Paths.get(config.getString(\"oryx.serving.api.keystore-file\")));\n  }\n}\n"}
{"INPUT": "@Override public void run(){\n  try {\n    Map<RequestContext,MasterTransaction> safeTransactions=null;\nsynchronized (transactions) {\n      safeTransactions=new HashMap<RequestContext,MasterTransaction>(transactions);\n    }\n    for (    Map.Entry<RequestContext,MasterTransaction> entry : safeTransactions.entrySet()) {\n      long time=entry.getValue().timeLastSuspended.get();\n      if ((time != 0 && System.currentTimeMillis() - time >= unfinishedTransactionThresholdMillis) || entry.getValue().finishAsap()) {\n        long displayableTime=(time == 0 ? 0 : (System.currentTimeMillis() - time));\n        msgLog.logMessage(\"Found old tx \" + entry.getKey() + \", \"+ \"\"+ entry.getValue().transaction+ \", \"+ displayableTime);\n        try {\n          Transaction otherTx=suspendOtherAndResumeThis(entry.getKey(),false);\n          finishThisAndResumeOther(otherTx,entry.getKey(),false);\n          msgLog.logMessage(\"Rolled back old tx \" + entry.getKey() + \", \"+ \"\"+ entry.getValue().transaction+ \", \"+ displayableTime);\n        }\n catch (        IllegalStateException e) {\n        }\ncatch (        Throwable t) {\n          msgLog.logMessage(\"Unable to roll back old tx \" + entry.getKey() + \", \"+ \"\"+ entry.getValue().transaction+ \", \"+ displayableTime,t);\n        }\n      }\n    }\n  }\n catch (  Throwable t) {\n// bug_start\n// bug_end\n  }\n}\n"}
{"INPUT": "private HttpURLConnection httpConnect(final HttpOpParam.Op op,final Path fspath,final Param<?,?>... parameters) throws IOException {\n  final URL url=toUrl(op,fspath,parameters);\n  HttpURLConnection conn=getHttpUrlConnection(url);\n  try {\n    conn.setRequestMethod(op.getType().toString());\n    if (op.getDoOutput()) {\n      conn=twoStepWrite(conn,op);\n// bug_start\n// bug_end\n    }\n    conn.setDoOutput(op.getDoOutput());\n    conn.connect();\n    return conn;\n  }\n catch (  IOException e) {\n    conn.disconnect();\n    throw e;\n  }\n}\n"}
{"INPUT": "private static void loadBundle(){\n  I18NBundle.setExceptionOnMissingKey(false);\n  if (externalBundle) {\n    try {\n      FileHandle handle=Gdx.files.local(\"bundle\");\n      Locale locale=Locale.ENGLISH;\n      Core.bundle=I18NBundle.createBundle(handle,locale);\n    }\n catch (    Exception e) {\n      Log.err(e);\n      Platform.instance.showError(\"Failed to find bundle!\\nMake sure you have bundle.properties in the same directory\\nas the jar file.\\n\\nIf the problem persists, try running it through the command prompt:\\n\" + \"Hold left-shift, then right click and select 'open command prompt here'.\\nThen, type in 'java -jar mindustry.jar' without quotes.\");\n      Gdx.app.exit();\n    }\n  }\n else {\n    FileHandle handle=Gdx.files.internal(\"bundles/bundle\");\n    Locale locale=getLocale();\n// bug_start\n// bug_end\n    if (!headless)     Log.info(\"Got locale: {0}\",locale);\n    Core.bundle=I18NBundle.createBundle(handle,locale);\n  }\n}\n"}
{"INPUT": "@Override public void onClick(View v){\n  Activity activity=getActivity();\n  if (activity != null) {\n    OsmandInAppPurchaseActivity.purchaseDepthContours(activity);\n// bug_start\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public Authentication attemptAuthentication(HttpServletRequest request,HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n  log.debug(\"Attempting Keycloak authentication\");\n  HttpFacade facade=new SimpleHttpFacade(request,response);\n  KeycloakDeployment deployment=adapterDeploymentContext.resolveDeployment(facade);\n// bug_start\n// bug_end\n  AdapterTokenStore tokenStore=adapterTokenStoreFactory.createAdapterTokenStore(deployment,request);\n  RequestAuthenticator authenticator=new SpringSecurityRequestAuthenticator(facade,request,deployment,tokenStore,-1);\n  AuthOutcome result=authenticator.authenticate();\n  log.debug(\"Auth outcome: {}\",result);\n  if (AuthOutcome.FAILED.equals(result)) {\n    AuthChallenge challenge=authenticator.getChallenge();\n    if (challenge != null) {\n      challenge.challenge(facade);\n    }\n    throw new KeycloakAuthenticationException(\"Invalid authorization header, see WWW-Authenticate header for details\");\n  }\n  if (AuthOutcome.NOT_ATTEMPTED.equals(result)) {\n    AuthChallenge challenge=authenticator.getChallenge();\n    if (challenge != null) {\n      challenge.challenge(facade);\n    }\n    if (deployment.isBearerOnly()) {\n      throw new KeycloakAuthenticationException(\"Authorization header not found,  see WWW-Authenticate header\");\n    }\n else {\n      return null;\n    }\n  }\n else   if (AuthOutcome.AUTHENTICATED.equals(result)) {\n    Authentication authentication=SecurityContextHolder.getContext().getAuthentication();\n    Assert.notNull(authentication,\"Authentication SecurityContextHolder was null\");\n    return authenticationManager.authenticate(authentication);\n  }\n else {\n    AuthChallenge challenge=authenticator.getChallenge();\n    if (challenge != null) {\n      challenge.challenge(facade);\n    }\n    return null;\n  }\n}\n"}
{"INPUT": "@Override protected void onClick(AjaxRequestTarget target,Form<?> form){\n  parent.getLayerModel().setObject(layer);\n  parent.getPopup().close(target);\n  parent.configurationChanged();\n// bug_start\n// bug_end\n  target.add(parent.styleForm);\n}\n"}
{"INPUT": "@Override public void onLoadFinished(Loader<Cursor> arg0,Cursor cursor){\n  Cursor pushCursor=ContactAccessor.getInstance().getCursorForContactsWithPush(getActivity());\n  ((CursorAdapter)getListAdapter()).changeCursor(new MergeCursor(new Cursor[]{pushCursor,cursor}));\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@org.junit.Test public void testStruct() throws Exception {\n  System.out.println(ThriftData.get().getSchema(Test.class).toString(true));\n  Test test=new Test();\n  test.setBoolField(true);\n  test.setByteField((byte)2);\n  test.setI16Field((short)3);\n// bug_start\n// bug_end\n  test.setI32Field(4);\n  test.setI64Field(5L);\n  test.setDoubleField(2.0);\n  test.setStringField(\"foo\");\n  test.setBinaryField(ByteBuffer.wrap(new byte[]{0,-1}));\n  test.setMapField(Collections.singletonMap(\"x\",1));\n  test.setListField(Collections.singletonList(7));\n  test.setSetField(Collections.singleton(8));\n  test.setEnumField(E.X);\n  test.setStructField(new Nested(9));\n  test.setFooOrBar(FooOrBar.foo(\"x\"));\n  System.out.println(test);\n  check(test);\n}\n"}
{"INPUT": "public void create(final Map<String,Object> iProperties){\n  try {\n    stateLock.acquireWriteLock();\n    try {\n      if (status != STATUS.CLOSED)       throw new OStorageExistsException(\"Cannot create new storage '\" + getURL() + \"' because it is not closed\");\n      if (exists())       throw new OStorageExistsException(\"Cannot create new storage '\" + getURL() + \"' because it already exists\");\n      if (!configuration.getContextConfiguration().getContextKeys().contains(OGlobalConfiguration.STORAGE_COMPRESSION_METHOD.getKey())) {\n        final String compression=iProperties != null ? (String)iProperties.get(OGlobalConfiguration.STORAGE_COMPRESSION_METHOD.getKey().toLowerCase(configuration.getLocaleInstance())) : null;\n        if (compression != null)         configuration.getContextConfiguration().setValue(OGlobalConfiguration.STORAGE_COMPRESSION_METHOD,compression);\n else         configuration.getContextConfiguration().setValue(OGlobalConfiguration.STORAGE_COMPRESSION_METHOD,OGlobalConfiguration.STORAGE_COMPRESSION_METHOD.getValue());\n      }\n      if (!configuration.getContextConfiguration().getContextKeys().contains(OGlobalConfiguration.STORAGE_ENCRYPTION_METHOD.getKey())) {\n        final String encryption=iProperties != null ? (String)iProperties.get(OGlobalConfiguration.STORAGE_ENCRYPTION_METHOD.getKey().toLowerCase(configuration.getLocaleInstance())) : null;\n        if (encryption != null)         configuration.getContextConfiguration().setValue(OGlobalConfiguration.STORAGE_ENCRYPTION_METHOD,encryption);\n else         configuration.getContextConfiguration().setValue(OGlobalConfiguration.STORAGE_ENCRYPTION_METHOD,OGlobalConfiguration.STORAGE_ENCRYPTION_METHOD.getValue());\n      }\n      final String encryptionKey=iProperties != null ? (String)iProperties.get(OGlobalConfiguration.STORAGE_ENCRYPTION_KEY.getKey().toLowerCase(configuration.getLocaleInstance())) : null;\n      if (encryptionKey != null)       configuration.getContextConfiguration().setValue(OGlobalConfiguration.STORAGE_ENCRYPTION_KEY,encryptionKey);\n else       configuration.getContextConfiguration().setValue(OGlobalConfiguration.STORAGE_ENCRYPTION_KEY,OGlobalConfiguration.STORAGE_ENCRYPTION_KEY.getValue());\n      componentsFactory=new OCurrentStorageComponentsFactory(configuration);\n      try {\n        performanceStatisticManager.registerMBean(name,id);\n      }\n catch (      Exception e) {\n        OLogManager.instance().error(this,\"MBean for profiler cannot be registered.\",e);\n      }\n      initWalAndDiskCache();\n      atomicOperationsManager=new OAtomicOperationsManager(this);\n      try {\n        atomicOperationsManager.registerMBean();\n      }\n catch (      Exception e) {\n        OLogManager.instance().error(this,\"MBean for atomic operations manager cannot be registered\",e);\n      }\n      preCreateSteps();\n      status=STATUS.OPEN;\n      doAddCluster(OMetadataDefault.CLUSTER_INTERNAL_NAME,null);\n      configuration.create();\n      configuration.setCreationVersion(OConstants.getVersion());\n      doAddCluster(OMetadataDefault.CLUSTER_INDEX_NAME,null);\n      doAddCluster(OMetadataDefault.CLUSTER_MANUAL_INDEX_NAME,null);\n      defaultClusterId=doAddCluster(CLUSTER_DEFAULT_NAME,null);\n      if (OGlobalConfiguration.STORAGE_MAKE_FULL_CHECKPOINT_AFTER_CREATE.getValueAsBoolean())       makeFullCheckpoint();\n      clearStorageDirty();\n      writeCache.startFuzzyCheckpoints();\n      postCreateSteps();\n    }\n catch (    OStorageException e) {\n      close();\n      throw e;\n    }\ncatch (    IOException e) {\n      close();\n      throw OException.wrapException(new OStorageException(\"Error on creation of storage '\" + name + \"'\"),e);\n    }\n finally {\n      stateLock.releaseWriteLock();\n    }\n  }\n catch (  RuntimeException e) {\n    throw logAndPrepareForRethrow(e);\n  }\ncatch (  Error e) {\n    throw logAndPrepareForRethrow(e);\n  }\ncatch (  Throwable t) {\n    throw logAndPrepareForRethrow(t);\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Command(name=\"refresh\") public void refresh(SolrQueryRequest req,SolrQueryResponse rsp,PayloadObj<String> payload){\n  String p=payload.get();\n  if (p == null) {\n    payload.addError(\"Package null\");\n    return;\n  }\n  PackageLoader.Package pkg=coreContainer.getPackageLoader().getPackage(p);\n  if (pkg == null) {\n    payload.addError(\"No such package: \" + p);\n    return;\n  }\n// bug_start\n// bug_end\n  for (  String s : coreContainer.getPackageStoreAPI().shuffledNodes()) {\n    Utils.executeGET(coreContainer.getUpdateShardHandler().getDefaultHttpClient(),coreContainer.getZkController().zkStateReader.getBaseUrlForNodeName(s).replace(\"/solr\",\"/api\") + \"/cluster/package?wt=javabin&omitHeader=true&refreshPackage=\" + p,Utils.JAVABINCONSUMER);\n  }\n}\n"}
{"INPUT": "@Override protected void configure(){\n  bind().to(InvocationContextReferencingFactory.class).in(RequestScope.class);\n  bind(InvocationContext.class).toFactory(InvocationContextReferencingFactory.class).in(RequestScope.class);\n  bind(ExecutionContext.class).toFactory(InvocationContextReferencingFactory.class).in(RequestScope.class);\n  bind(new TypeLiteral<Ref<InvocationContext>>(){\n  }\n).toFactory(ReferencingFactory.<InvocationContext>referenceFactory()).in(RequestScope.class);\n  bind().to(ProcessingExecutorsFactory.class);\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "public static PoolingDataSource setupPoolingDataSource(Properties dsProps,String datasourceName){\n  PoolingDataSource pds=new PoolingDataSource();\n  pds.setUniqueName(datasourceName);\n  pds.setClassName(dsProps.getProperty(\"className\"));\n  pds.setMaxPoolSize(Integer.parseInt(dsProps.getProperty(\"maxPoolSize\")));\n  pds.setAllowLocalTransactions(Boolean.parseBoolean(dsProps.getProperty(\"allowLocalTransactions\")));\n  for (  String propertyName : new String[]{\"user\",\"password\"}) {\n    pds.getDriverProperties().put(propertyName,dsProps.getProperty(propertyName));\n  }\n  String driverClass=dsProps.getProperty(\"driverClassName\");\n  if (driverClass.startsWith(\"org.h2\")) {\n    h2Server.start();\n    for (    String propertyName : new String[]{\"url\",\"driverClassName\"}) {\n      pds.getDriverProperties().put(propertyName,dsProps.getProperty(propertyName));\n    }\n  }\n else {\n    pds.setClassName(dsProps.getProperty(\"className\"));\n    if (driverClass.startsWith(\"oracle\")) {\n      pds.getDriverProperties().put(\"driverType\",\"thin\");\n      pds.getDriverProperties().put(\"URL\",dsProps.getProperty(\"url\"));\n    }\n else     if (driverClass.startsWith(\"com.ibm.db2\")) {\n      pds.getDriverProperties().put(\"databaseName\",dsProps.getProperty(\"databaseName\"));\n      pds.getDriverProperties().put(\"driverType\",\"4\");\n      pds.getDriverProperties().put(\"serverName\",dsProps.getProperty(\"serverName\"));\n      pds.getDriverProperties().put(\"portNumber\",dsProps.getProperty(\"portNumber\"));\n// bug_start\n// bug_end\n    }\n else     if (driverClass.startsWith(\"com.microsoft\")) {\n      for (      String propertyName : new String[]{\"serverName\",\"portNumber\",\"databaseName\"}) {\n        pds.getDriverProperties().put(propertyName,dsProps.getProperty(propertyName));\n      }\n      pds.getDriverProperties().put(\"URL\",dsProps.getProperty(\"url\"));\n      pds.getDriverProperties().put(\"selectMethod\",\"cursor\");\n      pds.getDriverProperties().put(\"InstanceName\",\"MSSQL01\");\n    }\n else     if (driverClass.startsWith(\"com.mysql\")) {\n      for (      String propertyName : new String[]{\"databaseName\",\"serverName\",\"portNumber\",\"url\"}) {\n        pds.getDriverProperties().put(propertyName,dsProps.getProperty(propertyName));\n      }\n    }\n else     if (driverClass.startsWith(\"com.sybase\")) {\n      for (      String propertyName : new String[]{\"databaseName\",\"portNumber\",\"serverName\"}) {\n        pds.getDriverProperties().put(propertyName,dsProps.getProperty(propertyName));\n      }\n      pds.getDriverProperties().put(\"REQUEST_HA_SESSION\",\"false\");\n      pds.getDriverProperties().put(\"networkProtocol\",\"Tds\");\n    }\n else     if (driverClass.startsWith(\"org.postgresql\") || driverClass.startsWith(\"com.edb\")) {\n      for (      String propertyName : new String[]{\"databaseName\",\"portNumber\",\"serverName\"}) {\n        pds.getDriverProperties().put(propertyName,dsProps.getProperty(propertyName));\n      }\n    }\n else {\n      throw new RuntimeException(\"Unknown driver class: \" + driverClass);\n    }\n  }\n  return pds;\n}\n"}
{"INPUT": "public void testCreateVertexByContent(){\n  OrientGraph graph=new OrientGraph(database,false);\n  graph.shutdown();\n  database.open(\"admin\",\"admin\");\n  OSchema schema=database.getMetadata().getSchema();\n  if (!schema.existsClass(\"CreateVertexByContent\")) {\n    OClass vClass=schema.createClass(\"CreateVertexByContent\",schema.getClass(\"V\"));\n    vClass.createProperty(\"message\",OType.STRING);\n  }\n  database.command(new OCommandSQL(\"create vertex CreateVertexByContent content { \\\"message\\\": \\\"(:\\\"}\")).execute();\n  database.command(new OCommandSQL(\"create vertex CreateVertexByContent content { \\\"message\\\": \\\"\\\\\\\", ?...\\\\\\\"\\\"}\")).execute();\n  List<ODocument> result=database.query(new OSQLSynchQuery<ODocument>(\"select from CreateVertexByContent\"));\n  Assert.assertEquals(result.size(),2);\n  List<String> messages=new ArrayList<String>();\n  messages.add(\"\\\", ?...\\\"\");\n  messages.add(\"(:\");\n  List<String> resultMessages=new ArrayList<String>();\n  for (  ODocument document : result) {\n    resultMessages.add(document.<String>field(\"message\"));\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override public boolean onActionItemClicked(ActionMode mode,MenuItem item){\n// bug_start\n// bug_end\n  if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {\n    return true;\n  }\n  Callback customCallback=getCustomCallback();\n  if (customCallback != null && customCallback.onActionItemClicked(mode,item)) {\n    return true;\n  }\n  final TextClassification textClassification=getSelectionActionModeHelper().getTextClassification();\n  if (TextView.ID_ASSIST == item.getItemId() && textClassification != null) {\n    final OnClickListener onClickListener=textClassification.getOnClickListener();\n    if (onClickListener != null) {\n      onClickListener.onClick(mTextView);\n    }\n else {\n      final Intent intent=textClassification.getIntent();\n      if (intent != null) {\n        TextClassification.createStartActivityOnClickListener(mTextView.getContext(),intent).onClick(mTextView);\n      }\n    }\n    mMetricsLogger.action(MetricsEvent.ACTION_TEXT_SELECTION_MENU_ITEM_ASSIST,textClassification.getLogType());\n    stopTextActionMode();\n    return true;\n  }\n  return mTextView.onTextContextMenuItem(item.getItemId());\n}\n"}
{"INPUT": "private <RT>UnionBuilder<RT> innerUnion(SubQueryExpression<?>... sq){\n// bug_start\n// bug_end\n  if (!queryMixin.getMetadata().getJoins().isEmpty()) {\n    throw new IllegalArgumentException(\"Don't mix union and from\");\n  }\n  this.union=sq;\n  return new UnionBuilder<RT>();\n}\n"}
{"INPUT": "@Override public void dozeTimeTick(){\n  mNotificationPanel.dozeTimeTick();\n// bug_start\n// bug_end\n  if (mAmbientIndicationContainer instanceof DozeReceiver) {\n    ((DozeReceiver)mAmbientIndicationContainer).dozeTimeTick();\n  }\n}\n"}
{"INPUT": "public void onPushReceived(int seq){\n// bug_start\n  updateActor.send(new SequenceActor.PushSeq(seq));\n// bug_end\n}\n"}
{"INPUT": "public Operation parseOperation(Element operationElement,BpmnInterface bpmnInterface){\n  Element inMessageRefElement=operationElement.element(\"inMessageRef\");\n  String inMessageRef=this.resolveName(inMessageRefElement.getText());\n  if (!this.messages.containsKey(inMessageRef)) {\n    addError(inMessageRef + \" does not exist\",inMessageRefElement);\n    return null;\n  }\n else {\n    MessageDefinition inMessage=this.messages.get(inMessageRef);\n    String id=operationElement.attribute(\"id\");\n    String name=operationElement.attribute(\"name\");\n    String implementationRef=this.resolveName(operationElement.attribute(\"implementationRef\"));\n    Operation operation=new Operation(this.targetNamespace + \":\" + id,name,bpmnInterface,inMessage);\n    operation.setImplementation(this.operationImplementations.get(implementationRef));\n    Element outMessageRefElement=operationElement.element(\"outMessageRef\");\n// bug_start\n    String outMessageRef=this.resolveName(outMessageRefElement.getText());\n    if (this.messages.containsKey(outMessageRef)) {\n      MessageDefinition outMessage=this.messages.get(outMessageRef);\n      operation.setOutMessage(outMessage);\n// bug_end\n    }\n    operations.put(operation.getId(),operation);\n    return operation;\n  }\n}\n"}
{"INPUT": "public void cancelLeafStage(){\n  QueryInfo queryInfo=getQueryInfo(false);\n// bug_start\n  cancelLeafStage(queryInfo.getOutputStage());\n// bug_end\n}\n"}
{"INPUT": "@Override @AfterEach public void tearDown() throws Exception {\n// bug_start\n  queue.close();\n// bug_end\n  super.tearDown();\n}\n"}
{"INPUT": "@Deprecated public Set<Artifact> createArtifacts(ArtifactFactory artifactFactory,String inheritedScope,ArtifactFilter filter){\n  Set<Artifact> artifacts=new LinkedHashSet<Artifact>();\n  for (  Dependency d : getDependencies()) {\n    Artifact dependencyArtifact=repositorySystem.createArtifact(d.getGroupId(),d.getArtifactId(),d.getVersion(),d.getScope(),d.getType());\n// bug_start\n    if (filter.include(dependencyArtifact)) {\n      artifacts.add(dependencyArtifact);\n// bug_end\n    }\n  }\n  return artifacts;\n}\n"}
{"INPUT": "@Override public void render(Application app){\n  if (m_platform.getType() == BodyType.KinematicBody) {\n    Vector2 p=m_platform.getTransform().getPosition();\n    Vector2 v=m_platform.getLinearVelocity();\n    if ((p.x < -10 && v.x < 0) || (p.x > 10 && v.x > 0)) {\n      v.x=-v.x;\n      m_platform.setLinearVelocity(v);\n    }\n  }\n  super.render(app);\n// bug_start\n  renderer.batch.begin();\n  renderer.batch.drawText(renderer.font,\"Keys: (d) dynamic, (s) static, (k) kinematic\",0,app.getGraphics().getHeight(),Color.WHITE);\n  renderer.batch.end();\n// bug_end\n}\n"}
{"INPUT": "private List<ACL> removeDuplicates(List<ACL> acl){\n  LinkedList<ACL> retval=new LinkedList<ACL>();\n// bug_start\n  for (  ACL a : acl) {\n    if (!retval.contains(a)) {\n      retval.add(a);\n// bug_end\n    }\n  }\n  return retval;\n}\n"}
{"INPUT": "@Override public void visit(BLangObjectTypeNode objectTypeNode){\n// bug_start\n  this.visit(objectTypeNode.initFunction);\n// bug_end\n  objectTypeNode.fields.forEach(null);\n  objectTypeNode.functions.forEach(null);\n}\n"}
{"INPUT": "@Override protected void onDestroy(){\n  super.onDestroy();\n// bug_start\n  disposables.dispose();\n// bug_end\n}\n"}
{"INPUT": "private void deleteFile(){\n  while (true) {\n    CleanerContext context=null;\n    boolean succeed=false;\n    boolean interrupted=false;\n    try {\n      context=pendingDelete.take();\n      if (context != null) {\n        FileStatus toClean=context.getTargetToClean();\n        succeed=this.fs.delete(toClean.getPath(),false);\n      }\n    }\n catch (    InterruptedException ite) {\n      if (context != null) {\n        LOG.warn(\"Interrupted while cleaning oldWALs \" + context.getTargetToClean() + \", try to clean it next round.\");\n      }\n      interrupted=true;\n    }\ncatch (    IOException e) {\n      LOG.warn(\"Failed to clean oldwals with exception: \" + e);\n      succeed=false;\n    }\n finally {\n// bug_start\n      context.setResult(succeed);\n// bug_end\n      if (interrupted) {\n        Thread.currentThread().interrupt();\n        break;\n      }\n    }\n  }\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Exiting cleaner.\");\n  }\n}\n"}
{"INPUT": "public void dequeue(){\n// bug_start\n  this.queue.dequeue(this.index);\n// bug_end\n  this.activated=false;\n}\n"}
{"INPUT": "public void onFocus(FocusEvent event){\n  if (event.getSource() instanceof VCalendarPanel) {\n    hasFocus=true;\n// bug_start\n    focusDay(focusedDay.getDay());\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void onClick(View v){\n// bug_start\n  activity.hideConversationsOverview();\n// bug_end\n}\n"}
{"INPUT": "@Override public void onAuthenticatorTaskCallback(RemoteOperationResult result){\n  mWaitingForOpId=Long.MAX_VALUE;\n  dismissWaitingDialog();\n  mAsyncTask=null;\n  if (result.isSuccess()) {\n    Log_OC.d(TAG,\"Successful access - time to save the account\");\n    boolean success=false;\n    if (mAction == ACTION_CREATE) {\n      success=createAccount(result);\n    }\n else {\n      try {\n        updateAccountAuthentication();\n        success=true;\n      }\n catch (      AccountNotFoundException e) {\n        Log_OC.e(TAG,\"Account \" + mAccount + \" was removed!\",e);\n        DisplayUtils.showSnackMessage(findViewById(R.id.scroll),R.string.auth_account_does_not_exist);\n        finish();\n      }\n    }\n    webViewPassword=null;\n    webViewUser=null;\n    deleteCookies();\n    if (success) {\n      accountManager.setCurrentOwnCloudAccount(mAccount.name);\n      if (!onlyAdd) {\n        Intent i=new Intent(this,FileDisplayActivity.class);\n        i.setAction(FileDisplayActivity.RESTART);\n        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        startActivity(i);\n      }\n    }\n else {\n// bug_start\n      mLoginWebView.setVisibility(View.GONE);\n// bug_end\n      setContentView(R.layout.account_setup);\n      initOverallUi();\n      mAuthStatusView=findViewById(R.id.auth_status_text);\n      mHostUrlInput.setText(mServerInfo.mBaseUrl);\n      mServerStatusView.setVisibility(View.GONE);\n      showAuthStatus();\n    }\n  }\n else   if (result.isServerFail() || result.isException()) {\n    mServerInfo=new GetServerInfoOperation.ServerInfo();\n    updateServerStatusIconAndText(result);\n    showServerStatus();\n    mAuthStatusIcon=0;\n    mAuthStatusText=EMPTY_STRING;\n    if (result.getCode() == ResultCode.SSL_RECOVERABLE_PEER_UNVERIFIED) {\n      showUntrustedCertDialog(result);\n    }\n  }\n else {\n    mLoginWebView=findViewById(R.id.login_webview);\n    if (mLoginWebView != null) {\n      initWebViewLogin(mServerInfo.mBaseUrl + WEB_LOGIN,false);\n      DisplayUtils.showSnackMessage(this,mLoginWebView,R.string.auth_access_failed,result.getLogMessage());\n    }\n else {\n      DisplayUtils.showSnackMessage(this,R.string.auth_access_failed,result.getLogMessage());\n      mLoginWebView.setVisibility(View.GONE);\n      updateAuthStatusIconAndText(result);\n    }\n    webViewPassword=null;\n    webViewUser=null;\n    deleteCookies();\n    Log_OC.d(TAG,\"Access failed: \" + result.getLogMessage());\n  }\n}\n"}
{"INPUT": "public static <T>ListDataSource<T> create(DataSource<CloseableReference<T>>... dataSources){\n  Preconditions.checkNotNull(dataSources);\n  Preconditions.checkState(dataSources.length > 0);\n  ListDataSource<T> listDataSource=new ListDataSource<T>(dataSources);\n  for (  DataSource<CloseableReference<T>> dataSource : dataSources) {\n// bug_start\n    dataSource.subscribe(listDataSource.new InternalDataSubscriber(),CallerThreadExecutor.getInstance());\n// bug_end\n  }\n  return listDataSource;\n}\n"}
{"INPUT": "@Override public void onAnimationUpdate(ValueAnimator animation){\n  circles[index].setAlpha((int)animation.getAnimatedValue());\n// bug_start\n  invalidateListener.reDraw();\n// bug_end\n}\n"}
{"INPUT": "public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext consumeConcurrentlyContext){\n  for (  MessageExt msg : msgs) {\n    msgIndex.getAndIncrement();\n    if (isDebug) {\n      if (listnerName != null && listnerName != \"\") {\n        logger.info(listnerName + \":\" + msgIndex.get()+ \":\"+ String.format(\"msgid:%s broker:%s queueId:%s offset:%s\",msg.getMsgId(),msg.getStoreHost(),msg.getQueueId(),msg.getQueueOffset()));\n      }\n else {\n        logger.info(msg);\n      }\n    }\n    msgBodys.addData(new String(msg.getBody()));\n    originMsgs.addData(msg);\n// bug_start\n    originMsgIndex.put(new String(msg.getBody()),msg);\n// bug_end\n  }\n  return consumeStatus;\n}\n"}
{"INPUT": "private void checkRidBagsPresence(final OAtomicOperation operation){\n  for (  final OCluster cluster : clusters) {\n// bug_start\n    final int clusterId=cluster.getId();\n    if (!sbTreeCollectionManager.isComponentPresent(operation,clusterId)) {\n      OLogManager.instance().info(this,\"Cluster with id %d does not have associated rid bag, fixing ...\");\n      sbTreeCollectionManager.createComponent(operation,clusterId);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "@MainThread final void clear(){\n  mCleared=true;\n// bug_start\n  for (  Object value : mBagOfTags.values()) {\n    closeWithRuntimeException(value);\n// bug_end\n  }\n  onCleared();\n}\n"}
{"INPUT": "@Override protected Void doInBackground(Void... voids){\n  MainActivity activity=activityWeakReference.get();\n  if (activity == null)   return null;\n  List<Pojo> pojos=KissApplication.getApplication(activity).getDataHandler().getApplications();\n// bug_start\n  this.addResult(pojos.toArray(new Pojo[0]));\n// bug_end\n  return null;\n}\n"}
{"INPUT": "@Override public void onComplete(){\n  if (done) {\n    return;\n  }\n  done=true;\n  Disposable d=debouncer.get();\n  if (d != DisposableHelper.DISPOSED) {\n    @SuppressWarnings(\"unchecked\") DebounceInnerObserver<T,U> dis=(DebounceInnerObserver<T,U>)d;\n// bug_start\n    dis.emit();\n// bug_end\n    DisposableHelper.dispose(debouncer);\n    downstream.onComplete();\n  }\n}\n"}
{"INPUT": "private int updateDefaultColor(boolean nightMode){\n  int color=MAP_DEFAULT_COLOR;\n  RenderingRulesStorage rrs=application.getRendererRegistry().getCurrentSelectedRenderer();\n// bug_start\n  RenderingRuleSearchRequest req=new RenderingRuleSearchRequest(rrs);\n  req.setBooleanFilter(rrs.PROPS.R_NIGHT_MODE,nightMode);\n  if (req.searchRenderingAttribute(RenderingRuleStorageProperties.A_DEFAULT_COLOR)) {\n    color=req.getIntPropertyValue(req.ALL.R_ATTR_COLOR_VALUE);\n    defaultColor=color;\n// bug_end\n  }\n  return color;\n}\n"}
{"INPUT": "public void close(){\n  doCancelRead(this,null);\n  doCancelWrite(this,null);\n// bug_start\n  key.cancel();\n// bug_end\n  currentRegistrations.getAndDecrement();\n  selector.wakeup();\n}\n"}
{"INPUT": "@Override public void disposeControl(){\n// bug_start\n  selectionProvider.dispose();\n// bug_end\n  DBeaverCore.getInstance().getNavigatorModel().removeListener(this);\n  super.disposeControl();\n}\n"}
{"INPUT": "public void pause() throws Exception {\n// bug_start\n  for (int i=0; i < wEnv.getHandlerCount(); i++) {\n    if (wEnv.getHandler(i) != null) {\n      wEnv.getHandler(i).pause();\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "public boolean testForPs2Ascii(){\n  try {\n    String procOutputLine=null;\n    StringBuffer procOutput=new StringBuffer();\n    Process ps2asciiProc=Runtime.getRuntime().exec(new String[]{\"ps2ascii\",\"--version\"});\n    BufferedReader stdOut=new BufferedReader(new InputStreamReader(ps2asciiProc.getInputStream()));\n    while ((procOutputLine=stdOut.readLine()) != null) {\n      procOutput.append(procOutputLine).append(\", \");\n    }\n    int returnCode=ps2asciiProc.waitFor();\n    return (returnCode == 0);\n  }\n catch (  Exception e) {\n// bug_start\n    this.theLogger.logInfo(\"ps2ascii not found. Switching to java parser mode.\");\n// bug_end\n    return false;\n  }\n}\n"}
{"INPUT": "public SQLResponse doQueryWithCache(SQLRequest sqlRequest){\n  KylinConfig kylinConfig=KylinConfig.getInstanceFromEnv();\n  String serverMode=kylinConfig.getServerMode();\n  if (!(Constant.SERVER_MODE_QUERY.equals(serverMode.toLowerCase()) || Constant.SERVER_MODE_ALL.equals(serverMode.toLowerCase()))) {\n    throw new InternalErrorException(\"Query is not allowed in \" + serverMode + \" mode.\");\n  }\n  final String queryId=UUID.randomUUID().toString();\n// bug_start\n  BackdoorToggles.addToggles(sqlRequest.getBackdoorToggles());\n// bug_end\n  QueryContext.setQueryId(queryId);\n  try (SetThreadName ignored=new SetThreadName(\"Query %s\",queryId)){\n    String sql=sqlRequest.getSql();\n    String project=sqlRequest.getProject();\n    logger.info(\"Using project: \" + project);\n    logger.info(\"The original query:  \" + sql);\n    if (!sql.toLowerCase().contains(\"select\")) {\n      logger.debug(\"Directly return exception as not supported\");\n      throw new InternalErrorException(\"Not Supported SQL.\");\n    }\n    long startTime=System.currentTimeMillis();\n    SQLResponse sqlResponse=null;\n    boolean queryCacheEnabled=checkCondition(kylinConfig.isQueryCacheEnabled(),\"query cache disabled in KylinConfig\") && checkCondition(!BackdoorToggles.getDisableCache(),\"query cache disabled in BackdoorToggles\");\n    if (queryCacheEnabled) {\n      sqlResponse=searchQueryInCache(sqlRequest);\n    }\n    try {\n      if (null == sqlResponse) {\n        sqlResponse=query(sqlRequest);\n        long durationThreshold=kylinConfig.getQueryDurationCacheThreshold();\n        long scancountThreshold=kylinConfig.getQueryScanCountCacheThreshold();\n        sqlResponse.setDuration(System.currentTimeMillis() - startTime);\n        logger.info(\"Stats of SQL response: isException: {}, duration: {}, total scan count {}\",String.valueOf(sqlResponse.getIsException()),String.valueOf(sqlResponse.getDuration()),String.valueOf(sqlResponse.getTotalScanCount()));\n        if (checkCondition(queryCacheEnabled,\"query cache is disabled\") && checkCondition(!sqlResponse.getIsException(),\"query has exception\") && checkCondition(sqlResponse.getDuration() > durationThreshold || sqlResponse.getTotalScanCount() > scancountThreshold,\"query is too lightweight with duration: {} ({}), scan count: {} ({})\",sqlResponse.getDuration(),durationThreshold,sqlResponse.getTotalScanCount(),scancountThreshold)&& checkCondition(sqlResponse.getResults().size() < kylinConfig.getLargeQueryThreshold(),\"query response is too large: {} ({})\",sqlResponse.getResults().size(),kylinConfig.getLargeQueryThreshold())) {\n          cacheManager.getCache(SUCCESS_QUERY_CACHE).put(new Element(sqlRequest,sqlResponse));\n        }\n      }\n else {\n        sqlResponse.setDuration(System.currentTimeMillis() - startTime);\n      }\n      checkQueryAuth(sqlResponse);\n    }\n catch (    Throwable e) {\n      logger.error(\"Exception when execute sql\",e);\n      String errMsg=QueryUtil.makeErrorMsgUserFriendly(e);\n      sqlResponse=new SQLResponse(null,null,0,true,errMsg);\n      if (queryCacheEnabled && e instanceof ScanOutOfLimitException) {\n        Cache exceptionCache=cacheManager.getCache(EXCEPTION_QUERY_CACHE);\n        exceptionCache.put(new Element(sqlRequest,sqlResponse));\n      }\n    }\n    logQuery(sqlRequest,sqlResponse);\n    QueryMetricsFacade.updateMetrics(sqlRequest,sqlResponse);\n    if (sqlResponse.getIsException())     throw new InternalErrorException(sqlResponse.getExceptionMessage());\n    return sqlResponse;\n  }\n  finally {\n    BackdoorToggles.cleanToggles();\n  }\n}\n"}
{"INPUT": "public static void clear(ByteBuffer buffer){\n// bug_start\n  buffer.position(0);\n  buffer.limit(0);\n// bug_end\n}\n"}
{"INPUT": "public static void clearQueue(){\n  try {\n// bug_start\n    mService.removeTracks(0,Integer.MAX_VALUE);\n// bug_end\n  }\n catch (  final RemoteException ignored) {\n  }\n}\n"}
{"INPUT": "public void messageUidChanged(Account account,String folder,String oldUid,String newUid){\n  if (updateForMe(account,folder)) {\n    MessageInfoHolder holder=getMessage(oldUid);\n// bug_start\n    holder.uid=newUid;\n    holder.message.setUid(newUid);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public RecordSet createRecordSet(List<SpanAlign> spanAlignList,long focusTimestamp){\n  if (spanAlignList == null) {\n    throw new NullPointerException(\"spanAlignList must not be null\");\n  }\n  RecordSet recordSet=new RecordSet();\n  SpanBo focusTimeSpanBo=findFocusTimeSpanBo(spanAlignList,focusTimestamp);\n// bug_start\n  recordSet.setAgentId(focusTimeSpanBo.getAgentId());\n  recordSet.setApplicationId(focusTimeSpanBo.getApplicationId());\n// bug_end\n  String applicationName=getRpcArgument(focusTimeSpanBo);\n  recordSet.setApplicationName(applicationName);\n  long startTime=getStartTime(spanAlignList);\n  recordSet.setStartTime(startTime);\n  long endTime=getEndTime(spanAlignList);\n  recordSet.setEndTime(endTime);\n  final SpanAlignPopulate spanAlignPopulate=new SpanAlignPopulate();\n  List<Record> recordList=spanAlignPopulate.populateSpanRecord(spanAlignList);\n  logger.debug(\"RecordList:{}\",recordList);\n  long beginTimeStamp=focusTimeSpanBo.getStartTime();\n  markFocusRecord(recordList,beginTimeStamp);\n  recordSet.setBeginTimestamp(beginTimeStamp);\n  recordSet.setRecordList(recordList);\n  return recordSet;\n}\n"}
{"INPUT": "@Override public void undeploy(){\n  try {\n    deployment.getApplicationListeners().contextDestroyed();\n    deployment.getApplicationListeners().stop();\n    deployment=null;\n  }\n  finally {\n// bug_start\n    executor.release();\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void onPageSelected(int position){\n  findViewById(R.id.header).animate().translationY(0).setInterpolator(new LinearInterpolator()).setDuration(180);\n// bug_start\n  if (position < 3) {\n    sortItem.setVisible(true);\n  }\n// bug_end\n else {\n// bug_start\n    sortItem.setVisible(false);\n// bug_end\n  }\n}\n"}
{"INPUT": "ContactGroupJabberImpl(RosterGroup rosterGroup,Iterator<RosterEntry> groupMembers,ServerStoredContactListJabberImpl ssclCallback,boolean isResolved){\n// bug_start\n  this.id=rosterGroup.getName();\n// bug_end\n  this.isResolved=isResolved;\n  this.ssclCallback=ssclCallback;\n  if (rosterGroup != null)   this.nameCopy=rosterGroup.getName();\n  Iterator<RosterEntry> iter=groupMembers;\n  while (iter.hasNext()) {\n    RosterEntry rEntry=iter.next();\n    if (ssclCallback.findContactById(rEntry.getUser()) != null) {\n      continue;\n    }\n    addContact(new ContactJabberImpl(rEntry,ssclCallback,true,true));\n  }\n}\n"}
{"INPUT": "@Override public User login(Object request) throws AccessException {\n  HttpServletRequest req=(HttpServletRequest)request;\n  String token=resolveToken(req);\n  if (StringUtils.isBlank(token)) {\n    throw new AccessException(\"user not found!\");\n  }\n  try {\n    tokenManager.validateToken(token);\n  }\n catch (  ExpiredJwtException e) {\n    throw new AccessException(\"token expired!\");\n  }\ncatch (  Exception e) {\n    throw new AccessException(\"token invalid!\");\n  }\n  Authentication authentication=tokenManager.getAuthentication(token);\n  SecurityContextHolder.getContext().setAuthentication(authentication);\n  String username=authentication.getName();\n  NacosUser user=new NacosUser();\n  user.setUserName(username);\n  user.setToken(token);\n  List<RoleInfo> roleInfoList=roleService.getRoles(username);\n// bug_start\n  for (  RoleInfo roleInfo : roleInfoList) {\n    if (roleInfo.getRole().equals(NacosRoleServiceImpl.GLOBAL_ADMIN_ROLE)) {\n      user.setGlobalAdmin(true);\n      break;\n// bug_end\n    }\n  }\n  return user;\n}\n"}
{"INPUT": "@Override public void visit(IMetaMember mm){\n  if (mm.isCompiled()) {\n    Journal journal=JournalUtil.getJournal(model,mm);\n    if (journal != null) {\n      Task lastTaskTag=JournalUtil.getLastTask(journal);\n      if (lastTaskTag != null) {\n        parseDictionary=lastTaskTag.getParseDictionary();\n        Tag parsePhase=JournalUtil.getParsePhase(journal);\n// bug_start\n        List<Tag> parseTags=parsePhase.getNamedChildren(TAG_PARSE);\n        for (        Tag parseTag : parseTags) {\n          processParseTag(parseTag,mm);\n// bug_end\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "private void setFailedStatusIcons(){\n  dateText.setText(R.string.ConversationItem_error_not_delivered);\n// bug_start\n  indicatorText.setText(R.string.ConversationItem_click_for_details);\n  indicatorText.setVisibility(View.VISIBLE);\n// bug_end\n}\n"}
{"INPUT": "public void close(){\n// bug_start\n  scheduler.shutdownNow();\n// bug_end\n  Object[] items=this.getDataSources().values().toArray();\n  for (  Object item : items) {\n    JdbcUtils.close((DataSourceHolder)item);\n  }\n  MultiDataSourceStatManager.remove(this);\n}\n"}
{"INPUT": "public void addNamedQuery(String name,Query query){\n// bug_start\n  namedQueries.put(name,query);\n// bug_end\n}\n"}
{"INPUT": "@Override public void collect(int docID,CharSequence key,CharSequence context,float score) throws IOException {\n  int globalDoc=docID + docBase;\n  boolean isNewDoc=docContexts.containsKey(globalDoc) == false;\n  List<CharSequence> contexts=docContexts.computeIfAbsent(globalDoc,null);\n// bug_start\n  contexts.add(context);\n// bug_end\n  if (isNewDoc) {\n    super.collect(docID,key,context,score);\n  }\n}\n"}
{"INPUT": "@Override public Object decode(Channel channel,String remoteIp,byte[] data) throws IOException {\n  MotanV2Header header=MotanV2Header.buildHeader(data);\n  Map<String,String> metaMap=new HashMap<String,String>();\n  ByteBuffer buf=ByteBuffer.wrap(data);\n  int metaSize=buf.getInt(HEADER_SIZE);\n  int index=HEADER_SIZE + 4;\n  if (metaSize > 0) {\n    byte[] meta=new byte[metaSize];\n    buf.position(index);\n    buf.get(meta);\n    metaMap=deocdeMeta(meta);\n    index+=metaSize;\n  }\n  int bodySize=buf.getInt(index);\n  index+=4;\n  Object obj=null;\n  if (bodySize > 0) {\n    byte[] body=new byte[bodySize];\n    buf.position(index);\n    buf.get(body);\n    if (header.isGzip()) {\n      body=ByteUtil.unGzip(body);\n    }\n    Serialization serialization=getSerializaiontByNum(header.getSerialize());\n    obj=new DeserializableObject(serialization,body);\n  }\n  if (header.isRequest()) {\n    if (header.isHeartbeat()) {\n      return DefaultRpcHeartbeatFactory.getDefaultHeartbeatRequest(header.getRequestId());\n    }\n else {\n      DefaultRequest request=new DefaultRequest();\n      request.setRequestId(header.getRequestId());\n      request.setInterfaceName(metaMap.remove(M2_PATH));\n      request.setMethodName(metaMap.remove(M2_METHOD));\n      request.setParamtersDesc(metaMap.remove(M2_METHOD_DESC));\n      request.setAttachments(metaMap);\n// bug_start\n      request.setArguments(new Object[]{obj});\n// bug_end\n      if (metaMap.get(M2_GROUP) != null) {\n        request.setAttachment(URLParamType.group.getName(),metaMap.get(M2_GROUP));\n      }\n      if (StringUtils.isNotBlank(metaMap.get(M2_VERSION))) {\n        request.setAttachment(URLParamType.version.getName(),metaMap.get(M2_VERSION));\n      }\n      return request;\n    }\n  }\n else {\n    if (header.isHeartbeat()) {\n      return DefaultRpcHeartbeatFactory.getDefaultHeartbeatResponse(header.getRequestId());\n    }\n    DefaultResponse response=new DefaultResponse();\n    response.setRequestId(header.getRequestId());\n    response.setProcessTime(MathUtil.parseLong(metaMap.remove(M2_PROCESS_TIME),0));\n    response.setAttachments(metaMap);\n    if (header.getStatus() == MotanV2Header.MessageStatus.NORMAL.getStatus()) {\n      response.setValue(obj);\n    }\n else {\n      String errmsg=metaMap.remove(M2_ERROR);\n      Exception e=ExceptionUtil.fromMessage(errmsg);\n      if (e == null) {\n        e=(Exception)new MotanServiceException(\"default remote exception. remote errmsg:\" + errmsg);\n      }\n      response.setException(e);\n    }\n    return response;\n  }\n}\n"}
{"INPUT": "static List<AbstractBounds> getRestrictedRanges(final AbstractBounds queryRange){\n  if (queryRange instanceof Bounds && queryRange.left.equals(queryRange.right)) {\n    if (logger.isDebugEnabled())     logger.debug(\"restricted single token match for query \" + queryRange);\n    return Collections.singletonList(queryRange);\n  }\n  TokenMetadata tokenMetadata=StorageService.instance.getTokenMetadata();\n  List<AbstractBounds> ranges=new ArrayList<AbstractBounds>();\n  Iterator<Token> ringIter=TokenMetadata.ringIterator(tokenMetadata.sortedTokens(),queryRange.left,true);\n  AbstractBounds remainder=queryRange;\n  while (ringIter.hasNext()) {\n    Token token=ringIter.next();\n    if (remainder == null || !remainder.contains(token))     break;\n    Pair<AbstractBounds,AbstractBounds> splits=remainder.split(token);\n// bug_start\n    ranges.add(splits.left);\n// bug_end\n    remainder=splits.right;\n  }\n  if (remainder != null)   ranges.add(remainder);\n  if (logger.isDebugEnabled())   logger.debug(\"restricted ranges for query \" + queryRange + \" are \"+ ranges);\n  return ranges;\n}\n"}
{"INPUT": "@Override @OutboundActionMeta(name=\"storage\") public void handleOutbound(Context ctx) throws ServletException, IOException {\n  Model model=new Model(ctx);\n  Payload payload=ctx.getPayload();\n  normalize(model,payload);\n  StorageReport storageReport=null;\n  StorageReport rawReport=null;\nswitch (payload.getAction()) {\ncase HOURLY_STORAGE:\n    storageReport=queryHourlyReport(payload);\n// bug_start\n  model.setOriginalReport(storageReport);\nrawReport=filterReport(payload,model,storageReport);\nstorageReport=mergeReport(payload,rawReport);\nmodel.setReport(storageReport);\nbuildDepartments(payload,model,storageReport);\n// bug_end\nbreak;\ncase HOURLY_STORAGE_GRAPH:\nstorageReport=queryHourlyReport(payload);\nrawReport=filterReport(payload,model,storageReport);\nif (Constants.ALL.equals(payload.getIpAddress())) {\nbuildPieCharts(model,payload,rawReport);\n}\nstorageReport=mergeReport(payload,rawReport);\nmodel.setReport(storageReport);\nbuildLineCharts(model,payload,storageReport);\nbuildDepartments(payload,model,storageReport);\nbreak;\ncase HISTORY_STORAGE:\nstorageReport=queryHistoryReport(payload);\nmodel.setOriginalReport(storageReport);\nrawReport=filterReport(payload,model,storageReport);\nstorageReport=mergeReport(payload,rawReport);\nmodel.setReport(storageReport);\nbuildDepartments(payload,model,storageReport);\nbreak;\ncase DASHBOARD:\nMap<String,StorageAlertInfo> alertInfos=m_alertInfoManager.queryAlertInfos(payload,model);\nmodel.setLinks(buildAlertLinks(alertInfos,payload.getType()));\nmodel.setAlertInfos(alertInfos);\nmodel.setReportStart(new Date(payload.getDate()));\nmodel.setReportEnd(new Date(payload.getDate() + TimeHelper.ONE_HOUR - 1));\nmodel.setAlterations(buildAlterations(payload,model));\nbreak;\n}\nmodel.setPage(ReportPage.STORAGE);\nif (!ctx.isProcessStopped()) {\nm_jspViewer.view(ctx,model);\n}\n}\n"}
{"INPUT": "@Override public void onPrepared(String url,Object... objects){\n  super.onPrepared(url,objects);\n  orientationUtils.setEnable(true);\n// bug_start\n  webView.removeAllViews();\n  webView.destroy();\n  webView=null;\n// bug_end\n}\n"}
{"INPUT": "private RichTooltip buildTooltip(LayoutBuilder builder){\n  String description=\"\";\n  LayoutUI layoutUI=null;\n  try {\n    layoutUI=builder.getUI();\n// bug_start\n    description=layoutUI.getDescription();\n// bug_end\n    if (layoutUI.getQualityRank() < 0 || layoutUI.getSpeedRank() < 0) {\n      layoutUI=null;\n    }\n  }\n catch (  Exception e) {\n    layoutUI=null;\n  }\n  RichTooltip richTooltip=new RichTooltip(builder.getName(),description);\n  if (layoutUI != null) {\n    LayoutDescriptionImage layoutDescriptionImage=new LayoutDescriptionImage(layoutUI);\n    richTooltip.setMainImage(layoutDescriptionImage.getImage());\n  }\n  return richTooltip;\n}\n"}
{"INPUT": "private ListMultimap<Class<? extends WorldFacet>,FacetProvider> determineProviderChains(){\n  ListMultimap<Class<? extends WorldFacet>,FacetProvider> result=ArrayListMultimap.create();\n  Set<Class<? extends WorldFacet>> facets=Sets.newHashSet();\n  for (  FacetProvider provider : providersList) {\n    Produces produces=provider.getClass().getAnnotation(Produces.class);\n    if (produces != null) {\n      facets.addAll(Arrays.asList(produces.value()));\n    }\n    Updates updates=provider.getClass().getAnnotation(Updates.class);\n// bug_start\n    for (    Facet facet : updates.value()) {\n      facets.add(facet.value());\n// bug_end\n    }\n  }\n  for (  Class<? extends WorldFacet> facet : facets) {\n    determineProviderChainFor(facet,result);\n  }\n  return result;\n}\n"}
{"INPUT": "protected static void shutdownClusters() throws Exception {\n  if (secureProps != null) {\n    secureProps.clear();\n  }\n// bug_start\n  kafkaServer.shutdown();\n// bug_end\n}\n"}
{"INPUT": "void updateProportion(float x,float y){\n  if (getTopPosition() < getItemCount()) {\n    View view=findViewByPosition(getTopPosition());\n// bug_start\n    float half=getHeight() / 2.0f;\n    state.proportion=-(y - half - view.getTop()) / half;\n// bug_end\n  }\n}\n"}
{"INPUT": "void restoreStates(@Nullable SparseArray<?> savedStates){\n  int cacheSize;\n  if (savedStates != null && (cacheSize=savedStates.size()) > 0) {\n    for (int i=0; i < cacheSize; i++) {\n      int order=savedStates.keyAt(i);\n      Object key=getKey(order);\n      coldKeyToOrderMap.put(order,key);\n      PlaybackInfo playbackInfo=(PlaybackInfo)savedStates.get(order);\n// bug_start\n      this.savePlaybackInfo(order,playbackInfo);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "@Override public void showMessage(CharSequence message,ColorStateList colorState){\n// bug_start\n  mSecurityMessageDisplay.setNextMessageColor(colorState);\n// bug_end\n  mSecurityMessageDisplay.setMessage(message);\n}\n"}
{"INPUT": "private void registerAccountTypesSupported(int uid,UserAccounts ua){\n  String interestedPackages=null;\n  try {\n    String[] allPackages=mPackageManager.getPackagesForUid(uid);\n// bug_start\n    for (    String aPackage : allPackages) {\n      ApplicationInfo ai=mPackageManager.getApplicationInfo(aPackage,PackageManager.GET_META_DATA);\n      Bundle b=ai.metaData;\n      if (b == null) {\n        return;\n// bug_end\n      }\n// bug_start\n      interestedPackages=b.getString(\"android.accounts.SupportedLoginTypes\");\n// bug_end\n    }\n  }\n catch (  PackageManager.NameNotFoundException e) {\n    Log.d(\"NameNotFoundException\",e.getMessage());\n  }\n  if (interestedPackages != null) {\n    requestAccountVisibility(interestedPackages.split(\";\"),uid,ua);\n  }\n}\n"}
{"INPUT": "@VisibleForTesting protected boolean inSystemImage(int callerUid){\n  String[] packages=mContext.getPackageManager().getPackagesForUid(callerUid);\n// bug_start\n  for (  String name : packages) {\n    try {\n      PackageInfo packageInfo=mContext.getPackageManager().getPackageInfo(name,0);\n      if ((packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n        return true;\n// bug_end\n      }\n// bug_start\n    }\n catch (    PackageManager.NameNotFoundException e) {\n      return false;\n// bug_end\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "public static void setActualDefaultRingtoneUri(Context context,int type,Uri ringtoneUri){\n  String setting=getSettingForType(type);\n  if (setting == null)   return;\n  Settings.System.putString(context.getContentResolver(),setting,ringtoneUri != null ? ringtoneUri.toString() : null);\n// bug_start\n  final ContentResolver cr=context.getContentResolver();\n  final Uri cacheUri=getCacheForType(type);\n  try (InputStream in=cr.openInputStream(ringtoneUri);OutputStream out=cr.openOutputStream(cacheUri)){\n    Streams.copy(in,out);\n  }\n catch (  IOException e) {\n    Log.w(TAG,\"Failed to cache ringtone: \" + e);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void onClick(View v){\n  mPipManager.closePip();\n// bug_start\n  mListener.onClosed();\n// bug_end\n}\n"}
{"INPUT": "public DownloadTask register(DownloadListener listener){\n  Progress progress=DownloadManager.getInstance().get(tag);\n  if (progress == null) {\n    progress=this.progress;\n    DownloadManager.getInstance().insert(progress);\n  }\n  Map<String,DownloadTask> taskMap=OkDownload.getInstance().getTaskMap();\n  DownloadTask downloadTask=taskMap.get(progress.tag);\n  if (downloadTask == null) {\n    downloadTask=this;\n    taskMap.put(progress.tag,downloadTask);\n  }\n// bug_start\n  downloadTask.listenerMap.put(listener.tag,listener);\n// bug_end\n  return this;\n}\n"}
{"INPUT": "public ListenerConfigReadOnly(ListenerConfig config){\n// bug_start\n  super.setClassName(config.getClassName());\n// bug_end\n  super.setImplementation(config.getImplementation());\n}\n"}
{"INPUT": "protected void showPolicyDialog(){\n  PolicyDialog dialog=new PolicyDialog(getView().getMainFrame());\n  dialog.initParam(getModel().getOptionsParam());\n  for (  AbstractParamPanel panel : policyPanels) {\n    dialog.addPolicyPanel(panel);\n  }\n  ExtensionPassiveScan pscan=(ExtensionPassiveScan)Control.getSingleton().getExtensionLoader().getExtension(ExtensionPassiveScan.NAME);\n// bug_start\n  dialog.addPolicyPanel(pscan.getPolicyPanel());\n// bug_end\n  int result=dialog.showDialog(false);\n  if (result == JOptionPane.OK_OPTION) {\n    try {\n      getModel().getOptionsParam().getConfig().save();\n    }\n catch (    ConfigurationException ce) {\n      logger.error(ce.getMessage(),ce);\n      getView().showWarningDialog(Constant.messages.getString(\"scanner.save.warning\"));\n    }\n  }\n}\n"}
{"INPUT": "@Implementation public View findViewById(int viewId){\n  if (context != null) {\n    if (inflatedView == null && layoutId > 0) {\n      inflatedView=ShadowLayoutInflater.from(context).inflate(layoutId,null);\n    }\n// bug_start\n    return inflatedView.findViewById(viewId);\n// bug_end\n  }\n  return null;\n}\n"}
{"INPUT": "public String search(Model model,HttpServletRequest request,HttpServletResponse response,String query) throws ServletException, IOException, ServiceException {\n  try {\n    if (StringUtils.isNotEmpty(query)) {\n      query=StringUtils.trim(query);\n      query=exploitProtectionService.cleanString(query);\n    }\n  }\n catch (  ServiceException e) {\n    query=null;\n  }\n  if (query == null || query.length() == 0) {\n    return \"redirect:/\";\n  }\n  if (request.getParameterMap().containsKey(\"facetField\")) {\n    String fieldName=request.getParameter(\"facetField\");\n    List<String> activeFieldFilters=new ArrayList<String>();\n    Map<String,String[]> parameters=new HashMap<String,String[]>(request.getParameterMap());\n    for (Iterator<Entry<String,String[]>> iter=parameters.entrySet().iterator(); iter.hasNext(); ) {\n      Map.Entry<String,String[]> entry=iter.next();\n      String key=entry.getKey();\n      if (key.startsWith(fieldName + \"-\")) {\n        activeFieldFilters.add(key.substring(key.indexOf('-') + 1));\n        iter.remove();\n      }\n    }\n    parameters.remove(ProductSearchCriteria.PAGE_NUMBER);\n    parameters.put(fieldName,activeFieldFilters.toArray(new String[activeFieldFilters.size()]));\n    parameters.remove(\"facetField\");\n    String newUrl=ProcessorUtils.getUrl(request.getRequestURL().toString(),parameters);\n    return \"redirect:\" + newUrl;\n  }\n else {\n    SearchRedirect handler=searchRedirectService.findSearchRedirectBySearchTerm(query);\n    if (handler != null) {\n      String contextPath=request.getContextPath();\n      String url=UrlUtil.fixRedirectUrl(contextPath,handler.getUrl());\n      response.sendRedirect(url);\n      return null;\n    }\n    if (StringUtils.isNotEmpty(query)) {\n      List<SearchFacetDTO> availableFacets=getSearchService().getSearchFacets();\n      ProductSearchCriteria searchCriteria=facetService.buildSearchCriteria(request,availableFacets);\n      ProductSearchResult result=getSearchService().findProductsByQuery(query,searchCriteria);\n      facetService.setActiveFacetResults(result.getFacets(),request);\n      model.addAttribute(PRODUCTS_ATTRIBUTE_NAME,result.getProducts());\n      model.addAttribute(FACETS_ATTRIBUTE_NAME,result.getFacets());\n      model.addAttribute(PRODUCT_SEARCH_RESULT_ATTRIBUTE_NAME,result);\n      model.addAttribute(ORIGINAL_QUERY_ATTRIBUTE_NAME,query);\n// bug_start\n      model.addAttribute(ALL_PRODUCTS_ATTRIBUTE_NAME,new HashSet<Product>(result.getProducts()));\n// bug_end\n    }\n  }\n  return getSearchView();\n}\n"}
{"INPUT": "@Override public void onReceive(Context context,Intent intent){\n  if (isWifiAvailable && intent.getAction().equals(NetworkMonitorService.NEW_ENDPOINT)) {\n    String address=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_ADDRESS), hardware=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_HARDWARE);\n    final Target target=Target.getFromString(address);\n    target.getEndpoint().setHardware(Endpoint.parseMacAddress(hardware));\n    MainActivity.this.runOnUiThread(new Runnable(){\n      @Override public void run(){\n        if (System.addOrderedTarget(target) == true) {\n          mTargetAdapter.notifyDataSetChanged();\n        }\n      }\n    }\n);\n  }\n else   if (isWifiAvailable == false && isConnectivityAvailable == true && intent.getAction().equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {\n    NetworkInfo info=intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);\n// bug_start\n    if (NetworkInfo.State.CONNECTING.equals(info.getState()))     mUpdateStatus.setText(\"Connecting to WiFi access point ...\");\n else     if (NetworkInfo.State.CONNECTED.equals(info.getState())) {\n      ((DSploitApplication)getApplication()).onCreate();\n      onCreate(null);\n// bug_end\n    }\n  }\n else   if (intent.getAction().equals(UpdateService.UPDATE_CHECKING) && mUpdateStatus != null) {\n    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(\"#STATUS#\",\"Checking ...\"));\n  }\n else   if (intent.getAction().equals(UpdateService.UPDATE_NOT_AVAILABLE) && mUpdateStatus != null) {\n    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(\"#STATUS#\",\"No updates available.\"));\n  }\n else   if (intent.getAction().equals(UpdateService.UPDATE_AVAILABLE)) {\n    final String remoteVersion=(String)intent.getExtras().get(UpdateService.AVAILABLE_VERSION);\n    if (mUpdateStatus != null)     mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(\"#STATUS#\",\"New version \" + remoteVersion + \" found!\"));\n    MainActivity.this.runOnUiThread(new Runnable(){\n      @Override public void run(){\n        new ConfirmDialog(\"Update Available\",\"A new update to version \" + remoteVersion + \" is available, do you want to download it ?\",MainActivity.this,new ConfirmDialogListener(){\n          @Override public void onConfirm(){\n            final ProgressDialog dialog=new ProgressDialog(MainActivity.this);\n            dialog.setMessage(\"Downloading update ...\");\n            dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n            dialog.setMax(100);\n            dialog.setCancelable(true);\n            dialog.show();\n            new Thread(new Runnable(){\n              @Override public void run(){\n                if (System.getUpdateManager().downloadUpdate(MainActivity.this,dialog) == false) {\n                  MainActivity.this.runOnUiThread(new Runnable(){\n                    @Override public void run(){\n                      new ErrorDialog(\"Error\",\"An error occurred while downloading the update.\",MainActivity.this).show();\n                    }\n                  }\n);\n                }\n                dialog.dismiss();\n              }\n            }\n).start();\n          }\n          @Override public void onCancel(){\n          }\n        }\n).show();\n      }\n    }\n);\n  }\n}\n"}
{"INPUT": "private static View createViewInternal(Context context,JSONObject jsonObject,ViewGroup parent,HashMap<String,Integer> ids){\n  View view=null;\n  ArrayList<DynamicProperty> properties;\n  try {\n    String widget=jsonObject.getString(\"widget\");\n    if (!widget.contains(\".\")) {\n      widget=\"android.widget.\" + widget;\n    }\n    Class viewClass=Class.forName(widget);\n    view=(View)viewClass.getConstructor(Context.class).newInstance(new Object[]{context});\n  }\n catch (  JSONException e) {\n    e.printStackTrace();\n  }\ncatch (  ClassNotFoundException e) {\n    e.printStackTrace();\n  }\ncatch (  NoSuchMethodException e) {\n    e.printStackTrace();\n  }\ncatch (  InvocationTargetException e) {\n    e.printStackTrace();\n  }\ncatch (  InstantiationException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalAccessException e) {\n    e.printStackTrace();\n  }\n  if (view == null)   return null;\n  try {\n    ViewGroup.LayoutParams params=DynamicHelper.createLayoutParams(parent);\n    view.setLayoutParams(params);\n    properties=new ArrayList<>();\n    JSONArray jArray=jsonObject.getJSONArray(\"properties\");\n    if (jArray != null) {\n      for (int i=0; i < jArray.length(); i++) {\n        DynamicProperty p=new DynamicProperty(jArray.getJSONObject(i));\n        if (p.isValid())         properties.add(p);\n      }\n    }\n    view.setTag(INTERNAL_TAG_ID,properties);\n    String id=DynamicHelper.applyStyleProperties(view,properties);\n    if (!TextUtils.isEmpty(id)) {\n      ids.put(id,mCurrentId);\n      view.setId(mCurrentId);\n      mCurrentId++;\n    }\n    if (view instanceof ViewGroup) {\n      ViewGroup viewGroup=(ViewGroup)view;\n      List<View> views=new ArrayList<>();\n      JSONArray jViews=jsonObject.optJSONArray(\"views\");\n      if (jViews != null) {\n        int count=jViews.length();\n        for (int i=0; i < count; i++) {\n          View dynamicChildView=DynamicView.createViewInternal(context,jViews.getJSONObject(i),parent,ids);\n// bug_start\n          views.add(dynamicChildView);\n          viewGroup.addView(dynamicChildView);\n// bug_end\n        }\n      }\n      for (      View v : views) {\n        DynamicHelper.applyLayoutProperties(v,(List<DynamicProperty>)v.getTag(INTERNAL_TAG_ID),viewGroup,ids);\n        v.setTag(INTERNAL_TAG_ID,null);\n      }\n    }\n  }\n catch (  JSONException e) {\n    e.printStackTrace();\n  }\n  return view;\n}\n"}
{"INPUT": "private Collection<Plugin> combine(Plugin corePlugin,Collection<Plugin> enabled){\n  List<Plugin> result=new ArrayList<Plugin>(enabled);\n// bug_start\n  result.add(corePlugin);\n// bug_end\n  return result;\n}\n"}
{"INPUT": "protected BuildConfiguration getConfiguration(BuildConfiguration fromConfig,PatchTransition transition) throws InterruptedException {\n  if (transition == NoTransition.INSTANCE) {\n    return fromConfig;\n  }\n else   if (transition == NullTransition.INSTANCE) {\n    return null;\n  }\n else {\n    try {\n// bug_start\n      return skyframeExecutor.getConfigurationForTesting(reporter,fromConfig.fragmentClasses(),transition.patch(fromConfig.getOptions()));\n// bug_end\n    }\n catch (    OptionsParsingException|InvalidConfigurationException e) {\n      throw new AssertionError(e);\n    }\n  }\n}\n"}
{"INPUT": "@Provides @LazySingleton @Global public StupidPool<ByteBuffer> getIntermediateResultsPool(DruidProcessingConfig config){\n  verifyDirectMemory(config);\n// bug_start\n  return new StupidPool<>(new OffheapBufferGenerator(\"intermediate processing\",config.intermediateComputeSizeBytes()),config.poolCacheMaxCount());\n// bug_end\n}\n"}
{"INPUT": "public void fetch(DefaultGoPublisher goPublisher,FetchArtifactBuilder fetchArtifactBuilder){\n  try {\n    String fetchMsg=String.format(\"Fetching artifact [%s] from [%s]\",fetchArtifactBuilder.getSrc(),fetchArtifactBuilder.jobLocatorForDisplay());\n// bug_start\n    goPublisher.consumeLineWithPrefix(fetchMsg);\n// bug_end\n    fetchArtifactBuilder.fetch(new DownloadAction(httpService,goPublisher,new SystemTimeClock()),urlService);\n  }\n catch (  Exception e) {\n    String fetchMsg=String.format(\"Failed to save artifact [%s] to [%s]\",fetchArtifactBuilder.getSrc(),fetchArtifactBuilder.getDest());\n    LOGGER.error(fetchMsg,e);\n    goPublisher.consumeLineWithPrefix(fetchMsg);\n    throw new RuntimeException(e);\n  }\n}\n"}
{"INPUT": "public JiraIssue createIssue(final Map<String,Object> fields,final HttpProxy proxy) throws IOException {\n  HttpRequest request=HttpRequest.builder(url.getHost(),url.getPort()).scheme(Scheme.parse(url.getScheme())).method(HttpMethod.POST).path(DEFAULT_PATH).jsonBody(null).auth(new BasicAuth(user,password.toCharArray())).proxy(proxy).build();\n  HttpResponse response=httpClient.execute(request);\n// bug_start\n  return JiraIssue.responded(fields,request,response);\n// bug_end\n}\n"}
{"INPUT": "@Test public void shouldCreateCorrectSinkKsqlTopic(){\n  final String simpleQuery=\"CREATE STREAM FOO WITH (KAFKA_TOPIC='TEST_TOPIC1') AS SELECT col0, col2, col3 FROM test1 WHERE col0 > 100;\";\n  final MetaStore testMetastore=metaStore.clone();\n// bug_start\n  final KsqlTopic ksqlTopic=new KsqlTopic(\"FOO\",\"TEST_TOPIC1\",new KsqlJsonTopicSerDe());\n// bug_end\n  testMetastore.putTopic(ksqlTopic);\n  final List<Statement> statements=getPreparedStatements(simpleQuery,testMetastore).stream().map(null).collect(Collectors.toList());\n  final CreateStreamAsSelect createStreamAsSelect=(CreateStreamAsSelect)statements.get(0);\n  final Table intoTable=new Table(QualifiedName.of(createStreamAsSelect.getName().toString()));\n  intoTable.setProperties(createStreamAsSelect.getProperties());\n  final QuerySpecification querySpecification=(QuerySpecification)createStreamAsSelect.getQuery().getQueryBody();\n  final QuerySpecification newQuerySpecification=new QuerySpecification(querySpecification.getSelect(),intoTable,false,querySpecification.getFrom(),querySpecification.getWindowExpression(),querySpecification.getWhere(),querySpecification.getGroupBy(),querySpecification.getHaving(),querySpecification.getLimit());\n  final Analysis analysis=new Analysis();\n  final Analyzer analyzer=new Analyzer(\"sqlExpression\",analysis,testMetastore,\"\");\n  analyzer.visitQuerySpecification(newQuerySpecification,new AnalysisContext(null));\n  Assert.assertNotNull(\"INTO is null\",analysis.getInto());\n  final StructuredDataSource structuredDataSource=analysis.getInto();\n  final KsqlTopic createdKsqlTopic=structuredDataSource.getKsqlTopic();\n  assertThat(createdKsqlTopic.getTopicName(),equalTo(\"FOO\"));\n  assertThat(createdKsqlTopic.getKafkaTopicName(),equalTo(\"TEST_TOPIC1\"));\n}\n"}
{"INPUT": "boolean verifyAttributes(FileObject fo,boolean checkOnly){\n  if (fo == null)   return false;\n  boolean vote=false;\n  try {\n    final ClassPath[] pps=validatePaths();\n    final URL url=fo.toURL();\n    String val=JavaIndex.getAttribute(url,APT_DIRTY,null);\n    if (Boolean.parseBoolean(val)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to processors dirty\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n      JavaIndex.setAttribute(url,APT_DIRTY,null);\n    }\n    if (JavaIndex.ensureAttributeValue(url,SOURCE_LEVEL_ROOT,sourceLevel.getSourceLevel(),checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to source level change\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n    if (JavaIndex.ensureAttributeValue(url,JRE_PROFILE,sourceLevel.getProfile().getName(),checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to jre profile change\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n// bug_start\n    final String cmpOptsStr=JavacParser.validateCompilerOptions(compilerOptions.getArguments()).stream().collect(Collectors.joining(\" \"));\n// bug_end\n    if (JavaIndex.ensureAttributeValue(url,COMPILER_OPTIONS,cmpOptsStr,checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to compiler options change\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n    if (JavaIndex.ensureAttributeValue(url,BOOT_PATH,pathToString(bootPath),checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to boot path change\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n    if (JavaIndex.ensureAttributeValue(url,COMPILE_PATH,pathToString(compilePath),checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to compile path change\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n    boolean apEnabledOnScan=aptOptions.annotationProcessingEnabled().contains(AnnotationProcessingQuery.Trigger.ON_SCAN);\n    if (JavaIndex.ensureAttributeValue(url,APT_ENABLED,apEnabledOnScan ? Boolean.TRUE.toString() : null,checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to change in annotation processing options\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n    if (!apEnabledOnScan) {\n      return vote;\n    }\n    if (JavaIndex.ensureAttributeValue(url,PROCESSOR_MODULE_PATH,pathToFlaggedString(pps[0],false),checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to processor module path change\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n    if (JavaIndex.ensureAttributeValue(url,PROCESSOR_PATH,pathToFlaggedString(pps[1],false),checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to processor path change\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n    if (JavaIndex.ensureAttributeValue(url,ANNOTATION_PROCESSORS,encodeToStirng(aptOptions.annotationProcessorsToRun()),checkOnly)) {\n      JavaIndex.LOG.fine(\"forcing reindex due to change in annotation processors\");\n      vote=true;\n      if (checkOnly) {\n        return vote;\n      }\n    }\n  }\n catch (  IOException ioe) {\n    Exceptions.printStackTrace(ioe);\n  }\n  return vote;\n}\n"}
{"INPUT": "protected ActiveMQConnection createActiveMQConnection(Transport transport,JMSStatsImpl stats) throws Exception {\n// bug_start\n  ActiveMQXAConnection connection=new ActiveMQXAConnection(transport,getClientIdGenerator(),stats);\n// bug_end\n  return connection;\n}\n"}
{"INPUT": "public static Handle createHandle(){\n  Connection fakeConnection=Mockito.mock(Connection.class);\n// bug_start\n  return new Handle(new ConfigRegistry(),null,new LocalTransactionHandler(),new DefaultStatementBuilder(),fakeConnection);\n// bug_end\n}\n"}
{"INPUT": "public void testPruneSubqueryAliases(){\n// bug_start\n  ShowTables s=new ShowTables(EMPTY,null);\n// bug_end\n  SubQueryAlias plan=new SubQueryAlias(EMPTY,s,\"show\");\n  LogicalPlan result=new PruneSubqueryAliases().apply(plan);\n  assertEquals(result,s);\n}\n"}
{"INPUT": "@Test public void testTopNWithDimFilterAndWithFilteredDimSpec() throws Exception {\n  TopNQuery query=new TopNQueryBuilder().dataSource(\"xx\").granularity(QueryGranularities.ALL).dimension(new ListFilteredDimensionSpec(new DefaultDimensionSpec(\"tags\",\"tags\"),ImmutableSet.of(\"t3\"),null)).metric(\"count\").intervals(QueryRunnerTestHelper.fullOnInterval).aggregators(Arrays.asList(new AggregatorFactory[]{new CountAggregatorFactory(\"count\")})).threshold(5).filters(new SelectorDimFilter(\"tags\",\"t3\",null)).build();\n  QueryRunnerFactory factory=new TopNQueryRunnerFactory(TestQueryRunners.getPool(),new TopNQueryQueryToolChest(new TopNQueryConfig(),QueryRunnerTestHelper.NoopIntervalChunkingQueryRunnerDecorator()),QueryRunnerTestHelper.NOOP_QUERYWATCHER);\n// bug_start\n  QueryRunner<Result<TopNResultValue>> runner=QueryRunnerTestHelper.makeQueryRunner(factory,new QueryableIndexSegment(\"sid1\",queryableIndex));\n// bug_end\n  Map<String,Object> context=Maps.newHashMap();\n  Sequence<Result<TopNResultValue>> result=runner.run(query,context);\n  List<Result<TopNResultValue>> expectedResults=Arrays.asList(new Result<TopNResultValue>(new DateTime(\"2011-01-12T00:00:00.000Z\"),new TopNResultValue(Arrays.<Map<String,Object>>asList(ImmutableMap.<String,Object>of(\"tags\",\"t3\",\"count\",2L)))));\n  TestHelper.assertExpectedObjects(expectedResults,Sequences.toList(result,new ArrayList<Result<TopNResultValue>>()),\"\");\n}\n"}
{"INPUT": "@Override public void subscribe(CoreSubscriber<? super T> actual){\n  BaseSink<T> sink=createSink(actual,backpressure);\n  actual.onSubscribe(sink);\n  try {\n    source.accept(createMode == CreateMode.PUSH_PULL ? new SerializedSink<>(sink) : sink);\n  }\n catch (  Throwable ex) {\n    Exceptions.throwIfFatal(ex);\n// bug_start\n    sink.error(Operators.onOperatorError(ex));\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public ITupleIterator search(StorageContext context,SQLDigest sqlDigest,TupleInfo returnTupleInfo){\n  GTCubeStorageQueryRequest request=getStorageQueryRequest(context,sqlDigest,returnTupleInfo);\n  List<CubeSegmentScanner> scanners=Lists.newArrayList();\n  for (  CubeSegment cubeSeg : cubeInstance.getSegments(SegmentStatusEnum.READY)) {\n    CubeSegmentScanner scanner;\n    if (cubeDesc.getConfig().isSkippingEmptySegments() && cubeSeg.getInputRecords() == 0) {\n      logger.info(\"Skip cube segment {} because its input record is 0\",cubeSeg);\n      continue;\n    }\n    scanner=new CubeSegmentScanner(cubeSeg,request.getCuboid(),request.getDimensions(),request.getGroups(),request.getMetrics(),request.getFilter(),request.getHavingFilter(),request.getContext());\n    if (!scanner.isSegmentSkipped())     scanners.add(scanner);\n  }\n  if (scanners.isEmpty())   return ITupleIterator.EMPTY_TUPLE_ITERATOR;\n// bug_start\n  return new SequentialCubeTupleIterator(scanners,request.getCuboid(),request.getDimensions(),request.getMetrics(),returnTupleInfo,request.getContext());\n// bug_end\n}\n"}
{"INPUT": "@Test public void checkAccountNotFound() throws Exception {\n// bug_start\n  final YubiKeyAuthenticationHandler handler=new YubiKeyAuthenticationHandler(CLIENT_ID,SECRET_KEY,null);\n// bug_end\n  this.thrown.expect(AccountNotFoundException.class);\n  handler.authenticate(new YubiKeyCredential(OTP));\n}\n"}
{"INPUT": "@Override @SuppressWarnings(\"deprecation\") public void updateFromUIDL(UIDL uidl,ApplicationConnection client){\n  boolean lastReadOnlyState=getWidgetForPaintable().readonly;\n  boolean lastEnabledState=getWidgetForPaintable().isEnabled();\n  getWidgetForPaintable().parsable=uidl.getBooleanAttribute(\"parsable\");\n  super.updateFromUIDL(uidl,client);\n// bug_start\n  String popupStyleNames=getStyleNameFromUIDL(VPopupCalendar.POPUP_PRIMARY_STYLE_NAME,uidl,false);\n// bug_end\n  popupStyleNames+=\" \" + VDateField.CLASSNAME + \"-\"+ VPopupCalendar.resolutionToString(getWidgetForPaintable().currentResolution);\n  getWidgetForPaintable().popup.setStyleName(popupStyleNames);\n  getWidgetForPaintable().calendar.setDateTimeService(getWidgetForPaintable().getDateTimeService());\n  getWidgetForPaintable().calendar.setShowISOWeekNumbers(getWidgetForPaintable().isShowISOWeekNumbers());\n  if (getWidgetForPaintable().calendar.getResolution() != getWidgetForPaintable().currentResolution) {\n    getWidgetForPaintable().calendar.setResolution(getWidgetForPaintable().currentResolution);\n    if (getWidgetForPaintable().calendar.getDate() != null) {\n      getWidgetForPaintable().calendar.setDate((Date)getWidgetForPaintable().getCurrentDate().clone());\n      getWidgetForPaintable().calendar.renderCalendar();\n    }\n  }\n  getWidgetForPaintable().calendarToggle.setEnabled(getWidgetForPaintable().enabled);\n  if (getWidgetForPaintable().currentResolution <= VPopupCalendar.RESOLUTION_MONTH) {\n    getWidgetForPaintable().calendar.setFocusChangeListener(new FocusChangeListener(){\n      public void focusChanged(      Date date){\n        getWidgetForPaintable().updateValue(date);\n        getWidgetForPaintable().buildDate();\n        Date date2=getWidgetForPaintable().calendar.getDate();\n        date2.setYear(date.getYear());\n        date2.setMonth(date.getMonth());\n      }\n    }\n);\n  }\n else {\n    getWidgetForPaintable().calendar.setFocusChangeListener(null);\n  }\n  if (getWidgetForPaintable().currentResolution > VPopupCalendar.RESOLUTION_DAY) {\n    getWidgetForPaintable().calendar.setTimeChangeListener(new TimeChangeListener(){\n      public void changed(      int hour,      int min,      int sec,      int msec){\n        Date d=getWidgetForPaintable().getDate();\n        if (d == null) {\n          d=(Date)getWidgetForPaintable().calendar.getDate().clone();\n        }\n        d.setHours(hour);\n        d.setMinutes(min);\n        d.setSeconds(sec);\n        DateTimeService.setMilliseconds(d,msec);\n        getWidgetForPaintable().updateValue(d);\n        getWidgetForPaintable().buildDate();\n      }\n    }\n);\n  }\n  if (getWidgetForPaintable().readonly) {\n    getWidgetForPaintable().calendarToggle.addStyleName(VPopupCalendar.CLASSNAME + \"-button-readonly\");\n  }\n else {\n    getWidgetForPaintable().calendarToggle.removeStyleName(VPopupCalendar.CLASSNAME + \"-button-readonly\");\n  }\n  if (lastReadOnlyState != getWidgetForPaintable().readonly || lastEnabledState != getWidgetForPaintable().isEnabled()) {\n    getWidgetForPaintable().updateWidth();\n  }\n  getWidgetForPaintable().calendarToggle.setEnabled(true);\n}\n"}
{"INPUT": "public static IndexSchemaFactory newIndexSchemaFactory(SolrConfig config){\n  PluginInfo info=config.getPluginInfo(IndexSchemaFactory.class.getName());\n  IndexSchemaFactory factory;\n  if (null != info) {\n// bug_start\n    factory=config.getResourceLoader().newInstance(info.className,IndexSchemaFactory.class);\n// bug_end\n    factory.init(info.initArgs);\n  }\n else {\n    factory=config.getResourceLoader().newInstance(ManagedIndexSchemaFactory.class.getName(),IndexSchemaFactory.class);\n  }\n  return factory;\n}\n"}
{"INPUT": "@Override public void processBindingConfiguration(String context,Item item,String bindingConfig) throws BindingConfigParseException {\n  super.processBindingConfiguration(context,item,bindingConfig);\n  logger.debug(\"read item : \" + item);\n  logger.debug(\"read config : \" + bindingConfig);\n// bug_start\n  String[] itemConfig=StringUtils.split(bindingConfig);\n// bug_end\n  zibaseBindingConfig config=zibaseBindingConfig.factory(itemConfig);\n  itemMap.put(item.getName(),config);\n  if (idMap.containsKey(config.getId())) {\n    idMap.get(config.getId()).add(item.getName());\n  }\n else {\n    Vector<String> vector=new Vector<String>();\n    vector.add(item.getName());\n    idMap.put(config.getId(),vector);\n  }\n  logger.info(\"adding \" + item.getName());\n  addBindingConfig(item,config);\n}\n"}
{"INPUT": "@Override public Facet facet(){\n// bug_start\n  return new InternalStringTermsFacet(facetName,comparatorType,size,Sets.newHashSet(new InternalStringTermsFacet.StringEntry(indexName,count)),0);\n// bug_end\n}\n"}
{"INPUT": "protected void resetEditorFrom(final FlexUnitRunConfiguration config){\n  final FlexUnitRunnerParameters params=config.getRunnerParameters();\n  myLauncherParameters=params.getLauncherParameters().clone();\n  myBCCombo.resetFrom(params);\n// bug_start\n  myWhatToTestForm.resetFrom(params);\n// bug_end\n  myShowLogCheckBox.setSelected(params.getOutputLogLevel() != null);\n  myLogLevelCombo.setEnabled(params.getOutputLogLevel() != null);\n  myLogLevelCombo.setSelectedItem(params.getOutputLogLevel() == null ? null : params.getOutputLogLevel());\n  myRunTrustedCheckBox.setSelected(params.isTrusted());\n}\n"}
{"INPUT": "@Override protected void onInitialize(){\n  super.onInitialize();\n  BuildQuery buildQuery=Preconditions.checkNotNull(descriptor.getPropertyGetter().getAnnotation(BuildQuery.class));\n  input=new TextField<String>(\"input\",getModel());\n  input.add(new BuildQueryBehavior(new AbstractReadOnlyModel<Project>(){\n    @Override public Project getObject(){\n      if (getPage() instanceof ProjectPage)       return ((ProjectPage)getPage()).getProject();\n else       return null;\n    }\n  }\n// bug_start\n,buildQuery.withCurrentUserCriteria(),buildQuery.withUnfinishedCriteria()));\n// bug_end\n  input.setLabel(Model.of(getDescriptor().getDisplayName()));\n  add(input);\n  input.add(new OnTypingDoneBehavior(){\n    @Override protected void onTypingDone(    AjaxRequestTarget target){\n      onPropertyUpdating(target);\n    }\n  }\n);\n}\n"}
{"INPUT": "public void testEmptyIterator(){\n  final RightTupleList map=new RightTupleList();\n  final Cheese stilton1=new Cheese(\"stilton\",35);\n  final InternalFactHandle h1=new DefaultFactHandle(1,stilton1);\n// bug_start\n  assertNull(map.getFirst(new LeftTuple(h1,null,true)));\n// bug_end\n}\n"}
{"INPUT": "@Test public void fourPeers() throws Exception {\n  InboundMessageQueuer[] channels={connectPeer(1),connectPeer(2),connectPeer(3),connectPeer(4)};\n  Transaction tx=new Transaction(params);\n// bug_start\n  TransactionBroadcast broadcast=new TransactionBroadcast(peerGroup,tx);\n// bug_end\n  ListenableFuture<Transaction> future=broadcast.broadcast();\n  assertFalse(future.isDone());\n  Message[] messages={(Message)outbound(channels[0]),(Message)outbound(channels[1]),(Message)outbound(channels[2]),(Message)outbound(channels[3])};\n  assertEquals(tx,messages[0]);\n  assertEquals(tx,messages[3]);\n  assertNull(messages[1]);\n  assertNull(messages[2]);\n  Threading.waitForUserCode();\n  assertFalse(future.isDone());\n  inbound(channels[1],InventoryMessage.with(tx));\n  pingAndWait(channels[1]);\n  Threading.waitForUserCode();\n  assertTrue(future.isDone());\n}\n"}
{"INPUT": "public PackageMaterialPluginInfo(PluginDescriptor descriptor,PluggableInstanceSettings repositorySettings,PluggableInstanceSettings packageSettings,PluggableInstanceSettings pluginSettings){\n// bug_start\n  super(descriptor,PluginConstants.PACKAGE_MATERIAL_EXTENSION,pluginSettings);\n// bug_end\n  this.repositorySettings=repositorySettings;\n  this.packageSettings=packageSettings;\n}\n"}
{"INPUT": "@Override protected MultiSearchResponse shardOperation(Request request,ShardId shardId) throws IOException {\n  final IndexService indexService=indicesService.indexService(shardId.getIndex());\n  final IndexShard indexShard=indicesService.getShardOrNull(shardId);\n  try (Engine.Searcher searcher=indexShard.acquireSearcher(\"enrich_msearch\")){\n    final FieldsVisitor visitor=new FieldsVisitor(true);\n    final QueryShardContext context=indexService.newQueryShardContext(shardId.id(),searcher,null,null);\n    final MapperService mapperService=context.getMapperService();\n    final MultiSearchResponse.Item[] items=new MultiSearchResponse.Item[request.multiSearchRequest.requests().size()];\n    for (int i=0; i < request.multiSearchRequest.requests().size(); i++) {\n      final SearchSourceBuilder searchSourceBuilder=request.multiSearchRequest.requests().get(i).source();\n      final QueryBuilder queryBuilder=searchSourceBuilder.query();\n      final int from=searchSourceBuilder.from();\n      final int size=searchSourceBuilder.size();\n      final FetchSourceContext fetchSourceContext=searchSourceBuilder.fetchSource();\n      final Query luceneQuery=queryBuilder.rewrite(context).toQuery(context);\n      final int n=from + size;\n      final TopDocs topDocs=searcher.search(luceneQuery,n,new Sort(SortField.FIELD_DOC));\n      final SearchHit[] hits=new SearchHit[topDocs.scoreDocs.length];\n      for (int j=0; j < topDocs.scoreDocs.length; j++) {\n        final ScoreDoc scoreDoc=topDocs.scoreDocs[j];\n        visitor.reset();\n        searcher.doc(scoreDoc.doc,visitor);\n        visitor.postProcess(mapperService);\n// bug_start\n        final SearchHit hit=new SearchHit(scoreDoc.doc,visitor.id(),Map.of());\n// bug_end\n        hit.sourceRef(filterSource(fetchSourceContext,visitor.source()));\n        hits[j]=hit;\n      }\n      items[i]=new MultiSearchResponse.Item(createSearchResponse(topDocs,hits),null);\n    }\n    return new MultiSearchResponse(items,1L);\n  }\n }\n"}
{"INPUT": "@Test public void testSymbolLookupInBIR(){\n  CompilerContext context=new CompilerContext();\n  CompileResult result=compile(\"test-src/symbol_lookup_with_imports_test.bal\",context);\n  BLangPackage pkg=(BLangPackage)result.getAST();\n  BPackageSymbol fooPkgSymbol=pkg.imports.get(0).symbol;\n  BallerinaSemanticModel model=new BallerinaSemanticModel(pkg,context);\n  List<String> annotationModuleSymbols=asList(\"deprecated\",\"untainted\",\"tainted\",\"icon\",\"strand\",\"StrandData\",\"typeParam\",\"Thread\",\"builtinSubtype\");\n  List<String> moduleLevelSymbols=asList(\"aString\",\"anInt\",\"HELLO\",\"testAnonTypes\");\n// bug_start\n  List<String> moduleSymbols=asList(\"xml\",\"foo\",\"object\",\"error\");\n// bug_end\n  List<String> expSymbolNames=getSymbolNames(annotationModuleSymbols,moduleLevelSymbols,moduleSymbols);\n  Map<String,Symbol> symbolsInScope=model.visibleSymbols(\"symbol_lookup_with_imports_test.bal\",LinePosition.from(19,1)).stream().collect(Collectors.toMap(null,null));\n  assertList(symbolsInScope,expSymbolNames);\n  BallerinaModule fooModule=(BallerinaModule)symbolsInScope.get(\"foo\");\n  List<String> fooFunctions=getSymbolNames(fooPkgSymbol,SymTag.FUNCTION);\n  assertList(fooModule.functions(),fooFunctions);\n  List<String> fooConstants=getSymbolNames(fooPkgSymbol,SymTag.CONSTANT);\n  assertList(fooModule.constants(),fooConstants);\n  List<String> fooTypeDefs=getSymbolNames(getSymbolNames(fooPkgSymbol,SymTag.TYPE_DEF),\"FileNotFoundError\",\"EofError\",\"Digit\");\n  assertList(fooModule.typeDefinitions(),fooTypeDefs);\n  List<String> allSymbols=getSymbolNames(fooPkgSymbol,0);\n  assertList(fooModule.allSymbols(),allSymbols);\n}\n"}
{"INPUT": "private QueryStateMachine createQueryStateMachine(String query,Session session,TransactionManager transactionManager){\n// bug_start\n  return QueryStateMachine.begin(query,Optional.empty(),session,URI.create(\"fake://uri\"),new ResourceGroupId(\"test\"),true,transactionManager,new AccessControlManager(transactionManager,emptyEventListenerManager(),new AccessControlConfig()),executor,metadata,WarningCollector.NOOP);\n// bug_end\n}\n"}
{"INPUT": "private void renameFile(String newName){\n  if (TextUtils.isEmpty(newName)) {\n    ALog.w(TAG,\"\");\n    return;\n  }\n  ALog.d(TAG,String.format(\"%s\",newName));\n  File oldFile=new File(mEntity.getFilePath());\n  String newPath=oldFile.getParent() + \"/\" + newName;\n  if (oldFile.exists()) {\n    boolean b=oldFile.renameTo(new File(newPath));\n    ALog.d(TAG,String.format(\"%s\",b ? \"\" : \"\"));\n  }\n  mEntity.setFileName(newName);\n  mEntity.setFilePath(newPath);\n// bug_start\n  RecordUtil.modifyTaskRecord(oldFile.getPath(),newPath);\n// bug_end\n}\n"}
{"INPUT": "IndexWriter(long keyCount){\n  indexFile=SequentialWriter.open(new File(descriptor.filenameFor(Component.PRIMARY_INDEX)),!metadata.populateIoCacheOnFlush());\n  builder=SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());\n// bug_start\n  summary=new IndexSummaryBuilder(keyCount,metadata.getIndexInterval());\n// bug_end\n  bf=FilterFactory.getFilter(keyCount,metadata.getBloomFilterFpChance(),true);\n}\n"}
{"INPUT": "@Before public void initSchema(){\n  SchemaManager schema=graph().schema();\n  logger.info(\"===============  propertyKey  ================\");\n  schema.makePropertyKey(\"id\").asInt().create();\n  schema.makePropertyKey(\"name\").asText().create();\n  schema.makePropertyKey(\"dynamic\").asBoolean().create();\n  schema.makePropertyKey(\"time\").asText().create();\n  schema.makePropertyKey(\"timestamp\").asLong().create();\n  schema.makePropertyKey(\"age\").asInt().valueSingle().create();\n  schema.makePropertyKey(\"comment\").asText().valueSet().create();\n  schema.makePropertyKey(\"contribution\").asText().create();\n  schema.makePropertyKey(\"score\").asInt().create();\n  schema.makePropertyKey(\"lived\").asText().create();\n  schema.makePropertyKey(\"city\").asText().create();\n  logger.info(\"===============  vertexLabel  ================\");\n  VertexLabel person=schema.makeVertexLabel(\"person\").properties(\"name\",\"age\",\"city\").primaryKeys(\"name\").create();\n// bug_start\n  schema.makeVertexLabel(\"author\").properties(\"id\",\"name\").primaryKeys(\"id\").create();\n// bug_end\n  schema.makeVertexLabel(\"language\").properties(\"name\",\"dynamic\").primaryKeys(\"name\").create();\n  schema.makeVertexLabel(\"book\").properties(\"name\").primaryKeys(\"name\").create();\n  logger.info(\"===============  vertexLabel index  ================\");\n  schema.makeIndexLabel(\"personByCity\").on(person).secondary().by(\"city\").create();\n  schema.makeIndexLabel(\"personByAge\").on(person).search().by(\"age\").create();\n  logger.info(\"===============  edgeLabel  ================\");\n  EdgeLabel transfer=schema.makeEdgeLabel(\"transfer\").properties(\"id\",\"timestamp\").multiTimes().sortKeys(\"id\").link(\"person\",\"person\").create();\n  EdgeLabel authored=schema.makeEdgeLabel(\"authored\").singleTime().properties(\"contribution\",\"comment\",\"score\").link(\"author\",\"book\").create();\n  schema.makeEdgeLabel(\"look\").properties(\"time\").multiTimes().sortKeys(\"time\").link(\"author\",\"book\").link(\"person\",\"book\").create();\n  schema.makeEdgeLabel(\"friend\").singleTime().link(\"author\",\"author\").link(\"author\",\"person\").link(\"person\",\"person\").link(\"person\",\"author\").create();\n  schema.makeEdgeLabel(\"created\").singleTime().link(\"author\",\"language\").create();\n  logger.info(\"===============  edgeLabel index  ================\");\n  schema.makeIndexLabel(\"transferByTimestamp\").on(transfer).search().by(\"timestamp\").create();\n}\n"}
{"INPUT": "@Override protected void onStartLoading(){\n  mListener=new PrintManager.PrintServiceRecommendationsChangeListener(){\n    @Override public void onPrintServiceRecommendationsChanged(){\n      queueNewResult();\n    }\n  }\n;\n// bug_start\n  mPrintManager.addPrintServiceRecommendationsChangeListener(mListener);\n// bug_end\n  deliverResult(mPrintManager.getPrintServiceRecommendations());\n}\n"}
{"INPUT": "protected void updatePower(ShellyDeviceProfile profile,Map<String,State> updates,int id,CoIotDescrSen sen,CoIotSensor s,List<CoIotSensor> allUpdates){\n  String group=\"\";\n  String channel=CHANNEL_BRIGHTNESS;\n  String checkL=\"\";\n  if (profile.isLight || profile.isDimmer) {\n    if (profile.isBulb || profile.inColor) {\n      group=CHANNEL_GROUP_LIGHT_CONTROL;\n      channel=CHANNEL_LIGHT_POWER;\n    }\n else     if (profile.isDuo) {\n      group=CHANNEL_GROUP_WHITE_CONTROL;\n    }\n else     if (profile.isDimmer) {\n      group=CHANNEL_GROUP_RELAY_CONTROL;\n    }\n else     if (profile.isRGBW2) {\n      group=CHANNEL_GROUP_LIGHT_CHANNEL + id;\n      checkL=String.valueOf(id - 1);\n      logger.trace(\"{}: updatePower() for L={}\",thingName,checkL);\n    }\n    Double brightness=-1.0;\n    Double power=-1.0;\n    for (    CoIotSensor update : allUpdates) {\n// bug_start\n      CoIotDescrSen d=fixDescription(sensorMap.get(update.id),blkMap);\n// bug_end\n      if (!checkL.isEmpty() && !d.links.equals(checkL)) {\n        continue;\n      }\n      if (d.desc.equalsIgnoreCase(\"brightness\")) {\n        brightness=new Double(update.value);\n      }\n else       if (d.desc.equalsIgnoreCase(\"output\") || d.desc.equalsIgnoreCase(\"state\")) {\n        power=new Double(update.value);\n      }\n    }\n    if (power != -1) {\n      updateChannel(updates,group,channel + \"$Switch\",power == 1 ? OnOffType.ON : OnOffType.OFF);\n    }\n    if (brightness != -1) {\n      updateChannel(updates,group,channel + \"$Value\",toQuantityType(power == 1 ? brightness : 0,DIGITS_NONE,SmartHomeUnits.PERCENT));\n    }\n  }\n else   if (profile.hasRelays) {\n    group=profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL : CHANNEL_GROUP_RELAY_CONTROL + id;\n    updateChannel(updates,group,CHANNEL_OUTPUT,s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n  }\n else   if (profile.isSensor) {\n    if (profile.isDW) {\n      updateChannel(updates,CHANNEL_GROUP_SENSOR,CHANNEL_SENSOR_CONTACT,s.value != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n    }\n else {\n      updateChannel(updates,CHANNEL_GROUP_SENSOR,CHANNEL_SENSOR_CONTACT,s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n    }\n  }\n}\n"}
{"INPUT": "private ArgumentCaptor<Secret> reconcileCa(TestContext context,CertificateAuthority clusterCa,CertificateAuthority clientsCa){\n  SecretOperator secretOps=mock(SecretOperator.class);\n  when(secretOps.list(eq(NAMESPACE),any())).thenAnswer(null);\n  ArgumentCaptor<Secret> c=ArgumentCaptor.forClass(Secret.class);\n  when(secretOps.reconcile(eq(NAMESPACE),eq(AbstractModel.clusterCaCertSecretName(NAME)),c.capture())).thenAnswer(null);\n  when(secretOps.reconcile(eq(NAMESPACE),eq(AbstractModel.clusterCaKeySecretName(NAME)),c.capture())).thenAnswer(null);\n  when(secretOps.reconcile(eq(NAMESPACE),eq(KafkaCluster.clientsCaCertSecretName(NAME)),c.capture())).thenAnswer(null);\n  when(secretOps.reconcile(eq(NAMESPACE),eq(KafkaCluster.clientsCaKeySecretName(NAME)),c.capture())).thenAnswer(null);\n// bug_start\n  KafkaAssemblyOperator op=new KafkaAssemblyOperator(vertx,new PlatformFeaturesAvailability(false,KubernetesVersion.V1_9),certManager,new ResourceOperatorSupplier(null,null,null,null,null,secretOps,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null),ResourceUtils.dummyClusterOperatorConfig(1L));\n// bug_end\n  Reconciliation reconciliation=new Reconciliation(\"test-trigger\",ResourceType.KAFKA,NAMESPACE,NAME);\n  Kafka kafka=new KafkaBuilder().editOrNewMetadata().withName(NAME).withNamespace(NAMESPACE).endMetadata().withNewSpec().withClusterCa(clusterCa).withClientsCa(clientsCa).endSpec().build();\n  AtomicReference<Throwable> error=new AtomicReference<>();\n  Async async=context.async();\n  op.new ReconciliationState(reconciliation,kafka).reconcileCas().setHandler(null);\n  async.await();\n  if (error.get() != null) {\n    Throwable t=error.get();\n    if (t instanceof RuntimeException) {\n      throw (RuntimeException)t;\n    }\n else     if (t instanceof Error) {\n      throw (Error)t;\n    }\n else {\n      throw new RuntimeException(t);\n    }\n  }\n  return c;\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") protected <T>T castTimestamp(DefaultJSONParser parser,Type clazz,Object fieldName,Object val){\n  if (val == null) {\n    return null;\n  }\n  if (val instanceof java.util.Date) {\n    return (T)new java.sql.Timestamp(((Date)val).getTime());\n  }\n  if (val instanceof Number) {\n    return (T)new java.sql.Timestamp(((Number)val).longValue());\n  }\n  if (val instanceof String) {\n    String strVal=(String)val;\n    if (strVal.length() == 0) {\n      return null;\n    }\n    long longVal;\n    JSONScanner dateLexer=new JSONScanner(strVal);\n    try {\n// bug_start\n      if (dateLexer.scanISO8601DateIfMatch()) {\n// bug_end\n        longVal=dateLexer.getCalendar().getTimeInMillis();\n      }\n else {\n        DateFormat dateFormat=parser.getDateFormat();\n        try {\n          java.util.Date date=(java.util.Date)dateFormat.parse(strVal);\n          java.sql.Timestamp sqlDate=new java.sql.Timestamp(date.getTime());\n          return (T)sqlDate;\n        }\n catch (        ParseException e) {\n        }\n        longVal=Long.parseLong(strVal);\n      }\n    }\n  finally {\n      dateLexer.close();\n    }\n    return (T)new java.sql.Timestamp(longVal);\n  }\n  throw new JSONException(\"parse error\");\n}\n"}
{"INPUT": "@Override protected void onCreate(@Nullable Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_debug_playable);\n  ButterKnife.bind(this);\n  inflater=LayoutInflater.from(this);\n  playable=(Playable)getLastCustomNonConfigurationInstance();\n  if (playable == null) {\n// bug_start\n    playable=DemoApp.Companion.getExoCreator().createPlayable(video);\n// bug_end\n    playable.prepare(true);\n  }\n  playable.setPlayerView(playerView);\n  buttonBar.removeAllViews();\n  addButton(inflater,buttonBar,R.layout.widget_debug_button,\"Play\",null);\n  addButton(inflater,buttonBar,R.layout.widget_debug_button,\"Pause\",null);\n  addButton(inflater,buttonBar,R.layout.widget_debug_button,\"Reset\",null);\n  addButton(inflater,buttonBar,R.layout.widget_debug_button,\"Release\",null);\n  addButton(inflater,buttonBar,R.layout.widget_debug_button,\"Resize mode\",null);\n  addButton(inflater,buttonBar,R.layout.widget_debug_button,\"Mute\",null);\n  addButton(inflater,buttonBar,R.layout.widget_debug_button,\"UnMute\",null);\n  changeResizeMode();\n}\n"}
{"INPUT": "@Test(groups=\"slow\",enabled=false) public void testTransitonAccountBAToSubscriptionBA() throws Exception {\n  final Account account=createAccountWithNonOsgiPaymentMethod(getAccountData(1));\n  clock.setDay(new LocalDate(2012,4,1));\n  final DefaultEntitlement bpEntitlement=createBaseEntitlementAndCheckForCompletion(account.getId(),\"externalKey\",\"Shotgun\",ProductCategory.BASE,BillingPeriod.MONTHLY,NextEvent.CREATE,NextEvent.INVOICE);\n  assertNotNull(bpEntitlement);\n  invoiceChecker.checkInvoice(account.getId(),1,callContext,new ExpectedInvoiceItemCheck(new LocalDate(2012,4,1),null,InvoiceItemType.FIXED,new BigDecimal(\"0\")));\n// bug_start\n  addDaysAndCheckForCompletion(33,NextEvent.PHASE,NextEvent.INVOICE,NextEvent.PAYMENT);\n// bug_end\n  changeEntitlementAndCheckForCompletion(bpEntitlement,\"Shotgun\",BillingPeriod.ANNUAL,null,NextEvent.CHANGE,NextEvent.INVOICE);\n}\n"}
{"INPUT": "private static void checkJarFile(URL jarfile) throws ProgramInvocationException {\n  try {\n    JobWithJars.checkJarFile(jarfile);\n  }\n catch (  IOException e) {\n// bug_start\n    throw new ProgramInvocationException(e.getMessage());\n// bug_end\n  }\ncatch (  Throwable t) {\n    throw new ProgramInvocationException(\"Cannot access jar file\" + (t.getMessage() == null ? \".\" : \": \" + t.getMessage()),t);\n  }\n}\n"}
{"INPUT": "@Override public FormDeploymentBuilder addInputStream(String resourceName,InputStream inputStream){\n  if (inputStream == null) {\n    throw new FlowableException(\"inputStream for resource '\" + resourceName + \"' is null\");\n  }\n  byte[] bytes=null;\n  try {\n    bytes=IOUtils.toByteArray(inputStream);\n  }\n catch (  Exception e) {\n// bug_start\n    throw new FlowableException(\"could not get byte array from resource '\" + resourceName + \"'\");\n// bug_end\n  }\n  if (bytes == null) {\n    throw new FlowableException(\"byte array for resource '\" + resourceName + \"' is null\");\n  }\n  FormResourceEntity resource=resourceEntityManager.create();\n  resource.setName(resourceName);\n  resource.setBytes(bytes);\n  deployment.addResource(resource);\n  return this;\n}\n"}
{"INPUT": "private Map<?,?> renderView() throws Exception {\n  final ModelAndView modelAndView=this.getModelAndViewUponServiceValidationWithSecurePgtUrl();\n  final MockHttpServletRequest req=new MockHttpServletRequest(new MockServletContext());\n  req.setAttribute(RequestContext.WEB_APPLICATION_CONTEXT_ATTRIBUTE,new GenericWebApplicationContext(req.getServletContext()));\n// bug_start\n  final Cas30ResponseView view=new Cas30ResponseView();\n// bug_end\n  view.setServicesManager(this.servicesManager);\n  view.setCasAttributeEncoder(new DefaultCasAttributeEncoder(this.servicesManager));\n  view.setView(new View(){\n    @Override public String getContentType(){\n      return \"text/html\";\n    }\n    @Override public void render(    final Map<String,?> map,    final HttpServletRequest request,    final HttpServletResponse response) throws Exception {\n      map.forEach(null);\n    }\n  }\n);\n  final MockHttpServletResponse resp=new MockHttpServletResponse();\n  view.render(modelAndView.getModel(),req,resp);\n  return (Map<?,?>)req.getAttribute(CasProtocolConstants.VALIDATION_CAS_MODEL_ATTRIBUTE_NAME_ATTRIBUTES);\n}\n"}
{"INPUT": "@BeforeAll public static void createClientAndEventLoopGroup(){\n  clientEventLoopGroup=new NioEventLoopGroup(3,new Scheduler.SchedulerThreadFactory(AbstractMockingIntegrationTestBase.class.getSimpleName() + \"-eventLoop\"));\n// bug_start\n  httpClient=new NettyHttpClient(new MockServerLogger(),clientEventLoopGroup,null,false);\n// bug_end\n}\n"}
{"INPUT": "@Override public ExitCode runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {\n  final ImmutableSet<String> fullyQualifiedBuildTargets=ImmutableSet.copyOf(getArgumentsFormattedAsBuildTargets(params.getBuckConfig()));\n  if (fullyQualifiedBuildTargets.isEmpty()) {\n    throw new CommandLineException(\"must specify at least one build target\");\n  }\n  if (params.getConsole().getAnsi().isAnsiTerminal()) {\n    params.getBuckEventBus().post(ConsoleEvent.info(\"'buck audit tests' is deprecated. Please use 'buck query' instead. e.g.\\n\\t%s\\n\\n\" + \"The query language is documented at https://buckbuild.com/command/query.html\",QueryCommand.buildAuditTestsQueryExpression(getArguments(),shouldGenerateJsonOutput())));\n  }\n// bug_start\n  try (CommandThreadManager pool=new CommandThreadManager(\"Audit\",getConcurrencyLimit(params.getBuckConfig()));PerBuildState parserState=new PerBuildState(params.getParser(),params.getBuckEventBus(),pool.getListeningExecutorService(),params.getCell(),params.getKnownBuildRuleTypesProvider(),getEnableParserProfiling(),PerBuildState.SpeculativeParsing.ENABLED)){\n// bug_end\n    BuckQueryEnvironment env=BuckQueryEnvironment.from(params,parserState,pool.getListeningExecutorService(),getEnableParserProfiling());\n    return QueryCommand.runMultipleQuery(params,env,\"testsof('%s')\",getArgumentsFormattedAsBuildTargets(params.getBuckConfig()),shouldGenerateJsonOutput());\n  }\n catch (  Exception e) {\n    if (e.getCause() instanceof InterruptedException) {\n      throw (InterruptedException)e.getCause();\n    }\n    params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));\n    return ExitCode.BUILD_ERROR;\n  }\n}\n"}
{"INPUT": "private void addMethodArguments(CodeWriter code,List<RegisterArg> args){\n  MethodParameters paramsAnnotation=mth.get(AType.ANNOTATION_MTH_PARAMETERS);\n  int i=0;\n  Iterator<RegisterArg> it=args.iterator();\n  while (it.hasNext()) {\n    RegisterArg mthArg=it.next();\n    SSAVar ssaVar=mthArg.getSVar();\n    CodeVar var;\n    if (ssaVar == null) {\n// bug_start\n      var=CodeVar.fromMthArg(mthArg);\n// bug_end\n    }\n else {\n      var=ssaVar.getCodeVar();\n    }\n    if (paramsAnnotation != null) {\n      annotationGen.addForParameter(code,paramsAnnotation,i);\n    }\n    if (var.isFinal()) {\n      code.add(\"final \");\n    }\n    ArgType argType;\n    ArgType varType=var.getType();\n    if (varType == null || varType == ArgType.UNKNOWN) {\n      argType=mthArg.getInitType();\n    }\n else {\n      argType=varType;\n    }\n    if (!it.hasNext() && mth.getAccessFlags().isVarArgs()) {\n      if (argType.isArray()) {\n        ArgType elType=argType.getArrayElement();\n        classGen.useType(code,elType);\n        code.add(\"...\");\n      }\n else {\n        mth.addComment(\"JADX INFO: Last argument in varargs method is not array: \" + var);\n        classGen.useType(code,argType);\n      }\n    }\n else {\n      classGen.useType(code,argType);\n    }\n    code.add(' ');\n    code.add(nameGen.assignArg(var));\n    i++;\n    if (it.hasNext()) {\n      code.add(\", \");\n    }\n  }\n}\n"}
{"INPUT": "public void test_bigdecimal() throws Exception {\n  Assert.assertEquals(0,JSON.parseObject(\"0\",Long.class).intValue());\n  Assert.assertEquals(0,JSON.parseObject(\"0.0\",Long.class).intValue());\n  Assert.assertEquals(0,JSON.parseObject(\"'0'\",Long.class).intValue());\n  Assert.assertEquals(null,JSON.parseObject(\"null\",Long.class));\n  DefaultExtJSONParser parser=new DefaultExtJSONParser(\"null\",ParserConfig.getGlobalInstance(),JSON.DEFAULT_PARSER_FEATURE);\n// bug_start\n  Assert.assertEquals(null,LongDeserializer.instance.deserialze(parser,null));\n// bug_end\n  Assert.assertEquals(JSONToken.LITERAL_INT,LongDeserializer.instance.getFastMatchToken());\n}\n"}
{"INPUT": "public Appenderator newAppenderator(FireDepartmentMetrics metrics,TaskToolbox toolbox){\n// bug_start\n  return appenderatorsManager.createRealtimeAppenderatorForTask(getId(),dataSchema,tuningConfig.withBasePersistDirectory(toolbox.getPersistDir()),metrics,toolbox.getSegmentPusher(),toolbox.getJsonMapper(),toolbox.getIndexIO(),toolbox.getIndexMergerV9(),toolbox.getQueryRunnerFactoryConglomerate(),toolbox.getSegmentAnnouncer(),toolbox.getEmitter(),toolbox.getQueryExecutorService(),toolbox.getCache(),toolbox.getCacheConfig(),toolbox.getCachePopulatorStats());\n// bug_end\n}\n"}
{"INPUT": "@Before public void setUp() throws Exception {\n  super.setUp();\n  Settings settings=Settings.builder().put(NODE_NAME_SETTING.getKey(),\"node\").build();\n  taskQueue=new DeterministicTaskQueue(settings,random());\n// bug_start\n  Set<Setting<?>> registeredSettings=Sets.newHashSet(CcrSettings.INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING,CcrSettings.RECOVERY_MAX_BYTES_PER_SECOND,CcrSettings.INDICES_RECOVERY_ACTION_TIMEOUT_SETTING);\n// bug_end\n  ClusterSettings clusterSettings=new ClusterSettings(Settings.EMPTY,registeredSettings);\n  restoreSourceService=new CcrRestoreSourceService(taskQueue.getThreadPool(),new CcrSettings(Settings.EMPTY,clusterSettings));\n}\n"}
{"INPUT": "@Override public CppCompileActionResult execWithReply(CppCompileAction action,ActionExecutionContext actionExecutionContext) throws ExecException, InterruptedException {\n  Iterable<Artifact> inputs=Iterables.concat(action.getMandatoryInputs(),action.getAdditionalInputs());\n// bug_start\n  Spawn spawn=new SimpleSpawn(action,ImmutableList.copyOf(action.getArguments()),ImmutableMap.copyOf(action.getEnvironment()),ImmutableMap.copyOf(action.getExecutionInfo()),EmptyRunfilesSupplier.INSTANCE,ImmutableMap.of(),ImmutableList.copyOf(inputs),ImmutableList.of(),action.getOutputs().asList(),action.estimateResourceConsumptionLocal());\n// bug_end\n  List<SpawnResult> spawnResults=actionExecutionContext.getSpawnActionContext(spawn).exec(spawn,actionExecutionContext);\n  return CppCompileActionResult.builder().setSpawnResults(spawnResults).build();\n}\n"}
{"INPUT": "public void initialize(){\n  try {\n    int api=1;\n// bug_start\n    this.dexFile=DexFileFactory.loadDexFile(inputDexFile,api);\n// bug_end\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e.toString());\n  }\n  if (dexFile instanceof DexBackedDexFile) {\n    DexBackedDexFile dbdf=(DexBackedDexFile)dexFile;\n    for (int i=0; i < dbdf.getTypeCount(); i++) {\n      String t=dbdf.getType(i);\n      Type st=DexType.toSoot(t);\n      if (st instanceof ArrayType) {\n        st=((ArrayType)st).baseType;\n      }\n      Debug.printDbg(\"Type: \",t,\" soot type:\",st);\n      String sootTypeName=st.toString();\n      if (!Scene.v().containsClass(sootTypeName)) {\n        if (st instanceof PrimType || st instanceof VoidType || systemAnnotationNames.contains(sootTypeName)) {\n          continue;\n        }\n        SootResolver.v().makeClassRef(sootTypeName);\n      }\n      SootResolver.v().resolveClass(sootTypeName,SootClass.SIGNATURES);\n    }\n  }\n else {\n    System.out.println(\"Warning: DexFile not instance of DexBackedDexFile! Not resolving types!\");\n    System.out.println(\"type: \" + dexFile.getClass());\n  }\n}\n"}
{"INPUT": "@Test public void ifWithoutElse_False() throws JoranException {\n  tc.doConfigure(CONDITIONAL_DIR_PREFIX + \"ifWithoutElse.xml\");\n  verifyConfig(new String[]{\"BEGIN\",\"END\"});\n  StatusChecker checker=new StatusChecker(context);\n// bug_start\n  assertTrue(checker.isErrorFree());\n// bug_end\n}\n"}
{"INPUT": "private void assertSimpleNamespaceExists(String name){\n  SymbolTable symbolTable=program.getSymbolTable();\n  Namespace ns=symbolTable.getNamespace(name,program.getGlobalNamespace());\n// bug_start\n  assertNotNull(ns);\n// bug_end\n  assertEquals(SymbolType.NAMESPACE,ns.getSymbol().getSymbolType());\n}\n"}
{"INPUT": "@Override protected Request createTestInstance(){\n  Request request=new Request();\n  if (randomBoolean()) {\n    request.indices(generateRandomStringArray(20,20,false));\n  }\n  if (randomBoolean()) {\n// bug_start\n    IndicesOptions indicesOptions=IndicesOptions.fromOptions(randomBoolean(),randomBoolean(),randomBoolean(),randomBoolean(),randomBoolean(),randomBoolean(),randomBoolean());\n// bug_end\n    request.indicesOptions(indicesOptions);\n  }\n  return request;\n}\n"}
{"INPUT": "@Bean public BeanPostProcessor SqlTermCustomerRegister(){\n// bug_start\n  List<Dialect> dialects=Arrays.asList(Dialect.H2,Dialect.MYSQL,Dialect.ORACLE,Dialect.MSSQL);\n// bug_end\n  return new BeanPostProcessor(){\n    @Override public Object postProcessBeforeInitialization(    Object bean,    String beanName) throws BeansException {\n      return bean;\n    }\n    @Override public Object postProcessAfterInitialization(    Object bean,    String beanName) throws BeansException {\n      if (bean instanceof SqlTermCustomer) {\n        SqlTermCustomer customer=((SqlTermCustomer)bean);\n        if (customer.forDialect() != null) {\n          for (          Dialect dialect : customer.forDialect()) {\n            dialect.setTermTypeMapper(customer.getTermType(),customer);\n          }\n        }\n else {\n          dialects.forEach(null);\n        }\n      }\n      return bean;\n    }\n  }\n;\n}\n"}
{"INPUT": "private ParameterMapping buildParameterMapping(String content){\n  Map<String,String> propertiesMap=parseParameterMapping(content);\n  String property=propertiesMap.get(\"property\");\n  String jdbcType=propertiesMap.get(\"jdbcType\");\n  Class<?> propertyType;\n  if (typeHandlerRegistry.hasTypeHandler(parameterType)) {\n    propertyType=parameterType;\n  }\n else   if (JdbcType.CURSOR.name().equals(jdbcType)) {\n    propertyType=java.sql.ResultSet.class;\n  }\n else   if (property != null) {\n// bug_start\n    MetaClass metaClass=MetaClass.forClass(parameterType);\n// bug_end\n    if (metaClass.hasGetter(property)) {\n      propertyType=metaClass.getGetterType(property);\n    }\n else {\n      propertyType=Object.class;\n    }\n  }\n else {\n    propertyType=Object.class;\n  }\n  ParameterMapping.Builder builder=new ParameterMapping.Builder(configuration,property,propertyType);\n  if (jdbcType != null) {\n    builder.jdbcType(resolveJdbcType(jdbcType));\n  }\n  Class<?> javaType=null;\n  String typeHandlerAlias=null;\n  for (  Map.Entry<String,String> entry : propertiesMap.entrySet()) {\n    String name=entry.getKey();\n    String value=entry.getValue();\n    if (\"javaType\".equals(name)) {\n      javaType=resolveClass(value);\n      builder.javaType(javaType);\n    }\n else     if (\"jdbcType\".equals(name)) {\n      builder.jdbcType(resolveJdbcType(value));\n    }\n else     if (\"mode\".equals(name)) {\n      builder.mode(resolveParameterMode(value));\n    }\n else     if (\"numericScale\".equals(name)) {\n      builder.numericScale(Integer.valueOf(value));\n    }\n else     if (\"resultMap\".equals(name)) {\n      builder.resultMapId(value);\n    }\n else     if (\"typeHandler\".equals(name)) {\n      typeHandlerAlias=value;\n    }\n else     if (\"jdbcTypeName\".equals(name)) {\n      builder.jdbcTypeName(value);\n    }\n else     if (\"property\".equals(name)) {\n    }\n else     if (\"expression\".equals(name)) {\n      builder.expression(value);\n    }\n else {\n      throw new BuilderException(\"An invalid property '\" + name + \"' was found in mapping @{\"+ content+ \"}.  Valid properties are \"+ parameterProperties);\n    }\n  }\n  if (typeHandlerAlias != null) {\n    builder.typeHandler(resolveTypeHandler(javaType,typeHandlerAlias));\n  }\n  return builder.build();\n}\n"}
{"INPUT": "public void initListeners(){\n// bug_start\n  schemaChangedListener.watch(ChangedType.UPDATED,ChangedType.DELETED);\n// bug_end\n  propertiesChangedListener.watch(ChangedType.UPDATED);\n  authenticationChangedListener.watch(ChangedType.UPDATED);\n  metricsConfigurationChangedListener.watch(ChangedType.UPDATED);\n  clusterConfigurationChangedListener.watch(ChangedType.UPDATED);\n}\n"}
{"INPUT": "private void putBinding(BindingImpl<?> binding){\n  Key<?> key=binding.getKey();\n  Class<?> rawType=key.getTypeLiteral().getRawType();\n  if (FORBIDDEN_TYPES.contains(rawType)) {\n    errors.cannotBindToGuiceType(rawType.getSimpleName());\n    return;\n  }\n  BindingImpl<?> original=injector.state.getExplicitBinding(key);\n  if (original != null) {\n    try {\n      if (!isOkayDuplicate(original,binding,injector.state)) {\n        errors.bindingAlreadySet(key,original.getSource());\n        return;\n      }\n    }\n catch (    Throwable t) {\n      errors.errorCheckingDuplicateBinding(key,original.getSource(),t);\n      return;\n    }\n  }\n// bug_start\n  injector.state.parent().blacklist(key);\n// bug_end\n  injector.state.putBinding(key,binding);\n}\n"}
{"INPUT": "@Override public StorageDirView allocateBlockWithView(long sessionId,long blockSize,BlockStoreLocation location,BlockMetadataManagerView view){\n// bug_start\n  mManagerView=Preconditions.checkNotNull(view);\n// bug_end\n  return allocateBlock(sessionId,blockSize,location);\n}\n"}
{"INPUT": "protected UidFieldMapper(String name,String indexName,Boolean docValues,PostingsFormatProvider postingsFormat,DocValuesFormatProvider docValuesFormat,@Nullable Settings fieldDataSettings,Settings indexSettings){\n// bug_start\n  super(new Names(name,indexName,indexName,name),Defaults.BOOST,new FieldType(Defaults.FIELD_TYPE),docValues,Lucene.KEYWORD_ANALYZER,Lucene.KEYWORD_ANALYZER,postingsFormat,docValuesFormat,null,fieldDataSettings,indexSettings);\n// bug_end\n}\n"}
{"INPUT": "@Test public void should_fail_if_size_of_actual_is_not_equal_to_expected_size(){\n  AssertionInfo info=someInfo();\n  String[] other=array(\"Solo\",\"Leia\");\n  try {\n    arrays.assertHasSameSizeAs(info,actual,other);\n  }\n catch (  AssertionError e) {\n// bug_start\n    assertThat(e).hasMessage(shouldHaveSameSizeAs(actual,actual.length,other.length).create(null));\n// bug_end\n    return;\n  }\n  failBecauseExpectedAssertionErrorWasNotThrown();\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n  List<FlashedToken> flashedTokens=generateTokens(100,\"Grow\",2);\n// bug_start\n  DBManager dbManager=new DBManager(\"db-test.properties\",new BlockingIOProcessor(1,100,null));\n// bug_end\n  dbManager.insertFlashedTokens(flashedTokens);\n  for (  FlashedToken token : flashedTokens) {\n    Path path=Paths.get(\"/home/doom369/Downloads/grow\",token.token + \"_\" + token.deviceId+ \".jpg\");\n    generateQR(token.token,path);\n  }\n}\n"}
{"INPUT": "@Inject public TransportShardBulkAction(Settings settings,TransportService transportService,ClusterService clusterService,IndicesService indicesService,ThreadPool threadPool,ShardStateAction shardStateAction,MappingUpdatedAction mappingUpdatedAction,UpdateHelper updateHelper,ActionFilters actionFilters,IndexNameExpressionResolver indexNameExpressionResolver){\n// bug_start\n  super(settings,ACTION_NAME,transportService,clusterService,indicesService,threadPool,shardStateAction,actionFilters,indexNameExpressionResolver,null,null,ThreadPool.Names.WRITE);\n// bug_end\n  this.threadPool=threadPool;\n  this.updateHelper=updateHelper;\n  this.mappingUpdatedAction=mappingUpdatedAction;\n}\n"}
{"INPUT": "@Override protected void doStart() throws Exception {\n  super.doStart();\n  if (clientConfig == null) {\n    clientConfig=new XmlRpcClientConfigImpl();\n  }\n  Map<String,Object> params=new HashMap<String,Object>();\n// bug_start\n  IntrospectionSupport.getProperties(configuration,params,null);\n// bug_end\n  setProperties(clientConfig,params);\n}\n"}
{"INPUT": "public void testOutOfMemoryErrorWhileMergingIsRethrownAndIsUncaught() throws IOException, InterruptedException {\n  engine.close();\n  final AtomicReference<Throwable> maybeFatal=new AtomicReference<>();\n  final CountDownLatch latch=new CountDownLatch(1);\n  final Thread.UncaughtExceptionHandler uncaughtExceptionHandler=Thread.getDefaultUncaughtExceptionHandler();\n  try {\n    Thread.setDefaultUncaughtExceptionHandler(null);\n    final AtomicReference<List<SegmentCommitInfo>> segmentsReference=new AtomicReference<>();\n// bug_start\n    try (Engine e=createEngine(defaultSettings,store,primaryTranslogDir,newMergePolicy(),null,null)){\n// bug_end\n      final ParsedDocument doc1=testParsedDocument(\"1\",null,testDocumentWithTextField(),B_1,null);\n      e.index(indexForDoc(doc1));\n      e.flush();\n      final List<SegmentCommitInfo> segments=StreamSupport.stream(e.getLastCommittedSegmentInfos().spliterator(),false).collect(Collectors.toList());\n      segmentsReference.set(segments);\n      e.forceMerge(randomBoolean(),0,false,false,false);\n      latch.await();\n      assertNotNull(maybeFatal.get());\n      assertThat(maybeFatal.get(),instanceOf(OutOfMemoryError.class));\n      assertThat(maybeFatal.get(),hasToString(containsString(\"640K ought to be enough for anybody\")));\n    }\n   }\n  finally {\n    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);\n  }\n}\n"}
{"INPUT": "private static PackageRollbackInfo newPkgInfoFor(String packageName,long fromVersion,long toVersion,boolean isApex){\n// bug_start\n  return new PackageRollbackInfo(new VersionedPackage(packageName,fromVersion),new VersionedPackage(packageName,toVersion),new IntArray(),new ArrayList<>(),isApex,new IntArray(),new SparseLongArray());\n// bug_end\n}\n"}
{"INPUT": "@Override public void readDesign(Element design,DesignContext designContext){\n  super.readDesign(design,designContext);\n  if (design.hasAttr(\"value\") && !design.attr(\"value\").isEmpty()) {\n// bug_start\n    setValue(DesignAttributeHandler.readAttribute(\"value\",design.attributes(),Float.class));\n// bug_end\n  }\n}\n"}
{"INPUT": "public void testAssertNoInFlightContext(){\n  final long nowInMillis=randomNonNegativeLong();\n// bug_start\n  SearchContext s=new TestSearchContext(new QueryShardContext(0,new IndexSettings(EMPTY_INDEX_METADATA,Settings.EMPTY),BigArrays.NON_RECYCLING_INSTANCE,null,null,null,null,null,xContentRegistry(),writableRegistry(),null,null,null,null)){\n// bug_end\n    @Override public SearchShardTarget shardTarget(){\n      return new SearchShardTarget(\"node\",new ShardId(\"idx\",\"ignored\",0),null,OriginalIndices.NONE);\n    }\n    @Override public SearchType searchType(){\n      return SearchType.DEFAULT;\n    }\n    @Override public Query query(){\n      return Queries.newMatchAllQuery();\n    }\n  }\n;\n  MockSearchService.addActiveContext(s);\n  try {\n    Throwable e=expectThrows(AssertionError.class,null);\n    assertEquals(\"There are still [1] in-flight contexts. The first one's creation site is listed as the cause of this exception.\",e.getMessage());\n    e=e.getCause();\n    assertEquals(\"[node][idx][0] query=[*:*]\",e.getMessage());\n    assertEquals(MockSearchService.class.getName(),e.getStackTrace()[0].getClassName());\n    assertEquals(MockSearchServiceTests.class.getName(),e.getStackTrace()[1].getClassName());\n  }\n  finally {\n    MockSearchService.removeActiveContext(s);\n  }\n}\n"}
{"INPUT": "@VisibleForTesting NetworkControllerImpl(Context context,ConnectivityManager connectivityManager,TelephonyManager telephonyManager,WifiManager wifiManager,SubscriptionManager subManager,Config config,Looper bgLooper,CallbackHandler callbackHandler,AccessPointControllerImpl accessPointController,DataUsageController dataUsageController,SubscriptionDefaults defaultsHandler,DeviceProvisionedController deviceProvisionedController){\n  mContext=context;\n  mConfig=config;\n  mReceiverHandler=new Handler(bgLooper);\n  mCallbackHandler=callbackHandler;\n  mDataSaverController=new DataSaverControllerImpl(context);\n  mSubscriptionManager=subManager;\n  mSubDefaults=defaultsHandler;\n  mConnectivityManager=connectivityManager;\n  mHasMobileDataFeature=mConnectivityManager.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);\n  mPhone=telephonyManager;\n  mWifiManager=wifiManager;\n  mLocale=mContext.getResources().getConfiguration().locale;\n  mAccessPoints=accessPointController;\n  mDataUsageController=dataUsageController;\n  mDataUsageController.setNetworkController(this);\n  mDataUsageController.setCallback(new DataUsageController.Callback(){\n    @Override public void onMobileDataEnabled(    boolean enabled){\n      mCallbackHandler.setMobileDataEnabled(enabled);\n    }\n  }\n);\n// bug_start\n  mWifiSignalController=new WifiSignalController(mContext,mHasMobileDataFeature,mCallbackHandler,this);\n// bug_end\n  mEthernetSignalController=new EthernetSignalController(mContext,mCallbackHandler,this);\n  updateAirplaneMode(true);\n  mUserTracker=new CurrentUserTracker(mContext){\n    @Override public void onUserSwitched(    int newUserId){\n      NetworkControllerImpl.this.onUserSwitched(newUserId);\n    }\n  }\n;\n  mUserTracker.startTracking();\n  deviceProvisionedController.addCallback(new DeviceProvisionedListener(){\n    @Override public void onUserSetupChanged(){\n      setUserSetupComplete(deviceProvisionedController.isUserSetup(deviceProvisionedController.getCurrentUser()));\n    }\n  }\n);\n}\n"}
{"INPUT": "public HardwareServer(Holder holder){\n// bug_start\n  super(holder.props.getIntProperty(\"hardware.default.port\"),holder.transportTypeHolder);\n// bug_end\n  final int hardTimeoutSecs=holder.props.getIntProperty(\"hard.socket.idle.timeout\",0);\n  final HardwareLoginHandler hardwareLoginHandler=new HardwareLoginHandler(holder,port);\n  final HardwareChannelStateHandler hardwareChannelStateHandler=new HardwareChannelStateHandler(holder.sessionDao,holder.gcmWrapper);\n  final AlreadyLoggedHandler alreadyLoggedHandler=new AlreadyLoggedHandler();\n  channelInitializer=new ChannelInitializer<SocketChannel>(){\n    @Override protected void initChannel(    SocketChannel ch) throws Exception {\n      final ChannelPipeline pipeline=ch.pipeline();\n      if (hardTimeoutSecs > 0) {\n        pipeline.addLast(\"H_ReadTimeout\",new ReadTimeoutHandler(hardTimeoutSecs));\n      }\n      pipeline.addLast(\"H_ChannelState\",hardwareChannelStateHandler);\n      pipeline.addLast(\"H_MessageDecoder\",new MessageDecoder(holder.stats));\n      pipeline.addLast(\"H_MessageEncoder\",new MessageEncoder(holder.stats));\n      pipeline.addLast(\"H_Login\",hardwareLoginHandler);\n      pipeline.addLast(\"H_NotLogged\",new HardwareNotLoggedHandler());\n      pipeline.addLast(\"H_AlreadyLogged\",alreadyLoggedHandler);\n    }\n  }\n;\n  log.debug(\"hard.socket.idle.timeout = {}\",hardTimeoutSecs);\n}\n"}
{"INPUT": "@NonNull @Override public Result doWork(){\n  OneTimeWorkRequest newRequest=new OneTimeWorkRequest.Builder(RecursiveWorker.class).addTag(TAG).setInitialDelay(100,TimeUnit.MILLISECONDS).build();\n// bug_start\n  WorkManager.getInstance().enqueue(newRequest);\n// bug_end\n  return Result.success();\n}\n"}
{"INPUT": "protected void processMessage(final @NotNull VirtualFile file,final @NotNull AnalysisError analysisError,final @NotNull GlobalInspectionContext globalContext,final @NotNull InspectionManager manager,final @NotNull ProblemDescriptionsProcessor problemDescriptionsProcessor){\n// bug_start\n  if (DartServerErrorsAnnotator.shouldIgnoreMessageFromDartAnalyzer(analysisError))   return;\n// bug_end\n  final PsiFile psiFile=PsiManager.getInstance(globalContext.getProject()).findFile(file);\n  if (psiFile == null)   return;\n  final ProblemDescriptor descriptor=computeProblemDescriptor(manager,psiFile,analysisError);\n  problemDescriptionsProcessor.addProblemElement(globalContext.getRefManager().getReference(psiFile),descriptor);\n}\n"}
{"INPUT": "public long transferTo(WritableByteChannel ch) throws IOException {\n// bug_start\n  long localWrittenBytes=file.transferTo(ch);\n// bug_end\n  writtenBytes+=localWrittenBytes;\n  return localWrittenBytes;\n}\n"}
{"INPUT": "private <T>BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key,Errors errors,boolean jitDisabled,JitLimitation jitType) throws ErrorsException {\n  if (parent != null) {\n    try {\n      return parent.createJustInTimeBindingRecursive(key,new Errors(),jitDisabled,parent.options.jitDisabled ? JitLimitation.NO_JIT : jitType);\n    }\n catch (    ErrorsException ignored) {\n    }\n  }\n  if (state.isBlacklisted(key)) {\n    Set<Object> sources=state.getSourcesForBlacklistedKey(key);\n    throw errors.childBindingAlreadySet(key,sources).toException();\n  }\n  BindingImpl<T> binding=createJustInTimeBinding(key,errors,jitDisabled,jitType);\n// bug_start\n  state.parent().blacklist(key,binding.getSource());\n// bug_end\n  jitBindings.put(key,binding);\n  return binding;\n}\n"}
{"INPUT": "public void testCustomThreadPool() throws Exception {\n  ThreadPool threadPool=null;\n  try {\n    final ScalingExecutorBuilder scaling=new ScalingExecutorBuilder(\"my_pool1\",1,EsExecutors.numberOfProcessors(Settings.EMPTY),TimeValue.timeValueMinutes(1));\n// bug_start\n    final FixedExecutorBuilder fixed=new FixedExecutorBuilder(Settings.EMPTY,\"my_pool2\",1,1);\n// bug_end\n    threadPool=new ThreadPool(Settings.builder().put(\"node.name\",\"testCustomThreadPool\").build(),scaling,fixed);\n    ThreadPoolInfo groups=threadPool.info();\n    boolean foundPool1=false;\n    boolean foundPool2=false;\n    outer:     for (    ThreadPool.Info info : groups) {\n      if (\"my_pool1\".equals(info.getName())) {\n        foundPool1=true;\n        assertEquals(info.getThreadPoolType(),ThreadPool.ThreadPoolType.SCALING);\n      }\n else       if (\"my_pool2\".equals(info.getName())) {\n        foundPool2=true;\n        assertEquals(info.getThreadPoolType(),ThreadPool.ThreadPoolType.FIXED);\n        assertThat(info.getMin(),equalTo(1));\n        assertThat(info.getMax(),equalTo(1));\n        assertThat(info.getQueueSize().singles(),equalTo(1L));\n      }\n else {\n        for (        Field field : Names.class.getFields()) {\n          if (info.getName().equalsIgnoreCase(field.getName())) {\n            continue outer;\n          }\n        }\n        fail(\"Unexpected pool name: \" + info.getName());\n      }\n    }\n    assertThat(foundPool1,is(true));\n    assertThat(foundPool2,is(true));\n  }\n  finally {\n    terminateThreadPoolIfNeeded(threadPool);\n  }\n}\n"}
{"INPUT": "public static TaskExecutor startTaskManager(Configuration configuration,ResourceID resourceID,RpcService rpcService,HighAvailabilityServices highAvailabilityServices,HeartbeatServices heartbeatServices,MetricRegistry metricRegistry,BlobCacheService blobCacheService,boolean localCommunicationOnly,FatalErrorHandler fatalErrorHandler) throws Exception {\n  checkNotNull(configuration);\n  checkNotNull(resourceID);\n  checkNotNull(rpcService);\n  checkNotNull(highAvailabilityServices);\n  InetAddress remoteAddress=InetAddress.getByName(rpcService.getAddress());\n  TaskManagerServicesConfiguration taskManagerServicesConfiguration=TaskManagerServicesConfiguration.fromConfiguration(configuration,remoteAddress,localCommunicationOnly);\n// bug_start\n  TaskManagerServices taskManagerServices=TaskManagerServices.fromConfiguration(taskManagerServicesConfiguration,resourceID);\n// bug_end\n  TaskManagerMetricGroup taskManagerMetricGroup=MetricUtils.instantiateTaskManagerMetricGroup(metricRegistry,taskManagerServices.getTaskManagerLocation(),taskManagerServices.getNetworkEnvironment());\n  TaskManagerConfiguration taskManagerConfiguration=TaskManagerConfiguration.fromConfiguration(configuration);\n  return new TaskExecutor(rpcService,taskManagerConfiguration,highAvailabilityServices,taskManagerServices,heartbeatServices,taskManagerMetricGroup,blobCacheService,fatalErrorHandler);\n}\n"}
{"INPUT": "@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName){\n  failIfNoDocValues();\n// bug_start\n  return new SortedSetOrdinalsIndexFieldData.Builder(CoreValuesSourceType.BYTES);\n// bug_end\n}\n"}
{"INPUT": "@Override protected RestChannelConsumer prepareRequest(final RestRequest restRequest,NodeClient client){\n  Set<String> metrics=Strings.tokenizeByCommaToSet(restRequest.param(\"metric\",\"\"));\n  WatcherStatsRequest request=new WatcherStatsRequest();\n  if (metrics.contains(\"_all\")) {\n    request.includeCurrentWatches(true);\n    request.includeQueuedWatches(true);\n  }\n else {\n    request.includeCurrentWatches(metrics.contains(\"current_watches\"));\n    request.includeQueuedWatches(metrics.contains(\"queued_watches\") || metrics.contains(\"pending_watches\"));\n  }\n  if (metrics.contains(\"pending_watches\")) {\n// bug_start\n    deprecationLogger.deprecated(\"The pending_watches parameter is deprecated, use queued_watches instead\");\n// bug_end\n  }\n  return null;\n}\n"}
{"INPUT": "public Job(JobID jobid,String jobSubmitDir) throws IOException {\n  this.systemJobDir=new Path(jobSubmitDir);\n  this.systemJobFile=new Path(systemJobDir,\"job.xml\");\n  this.id=jobid;\n  this.localFs=FileSystem.getLocal(conf);\n  this.localJobDir=localFs.makeQualified(conf.getLocalPath(jobDir));\n  this.localJobFile=new Path(this.localJobDir,id + \".xml\");\n// bug_start\n  this.trackerDistributerdCacheManager=new TrackerDistributedCacheManager(conf);\n// bug_end\n  this.taskDistributedCacheManager=trackerDistributerdCacheManager.newTaskDistributedCacheManager(conf);\n  taskDistributedCacheManager.setup(new LocalDirAllocator(\"mapred.local.dir\"),new File(systemJobDir.toString()),\"archive\",\"archive\");\n  if (DistributedCache.getSymlink(conf)) {\n    LOG.warn(\"LocalJobRunner does not support \" + \"symlinking into current working dir.\");\n  }\n  TaskRunner.setupWorkDir(conf,new File(localJobDir.toUri()).getAbsoluteFile());\n  OutputStream out=localFs.create(localJobFile);\n  try {\n    conf.writeXml(out);\n  }\n  finally {\n    out.close();\n  }\n  this.job=new JobConf(localJobFile);\n  if (!taskDistributedCacheManager.getClassPaths().isEmpty()) {\n    setContextClassLoader(taskDistributedCacheManager.makeClassLoader(getContextClassLoader()));\n  }\n  profile=new JobProfile(job.getUser(),id,systemJobFile.toString(),\"http://localhost:8080/\",job.getJobName());\n  status=new JobStatus(id,0.0f,0.0f,JobStatus.RUNNING);\n  jobs.put(id,this);\n  this.start();\n}\n"}
{"INPUT": "private void compareCuboidParquetWithSparkSql(String cubeName){\n  KylinConfig config=KylinConfig.getInstanceFromEnv();\n  CubeManager cubeMgr=CubeManager.getInstance(config);\n  Assert.assertTrue(config.getHdfsWorkingDirectory().startsWith(\"file:\"));\n  CubeInstance cube=cubeMgr.getCube(cubeName);\n  for (  CubeSegment segment : cube.getSegments()) {\n    List<LayoutEntity> dataLayouts=MetadataConverter.extractEntityList2JavaList(segment.getCubeInstance());\n    for (    LayoutEntity cuboid : dataLayouts) {\n      Set<Integer> rowKeys=cuboid.getOrderedDimensions().keySet();\n      Dataset<Row> layoutDataset=StorageFactory.createEngineAdapter(new IStorageAware(){\n        @Override public int getStorageType(){\n          return 4;\n        }\n      }\n// bug_start\n,NSparkCubingEngine.NSparkCubingStorage.class).getFrom(PathManager.getParquetStoragePath(segment.getConfig(),segment.getCubeInstance().getName(),segment.getName(),String.valueOf(cuboid.getId())),ss);\n// bug_end\n      layoutDataset=layoutDataset.select(NSparkCubingUtil.getColumns(rowKeys,chooseMeas(cuboid))).sort(NSparkCubingUtil.getColumns(rowKeys));\n      System.out.println(\"Query cuboid ------------ \" + cuboid.getId());\n      layoutDataset=dsConvertToOriginal(layoutDataset,cuboid);\n      layoutDataset.show(10);\n      Dataset<Row> ds=initFlatTable(segment);\n      if (!cuboid.isTableIndex()) {\n        ds=CuboidAggregator.agg(ss,ds,cuboid.getOrderedDimensions().keySet(),cuboid.getOrderedMeasures(),null,true);\n      }\n      Dataset<Row> exceptDs=ds.select(NSparkCubingUtil.getColumns(rowKeys,chooseMeas(cuboid))).sort(NSparkCubingUtil.getColumns(rowKeys));\n      System.out.println(\"Spark sql ------------ \");\n      exceptDs.show(10);\n      Assert.assertEquals(layoutDataset.count(),exceptDs.count());\n      String msg=SparkQueryTest.checkAnswer(layoutDataset,exceptDs,false);\n      Assert.assertNull(msg);\n    }\n  }\n}\n"}
{"INPUT": "@Override public void start(){\n  if (DEBUG)   Log.d(TAG,\"Start\");\n  mUserManager=mContext.getSystemService(UserManager.class);\n// bug_start\n  mThemeManager=new ThemeOverlayManager(mContext.getSystemService(OverlayManager.class),AsyncTask.THREAD_POOL_EXECUTOR,mContext.getString(R.string.launcher_overlayable_package));\n// bug_end\n  final Handler bgHandler=Dependency.get(Dependency.BG_HANDLER);\n  final IntentFilter filter=new IntentFilter();\n  filter.addAction(Intent.ACTION_USER_SWITCHED);\n  filter.addAction(Intent.ACTION_MANAGED_PROFILE_ADDED);\n  mContext.registerReceiverAsUser(new BroadcastReceiver(){\n    @Override public void onReceive(    Context context,    Intent intent){\n      if (DEBUG)       Log.d(TAG,\"Updating overlays for user switch / profile added.\");\n      updateThemeOverlays();\n    }\n  }\n,UserHandle.ALL,filter,null,bgHandler);\n  mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.THEME_CUSTOMIZATION_OVERLAY_PACKAGES),false,new ContentObserver(bgHandler){\n    @Override public void onChange(    boolean selfChange,    Uri uri,    int userId){\n      if (DEBUG)       Log.d(TAG,\"Overlay changed for user: \" + userId);\n      if (ActivityManager.getCurrentUser() == userId) {\n        updateThemeOverlays();\n      }\n    }\n  }\n,UserHandle.USER_ALL);\n}\n"}
{"INPUT": "@Inject public OpenShiftInternalRuntime(@Named(\"che.infra.kubernetes.workspace_start_timeout_min\") int workspaceStartTimeout,@Named(\"che.infra.kubernetes.ingress_start_timeout_min\") int ingressStartTimeout,NoOpURLRewriter urlRewriter,UnrecoverablePodEventListenerFactory unrecoverablePodEventListenerFactory,KubernetesBootstrapperFactory bootstrapperFactory,ServersCheckerFactory serverCheckerFactory,WorkspaceVolumesStrategy volumesStrategy,ProbeScheduler probeScheduler,WorkspaceProbesFactory probesFactory,RuntimeEventsPublisher eventPublisher,KubernetesSharedPool sharedPool,KubernetesRuntimeStateCache runtimesStatusesCache,KubernetesMachineCache machinesCache,StartSynchronizerFactory startSynchronizerFactory,Set<InternalEnvironmentProvisioner> internalEnvironmentProvisioners,OpenShiftEnvironmentProvisioner kubernetesEnvironmentProvisioner,SidecarToolingProvisioner<OpenShiftEnvironment> toolingProvisioner,RuntimeHangingDetector runtimeHangingDetector,Tracer tracer,@Assisted OpenShiftRuntimeContext context,@Assisted OpenShiftProject project){\n// bug_start\n  super(workspaceStartTimeout,ingressStartTimeout,urlRewriter,unrecoverablePodEventListenerFactory,bootstrapperFactory,serverCheckerFactory,volumesStrategy,probeScheduler,probesFactory,eventPublisher,sharedPool,runtimesStatusesCache,machinesCache,startSynchronizerFactory,internalEnvironmentProvisioners,kubernetesEnvironmentProvisioner,toolingProvisioner,runtimeHangingDetector,tracer,context,project);\n// bug_end\n  this.project=project;\n}\n"}
{"INPUT": "@Override protected Command getCreateCommand(CreateRequest request){\n  DiagramPart diagramPart=(DiagramPart)getHost();\n  Point location=request.getLocation();\n  diagramPart.getFigure().translateToRelative(location);\n  Object newObject=request.getNewObject();\n  if (newObject instanceof ERDNote) {\n// bug_start\n    return new NoteCreateCommand(diagramPart,(ERDNote)newObject,location);\n// bug_end\n  }\n  List<ERDEntity> entities=null;\n  if (newObject instanceof ERDEntity) {\n    entities=Collections.singletonList((ERDEntity)newObject);\n  }\n else   if (newObject instanceof Collection) {\n    entities=new ArrayList<>((Collection<ERDEntity>)newObject);\n  }\n  if (CommonUtils.isEmpty(entities)) {\n    return null;\n  }\n  Command entityAddCommand=diagramPart.createEntityAddCommand(entities,location);\n  if (!entityAddCommand.canExecute()) {\n    return null;\n  }\n  return entityAddCommand;\n}\n"}
{"INPUT": "@Override protected void init(ThreadContext context,IRubyObject[] args){\n  if (args.length < 2) {\n    throw getRuntime().newArgumentError(args.length,2);\n  }\n  IRubyObject doc=args[0];\n  content=args[1];\n  XmlDocument xmlDoc=(XmlDocument)((XmlNode)doc).document(context);\n  doc=xmlDoc;\n  Document document=xmlDoc.getDocument();\n  Node node=document.createCDATASection((content.isNil()) ? null : (String)content.toJava(String.class));\n// bug_start\n  setNode(node);\n// bug_end\n}\n"}
{"INPUT": "@Override protected RowExpression visitTimestampLiteral(TimestampLiteral node,Void context){\n  long value;\n  if (types.get(node).equals(TIMESTAMP_WITH_TIME_ZONE)) {\n// bug_start\n    value=parseTimestampWithTimeZone(node.getValue());\n// bug_end\n  }\n else {\n    value=parseTimestampWithoutTimeZone(timeZoneKey,node.getValue());\n  }\n  return constant(value,types.get(node));\n}\n"}
{"INPUT": "public FieldNamesFieldType(boolean enabled){\n// bug_start\n  super(Defaults.NAME,true,false,TextSearchInfo.SIMPLE_MATCH_ONLY,Collections.emptyMap());\n// bug_end\n  this.enabled=enabled;\n}\n"}
{"INPUT": "@Before public void setUp() throws Exception {\n  tmpDir=new File(System.getProperty(\"java.io.tmpdir\") + \"/ZeppelinLTest_\" + System.currentTimeMillis());\n  tmpDir.mkdirs();\n  new File(tmpDir,\"conf\").mkdirs();\n  MockInterpreter1.register(\"mock1\",\"org.apache.zeppelin.interpreter.mock.MockInterpreter1\");\n  MockInterpreter2.register(\"mock2\",\"org.apache.zeppelin.interpreter.mock.MockInterpreter2\");\n  System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(),tmpDir.getAbsolutePath());\n  System.setProperty(ConfVars.ZEPPELIN_INTERPRETERS.getVarName(),\"org.apache.zeppelin.interpreter.mock.MockInterpreter1,org.apache.zeppelin.interpreter.mock.MockInterpreter2\");\n  conf=new ZeppelinConfiguration();\n  factory=new InterpreterFactory(conf,new InterpreterOption(false),null);\n// bug_start\n  context=new InterpreterContext(\"id\",\"title\",\"text\",null,null,null,null);\n// bug_end\n}\n"}
{"INPUT": "public void addOrShowTerminal(MachineEntity machine){\n  String machineId=machine.getId();\n  TerminalPresenter terminal=terminals.get(machineId);\n  if (terminal != null) {\n    terminal.connect();\n    view.showTerminal(terminal);\n    return;\n  }\n// bug_start\n  TerminalPresenter newTerminal=terminalFactory.create(machine);\n// bug_end\n  terminals.put(machineId,newTerminal);\n  view.addTerminal(newTerminal);\n}\n"}
{"INPUT": "@Override public RouteResultset analyseShowSQL(SchemaConfig schema,RouteResultset rrs,String stmt) throws SQLSyntaxErrorException {\n  String upStmt=stmt.toUpperCase();\n  int tabInd=upStmt.indexOf(\" TABLES\");\n  if (tabInd > 0) {\n    int[] nextPost=RouterUtil.getSpecPos(upStmt,0);\n    if (nextPost[0] > 0) {\n      int end=RouterUtil.getSpecEndPos(upStmt,tabInd);\n      if (upStmt.indexOf(\" FULL\") > 0) {\n        stmt=\"SHOW FULL TABLES\" + stmt.substring(end);\n      }\n else {\n        stmt=\"SHOW TABLES\" + stmt.substring(end);\n      }\n    }\n    String defaultNode=schema.getDataNode();\n    if (!Strings.isNullOrEmpty(defaultNode)) {\n      return RouterUtil.routeToSingleNode(rrs,defaultNode,stmt);\n    }\n    return RouterUtil.routeToMultiNode(false,rrs,schema.getMetaDataNodes(),stmt);\n  }\n  int[] indx=RouterUtil.getSpecPos(upStmt,0);\n  if (indx[0] > 0) {\n    int[] repPos={indx[0] + indx[1],0};\n// bug_start\n    String tableName=RouterUtil.getShowTableName(stmt,repPos);\n// bug_end\n    int[] indx2=RouterUtil.getSpecPos(upStmt,indx[0] + indx[1] + 1);\n    if (indx2[0] > 0) {\n      repPos[1]=RouterUtil.getSpecEndPos(upStmt,indx2[0] + indx2[1]);\n    }\n    stmt=stmt.substring(0,indx[0]) + \" FROM \" + tableName+ stmt.substring(repPos[1]);\n    RouterUtil.routeForTableMeta(rrs,schema,tableName,stmt);\n    return rrs;\n  }\n  int[] createTabInd=RouterUtil.getCreateTablePos(upStmt,0);\n  if (createTabInd[0] > 0) {\n    int tableNameIndex=createTabInd[0] + createTabInd[1];\n    if (upStmt.length() > tableNameIndex) {\n      String tableName=stmt.substring(tableNameIndex).trim();\n      int ind2=tableName.indexOf('.');\n      if (ind2 > 0) {\n        tableName=tableName.substring(ind2 + 1);\n      }\n      RouterUtil.routeForTableMeta(rrs,schema,tableName,stmt);\n      return rrs;\n    }\n  }\n  return RouterUtil.routeToSingleNode(rrs,schema.getRandomDataNode(),stmt);\n}\n"}
{"INPUT": "@Test public void testFaultInOfValuesFromDisk(){\n  try {\n    diskProps.setMaxOplogSize(1000);\n    diskProps.setPersistBackup(true);\n    diskProps.setRolling(false);\n    diskProps.setSynchronous(true);\n    diskProps.setTimeInterval(-1);\n    diskProps.setOverflow(false);\n    region=DiskRegionHelperFactory.getSyncPersistOnlyRegion(cache,diskProps,Scope.LOCAL);\n    byte[] val=new byte[10];\n    for (int i=0; i < val.length; ++i) {\n      val[i]=(byte)i;\n    }\n    region.put(1,val);\n    DiskEntry entry=((DiskEntry)((LocalRegion)region).basicGetEntry(1));\n    DiskRegion dr=((LocalRegion)region).getDiskRegion();\n    val=(byte[])dr.getNoBuffer(entry.getDiskId());\n    for (int i=0; i < val.length; ++i) {\n      if (val[i] != (byte)i) {\n        fail(\"Test for fault in from disk failed\");\n      }\n    }\n// bug_start\n    val=(byte[])DiskStoreImpl.convertBytesAndBitsIntoObject(dr.getBytesAndBitsWithoutLock(entry.getDiskId(),true,false));\n// bug_end\n    for (int i=0; i < val.length; ++i) {\n      if (val[i] != (byte)i) {\n        fail(\"Test for fault in from disk failed\");\n      }\n    }\n    region.invalidate(1);\n    assertTrue(dr.getNoBuffer(entry.getDiskId()) == Token.INVALID);\n  }\n catch (  Exception e) {\n    logWriter.error(\"Exception occurred\",e);\n    fail(e.toString());\n  }\n  closeDown();\n}\n"}
{"INPUT": "private void visitConfigurationPropertySetter(ExecutableElement method){\n  BeanDefinitionVisitor writer=getOrCreateBeanDefinitionWriter(concreteClass,concreteClass.getQualifiedName());\n  VariableElement parameter=method.getParameters().get(0);\n  TypeMirror valueType=parameter.asType();\n  Object fieldType=modelUtils.resolveTypeReference(valueType);\n  Map<String,Object> genericTypes=Collections.emptyMap();\n  TypeKind typeKind=valueType.getKind();\n  if (!(typeKind.isPrimitive() || typeKind == ARRAY)) {\n    genericTypes=genericUtils.resolveGenericTypes(valueType,Collections.emptyMap());\n  }\n  TypeElement declaringClass=modelUtils.classElementFor(method);\n  if (declaringClass != null) {\n    AnnotationMetadata methodAnnotationMetadata=annotationUtils.getAnnotationMetadata(method);\n    if (methodAnnotationMetadata.hasStereotype(ConfigurationBuilder.class)) {\n      writer.visitConfigBuilderMethod(fieldType,NameUtils.getterNameFor(NameUtils.getPropertyNameForSetter(method.getSimpleName().toString())),methodAnnotationMetadata,metadataBuilder);\n      try {\n        visitConfigurationBuilder(declaringClass,method,valueType,writer);\n      }\n  finally {\n        writer.visitConfigBuilderEnd();\n      }\n    }\n else {\n      String docComment=elementUtils.getDocComment(method);\n      String setterName=method.getSimpleName().toString();\n      PropertyMetadata propertyMetadata=metadataBuilder.visitProperty(concreteClass,declaringClass,getPropertyMetadataTypeReference(valueType),NameUtils.getPropertyNameForSetter(setterName),docComment,null);\n      AnnotationMetadata annotationMetadata=DefaultAnnotationMetadata.mutateMember(AnnotationMetadata.EMPTY_METADATA,PropertySource.class.getName(),AnnotationMetadata.VALUE_MEMBER,Collections.singletonList(new io.micronaut.core.annotation.AnnotationValue(Property.class.getName(),Collections.singletonMap(\"name\",propertyMetadata.getPath()))));\n      boolean requiresReflection=true;\n      if (modelUtils.isPublic(method)) {\n        requiresReflection=false;\n      }\n else       if (modelUtils.isPackagePrivate(method) || modelUtils.isProtected(method)) {\n        PackageElement declaringPackage=elementUtils.getPackageOf(declaringClass);\n        PackageElement concretePackage=elementUtils.getPackageOf(this.concreteClass);\n        requiresReflection=!declaringPackage.getQualifiedName().equals(concretePackage.getQualifiedName());\n      }\n// bug_start\n      writer.visitSetterValue(modelUtils.resolveTypeReference(declaringClass),annotationMetadata,requiresReflection,fieldType,setterName,genericTypes,annotationUtils.getAnnotationMetadata(method.getParameters().get(0)),true);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "private FakeDownloadAction(boolean isRemoveAction,@Nullable String mediaId){\n// bug_start\n  super(\"FakeDownloadAction\",isRemoveAction,mediaId);\n// bug_end\n  this.mediaId=mediaId;\n  this.downloader=new FakeDownloader(isRemoveAction);\n  this.states=new ArrayBlockingQueue<>(10);\n}\n"}
{"INPUT": "public static Locale parseLocaleString(String localeString){\n  String[] parts=tokenizeToStringArray(localeString,\"_ \",false,false);\n  String language=(parts.length > 0 ? parts[0] : \"\");\n  String country=(parts.length > 1 ? parts[1] : \"\");\n  validateLocalePart(language);\n  validateLocalePart(country);\n  String variant=\"\";\n  if (parts.length > 2) {\n// bug_start\n    int endIndexOfCountryCode=localeString.lastIndexOf(country) + country.length();\n// bug_end\n    variant=trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n    if (variant.startsWith(\"_\")) {\n      variant=trimLeadingCharacter(variant,'_');\n    }\n  }\n  return (language.length() > 0 ? new Locale(language,country,variant) : null);\n}\n"}
{"INPUT": "public void testIsolation() throws Exception {\n  CollectionConfiguration colCfg=collectionConfiguration();\n  Ignite ignite=grid(0);\n// bug_start\n  CacheConfiguration cfg=new CacheConfiguration();\n// bug_end\n  cfg.setName(\"myCache\");\n  cfg.setAtomicityMode(TRANSACTIONAL);\n  cfg.setWriteSynchronizationMode(FULL_SYNC);\n  IgniteCache<Integer,Integer> cache=ignite.getOrCreateCache(cfg);\n  try {\n    IgniteSet<Integer> set0=ignite.set(SET_NAME,colCfg);\n    assertNotNull(set0);\n    try (Transaction tx=ignite.transactions().txStart()){\n      cache.put(1,1);\n      Collection<Integer> items=new ArrayList<>(100);\n      for (int i=0; i < 100; i++)       items.add(i);\n      set0.addAll(items);\n      tx.rollback();\n    }\n     assertEquals(0,cache.size());\n    assertEquals(100,set0.size());\n    set0.close();\n  }\n  finally {\n    ignite.destroyCache(cfg.getName());\n  }\n}\n"}
{"INPUT": "@Override public void doGenerateQueryPart(SearchJob job,Query query,Aggregation searchType,ESGeneratedQueryContext queryContext){\n// bug_start\n  final SearchSourceBuilder searchSourceBuilder=queryContext.searchSourceBuilder();\n// bug_end\n  List<AggregationBuilder> builders=Lists.newArrayList();\n  searchType.aggregations().forEach(null);\n  queryContext.addFilteredAggregations(builders,searchType);\n}\n"}
{"INPUT": "public HistogramFieldType(String name,boolean hasDocValues,Map<String,String> meta){\n// bug_start\n  super(name,false,hasDocValues,TextSearchInfo.SIMPLE_MATCH_ONLY,meta);\n// bug_end\n}\n"}
{"INPUT": "public void initialize(InputSplit split,TaskAttemptContext context) throws IOException, InterruptedException {\n  rr.initialize(split,context);\n  conf=context.getConfiguration();\n  nextKeyValue();\n  if (!empty) {\n    keyclass=key.getClass().asSubclass(WritableComparable.class);\n    valueclass=value.getClass();\n    if (cmp == null) {\n// bug_start\n      cmp=WritableComparator.get(keyclass);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "public IntWritable evaluate(DateWritable d){\n  if (d == null) {\n    return null;\n  }\n// bug_start\n  calendar.setTime(d.get());\n// bug_end\n  result.set(calendar.get(Calendar.DAY_OF_MONTH));\n  return result;\n}\n"}
{"INPUT": "protected Query createJpaQuery(String queryString){\n  EntityManager em=getEntityManager();\n  if (this.query.hasConstructorExpression() || this.query.isDefaultProjection()) {\n    return em.createQuery(queryString);\n  }\n  ResultProcessor resultFactory=getQueryMethod().getResultProcessor();\n  ReturnedType returnedType=resultFactory.getReturnedType();\n// bug_start\n  getMetamodel().isJpaManaged(returnedType.getReturnedType());\n// bug_end\n  return returnedType.isProjecting() && !getMetamodel().isJpaManaged(returnedType.getReturnedType()) ? em.createQuery(queryString,Tuple.class) : em.createQuery(queryString);\n}\n"}
{"INPUT": "@Override public void sessionSaved(Exception e){\n  if (e == null) {\n    view.getMainFrame().getMainMenuBar().getMenuFileSave().setEnabled(true);\n    setTitle();\n  }\n else {\n    view.showWarningDialog(Constant.messages.getString(\"menu.file.savingSession.error\"));\n// bug_start\n    e.printStackTrace();\n// bug_end\n    log.error(\"error saving session file \" + model.getSession().getFileName(),e);\n    log.error(e.getMessage(),e);\n  }\n  if (waitMessageDialog != null) {\n    waitMessageDialog.setVisible(false);\n    waitMessageDialog=null;\n  }\n}\n"}
{"INPUT": "@Test public void testForPasswordShouldReturnFirstAlgorithm() throws Exception {\n  when(passwordAlgorithm1.supports(anyString())).thenReturn(true);\n// bug_start\n  when(passwordAlgorithm2.supports(anyString())).thenReturn(false);\n// bug_end\n  final PasswordAlgorithmFactory passwordAlgorithmFactory=new PasswordAlgorithmFactory(passwordAlgorithms,passwordAlgorithm2);\n  assertThat(passwordAlgorithmFactory.forPassword(\"foobar\")).isEqualTo(passwordAlgorithm1);\n}\n"}
{"INPUT": "private AnnotateImageRequest(com.google.protobuf.CodedInputStream input,com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\n  this();\n// bug_start\n  if (extensionRegistry == null) {\n    throw new java.lang.NullPointerException();\n  }\n// bug_end\n  int mutable_bitField0_=0;\n  com.google.protobuf.UnknownFieldSet.Builder unknownFields=com.google.protobuf.UnknownFieldSet.newBuilder();\n  try {\n    boolean done=false;\n    while (!done) {\n      int tag=input.readTag();\nswitch (tag) {\ncase 0:\n        done=true;\n      break;\ndefault :\n{\n      if (!parseUnknownFieldProto3(input,unknownFields,extensionRegistry,tag)) {\n        done=true;\n      }\n      break;\n    }\ncase 10:\n{\n    com.google.cloud.vision.v1p1beta1.Image.Builder subBuilder=null;\n    if (image_ != null) {\n      subBuilder=image_.toBuilder();\n    }\n    image_=input.readMessage(com.google.cloud.vision.v1p1beta1.Image.parser(),extensionRegistry);\n    if (subBuilder != null) {\n      subBuilder.mergeFrom(image_);\n      image_=subBuilder.buildPartial();\n    }\n    break;\n  }\ncase 18:\n{\n  if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {\n    features_=new java.util.ArrayList<com.google.cloud.vision.v1p1beta1.Feature>();\n    mutable_bitField0_|=0x00000002;\n  }\n  features_.add(input.readMessage(com.google.cloud.vision.v1p1beta1.Feature.parser(),extensionRegistry));\n  break;\n}\ncase 26:\n{\ncom.google.cloud.vision.v1p1beta1.ImageContext.Builder subBuilder=null;\nif (imageContext_ != null) {\n  subBuilder=imageContext_.toBuilder();\n}\nimageContext_=input.readMessage(com.google.cloud.vision.v1p1beta1.ImageContext.parser(),extensionRegistry);\nif (subBuilder != null) {\n  subBuilder.mergeFrom(imageContext_);\n  imageContext_=subBuilder.buildPartial();\n}\nbreak;\n}\n}\n}\n}\n catch (com.google.protobuf.InvalidProtocolBufferException e) {\nthrow e.setUnfinishedMessage(this);\n}\ncatch (java.io.IOException e) {\nthrow new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);\n}\n finally {\nif (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {\nfeatures_=java.util.Collections.unmodifiableList(features_);\n}\nthis.unknownFields=unknownFields.build();\nmakeExtensionsImmutable();\n}\n}\n"}
{"INPUT": "protected List<Highlight> getHighlightsAtIndex(int index){\n  List<Highlight> vals=new ArrayList<Highlight>();\n  float phaseX=mChart.getAnimator().getPhaseX();\n  float phaseY=mChart.getAnimator().getPhaseY();\n  float sliceangle=mChart.getSliceAngle();\n  float factor=mChart.getFactor();\n  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {\n    IDataSet<?> dataSet=mChart.getData().getDataSetByIndex(i);\n    final Entry entry=dataSet.getEntryForIndex(index);\n    float y=(entry.getY() - mChart.getYChartMin());\n// bug_start\n    if (Float.isNaN(y))     continue;\n// bug_end\n    PointF p=Utils.getPosition(mChart.getCenterOffsets(),y * factor * phaseY,sliceangle * index * phaseX + mChart.getRotationAngle());\n    vals.add(new Highlight(index,entry.getY(),p.x,p.y,i,dataSet.getAxisDependency()));\n  }\n  return vals;\n}\n"}
{"INPUT": "@Override protected Void onExecute(Context context,Bundle args){\n  long fid=args.getLong(\"folder\");\n  String type=args.getString(\"type\");\n  DB db=DB.getInstance(context);\n  try {\n    db.beginTransaction();\n    EntityFolder folder=db.folder().getFolder(fid);\n    if (folder == null)     return null;\n    if (!folder.type.equals(type))     throw new IllegalStateException(\"Invalid folder type=\" + type);\n    EntityAccount account=db.account().getAccount(folder.account);\n    if (account == null)     return null;\n    EntityLog.log(context,\"Empty account=\" + account.name + \" folder=\"+ folder.name+ \" count=\"+ folder.total);\n    List<Long> ids=db.message().getMessageByFolder(folder.id);\n    for (    Long id : ids) {\n      EntityMessage message=db.message().getMessage(id);\n      if (message == null)       continue;\n      if (message.uid != null || account.protocol == EntityAccount.TYPE_POP)       db.message().setMessageUiHide(message.id,true);\n    }\n    EntityOperation.queue(context,folder,EntityOperation.PURGE);\n// bug_start\n    EntityOperation.sync(context,folder.id,false);\n// bug_end\n    db.setTransactionSuccessful();\n  }\n  finally {\n    db.endTransaction();\n  }\n  ServiceSynchronize.eval(context,\"delete\");\n  return null;\n}\n"}
{"INPUT": "@ApiResponses(value={@ApiResponse(code=200,message=\"Success/Fail\",response=RequestResult.class)}) @Audit @PostMapping(value=\"/{executorName}/dump\") public SuccessResponseEntity dump(final HttpServletRequest request,@AuditParam(\"namespace\") @PathVariable String namespace,@AuditParam(\"executorName\") @PathVariable String executorName) throws SaturnJobConsoleException {\n// bug_start\n  assertIsPermitted(PermissionKeys.executorDump,namespace);\n// bug_end\n  checkExecutorStatus(namespace,executorName,ServerStatus.ONLINE,\"Executordump\");\n  executorService.dump(namespace,executorName);\n  return new SuccessResponseEntity();\n}\n"}
{"INPUT": "@Override public void onAccept(Object socket){\n  SpdyConnectionSocket ch=new SpdyConnectionSocket(ctx,(Socket)socket);\n// bug_start\n  ctx.getExecutor().execute(ch.inputThread);\n// bug_end\n  ch.onBlockingSocket();\n}\n"}
{"INPUT": "protected RowLock getRowLockInternal(byte[] row,boolean waitForLock) throws IOException {\n// bug_start\n  checkRow(row,\"row lock\");\n// bug_end\n  HashedBytes rowKey=new HashedBytes(row);\n  RowLockContext rowLockContext=new RowLockContext(rowKey);\n  while (true) {\n    RowLockContext existingContext=lockedRows.putIfAbsent(rowKey,rowLockContext);\n    if (existingContext == null) {\n      break;\n    }\n else     if (existingContext.ownedByCurrentThread()) {\n      rowLockContext=existingContext;\n      break;\n    }\n else {\n      if (!waitForLock) {\n        return null;\n      }\n      TraceScope traceScope=null;\n      try {\n        if (Trace.isTracing()) {\n          traceScope=Trace.startSpan(\"HRegion.getRowLockInternal\");\n        }\n        if (!existingContext.latch.await(this.rowLockWaitDuration,TimeUnit.MILLISECONDS)) {\n          if (traceScope != null) {\n            traceScope.getSpan().addTimelineAnnotation(\"Failed to get row lock\");\n          }\n          throw new IOException(\"Timed out waiting for lock for row: \" + rowKey);\n        }\n        if (traceScope != null)         traceScope.close();\n        traceScope=null;\n      }\n catch (      InterruptedException ie) {\n        LOG.warn(\"Thread interrupted waiting for lock on row: \" + rowKey);\n        InterruptedIOException iie=new InterruptedIOException();\n        iie.initCause(ie);\n        throw iie;\n      }\n finally {\n        if (traceScope != null)         traceScope.close();\n      }\n    }\n  }\n  return rowLockContext.newLock();\n}\n"}
{"INPUT": "private void parseHost(MessageBytes valueMB){\n  if (valueMB == null || valueMB.isNull()) {\n    request.setServerPort(request.getLocalPort());\n    try {\n      request.serverName().duplicate(request.localName());\n    }\n catch (    IOException e) {\n      response.setStatus(400);\n      setErrorState(ErrorState.CLOSE_CLEAN,e);\n    }\n    return;\n  }\n  ByteChunk valueBC=valueMB.getByteChunk();\n  byte[] valueB=valueBC.getBytes();\n  int valueL=valueBC.getLength();\n  int valueS=valueBC.getStart();\n  int colonPos=-1;\n  if (hostNameC.length < valueL) {\n    hostNameC=new char[valueL];\n  }\n  boolean ipv6=(valueB[valueS] == '[');\n  boolean bracketClosed=false;\n  for (int i=0; i < valueL; i++) {\n    char b=(char)valueB[i + valueS];\n    hostNameC[i]=b;\n    if (b == ']') {\n      bracketClosed=true;\n    }\n else     if (b == ':') {\n      if (!ipv6 || bracketClosed) {\n        colonPos=i;\n        break;\n      }\n    }\n  }\n  if (colonPos < 0) {\n// bug_start\n    if (request.scheme().equalsIgnoreCase(\"https\")) {\n      request.setServerPort(443);\n    }\n else {\n      request.setServerPort(80);\n    }\n// bug_end\n    request.serverName().setChars(hostNameC,0,valueL);\n  }\n else {\n    request.serverName().setChars(hostNameC,0,colonPos);\n    int port=0;\n    int mult=1;\n    for (int i=valueL - 1; i > colonPos; i--) {\n      int charValue=HexUtils.getDec(valueB[i + valueS]);\n      if (charValue == -1) {\n        response.setStatus(400);\n        setErrorState(ErrorState.CLOSE_CLEAN,null);\n        break;\n      }\n      port=port + (charValue * mult);\n      mult=10 * mult;\n    }\n    request.setServerPort(port);\n  }\n}\n"}
{"INPUT": "@Override protected void processEvent(InListEvent listEvent){\n  acquireLock();\n  try {\n// bug_start\n    System.out.println(listEvent);\n// bug_end\n    for (int i=0, size=listEvent.getActiveEvents(); i < size; i++) {\n      newEventList.add((InEvent)listEvent.getEvent(i));\n    }\n  }\n  finally {\n    releaseLock();\n  }\n}\n"}
{"INPUT": "public HiveSessionImpl(SessionHandle sessionHandle,TProtocolVersion protocol,String username,String password,HiveConf serverConf,String ipAddress,final List<String> forwardedAddresses){\n  this.username=username;\n  this.password=password;\n  creationTime=System.currentTimeMillis();\n  this.sessionHandle=sessionHandle != null ? sessionHandle : new SessionHandle(protocol);\n  this.sessionConf=new HiveConf(serverConf);\n  this.ipAddress=ipAddress;\n  this.forwardedAddresses=forwardedAddresses;\n  this.operationLock=serverConf.getBoolVar(ConfVars.HIVE_SERVER2_PARALLEL_OPS_IN_SESSION) ? null : new Semaphore(1);\n// bug_start\n  try {\n    if (!sessionConf.getBoolVar(ConfVars.HIVE_SERVER2_ENABLE_DOAS) && sessionConf.getBoolVar(ConfVars.HIVE_SERVER2_MAP_FAIR_SCHEDULER_QUEUE)) {\n      ShimLoader.getHadoopShims().refreshDefaultQueue(sessionConf,username);\n    }\n  }\n catch (  IOException e) {\n    LOG.warn(\"Error setting scheduler queue: \" + e,e);\n  }\n// bug_end\n  sessionConf.set(ConfVars.HIVESESSIONID.varname,this.sessionHandle.getHandleIdentifier().toString());\n  sessionConf.set(SerDeUtils.LIST_SINK_OUTPUT_FORMATTER,ThriftFormatter.class.getName());\n  sessionConf.setInt(SerDeUtils.LIST_SINK_OUTPUT_PROTOCOL,protocol.getValue());\n}\n"}
{"INPUT": "@Override protected FullHttpRequest newHandshakeRequest(){\n  int spaces1=WebSocketUtil.randomNumber(1,12);\n  int spaces2=WebSocketUtil.randomNumber(1,12);\n  int max1=Integer.MAX_VALUE / spaces1;\n  int max2=Integer.MAX_VALUE / spaces2;\n  int number1=WebSocketUtil.randomNumber(0,max1);\n  int number2=WebSocketUtil.randomNumber(0,max2);\n  int product1=number1 * spaces1;\n  int product2=number2 * spaces2;\n  String key1=Integer.toString(product1);\n  String key2=Integer.toString(product2);\n  key1=insertRandomCharacters(key1);\n  key2=insertRandomCharacters(key2);\n  key1=insertSpaces(key1,spaces1);\n  key2=insertSpaces(key2,spaces2);\n  byte[] key3=WebSocketUtil.randomBytes(8);\n  ByteBuffer buffer=ByteBuffer.allocate(4);\n  buffer.putInt(number1);\n  byte[] number1Array=buffer.array();\n  buffer=ByteBuffer.allocate(4);\n  buffer.putInt(number2);\n  byte[] number2Array=buffer.array();\n  byte[] challenge=new byte[16];\n  System.arraycopy(number1Array,0,challenge,0,4);\n  System.arraycopy(number2Array,0,challenge,4,4);\n  System.arraycopy(key3,0,challenge,8,8);\n  expectedChallengeResponseBytes=Unpooled.wrappedBuffer(WebSocketUtil.md5(challenge));\n  URI wsURL=uri();\n  FullHttpRequest request=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,upgradeUrl(wsURL),Unpooled.wrappedBuffer(key3));\n  HttpHeaders headers=request.headers();\n  if (customHeaders != null) {\n    headers.add(customHeaders);\n  }\n  headers.set(HttpHeaderNames.UPGRADE,WEBSOCKET).set(HttpHeaderNames.CONNECTION,HttpHeaderValues.UPGRADE).set(HttpHeaderNames.HOST,websocketHostValue(wsURL)).set(HttpHeaderNames.SEC_WEBSOCKET_KEY1,key1).set(HttpHeaderNames.SEC_WEBSOCKET_KEY2,key2);\n// bug_start\n  if (!headers.contains(HttpHeaderNames.ORIGIN)) {\n    headers.set(HttpHeaderNames.ORIGIN,websocketOriginValue(wsURL));\n  }\n// bug_end\n  String expectedSubprotocol=expectedSubprotocol();\n  if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {\n    headers.set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL,expectedSubprotocol);\n  }\n  headers.set(HttpHeaderNames.CONTENT_LENGTH,key3.length);\n  return request;\n}\n"}
{"INPUT": "public void setImportMetadata(AnnotationMetadata importMetadata){\n  Map<String,Object> enableAttrMap=importMetadata.getAnnotationAttributes(EnableRedisHttpSession.class.getName());\n  AnnotationAttributes enableAttrs=AnnotationAttributes.fromMap(enableAttrMap);\n// bug_start\n  if (enableAttrs == null) {\n    Class<?> currentClass=ClassUtils.resolveClassName(importMetadata.getClassName(),beanClassLoader);\n    for (Class<?> classToInspect=currentClass; classToInspect != null; classToInspect=classToInspect.getSuperclass()) {\n      EnableRedisHttpSession enableRedisHttpSessionAnnotation=AnnotationUtils.findAnnotation(classToInspect,EnableRedisHttpSession.class);\n      if (enableRedisHttpSessionAnnotation == null) {\n        continue;\n      }\n      enableAttrMap=AnnotationUtils.getAnnotationAttributes(enableRedisHttpSessionAnnotation);\n      enableAttrs=AnnotationAttributes.fromMap(enableAttrMap);\n    }\n  }\n// bug_end\n  maxInactiveIntervalInSeconds=enableAttrs.getNumber(\"maxInactiveIntervalInSeconds\");\n  this.redisNamespace=enableAttrs.getString(\"redisNamespace\");\n}\n"}
{"INPUT": "public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n  final DeploymentUnit deploymentUnit=phaseContext.getDeploymentUnit();\n  final ModuleSpecification moduleSpecification=deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n  final ModuleLoader moduleLoader=Module.getBootModuleLoader();\n  addDependency(moduleSpecification,moduleLoader,JAXB_API);\n// bug_start\n  if (!JaxrsDeploymentMarker.isJaxrsDeployment(deploymentUnit)) {\n    return;\n  }\n// bug_end\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_ATOM);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_VALIDATOR_11);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_JAXRS);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_JAXB);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_JACKSON);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_JSAPI);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_MULTIPART);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_YAML);\n  addDependency(moduleSpecification,moduleLoader,JACKSON_CORE_ASL);\n  addDependency(moduleSpecification,moduleLoader,RESTEASY_CRYPTO);\n  if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n    addDependency(moduleSpecification,moduleLoader,RESTEASY_CDI);\n  }\n}\n"}
{"INPUT": "@Test public void shouldPassAllOutcomes(){\n  BsonDocument outcome=helper.getOperationResults(definition.getDocument(\"operation\"));\n  BsonDocument expectedOutcome=definition.getDocument(\"outcome\");\n  BsonValue expectedResult=expectedOutcome.get(\"result\");\n  BsonValue actualResult=outcome.get(\"result\");\n  if (actualResult.isDocument() && actualResult.asDocument().containsKey(\"upsertedCount\") && actualResult.asDocument().getNumber(\"upsertedCount\").intValue() == 0 && !expectedResult.asDocument().containsKey(\"upsertedCount\")) {\n    expectedResult.asDocument().append(\"upsertedCount\",actualResult.asDocument().get(\"upsertedCount\"));\n  }\n// bug_start\n  if (actualResult.isDocument() && actualResult.asDocument().containsKey(\"insertedCount\")) {\n    actualResult.asDocument().remove(\"insertedCount\");\n  }\n// bug_end\n  assertEquals(description,expectedResult,actualResult);\n  if (expectedOutcome.containsKey(\"collection\")) {\n    assertCollectionEquals(expectedOutcome.getDocument(\"collection\"));\n  }\n}\n"}
{"INPUT": "private Map<String,List<MojoExecution>> calculateLifecycleMappings(MavenSession session,MavenProject project,String lifecyclePhase) throws LifecyclePhaseNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException {\n  Lifecycle lifecycle=phaseToLifecycleMap.get(lifecyclePhase);\n  if (lifecycle == null) {\n// bug_start\n    logger.info(\"Invalid task '\" + lifecyclePhase + \"' : you must specify a valid lifecycle phase\"+ \", or a goal in the format <plugin-prefix>:<goal> or\"+ \" <plugin-group-id>:<plugin-artifact-id>:<plugin-version>:<goal>\");\n// bug_end\n    throw new LifecyclePhaseNotFoundException(lifecyclePhase);\n  }\n  Map<String,List<MojoExecution>> lifecycleMappings=new LinkedHashMap<String,List<MojoExecution>>();\n  for (  String phase : lifecycle.getPhases()) {\n    List<MojoExecution> mojoExecutions=new ArrayList<MojoExecution>();\n    lifecycleMappings.put(phase,mojoExecutions);\n    if (phase.equals(lifecyclePhase)) {\n      break;\n    }\n  }\n  for (  Plugin plugin : project.getBuild().getPlugins()) {\n    for (    PluginExecution execution : plugin.getExecutions()) {\n      if (execution.getPhase() != null) {\n        List<MojoExecution> mojoExecutions=lifecycleMappings.get(execution.getPhase());\n        if (mojoExecutions != null) {\n          for (          String goal : execution.getGoals()) {\n            MojoExecution mojoExecution=new MojoExecution(plugin,goal,execution.getId());\n            mojoExecutions.add(mojoExecution);\n          }\n        }\n      }\n else {\n        for (        String goal : execution.getGoals()) {\n          MojoDescriptor mojoDescriptor=pluginManager.getMojoDescriptor(plugin,goal,getRepositoryRequest(session,project));\n          List<MojoExecution> mojoExecutions=lifecycleMappings.get(mojoDescriptor.getPhase());\n          if (mojoExecutions != null) {\n            MojoExecution mojoExecution=new MojoExecution(mojoDescriptor,execution.getId());\n            mojoExecutions.add(mojoExecution);\n          }\n        }\n      }\n    }\n  }\n  return lifecycleMappings;\n}\n"}
{"INPUT": "@Test(groups=\"fast\") public void testLastBCDShouldNotBeBeforePreviousBCD() throws Exception {\n  final LocalDate start=new LocalDate(\"2012-07-16\");\n// bug_start\n  final LocalDate previousBCD=new LocalDate(\"2012-08-15\");\n// bug_end\n  final int bcdLocal=15;\n  final BillingIntervalDetail billingIntervalDetail=new BillingIntervalDetail(start,null,start,bcdLocal,BillingPeriod.MONTHLY);\n  final LocalDate lastBCD=billingIntervalDetail.getLastBillingCycleDate();\n  Assert.assertEquals(lastBCD,new LocalDate(\"2012-08-15\"));\n}\n"}
{"INPUT": "public FakeJobInProgress(JobConf jobConf,FakeTaskTrackerManager taskTrackerManager,JobTracker jt) throws IOException {\n  super(new JobID(\"test\",++jobCounter),jobConf,jt);\n  this.taskTrackerManager=taskTrackerManager;\n  this.startTime=System.currentTimeMillis();\n// bug_start\n  this.status=new JobStatus(getJobID(),0f,0f,JobStatus.PREP);\n// bug_end\n  this.status.setJobPriority(JobPriority.NORMAL);\n  this.status.setStartTime(startTime);\n}\n"}
{"INPUT": "@Before public void setup() throws IOException {\n  conf=new HdfsConfiguration();\n  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,blockSize);\n  conf.setLong(HdfsClientConfigKeys.DFS_CLIENT_SOCKET_TIMEOUT_KEY,60000L);\n// bug_start\n  conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_CONSIDERLOAD_KEY,false);\n// bug_end\n  conf.setInt(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,1);\n  conf.setInt(DFSConfigKeys.DFS_NAMENODE_REPLICATION_MAX_STREAMS_KEY,0);\n  final int numDNs=dataBlocks + parityBlocks;\n  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDNs).build();\n  cluster.waitActive();\n  dfs=cluster.getFileSystem();\n  dfs.enableErasureCodingPolicy(ecPolicy.getName());\n  dfs.mkdirs(dir);\n  dfs.setErasureCodingPolicy(dir,ecPolicy.getName());\n}\n"}
{"INPUT": "@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {\n  Class<?> iface=proxy.getClass().getInterfaces()[0];\n  ConfigGroup group=iface.getAnnotation(ConfigGroup.class);\n  ConfigItem item=method.getAnnotation(ConfigItem.class);\n  if (group == null) {\n    logger.warn(\"Configuration proxy class {} has no @ConfigGroup!\",proxy.getClass());\n    return null;\n  }\n  if (item == null) {\n    logger.warn(\"Configuration method {} has no @ConfigItem!\",method);\n    return null;\n  }\n  if (args == null) {\n    String value=manager.getConfiguration(group.keyName(),item.keyName());\n    if (value == null) {\n      if (method.isDefault()) {\n        return callDefaultMethod(proxy,method,args);\n      }\n      return null;\n    }\n    Class<?> returnType=method.getReturnType();\n    Object objectValue=ConfigManager.stringToObject(value,returnType);\n// bug_start\n    if (!objectValue.getClass().equals(returnType)) {\n      logger.warn(\"Unable to convert return type for configuration item {}.{}: {}\",group.keyName(),item.keyName(),returnType);\n      return null;\n    }\n// bug_end\n    return objectValue;\n  }\n else {\n    if (args.length != 1) {\n      throw new RuntimeException(\"Invalid number of arguents to configuration method\");\n    }\n    Object newValue=args[0];\n    if (method.isDefault()) {\n      Object defaultValue=callDefaultMethod(proxy,method,args);\n      if (Objects.equal(newValue,defaultValue)) {\n        manager.unsetConfiguration(group.keyName(),item.keyName());\n        return null;\n      }\n    }\n    manager.setConfiguration(group.keyName(),item.keyName(),args[0].toString());\n    return null;\n  }\n}\n"}
{"INPUT": "private static void apply(Paint paint,int style){\n  int oldStyle;\n  Typeface old=paint.getTypeface();\n  if (old == null) {\n    oldStyle=0;\n  }\n else {\n    oldStyle=old.getStyle();\n  }\n  int want=oldStyle | style;\n  Typeface tf;\n  if (old == null) {\n    tf=Typeface.defaultFromStyle(want);\n  }\n else {\n    tf=Typeface.create(old,want);\n  }\n  int fake=want & ~tf.getStyle();\n// bug_start\n  fake|=tf.getStyle() & Typeface.BOLD;\n// bug_end\n  if ((fake & Typeface.BOLD) != 0) {\n    paint.setFakeBoldText(true);\n  }\n  if ((fake & Typeface.ITALIC) != 0) {\n    paint.setTextSkewX(-0.25f);\n  }\n  paint.setTypeface(tf);\n}\n"}
{"INPUT": "private static void assertContent(String result,String expected,boolean verifyValues){\n  assertNotNull(result);\n  assertNotNull(expected);\n  try {\n    XContentParser resultParser=XContentFactory.xContent(result).createParser(result);\n    XContentParser expectedParser=XContentFactory.xContent(expected).createParser(expected);\n    while (true) {\n      XContentParser.Token token1=resultParser.nextToken();\n      XContentParser.Token token2=expectedParser.nextToken();\n      if (token1 == null) {\n        assertThat(token2,nullValue());\n        return;\n      }\n      assertThat(token1,Matchers.equalTo(token2));\nswitch (token1) {\ncase FIELD_NAME:\n        assertThat(\"field name for property '\" + resultParser.currentName() + \"' must be identical\",resultParser.currentName(),Matchers.equalTo(expectedParser.currentName()));\n      break;\ncase VALUE_STRING:\n    if (verifyValues) {\n      assertThat(\"string value for property '\" + resultParser.currentName() + \"' must be identical\",resultParser.text(),Matchers.equalTo(expectedParser.text()));\n    }\n else {\n      assertThat(\"string value for property '\" + resultParser.currentName() + \"' must be empty or non empty\",Strings.hasLength(resultParser.text()),Matchers.equalTo(Strings.hasLength(expectedParser.text())));\n    }\n  break;\ncase VALUE_NUMBER:\n// bug_start\nassertThat(\"numeric type for property '\" + resultParser.currentName() + \"' must be identical\",resultParser.numberType(),Matchers.equalTo(expectedParser.numberType()));\n// bug_end\nif (verifyValues) {\n// bug_start\nassertThat(\"numeric value for property '\" + resultParser.currentName() + \"' must be identical\",resultParser.numberValue(),Matchers.equalTo(expectedParser.numberValue()));\n// bug_end\n}\nbreak;\n}\n}\n}\n catch (Exception e) {\nfail(\"Fail to verify the result of the renderer: \" + e.getMessage());\n}\n}\n"}
{"INPUT": "@Override public void run(){\n  ctx.markSegmented();\n// bug_start\n  System.out.println(\"Stopping grid on segmentation: \" + ctx.gridName());\n// bug_end\n  G.stop(ctx.gridName(),true);\n}\n"}
{"INPUT": "@Override public void setMaxThreads(int num){\n// bug_start\n  try {\n    mkl_rt.MKL_Set_Num_Threads(num);\n    mkl_rt.MKL_Set_Num_Threads_Local(num);\n  }\n catch (  UnsatisfiedLinkError e) {\n    log.trace(\"Could not load MKL\",e);\n  }\ncatch (  NoClassDefFoundError e) {\n    log.trace(\"Could not load MKL\",e);\n  }\n// bug_end\n  blas_set_num_threads(num);\n}\n"}
{"INPUT": "@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n  Log.i(TAG_NAME,\"onMeasure\");\n  int width=defaultStepIndicatorNum;\n  mHeight=0;\n  if (mStepNum > 0) {\n    mHeight=(int)(getPaddingTop() + getPaddingBottom() + mCircleRadius * 2 * mStepNum + (mStepNum - 1) * mLinePadding);\n  }\n  if (MeasureSpec.UNSPECIFIED != MeasureSpec.getMode(widthMeasureSpec)) {\n    width=Math.min(width,MeasureSpec.getSize(widthMeasureSpec));\n  }\n// bug_start\n  if (MeasureSpec.UNSPECIFIED != MeasureSpec.getMode(heightMeasureSpec)) {\n    mHeight=MeasureSpec.getSize(heightMeasureSpec);\n  }\n// bug_end\n  setMeasuredDimension(width,mHeight);\n}\n"}
{"INPUT": "private void addAndSendApplicationBundles(){\n  for (  ComponentInfo component : getRoot().getDeployState().getApplicationPackage().getComponentsInfo(getRoot().getDeployState().getProperties().vespaVersion())) {\n    FileReference reference=FileSender.sendFileToServices(component.getPathRelativeToAppDir(),containers);\n// bug_start\n    System.out.println(\"Adding app bundle \" + component + \", reference \"+ reference);\n// bug_end\n    applicationBundles.add(reference);\n  }\n}\n"}
{"INPUT": "public void testProvider() throws Exception {\n  YahooProvider yahooProvider=new YahooProvider();\n  yahooProvider.setKey(PrivateData.get(\"yahoo.key\"));\n  yahooProvider.setSecret(PrivateData.get(\"yahoo.secret\"));\n  yahooProvider.setCallbackUrl(PrivateData.get(\"callbackUrl\"));\n// bug_start\n  yahooProvider.setName(\"testYahoo\");\n// bug_end\n  yahooProvider.init();\n  SingleUserSession testSession=new SingleUserSession();\n  String authorizationUrl=yahooProvider.getAuthorizationUrl(testSession);\n  logger.debug(\"authorizationUrl : {}\",authorizationUrl);\n  WebClient webClient=WebHelper.newClient();\n  HtmlPage loginPage=webClient.getPage(authorizationUrl);\n  HtmlForm form=loginPage.getFormByName(\"login_form\");\n  HtmlTextInput login=form.getInputByName(\"login\");\n  login.setValueAttribute(PrivateData.get(\"yahoo.login\"));\n  HtmlPasswordInput passwd=form.getInputByName(\"passwd\");\n  passwd.setValueAttribute(PrivateData.get(\"yahoo.password\"));\n  HtmlSubmitInput submit=form.getInputByName(\".save\");\n  HtmlPage confirmPage=submit.click();\n  form=confirmPage.getFormByName(\"rcForm\");\n  submit=form.getInputByName(\"agree\");\n  HtmlPage callbackPage=submit.click();\n  String callbackUrl=callbackPage.getUrl().toString();\n  logger.debug(\"callbackUrl : {}\",callbackUrl);\n  OAuthCredential credential=yahooProvider.extractCredentialFromParameters(WebHelper.extractParametersFromUrl(callbackUrl));\n  Token accessToken=yahooProvider.getAccessToken(testSession,credential);\n  logger.debug(\"accessToken : {}\",accessToken);\n  UserProfile userProfile=yahooProvider.getUserProfile(accessToken);\n  logger.debug(\"userProfile : {}\",userProfile);\n  assertEquals(PrivateData.get(\"yahoo.id\"),userProfile.getId());\n  assertEquals(PrivateData.get(\"yahoo.attributeValue1\"),userProfile.getAttributes().get(PrivateData.get(\"yahoo.attributeName1\")));\n  assertEquals(PrivateData.get(\"yahoo.nbAttributes\"),\"\" + userProfile.getAttributes().size());\n}\n"}
{"INPUT": "private void buildSimpleJobSettings(final String jobName,final JobSettings result,final LiteJobConfiguration liteJobConfig){\n  result.setJobName(jobName);\n  result.setJobType(liteJobConfig.getTypeConfig().getJobType().name());\n// bug_start\n  result.setJobClass(liteJobConfig.getTypeConfig().getJobClass());\n// bug_end\n  result.setShardingTotalCount(liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount());\n  result.setCron(liteJobConfig.getTypeConfig().getCoreConfig().getCron());\n  result.setShardingItemParameters(liteJobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters());\n  result.setJobParameter(liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter());\n  result.setMonitorExecution(liteJobConfig.isMonitorExecution());\n  result.setMaxTimeDiffSeconds(liteJobConfig.getMaxTimeDiffSeconds());\n  result.setMonitorPort(liteJobConfig.getMonitorPort());\n  result.setFailover(liteJobConfig.getTypeConfig().getCoreConfig().isFailover());\n  result.setMisfire(liteJobConfig.getTypeConfig().getCoreConfig().isMisfire());\n  result.setJobShardingStrategyClass(liteJobConfig.getJobShardingStrategyClass());\n  result.setDescription(liteJobConfig.getTypeConfig().getCoreConfig().getDescription());\n  result.setReconcileIntervalMinutes(liteJobConfig.getReconcileIntervalMinutes());\n  result.getJobProperties().put(JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER.getKey(),liteJobConfig.getTypeConfig().getCoreConfig().getJobProperties().get(JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER));\n  result.getJobProperties().put(JobPropertiesEnum.JOB_EXCEPTION_HANDLER.getKey(),liteJobConfig.getTypeConfig().getCoreConfig().getJobProperties().get(JobPropertiesEnum.JOB_EXCEPTION_HANDLER));\n}\n"}
{"INPUT": "@RequestMapping(value=\"/transactionList\",method=RequestMethod.GET) public String getBusinessTransactionsData(Model model,HttpServletResponse response,@RequestParam(\"application\") String applicationName,@RequestParam(\"from\") long from,@RequestParam(\"to\") long to,@RequestParam(value=\"filter\",required=false) String filterText){\n  Set<TraceId> traceIdList=flow.selectTraceIdsFromApplicationTraceIndex(applicationName,from,to);\n  Filter filter=FilterBuilder.build(filterText);\n  BusinessTransactions selectBusinessTransactions=flow.selectBusinessTransactions(traceIdList,applicationName,from,to,filter);\n  model.addAttribute(\"rpcList\",selectBusinessTransactions.getBusinessTransactionIterator());\n  model.addAttribute(\"requestList\",selectBusinessTransactions.getBusinessTransactionIterator());\n  model.addAttribute(\"scatterList\",selectBusinessTransactions.getBusinessTransactionIterator());\n  model.addAttribute(\"applicationName\",applicationName);\n  model.addAttribute(\"from\",new Date(from));\n  model.addAttribute(\"to\",new Date(to));\n  model.addAttribute(\"urlCount\",selectBusinessTransactions.getURLCount());\n  model.addAttribute(\"totalCount\",selectBusinessTransactions.getTotalCallCount());\n  model.addAttribute(\"filterText\",filterText);\n  model.addAttribute(\"filter\",filter);\n// bug_start\n  addResponseHeader(response);\n// bug_end\n  return \"transactionList\";\n}\n"}
{"INPUT": "@Override public ResultSet getResultSet() throws SQLException {\n  if (null != currentResultSet) {\n    return currentResultSet;\n  }\n  if (1 == preparedStatementExecutor.getStatements().size() && routeResult.getSqlStatement() instanceof DQLStatement) {\n    currentResultSet=preparedStatementExecutor.getStatements().iterator().next().getResultSet();\n    return currentResultSet;\n  }\n  List<ResultSet> resultSets=new ArrayList<>(preparedStatementExecutor.getStatements().size());\n  List<QueryResult> queryResults=new ArrayList<>(preparedStatementExecutor.getStatements().size());\n  for (  Statement each : preparedStatementExecutor.getStatements()) {\n    ResultSet resultSet=each.getResultSet();\n    resultSets.add(resultSet);\n    ShardingRule shardingRule=connection.getShardingContext().getShardingRule();\n// bug_start\n    queryResults.add(new StreamQueryResult(resultSet,shardingRule.getAllActualTableNames(),shardingRule.getShardingEncryptorEngine()));\n// bug_end\n  }\n  if (routeResult.getSqlStatement() instanceof SelectStatement || routeResult.getSqlStatement() instanceof DALStatement) {\n    MergeEngine mergeEngine=MergeEngineFactory.newInstance(connection.getShardingContext().getDatabaseType(),connection.getShardingContext().getShardingRule(),routeResult.getSqlStatement(),connection.getShardingContext().getMetaData().getTable(),queryResults);\n    currentResultSet=getCurrentResultSet(resultSets,mergeEngine);\n  }\n  return currentResultSet;\n}\n"}
{"INPUT": "public synchronized QueryResults getNextResults(UriInfo uriInfo,Duration maxWaitTime) throws InterruptedException {\n  Iterable<List<Object>> data=getData(maxWaitTime);\n  QueryInfo queryInfo=queryManager.getQueryInfo(queryId);\n  queryManager.recordHeartbeat(queryId);\n  if (exchangeClient.isClosed() && !queryInfo.getState().isDone()) {\n    queryManager.waitForStateChange(queryId,queryInfo.getState(),maxWaitTime);\n    queryInfo=queryManager.getQueryInfo(queryId);\n  }\n  if ((data != null) && (queryInfo.getUpdateType() != null) && (updateCount == null)&& (columns.size() == 1)&& (columns.get(0).getType().equals(StandardTypes.BIGINT))) {\n    Iterator<List<Object>> iterator=data.iterator();\n    if (iterator.hasNext()) {\n      Number number=(Number)iterator.next().get(0);\n      if (number != null) {\n        updateCount=number.longValue();\n      }\n    }\n  }\n  if (queryInfo.getState().isDone()) {\n    if (queryInfo.getState() != QueryState.FINISHED) {\n      exchangeClient.close();\n    }\n else     if (queryInfo.getOutputStage() == null) {\n      exchangeClient.close();\n// bug_start\n      columns=ImmutableList.of(new Column(\"result\",\"boolean\",new ClientTypeSignature(StandardTypes.BOOLEAN,ImmutableList.<ClientTypeSignature>of(),ImmutableList.of())));\n// bug_end\n      data=ImmutableSet.<List<Object>>of(ImmutableList.<Object>of(true));\n    }\n  }\n  URI nextResultsUri=null;\n  if ((!queryInfo.getState().isDone()) || (!exchangeClient.isClosed())) {\n    nextResultsUri=createNextResultsUri(uriInfo);\n  }\n  setSessionProperties=queryInfo.getSetSessionProperties();\n  resetSessionProperties=queryInfo.getResetSessionProperties();\n  startedTransactionId=queryInfo.getStartedTransactionId();\n  clearTransactionId=queryInfo.isClearTransactionId();\n  QueryResults queryResults=new QueryResults(queryId.toString(),uriInfo.getRequestUriBuilder().replaceQuery(\"\").replacePath(queryInfo.getSelf().getPath()).build(),findCancelableLeafStage(queryInfo),nextResultsUri,columns,data,toStatementStats(queryInfo),toQueryError(queryInfo),queryInfo.getUpdateType(),updateCount);\n  if (lastResult != null && lastResult.getNextUri() != null) {\n    lastResultPath=lastResult.getNextUri().getPath();\n  }\n else {\n    lastResultPath=null;\n  }\n  lastResult=queryResults;\n  return queryResults;\n}\n"}
{"INPUT": "public static INDArray identity(INDArray ndArray,boolean dup){\n// bug_start\n  return exec(dup ? new Identity(ndArray,ndArray.dup()) : new Identity(ndArray));\n// bug_end\n}\n"}
{"INPUT": "@Override public int hashCode(){\n  int hashCode=ObjectUtils.nullSafeHashCode(this.type);\n// bug_start\n  hashCode=hashCode * 31 + ObjectUtils.nullSafeHashCode(this.variableResolver);\n// bug_end\n  hashCode=hashCode * 31 + ObjectUtils.nullSafeHashCode(this.componentType);\n  return hashCode;\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  final TextView txtResponse=(TextView)findViewById(R.id.txt_response);\n  application=(SampleApplication)getApplication();\n// bug_start\n  application.apolloClient().newCall(new FeedQuery(FeedQuery.Variables.builder().limit(10).type(FeedType.HOT).build())).enqueue(new ApolloCall.Callback<FeedQuery.Data>(){\n// bug_end\n    @Override public void onResponse(    @Nonnull Response<FeedQuery.Data> dataResponse){\n      final StringBuffer buffer=new StringBuffer();\n      for (      FeedQuery.Data.Feed feed : dataResponse.data().feed()) {\n        buffer.append(\"name:\" + feed.repository().fragments().repositoryFragment().name());\n        buffer.append(\" owner: \" + feed.repository().fragments().repositoryFragment().owner().login());\n        buffer.append(\" postedBy: \" + feed.postedBy().login());\n        buffer.append(\"\\n~~~~~~~~~~~\");\n        buffer.append(\"\\n\\n\");\n      }\n      MainActivity.this.runOnUiThread(new Runnable(){\n        @Override public void run(){\n          txtResponse.setText(buffer.toString());\n        }\n      }\n);\n    }\n    @Override public void onFailure(    @Nonnull Exception e){\n      Log.e(TAG,e.getMessage(),e);\n    }\n  }\n);\n}\n"}
{"INPUT": "@Override public void onItemSelected(Presenter.ViewHolder itemViewHolder,Object item,RowPresenter.ViewHolder rowViewHolder,Row row){\n// bug_start\n  Log.i(TAG,\"onItemSelected: \" + item + \" row \"+ row.getHeaderItem().getName()+ \" \"+ rowViewHolder+ \" \"+ ((ListRowPresenter.ViewHolder)rowViewHolder).getGridView());\n// bug_end\n}\n"}
{"INPUT": "public static ExampleTrainingResult runExample(String[] args) throws IOException, ParseException {\n  Arguments arguments=Arguments.parseArgs(args);\n  Block block=new Mlp(28,28);\n  try (Model model=Model.newInstance()){\n    model.setBlock(block);\n    RandomAccessDataset trainingSet=getDataset(Dataset.Usage.TRAIN,arguments);\n    RandomAccessDataset validateSet=getDataset(Dataset.Usage.TEST,arguments);\n    DefaultTrainingConfig config=setupTrainingConfig(arguments);\n    config.addTrainingListeners(TrainingListener.Defaults.logging(arguments.getBatchSize(),(int)trainingSet.getNumIterations(),(int)validateSet.getNumIterations(),arguments.getOutputDir()));\n    ExampleTrainingResult result;\n    try (Trainer trainer=model.newTrainer(config)){\n      trainer.setMetrics(new Metrics());\n// bug_start\n      Shape inputShape=new Shape(1,28 * 28);\n// bug_end\n      trainer.initialize(inputShape);\n      TrainingUtils.fit(trainer,arguments.getEpoch(),trainingSet,validateSet,arguments.getOutputDir(),\"mlp\");\n      result=new ExampleTrainingResult(trainer);\n    }\n     model.save(Paths.get(arguments.getOutputDir()),\"mlp\");\n    return result;\n  }\n }\n"}
{"INPUT": "@Override protected List<? extends Module> getModules(){\n  return ImmutableList.<Module>of(new Module(){\n    @Override public void configure(    Binder binder){\n      binder.bindConstant().annotatedWith(Names.named(\"serviceName\")).to(\"druid/middlemanager\");\n      binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8091);\n// bug_start\n// bug_end\n      IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n      JsonConfigProvider.bind(binder,\"druid.indexer.task\",TaskConfig.class);\n      JsonConfigProvider.bind(binder,\"druid.worker\",WorkerConfig.class);\n      binder.bind(TaskRunner.class).to(ForkingTaskRunner.class);\n      binder.bind(ForkingTaskRunner.class).in(LazySingleton.class);\n      binder.bind(ChatHandlerProvider.class).toProvider(Providers.<ChatHandlerProvider>of(null));\n      binder.bind(WorkerTaskMonitor.class).in(ManageLifecycle.class);\n      binder.bind(WorkerCuratorCoordinator.class).in(ManageLifecycle.class);\n      LifecycleModule.register(binder,WorkerTaskMonitor.class);\n      binder.bind(JettyServerInitializer.class).toInstance(new MiddleManagerJettyServerInitializer());\n      Jerseys.addResource(binder,WorkerResource.class);\n      LifecycleModule.register(binder,Server.class);\n    }\n    @Provides @LazySingleton public Worker getWorker(    @Self DruidNode node,    WorkerConfig config){\n// bug_start\n      return new Worker(node.getHostAndPort(),config.getIp(),config.getCapacity(),config.getVersion());\n// bug_end\n    }\n  }\n,new IndexingServiceFirehoseModule(),new IndexingServiceTaskLogsModule());\n}\n"}
{"INPUT": "private static Configuration createNetworkBufferConfiguration(){\n  final Configuration configuration=new Configuration();\n  final int memorySegmentSizeKb=32;\n// bug_start\n  final MemorySize networkBuffersMemory=MemorySize.parse(memorySegmentSizeKb * (NUM_TASKS + 2) + \"kb\");\n// bug_end\n  configuration.set(TaskManagerOptions.MEMORY_SEGMENT_SIZE,MemorySize.parse(memorySegmentSizeKb + \"kb\"));\n  configuration.set(TaskManagerOptions.NETWORK_MEMORY_MIN,networkBuffersMemory);\n  configuration.set(TaskManagerOptions.NETWORK_MEMORY_MAX,networkBuffersMemory);\n  return configuration;\n}\n"}
{"INPUT": "private List<DependencyReport> fetchReport(Collection<String> domains){\n  long current=System.currentTimeMillis();\n  long currentHour=current - current % TimeUtil.ONE_HOUR;\n  List<DependencyReport> reports=new ArrayList<DependencyReport>();\n  Transaction t=Cat.newTransaction(DEPENDENCY,\"FetchReport\");\n  try {\n    for (    String temp : domains) {\n      try {\n// bug_start\n        ModelRequest request=new ModelRequest(temp,ModelPeriod.CURRENT).setProperty(\"date\",String.valueOf(currentHour));\n// bug_end\n        if (m_service.isEligable(request)) {\n          ModelResponse<DependencyReport> response=m_service.invoke(request);\n          DependencyReport report=response.getModel();\n          if (report != null) {\n            reports.add(report);\n          }\n        }\n else {\n          m_logger.warn(String.format(\"Can't get dependency report of %s\",temp));\n        }\n      }\n catch (      Exception e) {\n        Cat.logError(e);\n      }\n    }\n    t.setStatus(Message.SUCCESS);\n  }\n catch (  Exception e) {\n    t.setStatus(e);\n  }\n finally {\n    t.complete();\n  }\n  return reports;\n}\n"}
{"INPUT": "public Path getTestJsonPathTargetCache(PackageID moduleID){\n  try {\n    Files.createDirectories(targetTestJsonCacheDir);\nswitch (this.getSourceType()) {\ncase SINGLE_MODULE:\ncase ALL_MODULES:\n      return Files.createDirectories(targetTestJsonCacheDir.resolve(moduleID.orgName.value).resolve(moduleID.name.value).resolve(moduleID.version.value));\ndefault :\n    return targetTestJsonCacheDir;\n}\n}\n catch (IOException e) {\n// bug_start\nthrow new BLangCompilerException(\"error creating test_json_cache dir for module(s): \" + targetTestJsonCacheDir);\n// bug_end\n}\n}\n"}
{"INPUT": "public static WeightInit mapWeightInitialization(String kerasInit) throws UnsupportedKerasConfigurationException {\n  WeightInit init=WeightInit.XAVIER;\n  if (kerasInit != null) {\nswitch (kerasInit) {\ncase INIT_GLOROT_NORMAL:\n      init=WeightInit.XAVIER;\n    break;\ncase INIT_GLOROT_UNIFORM:\n  init=WeightInit.XAVIER_UNIFORM;\nbreak;\ncase INIT_HE_NORMAL:\ninit=WeightInit.RELU;\nbreak;\ncase INIT_HE_UNIFORM:\ninit=WeightInit.RELU_UNIFORM;\nbreak;\ncase INIT_ZERO:\ninit=WeightInit.ZERO;\nbreak;\ncase INIT_UNIFORM:\ncase INIT_NORMAL:\ncase INIT_IDENTITY:\ncase INIT_ORTHOGONAL:\ncase INIT_LECUN_UNIFORM:\ndefault :\n// bug_start\nthrow new UnsupportedKerasConfigurationException(\"Unknown keras weight initializer \" + init);\n// bug_end\n}\n}\nreturn init;\n}\n"}
{"INPUT": "private static void replaceWithTrappingNullCheck(AbstractDeoptimizeNode deopt,IfNode ifNode,LogicNode condition,DeoptimizationReason deoptimizationReason,long implicitNullCheckLimit,JavaConstant deoptReasonAndAction,JavaConstant deoptSpeculation){\n  DebugContext debug=deopt.getDebug();\n  StructuredGraph graph=deopt.graph();\n  counterTrappingNullCheck.increment(debug);\n  if (deopt instanceof DynamicDeoptimizeNode) {\n    counterTrappingNullCheckDynamicDeoptimize.increment(debug);\n  }\n  if (deoptimizationReason == DeoptimizationReason.UnreachedCode) {\n    counterTrappingNullCheckUnreached.increment(debug);\n  }\n  IsNullNode isNullNode=(IsNullNode)condition;\n  AbstractBeginNode nonTrappingContinuation=ifNode.falseSuccessor();\n  AbstractBeginNode trappingContinuation=ifNode.trueSuccessor();\n  DeoptimizingFixedWithNextNode trappingNullCheck=null;\n  FixedNode nextNonTrapping=nonTrappingContinuation.next();\n  ValueNode value=isNullNode.getValue();\n  if (OptImplicitNullChecks.getValue(graph.getOptions()) && implicitNullCheckLimit > 0) {\n    if (nextNonTrapping instanceof FixedAccessNode) {\n      FixedAccessNode fixedAccessNode=(FixedAccessNode)nextNonTrapping;\n      if (fixedAccessNode.canNullCheck()) {\n        AddressNode address=fixedAccessNode.getAddress();\n        ValueNode base=address.getBase();\n        ValueNode index=address.getIndex();\n        if (base != null && base instanceof CompressionNode) {\n          base=((CompressionNode)base).getValue();\n        }\n        if (index != null && index instanceof CompressionNode) {\n          index=((CompressionNode)index).getValue();\n        }\n        if (((base == value && index == null) || (base == null && index == value)) && address.getMaxConstantDisplacement() < implicitNullCheckLimit) {\n          fixedAccessNode.setStateBefore(deopt.stateBefore());\n          fixedAccessNode.setNullCheck(true);\n          fixedAccessNode.setImplicitDeoptimization(deoptReasonAndAction,deoptSpeculation);\n          graph.removeSplit(ifNode,nonTrappingContinuation);\n          trappingNullCheck=fixedAccessNode;\n          counterTrappingNullCheckExistingRead.increment(debug);\n          debug.log(\"Added implicit null check to %s\",fixedAccessNode);\n        }\n      }\n    }\n  }\n  if (trappingNullCheck == null) {\n// bug_start\n    trappingNullCheck=graph.add(new NullCheckNode(value,deoptReasonAndAction,deoptSpeculation));\n// bug_end\n    graph.replaceSplit(ifNode,trappingNullCheck,nonTrappingContinuation);\n    debug.log(\"Inserted NullCheckNode %s\",trappingNullCheck);\n  }\n  trappingNullCheck.setStateBefore(deopt.stateBefore());\n  nonTrappingContinuation.replaceAtUsages(trappingNullCheck,InputType.Guard);\n  if (nonTrappingContinuation instanceof BeginNode) {\n    GraphUtil.unlinkFixedNode(nonTrappingContinuation);\n    nonTrappingContinuation.safeDelete();\n  }\n  GraphUtil.killCFG(trappingContinuation);\n  GraphUtil.tryKillUnused(isNullNode);\n}\n"}
{"INPUT": "@Override public void onBindViewHolder(final ViewHolder holder,int position){\n  final Actress actress=getItems().get(position);\n  holder.parse(actress);\n  holder.mLayout.setOnClickListener(new ActressClickListener(actress,mParentActivity));\n  holder.mLayout.setOnLongClickListener(new ActressLongClickListener(actress,mParentActivity));\n  holder.mImage.setImageDrawable(null);\n// bug_start\n  Glide.with(holder.mImage.getContext()).load(actress.getImageUrl()).placeholder(R.drawable.ic_movie_actresses).diskCacheStrategy(SOURCE).skipMemoryCache(true).transform(new SquareTopCrop(holder.mImage.getContext())).dontAnimate().into(holder.mImage);\n// bug_end\n}\n"}
{"INPUT": "@Test public void should_assert_bytes_contains_in_hexadecimal(){\n// bug_start\n  thrown.expectMessage(\"Expecting:%n\" + \" <[0x02, 0x03]>%n\" + \"to contain:%n\"+ \" <[0x01]>%n\"+ \"but could not find:%n\"+ \" <[0x01]>\");\n// bug_end\n  assertThat(new byte[]{2,3}).inHexadecimal().contains(new byte[]{1});\n}\n"}
{"INPUT": "@Test public void test(){\nclass Highlight {\n  }\n  final Object codeSpan=new Object();\n  final SyntaxHighlight highlight=new SyntaxHighlight(){\n    @NonNull @Override public CharSequence highlight(    @Nullable String info,    @NonNull String code){\n      final SpannableStringBuilder builder=new SpannableStringBuilder(code);\n      for (int i=0, length=code.length(); i < length; i++) {\n        builder.setSpan(new Highlight(),i,i + 1,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n      }\n      return builder;\n    }\n  }\n;\n  final MarkwonSpansFactory spansFactory=mock(MarkwonSpansFactory.class);\n// bug_start\n  when(spansFactory.get(any(FencedCodeBlock.class))).thenReturn(new SpanFactory(){\n// bug_end\n    @Override public Object getSpans(    @NonNull MarkwonConfiguration configuration,    @NonNull RenderProps props){\n      return codeSpan;\n    }\n  }\n);\n  final MarkwonConfiguration configuration=MarkwonConfiguration.builder().syntaxHighlight(highlight).build(mock(MarkwonTheme.class),mock(AsyncDrawableLoader.class),spansFactory);\n  final Map<Class<? extends Node>,MarkwonVisitor.NodeVisitor<? extends Node>> visitorMap=Collections.emptyMap();\n  final MarkwonVisitor visitor=new AbstractMarkwonVisitorImpl(configuration,mock(RenderProps.class),new SpannableBuilder(),visitorMap);\n  final SpannableBuilder builder=visitor.builder();\n  append(builder,\"# Header 1\\n\",new Object());\n  append(builder,\"## Header 2\\n\",new Object());\n  append(builder,\"### Header 3\\n\",new Object());\n  final int start=builder.length();\n  final FencedCodeBlock fencedCodeBlock=new FencedCodeBlock();\n  fencedCodeBlock.setLiteral(\"{code}\");\n  CorePluginBridge.visitCodeBlock(visitor,null,fencedCodeBlock.getLiteral(),fencedCodeBlock);\n  final int end=builder.length();\n  append(builder,\"### Footer 3\\n\",new Object());\n  append(builder,\"## Footer 2\\n\",new Object());\n  append(builder,\"# Footer 1\\n\",new Object());\n  final Object[] spans=builder.spannableStringBuilder().getSpans(start,end,Object.class);\n  final int length=fencedCodeBlock.getLiteral().length() + 1;\n  assertEquals(Arrays.toString(spans),length,spans.length);\n  assertEquals(codeSpan,spans[0]);\n  for (int i=1; i < length; i++) {\n    assertTrue(spans[i] instanceof Highlight);\n  }\n}\n"}
{"INPUT": "private void performRecoveryOperation(Engine engine,Translog.Operation operation,boolean allowMappingUpdates,Engine.Operation.Origin origin){\n  try {\nswitch (operation.opType()) {\ncase INDEX:\n      Translog.Index index=(Translog.Index)operation;\n// bug_start\n    Engine.Index engineIndex=IndexShard.prepareIndex(docMapper(index.type()),source(shardId.getIndexName(),index.type(),index.id(),index.source()).routing(index.routing()).parent(index.parent()).timestamp(index.timestamp()).ttl(index.ttl()),index.seqNo(),index.version(),index.versionType().versionTypeForReplicationAndRecovery(),origin,index.getAutoGeneratedIdTimestamp(),true);\n// bug_end\n  maybeAddMappingUpdate(engineIndex.type(),engineIndex.parsedDoc().dynamicMappingsUpdate(),engineIndex.id(),allowMappingUpdates);\nif (logger.isTraceEnabled()) {\n  logger.trace(\"[translog] recover [index] op of [{}][{}]\",index.type(),index.id());\n}\nindex(engine,engineIndex);\nbreak;\ncase DELETE:\nTranslog.Delete delete=(Translog.Delete)operation;\nUid uid=Uid.createUid(delete.uid().text());\nif (logger.isTraceEnabled()) {\nlogger.trace(\"[translog] recover [delete] op of [{}][{}]\",uid.type(),uid.id());\n}\nfinal Engine.Delete engineDelete=new Engine.Delete(uid.type(),uid.id(),delete.uid(),delete.seqNo(),delete.version(),delete.versionType().versionTypeForReplicationAndRecovery(),origin,System.nanoTime());\ndelete(engine,engineDelete);\nbreak;\ndefault :\nthrow new IllegalStateException(\"No operation defined for [\" + operation + \"]\");\n}\n}\n catch (ElasticsearchException e) {\nboolean hasIgnoreOnRecoveryException=false;\nElasticsearchException current=e;\nwhile (true) {\nif (current instanceof IgnoreOnRecoveryEngineException) {\nhasIgnoreOnRecoveryException=true;\nbreak;\n}\nif (current.getCause() instanceof ElasticsearchException) {\ncurrent=(ElasticsearchException)current.getCause();\n}\n else {\nbreak;\n}\n}\nif (!hasIgnoreOnRecoveryException) {\nthrow e;\n}\n}\noperationProcessed();\n}\n"}
{"INPUT": "protected List<EnvVar> getExpectedEnvVars(){\n  List<EnvVar> expected=new ArrayList<>();\n  expected.add(new EnvVarBuilder().withName(KafkaConnectCluster.ENV_VAR_KAFKA_CONNECT_CONFIGURATION).withValue(expectedConfiguration.asPairs()).build());\n  expected.add(new EnvVarBuilder().withName(KafkaConnectCluster.ENV_VAR_KAFKA_CONNECT_METRICS_ENABLED).withValue(String.valueOf(true)).build());\n  expected.add(new EnvVarBuilder().withName(KafkaConnectCluster.ENV_VAR_KAFKA_CONNECT_BOOTSTRAP_SERVERS).withValue(bootstrapServers).build());\n// bug_start\n  expected.add(new EnvVarBuilder().withName(KafkaConnectCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(KafkaConnectCluster.DEFAULT_KAFKA_GC_LOG_ENABLED).build());\n// bug_end\n  expected.add(new EnvVarBuilder().withName(AbstractModel.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n  return expected;\n}\n"}
{"INPUT": "@Before public void startServers() throws Exception {\n  CLUSTER.getClusterControl().startAllServers();\n  CLUSTER.getClusterControl().waitForActive();\n  CLUSTER.getClusterControl().waitForRunningPassivesInStandby();\n// bug_start\n  final CacheManagerBuilder<PersistentCacheManager> clusteredCacheManagerBuilder=CacheManagerBuilder.newCacheManagerBuilder().with(ClusteringServiceConfigurationBuilder.cluster(CLUSTER.getConnectionURI().resolve(\"/crud-cm-replication\")).timeouts(TimeoutsBuilder.timeouts().read(Duration.ofSeconds(20)).write(Duration.ofSeconds(20))).autoCreate().defaultServerResource(\"primary-server-resource\"));\n// bug_end\n  CACHE_MANAGER1=clusteredCacheManagerBuilder.build(true);\n  CACHE_MANAGER2=clusteredCacheManagerBuilder.build(true);\n  CacheConfiguration<Long,BlobValue> config=CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class,BlobValue.class,ResourcePoolsBuilder.newResourcePoolsBuilder().heap(500,EntryUnit.ENTRIES).with(ClusteredResourcePoolBuilder.clusteredDedicated(\"primary-server-resource\",4,MemoryUnit.MB))).add(ClusteredStoreConfigurationBuilder.withConsistency(cacheConsistency)).build();\n  CACHE1=CACHE_MANAGER1.createCache(\"clustered-cache\",config);\n  CACHE2=CACHE_MANAGER2.createCache(\"clustered-cache\",config);\n}\n"}
{"INPUT": "@Test public void testExtractColumnDefinitions() throws Exception {\n  XContentBuilder builder=XContentFactory.jsonBuilder().startObject().startObject(\"_meta\").field(\"primary_keys\",\"id\").endObject().startObject(\"properties\").startObject(\"id\").field(\"type\",\"integer\").field(\"index\",\"not_analyzed\").endObject().startObject(\"title\").field(\"type\",\"string\").field(\"index\",\"no\").endObject().startObject(\"datum\").field(\"type\",\"date\").endObject().startObject(\"content\").field(\"type\",\"string\").field(\"index\",\"analyzed\").field(\"analyzer\",\"standard\").endObject().startObject(\"person\").startObject(\"properties\").startObject(\"first_name\").field(\"type\",\"string\").field(\"index\",\"not_analyzed\").endObject().startObject(\"birthday\").field(\"type\",\"date\").field(\"index\",\"not_analyzed\").endObject().endObject().endObject().startObject(\"nested\").field(\"type\",\"nested\").startObject(\"properties\").startObject(\"inner_nested\").field(\"type\",\"date\").field(\"index\",\"not_analyzed\").endObject().endObject().endObject().endObject().endObject();\n  IndexMetaData metaData=getIndexMetaData(\"test1\",builder);\n  DocIndexMetaData md=newMeta(metaData,\"test1\");\n  assertEquals(6,md.columns().size());\n  assertEquals(14,md.references().size());\n  ImmutableList<ReferenceInfo> columns=ImmutableList.copyOf(md.columns());\n  assertThat(columns.get(0).ident().columnIdent().name(),is(\"content\"));\n  assertThat(columns.get(0).type(),is(DataType.STRING));\n  assertThat(columns.get(0).ident().tableIdent().name(),is(\"test1\"));\n  ImmutableList<ReferenceInfo> references=ImmutableList.<ReferenceInfo>copyOf(md.references().values());\n  ReferenceInfo birthday=md.references().get(new ColumnIdent(\"person\",\"birthday\"));\n  assertThat(birthday.type(),is(DataType.TIMESTAMP));\n  List<String> fqns=Lists.transform(references,new Function<ReferenceInfo,String>(){\n    @Nullable @Override public String apply(    @Nullable ReferenceInfo input){\n      return input.ident().columnIdent().fqn();\n    }\n  }\n);\n// bug_start\n  assertThat(fqns,Matchers.<List<String>>is(ImmutableList.of(\"content\",\"datum\",\"id\",\"nested\",\"nested.inner_nested\",\"person\",\"person.birthday\",\"person.first_name\",\"title\",\"_id\",\"_version\",\"_score\",\"_uid\",\"_source\")));\n// bug_end\n}\n"}
{"INPUT": "public jedd.internal.RelationContainer get(){\n  final jedd.internal.RelationContainer ret=new jedd.internal.RelationContainer(new Attribute[]{var.v(),obj.v()},new PhysicalDomain[]{V1.v(),H1.v()},(\"<soot.jimple.paddle.bdddomains.var:soot.jimple.paddle.bdddom\" + \"ains.V1, soot.jimple.paddle.bdddomains.obj:soot.jimple.paddl\" + \"e.bdddomains.H1> ret = jedd.internal.Jedd.v().falseBDD(); at\"+ \" /home/research/ccl/olhota/soot-trunk/src/soot/jimple/paddle\"+ \"/queue/Rvar_objIter.jedd:46,25-28\"),jedd.internal.Jedd.v().falseBDD());\n  while (r.hasNext()) {\n    ret.eqUnion(jedd.internal.Jedd.v().literal(new Object[]{r.next(),r.next()},new Attribute[]{var.v(),obj.v()},new PhysicalDomain[]{V1.v(),H1.v()}));\n  }\n// bug_start\n  return new jedd.internal.RelationContainer(new Attribute[]{obj.v(),var.v()},new PhysicalDomain[]{H1.v(),V1.v()},(\"return ret; at /home/research/ccl/olhota/soot-trunk/src/soot\" + \"/jimple/paddle/queue/Rvar_objIter.jedd:50,8-14\"),ret);\n// bug_end\n}\n"}
{"INPUT": "public void repairSurvivors(){\n  if (this.m_promotionResult.isCancelled()) {\n    repairLogger.debug(m_whoami + \"Skipping repair message creation for cancelled Term.\");\n    return;\n  }\n  int queued=0;\n  if (repairLogger.isDebugEnabled()) {\n    repairLogger.debug(m_whoami + \"received all repair logs and is repairing surviving replicas.\");\n  }\n  for (  Iv2RepairLogResponseMessage li : m_repairLogUnion) {\n    if (repairLogger.isDebugEnabled()) {\n      repairLogger.debug(m_whoami + \"RepairResponse:\\n\" + li);\n    }\n    List<Long> needsRepair=new ArrayList<Long>(5);\n    for (    Entry<Long,ReplicaRepairStruct> entry : m_replicaRepairStructs.entrySet()) {\n      if (entry.getValue().needs(li.getHandle())) {\n        ++queued;\n        if (repairLogger.isDebugEnabled()) {\n// bug_start\n          repairLogger.debug(m_whoami + \"repairing \" + CoreUtils.hsIdToString(entry.getKey())+ \". Max seen \"+ entry.getValue().m_maxSpHandleSeen+ \". Repairing with \"+ li.getHandle());\n// bug_end\n        }\n        needsRepair.add(entry.getKey());\n      }\n    }\n    if (!needsRepair.isEmpty()) {\n      if (repairLogger.isDebugEnabled()) {\n        repairLogger.debug(m_whoami + \"repairing: \" + CoreUtils.hsIdCollectionToString(needsRepair)+ \" with message: \"+ li.getPayload());\n      }\n      m_mailbox.repairReplicasWith(needsRepair,li.getPayload());\n    }\n  }\n  if (repairLogger.isDebugEnabled()) {\n    repairLogger.debug(m_whoami + \"finished queuing \" + queued+ \" replica repair messages.\");\n  }\n  m_promotionResult.set(new RepairResult(m_maxSeenTxnId));\n}\n"}
{"INPUT": "public void testSerialization() throws IOException {\n  int numLoadAverages=randomIntBetween(1,5);\n  double loadAverages[]=new double[numLoadAverages];\n  for (int i=0; i < loadAverages.length; i++) {\n    loadAverages[i]=randomDouble();\n  }\n  OsStats.Cpu cpu=new OsStats.Cpu(randomShort(),loadAverages);\n  OsStats.Mem mem=new OsStats.Mem(randomLong(),randomLong());\n  OsStats.Swap swap=new OsStats.Swap(randomLong(),randomLong());\n// bug_start\n  OsStats.Cgroup cgroup=new OsStats.Cgroup(randomAsciiOfLength(8),randomPositiveLong(),randomAsciiOfLength(8),randomPositiveLong(),randomPositiveLong(),new OsStats.Cgroup.CpuStat(randomPositiveLong(),randomPositiveLong(),randomPositiveLong()));\n// bug_end\n  OsStats osStats=new OsStats(System.currentTimeMillis(),cpu,mem,swap,cgroup);\n  try (BytesStreamOutput out=new BytesStreamOutput()){\n    osStats.writeTo(out);\n    try (StreamInput in=out.bytes().streamInput()){\n      OsStats deserializedOsStats=new OsStats(in);\n      assertEquals(osStats.getTimestamp(),deserializedOsStats.getTimestamp());\n      assertEquals(osStats.getCpu().getPercent(),deserializedOsStats.getCpu().getPercent());\n      assertArrayEquals(osStats.getCpu().getLoadAverage(),deserializedOsStats.getCpu().getLoadAverage(),0);\n      assertEquals(osStats.getMem().getFree(),deserializedOsStats.getMem().getFree());\n      assertEquals(osStats.getMem().getTotal(),deserializedOsStats.getMem().getTotal());\n      assertEquals(osStats.getSwap().getFree(),deserializedOsStats.getSwap().getFree());\n      assertEquals(osStats.getSwap().getTotal(),deserializedOsStats.getSwap().getTotal());\n      assertEquals(osStats.getCgroup().getCpuAcctControlGroup(),deserializedOsStats.getCgroup().getCpuAcctControlGroup());\n      assertEquals(osStats.getCgroup().getCpuAcctUsageNanos(),deserializedOsStats.getCgroup().getCpuAcctUsageNanos());\n      assertEquals(osStats.getCgroup().getCpuControlGroup(),deserializedOsStats.getCgroup().getCpuControlGroup());\n      assertEquals(osStats.getCgroup().getCpuCfsPeriodMicros(),deserializedOsStats.getCgroup().getCpuCfsPeriodMicros());\n      assertEquals(osStats.getCgroup().getCpuCfsQuotaMicros(),deserializedOsStats.getCgroup().getCpuCfsQuotaMicros());\n      assertEquals(osStats.getCgroup().getCpuStat().getNumberOfElapsedPeriods(),deserializedOsStats.getCgroup().getCpuStat().getNumberOfElapsedPeriods());\n      assertEquals(osStats.getCgroup().getCpuStat().getNumberOfTimesThrottled(),deserializedOsStats.getCgroup().getCpuStat().getNumberOfTimesThrottled());\n      assertEquals(osStats.getCgroup().getCpuStat().getTimeThrottledNanos(),deserializedOsStats.getCgroup().getCpuStat().getTimeThrottledNanos());\n    }\n   }\n }\n"}
{"INPUT": "private static void assign(Environment env,Location loc,Ident ident,Object result) throws EvalException, InterruptedException {\n  Preconditions.checkNotNull(result,\"trying to assign null to %s\",ident);\n  if (env.isSkylarkEnabled()) {\n    SkylarkEnvironment skylarkEnv=(SkylarkEnvironment)env;\n    if (skylarkEnv.hasBeenReadGlobalVariable(ident.getName())) {\n      throw new EvalException(loc,\"Variable '\" + ident.getName() + \"' is referenced before assignment.\"+ \"The variable is defined in the global scope.\");\n    }\n    Class<?> variableType=skylarkEnv.getVariableType(ident.getName());\n    Class<?> resultType=EvalUtils.getSkylarkType(result.getClass());\n    if (variableType != null && !variableType.equals(resultType) && !resultType.equals(Environment.NoneType.class) && !variableType.equals(Environment.NoneType.class)) {\n// bug_start\n      throw new EvalException(loc,String.format(\"Incompatible variable types, \" + \"trying to assign %s (type of %s) to variable %s which is already %s\",Printer.repr(result),EvalUtils.getDataTypeName(result),ident.getName(),EvalUtils.getDataTypeNameFromClass(variableType)));\n// bug_end\n    }\n  }\n  env.update(ident.getName(),result);\n}\n"}
{"INPUT": "@Configuration public static Option[] configure() throws Exception {\n// bug_start\n  Option[] options=combine(getDefaultCamelKarafOptions(),loadCamelFeatures(\"camel-blueprint\"),bundle(newBundle().add(\"OSGI-INF/blueprint/test.xml\",XsltBlueprintRouteTest.class.getResource(\"XsltBlueprintRouter.xml\")).add(\"transform.xsl\",XsltBlueprintRouteTest.class.getResource(\"transform.xsl\")).set(Constants.BUNDLE_SYMBOLICNAME,\"XsltBlueprintRouteTest\").build(withBnd())).noStart());\n// bug_end\n  return options;\n}\n"}
{"INPUT": "@Override public void run(){\n  if (!running) {\n    return;\n  }\n// bug_start\n  transportService.sendRequest(node,PingRequestHandler.ACTION,new PingRequest(node.id()),options().withPingType().withTimeout(pingRetryTimeout),new BaseTransportResponseHandler<PingResponse>(){\n// bug_end\n    @Override public PingResponse newInstance(){\n      return new PingResponse();\n    }\n    @Override public void handleResponse(    PingResponse response){\n      if (!running) {\n        return;\n      }\n      NodeFD nodeFD=nodesFD.get(node);\n      if (nodeFD != null) {\n        if (!nodeFD.running) {\n          return;\n        }\n        nodeFD.retryCount=0;\n        threadPool.schedule(pingInterval,ThreadPool.Names.SAME,SendPingRequest.this);\n      }\n    }\n    @Override public void handleException(    TransportException exp){\n      if (!running) {\n        return;\n      }\n      if (exp instanceof ConnectTransportException) {\n        return;\n      }\n      NodeFD nodeFD=nodesFD.get(node);\n      if (nodeFD != null) {\n        if (!nodeFD.running) {\n          return;\n        }\n        int retryCount=++nodeFD.retryCount;\n        logger.trace(\"[node  ] failed to ping [{}], retry [{}] out of [{}]\",exp,node,retryCount,pingRetryCount);\n        if (retryCount >= pingRetryCount) {\n          logger.debug(\"[node  ] failed to ping [{}], tried [{}] times, each with  maximum [{}] timeout\",node,pingRetryCount,pingRetryTimeout);\n          if (nodesFD.remove(node) != null) {\n            notifyNodeFailure(node,\"failed to ping, tried [\" + pingRetryCount + \"] times, each with maximum [\"+ pingRetryTimeout+ \"] timeout\");\n          }\n        }\n else {\n// bug_start\n          transportService.sendRequest(node,PingRequestHandler.ACTION,new PingRequest(node.id()),options().withPingType().withTimeout(pingRetryTimeout),this);\n// bug_end\n        }\n      }\n    }\n    @Override public String executor(){\n      return ThreadPool.Names.SAME;\n    }\n  }\n);\n}\n"}
{"INPUT": "public static ProtocolMapperModel toModel(ProtocolMapperRepresentation rep){\n  ProtocolMapperModel model=new ProtocolMapperModel();\n  model.setId(rep.getId());\n  model.setName(rep.getName());\n  model.setConsentRequired(rep.isConsentRequired());\n  model.setConsentText(rep.getConsentText());\n  model.setProtocol(rep.getProtocol());\n  model.setProtocolMapper(rep.getProtocolMapper());\n// bug_start\n  model.setConfig(rep.getConfig());\n// bug_end\n  return model;\n}\n"}
{"INPUT": "@Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus){\n// bug_start\n  eventStore.appendEvents(Arrays.asList(new GenericDomainEventMessage<>(\"id1\",0,\"Payload1\"),new GenericDomainEventMessage<>(\"id1\",1,\"Payload2\")));\n// bug_end\n}\n"}
{"INPUT": "@Override public void onSaveInstanceState(Bundle outState){\n// bug_start\n  outState.putParcelableArrayList(CHECKED_STATE_MAP,(ArrayList<? extends Parcelable>)expandableList.groups);\n// bug_end\n  super.onSaveInstanceState(outState);\n}\n"}
{"INPUT": "@Test void estimateSize(){\n// bug_start\n  assertThat(new StringCodec(LettuceCharsets.UTF8).estimateSize(teststring)).isEqualTo((int)(teststring.length() * 1.1));\n// bug_end\n  assertThat(new StringCodec(LettuceCharsets.ASCII).estimateSize(teststring)).isEqualTo(teststring.length());\n  assertThat(new StringCodec(StandardCharsets.ISO_8859_1).estimateSize(teststring)).isEqualTo(teststring.length());\n}\n"}
{"INPUT": "public void testMergeObjectAndNested() throws Exception {\n  DocumentMapper objectMapper=createDocumentMapper(mapping(null));\n// bug_start\n  DocumentMapper nestedMapper=createDocumentMapper(mapping(null));\n// bug_end\n  MergeReason reason=randomFrom(MergeReason.MAPPING_UPDATE,MergeReason.INDEX_TEMPLATE);\n{\n    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,null);\n    assertThat(e.getMessage(),containsString(\"cannot change object mapping from non-nested to nested\"));\n  }\n{\n    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,null);\n    assertThat(e.getMessage(),containsString(\"cannot change object mapping from nested to non-nested\"));\n  }\n}\n"}
{"INPUT": "NestedAggregator(String name,AggregatorFactories factories,ObjectMapper parentObjectMapper,ObjectMapper childObjectMapper,SearchContext context,Aggregator parent,CardinalityUpperBound cardinality,Map<String,Object> metadata) throws IOException {\n  super(name,factories,context,parent,cardinality,metadata);\n// bug_start\n  Query parentFilter=parentObjectMapper != null ? parentObjectMapper.nestedTypeFilter() : Queries.newNonNestedFilter(context.mapperService().getIndexSettings().getIndexVersionCreated());\n// bug_end\n  this.parentFilter=context.bitsetFilterCache().getBitSetProducer(parentFilter);\n  this.childFilter=childObjectMapper.nestedTypeFilter();\n  this.collectsFromSingleBucket=cardinality.map(null);\n}\n"}
{"INPUT": "private boolean secureUrls(String[] ldapUrls){\n  if (ldapUrls.length == 0) {\n    return true;\n  }\n  boolean allSecure=asList(ldapUrls).stream().allMatch(null);\n  boolean allClear=asList(ldapUrls).stream().allMatch(null);\n  if (!allSecure && !allClear) {\n// bug_start\n    throw new IllegalArgumentException(\"configured LDAP protocols are not all equal \" + \"(ldaps://.. and ldap://..): [\" + Strings.arrayToCommaDelimitedString(ldapUrls) + \"]\");\n// bug_end\n  }\n  return allSecure;\n}\n"}
{"INPUT": "@Override public void execute(){\n// bug_start\n  Lookup.getDefault().lookup(AttributeColumnsMergeStrategiesController.class).joinWithSeparatorMerge(table,columns,BigDecimal[].class,columnTitle,SEPARATOR);\n// bug_end\n}\n"}
{"INPUT": "private void unicast(String msg,URL url){\n  if (logger.isInfoEnabled()) {\n// bug_start\n    logger.info(\"Send unicast message: \" + msg + \" to \"+ url.getAddress());\n// bug_end\n  }\n  try {\n    byte[] data=(msg + \"\\n\").getBytes();\n    DatagramPacket hi=new DatagramPacket(data,data.length,InetAddress.getByName(url.getHost()),mutilcastSocket.getLocalPort());\n    mutilcastSocket.send(hi);\n  }\n catch (  Exception e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n}\n"}
{"INPUT": "public void testParseFromXContent() throws IOException {\n  final ElasticsearchException exception=new ElasticsearchException(\"test\");\n  final String nodesHeader=\"\\\"_nodes\\\": { \\\"total\\\": 2, \\\"successful\\\": 1, \\\"failed\\\": 1, \\\"failures\\\": [ \" + Strings.toString(exception) + \"] },\";\n  final String clusterName=\"\\\"cluster_name\\\": \\\"cn\\\",\";\n  try (XContentParser parser=JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\"{\" + nodesHeader + clusterName+ \"\\\"nodes\\\" : {} }\")){\n    ClearRolesCacheResponse response=ClearRolesCacheResponse.fromXContent(parser);\n    assertNotNull(response);\n    assertThat(response.getNodes(),empty());\n    assertThat(response.getClusterName(),equalTo(\"cn\"));\n    assertThat(response.getHeader().getSuccessful(),equalTo(1));\n    assertThat(response.getHeader().getFailed(),equalTo(1));\n    assertThat(response.getHeader().getTotal(),equalTo(2));\n    assertThat(response.getHeader().getFailures(),hasSize(1));\n    assertThat(response.getHeader().getFailures().get(0).getMessage(),containsString(\"reason=test\"));\n  }\n// bug_start\n   try (XContentParser parser=JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\"{\" + nodesHeader + clusterName+ \"\\\"nodes\\\" : { \"+ \"\\\"id1\\\": { \\\"name\\\": \\\"a\\\"}, \"+ \"\\\"id2\\\": { \\\"name\\\": \\\"b\\\"}\"+ \"}}\")){\n// bug_end\n    ClearRolesCacheResponse response=ClearRolesCacheResponse.fromXContent(parser);\n    assertNotNull(response);\n    assertThat(response.getNodes(),hasSize(2));\n    assertThat(response.getNodes().get(0).getId(),equalTo(\"id1\"));\n    assertThat(response.getNodes().get(0).getName(),equalTo(\"a\"));\n    assertThat(response.getNodes().get(1).getId(),equalTo(\"id2\"));\n    assertThat(response.getNodes().get(1).getName(),equalTo(\"b\"));\n  }\n }\n"}
{"INPUT": "public FrameworkTest(){\n// bug_start\n  this(System.getProperty(\"host\",\"0.0.0.0\"),8080,13,2 * (1 << 14),1 << 22,Integer.parseInt(System.getProperty(\"telemetry.port\",\"-1\")),\"tfb-database\",\"hello_world\",\"benchmarkdbuser\",\"benchmarkdbpass\");\n// bug_end\n}\n"}
{"INPUT": "@Override public void beforeMethod(EnhancedInstance objInst,Method method,Object[] allArguments,Class<?>[] argumentsTypes,MethodInterceptResult result) throws Throwable {\n  if (allArguments[0] instanceof HttpRequest) {\n    HttpRequest request=(HttpRequest)allArguments[0];\n    ContextCarrier contextCarrier=new ContextCarrier();\n    CarrierItem next=contextCarrier.items();\n    while (next.hasNext()) {\n      next=next.next();\n      next.setHeadValue(request.headers().get(next.getHeadKey()));\n      request.headers().remove(next.getHeadKey());\n    }\n// bug_start\n    AbstractSpan span=ContextManager.createEntrySpan(toPath(request.getUri()),contextCarrier);\n// bug_end\n    span.setComponent(ComponentsDefine.VERTX);\n    SpanLayer.asHttp(span);\n    Tags.HTTP.METHOD.set(span,request.getMethod().toString());\n    Tags.URL.set(span,request.getUri());\n    objInst.setSkyWalkingDynamicField(new VertxContext(ContextManager.capture(),span.prepareForAsync()));\n  }\n}\n"}
{"INPUT": "@Override protected FilterProcessor createFilterProcessor(RouteContext routeContext) throws Exception {\n  Processor childProcessor=this.createChildProcessor(routeContext,true);\n// bug_start\n  return new FilterProcessor(getExpression().createPredicate(routeContext),childProcessor);\n// bug_end\n}\n"}
{"INPUT": "public static void addMethods(ImmutableMap.Builder<String,Object> env,Object v){\n  Class<?> cls=v.getClass();\n  if (!SkylarkInterfaceUtils.hasSkylarkGlobalLibrary(cls) && SkylarkInterfaceUtils.getSkylarkModule(cls) == null) {\n    throw new IllegalArgumentException(cls.getName() + \" is annotated with neither @SkylarkGlobalLibrary nor @SkylarkModule\");\n  }\n  StarlarkSemantics semantics=StarlarkSemantics.DEFAULT_SEMANTICS;\n  for (  String name : CallUtils.getMethodNames(semantics,v.getClass())) {\n// bug_start\n    env.put(name,CallUtils.getBuiltinCallable(semantics,v,name));\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void beforeSendRequest(Invocation invocation,HttpServletRequestEx requestEx){\n  RestClientRequestImpl restClientRequest=(RestClientRequestImpl)invocation.getHandlerContext().get(RestConst.INVOCATION_HANDLER_REQUESTCLIENT);\n  OperationMeta operationMeta=invocation.getOperationMeta();\n  RestOperationMeta swaggerRestOperation=operationMeta.getExtData(RestConst.SWAGGER_REST_OPERATION);\n  try {\n// bug_start\n    RestCodec.argsToRest(invocation.getArguments(),swaggerRestOperation,restClientRequest);\n// bug_end\n    requestEx.setBodyBuffer(restClientRequest.getBodyBuffer());\n  }\n catch (  Throwable e) {\n    throw ExceptionFactory.convertConsumerException(e);\n  }\n}\n"}
{"INPUT": "private void renderFunctionTable(WasmModule module){\n  line(\"static void *wasm_table[] = {\");\n  if (!module.getFunctionTable().isEmpty()) {\n    indent();\n    for (int i=0; i < module.getFunctionTable().size() - 1; ++i) {\n      WasmFunction function=module.getFunctionTable().get(i);\n// bug_start\n      line(function.getName() + \",\");\n// bug_end\n    }\n    line(module.getFunctionTable().get(module.getFunctionTable().size() - 1).getName());\n    outdent();\n  }\n  line(\"};\");\n  line(\"\");\n}\n"}
{"INPUT": "private void init(final Map<String,DataSource> dataSourceMap,final ShardingRule shardingRule,final DatabaseType databaseType,final ShardingExecuteEngine executeEngine,final ConnectionMode connectionMode,final boolean showSQL){\n  this.dataSourceMap=dataSourceMap;\n  this.shardingRule=shardingRule;\n  this.executeEngine=executeEngine;\n  this.databaseType=databaseType;\n  this.connectionMode=connectionMode;\n  this.showSQL=showSQL;\n// bug_start\n  metaData=new ShardingMetaData(getDataSourceURLs(getDataSourceMap()),shardingRule,getDatabaseType(),executeEngine,new JDBCTableMetaDataConnectionManager(getDataSourceMap()));\n// bug_end\n}\n"}
{"INPUT": "@SuppressLint(\"InflateParams\") private void addItem(final boolean isMoreButton,final int position,final Menu fsb){\n  if (isMoreButton == false) {\n    if (position < 0 || fsb == null || StringUtil.isNotEmpty(fsb.getName(),true) == false || fsb.getImageRes() <= 0) {\n      Log.e(TAG,\"addItem isMoreButton == false >> position < 0 || fsb == null \" + \"|| StringUtil.isNotEmpty(fsb.getName(), true) == false \" + \"|| fsb.getImageRes() <= 0 >> return;\");\n      return;\n    }\n    ;\n  }\n  LinearLayout ll=(LinearLayout)inflater.inflate(R.layout.icon_name_item,null);\n  ImageView iv=(ImageView)ll.findViewById(R.id.ivIconNameIcon);\n  TextView tv=(TextView)ll.findViewById(R.id.tvIconNameName);\n  try {\n    iv.setImageResource(isMoreButton ? R.drawable.up2_light : fsb.getImageRes());\n  }\n catch (  Exception e) {\n    Log.e(TAG,\"addItem try {\" + \" iv.setImageResource(fsb.getImageRes()); \" + e.getMessage() + \">> return;\");\n    return;\n  }\n  tv.setText(isMoreButton ? \"\" : \"\" + fsb.getName());\n// bug_start\n  ll.setPadding((int)getDimension(R.dimen.common_item_left_tv_padding),0,(int)getDimension(R.dimen.common_item_right_img_padding_right),0);\n// bug_end\n  ll.setOnClickListener(new OnClickListener(){\n    @Override public void onClick(    View v){\n      if (isMoreButton) {\n        CommonUtil.toActivity(context,BottomMenuWindow.createIntent(context,moreMenuNameList,moreMenuIntentCodeList).putExtra(BottomMenuWindow.INTENT_TITLE,\"\"),toBottomMenuWindowRequestCode,false);\n      }\n else {\n        onBottomMenuItemClickListener.onBottomMenuItemClick(fsb.getIntentCode());\n      }\n    }\n  }\n);\n  llBottomMenuViewMainItemContainer.addView(ll,position);\n}\n"}
{"INPUT": "private static Spanned parseCueText(String string){\n  WebvttCue.Builder builder=new WebvttCue.Builder();\n// bug_start\n  WebvttCueParser.parseCueText(null,string,builder,Collections.<WebvttCssStyle>emptyList());\n// bug_end\n  return (Spanned)builder.build().text;\n}\n"}
{"INPUT": "public ModInfo(final ModFileInfo owningFile,final UnmodifiableConfig modConfig){\n  this.owningFile=owningFile;\n  this.modConfig=modConfig;\n  this.modId=modConfig.<String>getOptional(\"modId\").orElseThrow(null);\n  if (!VALID_LABEL.matcher(this.modId).matches()) {\n    LOGGER.fatal(\"Invalid modId found in file {} - {} does not match the standard: {}\",this.owningFile.getFile().getFilePath(),this.modId,VALID_LABEL.pattern());\n    throw new InvalidModFileException(\"Invalid modId found : \" + this.modId,owningFile);\n  }\n  this.namespace=modConfig.<String>getOptional(\"namespace\").orElse(this.modId);\n  if (!VALID_LABEL.matcher(this.namespace).matches()) {\n    LOGGER.fatal(\"Invalid override namespace found in file {} - {} does not match the standard: {}\",this.owningFile.getFile().getFilePath(),this.namespace,VALID_LABEL.pattern());\n    throw new InvalidModFileException(\"Invalid override namespace found : \" + this.namespace,owningFile);\n  }\n  this.version=modConfig.<String>getOptional(\"version\").map(null).map(null).orElse(DEFAULT_VERSION);\n// bug_start\n  this.displayName=modConfig.<String>getOptional(\"displayName\").orElse(null);\n// bug_end\n  this.description=modConfig.get(\"description\");\n  this.updateJSONURL=modConfig.<String>getOptional(\"updateJSONURL\").map(null).orElse(null);\n  if (owningFile != null) {\n    this.dependencies=owningFile.getConfig().<List<UnmodifiableConfig>>getOptional(Arrays.asList(\"dependencies\",this.modId)).orElse(Collections.emptyList()).stream().map(null).collect(Collectors.toList());\n    this.properties=owningFile.getConfig().<UnmodifiableConfig>getOptional(Arrays.asList(\"modproperties\",this.modId)).map(null).orElse(Collections.emptyMap());\n  }\n else {\n    this.dependencies=Collections.emptyList();\n    this.properties=Collections.emptyMap();\n  }\n}\n"}
{"INPUT": "@Override public Integer run() throws Exception {\n  String proto=\"http://\";\n  if (UserGroupInformation.isSecurityEnabled()) {\n// bug_start\n    System.setProperty(\"https.cipherSuites\",Krb5AndCertsSslSocketConnector.KRB5_CIPHER_SUITES[0]);\n// bug_end\n    proto=\"https://\";\n  }\n  final StringBuffer url=new StringBuffer(proto);\n  url.append(NameNode.getInfoServer(getConf())).append(\"/fsck?ugi=\").append(ugi.getShortUserName()).append(\"&path=\");\n  String dir=\"/\";\n  for (int idx=0; idx < args.length; idx++) {\n    if (!args[idx].startsWith(\"-\")) {\n      dir=args[idx];\n      break;\n    }\n  }\n  url.append(URLEncoder.encode(dir,\"UTF-8\"));\n  for (int idx=0; idx < args.length; idx++) {\n    if (args[idx].equals(\"-move\")) {\n      url.append(\"&move=1\");\n    }\n else     if (args[idx].equals(\"-delete\")) {\n      url.append(\"&delete=1\");\n    }\n else     if (args[idx].equals(\"-files\")) {\n      url.append(\"&files=1\");\n    }\n else     if (args[idx].equals(\"-openforwrite\")) {\n      url.append(\"&openforwrite=1\");\n    }\n else     if (args[idx].equals(\"-blocks\")) {\n      url.append(\"&blocks=1\");\n    }\n else     if (args[idx].equals(\"-locations\")) {\n      url.append(\"&locations=1\");\n    }\n else     if (args[idx].equals(\"-racks\")) {\n      url.append(\"&racks=1\");\n    }\n  }\n  URL path=new URL(url.toString());\n  SecurityUtil.fetchServiceTicket(path);\n  URLConnection connection=path.openConnection();\n  InputStream stream=connection.getInputStream();\n  BufferedReader input=new BufferedReader(new InputStreamReader(stream,\"UTF-8\"));\n  String line=null;\n  String lastLine=null;\n  int errCode=-1;\n  try {\n    while ((line=input.readLine()) != null) {\n      System.out.println(line);\n      lastLine=line;\n    }\n  }\n  finally {\n    input.close();\n  }\n  if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n    errCode=0;\n  }\n else   if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n    errCode=1;\n  }\n else   if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n    errCode=0;\n  }\n  return errCode;\n}\n"}
{"INPUT": "private void createNewPeerData(int id){\n  int clientPort=ZKTestUtil.getRandomPort();\n  int quorumPort=ZKTestUtil.getRandomPort() + 1000;\n  int electionPort=ZKTestUtil.getRandomPort() + 1001;\n  ZKPeer zkpeer=new ZKPeer(id,ZKTestUtil.createTempDir(\"zkdata\" + id),ZKTestUtil.createTempDir(\"zklog\" + id),HOST,clientPort,quorumPort,electionPort);\n  _peers.put(id,zkpeer);\n// bug_start\n  _peersView.put(Long.valueOf(id),new QuorumServer(id,new InetSocketAddress(HOST,quorumPort),new InetSocketAddress(HOST,electionPort),LearnerType.PARTICIPANT));\n// bug_end\n  _log.info(\"Created peer #\" + id + \" with ports:\"+ clientPort+ \"/\"+ quorumPort+ \"/\"+ electionPort+ \"  peer server addr:\"+ _peersView.get(Long.valueOf(id)).addr+ \"  peer server electionAddr:\"+ _peersView.get(Long.valueOf(id)).electionAddr);\n}\n"}
{"INPUT": "protected BootstrapAppModelResolver initResolver(LocalWorkspace workspace) throws AppModelResolverException {\n// bug_start\n  return new BootstrapAppModelResolver(MavenArtifactResolver.builder().setRepoHome(repoHome).setOffline(true).setWorkspace(workspace).build());\n// bug_end\n}\n"}
{"INPUT": "private ServerWebExchange createExchange(HttpMethod method,String path,String origin){\n// bug_start\n  return MockServerWebExchange.from(MockServerHttpRequest.method(method,\"http://localhost\" + path).header(\"Origin\",origin).header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD,\"GET\").build());\n// bug_end\n}\n"}
{"INPUT": "@Override public void before(Object target,Object[] args){\n  if (isDebug) {\n    logger.beforeInterceptor(target,args);\n  }\n  Trace trace=traceContext.currentRawTraceObject();\n  if (trace == null) {\n    return;\n  }\n  final HttpUriRequest request=(HttpUriRequest)args[0];\n  final boolean sampling=trace.canSampled();\n  if (!sampling) {\n    if (isDebug) {\n      logger.debug(\"set Sampling flag=false\");\n    }\n    request.addHeader(Header.HTTP_SAMPLED.toString(),SamplingFlagUtils.SAMPLING_RATE_FALSE);\n    return;\n  }\n  trace.traceBlockBegin();\n  trace.markBeforeTime();\n  TraceId nextId=trace.getTraceId().getNextTraceId();\n  trace.recordNextSpanId(nextId.getSpanId());\n  request.addHeader(Header.HTTP_TRACE_ID.toString(),nextId.getTransactionId());\n  request.addHeader(Header.HTTP_SPAN_ID.toString(),Integer.toString(nextId.getSpanId()));\n  request.addHeader(Header.HTTP_PARENT_SPAN_ID.toString(),Integer.toString(nextId.getParentSpanId()));\n  request.addHeader(Header.HTTP_FLAGS.toString(),String.valueOf(nextId.getFlags()));\n  request.addHeader(Header.HTTP_PARENT_APPLICATION_NAME.toString(),traceContext.getApplicationName());\n// bug_start\n  request.addHeader(Header.HTTP_PARENT_APPLICATION_TYPE.toString(),traceContext.getServerType());\n// bug_end\n  HttpHost host=extractHost(request.getURI());\n  trace.recordServiceType(ServiceType.HTTP_CLIENT);\n  int port=host.getPort();\n  String endpoint=getEndpoint(host.getHostName(),port);\n  trace.recordDestinationId(endpoint);\n  trace.recordAttribute(AnnotationKey.HTTP_URL,request.getRequestLine().getUri());\n}\n"}
{"INPUT": "@Override @SuppressWarnings(\"unchecked\") public void inform(SolrCore core){\n  this.core=core;\n  List<String> c=(List<String>)initArgs.get(INIT_COMPONENTS);\n  Set<String> missing=new HashSet<>(core.getSearchComponents().checkContains(c));\n  List<String> first=(List<String>)initArgs.get(INIT_FIRST_COMPONENTS);\n  missing.addAll(core.getSearchComponents().checkContains(first));\n  List<String> last=(List<String>)initArgs.get(INIT_LAST_COMPONENTS);\n  missing.addAll(core.getSearchComponents().checkContains(last));\n  if (!missing.isEmpty())   throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\"Missing SearchComponents named : \" + missing);\n  if (c != null && (first != null || last != null))   throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\"First/Last components only valid if you do not declare 'components'\");\n  if (shfInfo == null) {\n    shardHandlerFactory=core.getCoreContainer().getShardHandlerFactory();\n  }\n else {\n    shardHandlerFactory=core.createInitInstance(shfInfo,ShardHandlerFactory.class,null,null);\n    core.addCloseHook(new CloseHook(){\n      @Override public void preClose(      SolrCore core){\n        shardHandlerFactory.close();\n      }\n      @Override public void postClose(      SolrCore core){\n      }\n    }\n);\n  }\n  if (core.getCoreContainer().isZooKeeperAware()) {\n    core.getPackageListeners().addListener(new PackageListeners.Listener(){\n      @Override public String packageName(){\n        return null;\n      }\n      @Override public PluginInfo pluginInfo(){\n        return null;\n      }\n// bug_start\n      @Override public void changed(      PackageLoader.Package pkg){\n// bug_end\n        components=null;\n// bug_start\n      }\n      @Override public PackageLoader.Package.Version getPackageVersion(){\n        return null;\n// bug_end\n      }\n    }\n);\n  }\n}\n"}
{"INPUT": "public DruidServer(DruidNode node,DruidServerConfig config,String type){\n// bug_start\n  this(node.getHost(),node.getHost(),config.getMaxSize(),type,config.getTier(),DEFAULT_PRIORITY);\n// bug_end\n}\n"}
{"INPUT": "@Override public final void customize(T factory){\n  ManagementServerProperties managementServerProperties=BeanFactoryUtils.beanOfTypeIncludingAncestors(this.beanFactory,ManagementServerProperties.class);\n  ServerProperties serverProperties=BeanFactoryUtils.beanOfTypeIncludingAncestors(this.beanFactory,ServerProperties.class);\n  WebServerFactoryCustomizer<T> webServerFactoryCustomizer=BeanFactoryUtils.beanOfTypeIncludingAncestors(this.beanFactory,this.customizerClass);\n  webServerFactoryCustomizer.customize(factory);\n// bug_start\n  factory.setErrorPages(Collections.<ErrorPage>emptySet());\n// bug_end\n  customize(factory,managementServerProperties,serverProperties);\n}\n"}
{"INPUT": "@Override public RelNode convertToRel(RelOptTable.ToRelContext context){\n// bug_start\n  FlinkRelBuilder relBuilder=FlinkRelBuilder.of(context.getCluster(),this);\n// bug_end\n  return relBuilder.queryOperation(catalogView.getQueryOperation()).build();\n}\n"}
{"INPUT": "@Test public void testPreFlightCorsRequest(){\n  ClientResponse clientResponse=webClient.options().uri(\"/abc/123/function\").header(\"Origin\",\"domain.com\").header(\"Access-Control-Request-Method\",\"GET\").exchange().block();\n  HttpHeaders asHttpHeaders=clientResponse.headers().asHttpHeaders();\n  Mono<String> bodyToMono=clientResponse.bodyToMono(String.class);\n  assertNull(bodyToMono.block());\n  assertEquals(\"Missing header value in response: \" + HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN,\"*\",asHttpHeaders.getAccessControlAllowOrigin());\n// bug_start\n  assertEquals(\"Missing header value in response: \" + HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS,Arrays.asList(new HttpMethod[]{HttpMethod.GET,HttpMethod.HEAD}),asHttpHeaders.getAccessControlAllowMethods());\n// bug_end\n  assertEquals(\"Pre Flight call failed.\",HttpStatus.OK,clientResponse.statusCode());\n}\n"}
{"INPUT": "@Override public void awaitIndexOnline(IndexDefinition index,long duration,TimeUnit unit){\n  actions.assertInOpenTransaction();\n  long timeout=System.currentTimeMillis() + unit.toMillis(duration);\n  do {\n    IndexState state=getIndexState(index);\nswitch (state) {\ncase ONLINE:\n      return;\ncase FAILED:\n    String cause=getIndexFailure(index);\n// bug_start\n  String message=IndexPopulationFailure.appendCauseOfFailure(String.format(\"Index entered a %s state. Please see database logs. Index: %s\",state,index),cause);\n// bug_end\nthrow new IllegalStateException(message);\ndefault :\ntry {\nThread.sleep(100);\n}\n catch (InterruptedException e) {\n}\nbreak;\n}\n}\n while (System.currentTimeMillis() < timeout);\nthrow new IllegalStateException(\"Expected index to come online within a reasonable time.\");\n}\n"}
{"INPUT": "public void testInvalidJson(){\n  JsonProcessor jsonProcessor=new JsonProcessor(\"tag\",\"field\",\"target_field\",false);\n  Map<String,Object> document=new HashMap<>();\n  document.put(\"field\",\"invalid json\");\n  IngestDocument ingestDocument=RandomDocumentPicks.randomIngestDocument(random(),document);\n  Exception exception=expectThrows(IllegalArgumentException.class,null);\n// bug_start\n  assertThat(exception.getMessage(),equalTo(\"com.fasterxml.jackson.core.JsonParseException: Unrecognized token\" + \" 'invalid': was expecting ('true', 'false' or 'null')\\n\" + \" at [Source: invalid json; line: 1, column: 8]\"));\n// bug_end\n}\n"}
{"INPUT": "private M copyModel(M original) throws IOException {\n  try (BytesStreamOutput output=new BytesStreamOutput()){\n    original.writeTo(output);\n// bug_start\n    try (StreamInput in=new NamedWriteableAwareStreamInput(StreamInput.wrap(output.bytes()),provideNamedWritableRegistry())){\n// bug_end\n      return readFrom(in);\n    }\n   }\n }\n"}
{"INPUT": "@Override public void onActivityCreated(Bundle savedInstanceState){\n  super.onActivityCreated(savedInstanceState);\n  getSherlockActivity().setSupportProgressBarIndeterminateVisibility(false);\n  mAdapter=new MoviesAdapter(getActivity(),this);\n// bug_start\n  GridView list=(GridView)getView().findViewById(R.id.gridViewMovies);\n// bug_end\n  list.setAdapter(mAdapter);\n  list.setOnItemClickListener(this);\n  list.setEmptyView(mEmptyView);\n  registerForContextMenu(list);\n  getLoaderManager().initLoader(LOADER_ID,null,this);\n}\n"}
{"INPUT": "private void prepareReplication(){\n  try {\n    if (m_nodeDRGateway != null) {\n      m_nodeDRGateway.bindPorts(m_catalogContext.cluster.getDrproducerenabled(),VoltDB.getReplicationPort(m_catalogContext.cluster.getDrproducerport()),VoltDB.getDefaultReplicationInterface());\n    }\n    if (m_consumerDRGateway != null) {\n// bug_start\n      m_consumerDRGateway.initialize(m_config.m_startAction.doesRecover());\n// bug_end\n    }\n  }\n catch (  Exception ex) {\n    MiscUtils.printPortsInUse(hostLog);\n    VoltDB.crashLocalVoltDB(\"Failed to initialize DR\",false,ex);\n  }\n}\n"}
{"INPUT": "@Override public void onViewCreated(View view,Bundle savedInstanceState){\n  super.onViewCreated(view,savedInstanceState);\n  bindUIElements(view);\n  mValues=getResources().getStringArray(R.array.languages);\n// bug_start\n  ArrayAdapter<String> adapter=new ArrayAdapter<String>(getActivity(),android.R.layout.simple_list_item_1,android.R.id.text1,mValues);\n// bug_end\n  mQuickReturnListView.setAdapter(adapter);\n  mQuickReturnListView.getViewTreeObserver().addOnGlobalLayoutListener(mQuickReturnListViewOnGlobalLayoutListener);\n  mQuickReturnListView.setOnScrollListener(mQuickReturnListViewOnScrollListener);\n}\n"}
{"INPUT": "@Override protected ShardDfsOnlyRequest newShardRequest(int numShards,ShardRouting shard,DfsOnlyRequest request){\n// bug_start\n  String[] filteringAliases=indexNameExpressionResolver.filteringAliases(clusterService.state(),shard.index(),request.indices());\n// bug_end\n  return new ShardDfsOnlyRequest(shard,numShards,filteringAliases,request.nowInMillis,request);\n}\n"}
{"INPUT": "public void run(){\n  final ScheduledExecutorService executorService=Executors.newSingleThreadScheduledExecutor();\n  executorService.scheduleAtFixedRate(new Runnable(){\n// bug_start\n// bug_end\n    @Override public void run(){\n// bug_start\n      World world=new World();\n// bug_end\n      List<String> countries=world.fetch();\n      System.out.println(\"Our world currently has the following countries:-\");\n      for (      String country : countries) {\n        System.out.println(\"\\t\" + country);\n      }\n    }\n  }\n,0,15,TimeUnit.SECONDS);\n}\n"}
{"INPUT": "public static void processQueryDef(KnowledgeBuilderImpl kbuilder,InternalKnowledgePackage pkg,PackageModel packageModel,QueryDescr queryDescr){\n// bug_start\n  RuleContext context=new RuleContext(kbuilder,pkg,packageModel.getExprIdGenerator(),Optional.of(queryDescr));\n// bug_end\n  String queryName=queryDescr.getName();\n  final String queryDefVariableName=toQueryDef(queryName);\n  context.setQueryName(Optional.of(queryDefVariableName));\n  parseQueryParameters(context,packageModel,queryDescr);\n  ClassOrInterfaceType queryDefType=getQueryType(context.getQueryParameters());\n  MethodCallExpr queryCall=new MethodCallExpr(null,QUERY_CALL);\n  if (!queryDescr.getNamespace().isEmpty()) {\n    queryCall.addArgument(new StringLiteralExpr(queryDescr.getNamespace()));\n  }\n  queryCall.addArgument(new StringLiteralExpr(queryName));\n  for (  QueryParameter qp : context.getQueryParameters()) {\n    queryCall.addArgument(new ClassExpr(JavaParser.parseType(qp.type.getCanonicalName())));\n    queryCall.addArgument(new StringLiteralExpr(qp.name));\n  }\n  packageModel.getQueryDefWithType().put(queryDefVariableName,new QueryDefWithType(queryDefType,queryCall,context));\n}\n"}
{"INPUT": "private void filterTags(FileChannel outputFileChannel,AbcNameFilter abcNameFilter) throws IOException {\n  int lastWrittenPosition=0;\n  while (byteBuffer.position() < byteBuffer.limit()) {\n    int tagCodeAndLength=byteBuffer.getShort();\n    int type=tagCodeAndLength >> 6;\n    int length=tagCodeAndLength & 0x3F;\n    if (length == 63) {\n      length=byteBuffer.getInt();\n    }\nswitch (type) {\ncase endTag:\n      byteBuffer.position(lastWrittenPosition);\n    outputFileChannel.write(byteBuffer);\n  return;\ncase symbolClass:\n{\n  final int tagStartPosition=byteBuffer.position();\n  if (replaceMainClass) {\n    lastWrittenPosition=parseSymbolClassTagAndRenameClassAssociatedWithMainTimeline(lastWrittenPosition,outputFileChannel,length);\n  }\n  byteBuffer.position(tagStartPosition + length);\n}\nbreak;\ncase stagDoABC2:\nString name=readAbcName(byteBuffer.position() + 4);\nif (!abcNameFilter.accept(name)) {\nbyteBuffer.limit(byteBuffer.position() - 6);\nbyteBuffer.position(lastWrittenPosition);\noutputFileChannel.write(byteBuffer);\nlastWrittenPosition=byteBuffer.limit() + length + 6;\nbyteBuffer.limit(byteBuffer.capacity());\nbyteBuffer.position(lastWrittenPosition);\ncontinue;\n}\n else if (flexSdkVersion != null && !flexInjected) {\nboolean isStyleProtoChain=name.equals(\"mx.styles:StyleProtoChain\");\nif (isStyleProtoChain) {\nfinal int oldPosition=byteBuffer.position();\nbyteBuffer.position(byteBuffer.position() + 4 + name.length()+ 1);\nparseCPoolAndRenameStyleProtoChain();\nbyteBuffer.position(oldPosition + 4 + 10);\nbyteBuffer.put((byte)'F');\nbyteBuffer.position(oldPosition);\n}\nif (isStyleProtoChain ? flexSdkVersion.equals(\"4.5\") : (flexSdkVersion.equals(\"4.1\") && name.equals(\"mx.styles:CSSStyleDeclaration\"))) {\nflexInjected=true;\nbyteBuffer.limit(byteBuffer.position() + length);\nbyteBuffer.position(lastWrittenPosition);\noutputFileChannel.write(byteBuffer);\nlastWrittenPosition=byteBuffer.limit();\nbyteBuffer.limit(byteBuffer.capacity());\nfinal String injectionFileName=\"flex-injection-\" + flexSdkVersion + \".abc\";\nif (System.getProperty(\"fud.debug\") == null) {\nInputStream inputStream=getClass().getClassLoader().getResourceAsStream(injectionFileName);\ntry {\n  outputFileChannel.write(ByteBuffer.wrap(FileUtil.loadBytes(inputStream)));\n}\n  finally {\n  inputStream.close();\n}\n}\n else {\n// bug_start\nfinal FileChannel injection=new FileInputStream(new File(\"/Users/develar/workspace/idea/plugins/flex/tools/flex-ui-designer/flex-injection/target/\" + injectionFileName)).getChannel();\n// bug_end\ntry {\n  injection.transferTo(0,injection.size(),outputFileChannel);\n}\n  finally {\n  injection.close();\n}\n}\ncontinue;\n}\n}\ndefault :\nbyteBuffer.position(byteBuffer.position() + length);\nbreak;\n}\n}\n}\n"}
{"INPUT": "@Override public boolean isWorking(){\n  if (working == null) {\n    ensureCommand(CMD_PROPERTY_KEY,CMD_FALLBACK);\n// bug_start\n    working=checkCmd(new String[]{cmd});\n// bug_end\n  }\n  return working.booleanValue();\n}\n"}
{"INPUT": "@Test public void requireThatMaxAndMinWithTensorAttributesAreReplaced() throws ParseException {\n  assertTransformedExpression(\"reduce(attribute(tensor_field_1),max,x)\",\"max(attribute(tensor_field_1),x)\");\n  assertTransformedExpression(\"1+reduce(attribute(tensor_field_1),max,x)\",\"1 + max(attribute(tensor_field_1),x)\");\n// bug_start\n  assertTransformedExpression(\"if(attribute(double_field),1+reduce(attribute(tensor_field_1),max,x),0)\",\"if(attribute(double_field),1 + max(attribute(tensor_field_1),x),0)\");\n// bug_end\n  assertTransformedExpression(\"reduce(max(attribute(tensor_field_1),attribute(tensor_field_2)),max,x)\",\"max(max(attribute(tensor_field_1),attribute(tensor_field_2)),x)\");\n  assertTransformedExpression(\"reduce(if(attribute(double_field),attribute(tensor_field_2),attribute(tensor_field_2)),max,x)\",\"max(if(attribute(double_field),attribute(tensor_field_2),attribute(tensor_field_2)),x)\");\n  assertTransformedExpression(\"max(reduce(attribute(tensor_field_1),max,x),x)\",\"max(max(attribute(tensor_field_1),x),x)\");\n  assertTransformedExpression(\"reduce(reduce(attribute(tensor_field_2),max,x),max,y)\",\"max(max(attribute(tensor_field_2),x),y)\");\n}\n"}
{"INPUT": "public void testSyncerSendsOffCorrectDocuments() throws Exception {\n  IndexShard shard=newStartedShard(true);\n  TaskManager taskManager=new TaskManager(Settings.EMPTY,threadPool,Collections.emptySet());\n  AtomicBoolean syncActionCalled=new AtomicBoolean();\n  List<ResyncReplicationRequest> resyncRequests=new ArrayList<>();\n  PrimaryReplicaSyncer.SyncAction syncAction=null;\n  PrimaryReplicaSyncer syncer=new PrimaryReplicaSyncer(taskManager,syncAction);\n  syncer.setChunkSize(new ByteSizeValue(randomIntBetween(1,10)));\n  int numDocs=randomInt(10);\n  for (int i=0; i < numDocs; i++) {\n// bug_start\n    shard.applyIndexOperationOnPrimary(Versions.MATCH_ANY,VersionType.INTERNAL,new SourceToParse(shard.shardId().getIndexName(),\"_doc\",Integer.toString(i),new BytesArray(\"{}\"),XContentType.JSON),SequenceNumbers.UNASSIGNED_SEQ_NO,0,randomBoolean() ? IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP : randomNonNegativeLong(),true);\n// bug_end\n  }\n  long globalCheckPoint=numDocs > 0 ? randomIntBetween(0,numDocs - 1) : 0;\n  boolean syncNeeded=numDocs > 0;\n  String allocationId=shard.routingEntry().allocationId().getId();\n  shard.updateShardState(shard.routingEntry(),shard.getPendingPrimaryTerm(),null,1000L,Collections.singleton(allocationId),new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard.routingEntry()).build());\n  shard.updateLocalCheckpointForShard(allocationId,globalCheckPoint);\n  assertEquals(globalCheckPoint,shard.getLastKnownGlobalCheckpoint());\n  logger.info(\"Total ops: {}, global checkpoint: {}\",numDocs,globalCheckPoint);\n  PlainActionFuture<PrimaryReplicaSyncer.ResyncTask> fut=new PlainActionFuture<>();\n  syncer.resync(shard,fut);\n  PrimaryReplicaSyncer.ResyncTask resyncTask=fut.get();\n  if (syncNeeded) {\n    assertTrue(\"Sync action was not called\",syncActionCalled.get());\n    ResyncReplicationRequest resyncRequest=resyncRequests.remove(0);\n    assertThat(resyncRequest.getTrimAboveSeqNo(),equalTo(numDocs - 1L));\n    assertThat(\"trimAboveSeqNo has to be specified in request #0 only\",resyncRequests.stream().mapToLong(null).filter(null).findFirst().isPresent(),is(false));\n    assertThat(resyncRequest.getMaxSeenAutoIdTimestampOnPrimary(),equalTo(shard.getMaxSeenAutoIdTimestamp()));\n  }\n  if (syncNeeded && globalCheckPoint < numDocs - 1) {\n    if (shard.indexSettings.isSoftDeleteEnabled()) {\n      assertThat(resyncTask.getSkippedOperations(),equalTo(0));\n      assertThat(resyncTask.getResyncedOperations(),equalTo(resyncTask.getTotalOperations()));\n      assertThat(resyncTask.getTotalOperations(),equalTo(Math.toIntExact(numDocs - 1 - globalCheckPoint)));\n    }\n else {\n      int skippedOps=Math.toIntExact(globalCheckPoint + 1);\n      assertThat(resyncTask.getSkippedOperations(),equalTo(skippedOps));\n      assertThat(resyncTask.getResyncedOperations(),equalTo(numDocs - skippedOps));\n      assertThat(resyncTask.getTotalOperations(),equalTo(globalCheckPoint == numDocs - 1 ? 0 : numDocs));\n    }\n  }\n else {\n    assertThat(resyncTask.getSkippedOperations(),equalTo(0));\n    assertThat(resyncTask.getResyncedOperations(),equalTo(0));\n    assertThat(resyncTask.getTotalOperations(),equalTo(0));\n  }\n  closeShards(shard);\n}\n"}
{"INPUT": "@Override public Node getGraphicNode(){\n  GlyphIcons icon=icons.get(0);\n// bug_start\n  Text text=new Text(icon.unicode());\n// bug_end\n  text.getStyleClass().add(\"glyph-icon\");\n  text.setStyle(String.format(\"-fx-font-family: %s;\",icon.fontFamily()));\n  color.ifPresent(null);\n  return text;\n}\n"}
{"INPUT": "@Override public boolean doBuild(TopologyBuilder bldr,Set<String> stageNames){\n// bug_start\n  setDefaultNameIfNone(StreamletNamePrefixes.REMAP.toString(),stageNames);\n// bug_end\n  bldr.setBolt(getName(),new MapOperator<R,R>(null),getNumPartitions()).customGrouping(parent.getName(),new RemapCustomGrouping<R>(remapFn));\n  return true;\n}\n"}
{"INPUT": "@Override protected RemoteOperationResult run(WebdavClient client){\n  PropFindMethod propfind=null;\n  RemoteOperationResult result=null;\n  mTransferWasRequested=false;\n  try {\n    if (!mLocalFile.isDown()) {\n      requestForDownload(mLocalFile);\n      result=new RemoteOperationResult(ResultCode.OK);\n    }\n else {\n      if (mServerFile == null) {\n        propfind=new PropFindMethod(client.getBaseUri() + WebdavUtils.encodePath(mLocalFile.getRemotePath()));\n        int status=client.executeMethod(propfind,SYNC_READ_TIMEOUT,SYNC_CONNECTION_TIMEOUT);\n        boolean isMultiStatus=status == HttpStatus.SC_MULTI_STATUS;\n        if (isMultiStatus) {\n          MultiStatus resp=propfind.getResponseBodyAsMultiStatus();\n          WebdavEntry we=new WebdavEntry(resp.getResponses()[0],client.getBaseUri().getPath());\n          mServerFile=fillOCFile(we);\n          mServerFile.setLastSyncDateForProperties(System.currentTimeMillis());\n        }\n else {\n          client.exhaustResponse(propfind.getResponseBodyAsStream());\n          result=new RemoteOperationResult(false,status);\n        }\n      }\n      if (result == null) {\n        boolean serverChanged=false;\n        if (mServerFile.getEtag() != null) {\n          serverChanged=(!mServerFile.getEtag().equals(mLocalFile.getEtag()));\n        }\n else {\n          serverChanged=(mServerFile.getModificationTimestamp() > mLocalFile.getModificationTimestampAtLastSyncForData());\n        }\n        boolean localChanged=(mLocalChangeAlreadyKnown || mLocalFile.getLocalModificationTimestamp() > mLocalFile.getLastSyncDateForData());\n        if (localChanged && serverChanged) {\n          result=new RemoteOperationResult(ResultCode.SYNC_CONFLICT);\n        }\n else         if (localChanged) {\n          if (mSyncFileContents) {\n            requestForUpload(mLocalFile);\n          }\n else {\n          }\n          result=new RemoteOperationResult(ResultCode.OK);\n        }\n else         if (serverChanged) {\n          if (mSyncFileContents) {\n            requestForDownload(mLocalFile);\n          }\n else {\n            mServerFile.setKeepInSync(mLocalFile.keepInSync());\n            mServerFile.setLastSyncDateForData(mLocalFile.getLastSyncDateForData());\n            mServerFile.setStoragePath(mLocalFile.getStoragePath());\n            mServerFile.setParentId(mLocalFile.getParentId());\n            mStorageManager.saveFile(mServerFile);\n          }\n          result=new RemoteOperationResult(ResultCode.OK);\n        }\n else {\n          result=new RemoteOperationResult(ResultCode.OK);\n        }\n      }\n    }\n    Log.i(TAG,\"Synchronizing \" + mAccount.name + \", file \"+ mLocalFile.getRemotePath()+ \": \"+ result.getLogMessage());\n  }\n catch (  Exception e) {\n    result=new RemoteOperationResult(e);\n// bug_start\n    Log.e(TAG,\"Synchronizing \" + mAccount.name + \", file \"+ mLocalFile.getRemotePath()+ \": \"+ result.getLogMessage(),result.getException());\n// bug_end\n  }\n finally {\n    if (propfind != null)     propfind.releaseConnection();\n  }\n  return result;\n}\n"}
{"INPUT": "@Test public void readByteArraySmall() throws Exception {\n  byte[] array=new byte[1];\n  int read=stream.read(array);\n// bug_start\n  assertThat(read,is(1));\n// bug_end\n}\n"}
{"INPUT": "public AMD64ArrayEqualsOp(LIRGeneratorTool tool,JavaKind kind,Value result,Value array1,Value array2,Value length,int constantLength,boolean directPointers,int maxVectorSize){\n  super(TYPE);\n  this.kind=kind;\n  this.arrayBaseOffset=directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind);\n  this.arrayIndexScale=tool.getProviders().getMetaAccess().getArrayIndexScale(kind);\n  if (constantLength >= 0 && arrayIndexScale > 1) {\n    this.constantByteLength=constantLength << NumUtil.log2Ceil(arrayIndexScale);\n  }\n else {\n    this.constantByteLength=constantLength;\n  }\n  this.resultValue=result;\n  this.array1Value=array1;\n  this.array2Value=array2;\n  this.lengthValue=length;\n  this.temp1=tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));\n  this.temp2=tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));\n  this.temp3=tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));\n  this.temp4=tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));\n  this.temp5=kind.isNumericFloat() ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;\n  if (kind == JavaKind.Float) {\n    this.tempXMM=tool.newVariable(LIRKind.value(AMD64Kind.SINGLE));\n  }\n else   if (kind == JavaKind.Double) {\n    this.tempXMM=tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));\n  }\n else {\n    this.tempXMM=Value.ILLEGAL;\n  }\n  if (supportsSSE41(tool.target())) {\n    if (canGenerateConstantLengthCompare(tool.target())) {\n// bug_start\n      LIRKind lirKind=LIRKind.value(supportsAVX2(tool.target()) && maxVectorSize >= 32 ? AMD64Kind.V256_BYTE : AMD64Kind.V128_BYTE);\n// bug_end\n      this.vectorTemp1=tool.newVariable(lirKind);\n      this.vectorTemp2=tool.newVariable(lirKind);\n      this.vectorTemp3=tool.newVariable(lirKind);\n      this.vectorTemp4=tool.newVariable(lirKind);\n    }\n else {\n      this.vectorTemp1=tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));\n      this.vectorTemp2=tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));\n      this.vectorTemp3=Value.ILLEGAL;\n      this.vectorTemp4=Value.ILLEGAL;\n    }\n  }\n else {\n    this.vectorTemp1=Value.ILLEGAL;\n    this.vectorTemp2=Value.ILLEGAL;\n    this.vectorTemp3=Value.ILLEGAL;\n    this.vectorTemp4=Value.ILLEGAL;\n  }\n}\n"}
{"INPUT": "public Object putAfterCommit(String name,Object key,Object value,long timeout,long ttl,long txnId){\n  Object result=null;\n  if (txnId != -1) {\n    ThreadContext tc=ThreadContext.get();\n    Data dataKey=toData(key);\n    CMap cmap=getMap(name);\n    final LocalLock localLock=cmap.mapLocalLocks.get(dataKey);\n    final boolean shouldUnlock=localLock != null && localLock.getThreadId() == tc.getThreadId();\n    final boolean shouldRemove=shouldUnlock && localLock.getCount() == 1;\n    if (shouldRemove) {\n// bug_start\n      result=txnalPut(CONCURRENT_MAP_PUT_AND_UNLOCK,name,key,value,timeout,ttl,-1);\n// bug_end\n      cmap.mapLocalLocks.remove(dataKey,localLock);\n    }\n else     if (shouldUnlock) {\n      result=txnalPut(CONCURRENT_MAP_PUT,name,key,value,timeout,ttl,-1);\n      localLock.decrementAndGet();\n    }\n else {\n      final String error=\"Could not commit put operation! Current thread is not owner of \" + \"transaction lock! Thread-Id: \" + tc.getThreadId() + \", LocalLock: \"+ localLock;\n      logger.log(Level.WARNING,error);\n      throw new IllegalStateException(error);\n    }\n  }\n  return result;\n}\n"}
{"INPUT": "@Inject public TransportClusterRerouteAction(TransportService transportService,ClusterService clusterService,ThreadPool threadPool,AllocationService allocationService,ActionFilters actionFilters,IndexNameExpressionResolver indexNameExpressionResolver){\n// bug_start\n  super(ClusterRerouteAction.NAME,transportService,clusterService,threadPool,actionFilters,indexNameExpressionResolver,null);\n// bug_end\n  this.allocationService=allocationService;\n}\n"}
{"INPUT": "public JsonConfigurationFactory(Class<T> klass,Validator validator,ObjectMapper objectMapper,String propertyPrefix){\n// bug_start\n  super(new JsonFactory(),JsonFactory.FORMAT_NAME_JSON,klass,validator,objectMapper,propertyPrefix);\n// bug_end\n}\n"}
{"INPUT": "@Test public void testObjectConstructorNegative(){\n  CompileResult negativeResult=BCompileUtil.compile(\"test-src/expressions/object/object_constructor_expression_negative.bal\");\n  int index=0;\n  BAssertUtil.validateError(negativeResult,index++,\"incompatible types: 'SampleRec' is not an object\",19,39);\n  BAssertUtil.validateError(negativeResult,index++,\"a remote function in a non client object\",22,5);\n  BAssertUtil.validateError(negativeResult,index++,\"object constructor 'init' method cannot have parameters\",26,5);\n  BAssertUtil.validateError(negativeResult,index++,\"object initializer function can not be declared as \" + \"private\",30,5);\n  BAssertUtil.validateError(negativeResult,index++,\"invalid token 'public'\",34,29);\n  BAssertUtil.validateError(negativeResult,index++,\"type inclusions are not allowed in object constructor\",40,1);\n  BAssertUtil.validateError(negativeResult,index++,\"invalid usage of 'object constructor expression' with \" + \"type 'any'\",42,9);\n// bug_start\n  BAssertUtil.validateError(negativeResult,index++,\"invalid usage of 'object constructor expression' with type\" + \" '(DistinctFooA|DistinctFoo)'\",53,47);\n// bug_end\n  Assert.assertEquals(negativeResult.getErrorCount(),index);\n}\n"}
{"INPUT": "@Test public void verifyChainedResolver(){\n  final PersonDirectoryPrincipalResolver resolver=new PersonDirectoryPrincipalResolver(this.attributeRepository);\n  final ChainingPrincipalResolver chain=new ChainingPrincipalResolver();\n// bug_start\n  chain.setChain(Arrays.asList(resolver,new EchoingPrincipalResolver()));\n// bug_end\n  final Map<String,Object> attributes=new HashMap<>(2);\n  attributes.put(\"a1\",\"v1\");\n  attributes.put(\"a2\",\"v2\");\n  final Principal p=chain.resolve(new UsernamePasswordCredential(\"castest1\",\"castest1\"),Optional.of(CoreAuthenticationTestUtils.getPrincipal(\"castest1\",attributes)),Optional.of(new SimpleTestUsernamePasswordAuthenticationHandler()));\n  assertNotNull(p);\n  assertTrue(p.getAttributes().containsKey(\"givenName\"));\n  assertTrue(p.getAttributes().containsKey(\"a1\"));\n  assertTrue(p.getAttributes().containsKey(\"a2\"));\n}\n"}
{"INPUT": "@SuppressWarnings({\"unchecked\",\"ConstantConditions\"}) private void initializeRecyclerView(){\n  mAdapter=new FlexibleAdapter<>(DatabaseService.getInstance().getDatabaseList(),getActivity(),true);\n  mAdapter.addListener(getActivity()).setAnimationOnScrolling(true).setAnimationOnReverseScrolling(true);\n  mRecyclerView=(RecyclerView)getView().findViewById(R.id.recycler_view);\n  mRecyclerView.setLayoutManager(createNewLinearLayoutManager());\n  mRecyclerView.setAdapter(mAdapter);\n  mRecyclerView.setHasFixedSize(true);\n  mRecyclerView.setItemAnimator(new DefaultItemAnimator());\n// bug_start\n  mRecyclerView.addItemDecoration(new FlexibleItemDecoration(getActivity(),0,24));\n// bug_end\n  mAdapter.setDisplayHeadersAtStartUp(true).setStickyHeaders(true).setEndlessScrollListener(this,new ProgressItem()).setEndlessScrollThreshold(1);\n  SwipeRefreshLayout swipeRefreshLayout=(SwipeRefreshLayout)getView().findViewById(R.id.swipeRefreshLayout);\n  swipeRefreshLayout.setEnabled(true);\n  mListener.onFragmentChange(swipeRefreshLayout,mRecyclerView,Mode.IDLE);\n}\n"}
{"INPUT": "@Test(timeout=300000) public void testGetTableDescriptor() throws IOException {\n  HColumnDescriptor fam1=new HColumnDescriptor(\"fam1\");\n  HColumnDescriptor fam2=new HColumnDescriptor(\"fam2\");\n  HColumnDescriptor fam3=new HColumnDescriptor(\"fam3\");\n  HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(name.getMethodName()));\n  htd.addFamily(fam1);\n  htd.addFamily(fam2);\n  htd.addFamily(fam3);\n  this.admin.createTable(htd);\n  Table table=TEST_UTIL.getConnection().getTable(htd.getTableName());\n  TableDescriptor confirmedHtd=table.getDescriptor();\n// bug_start\n  assertEquals(TableDescriptor.COMPARATOR.compare(htd,confirmedHtd),0);\n// bug_end\n  MetaTableAccessor.fullScanMetaAndPrint(TEST_UTIL.getConnection());\n  table.close();\n}\n"}
{"INPUT": "private boolean doRemoveDataConfirmation(){\n  if (wizard.removeOldData && !removeOldDataConfirmed) {\n// bug_start\n    if (UIUtils.confirmAction(getShell(),\"Mock Data Wizard\",\"Are you sure you want to delete old data?\")) {\n// bug_end\n      removeOldDataConfirmed=true;\n    }\n else {\n      return true;\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "@SuppressWarnings(\"DeprecatedIsStillUsed\") @Deprecated protected LongTaskTimer newLongTaskTimer(Meter.Id id){\n// bug_start\n  throw new UnsupportedOperationException(\"MeterRegistry implementations may still override this, but it is only\" + \"invoked by the overloaded form of newLongTaskTimer for backwards compatibility\");\n// bug_end\n}\n"}
{"INPUT": "private int updateSpecWithExtra(int spec,int startInset,int endInset){\n  if (startInset == 0 && endInset == 0) {\n    return spec;\n  }\n  final int mode=View.MeasureSpec.getMode(spec);\n  if (mode == View.MeasureSpec.AT_MOST || mode == View.MeasureSpec.EXACTLY) {\n// bug_start\n    return View.MeasureSpec.makeMeasureSpec(View.MeasureSpec.getSize(spec) - startInset - endInset,mode);\n// bug_end\n  }\n  return spec;\n}\n"}
{"INPUT": "protected void fullBuildCube(String cubeName) throws Exception {\n  Assert.assertTrue(config.getHdfsWorkingDirectory().startsWith(\"file:\"));\n  cleanupSegments(cubeName);\n// bug_start\n  buildCuboid(cubeName,new SegmentRange.TSRange(0L,Long.MAX_VALUE));\n// bug_end\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n  Random random=new Random();\n  Settings settings=settingsBuilder().put(\"index.refresh_interval\",\"1s\").put(\"index.merge.async\",true).put(\"index.translog.flush_threshold_ops\",5000).put(\"gateway.type\",\"none\").put(SETTING_NUMBER_OF_SHARDS,1).put(SETTING_NUMBER_OF_REPLICAS,1).build();\n  Node[] nodes=new Node[1];\n  for (int i=0; i < nodes.length; i++) {\n    nodes[i]=nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\",\"node\" + i)).node();\n  }\n  Node client=nodes[0];\n  Client client1=client.client();\n  Thread.sleep(1000);\n  client1.admin().indices().prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\",XContentFactory.jsonBuilder().startObject().startObject(\"type1\").startObject(\"_source\").field(\"enabled\",false).endObject().startObject(\"_all\").field(\"enabled\",false).endObject().startObject(\"_type\").field(\"index\",\"no\").endObject().startObject(\"_id\").field(\"index\",\"no\").endObject().startObject(\"properties\").startObject(\"field\").field(\"type\",\"string\").field(\"index\",\"not_analyzed\").field(\"omit_norms\",true).endObject().endObject().endObject().endObject()).execute().actionGet();\n  Thread.sleep(5000);\n  StopWatch stopWatch=new StopWatch().start();\n  long COUNT=SizeValue.parseSizeValue(\"2m\").singles();\n  int BATCH=500;\n  System.out.println(\"Indexing [\" + COUNT + \"] ...\");\n  long ITERS=COUNT / BATCH;\n  long i=1;\n  int counter=0;\n  for (; i <= ITERS; i++) {\n    BulkRequestBuilder request=client1.prepareBulk();\n    for (int j=0; j < BATCH; j++) {\n      counter++;\n// bug_start\n      request.add(Requests.indexRequest(\"test\").setType(\"type1\").setId(Integer.toString(counter)).setSource(source(Integer.toString(counter),\"test\" + counter)));\n// bug_end\n    }\n    BulkResponse response=request.execute().actionGet();\n    if (response.hasFailures()) {\n      System.err.println(\"failures...\");\n    }\n    if (((i * BATCH) % 10000) == 0) {\n      System.out.println(\"Indexed \" + (i * BATCH) + \" took \"+ stopWatch.stop().lastTaskTime());\n      stopWatch.start();\n    }\n  }\n  System.out.println(\"Indexing took \" + stopWatch.totalTime() + \", TPS \"+ (((double)COUNT) / stopWatch.totalTime().secondsFrac()));\n  client.client().admin().indices().prepareRefresh().execute().actionGet();\n  System.out.println(\"Count: \" + client.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount());\n  client.close();\n  for (  Node node : nodes) {\n    node.close();\n  }\n}\n"}
{"INPUT": "public static ClientConnectionManager wrap(ClientConnectionManager orig){\n  if (orig instanceof Wrapped)   throw new IllegalArgumentException();\n// bug_start\n  return (ClientConnectionManager)Proxy.newProxyInstance(ClientConnectionManager.class.getClassLoader(),interfaces,new Handler(orig));\n// bug_end\n}\n"}
{"INPUT": "@Override @BeforeMethod(groups=\"slow\") public void beforeMethod() throws Exception {\n  super.beforeMethod();\n// bug_start\n  entitySqlDaoTransactionalJdbiWrapper=new EntitySqlDaoTransactionalJdbiWrapper(getDBI(),clock,cacheControllerDispatcher,nonEntityDao);\n// bug_end\n  overdueQueue=notificationQueueService.getNotificationQueue(DefaultOverdueService.OVERDUE_SERVICE_NAME,DefaultOverdueCheckNotifier.OVERDUE_CHECK_NOTIFIER_QUEUE);\n  Assert.assertTrue(overdueQueue.isStarted());\n  testReferenceTime=clock.getUTCNow();\n}\n"}
{"INPUT": "public void sendInvitation(JID to,String reason,MUCRole senderRole,List<Element> extensions) throws ForbiddenException, CannotBeInvitedException {\n  if (!isMembersOnly() || canOccupantsInvite() || MUCRole.Affiliation.admin == senderRole.getAffiliation() || MUCRole.Affiliation.owner == senderRole.getAffiliation()) {\n    Message message=new Message();\n    message.setFrom(role.getRoleAddress());\n    message.setTo(to);\n    if (((MultiUserChatServiceImpl)mucService).getMUCDelegate() != null) {\n// bug_start\nswitch (((MultiUserChatServiceImpl)mucService).getMUCDelegate().sendingInvitation(this,to,role.getRoleAddress(),reason)) {\n// bug_end\ncase HANDLED_BY_DELEGATE:\n        return;\ncase HANDLED_BY_OPENFIRE:\n      break;\ncase REJECTED:\n    throw new CannotBeInvitedException();\n}\n}\nif (extensions != null) {\nfor (Element element : extensions) {\n  element.setParent(null);\n  message.getElement().add(element);\n}\n}\nElement frag=message.addChildElement(\"x\",\"http://jabber.org/protocol/muc#user\");\nif (senderRole.getUserAddress() != null) {\nfrag.addElement(\"invite\").addAttribute(\"from\",senderRole.getUserAddress().toBareJID());\n}\nif (reason != null && reason.length() > 0) {\nElement invite=frag.element(\"invite\");\nif (invite == null) {\n  invite=frag.addElement(\"invite\");\n}\ninvite.addElement(\"reason\").setText(reason);\n}\nif (isPasswordProtected()) {\nfrag.addElement(\"password\").setText(getPassword());\n}\nfrag=message.addChildElement(\"x\",\"jabber:x:conference\");\nfrag.addAttribute(\"jid\",role.getRoleAddress().toBareJID());\nrouter.route(message);\n}\n else {\nthrow new ForbiddenException();\n}\n}\n"}
{"INPUT": "@Test public void testRegister(){\n  Set<URL> registered=null;\n  registered=registry.getRegistered();\n  for (int i=0; i < 2; i++) {\n    registry.register(serviceUrl);\n    registered=registry.getRegistered();\n// bug_start\n    assertTrue(registered.contains(serviceUrl.toFullString()));\n// bug_end\n  }\n  registered=registry.getRegistered();\n  assertEquals(1,registered.size());\n}\n"}
{"INPUT": "@Test public void testSwiftInHostAndTestBundleAppleLibraryMacOS() throws Exception {\n  assumeThat(AppleNativeIntegrationTestUtils.isSwiftAvailable(ApplePlatform.MACOSX),is(true));\n  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,\"swift_test_with_host\",tmp);\n  workspace.setUp();\n  workspace.copyRecursively(TestDataHelper.getTestDataDirectory(AppleTestBuilder.class).resolve(\"fbxctest\"),Paths.get(\"fbxctest\"));\n  workspace.addBuckConfigLocalOption(\"apple\",\"xctool_path\",\"fbxctest/bin/fbxctest\");\n  ProjectFilesystem filesystem=TestProjectFilesystems.createProjectFilesystem(workspace.getDestPath());\n  BuildTarget target=workspace.newBuildTarget(\"//:swifttest#macosx-x86_64\");\n  ProcessResult result=workspace.runBuckCommand(\"test\",target.getFullyQualifiedName(),\"--config\",\"cxx.default_platform=macosx-x86_64\");\n  result.assertSuccess();\n  Path binaryOutput=workspace.getPath(BuildTargetPaths.getGenPath(filesystem,target.withAppendedFlavors(InternalFlavor.of(\"macosx-x86_64\"),InternalFlavor.of(\"apple-test-bundle\"),AppleDebugFormat.DWARF.getFlavor(),LinkerMapMode.NO_LINKER_MAP.getFlavor(),AppleDescriptions.NO_INCLUDE_FRAMEWORKS_FLAVOR),\"%s/swifttest.xctest\")).resolve(\"Contents/MacOS/swifttest/\");\n  assertThat(Files.exists(binaryOutput),CoreMatchers.is(true));\n  assertThat(workspace.runCommand(\"file\",binaryOutput.toString()).getStdout().get(),containsString(\"bundle x86_64\"));\n  assertThat(workspace.runCommand(\"otool\",\"-hv\",binaryOutput.toString()).getStdout().get(),containsString(\"X86_64\"));\n  assertThat(workspace.runCommand(\"otool\",\"-L\",binaryOutput.toString()).getStdout().get(),containsString(\"XCTest.framework/Versions/A/XCTest\"));\n// bug_start\n  assertThat(workspace.runCommand(\"otool\",\"-L\",binaryOutput.toString()).getStdout().get(),(containsString(\"@rpath/libswiftCore.dylib\")));\n// bug_end\n}\n"}
{"INPUT": "private Cluster createMockCluster(SecurityType securityType,Collection<Host> hosts,Map<String,Service> services,Map<String,List<ServiceComponentHost>> serviceComponentHosts,StackId currentStackId,final Map<String,Config> clusterConfigs){\n  final Cluster cluster=createMock(Cluster.class);\n  expect(cluster.getSecurityType()).andReturn(securityType).anyTimes();\n  expect(cluster.getClusterName()).andReturn(CLUSTER_NAME).anyTimes();\n  expect(cluster.getClusterId()).andReturn(1L).anyTimes();\n  expect(cluster.getHosts()).andReturn(hosts).anyTimes();\n  expect(cluster.getServices()).andReturn(services).anyTimes();\n  expect(cluster.getCurrentStackVersion()).andReturn(currentStackId).anyTimes();\n  for (  Map.Entry<String,List<ServiceComponentHost>> entry : serviceComponentHosts.entrySet()) {\n    expect(cluster.getServiceComponentHosts(entry.getKey())).andReturn(entry.getValue()).atLeastOnce();\n  }\n  expect(cluster.getServiceComponentHostMap(null,new HashSet<>(Arrays.asList(\"HDFS\",\"ZOOKEEPER\",\"YARN\",\"KNOX\")))).andReturn(null).anyTimes();\n  expect(cluster.getServiceComponentHostMap(null,new HashSet<>(Arrays.asList(\"HDFS\",\"ZOOKEEPER\",\"YARN\")))).andReturn(null).anyTimes();\n  Map<String,String> configTypeService=new HashMap<>();\n  configTypeService.put(\"hdfs-site\",\"HDFS\");\n  configTypeService.put(\"core-site\",\"HDFS\");\n  configTypeService.put(\"hadoop-env\",\"HDFS\");\n  configTypeService.put(\"cluster-env\",null);\n  configTypeService.put(\"kerberos-env\",\"KERBEROS\");\n  configTypeService.put(\"ranger-hdfs-audit\",\"RANGER\");\n  configTypeService.put(\"zookeeper-env\",\"ZOOKEEPER\");\n  configTypeService.put(\"gateway-site\",\"KNOX\");\n  for (  Map.Entry<String,String> entry : configTypeService.entrySet()) {\n// bug_start\n    expect(cluster.getServiceByConfigType(entry.getKey())).andReturn(entry.getValue()).anyTimes();\n// bug_end\n  }\n  for (  Map.Entry<String,Config> entry : clusterConfigs.entrySet()) {\n    expect(cluster.getDesiredConfigByType(entry.getKey())).andReturn(entry.getValue()).anyTimes();\n    expect(cluster.getConfigsByType(entry.getKey())).andReturn(Collections.singletonMap(entry.getKey(),entry.getValue())).anyTimes();\n    expect(cluster.getConfigPropertiesTypes(entry.getKey())).andReturn(Collections.<PropertyInfo.PropertyType,Set<String>>emptyMap()).anyTimes();\n  }\n  return cluster;\n}\n"}
{"INPUT": "@Override protected CloseIndexResponse masterOperation(CloseIndexRequest request,ClusterState state) throws ElasticSearchException {\n  final AtomicReference<CloseIndexResponse> responseRef=new AtomicReference<CloseIndexResponse>();\n  final AtomicReference<Throwable> failureRef=new AtomicReference<Throwable>();\n  final CountDownLatch latch=new CountDownLatch(1);\n// bug_start\n  stateIndexService.closeIndex(new MetaDataStateIndexService.Request(request.index()).timeout(request.timeout()),new MetaDataStateIndexService.Listener(){\n// bug_end\n    @Override public void onResponse(    MetaDataStateIndexService.Response response){\n      responseRef.set(new CloseIndexResponse(response.acknowledged()));\n      latch.countDown();\n    }\n    @Override public void onFailure(    Throwable t){\n      failureRef.set(t);\n      latch.countDown();\n    }\n  }\n);\n  try {\n    latch.await();\n  }\n catch (  InterruptedException e) {\n    failureRef.set(e);\n  }\n  if (failureRef.get() != null) {\n    if (failureRef.get() instanceof ElasticSearchException) {\n      throw (ElasticSearchException)failureRef.get();\n    }\n else {\n      throw new ElasticSearchException(failureRef.get().getMessage(),failureRef.get());\n    }\n  }\n  return responseRef.get();\n}\n"}
{"INPUT": "@Override public boolean equals(Object obj){\n// bug_start\n  if ((obj != null) && (obj instanceof NamingEntry)) {\n// bug_end\n    return name.equals(((NamingEntry)obj).name);\n  }\n else {\n    return false;\n  }\n}\n"}
{"INPUT": "@Override public boolean equals(Object other){\n  if (this == other) {\n    return true;\n  }\n// bug_start\n  if (!(other instanceof MergedContextConfiguration)) {\n// bug_end\n    return false;\n  }\n  MergedContextConfiguration otherConfig=(MergedContextConfiguration)other;\n  if (!Arrays.equals(this.locations,otherConfig.locations)) {\n    return false;\n  }\n  if (!Arrays.equals(this.classes,otherConfig.classes)) {\n    return false;\n  }\n  if (!this.contextInitializerClasses.equals(otherConfig.contextInitializerClasses)) {\n    return false;\n  }\n  if (!Arrays.equals(this.activeProfiles,otherConfig.activeProfiles)) {\n    return false;\n  }\n  if (!Arrays.equals(this.propertySourceLocations,otherConfig.propertySourceLocations)) {\n    return false;\n  }\n  if (!Arrays.equals(this.propertySourceProperties,otherConfig.propertySourceProperties)) {\n    return false;\n  }\n  if (this.parent == null) {\n    if (otherConfig.parent != null) {\n      return false;\n    }\n  }\n else   if (!this.parent.equals(otherConfig.parent)) {\n    return false;\n  }\n  if (!nullSafeToString(this.contextLoader).equals(nullSafeToString(otherConfig.contextLoader))) {\n    return false;\n  }\n  return true;\n}\n"}
{"INPUT": "public static HttpResponseStatus parseLine(CharSequence line){\n  String status=line.toString();\n  try {\n    int space=status.indexOf(' ');\n    if (space == -1) {\n      return valueOf(Integer.parseInt(status));\n    }\n else {\n      int code=Integer.parseInt(status.substring(0,space));\n      String reasonPhrase=status.substring(space + 1);\n      HttpResponseStatus responseStatus=valueOf(code);\n// bug_start\n      if (responseStatus.reasonPhrase().equals(reasonPhrase)) {\n// bug_end\n        return responseStatus;\n      }\n else {\n        return new HttpResponseStatus(code,reasonPhrase);\n      }\n    }\n  }\n catch (  Exception e) {\n    throw new IllegalArgumentException(\"malformed status line: \" + status,e);\n  }\n}\n"}
{"INPUT": "@TaskAction public void doExecute(){\n  AaptOptions aaptOptions=processAndroidResources.getAaptOptions();\n  if (null == aaptOptions) {\n    aaptOptions=new AaptOptions();\n  }\n  if (null == aaptOptions.getAdditionalParameters()) {\n    aaptOptions.setAdditionalParameters(new ArrayList<String>());\n  }\n  if (!appVariantContext.getAtlasExtension().getTBuildConfig().getAaptConstantId()) {\n    aaptOptions.getAdditionalParameters().add(\"--non-constant-id\");\n  }\n  processAndroidResources.setAndroidBuilder(getBuilder());\n  processAndroidResources.setAaptOptions(aaptOptions);\n  ApContext apContext=appVariantContext.apContext;\n  if (null != apContext && apContext.getBaseApk() != null) {\n    File baseApk=appVariantContext.apContext.getBaseApk();\n    if (!aaptOptions.getAdditionalParameters().contains(\"-B\")) {\n      aaptOptions.getAdditionalParameters().add(\"-B\");\n      aaptOptions.getAdditionalParameters().add(baseApk.getAbsolutePath());\n    }\n// bug_start\n    if (appVariantContext.getAtlasExtension().getTBuildConfig().isIncremental() && !appVariantContext.getBuildType().getPatchConfig().isCreateTPatch()) {\n// bug_end\n      aaptOptions.getAdditionalParameters().add(\"--vm-safemode\");\n      aaptOptions.getAdditionalParameters().add(\"--merge\");\n    }\n  }\n}\n"}
{"INPUT": "public Runnable prepareMergeRunnable(){\n  Map<MapContainer,Collection<Record>> recordMap=new HashMap<MapContainer,Collection<Record>>(mapContainers.size());\n  for (  MapContainer mapContainer : mapContainers.values()) {\n    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {\n      RecordStore recordStore=getPartitionContainer(i).getRecordStore(mapContainer.getName());\n// bug_start\n      if (nodeEngine.getPartitionService().getPartitionOwner(i).equals(nodeEngine.getClusterService().getThisAddress())) {\n// bug_end\n        if (!recordMap.containsKey(mapContainer)) {\n          recordMap.put(mapContainer,new ArrayList<Record>());\n        }\n        recordMap.get(mapContainer).addAll(recordStore.getRecords().values());\n      }\n      recordStore.reset();\n    }\n  }\n  return new Merger(recordMap);\n}\n"}
{"INPUT": "@Override public boolean onMenuItemClick(MenuItem item){\n  for (int i=0; i < mDelKeyNames.length(); i++) {\n// bug_start\n    if (mDelKeyNames.getText(i).equals(item.getTitle().toString())) {\n// bug_end\n      mHost.setDelKey(mDelKeyValues.getText(i).toString());\n      mDelKeyText.setText(mDelKeyNames.getText(i));\n      return true;\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "@Override protected String getBlobPath(){\n// bug_start\n  if (getRevision().equals(change.getNewBlobIdent().revision))   return change.getNewBlobIdent().path;\n// bug_end\n else   return change.getOldBlobIdent().path;\n}\n"}
{"INPUT": "@Override protected CrossReport getReport(ModelRequest request,ModelPeriod period,String domain) throws Exception {\n  CrossReport report=super.getReport(request,period,domain);\n// bug_start\n  if (report == null && period.isLast()) {\n// bug_end\n    long startTime=request.getStartTime();\n    report=getReportFromLocalDisk(startTime,domain);\n  }\n  return report;\n}\n"}
{"INPUT": "private static boolean maybeMakeSubdirectory(JobID id,long millisecondTime) throws IOException {\n  Path dir=canonicalHistoryLogPath(id,millisecondTime);\nsynchronized (existingDoneSubdirs) {\n    if (existingDoneSubdirs.contains(dir)) {\n      if (DEBUG_MODE && !DONEDIR_FS.exists(dir)) {\n        System.err.println(\"JobHistory.maybeMakeSubdirectory -- We believed \" + dir + \" already existed, but it didn't.\");\n      }\n      return true;\n    }\n    if (!DONEDIR_FS.exists(dir)) {\n      LOG.info(\"Creating DONE subfolder at \" + dir);\n// bug_start\n      if (!DONEDIR_FS.mkdirs(dir,new FsPermission(HISTORY_DIR_PERMISSION))) {\n// bug_end\n        throw new IOException(\"Mkdirs failed to create \" + dir.toString());\n      }\n      existingDoneSubdirs.add(dir);\n      return false;\n    }\n else {\n      if (DEBUG_MODE) {\n        System.err.println(\"JobHistory.maybeMakeSubdirectory -- We believed \" + dir + \" didn't already exist, but it did.\");\n      }\n      return false;\n    }\n  }\n}\n"}
{"INPUT": "private String getExtraString(){\n  try {\n    VoidProgressMonitor monitor=new VoidProgressMonitor();\n    if (object instanceof DBSObjectReference) {\n// bug_start\n      if (((DBSObjectReference)object).getObjectType() == RelationalObjectType.TYPE_PROCEDURE) {\n// bug_end\n        object=((DBSObjectReference)object).resolveObject(monitor);\n      }\n    }\n    if (object instanceof DBSProcedure) {\n      Collection<? extends DBSProcedureParameter> parameters=((DBSProcedure)object).getParameters(monitor);\n      if (!CommonUtils.isEmpty(parameters)) {\n        StringBuilder params=new StringBuilder();\n        for (        DBSProcedureParameter param : parameters) {\n          if (param.getParameterKind().isInput()) {\n            if (params.length() > 0)             params.append(\", \");\n            params.append(\":\").append(param.getName());\n          }\n        }\n        return \"(\" + params.toString() + \")\";\n      }\n else {\n        return \"()\";\n      }\n    }\n    return null;\n  }\n catch (  DBException e) {\n    log.error(\"Error resolving procedure parameters\",e);\n    return null;\n  }\n}\n"}
{"INPUT": "@Override protected boolean token(XContentParser parser,QueryParseContext context,String field,XContentParser.Token token,Map<String,Object> params) throws IOException {\n// bug_start\n  if (context.getParseFieldMatcher().match(field,SIGMA) && token == XContentParser.Token.VALUE_NUMBER) {\n// bug_end\n    params.put(SIGMA.getPreferredName(),parser.doubleValue());\n    return true;\n  }\n  return false;\n}\n"}
{"INPUT": "@Override public boolean hasNext(){\n  while (this.partitionIndex < partitionHi) {\n    final long hi=reader.openPartition(partitionIndex);\n// bug_start\n    if (hi == -1) {\n// bug_end\n      partitionIndex++;\n    }\n else {\n      frame.partitionIndex=partitionIndex;\n      frame.rowHi=hi;\n      partitionIndex++;\n      return true;\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "private void doStart(Map<String,? extends Lifecycle> lifecycleBeans,String beanName,boolean autoStartupOnly){\n  Lifecycle bean=lifecycleBeans.remove(beanName);\n// bug_start\n  if (bean != null && !this.equals(bean)) {\n// bug_end\n    String[] dependenciesForBean=getBeanFactory().getDependenciesForBean(beanName);\n    for (    String dependency : dependenciesForBean) {\n      doStart(lifecycleBeans,dependency,autoStartupOnly);\n    }\n    if (!bean.isRunning() && (!autoStartupOnly || !(bean instanceof SmartLifecycle) || ((SmartLifecycle)bean).isAutoStartup())) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Starting bean '\" + beanName + \"' of type [\"+ bean.getClass()+ \"]\");\n      }\n      try {\n        bean.start();\n      }\n catch (      Throwable ex) {\n        throw new ApplicationContextException(\"Failed to start bean '\" + beanName + \"'\",ex);\n      }\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Successfully started bean '\" + beanName + \"'\");\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_mi_band_pairing);\n  message=findViewById(R.id.miband_pair_message);\n  Intent intent=getIntent();\n  deviceCandidate=intent.getParcelableExtra(DeviceCoordinator.EXTRA_DEVICE_CANDIDATE);\n  if (deviceCandidate == null && savedInstanceState != null) {\n    deviceCandidate=savedInstanceState.getParcelable(STATE_DEVICE_CANDIDATE);\n  }\n  if (deviceCandidate == null) {\n    Toast.makeText(this,getString(R.string.message_cannot_pair_no_mac),Toast.LENGTH_SHORT).show();\n    startActivity(new Intent(this,DiscoveryActivity.class).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP));\n    finish();\n    return;\n  }\n  DeviceCoordinator coordinator=DeviceHelper.getInstance().getCoordinator(deviceCandidate);\n  GBDevice device=DeviceHelper.getInstance().toSupportedDevice(deviceCandidate);\n// bug_start\n  if (coordinator.supportsDeviceSpecificSettings(device)) {\n// bug_end\n    SharedPreferences sharedPrefs=GBApplication.getDeviceSpecificSharedPrefs(device.getAddress());\n    String authKey=sharedPrefs.getString(\"authkey\",null);\n    if (authKey == null || authKey.isEmpty()) {\n      SharedPreferences.Editor editor=sharedPrefs.edit();\n      String randomAuthkey=RandomStringUtils.random(16,true,true);\n      editor.putString(\"authkey\",randomAuthkey);\n      editor.apply();\n    }\n  }\n  if (!MiBandCoordinator.hasValidUserInfo()) {\n    Intent userSettingsIntent=new Intent(this,MiBandPreferencesActivity.class);\n    startActivityForResult(userSettingsIntent,REQ_CODE_USER_SETTINGS,null);\n    return;\n  }\n  startPairing();\n}\n"}
{"INPUT": "@SuppressWarnings({\"rawtypes\",\"unchecked\"}) public static void localListen(int port,Map<String,SocketAction> actions,ExecutorService service,Class<? extends SocketMain> klass){\n  try {\n    SocketActionTable saTable=new SocketActionTable(actions);\n    final ServerSocket server;\n    try {\n      server=new ServerSocket(port);\n    }\n catch (    IOException e1) {\n      throw Lang.wrapThrow(e1);\n    }\n    if (log.isInfoEnabled())     log.infof(\"Local socket is up at :%d with %d action ready\",port,actions.size());\n    final SocketLock lock=new SocketLock();\n    ExecutorService execs=Executors.newCachedThreadPool();\n    SocketMain main=null;\n    Mirror mirror=Mirror.me(klass);\n    Borning<SocketMain> borning=null;\n    List<SocketAtom> atoms=new LinkedList<SocketAtom>();\n    while (!lock.isStop()) {\n      if (log.isDebugEnabled())       log.debug(\"create new main thread to wait...\");\n      if (borning == null)       borning=mirror.getBorning(atoms,lock,server,service,saTable);\n      main=borning.born(new Object[]{atoms,lock,server,service,saTable});\n      if (log.isDebugEnabled())       log.debug(\"Ready for listen\");\n      execs.execute(main);\n      if (log.isDebugEnabled())       log.debug(\"wait for accept ...\");\n// bug_start\n      while (!main.isAccepted()) {\n// bug_end\n        if (log.isDebugEnabled())         log.debug(\"wait lock ...\");\nsynchronized (lock) {\n          try {\n            lock.wait();\n          }\n catch (          InterruptedException e) {\n            throw Lang.wrapThrow(e);\n          }\n        }\n        if (log.isDebugEnabled())         log.debugf(\"check main accept [%s], lock [%s]\",main.isAccepted(),lock.isStop());\n        if (lock.isStop())         break;\n      }\n      if (log.isDebugEnabled())       log.debug(\"Created a socket\");\n    }\n    if (null != main && !main.isAccepted()) {\n      if (log.isInfoEnabled())       log.info(\"Notify waiting threads...\");\n      try {\n        Socket ss=new Socket(\"127.0.0.1\",port);\n        OutputStream sOut=ss.getOutputStream();\n        sOut.write(\"V~~\".getBytes());\n        sOut.flush();\n        sOut.close();\n        ss.close();\n      }\n catch (      Exception e) {\n      }\n    }\n    if (log.isInfoEnabled())     log.info(\"Stop connected threads...\");\n    while (!execs.isTerminated())     execs.shutdown();\n    if (log.isInfoEnabled())     log.info(\"Close all sockets..\");\n    try {\n      for (      SocketAtom atom : atoms)       Sockets.safeClose(atom.getSocket());\n    }\n catch (    Exception e) {\n    }\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\n finally {\n    if (log.isInfoEnabled())     log.info(\"Stop services ...\");\n    service.shutdown();\n  }\n  if (log.isInfoEnabled())   log.infof(\"Local socket is down for :%d\",port);\n}\n"}
{"INPUT": "private void validateLegacyDestinations(List<IncomingMessage> messages) throws ValidationException {\n  String destination=null;\n  for (  IncomingMessage message : messages) {\n// bug_start\n    if (destination != null && !destination.equals(message.getDestination())) {\n// bug_end\n      throw new ValidationException(\"Multiple account destinations!\");\n    }\n    destination=message.getDestination();\n  }\n}\n"}
{"INPUT": "@Override public void postprocess(){\n// bug_start\n  if (anchor != null && OptEliminateGuards.getValue(activeGuards.graph().getOptions())) {\n// bug_end\n    for (    GuardNode guard : anchor.asNode().usages().filter(GuardNode.class)) {\n      if (activeGuards.isMarkedAndGrow(guard)) {\n        activeGuards.clear(guard);\n      }\n    }\n  }\n}\n"}
{"INPUT": "private static void copyProperties(Object source,Object target,Class<?> editable,String... ignoreProperties) throws BeansException {\n  Assert.notNull(source,\"Source must not be null\");\n  Assert.notNull(target,\"Target must not be null\");\n  Class<?> actualEditable=target.getClass();\n  if (editable != null) {\n    if (!editable.isInstance(target)) {\n      throw new IllegalArgumentException(\"Target class [\" + target.getClass().getName() + \"] not assignable to Editable class [\"+ editable.getName()+ \"]\");\n    }\n    actualEditable=editable;\n  }\n  PropertyDescriptor[] targetPds=getPropertyDescriptors(actualEditable);\n  List<String> ignoreList=(ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null;\n  for (  PropertyDescriptor targetPd : targetPds) {\n    Method writeMethod=targetPd.getWriteMethod();\n    if (writeMethod != null && (ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {\n      PropertyDescriptor sourcePd=getPropertyDescriptor(source.getClass(),targetPd.getName());\n      if (sourcePd != null) {\n        Method readMethod=sourcePd.getReadMethod();\n// bug_start\n        if (readMethod != null && writeMethod.getParameterTypes()[0].isAssignableFrom(readMethod.getReturnType())) {\n// bug_end\n          try {\n            if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n              readMethod.setAccessible(true);\n            }\n            Object value=readMethod.invoke(source);\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n              writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(target,value);\n          }\n catch (          Throwable ex) {\n            throw new FatalBeanException(\"Could not copy property '\" + targetPd.getName() + \"' from source to target\",ex);\n          }\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "public View getView(final int position,View convertView,ViewGroup parent){\n  if (convertView == null) {\n    convertView=mInflater.inflate(R.layout.view_key_subkey_item,null);\n    final ViewHolder holder=new ViewHolder();\n    holder.vKeyId=(TextView)convertView.findViewById(R.id.subkey_item_key_id);\n    holder.vKeyDetails=(TextView)convertView.findViewById(R.id.subkey_item_details);\n    holder.vKeyExpiry=(TextView)convertView.findViewById(R.id.subkey_item_expiry);\n    holder.vCertifyIcon=(ImageView)convertView.findViewById(R.id.subkey_item_ic_certify);\n    holder.vEncryptIcon=(ImageView)convertView.findViewById(R.id.subkey_item_ic_encrypt);\n    holder.vSignIcon=(ImageView)convertView.findViewById(R.id.subkey_item_ic_sign);\n    holder.vDelete=(ImageButton)convertView.findViewById(R.id.subkey_item_delete_button);\n    holder.vDelete.setVisibility(View.VISIBLE);\n    ImageView editImage=(ImageView)convertView.findViewById(R.id.subkey_item_edit_image);\n    editImage.setVisibility(View.GONE);\n    ImageView revokedIcon=(ImageView)convertView.findViewById(R.id.subkey_item_ic_revoked);\n    revokedIcon.setVisibility(View.GONE);\n    convertView.setTag(holder);\n    holder.vDelete.setOnClickListener(new View.OnClickListener(){\n      @Override public void onClick(      View v){\n        SubkeysAddedAdapter.this.remove(holder.mModel);\n      }\n    }\n);\n  }\n  final ViewHolder holder=(ViewHolder)convertView.getTag();\n  holder.mModel=getItem(position);\n  String algorithmStr=PgpKeyHelper.getAlgorithmInfo(mActivity,holder.mModel.mAlgorithm,holder.mModel.mKeysize);\n  holder.vKeyId.setText(R.string.edit_key_new_subkey);\n  holder.vKeyDetails.setText(algorithmStr);\n// bug_start\n  if (holder.mModel.mExpiry != null) {\n// bug_end\n    Date expiryDate=new Date(holder.mModel.mExpiry * 1000);\n    holder.vKeyExpiry.setText(getContext().getString(R.string.label_expiry) + \": \" + DateFormat.getDateFormat(getContext()).format(expiryDate));\n  }\n else {\n    holder.vKeyExpiry.setText(getContext().getString(R.string.label_expiry) + \": \" + getContext().getString(R.string.none));\n  }\n  int flags=holder.mModel.mFlags;\n  if ((flags & KeyFlags.CERTIFY_OTHER) > 0) {\n    holder.vCertifyIcon.setVisibility(View.VISIBLE);\n  }\n else {\n    holder.vCertifyIcon.setVisibility(View.GONE);\n  }\n  if ((flags & KeyFlags.SIGN_DATA) > 0) {\n    holder.vSignIcon.setVisibility(View.VISIBLE);\n  }\n else {\n    holder.vSignIcon.setVisibility(View.GONE);\n  }\n  if (((flags & KeyFlags.ENCRYPT_COMMS) > 0) || ((flags & KeyFlags.ENCRYPT_STORAGE) > 0)) {\n    holder.vEncryptIcon.setVisibility(View.VISIBLE);\n  }\n else {\n    holder.vEncryptIcon.setVisibility(View.GONE);\n  }\n  return convertView;\n}\n"}
{"INPUT": "public void execute(OperationContext context,ModelNode operation) throws OperationFailedException {\n  validator.validate(operation);\n  final ModelNode opAddr=operation.get(OP_ADDR);\n  PathAddress address=PathAddress.pathAddress(opAddr);\n  final String name=address.getLastElement().getValue();\n  final String runtimeName=operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : name;\n  final ModelNode content=operation.require(CONTENT).clone();\n  final DeploymentHandlerUtil.ContentItem contentItem;\n  final ModelNode contentItemNode=content.require(0);\n  if (contentItemNode.hasDefined(HASH)) {\n    managedContentValidator.validate(contentItemNode);\n    byte[] hash=contentItemNode.require(HASH).asBytes();\n    contentItem=addFromHash(hash,contentItemNode);\n  }\n else   if (hasValidContentAdditionParameterDefined(contentItemNode)) {\n    contentItem=addFromContentAdditionParameter(context,contentItemNode);\n  }\n else {\n    contentItem=addUnmanaged(contentItemNode);\n  }\n  final Resource resource=context.createResource(PathAddress.EMPTY_ADDRESS);\n  ModelNode subModel=resource.getModel();\n  subModel.get(NAME).set(name);\n  subModel.get(RUNTIME_NAME).set(runtimeName);\n  subModel.get(CONTENT).set(content);\n  subModel.get(ENABLED).set(operation.has(ENABLED) && operation.get(ENABLED).asBoolean());\n  subModel.get(PERSISTENT).set(!operation.hasDefined(PERSISTENT) || operation.get(PERSISTENT).asBoolean());\n// bug_start\n  if (subModel.get(ENABLED).asBoolean() && (context.getType() == OperationContext.Type.SERVER)) {\n// bug_end\n    DeploymentHandlerUtil.deploy(context,runtimeName,name,contentItem);\n  }\n  context.completeStep();\n}\n"}
{"INPUT": "@Override public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (obj == null)   return false;\n// bug_start\n  if (getClass() != obj.getClass())   return false;\n// bug_end\n  PaymentTransactionType other=(PaymentTransactionType)obj;\n  if (type == null) {\n    if (other.type != null)     return false;\n  }\n else   if (!type.equals(other.type))   return false;\n  return true;\n}\n"}
{"INPUT": "@Override public Mapper.Builder<?,?> parse(String name,Map<String,Object> node,ParserContext parserContext) throws MapperParsingException {\n  Builder builder;\n// bug_start\n  if (parserContext.indexVersionCreated().onOrBefore(Version.CURRENT)) {\n// bug_end\n    builder=new GeoPointFieldMapperLegacy.Builder(name);\n  }\n else {\n    builder=new GeoPointFieldMapper.Builder(name);\n  }\n  parseField(builder,name,node,parserContext);\n  for (Iterator<Map.Entry<String,Object>> iterator=node.entrySet().iterator(); iterator.hasNext(); ) {\n    Map.Entry<String,Object> entry=iterator.next();\n    String propName=Strings.toUnderscoreCase(entry.getKey());\n    Object propNode=entry.getValue();\n    if (propName.equals(\"lat_lon\")) {\n      builder.enableLatLon(XContentMapValues.nodeBooleanValue(propNode));\n      iterator.remove();\n    }\n else     if (propName.equals(\"precision_step\")) {\n      builder.precisionStep(XContentMapValues.nodeIntegerValue(propNode));\n      iterator.remove();\n    }\n else     if (propName.equals(\"geohash\")) {\n      builder.enableGeoHash(XContentMapValues.nodeBooleanValue(propNode));\n      iterator.remove();\n    }\n else     if (propName.equals(\"geohash_prefix\")) {\n      builder.geoHashPrefix(XContentMapValues.nodeBooleanValue(propNode));\n      if (XContentMapValues.nodeBooleanValue(propNode)) {\n        builder.enableGeoHash(true);\n      }\n      iterator.remove();\n    }\n else     if (propName.equals(\"geohash_precision\")) {\n      if (propNode instanceof Integer) {\n        builder.geoHashPrecision(XContentMapValues.nodeIntegerValue(propNode));\n      }\n else {\n        builder.geoHashPrecision(GeoUtils.geoHashLevelsForPrecision(propNode.toString()));\n      }\n      iterator.remove();\n    }\n else     if (propName.equals(Names.IGNORE_MALFORMED)) {\n      builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode));\n      iterator.remove();\n    }\n else     if (parseMultiField(builder,name,parserContext,propName,propNode)) {\n      iterator.remove();\n    }\n  }\n  if (builder instanceof GeoPointFieldMapperLegacy.Builder) {\n    return GeoPointFieldMapperLegacy.parse((GeoPointFieldMapperLegacy.Builder)builder,node,parserContext);\n  }\n  return (GeoPointFieldMapper.Builder)builder;\n}\n"}
{"INPUT": "Memory writePushCall(CallExprToken function,boolean returnValue,boolean writeOpcode,PushCallStatistic statistic){\n  Token name=function.getName();\n  if (name instanceof NameToken) {\n    String realName=((NameToken)name).getName();\n    CompileFunction compileFunction=compiler.getScope().findCompileFunction(realName);\n// bug_start\n    if (compileFunction == null && name instanceof FulledNameToken && compiler.getEnvironment().functionMap.get(realName.toLowerCase()) == null && compiler.findFunction(realName) == null) {\n// bug_end\n      String tryName=((FulledNameToken)name).getLastName().getName();\n      compileFunction=compiler.getScope().findCompileFunction(tryName);\n    }\n    if (compileFunction != null) {\n      return writePushCompileFunction(function,compileFunction,returnValue,writeOpcode,statistic);\n    }\n else {\n      if (!writeOpcode)       return null;\n      method.entity.setImmutable(false);\n      int index=method.clazz.getAndIncCallFuncCount();\n      writePushEnv();\n      writePushTraceInfo(function);\n      writePushString(realName.toLowerCase());\n      writePushString(realName);\n      writePushParameters(function.getParameters());\n      writeGetStatic(\"$CALL_FUNC_CACHE\",FunctionCallCache.class);\n      writePushConstInt(index);\n      writeSysStaticCall(InvokeHelper.class,\"call\",Memory.class,Environment.class,TraceInfo.class,String.class,String.class,Memory[].class,FunctionCallCache.class,Integer.TYPE);\n      if (!returnValue)       writePopAll(1);\n    }\n  }\n else   if (name instanceof StaticAccessExprToken) {\n    method.entity.setImmutable(false);\n    if (((StaticAccessExprToken)name).isAsParent())     return writePushParentDynamicMethod(function,returnValue,writeOpcode,statistic);\n else     return writePushStaticMethod(function,returnValue,writeOpcode,statistic);\n  }\n else   if (name instanceof DynamicAccessExprToken) {\n    method.entity.setImmutable(false);\n    return writePushDynamicMethod(function,returnValue,writeOpcode,statistic);\n  }\n else {\n    if (!writeOpcode)     return null;\n    method.entity.setImmutable(false);\n    writeLineNumber(function);\n    writePush((ValueExprToken)function.getName(),true,false);\n    writePopBoxing();\n    writePushParameters(function.getParameters());\n    writePushEnv();\n    writePushTraceInfo(function);\n    writeSysStaticCall(InvokeHelper.class,\"callAny\",Memory.class,Memory.class,Memory[].class,Environment.class,TraceInfo.class);\n    if (!returnValue)     writePopAll(1);\n  }\n  return null;\n}\n"}
{"INPUT": "public static String javaTypeToJvmSignature(String[] javaTypeArray){\n// bug_start\n  if (javaTypeArray == null || javaTypeArray.length == 0) {\n// bug_end\n    return \"()\";\n  }\n  final StringBuilder buffer=new StringBuilder();\n  buffer.append('(');\n  for (  String javaType : javaTypeArray) {\n    final String jvmSignature=toJvmSignature(javaType);\n    buffer.append(jvmSignature);\n  }\n  buffer.append(')');\n  return buffer.toString();\n}\n"}
{"INPUT": "@Override public Font getFont(Object element){\n  if (NavigatorUtils.isDefaultElement(element)) {\n    return boldFont;\n  }\n else {\n    if (element instanceof DBNDataSource) {\n      final DBPDataSourceContainer ds=((DBNDataSource)element).getDataSourceContainer();\n// bug_start\n      if (ds != null && ds.isProvided()) {\n// bug_end\n        return italicFont;\n      }\n    }\n    return normalFont;\n  }\n}\n"}
{"INPUT": "public SootMethod resolveNonSpecial(RefType t,NumberedString subSig){\n  SmallNumberedMap vtbl=(SmallNumberedMap)typeToVtbl.get(t);\n  if (vtbl == null) {\n    typeToVtbl.put(t,vtbl=new SmallNumberedMap(Scene.v().getMethodNumberer()));\n  }\n  SootMethod ret=(SootMethod)vtbl.get(subSig);\n  if (ret != null)   return ret;\n  SootClass cls=(t).getSootClass();\n  if (cls.declaresMethod(subSig)) {\n    SootMethod m=cls.getMethod(subSig);\n// bug_start\n    if (m.isConcrete() || m.isNative()) {\n// bug_end\n      ret=cls.getMethod(subSig);\n    }\n  }\n else {\n    if (cls.hasSuperclass()) {\n      ret=resolveNonSpecial(cls.getSuperclass().getType(),subSig);\n    }\n  }\n  vtbl.put(subSig,ret);\n  return ret;\n}\n"}
{"INPUT": "@Override public String process() throws Throwable {\n  String bizName=nameCommandOption.getArgs()[0];\n  String bizVersion=versionCommandOption.getArgs()[0];\n  Biz biz=bizManagerService.getBiz(bizName,bizVersion);\n  if (biz != null) {\n// bug_start\n    if (biz.getBizState() == BizState.UNRESOLVED || biz.getBizState() != BizState.RESOLVED || biz.getBizState() != BizState.BROKEN) {\n// bug_end\n      LOGGER.info(String.format(\"The specified biz's state must not be %s.\",biz.getBizState()));\n      return String.format(\"The specified biz's state must not be %s.\",biz.getBizState());\n    }\n else {\n      bizManagerService.activeBiz(bizName,bizVersion);\n      LOGGER.info(String.format(\"Switch biz:\\'%s\\' to be activated.\",biz.getIdentity()));\n      return String.format(\"Biz:\\'%s\\' is activated.\",biz.getIdentity());\n    }\n  }\n else {\n    LOGGER.info(\"The specified biz does not exists.\");\n    return \"The specified biz does not exists.\";\n  }\n}\n"}
{"INPUT": "@TargetApi(Build.VERSION_CODES.O) public void setItemInfo(final ItemInfo info){\n// bug_start\n  if (!(FeatureFlags.LAUNCHER3_SPRING_ICONS && Utilities.isAtLeastO())) {\n// bug_end\n    return;\n  }\n  if (info.itemType != LauncherSettings.Favorites.ITEM_TYPE_APPLICATION && info.itemType != LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT && info.itemType != LauncherSettings.Favorites.ITEM_TYPE_FOLDER) {\n    return;\n  }\n  final Looper workerLooper=LauncherModel.getWorkerLooper();\n  new Handler(workerLooper).postAtFrontOfQueue(new Runnable(){\n    @Override public void run(){\n      LauncherAppState appState=LauncherAppState.getInstance(mLauncher);\n      Object[] outObj=new Object[1];\n      final Drawable dr=getFullDrawable(info,appState,outObj);\n      if (dr instanceof AdaptiveIconDrawable) {\n        int w=mBitmap.getWidth();\n        int h=mBitmap.getHeight();\n        int blurMargin=(int)mLauncher.getResources().getDimension(R.dimen.blur_size_medium_outline) / 2;\n        Rect bounds=new Rect(0,0,w,h);\n        bounds.inset(blurMargin,blurMargin);\n        Rect badgeBounds=new Rect(bounds);\n        mBadge=getBadge(info,appState,outObj[0]);\n        mBadge.setBounds(badgeBounds);\n        Utilities.scaleRectAboutCenter(bounds,IconNormalizer.getInstance(mLauncher).getScale(dr,null,null,null));\n        AdaptiveIconDrawable adaptiveIcon=(AdaptiveIconDrawable)dr;\n        Rect shrunkBounds=new Rect(bounds);\n        Utilities.scaleRectAboutCenter(shrunkBounds,0.98f);\n        adaptiveIcon.setBounds(shrunkBounds);\n        final Path mask=adaptiveIcon.getIconMask();\n        mTranslateX=new SpringFloatValue(DragView.this,w * AdaptiveIconDrawable.getExtraInsetFraction());\n        mTranslateY=new SpringFloatValue(DragView.this,h * AdaptiveIconDrawable.getExtraInsetFraction());\n        bounds.inset((int)(-bounds.width() * AdaptiveIconDrawable.getExtraInsetFraction()),(int)(-bounds.height() * AdaptiveIconDrawable.getExtraInsetFraction()));\n        mBgSpringDrawable=adaptiveIcon.getBackground();\n        if (mBgSpringDrawable == null) {\n          mBgSpringDrawable=new ColorDrawable(Color.TRANSPARENT);\n        }\n        mBgSpringDrawable.setBounds(bounds);\n        mFgSpringDrawable=adaptiveIcon.getForeground();\n        if (mFgSpringDrawable == null) {\n          mFgSpringDrawable=new ColorDrawable(Color.TRANSPARENT);\n        }\n        mFgSpringDrawable.setBounds(bounds);\n        new Handler(Looper.getMainLooper()).post(new Runnable(){\n          @Override public void run(){\n            mScaledMaskPath=mask;\n            mDrawBitmap=!(dr instanceof FolderAdaptiveIcon);\n            if (info.isDisabled()) {\n              FastBitmapDrawable d=new FastBitmapDrawable(null);\n              d.setIsDisabled(true);\n              mBaseFilter=(ColorMatrixColorFilter)d.getColorFilter();\n            }\n            updateColorFilter();\n          }\n        }\n);\n      }\n    }\n  }\n);\n}\n"}
{"INPUT": "private void write(final TBase<?,?> base,final String fieldName,final List<ByteArrayOutput> list) throws TException {\n  final TReplaceListProtocol protocol=new TReplaceListProtocol(protocolFactory.getProtocol(transport));\n  writeChunkHeader(protocol);\n  writeHeader(protocol,locator.headerLookup(base));\n// bug_start\n  if (list != null && list.size() > 0) {\n// bug_end\n    protocol.addReplaceField(fieldName,list);\n  }\n  base.write(protocol);\n  if (isNeedFlush()) {\n    flush();\n  }\n}\n"}
{"INPUT": "@Override public boolean equals(Object other){\n  if (this == other) {\n    return true;\n  }\n// bug_start\n  if (other == null || getClass() != other.getClass()) {\n// bug_end\n    return false;\n  }\n  MethodParameter otherParam=(MethodParameter)other;\n  return (this.parameterIndex == otherParam.parameterIndex && getExecutable().equals(otherParam.getExecutable()));\n}\n"}
{"INPUT": "public List<Subscriber> getSubscribers(String serviceName,String namespaceId,boolean aggregation) throws InterruptedException {\n  if (aggregation) {\n    if (memberManager.getServerList().size() <= 1) {\n      return getSubscribersFuzzy(serviceName,namespaceId);\n    }\n    List<Subscriber> subscriberList=new ArrayList<Subscriber>();\n    for (    Member server : memberManager.allMembers()) {\n      Map<String,String> paramValues=new HashMap<>(128);\n      paramValues.put(CommonParams.SERVICE_NAME,serviceName);\n      paramValues.put(CommonParams.NAMESPACE_ID,namespaceId);\n      paramValues.put(\"aggregation\",String.valueOf(Boolean.FALSE));\n      if (NetUtils.localServer().equals(server.getAddress())) {\n        subscriberList.addAll(getSubscribersFuzzy(serviceName,namespaceId));\n        continue;\n      }\n      RestResult<String> result=HttpClient.httpGet(\"http://\" + server.getAddress() + ApplicationUtils.getContextPath()+ UtilsAndCommons.NACOS_NAMING_CONTEXT+ SUBSCRIBER_ON_SYNC_URL,new ArrayList<>(),paramValues);\n// bug_start\n      if (!result.ok()) {\n// bug_end\n        Subscribers subscribers=JacksonUtils.toObj(result.getData(),Subscribers.class);\n        subscriberList.addAll(subscribers.getSubscribers());\n      }\n    }\n    return CollectionUtils.isNotEmpty(subscriberList) ? subscriberList.stream().filter(distinctByKey(null)).collect(Collectors.toList()) : Collections.EMPTY_LIST;\n  }\n else {\n    return getSubscribersFuzzy(serviceName,namespaceId);\n  }\n}\n"}
{"INPUT": "private static int sessionVarCheck(String stmt,int offset){\n  String s=stmt.substring(offset).toLowerCase();\n  if (s.startsWith(\"session.auto_increment_increment\")) {\n// bug_start\n    if (s.length() > 32 && s.charAt(32) == ',') {\n// bug_end\n      return SELECT_VAR_ALL;\n    }\n    return SESSION_INCREMENT;\n  }\n else   if (s.startsWith(\"session.tx_isolation\")) {\n    return SESSION_ISOLATION;\n  }\n else {\n    return OTHER;\n  }\n}\n"}
{"INPUT": "public String getPath(ABC abc){\n  for (  Trait t : traits.traits) {\n    Multiname name=t.getName(abc);\n    Namespace ns=name.getNamespace(abc.constants);\n// bug_start\n    if (ns.kind == Namespace.KIND_PACKAGE) {\n// bug_end\n      return ns.getName(abc.constants) + \".\" + name.getName(abc.constants,new ArrayList<String>());\n    }\n  }\n  return \"\";\n}\n"}
{"INPUT": "@Override protected PostgreSchema fetchObject(@NotNull JDBCSession session,@NotNull PostgreDatabase owner,@NotNull JDBCResultSet resultSet) throws SQLException, DBException {\n  String name=JDBCUtils.safeGetString(resultSet,\"nspname\");\n  if (name == null) {\n    return null;\n  }\n// bug_start\n  if (PostgreSchema.isUtilitySchema(name) && !owner.getDataSource().getContainer().isShowUtilityObjects()) {\n// bug_end\n    return null;\n  }\n  return new PostgreSchema(owner,name,resultSet);\n}\n"}
{"INPUT": "public void waitForStreaming() throws InterruptedException {\n  for (  DebuggableThreadPoolExecutor e : streamExecutors.values())   e.shutdown();\n  for (  DebuggableThreadPoolExecutor e : streamExecutors.values()) {\n// bug_start\n    if (e.awaitTermination(24,TimeUnit.HOURS))     logger_.error(\"Stream took more than 24H to complete; skipping\");\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public List<Word> segImpl(final String text){\n  List<Word> wordsRMIM=RMIM.seg(text);\n  List<Word> wordsMIM=MIM.seg(text);\n// bug_start\n  if (wordsRMIM.size() == wordsMIM.size() && wordsRMIM.toString().equals(wordsMIM.toString())) {\n// bug_end\n    return wordsRMIM;\n  }\n  Map<List<Word>,Float> words=Bigram.bigram(wordsRMIM,wordsMIM);\n  float score=words.get(wordsRMIM);\n  LOGGER.debug(\"\" + wordsRMIM.toString() + \" : =\"+ score);\n  List<Word> result=wordsRMIM;\n  float max=score;\n  score=words.get(wordsMIM);\n  LOGGER.debug(\"\" + wordsMIM.toString() + \" : =\"+ score);\n  if (score > max) {\n    result=wordsMIM;\n    max=score;\n  }\n  LOGGER.debug(\"\" + max + \", \"+ result);\n  return result;\n}\n"}
{"INPUT": "private void searchForCandidateBroker(NamespaceBundle bundle,CompletableFuture<Optional<LookupResult>> lookupFuture,boolean authoritative){\n  String candidateBroker=null;\n  try {\n    candidateBroker=checkHeartbeatNamespace(bundle);\n    if (candidateBroker == null) {\n      String broker=getSLAMonitorBrokerName(bundle);\n      if (broker != null && isBrokerActive(broker)) {\n        candidateBroker=broker;\n      }\n    }\n    if (candidateBroker == null) {\n// bug_start\n      if (!this.loadManager.get().isCentralized() || pulsar.getLeaderElectionService().isLeader()) {\n// bug_end\n        Optional<String> availableBroker=getLeastLoadedFromLoadManager(bundle);\n        if (!availableBroker.isPresent()) {\n          lookupFuture.complete(Optional.empty());\n          return;\n        }\n        candidateBroker=availableBroker.get();\n      }\n else {\n        if (authoritative) {\n          candidateBroker=pulsar.getWebServiceAddress();\n        }\n else {\n          candidateBroker=pulsar.getLeaderElectionService().getCurrentLeader().getServiceUrl();\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    LOG.warn(\"Error when searching for candidate broker to acquire {}: {}\",bundle,e.getMessage(),e);\n    lookupFuture.completeExceptionally(e);\n    return;\n  }\n  try {\n    checkNotNull(candidateBroker);\n    if (pulsar.getWebServiceAddress().equals(candidateBroker)) {\n      ownershipCache.tryAcquiringOwnership(bundle).thenAccept(null).exceptionally(null);\n    }\n else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Redirecting to broker {} to acquire ownership of bundle {}\",candidateBroker,bundle);\n      }\n      createLookupResult(candidateBroker).thenAccept(null).exceptionally(null);\n    }\n  }\n catch (  Exception e) {\n    LOG.warn(\"Error in trying to acquire namespace bundle ownership for {}: {}\",bundle,e.getMessage(),e);\n    lookupFuture.completeExceptionally(e);\n  }\n}\n"}
{"INPUT": "public void addToMethod(DexMaker dexMaker,MethodId<?,?> method){\n  if (annotatedElement != ElementType.METHOD) {\n    throw new IllegalStateException(\"This annotation is not for method\");\n  }\n// bug_start\n  if (method.declaringType != declaringType) {\n// bug_end\n    throw new IllegalArgumentException(\"Method\" + method + \"'s declaring type is inconsistent with\"+ this);\n  }\n  ClassDefItem classDefItem=dexMaker.getTypeDeclaration(declaringType).toClassDefItem();\n  if (classDefItem == null) {\n    throw new NullPointerException(\"No class defined item is found\");\n  }\n else {\n    CstMethodRef cstMethodRef=method.constant;\n    if (cstMethodRef == null) {\n      throw new NullPointerException(\"Method reference is NULL\");\n    }\n else {\n      CstType cstType=CstType.intern(type.ropType);\n      Annotation annotation=new Annotation(cstType,AnnotationVisibility.RUNTIME);\n      Annotations annotations=new Annotations();\n      for (      NameValuePair nvp : elements.values()) {\n        annotation.add(nvp);\n      }\n      annotations.add(annotation);\n      classDefItem.addMethodAnnotations(cstMethodRef,annotations,dexMaker.getDexFile());\n    }\n  }\n}\n"}
{"INPUT": "@Override public ImageDecoder createImageDecoder(boolean preferAnimation) throws IOException {\n  AssetFileDescriptor assetFd=null;\n  try {\n// bug_start\n    if (mUri.getScheme() == ContentResolver.SCHEME_CONTENT) {\n// bug_end\n      assetFd=mResolver.openTypedAssetFileDescriptor(mUri,\"image/*\",null);\n    }\n else {\n      assetFd=mResolver.openAssetFileDescriptor(mUri,\"r\");\n    }\n  }\n catch (  FileNotFoundException e) {\n    InputStream is=mResolver.openInputStream(mUri);\n    if (is == null) {\n      throw new FileNotFoundException(mUri.toString());\n    }\n    return createFromStream(is,true,preferAnimation,this);\n  }\n  if (assetFd == null) {\n    throw new FileNotFoundException(mUri.toString());\n  }\n  return createFromAssetFileDescriptor(assetFd,preferAnimation,this);\n}\n"}
{"INPUT": "void onAnimationFinished(){\n  if (DEBUG_ANIM)   Slog.v(TAG,\"Animation done in \" + this + \": exiting=\"+ mWin.mAnimatingExit+ \", reportedVisible=\"+ (mWin.mActivityRecord != null ? mWin.mActivityRecord.reportedVisible : false));\n  mWin.checkPolicyVisibilityChange();\n  final DisplayContent displayContent=mWin.getDisplayContent();\n// bug_start\n  if (mAttrType == LayoutParams.TYPE_STATUS_BAR && mWin.isVisibleByPolicy()) {\n// bug_end\n    displayContent.setLayoutNeeded();\n  }\n  mWin.onExitAnimationDone();\n  displayContent.pendingLayoutChanges|=FINISH_LAYOUT_REDO_ANIM;\n  if (displayContent.mWallpaperController.isWallpaperTarget(mWin)) {\n    displayContent.pendingLayoutChanges|=FINISH_LAYOUT_REDO_WALLPAPER;\n  }\n  if (DEBUG_LAYOUT_REPEATS) {\n    mService.mWindowPlacerLocked.debugLayoutRepeats(\"WindowStateAnimator\",displayContent.pendingLayoutChanges);\n  }\n  if (mWin.mActivityRecord != null) {\n    mWin.mActivityRecord.updateReportedVisibilityLocked();\n  }\n}\n"}
{"INPUT": "private boolean isReasonableMethod(Class<?> clazz,String methodName){\n  if (\"hashCode\".equals(methodName) || \"equals\".equals(methodName)) {\n    return false;\n  }\n  if (Collection.class.isAssignableFrom(clazz)) {\n    if (checkCollectionMethods(methodName)) {\n      return false;\n    }\n  }\n  if (Set.class.isAssignableFrom(clazz)) {\n    if (checkCollectionMethods(methodName)) {\n      return false;\n    }\n  }\n  if (List.class.isAssignableFrom(clazz)) {\n// bug_start\n    if (checkCollectionMethods(methodName) || \"listIterator\".equals(methodName) || \"lastIndexOf\".equals(methodName)|| \"indexOf\".equals(methodName)|| \"subList\".equals(methodName)) {\n// bug_end\n      return false;\n    }\n  }\n  if (Map.class.isAssignableFrom(clazz)) {\n    if (\"get\".equals(methodName) || \"isEmpty\".equals(methodName) || \"containsKey\".equals(methodName)|| \"values\".equals(methodName)|| \"entrySet\".equals(methodName)|| \"containsValue\".equals(methodName)|| \"keySet\".equals(methodName)|| \"size\".equals(methodName)) {\n      return false;\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "@Nullable private Function createAdditionalComparison(Function function,GeneratedReference generatedReference,Symbol comparedAgainst){\n  if (generatedReference != null && generatedReference.generatedExpression().symbolType().equals(SymbolType.FUNCTION)) {\n    Function generatedFunction=(Function)generatedReference.generatedExpression();\n    String operatorName=function.info().ident().name();\n    if (!operatorName.equals(EqOperator.NAME)) {\n// bug_start\n      if (!generatedFunction.info().features().contains(FunctionInfo.Feature.COMPARISON_REPLACEMENT)) {\n// bug_end\n        return null;\n      }\n      if (ROUNDING_FUNCTIONS.contains(generatedFunction.info().ident().name())) {\n        String replacedOperatorName=ROUNDING_FUNCTION_MAPPING.get(operatorName);\n        if (replacedOperatorName != null) {\n          operatorName=replacedOperatorName;\n        }\n      }\n    }\n    Symbol wrapped=wrapInGenerationExpression(comparedAgainst,generatedReference);\n    FunctionInfo comparisonFunctionInfo=new FunctionInfo(new FunctionIdent(operatorName,Arrays.asList(generatedReference.valueType(),wrapped.valueType())),DataTypes.BOOLEAN);\n    return new Function(comparisonFunctionInfo,Arrays.asList(generatedReference,wrapped));\n  }\n  return null;\n}\n"}
{"INPUT": "@Override public Collection<DatabasePacket> execute(){\n// bug_start\n  if (ProxySchemaContexts.getInstance().isCircuitBreak()) {\n// bug_end\n    return Collections.singletonList(new MySQLErrPacket(1,CommonErrorCode.CIRCUIT_BREAK_MODE));\n  }\n  BackendResponse backendResponse=databaseCommunicationEngine.execute();\n  if (backendResponse instanceof ErrorResponse) {\n    isErrorResponse=true;\n    return Collections.singletonList(createErrorPacket(((ErrorResponse)backendResponse).getCause()));\n  }\n  if (backendResponse instanceof UpdateResponse) {\n    isUpdateResponse=true;\n    return Collections.singletonList(createUpdatePacket((UpdateResponse)backendResponse));\n  }\n  isQuery=true;\n  return createQueryPacket((QueryResponse)backendResponse);\n}\n"}
{"INPUT": "private Table getTable(ParseContext parseContext,Operator<? extends OperatorDesc> op,List<TableScanOperator> tableScanOpsForJoin){\n  while (true) {\n    if (op instanceof TableScanOperator) {\n      TableScanOperator tsOp=(TableScanOperator)op;\n      if (tableScanOpsForJoin.contains(tsOp)) {\n        return parseContext.getTopToTable().get(tsOp);\n      }\n    }\n// bug_start\n    if ((op.getParentOperators() == null) || (op.getParentOperators().size() > 1)) {\n// bug_end\n      return null;\n    }\n    op=op.getParentOperators().get(0);\n  }\n}\n"}
{"INPUT": "@Override void analyze(Locals locals){\n  if (write) {\n    throw createError(new IllegalArgumentException(\"Can't write to null safe reference\"));\n  }\n  guarded.read=read;\n  guarded.analyze(locals);\n  actual=guarded.actual;\n// bug_start\n  if (actual.sort.primitive) {\n// bug_end\n    throw new IllegalArgumentException(\"Result of null safe operator must be nullable\");\n  }\n}\n"}
{"INPUT": "private boolean isAddressAllowed(Packet packet){\n  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);\n  if (packet.uid == Process.myUid())   return true;\n  packet.allowed=false;\n// bug_start\n  if (packet.protocol == 6 || packet.protocol == 17) {\n// bug_end\n    if (prefs.getBoolean(\"filter\",false)) {\n      if (packet.uid <= 0)       packet.allowed=true;\n else {\n        boolean filtered=false;\nsynchronized (mapUidIPFilters) {\n          if (mapUidIPFilters.containsKey(packet.uid))           try {\n            InetAddress iaddr=InetAddress.getByName(packet.daddr);\n            Map<InetAddress,Boolean> map=mapUidIPFilters.get(packet.uid).get(packet.dport);\n            if (map != null && map.containsKey(iaddr)) {\n              filtered=true;\n              packet.allowed=!mapUidIPFilters.get(packet.uid).get(packet.dport).get(iaddr);\n              Log.i(TAG,\"Filtering uid=\" + packet.uid + \" \"+ iaddr+ \"/\"+ packet.dport+ \" allowed=\"+ packet.allowed);\n            }\n          }\n catch (          UnknownHostException ex) {\n            Log.w(TAG,ex.toString() + \"\\n\" + Log.getStackTraceString(ex));\n          }\n        }\n        if (!filtered)         packet.allowed=(mapUidAllowed.containsKey(packet.uid) && mapUidAllowed.get(packet.uid));\n      }\n    }\n  }\n  if (prefs.getBoolean(\"log\",false) || prefs.getBoolean(\"log_app\",false))   logPacket(packet);\n  return packet.allowed;\n}\n"}
{"INPUT": "public boolean filterTransformers(List<? extends DBDAttributeTransformerDescriptor> descriptors){\n  if (!hasValuableData()) {\n    return false;\n  }\n  for (int i=0; i < descriptors.size(); ) {\n    final DBDAttributeTransformerDescriptor descriptor=descriptors.get(i);\n// bug_start\n    if ((descriptor.isApplicableByDefault() && excludedTransformers != null && excludedTransformers.contains(descriptor.getId())) || (!descriptor.isApplicableByDefault() && includedTransformers != null && includedTransformers.contains(descriptor.getId()))) {\n// bug_end\n      descriptors.remove(i);\n    }\n else {\n      i++;\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "public void start(URL applicationUrl,Properties applicationProperties,ApplicationContext context){\n  this.applicationUrl=applicationUrl;\n  properties=applicationProperties;\n  this.context=context;\n// bug_start\n  if (getProperty(\"Debug\") != null && getProperty(\"Debug\").equals(\"true\")) {\n// bug_end\n    debugMode=true;\n  }\n  init();\n  applicationIsRunning=true;\n}\n"}
{"INPUT": "public Array<Tile> getPowerConnections(Tile tile,Array<Tile> out){\n  out.clear();\n  for (  Tile other : tile.entity.proximity()) {\n    if (other.entity.power != null && !(consumesPower && other.block().consumesPower)) {\n      out.add(other);\n    }\n  }\n  for (int i=0; i < tile.entity.power.links.size; i++) {\n    Tile link=world.tile(tile.entity.power.links.get(i));\n// bug_start\n    if (link != null)     out.add(link);\n// bug_end\n  }\n  return out;\n}\n"}
{"INPUT": "private static boolean isDeclaredIn(Artifact input,Set<PathFragment> declaredIncludeDirs,Set<Artifact> declaredIncludeSrcs){\n  if (declaredIncludeSrcs.contains(input)) {\n    return true;\n  }\n  if (!input.isSourceArtifact() && !input.getRoot().getExecPath().getBaseName().equals(\"include\")) {\n    return false;\n  }\n  PathFragment includeDir=input.getRootRelativePath().getParentDirectory();\n// bug_start\n  if (includeDir.segmentCount() == 0 || declaredIncludeDirs.contains(includeDir)) {\n// bug_end\n    return true;\n  }\n  for (  PathFragment declared : declaredIncludeDirs) {\n    if (declared.getBaseName().equals(\"**\")) {\n      if (includeDir.startsWith(declared.getParentDirectory())) {\n        return true;\n      }\n    }\n  }\n  Root root=input.getRoot().getRoot();\n  for (Path dir=input.getPath().getParentDirectory(); ; ) {\n    if (dir.getRelative(BUILD_PATH_FRAGMENT).exists()) {\n      return false;\n    }\n    dir=dir.getParentDirectory();\n    if (dir.equals(root.asPath())) {\n      return false;\n    }\n    if (declaredIncludeDirs.contains(root.relativize(dir))) {\n      return true;\n    }\n  }\n}\n"}
{"INPUT": "@Override protected Fieldable parseCreateField(ParseContext context) throws IOException {\n  String dateAsString;\n  if (context.externalValueSet()) {\n    dateAsString=(String)context.externalValue();\n    if (dateAsString == null) {\n      dateAsString=nullValue;\n    }\n  }\n else {\n    if (context.parser().currentToken() == XContentParser.Token.VALUE_NULL) {\n      dateAsString=nullValue;\n    }\n else {\n      dateAsString=context.parser().text();\n    }\n  }\n  if (dateAsString == null) {\n    return null;\n  }\n// bug_start\n  if (includeInAll == null || includeInAll) {\n// bug_end\n    context.allEntries().addText(names.fullName(),dateAsString,boost);\n  }\n  final long value=parseStringValue(dateAsString);\n  return new LongFieldMapper.CustomLongNumericField(this,value);\n}\n"}
{"INPUT": "static WebViewFactoryProvider getProvider(){\nsynchronized (sProviderLock) {\n    if (sProviderInstance != null)     return sProviderInstance;\n    final int uid=android.os.Process.myUid();\n// bug_start\n    if (uid == android.os.Process.ROOT_UID || uid == android.os.Process.SYSTEM_UID) {\n// bug_end\n      throw new UnsupportedOperationException(\"For security reasons, WebView is not allowed in privileged processes\");\n    }\n    StrictMode.ThreadPolicy oldPolicy=StrictMode.allowThreadDiskReads();\n    Trace.traceBegin(Trace.TRACE_TAG_WEBVIEW,\"WebViewFactory.getProvider()\");\n    try {\n      Class<WebViewFactoryProvider> providerClass=getProviderClass();\n      Method staticFactory=null;\n      try {\n        staticFactory=providerClass.getMethod(CHROMIUM_WEBVIEW_FACTORY_METHOD,WebViewDelegate.class);\n      }\n catch (      Exception e) {\n        if (DEBUG) {\n          Log.w(LOGTAG,\"error instantiating provider with static factory method\",e);\n        }\n      }\n      Trace.traceBegin(Trace.TRACE_TAG_WEBVIEW,\"WebViewFactoryProvider invocation\");\n      try {\n        sProviderInstance=(WebViewFactoryProvider)staticFactory.invoke(null,new WebViewDelegate());\n        if (DEBUG)         Log.v(LOGTAG,\"Loaded provider: \" + sProviderInstance);\n        return sProviderInstance;\n      }\n catch (      Exception e) {\n        Log.e(LOGTAG,\"error instantiating provider\",e);\n        throw new AndroidRuntimeException(e);\n      }\n finally {\n        Trace.traceEnd(Trace.TRACE_TAG_WEBVIEW);\n      }\n    }\n  finally {\n      Trace.traceEnd(Trace.TRACE_TAG_WEBVIEW);\n      StrictMode.setThreadPolicy(oldPolicy);\n    }\n  }\n}\n"}
{"INPUT": "@Override public void sawOpcode(int seen){\n  if (seen == PUTSTATIC && getClassConstantOperand().equals(getClassName())) {\n// bug_start\n    if (REPORT_CREATE_INSTANCE_BEFORE_FIELDS_ASSIGNED && instanceCreated && !instanceCreatedWarningGiven) {\n// bug_end\n      String okSig=\"L\" + getClassName() + \";\";\n      if (!okSig.equals(getSigConstantOperand())) {\n        bugReporter.reportBug(new BugInstance(this,\"SI_INSTANCE_BEFORE_FINALS_ASSIGNED\",NORMAL_PRIORITY).addClassAndMethod(this).addSourceLine(this,instanceCreatedPC));\n        instanceCreatedWarningGiven=true;\n      }\n    }\n  }\n else   if (seen == NEW && getClassConstantOperand().equals(getClassName())) {\n    instanceCreated=true;\n    instanceCreatedPC=getPC();\n  }\n else   if (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC || seen == NEW)   if (getPC() + 6 < codeBytes.length)   requires.add(getDottedClassConstantOperand());\n}\n"}
{"INPUT": "@Override public void onApiChange(SyncthingService.State currentState){\nswitch (currentState) {\ncase STARTING:\n    break;\ncase ACTIVE:\n  showBatteryOptimizationDialogIfNecessary();\nmDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED);\nmDrawerFragment.requestGuiUpdate();\n// bug_start\nif (new Date().getTime() > getFirstStartTime() + USAGE_REPORTING_DIALOG_DELAY && getApi().getOptions().getUsageReportValue() == Options.USAGE_REPORTING_UNDECIDED) {\n// bug_end\nshowUsageReportingDialog();\n}\nbreak;\ncase ERROR:\nfinish();\nbreak;\ncase DISABLED:\nbreak;\n}\n}\n"}
{"INPUT": "@NonNull @Override public Set<File> getJavaResources(){\n  Set<File> javaResourcesLocations=Sets.newHashSet();\n// bug_start\n  if (appVariantContext.getAtlasExtension().getTBuildConfig().isIncremental() && awbBundle.getAllLibraryAars().size() > 1) {\n// bug_end\n    File baseAwb=appVariantOutputContext.getVariantContext().apContext.getBaseAwb(awbBundle.getAwbSoName());\n    javaResourcesLocations.add(baseAwb);\n  }\n  if (appVariantContext.getAtlasExtension().getTBuildConfig().getMergeAwbJavaRes()) {\n    javaResourcesLocations.addAll(awbBundle.getLibraryJars());\n  }\n  return javaResourcesLocations;\n}\n"}
{"INPUT": "public void endOperation(){\n// bug_start\n  if (database != null)   if (!database.isClosed() && database.getLocalCache() != null)   database.getLocalCache().clear();\n// bug_end\n  stats.lastCommandExecutionTime=System.currentTimeMillis() - stats.lastCommandReceived;\n  stats.totalCommandExecutionTime+=stats.lastCommandExecutionTime;\n  stats.lastCommandInfo=data.commandInfo;\n  stats.lastCommandDetail=data.commandDetail;\n  data.commandDetail=\"-\";\n  release();\n}\n"}
{"INPUT": "@Override protected void updateProjectAction(ActionEvent e){\n  if (editorAgent.getActiveEditor() != null) {\n    EditorInput input=editorAgent.getActiveEditor().getEditorInput();\n    VirtualFile file=input.getFile();\n    final String fileExtension=fileTypeRegistry.getFileTypeByFile(file).getExtension();\n// bug_start\n    if (fileExtension.equals(\"java\") || fileExtension.equals(\"class\")) {\n// bug_end\n      e.getPresentation().setEnabledAndVisible(true);\n      return;\n    }\n  }\n  e.getPresentation().setEnabledAndVisible(false);\n}\n"}
{"INPUT": "public static Set<Index> getRelevantIndices(ClusterState state,ClusterState previousState,Set<Index> previouslyWrittenIndices){\n  Set<Index> relevantIndices;\n  if (isDataOnlyNode(state)) {\n    relevantIndices=getRelevantIndicesOnDataOnlyNode(state,previousState,previouslyWrittenIndices);\n  }\n// bug_start\n else   if (state.nodes().getLocalNode().isMasterNode() == true) {\n// bug_end\n    relevantIndices=getRelevantIndicesForMasterEligibleNode(state);\n  }\n else {\n    relevantIndices=Collections.emptySet();\n  }\n  return relevantIndices;\n}\n"}
{"INPUT": "private boolean iterateStatements(RootStatement root,SSAUConstructorSparseEx ssa){\n  FlattenStatementsHelper flatthelper=new FlattenStatementsHelper();\n  DirectGraph dgraph=flatthelper.buildDirectGraph(root);\n  boolean res=false;\n  HashSet<DirectNode> setVisited=new HashSet<DirectNode>();\n  LinkedList<DirectNode> stack=new LinkedList<DirectNode>();\n  LinkedList<HashMap<VarVersionPaar,Exprent>> stackMaps=new LinkedList<HashMap<VarVersionPaar,Exprent>>();\n  stack.add(dgraph.first);\n  stackMaps.add(new HashMap<VarVersionPaar,Exprent>());\n  while (!stack.isEmpty()) {\n    DirectNode nd=stack.removeFirst();\n    HashMap<VarVersionPaar,Exprent> mapVarValues=stackMaps.removeFirst();\n    if (setVisited.contains(nd)) {\n      continue;\n    }\n    setVisited.add(nd);\n    List<List<Exprent>> lstLists=new ArrayList<List<Exprent>>();\n    if (!nd.exprents.isEmpty()) {\n      lstLists.add(nd.exprents);\n    }\n    if (nd.succs.size() == 1) {\n      DirectNode ndsucc=nd.succs.get(0);\n      if (ndsucc.type == DirectNode.NODE_TAIL && !ndsucc.exprents.isEmpty()) {\n        lstLists.add(nd.succs.get(0).exprents);\n        nd=ndsucc;\n      }\n    }\n    for (int i=0; i < lstLists.size(); i++) {\n      List<Exprent> lst=lstLists.get(i);\n      int index=0;\n      while (index < lst.size()) {\n        Exprent next=null;\n        if (index == lst.size() - 1) {\n          if (i < lstLists.size() - 1) {\n            next=lstLists.get(i + 1).get(0);\n          }\n        }\n else {\n          next=lst.get(index + 1);\n        }\n        int[] ret=iterateExprent(lst,index,next,mapVarValues,ssa);\n        if (ret[0] >= 0) {\n          index=ret[0];\n        }\n else {\n          index++;\n        }\n        res|=(ret[1] == 1);\n      }\n    }\n    for (    DirectNode ndx : nd.succs) {\n      stack.add(ndx);\n      stackMaps.add(new HashMap<VarVersionPaar,Exprent>(mapVarValues));\n    }\n    if (nd.exprents.isEmpty() && (nd.type == DirectNode.NODE_INIT || nd.type == DirectNode.NODE_CONDITION || nd.type == DirectNode.NODE_INCREMENT)) {\n      nd.exprents.add(null);\n      if (nd.statement.type == Statement.TYPE_DO) {\n        DoStatement loop=(DoStatement)nd.statement;\n// bug_start\n        if (nd.type == DirectNode.NODE_INCREMENT && loop.getLooptype() == DoStatement.LOOP_FOR) {\n// bug_end\n          loop.setLooptype(DoStatement.LOOP_WHILE);\n        }\n      }\n    }\n  }\n  return res;\n}\n"}
{"INPUT": "private void checkRootElement(Element root){\n  String rootNodeName=root.getNodeName();\n// bug_start\n  if (!ConfigSections.HAZELCAST.isEqual(rootNodeName)) {\n// bug_end\n    throw new InvalidConfigurationException(\"Invalid root element in xml configuration!\" + \" Expected: <\" + ConfigSections.HAZELCAST.getName() + \">, Actual: <\"+ rootNodeName+ \">.\");\n  }\n}\n"}
{"INPUT": "@Override public void postParse(ParseContext context) throws IOException {\n  Analyzer analyzer=context.docMapper().mappers().indexAnalyzer();\n  if (path != null) {\n    String value=null;\n    List<IndexableField> fields=context.doc().getFields();\n    for (int i=0, fieldsSize=fields.size(); i < fieldsSize; i++) {\n      IndexableField field=fields.get(i);\n// bug_start\n      if (field.name() == path) {\n// bug_end\n        value=field.stringValue();\n        break;\n      }\n    }\n    if (value == null) {\n      value=context.ignoredValue(path);\n    }\n    if (value != null) {\n      analyzer=context.analysisService().analyzer(value);\n      if (analyzer == null) {\n        throw new MapperParsingException(\"No analyzer found for [\" + value + \"] from path [\"+ path+ \"]\");\n      }\n      analyzer=context.docMapper().mappers().indexAnalyzer(analyzer);\n    }\n  }\n  context.analyzer(analyzer);\n}\n"}
{"INPUT": "private static ResolvedJavaType meetTypes(ResolvedJavaType a,ResolvedJavaType b){\n  if (Objects.equals(a,b)) {\n    return a;\n  }\n else   if (a == null || b == null) {\n    return null;\n  }\n else {\n    ResolvedJavaType result=a.findLeastCommonAncestor(b);\n// bug_start\n    if (result.getSuperclass() == null && a.isInterface() && b.isInterface()) {\n// bug_end\n      ResolvedJavaType[] interfacesA=a.getInterfaces();\n      ResolvedJavaType[] interfacesB=b.getInterfaces();\n      for (int i=0; i < interfacesA.length; ++i) {\n        ResolvedJavaType interface1=interfacesA[i];\n        for (int j=0; j < interfacesB.length; ++j) {\n          ResolvedJavaType interface2=interfacesB[i];\n          ResolvedJavaType leastCommon=meetTypes(interface1,interface2);\n          if (leastCommon.isInterface()) {\n            return leastCommon;\n          }\n        }\n      }\n    }\n    return result;\n  }\n}\n"}
{"INPUT": "public void addPropertyCreator(AnnotatedWithParams creator,boolean explicit,SettableBeanProperty[] properties){\n  if (verifyNonDup(creator,C_PROPS,explicit)) {\n    if (properties.length > 1) {\n      HashMap<String,Integer> names=new HashMap<String,Integer>();\n      for (int i=0, len=properties.length; i < len; ++i) {\n        String name=properties[i].getName();\n// bug_start\n        if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n// bug_end\n          continue;\n        }\n        Integer old=names.put(name,Integer.valueOf(i));\n        if (old != null) {\n          throw new IllegalArgumentException(String.format(\"Duplicate creator property \\\"%s\\\" (index %s vs %d)\",name,old,i));\n        }\n      }\n    }\n    _propertyBasedArgs=properties;\n  }\n}\n"}
{"INPUT": "@Override public void update(Tile tile){\n  CraterConveyorEntity entity=tile.ent();\n  if (entity.lastFrameUpdated == Core.graphics.getFrameId())   return;\n  entity.lastFrameUpdated=Core.graphics.getFrameId();\n  entity.reload=Mathf.clamp(entity.reload - speed,0f,1f);\n  if (entity.link == Pos.invalid) {\n    if (entity.items.total() <= 0 || entity.reload > 0)     return;\n    Effects.effect(Fx.plasticburn,tile.drawx(),tile.drawy());\n    entity.link=tile.pos();\n  }\n else {\n    if (entity.items.total() == 0) {\n      Effects.effect(Fx.plasticburn,tile.drawx(),tile.drawy());\n      entity.link=Pos.invalid;\n      return;\n    }\n  }\n  if (shouldLaunch(tile)) {\n    Tile destination=tile.front();\n    destination.block().update(destination);\n    if (entity.reload < 0.25f) {\n// bug_start\n      if (!(destination.block() instanceof CraterConveyor) && entity.link != tile.pos()) {\n// bug_end\n        while (entity.items.total() > 0 && entity.dominant() != null && offloadDir(tile,entity.dominant()))         entity.items.remove(entity.dominant(),1);\n      }\n    }\n    if (entity.reload == 0) {\n      if (destination.block() instanceof CraterConveyor) {\n        CraterConveyorEntity e=destination.ent();\n        if (e.items.total() == 0) {\n          entity.link=Pos.invalid;\n          e.link=tile.pos();\n          entity.reload=1;\n          e.reload=1;\n          e.items.addAll(entity.items);\n          entity.items.clear();\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override public List<SpawnResult> exec(Spawn spawn,ActionExecutionContext actionExecutionContext,AtomicReference<Class<? extends SpawnActionContext>> writeOutputFiles) throws ExecException, InterruptedException {\n  if (actionExecutionContext.reportsSubcommands()) {\n    actionExecutionContext.reportSubcommand(spawn);\n  }\n  final Duration timeout=Spawns.getTimeout(spawn);\n  SpawnExecutionPolicy policy=new SpawnExecutionPolicyImpl(spawn,actionExecutionContext,writeOutputFiles,timeout);\n  SpawnCache cache=actionExecutionContext.getContext(SpawnCache.class);\n  if (cache == null || !Spawns.mayBeCached(spawn)) {\n    cache=SpawnCache.NO_CACHE;\n  }\n  SpawnResult spawnResult;\n  try {\n    try (CacheHandle cacheHandle=cache.lookup(spawn,policy)){\n      if (cacheHandle.hasResult()) {\n        spawnResult=Preconditions.checkNotNull(cacheHandle.getResult());\n      }\n else {\n        spawnResult=spawnRunner.exec(spawn,policy);\n        if (cacheHandle.willStore()) {\n          cacheHandle.store(spawnResult,listExistingOutputFiles(spawn,actionExecutionContext.getExecRoot()));\n        }\n      }\n    }\n   }\n catch (  IOException e) {\n    throw new EnvironmentalExecException(\"Unexpected IO error.\",e);\n  }\n// bug_start\n  if ((spawnResult.status() != Status.SUCCESS) || (spawnResult.exitCode() != 0)) {\n// bug_end\n    String cwd=actionExecutionContext.getExecRoot().getPathString();\n    String message=CommandFailureUtils.describeCommandFailure(actionExecutionContext.getVerboseFailures(),spawn.getArguments(),spawn.getEnvironment(),cwd);\n    throw new SpawnExecException(message,spawnResult,false);\n  }\n  return ImmutableList.of(spawnResult);\n}\n"}
{"INPUT": "@Override protected String extractPrincipalId(final Credential credential,final Optional<Principal> currentPrincipal){\n  LOGGER.debug(\"Attempting to extract principal id for principal [{}]\",currentPrincipal);\n  if (!credential.getClass().equals(SurrogateUsernamePasswordCredential.class)) {\n    LOGGER.debug(\"Provided credential is not one of [{}]\",SurrogateUsernamePasswordCredential.class.getName());\n    return super.extractPrincipalId(credential,currentPrincipal);\n  }\n// bug_start\n  if (!currentPrincipal.isPresent()) {\n// bug_end\n    throw new IllegalArgumentException(\"Current principal resolved cannot be null\");\n  }\n  val id=currentPrincipal.get().getId();\n  LOGGER.debug(\"Resolving principal id for surrogate authentication as [{}]\",id);\n  return id;\n}\n"}
{"INPUT": "@Override public void resetHeadsUpDecayTimer(){\n  mHandler.removeMessages(MSG_HIDE_HEADS_UP);\n// bug_start\n  if (mHeadsUpNotificationDecay > 0) {\n// bug_end\n    mHandler.sendEmptyMessageDelayed(MSG_HIDE_HEADS_UP,mHeadsUpNotificationDecay);\n  }\n}\n"}
{"INPUT": "@Override public InvoiceWithMetadata generateInvoice(final ImmutableAccountData account,@Nullable final BillingEventSet events,@Nullable final Iterable<Invoice> existingInvoices,@Nullable final UUID targetInvoiceId,final LocalDate targetDate,final Currency targetCurrency,final InternalCallContext context) throws InvoiceApiException {\n// bug_start\n  if ((events == null) || (events.size() == 0) || events.isAccountAutoInvoiceOff()) {\n// bug_end\n    return new InvoiceWithMetadata(null,ImmutableSet.of(),ImmutableMap.<UUID,SubscriptionFutureNotificationDates>of());\n  }\n  validateTargetDate(targetDate,context);\n  final LocalDate adjustedTargetDate=adjustTargetDate(existingInvoices,targetDate);\n  final LocalDate invoiceDate=context.toLocalDate(context.getCreatedDate());\n  final InvoiceStatus invoiceStatus=events.isAccountAutoInvoiceDraft() ? InvoiceStatus.DRAFT : InvoiceStatus.COMMITTED;\n  final DefaultInvoice invoice=targetInvoiceId != null ? new DefaultInvoice(targetInvoiceId,account.getId(),null,invoiceDate,adjustedTargetDate,targetCurrency,false,invoiceStatus) : new DefaultInvoice(account.getId(),invoiceDate,adjustedTargetDate,targetCurrency,invoiceStatus);\n  final Map<UUID,SubscriptionFutureNotificationDates> perSubscriptionFutureNotificationDates=new HashMap<UUID,SubscriptionFutureNotificationDates>();\n  final InvoiceGeneratorResult fixedAndRecurringItems=recurringInvoiceItemGenerator.generateItems(account,invoice.getId(),events,existingInvoices,adjustedTargetDate,targetCurrency,perSubscriptionFutureNotificationDates,context);\n  invoice.addInvoiceItems(fixedAndRecurringItems.getItems());\n  final InvoiceGeneratorResult usageItemsWithTrackingIds=usageInvoiceItemGenerator.generateItems(account,invoice.getId(),events,existingInvoices,adjustedTargetDate,targetCurrency,perSubscriptionFutureNotificationDates,context);\n  invoice.addInvoiceItems(usageItemsWithTrackingIds.getItems());\n  if (targetInvoiceId != null) {\n    final Invoice originalInvoice=Iterables.tryFind(existingInvoices,new Predicate<Invoice>(){\n      @Override public boolean apply(      final Invoice input){\n        return input.getId().equals(targetInvoiceId);\n      }\n    }\n).orNull();\n    Preconditions.checkNotNull(originalInvoice,\"Expecting to find an existing invoice matching the targetInvoiceId\");\n    invoice.addInvoiceItems(originalInvoice.getInvoiceItems());\n  }\n  return new InvoiceWithMetadata(invoice.getInvoiceItems().isEmpty() ? null : invoice,usageItemsWithTrackingIds.getTrackingIds(),perSubscriptionFutureNotificationDates);\n}\n"}
{"INPUT": "private static SpannableStringBuilder getCrosspostSpannable(Submission s,Context mContext){\n  String spacer=mContext.getString(R.string.submission_properties_seperator);\n  SpannableStringBuilder titleString=new SpannableStringBuilder(\"Crosspost\" + spacer);\n  JsonNode json=s.getDataNode();\n// bug_start\n  if (!json.has(\"crosspost_parent_list\") && json.get(\"crosspost_parent_list\").get(0) != null) {\n// bug_end\n    return new SpannableStringBuilder();\n  }\n  json=json.get(\"crosspost_parent_list\").get(0);\n  if (json.has(\"subreddit\")) {\n    String subname=json.get(\"subreddit\").asText().toLowerCase(Locale.ENGLISH);\n    SpannableStringBuilder subreddit=new SpannableStringBuilder(\"/r/\" + subname + spacer);\n    if ((SettingValues.colorSubName && Palette.getColor(subname) != Palette.getDefaultColor()) || (SettingValues.colorSubName && Palette.getColor(subname) != Palette.getDefaultColor())) {\n      if (!SettingValues.colorEverywhere) {\n        subreddit.setSpan(new ForegroundColorSpan(Palette.getColor(subname)),0,subreddit.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n        subreddit.setSpan(new StyleSpan(Typeface.BOLD),0,subreddit.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n      }\n    }\n    titleString.append(subreddit);\n  }\n  SpannableStringBuilder author=new SpannableStringBuilder(json.get(\"author\").asText() + \" \");\n  int authorcolor=Palette.getFontColorUser(json.get(\"author\").asText());\n  if (authorcolor != 0) {\n    author.setSpan(new ForegroundColorSpan(authorcolor),0,author.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n  }\n  titleString.append(author);\n  if (UserTags.isUserTagged(json.get(\"author\").asText())) {\n    SpannableStringBuilder pinned=new SpannableStringBuilder(\" \" + UserTags.getUserTag(json.get(\"author\").asText()) + \" \");\n    pinned.setSpan(new RoundedBackgroundSpan(mContext,R.color.white,R.color.md_blue_500,false),0,pinned.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    titleString.append(pinned);\n  }\n  if (UserSubscriptions.friends.contains(json.get(\"author\").asText())) {\n    SpannableStringBuilder pinned=new SpannableStringBuilder(\" \" + mContext.getString(R.string.profile_friend) + \" \");\n    pinned.setSpan(new RoundedBackgroundSpan(mContext,R.color.white,R.color.md_deep_orange_500,false),0,pinned.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    titleString.append(pinned);\n  }\n  return titleString;\n}\n"}
{"INPUT": "public void mouseClicked(MouseEvent e){\n  int index=list.locationToIndex(e.getPoint());\n// bug_start\n  if (e.getButton() == MouseEvent.BUTTON3) {\n// bug_end\n    if ((index > 0) && (index < list.getModel().getSize())) {\n      list.setSelectedIndex(index);\n      gropt.show(list,e.getPoint().x,list.indexToLocation(index).y);\n    }\n  }\n else {\n    if ((index > 0) && (e.getClickCount() == 2)) {\n      modifyAction.actionPerformed(new ActionEvent(list,0,\"Modify\"));\n    }\n  }\n}\n"}
{"INPUT": "@Override public void resetResolvedLayoutDirection(){\n  super.resetResolvedLayoutDirection();\n  int count=getChildCount();\n  for (int i=0; i < count; i++) {\n    final View child=getChildAt(i);\n    if (child.isLayoutDirectionInherited()) {\n      child.resetResolvedLayoutDirection();\n    }\n// bug_start\n    if (child.getTextDirection() == TEXT_DIRECTION_INHERIT) {\n// bug_end\n      child.resetResolvedTextDirection();\n    }\n    if (child.getTextAlignment() == TEXT_ALIGNMENT_INHERIT) {\n      child.resetResolvedTextAlignment();\n    }\n  }\n}\n"}
{"INPUT": "public void reportAnalysisErrors(){\n// bug_start\n  if (reporter.getErrorDialog() != null) {\n// bug_end\n    reporter.getErrorDialog().generateContents();\n    reporter.getErrorDialog().setSize(750,520);\n    reporter.getErrorDialog().setLocationRelativeTo(null);\n    reporter.getErrorDialog().setVisible(true);\n  }\n}\n"}
{"INPUT": "private void processTokenArray(JsonToken token,List<TokenBuffer> result) throws IOException {\n  if (!isTopLevelArrayToken(token)) {\n    this.tokenBuffer.copyCurrentEvent(this.parser);\n  }\n// bug_start\n  if ((token == JsonToken.END_OBJECT && this.objectDepth == 0 && (this.arrayDepth == 1 || this.arrayDepth == 0)) || (token.isScalarValue()) && this.objectDepth == 0 && this.arrayDepth == 0) {\n// bug_end\n    result.add(this.tokenBuffer);\n    this.tokenBuffer=new TokenBuffer(this.parser);\n  }\n}\n"}
{"INPUT": "private void doForward(ServletRequest request,ServletResponse response) throws ServletException, IOException {\n  if (response.isCommitted()) {\n    throw new IllegalStateException(sm.getString(\"applicationDispatcher.forward.ise\"));\n  }\n  try {\n    response.resetBuffer();\n  }\n catch (  IllegalStateException e) {\n    throw e;\n  }\n  State state=new State(request,response,false);\n  if (WRAP_SAME_OBJECT) {\n    checkSameObjects(request,response);\n  }\n  wrapResponse(state);\n  if ((servletPath == null) && (pathInfo == null)) {\n    ApplicationHttpRequest wrequest=(ApplicationHttpRequest)wrapRequest(state);\n    HttpServletRequest hrequest=state.hrequest;\n    wrequest.setRequestURI(hrequest.getRequestURI());\n    wrequest.setContextPath(hrequest.getContextPath());\n    wrequest.setServletPath(hrequest.getServletPath());\n    wrequest.setPathInfo(hrequest.getPathInfo());\n    wrequest.setQueryString(hrequest.getQueryString());\n    processRequest(request,response,state);\n  }\n else {\n    ApplicationHttpRequest wrequest=(ApplicationHttpRequest)wrapRequest(state);\n    String contextPath=context.getPath();\n    HttpServletRequest hrequest=state.hrequest;\n    if (hrequest.getAttribute(RequestDispatcher.FORWARD_REQUEST_URI) == null) {\n      wrequest.setAttribute(RequestDispatcher.FORWARD_REQUEST_URI,hrequest.getRequestURI());\n      wrequest.setAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH,hrequest.getContextPath());\n      wrequest.setAttribute(RequestDispatcher.FORWARD_SERVLET_PATH,hrequest.getServletPath());\n      wrequest.setAttribute(RequestDispatcher.FORWARD_PATH_INFO,hrequest.getPathInfo());\n      wrequest.setAttribute(RequestDispatcher.FORWARD_QUERY_STRING,hrequest.getQueryString());\n    }\n    wrequest.setContextPath(contextPath);\n    wrequest.setRequestURI(requestURI);\n    wrequest.setServletPath(servletPath);\n    wrequest.setPathInfo(pathInfo);\n    if (queryString != null) {\n      wrequest.setQueryString(queryString);\n      wrequest.setQueryParams(queryString);\n    }\n    processRequest(request,response,state);\n  }\n// bug_start\n  if (request.getAsyncContext() != null) {\n// bug_end\n    return;\n  }\n  if (wrapper.getLogger().isDebugEnabled())   wrapper.getLogger().debug(\" Disabling the response for futher output\");\n  if (response instanceof ResponseFacade) {\n    ((ResponseFacade)response).finish();\n  }\n else {\n    if (wrapper.getLogger().isDebugEnabled()) {\n      wrapper.getLogger().debug(\" The Response is vehiculed using a wrapper: \" + response.getClass().getName());\n    }\n    try {\n      PrintWriter writer=response.getWriter();\n      writer.close();\n    }\n catch (    IllegalStateException e) {\n      try {\n        ServletOutputStream stream=response.getOutputStream();\n        stream.close();\n      }\n catch (      IllegalStateException f) {\n      }\ncatch (      IOException f) {\n      }\n    }\ncatch (    IOException e) {\n    }\n  }\n}\n"}
{"INPUT": "public Set<RealmObjectSchema> getAll(){\n  if (realm == null) {\n    long[] ptrs=nativeGetAll(nativePtr);\n    Set<RealmObjectSchema> schemas=new LinkedHashSet<>(ptrs.length);\n    for (int i=0; i < ptrs.length; i++) {\n      schemas.add(new RealmObjectSchema(ptrs[i]));\n    }\n    return schemas;\n  }\n else {\n    int tableCount=(int)realm.sharedRealm.size();\n    Set<RealmObjectSchema> schemas=new LinkedHashSet<>(tableCount);\n    for (int i=0; i < tableCount; i++) {\n      String tableName=realm.sharedRealm.getTableName(i);\n// bug_start\n      if (Table.isModelTable(tableName)) {\n// bug_end\n        continue;\n      }\n      Table table=realm.sharedRealm.getTable(tableName);\n      RealmObjectSchema.DynamicColumnMap columnIndices=new RealmObjectSchema.DynamicColumnMap(table);\n      schemas.add(new RealmObjectSchema(realm,table,columnIndices));\n    }\n    return schemas;\n  }\n}\n"}
{"INPUT": "@Override public DatabaseDataType toDatabaseDataType(Database database){\n  int dataTypeMaxParameters;\n  if (getName().equalsIgnoreCase(\"enum\") || getName().equalsIgnoreCase(\"set\")) {\n    dataTypeMaxParameters=Integer.MAX_VALUE;\n  }\n else {\n    dataTypeMaxParameters=database.getDataTypeMaxParameters(getName());\n  }\n  Object[] parameters=getParameters();\n  if (database instanceof MySQLDatabase && (getName().equalsIgnoreCase(\"TINYBLOB\") || getName().equalsIgnoreCase(\"MEDIUMBLOB\") || getName().equalsIgnoreCase(\"TINYTEXT\")|| getName().equalsIgnoreCase(\"MEDIUMTEXT\")|| getName().equalsIgnoreCase(\"REAL\"))) {\n    parameters=new Object[0];\n  }\n  if (database instanceof DB2Database && (getName().equalsIgnoreCase(\"REAL\") || getName().equalsIgnoreCase(\"XML\"))) {\n    parameters=new Object[0];\n  }\n  if (database instanceof MSSQLDatabase && (getName().equalsIgnoreCase(\"REAL\") || getName().equalsIgnoreCase(\"XML\") || getName().equalsIgnoreCase(\"HIERARCHYID\")|| getName().equalsIgnoreCase(\"DATETIMEOFFSET\")|| getName().equalsIgnoreCase(\"IMAGE\")|| getName().equalsIgnoreCase(\"NTEXT\")|| getName().equalsIgnoreCase(\"SMALLMONEY\"))) {\n    parameters=new Object[0];\n  }\n  if (database instanceof OracleDatabase) {\n// bug_start\n    if (getName().equalsIgnoreCase(\"LONG\") || getName().equalsIgnoreCase(\"NCLOB\")) {\n// bug_end\n      parameters=new Object[0];\n    }\n else     if (getName().toUpperCase().startsWith(\"INTERVAL \")) {\n      return new DatabaseDataType(getName().replaceAll(\"\\\\(\\\\d+\\\\)\",\"\"));\n    }\n  }\n  if (dataTypeMaxParameters < parameters.length) {\n    parameters=Arrays.copyOfRange(parameters,0,dataTypeMaxParameters);\n  }\n  DatabaseDataType type=new DatabaseDataType(getName().toUpperCase(),parameters);\n  type.addAdditionalInformation(getAdditionalInformation());\n  return type;\n}\n"}
{"INPUT": "@Override protected void onSeekTargetStep(int dx,int dy,RecyclerView.State state,Action action){\n  if (getChildCount() == 0) {\n    stop();\n    return;\n  }\n// bug_start\n  if (DEBUG && mTargetVector != null && ((mTargetVector.x * dx < 0 || mTargetVector.y * dy < 0))) {\n// bug_end\n    throw new IllegalStateException(\"Scroll happened in the opposite direction\" + \" of the target. Some calculations are wrong\");\n  }\n  mInterimTargetDx=clampApplyScroll(mInterimTargetDx,dx);\n  mInterimTargetDy=clampApplyScroll(mInterimTargetDy,dy);\n  if (mInterimTargetDx == 0 && mInterimTargetDy == 0) {\n    updateActionForInterimTarget(action);\n  }\n}\n"}
{"INPUT": "@Override public JsonDeserializer<?> createContextual(DeserializationContext ctxt,BeanProperty property) throws JsonMappingException {\n// bug_start\n  if ((_deser == null) && (_inputType != null)) {\n// bug_end\n    return new FactoryBasedEnumDeserializer(this,ctxt.findContextualValueDeserializer(_inputType,property));\n  }\n  return this;\n}\n"}
{"INPUT": "@Override public Void execute(CommandContext commandContext){\n  String processInstanceId=builder.getProcessInstanceId();\n  ExecutionManager executionManager=commandContext.getExecutionManager();\n  ExecutionEntity processInstance=executionManager.findExecutionById(processInstanceId);\n  ensureProcessInstanceExist(processInstanceId,processInstance);\n  checkUpdateProcessInstance(processInstance,commandContext);\n  processInstance.setPreserveScope(true);\n  List<AbstractProcessInstanceModificationCommand> instructions=builder.getModificationOperations();\n  checkCancellation(commandContext);\n  for (int i=0; i < instructions.size(); i++) {\n    AbstractProcessInstanceModificationCommand instruction=instructions.get(i);\n    LOG.debugModificationInstruction(processInstanceId,i + 1,instruction.describe());\n    instruction.setSkipCustomListeners(builder.isSkipCustomListeners());\n    instruction.setSkipIoMappings(builder.isSkipIoMappings());\n    instruction.execute(commandContext);\n  }\n  processInstance=executionManager.findExecutionById(processInstanceId);\n  if (!processInstance.hasChildren()) {\n// bug_start\n    if (!(processInstance.getActivity() != null && !processInstance.getId().equals(processInstance.getActivityInstanceId()))) {\n// bug_end\n      checkDeleteProcessInstance(processInstance,commandContext);\n      deletePropagate(processInstance,builder.getModificationReason(),builder.isSkipCustomListeners(),builder.isSkipIoMappings());\n    }\n else     if (processInstance.isEnded()) {\n      processInstance.propagateEnd();\n    }\n  }\n  if (writeOperationLog) {\n    commandContext.getOperationLogManager().logProcessInstanceOperation(getLogEntryOperation(),processInstanceId,null,null,Collections.singletonList(PropertyChange.EMPTY_CHANGE));\n  }\n  return null;\n}\n"}
{"INPUT": "public List<Subscription> matches(String topic){\n  List<Token> tokens;\n  try {\n    tokens=parseTopic(topic);\n  }\n catch (  ParseException ex) {\n    LOG.error(null,ex);\n    return Collections.emptyList();\n  }\n  Queue<Token> tokenQueue=new LinkedBlockingDeque<>(tokens);\n  List<Subscription> matchingSubs=new ArrayList<>();\n  subscriptions.matches(tokenQueue,matchingSubs);\n  Map<String,Subscription> subsForClient=new HashMap<>();\n  for (  Subscription sub : matchingSubs) {\n    Subscription existingSub=subsForClient.get(sub.getClientId());\n// bug_start\n    if (existingSub == null || existingSub.getRequestedQos().ordinal() < sub.getRequestedQos().ordinal()) {\n// bug_end\n      subsForClient.put(sub.getClientId(),sub);\n    }\n  }\n  return new ArrayList<>(subsForClient.values());\n}\n"}
{"INPUT": "public static void assertAndEnsureCleanDb(ContentEngine contentEngine){\n  log.debug(\"verifying that db is clean after test\");\n  ContentService contentService=contentEngine.getContentEngineConfiguration().getContentService();\n  List<ContentItem> items=contentService.createContentItemQuery().list();\n// bug_start\n  if (items != null && items.isEmpty() == false) {\n// bug_end\n    throw new AssertionError(\"ContentItem is not empty\");\n  }\n}\n"}
{"INPUT": "private RuntimeException mangleMultipleCompilationErrorsException(MultipleCompilationErrorsException e,List<StringSection> sections){\n  RuntimeException result=e;\n  ErrorCollector collector=e.getErrorCollector();\n  @SuppressWarnings({\"unchecked\"}) List<Message> errors=(List<Message>)collector.getErrors();\n// bug_start\n  if (errors.size() > 0) {\n// bug_end\n    Message firstMessage=errors.get(0);\n    if (firstMessage instanceof SyntaxErrorMessage) {\n      @SuppressWarnings({\"ThrowableResultOfMethodCallIgnored\"}) SyntaxException syntaxException=((SyntaxErrorMessage)firstMessage).getCause();\n      Position errorPosition=new Position(syntaxException.getLine(),syntaxException.getStartColumn());\n      StringSection precedingSection=findPrecedingSection(errorPosition,sections);\n      if (precedingSection != null) {\n        offsetPositionFromSection(errorPosition,precedingSection);\n        if (sections.get(sections.size() - 1) == precedingSection) {\n          errorPosition.column=precedingSection.lastSourcePosition.column;\n        }\n        String message=mangleExceptionMessage(e.getMessage(),errorPosition);\n        result=new TemplateParseException(message,e,errorPosition.row,errorPosition.column);\n      }\n    }\n  }\n  return result;\n}\n"}
{"INPUT": "public static UriRequest getUriRequest(RequestParams params,Type loadType) throws Throwable {\n  String uri=params.getUri();\n  if (uri.startsWith(\"http\")) {\n    return new HttpRequest(params,loadType);\n  }\n else   if (uri.startsWith(\"assets://\")) {\n    if (ASSETS_REQUEST_CLS != null) {\n      Constructor<? extends AssetsRequest> constructor=ASSETS_REQUEST_CLS.getConstructor(RequestParams.class,Class.class);\n      return constructor.newInstance(params,loadType);\n    }\n else {\n      return new AssetsRequest(params,loadType);\n    }\n  }\n// bug_start\n else   if (uri.startsWith(\"file://\")) {\n// bug_end\n    return new LocalFileRequest(params,loadType);\n  }\n else {\n    throw new IllegalArgumentException(\"The url not be support: \" + uri);\n  }\n}\n"}
{"INPUT": "@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){\n  if (LOGD)   Log.d(TAG,\"onUpgrade triggered: \" + oldVersion);\nswitch (oldVersion) {\ncase 12:\n{\n      mMaxScreenId=0;\n      addWorkspacesTable(db,false);\n    }\ncase 13:\n{\n    try (SQLiteTransaction t=new SQLiteTransaction(db)){\n      db.execSQL(\"ALTER TABLE favorites \" + \"ADD COLUMN appWidgetProvider TEXT;\");\n      t.commit();\n    }\n catch (    SQLException ex) {\n      Log.e(TAG,ex.getMessage(),ex);\n      break;\n    }\n  }\ncase 14:\n{\n  try (SQLiteTransaction t=new SQLiteTransaction(db)){\n    db.execSQL(\"ALTER TABLE favorites \" + \"ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;\");\n    db.execSQL(\"ALTER TABLE workspaceScreens \" + \"ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;\");\n    t.commit();\n  }\n catch (  SQLException ex) {\n    Log.e(TAG,ex.getMessage(),ex);\n    break;\n  }\n}\ncase 15:\n{\nif (!addIntegerColumn(db,Favorites.RESTORED,0)) {\n  break;\n}\n}\ncase 16:\n{\n}\ncase 17:\n{\n}\ncase 18:\n{\nremoveOrphanedItems(db);\n}\ncase 19:\n{\nif (!addProfileColumn(db)) {\nbreak;\n}\n}\ncase 20:\nif (!updateFolderItemsRank(db,true)) {\nbreak;\n}\ncase 21:\nif (!recreateWorkspaceTable(db)) {\nbreak;\n}\ncase 22:\n{\nif (!addIntegerColumn(db,Favorites.OPTIONS,0)) {\nbreak;\n}\n}\ncase 23:\ncase 24:\ncase 25:\nconvertShortcutsToLauncherActivities(db);\ncase 26:\n// bug_start\nif (FeatureFlags.QSB_ON_FIRST_SCREEN && !LauncherDbUtils.prepareScreenZeroToHostQsb(mContext,db)) {\n// bug_end\nbreak;\n}\ncase 27:\nreturn;\n}\nLog.w(TAG,\"Destroying all old data.\");\ncreateEmptyDB(db);\n}\n"}
{"INPUT": "public ErrorLevel getErrorLevel(){\n  ErrorLevel level=null;\n  for (int i=0; i < causes.length; i++) {\n    final ErrorLevel causeLevel=(causes[i] instanceof ErrorMessage) ? ((ErrorMessage)causes[i]).getErrorLevel() : ErrorLevel.ERROR;\n    if (level == null) {\n      level=causeLevel;\n    }\n else {\n// bug_start\n      if (causeLevel.ordinal() > level.ordinal()) {\n// bug_end\n        level=causeLevel;\n      }\n    }\n  }\n  return level == null ? ErrorLevel.ERROR : level;\n}\n"}
{"INPUT": "private ChangeSet findChangedAndNewFiles(final File root,final Database database) throws FileNotFoundException, IOException {\n  Path rootPath=Paths.get(root.getAbsolutePath());\n  StatusFileVisitor fileVisitor=new StatusFileVisitor(rootPath,database);\n  Files.walkFileTree(rootPath,fileVisitor);\n  ChangeSet changeSet=fileVisitor.getChangeSet();\n  for (  PartialFileHistory fileHistory : database.getFileHistories()) {\n    FileVersion lastLocalVersion=fileHistory.getLastVersion();\n    File lastLocalVersionOnDisk=new File(config.getLocalDir() + File.separator + lastLocalVersion.getPath());\n    if (lastLocalVersion.getStatus() == FileStatus.DELETED) {\n      continue;\n    }\n// bug_start\n    if (!lastLocalVersionOnDisk.exists()) {\n// bug_end\n      changeSet.deletedFiles.add(lastLocalVersion.getPath());\n    }\n  }\n  return changeSet;\n}\n"}
{"INPUT": "@Override public boolean equals(Object o){\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  DimensionDesc that=(DimensionDesc)o;\n  if (column != null ? !column.equals(that.column) : that.column != null) {\n    return false;\n  }\n  if (name != null ? !name.equals(that.name) : that.name != null) {\n    return false;\n  }\n  if (table != null ? !table.equals(that.table) : that.table != null) {\n    return false;\n  }\n// bug_start\n  if (derived != null ? !derived.equals(that.derived) : that.derived != null) {\n// bug_end\n    return false;\n  }\n  return true;\n}\n"}
{"INPUT": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n// bug_start\n  if (getOpenOrders().size() < 1) {\n// bug_end\n    sb.append(\"No open orders!\");\n  }\n else {\n    sb.append(\"Open orders: \\n\");\n    for (    LimitOrder order : getOpenOrders()) {\n      sb.append(\"[order=\");\n      sb.append(order.toString());\n      sb.append(\"]\\n\");\n    }\n  }\n  return sb.toString();\n}\n"}
{"INPUT": "private static String getHtmlBegin(){\n// bug_start\n  return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\"\\n\" + \"    \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\\n\"+ \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\"+ \" xml:lang=\\\"en\\\" lang=\\\"en\\\"\\n\"+ \"      class=\\\"xref\\\">\\n\"+ \"<head>\\n\"+ \"<title>sampleFile - OpenGrok cross reference\"+ \" for /sampleFile</title></head><body>\\n\";\n// bug_end\n}\n"}
{"INPUT": "public boolean isLauncherIntent(){\n  final Set<String> intentCategories=intent.getCategories();\n// bug_start\n  return (intentCategories != null && intentCategories.contains(Intent.CATEGORY_LAUNCHER) && intent.getAction().equals(Intent.ACTION_MAIN));\n// bug_end\n}\n"}
{"INPUT": "public static String getMapKey(String dataId,String group){\n// bug_start\n  return String.format(\"%s$%s\",String.valueOf(dataId),String.valueOf(group));\n// bug_end\n}\n"}
{"INPUT": "private boolean noteAlreadyOpened(Note note){\n  DetailFragment detailFragment=(DetailFragment)mFragmentManager.findFragmentByTag(FRAGMENT_DETAIL_TAG);\n// bug_start\n  return detailFragment != null && detailFragment.getCurrentNote() != null && detailFragment.getCurrentNote().get_id() == note.get_id();\n// bug_end\n}\n"}
{"INPUT": "@Override public InvoicePayment getInvoicePaymentByCookieId(final String cookieId,final TenantContext context){\n  final InvoicePaymentModelDao invoicePaymentModelDao=dao.getInvoicePaymentByCookieId(cookieId,internalCallContextFactory.createInternalTenantContext(context.getAccountId(),ObjectType.ACCOUNT,context));\n// bug_start\n  return new DefaultInvoicePayment(invoicePaymentModelDao);\n// bug_end\n}\n"}
{"INPUT": "ApiInfo apiInfo(){\n// bug_start\n  return new ApiInfoBuilder().title(\"Swagger Generator\").description(\"This is an online swagger codegen server.  You can find out more at https://github.com/swagger-api/swagger-codegen or on [irc.freenode.net, #swagger](http://swagger.io/irc/).\").license(\"Apache 2.0\").licenseUrl(\"http://www.apache.org/licenses/LICENSE-2.0.html\").termsOfServiceUrl(\"\").version(\"2.3.1\").contact(new Contact(\"\",\"\",\"\")).build();\n// bug_end\n}\n"}
{"INPUT": "private static boolean isAutomationOrUselessLibrary(String libFileName){\n// bug_start\n  return libFileName.startsWith(\"qtp\") || libFileName.startsWith(\"automation\") || libFileName.equals(\"flex.swc\")|| libFileName.equals(\"servicemonitor.swc\")|| libFileName.equals(\"core.swc\");\n// bug_end\n}\n"}
{"INPUT": "protected static final int getAsuFromRssiDbm(int dbm){\n  if (dbm == CellInfo.UNAVAILABLE)   return 99;\n// bug_start\n  return (dbm / 2) + 113;\n// bug_end\n}\n"}
{"INPUT": "@Override public boolean isLetterboxedForDisplayCutoutLw(){\n  if (mAppToken == null) {\n    return false;\n  }\n  if (getDisplayContent().getDisplayInfo().displayCutout == null) {\n    return false;\n  }\n  if ((mAttrs.flags2 & FLAG2_LAYOUT_IN_DISPLAY_CUTOUT_AREA) != 0) {\n    return false;\n  }\n  final int fl=mAttrs.flags;\n  final int sysui=mSystemUiVisibility;\n// bug_start\n  return (fl & FLAG_FULLSCREEN) != 0 || (sysui & (SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | SYSTEM_UI_FLAG_FULLSCREEN)) != 0;\n// bug_end\n}\n"}
{"INPUT": "@Override protected AuthUser getUserInfo(AuthToken authToken){\n  String code=authToken.getAccessCode();\n  JSONObject param=new JSONObject();\n  param.put(\"tmp_auth_code\",code);\n  String response=new HttpUtils(config.getHttpConfig()).post(userInfoUrl(authToken),param.toJSONString());\n  JSONObject object=JSON.parseObject(response);\n  if (object.getIntValue(\"errcode\") != 0) {\n    throw new AuthException(object.getString(\"errmsg\"));\n  }\n  object=object.getJSONObject(\"user_info\");\n  AuthToken token=AuthToken.builder().openId(object.getString(\"openid\")).unionId(object.getString(\"unionid\")).build();\n// bug_start\n  return AuthUser.builder().uuid(object.getString(\"unionid\")).nickname(object.getString(\"nick\")).username(object.getString(\"nick\")).gender(AuthUserGender.UNKNOWN).source(source.toString()).token(token).build();\n// bug_end\n}\n"}
{"INPUT": "@Override public ExportResult<PhotosContainerResource> export(UUID jobId,TokenAuthData authData,Optional<ExportInformation> exportInformation){\n  try {\n    List<Map<String,Object>> photoItems=requestAllPhotoItems(authData);\n    downloadAndCachePhotos(jobId,authData,photoItems);\n    PhotosContainerResource containerResource=convertToResource(photoItems);\n    return new ExportResult<>(ExportResult.ResultType.END,containerResource);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n// bug_start\n    return new ExportResult<>(ExportResult.ResultType.ERROR,\"Error retrieving contacts: \" + e.getMessage());\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public Operator<? super T> call(final Operator<? super GroupedObservable<K,T>> childOperator){\n  final CompositeSubscription parentSubscription=new CompositeSubscription();\n  return new Operator<T>(parentSubscription){\n    private final Map<K,PublishSubject<T>> groups=new HashMap<K,PublishSubject<T>>();\n    private final AtomicInteger completionCounter=new AtomicInteger(0);\n    @Override public void onCompleted(){\n      for (      PublishSubject<T> ps : groups.values()) {\n        ps.onCompleted();\n      }\n// bug_start\n      childOperator.onCompleted();\n// bug_end\n    }\n    @Override public void onError(    Throwable e){\n      childOperator.onError(e);\n    }\n    @Override public void onNext(    T t){\n      try {\n        final K key=keySelector.call(t);\n        PublishSubject<T> gps=groups.get(key);\n        if (gps == null) {\n          if (childOperator.isUnsubscribed()) {\n            return;\n          }\n          gps=PublishSubject.create();\n          final PublishSubject<T> _gps=gps;\n          GroupedObservable<K,T> go=new GroupedObservable<K,T>(key,new Action1<Operator<? super T>>(){\n            @Override public void call(            final Operator<? super T> o){\n              o.add(Subscriptions.create(new Action0(){\n                @Override public void call(){\n                  completeInner();\n                }\n              }\n));\n// bug_start\n              _gps.subscribe(o);\n// bug_end\n            }\n          }\n);\n          groups.put(key,gps);\n          completionCounter.incrementAndGet();\n          childOperator.onNext(go);\n        }\n        gps.onNext(t);\n      }\n catch (      Throwable e) {\n        onError(e);\n      }\n    }\n    private void completeInner(){\n      if (completionCounter.decrementAndGet() == 0) {\n        parentSubscription.unsubscribe();\n        for (        PublishSubject<T> ps : groups.values()) {\n          ps.onCompleted();\n        }\n        childOperator.onCompleted();\n      }\n    }\n  }\n;\n}\n"}
{"INPUT": "public InvoiceItem toInvoiceItem(){\n  return new InvoiceItem(){\n    @Override public InvoiceItemType getInvoiceItemType(){\n      return itemType;\n    }\n    @Override public UUID getInvoiceId(){\n      return invoiceId;\n    }\n    @Override public UUID getAccountId(){\n      return accountId;\n    }\n    @Override public UUID getChildAccountId(){\n      return childAccountId;\n    }\n    @Override public LocalDate getStartDate(){\n      return startDate;\n    }\n    @Override public LocalDate getEndDate(){\n      return endDate;\n    }\n    @Override public BigDecimal getAmount(){\n      return amount;\n    }\n    @Override public Currency getCurrency(){\n      return currency;\n    }\n    @Override public String getDescription(){\n      return description;\n    }\n    @Override public UUID getBundleId(){\n      return bundleId;\n    }\n    @Override public UUID getSubscriptionId(){\n      return subscriptionId;\n    }\n    @Override public String getProductName(){\n// bug_start\n      return null;\n// bug_end\n    }\n    @Override public String getPrettyProductName(){\n// bug_start\n      return null;\n// bug_end\n    }\n    @Override public String getPlanName(){\n      return planName;\n    }\n    @Override public String getPrettyPlanName(){\n      return prettyPlanName;\n    }\n    @Override public String getPhaseName(){\n      return phaseName;\n    }\n    @Override public String getPrettyPhaseName(){\n      return prettyPhaseName;\n    }\n    @Override public String getUsageName(){\n      return usageName;\n    }\n    @Override public String getPrettyUsageName(){\n      return prettyUsageName;\n    }\n    @Override public BigDecimal getRate(){\n      return rate;\n    }\n    @Override public UUID getLinkedItemId(){\n      return linkedInvoiceItemId;\n    }\n    @Override public Integer getQuantity(){\n      return quantity;\n    }\n    @Override public String getItemDetails(){\n      return itemDetails;\n    }\n    @Override public boolean matches(    final Object o){\n      return false;\n    }\n    @Override public UUID getId(){\n      return null;\n    }\n    @Override public DateTime getCreatedDate(){\n      return null;\n    }\n    @Override public DateTime getUpdatedDate(){\n      return null;\n    }\n  }\n;\n}\n"}
{"INPUT": "@Bean @ConditionalOnMissingBean({EventStorageEngine.class,EventBus.class}) public SimpleEventBus eventBus(AxonConfiguration configuration){\n// bug_start\n  return new SimpleEventBus(Integer.MAX_VALUE,configuration.messageMonitor(EventStore.class,\"eventStore\"));\n// bug_end\n}\n"}
{"INPUT": "private AbstractSearchAsyncAction<SearchPhaseResult> createAction(final boolean controlled,final AtomicLong expected){\n  final Runnable runnable;\n  final TransportSearchAction.SearchTimeProvider timeProvider;\n  if (controlled) {\n    runnable=null;\n    timeProvider=new TransportSearchAction.SearchTimeProvider(0,0,null);\n  }\n else {\n    runnable=null;\n    timeProvider=new TransportSearchAction.SearchTimeProvider(0,System.nanoTime(),null);\n  }\n  final SearchRequest request=new SearchRequest();\n// bug_start\n  return new AbstractSearchAsyncAction<SearchPhaseResult>(\"test\",null,null,null,Collections.singletonMap(\"foo\",new AliasFilter(new MatchAllQueryBuilder())),Collections.singletonMap(\"foo\",2.0f),null,request,null,new GroupShardsIterator<>(Collections.singletonList(new SearchShardIterator(null,null,Collections.emptyList(),null))),timeProvider,0,null,new InitialSearchPhase.ArraySearchPhaseResults<>(10),request.getMaxConcurrentShardRequests()){\n// bug_end\n    @Override protected SearchPhase getNextPhase(    final SearchPhaseResults<SearchPhaseResult> results,    final SearchPhaseContext context){\n      return null;\n    }\n    @Override protected void executePhaseOnShard(    final SearchShardIterator shardIt,    final ShardRouting shard,    final SearchActionListener<SearchPhaseResult> listener){\n    }\n    @Override long buildTookInMillis(){\n      runnable.run();\n      return super.buildTookInMillis();\n    }\n  }\n;\n}\n"}
{"INPUT": "public Object getValueForColumn(Oop oop,int col){\n  ByteArrayOutputStream bos=new ByteArrayOutputStream();\nswitch (col) {\ncase 0:\n    return new AddressWrapper(oop.getHandle());\ncase 1:\n  oop.printValueOn(new PrintStream(bos));\nbreak;\ncase 2:\nif (hasArrays) {\nif (oop instanceof Array) {\n// bug_start\n  return new Long(((Array)oop).getLength());\n// bug_end\n}\nreturn null;\n}\n else {\noop.getKlass().printValueOn(new PrintStream(bos));\nbreak;\n}\ncase 3:\nif (hasArrays) {\noop.getKlass().printValueOn(new PrintStream(bos));\nbreak;\n}\n else {\nif (VM.getVM().getRevPtrs() != null) {\nif (VM.getVM().getRevPtrs().get(oop) != null) {\n  return \"Alive\";\n}\n else {\n  return \"Dead\";\n}\n}\n}\ncase 4:\nif (hasArrays) {\nif (VM.getVM().getRevPtrs() != null) {\nif (VM.getVM().getRevPtrs().get(oop) != null) {\nreturn \"Alive\";\n}\n else {\nreturn \"Dead\";\n}\n}\n}\ndefault :\nthrow new RuntimeException(\"Column \" + col + \" out of bounds\");\n}\nreturn bos.toString();\n}\n"}
{"INPUT": "@Override public ObservableSource<RxBleConnection> call() throws Exception {\n  final ConnectionComponent connectionComponent=connectionComponentBuilder.connectionModule(new ConnectionModule(options)).build();\n  final Set<ConnectionSubscriptionWatcher> connSubWatchers=connectionComponent.connectionSubscriptionWatchers();\n// bug_start\n  return obtainRxBleConnection(connectionComponent).delaySubscription(enqueueConnectOperation(connectionComponent)).mergeWith(observeDisconnections(connectionComponent)).doOnSubscribe(new Consumer<Disposable>(){\n// bug_end\n    @Override public void accept(    Disposable disposable) throws Exception {\n      for (      ConnectionSubscriptionWatcher csa : connSubWatchers) {\n        csa.onConnectionSubscribed();\n      }\n    }\n  }\n).doFinally(new Action(){\n    @Override public void run() throws Exception {\n      for (      ConnectionSubscriptionWatcher csa : connSubWatchers) {\n        csa.onConnectionUnsubscribed();\n      }\n    }\n  }\n).subscribeOn(callbacksScheduler).unsubscribeOn(callbacksScheduler);\n}\n"}
{"INPUT": "@Override public synchronized String toString(){\n// bug_start\n  return \"HttpDestination@\" + hashCode() + \"//\"+ _address.getHost()+ \":\"+ _address.getPort()+ \"(\"+ _connections.size()+ \",\"+ _idle.size()+ \",\"+ _queue.size()+ \")\";\n// bug_end\n}\n"}
{"INPUT": "private static String getCompletionItemPropertyString(CompletionItem completionItem){\n  String additionalTextEdits=\"\";\n  if (completionItem.getAdditionalTextEdits() != null && !completionItem.getAdditionalTextEdits().isEmpty()) {\n    additionalTextEdits=\",\" + GSON.toJson(completionItem.getAdditionalTextEdits());\n  }\n// bug_start\n  return (\"{\" + completionItem.getInsertText() + \",\"+ completionItem.getDetail()+ \",\"+ completionItem.getLabel()+ additionalTextEdits+ \"}\").replace(\"\\r\\n\",\"\\n\");\n// bug_end\n}\n"}
{"INPUT": "public static boolean sameSign(IntegerStamp s1,IntegerStamp s2){\n// bug_start\n  return s1.isPositive() && s2.isPositive() || s1.isNegative() && s2.isNegative();\n// bug_end\n}\n"}
{"INPUT": "@Override public Object execute(Object[] parameters){\n  ParametersParameterAccessor accessor=new ParametersParameterAccessor(queryMethod.getParameters(),parameters);\n  StringQuery stringQuery=createQuery(accessor);\n  Class<?> clazz=queryMethod.getEntityInformation().getJavaType();\n  IndexCoordinates index=elasticsearchOperations.getIndexCoordinatesFor(clazz);\n  Object result=null;\n  if (queryMethod.isPageQuery()) {\n    stringQuery.setPageable(accessor.getPageable());\n    SearchHits<?> searchHits=elasticsearchOperations.search(stringQuery,clazz,index);\n    result=SearchHitSupport.page(searchHits,stringQuery.getPageable());\n  }\n else   if (queryMethod.isCollectionQuery()) {\n    if (accessor.getPageable().isPaged()) {\n      stringQuery.setPageable(accessor.getPageable());\n    }\n    result=elasticsearchOperations.search(stringQuery,clazz,index);\n  }\n else {\n    result=elasticsearchOperations.searchOne(stringQuery,clazz,index);\n  }\n// bug_start\n  return SearchHitSupport.unwrapSearchHits(result);\n// bug_end\n}\n"}
{"INPUT": "@Override public String getAstExtra(){\n  BasedSequence content=getContentChars();\n  int lines=getSegments().length;\n// bug_start\n  return segmentSpan(openingMarker,\"open\") + segmentSpan(info,\"info\") + segmentSpan(content,\"content\")+ \" lines[\"+ lines+ \"]\"+ segmentSpan(closingMarker,\"close\");\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return super.toString() + \" \" + (isEnd ? \"end: \" + InsnUtils.formatOffset(startAddr) + \"-\"+ InsnUtils.formatOffset(endAddr) : \"active: \" + InsnUtils.formatOffset(startAddr));\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return \"State{\" + \"mTargetPosition=\" + mTargetPosition + \", mData=\"+ mData+ \", mItemCount=\"+ mItemCount+ \", mPreviousLayoutItemCount=\"+ mPreviousLayoutItemCount+ \", mDeletedInvisibleItemCountSincePreviousLayout=\"+ mDeletedInvisibleItemCountSincePreviousLayout+ \", mStructureChanged=\"+ mStructureChanged+ \", mInPreLayout=\"+ mInPreLayout+ \", mRunSimpleAnimations=\"+ mRunSimpleAnimations+ \", mRunPredictiveAnimations=\"+ mRunPredictiveAnimations+ '}';\n// bug_end\n}\n"}
{"INPUT": "private Date getDate(String dateStr){\n  if (dateStr == null)   return null;\n  Matcher m=PLACE_HOLDER_PATTERN.matcher(dateStr);\n  if (m.find()) {\n    return (Date)resolver.resolve(dateStr);\n  }\n  m=EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);\n  if (m.find()) {\n    String expr=null;\n    expr=m.group(1).replaceAll(\"NOW\",\"\");\n    try {\n      return EvaluatorBag.dateMathParser.parseMath(expr);\n    }\n catch (    ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\"Invalid expression for date\",exp);\n    }\n  }\n  try {\n// bug_start\n    return DataImporter.DATE_TIME_FORMAT.parse(dateStr);\n// bug_end\n  }\n catch (  ParseException exp) {\n    throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\"Invalid expression for date\",exp);\n  }\n}\n"}
{"INPUT": "@Override public boolean isPrepared(){\n  SimpleExoPlayer player=playerView.getPlayer();\n// bug_start\n  return player != null && (player.getPlaybackState() == ExoPlayer.STATE_READY || (player.getPlaybackState() == ExoPlayer.STATE_BUFFERING && player.getPlayWhenReady()));\n// bug_end\n}\n"}
{"INPUT": "@Override public Optional<Value> solveSymbolAsValue(String name){\n  Expression scope=wrappedNode.getScope();\n  if (wrappedNode.getName().toString().equals(name)) {\n    ResolvedType typeOfScope=JavaParserFacade.get(typeSolver).getType(scope);\n    if (typeOfScope.isArray() && name.equals(ARRAY_LENGTH_FIELD_NAME)) {\n      return Optional.of(new Value(ResolvedPrimitiveType.INT,ARRAY_LENGTH_FIELD_NAME));\n    }\n    if (typeOfScope.isReferenceType()) {\n      return solveSymbolAsValue(name,typeOfScope.asReferenceType());\n    }\n else     if (typeOfScope.isConstraint()) {\n      return solveSymbolAsValue(name,typeOfScope.asConstraintType().getBound().asReferenceType());\n    }\n else {\n      return Optional.empty();\n    }\n  }\n else {\n// bug_start\n    return getParent().orElseThrow(null).solveSymbolAsValue(name);\n// bug_end\n  }\n}\n"}
{"INPUT": "public <T extends Content>T getByID(ContentType type,int id){\n  if (temporaryMapper != null && temporaryMapper[type.ordinal()] != null && temporaryMapper[type.ordinal()].length != 0) {\n    if (id < 0) {\n      return null;\n    }\n    if (temporaryMapper[type.ordinal()].length <= id || temporaryMapper[type.ordinal()][id] == null) {\n// bug_start\n      return getByID(type,0);\n// bug_end\n    }\n    return (T)temporaryMapper[type.ordinal()][id];\n  }\n  if (id >= contentMap[type.ordinal()].size || id < 0) {\n    return null;\n  }\n  return (T)contentMap[type.ordinal()].get(id);\n}\n"}
{"INPUT": "@Override public Optional<String> parse(String target,Object context){\n  Map<String,Object> vars=new HashMap<>();\n  vars.put(\"context\",context);\n  DynamicScriptEngine engine=DynamicScriptEngineFactory.getEngine(language);\n  String scriptId=String.valueOf(script.hashCode());\n  try {\n    if (!engine.compiled(scriptId)) {\n      engine.compile(scriptId,language);\n    }\n    Object result=engine.execute(scriptId,vars).getIfSuccess();\n    if (result == null) {\n// bug_start\n      return null;\n// bug_end\n    }\n    return Optional.of(String.valueOf(result));\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n"}
{"INPUT": "private Set<String> getMissingFields(GraphQLInputObjectType type,Map<String,ObjectField> objectFieldMap,GraphqlFieldVisibility fieldVisibility){\n// bug_start\n  return fieldVisibility.getFieldDefinitions(type).stream().filter(null).map(null).filter(((Predicate<String>)null).negate()).collect(Collectors.toSet());\n// bug_end\n}\n"}
{"INPUT": "private static boolean isFatal(String msg){\n// bug_start\n  return msg.toLowerCase().contains(\"in prolog\") || msg.toLowerCase().contains(\"preceding the root element must be well-formed\");\n// bug_end\n}\n"}
{"INPUT": "@Override public boolean isAllowed(Map<String,String> osmProperties){\n  String highwayValue=osmProperties.get(\"highway\");\n  if (!allowedHighwayTags.contains(highwayValue))   return false;\n  if (hasTag(\"bicycle\",intended,osmProperties))   return true;\n  if (hasTag(\"motorroad\",\"yes\",osmProperties))   return false;\n// bug_start\n  return checkAccessRestrictions(osmProperties);\n// bug_end\n}\n"}
{"INPUT": "SimpleJavaFileObject asJFO(java.io.File dir){\n// bug_start\n  return new SimpleJavaFileObject(URI.create(dir.getAbsolutePath() + \"/\" + filename),JavaFileObject.Kind.SOURCE){\n// bug_end\n    @Override public CharSequence getCharContent(    boolean ignoreEncodingErrors) throws IOException {\n      return contents;\n    }\n  }\n;\n}\n"}
{"INPUT": "public static String getInstantUploadFilePath(Locale current,String remotePath,String fileName,long dateTaken,Boolean subfolderByDate){\n  String subPath=\"\";\n  if (subfolderByDate) {\n    subPath=getSubPathFromDate(dateTaken,current);\n  }\n// bug_start\n  return remotePath + OCFile.PATH_SEPARATOR + subPath+ (fileName == null ? \"\" : fileName);\n// bug_end\n}\n"}
{"INPUT": "public static DocumentFile fromUri(Context context,Uri treeUri){\n  if (Utils.hasLollipop()) {\n    return new BasicDocumentFile(null,context,treeUri);\n  }\n else {\n// bug_start\n    return null;\n// bug_end\n  }\n}\n"}
{"INPUT": "public String toString(){\n  String inverter=\"\";\n  if (this.getInverted())   inverter=\" not \";\n// bug_start\n  return (\"Field \" + this.field + \" must \"+ inverter+ this.getSentenceRepresentation()+ \" \"+ this.value);\n// bug_end\n}\n"}
{"INPUT": "private boolean loadNextRecord(){\n// bug_start\n  return relationshipId != NO_SUCH_RELATIONSHIP && relationshipStore.readRecord(relationshipId,relationshipRecord,CHECK,cursor).inUse();\n// bug_end\n}\n"}
{"INPUT": "private static DataStream<String> getTextDataStream(final StreamExecutionEnvironment env){\n  if (fileOutput) {\n    final String[] tokens=textPath.split(\":\");\n    final String localFile=tokens[tokens.length - 1];\n    return env.addSource(new StormFiniteSpoutWrapper<String>(new StormFileSpout(localFile),true),TypeExtractor.getForClass(String.class)).setParallelism(1);\n  }\n// bug_start\n  return env.addSource(new StormFiniteSpoutWrapper<String>(new StormInMemorySpout(WordCountData.WORDS),true),TypeExtractor.getForClass(String.class));\n// bug_end\n}\n"}
{"INPUT": "private PackageInstallerSession createSession(boolean staged,boolean withGrantedPermissions,int sessionId,boolean isMultiPackage,int parentSessionId,int[] childSessionIds){\n  PackageInstaller.SessionParams params=new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL);\n  if (staged) {\n    params.isStaged=true;\n  }\n  if (withGrantedPermissions) {\n    params.grantedRuntimePermissions=new String[]{\"permission1\",\"permission2\"};\n  }\n  if (isMultiPackage) {\n    params.isMultiPackage=true;\n  }\n// bug_start\n  return new PackageInstallerSession(null,null,mMockPackageManagerInternal,null,BackgroundThread.getHandler().getLooper(),null,sessionId,456,\"testInstaller\",-1,InstallSource.create(\"testInstaller\"),params,0L,mTmpDir,null,true,true,false,childSessionIds != null ? childSessionIds : new int[0],parentSessionId,staged ? true : false,false,false,PackageInstaller.SessionInfo.STAGED_SESSION_VERIFICATION_FAILED,\"some error\");\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return \"UpdateRecord[\" + mProvider + \" \"+ mReceiver.mIdentity.mPackageName+ \"(\"+ mReceiver.mIdentity.mUid+ (mIsForegroundUid ? \" foreground\" : \" background\")+ \")\"+ \" \"+ mRealRequest+ \"]\";\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n  SB b=new SB(\"[\");\n  for (int i=0; i < idx; i++) {\n    if (i != 0)     b.a(',');\n    b.a(arr[i]);\n  }\n  b.a(']');\n// bug_start\n  return S.toString(GridIntList.class,this,\"arr\",b);\n// bug_end\n}\n"}
{"INPUT": "@Override public ValueFetcher valueFetcher(MapperService mapperService,SearchLookup searchLookup,String format){\n// bug_start\n  return new SourceValueFetcher(name(),mapperService,false){\n// bug_end\n    @Override protected String parseSourceValue(    Object value){\n      return value.toString();\n    }\n  }\n;\n}\n"}
{"INPUT": "private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config){\n  Class<?>[] interfaces=config.getProxiedInterfaces();\n// bug_start\n  return (interfaces.length == 0 || (interfaces.length == 1 && SpringProxy.class.equals(interfaces[0])));\n// bug_end\n}\n"}
{"INPUT": "@Override protected AbstractNonNamespacedResourceOperator<KubernetesClient,ClusterRoleBinding,ClusterRoleBindingList,DoneableClusterRoleBinding,Resource<ClusterRoleBinding,DoneableClusterRoleBinding>> createResourceOperations(Vertx vertx,KubernetesClient mockClient){\n// bug_start\n  return new ClusterRoleBindingOperator(vertx,mockClient,100);\n// bug_end\n}\n"}
{"INPUT": "@Override public Publisher<Long> createPublisher(final long elements){\n// bug_start\n  return FlowableTck.wrap(Flowable.fromCallable(new Callable<Long>(){\n// bug_end\n    @Override public Long call() throws Exception {\n      return 1L;\n    }\n  }\n// bug_start\n));\n// bug_end\n}\n"}
{"INPUT": "@Override public Iterator<V> iterator(){\n  return new Iterator<V>(){\n// bug_start\n// bug_end\n    private Iterator<V> iter;\n    private RedisClient client;\n    private long iterPos;\n    private boolean removeExecuted;\n    private V value;\n    @Override public boolean hasNext(){\n      if (iter == null || !iter.hasNext()) {\n        ListScanResult<V> res=scanIterator(client,iterPos);\n        client=res.getRedisClient();\n// bug_start\n// bug_end\n        iter=res.getValues().iterator();\n        iterPos=res.getPos();\n      }\n      return iter.hasNext();\n    }\n    @Override public V next(){\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"No such element at index\");\n      }\n      value=iter.next();\n      removeExecuted=false;\n      return value;\n    }\n    @Override public void remove(){\n      if (removeExecuted) {\n        throw new IllegalStateException(\"Element been already deleted\");\n      }\n      if (iter == null) {\n        throw new IllegalStateException();\n      }\n      iter.remove();\n      RedissonSet.this.remove(value);\n      removeExecuted=true;\n    }\n  }\n;\n}\n"}
{"INPUT": "@DataProvider(name=\"completion-data-provider\") @Override public Object[][] dataProvider(){\n// bug_start\n  return new Object[][]{{\"serviceAnnotation1.json\",\"annotation\"},{\"serviceAnnotation2.json\",\"annotation\"},{\"resourceAnnotation1.json\",\"annotation\"},{\"resourceAnnotation2.json\",\"annotation\"},{\"functionAnnotation1.json\",\"annotation\"},{\"endpointAnnotation1.json\",\"annotation\"}};\n// bug_end\n}\n"}
{"INPUT": "@Override protected Application configure(){\n  forceSet(TestProperties.CONTAINER_PORT,\"0\");\n// bug_start\n  return DropwizardResourceConfig.forTesting(new MetricRegistry()).register(OptionalLongReturnResource.class);\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return \"Update{\" + \"updateId=\" + updateId + \", message=\"+ message+ \", inlineQuery=\"+ inlineQuery+ \", chosenInlineQuery=\"+ chosenInlineQuery+ '}';\n// bug_end\n}\n"}
{"INPUT": "@Override public ValueFetcher valueFetcher(MapperService mapperService,SearchLookup searchLookup,String format){\n  if (format != null) {\n    throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\"+ typeName()+ \"] doesn't support formats.\");\n  }\n// bug_start\n  return new SourceValueFetcher(name(),mapperService,false,nullValue){\n// bug_end\n    @Override protected Object parseSourceValue(    Object value){\n      if (value.equals(\"\")) {\n        return nullValue;\n      }\n      return type.parse(value,coerce);\n    }\n  }\n;\n}\n"}
{"INPUT": "@Override public AggregateCombiner makeAggregateCombiner(){\n  return new ObjectAggregateCombiner<SketchHolder>(){\n    private final Union union=(Union)SetOperation.builder().build(size,Family.UNION);\n    private final SketchHolder combined=SketchHolder.of(union);\n    @Override public void reset(    ColumnValueSelector selector){\n      union.reset();\n      fold(selector);\n    }\n    @Override public void fold(    ColumnValueSelector selector){\n// bug_start\n      @SuppressWarnings(\"unchecked\") SketchHolder other=((ObjectColumnSelector<SketchHolder>)selector).get();\n// bug_end\n      other.updateUnion(union);\n      combined.invalidateCache();\n    }\n    @Override public Class<SketchHolder> classOfObject(){\n      return SketchHolder.class;\n    }\n// bug_start\n    @Nullable @Override public SketchHolder get(){\n// bug_end\n      return combined;\n    }\n  }\n;\n}\n"}
{"INPUT": "@Override public boolean equals(java.lang.Object o){\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ConfigFile configFile=(ConfigFile)o;\n// bug_start\n  return Objects.equals(this.type,configFile.type) && Objects.equals(this.destFile,configFile.destFile) && Objects.equals(this.srcFile,configFile.srcFile);\n// bug_end\n}\n"}
{"INPUT": "public final long readUnsignedInt() throws IOException {\n  d.readFully(w,0,4);\n// bug_start\n  return (w[3]) << 24 | (w[2] & 0xff) << 16 | (w[1] & 0xff) << 8 | (w[0] & 0xff);\n// bug_end\n}\n"}
{"INPUT": "static TypeDescription logicalTypeToOrcType(LogicalType type){\n  type=type.copy(true);\nswitch (type.getTypeRoot()) {\ncase CHAR:\n    return TypeDescription.createChar().withMaxLength(((CharType)type).getLength());\ncase VARCHAR:\n  int len=((VarCharType)type).getLength();\nif (len == VarCharType.MAX_LENGTH) {\n  return TypeDescription.createString();\n}\n else {\n  return TypeDescription.createVarchar().withMaxLength(len);\n}\ncase BOOLEAN:\nreturn TypeDescription.createBoolean();\ncase VARBINARY:\nif (type.equals(DataTypes.BYTES().getLogicalType())) {\nreturn TypeDescription.createBinary();\n}\n else {\nthrow new UnsupportedOperationException(\"Not support other binary type: \" + type);\n}\ncase DECIMAL:\nDecimalType decimalType=(DecimalType)type;\n// bug_start\nreturn TypeDescription.createDecimal().withPrecision(decimalType.getPrecision()).withScale(decimalType.getScale());\n// bug_end\ncase TINYINT:\nreturn TypeDescription.createByte();\ncase SMALLINT:\nreturn TypeDescription.createShort();\ncase INTEGER:\nreturn TypeDescription.createInt();\ncase BIGINT:\nreturn TypeDescription.createLong();\ncase FLOAT:\nreturn TypeDescription.createFloat();\ncase DOUBLE:\nreturn TypeDescription.createDouble();\ncase DATE:\nreturn TypeDescription.createDate();\ncase TIMESTAMP_WITHOUT_TIME_ZONE:\nreturn TypeDescription.createTimestamp();\ncase ARRAY:\nArrayType arrayType=(ArrayType)type;\nreturn TypeDescription.createList(logicalTypeToOrcType(arrayType.getElementType()));\ncase MAP:\nMapType mapType=(MapType)type;\nreturn TypeDescription.createMap(logicalTypeToOrcType(mapType.getKeyType()),logicalTypeToOrcType(mapType.getValueType()));\ncase ROW:\nRowType rowType=(RowType)type;\nTypeDescription struct=TypeDescription.createStruct();\nfor (int i=0; i < rowType.getFieldCount(); i++) {\nstruct.addField(rowType.getFieldNames().get(i),logicalTypeToOrcType(rowType.getChildren().get(i)));\n}\nreturn struct;\ndefault :\nthrow new UnsupportedOperationException(\"Unsupported type: \" + type);\n}\n}\n"}
{"INPUT": "private ReplicaQueryRule getReplicaQueryRule(final String dataSourceName){\n  GovernanceShardingSphereDataSource dataSource=applicationContext.getBean(dataSourceName,GovernanceShardingSphereDataSource.class);\n  SchemaContexts schemaContexts=(SchemaContexts)FieldValueUtil.getFieldValue(dataSource,\"schemaContexts\");\n// bug_start\n  return (ReplicaQueryRule)schemaContexts.getDefaultMetaData().getRules().iterator().next();\n// bug_end\n}\n"}
{"INPUT": "@Override protected AbstractNonNamespacedResourceOperator<KubernetesClient,ClusterRole,ClusterRoleList,DoneableClusterRole,Resource<ClusterRole,DoneableClusterRole>> createResourceOperations(Vertx vertx,KubernetesClient mockClient){\n// bug_start\n  return new ClusterRoleOperator(vertx,mockClient,100);\n// bug_end\n}\n"}
{"INPUT": "public static double plainDateToJulianDate(Calendar calendar){\n// bug_start\n  return calendar.getTimeInMillis() / MILLISECONDS_PER_DAY - 0.5 + J1970;\n// bug_end\n}\n"}
{"INPUT": "private static UnframedGrpcService buildUnframedGrpcService(BindableService bindableService){\n// bug_start\n  return (UnframedGrpcService)new GrpcServiceBuilder().addService(bindableService).setMaxInboundMessageSizeBytes(MAX_MESSAGE_BYTES).setMaxOutboundMessageSizeBytes(MAX_MESSAGE_BYTES).supportedSerializationFormats(GrpcSerializationFormats.values()).enableUnframedRequests(true).build();\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return \"TxOutput{\" + \"\\nindex=\" + index + \",\\nvalue=\"+ value+ \",\\naddresses=\"+ addresses+ \",\\nscriptProgramBytes=\"+ Hex.toHexString(scriptProgramBytes)+ \"}\\n\";\n// bug_end\n}\n"}
{"INPUT": "@Override protected org.elasticsearch.action.support.master.AcknowledgedResponse createServerTestInstance(XContentType xContentType){\n// bug_start\n  return new org.elasticsearch.action.support.master.AcknowledgedResponse(randomBoolean());\n// bug_end\n}\n"}
{"INPUT": "@Override public boolean equals(Object o){\n  if (this == o)   return true;\n  if (o == null || getClass() != o.getClass())   return false;\n  UsernamePasswordToken that=(UsernamePasswordToken)o;\n// bug_start\n  return password.equals(password) && Objects.equals(username,that.username);\n// bug_end\n}\n"}
{"INPUT": "@CalledOnlyBy(AmidstThread.EDT) private String createVersionString(String versionId,String recognisedVersionName){\n// bug_start\n  return \"Amidst \" + metadata.getVersion().createVersionString() + \" - Minecraft Version \"+ versionId+ \" (\"+ recognisedVersionName+ \")\";\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return \"UidTraffic{\" + \"mAppUid=\" + mAppUid + \", mRxBytes=\"+ mRxBytes+ \", mTxBytes=\"+ mTxBytes+ '}';\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return \"SegmentAnalysis{\" + \"id='\" + id + '\\''+ \", interval=\"+ interval+ \", size=\"+ size+ \", numRows=\"+ numRows+ '}';\n// bug_end\n}\n"}
{"INPUT": "@Override public boolean equals(final Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (!(obj instanceof KeyValue)) {\n    return false;\n  }\n  final KeyValue other=(KeyValue)obj;\n// bug_start\n  return (key == null ? other.key == null : key.equals(other.key)) && (value == null ? other.value == null : value.equals(other.value));\n// bug_end\n}\n"}
{"INPUT": "private <T>void addFilter(String reference,T value,List<FilterExpression> filters){\n  if (value == null) {\n    return;\n  }\n  if (value instanceof List) {\n// bug_start\n    List<?> list=(List)value;\n// bug_end\n    if (list.isEmpty()) {\n      return;\n    }\n    filters.add(FilterExpression.in(reference,list));\n    return;\n  }\n  filters.add(FilterExpression.equal(reference,value));\n}\n"}
{"INPUT": "@Override @TruffleBoundary public Object readBigInteger(long bitOffset,int bitSize,boolean signed){\n  if (!canRead(bitOffset,bitSize)) {\n    return unavailable(bitOffset,bitSize);\n  }\n  final int byteOffset=(int)(bitOffset / Byte.SIZE);\n  if (isByteAligned(bitOffset)) {\nswitch (bitSize) {\ncase LLVMDebugTypeConstants.BYTE_SIZE:\n{\n        final Object value=loadValue(PrimitiveType.I8,byteOffset);\n        if (value instanceof Byte) {\n// bug_start\n          return BigInteger.valueOf(signed ? (short)value : Byte.toUnsignedInt((byte)value));\n// bug_end\n        }\n else {\n          return unavailable(bitOffset,LLVMDebugTypeConstants.BYTE_SIZE);\n        }\n      }\ncase LLVMDebugTypeConstants.SHORT_SIZE:\n{\n      final Object value=loadValue(PrimitiveType.I16,byteOffset);\n      if (value instanceof Short) {\n        return BigInteger.valueOf(signed ? (short)value : Short.toUnsignedInt((short)value));\n      }\n else {\n        return unavailable(bitOffset,LLVMDebugTypeConstants.SHORT_SIZE);\n      }\n    }\ncase LLVMDebugTypeConstants.INTEGER_SIZE:\n{\n    final Object value=loadValue(PrimitiveType.I32,byteOffset);\n    if (value instanceof Integer) {\n      return BigInteger.valueOf(signed ? (int)value : Integer.toUnsignedLong((int)value));\n    }\n else {\n      return unavailable(bitOffset,LLVMDebugTypeConstants.INTEGER_SIZE);\n    }\n  }\ncase LLVMDebugTypeConstants.LONG_SIZE:\n{\n  final Object value=loadValue(PrimitiveType.I64,byteOffset);\n  final long longValue;\n  if (value instanceof Long) {\n    longValue=(long)value;\n  }\n else   if (LLVMNativePointer.isInstance(value)) {\n    longValue=LLVMNativePointer.cast(value).asNative();\n  }\n else   if (LLVMManagedPointer.isInstance(value)) {\n    return \"<managed pointer>\";\n  }\n else {\n    return unavailable(bitOffset,LLVMDebugTypeConstants.LONG_SIZE);\n  }\n  return signed ? BigInteger.valueOf(longValue) : new BigInteger(Long.toUnsignedString(longValue));\n}\n}\n}\nfinal int alignedBitSize=bitSize + ((int)bitOffset % Byte.SIZE);\nfinal int alignedByteSize=((alignedBitSize - 1) / Byte.SIZE) + 1;\nfinal byte[] bytes=new byte[alignedByteSize];\nfor (int i=0; i < alignedByteSize; i++) {\nfinal Object value=loadValue(PrimitiveType.I8,byteOffset + i);\nif (value instanceof Byte) {\nbytes[alignedByteSize - 1 - i]=(byte)value;\n}\n else {\nreturn unavailable(bitOffset,bitSize);\n}\n}\nif (isAllZeros(bytes)) {\nreturn BigInteger.ZERO;\n}\nfinal BigInteger totalMemory=new BigInteger(1,bytes);\nfinal BigInteger shiftedMemory=totalMemory.shiftRight((int)(bitOffset % Byte.SIZE));\nBigInteger maskedMemory=shiftedMemory;\nfor (int i=bitSize; i < shiftedMemory.bitLength(); i++) {\nmaskedMemory=maskedMemory.clearBit(i);\n}\nif (BigInteger.ZERO.equals(maskedMemory) || isAllZeros(maskedMemory.toByteArray())) {\nreturn BigInteger.ZERO;\n}\n else if (!signed || !maskedMemory.testBit(bitSize - 1)) {\nreturn maskedMemory;\n}\n else {\nBigInteger value=maskedMemory;\nfor (int i=0; i < bitSize; i++) {\nvalue=value.flipBit(i);\n}\nvalue=value.add(BigInteger.ONE);\nvalue=value.negate();\nreturn value;\n}\n}\n"}
{"INPUT": "@SuppressWarnings(\"rawtypes\") public void attach(final Object iPojo){\n  checkOpeness();\n  final ODocument record=objects2Records.get(System.identityHashCode(iPojo));\n  if (record != null)   return;\n  if (OObjectSerializerHelper.hasObjectID(iPojo)) {\n    for (    Field field : iPojo.getClass().getDeclaredFields()) {\n      Object value=OObjectSerializerHelper.getFieldValue(iPojo,field.getName());\n      if (value instanceof OLazyObjectMap<?>) {\n        ((OLazyObjectMap)value).assignDatabase(this);\n      }\n else       if (value instanceof OLazyObjectList<?>) {\n        ((OLazyObjectList)value).assignDatabase(this);\n      }\n else       if (value instanceof OLazyObjectSet<?>) {\n// bug_start\n        ((OLazyObjectList)value).assignDatabase(this);\n// bug_end\n      }\n    }\n  }\n else {\n    throw new OObjectNotDetachedException(\"Cannot attach a non detached object\");\n  }\n}\n"}
{"INPUT": "public DataTable getAggregationResultDataTable() throws Exception {\n  DataSchema schema=AggregationFunctionUtils.getAggregationResultsDataSchema(_aggregationFunctionList);\n  DataTableBuilder builder=new DataTableBuilder(schema);\n  builder.open();\n  builder.startRow();\n  for (int i=0; i < _aggregationResultList.size(); ++i) {\nswitch (_aggregationFunctionList.get(i).aggregateResultDataType()) {\ncase LONG:\n// bug_start\n      builder.setColumn(i,((Long)_aggregationResultList.get(i)).longValue());\n// bug_end\n    break;\ncase DOUBLE:\n  builder.setColumn(i,((Double)_aggregationResultList.get(i)).doubleValue());\nbreak;\ncase OBJECT:\nbuilder.setColumn(i,_aggregationResultList.get(i));\nbreak;\ndefault :\nthrow new UnsupportedOperationException(\"Shouldn't reach here in getAggregationResultsList()\");\n}\n}\nbuilder.finishRow();\nbuilder.seal();\nreturn attachMetadataToDataTable(builder.build());\n}\n"}
{"INPUT": "public String formatBytes(long value){\n// bug_start\n  return SimpleXYChartUtils.formatBytes((int)(value * chartFactor));\n// bug_end\n}\n"}
{"INPUT": "@Test public void shouldOmitTargetsInTheSameBuildFileInVisibilityArguments() throws Exception {\n  Resolver resolver=new Resolver(buckRepoRoot,thirdPartyRelative,localRepo,httpd.getUri(\"/\").toString());\n  resolver.resolve(\"com.example:deps-in-same-project:jar:1.0\");\n  Path exampleDir=thirdPartyRelative.resolve(\"example\");\n  List<Map<String,Object>> allTargets=buildFileParser.getAll(buckRepoRoot.resolve(exampleDir).resolve(\"BUCK\"));\n  assertEquals(2,allTargets.size());\n  Map<String,Object> noDeps=null;\n  for (  Map<String,Object> target : allTargets) {\n    if (\"no-deps\".equals(target.get(\"name\"))) {\n      noDeps=target;\n      break;\n    }\n  }\n  assertNotNull(noDeps);\n// bug_start\n  assertEquals(0,((Collection)noDeps.get(\"visibility\")).size());\n// bug_end\n}\n"}
{"INPUT": "@Test public void testNullSplitForParquetReader() throws Exception {\n  Configuration conf=new Configuration();\n  conf.set(IOConstants.COLUMNS,\"int32_field\");\n  conf.set(IOConstants.COLUMNS_TYPES,\"int\");\n  HiveConf.setBoolVar(conf,HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED,true);\n  HiveConf.setVar(conf,HiveConf.ConfVars.PLAN,\"//tmp\");\n  initialVectorizedRowBatchCtx(conf);\n// bug_start\n  VectorizedParquetRecordReader reader=new VectorizedParquetRecordReader((org.apache.hadoop.mapred.InputSplit)null,new JobConf(conf));\n// bug_end\n  assertFalse(reader.next(reader.createKey(),reader.createValue()));\n}\n"}
{"INPUT": "// bug_start\npublic synchronized boolean remove(String hash){\n  try {\n    return (urlHashCache.remove(hash.getBytes()) != null);\n  }\n catch (  IOException e) {\n    return false;\n  }\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@ReactProp(name=\"gestureEnabled\",defaultBoolean=true) public void setGestureEnabled(ScreenStackHeaderConfig config,boolean gestureEnabled){\n  config.setGestureEnabled(gestureEnabled);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test(expected=TableException.class) public void testAsWithToFewFields() throws Exception {\n  ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();\n  BatchTableEnvironment tableEnv=TableEnvironment.getTableEnvironment(env,config());\n  tableEnv.fromDataSet(CollectionDataSets.get3TupleDataSet(env),\"a, b\");\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic void testErrorMessage() throws Throwable {\n  Message baseMessage=myTransport.createBaseMessage(mySelf,null);\n  baseMessage.setType(Message.Type.ERROR);\n  baseMessage.setError(new XMPPError(44,\"some error message\"));\n  myIdeFacade.getAndClearLog();\n  myTransport.getFacade().getConnection().sendPacket(baseMessage);\n  Thread.sleep(200);\n  String log=myIdeFacade.getAndClearLog();\n  assertTrue(\"Should show Message: \" + log,log.indexOf(\"showMessage\") == 0);\n  assertTrue(\"Should show error text: \" + log,log.indexOf(\"some error message\") > 0);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test public void processContextConfigurationWithoutLocationsAndConfigurationClassesForBogusTestClass(){\n  expectedException.expect(IllegalStateException.class);\n  expectedException.expectMessage(startsWith(\"Neither\"));\n  expectedException.expectMessage(containsString(\"was able to detect defaults\"));\n  ContextConfigurationAttributes configAttributes=new ContextConfigurationAttributes(getClass(),EMPTY_STRING_ARRAY,EMPTY_CLASS_ARRAY,true,null,true,ContextLoader.class);\n  loader.processContextConfiguration(configAttributes);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic static Expression xpathExpression(final String expression){\n  return new ExpressionAdapter(){\n    public Object evaluate(    Exchange exchange){\n      Language language=exchange.getContext().resolveLanguage(\"xpath\");\n      return language.createExpression(expression).evaluate(exchange,Object.class);\n    }\n    @Override public String toString(){\n      return \"xpath(\" + expression + \")\";\n    }\n  }\n;\n}\n// bug_end\n"}
{"INPUT": "// bug_start\nprivate LogicalExpression parseExpr(String expr) throws RecognitionException {\n  final ExprLexer lexer=new ExprLexer(new ANTLRStringStream(expr));\n  final CommonTokenStream tokens=new CommonTokenStream(lexer);\n  final ExprParser parser=new ExprParser(tokens);\n  parse_return ret=parser.parse();\n  return ret.e;\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic static Scorer illegalScorer(final String message){\n  return new Scorer(null){\n    @Override public float score() throws IOException {\n      throw new IllegalStateException(message);\n    }\n    @Override public int docID(){\n      throw new IllegalStateException(message);\n    }\n    @Override public DocIdSetIterator iterator(){\n      throw new IllegalStateException(message);\n    }\n    @Override public float getMaxScore(    int upTo) throws IOException {\n      throw new IllegalStateException(message);\n    }\n  }\n;\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test public void testUseInMultithreadedWorker() throws Exception {\nclass MyVerticle extends AbstractVerticle {\n    @Override public void start(){\n      assertIllegalStateException(null);\n      testComplete();\n    }\n  }\n  MyVerticle verticle=new MyVerticle();\n  vertx.deployVerticle(verticle,new DeploymentOptions().setWorker(true).setMultiThreaded(true));\n  await();\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test public void voidDecodesToNull() throws Exception {\n  Response response=Response.create(200,\"OK\",Collections.<String,Collection<String>>emptyMap(),statusFailed);\n  assertEquals(decoder.decode(response,void.class),null);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Deprecated public static List<List<Double>> partitionVariable(List<Double> arr,int chunk){\n  int count=0;\n  List<List<Double>> ret=new ArrayList<>();\n  while (count < arr.size()) {\n    List<Double> sublist=arr.subList(count,count + chunk);\n    count+=chunk;\n    ret.add(sublist);\n  }\n  for (  List<Double> lists : ret) {\n    if (lists.size() < chunk)     ret.remove(lists);\n  }\n  return ret;\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic AvoidDmlStatementsInLoopsRule(){\n  setProperty(CODECLIMATE_CATEGORIES,\"Performance\");\n  setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER,150);\n  setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING,false);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@SPITest @SuppressWarnings(\"unchecked\") public void exceptionWhenValueHolderIsNotAnInstanceFromTheCachingTier() throws LegalSPITesterException {\n  K key=factory.createKey(1);\n  final V value=factory.createValue(1);\n  tier=factory.newStore(factory.newConfiguration(factory.getKeyType(),factory.getValueType(),1L,null,null,Expirations.noExpiration()));\n  Store.ValueHolder<V> valueHolder=null;\n  try {\n    tier.put(key,value);\n    valueHolder=tier.get(key);\n  }\n catch (  CacheAccessException e) {\n    throw new LegalSPITesterException(\"Warning, an exception is thrown due to the SPI test\");\n  }\n  try {\n    tier.flush(key,valueHolder);\n    throw new AssertionError();\n  }\n catch (  IllegalArgumentException e) {\n  }\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Override public ProcedureStatsCollector registerProcedureStatsSource(long catalogId,ProcedureStatsCollector source){\n  m_source=source;\n  m_selector=StatsSelector.PROCEDURE;\n  m_catalogId=catalogId;\n  return source;\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic RecoveryFailedException(ShardId shardId,DiscoveryNode sourceNode,DiscoveryNode targetNode,Throwable cause){\n  this(shardId,sourceNode,targetNode,null,cause);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic DiscoveryNode(String nodeName,String nodeId,DiscoveryNode node){\n  this(nodeName,nodeId,node.hostName,node.hostAddress,node.address,node.attributes,node.roles,node.version);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test public void testDoNotCompileSourceFilesInHeaders() throws Exception {\n  AnalysisMock.get().ccSupport().setupCrosstool(mockToolsConfig,MockCcSupport.HEADER_PROCESSING_FEATURE_CONFIGURATION);\n  useConfiguration(\"--features=parse_headers\");\n  ConfiguredTarget x=scratchConfiguredTarget(\"x\",\"x\",\"cc_library(name = 'x', hdrs = ['x.cc'])\");\n  assertThat(getGeneratingAction(getBinArtifact(\"_objs/x/x/x.pic.o\",x))).isNull();\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test public void testGzipCompression() throws Exception {\n  meta.content.fileCompression=\"GZip\";\n  initByFile(\"default.csv.gz\");\n  setFields(new BaseFileField(\"f1\",-1,-1),new BaseFileField(\"f2\",-1,-1),new BaseFileField(\"f2\",-1,-1));\n  process();\n  check(new Object[][]{{\"first\",\"1\",\"1.1\"},{\"second\",\"2\",\"2.2\"},{\"third\",\"3\",\"3.3\"}});\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test public void shouldSerializeServerInfoToJSON() throws Exception {\n  String pluginId=\"plugin_id\";\n  ElasticAgentExtension extension=new ElasticAgentExtension(pluginManager);\n  when(pluginManager.resolveExtensionVersion(pluginId,extension.goSupportedVersions())).thenReturn(\"1.0\");\n  String serverInfoJSON=extension.serverInfoJSON(pluginId,\"x12adf\",\"http://my.build.com\",\"https://my.build.com\");\n  assertThat(serverInfoJSON,Is.is(\"{\\\"server_id\\\":\\\"x12adf\\\",\\\"site_url\\\":\\\"http://my.build.com\\\",\\\"secure_site_url\\\":\\\"https://my.build.com\\\"}\"));\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic void paintChild(Context c,Box box,Layout layout){\n  int y1=c.getExtents().y;\n  super.paintChild(c,box,layout);\n  int y2=c.getExtents().y;\n  int y=(y1 + y2) / 2;\n  c.getGraphics().fillOval(c.getExtents().x + c.getCursor().x - 10,y - 2,8,8);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic static ParameterizedType newParameterizedTypeWithOwner(Type ownerType,Type rawType,Type... typeArguments){\n  if (ownerType == null) {\n    throw new NullPointerException(\"ownerType\");\n  }\n  return new ParameterizedTypeImpl(ownerType,rawType,typeArguments);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Override protected long getIdleTimeout(){\n  long blockingTimeout=_channel.getHttpConfiguration().getBlockingTimeout();\n  if (blockingTimeout == 0)   return _channel.getIdleTimeout();\n  return blockingTimeout;\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Override public int compareTo(Block leftBlock,int leftPosition,Block rightBlock,int rightPosition){\n  long leftValue=leftBlock.getLong(leftPosition,0);\n  long rightValue=rightBlock.getLong(rightPosition,0);\n  return Long.compare(leftValue,rightValue);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Override public boolean isUidActive(int uid){\nsynchronized (ActivityManagerService.this) {\n    final UidRecord uidRec=mActiveUids.get(uid);\n    return (uidRec != null) && !uidRec.idle;\n  }\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Test public void shouldGetArity(){\n  final Function8<Object,Object,Object,Object,Object,Object,Object,Object,Object> f=null;\n  assertThat(f.arity()).isEqualTo(8);\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic void recycleContainers(){\n  for (  Container c : highlowcontainer.values()) {\n    if (c instanceof ArrayContainer) {\n      ContainerFactory.putBackInStore((ArrayContainer)c);\n    }\n else     if (c instanceof BitmapContainer) {\n      ContainerFactory.putBackInStore((BitmapContainer)c);\n    }\n  }\n}\n// bug_end\n"}
{"INPUT": "// bug_start\npublic String toBriefString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(((ToBriefString)baseBox.getValue()).toBriefString() + \".\" + method.getName()+ \"(\");\n  for (int i=0; i < argBoxes.length; i++) {\n    if (i != 0)     buffer.append(\", \");\n    buffer.append(((ToBriefString)argBoxes[i].getValue()).toBriefString());\n  }\n  buffer.append(\")\");\n  return buffer.toString();\n}\n// bug_end\n"}
{"INPUT": "// bug_start\n@Override @Deprecated protected WebApplicationContext createWebApplicationContext(ServletContext servletContext,ApplicationContext parent) throws BeansException {\n  MergeXmlWebApplicationContext wac=new MergeXmlWebApplicationContext();\n  wac.setParent(parent);\n  wac.setServletContext(servletContext);\n  wac.setConfigLocation(servletContext.getInitParameter(ContextLoader.CONFIG_LOCATION_PARAM));\n  wac.setPatchLocation(servletContext.getInitParameter(PATCH_LOCATION_PARAM));\n  wac.setShutdownBean(servletContext.getInitParameter(SHUTDOWN_HOOK_BEAN));\n  wac.setShutdownMethod(servletContext.getInitParameter(SHUTDOWN_HOOK_METHOD));\n  customizeContext(servletContext,wac);\n  wac.refresh();\n  return wac;\n}\n// bug_end\n"}
{"INPUT": "@Override protected WritableMap doInBackground(Void... voids){\n  WritableMap response=Arguments.createMap();\n  ByteArrayInputStream inputStream=null;\n  if (mOptions.hasKey(\"skipProcessing\")) {\n    try {\n      File imageFile=new File(RNFileUtils.getOutputFilePath(mCacheDirectory,\".jpg\"));\n      imageFile.createNewFile();\n      FileOutputStream fOut=new FileOutputStream(imageFile);\n      fOut.write(mImageData);\n      String fileUri=Uri.fromFile(imageFile).toString();\n      response.putString(\"uri\",fileUri);\n    }\n catch (    Resources.NotFoundException e) {\n      mPromise.reject(ERROR_TAG,\"Documents directory of the app could not be found.\",e);\n      e.printStackTrace();\n    }\ncatch (    IOException e) {\n      mPromise.reject(ERROR_TAG,\"An unknown I/O exception has occurred.\",e);\n      e.printStackTrace();\n    }\n    return response;\n  }\n  if (mBitmap == null) {\n    mBitmap=BitmapFactory.decodeByteArray(mImageData,0,mImageData.length);\n    inputStream=new ByteArrayInputStream(mImageData);\n  }\n  try {\n    if (inputStream != null) {\n      ExifInterface exifInterface=new ExifInterface(inputStream);\n      int orientation=exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION,ExifInterface.ORIENTATION_UNDEFINED);\n      if (mOptions.hasKey(\"fixOrientation\") && mOptions.getBoolean(\"fixOrientation\") && orientation != ExifInterface.ORIENTATION_UNDEFINED) {\n        mBitmap=rotateBitmap(mBitmap,getImageRotation(orientation));\n      }\n      if (mOptions.hasKey(\"width\")) {\n        mBitmap=resizeBitmap(mBitmap,mOptions.getInt(\"width\"));\n      }\n      if (mOptions.hasKey(\"mirrorImage\") && mOptions.getBoolean(\"mirrorImage\")) {\n        mBitmap=flipHorizontally(mBitmap);\n      }\n      if (mOptions.hasKey(\"exif\") && mOptions.getBoolean(\"exif\")) {\n        WritableMap exifData=RNCameraViewHelper.getExifData(exifInterface);\n        response.putMap(\"exif\",exifData);\n      }\n    }\n    response.putInt(\"width\",mBitmap.getWidth());\n    response.putInt(\"height\",mBitmap.getHeight());\n    ByteArrayOutputStream imageStream=new ByteArrayOutputStream();\n    mBitmap.compress(Bitmap.CompressFormat.JPEG,getQuality(),imageStream);\n// bug_start\n    String filePath=writeStreamToFile(imageStream);\n    File imageFile=new File(filePath);\n    String fileUri=Uri.fromFile(imageFile).toString();\n    response.putString(\"uri\",fileUri);\n// bug_end\n    if (mOptions.hasKey(\"base64\") && mOptions.getBoolean(\"base64\")) {\n      response.putString(\"base64\",Base64.encodeToString(imageStream.toByteArray(),Base64.DEFAULT));\n    }\n    imageStream.close();\n    if (inputStream != null) {\n      inputStream.close();\n      inputStream=null;\n    }\n    return response;\n  }\n catch (  Resources.NotFoundException e) {\n    mPromise.reject(ERROR_TAG,\"Documents directory of the app could not be found.\",e);\n    e.printStackTrace();\n  }\ncatch (  IOException e) {\n    mPromise.reject(ERROR_TAG,\"An unknown I/O exception has occurred.\",e);\n    e.printStackTrace();\n  }\n finally {\n    try {\n      if (inputStream != null) {\n        inputStream.close();\n      }\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "@Override public void destroy(ObjectNamespace namespace,int partitionId){\n  final RingbufferService service;\n  try {\n    service=getRingbufferService();\n  }\n catch (  Exception e) {\n// bug_start\n    logger.fine(\"Could not retrieve ringbuffer service to destroy event journal \" + namespace,e);\n// bug_end\n    return;\n  }\n  service.destroyContainer(partitionId,namespace);\n}\n"}
{"INPUT": "@Override protected void doExecute(JobExecution execution) throws JobInterruptedException, JobRestartException, StartLimitExceededException {\n  StepExecution stepExecution=null;\n  for (  Step step : steps) {\n    stepExecution=handleStep(step,execution);\n    if (stepExecution.getStatus() != BatchStatus.COMPLETED) {\n      break;\n    }\n  }\n  if (stepExecution != null) {\n// bug_start\n    logger.debug(\"Upgrading JobExecution status: \" + stepExecution);\n// bug_end\n    execution.upgradeStatus(stepExecution.getStatus());\n    execution.setExitStatus(stepExecution.getExitStatus());\n  }\n}\n"}
{"INPUT": "private static Expression computeBase(final String baseStr){\n// bug_start\n  final Token token=Token.parse(baseStr);\n  if (token != null) {\n    return TextLiteralExpression.parseTextLiteral(token.getValue());\n// bug_end\n  }\n  return Expression.parse(baseStr);\n}\n"}
{"INPUT": "private Dialog getSimUnlockProgressDialog(){\n  if (mSimUnlockProgressDialog == null) {\n    mSimUnlockProgressDialog=new ProgressDialog(mContext);\n    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));\n    mSimUnlockProgressDialog.setIndeterminate(true);\n    mSimUnlockProgressDialog.setCancelable(false);\n    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);\n// bug_start\n    mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);\n// bug_end\n  }\n  return mSimUnlockProgressDialog;\n}\n"}
{"INPUT": "public boolean isConstantResponse(){\n  double m=Double.NaN;\n  for (int b=0; b < _bins.length; b++) {\n    if (_bins[b] == 0)     continue;\n    if (var(b) > 1e-14)     return false;\n    double mean=mean(b);\n    if (mean != m)     if (Double.isNaN(m))     m=mean;\n// bug_start\n else     return false;\n// bug_end\n  }\n  return true;\n}\n"}
{"INPUT": "@Override public void contextDestroyed(ServletContextEvent event){\n  if (!instanceEnabled) {\n    return;\n  }\n  SESSION_MAP_BY_ID.clear();\n  SESSION_COUNT.set(0);\n  JdbcWrapper.SINGLETON.stop();\n// bug_start\n  Parameters.initialize((ServletContext)null);\n// bug_end\n  LOG.debug(\"JavaMelody listener destroy done\");\n}\n"}
{"INPUT": "private void initAdminUser() throws Exception {\n  String caller=Thread.currentThread().getName();\n  E.checkState(caller.equals(\"main\"),\"Invalid caller '%s'\",caller);\n  UserManager userManager=this.graph().hugegraph().userManager();\n// bug_start\n  HugeUser admin=new HugeUser(HugeAuthenticator.USER_ADMIN);\n  admin.password(StringEncoding.hashPassword(inputPassword()));\n  admin.creator(HugeAuthenticator.USER_SYSTEM);\n  userManager.createUser(admin);\n// bug_end\n  this.graph.close();\n}\n"}
{"INPUT": "public static <T>T detachAll(T o,ODatabaseObject db,boolean returnNonProxiedInstance,Map<Object,Object> alreadyDetached){\n  if (o instanceof Proxy) {\n    OObjectProxyMethodHandler handler=(OObjectProxyMethodHandler)((ProxyObject)o).getHandler();\n    try {\n      if (returnNonProxiedInstance) {\n        o=getNonProxiedInstance(o);\n      }\n// bug_start\n      ORID identity=handler.getDoc().getIdentity();\n      if (!alreadyDetached.containsKey(identity)) {\n        alreadyDetached.put(identity,o);\n      }\n else       if (returnNonProxiedInstance) {\n        return (T)alreadyDetached.get(identity);\n// bug_end\n      }\n      handler.detachAll(o,returnNonProxiedInstance,alreadyDetached);\n    }\n catch (    IllegalArgumentException e) {\n      throw new OSerializationException(\"Error detaching object of class \" + o.getClass(),e);\n    }\ncatch (    IllegalAccessException e) {\n      throw new OSerializationException(\"Error detaching object of class \" + o.getClass(),e);\n    }\ncatch (    NoSuchMethodException e) {\n      throw new OSerializationException(\"Error detaching object of class \" + o.getClass(),e);\n    }\ncatch (    InvocationTargetException e) {\n      throw new OSerializationException(\"Error detaching object of class \" + o.getClass(),e);\n    }\n    return o;\n  }\n else   if (!returnNonProxiedInstance)   return serializeObject(o,db);\n  return o;\n}\n"}
{"INPUT": "public UIWindow openWindow(UIWindow window){\n  if (window == null) {\n    logger.warn(\"Can't open window: null\");\n  }\n else {\n    if (!renderer.getDisplayElements().contains(window)) {\n      addWindow(window);\n    }\n    logger.debug(\"Open and focus window by reference with ID \\\"{}\\\"\",window.getId());\n// bug_start\n    renderer.setWindowFocus(window);\n// bug_end\n  }\n  return window;\n}\n"}
{"INPUT": "@Override public void onOpen(WebSocket webSocket,Response response){\n  try {\n    if (in instanceof PipedInputStream && input != null) {\n      input.connect((PipedInputStream)in);\n    }\n    if (out instanceof PipedOutputStream && output != null) {\n      output.connect((PipedOutputStream)out);\n    }\n    if (err instanceof PipedOutputStream && error != null) {\n      error.connect((PipedOutputStream)err);\n    }\n    if (errChannel instanceof PipedOutputStream && errorChannel != null) {\n      errorChannel.connect((PipedOutputStream)errChannel);\n    }\n    webSocketRef.set(webSocket);\n// bug_start\n    executorService.submit(pumper);\n    started.set(true);\n    queue.add(true);\n// bug_end\n  }\n catch (  IOException e) {\n    queue.add(new KubernetesClientException(OperationSupport.createStatus(response)));\n  }\n finally {\n    if (listener != null) {\n      listener.onOpen(response);\n    }\n  }\n}\n"}
{"INPUT": "protected boolean validateClassNameParams(HttpServletRequest request){\n  String ceilingEntityClassname=request.getParameter(\"ceilingEntityClassname\");\n  String ceilingEntity=request.getParameter(\"ceilingEntity\");\n  String ceilingEntityFullyQualifiedClassname=request.getParameter(\"fields['ceilingEntityFullyQualifiedClassname'].value\");\n  String originalType=request.getParameter(\"fields['__originalType'].value\");\n  String entityType=request.getParameter(\"entityType\");\n  Map<String,String> params=new HashMap<>(2);\n  params.put(\"ceilingEntityClassname\",ceilingEntityClassname);\n// bug_start\n  params.put(\"entityType\",entityType);\n// bug_end\n  params.put(\"ceilingEntity\",ceilingEntity);\n  params.put(\"ceilingEntityFullyQualifiedClassname\",ceilingEntityFullyQualifiedClassname);\n  params.put(\"__originalType\",originalType);\n  return validationService.validateClassNameParams(params,\"blPU\");\n}\n"}
{"INPUT": "private void update(int what,CharSequence string){\n  if (inWidgetMode()) {\n    if (DEBUG)     Log.v(TAG,\"inWidgetMode() is true\");\nswitch (what) {\ncase INSTRUCTION_TEXT:\ncase CARRIER_HELP_TEXT:\ncase HELP_MESSAGE_TEXT:\n      mTransientTextManager.post(string,0,INSTRUCTION_RESET_DELAY);\n    break;\ncase OWNER_INFO:\ncase CARRIER_TEXT:\ndefault :\n// bug_start\n  Log.w(TAG,\"Not showing message id \" + what + \", str=\"+ string);\n// bug_end\n}\n}\n else {\nupdateStatusLines(mShowingStatus);\n}\n}\n"}
{"INPUT": "public void setItems(Array newItems){\n  if (newItems == null)   throw new IllegalArgumentException(\"newItems cannot be null.\");\n  float oldPrefWidth=getPrefWidth(), oldPrefHeight=getPrefHeight();\n// bug_start\n  items.clear();\n  items.addAll(newItems);\n// bug_end\n  selection.validate();\n  invalidate();\n  if (oldPrefWidth != getPrefWidth() || oldPrefHeight != getPrefHeight())   invalidateHierarchy();\n}\n"}
{"INPUT": "public void build(){\n  AbstractType<?> keyValidator=cfs.metadata.getKeyValidator();\n  for (  Map.Entry<SSTableReader,Map<ColumnDefinition,ColumnIndex>> e : sstables.entrySet()) {\n    SSTableReader sstable=e.getKey();\n    Map<ColumnDefinition,ColumnIndex> indexes=e.getValue();\n    try (RandomAccessReader dataFile=sstable.openDataReader()){\n      PerSSTableIndexWriter indexWriter=SASIIndex.newWriter(keyValidator,sstable.descriptor,indexes,OperationType.COMPACTION);\n      long previousKeyPosition=0;\n      try (KeyIterator keys=new KeyIterator(sstable.descriptor,cfs.metadata)){\n        while (keys.hasNext()) {\n          if (isStopRequested())           throw new CompactionInterruptedException(getCompactionInfo());\n          final DecoratedKey key=keys.next();\n          final long keyPosition=keys.getKeyPosition();\n          indexWriter.startPartition(key,keyPosition);\n          try {\n            RowIndexEntry indexEntry=sstable.getPosition(key,SSTableReader.Operator.EQ);\n            dataFile.seek(indexEntry.position);\n            ByteBufferUtil.readWithShortLength(dataFile);\n            try (SSTableIdentityIterator partition=SSTableIdentityIterator.create(sstable,dataFile,key)){\n// bug_start\n              indexWriter.nextUnfilteredCluster(partition.staticRow());\n// bug_end\n              while (partition.hasNext())               indexWriter.nextUnfilteredCluster(partition.next());\n            }\n           }\n catch (          IOException ex) {\n            throw new FSReadError(ex,sstable.getFilename());\n          }\n          bytesProcessed+=keyPosition - previousKeyPosition;\n          previousKeyPosition=keyPosition;\n        }\n        completeSSTable(indexWriter,sstable,indexes.values());\n      }\n     }\n   }\n}\n"}
{"INPUT": "private boolean isAllMyMsg(){\n  SparseBooleanArray size=listView.getCheckedItemPositions();\n  for (int i=0; i < size.size(); i++) {\n    int position=size.keyAt(i);\n// bug_start\n    MessageBean msg=(MessageBean)adapter.getItem(position - 1);\n    if (!msg.getUser().getId().equals(currentUserId))     return false;\n// bug_end\n  }\n  return true;\n}\n"}
{"INPUT": "@Test public void correctEs5Es6FileImportedThroughFrontend(){\n  openTestURL();\n  $(ButtonElement.class).first().click();\n  String es;\n  if (BrowserUtil.isIE(getDesiredCapabilities()) || BrowserUtil.isPhantomJS(getDesiredCapabilities()) || BrowserUtil.isFirefox(getDesiredCapabilities())) {\n    es=\"es5\";\n  }\n else {\n    es=\"es6\";\n  }\n// bug_start\n  testBench().disableWaitForVaadin();\n// bug_end\n  Assert.assertEquals(\"/VAADIN/frontend/\" + es + \"/logFilename.js\",findElement(By.tagName(\"body\")).getText());\n}\n"}
{"INPUT": "@Override public void handle(Tag<?> tag){\n// bug_start\n  TagInternals tagi=tagi(tag);\n  TagData<?> tagData=tagi.tagData();\n  tagi.setHnd(getNewId(tagData));\n// bug_end\n}\n"}
{"INPUT": "@Override public long delay(){\n  if (getGroupSize() >= 0) {\n    int arrival=0;\n    try {\n      if (timeoutInMs == 0) {\n        arrival=this.barrier.await();\n      }\n else       if (timeoutInMs > 0) {\n        arrival=this.barrier.await(timeoutInMs,TimeUnit.MILLISECONDS);\n      }\n else {\n        throw new IllegalArgumentException(\"Negative value for timeout:\" + timeoutInMs + \" in Synchronizing Timer \"+ getName());\n      }\n    }\n catch (    InterruptedException|BrokenBarrierException e) {\n      return 0;\n    }\ncatch (    TimeoutException e) {\n// bug_start\n      log.warn(\"SyncTimer {} timeouted waiting for users after: {}ms\",getName(),getTimeoutInMs());\n// bug_end\n      return 0;\n    }\n finally {\n      if (arrival == 0) {\n        barrier.reset();\n      }\n    }\n  }\n  return 0;\n}\n"}
{"INPUT": "@Override @After public void tearDown() throws Exception {\n  if (sysProp == null) {\n    System.getProperties().remove(\"java.naming.factory.initial\");\n  }\n else {\n    System.setProperty(\"java.naming.factory.initial\",sysProp);\n  }\n  super.tearDown();\n// bug_start\n  reset(driver,dataSource,connection);\n// bug_end\n}\n"}
{"INPUT": "@Override protected boolean isActionAllowed(RepositoryModel repository,String action){\n// bug_start\n  if (action.equals(gitReceivePack)) {\n    if (!repository.isBare) {\n      logger.warn(\"Gitblit does not allow pushes to repositories with a working copy\");\n      return false;\n// bug_end\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "@Test public void qualifiersTest() throws BrutException {\n// bug_start\n  compareValuesFiles(\"values-mcc004-mnc4-en-rUS-ldrtl-sw100dp-w200dp-h300dp\" + \"-xlarge-long-land-desk-night-xhdpi-finger-keyssoft-12key\" + \"-navhidden-dpad/strings.xml\");\n// bug_end\n}\n"}
{"INPUT": "@Override protected void encode(ChannelHandlerContext ctx,Object msg,List<Object> out) throws Exception {\n  NettyHttpResponse res=ctx.channel().attr(NettyHttpResponse.KEY).get();\n  DefaultFullHttpResponse httpResponse=res != null ? res.getNativeResponse() : new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);\n  byte[] bytes=objectMapper.writeValueAsBytes(msg);\n  ByteBuf content=Unpooled.copiedBuffer(bytes);\n  int len=bytes.length;\n// bug_start\n  httpResponse.headers().add(HttpHeaderNames.CONTENT_LENGTH,len);\n// bug_end\n  out.add(httpResponse.replace(content));\n}\n"}
{"INPUT": "@Override public GeoServerTileLayerInfoModel createOwnModel(final IModel<? extends PublishedInfo> layerModel,final boolean isNew){\n  PublishedInfo layerInfo=layerModel.getObject();\n  GeoServerTileLayerInfo tileLayerInfo;\n  final GWC mediator=GWC.get();\n  final GWCConfig defaultSettings=mediator.getConfig();\n  final GeoServerTileLayer tileLayer=isNew ? null : mediator.getTileLayer(layerInfo);\n  if (isNew || tileLayer == null) {\n    final GWCConfig saneDefaults=defaultSettings.saneConfig();\n    tileLayerInfo=TileLayerInfoUtil.loadOrCreate(layerInfo,saneDefaults);\n  }\n else {\n    GeoServerTileLayerInfo info=((GeoServerTileLayer)tileLayer).getInfo();\n    tileLayerInfo=info.clone();\n  }\n// bug_start\n  tileLayerInfo.setEnabled(true);\n// bug_end\n  final boolean initWithTileLayer=(isNew && defaultSettings.isCacheLayersByDefault()) || tileLayer != null;\n  if (!initWithTileLayer) {\n    tileLayerInfo.setId(null);\n  }\n  return new GeoServerTileLayerInfoModel(tileLayerInfo,isNew);\n}\n"}
{"INPUT": "@Override public byte[] doInTransform(Instrumentor instrumentor,ClassLoader loader,String className,Class<?> classBeingRedefined,ProtectionDomain protectionDomain,byte[] classfileBuffer) throws InstrumentException {\n  if (className.equals(CLASS_PREPARED_STATEMENT)) {\n    if (instrumentor.exist(loader,CLASS_PREPARED_STATEMENT_WRAPPER)) {\n      return null;\n    }\n  }\n  InstrumentClass target=instrumentor.getInstrumentClass(loader,className,classfileBuffer);\n  target.addField(\"com.navercorp.pinpoint.bootstrap.plugin.jdbc.DatabaseInfoAccessor\");\n  target.addField(\"com.navercorp.pinpoint.bootstrap.plugin.jdbc.ParsingResultAccessor\");\n  target.addField(\"com.navercorp.pinpoint.bootstrap.plugin.jdbc.BindValueAccessor\");\n  int maxBindValueSize=config.getMaxSqlBindValueSize();\n  target.addScopedInterceptor(\"com.navercorp.pinpoint.bootstrap.plugin.jdbc.interceptor.PreparedStatementExecuteQueryInterceptor\",va(maxBindValueSize),OracleConstants.ORACLE_SCOPE);\n// bug_start\n  target.addScopedInterceptor(\"com.navercorp.pinpoint.bootstrap.plugin.jdbc.interceptor.PreparedStatementBindVariableInterceptor\",OracleConstants.ORACLE_SCOPE);\n// bug_end\n  return target.toBytecode();\n}\n"}
{"INPUT": "public static ArrayList<String> getListArray(final File listFile){\n  String line;\n  final ArrayList<String> list=new ArrayList<String>();\n  BufferedReader br=null;\n  try {\n    br=new BufferedReader(new InputStreamReader(new FileInputStream(listFile),StandardCharsets.UTF_8));\n    while ((line=br.readLine()) != null) {\n// bug_start\n      list.add(line);\n// bug_end\n    }\n    br.close();\n  }\n catch (  final IOException e) {\n  }\n finally {\n    if (br != null) {\n      try {\n        br.close();\n      }\n catch (      final Exception e) {\n      }\n    }\n  }\n  return list;\n}\n"}
{"INPUT": "@Override public boolean onInterceptTouchEvent(MotionEvent ev){\nswitch (ev.getAction()) {\ncase MotionEvent.ACTION_UP:\n    if (getScrollX() > mScaleTouchSlop) {\n// bug_start\n      return true;\n// bug_end\n    }\n  break;\n}\nreturn super.onInterceptTouchEvent(ev);\n}\n"}
{"INPUT": "@Override public void forward(final ServletRequest request,final ServletResponse response) throws ServletException, IOException {\n  final ServletRequestContext servletRequestContext=ServletRequestContext.requireCurrent();\n  final HttpServletRequestImpl requestImpl=servletRequestContext.getOriginalRequest();\n  final HttpServletResponseImpl responseImpl=servletRequestContext.getOriginalResponse();\n  if (!servletContext.getDeployment().getDeploymentInfo().isAllowNonStandardWrappers()) {\n    if (servletRequestContext.getOriginalRequest() != request) {\n      if (!(request instanceof ServletRequestWrapper)) {\n        throw UndertowServletMessages.MESSAGES.requestWasNotOriginalOrWrapper(request);\n      }\n    }\n    if (servletRequestContext.getOriginalResponse() != response) {\n      if (!(response instanceof ServletResponseWrapper)) {\n        throw UndertowServletMessages.MESSAGES.responseWasNotOriginalOrWrapper(response);\n      }\n    }\n  }\n  response.resetBuffer();\n  final ServletRequest oldRequest=servletRequestContext.getServletRequest();\n  final ServletResponse oldResponse=servletRequestContext.getServletResponse();\n  Map<String,Deque<String>> queryParameters=requestImpl.getQueryParameters();\n  if (!named) {\n    if (request.getAttribute(FORWARD_REQUEST_URI) == null) {\n      requestImpl.setAttribute(FORWARD_REQUEST_URI,requestImpl.getRequestURI());\n      requestImpl.setAttribute(FORWARD_CONTEXT_PATH,requestImpl.getContextPath());\n      requestImpl.setAttribute(FORWARD_SERVLET_PATH,requestImpl.getServletPath());\n      requestImpl.setAttribute(FORWARD_PATH_INFO,requestImpl.getPathInfo());\n      requestImpl.setAttribute(FORWARD_QUERY_STRING,requestImpl.getQueryString());\n    }\n    String newQueryString=\"\";\n    int qsPos=path.indexOf(\"?\");\n    String newServletPath=path;\n    if (qsPos != -1) {\n      newQueryString=newServletPath.substring(qsPos + 1);\n      newServletPath=newServletPath.substring(0,qsPos);\n    }\n    String newRequestUri=servletContext.getContextPath() + newServletPath;\n    Map<String,Deque<String>> newQueryParameters=createNewQueryParameters(queryParameters,newQueryString);\n    requestImpl.setQueryParameters(newQueryParameters);\n    requestImpl.getExchange().setRelativePath(newServletPath);\n    requestImpl.getExchange().setQueryString(newQueryString);\n    requestImpl.getExchange().setRequestPath(newRequestUri);\n    requestImpl.getExchange().setRequestURI(newRequestUri);\n    requestImpl.getExchange().getAttachment(ServletRequestContext.ATTACHMENT_KEY).setServletPathMatch(pathMatch);\n    requestImpl.setServletContext(servletContext);\n    responseImpl.setServletContext(servletContext);\n  }\n  try {\n    try {\n      servletRequestContext.setServletRequest(request);\n      servletRequestContext.setServletResponse(response);\n      if (named) {\n        servletContext.getDeployment().getServletDispatcher().dispatchToServlet(requestImpl.getExchange(),chain,DispatcherType.FORWARD);\n      }\n else {\n        servletContext.getDeployment().getServletDispatcher().dispatchToPath(requestImpl.getExchange(),pathMatch,DispatcherType.FORWARD);\n      }\n// bug_start\n      if (response instanceof HttpServletResponseImpl) {\n        responseImpl.closeStreamAndWriter();\n      }\n// bug_end\n else {\n// bug_start\n        try {\n          final PrintWriter writer=response.getWriter();\n          writer.flush();\n          writer.close();\n        }\n catch (        IllegalStateException e) {\n          final ServletOutputStream outputStream=response.getOutputStream();\n          outputStream.flush();\n          outputStream.close();\n// bug_end\n        }\n      }\n    }\n catch (    ServletException e) {\n      throw e;\n    }\ncatch (    IOException e) {\n      throw e;\n    }\ncatch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  finally {\n    servletRequestContext.setServletRequest(oldRequest);\n    servletRequestContext.setServletResponse(oldResponse);\n  }\n}\n"}
{"INPUT": "public AtomicFileWriter(@Nonnull Path destinationPath,@Nonnull Charset charset) throws IOException {\n  if (charset == null) {\n    throw new IllegalArgumentException(\"charset is null\");\n  }\n  this.destPath=destinationPath;\n  Path dir=this.destPath.getParent();\n  try {\n// bug_start\n    Files.createDirectories(dir);\n// bug_end\n    tmpPath=Files.createTempFile(dir,\"atomic\",\"tmp\");\n  }\n catch (  IOException e) {\n    throw new IOException(\"Failed to create a temporary file in \" + dir,e);\n  }\n  core=Files.newBufferedWriter(tmpPath,charset,StandardOpenOption.SYNC);\n}\n"}
{"INPUT": "public ExecutionCommand getExecutionCommand(){\n  if (executionCommand != null) {\n    return executionCommand;\n  }\n  if (null == jsonExecutionCommand) {\n    throw new RuntimeException(\"Invalid ExecutionCommandWrapper, both object and string representations are null\");\n  }\n  try {\n    executionCommand=gson.fromJson(jsonExecutionCommand,ExecutionCommand.class);\n    if (null == executionCommand.getConfigurations()) {\n      executionCommand.setConfigurations(new TreeMap<String,Map<String,String>>());\n    }\n    Map<String,Map<String,String>> configurations=executionCommand.getConfigurations();\n    Long clusterId=hostRoleCommandDAO.findByPK(executionCommand.getTaskId()).getStage().getClusterId();\n    Cluster cluster=clusters.getClusterById(clusterId);\n    boolean refreshConfigTagsBeforeExecution=executionCommand.getForceRefreshConfigTagsBeforeExecution();\n    if (refreshConfigTagsBeforeExecution) {\n      Map<String,DesiredConfig> desiredConfigs=cluster.getDesiredConfigs();\n      Map<String,Map<String,String>> configurationTags=configHelper.getEffectiveDesiredTags(cluster,executionCommand.getHostname(),desiredConfigs);\n      LOG.debug(\"While scheduling task {} on cluster {}, configurations are being refreshed using desired configurations of {}\",executionCommand.getTaskId(),cluster.getClusterName(),desiredConfigs);\n      configurations.clear();\n      executionCommand.setConfigurationTags(configurationTags);\n    }\n    Map<String,Map<String,String>> configurationTags=executionCommand.getConfigurationTags();\n    if (null != configurationTags && !configurationTags.isEmpty()) {\n      Map<String,Map<String,String>> configProperties=configHelper.getEffectiveConfigProperties(cluster,configurationTags);\n      for (      Map.Entry<String,Map<String,String>> entry : configProperties.entrySet()) {\n        String type=entry.getKey();\n        Map<String,String> allLevelMergedConfig=entry.getValue();\n        if (configurations.containsKey(type)) {\n          Map<String,String> mergedConfig=configHelper.getMergedConfig(allLevelMergedConfig,configurations.get(type));\n          configurations.get(type).clear();\n          configurations.get(type).putAll(mergedConfig);\n        }\n else {\n          configurations.put(type,new HashMap<String,String>());\n          configurations.get(type).putAll(allLevelMergedConfig);\n        }\n      }\n      Map<String,Map<String,Map<String,String>>> configAttributes=configHelper.getEffectiveConfigAttributes(cluster,executionCommand.getConfigurationTags());\n      for (      Map.Entry<String,Map<String,Map<String,String>>> attributesOccurrence : configAttributes.entrySet()) {\n        String type=attributesOccurrence.getKey();\n        Map<String,Map<String,String>> attributes=attributesOccurrence.getValue();\n        if (executionCommand.getConfigurationAttributes() != null) {\n          if (!executionCommand.getConfigurationAttributes().containsKey(type)) {\n            executionCommand.getConfigurationAttributes().put(type,new TreeMap<String,Map<String,String>>());\n          }\n          configHelper.cloneAttributesMap(attributes,executionCommand.getConfigurationAttributes().get(type));\n        }\n      }\n    }\n    ClusterVersionEntity effectiveClusterVersion=cluster.getEffectiveClusterVersion();\n// bug_start\n    executionCommand.getCommandParams().put(KeyNames.VERSION,effectiveClusterVersion.getRepositoryVersion().getVersion());\n// bug_end\n  }\n catch (  ClusterNotFoundException cnfe) {\n    LOG.warn(\"Unable to lookup the cluster by ID; assuming that there is no cluster and therefore no configs for this execution command: {}\",cnfe.getMessage());\n    return executionCommand;\n  }\ncatch (  AmbariException e) {\n    throw new RuntimeException(e);\n  }\n  return executionCommand;\n}\n"}
{"INPUT": "private boolean checkCompletingThread(){\n  boolean check=(this.completingThread == Thread.currentThread());\n// bug_start\n  this.completingThread=null;\n// bug_end\n  return check;\n}\n"}
{"INPUT": "@GuardedBy(\"mLock\") private void assertProvidersNotDefinedLocked(PackageParser.Package pkg) throws PackageManagerException {\n  final int providersSize=pkg.providers.size();\n  int i;\n  for (i=0; i < providersSize; i++) {\n    PackageParser.Provider p=pkg.providers.get(i);\n    if (p.info.authority != null) {\n      final String[] names=p.info.authority.split(\";\");\n      for (int j=0; j < names.length; j++) {\n        if (mProvidersByAuthority.containsKey(names[j])) {\n          final PackageParser.Provider other=mProvidersByAuthority.get(names[j]);\n          final String otherPackageName=(other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : \"?\";\n// bug_start\n          throw new PackageManagerException(INSTALL_FAILED_CONFLICTING_PROVIDER,\"Can't install because provider name \" + names[j] + \" (in package \"+ pkg.applicationInfo.packageName+ \") is already used by \"+ otherPackageName);\n// bug_end\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "public void manageCommands(){\n  syncDevTools();\n  disableForVisualMode(commands_.jumpTo(),commands_.showDiagnosticsActiveDocument(),commands_.findSelectAll(),commands_.fold(),commands_.foldAll(),commands_.unfold(),commands_.unfoldAll(),commands_.goToLine());\n// bug_start\n  setCodeCommandsEnabled(false);\n// bug_end\n}\n"}
{"INPUT": "@Override @After public void tearDown() throws Exception {\n  System.clearProperty(\"zkHost\");\n  if (cores != null) {\n    cores.shutdown();\n    cores=null;\n  }\n// bug_start\n  zkServer.shutdown();\n  zkServer=null;\n// bug_end\n  zkDir=null;\n  super.tearDown();\n}\n"}
{"INPUT": "private ViewInstanceEntity toEntity(Map<String,Object> properties,boolean update) throws AmbariException {\n  String name=(String)properties.get(INSTANCE_NAME_PROPERTY_ID);\n  if (name == null || name.isEmpty()) {\n    throw new IllegalArgumentException(\"View instance name must be provided\");\n  }\n  String version=(String)properties.get(VIEW_VERSION_PROPERTY_ID);\n  if (version == null || version.isEmpty()) {\n    throw new IllegalArgumentException(\"View version must be provided\");\n  }\n  String commonViewName=(String)properties.get(VIEW_NAME_PROPERTY_ID);\n  if (commonViewName == null || commonViewName.isEmpty()) {\n    throw new IllegalArgumentException(\"View name must be provided\");\n  }\n  ViewRegistry viewRegistry=ViewRegistry.getInstance();\n  ViewEntity viewEntity=viewRegistry.getDefinition(commonViewName,version);\n  String viewName=ViewEntity.getViewName(commonViewName,version);\n  if (viewEntity == null) {\n    throw new IllegalArgumentException(\"View name \" + viewName + \" does not exist.\");\n  }\n  ViewInstanceEntity viewInstanceEntity=null;\n  if (update) {\n    viewInstanceEntity=viewRegistry.getViewInstanceEntity(viewName,name);\n  }\n  if (viewInstanceEntity == null) {\n    viewInstanceEntity=new ViewInstanceEntity();\n    viewInstanceEntity.setName(name);\n    viewInstanceEntity.setViewName(viewName);\n    viewInstanceEntity.setViewEntity(viewEntity);\n  }\n  if (properties.containsKey(LABEL_PROPERTY_ID)) {\n    viewInstanceEntity.setLabel((String)properties.get(LABEL_PROPERTY_ID));\n  }\n  if (properties.containsKey(DESCRIPTION_PROPERTY_ID)) {\n    viewInstanceEntity.setDescription((String)properties.get(DESCRIPTION_PROPERTY_ID));\n  }\n  String visible=(String)properties.get(VISIBLE_PROPERTY_ID);\n  viewInstanceEntity.setVisible(visible == null ? true : Boolean.valueOf(visible));\n  if (properties.containsKey(ICON_PATH_ID)) {\n    viewInstanceEntity.setIcon((String)properties.get(ICON_PATH_ID));\n  }\n  if (properties.containsKey(ICON64_PATH_ID)) {\n    viewInstanceEntity.setIcon64((String)properties.get(ICON64_PATH_ID));\n  }\n// bug_start\n  String handle=(String)properties.get(CLUSTER_HANDLE_PROPERTY_ID);\n  if (handle != null) {\n    viewInstanceEntity.setClusterHandle(Long.valueOf(handle));\n  }\n// bug_end\n else {\n// bug_start\n    viewInstanceEntity.setClusterHandle(null);\n// bug_end\n  }\n  if (properties.containsKey(CLUSTER_TYPE_PROPERTY_ID)) {\n    String clusterType=(String)properties.get(CLUSTER_TYPE_PROPERTY_ID);\n    viewInstanceEntity.setClusterType(ClusterType.valueOf(clusterType));\n  }\n  Map<String,String> instanceProperties=new HashMap<String,String>();\n  boolean isUserAdmin=viewRegistry.checkAdmin();\n  for (  Map.Entry<String,Object> entry : properties.entrySet()) {\n    String propertyName=entry.getKey();\n    if (propertyName.startsWith(PROPERTIES_PREFIX)) {\n      if (isUserAdmin) {\n        instanceProperties.put(entry.getKey().substring(PROPERTIES_PREFIX.length()),(String)entry.getValue());\n      }\n    }\n else     if (propertyName.startsWith(DATA_PREFIX)) {\n      viewInstanceEntity.putInstanceData(entry.getKey().substring(DATA_PREFIX.length()),(String)entry.getValue());\n    }\n  }\n  if (!instanceProperties.isEmpty()) {\n    try {\n      viewRegistry.setViewInstanceProperties(viewInstanceEntity,instanceProperties,viewEntity.getConfiguration(),viewEntity.getClassLoader());\n    }\n catch (    org.apache.ambari.view.SystemException e) {\n      throw new AmbariException(\"Caught exception trying to set view properties.\",e);\n    }\n  }\n  return viewInstanceEntity;\n}\n"}
{"INPUT": "public void messageFinished(Message message,int number,int ofTotal){\n  try {\n    localFolder.appendMessages(new Message[]{message});\n    Message localMessage=localFolder.getMessage(message.getUid());\n    localMessage.setFlag(Flag.X_DOWNLOADED_FULL,true);\n    if (Email.DEBUG) {\n      Log.v(Email.LOG_TAG,\"About to notify listeners that we got a new small message \" + account + \":\"+ folder+ \":\"+ message.getUid());\n    }\n    for (    MessagingListener l : getListeners()) {\n      l.synchronizeMailboxAddOrUpdateMessage(account,folder,localMessage);\n// bug_start\n      l.synchronizeMailboxNewMessage(account,folder,localMessage);\n// bug_end\n    }\n  }\n catch (  MessagingException me) {\n    addErrorMessage(account,me);\n    Log.e(Email.LOG_TAG,\"SYNC: fetch small messages\",me);\n  }\n}\n"}
{"INPUT": "public void startScroll(int offsetY,int duration){\n// bug_start\n  mScroller.startScroll(0,mHolder.mOffsetY,0,offsetY,duration);\n  invalidate();\n// bug_end\n}\n"}
{"INPUT": "public List<Day> getSelectedDays(){\n  List<Day> selectedDays=new ArrayList<>();\n  for (Iterator<Month> monthIterator=monthAdapter.getData().iterator(); monthIterator.hasNext(); ) {\n    Month month=monthIterator.next();\n    for (Iterator<Day> dayIterator=month.getDaysWithoutTitlesAndOnlyCurrent().iterator(); dayIterator.hasNext(); ) {\n      Day day=dayIterator.next();\n// bug_start\n      selectedDays.add(day);\n// bug_end\n    }\n  }\n  return selectedDays;\n}\n"}
{"INPUT": "public ImageManager(Context context,File diskCacheDir,Executor executor,Handler mainHandler,Options options){\n  isBitmapRecyclingEnabled=options.recycleBitmaps && CAN_RECYCLE;\n  if (options.useMemoryCache && options.maxMemorySize <= 0) {\n    options.maxMemorySize=LruPhotoCache.getMaxCacheSize(context);\n  }\n  if (options.useDiskCache && options.maxDiskCacheSize <= 0) {\n    options.maxDiskCacheSize=MAX_DISK_CACHE_SIZE;\n  }\n  if (diskCacheDir == null || !options.useDiskCache) {\n    diskCache=null;\n  }\n else {\n    diskCache=new PhotoDiskCache(diskCacheDir,options.maxDiskCacheSize,options.appVersion);\n  }\n  if (!options.useMemoryCache) {\n    memoryCache=null;\n  }\n else {\n    memoryCache=new LruPhotoCache(options.maxMemorySize);\n  }\n  if (isBitmapRecyclingEnabled) {\n    if (memoryCache != null) {\n      memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener(){\n        @Override public void onPhotoRemoved(        String key,        Bitmap bitmap){\n          releaseBitmap(bitmap);\n        }\n      }\n);\n    }\n    bitmapCache=new SizedBitmapCache(options.maxPerSize);\n  }\n else {\n// bug_start\n    options.bitmapDecodeOptions.inMutable=false;\n// bug_end\n    bitmapCache=null;\n  }\n  this.resizer=new ImageResizer(bitmapCache,options.bitmapDecodeOptions);\n  this.mainHandler=mainHandler;\n  this.executor=executor;\n}\n"}
{"INPUT": "int handleIncomingUser(int callingPid,int callingUid,@UserIdInt int userId,boolean allowAll,int allowMode,String name,String callerPackage){\n  final int callingUserId=UserHandle.getUserId(callingUid);\n  if (callingUserId == userId) {\n    return userId;\n  }\n  int targetUserId=unsafeConvertIncomingUser(userId);\n  if (callingUid != 0 && callingUid != SYSTEM_UID) {\n    final boolean allow;\n    final boolean isSameProfileGroup=isSameProfileGroup(callingUserId,targetUserId);\n    if (mInjector.isCallerRecents(callingUid) && isSameProfileGroup(callingUserId,targetUserId)) {\n      allow=true;\n    }\n else     if (mInjector.checkComponentPermission(INTERACT_ACROSS_USERS_FULL,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {\n      allow=true;\n    }\n else     if (allowMode == ALLOW_FULL_ONLY) {\n      allow=false;\n    }\n else     if (canInteractWithAcrossProfilesPermission(allowMode,isSameProfileGroup,callingPid,callingUid,callerPackage)) {\n      allow=true;\n    }\n else     if (mInjector.checkComponentPermission(INTERACT_ACROSS_USERS,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {\n      allow=false;\n    }\n else     if (allowMode == ALLOW_NON_FULL) {\n      allow=true;\n    }\n else     if (allowMode == ALLOW_NON_FULL_IN_PROFILE || allowMode == ALLOW_ALL_PROFILE_PERMISSIONS_IN_PROFILE) {\n      allow=isSameProfileGroup;\n    }\n else {\n      throw new IllegalArgumentException(\"Unknown mode: \" + allowMode);\n    }\n    if (!allow) {\n      if (userId == UserHandle.USER_CURRENT_OR_SELF) {\n        targetUserId=callingUserId;\n      }\n else {\n        StringBuilder builder=new StringBuilder(128);\n        builder.append(\"Permission Denial: \");\n        builder.append(name);\n        if (callerPackage != null) {\n          builder.append(\" from \");\n          builder.append(callerPackage);\n        }\n        builder.append(\" asks to run as user \");\n        builder.append(userId);\n        builder.append(\" but is calling from uid \");\n        UserHandle.formatUid(builder,callingUid);\n        builder.append(\"; this requires \");\n        builder.append(INTERACT_ACROSS_USERS_FULL);\n        if (allowMode != ALLOW_FULL_ONLY) {\n// bug_start\n          builder.append(\" or \");\n          builder.append(INTERACT_ACROSS_USERS);\n// bug_end\n          if (isSameProfileGroup && allowMode == ALLOW_ALL_PROFILE_PERMISSIONS_IN_PROFILE) {\n            builder.append(\" or \");\n            builder.append(INTERACT_ACROSS_PROFILES);\n          }\n        }\n        String msg=builder.toString();\n        Slog.w(TAG,msg);\n        throw new SecurityException(msg);\n      }\n    }\n  }\n  if (!allowAll) {\n    ensureNotSpecialUser(targetUserId);\n  }\n  if (callingUid == Process.SHELL_UID && targetUserId >= UserHandle.USER_SYSTEM) {\n    if (hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,targetUserId)) {\n      throw new SecurityException(\"Shell does not have permission to access user \" + targetUserId + \"\\n \"+ Debug.getCallers(3));\n    }\n  }\n  return targetUserId;\n}\n"}
{"INPUT": "public byte[] readBytesZlib(long count,String name) throws IOException {\n  newDumpLevel(name,\"bytesZlib\");\n  byte[] data=readBytesInternalEx(count);\n  endDumpLevel();\n  InflaterInputStream dis=new InflaterInputStream(new ByteArrayInputStream(data));\n  ByteArrayOutputStream baos=new ByteArrayOutputStream();\n// bug_start\n  byte[] buf=new byte[4096];\n  int c=0;\n  while ((c=dis.read(buf)) > 0) {\n    baos.write(buf,0,c);\n// bug_end\n  }\n  return baos.toByteArray();\n}\n"}
{"INPUT": "@AfterClass public static void afterClass() throws Exception {\n// bug_start\n  exe.shutdownNow();\n  exe=null;\n// bug_end\n  inputFactory=null;\n}\n"}
{"INPUT": "public void close(){\nsynchronized (buffers) {\n    closed=true;\n    Iterator<ByteBuffer> bufferIter=buffers.iterator();\n    boolean loggerIsTraceEnabled=logger.isTraceEnabled();\n    int leakedCount=0;\n    while (bufferIter.hasNext()) {\n      ByteBuffer buffer=bufferIter.next();\n      if (buffer.isFree()) {\n        bufferIter.remove();\n        FFmpeg.av_free(buffer.ptr);\n      }\n else       if (loggerIsTraceEnabled)       leakedCount++;\n    }\n    if (loggerIsTraceEnabled) {\n// bug_start\n      logger.trace(\"Leaking \" + leakedCount + \" ByteBuffer instances.\");\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "@Override public void visit(ReturnStatement statement){\n  try {\n    debugEmitter.emitStatementStart();\n    if (statement.getLocation() != null) {\n      pushLocation(statement.getLocation());\n    }\n    writer.append(\"return\");\n    if (async) {\n      writer.append(\" $return($rt_asyncResult(\");\n    }\n    if (statement.getResult() != null) {\n// bug_start\n      writer.append(' ');\n// bug_end\n      prevCallSite=debugEmitter.emitCallSite();\n      statement.getResult().acceptVisitor(this);\n      debugEmitter.emitCallSite();\n    }\n    if (async) {\n      writer.append(\"))\");\n    }\n    writer.append(\";\").softNewLine();\n    if (statement.getLocation() != null) {\n      popLocation();\n    }\n  }\n catch (  IOException e) {\n    throw new RenderingException(\"IO error occured\",e);\n  }\n}\n"}
{"INPUT": "@Override protected void writeSingleRecordInternal(Row row) throws WriteRecordException {\n  if (restoreConfig.isRestore()) {\n// bug_start\n    nextBlock();\n// bug_end\n    if (lastRow != null) {\n      readyCheckpoint=!ObjectUtils.equals(lastRow.getField(restoreConfig.getRestoreColumnIndex()),row.getField(restoreConfig.getRestoreColumnIndex()));\n    }\n  }\n else {\n    checkWriteSize();\n  }\n  Group group=groupFactory.newGroup();\n  int i=0;\n  try {\n    for (; i < fullColumnNames.size(); i++) {\n      String colName=fullColumnNames.get(i);\n      String colType=fullColumnTypes.get(i);\n      colType=ColumnType.fromString(colType).name().toLowerCase();\n      Object valObj=row.getField(colIndices[i]);\n      if (valObj == null) {\n        continue;\n      }\n      String val=valObj.toString();\nswitch (colType) {\ncase \"tinyint\":\ncase \"smallint\":\ncase \"int\":\n        if (valObj instanceof Timestamp) {\n          ((Timestamp)valObj).getTime();\n          group.add(colName,(int)((Timestamp)valObj).getTime());\n        }\n else         if (valObj instanceof Date) {\n          group.add(colName,(int)((Date)valObj).getTime());\n        }\n else {\n          group.add(colName,Integer.parseInt(val));\n        }\n      break;\ncase \"bigint\":\n    if (valObj instanceof Timestamp) {\n      group.add(colName,((Timestamp)valObj).getTime());\n    }\n else     if (valObj instanceof Date) {\n      group.add(colName,((Date)valObj).getTime());\n    }\n else {\n      group.add(colName,Long.parseLong(val));\n    }\n  break;\ncase \"float\":\ngroup.add(colName,Float.parseFloat(val));\nbreak;\ncase \"double\":\ngroup.add(colName,Double.parseDouble(val));\nbreak;\ncase \"binary\":\ngroup.add(colName,Binary.fromString(val));\nbreak;\ncase \"char\":\ncase \"varchar\":\ncase \"string\":\nif (valObj instanceof Timestamp) {\nval=DateUtil.getDateTimeFormatter().format(valObj);\ngroup.add(colName,val);\n}\n else {\ngroup.add(colName,val);\n}\nbreak;\ncase \"boolean\":\ngroup.add(colName,Boolean.parseBoolean(val));\nbreak;\ncase \"timestamp\":\nTimestamp ts=DateUtil.columnToTimestamp(valObj,null);\nbyte[] dst=longToByteArray(ts.getTime());\ngroup.add(colName,Binary.fromConstantByteArray(dst));\nbreak;\ncase \"decimal\":\nHiveDecimal hiveDecimal=HiveDecimal.create(new BigDecimal(val));\nMap<String,Integer> decimalInfo=decimalColInfo.get(colName);\nif (decimalInfo != null) {\ngroup.add(colName,decimalToBinary(hiveDecimal,decimalInfo.get(KEY_PRECISION),decimalInfo.get(KEY_SCALE)));\n}\n else {\ngroup.add(colName,decimalToBinary(hiveDecimal,DEFAULT_PRECISION,DEFAULT_SCALE));\n}\nbreak;\ncase \"date\":\nDate date=DateUtil.columnToDate(valObj,null);\ngroup.add(colName,DateWritable.dateToDays(new java.sql.Date(date.getTime())));\nbreak;\ndefault :\ngroup.add(colName,val);\nbreak;\n}\n}\nwriter.write(group);\nlastRow=row;\nrowsOfCurrentBlock++;\n}\n catch (Exception e) {\nif (i < row.getArity()) {\nthrow new WriteRecordException(recordConvertDetailErrorMessage(i,row),e,i,row);\n}\nthrow new WriteRecordException(e.getMessage(),e);\n}\n}\n"}
{"INPUT": "public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n  this.applicationContext=applicationContext;\n  if (applicationContext instanceof ConfigurableApplicationContext) {\n// bug_start\n    addComponent(\"spring-event\",new EventComponent(applicationContext));\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void addOnGLIdleListener(OnGLIdleListener listener){\nsynchronized (mIdleListeners) {\n    mIdleListeners.addLast(listener);\n// bug_start\n    mIdleRunner.enable();\n// bug_end\n  }\n}\n"}
{"INPUT": "private static void buildFolding(ASTNode node,List<FoldingDescriptor> list){\n  boolean isBlock=node.getElementType() == DartTokenTypes.BLOCK || node.getElementType() == DartTokenTypes.CLASS_BODY;\n  if (isBlock && !node.getTextRange().isEmpty()) {\n    final TextRange range=node.getTextRange();\n// bug_start\n    list.add(new FoldingDescriptor(node,range));\n// bug_end\n  }\n  for (  ASTNode child : node.getChildren(null)) {\n    buildFolding(child,list);\n  }\n}\n"}
{"INPUT": "public final void process(final ITemplateProcessingContext processingContext,final IDocType docType,final IDocTypeStructureHandler structureHandler){\n  try {\n    doProcess(processingContext,docType,structureHandler);\n  }\n catch (  final TemplateProcessingException e) {\n// bug_start\n    if (!e.hasTemplateName()) {\n      e.setTemplateName(docType.getTemplateName());\n    }\n    if (!e.hasLineAndCol()) {\n      e.setLineAndCol(docType.getLine(),docType.getCol());\n// bug_end\n    }\n    throw e;\n  }\ncatch (  final Exception e) {\n    throw new TemplateProcessingException(\"Error during execution of processor '\" + this.getClass().getName() + \"'\",docType.getTemplateName(),docType.getLine(),docType.getCol(),e);\n  }\n}\n"}
{"INPUT": "private boolean javaVersionOkay(){\n  final String version=System.getProperty(\"java.version\");\n  if (version != null && (version.startsWith(\"1.0\") || version.startsWith(\"1.1\") || version.startsWith(\"1.2\")|| version.startsWith(\"1.3\")|| version.startsWith(\"1.4\")|| version.startsWith(\"1.5\"))) {\n    final DialogThread dt=new DialogThread(\"Error: LanguageTool requires Java 6.0 or later. Current version: \" + version);\n    dt.start();\n    return false;\n  }\n  try {\n// bug_start\n    for (    UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {\n      if (\"Nimbus\".equals(info.getName())) {\n        UIManager.setLookAndFeel(info.getClassName());\n        break;\n// bug_end\n      }\n    }\n  }\n catch (  Exception ignored) {\n  }\n  return true;\n}\n"}
{"INPUT": "void removeRequest(BuildRequest request){\n  selectRequests.removeValue(request,true);\n// bug_start\n  removals.add(request);\n// bug_end\n}\n"}
{"INPUT": "public Object get(String entityName,Serializable id,LockMode lockMode){\n  errorIfClosed();\n  Object result=getFactory().getEntityPersister(entityName).load(id,null,lockMode,this);\n// bug_start\n  temporaryPersistenceContext.clear();\n// bug_end\n  return result;\n}\n"}
{"INPUT": "@Override public void add(Instant value){\n  final Instant currentValue=readInternal();\n  final Instant combinedValue=currentValue == null ? value : timestampCombiner.combine(currentValue,value);\n// bug_start\n  writeInternal(combinedValue);\n// bug_end\n}\n"}
{"INPUT": "@Override public void onChanged(){\n  orderViewStack();\n  int delay=0;\n  for (int i=0; i < VIEW_COUNT; i++) {\n    CardItemView itemView=viewList.get(i);\n    if (itemView.getVisibility() == View.VISIBLE) {\n      continue;\n    }\n else     if (i == 0) {\n// bug_start\n      isShowing++;\n// bug_end\n      cardSwitchListener.onShow(isShowing);\n    }\n    if (i == VIEW_COUNT - 1) {\n      itemView.setAlpha(0);\n      itemView.setVisibility(View.VISIBLE);\n    }\n else {\n      itemView.setVisibilityWithAnimation(View.VISIBLE,delay++);\n    }\n    adapter.bindView(itemView,isShowing + i);\n  }\n}\n"}
{"INPUT": "private void writeChunkToContainer(ByteBuffer chunk) throws IOException {\n  int effectiveChunkSize=chunk.remaining();\n  ByteString data=ByteStringHelper.getByteString(chunk);\n  Checksum checksum=new Checksum(checksumType,bytesPerChecksum);\n  ChecksumData checksumData=checksum.computeChecksum(chunk);\n  ChunkInfo chunkInfo=ChunkInfo.newBuilder().setChunkName(blockID.getLocalID() + \"_chunk_\" + ++chunkIndex).setOffset(0).setLen(effectiveChunkSize).setChecksumData(checksumData.getProtoBufMessage()).build();\n  try {\n    XceiverClientReply asyncReply=writeChunkAsync(xceiverClient,chunkInfo,blockID,data);\n    CompletableFuture<ContainerProtos.ContainerCommandResponseProto> future=asyncReply.getResponse();\n    future.thenApplyAsync(null,responseExecutor).exceptionally(null);\n  }\n catch (  IOException|InterruptedException|ExecutionException e) {\n    throw new IOException(\"Unexpected Storage Container Exception: \" + e.toString(),e);\n  }\n// bug_start\n  LOG.debug(\"writing chunk \" + chunkInfo.getChunkName() + \" blockID \"+ blockID+ \" length \"+ effectiveChunkSize);\n// bug_end\n  containerBlockData.addChunks(chunkInfo);\n}\n"}
{"INPUT": "@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){\n  super.onSizeChanged(w,h,oldw,oldh);\n// bug_start\n  setBackgroundCompat(w,h);\n// bug_end\n}\n"}
{"INPUT": "private void handleIccCardStatus(IccCardStatus newCardStatus){\n  boolean transitionedIntoPinLocked;\n  boolean transitionedIntoAbsent;\n  boolean transitionedIntoNetworkLocked;\n  boolean transitionedIntoPermBlocked;\n  boolean isIccCardRemoved;\n  boolean isIccCardAdded;\n  State oldState, newState;\n  State oldRuimState=getRuimState();\n  oldState=mState;\n  mIccCardStatus=newCardStatus;\n  newState=getIccCardState();\nsynchronized (mStateMonitor) {\n    mState=newState;\n    updateStateProperty();\n    if (oldState != State.READY && newState == State.READY) {\n      mHandler.sendMessage(mHandler.obtainMessage(EVENT_ICC_READY));\n      mReadyRegistrants.notifyRegistrants();\n    }\n else     if (newState.isPinLocked()) {\n      mHandler.sendMessage(mHandler.obtainMessage(EVENT_ICC_LOCKED));\n    }\n    if (oldRuimState != State.READY && getRuimState() == State.READY) {\n      mRuimReadyRegistrants.notifyRegistrants();\n    }\n  }\n  transitionedIntoPinLocked=((oldState != State.PIN_REQUIRED && newState == State.PIN_REQUIRED) || (oldState != State.PUK_REQUIRED && newState == State.PUK_REQUIRED));\n  transitionedIntoAbsent=(oldState != State.ABSENT && newState == State.ABSENT);\n  transitionedIntoNetworkLocked=(oldState != State.NETWORK_LOCKED && newState == State.NETWORK_LOCKED);\n  transitionedIntoPermBlocked=(oldState != State.PERM_DISABLED && newState == State.PERM_DISABLED);\n  isIccCardRemoved=(oldState != null && oldState.iccCardExist() && newState == State.ABSENT);\n  isIccCardAdded=(oldState == State.ABSENT && newState != null && newState.iccCardExist());\n  if (transitionedIntoPinLocked) {\n    if (mDbg)     log(\"Notify SIM pin or puk locked.\");\n    mPinLockedRegistrants.notifyRegistrants();\n    broadcastIccStateChangedIntent(INTENT_VALUE_ICC_LOCKED,(newState == State.PIN_REQUIRED) ? INTENT_VALUE_LOCKED_ON_PIN : INTENT_VALUE_LOCKED_ON_PUK);\n  }\n else   if (transitionedIntoAbsent) {\n    if (mDbg)     log(\"Notify SIM missing.\");\n    mAbsentRegistrants.notifyRegistrants();\n    broadcastIccStateChangedIntent(INTENT_VALUE_ICC_ABSENT,null);\n  }\n else   if (transitionedIntoNetworkLocked) {\n    if (mDbg)     log(\"Notify SIM network locked.\");\n    mNetworkLockedRegistrants.notifyRegistrants();\n    broadcastIccStateChangedIntent(INTENT_VALUE_ICC_LOCKED,INTENT_VALUE_LOCKED_NETWORK);\n  }\n else   if (transitionedIntoPermBlocked) {\n    if (mDbg)     log(\"Notify SIM permanently disabled.\");\n    broadcastIccStateChangedIntent(INTENT_VALUE_ICC_ABSENT,INTENT_VALUE_ABSENT_ON_PERM_DISABLED);\n  }\n  if (isIccCardRemoved) {\n    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_REMOVED,null));\n  }\n else   if (isIccCardAdded) {\n    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_ADDED,null));\n  }\n  if (oldState != State.READY && newState == State.READY && (is3gpp || isSubscriptionFromIccCard)) {\n// bug_start\n    mIccFileHandler.setAid(getAid());\n// bug_end\n    mIccRecords.onReady();\n  }\n}\n"}
{"INPUT": "@Override public void advanceIfNeeded(int minval){\n  while ((hs >>> 16) < (minval >>> 16)) {\n    cp.advance();\n    if (cp.hasContainer()) {\n      nextContainer();\n    }\n else {\n      return;\n    }\n  }\n// bug_start\n  iter.advanceIfNeeded(BufferUtil.lowbits(minval));\n// bug_end\n}\n"}
{"INPUT": "@Override public MultiLayerConfiguration deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException {\n  long charOffsetStart=jp.getCurrentLocation().getCharOffset();\n  MultiLayerConfiguration conf=(MultiLayerConfiguration)defaultDeserializer.deserialize(jp,ctxt);\n  Layer[] layers=new Layer[conf.getConfs().size()];\n  for (int i=0; i < layers.length; i++) {\n    layers[i]=conf.getConf(i).getLayer();\n  }\n  boolean attemptIUpdaterFromLegacy=requiresIUpdaterFromLegacy(layers);\n  if (attemptIUpdaterFromLegacy) {\n    JsonLocation endLocation=jp.getCurrentLocation();\n    long charOffsetEnd=endLocation.getCharOffset();\n    String jsonSubString=endLocation.getSourceRef().toString().substring((int)charOffsetStart - 1,(int)charOffsetEnd);\n    ObjectMapper om=NeuralNetConfiguration.mapper();\n    JsonNode rootNode=om.readTree(jsonSubString);\n    ArrayNode confsNode=(ArrayNode)rootNode.get(\"confs\");\n    for (int i=0; i < layers.length; i++) {\n      ObjectNode on=(ObjectNode)confsNode.get(i);\n      ObjectNode confNode=null;\n      if (layers[i] instanceof BaseLayer && ((BaseLayer)layers[i]).getIUpdater() == null) {\n        if (on.has(\"layer\")) {\n          confNode=on;\n          on=(ObjectNode)on.get(\"layer\");\n        }\n else {\n          continue;\n        }\n        on=(ObjectNode)on.elements().next();\n        handleUpdaterBackwardCompatibility((BaseLayer)layers[i],on);\n      }\n      if (layers[i].getIDropout() == null) {\n        if (on.has(\"dropOut\")) {\n          double d=on.get(\"dropOut\").asDouble();\n          if (!Double.isNaN(d)) {\n            if (confNode != null && layers[i] instanceof BaseLayer && confNode.has(\"useDropConnect\") && confNode.get(\"useDropConnect\").asBoolean(false)) {\n              ((BaseLayer)layers[i]).setWeightNoise(new DropConnect(d));\n            }\n else {\n// bug_start\n              layers[i].setIDropout(new Dropout(d));\n// bug_end\n            }\n          }\n        }\n      }\n    }\n  }\n  return conf;\n}\n"}
{"INPUT": "private MimeMessage createMessage(boolean isDraft) throws MessagingException {\n  MimeMessage message=new MimeMessage();\n  message.addSentDate(new Date());\n  Address from=new Address(mIdentity.getEmail(),mIdentity.getName());\n  message.setFrom(from);\n  message.setRecipients(RecipientType.TO,getAddresses(mToView));\n  message.setRecipients(RecipientType.CC,getAddresses(mCcView));\n  message.setRecipients(RecipientType.BCC,getAddresses(mBccView));\n  message.setSubject(mSubjectView.getText().toString());\n  if (mReadReceipt) {\n    message.setHeader(\"Disposition-Notification-To\",from.toEncodedString());\n    message.setHeader(\"X-Confirm-Reading-To\",from.toEncodedString());\n    message.setHeader(\"Return-Receipt-To\",from.toEncodedString());\n  }\n// bug_start\n  message.setHeader(\"User-Agent\",getString(R.string.message_header_mua));\n// bug_end\n  final String replyTo=mIdentity.getReplyTo();\n  if (replyTo != null) {\n    message.setReplyTo(new Address[]{new Address(replyTo)});\n  }\n  if (mInReplyTo != null) {\n    message.setInReplyTo(mInReplyTo);\n  }\n  if (mReferences != null) {\n    message.setReferences(mReferences);\n  }\n  TextBody body=null;\n  if (mPgpData.getEncryptedData() != null) {\n    String text=mPgpData.getEncryptedData();\n    body=new TextBody(text);\n  }\n else {\n    body=buildText(isDraft);\n  }\n  TextBody bodyPlain=null;\n  final boolean hasAttachments=mAttachments.getChildCount() > 0;\n  if (mMessageFormat == SimpleMessageFormat.HTML) {\n    MimeMultipart composedMimeMessage=new MimeMultipart();\n    composedMimeMessage.setSubType(\"alternative\");\n    composedMimeMessage.addBodyPart(new MimeBodyPart(body,\"text/html\"));\n    bodyPlain=buildText(isDraft,SimpleMessageFormat.TEXT);\n    composedMimeMessage.addBodyPart(new MimeBodyPart(bodyPlain,\"text/plain\"));\n    if (hasAttachments) {\n      MimeMultipart mp=new MimeMultipart();\n      mp.addBodyPart(new MimeBodyPart(composedMimeMessage));\n      addAttachmentsToMessage(mp);\n      message.setBody(mp);\n    }\n else {\n      message.setBody(composedMimeMessage);\n    }\n  }\n else   if (mMessageFormat == SimpleMessageFormat.TEXT) {\n    if (hasAttachments) {\n      MimeMultipart mp=new MimeMultipart();\n      mp.addBodyPart(new MimeBodyPart(body,\"text/plain\"));\n      addAttachmentsToMessage(mp);\n      message.setBody(mp);\n    }\n else {\n      message.setBody(body);\n    }\n  }\n  if (isDraft) {\n    message.addHeader(K9.IDENTITY_HEADER,buildIdentityHeader(body,bodyPlain));\n  }\n  return message;\n}\n"}
{"INPUT": "@Override public SolrResourceLoader createCoreResourceLoader(CoreDescriptor cd){\n  final String colName=cd.getCollectionName();\n  try {\n    if (!zkController.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + colName,true)) {\n      log.warn(\"Auto-creating collection (in ZK) from core descriptor (on disk).  This feature may go away!\");\n// bug_start\n      CreateCollectionCmd.createCollectionZkNode(zkController.getSolrCloudManager().getDistribStateManager(),colName,cd.getCloudDescriptor().getParams(),null);\n// bug_end\n    }\n  }\n catch (  InterruptedException e) {\n    Thread.currentThread().interrupt();\n    throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\"Interrupted auto-creating collection\",e);\n  }\ncatch (  KeeperException e) {\n    throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\"Failure auto-creating collection\",e);\n  }\n  final String configSetName;\n  try {\n    configSetName=zkController.getZkStateReader().readConfigName(colName);\n    cd.setConfigSet(configSetName);\n  }\n catch (  KeeperException ex) {\n    throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\"Trouble resolving configSet for collection \" + colName + \": \"+ ex.getMessage());\n  }\n  return new ZkSolrResourceLoader(cd.getInstanceDir(),configSetName,parentLoader.getClassLoader(),zkController);\n}\n"}
{"INPUT": "public void remove(){\n// bug_start\n  persistenceManager.pop();\n// bug_end\n  if (persistenceManager.empty()) {\n    PersistenceManagerContext.clear();\n  }\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n  final Options options=buildOptions();\n  try {\n    final CommandLine cmd=new DefaultParser().parse(options,args);\n    if (!cmd.hasOption(GobblinClusterConfigurationKeys.APPLICATION_NAME_OPTION_NAME) || !cmd.hasOption(GobblinClusterConfigurationKeys.HELIX_INSTANCE_NAME_OPTION_NAME) || !cmd.hasOption(GobblinAWSConfigurationKeys.APP_WORK_DIR)) {\n      printUsage(options);\n      System.exit(1);\n    }\n// bug_start\n    Log4jConfigHelper.updateLog4jConfiguration(GobblinTaskRunner.class,GobblinAWSConfigurationKeys.GOBBLIN_AWS_LOG4J_CONFIGURATION_FILE);\n// bug_end\n    LOGGER.info(JvmUtils.getJvmInputArguments());\n    final String applicationName=cmd.getOptionValue(GobblinClusterConfigurationKeys.APPLICATION_NAME_OPTION_NAME);\n    final String helixInstanceName=cmd.getOptionValue(GobblinClusterConfigurationKeys.HELIX_INSTANCE_NAME_OPTION_NAME);\n    final String appWorkDir=cmd.getOptionValue(GobblinAWSConfigurationKeys.APP_WORK_DIR);\n    final GobblinTaskRunner gobblinTaskRunner=new GobblinAWSTaskRunner(applicationName,helixInstanceName,ConfigFactory.load(),Optional.of(new Path(appWorkDir)));\n    gobblinTaskRunner.start();\n  }\n catch (  ParseException pe) {\n    printUsage(options);\n    System.exit(1);\n  }\n}\n"}
{"INPUT": "private String format(TcpChannel channel,BytesReference message,String event) throws IOException {\n  final StringBuilder sb=new StringBuilder();\n  sb.append(channel);\n  int messageLengthWithHeader=HEADER_SIZE + message.length();\n  if (message.length() == 0) {\n    sb.append(\" [ping]\").append(' ').append(event).append(\": \").append(messageLengthWithHeader).append('B');\n  }\n else {\n    boolean success=false;\n    StreamInput streamInput=message.streamInput();\n    try {\n      final long requestId=streamInput.readLong();\n      final byte status=streamInput.readByte();\n      final boolean isRequest=TransportStatus.isRequest(status);\n      final String type=isRequest ? \"request\" : \"response\";\n      final String version=Version.fromId(streamInput.readInt()).toString();\n      sb.append(\" [length: \").append(messageLengthWithHeader);\n      sb.append(\", request id: \").append(requestId);\n      sb.append(\", type: \").append(type);\n      sb.append(\", version: \").append(version);\n      if (isRequest) {\n        if (TransportStatus.isCompress(status)) {\n          Compressor compressor;\n          compressor=InboundMessage.getCompressor(message);\n          if (compressor == null) {\n            throw new IllegalStateException(new NotCompressedException());\n          }\n          streamInput=compressor.streamInput(streamInput);\n        }\n        try (ThreadContext context=new ThreadContext(Settings.EMPTY)){\n          context.readHeaders(streamInput);\n        }\n// bug_start\n         streamInput.readStringArray();\n// bug_end\n        sb.append(\", action: \").append(streamInput.readString());\n      }\n      sb.append(']');\n      sb.append(' ').append(event).append(\": \").append(messageLengthWithHeader).append('B');\n      success=true;\n    }\n  finally {\n      if (success) {\n        IOUtils.close(streamInput);\n      }\n else {\n        IOUtils.closeWhileHandlingException(streamInput);\n      }\n    }\n  }\n  return sb.toString();\n}\n"}
{"INPUT": "long moveToEnd(final Wire wire){\n  Sequence sequence1=this.sequence;\n  if (sequence1 != null) {\n    for (int i=0; i < 128; i++) {\n      long endAddress=writePosition.getVolatileValue();\n      if (endAddress == 0)       return -1;\n      long sequence=sequence1.getSequence(endAddress);\n      if (sequence == Sequence.NOT_FOUND_RETRY)       continue;\n      if (sequence == Sequence.NOT_FOUND)       return -1;\n      Bytes<?> bytes=wire.bytes();\n      bytes.readPosition(endAddress);\n      for (; ; ) {\n        int header=bytes.readInt(endAddress);\n        if (header == 0 || Wires.isNotComplete(header))         return sequence;\n        int len=Wires.lengthOf(header) + 4;\n        bytes.readSkip(len);\n        endAddress+=len;\n// bug_start\n        sequence+=1;\n// bug_end\n      }\n    }\n  }\n  return -1;\n}\n"}
{"INPUT": "public Path lastDataFileForDataset(HoodieDatasetReference metadata,String partitionPathString){\n  try {\n    Path partitionPath=new Path(partitionPathString);\n    if (!fs.exists(partitionPath)) {\n      throw new HoodieHiveDatasetException(\"Partition path \" + partitionPath + \" not found in Dataset \"+ metadata);\n    }\n    RemoteIterator<LocatedFileStatus> files=fs.listFiles(partitionPath,true);\n    Path returnPath=null;\n    while (files.hasNext()) {\n      Path path=files.next().getPath();\n      if (path.getName().endsWith(PARQUET_EXTENSION) || path.getName().endsWith(PARQUET_EXTENSION_ZIPPED)) {\n// bug_start\n        returnPath=path;\n// bug_end\n      }\n    }\n    if (returnPath != null) {\n      return returnPath;\n    }\n    throw new HoodieHiveDatasetException(\"No data file found in path \" + partitionPath + \" for dataset \"+ metadata);\n  }\n catch (  IOException e) {\n    throw new HoodieHiveDatasetException(\"Failed to get data file in path \" + partitionPathString + \" for dataset \"+ metadata,e);\n  }\n}\n"}
{"INPUT": "public static List<Option> http2JettyDependencies(){\n  List<Option> res=new ArrayList<Option>();\n  res.add(CoreOptions.systemProperty(\"jetty.http.port\").value(String.valueOf(TestJettyOSGiBootCore.DEFAULT_HTTP_PORT)));\n  res.add(CoreOptions.systemProperty(\"jetty.ssl.port\").value(String.valueOf(TestJettyOSGiBootCore.DEFAULT_SSL_PORT)));\n  String alpnBoot=System.getProperty(\"mortbay-alpn-boot\");\n  if (alpnBoot == null) {\n    throw new IllegalStateException(\"Define path to alpn boot jar as system property -Dmortbay-alpn-boot\");\n  }\n  File checkALPNBoot=new File(alpnBoot);\n  if (!checkALPNBoot.exists()) {\n    throw new IllegalStateException(\"Unable to find the alpn boot jar here: \" + alpnBoot);\n  }\n// bug_start\n  res.add(CoreOptions.vmOptions(\"-Xbootclasspath/p:\" + alpnBoot));\n// bug_end\n  res.add(mavenBundle().groupId(\"org.eclipse.jetty.osgi\").artifactId(\"jetty-osgi-alpn\").versionAsInProject().noStart());\n  res.add(mavenBundle().groupId(\"org.eclipse.jetty\").artifactId(\"jetty-alpn-server\").versionAsInProject().start());\n  res.add(mavenBundle().groupId(\"org.eclipse.jetty.http2\").artifactId(\"http2-common\").versionAsInProject());\n  res.add(mavenBundle().groupId(\"org.eclipse.jetty.http2\").artifactId(\"http2-hpack\").versionAsInProject());\n  res.add(mavenBundle().groupId(\"org.eclipse.jetty.http2\").artifactId(\"http2-server\").versionAsInProject());\n  return res;\n}\n"}
{"INPUT": "public BootstrapActionDetail unmarshall(JsonUnmarshallerContext context) throws Exception {\n  BootstrapActionDetail bootstrapActionDetail=new BootstrapActionDetail();\n  int originalDepth=context.getCurrentDepth();\n  String currentParentElement=context.getCurrentParentElement();\n  int targetDepth=originalDepth + 1;\n// bug_start\n  JsonToken token=context.currentToken;\n// bug_end\n  if (token == null)   token=context.nextToken();\n  if (token == VALUE_NULL)   return null;\n  while (true) {\n    if (token == null)     break;\n    if (token == FIELD_NAME || token == START_OBJECT) {\n      if (context.testExpression(\"BootstrapActionConfig\",targetDepth)) {\n        context.nextToken();\n        bootstrapActionDetail.setBootstrapActionConfig(BootstrapActionConfigJsonUnmarshaller.getInstance().unmarshall(context));\n      }\n    }\n else     if (token == END_ARRAY || token == END_OBJECT) {\n      if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n        if (context.getCurrentDepth() <= originalDepth)         break;\n      }\n    }\n    token=context.nextToken();\n  }\n  return bootstrapActionDetail;\n}\n"}
{"INPUT": "@Inject ClassUsingQualifierWithArgsFactory(@QualifierWithArgs(name=\"Fred\",count=3) Provider<String> providedDepAProvider){\n// bug_start\n  this.providedDepAProvider=providedDepAProvider;\n// bug_end\n}\n"}
{"INPUT": "public void remove(){\n  if (currentIndex == INDEX_ZERO && map.hasZeroValue) {\n    map.hasZeroValue=false;\n  }\n else   if (currentIndex < 0) {\n    throw new IllegalStateException(\"next must be called before remove.\");\n  }\n else   if (currentIndex >= map.capacity) {\n    map.removeStashIndex(currentIndex);\n// bug_start\n    nextIndex=currentIndex;\n// bug_end\n    findNextIndex();\n  }\n else {\n    map.keyTable[currentIndex]=EMPTY;\n  }\n  currentIndex=INDEX_ILLEGAL;\n  map.size--;\n}\n"}
{"INPUT": "@Override protected void runChild(Feature feature,RunNotifier notifier){\n  FeatureInfo info=featureMap.get(feature.getRelativePath());\n  info.setNotifier(notifier);\n  info.unit.run();\n// bug_start\n  FeatureResult result=info.exec.result;\n// bug_end\n  if (!result.isEmpty()) {\n    result.printStats(null);\n    HtmlFeatureReport.saveFeatureResult(targetDir,result);\n    summary.addFeatureResult(result);\n  }\n}\n"}
{"INPUT": "@Override public TokenResponse exchange(AuthorizationCodeAuthenticationToken authorizationCodeAuthentication) throws OAuth2AuthenticationException {\n  ClientRegistration clientRegistration=authorizationCodeAuthentication.getClientRegistration();\n// bug_start\n  AuthorizationCode authorizationCode=new AuthorizationCode(authorizationCodeAuthentication.getAuthorizationResponse().getCode());\n// bug_end\n  URI redirectUri=toURI(clientRegistration.getRedirectUri());\n  AuthorizationGrant authorizationCodeGrant=new AuthorizationCodeGrant(authorizationCode,redirectUri);\n  URI tokenUri=toURI(clientRegistration.getProviderDetails().getTokenUri());\n  ClientID clientId=new ClientID(clientRegistration.getClientId());\n  Secret clientSecret=new Secret(clientRegistration.getClientSecret());\n  ClientAuthentication clientAuthentication;\n  if (ClientAuthenticationMethod.POST.equals(clientRegistration.getClientAuthenticationMethod())) {\n    clientAuthentication=new ClientSecretPost(clientId,clientSecret);\n  }\n else {\n    clientAuthentication=new ClientSecretBasic(clientId,clientSecret);\n  }\n  com.nimbusds.oauth2.sdk.TokenResponse tokenResponse;\n  try {\n    TokenRequest tokenRequest=new TokenRequest(tokenUri,clientAuthentication,authorizationCodeGrant);\n    HTTPRequest httpRequest=tokenRequest.toHTTPRequest();\n    httpRequest.setAccept(MediaType.APPLICATION_JSON_VALUE);\n    httpRequest.setConnectTimeout(30000);\n    httpRequest.setReadTimeout(30000);\n    tokenResponse=com.nimbusds.oauth2.sdk.TokenResponse.parse(httpRequest.send());\n  }\n catch (  ParseException pe) {\n    throw new OAuth2AuthenticationException(new OAuth2Error(INVALID_TOKEN_RESPONSE_ERROR_CODE),pe);\n  }\ncatch (  IOException ioe) {\n    throw new AuthenticationServiceException(\"An error occurred while sending the Access Token Request: \" + ioe.getMessage(),ioe);\n  }\n  if (!tokenResponse.indicatesSuccess()) {\n    TokenErrorResponse tokenErrorResponse=(TokenErrorResponse)tokenResponse;\n    ErrorObject errorObject=tokenErrorResponse.getErrorObject();\n    OAuth2Error oauth2Error=new OAuth2Error(errorObject.getCode(),errorObject.getDescription(),(errorObject.getURI() != null ? errorObject.getURI().toString() : null));\n    throw new OAuth2AuthenticationException(oauth2Error,oauth2Error.toString());\n  }\n  AccessTokenResponse accessTokenResponse=(AccessTokenResponse)tokenResponse;\n  String accessToken=accessTokenResponse.getTokens().getAccessToken().getValue();\n  AccessToken.TokenType accessTokenType=null;\n  if (AccessToken.TokenType.BEARER.getValue().equalsIgnoreCase(accessTokenResponse.getTokens().getAccessToken().getType().getValue())) {\n    accessTokenType=AccessToken.TokenType.BEARER;\n  }\n  long expiresIn=accessTokenResponse.getTokens().getAccessToken().getLifetime();\n  Set<String> scopes=Collections.emptySet();\n  if (!CollectionUtils.isEmpty(accessTokenResponse.getTokens().getAccessToken().getScope())) {\n    scopes=new LinkedHashSet<>(accessTokenResponse.getTokens().getAccessToken().getScope().toStringList());\n  }\n  Map<String,Object> additionalParameters=new LinkedHashMap<>(accessTokenResponse.getCustomParameters());\n  return TokenResponse.withToken(accessToken).tokenType(accessTokenType).expiresIn(expiresIn).scopes(scopes).additionalParameters(additionalParameters).build();\n}\n"}
{"INPUT": "@Test public void testString() throws IOException {\n  String string=\"\";\n  byte[] data=string.getBytes(MessagePack.UTF8);\n  LinkedBuffer lb=LinkedBuffer.allocate();\n  WriteSession session=new WriteSession(lb);\n// bug_start\n  StringSerializer.writeUTF8(string,session,session.tail);\n// bug_end\n  byte[] xdata=session.toByteArray();\n  Assert.assertTrue(Arrays.equals(data,xdata));\n}\n"}
{"INPUT": "void doIO(SelectionKey k) throws InterruptedException {\n  try {\n    if (isSocketOpen() == false) {\n      LOG.warn(\"trying to do i/o on a null socket for session:0x\" + Long.toHexString(sessionId));\n      return;\n    }\n    if (k.isReadable()) {\n      int rc=sock.read(incomingBuffer);\n      if (rc < 0) {\n        throw new EndOfStreamException(\"Unable to read additional data from client sessionid 0x\" + Long.toHexString(sessionId) + \", likely client has closed socket\");\n      }\n      if (incomingBuffer.remaining() == 0) {\n        boolean isPayload;\n        if (incomingBuffer == lenBuffer) {\n          incomingBuffer.flip();\n          isPayload=readLength(k);\n          incomingBuffer.clear();\n        }\n else {\n          isPayload=true;\n        }\n        if (isPayload) {\n          readPayload();\n        }\n else {\n          return;\n        }\n      }\n    }\n    if (k.isWritable()) {\n      handleWrite(k);\n      if (!initialized && !getReadInterest() && !getWriteInterest()) {\n        throw new CloseRequestException(\"responded to info probe\");\n      }\n    }\n  }\n catch (  CancelledKeyException e) {\n    LOG.warn(\"CancelledKeyException causing close of session 0x\" + Long.toHexString(sessionId));\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"CancelledKeyException stack trace\",e);\n    }\n    close();\n  }\ncatch (  CloseRequestException e) {\n    close();\n  }\ncatch (  EndOfStreamException e) {\n    LOG.warn(e.getMessage());\n    close();\n  }\ncatch (  ClientCnxnLimitException e) {\n// bug_start\n    ServerMetrics.CONNECTION_REJECTED.add(1);\n// bug_end\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Exception causing close of session 0x\" + Long.toHexString(sessionId) + \": \"+ e.getMessage());\n    }\n    close();\n  }\ncatch (  IOException e) {\n    LOG.warn(\"Exception causing close of session 0x\" + Long.toHexString(sessionId) + \": \"+ e.getMessage());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"IOException stack trace\",e);\n    }\n    close();\n  }\n}\n"}
{"INPUT": "@Override public ServerCallTree selectServerCallTree(Set<TraceId> traceIds){\n  final ServerCallTree tree=new ServerCallTree();\n  List<List<SpanBo>> traces=this.traceDao.selectSpansAndAnnotation(traceIds);\n  for (  List<SpanBo> transaction : traces) {\n    for (    SpanBo eachTransaction : transaction) {\n      tree.addSpan(eachTransaction);\n    }\n  }\n// bug_start\n  return tree;\n// bug_end\n}\n"}
{"INPUT": "private boolean checkConnectionToMaster(Pair<Master,Machine> master){\n  Pair<String,Integer> connectionInfo=master.other().getServer();\n  SocketAddress socketAddr=new InetSocketAddress(connectionInfo.first(),connectionInfo.other());\n  Socket socket=new Socket();\n  try {\n    socket.connect(socketAddr);\n  }\n catch (  Exception e) {\n    getMessageLog().logMessage(\"COULD NOT CONNECT: \" + socketAddr,e);\n    return false;\n  }\n finally {\n    try {\n      socket.close();\n    }\n catch (    IOException e) {\n// bug_start\n      msgLog.logMessage(\"Could not close test socket to \" + socketAddr,e);\n// bug_end\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "@MarshalsPointer public static List<CGImagePropertyDNGData> toObject(Class<? extends CFType> cls,long handle,long flags){\n// bug_start\n  CFArray o=(CFArray)CFType.Marshaler.toObject(cls,handle,flags);\n// bug_end\n  if (o == null) {\n    return null;\n  }\n  List<CGImagePropertyDNGData> list=new ArrayList<>();\n  for (int i=0; i < o.size(); i++) {\n    list.add(new CGImagePropertyDNGData(o.get(i,CFDictionary.class)));\n  }\n  return list;\n}\n"}
{"INPUT": "public void play(CommandBuilder newCommand){\n  int left=voiceRouter.router.getLeftDistance();\n  int time=voiceRouter.router.getLeftTime();\n  if (left > 0) {\n    if (type == ROUTE_CALCULATED) {\n      newCommand.newRouteCalculated(left,time);\n    }\n else     if (type == ROUTE_RECALCULATED) {\n      newCommand.routeRecalculated(left,time);\n    }\n// bug_start\n    VoiceRouter.play(newCommand);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public void createMenuItems(Bundle savedInstanceState){\n  Bundle args=getArguments();\n  boolean snapToRoadEnabled=args.getBoolean(SNAP_TO_ROAD_ENABLED_KEY);\n  boolean addLineMode=args.getBoolean(ADD_LINE_MODE_KEY);\n  items.add(new TitleItem(getString(R.string.shared_string_options)));\n  BaseBottomSheetItem snapToRoadItem=new BottomSheetItemWithCompoundButton.Builder().setChecked(snapToRoadEnabled).setDescription(getString(snapToRoadEnabled ? R.string.shared_string_enabled : R.string.shared_string_disabled)).setIcon(snapToRoadEnabled ? getActiveIcon(R.drawable.ic_action_snap_to_road) : getContentIcon(R.drawable.ic_action_snap_to_road)).setTitle(getString(R.string.snap_to_road)).setLayoutId(R.layout.bottom_sheet_item_with_descr_and_switch_56dp).setOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      if (listener != null) {\n        listener.snapToRoadOnCLick();\n      }\n      dismiss();\n    }\n  }\n).create();\n  items.add(snapToRoadItem);\n  items.add(new DividerHalfItem(getContext()));\n// bug_start\n  if (addLineMode) {\n// bug_end\n    BaseBottomSheetItem saveAsNewSegmentItem=new SimpleBottomSheetItem.Builder().setIcon(getContentIcon(R.drawable.ic_action_polygom_dark)).setTitle(getString(R.string.shared_string_save)).setLayoutId(R.layout.bottom_sheet_item_simple).setOnClickListener(new View.OnClickListener(){\n      @Override public void onClick(      View v){\n        if (listener != null) {\n          listener.addToGpxOnClick();\n        }\n        dismiss();\n      }\n    }\n).create();\n    items.add(saveAsNewSegmentItem);\n  }\n else {\n    BaseBottomSheetItem saveAsNewTrackItem=new SimpleBottomSheetItem.Builder().setIcon(getContentIcon(R.drawable.ic_action_polygom_dark)).setTitle(getString(R.string.shared_string_save_as_gpx)).setLayoutId(R.layout.bottom_sheet_item_simple).setOnClickListener(new View.OnClickListener(){\n      @Override public void onClick(      View v){\n        if (listener != null) {\n          listener.saveAsNewTrackOnClick();\n        }\n        dismiss();\n      }\n    }\n).create();\n    items.add(saveAsNewTrackItem);\n    BaseBottomSheetItem addToTrackItem=new SimpleBottomSheetItem.Builder().setIcon(getContentIcon(R.drawable.ic_action_split_interval)).setTitle(getString(R.string.add_segment_to_the_track)).setLayoutId(R.layout.bottom_sheet_item_simple).setOnClickListener(new View.OnClickListener(){\n      @Override public void onClick(      View v){\n        if (listener != null) {\n          listener.addToTheTrackOnClick();\n        }\n        dismiss();\n      }\n    }\n).create();\n    items.add(addToTrackItem);\n  }\n  items.add(new DividerHalfItem(getContext()));\n  BaseBottomSheetItem clearAllItem=new SimpleBottomSheetItem.Builder().setIcon(getContentIcon(R.drawable.ic_action_reset_to_default_dark)).setTitle(getString(R.string.shared_string_clear_all)).setLayoutId(R.layout.bottom_sheet_item_simple).setOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      if (listener != null) {\n        listener.clearAllOnClick();\n      }\n      dismiss();\n    }\n  }\n).create();\n  items.add(clearAllItem);\n}\n"}
{"INPUT": "@Before public void setupMocks(){\n  index=mock(SamlServiceProviderIndex.class);\n  identityProvider=mock(SamlIdentityProvider.class);\n  serviceProviderDefaults=configureIdentityProviderDefaults();\n// bug_start\n  resolver=new SamlServiceProviderResolver(Settings.EMPTY,index,serviceProviderDefaults);\n// bug_end\n}\n"}
{"INPUT": "public String shortToString(){\n  StringBuilder out=new StringBuilder();\n  out.append(String.format(\"WHEN: %14d THREAD: %s AST: %s\",when,threadName,ownerName()));\n// bug_start\n  if (message != null)   out.append(String.format(message,params));\n// bug_end\n  return out.toString();\n}\n"}
{"INPUT": "public static void assertNotEquals(String message,float unexpected,float actual,float delta){\n  if (!floatIsDifferent(unexpected,actual,delta)) {\n// bug_start\n    failEquals(message,actual);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override synchronized public void merge(IndexWriter writer,MergeTrigger trigger,boolean newMergesFound) throws CorruptIndexException, IOException {\n  int cycle=0;\n  while (cycle++ < maxMergeAtOnce) {\n    MergePolicy.OneMerge merge=writer.getNextMerge();\n    if (merge == null)     break;\n    writer.mergeInit(merge);\n    int totalNumDocs=merge.totalNumDocs();\n// bug_start\n    long totalSizeInBytes=merge.estimatedMergeBytes;\n// bug_end\n    long time=System.currentTimeMillis();\n    currentMerges.inc();\n    currentMergesNumDocs.inc(totalNumDocs);\n    currentMergesSizeInBytes.inc(totalSizeInBytes);\n    OnGoingMerge onGoingMerge=new OnGoingMerge(merge);\n    onGoingMerges.add(onGoingMerge);\n    if (logger.isTraceEnabled()) {\n      logger.trace(\"merge [{}] starting..., merging [{}] segments, [{}] docs, [{}] size, into [{}] estimated_size\",merge.info == null ? \"_na_\" : merge.info.info.name,merge.segments.size(),totalNumDocs,new ByteSizeValue(totalSizeInBytes),new ByteSizeValue(merge.estimatedMergeBytes));\n    }\n    try {\n      beforeMerge(onGoingMerge);\n      writer.merge(merge);\n    }\n  finally {\n      long took=System.currentTimeMillis() - time;\n      onGoingMerges.remove(onGoingMerge);\n      afterMerge(onGoingMerge);\n      currentMerges.dec();\n      currentMergesNumDocs.dec(totalNumDocs);\n      currentMergesSizeInBytes.dec(totalSizeInBytes);\n      totalMergesNumDocs.inc(totalNumDocs);\n      totalMergesSizeInBytes.inc(totalSizeInBytes);\n      totalMerges.inc(took);\n      if (took > 20000) {\n        logger.debug(\"merge [{}] done, took [{}]\",merge.info == null ? \"_na_\" : merge.info.info.name,TimeValue.timeValueMillis(took));\n      }\n else       if (logger.isTraceEnabled()) {\n        logger.trace(\"merge [{}] done, took [{}]\",merge.info == null ? \"_na_\" : merge.info.info.name,TimeValue.timeValueMillis(took));\n      }\n    }\n  }\n}\n"}
{"INPUT": "public void attach(BuildContext context){\n  super.attach(context);\n  if (context == null) {\n    return;\n  }\n  for (  InternalWorkingMemory workingMemory : context.getWorkingMemories()) {\n    PropagationContextFactory pctxFactory=workingMemory.getKnowledgeBase().getConfiguration().getComponentFactory().getPropagationContextFactory();\n// bug_start\n    final PropagationContext propagationContext=pctxFactory.createPropagationContext(workingMemory.getNextPropagationIdCounter(),PropagationContext.RULE_ADDITION,null,null,null);\n// bug_end\n    this.leftInput.updateSink(this,propagationContext,workingMemory);\n  }\n}\n"}
{"INPUT": "private void updateImage(){\n  boolean isPressed=isPressed();\n// bug_start\n  if (isDisabled && style.imageDisabled != null)   image.setDrawable(style.imageDisabled);\n// bug_end\n else   if (isPressed && style.imageDown != null)   image.setDrawable(style.imageDown);\n else   if (isChecked && style.imageChecked != null)   image.setDrawable((style.imageCheckedOver != null && isOver()) ? style.imageCheckedOver : style.imageChecked);\n else   if (isOver() && style.imageOver != null)   image.setDrawable(style.imageOver);\n else   if (style.imageUp != null)   image.setDrawable(style.imageUp);\n}\n"}
{"INPUT": "@MarshalsPointer public static List<UIApplicationLaunchOptions> toObject(Class<? extends NSObject> cls,long handle,long flags){\n// bug_start\n  NSArray<NSDictionary<NSString,NSObject>> o=(NSArray<NSDictionary<NSString,NSObject>>)NSObject.Marshaler.toObject(cls,handle,flags);\n// bug_end\n  if (o == null) {\n    return null;\n  }\n  List<UIApplicationLaunchOptions> list=new ArrayList<>();\n  for (int i=0; i < o.size(); i++) {\n    list.add(new UIApplicationLaunchOptions(o.get(i)));\n  }\n  return list;\n}\n"}
{"INPUT": "public TranscodeInputStream(ProcessBuilder processBuilder,final InputStream in,File tmpFile) throws IOException {\n  this.tmpFile=tmpFile;\n  StringBuffer buf=new StringBuffer(\"Starting transcoder: \");\n  for (  String s : processBuilder.command()) {\n    buf.append('[').append(s).append(\"] \");\n  }\n// bug_start\n  LOG.info(buf);\n// bug_end\n  process=processBuilder.start();\n  processOutputStream=process.getOutputStream();\n  processInputStream=process.getInputStream();\n  final String name=processBuilder.command().get(0);\n  new InputStreamReaderThread(process.getErrorStream(),name,true).start();\n  if (in != null) {\n    new Thread(name + \" TranscodedInputStream copy thread\"){\n      public void run(){\n        try {\n          IOUtils.copy(in,processOutputStream);\n        }\n catch (        IOException x) {\n        }\n finally {\n          IOUtils.closeQuietly(in);\n          IOUtils.closeQuietly(processOutputStream);\n        }\n      }\n    }\n.start();\n  }\n}\n"}
{"INPUT": "@Override public DataSet next(int batchSize){\n  if (useCurrent) {\n    useCurrent=false;\n    return last;\n  }\n  DataSet result;\n  if (useSpecialPreProcessCifar) {\n    result=loader.next(batchSize,exampleCount);\n  }\n else   result=loader.next(batchSize);\n  exampleCount+=batchSize;\n  batchNum++;\n// bug_start\n  if ((result == null || result == new DataSet()) || (maxNumBatches > -1 && batchNum >= maxNumBatches)) {\n// bug_end\n    overshot=true;\n    return last;\n  }\n  if (preProcessor != null)   preProcessor.preProcess(result);\n  last=result;\n  if (loader.getLabels() != null)   result.setLabelNames(loader.getLabels());\n  return result;\n}\n"}
{"INPUT": "public static void main(String[] args){\n  try {\n    if (args == null || args.length == 0) {\n      String config=ConfigUtils.getProperty(CONTAINER_KEY,loader.getDefaultExtensionName());\n      args=Constants.COMMA_SPLIT_PATTERN.split(config);\n    }\n    final List<Container> containers=new ArrayList<Container>();\n    for (int i=0; i < args.length; i++) {\n      containers.add(loader.getExtension(args[i]));\n    }\n    logger.info(\"Use container type(\" + Arrays.toString(args) + \") to run dubbo serivce.\");\n    Runtime.getRuntime().addShutdownHook(new Thread(){\n      public void run(){\n        for (        Container container : containers) {\n          try {\n            container.stop();\n            logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" stopped!\");\n          }\n catch (          Throwable t) {\n            logger.error(t.getMessage(),t);\n          }\nsynchronized (Main.class) {\n            running=false;\n            Main.class.notify();\n          }\n        }\n      }\n    }\n);\n    for (    Container container : containers) {\n      container.start();\n      logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" started!\");\n    }\n    System.out.println(new SimpleDateFormat(\"[yyyy-MM-dd HH:mm:ss]\").format(new Date()) + \" Dubbo service server started!\");\n  }\n catch (  RuntimeException e) {\n    e.printStackTrace();\n    logger.error(e.getMessage(),e);\n// bug_start\n    throw e;\n// bug_end\n  }\nsynchronized (Main.class) {\n    while (running) {\n      try {\n        Main.class.wait();\n      }\n catch (      Throwable e) {\n      }\n    }\n  }\n}\n"}
{"INPUT": "private void createSelectorAndRule(final MetaDataDTO metaDataDTO){\n  String path=metaDataDTO.getPath();\n  String[] splitList=StringUtils.split(path,\"/\");\n  String contextPath=\"/\" + splitList[0];\n  SelectorDO selectorDO=selectorService.findByName(contextPath);\n  String selectorId;\n  if (Objects.isNull(selectorDO)) {\n    SelectorDTO selectorDTO=new SelectorDTO();\n    selectorDTO.setName(contextPath);\n    selectorDTO.setType(SelectorTypeEnum.CUSTOM_FLOW.getCode());\n    selectorDTO.setMatchMode(MatchModeEnum.AND.getCode());\n    selectorDTO.setEnabled(Boolean.TRUE);\n    selectorDTO.setLoged(Boolean.TRUE);\n    selectorDTO.setContinued(Boolean.TRUE);\n    selectorDTO.setSort(1);\n    if (RpcTypeEnum.DUBBO.getName().equals(metaDataDTO.getRpcType())) {\n      selectorDTO.setPluginId(\"6\");\n      DubboSelectorHandle dubboSelectorHandle=new DubboSelectorHandle();\n      dubboSelectorHandle.setAppName(metaDataDTO.getAppName());\n      dubboSelectorHandle.setProtocol(\"dubbo\");\n      dubboSelectorHandle.setPort(20888);\n      dubboSelectorHandle.setRegistry(\"zookeeper://localhost:2181\");\n      selectorDTO.setHandle(JsonUtils.toJson(dubboSelectorHandle));\n    }\n else     if (RpcTypeEnum.SPRING_CLOUD.getName().equals(metaDataDTO.getRpcType())) {\n      selectorDTO.setPluginId(\"8\");\n      selectorDTO.setHandle(metaDataDTO.getAppName());\n    }\n else {\n      selectorDTO.setPluginId(\"5\");\n    }\n    SelectorConditionDTO selectorConditionDTO=new SelectorConditionDTO();\n    selectorConditionDTO.setParamType(ParamTypeEnum.URI.getName());\n    selectorConditionDTO.setParamName(\"/\");\n    selectorConditionDTO.setOperator(OperatorEnum.MATCH.getAlias());\n// bug_start\n    selectorConditionDTO.setParamValue(contextPath);\n// bug_end\n    selectorDTO.setSelectorConditions(Collections.singletonList(selectorConditionDTO));\n    selectorId=selectorService.register(selectorDTO);\n  }\n else {\n    selectorId=selectorDO.getId();\n  }\n  registerRule(selectorId,metaDataDTO.getPath(),metaDataDTO.getRpcType());\n}\n"}
{"INPUT": "public BitfinexTrade toBitfinexTrade(){\n  String type;\n  BigDecimal zero=new BigDecimal(0);\n  if (amount.compareTo(zero) < 0) {\n    type=\"sell\";\n  }\n else {\n    type=\"buy\";\n  }\n// bug_start\n  return new BitfinexTrade(price,amount,timestamp,\"bitfinex\",tradeId,type);\n// bug_end\n}\n"}
{"INPUT": "public void addDiagnostic(BallerinaDiagnostic diagnostic){\n  this.diagnostics.add(diagnostic);\n  if (diagnostic.diagnosticInfo().severity() == DiagnosticSeverity.ERROR) {\n    this.errorCount++;\n  }\n// bug_start\n else   if (diagnostic.severity() == DiagnosticSeverity.WARNING) {\n// bug_end\n    this.warnCount++;\n  }\n}\n"}
{"INPUT": "@Override public Deferred<Object> initialize(final TSDB tsdb,final String id){\n  this.id=Strings.isNullOrEmpty(id) ? TYPE : id;\n  this.tsdb=tsdb;\n  if (!tsdb.getConfig().hasProperty(getConfigKey(MAX_CARD_KEY))) {\n    tsdb.getConfig().register(getConfigKey(MAX_CARD_KEY),4096,true,\"The maximum number of entries to allow for multi-get queries.\");\n  }\n  if (!tsdb.getConfig().hasProperty(getConfigKey(FALLBACK_ON_NO_DATA_KEY))) {\n    tsdb.getConfig().register(getConfigKey(FALLBACK_ON_NO_DATA_KEY),false,true,\"Whether or not to fall back to scans when the meta \" + \"query returns an empty data set.\");\n  }\n  if (!tsdb.getConfig().hasProperty(getConfigKey(FALLBACK_ON_EX_KEY))) {\n    tsdb.getConfig().register(getConfigKey(FALLBACK_ON_EX_KEY),true,true,\"Whether or not to fall back to scans when the meta \" + \"query returns an exception.\");\n  }\n  if (!tsdb.getConfig().hasProperty(getConfigKey(CLIENT_ID))) {\n    tsdb.getConfig().register(getConfigKey(CLIENT_ID),null,false,\"Meta client id.\");\n  }\n  if (!tsdb.getConfig().hasProperty(getConfigKey(SKIP_META))) {\n// bug_start\n    tsdb.getConfig().register(ConfigurationEntrySchema.newBuilder().setKey(SKIP_META).setDefaultValue(Maps.newHashMap()).setDescription(\"TODO\").setType(NAMESPACE_FILTERS).setSource(this.getClass().toString()).isDynamic().build());\n// bug_end\n  }\n  String clientID=tsdb.getConfig().getString(getConfigKey(CLIENT_ID));\n  client=tsdb.getRegistry().getPlugin(MetaClient.class,clientID);\n  if (client == null) {\n    throw new IllegalStateException(\"No client found with id: \" + clientID);\n  }\n  return Deferred.fromResult(null);\n}\n"}
{"INPUT": "@Override public void setRealm(Realm realm){\n  Lock l=realmLock.writeLock();\n  try {\n    l.lock();\n// bug_start\n    Realm oldRealm=realm;\n// bug_end\n    if (oldRealm == realm)     return;\n    this.realm=realm;\n    if (getState().isAvailable() && (oldRealm != null) && (oldRealm instanceof Lifecycle)) {\n      try {\n        ((Lifecycle)oldRealm).stop();\n      }\n catch (      LifecycleException e) {\n        log.error(\"ContainerBase.setRealm: stop: \",e);\n      }\n    }\n    if (realm != null)     realm.setContainer(this);\n    if (getState().isAvailable() && (realm != null) && (realm instanceof Lifecycle)) {\n      try {\n        ((Lifecycle)realm).start();\n      }\n catch (      LifecycleException e) {\n        log.error(\"ContainerBase.setRealm: start: \",e);\n      }\n    }\n    support.firePropertyChange(\"realm\",oldRealm,this.realm);\n  }\n  finally {\n    l.unlock();\n  }\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") @MarshalsPointer public static List<AVAudioSessionCategory> toObject(Class<? extends NSObject> cls,long handle,long flags){\n// bug_start\n  NSArray<NSString> o=(NSArray<NSString>)NSObject.Marshaler.toObject(cls,handle,flags);\n// bug_end\n  if (o == null) {\n    return null;\n  }\n  List<AVAudioSessionCategory> list=new ArrayList<>();\n  for (int i=0; i < o.size(); i++) {\n    list.add(AVAudioSessionCategory.valueOf(o.get(i)));\n  }\n  return list;\n}\n"}
{"INPUT": "@Override public void executeCommand(Command command,ExecutionHandlerContext context){\n  int numberOfAdds=0;\n  List<byte[]> commandElems=command.getProcessedCommand();\n  ByteArrayWrapper key=command.getKey();\n  if (commandElems.size() < 5 || ((commandElems.size() - 2) % 3) != 0) {\n    command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),RedisConstants.ArityDef.GEOADD));\n    return;\n  }\n  Region<ByteArrayWrapper,ByteArrayWrapper> keyRegion=getOrCreateRegion(context,key,RedisDataType.REDIS_SORTEDSET);\n  Map<ByteArrayWrapper,ByteArrayWrapper> tempMap=new HashMap<>();\n  for (int i=2; i < commandElems.size(); i+=3) {\n    byte[] longitude=commandElems.get(i);\n    byte[] latitude=commandElems.get(i + 1);\n    byte[] member=commandElems.get(i + 2);\n    String score;\n    try {\n      score=GeoCoder.geohash(longitude,latitude);\n    }\n catch (    IllegalArgumentException e) {\n      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),\"ERR \" + ERROR_INVALID_LATLONG + \" \"+ longitude.toString()+ \" \"+ latitude.toString()));\n      return;\n    }\n    tempMap.put(new ByteArrayWrapper(member),new ByteArrayWrapper(score.getBytes()));\n  }\n  for (  ByteArrayWrapper m : tempMap.keySet()) {\n    Object oldVal=keyRegion.put(m,tempMap.get(m));\n// bug_start\n    if (oldVal == null)     numberOfAdds++;\n// bug_end\n  }\n  command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(),numberOfAdds));\n}\n"}
{"INPUT": "PlainSocketImpl(FileDescriptor fd){\n// bug_start\n  if (useDualStackImpl) {\n// bug_end\n    impl=new DualStackPlainSocketImpl(fd,exclusiveBind);\n  }\n else {\n    impl=new TwoStacksPlainSocketImpl(fd,exclusiveBind);\n  }\n}\n"}
{"INPUT": "@Override public boolean process(byte value) throws Exception {\n// bug_start\n  char nextByte=(char)value;\n// bug_end\n  if (nextByte == HttpConstants.CR) {\n    return true;\n  }\n  if (nextByte == HttpConstants.LF) {\n    return false;\n  }\n  if (++size > maxLength) {\n    throw newException(maxLength);\n  }\n  seq.append(nextByte);\n  return true;\n}\n"}
{"INPUT": "public static byte[] getRecordBytes(OClientConnection connection,final ORecord iRecord){\n  final byte[] stream;\n  String dbSerializerName=null;\n// bug_start\n  if (ODatabaseRecordThreadLocal.INSTANCE.getIfDefined() != null)   dbSerializerName=((ODatabaseDocumentInternal)iRecord.getDatabase()).getSerializer().toString();\n// bug_end\n  String name=connection.getData().getSerializationImpl();\n  if (ORecordInternal.getRecordType(iRecord) == ODocument.RECORD_TYPE && (dbSerializerName == null || !dbSerializerName.equals(name))) {\n    ((ODocument)iRecord).deserializeFields();\n    ORecordSerializer ser=ORecordSerializerFactory.instance().getFormat(name);\n    stream=ser.toStream(iRecord,false);\n  }\n else   stream=iRecord.toStream();\n  return stream;\n}\n"}
{"INPUT": "@Override protected HttpObject filter(HttpObject obj){\n  if (!(obj instanceof HttpHeaders)) {\n    return obj;\n  }\n  final HttpHeaders headers=(HttpHeaders)obj;\n  final HttpStatus status=headers.status();\n  if (status == null || status.codeClass() == HttpStatusClass.INFORMATIONAL) {\n    return headers;\n  }\n  final HttpHeaders mutableHeaders=headers.toMutable();\n  setCorsResponseHeaders(ctx,req,mutableHeaders);\n// bug_start\n  return mutableHeaders;\n// bug_end\n}\n"}
{"INPUT": "private RestRequest getRequestFromUrl(RestMethod restMethod,String url) throws Exception {\n  JSONObject request=new JSONObject();\n// bug_start\n  request.put(MockRestRequest.REST_METHOD_KEY,restMethod);\n// bug_end\n  request.put(MockRestRequest.URI_KEY,url);\n  return new MockRestRequest(request,null);\n}\n"}
{"INPUT": "@SuppressFBWarnings({\"IS2_INCONSISTENT_SYNC\",\"DC_DOUBLECHECK\"}) public KubernetesClient connect() throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, IOException, CertificateEncodingException {\n  LOGGER.log(Level.FINE,\"Building connection to Kubernetes {0} URL {1} namespace {2}\",new String[]{getDisplayName(),serverUrl,namespace});\n  KubernetesClient client=KubernetesClientProvider.createClient(this);\n// bug_start\n  LOGGER.log(Level.FINE,\"Connected to Kubernetes {0} URL {1}\",new String[]{getDisplayName(),serverUrl});\n// bug_end\n  return client;\n}\n"}
{"INPUT": "@Override public BackendResponse execute() throws SQLException {\n  SchemaContext schemaContext=ProxyContext.getInstance().getSchema(backendConnection.getSchemaName());\n  if (null == schemaContext) {\n    throw new NoDatabaseSelectedException();\n  }\n// bug_start\n  if (!schemaContext.isComplete()) {\n// bug_end\n    return getDefaultQueryResponse(backendConnection.getSchemaName());\n  }\n  databaseCommunicationEngine=databaseCommunicationEngineFactory.newTextProtocolInstance(sqlStatement,sql,backendConnection);\n  return databaseCommunicationEngine.execute();\n}\n"}
{"INPUT": "private Response forwardToPage(String path,AccountPages page){\n  if (auth != null) {\n    try {\n      auth.require(AccountRoles.MANAGE_ACCOUNT);\n    }\n catch (    ForbiddenException e) {\n      return session.getProvider(LoginFormsProvider.class).setError(Messages.NO_ACCESS).createErrorPage(Response.Status.FORBIDDEN);\n    }\n    setReferrerOnPage();\n    UserSessionModel userSession=auth.getSession();\n// bug_start\n    String tabId=request.getUri().getQueryParameters().getFirst(org.keycloak.models.Constants.TAB_ID);\n// bug_end\n    if (tabId != null) {\n      AuthenticationSessionModel authSession=new AuthenticationSessionManager(session).getAuthenticationSessionByIdAndClient(realm,userSession.getId(),client,tabId);\n      if (authSession != null) {\n        String forwardedError=authSession.getAuthNote(ACCOUNT_MGMT_FORWARDED_ERROR_NOTE);\n        if (forwardedError != null) {\n          try {\n            FormMessage errorMessage=JsonSerialization.readValue(forwardedError,FormMessage.class);\n            account.setError(Response.Status.INTERNAL_SERVER_ERROR,errorMessage.getMessage(),errorMessage.getParameters());\n            authSession.removeAuthNote(ACCOUNT_MGMT_FORWARDED_ERROR_NOTE);\n          }\n catch (          IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      }\n    }\n    return account.createResponse(page);\n  }\n else {\n    return login(path);\n  }\n}\n"}
{"INPUT": "public WorkflowTypeInfo unmarshall(JsonUnmarshallerContext context) throws Exception {\n  WorkflowTypeInfo workflowTypeInfo=new WorkflowTypeInfo();\n  int originalDepth=context.getCurrentDepth();\n  String currentParentElement=context.getCurrentParentElement();\n  int targetDepth=originalDepth + 1;\n// bug_start\n  JsonToken token=context.currentToken;\n// bug_end\n  if (token == null)   token=context.nextToken();\n  if (token == VALUE_NULL)   return null;\n  while (true) {\n    if (token == null)     break;\n    if (token == FIELD_NAME || token == START_OBJECT) {\n      if (context.testExpression(\"workflowType\",targetDepth)) {\n        context.nextToken();\n        workflowTypeInfo.setWorkflowType(WorkflowTypeJsonUnmarshaller.getInstance().unmarshall(context));\n      }\n      if (context.testExpression(\"status\",targetDepth)) {\n        context.nextToken();\n        workflowTypeInfo.setStatus(StringJsonUnmarshaller.getInstance().unmarshall(context));\n      }\n      if (context.testExpression(\"description\",targetDepth)) {\n        context.nextToken();\n        workflowTypeInfo.setDescription(StringJsonUnmarshaller.getInstance().unmarshall(context));\n      }\n      if (context.testExpression(\"creationDate\",targetDepth)) {\n        context.nextToken();\n        workflowTypeInfo.setCreationDate(DateJsonUnmarshaller.getInstance().unmarshall(context));\n      }\n      if (context.testExpression(\"deprecationDate\",targetDepth)) {\n        context.nextToken();\n        workflowTypeInfo.setDeprecationDate(DateJsonUnmarshaller.getInstance().unmarshall(context));\n      }\n    }\n else     if (token == END_ARRAY || token == END_OBJECT) {\n      if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n        if (context.getCurrentDepth() <= originalDepth)         break;\n      }\n    }\n    token=context.nextToken();\n  }\n  return workflowTypeInfo;\n}\n"}
{"INPUT": "@Override public boolean matches(BinaryTree tree,VisitorState state){\n  if (tree.getKind() != Kind.EQUAL_TO && tree.getKind() != Kind.NOT_EQUAL_TO) {\n    return false;\n  }\n  List<ExpressionTree> binaryTreeMatches=ASTHelpers.matchBinaryTree(tree,Arrays.asList(Matchers.<ExpressionTree>isInstance(JCLiteral.class),Matchers.<ExpressionTree>isSameType(comparisonType)),state);\n  if (binaryTreeMatches == null) {\n    return false;\n  }\n  JCLiteral literal=(JCLiteral)binaryTreeMatches.get(0);\n  Object literalValue=literal.getValue();\nswitch (literal.getKind()) {\ncase DOUBLE_LITERAL:\n    double doubleValue=((Double)literalValue).doubleValue();\n  return doubleValue < minValue || doubleValue > maxValue;\ncase FLOAT_LITERAL:\nfloat floatValue=((Float)literalValue).floatValue();\nreturn floatValue < minValue || floatValue > maxValue;\ncase LONG_LITERAL:\nlong longValue=((Long)literalValue).longValue();\nreturn longValue < minValue || longValue > maxValue;\ndefault :\nint intValue;\nif (literalValue instanceof Integer) {\nintValue=((Integer)literalValue).intValue();\n}\n else if (literalValue instanceof Character) {\nintValue=((Character)literalValue).charValue();\n}\n else if (literalValue instanceof Boolean) {\nthrow new IllegalStateException(\"Cannot compare \" + comparisonType + \" to boolean literal\");\n}\n else {\n// bug_start\nthrow new IllegalStateException(\"Unexpected literal type: \" + literal);\n// bug_end\n}\nreturn intValue < minValue || intValue > maxValue;\n}\n}\n"}
{"INPUT": "@Test public void equality(){\n  ConnectivityStateInfo info1=ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n  ConnectivityStateInfo info2=ConnectivityStateInfo.forNonError(ConnectivityState.CONNECTING);\n  ConnectivityStateInfo info3=ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n  ConnectivityStateInfo info4=ConnectivityStateInfo.forTransientFailure(Status.UNAVAILABLE);\n  ConnectivityStateInfo info5=ConnectivityStateInfo.forTransientFailure(Status.INTERNAL);\n  ConnectivityStateInfo info6=ConnectivityStateInfo.forTransientFailure(Status.INTERNAL);\n  assertEquals(info1,info3);\n  assertNotSame(info1,info3);\n  assertEquals(info1.hashCode(),info3.hashCode());\n  assertEquals(info5,info6);\n  assertEquals(info5.hashCode(),info6.hashCode());\n  assertNotSame(info5,info6);\n  assertNotEquals(info1,info2);\n  assertNotEquals(info1,info4);\n  assertNotEquals(info4,info6);\n  assertFalse(info1.equals(null));\n// bug_start\n  assertFalse(info1.equals(this));\n// bug_end\n}\n"}
{"INPUT": "@Override public void onConstruct(EnhancedClassInstanceContext context,ConstructorInvokeContext interceptorContext){\n  StringBuilder redisConnInfo=new StringBuilder();\n  Set<HostAndPort> hostAndPorts=(Set<HostAndPort>)interceptorContext.allArguments()[0];\n  for (  HostAndPort hostAndPort : hostAndPorts) {\n    redisConnInfo.append(hostAndPort.toString()).append(\";\");\n  }\n  context.set(JedisMethodInterceptor.KEY_OF_REDIS_CONN_INFO,redisConnInfo.toString());\n// bug_start\n  context.set(JedisMethodInterceptor.KEY_OF_REDIS_HOSTS,redisConnInfo);\n// bug_end\n}\n"}
{"INPUT": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder(super.toString());\n// bug_start\n  sb.append(\"writer=\").append(writer).append(\"\\n\");\n// bug_end\n  return sb.toString();\n}\n"}
{"INPUT": "public ShardReplicationOperationRequest(T request){\n  super(request);\n  this.timeout=request.timeout();\n  this.index=request.index();\n// bug_start\n  this.threadedOperation=request.threadedOperation;\n// bug_end\n  this.replicationType=request.replicationType();\n  this.consistencyLevel=request.consistencyLevel();\n}\n"}
{"INPUT": "public static synchronized List<MediaCodecInfo> getDecoderInfos(String mimeType,boolean secure,boolean tunneling) throws DecoderQueryException {\n  CodecKey key=new CodecKey(mimeType,secure,tunneling);\n  List<MediaCodecInfo> cachedDecoderInfos=decoderInfosCache.get(key);\n  if (cachedDecoderInfos != null) {\n    return cachedDecoderInfos;\n  }\n  MediaCodecListCompat mediaCodecList=Util.SDK_INT >= 21 ? new MediaCodecListCompatV21(secure,tunneling) : new MediaCodecListCompatV16();\n  ArrayList<MediaCodecInfo> decoderInfos=getDecoderInfosInternal(key,mediaCodecList,mimeType);\n  if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {\n    mediaCodecList=new MediaCodecListCompatV16();\n    decoderInfos=getDecoderInfosInternal(key,mediaCodecList,mimeType);\n    if (!decoderInfos.isEmpty()) {\n      Log.w(TAG,\"MediaCodecList API didn't list secure decoder for: \" + mimeType + \". Assuming: \"+ decoderInfos.get(0).name);\n    }\n  }\n  if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {\n    CodecKey eac3Key=new CodecKey(MimeTypes.AUDIO_E_AC3,key.secure,key.tunneling);\n// bug_start\n    ArrayList<MediaCodecInfo> eac3DecoderInfos=getDecoderInfosInternal(eac3Key,mediaCodecList,mimeType);\n// bug_end\n    decoderInfos.addAll(eac3DecoderInfos);\n  }\n  applyWorkarounds(mimeType,decoderInfos);\n  List<MediaCodecInfo> unmodifiableDecoderInfos=Collections.unmodifiableList(decoderInfos);\n  decoderInfosCache.put(key,unmodifiableDecoderInfos);\n  return unmodifiableDecoderInfos;\n}\n"}
{"INPUT": "void updateTaskStatuses(TaskTrackerStatus status){\n  String trackerName=status.getTrackerName();\n  for (  TaskStatus report : status.getTaskReports()) {\n    report.setTaskTracker(trackerName);\n    TaskAttemptID taskId=report.getTaskID();\n    expireLaunchingTasks.removeTask(taskId);\n    JobInProgress job=getJob(taskId.getJobID());\n    if (job == null) {\nsynchronized (trackerToJobsToCleanup) {\n        Set<JobID> jobs=trackerToJobsToCleanup.get(trackerName);\n        if (jobs == null) {\n          jobs=new HashSet<JobID>();\n          trackerToJobsToCleanup.put(trackerName,jobs);\n        }\n        jobs.add(taskId.getJobID());\n      }\n      continue;\n    }\n    TaskInProgress tip=taskidToTIPMap.get(taskId);\n    if (tip != null || hasRestarted()) {\n      if (tip == null) {\n        tip=job.getTaskInProgress(taskId.getTaskID());\n        job.addRunningTaskToTIP(tip,taskId,status,false);\n      }\n      JobStatus prevStatus=(JobStatus)job.getStatus().clone();\n// bug_start\n      job.updateTaskStatus(tip,report,myInstrumentation);\n// bug_end\n      JobStatus newStatus=(JobStatus)job.getStatus().clone();\n      if (prevStatus.getRunState() != newStatus.getRunState()) {\n        JobStatusChangeEvent event=new JobStatusChangeEvent(job,EventType.RUN_STATE_CHANGED,prevStatus,newStatus);\n        updateJobInProgressListeners(event);\n      }\n    }\n else {\n      LOG.info(\"Serious problem.  While updating status, cannot find taskid \" + report.getTaskID());\n    }\n    List<TaskAttemptID> failedFetchMaps=report.getFetchFailedMaps();\n    if (failedFetchMaps != null) {\n      for (      TaskAttemptID mapTaskId : failedFetchMaps) {\n        TaskInProgress failedFetchMap=taskidToTIPMap.get(mapTaskId);\n        if (failedFetchMap != null) {\n          String failedFetchTrackerName=getAssignedTracker(mapTaskId);\n          if (failedFetchTrackerName == null) {\n            failedFetchTrackerName=\"Lost task tracker\";\n          }\n          failedFetchMap.getJob().fetchFailureNotification(failedFetchMap,mapTaskId,failedFetchTrackerName,myInstrumentation);\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Test public void newStream_duringShutdown() throws Exception {\n  server.start(serverListener);\n  client=newClientTransport(server);\n  runIfNotNull(client.start(mockClientTransportListener));\n  ClientStream stream=client.newStream(methodDescriptor,new Metadata());\n  stream.start(mockClientStreamListener);\n  client.shutdown();\n  verify(mockClientTransportListener,timeout(TIMEOUT_MS)).transportShutdown(any(Status.class));\n  ClientStream stream2=client.newStream(methodDescriptor,new Metadata());\n  ClientStreamListener mockClientStreamListener2=mock(ClientStreamListener.class);\n  stream2.start(mockClientStreamListener2);\n  verify(mockClientStreamListener2,timeout(TIMEOUT_MS)).closed(statusCaptor.capture(),any(Metadata.class));\n  assertCodeEquals(Status.UNAVAILABLE,statusCaptor.getValue());\n  MockServerTransportListener serverTransportListener=serverListener.takeListenerOrFail(TIMEOUT_MS,TimeUnit.MILLISECONDS);\n  serverTransport=serverTransportListener.transport;\n// bug_start\n  StreamCreation serverStreamCreation=serverTransportListener.takeStreamOrFail(TIMEOUT_MS,TimeUnit.MILLISECONDS);\n// bug_end\n  serverStreamCreation.stream.close(Status.OK,new Metadata());\n  verify(mockClientStreamListener,timeout(TIMEOUT_MS)).closed(statusCaptor.capture(),any(Metadata.class));\n  assertCodeEquals(Status.OK,statusCaptor.getValue());\n}\n"}
{"INPUT": "public void testDefaultFieldParsing() throws IOException {\n// bug_start\n  assumeTrue(\"5.x behaves differently, so skip on non-6.x indices\",indexVersionCreated.onOrAfter(Version.V_6_0_0_alpha1));\n// bug_end\n  String query=randomAlphaOfLengthBetween(1,10).toLowerCase(Locale.ROOT);\n  String contentString=\"{\\n\" + \"    \\\"simple_query_string\\\" : {\\n\" + \"      \\\"query\\\" : \\\"\" + query + \"\\\"\"+ \"    }\\n\"+ \"}\";\n  SimpleQueryStringBuilder queryBuilder=(SimpleQueryStringBuilder)parseQuery(contentString);\n  assertThat(queryBuilder.value(),equalTo(query));\n  assertThat(queryBuilder.fields(),notNullValue());\n  assertThat(queryBuilder.fields().size(),equalTo(0));\n  QueryShardContext shardContext=createShardContext();\n  Query luceneQuery=queryBuilder.toQuery(shardContext);\n  assertThat(luceneQuery,anyOf(instanceOf(BooleanQuery.class),instanceOf(DisjunctionMaxQuery.class)));\n}\n"}
{"INPUT": "public CreatePipelineResult unmarshall(JsonUnmarshallerContext context) throws Exception {\n  CreatePipelineResult createPipelineResult=new CreatePipelineResult();\n  int originalDepth=context.getCurrentDepth();\n  String currentParentElement=context.getCurrentParentElement();\n  int targetDepth=originalDepth + 1;\n// bug_start\n  JsonToken token=context.currentToken;\n// bug_end\n  if (token == null)   token=context.nextToken();\n  if (token == VALUE_NULL)   return null;\n  while (true) {\n    if (token == null)     break;\n    if (token == FIELD_NAME || token == START_OBJECT) {\n      if (context.testExpression(\"pipelineId\",targetDepth)) {\n        context.nextToken();\n        createPipelineResult.setPipelineId(StringJsonUnmarshaller.getInstance().unmarshall(context));\n      }\n    }\n else     if (token == END_ARRAY || token == END_OBJECT) {\n      if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n        if (context.getCurrentDepth() <= originalDepth)         break;\n      }\n    }\n    token=context.nextToken();\n  }\n  return createPipelineResult;\n}\n"}
{"INPUT": "public Consumer(Subscription subscription,SubType subType,String topicName,long consumerId,int priorityLevel,String consumerName,int maxUnackedMessages,ServerCnx cnx,String appId,Map<String,String> metadata,boolean readCompacted,InitialPosition subscriptionInitialPosition,PulsarApi.KeySharedMeta keySharedMeta) throws BrokerServiceException {\n  this.subscription=subscription;\n  this.subType=subType;\n  this.topicName=topicName;\n  this.partitionIdx=TopicName.getPartitionIndex(topicName);\n  this.consumerId=consumerId;\n  this.priorityLevel=priorityLevel;\n  this.readCompacted=readCompacted;\n  this.consumerName=consumerName;\n  this.maxUnackedMessages=maxUnackedMessages;\n  this.subscriptionInitialPosition=subscriptionInitialPosition;\n  this.keySharedMeta=keySharedMeta;\n  this.cnx=cnx;\n  this.msgOut=new Rate();\n  this.chuckedMessageRate=new Rate();\n  this.msgRedeliver=new Rate();\n  this.bytesOutCounter=new LongAdder();\n  this.msgOutCounter=new LongAdder();\n  this.appId=appId;\n// bug_start\n  this.authenticationData=cnx.authenticationData;\n// bug_end\n  this.preciseDispatcherFlowControl=cnx.isPreciseDispatcherFlowControl();\n  PERMITS_RECEIVED_WHILE_CONSUMER_BLOCKED_UPDATER.set(this,0);\n  MESSAGE_PERMITS_UPDATER.set(this,0);\n  UNACKED_MESSAGES_UPDATER.set(this,0);\n  AVG_MESSAGES_PER_ENTRY.set(this,1000);\n  this.metadata=metadata != null ? metadata : Collections.emptyMap();\n  stats=new ConsumerStats();\n  stats.setAddress(cnx.clientAddress().toString());\n  stats.consumerName=consumerName;\n  stats.setConnectedSince(DateFormatter.now());\n  stats.setClientVersion(cnx.getClientVersion());\n  stats.metadata=this.metadata;\n  if (Subscription.isIndividualAckMode(subType)) {\n    this.pendingAcks=new ConcurrentLongLongPairHashMap(256,1);\n  }\n else {\n    this.pendingAcks=null;\n  }\n}\n"}
{"INPUT": "@Test public void testExtract() throws Exception {\n  for (  DateTime left : dateTimeValues) {\n    for (    Field field : Field.values()) {\n      Long expected=null;\n      Long millis=null;\n      if (left != null) {\n        millis=left.getMillis();\n// bug_start\n        expected=callExtractFunction(SESSION,millis,field);\n// bug_end\n      }\n      assertExecute(generateExpression(\"extract(\" + field.toString() + \" from from_unixtime(%s / 1000.0, 0, 0))\",millis),expected);\n    }\n  }\n  Futures.allAsList(futures).get();\n}\n"}
{"INPUT": "@Override protected void onLayout(boolean changed,int l,int t,int r,int b){\n  mInLayout=true;\n  final int width=r - l;\n  final int childCount=getChildCount();\n  for (int i=0; i < childCount; i++) {\n    final View child=getChildAt(i);\n    if (child.getVisibility() == GONE) {\n      continue;\n    }\n    final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n    if (isContentView(child)) {\n      child.layout(lp.leftMargin,lp.topMargin,lp.leftMargin + child.getMeasuredWidth(),lp.topMargin + child.getMeasuredHeight());\n    }\n else {\n      final int childWidth=child.getMeasuredWidth();\n      final int childHeight=child.getMeasuredHeight();\n      int childLeft;\n      final float newOffset;\n      if (checkDrawerViewGravity(child,Gravity.LEFT)) {\n        childLeft=-childWidth + (int)(childWidth * lp.onScreen);\n        newOffset=(float)(childWidth + childLeft) / childWidth;\n      }\n else {\n        childLeft=width - (int)(childWidth * lp.onScreen);\n        newOffset=(float)(width - childLeft) / childWidth;\n      }\n      final boolean changeOffset=newOffset != lp.onScreen;\n      final int vgrav=lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;\nswitch (vgrav) {\ndefault :\ncase Gravity.TOP:\n{\n// bug_start\n          child.layout(childLeft,lp.topMargin,childLeft + childWidth,childHeight);\n// bug_end\n          break;\n        }\ncase Gravity.BOTTOM:\n{\n        final int height=b - t;\n        child.layout(childLeft,height - lp.bottomMargin - child.getMeasuredHeight(),childLeft + childWidth,height - lp.bottomMargin);\n        break;\n      }\ncase Gravity.CENTER_VERTICAL:\n{\n      final int height=b - t;\n      int childTop=(height - childHeight) / 2;\n      if (childTop < lp.topMargin) {\n        childTop=lp.topMargin;\n      }\n else       if (childTop + childHeight > height - lp.bottomMargin) {\n        childTop=height - lp.bottomMargin - childHeight;\n      }\n      child.layout(childLeft,childTop,childLeft + childWidth,childTop + childHeight);\n      break;\n    }\n}\nif (changeOffset) {\n  setDrawerViewOffset(child,newOffset);\n}\nfinal int newVisibility=lp.onScreen > 0 ? VISIBLE : INVISIBLE;\nif (child.getVisibility() != newVisibility) {\n  child.setVisibility(newVisibility);\n}\n}\n}\nmInLayout=false;\nmFirstLayout=false;\n}\n"}
{"INPUT": "@Override public void shutdown(DBRProgressMonitor monitor){\n  super.shutdown(monitor);\n  String paramShutdown=CommonUtils.toString(getContainer().getDriver().getDriverParameter(GenericConstants.PARAM_SHUTDOWN_URL_PARAM));\n  if (!CommonUtils.isEmpty(paramShutdown)) {\n    monitor.subTask(\"Shutdown embedded database\");\n    try {\n      final Driver driver=getDriverInstance(VoidProgressMonitor.INSTANCE);\n      if (driver != null) {\n        driver.connect(getContainer().getActualConnectionConfiguration().getUrl() + paramShutdown,null);\n      }\n    }\n catch (    Exception e) {\n// bug_start\n      log.debug(e);\n// bug_end\n    }\n    monitor.worked(1);\n  }\n}\n"}
{"INPUT": "public AdHocChatRoom createAdHocChatRoom(String adHocRoomName,List<String> contacts,String reason) throws OperationFailedException, OperationNotSupportedException {\n// bug_start\n  AdHocChatRoom adHocChatRoom=createAdHocChatRoom(adHocRoomName,new Hashtable<String,Object>());\n// bug_end\n  if (adHocChatRoom != null && contacts != null) {\n    for (    String address : contacts) {\n      adHocChatRoom.invite(address,reason);\n    }\n  }\n  return adHocChatRoom;\n}\n"}
{"INPUT": "@Test public void findDepsFromParams(){\n  BuildTarget gtest=BuildTargetFactory.newInstance(\"//:gtest\");\n  FakeBuckConfig buckConfig=new FakeBuckConfig(ImmutableMap.<String,Map<String,String>>of(\"cxx\",ImmutableMap.of(\"gtest_dep\",gtest.toString())));\n  CxxBuckConfig cxxBuckConfig=new CxxBuckConfig(buckConfig);\n// bug_start\n  CxxPlatform cxxPlatform=DefaultCxxPlatforms.build(buckConfig);\n// bug_end\n  CxxTestDescription desc=new CxxTestDescription(cxxBuckConfig,cxxPlatform,new FlavorDomain<>(\"platform\",ImmutableMap.<Flavor,CxxPlatform>of()));\n  BuildTarget target=BuildTargetFactory.newInstance(\"//:target\");\n  CxxTestDescription.Arg constructorArg=desc.createUnpopulatedConstructorArg();\n  constructorArg.framework=Optional.of(CxxTestType.GTEST);\n  constructorArg.lexSrcs=Optional.of(ImmutableList.<SourcePath>of());\n  Iterable<BuildTarget> implicit=desc.findDepsForTargetFromConstructorArgs(target,constructorArg);\n  assertTrue(Iterables.contains(implicit,gtest));\n}\n"}
{"INPUT": "private DataContainer handleDynParts(Hive db,Table table,LoadTableDesc tbd,TaskInformation ti,DynamicPartitionCtx dpCtx) throws HiveException, IOException, InvalidOperationException {\n  DataContainer dc;\n  List<LinkedHashMap<String,String>> dps=Utilities.getFullDPSpecs(conf,dpCtx);\n  console.printInfo(System.getProperty(\"line.separator\"));\n  long startTime=System.currentTimeMillis();\n  if (tbd.isMmTable() && !tbd.isCommitMmWrite()) {\n    throw new HiveException(\"Only single-partition LoadTableDesc can skip commiting write ID\");\n  }\n  Map<Map<String,String>,Partition> dp=db.loadDynamicPartitions(tbd.getSourcePath(),tbd.getTable().getTableName(),tbd.getPartitionSpec(),tbd.getReplace(),dpCtx.getNumDPCols(),(tbd.getLbCtx() == null) ? 0 : tbd.getLbCtx().calculateListBucketingLevel(),work.getLoadTableWork().getWriteType() != AcidUtils.Operation.NOT_ACID && work.getLoadTableWork().getWriteType() != AcidUtils.Operation.INSERT_ONLY,SessionState.get().getTxnMgr().getCurrentTxnId(),hasFollowingStatsTask(),work.getLoadTableWork().getWriteType(),tbd.getMmWriteId());\n  if (dps != null && dps.size() > 0) {\n// bug_start\n    pushFeed(FeedType.DYNAMIC_PARTITIONS,dps);\n// bug_end\n  }\n  String loadTime=\"\\t Time taken to load dynamic partitions: \" + (System.currentTimeMillis() - startTime) / 1000.0 + \" seconds\";\n  console.printInfo(loadTime);\n  LOG.info(loadTime);\n  if (dp.size() == 0 && conf.getBoolVar(HiveConf.ConfVars.HIVE_ERROR_ON_EMPTY_PARTITION)) {\n    throw new HiveException(\"This query creates no partitions.\" + \" To turn off this error, set hive.error.on.empty.partition=false.\");\n  }\n  startTime=System.currentTimeMillis();\n  for (  Map.Entry<Map<String,String>,Partition> entry : dp.entrySet()) {\n    Partition partn=entry.getValue();\n    if (ti.bucketCols != null || ti.sortCols != null) {\n      updatePartitionBucketSortColumns(db,table,partn,ti.bucketCols,ti.numBuckets,ti.sortCols);\n    }\n    WriteEntity enty=new WriteEntity(partn,getWriteType(tbd,work.getLoadTableWork().getWriteType()));\n    if (work.getOutputs() != null) {\n      DDLTask.addIfAbsentByName(enty,work.getOutputs());\n    }\n    if (queryPlan.getOutputs() == null) {\n      queryPlan.setOutputs(new LinkedHashSet<WriteEntity>());\n    }\n    queryPlan.getOutputs().add(enty);\n    dc=new DataContainer(table.getTTable(),partn.getTPartition());\n    if (SessionState.get() != null && work.getLoadTableWork().getWriteType() != AcidUtils.Operation.DELETE && work.getLoadTableWork().getWriteType() != AcidUtils.Operation.UPDATE) {\n      SessionState.get().getLineageState().setLineage(tbd.getSourcePath(),dc,table.getCols());\n    }\n    LOG.info(\"\\tLoading partition \" + entry.getKey());\n  }\n  console.printInfo(\"\\t Time taken for adding to write entity : \" + (System.currentTimeMillis() - startTime) / 1000.0 + \" seconds\");\n  dc=null;\n  return dc;\n}\n"}
{"INPUT": "public int pop(){\n  int tmp=arr[frontIndex];\n  frontIndex++;\n  int smallerSize=(int)(arr.length / factor);\n  if (frontIndex > smallerSize) {\n    endIndexPlusOne=size();\n// bug_start\n    int[] newArr=new int[endIndexPlusOne];\n// bug_end\n    System.arraycopy(arr,frontIndex,newArr,0,endIndexPlusOne);\n    arr=newArr;\n    frontIndex=0;\n  }\n  return tmp;\n}\n"}
{"INPUT": "private static ImmutableList<Fix> literalReplacement(MethodInvocationTree methodInvocationTree,VisitorState state,ExpressionTree lhs){\n  Tree parent=state.getPath().getParentPath().getLeaf();\n  if (parent instanceof ExpressionStatementTree) {\n    Fix fix;\n    if (instanceMethod().anyClass().named(\"removeAll\").matches(methodInvocationTree,state)) {\n// bug_start\n      fix=SuggestedFix.replace(methodInvocationTree,lhs + \".clear()\");\n// bug_end\n    }\n else {\n      fix=SuggestedFix.delete(parent);\n    }\n    return ImmutableList.of(fix);\n  }\n  return ImmutableList.of();\n}\n"}
{"INPUT": "@Override public SDVariable defineLayer(SameDiff sd,SDVariable layerInput,Map<String,SDVariable> paramTable){\n  SDVariable weights=paramTable.get(DefaultParamInitializer.WEIGHT_KEY);\n  SDVariable logits=sd.tensorMmul(layerInput,weights,new int[][]{{2},{0}});\n  SDVariable reshapedLogits=sd.reshape(logits,layerInput.getShape()[0],layerInput.getShape()[1]);\n// bug_start\n  SDVariable ai=sd.exp(reshapedLogits);\n// bug_end\n  SDVariable aiSum=sd.sum(ai,1);\n  SDVariable aiSumEps=sd.expandDims(aiSum.add(EPS),1);\n  SDVariable attentionWeights=ai.div(aiSumEps);\n  SDVariable weightedInput=layerInput.mul(sd.expandDims(attentionWeights,2));\n  return sd.sum(weightedInput,2);\n}\n"}
{"INPUT": "@Override protected void doInternalXContent(XContentBuilder builder,Params params) throws IOException {\n  if (percents != null) {\n// bug_start\n    builder.field(PercentilesBucketParser.PERCENTS.getPreferredName(),percents);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override protected SecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication,FilterInvocation fi){\n  WebSecurityExpressionRoot root=new WebSecurityExpressionRoot(authentication,fi);\n  root.setPermissionEvaluator(getPermissionEvaluator());\n// bug_start\n  root.setTrustResolver(trustResolver);\n// bug_end\n  root.setRoleHierarchy(getRoleHierarchy());\n  root.setDefaultRolePrefix(this.defaultRolePrefix);\n  return root;\n}\n"}
{"INPUT": "@Nullable @Override public DBSObjectCache<PostgreTableContainer,PostgreTableBase> getObjectsCache(PostgreTableBase object){\n// bug_start\n  return object.getContainer().getSchema().tableCache;\n// bug_end\n}\n"}
{"INPUT": "public void stop() throws Exception {\n// bug_start\n  if (stopping.compareAndSet(false,true) && !disposed) {\n// bug_end\n    super.stop();\n    if (connectionCount.decrementAndGet() == 0 && disposeOnDisconnect) {\n      VMTransportServer.this.stop();\n    }\n  }\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return S.toString(PlatformNativeException.class,this,\"cause\",S.INCLUDE_SENSITIVE ? cause : (cause == null ? \"null\" : cause.getClass().getSimpleName()));\n// bug_end\n}\n"}
{"INPUT": "@Override public ShortFieldMapper build(BuilderContext context){\n// bug_start\n  ShortFieldMapper fieldMapper=new ShortFieldMapper(buildNames(context),precisionStep,fuzzyFactor,index,store,boost,omitNorms,indexOptions,nullValue,ignoreMalformed);\n// bug_end\n  fieldMapper.includeInAll(includeInAll);\n  return fieldMapper;\n}\n"}
{"INPUT": "public static List<List<String>> splitFieldsFast(String str,String delimiter){\n  List<List<String>> fields=Generics.newArrayList();\n  StringTokenizer tokenizer=new StringTokenizer(str.trim());\n  List<String> currentField=Generics.newArrayList();\n  while (tokenizer.hasMoreTokens()) {\n    String token=tokenizer.nextToken();\n    if (token.equals(delimiter)) {\n      fields.add(currentField);\n      currentField=Generics.newArrayList();\n    }\n else {\n// bug_start\n      currentField.add(token);\n// bug_end\n    }\n  }\n  if (currentField.size() > 0) {\n    fields.add(currentField);\n  }\n  return fields;\n}\n"}
{"INPUT": "protected long freePhysRecTake(final int requiredSize) throws IOException {\n  writeLock_checkLocked();\n  if (requiredSize <= 0)   throw new InternalError();\n// bug_start\n  long freePhysRec=appendOnly ? 0L : findFreePhysSlot(requiredSize);\n// bug_end\n  if (freePhysRec != 0) {\n    return freePhysRec;\n  }\n  final long physFileSize=index.getLong(RECID_CURRENT_PHYS_FILE_SIZE * 8);\n  if (physFileSize <= 0)   throw new InternalError(\"illegal file size:\" + physFileSize);\n  if (physFileSize % Volume.BUF_SIZE + requiredSize <= Volume.BUF_SIZE) {\n    phys.ensureAvailable(physFileSize + requiredSize);\n    index.putLong(RECID_CURRENT_PHYS_FILE_SIZE * 8,physFileSize + requiredSize);\n    return (((long)requiredSize) << 48) | physFileSize;\n  }\n else {\n    final long freeSizeToCreate=Volume.BUF_SIZE - physFileSize % Volume.BUF_SIZE;\n    if (freeSizeToCreate == 0)     throw new InternalError();\n    final long nextBufferStartOffset=physFileSize + freeSizeToCreate;\n    if (nextBufferStartOffset % Volume.BUF_SIZE != 0)     throw new InternalError();\n    phys.ensureAvailable(physFileSize + freeSizeToCreate + requiredSize);\n    index.putLong(RECID_CURRENT_PHYS_FILE_SIZE * 8,physFileSize + freeSizeToCreate + requiredSize);\n    freePhysRecPut((freeSizeToCreate << 48) | physFileSize);\n    return (((long)requiredSize) << 48) | nextBufferStartOffset;\n  }\n}\n"}
{"INPUT": "@Override public StorageVolume[] getVolumeList(int uid,String packageName,int flags){\n  final int userId=UserHandle.getUserId(uid);\n  final boolean forWrite=(flags & StorageManager.FLAG_FOR_WRITE) != 0;\n  final boolean realState=(flags & StorageManager.FLAG_REAL_STATE) != 0;\n  final boolean includeInvisible=(flags & StorageManager.FLAG_INCLUDE_INVISIBLE) != 0;\n  final boolean userKeyUnlocked;\n  final boolean storagePermission;\n  final long token=Binder.clearCallingIdentity();\n  try {\n    userKeyUnlocked=isUserKeyUnlocked(userId);\n    storagePermission=mMountServiceInternal.hasExternalStorage(uid,packageName);\n  }\n  finally {\n    Binder.restoreCallingIdentity(token);\n  }\n  boolean foundPrimary=false;\n  final ArrayList<StorageVolume> res=new ArrayList<>();\nsynchronized (mLock) {\n    for (int i=0; i < mVolumes.size(); i++) {\n      final VolumeInfo vol=mVolumes.valueAt(i);\nswitch (vol.getType()) {\ncase VolumeInfo.TYPE_PUBLIC:\ncase VolumeInfo.TYPE_EMULATED:\n        break;\ndefault :\n      continue;\n  }\n  boolean match=false;\n  if (forWrite) {\n    match=vol.isVisibleForWrite(userId);\n  }\n else {\n// bug_start\n    match=vol.isVisibleForRead(userId) || includeInvisible;\n// bug_end\n  }\n  if (!match)   continue;\n  boolean reportUnmounted=false;\n  if ((vol.getType() == VolumeInfo.TYPE_EMULATED) && !userKeyUnlocked) {\n    reportUnmounted=true;\n  }\n else   if (!storagePermission && !realState) {\n    reportUnmounted=true;\n  }\n  final StorageVolume userVol=vol.buildStorageVolume(mContext,userId,reportUnmounted);\n  if (vol.isPrimary()) {\n    res.add(0,userVol);\n    foundPrimary=true;\n  }\n else {\n    res.add(userVol);\n  }\n}\n}\nif (!foundPrimary) {\nLog.w(TAG,\"No primary storage defined yet; hacking together a stub\");\nfinal boolean primaryPhysical=SystemProperties.getBoolean(StorageManager.PROP_PRIMARY_PHYSICAL,false);\nfinal String id=\"stub_primary\";\nfinal File path=Environment.getLegacyExternalStorageDirectory();\nfinal String description=mContext.getString(android.R.string.unknownName);\nfinal boolean primary=true;\nfinal boolean removable=primaryPhysical;\nfinal boolean emulated=!primaryPhysical;\nfinal long mtpReserveSize=0L;\nfinal boolean allowMassStorage=false;\nfinal long maxFileSize=0L;\nfinal UserHandle owner=new UserHandle(userId);\nfinal String uuid=null;\nfinal String state=Environment.MEDIA_REMOVED;\nres.add(0,new StorageVolume(id,StorageVolume.STORAGE_ID_INVALID,path,description,primary,removable,emulated,mtpReserveSize,allowMassStorage,maxFileSize,owner,uuid,state));\n}\nreturn res.toArray(new StorageVolume[res.size()]);\n}\n"}
{"INPUT": "public static Vec compose(TransfVec origVec,int[] transfMap,boolean keepOrig){\n  int[] domMap=Utils.compose(origVec._domMap,transfMap);\n// bug_start\n  Vec result=origVec.makeTransf(domMap,origVec._domain);\n// bug_end\n  if (!keepOrig)   DKV.remove(origVec._key);\n  return result;\n}\n"}
{"INPUT": "@Override @NotNull public String getPackageImportPath(){\n  VirtualFile virtualFile=getCurrentOrIndexedVirtualFile();\n  String importPath=GoSdkParsingHelper.getInstance().getPackageImportPath(getProject(),this,virtualFile);\n  if (importPath != null) {\n    return importPath;\n  }\n  ProjectFileIndex projectFileIndex=ProjectRootManager.getInstance(getProject()).getFileIndex();\n  if (!projectFileIndex.isInSource(virtualFile) || projectFileIndex.isLibraryClassFile(virtualFile)) {\n    return \"\";\n  }\n  VirtualFile sourceRoot=projectFileIndex.getSourceRootForFile(virtualFile);\n  if (sourceRoot == null) {\n    return \"\";\n  }\n  String path=VfsUtil.getRelativePath(virtualFile.getParent(),sourceRoot,'/');\n  if (path == null || path.equals(\"\"))   path=getPackageName();\n// bug_start\n  if (path != null && !path.endsWith(getPackageName())) {\n// bug_end\n    path=path + \"/\" + getPackageName();\n  }\n  String makefileTarget=GoUtil.getTargetFromMakefile(virtualFile.getParent().findChild(\"Makefile\"));\n  if (makefileTarget != null) {\n    path=makefileTarget;\n  }\n  return path;\n}\n"}
{"INPUT": "@Override public void startup(){\n// bug_start\n  ODatabaseDocument db=ODatabaseRecordThreadLocal.INSTANCE.get();\n// bug_end\n  profilerPrefix=\"db.\" + db.getName() + \".cache.level1.\";\n  profilerMetadataPrefix=\"db.*.cache.level1.\";\n  CACHE_HIT=profilerPrefix + \"cache.found\";\n  CACHE_MISS=profilerPrefix + \"cache.notFound\";\n  super.startup();\n}\n"}
{"INPUT": "protected void processFile(String packageName,String scheme,String fileName,Func1<PrintWriter,Void> handler){\n  PrintWriter writer=null;\n  try {\n    Writer out=null;\n    Filer filer=processingEnv.getFiler();\n    FileObject resource;\n    try {\n      resource=filer.getResource(StandardLocation.CLASS_OUTPUT,packageName,fileName);\n    }\n catch (    Throwable e) {\n      resource=filer.createResource(StandardLocation.CLASS_OUTPUT,packageName,fileName,new Element[0]);\n    }\n    URI uri=resource.toUri();\n    File file=null;\n    if (uri != null) {\n      try {\n// bug_start\n        file=new File(uri);\n// bug_end\n      }\n catch (      Exception e) {\n        warning(\"Could not convert output directory resource URI to a file \" + e);\n      }\n    }\n    if (file == null) {\n      warning(\"No class output directory could be found!\");\n    }\n else {\n      file.getParentFile().mkdirs();\n      out=new FileWriter(file);\n      writer=new PrintWriter(out);\n      handler.call(writer);\n    }\n  }\n catch (  IOException e) {\n    log(e);\n  }\n finally {\n    if (writer != null) {\n      writer.close();\n    }\n  }\n}\n"}
{"INPUT": "public String getXRobotsTag(){\n  String x_robots_tag=this.get(HeaderFramework.X_ROBOTS_TAG,\"\");\n  if (x_robots_tag.isEmpty()) {\n    x_robots_tag=this.get(HeaderFramework.X_ROBOTS,\"\");\n  }\n// bug_start\n  return x_robots_tag;\n// bug_end\n}\n"}
{"INPUT": "public static boolean getCastedExprent(Exprent exprent,VarType leftType,TextBuffer buffer,int indent,boolean castNull,boolean castAlways,BytecodeMappingTracer tracer){\n  VarType rightType=exprent.getExprType();\n// bug_start\n  boolean cast=castAlways || (!leftType.isSuperset(rightType) && (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.type != CodeConstants.TYPE_OBJECT)) || (castNull && rightType.type == CodeConstants.TYPE_NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType)))|| (isIntConstant(exprent) && rightType.isStrictSuperset(leftType));\n// bug_end\n  boolean quote=cast && exprent.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST);\n  if (cast)   buffer.append('(').append(getCastTypeName(leftType)).append(')');\n  if (quote)   buffer.append('(');\n  buffer.append(exprent.toJava(indent,tracer));\n  if (quote)   buffer.append(')');\n  return cast;\n}\n"}
{"INPUT": "private void releaseClob(){\n  if (clob != null) {\n    try {\n      clob.free();\n    }\n catch (    Throwable e) {\n// bug_start\n      log.debug(e);\n// bug_end\n    }\n    clob=null;\n  }\n}\n"}
{"INPUT": "@Test public void testGetHalfMessageNull(){\n  when(messageStore.getMessage(anyString(),anyString(),anyInt(),anyLong(),anyInt(),ArgumentMatchers.nullable(MessageFilter.class))).thenReturn(null);\n  PullResult result=transactionBridge.getHalfMessage(0,0,1);\n// bug_start\n  assertThat(result).isNull();\n// bug_end\n}\n"}
{"INPUT": "public void testTemplateParse() throws Exception {\n  XContentBuilder jsonBuilder=jsonBuilder();\n  jsonBuilder.startObject();\n  TextTemplate body=TextTemplate.inline(randomAsciiOfLength(200)).build();\n  jsonBuilder.field(\"body\",body,ToXContent.EMPTY_PARAMS);\n  TextTemplate[] rooms=null;\n  if (randomBoolean()) {\n    jsonBuilder.startArray(\"room\");\n    rooms=new TextTemplate[randomIntBetween(1,3)];\n    for (int i=0; i < rooms.length; i++) {\n      rooms[i]=TextTemplate.inline(randomAsciiOfLength(10)).build();\n      rooms[i].toXContent(jsonBuilder,ToXContent.EMPTY_PARAMS);\n    }\n    jsonBuilder.endArray();\n  }\n  TextTemplate[] users=null;\n  if (randomBoolean()) {\n    jsonBuilder.startArray(\"user\");\n    users=new TextTemplate[randomIntBetween(1,3)];\n    for (int i=0; i < users.length; i++) {\n      users[i]=TextTemplate.inline(randomAsciiOfLength(10)).build();\n      users[i].toXContent(jsonBuilder,ToXContent.EMPTY_PARAMS);\n    }\n    jsonBuilder.endArray();\n  }\n  String from=null;\n  if (randomBoolean()) {\n    from=randomAsciiOfLength(10);\n    jsonBuilder.field(\"from\",from);\n  }\n  TextTemplate color=null;\n  if (randomBoolean()) {\n    color=TextTemplate.inline(randomAsciiOfLength(10)).build();\n    jsonBuilder.field(\"color\",color,ToXContent.EMPTY_PARAMS);\n  }\n  HipChatMessage.Format format=null;\n  if (randomBoolean()) {\n    format=randomFrom(HipChatMessage.Format.values());\n    jsonBuilder.field(\"format\",format,ToXContent.EMPTY_PARAMS);\n  }\n  Boolean notify=null;\n  if (randomBoolean()) {\n    notify=randomBoolean();\n    jsonBuilder.field(\"notify\",notify);\n  }\n// bug_start\n  BytesReference bytes=jsonBuilder.bytes();\n// bug_end\n  XContentParser parser=JsonXContent.jsonXContent.createParser(bytes);\n  parser.nextToken();\n  HipChatMessage.Template template=HipChatMessage.Template.parse(parser);\n  assertThat(template,notNullValue());\n  assertThat(template.body,is(body));\n  if (rooms == null) {\n    assertThat(template.rooms,nullValue());\n  }\n else {\n    assertThat(template.rooms,arrayContaining(rooms));\n  }\n  if (users == null) {\n    assertThat(template.users,nullValue());\n  }\n else {\n    assertThat(template.users,arrayContaining(users));\n  }\n  assertThat(template.from,is(from));\n  assertThat(template.color,is(color));\n  assertThat(template.format,is(format));\n  assertThat(template.notify,is(notify));\n}\n"}
{"INPUT": "public StandardHostValveInvokeInterceptor(TraceContext traceContext,MethodDescriptor descriptor){\n  this.traceContext=traceContext;\n  this.methodDescriptor=descriptor;\n  TomcatConfig tomcatConfig=new TomcatConfig(traceContext.getProfilerConfig());\n  this.excludeUrlFilter=tomcatConfig.getTomcatExcludeUrlFilter();\n  final String proxyIpHeader=tomcatConfig.getTomcatRealIpHeader();\n  if (StringUtils.isEmpty(proxyIpHeader)) {\n    this.remoteAddressResolver=new Bypass<HttpServletRequest>();\n  }\n else {\n    final String tomcatRealIpEmptyValue=tomcatConfig.getTomcatRealIpEmptyValue();\n    this.remoteAddressResolver=new RealIpHeaderResolver<HttpServletRequest>(proxyIpHeader,tomcatRealIpEmptyValue);\n  }\n  this.isTraceRequestParam=tomcatConfig.isTomcatTraceRequestParam();\n  this.excludeProfileMethodFilter=tomcatConfig.getTomcatExcludeProfileMethodFilter();\n// bug_start\n  this.proxyHttpHeaderRecorder=new ProxyHttpHeaderRecorder(traceContext);\n// bug_end\n  traceContext.cacheApi(SERVLET_ASYNCHRONOUS_API_TAG);\n  traceContext.cacheApi(SERVLET_SYNCHRONOUS_API_TAG);\n}\n"}
{"INPUT": "@MarshalsPointer public static List<AVAudioSessionRouteChangeNotification> toObject(Class<? extends NSObject> cls,long handle,long flags){\n// bug_start\n  NSArray<NSDictionary<NSString,NSObject>> o=(NSArray<NSDictionary<NSString,NSObject>>)NSObject.Marshaler.toObject(cls,handle,flags);\n// bug_end\n  if (o == null) {\n    return null;\n  }\n  List<AVAudioSessionRouteChangeNotification> list=new ArrayList<>();\n  for (int i=0; i < o.size(); i++) {\n    list.add(new AVAudioSessionRouteChangeNotification(o.get(i)));\n  }\n  return list;\n}\n"}
{"INPUT": "@MarshalsPointer public static List<CVImageBufferPixelAspectRatio> toObject(Class<? extends CFType> cls,long handle,long flags){\n// bug_start\n  CFArray o=(CFArray)CFType.Marshaler.toObject(cls,handle,flags);\n// bug_end\n  if (o == null) {\n    return null;\n  }\n  List<CVImageBufferPixelAspectRatio> list=new ArrayList<>();\n  for (int i=0; i < o.size(); i++) {\n    list.add(new CVImageBufferPixelAspectRatio(o.get(i,CFDictionary.class)));\n  }\n  return list;\n}\n"}
{"INPUT": "public DB acquireDatabase(final String iURL) throws OLockException, InterruptedException {\n// bug_start\n  final String url=iURL;\n// bug_end\n  OResourcePool<String,DB> pool=pools.get(url);\n  if (pool == null) {\nsynchronized (pools) {\n      if (pool == null) {\n        pool=new OResourcePool<String,DB>(maxSize,this);\n        pools.put(url,pool);\n      }\n    }\n  }\n  return pool.getResource(iURL,timeout);\n}\n"}
{"INPUT": "void writePosition(TypeAnnotationPosition p){\n  databuf.appendByte(p.type.targetTypeValue());\nswitch (p.type) {\ncase INSTANCEOF:\ncase NEW:\ncase CONSTRUCTOR_REFERENCE:\ncase METHOD_REFERENCE:\n    databuf.appendChar(p.offset);\n  break;\ncase LOCAL_VARIABLE:\ncase RESOURCE_VARIABLE:\ndatabuf.appendChar(p.lvarOffset.length);\nfor (int i=0; i < p.lvarOffset.length; ++i) {\ndatabuf.appendChar(p.lvarOffset[i]);\ndatabuf.appendChar(p.lvarLength[i]);\ndatabuf.appendChar(p.lvarIndex[i]);\n}\nbreak;\ncase EXCEPTION_PARAMETER:\n// bug_start\ndatabuf.appendChar(p.exception_index);\n// bug_end\nbreak;\ncase METHOD_RECEIVER:\nbreak;\ncase CLASS_TYPE_PARAMETER:\ncase METHOD_TYPE_PARAMETER:\ndatabuf.appendByte(p.parameter_index);\nbreak;\ncase CLASS_TYPE_PARAMETER_BOUND:\ncase METHOD_TYPE_PARAMETER_BOUND:\ndatabuf.appendByte(p.parameter_index);\ndatabuf.appendByte(p.bound_index);\nbreak;\ncase CLASS_EXTENDS:\ndatabuf.appendChar(p.type_index);\nbreak;\ncase THROWS:\ndatabuf.appendChar(p.type_index);\nbreak;\ncase METHOD_FORMAL_PARAMETER:\ndatabuf.appendByte(p.parameter_index);\nbreak;\ncase CAST:\ncase CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\ncase METHOD_INVOCATION_TYPE_ARGUMENT:\ncase CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\ncase METHOD_REFERENCE_TYPE_ARGUMENT:\ndatabuf.appendChar(p.offset);\ndatabuf.appendByte(p.type_index);\nbreak;\ncase METHOD_RETURN:\ncase FIELD:\nbreak;\ncase UNKNOWN:\nthrow new AssertionError(\"jvm.ClassWriter: UNKNOWN target type should never occur!\");\ndefault :\nthrow new AssertionError(\"jvm.ClassWriter: Unknown target type for position: \" + p);\n}\n{\ndatabuf.appendByte(p.location.size());\njava.util.List<Integer> loc=TypeAnnotationPosition.getBinaryFromTypePath(p.location);\nfor (int i : loc) databuf.appendByte((byte)i);\n}\n}\n"}
{"INPUT": "@Override public void performAction(BasePanel basePanel,ParserResult parserResult){\n  MergeReviewIntoCommentMigration migration=new MergeReviewIntoCommentMigration();\n  migration.performMigration(parserResult);\n  List<BibEntry> conflicts=MergeReviewIntoCommentMigration.collectConflicts(parserResult);\n// bug_start\n  if (!conflicts.isEmpty() && new MergeReviewIntoCommentConfirmationDialog(basePanel).askUserForMerge(conflicts)) {\n// bug_end\n    migration.performConflictingMigration(parserResult);\n  }\n}\n"}
{"INPUT": "@Override protected Object decode(Channel channel,SocketAddress remoteAddress,Object msg) throws Exception {\n  ByteBuf buf=(ByteBuf)msg;\n  buf.readUnsignedByte();\n  int type=buf.readUnsignedByte();\n  if (type == '1') {\n    DeviceSession deviceSession=getDeviceSession(channel,remoteAddress);\n    if (deviceSession == null) {\n      return null;\n    }\n    Position position=new Position(getProtocolName());\n    position.setDeviceId(deviceSession.getDeviceId());\n    position.set(Position.KEY_INDEX,buf.readUnsignedShort());\n    buf.readUnsignedShort();\n    buf.readUnsignedShort();\n    buf.readUnsignedByte();\n    buf.readUnsignedByte();\n    while (buf.readableBytes() > 1) {\n      int fieldNumber=buf.readUnsignedByte();\n      buf.readUnsignedByte();\n      if (buf.getUnsignedByte(buf.readerIndex()) == 0xFF) {\n        buf.readUnsignedByte();\n        int endIndex=buf.readUnsignedShort() + buf.readerIndex();\n        if (fieldNumber == 52) {\n          position.setValid(true);\n          buf.readUnsignedByte();\n          buf.readUnsignedByte();\n          DateBuilder dateBuilder=new DateBuilder().setDate(buf.readUnsignedByte(),buf.readUnsignedByte(),buf.readUnsignedByte()).setTime(buf.readUnsignedByte(),buf.readUnsignedByte(),buf.readUnsignedByte());\n          position.setFixTime(dateBuilder.getDate());\n          position.setLatitude(buf.readInt() / 600000.0);\n          position.setLongitude(buf.readInt() / 600000.0);\n          position.setSpeed(buf.readUnsignedShort());\n          position.setCourse(buf.readUnsignedShort() * 0.1);\n          position.set(Position.KEY_ODOMETER,UnitsConverter.metersFromFeet(buf.readUnsignedInt()));\n          position.setAltitude(buf.readInt() * 0.1);\n        }\n        buf.readerIndex(endIndex);\n      }\n else {\n        int endIndex=buf.indexOf(buf.readerIndex(),buf.writerIndex(),(byte)0);\n        String value=buf.readCharSequence(endIndex - buf.readerIndex(),StandardCharsets.US_ASCII).toString();\nswitch (fieldNumber) {\ncase 246:\n          String[] values=value.split(\",\");\n        position.set(Position.KEY_POWER,Integer.parseInt(values[2]) * 0.01);\n      position.set(Position.KEY_BATTERY,Integer.parseInt(values[3]) * 0.01);\n    break;\ncase 255:\n  position.setDeviceTime(new Date(Long.parseLong(value) * 1000));\nbreak;\ndefault :\nbreak;\n}\n}\nbuf.readUnsignedByte();\n}\nif (!position.getValid()) {\ngetLastLocation(position,position.getDeviceTime());\n}\nreturn position;\n}\n else if (type == '2') {\nString id=buf.toString(buf.readerIndex(),buf.readableBytes() - 1,StandardCharsets.US_ASCII);\n// bug_start\ngetDeviceSession(channel,remoteAddress,id);\n// bug_end\nreturn null;\n}\nreturn null;\n}\n"}
{"INPUT": "private Repository createRepository(){\n  Settings settings=Settings.builder().put(\"location\",randomAlphaOfLength(10)).build();\n  RepositoryMetaData repositoryMetaData=new RepositoryMetaData(randomAlphaOfLength(10),FsRepository.TYPE,settings);\n// bug_start\n  final FsRepository repository=new FsRepository(repositoryMetaData,createEnvironment(),xContentRegistry(),threadPool){\n// bug_end\n    @Override protected void assertSnapshotOrGenericThread(){\n    }\n  }\n;\n  repository.start();\n  return repository;\n}\n"}
{"INPUT": "public static void overrideTextSize(Context context,SharedPreferences prefs,View v){\n  try {\n    if (v instanceof ViewGroup) {\n      ViewGroup vg=(ViewGroup)v;\n      for (int i=0; i < vg.getChildCount(); i++) {\n        View child=vg.getChildAt(i);\n        overrideTextSize(context,prefs,child);\n      }\n    }\n else     if (v instanceof TextView) {\n      float currentSize=DensityUtil.convertPixelsToDp(((TextView)v).getTextSize(),context);\n      int index=Arrays.asList(context.getResources().getStringArray(R.array.text_size_values)).indexOf(prefs.getString(\"settings_text_size\",\"default\"));\n// bug_start\n      float offset=context.getResources().getIntArray(R.array.text_size_offset)[index];\n// bug_end\n      ((TextView)v).setTextSize(currentSize + offset);\n    }\n  }\n catch (  Exception e) {\n    Log.e(Constants.TAG,\"Error setting font size\",e);\n  }\n}\n"}
{"INPUT": "private static void addUrlsFromPath(List<URL> addTo,String path) throws Exception {\n  File thisClassFile=new File(new URI(Thread.currentThread().getContextClassLoader().getResource(\"liquibase/test/JUnitJDBCDriverClassLoader.class\").toExternalForm()));\n  File jdbcLib=new File(thisClassFile.getParentFile().getParentFile().getParentFile(),path);\n  if (!jdbcLib.exists()) {\n    throw new RuntimeException(\"JDBC driver directory \" + jdbcLib.getAbsolutePath() + \" does not exist\");\n  }\n  File[] files=jdbcLib.listFiles(new FileFilter(){\n    @Override public boolean accept(    File pathname){\n      return pathname.isDirectory();\n    }\n  }\n);\n  if (files == null) {\n    files=new File[]{};\n  }\n  for (  File driverDir : files) {\n    File[] driverJars=driverDir.listFiles(new FilenameFilter(){\n      @Override public boolean accept(      File dir,      String name){\n        return name.endsWith(\"jar\");\n      }\n    }\n);\n    for (    File jar : driverJars) {\n// bug_start\n      addTo.add(jar.toURL());\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "public String toQueryString(boolean count){\n  StringBuilder sb=getSelectClause(new StringBuilder(),count).append(\" FROM \").append(rootClass.getName()).append(\" \").append(rootAlias);\n  if (CollectionUtils.isNotEmpty(joins)) {\n// bug_start\n    sb.append(\" JOIN\");\n// bug_end\n    for (    TQJoin join : joins) {\n// bug_start\n// bug_end\n      sb.append(\" \");\n      sb.append(join.toQl());\n    }\n  }\n  if (CollectionUtils.isNotEmpty(restrictions)) {\n    sb.append(\" WHERE \");\n    for (int i=0; i < restrictions.size(); i++) {\n      TQRestriction r=restrictions.get(i);\n      sb.append(r.toQl(\"p\" + i,paramMap));\n      if (i != restrictions.size() - 1) {\n        sb.append(\" AND \");\n      }\n    }\n  }\n  if (CollectionUtils.isNotEmpty(orders)) {\n    sb.append(\" ORDER BY\");\n    for (int j=0; j < orders.size(); j++) {\n      sb.append(\" \");\n      sb.append(orders.get(j).toQl());\n      if (j < orders.size() - 1) {\n        sb.append(\",\");\n      }\n    }\n  }\n  return sb.toString();\n}\n"}
{"INPUT": "@Override public void execute(Context context){\n  BStruct webSocketConnector=(BStruct)context.getRefArgument(0);\n  int statusCode=(int)context.getIntArgument(0);\n  String reason=context.getStringArgument(0);\n  Session session=(Session)webSocketConnector.getNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_SESSION);\n  try {\n    session.close(new CloseReason(null,reason));\n// bug_start\n// bug_end\n  }\n catch (  IOException e) {\n    context.setReturnValues(BLangConnectorSPIUtil.createBStruct(context,HttpConstants.PROTOCOL_PACKAGE_HTTP,WebSocketConstants.WEBSOCKET_CONNECTOR_ERROR,\"Could not close the connection: \" + e.getMessage()));\n  }\n finally {\n    WebSocketConnectionManager connectionManager=(WebSocketConnectionManager)webSocketConnector.getNativeData(WebSocketConstants.WEBSOCKET_CONNECTION_MANAGER);\n    if (connectionManager != null) {\n      connectionManager.removeConnectionInfo(session.getId());\n    }\n  }\n// bug_start\n  context.setReturnValues();\n// bug_end\n}\n"}
{"INPUT": "@Override public void processTrigger(){\n  if (matchFilter(contractEventTrigger)) {\n// bug_start\n// bug_end\n    contractEventTrigger.setDataMap(ContractEventParser.parseEventData(contractEventTrigger,abiEntry));\n// bug_start\n    contractEventTrigger.setTopicMap(ContractEventParser.parseTopics(contractEventTrigger,abiEntry));\n// bug_end\n    EventPluginLoader.getInstance().postContractEventTrigger(contractEventTrigger);\n  }\n}\n"}
{"INPUT": "public static void writeProcess(Process process,XMLStreamWriter xtw) throws Exception {\n  xtw.writeStartElement(ELEMENT_PROCESS);\n  xtw.writeAttribute(ATTRIBUTE_ID,process.getId());\n  if (StringUtils.isNotEmpty(process.getName())) {\n    xtw.writeAttribute(ATTRIBUTE_NAME,process.getName());\n  }\n  xtw.writeAttribute(ATTRIBUTE_PROCESS_EXECUTABLE,ATTRIBUTE_VALUE_TRUE);\n  if (process.getCandidateStarterUsers().size() > 0) {\n    xtw.writeAttribute(ACTIVITI_EXTENSIONS_PREFIX,ACTIVITI_EXTENSIONS_NAMESPACE,ATTRIBUTE_PROCESS_CANDIDATE_USERS,BpmnXMLUtil.convertToDelimitedString(process.getCandidateStarterUsers()));\n  }\n  if (process.getCandidateStarterGroups().size() > 0) {\n    xtw.writeAttribute(ACTIVITI_EXTENSIONS_PREFIX,ACTIVITI_EXTENSIONS_NAMESPACE,ATTRIBUTE_PROCESS_CANDIDATE_GROUPS,BpmnXMLUtil.convertToDelimitedString(process.getCandidateStarterGroups()));\n  }\n  if (StringUtils.isNotEmpty(process.getDocumentation())) {\n    xtw.writeStartElement(ELEMENT_DOCUMENTATION);\n    xtw.writeCharacters(process.getDocumentation());\n    xtw.writeEndElement();\n  }\n// bug_start\n  LaneExport.writeLanes(process,xtw);\n// bug_end\n  boolean wroteListener=ActivitiListenerExport.writeListeners(process,false,xtw);\n  if (wroteListener) {\n    xtw.writeEndElement();\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@SuppressWarnings({\"TypeMayBeWeakened\",\"unchecked\"}) private void stopCache(GridCacheAdapter<?,?> cache,boolean cancel,boolean destroy){\n  GridCacheContext ctx=cache.context();\n  sharedCtx.removeCacheContext(ctx);\n  cache.stop();\n// bug_start\n// bug_end\n  if (isNearEnabled(ctx)) {\n    GridDhtCacheAdapter dht=ctx.near().dht();\n    if (dht != null) {\n      dht.stop();\n      GridCacheContext<?,?> dhtCtx=dht.context();\n      List<GridCacheManager> dhtMgrs=dhtManagers(dhtCtx);\n      for (ListIterator<GridCacheManager> it=dhtMgrs.listIterator(dhtMgrs.size()); it.hasPrevious(); ) {\n        GridCacheManager mgr=it.previous();\n        mgr.stop(cancel,destroy);\n      }\n    }\n  }\n  List<GridCacheManager> mgrs=ctx.managers();\n  Collection<GridCacheManager> excludes=dhtExcludes(ctx);\n  for (ListIterator<GridCacheManager> it=mgrs.listIterator(mgrs.size()); it.hasPrevious(); ) {\n    GridCacheManager mgr=it.previous();\n    if (!excludes.contains(mgr))     mgr.stop(cancel,destroy);\n  }\n// bug_start\n  ctx.kernalContext().query().onCacheStop(ctx);\n// bug_end\n  ctx.kernalContext().continuous().onCacheStop(ctx);\n  U.stopLifecycleAware(log,lifecycleAwares(cache.configuration(),ctx.store().configuredStore()));\n  if (log.isInfoEnabled())   log.info(\"Stopped cache: \" + cache.name());\n  if (destroy && sharedCtx.pageStore() != null) {\n    try {\n      sharedCtx.pageStore().onAfterCacheDestroy(ctx);\n    }\n catch (    IgniteCheckedException e) {\n      U.error(log,\"Failed to gracefully clean page store resources for destroyed cache \" + \"[cache=\" + ctx.name() + \"]\",e);\n    }\n  }\n  cleanup(ctx);\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  requestWindowFeature(Window.FEATURE_NO_TITLE);\n  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);\n  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n  View decor=this.getWindow().getDecorView();\n  decor.setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);\n  setContentView(R.layout.jc_activity_fullscreen);\n  try {\n    Constructor<JCVideoPlayerStandard> constructor=VIDEO_PLAYER_CLASS.getConstructor(Context.class);\n    jcVideoPlayer=constructor.newInstance(this);\n    setContentView(jcVideoPlayer);\n  }\n catch (  InstantiationException e) {\n    e.printStackTrace();\n  }\ncatch (  Exception e) {\n    e.printStackTrace();\n  }\n  jcVideoPlayer.IF_CURRENT_IS_FULLSCREEN=true;\n  jcVideoPlayer.IF_FULLSCREEN_IS_DIRECTLY=DIRECT_FULLSCREEN;\n// bug_start\n// bug_end\n  jcVideoPlayer.addSurfaceView();\n// bug_start\n  jcVideoPlayer.setUp(URL,OBJECTS);\n// bug_end\n  jcVideoPlayer.setStateAndUi(CURRENT_STATE);\n  if (jcVideoPlayer.IF_FULLSCREEN_IS_DIRECTLY) {\n    jcVideoPlayer.ivStart.performClick();\n  }\n else {\n    JCAbstractVideoPlayer.IF_RELEASE_WHEN_ON_PAUSE=true;\n    JCMediaManager.intance().listener=jcVideoPlayer;\n  }\n}\n"}
{"INPUT": "ClasspathFinder(final ScanSpec scanSpec,final NestedJarHandler nestedJarHandler,final LogNode log){\n  this.nestedJarHandler=nestedJarHandler;\n  if (scanSpec.overrideClasspath != null) {\n    if (scanSpec.overrideClassLoaders) {\n      if (log != null) {\n        log.log(\"It is not possible to override both the classpath and the ClassLoaders -- \" + \"ignoring the ClassLoader override\");\n      }\n    }\n    final LogNode overrideLog=log == null ? null : log.log(\"Overriding classpath\");\n    addClasspathElements(scanSpec.overrideClasspath,overrideLog);\n  }\n else {\n    if (!scanSpec.blacklistSystemJars()) {\n      final String rtJarPath=JarUtils.getRtJarPath();\n      if (rtJarPath != null) {\n        addClasspathElement(rtJarPath,log);\n      }\n    }\n    final List<ClassLoaderHandler> classLoaderHandlers=new ArrayList<>();\n// bug_start\n// bug_end\n    for (    final Class<? extends ClassLoaderHandler> classLoaderHandlerClass : ClassLoaderHandlerRegistry.DEFAULT_CLASS_LOADER_HANDLERS) {\n      try {\n        classLoaderHandlers.add(classLoaderHandlerClass.newInstance());\n      }\n catch (      InstantiationException|IllegalAccessException e) {\n        if (log != null) {\n          log.log(\"Could not instantiate \" + classLoaderHandlerClass.getName(),e);\n// bug_start\n        }\n      }\n    }\n    for (    final Class<? extends ClassLoaderHandler> classLoaderHandler : scanSpec.extraClassLoaderHandlers) {\n      try {\n        classLoaderHandlers.add(classLoaderHandler.newInstance());\n      }\n catch (      InstantiationException|IllegalAccessException e) {\n        if (log != null) {\n          log.log(\"Could not instantiate \" + classLoaderHandler.getName(),e);\n// bug_end\n        }\n      }\n    }\n    if (log != null) {\n      final LogNode classLoaderHandlerLog=log.log(\"ClassLoaderHandlers loaded:\");\n      for (      final ClassLoaderHandler classLoaderHandler : classLoaderHandlers) {\n        classLoaderHandlerLog.log(classLoaderHandler.getClass().getName());\n      }\n    }\n    final AdditionOrderedSet<ClassLoader> allClassLoaders=new AdditionOrderedSet<>();\n    for (    final ClassLoader classLoader : scanSpec.classLoaders) {\n      final ArrayList<ClassLoader> parentClassLoaders=new ArrayList<>();\n      for (ClassLoader cl=classLoader; cl != null; cl=cl.getParent()) {\n        parentClassLoaders.add(cl);\n      }\n      for (int i=parentClassLoaders.size() - 1; i >= 0; --i) {\n        allClassLoaders.add(parentClassLoaders.get(i));\n      }\n    }\n    final List<ClassLoader> classLoaderOrder=allClassLoaders.getList();\n    for (    final ClassLoader classLoader : classLoaderOrder) {\n      if (!scanSpec.blacklistSystemJars() || !classLoader.getClass().getName().startsWith(\"sun.misc.Launcher$ExtClassLoader\")) {\n        final LogNode classLoaderLog=log == null ? null : log.log(\"Finding classpath elements in ClassLoader \" + classLoader);\n        boolean classloaderFound=false;\n        for (        final ClassLoaderHandler handler : classLoaderHandlers) {\n          try {\n            if (handler.handle(classLoader,this,classLoaderLog)) {\n              classloaderFound=true;\n              break;\n            }\n          }\n catch (          final Exception e) {\n            if (classLoaderLog != null) {\n              classLoaderLog.log(\"Exception in ClassLoaderHandler\",e);\n            }\n          }\n        }\n        if (!classloaderFound) {\n          if (classLoaderLog != null) {\n            classLoaderLog.log(\"Unknown ClassLoader type, cannot scan classes\");\n          }\n        }\n      }\n    }\n    if (!scanSpec.overrideClassLoaders) {\n      final LogNode sysPropLog=log == null ? null : log.log(\"Getting classpath entries from java.class.path\");\n      addClasspathElements(System.getProperty(\"java.class.path\"),sysPropLog);\n    }\n  }\n}\n"}
{"INPUT": "@Override public void draw(){\n  camera.update();\n  clearScreen(clearColor);\n  batch.setProjectionMatrix(camera.combined);\n  if (pixelate)   Graphics.surface(pixelSurface,false);\n else   batch.begin();\n  Graphics.surface(shieldSurface);\n  Graphics.surface();\n  drawPadding();\n  blocks.drawFloor();\n  blocks.processBlocks();\n  blocks.drawBlocks(false);\n  Graphics.shader(Shaders.outline,false);\n  Entities.draw(enemyGroup);\n// bug_start\n// bug_end\n  Entities.draw(playerGroup,null);\n// bug_start\n  Graphics.shader();\n// bug_end\n  Entities.draw(Entities.defaultGroup());\n  blocks.drawBlocks(true);\n  Graphics.shader(Shaders.outline,false);\n  Entities.draw(playerGroup,null);\n  Graphics.shader();\n  Entities.draw(bulletGroup);\n  Entities.draw(effectGroup);\n  drawShield();\n  drawOverlay();\n  if (Settings.getBool(\"indicators\") && showUI) {\n    drawEnemyMarkers();\n  }\n  if (pixelate)   Graphics.flushSurface();\n  drawPlayerNames();\n  batch.end();\n}\n"}
{"INPUT": "public Object invoke(Object object,Method method,Object[] objects) throws Throwable {\n  WebElement element;\n  try {\n    element=locator.findElement();\n  }\n catch (  NoSuchElementException e) {\n    if (\"toString\".equals(method.getName())) {\n      return \"Proxy element for: \" + locator.toString();\n    }\n// bug_start\n else     throw e;\n// bug_end\n  }\n  if (\"getWrappedElement\".equals(method.getName())) {\n    return element;\n  }\n  try {\n    return method.invoke(element,objects);\n  }\n catch (  InvocationTargetException e) {\n    throw e.getCause();\n  }\n}\n"}
{"INPUT": "@Override public void run(){\n  String listenerName=listener == null ? null : listener.component.toShortString();\n  if (DBG)   EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);\nsynchronized (mNotificationList) {\n    int index=indexOfNotificationLocked(pkg,tag,id,userId);\n    if (index >= 0) {\n      NotificationRecord r=mNotificationList.get(index);\n      if (reason == REASON_DELEGATE_CLICK) {\n        mUsageStats.registerClickedByUser(r);\n      }\n      if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {\n        return;\n      }\n      if ((r.getNotification().flags & mustNotHaveFlags) != 0) {\n        return;\n      }\n      mNotificationList.remove(index);\n// bug_start\n// bug_end\n      cancelNotificationLocked(r,sendDelete,reason);\n// bug_start\n      cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);\n// bug_end\n      updateLightsLocked();\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\npublic final static String getDefaultType(){\n// bug_end\n  String cstype;\n  cstype=AccessController.doPrivileged(new PrivilegedAction<>(){\n    public String run(){\n      return Security.getProperty(CERTSTORE_TYPE);\n    }\n  }\n);\n  if (cstype == null) {\n    cstype=\"LDAP\";\n  }\n  return cstype;\n}\n"}
{"INPUT": "@Test public void createWorkspaceFromCentosWildFlySwarmStack(){\n  testWorkspace=createWorkspaceHelper.createWorkspaceFromStackWithProject(CENTOS_WILDFLY_SWARM,WORKSPACE_NAME,PROJECT_NAME);\n  ide.switchToIdeAndWaitWorkspaceIsReadyToUse();\n// bug_start\n// bug_end\n  consoles.waitJDTLSProjectResolveFinishedMessage(PROJECT_NAME);\n// bug_start\n  projectExplorer.waitProjectInitialization(PROJECT_NAME);\n// bug_end\n}\n"}
{"INPUT": "public ChannelFuture handshake(){\n  if (handshaken && !isEnableRenegotiation()) {\n    throw new IllegalStateException(\"renegotiation disabled\");\n  }\n  ChannelHandlerContext ctx=this.ctx;\n  Channel channel=ctx.getChannel();\n  ChannelFuture handshakeFuture;\n  Exception exception=null;\nsynchronized (handshakeLock) {\n    if (handshaking) {\n      return this.handshakeFuture;\n    }\n else {\n      handshaking=true;\n      try {\n        engine.beginHandshake();\n        runDelegatedTasks();\n        handshakeFuture=this.handshakeFuture=future(channel);\n      }\n catch (      Exception e) {\n        handshakeFuture=this.handshakeFuture=failedFuture(channel,e);\n        exception=e;\n      }\n    }\n  }\n  if (exception == null) {\n    try {\n      wrapNonAppData(ctx,channel);\n    }\n catch (    SSLException e) {\n// bug_start\n// bug_end\n      fireExceptionCaught(ctx,e);\n// bug_start\n      handshakeFuture.setFailure(e);\n// bug_end\n    }\n  }\n else {\n    fireExceptionCaught(ctx,exception);\n  }\n  return handshakeFuture;\n}\n"}
{"INPUT": "// bug_start\npublic CreateTableStatement addPrimaryKeyColumn(String columnName,String keyName,String columnType,ColumnConstraint... constraints){\n// bug_end\n  PrimaryKeyConstraint pkConstraint=new PrimaryKeyConstraint(keyName);\n  pkConstraint.addColumns(columnName);\n  List<ColumnConstraint> allConstraints=new ArrayList<ColumnConstraint>();\n  allConstraints.addAll(Arrays.asList(constraints));\n  allConstraints.add(new NotNullConstraint(columnName));\n  allConstraints.add(pkConstraint);\n  addColumn(columnName,columnType,allConstraints.toArray(new ColumnConstraint[allConstraints.size()]));\n  return this;\n}\n"}
{"INPUT": "@Test public void testStartup() throws IOException {\n  service=HddsDatanodeService.createHddsDatanodeService(args);\n  service.start(conf);\n// bug_start\n  service.join();\n// bug_end\n  assertNotNull(service.getDatanodeDetails());\n  assertNotNull(service.getDatanodeDetails().getHostName());\n  assertFalse(service.getDatanodeStateMachine().isDaemonStopped());\n  service.stop();\n// bug_start\n// bug_end\n  service.close();\n}\n"}
{"INPUT": "private void resumeWaitTask(){\n  int maxTaskNum=mQueue.getMaxTaskNum();\n  if (mWaitList == null || mWaitList.isEmpty())   return;\n  for (  AbsTaskEntity te : mWaitList) {\n// bug_start\n// bug_end\n    if (mQueue.getCurrentExePoolNum() < maxTaskNum) {\n      startTask(createTask(te));\n    }\n else {\n// bug_start\n      if (te instanceof DownloadTaskEntity) {\n        mQueue=DownloadTaskQueue.getInstance();\n      }\n else       if (te instanceof UploadTaskEntity) {\n        mQueue=UploadTaskQueue.getInstance();\n      }\n else       if (te instanceof DownloadGroupTaskEntity) {\n        mQueue=DownloadGroupTaskQueue.getInstance();\n      }\n// bug_end\n      createTask(te);\n    }\n  }\n}\n"}
{"INPUT": "@Test public void testShrinkShardsOfPartition(){\n  execute(\"create table quotes (id integer, quote string, date timestamp with time zone) \" + \"partitioned by(date) clustered into 3 shards\");\n// bug_start\n// bug_end\n  ensureYellow();\n// bug_start\n  execute(\"insert into quotes (id, quote, date) values (?, ?, ?), (?, ?, ?)\",new Object[]{1,\"Don't panic\",1395874800000L,2,\"Now panic\",1395961200000L});\n// bug_end\n  execute(\"refresh table quotes\");\n  ClusterService clusterService=internalCluster().getInstance(ClusterService.class);\n  final String resizeNodeName=getADataNodeName(clusterService.state());\n  execute(\"alter table quotes partition (date=1395874800000) \" + \"set (\\\"routing.allocation.require._name\\\"=?, \\\"blocks.write\\\"=?)\",$(resizeNodeName,true));\n  ensureYellowAndNoInitializingShards();\n  execute(\"alter table quotes partition (date=1395874800000) set (number_of_shards=?)\",$(1));\n  ensureYellow();\n  execute(\"select number_of_shards from information_schema.table_partitions \" + \"where table_name = 'quotes' \" + \"and values = '{\\\"date\\\": 1395874800000}'\");\n  assertThat(printedTable(response.rows()),is(\"1\\n\"));\n  execute(\"select id from quotes\");\n  assertThat(response.rowCount(),is(2L));\n}\n"}
{"INPUT": "@Override public void onReplaceResult(ReplaceResultEvent event){\n  Debug.logToConsole(\"Replace Result Event with \" + event.getResults().size() + \" Results\");\n  if (event.getHandle() != currentFindHandle_)   return;\n  view_.setReplaceMode(true);\n  ArrayList<FindResult> results=event.getResults();\n  int errorCount=0;\n  for (  FindResult fr : results) {\n    fr.setReplaceIndicator();\n    if (!StringUtil.isNullOrEmpty(fr.getErrors())) {\n      errorCount++;\n    }\n    dialogState_.updateReplaceErrors(fr.getErrors());\n  }\n  dialogState_.updateErrorCount(errorCount);\n// bug_start\n// bug_end\n  view_.addMatches(results);\n// bug_start\n  view_.setReplaceMode(false);\n// bug_end\n  view_.ensureVisible(true);\n  view_.disableReplace();\n  if (!view_.getProgress().isVisible())   events_.fireEvent(new ReplaceOperationEndedEvent(currentFindHandle_));\n}\n"}
{"INPUT": "protected long[] logAllocate(long[] physPos){\n  openLogIfNeeded();\n  logSize+=1 + 8 + 8;\n  long[] ret=new long[physPos.length];\n  for (int i=0; i < physPos.length; i++) {\n    long size=(physPos[i] & MASK_SIZE) >>> 48;\n// bug_start\n    checkLogRounding();\n// bug_end\n    logSize+=1 + 8;\n    ret[i]=(size << 48) | logSize;\n    logSize+=size;\n// bug_start\n// bug_end\n  }\n  log.ensureAvailable(logSize);\n  return ret;\n}\n"}
{"INPUT": "@Before @Override public void setUp() throws Exception {\n// bug_start\n// bug_end\n  nagios=new NagiosNscaStub(25669,\"password\");\n  try {\n    nagios.start();\n  }\n catch (  Exception e) {\n    log.warn(\"Error starting NagiosNscaStub. This exception is ignored.\",e);\n    canRun=false;\n  }\n  super.setUp();\n// bug_start\n  canRun=true;\n// bug_end\n}\n"}
{"INPUT": "@Override public void onCreate(){\n  super.onCreate();\n  if (isDexProcess()) {\n    return;\n  }\n// bug_start\n// bug_end\n  initComponent();\n// bug_start\n  mRefWatcher=LeakCanary.install(this);\n// bug_end\n  initImageLoader();\n  FilePathUtils.initEnvironment(this);\n  Evi.init(this);\n  PGEditImageLoader.initImageLoader(this);\n  MobclickAgent.setDebugMode(BuildConfig.LOG_DEBUG);\n  MobclickAgent.openActivityDurationTrack(true);\n  MobclickAgent.updateOnlineConfig(this);\n  MobclickAgent.setCatchUncaughtExceptions(!BuildConfig.LOG_DEBUG);\n  YLog.setDEBUG(BuildConfig.LOG_DEBUG);\n}\n"}
{"INPUT": "public void run(){\n  monitor.subTask(\"Opening PDF File\");\n// bug_start\n  tlaEditorAndPDFViewer.setActivePage(TLAEditorAndPDFViewer.PDFPage_ID);\n// bug_end\n  final IResource pdfFile=ResourceHelper.getResourceByName(outputFileName);\n  try {\n    UIHelper.openEditorUnchecked(\"de.vonloesch.pdf4eclipse.editors.PDFEditor\",(IFile)pdfFile);\n  }\n catch (  PartInitException e) {\n// bug_start\n// bug_end\n    tlaEditorAndPDFViewer.getPDFViewingPage().getBrowser().setUrl(outputFileName);\n  }\n  monitor.worked(1);\n  if (outputFile.lastModified() < translationStartTime) {\n    MessageDialog.openWarning(UIHelper.getShellProvider().getShell(),\"PDF File Not Modified\",\"The pdf file could not be modified. \" + \"Make sure that the file \" + outputFileName + \" is not open in any external programs.\");\n  }\n}\n"}
{"INPUT": "static ObjectStreamClass lookupInternal(Class cl){\n  ObjectStreamClass desc=null;\nsynchronized (descriptorFor) {\n    desc=findDescriptorFor(cl);\n    if (desc == null) {\n      boolean serializable=classSerializable.isAssignableFrom(cl);\n      ObjectStreamClass superdesc=null;\n      if (serializable) {\n        Class superclass=cl.getSuperclass();\n        if (superclass != null)         superdesc=lookup(superclass);\n      }\n      boolean externalizable=false;\n      if (serializable) {\n        externalizable=((superdesc != null) && superdesc.isExternalizable()) || classExternalizable.isAssignableFrom(cl);\n        if (externalizable) {\n          serializable=false;\n        }\n      }\n      desc=new ObjectStreamClass(cl,superdesc,serializable,externalizable);\n    }\n// bug_start\n// bug_end\n  }\n// bug_start\n  desc.init();\n// bug_end\n  return desc;\n}\n"}
{"INPUT": "private Object[] filterInstances(Map<String,List<Instance>> instanceMap){\n  List<String> filters=new ArrayList<String>();\n  for (  Map.Entry<String,List<Instance>> entry : instanceMap.entrySet()) {\n    List<Instance> instances=entry.getValue();\n    for (    Instance instance : instances) {\n// bug_start\n// bug_end\n      String filter=InstanceEntityWrapper.getGroup(instance);\n// bug_start\n      String plugin=InstanceEntityWrapper.getPlugin(instance);\n// bug_end\n      if (StringUtils.isNotEmpty(plugin) && !filters.contains(filter)) {\n        filters.add(filter);\n      }\n    }\n  }\n  if (filters.contains(StringUtils.EMPTY)) {\n    filters.remove(StringUtils.EMPTY);\n  }\n  filters.add(NO_FILTER);\n  return filters.toArray();\n}\n"}
{"INPUT": "protected void initTheme(){\n// bug_start\n// bug_end\n  if (ColorUtil.isColorLight(ThemeStore.primaryColor(this))) {\n    setTheme(R.style.CAppTheme);\n  }\n else {\n    setTheme(R.style.CAppThemeBarDark);\n  }\n// bug_start\n  if (isNightTheme()) {\n    getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES);\n  }\n else {\n    getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO);\n  }\n// bug_end\n}\n"}
{"INPUT": "public static void WriteTeXAlignmentFile(Token[][] spec,Vector preamble,float linewidth){\n  OutputFileWriter writer=new OutputFileWriter(Parameters.LaTeXAlignmentFile + \".tex\");\n  writer.putLine(\"\\\\batchmode\");\n  int i=0;\n  while (i < preamble.size()) {\n    writer.putLine((String)preamble.elementAt(i));\n    i=i + 1;\n  }\n  ;\n  if (linewidth >= 0) {\n    writer.putLine(\"\\\\setlength{\\\\textwidth}{\" + Misc.floatToString(linewidth,2) + \"pt}\");\n// bug_start\n    writer.putLine(\"\\\\makeatletter\");\n// bug_end\n  }\n  ;\n  writer.putLine(\"\\\\begin{document}\");\n// bug_start\n// bug_end\n  writer.putLine(\"\\\\chardef\\\\%=`\\\\%\");\n  InnerWriteAlignmentFile(spec,writer,false);\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") final <E extends Exception>R operate(RecordOperation<? super R,E> operation) throws E {\n  RecordListenerProvider[] providers=null;\n  RecordListener[] listeners=null;\n  DefaultRecordContext ctx=null;\n  E exception=null;\n  if (configuration != null) {\n    providers=configuration.recordListenerProviders();\n    if (providers != null && providers.length > 0) {\n      listeners=new RecordListener[providers.length];\n      ctx=new DefaultRecordContext(configuration,executeType(),record);\n      for (int i=0; i < providers.length; i++) {\n        listeners[i]=providers[i].provide();\n      }\n    }\n  }\n  if (listeners != null) {\n    for (    RecordListener listener : listeners) {\nswitch (type) {\ncase LOAD:\n        listener.loadStart(ctx);\n      break;\ncase REFRESH:\n    listener.refreshStart(ctx);\n  break;\ncase STORE:\nlistener.storeStart(ctx);\nbreak;\ncase INSERT:\nlistener.insertStart(ctx);\nbreak;\ncase UPDATE:\nlistener.updateStart(ctx);\nbreak;\ncase DELETE:\nlistener.deleteStart(ctx);\nbreak;\ndefault :\nthrow new IllegalStateException(\"Type not supported: \" + type);\n}\n}\n}\n// bug_start\n// bug_end\nif (operation != null) {\ntry {\noperation.operate(record);\n}\n catch (Exception e) {\nexception=(E)e;\nif (!(e instanceof ControlFlowSignal)) {\nif (ctx != null) ctx.exception=e;\nif (listeners != null) for (RecordListener listener : listeners) listener.exception(ctx);\n}\n}\n// bug_start\n}\nif (attachRecords(configuration)) {\nrecord.attach(configuration);\n// bug_end\n}\nif (listeners != null) {\nfor (RecordListener listener : listeners) {\nswitch (type) {\ncase LOAD:\nlistener.loadEnd(ctx);\nbreak;\ncase REFRESH:\nlistener.refreshEnd(ctx);\nbreak;\ncase STORE:\nlistener.storeEnd(ctx);\nbreak;\ncase INSERT:\nlistener.insertEnd(ctx);\nbreak;\ncase UPDATE:\nlistener.updateEnd(ctx);\nbreak;\ncase DELETE:\nlistener.deleteEnd(ctx);\nbreak;\ndefault :\nthrow new IllegalStateException(\"Type not supported: \" + type);\n}\n}\n}\nif (exception != null) {\nthrow exception;\n}\nreturn record;\n}\n"}
{"INPUT": "public void requestFocus(boolean allowRecentsFocusable){\n// bug_start\n// bug_end\n  if (!mIsRecentsShown || mIsPipFocusedInRecent) {\n    return;\n  }\n  mIsPipFocusedInRecent=true;\n  mPipManager.resizePinnedStack(STATE_PIP_RECENTS_FOCUSED);\n  mWindowManager.updateViewLayout(mOverlayView,mPipRecentsControlsViewFocusedLayoutParams);\n  mPipControlsView.requestFocus();\n  mPipControlsView.startFocusGainAnimation();\n// bug_start\n  mRecentsView.setVisibility(allowRecentsFocusable ? View.VISIBLE : View.GONE);\n// bug_end\n}\n"}
{"INPUT": "@Override public void init(ServletConfig config) throws ServletException {\n// bug_start\n// bug_end\n  framework.setBroadcasterFactory(new MyBroadcasterFactory());\n// bug_start\n  super.init(config);\n// bug_end\n}\n"}
{"INPUT": "@Override public void onSaveInstanceState(Bundle outState){\n// bug_start\n// bug_end\n  outState.putInt(\"provider\",spProvider.getSelectedItemPosition());\n  outState.putString(\"password\",tilPassword.getEditText().getText().toString());\n// bug_start\n  super.onSaveInstanceState(outState);\n// bug_end\n}\n"}
{"INPUT": "public EditSession createEditSession(Player player){\n  checkNotNull(player);\n  BlockBag blockBag=getBlockBag(player);\n  EditSession editSession=WorldEdit.getInstance().getEditSessionFactory().getEditSession(player.isPlayer() ? player.getWorld() : null,getBlockChangeLimit(),blockBag,player);\n// bug_start\n// bug_end\n  editSession.setFastMode(fastMode);\n  editSession.setReorderMode(reorderMode);\n// bug_start\n  Request.request().setEditSession(editSession);\n// bug_end\n  editSession.setMask(mask);\n  return editSession;\n}\n"}
{"INPUT": "public Boolean run() throws Exception {\n  File file=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS);\n  if (file != null) {\n    restoreBookSource(file);\n// bug_start\n    restoreReplaceRule(file);\n// bug_end\n    restoreBookShelf(file);\n    restoreSearchHistory(file);\n// bug_start\n// bug_end\n    return true;\n  }\n  return false;\n}\n"}
{"INPUT": "public void copy() throws Exception {\n  recordReader.initialize(configuration,inputUrl);\n  partitioner.init(configuration,outputUrl);\n  recordWriter.initialize(configuration,outputUrl,partitioner);\n  if (batchSize > 0 && recordReader.batchesSupported() && recordWriter.supportsBatch()) {\n    while (recordReader.hasNext()) {\n      List<List<Writable>> next=recordReader.next(batchSize);\n// bug_start\n      partitioner.updatePartitionInfo(recordWriter.writeBatch(next));\n// bug_end\n      if (recordReader.hasNext() && partitioner.needsNewPartition()) {\n        partitioner.currentOutputStream().flush();\n        partitioner.currentOutputStream().close();\n        partitioner.openNewStream();\n      }\n// bug_start\n// bug_end\n    }\n    partitioner.currentOutputStream().flush();\n    partitioner.currentOutputStream().close();\n    recordReader.close();\n    recordWriter.close();\n  }\n else {\n    while (recordReader.hasNext()) {\n      List<Writable> next=recordReader.next();\n      partitioner.updatePartitionInfo(recordWriter.write(next));\n      if (partitioner.needsNewPartition()) {\n        partitioner.openNewStream();\n      }\n    }\n  }\n}\n"}
{"INPUT": "public void close(){\n// bug_start\n// bug_end\n  for (  final MappedByteBuffer buffer : mappedByteBuffers) {\n    IoUtil.unmap(buffer);\n  }\n// bug_start\n  CloseHelper.close(fileChannel);\n// bug_end\n}\n"}
{"INPUT": "private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n  final HttpMessage message=this.message;\n  String line=readHeader(buffer);\n  String lastHeader=null;\n  if (line.length() != 0) {\n    message.clearHeaders();\n    do {\n      char firstChar=line.charAt(0);\n      if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n        List<String> current=message.getHeaders(lastHeader);\n        int lastPos=current.size() - 1;\n        String newString=current.get(lastPos) + line.trim();\n        current.set(lastPos,newString);\n      }\n else {\n        String[] header=splitHeader(line);\n        message.addHeader(header[0],header[1]);\n        lastHeader=header[0];\n// bug_start\n        line=readHeader(buffer);\n// bug_end\n      }\n// bug_start\n// bug_end\n    }\n while (line.length() != 0);\n  }\n  State nextState;\n  if (isContentAlwaysEmpty(message)) {\n    nextState=State.SKIP_CONTROL_CHARS;\n  }\n else   if (message.isChunked()) {\n    nextState=State.READ_CHUNK_SIZE;\n  }\n else   if (message.getContentLength(-1) >= 0) {\n    nextState=State.READ_FIXED_LENGTH_CONTENT;\n  }\n else {\n    nextState=State.READ_VARIABLE_LENGTH_CONTENT;\n  }\n  return nextState;\n}\n"}
{"INPUT": "private synchronized boolean terminate(int exitCode,Handler<Void> completionHandler,String message){\n  if (processStatus != ExecStatus.TERMINATED) {\n// bug_start\n// bug_end\n    if (process != null) {\n      processOutput.close();\n    }\n// bug_start\n    this.appendResult(new StatusModel(exitCode,message));\n// bug_end\n    updateStatus(ExecStatus.TERMINATED,exitCode,false,endHandler,terminatedHandler,completionHandler);\n    if (process != null) {\n      process.unregister();\n    }\n    return true;\n  }\n else {\n    return false;\n  }\n}\n"}
{"INPUT": "@Override public InputConnection onCreateInputConnection(EditorInfo outAttrs){\n  if (onCheckIsTextEditor() && isEnabled()) {\n    mEditor.createInputMethodStateIfNeeded();\n    outAttrs.inputType=getInputType();\n    if (mEditor.mInputContentType != null) {\n      outAttrs.imeOptions=mEditor.mInputContentType.imeOptions;\n      outAttrs.privateImeOptions=mEditor.mInputContentType.privateImeOptions;\n      outAttrs.actionLabel=mEditor.mInputContentType.imeActionLabel;\n      outAttrs.actionId=mEditor.mInputContentType.imeActionId;\n      outAttrs.extras=mEditor.mInputContentType.extras;\n    }\n else {\n      outAttrs.imeOptions=EditorInfo.IME_NULL;\n    }\n    if (focusSearch(FOCUS_DOWN) != null) {\n      outAttrs.imeOptions|=EditorInfo.IME_FLAG_NAVIGATE_NEXT;\n    }\n    if (focusSearch(FOCUS_UP) != null) {\n      outAttrs.imeOptions|=EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;\n    }\n    if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {\n      if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {\n        outAttrs.imeOptions|=EditorInfo.IME_ACTION_NEXT;\n      }\n else {\n        outAttrs.imeOptions|=EditorInfo.IME_ACTION_DONE;\n      }\n      if (!shouldAdvanceFocusOnEnter()) {\n        outAttrs.imeOptions|=EditorInfo.IME_FLAG_NO_ENTER_ACTION;\n      }\n    }\n    if (isMultilineInputType(outAttrs.inputType)) {\n      outAttrs.imeOptions|=EditorInfo.IME_FLAG_NO_ENTER_ACTION;\n    }\n    outAttrs.hintText=mHint;\n// bug_start\n// bug_end\n    if (mText instanceof Editable) {\n      InputConnection ic=new EditableInputConnection(this);\n      outAttrs.initialSelStart=getSelectionStart();\n      outAttrs.initialSelEnd=getSelectionEnd();\n      outAttrs.initialCapsMode=ic.getCursorCapsMode(getInputType());\n      return ic;\n    }\n// bug_start\n    outAttrs.locales=getTextLocales();\n// bug_end\n  }\n  return null;\n}\n"}
{"INPUT": "private <M extends Meter>M registerMeterIfNecessary(Class<M> meterClass,Meter.Id id,Function<Meter.Id,Meter> builder){\n  Meter.Id idWithCommonTags=new Meter.Id(id.getName(),Tags.concat(id.getTags(),config().commonTags()),id.getBaseUnit(),id.getDescription());\n  Meter m=meterMap.get(idWithCommonTags);\n  if (m == null) {\n// bug_start\n    m=builder.apply(idWithCommonTags);\n// bug_end\nsynchronized (meterMap) {\n// bug_start\n// bug_end\n      Meter m2=meterMap.putIfAbsent(idWithCommonTags,m);\n      m=m2 == null ? m : m2;\n    }\n  }\n  if (!meterClass.isInstance(m)) {\n    throw new IllegalArgumentException(\"There is already a registered meter of a different type with the same name\");\n  }\n  return (M)m;\n}\n"}
{"INPUT": "public static TestRuleAnnotatedMember from(Object testInstance,Member member){\n  if (member instanceof Method) {\n    return new TestRuleAnnotatedMethod(testInstance,(Method)member);\n  }\n// bug_start\n else   if (member instanceof Field) {\n// bug_end\n    return new TestRuleAnnotatedField(testInstance,(Field)member);\n  }\n  throw new PreconditionViolationException(String.format(\"Unsupported Member type [%s] for TestRule. Member must be of type %s or %s\",member,Method.class.getName(),Field.class.getName()));\n}\n"}
{"INPUT": "@Override public String toString(){\n  StringBuilder result=new StringBuilder();\n  result.append(\"DELETE VERTEX \");\n  result.append(fromClause.toString());\n// bug_start\n// bug_end\n  if (whereClause != null) {\n    result.append(\" WHERE \");\n    result.append(whereClause.toString());\n// bug_start\n  }\n  if (returnBefore) {\n    result.append(\" RETURN BEFORE\");\n// bug_end\n  }\n  if (limit != null) {\n    result.append(\" LIMIT \");\n    result.append(limit);\n  }\n  return result.toString();\n}\n"}
{"INPUT": "public static void initLogging(ServletContext servletContext){\n  if (exposeWebAppRoot(servletContext)) {\n    WebUtils.setWebAppRootSystemProperty(servletContext);\n  }\n  String location=servletContext.getInitParameter(CONFIG_LOCATION_PARAM);\n  if (location != null) {\n    try {\n// bug_start\n// bug_end\n      if (!ResourceUtils.isUrl(location)) {\n// bug_start\n        location=SystemPropertyUtils.resolvePlaceholders(location);\n// bug_end\n        location=WebUtils.getRealPath(servletContext,location);\n      }\n      servletContext.log(\"Initializing log4j from [\" + location + \"]\");\n      String intervalString=servletContext.getInitParameter(REFRESH_INTERVAL_PARAM);\n      if (intervalString != null) {\n        try {\n          long refreshInterval=Long.parseLong(intervalString);\n          Log4jConfigurer.initLogging(location,refreshInterval);\n        }\n catch (        NumberFormatException ex) {\n          throw new IllegalArgumentException(\"Invalid 'log4jRefreshInterval' parameter: \" + ex.getMessage());\n        }\n      }\n else {\n        Log4jConfigurer.initLogging(location);\n      }\n    }\n catch (    FileNotFoundException ex) {\n      throw new IllegalArgumentException(\"Invalid 'log4jConfigLocation' parameter: \" + ex.getMessage());\n    }\n  }\n}\n"}
{"INPUT": "@Override public void remove(){\n  if (entryToRemove == null) {\n    throw new IllegalStateException(\"can only remove once, call hasNext();next() again\");\n  }\n  try {\n    entryToRemove.unlink();\n// bug_start\n    entryToRemove=null;\n// bug_end\n    ListNode<Key,Value> toRemoveNode=null;\n    if (currentNode.entries.isEmpty()) {\n      if (currentNode.isHead() && currentNode.isTail()) {\n      }\n else       if (currentNode.isHead()) {\n        ListNode<Key,Value> headNode=currentNode;\n        nextEntry=getFromNextNode();\n        if (currentNode.isTail()) {\n          targetList.setTailPageId(headNode.getPageId());\n        }\n        headNode.setEntries(currentNode.entries);\n        headNode.setNext(currentNode.getNext());\n        headNode.store(tx);\n        toRemoveNode=currentNode;\n        currentNode=headNode;\n      }\n else       if (currentNode.isTail()) {\n        toRemoveNode=currentNode;\n        previousNode.setNext(ListIndex.NOT_SET);\n        previousNode.store(tx);\n        targetList.setTailPageId(previousNode.getPageId());\n      }\n else {\n        toRemoveNode=currentNode;\n        previousNode.setNext(toRemoveNode.getNext());\n        previousNode.store(tx);\n        currentNode=previousNode;\n      }\n    }\n    targetList.onRemove(entryToRemove);\n// bug_start\n// bug_end\n    if (toRemoveNode != null) {\n      tx.free(toRemoveNode.getPage());\n    }\n else {\n      currentNode.store(tx);\n    }\n  }\n catch (  IOException unexpected) {\n    IllegalStateException e=new IllegalStateException(unexpected.getLocalizedMessage());\n    e.initCause(unexpected);\n    throw e;\n  }\n}\n"}
{"INPUT": "public static Field getPrimaryKeyField(Class<?> clazz){\n  Field primaryKeyField=null;\n  Field[] fields=clazz.getDeclaredFields();\n  if (fields != null) {\n    for (    Field field : fields) {\n      if (field.getAnnotation(Id.class) != null) {\n        primaryKeyField=field;\n        break;\n      }\n    }\n    if (primaryKeyField == null) {\n      for (      Field field : fields) {\n        if (\"_id\".equals(field.getName())) {\n          primaryKeyField=field;\n          break;\n        }\n      }\n// bug_start\n      if (primaryKeyField == null) {\n        for (        Field field : fields) {\n          if (\"id\".equals(field.getName())) {\n            primaryKeyField=field;\n            break;\n          }\n// bug_end\n        }\n      }\n    }\n  }\n else {\n    throw new RuntimeException(\"this model[\" + clazz + \"] has no field\");\n  }\n  return primaryKeyField;\n}\n"}
{"INPUT": "private URL mergeUrl(URL providerUrl){\n// bug_start\n// bug_end\n  List<Configurator> localConfigurators=this.configurators;\n  if (localConfigurators != null && localConfigurators.size() > 0) {\n    for (    Configurator configurator : localConfigurators) {\n      providerUrl=configurator.configure(providerUrl);\n    }\n  }\n// bug_start\n  providerUrl=ClusterUtils.mergeUrl(providerUrl,queryMap);\n// bug_end\n  providerUrl=providerUrl.addParameter(Constants.CHECK_KEY,String.valueOf(false));\n  this.overrideDirectoryUrl=this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters());\n  if ((providerUrl.getPath() == null || providerUrl.getPath().length() == 0) && \"dubbo\".equals(providerUrl.getProtocol())) {\n    String path=directoryUrl.getParameter(Constants.INTERFACE_KEY);\n    int i=path.indexOf('/');\n    if (i >= 0) {\n      path=path.substring(i + 1);\n    }\n    i=path.lastIndexOf(':');\n    if (i >= 0) {\n      path=path.substring(0,i);\n    }\n    providerUrl=providerUrl.setPath(path);\n  }\n  return providerUrl;\n}\n"}
{"INPUT": "public void run(){\n  try {\n    if (isDebug())     debugPrint(\"new Client created \" + client);\n    if (client.shouldAddTransformer()) {\n// bug_start\n// bug_end\n      Class[] classes=inst.getAllLoadedClasses();\n      ArrayList<Class> list=new ArrayList<Class>();\n      if (isDebug())       debugPrint(\"filtering loaded classes\");\n      for (      Class c : classes) {\n        if (inst.isModifiableClass(c) && client.isCandidate(c)) {\n          if (isDebug())           debugPrint(\"candidate \" + c + \" added\");\n          list.add(c);\n        }\n      }\n      list.trimToSize();\n      int size=list.size();\n      if (isDebug())       debugPrint(\"added as ClassFileTransformer\");\n// bug_start\n      inst.addTransformer(client,true);\n// bug_end\n      if (size > 0) {\n        classes=new Class[size];\n        list.toArray(classes);\n        if (isDebug())         debugPrint(\"calling retransformClasses\");\n        inst.retransformClasses(classes);\n        client.skipRetransforms();\n        if (isDebug())         debugPrint(\"finished retransformClasses\");\n      }\n    }\n  }\n catch (  UnmodifiableClassException uce) {\n    if (isDebug()) {\n      debugPrint(uce);\n    }\n  }\n}\n"}
{"INPUT": "@Override public ChannelPipeline getPipeline(){\n  ChannelPipeline pipeline=Channels.pipeline();\n  if (timeout > 0 && !server.isConnectionless()) {\n    pipeline.addLast(\"idleHandler\",new IdleStateHandler(GlobalTimer.getTimer(),timeout,0,0));\n  }\n  pipeline.addLast(\"openHandler\",new OpenChannelHandler(server));\n  if (Context.isLoggerEnabled()) {\n    pipeline.addLast(\"logger\",new StandardLoggingHandler());\n  }\n  addSpecificHandlers(pipeline);\n// bug_start\n// bug_end\n  if (hemisphereHandler != null) {\n    pipeline.addLast(\"hemisphere\",hemisphereHandler);\n  }\n  if (geocoderHandler != null) {\n    pipeline.addLast(\"geocoder\",geocoderHandler);\n// bug_start\n  }\n  if (geolocationHandler != null) {\n    pipeline.addLast(\"location\",geolocationHandler);\n// bug_end\n  }\n  pipeline.addLast(\"remoteAddress\",new RemoteAddressHandler());\n  addDynamicHandlers(pipeline);\n  if (filterHandler != null) {\n    pipeline.addLast(\"filter\",filterHandler);\n  }\n  if (coordinatesHandler != null) {\n    pipeline.addLast(\"coordinatesHandler\",coordinatesHandler);\n  }\n  if (distanceHandler != null) {\n    pipeline.addLast(\"distance\",distanceHandler);\n  }\n  if (copyAttributesHandler != null) {\n    pipeline.addLast(\"copyAttributes\",copyAttributesHandler);\n  }\n  if (Context.getDataManager() != null) {\n    pipeline.addLast(\"dataHandler\",new DefaultDataHandler());\n  }\n  if (Context.getConfig().getBoolean(\"forward.enable\")) {\n    pipeline.addLast(\"webHandler\",new WebDataHandler(Context.getConfig().getString(\"forward.url\")));\n  }\n  if (commandResultEventHandler != null) {\n    pipeline.addLast(\"CommandResultEventHandler\",commandResultEventHandler);\n  }\n  if (overspeedEventHandler != null) {\n    pipeline.addLast(\"OverspeedEventHandler\",overspeedEventHandler);\n  }\n  if (motionEventHandler != null) {\n    pipeline.addLast(\"MotionEventHandler\",motionEventHandler);\n  }\n  if (geofenceEventHandler != null) {\n    pipeline.addLast(\"GeofenceEventHandler\",geofenceEventHandler);\n  }\n  if (alertEventHandler != null) {\n    pipeline.addLast(\"AlertEventHandler\",alertEventHandler);\n  }\n  if (ignitionEventHandler != null) {\n    pipeline.addLast(\"IgnitionEventHandler\",ignitionEventHandler);\n  }\n  if (maintenanceEventHandler != null) {\n    pipeline.addLast(\"MaintenanceEventHandler\",maintenanceEventHandler);\n  }\n  pipeline.addLast(\"mainHandler\",new MainEventHandler());\n  return pipeline;\n}\n"}
{"INPUT": "private void initialize(){\n  isHorizontal=getSkinnable().getOrientation() == Orientation.HORIZONTAL;\n// bug_start\n  coloredTrack=new Line();\n// bug_end\n  thumb=new Circle();\n  thumb.setStrokeWidth(2);\n  thumb.setRadius(7);\n  thumb.setFill(thumbColor);\n  thumb.setStroke(thumbColor);\n  thumb.getStyleClass().setAll(\"thumb\");\n  track=new Line();\n  track.setStroke(trackColor);\n  track.setStrokeWidth(3);\n  track.getStyleClass().setAll(\"track\");\n// bug_start\n// bug_end\n  coloredTrack.strokeProperty().bind(thumb.strokeProperty());\n  coloredTrack.strokeWidthProperty().bind(track.strokeWidthProperty());\n  sliderValue=new Text();\n  sliderValue.setStroke(Color.WHITE);\n  sliderValue.setFont(new Font(10));\n  sliderValue.getStyleClass().setAll(\"sliderValue\");\n  animatedThumb=new StackPane();\n  animatedThumb.getChildren().add(sliderValue);\n  getChildren().clear();\n  getChildren().addAll(track,coloredTrack,animatedThumb,thumb);\n}\n"}
{"INPUT": "@Test public void testSlidingTimeWindow(){\n  final int NUM_ELEMENTS_PER_KEY=numElementsPerKey();\n  final int WINDOW_SIZE=windowSize();\n  final int WINDOW_SLIDE=windowSlide();\n  final int NUM_KEYS=numKeys();\n  FailingSource.reset();\n  try {\n    StreamExecutionEnvironment env=StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\",cluster.getLeaderRPCPort());\n// bug_start\n// bug_end\n    env.setParallelism(PARALLELISM);\n// bug_start\n    env.setMaxParallelism(2 * PARALLELISM);\n// bug_end\n    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n    env.enableCheckpointing(100);\n    env.setRestartStrategy(RestartStrategies.fixedDelayRestart(3,0));\n    env.getConfig().disableSysoutLogging();\n    env.setStateBackend(this.stateBackend);\n    env.addSource(new FailingSource(NUM_KEYS,NUM_ELEMENTS_PER_KEY,NUM_ELEMENTS_PER_KEY / 3)).rebalance().keyBy(0).timeWindow(Time.of(WINDOW_SIZE,MILLISECONDS),Time.of(WINDOW_SLIDE,MILLISECONDS)).apply(new RichWindowFunction<Tuple2<Long,IntType>,Tuple4<Long,Long,Long,IntType>,Tuple,TimeWindow>(){\n      private boolean open=false;\n      @Override public void open(      Configuration parameters){\n        assertEquals(PARALLELISM,getRuntimeContext().getNumberOfParallelSubtasks());\n        open=true;\n      }\n      @Override public void apply(      Tuple tuple,      TimeWindow window,      Iterable<Tuple2<Long,IntType>> values,      Collector<Tuple4<Long,Long,Long,IntType>> out){\n        assertTrue(open);\n        int sum=0;\n        long key=-1;\n        for (        Tuple2<Long,IntType> value : values) {\n          sum+=value.f1.value;\n          key=value.f0;\n        }\n        out.collect(new Tuple4<>(key,window.getStart(),window.getEnd(),new IntType(sum)));\n      }\n    }\n).addSink(new ValidatingSink(NUM_KEYS,NUM_ELEMENTS_PER_KEY / WINDOW_SLIDE)).setParallelism(1);\n    tryExecute(env,\"Tumbling Window Test\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail(e.getMessage());\n  }\n}\n"}
{"INPUT": "private static SessionTimeoutRestorer unbind(HttpSession s){\n  if (s == null)   return null;\n  SessionTimeoutRestorer r=null;\n  try {\n    r=(SessionTimeoutRestorer)s.getAttribute(KEY);\n// bug_start\n// bug_end\n  }\n catch (  Exception ex) {\n    logger.trace(\"\",ex);\n  }\n// bug_start\n  s.removeAttribute(KEY);\n// bug_end\n  return r;\n}\n"}
{"INPUT": "protected static SessionFactory createSessionFactory(Properties props){\n  Configuration conf=new Configuration();\n  URL xml=HibernateTestSupport.class.getClassLoader().getResource(\"test-hibernate.cfg.xml\");\n  props.put(CacheEnvironment.EXPLICIT_VERSION_CHECK,\"true\");\n// bug_start\n// bug_end\n  conf.addProperties(props);\n// bug_start\n  conf.configure(xml);\n// bug_end\n  final SessionFactory sf=conf.buildSessionFactory();\n  sf.getStatistics().setStatisticsEnabled(true);\n  return sf;\n}\n"}
{"INPUT": "public boolean establishesBFC(){\n// bug_start\n  IdentValue display=getIdent(CSSName.DISPLAY);\n// bug_end\n  FSDerivedValue value=valueByName(CSSName.POSITION);\n  if (value instanceof FunctionValue) {\n    return false;\n  }\n else {\n// bug_start\n// bug_end\n    IdentValue position=(IdentValue)value;\n    return isFloated() || position == IdentValue.ABSOLUTE || position == IdentValue.FIXED || display == IdentValue.INLINE_BLOCK || display == IdentValue.TABLE_CELL || !isIdent(CSSName.OVERFLOW,IdentValue.VISIBLE);\n  }\n}\n"}
{"INPUT": "private byte[] transform(String className,Consumer<ClassVisitor> reader,ClassVisitorChain chain){\n  try {\n    ClassWriter writer=new ClassWriter(ClassWriter.COMPUTE_MAXS);\n    ClassVisitor next=writer;\n    next=new LowerBytecodeVersion(next,targetVersion);\n    if (targetVersion < Opcodes.V1_7) {\n      next=new SwallowSuppressedExceptions(next);\n      next=new RemoveMethodHandlesLookupReferences(next);\n// bug_start\n      next=new RemoveLambdaHiddenReferences(next);\n// bug_end\n      next=new RequireNonNull(next);\n    }\n// bug_start\n// bug_end\n    next=new FixInvokeStaticOnInterfaceMethod(next);\n    next=chain.wrap(next);\n    reader.accept(next);\n    return writer.toByteArray();\n  }\n catch (  Throwable t) {\n    throw new RuntimeException(\"Failed to backport class: \" + className,t);\n  }\n}\n"}
{"INPUT": "public void close() throws JMSException {\n  checkClosed();\n  try {\n    stop();\nsynchronized (this) {\n      if (!closed.get()) {\n        closing.set(true);\n        if (advisoryConsumer != null) {\n          advisoryConsumer.dispose();\n          advisoryConsumer=null;\n        }\n        for (Iterator i=this.sessions.iterator(); i.hasNext(); ) {\n          ActiveMQSession s=(ActiveMQSession)i.next();\n          s.dispose();\n        }\n        for (Iterator i=this.connectionConsumers.iterator(); i.hasNext(); ) {\n          ActiveMQConnectionConsumer c=(ActiveMQConnectionConsumer)i.next();\n          c.dispose();\n        }\n        for (Iterator i=this.inputStreams.iterator(); i.hasNext(); ) {\n          ActiveMQInputStream c=(ActiveMQInputStream)i.next();\n          c.dispose();\n        }\n        for (Iterator i=this.outputStreams.iterator(); i.hasNext(); ) {\n          ActiveMQOutputStream c=(ActiveMQOutputStream)i.next();\n          c.dispose();\n        }\n        if (isConnectionInfoSentToBroker) {\n          syncSendPacket(info.createRemoveCommand(),closeTimeout);\n// bug_start\n// bug_end\n        }\n// bug_start\n        asyncSendPacket(new ShutdownInfo());\n// bug_end\n        ServiceSupport.dispose(this.transport);\n        started.set(false);\n        sessionTaskRunner.shutdown();\n        closed.set(true);\n        closing.set(false);\n      }\n    }\n  }\n  finally {\n    factoryStats.removeConnection(this);\n  }\n}\n"}
{"INPUT": "@Override public void visitTransform(TransformTreeNode node){\n  toFinalize.removeAll(node.getInput().expand());\n  AppliedPTransform<?,?,?> appliedTransform=getAppliedTransform(node);\n// bug_start\n// bug_end\n  if (node.getInput().expand().isEmpty()) {\n    rootTransforms.add(appliedTransform);\n  }\n else {\n    for (    PValue value : node.getInput().expand()) {\n      valueToConsumers.get(value).add(appliedTransform);\n// bug_start\n      stepNames.put(appliedTransform,genStepName());\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "private void preload(int from,int to){\n  int start;\n  int end;\n  if (from < to) {\n    start=Math.max(lastEnd,from);\n    end=to;\n  }\n else {\n    start=to;\n    end=Math.min(lastStart,from);\n  }\n  end=Math.min(totalItemCount,end);\n  start=Math.min(totalItemCount,Math.max(0,start));\n  List<T> items=getItems(start,end);\n  if (from < to) {\n// bug_start\n    for (int i=items.size() - 1; i >= 0; i--) {\n// bug_end\n      preloadItem(items,i);\n    }\n  }\n else {\n// bug_start\n    final int numItems=items.size();\n    for (int i=0; i < numItems; i++) {\n// bug_end\n      preloadItem(items,i);\n    }\n  }\n  lastStart=start;\n  lastEnd=end;\n}\n"}
{"INPUT": "public void shutdown(ShutdownListener listener){\nsynchronized (monitor) {\n    if (this.listener != null) {\n      throw new ElasticSearchIllegalStateException(\"Shutdown was already called on this thread pool\");\n    }\n    if (isTerminated()) {\n      listener.onTerminated();\n    }\n else {\n      this.listener=listener;\n    }\n// bug_start\n    shutdown();\n// bug_end\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {\n  if (partialFrame == null) {\n    partialFrame=receiveFrame();\n  }\n  try {\n    partialFrame.handle(data);\n  }\n catch (  WebSocketException e) {\n// bug_start\n// bug_end\n    markReadsBroken(e);\n    if (WebSocketLogger.REQUEST_LOGGER.isDebugEnabled()) {\n      WebSocketLogger.REQUEST_LOGGER.debugf(e,\"receive failed due to Exception\");\n    }\n// bug_start\n    WebSockets.sendClose(new CloseMessage(CloseMessage.WRONG_CODE,e.getMessage()).toByteBuffer(),this,null);\n// bug_end\n    throw new IOException(e);\n  }\n  if (partialFrame.isDone()) {\n    PartialFrame p=this.partialFrame;\n    this.partialFrame=null;\n    return p;\n  }\n  return null;\n}\n"}
{"INPUT": "@Override public void onClick(ClickEvent event){\n  Element el=Element.as(event.getNativeEvent().getEventTarget());\n  while (!el.getClassName().contains(VDebugWindow.STYLENAME + \"-message\")) {\n// bug_start\n    el=el.getParentElement();\n// bug_end\n    if (el == contentElement) {\n      return;\n    }\n// bug_start\n// bug_end\n  }\n  selectText(el);\n}\n"}
{"INPUT": "public static void processQuery(MBeanServerConnection mbeanServer,Query query) throws Exception {\n// bug_start\n  List<Result> resList=new ArrayList<Result>();\n// bug_end\n  ObjectName oName=new ObjectName(query.getObj());\n  Set<ObjectName> queryNames=mbeanServer.queryNames(oName,null);\n  for (  ObjectName queryName : queryNames) {\n// bug_start\n// bug_end\n    MBeanInfo info=mbeanServer.getMBeanInfo(queryName);\n    ObjectInstance oi=mbeanServer.getObjectInstance(queryName);\n    List<String> queryAttributes=query.getAttr();\n    if (queryAttributes == null || queryAttributes.size() == 0) {\n      MBeanAttributeInfo[] attrs=info.getAttributes();\n      for (      MBeanAttributeInfo attrInfo : attrs) {\n        query.addAttr(attrInfo.getName());\n      }\n    }\n    try {\n      if (query.getAttr() != null && query.getAttr().size() > 0) {\n        log.debug(\"Started query: \" + query);\n        AttributeList al=mbeanServer.getAttributes(queryName,query.getAttr().toArray(new String[query.getAttr().size()]));\n        for (        Attribute attribute : al.asList()) {\n          getResult(resList,info,oi,(Attribute)attribute,query);\n        }\n        if (log.isDebugEnabled()) {\n          log.debug(\"Finished query.\");\n        }\n        query.setResults(resList);\n        runFiltersForQuery(query);\n        if (log.isDebugEnabled()) {\n          log.debug(\"Finished running filters: \" + query);\n        }\n      }\n    }\n catch (    UnmarshalException ue) {\n      if (ue.getCause() != null && ue.getCause() instanceof ClassNotFoundException) {\n        log.debug(\"Bad unmarshall, continuing. This is probably ok and due to something like this: \" + \"http://ehcache.org/xref/net/sf/ehcache/distribution/RMICacheManagerPeerListener.html#52\",ue.getMessage());\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  Log.d(\"ERROR\",this.toString());\n  setContentView(R.layout.activity_splash);\n  try {\n// bug_start\n// bug_end\n    tf=Typeface.createFromAsset(getAssets(),\"fonts/Roboto-Regular.ttf\");\n    tf2=Typeface.createFromAsset(getAssets(),\"fonts/Raleway-Medium.ttf\");\n// bug_start\n    tf3=Typeface.createFromAsset(getAssets(),\"fonts/Gidole-Regular.ttf\");\n// bug_end\n  }\n catch (  Exception e) {\n  }\n  if (Build.VERSION.SDK_INT >= 23) {\n    requestPermissions();\n  }\n else {\n    final Handler handler=new Handler();\n    handler.postDelayed(new Runnable(){\n      @Override public void run(){\n        Intent i=new Intent(SplashActivity.this,HomeActivity.class);\n        startActivity(i);\n        finish();\n      }\n    }\n,1000);\n  }\n}\n"}
{"INPUT": "@Override protected void onCreate(Bundle savedInstanceState){\n// bug_start\n  setStatusBarTransparent();\n// bug_end\n  super.onCreate(savedInstanceState);\n  ButterKnife.bind(this);\n// bug_start\n// bug_end\n  getIntentExtras();\n  setUpRecyclerView();\n  checkIsEmpty();\n  setUpToolBar();\n  if (shouldColorNavigationBar())   setNavigationBarThemeColor();\n  setStatusBarThemeColor();\n}\n"}
{"INPUT": "private Promise<Void> onNewMessages(Peer peer,List<Message> messages){\n  assertTrue(messages.size() != 0);\n  boolean isConversationVisible=isConversationVisible(peer);\n  ConversationState state=conversationStates.getValue(peer.getUnuqueId());\n  Message topMessage=null;\n  int unreadCount=0;\n  long maxInDate=0;\n  for (  Message m : messages) {\n    if (topMessage == null || topMessage.getSortDate() < m.getSortDate()) {\n      topMessage=m;\n    }\n    if (m.getSenderId() != myUid()) {\n      if (m.getSortDate() > state.getInReadDate()) {\n        unreadCount++;\n// bug_start\n// bug_end\n      }\n// bug_start\n      maxInDate=Math.max(maxInDate,m.getSortDate());\n// bug_end\n    }\n  }\n  conversation(peer).addOrUpdateItems(messages);\n  boolean isRead=false;\n  if (unreadCount != 0) {\n    if (isConversationVisible) {\n      if (maxInDate > 0) {\n        state=state.changeInReadDate(maxInDate).changeInMaxDate(maxInDate).changeCounter(0);\n        context().getMessagesModule().getPlainReadActor().send(new CursorReaderActor.MarkRead(peer,maxInDate));\n        context().getNotificationsModule().onOwnRead(peer,maxInDate);\n        isRead=true;\n        conversationStates.addOrUpdateItem(state);\n      }\n    }\n else {\n      state=state.changeCounter(state.getUnreadCount() + unreadCount);\n      if (maxInDate > 0) {\n        state=state.changeInMaxDate(maxInDate);\n      }\n      conversationStates.addOrUpdateItem(state);\n      notifyActiveDialogsVM();\n    }\n  }\n  if (maxInDate > 0 && !isRead) {\n    context().getMessagesModule().getPlainReceiverActor().send(new CursorReceiverActor.MarkReceived(peer,maxInDate));\n  }\n  Promise<Void> res=getDialogsRouter().onMessage(peer,topMessage,state.getUnreadCount());\n  if (!isConversationVisible) {\n    for (    Message m : messages) {\n      if (m.getSenderId() != myUid()) {\n        boolean hasCurrentMention=false;\n        if (m.getContent() instanceof TextContent) {\n          if (((TextContent)m.getContent()).getMentions().contains(myUid())) {\n            hasCurrentMention=true;\n          }\n        }\n        context().getNotificationsModule().onInMessage(peer,m.getSenderId(),m.getSortDate(),ContentDescription.fromContent(m.getContent()),hasCurrentMention);\n      }\n    }\n  }\n  return res;\n}\n"}
{"INPUT": "public void lifecycleEvent(LifecycleEvent event){\n  container=event.getLifecycle();\n  if (container instanceof Context) {\n    namingResources=((Context)container).getNamingResources();\n    logger=log;\n  }\n else   if (container instanceof Server) {\n    namingResources=((Server)container).getGlobalNamingResources();\n  }\n else {\n    return;\n  }\n  if (Lifecycle.START_EVENT.equals(event.getType())) {\n    if (initialized)     return;\n    Hashtable<String,Object> contextEnv=new Hashtable<String,Object>();\n    try {\n      namingContext=new NamingContext(contextEnv,getName());\n    }\n catch (    NamingException e) {\n    }\n    ContextAccessController.setSecurityToken(getName(),container);\n    ContextBindings.bindContext(container,namingContext,container);\n    if (log.isDebugEnabled()) {\n      log.debug(\"Bound \" + container);\n    }\n    ContextAccessController.setWritable(getName(),container);\n    try {\n      createNamingContext();\n    }\n catch (    NamingException e) {\n      logger.error(sm.getString(\"naming.namingContextCreationFailed\",e));\n    }\n// bug_start\n// bug_end\n    if (container instanceof Context) {\n      ContextAccessController.setReadOnly(getName());\n      try {\n        ContextBindings.bindClassLoader(container,container,((Container)container).getLoader().getClassLoader());\n      }\n catch (      NamingException e) {\n        logger.error(sm.getString(\"naming.bindFailed\",e));\n      }\n    }\n    if (container instanceof Server) {\n// bug_start\n      namingResources.addPropertyChangeListener(this);\n// bug_end\n      org.apache.naming.factory.ResourceLinkFactory.setGlobalContext(namingContext);\n      try {\n        ContextBindings.bindClassLoader(container,container,this.getClass().getClassLoader());\n      }\n catch (      NamingException e) {\n        logger.error(sm.getString(\"naming.bindFailed\",e));\n      }\n      if (container instanceof StandardServer) {\n        ((StandardServer)container).setGlobalNamingContext(namingContext);\n      }\n    }\n    initialized=true;\n  }\n else   if (Lifecycle.STOP_EVENT.equals(event.getType())) {\n    if (!initialized)     return;\n    ContextAccessController.setWritable(getName(),container);\n    ContextBindings.unbindContext(container,container);\n    if (container instanceof Context) {\n      ContextBindings.unbindClassLoader(container,container,((Container)container).getLoader().getClassLoader());\n    }\n    if (container instanceof Server) {\n      namingResources.removePropertyChangeListener(this);\n      ContextBindings.unbindClassLoader(container,container,this.getClass().getClassLoader());\n    }\n    ContextAccessController.unsetSecurityToken(getName(),container);\n    namingContext=null;\n    envCtx=null;\n    compCtx=null;\n    initialized=false;\n  }\n}\n"}
{"INPUT": "@Override public void onCreate(Bundle icicle){\n  this.mTestPath=(String)icicle.get(\"path\");\n  String timeout_str=(String)icicle.get(\"timeout\");\n  if (timeout_str != null) {\n    try {\n      this.mTimeoutInMillis=Integer.parseInt(timeout_str);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n  }\n  String delay_str=(String)icicle.get(\"delay\");\n  if (delay_str != null) {\n    try {\n      this.mDelay=Integer.parseInt(delay_str);\n    }\n catch (    Exception e) {\n    }\n  }\n  String r=(String)icicle.get(\"rebaseline\");\n  this.mRebaseline=(r != null && r.toLowerCase().equals(\"true\"));\n// bug_start\n  super.onCreate(icicle);\n// bug_end\n  String logtime=(String)icicle.get(\"logtime\");\n  this.mLogtime=(logtime != null && logtime.toLowerCase().equals(\"true\"));\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override public void call(Subscriber<? super Integer> t1){\n  try {\n    t1.onNext(0);\n// bug_start\n    t1.onNext(1);\n// bug_end\n  }\n catch (  Throwable swallow) {\n  }\n// bug_start\n// bug_end\n  t1.onCompleted();\n}\n"}
{"INPUT": "public void initialize(ConnectorConfig connectorConfig){\n// bug_start\n  log.debug(\"Initializing connector {} with config {}\",connName,config);\n// bug_end\n  try {\n    this.config=connectorConfig.originalsStrings();\n// bug_start\n// bug_end\n    connector.initialize(new ConnectorContext(){\n      @Override public void requestTaskReconfiguration(){\n        ctx.requestTaskReconfiguration();\n      }\n      @Override public void raiseError(      Exception e){\n        log.error(\"Connector raised an error {}\",connName,e);\n        onFailure(e);\n        ctx.raiseError(e);\n      }\n    }\n);\n  }\n catch (  Throwable t) {\n    log.error(\"Error initializing connector {}\",connName,t);\n    onFailure(t);\n  }\n}\n"}
{"INPUT": "public void setLoadComplete(boolean hasComplete){\n  mHasLoadComplete=hasComplete;\n// bug_start\n  stopLoadMore();\n// bug_end\n  if (needAddFooterView()) {\n// bug_start\n// bug_end\n    if (!hasComplete && mEnablePullLoad && mFooterCallBack != null) {\n      mFooterCallBack.onStateRefreshing();\n    }\n  }\n  mContentView.setLoadComplete(hasComplete);\n}\n"}
{"INPUT": "@Override protected void handleConnected(CommandConnected connected){\n  if (isTlsHostnameVerificationEnable && remoteHostName != null && !verifyTlsHostName(remoteHostName,ctx)) {\n    log.warn(\"[{}] Failed to verify hostname of {}\",ctx.channel(),remoteHostName);\n    ctx.close();\n    return;\n  }\n  checkArgument(state == State.SentConnectFrame);\n  if (log.isDebugEnabled()) {\n    log.debug(\"{} Connection is ready\",ctx.channel());\n  }\n// bug_start\n// bug_end\n  connectionFuture.complete(null);\n// bug_start\n  remoteEndpointProtocolVersion=connected.getProtocolVersion();\n// bug_end\n  state=State.Ready;\n}\n"}
{"INPUT": "private boolean isSupportedForView(ResourceType type){\nswitch (type) {\ncase CODE:\n// bug_start\ncase XML:\n// bug_end\ncase ARSC:\ncase FONT:\ncase IMG:\ncase LIB:\n    return false;\ncase MANIFEST:\n// bug_start\n// bug_end\ncase UNKNOWN:\n  return true;\n}\nreturn true;\n}\n"}
{"INPUT": "@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\n  View view=inflater.inflate(R.layout.fragment_live_updates,container,false);\n  listView=(ExpandableListView)view.findViewById(android.R.id.list);\n  View bottomShadowView=inflater.inflate(R.layout.card_bottom_divider,listView,false);\n  listView.addFooterView(bottomShadowView);\n  adapter=new LocalIndexesAdapter(this);\n// bug_start\n  listView.setAdapter(adapter);\n// bug_end\n  listView.setOnChildClickListener(new ExpandableListView.OnChildClickListener(){\n    @Override public boolean onChildClick(    ExpandableListView parent,    View v,    int groupPosition,    int childPosition,    long id){\n      if (!processing && InAppHelper.isSubscribedToLiveUpdates()) {\n        final FragmentManager fragmentManager=getChildFragmentManager();\n        LiveUpdatesSettingsDialogFragment.createInstance(adapter.getChild(groupPosition,childPosition).getFileName()).show(fragmentManager,\"settings\");\n        return true;\n      }\n else {\n        return false;\n      }\n    }\n  }\n);\n  progressBar=(ProgressBar)view.findViewById(R.id.progress);\n  if (!Version.isDeveloperVersion(getMyApplication())) {\n    subscriptionHeader=inflater.inflate(R.layout.live_updates_header,listView,false);\n    updateSubscriptionHeader();\n    listView.addHeaderView(subscriptionHeader);\n    listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){\n      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){\n        if (position == 0 && !processing && InAppHelper.isSubscribedToLiveUpdates()) {\n          SubscriptionFragment subscriptionFragment=new SubscriptionFragment();\n          subscriptionFragment.setEditMode(true);\n          subscriptionFragment.show(getChildFragmentManager(),SubscriptionFragment.TAG);\n        }\n      }\n    }\n);\n  }\n// bug_start\n// bug_end\n  if (Build.VERSION.SDK_INT >= 11) {\n    loadLocalIndexesTask=new LoadLocalIndexTask(adapter,this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);\n  }\n else {\n    loadLocalIndexesTask=new LoadLocalIndexTask(adapter,this).execute();\n  }\n  return view;\n}\n"}
{"INPUT": "synchronized Closeable lockAndAbortAll() throws IOException {\n  if (infoStream.isEnabled(\"DW\")) {\n    infoStream.message(\"DW\",\"lockAndAbortAll\");\n  }\n  ticketQueue.forcePurge(null);\n  List<ThreadState> threadStates=new ArrayList<>();\n  AtomicBoolean released=new AtomicBoolean(false);\n  final Closeable release=null;\n  try {\n    deleteQueue.clear();\n// bug_start\n// bug_end\n    perThreadPool.lockNewThreadStates();\n// bug_start\n    final int limit=perThreadPool.getMaxThreadStates();\n// bug_end\n    for (int i=0; i < limit; i++) {\n      final ThreadState perThread=perThreadPool.getThreadState(i);\n      perThread.lock();\n      threadStates.add(perThread);\n      abortThreadState(perThread);\n    }\n    deleteQueue.clear();\n    deleteQueue.skipSequenceNumbers(perThreadPool.getActiveThreadStateCount() + 1);\n    flushControl.abortPendingFlushes();\n    flushControl.waitForFlush();\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\",\"finished lockAndAbortAll success=true\");\n    }\n    return release;\n  }\n catch (  Throwable t) {\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\",\"finished lockAndAbortAll success=false\");\n    }\n    try {\n      release.close();\n    }\n catch (    Throwable t1) {\n      t.addSuppressed(t1);\n    }\n    throw t;\n  }\n}\n"}
{"INPUT": "@Override public Void call() throws Exception {\n  if (request.getOnlyReserveSpace()) {\n// bug_start\n// bug_end\n    String path=mBlockWorker.createBlock(request.getSessionId(),request.getBlockId(),mStorageTierAssoc.getAlias(request.getTier()),request.getSpaceToReserve());\n    Protocol.LocalBlockCreateResponse response=Protocol.LocalBlockCreateResponse.newBuilder().setPath(path).build();\n    ctx.writeAndFlush(new RPCProtoMessage(new ProtoMessage(response)));\n  }\n// bug_start\n else {\n    mBlockWorker.requestSpace(request.getSessionId(),request.getBlockId(),request.getSpaceToReserve());\n    ctx.writeAndFlush(RPCProtoMessage.createOkResponse(null));\n  }\n// bug_end\n  return null;\n}\n"}
{"INPUT": "public static void runWebkitOverflowAutoFix(final Element elem){\n// bug_start\n  if (BrowserInfo.get().getWebkitVersion() > 0) {\n// bug_end\n    final String originalOverflow=elem.getStyle().getProperty(\"overflow\");\n    if (\"hidden\".equals(originalOverflow)) {\n      return;\n    }\n    final int scrolltop=elem.getScrollTop();\n    elem.getStyle().setProperty(\"overflow\",\"hidden\");\n    Scheduler.get().scheduleDeferred(new Command(){\n      public void execute(){\n        elem.getStyle().setProperty(\"overflow\",originalOverflow);\n        if (scrolltop > 0 || elem.getScrollTop() > 0) {\n          int scrollvalue=scrolltop;\n          if (scrolltop == 0) {\n            scrollvalue=elem.getScrollTop();\n          }\n          elem.setScrollTop(scrollvalue - 1);\n          elem.setScrollTop(scrollvalue);\n        }\n      }\n    }\n);\n  }\n}\n"}
{"INPUT": "public Date getLastTime(){\n  RealmResults<MessageItem> messages=getMessages();\n  Number max=null;\n// bug_start\n  if (messages.isLoaded()) {\n// bug_end\n    max=messages.where().max(MessageItem.Fields.TIMESTAMP);\n  }\n  if (max != null) {\n    return new Date(max.longValue());\n  }\n else {\n    return null;\n  }\n}\n"}
{"INPUT": "private Object validateComboBox(Object text){\n  if (control instanceof ComboBox && ((ComboBox)control).isEditable()) {\n    final String editorText=((ComboBox<?>)control).getEditor().getText();\n// bug_start\n    text=editorText.isEmpty() ? null : text;\n// bug_end\n  }\n  return text;\n}\n"}
{"INPUT": "@Override public boolean shouldRotateSeamlessly(int oldRotation,int newRotation){\n  if (oldRotation == mUpsideDownRotation || newRotation == mUpsideDownRotation) {\n    return false;\n  }\n  int delta=newRotation - oldRotation;\n  if (delta < 0)   delta+=4;\n  if (delta == Surface.ROTATION_180) {\n    return false;\n  }\n// bug_start\n  if (mTopFullscreenOpaqueWindowState != null && mTopIsFullscreen && mTopFullscreenOpaqueWindowState.getAttrs().rotationAnimation == ROTATION_ANIMATION_JUMPCUT) {\n// bug_end\n    return true;\n  }\n  return false;\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") private Map<String,Object> buildSupportFileBundle(List<Object> allOperations,List<Object> allModels){\n  Map<String,Object> bundle=new HashMap<>(config.additionalProperties());\n  bundle.put(\"apiPackage\",config.apiPackage());\n  Map<String,Object> apis=new HashMap<>();\n  apis.put(\"apis\",allOperations);\n  URL url=URLPathUtils.getServerURL(openAPI,config.serverVariableOverrides());\n  bundle.put(\"openAPI\",openAPI);\n  bundle.put(\"basePath\",basePath);\n  bundle.put(\"basePathWithoutHost\",basePathWithoutHost);\n  bundle.put(\"scheme\",URLPathUtils.getScheme(url,config));\n  bundle.put(\"host\",url.getHost());\n// bug_start\n  if (url.getPort() != 80) {\n// bug_end\n    bundle.put(\"port\",url.getPort());\n  }\n  bundle.put(\"contextPath\",contextPath);\n  bundle.put(\"apiInfo\",apis);\n  bundle.put(\"models\",allModels);\n  bundle.put(\"apiFolder\",config.apiPackage().replace('.',File.separatorChar));\n  bundle.put(\"modelPackage\",config.modelPackage());\n  Map<String,SecurityScheme> securitySchemeMap=openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null;\n  List<CodegenSecurity> authMethods=config.fromSecurity(securitySchemeMap);\n  if (authMethods != null && !authMethods.isEmpty()) {\n    bundle.put(\"authMethods\",authMethods);\n    bundle.put(\"hasAuthMethods\",true);\n    if (ProcessUtils.hasOAuthMethods(authMethods)) {\n      bundle.put(\"hasOAuthMethods\",true);\n      bundle.put(\"oauthMethods\",ProcessUtils.getOAuthMethods(authMethods));\n    }\n    if (ProcessUtils.hasHttpBearerMethods(authMethods)) {\n      bundle.put(\"hasHttpBearerMethods\",true);\n    }\n    if (ProcessUtils.hasHttpSignatureMethods(authMethods)) {\n      bundle.put(\"hasHttpSignatureMethods\",true);\n    }\n    if (ProcessUtils.hasHttpBasicMethods(authMethods)) {\n      bundle.put(\"hasHttpBasicMethods\",true);\n    }\n    if (ProcessUtils.hasApiKeyMethods(authMethods)) {\n      bundle.put(\"hasApiKeyMethods\",true);\n    }\n  }\n  List<CodegenServer> servers=config.fromServers(openAPI.getServers());\n  if (servers != null && !servers.isEmpty()) {\n    bundle.put(\"servers\",servers);\n    bundle.put(\"hasServers\",true);\n  }\n  if (openAPI.getExternalDocs() != null) {\n    bundle.put(\"externalDocs\",openAPI.getExternalDocs());\n  }\n  for (int i=0; i < allModels.size() - 1; i++) {\n    HashMap<String,CodegenModel> cm=(HashMap<String,CodegenModel>)allModels.get(i);\n    CodegenModel m=cm.get(\"model\");\n    m.hasMoreModels=true;\n  }\n  config.postProcessSupportingFileData(bundle);\n  if (GlobalSettings.getProperty(\"debugSupportingFiles\") != null) {\n    LOGGER.info(\"############ Supporting file info ############\");\n    Json.prettyPrint(bundle);\n  }\n  return bundle;\n}\n"}
{"INPUT": "private void notifyChange(final String what){\n  final Intent intent=new Intent(what);\n  final int position=getPosition();\n// bug_start\n  if (position >= 0) {\n// bug_end\n    final Song currentSong=playingQueue.get(position);\n    intent.putExtra(\"id\",currentSong.id);\n    intent.putExtra(\"artist\",currentSong.artistName);\n    intent.putExtra(\"album\",currentSong.albumName);\n    intent.putExtra(\"track\",currentSong.title);\n  }\n  intent.putExtra(\"playing\",isPlaying());\n  sendStickyBroadcast(intent);\n}\n"}
{"INPUT": "@Override public BedrockPong onQuery(InetSocketAddress inetSocketAddress){\n  connector.getLogger().debug(inetSocketAddress + \" has pinged you!\");\n  IGeyserConfiguration config=connector.getConfig();\n  ServerStatusInfo serverInfo=connector.getPassthroughThread().getInfo();\n  BedrockPong pong=new BedrockPong();\n  pong.setEdition(\"MCPE\");\n  pong.setGameType(\"Default\");\n  pong.setNintendoLimited(false);\n  pong.setProtocolVersion(GeyserConnector.BEDROCK_1_14_PROTOCOL_VERSION);\n  pong.setVersion(GeyserConnector.BEDROCK_PACKET_CODEC.getMinecraftVersion());\n  pong.setIpv4Port(config.getBedrock().getPort());\n// bug_start\n  if (connector.getConfig().isPingPassthrough()) {\n// bug_end\n    pong.setMotd(MessageUtils.getBedrockMessage(serverInfo.getDescription()));\n    pong.setSubMotd(config.getBedrock().getMotd2());\n    pong.setPlayerCount(serverInfo.getPlayerInfo().getOnlinePlayers());\n    pong.setMaximumPlayerCount(serverInfo.getPlayerInfo().getMaxPlayers());\n  }\n else {\n    pong.setPlayerCount(connector.getPlayers().size());\n    pong.setMaximumPlayerCount(config.getMaxPlayers());\n    pong.setMotd(config.getBedrock().getMotd1());\n    pong.setMotd(config.getBedrock().getMotd2());\n  }\n  return pong;\n}\n"}
{"INPUT": "public void update(long value,long timestamp){\n  rescaleIfNeeded();\n  lockForRegularUsage();\n  try {\n    final double itemWeight=weight(timestamp - startTime);\n    final WeightedSample sample=new WeightedSample(value,itemWeight);\n    final double priority=itemWeight / ThreadLocalRandomProxy.current().nextDouble();\n    final long newCount=count.incrementAndGet();\n// bug_start\n    if (newCount <= size) {\n// bug_end\n      values.put(priority,sample);\n    }\n else {\n      Double first=values.firstKey();\n      if (first < priority && values.putIfAbsent(priority,sample) == null) {\n        while (values.remove(first) == null) {\n          first=values.firstKey();\n        }\n      }\n    }\n  }\n  finally {\n    unlockForRegularUsage();\n  }\n}\n"}
{"INPUT": "private List<String> splitIntoAllophoneList(String allophoneString,boolean includeStressAndSyllableMarkers){\n  List<String> phones=new ArrayList<String>();\n  for (int i=0; i < allophoneString.length(); i++) {\n    String one=allophoneString.substring(i,i + 1);\n    if (getIgnoreChars().contains(one)) {\n      if (includeStressAndSyllableMarkers)       phones.add(one);\n      continue;\n    }\n else     if (one.equals(\" \")) {\n      continue;\n    }\n    String ph=null;\n    for (int l=maxAllophoneSymbolLength; l >= 1; l--) {\n      if (i + l <= allophoneString.length()) {\n        ph=allophoneString.substring(i,i + l);\n        if (allophones.containsKey(ph)) {\n          i+=l - 1;\n          break;\n        }\n      }\n    }\n// bug_start\n    if (ph != null) {\n// bug_end\n      phones.add(ph);\n    }\n else {\n      throw new IllegalArgumentException(\"Found unknown symbol `\" + allophoneString.charAt(i) + \"' in phonetic string `\"+ allophoneString+ \"' -- ignoring.\");\n    }\n  }\n  return phones;\n}\n"}
{"INPUT": "protected void updateWindowPosition(){\n  VWindow window=getWidget();\n  WindowState state=getState();\n  if (state.windowMode == WindowMode.NORMAL) {\n// bug_start\n    if (!state.centered) {\n// bug_end\n      window.setPopupPosition(state.positionX,state.positionY);\n    }\n  }\n else   if (state.windowMode == WindowMode.MAXIMIZED) {\n    window.setPopupPositionNoUpdate(0,0);\n    window.bringToFront();\n  }\n}\n"}
{"INPUT": "private FixingResult addSpacesAroundSpansUntilFixed(SpannableStringBuilder builder,int widthMeasureSpec,int heightMeasureSpec){\n  Object[] spans=builder.getSpans(0,builder.length(),Object.class);\n  List<Object> spansWithSpacesBefore=new ArrayList<Object>(spans.length);\n  List<Object> spansWithSpacesAfter=new ArrayList<Object>(spans.length);\n  for (  Object span : spans) {\n    int spanStart=builder.getSpanStart(span);\n// bug_start\n    if (isNotSpace(builder,spanStart - 1)) {\n// bug_end\n      builder.insert(spanStart,\" \");\n      spansWithSpacesBefore.add(span);\n    }\n    int spanEnd=builder.getSpanEnd(span);\n    if (isNotSpace(builder,spanEnd)) {\n      builder.insert(spanEnd,\" \");\n      spansWithSpacesAfter.add(span);\n    }\n    try {\n      setTextAndMeasure(builder,widthMeasureSpec,heightMeasureSpec);\n      return FixingResult.fixed(spansWithSpacesBefore,spansWithSpacesAfter);\n    }\n catch (    IndexOutOfBoundsException notFixed) {\n    }\n  }\n  return FixingResult.notFixed();\n}\n"}
{"INPUT": "static private boolean isProperIntent(Intent intent){\n// bug_start\n  return !(TextUtils.isEmpty(intent.getAction()) || null == intent.getData() || TextUtils.isEmpty(intent.getData().getSchemeSpecificPart()) || intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));\n// bug_end\n}\n"}
{"INPUT": "protected String toCamelCase(String str){\n  boolean toLower=str.toUpperCase().equals(str);\n  StringBuilder builder=new StringBuilder(str.length());\n  for (int i=0; i < str.length(); i++) {\n// bug_start\n    if (str.charAt(i) == '_') {\n// bug_end\n      i+=1;\n      if (i < str.length()) {\n        builder.append(Character.toUpperCase(str.charAt(i)));\n      }\n    }\n else     if (toLower) {\n      builder.append(Character.toLowerCase(str.charAt(i)));\n    }\n else {\n      builder.append(str.charAt(i));\n    }\n  }\n  return builder.toString();\n}\n"}
{"INPUT": "void updateResumePosition(){\n// bug_start\n  if (player == null)   return;\n// bug_end\n  playbackInfo.setResumeWindow(player.getCurrentWindowIndex());\n  playbackInfo.setResumePosition(player.isCurrentWindowSeekable() ? Math.max(0,player.getCurrentPosition()) : C.TIME_UNSET);\n}\n"}
{"INPUT": "@Override public void onRemoteOperationFinish(RemoteOperation operation,RemoteOperationResult result){\n  super.onRemoteOperationFinish(operation,result);\n  if (result.isSuccess() || (operation instanceof GetSharesForFileOperation && result.getCode() == RemoteOperationResult.ResultCode.SHARE_NOT_FOUND)) {\n    Log_OC.d(TAG,\"Refreshing view on successful operation or finished refresh\");\n    refreshSharesFromStorageManager();\n  }\n// bug_start\n  if (operation instanceof CreateShareViaLinkOperation) {\n// bug_end\n    String link=((OCShare)(result.getData().get(0))).getShareLink();\n    Log_OC.d(TAG,\"Share link = \" + link);\n    Intent intentToShareLink=new Intent(Intent.ACTION_SEND);\n    intentToShareLink.putExtra(Intent.EXTRA_TEXT,link);\n    intentToShareLink.setType(HTTP.PLAIN_TEXT_TYPE);\n    String[] packagesToExclude=new String[]{getPackageName()};\n    DialogFragment chooserDialog=ShareLinkToDialog.newInstance(intentToShareLink,packagesToExclude);\n    chooserDialog.show(getSupportFragmentManager(),FTAG_CHOOSER_DIALOG);\n  }\n}\n"}
{"INPUT": "private void generalUnsignApk(HashMap<String,Integer> compressData) throws IOException, InterruptedException {\n  System.out.printf(\"general unsigned apk: %s\\n\",mUnSignedApk.getName());\n  File tempOutDir=new File(mOutDir.getAbsolutePath(),TypedValue.UNZIP_FILE_PATH);\n  if (!tempOutDir.exists()) {\n    System.err.printf(\"Missing apk unzip files, path=%s\\n\",tempOutDir.getAbsolutePath());\n    System.exit(-1);\n  }\n  File[] unzipFiles=tempOutDir.listFiles();\n  List<File> collectFiles=new ArrayList<>();\n  for (  File f : unzipFiles) {\n    String name=f.getName();\n    if (name.equals(\"res\") || name.equals(config.mMetaName) || name.equals(\"resources.arsc\")) {\n      continue;\n    }\n    collectFiles.add(f);\n  }\n  File destResDir=new File(mOutDir.getAbsolutePath(),\"res\");\n// bug_start\n  if (!config.mKeepRoot) {\n// bug_end\n    destResDir=new File(mOutDir.getAbsolutePath(),TypedValue.RES_FILE_PATH);\n  }\n  File rawResDir=new File(tempOutDir.getAbsolutePath() + File.separator + \"res\");\n  System.out.printf(\"DestResDir %d rawResDir %d\\n\",FileOperation.getlist(destResDir),FileOperation.getlist(rawResDir));\n  if (FileOperation.getlist(destResDir) != FileOperation.getlist(rawResDir)) {\n    throw new IOException(String.format(\"the file count of %s, and the file count of %s is not equal, there must be some problem\\n\",rawResDir.getAbsolutePath(),destResDir.getAbsolutePath()));\n  }\n  if (!destResDir.exists()) {\n    System.err.printf(\"Missing res files, path=%s\\n\",destResDir.getAbsolutePath());\n    System.exit(-1);\n  }\n  collectFiles.add(destResDir);\n  File rawARSCFile=new File(mOutDir.getAbsolutePath() + File.separator + \"resources.arsc\");\n  if (!rawARSCFile.exists()) {\n    System.err.printf(\"Missing resources.arsc files, path=%s\\n\",rawARSCFile.getAbsolutePath());\n    System.exit(-1);\n  }\n  collectFiles.add(rawARSCFile);\n  FileOperation.zipFiles(collectFiles,mUnSignedApk,compressData);\n  if (!mUnSignedApk.exists()) {\n    throw new IOException(String.format(\"can not found the unsign apk file path=%s\",mUnSignedApk.getAbsolutePath()));\n  }\n}\n"}
{"INPUT": "@Override public Object invoke(ELContext context,Object base,Object method,Class<?>[] paramTypes,Object[] params){\n  if (context == null) {\n    throw new NullPointerException();\n  }\n  if (base == null || method == null) {\n    return null;\n  }\n  ExpressionFactory factory=ExpressionFactory.newInstance();\n  String methodName=(String)factory.coerceToType(method,String.class);\n  Method matchingMethod=null;\n  Class<?> clazz=base.getClass();\n  if (paramTypes != null) {\n    try {\n      matchingMethod=clazz.getMethod(methodName,paramTypes);\n    }\n catch (    NoSuchMethodException e) {\n      throw new MethodNotFoundException(e);\n    }\n  }\n else {\n    int paramCount=0;\n    if (params != null) {\n      paramCount=params.length;\n    }\n    Method[] methods=clazz.getMethods();\n    for (    Method m : methods) {\n// bug_start\n      if (m.getParameterTypes().length == paramCount) {\n// bug_end\n        matchingMethod=m;\n        break;\n      }\n      if (m.isVarArgs()) {\n        matchingMethod=m;\n      }\n    }\n    if (matchingMethod == null) {\n      throw new MethodNotFoundException(\"Unable to find method [\" + methodName + \"] with [\"+ paramCount+ \"] parameters\");\n    }\n  }\n  Class<?>[] parameterTypes=matchingMethod.getParameterTypes();\n  Object[] parameters=null;\n  if (parameterTypes.length > 0) {\n    parameters=new Object[parameterTypes.length];\n    @SuppressWarnings(\"null\") int paramCount=params.length;\n    if (matchingMethod.isVarArgs()) {\n      int varArgIndex=parameterTypes.length - 1;\n      for (int i=0; (i < varArgIndex - 1); i++) {\n        parameters[i]=factory.coerceToType(params[i],parameterTypes[i]);\n      }\n      Class<?> varArgClass=parameterTypes[varArgIndex].getComponentType();\n      for (int i=(varArgIndex); i < paramCount; i++) {\n        Object varargs=Array.newInstance(parameterTypes[paramCount],(paramCount - varArgIndex));\n        Array.set(varargs,i,factory.coerceToType(params[i],varArgClass));\n        parameters[varArgIndex]=varargs;\n      }\n    }\n else {\n      parameters=new Object[parameterTypes.length];\n      for (int i=0; i < parameterTypes.length; i++) {\n        parameters[i]=factory.coerceToType(params[i],parameterTypes[i]);\n      }\n    }\n  }\n  Object result=null;\n  try {\n    result=matchingMethod.invoke(base,parameters);\n  }\n catch (  IllegalArgumentException e) {\n    throw new ELException(e);\n  }\ncatch (  IllegalAccessException e) {\n    throw new ELException(e);\n  }\ncatch (  InvocationTargetException e) {\n    throw new ELException(e.getCause());\n  }\n  context.setPropertyResolved(true);\n  return result;\n}\n"}
{"INPUT": "boolean isPluggedIn(){\n// bug_start\n  return plugged == BatteryManager.BATTERY_PLUGGED_AC || plugged == BatteryManager.BATTERY_PLUGGED_USB;\n// bug_end\n}\n"}
{"INPUT": "protected String calculateCurrentUri(HttpServletRequest request) throws UnsupportedEncodingException {\n  StringBuilder queryBuilder=new StringBuilder();\n  Enumeration paramNames=request.getParameterNames();\n  while (paramNames.hasMoreElements()) {\n    String name=(String)paramNames.nextElement();\n    if (!\"code\".equals(name)) {\n      String[] parameterValues=request.getParameterValues(name);\n      if (parameterValues.length == 0) {\n        queryBuilder.append(URLEncoder.encode(name,\"UTF-8\"));\n      }\n else {\n        for (int i=0; i < parameterValues.length; i++) {\n          String parameterValue=parameterValues[i];\n          queryBuilder.append(URLEncoder.encode(name,\"UTF-8\")).append('=').append(URLEncoder.encode(parameterValue,\"UTF-8\"));\n          if (i + 1 < parameterValues.length) {\n            queryBuilder.append('&');\n          }\n        }\n      }\n    }\n// bug_start\n    if (paramNames.hasMoreElements()) {\n// bug_end\n      queryBuilder.append('&');\n    }\n  }\n  return UrlUtils.buildFullRequestUrl(request.getScheme(),request.getServerName(),getPortResolver().getServerPort(request),request.getRequestURI(),queryBuilder.length() > 0 ? queryBuilder.toString() : null);\n}\n"}
{"INPUT": "private void detachOrCloseSpans(HttpServletRequest request,HttpServletResponse response,SpanAndScope spanFromRequest,Throwable exception){\n  Span span=spanFromRequest.span;\n  if (span != null) {\n    addResponseTagsForSpanWithoutParent(exception,request,response,span);\n// bug_start\n    if (httpStatusSuccessful(response)) {\n// bug_end\n      if (log.isDebugEnabled()) {\n        log.debug(\"Closing the span \" + span + \" since the response was successful\");\n      }\n      if (exception == null || !hasErrorController()) {\n        clearTraceAttribute(request);\n        handler().handleSend(response,exception,span);\n      }\n    }\n else     if (errorAlreadyHandled(request) && !shouldCloseSpan(request)) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Won't detach the span \" + span + \" since error has already been handled\");\n      }\n    }\n else     if ((shouldCloseSpan(request) || isRootSpan(span)) && stillTracingCurrentSpan(span)) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Will close span \" + span + \" since \"+ (shouldCloseSpan(request) ? \"some component marked it for closure\" : \"response was unsuccessful for the root span\"));\n      }\n      handler().handleSend(response,exception,span);\n      if (shouldCloseSpan(request)) {\n        clearTraceAttribute(request);\n      }\n    }\n else     if (span != null || requestHasAlreadyBeenHandled(request)) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Detaching the span \" + span + \" since the response was unsuccessful\");\n      }\n      clearTraceAttribute(request);\n      if (exception == null || !hasErrorController()) {\n        handler().handleSend(response,exception,span);\n      }\n else {\n        span.abandon();\n      }\n    }\n  }\n}\n"}
{"INPUT": "public boolean fetch(List res) throws IOException, CommandNeedRetryException {\n  sink.reset(res);\n  int rowsRet=work.getLeastNumRows();\n  if (rowsRet <= 0) {\n    rowsRet=work.getLimit() >= 0 ? Math.min(work.getLimit() - totalRows,maxRows) : maxRows;\n  }\n  try {\n// bug_start\n    if (rowsRet <= 0) {\n// bug_end\n      fetch.clearFetchContext();\n      return false;\n    }\n    boolean fetched=false;\n    while (sink.getNumRows() < rowsRet) {\n      if (!fetch.pushRow()) {\n        if (work.getLeastNumRows() > 0) {\n          throw new CommandNeedRetryException();\n        }\n        return fetched;\n      }\n      fetched=true;\n    }\n    return true;\n  }\n catch (  CommandNeedRetryException e) {\n    throw e;\n  }\ncatch (  IOException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new IOException(e);\n  }\n finally {\n    totalRows+=sink.getNumRows();\n  }\n}\n"}
{"INPUT": "private void onSynchronizeFolderOperationFinish(SynchronizeFolderOperation operation,RemoteOperationResult result){\n// bug_start\n  if (!result.isSuccess()) {\n// bug_end\n    Toast t=Toast.makeText(this,ErrorMessageAdapter.getErrorCauseMessage(result,operation,getResources()),Toast.LENGTH_LONG);\n    t.show();\n  }\n}\n"}
{"INPUT": "private boolean configureIPv4(boolean enabled){\n  if (VDBG)   Log.d(TAG,\"configureIPv4(\" + enabled + \")\");\n  if (enabled) {\n    mIpv4Address=requestIpv4Address();\n  }\n  if (mIpv4Address == null) {\n    mLog.e(\"No available ipv4 address\");\n    return false;\n  }\n  if (mInterfaceType == TetheringManager.TETHERING_BLUETOOTH) {\n    return configureDhcp(enabled,mIpv4Address,null);\n  }\n  final IpPrefix ipv4Prefix=asIpPrefix(mIpv4Address);\n  final Boolean setIfaceUp;\n// bug_start\n  if (mInterfaceType == TetheringManager.TETHERING_WIFI || mInterfaceType == TetheringManager.TETHERING_WIFI_P2P) {\n// bug_end\n    setIfaceUp=null;\n  }\n else {\n    setIfaceUp=enabled;\n  }\n  if (!mInterfaceCtrl.setInterfaceConfiguration(mIpv4Address,setIfaceUp)) {\n    mLog.e(\"Error configuring interface\");\n    if (!enabled)     stopDhcp();\n    return false;\n  }\n  if (enabled) {\n    mLinkProperties.addLinkAddress(mIpv4Address);\n    mLinkProperties.addRoute(getDirectConnectedRoute(mIpv4Address));\n  }\n else {\n    mLinkProperties.removeLinkAddress(mIpv4Address);\n    mLinkProperties.removeRoute(getDirectConnectedRoute(mIpv4Address));\n  }\n  return configureDhcp(enabled,mIpv4Address,mStaticIpv4ClientAddr);\n}\n"}
{"INPUT": "private void updateRightAffordanceIcon(){\n  IconState state=mRightButton.getIcon();\n// bug_start\n  mRightAffordanceView.setVisibility(state.isVisible ? View.VISIBLE : View.GONE);\n// bug_end\n  mRightAffordanceView.setImageDrawable(state.drawable,state.tint);\n  mRightAffordanceView.setContentDescription(state.contentDescription);\n}\n"}
{"INPUT": "private void invoke(TransformOp op){\n// bug_start\n  if (!KernelFunctionLoader.getInstance().exists(op.name())) {\n// bug_end\n    super.exec(op);\n    return;\n  }\n  if (op.y() != null) {\n    Object[] kernelParams=new Object[]{op.n(),op.x().offset(),op.y().offset(),op.x(),op.y(),op.x().majorStride(),op.y().majorStride(),toArgs(op.extraArgs(),getType(op)),op.z()};\n    try (KernelParamsWrapper kParams=new KernelParamsWrapper(kernelParams).setResultArray(op.z())){\n      invokeFunction(op,kParams.getKernelParameters());\n      kParams.close();\n    }\n catch (    Exception e) {\n      throw new RuntimeException(\"Could not execute kernel\",e);\n    }\n  }\n else {\n    Object[] kernelParams=new Object[]{op.n(),op.x().offset(),op.x(),1,toArgs(op.extraArgs(),getType(op)),op.z()};\n    try (KernelParamsWrapper kParams=new KernelParamsWrapper(kernelParams).setResultArray(op.z())){\n      invokeFunction(op,kParams.getKernelParameters());\n      kParams.close();\n    }\n catch (    Exception e) {\n      throw new RuntimeException(\"Could not execute kernel\",e);\n    }\n  }\n}\n"}
{"INPUT": "public boolean shouldInterceptTouchEvent(MotionEvent ev){\n  final int action=MotionEventCompat.getActionMasked(ev);\n  final int actionIndex=MotionEventCompat.getActionIndex(ev);\n  if (action == MotionEvent.ACTION_DOWN) {\n    cancel();\n  }\n  if (mVelocityTracker == null) {\n    mVelocityTracker=VelocityTracker.obtain();\n  }\n  mVelocityTracker.addMovement(ev);\nswitch (action) {\ncase MotionEvent.ACTION_DOWN:\n{\n      final float x=ev.getX();\n      final float y=ev.getY();\n      final int pointerId=MotionEventCompat.getPointerId(ev,0);\n      saveInitialMotion(x,y,pointerId);\n      final View toCapture=findTopChildUnder((int)x,(int)y);\n      if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {\n        tryCaptureViewForDrag(toCapture,pointerId);\n      }\n      final int edgesTouched=mInitialEdgesTouched[pointerId];\n      if ((edgesTouched & mTrackingEdges) != 0) {\n        mCallback.onEdgeTouched(edgesTouched & mTrackingEdges,pointerId);\n      }\n      break;\n    }\ncase MotionEventCompat.ACTION_POINTER_DOWN:\n{\n    final int pointerId=MotionEventCompat.getPointerId(ev,actionIndex);\n    final float x=MotionEventCompat.getX(ev,actionIndex);\n    final float y=MotionEventCompat.getY(ev,actionIndex);\n    saveInitialMotion(x,y,pointerId);\n    if (mDragState == STATE_IDLE) {\n      final int edgesTouched=mInitialEdgesTouched[pointerId];\n      if ((edgesTouched & mTrackingEdges) != 0) {\n        mCallback.onEdgeTouched(edgesTouched & mTrackingEdges,pointerId);\n      }\n    }\n else     if (mDragState == STATE_SETTLING) {\n      final View toCapture=findTopChildUnder((int)x,(int)y);\n      if (toCapture == mCapturedView) {\n        tryCaptureViewForDrag(toCapture,pointerId);\n      }\n    }\n    break;\n  }\ncase MotionEvent.ACTION_MOVE:\n{\n  final int pointerCount=MotionEventCompat.getPointerCount(ev);\n  for (int i=0; i < pointerCount; i++) {\n    final int pointerId=MotionEventCompat.getPointerId(ev,i);\n    final float x=MotionEventCompat.getX(ev,i);\n    final float y=MotionEventCompat.getY(ev,i);\n    final float dx=x - mInitialMotionX[pointerId];\n    final float dy=y - mInitialMotionY[pointerId];\n    reportNewEdgeDrags(dx,dy,pointerId);\n    if (mDragState == STATE_DRAGGING) {\n      break;\n    }\n    final View toCapture=findTopChildUnder((int)x,(int)y);\n// bug_start\n    if (slopCheck(toCapture,dx,dy) && tryCaptureViewForDrag(toCapture,pointerId)) {\n// bug_end\n      break;\n    }\n  }\n  saveLastMotion(ev);\n  break;\n}\ncase MotionEventCompat.ACTION_POINTER_UP:\n{\nfinal int pointerId=MotionEventCompat.getPointerId(ev,actionIndex);\nclearMotionHistory(pointerId);\nbreak;\n}\ncase MotionEvent.ACTION_UP:\ncase MotionEvent.ACTION_CANCEL:\n{\ncancel();\nbreak;\n}\n}\nreturn mDragState == STATE_DRAGGING;\n}\n"}
{"INPUT": "public static File relativizePath(File f,ArrayList<File> dirs){\n  String pth=f.getPath();\n  for (  File dir : dirs) {\n// bug_start\n    if (pth.startsWith(dir.getPath())) {\n// bug_end\n      String subs=pth.substring(dir.getPath().length());\n      if ((subs.length() > 0) && ((subs.charAt(0) == '/') || (subs.charAt(0) == '\\\\')))       subs=subs.substring(1);\n      return new File(subs);\n    }\n  }\n  return f;\n}\n"}
{"INPUT": "protected void updateStatus(Location currentLocation){\n  float speed=DEFAULT_SPEED;\n  if (currentLocation != null && currentLocation.hasSpeed()) {\n    speed=Math.max(currentLocation.getSpeed(),speed);\n  }\n  NextDirectionInfo nextInfo=router.getNextRouteDirectionInfo(new NextDirectionInfo(),true);\n// bug_start\n  if (nextInfo == null || nextInfo.directionInfo.distance == 0) {\n// bug_end\n    if (currentStatus <= STATUS_UNKNOWN) {\n      if (playGoAheadToDestination()) {\n        currentStatus=STATUS_TOLD;\n        playGoAheadDist=0;\n      }\n    }\n    return;\n  }\n  int dist=nextInfo.distanceTo;\n  RouteDirectionInfo next=nextInfo.directionInfo;\n  if (next != nextRouteDirection) {\n    nextRouteDirection=next;\n    currentStatus=STATUS_UNKNOWN;\n    playGoAheadDist=0;\n  }\n  if (dist == 0 || currentStatus == STATUS_TOLD) {\n    return;\n  }\n  if (currentStatus == STATUS_UNKNOWN) {\n    if (!isDistanceLess(speed,dist,TURN_IN_DISTANCE * 1.3)) {\n      playGoAheadDist=dist - 80;\n    }\n    if (dist > PREPARE_LONG_DISTANCE + 300) {\n      nextStatusAfter(STATUS_UNKNOWN);\n    }\n else     if (dist > PREPARE_DISTANCE + 300) {\n      nextStatusAfter(STATUS_LONG_PREPARE);\n    }\n else {\n      nextStatusAfter(STATUS_PREPARE);\n    }\n  }\n  NextDirectionInfo nextNextInfo=router.getNextRouteDirectionInfoAfter(nextInfo,new NextDirectionInfo(),false);\n  if (statusNotPassed(STATUS_TURN) && isDistanceLess(speed,dist,TURN_DISTANCE,TURN_DEFAULT_SPEED)) {\n    if (next.distance < TURN_IN_DISTANCE_END && nextNextInfo != null) {\n      playMakeTurn(next,nextNextInfo.directionInfo);\n    }\n else {\n      playMakeTurn(next,null);\n    }\n    nextStatusAfter(STATUS_TURN);\n  }\n else   if (statusNotPassed(STATUS_TURN_IN) && isDistanceLess(speed,dist,TURN_IN_DISTANCE)) {\n    if (dist >= TURN_IN_DISTANCE_END) {\n      if ((isDistanceLess(speed,next.distance,TURN_DISTANCE) || next.distance < TURN_IN_DISTANCE_END) && nextNextInfo != null) {\n        playMakeTurnIn(next,dist,nextNextInfo.directionInfo);\n      }\n else {\n        playMakeTurnIn(next,dist,null);\n      }\n    }\n    nextStatusAfter(STATUS_TURN_IN);\n  }\n else   if (statusNotPassed(STATUS_PREPARE) && (dist <= PREPARE_DISTANCE)) {\n    if (dist >= PREPARE_DISTANCE_END) {\n      if (next.getTurnType().keepLeft() || next.getTurnType().keepRight()) {\n      }\n else {\n        playPrepareTurn(next,dist);\n      }\n    }\n    nextStatusAfter(STATUS_PREPARE);\n  }\n else   if (statusNotPassed(STATUS_LONG_PREPARE) && (dist <= PREPARE_LONG_DISTANCE)) {\n    if (dist >= PREPARE_LONG_DISTANCE_END) {\n      playPrepareTurn(next,dist);\n    }\n    nextStatusAfter(STATUS_LONG_PREPARE);\n  }\n else   if (statusNotPassed(STATUS_UNKNOWN)) {\n    nextStatusAfter(STATUS_UNKNOWN);\n  }\n else   if (statusNotPassed(STATUS_TURN_IN) && dist < playGoAheadDist) {\n    playGoAheadDist=0;\n    playGoAhead(dist);\n  }\n}\n"}
{"INPUT": "@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){\n  super.onActivityResult(requestCode,resultCode,data);\n  if (resultCode == RESULT_OK) {\nswitch (requestCode) {\ncase SourceEditActivity.EDIT_SOURCE:\n      refreshBookSource();\n    break;\ncase IMPORT_SOURCE:\n// bug_start\n  if (data != null) {\n// bug_end\n    mPresenter.importBookSourceLocal(FileUtils.getPath(this,data.getData()));\n  }\nbreak;\ncase REQUEST_QR:\nif (data != null) {\nString result=data.getStringExtra(\"result\");\nmPresenter.importBookSource(result);\n}\nbreak;\n}\n}\n}\n"}
{"INPUT": "public Page<E> setPageSizeZero(Boolean pageSizeZero){\n// bug_start\n  if (pageSizeZero != null) {\n// bug_end\n    this.pageSizeZero=pageSizeZero;\n  }\n  return this;\n}\n"}
{"INPUT": "private boolean matchHosts(String host,String[] patterns){\n// bug_start\n  if (patterns != null) {\n// bug_end\n    for (    String pattern : patterns) {\n      if (matchHost(host,pattern)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "public void assertObject(final InternalFactHandle factHandle,final PropagationContext context,final InternalWorkingMemory workingMemory){\n  if (this.objectMemoryEnabled) {\n    final ObjectHashSet memory=(ObjectHashSet)workingMemory.getNodeMemory(this);\n    memory.add(factHandle,false);\n  }\n  if (compiledNetwork != null) {\n    compiledNetwork.assertObject(factHandle,context,workingMemory);\n  }\n else {\n    context.setCurrentPropagatingOTN(this);\n    this.sink.propagateAssertObject(factHandle,context,workingMemory);\n  }\n// bug_start\n  if (this.expirationOffset >= 0 && this.expirationOffset != Long.MAX_VALUE) {\n// bug_end\n    WorkingMemoryReteExpireAction expire=new WorkingMemoryReteExpireAction(factHandle,this);\n    TimerService clock=workingMemory.getTimerService();\n    long nextTimestamp=Math.max(clock.getCurrentTime() + this.expirationOffset,((EventFactHandle)factHandle).getStartTimestamp() + this.expirationOffset);\n    JobContext jobctx=new ExpireJobContext(expire,workingMemory);\n    JobHandle handle=clock.scheduleJob(job,jobctx,new PointInTimeTrigger(nextTimestamp,null,null));\n    jobctx.setJobHandle(handle);\n  }\n}\n"}
{"INPUT": "private void collectTargetClasses(Set<ClassInfo> targetClasses,DotName normalScope){\n  for (  AnnotationInstance annotationInstance : beanArchiveIndex.getIndex().getAnnotations(normalScope)) {\n// bug_start\n    if (annotationInstance.target().kind() == Kind.CLASS) {\n// bug_end\n      targetClasses.add(annotationInstance.target().asClass());\n    }\n  }\n}\n"}
{"INPUT": "@Override public void onDestroyActionMode(ActionMode mode){\n  Iterator it=mAdapter.getSelectedItems().entrySet().iterator();\n  while (it.hasNext()) {\n    Map.Entry mapEntry=(Map.Entry)it.next();\n    int i=(Integer)mapEntry.getKey();\n// bug_start\n    if (mAdapter.getItem(i) != null) {\n// bug_end\n      mAdapter.restoreDrawable(mAdapter.getItem(i),listView.getChildAt(i).findViewById(R.id.card_layout));\n    }\n  }\n  selectedNotes.clear();\n  mAdapter.clearSelectedItems();\n  listView.clearChoices();\n  mActionMode=null;\n  Log.d(Constants.TAG,\"Closed multiselection contextual menu\");\n}\n"}
{"INPUT": "@Override public void getOutline(@NonNull Outline outline){\n  super.getOutline(outline);\n// bug_start\n  if (mBitmapState.mBitmap.hasAlpha()) {\n// bug_end\n    outline.setAlpha(0.0f);\n  }\n}\n"}
{"INPUT": "public String preprocess(String buildPath,Target target) throws RunnerException {\n  ensureExistence();\n  String[] codeFolderPackages=null;\n  classPath=buildPath;\n  StringBuffer bigCode=new StringBuffer();\n  int bigCount=0;\n  for (  SketchCode sc : code) {\n    if (sc.isExtension(\"pde\")) {\n      sc.setPreprocOffset(bigCount);\n      bigCode.append(sc.getProgram());\n      bigCode.append('\\n');\n      bigCount+=sc.getLineCount();\n    }\n  }\n  int headerOffset=0;\n  PdePreprocessor preprocessor=new PdePreprocessor();\n  String primaryClassName=null;\n  try {\n    String className=preprocessor.write(bigCode.toString(),buildPath,name,codeFolderPackages,target);\n    headerOffset=preprocessor.headerCount + preprocessor.prototypeCount;\n    if (className == null) {\n      throw new RunnerException(\"Could not find main class\");\n    }\n    primaryClassName=className + \".cpp\";\n  }\n catch (  FileNotFoundException fnfe) {\n    fnfe.printStackTrace();\n    String msg=\"Build folder disappeared or could not be written\";\n    throw new RunnerException(msg);\n  }\ncatch (  RunnerException pe) {\n    throw pe;\n  }\ncatch (  Exception ex) {\n    System.err.println(\"Uncaught exception type:\" + ex.getClass());\n    ex.printStackTrace();\n    throw new RunnerException(ex.toString());\n  }\n  importedLibraries=new ArrayList<File>();\n  for (  String item : preprocessor.getExtraImports()) {\n    File libFolder=(File)Base.importToLibraryTable.get(item);\n// bug_start\n    if (libFolder != null) {\n// bug_end\n      importedLibraries.add(libFolder);\n      classPath+=Compiler.contentsToClassPath(libFolder);\n      libraryPath+=File.pathSeparator + libFolder.getAbsolutePath();\n    }\n  }\n  for (  SketchCode sc : code) {\n    if (sc.isExtension(\"c\") || sc.isExtension(\"cpp\") || sc.isExtension(\"h\")) {\n      String filename=sc.getFileName();\n      try {\n        Base.saveFile(sc.getProgram(),new File(buildPath,filename));\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n        throw new RunnerException(\"Problem moving \" + filename + \" to the build folder\");\n      }\n    }\n else     if (sc.isExtension(\"pde\")) {\n      sc.addPreprocOffset(headerOffset);\n    }\n  }\n  return primaryClassName;\n}\n"}
{"INPUT": "int process(){\n  int processed=0;\n  final Iterator<Map.Entry<TaskId,StreamTask>> it=running.entrySet().iterator();\n  while (it.hasNext()) {\n    final StreamTask task=it.next().getValue();\n    try {\n// bug_start\n      if (task.process()) {\n// bug_end\n        processed++;\n      }\n    }\n catch (    final TaskMigratedException e) {\n      log.info(\"Failed to process stream task {} since it got migrated to another thread already. \" + \"Closing it as zombie before triggering a new rebalance.\",task.id());\n      final RuntimeException fatalException=closeZombieTask(task);\n      if (fatalException != null) {\n        throw fatalException;\n      }\n      it.remove();\n      throw e;\n    }\ncatch (    final RuntimeException e) {\n      log.error(\"Failed to process stream task {} due to the following error:\",task.id(),e);\n      throw e;\n    }\n  }\n  return processed;\n}\n"}
{"INPUT": "static void sendKey(View view,String keyName){\n  TerminalView terminalView=view.findViewById(R.id.terminal_view);\n  if (keyCodesForString.containsKey(keyName)) {\n    int keyCode=keyCodesForString.get(keyName);\n    terminalView.onKeyDown(keyCode,new KeyEvent(KeyEvent.ACTION_UP,keyCode));\n  }\n else {\n    TerminalSession session=terminalView.getCurrentSession();\n// bug_start\n    if (session != null)     session.write(keyName);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override public Resource getServerXml() throws IOException {\n  IOException ioe=null;\n  Resource result=null;\n  try {\n    if (serverXmlPath == null || serverXmlPath.equals(Catalina.SERVER_XML)) {\n      result=ConfigurationSource.super.getServerXml();\n    }\n else {\n      result=getResource(serverXmlPath);\n    }\n  }\n catch (  IOException e) {\n    ioe=e;\n  }\n  if (result == null) {\n    InputStream inputStream=getClass().getClassLoader().getResourceAsStream(\"server-embed.xml\");\n    if (inputStream != null) {\n      try {\n        result=new Resource(inputStream,getClass().getClassLoader().getResource(\"server-embed.xml\").toURI());\n      }\n catch (      URISyntaxException e) {\n      }\n    }\n  }\n// bug_start\n  if (result == null) {\n// bug_end\n    throw ioe;\n  }\n else {\n    return result;\n  }\n}\n"}
{"INPUT": "@Override public void onBackPressed(){\n  MediaSendFragment sendFragment=(MediaSendFragment)getSupportFragmentManager().findFragmentByTag(TAG_SEND);\n// bug_start\n  if (sendFragment == null || !sendFragment.handleBackPress()) {\n// bug_end\n    super.onBackPressed();\n  }\n}\n"}
{"INPUT": "private String parseKey() throws IOException {\n  StringBuilder token=new StringBuilder(20);\n  while (true) {\n    int character=read();\n    if (character == -1) {\n      eof=true;\n      return token.toString();\n    }\n    if (!Character.isWhitespace((char)character) && (Character.isLetterOrDigit((char)character) || (character == ':') || ((character != '#') && (character != '{') && (character != '}')&& (character != '\\uFFFD')&& (character != '~')&& (character != '\\uFFFD')&& (character != ',')&& (character != '=')))) {\n      token.append((char)character);\n    }\n else {\n      if (Character.isWhitespace((char)character)) {\n        return token + fixKey();\n      }\n// bug_start\n else       if (character == ',') {\n// bug_end\n        unread(character);\n        return token.toString();\n      }\n else       if (character == '=') {\n        return token.toString();\n      }\n else {\n        throw new IOException(\"Error in line \" + line + \":\"+ \"Character '\"+ (char)character+ \"' is not \"+ \"allowed in bibtex keys.\");\n      }\n    }\n  }\n}\n"}
{"INPUT": "public static boolean isExecQuery(@NotNull SQLDialect dialect,String query){\n  final String[] executeKeywords=dialect.getExecuteKeywords();\n// bug_start\n  if (executeKeywords.length > 0) {\n// bug_end\n    final String queryStart=getFirstKeyword(dialect,query);\n    for (    String keyword : executeKeywords) {\n      if (keyword.equalsIgnoreCase(queryStart)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "private void filterClass(List<Reference> classes,Collection<? extends Element> elements){\n  for (  Element element : elements) {\n// bug_start\n    if (element.getKind().equals(ElementKind.CLASS)) {\n// bug_end\n      classes.add(new Reference((TypeElement)element,processingEnv));\n      filterClass(classes,ElementFilter.typesIn(element.getEnclosedElements()));\n    }\n  }\n}\n"}
{"INPUT": "private void registerEjbInterceptor(){\n  try {\n    final Object interceptor=new EjbComponentInterceptor(locator);\n    initialContext=getInitialContext();\n    final EjbContainerUtil ejbUtil=EjbContainerUtilImpl.getInstance();\n    final ApplicationInfo appInfo=getApplicationInfo(ejbUtil);\n    final List<String> tempLibNames=new LinkedList<>();\n    for (    ModuleInfo moduleInfo : appInfo.getModuleInfos()) {\n      final String jarName=moduleInfo.getName();\n// bug_start\n      if (jarName.endsWith(\".jar\")) {\n// bug_end\n        final String moduleName=jarName.substring(0,jarName.length() - 4);\n        tempLibNames.add(moduleName);\n        final Object bundleDescriptor=moduleInfo.getMetaData(EjbBundleDescriptorImpl.class.getName());\n        if (bundleDescriptor instanceof EjbBundleDescriptorImpl) {\n          final Collection<EjbDescriptor> ejbs=((EjbBundleDescriptorImpl)bundleDescriptor).getEjbs();\n          for (          final EjbDescriptor ejb : ejbs) {\n            final BaseContainer ejbContainer=EjbContainerUtilImpl.getInstance().getContainer(ejb.getUniqueId());\n            try {\n              AccessController.doPrivileged(new PrivilegedExceptionAction(){\n                @Override public Object run() throws Exception {\n                  final Method registerInterceptorMethod=BaseContainer.class.getDeclaredMethod(\"registerSystemInterceptor\",java.lang.Object.class);\n                  registerInterceptorMethod.setAccessible(true);\n                  registerInterceptorMethod.invoke(ejbContainer,interceptor);\n                  return null;\n                }\n              }\n);\n            }\n catch (            PrivilegedActionException pae) {\n              final Throwable cause=pae.getCause();\n              LOGGER.log(Level.WARNING,LocalizationMessages.EJB_INTERCEPTOR_BINDING_WARNING(ejb.getEjbClassName()),cause);\n            }\n          }\n        }\n      }\n    }\n    libNames.addAll(tempLibNames);\n    final Object interceptorBinder=initialContext.lookup(\"java:org.glassfish.ejb.container.interceptor_binding_spi\");\n    if (interceptorBinder == null) {\n      throw new IllegalStateException(LocalizationMessages.EJB_INTERCEPTOR_BIND_API_NOT_AVAILABLE());\n    }\n    try {\n      AccessController.doPrivileged(new PrivilegedExceptionAction(){\n        @Override public Object run() throws Exception {\n          Method interceptorBinderMethod=interceptorBinder.getClass().getMethod(\"registerInterceptor\",java.lang.Object.class);\n          interceptorBinderMethod.invoke(interceptorBinder,interceptor);\n          EjbComponentProvider.this.ejbInterceptorRegistered=true;\n          LOGGER.log(Level.CONFIG,LocalizationMessages.EJB_INTERCEPTOR_BOUND());\n          return null;\n        }\n      }\n);\n    }\n catch (    PrivilegedActionException pae) {\n      throw new IllegalStateException(LocalizationMessages.EJB_INTERCEPTOR_CONFIG_ERROR(),pae.getCause());\n    }\n  }\n catch (  NamingException ex) {\n    throw new IllegalStateException(LocalizationMessages.EJB_INTERCEPTOR_BIND_API_NOT_AVAILABLE(),ex);\n  }\ncatch (  LinkageError ex) {\n    throw new IllegalStateException(LocalizationMessages.EJB_INTERCEPTOR_CONFIG_LINKAGE_ERROR(),ex);\n  }\n}\n"}
{"INPUT": "@Override protected void onProvideStructure(@NonNull ViewStructure structure,@ViewStructureType int viewFor,int flags){\n  super.onProvideStructure(structure,viewFor,flags);\n// bug_start\n  if (viewFor == VIEW_STRUCTURE_FOR_AUTOFILL) {\n// bug_end\n    final Adapter adapter=getAdapter();\n    if (adapter == null)     return;\n    final CharSequence[] options=adapter.getAutofillOptions();\n    if (options != null) {\n      structure.setAutofillOptions(options);\n    }\n  }\n}\n"}
{"INPUT": "public File getInternalPathForUser(int userId){\n// bug_start\n  if (type == TYPE_PUBLIC) {\n// bug_end\n    return new File(path.replace(\"/storage/\",\"/mnt/media_rw/\"));\n  }\n else {\n    return getPathForUser(userId);\n  }\n}\n"}
{"INPUT": "@NotNull @Override public String getResourceNodeName(@NotNull IResource resource){\n// bug_start\n  if (resource.getParent() instanceof IProject) {\n// bug_end\n    return \"SQL Scripts\";\n  }\n else {\n    return super.getResourceNodeName(resource);\n  }\n}\n"}
{"INPUT": "public void reset(Context mContext,SubmissionComments dataSet,RecyclerView listView,Submission submission){\n  this.mContext=mContext;\n  this.listView=listView;\n  this.dataSet=dataSet;\n  this.submission=submission;\n  hidden=new ArrayList<>();\n  users=dataSet.comments;\n  if (users != null) {\n    for (int i=0; i < users.size(); i++) {\n      keys.put(users.get(i).getName(),i);\n    }\n  }\n  hiddenPersons=new ArrayList<>();\n  replie=new ArrayList<>();\n  if (currentSelectedItem != null && !currentSelectedItem.isEmpty()) {\n    notifyDataSetChanged();\n  }\n else {\n    if (users != null) {\n      notifyItemRangeChanged(2,users.size() + 1);\n    }\n else {\n      users=new ArrayList<>();\n      notifyDataSetChanged();\n    }\n  }\n  isSame=false;\n// bug_start\n  if (currentSelectedItem != null && !currentSelectedItem.isEmpty() && !users.isEmpty()) {\n// bug_end\n    int i=2;\n    for (    CommentObject n : users) {\n      if (n instanceof CommentItem && n.comment.getComment().getFullName().contains(currentSelectedItem)) {\n        ((PreCachingLayoutManagerComments)listView.getLayoutManager()).scrollToPositionWithOffset(i,mPage.getActivity().findViewById(R.id.header).getHeight());\n        break;\n      }\n      i++;\n    }\n  }\n}\n"}
{"INPUT": "private void readConfidence(Transaction tx,Protos.TransactionConfidence confidenceProto,TransactionConfidence confidence){\n  if (!confidenceProto.hasType()) {\n    log.warn(\"Unknown confidence type for tx {}\",tx.getHashAsString());\n    return;\n  }\n  ConfidenceType confidenceType=TransactionConfidence.ConfidenceType.valueOf(confidenceProto.getType().getNumber());\n  confidence.setConfidenceType(confidenceType);\n  if (confidenceProto.hasAppearedAtHeight()) {\n    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {\n      log.warn(\"Have appearedAtHeight but not BUILDING for tx {}\",tx.getHashAsString());\n      return;\n    }\n    confidence.setAppearedAtChainHeight(confidenceProto.getAppearedAtHeight());\n  }\n  if (confidenceProto.hasDepth()) {\n    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {\n      log.warn(\"Have depth but not BUILDING for tx {}\",tx.getHashAsString());\n      return;\n    }\n    confidence.setDepthInBlocks(confidenceProto.getDepth());\n  }\n else {\n// bug_start\n    if (chainHeight != 0) {\n// bug_end\n      confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight() + 1);\n    }\n  }\n  if (confidenceProto.hasWorkDone()) {\n    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {\n      log.warn(\"Have workDone but not BUILDING for tx {}\",tx.getHashAsString());\n      return;\n    }\n    confidence.setWorkDone(BigInteger.valueOf(confidenceProto.getWorkDone()));\n  }\n  if (confidenceProto.hasOverridingTransaction()) {\n    if (confidence.getConfidenceType() != ConfidenceType.DEAD) {\n      log.warn(\"Have overridingTransaction but not OVERRIDDEN for tx {}\",tx.getHashAsString());\n      return;\n    }\n    Transaction overridingTransaction=txMap.get(confidenceProto.getOverridingTransaction());\n    if (overridingTransaction == null) {\n      log.warn(\"Have overridingTransaction that is not in wallet for tx {}\",tx.getHashAsString());\n      return;\n    }\n    confidence.setOverridingTransaction(overridingTransaction);\n  }\n  for (  Protos.PeerAddress proto : confidenceProto.getBroadcastByList()) {\n    InetAddress ip;\n    try {\n      ip=InetAddress.getByAddress(proto.getIpAddress().toByteArray());\n    }\n catch (    UnknownHostException e) {\n      throw new RuntimeException(e);\n    }\n    int port=proto.getPort();\n    PeerAddress address=new PeerAddress(ip,port);\n    address.setServices(BigInteger.valueOf(proto.getServices()));\n    confidence.markBroadcastBy(address);\n  }\n}\n"}
{"INPUT": "private void updateSashWidths(){\n  if (sashForm.isDisposed()) {\n    return;\n  }\n  Control[] children=sashForm.getChildren();\n  if (children.length < 2) {\n    return;\n  }\n  Point foldersSize=children[1].computeSize(SWT.DEFAULT,SWT.DEFAULT);\n  Point sashSize=sashForm.getSize();\n// bug_start\n  if (sashSize.y > 0 && foldersSize.y > sashSize.y / 2) {\n// bug_end\n    int[] weights=new int[]{(sashSize.y - foldersSize.y),foldersSize.y};\n    sashForm.setWeights(weights);\n  }\n else {\n    sashForm.setWeights(new int[]{400,600});\n  }\n  sashForm.layout();\n}\n"}
{"INPUT": "public void run(){\n  idList=tf.getText().replace(';',',');\n  Pattern p1=Pattern.compile(\"\\\\d+[,\\\\d+]*\"), p2=Pattern.compile(\".+[,.+]*\");\n  Matcher m1=p1.matcher(idList), m2=p2.matcher(idList);\n  if (m1.matches()) {\n    panel.frame().output(Globals.lang(\"Fetching Medline by id ...\"));\n    idList=tf.getText().replace(';',',');\n    fetchById();\n  }\n else   if (m2.matches()) {\n    panel.frame().output(Globals.lang(\"Fetching Medline by term ...\"));\n    String searchTerm=setupTerm(idList);\n    SearchResult result=getIds(searchTerm,0,1);\n    if (result.count == 0) {\n      JOptionPane.showMessageDialog(panel.frame(),Globals.lang(\"No references found\"));\n      return;\n    }\n    String question=Globals.lang(\"References found\") + \": \" + Integer.toString(result.count)+ \"  \"+ Globals.lang(\"Number of references to fetch?\");\n    String strCount=JOptionPane.showInputDialog(question,Integer.toString(result.count));\n// bug_start\n    if (strCount.equals(\"\"))     return;\n// bug_end\n    int count;\n    try {\n      count=Integer.parseInt(strCount);\n    }\n catch (    NumberFormatException ex) {\n      panel.output(\"\");\n      return;\n    }\n    ImportInspectionDialog diag=new ImportInspectionDialog(panel.frame(),panel,BibtexFields.DEFAULT_INSPECTION_FIELDS,Globals.lang(\"Fetch Medline\"),false);\n    Util.placeDialog(diag,panel.frame());\n    diag.setDefaultSelected(false);\n    diag.setVisible(true);\n    keepOn=true;\n    diag.addCallBack(new ImportInspectionDialog.CallBack(){\n      public void done(      int entriesImported){\n        if (entriesImported > 0) {\n          panel.output(Globals.lang(\"Medline entries fetched\") + \": \" + entriesImported);\n          panel.markBaseChanged();\n        }\n else         panel.output(Globals.lang(\"No Medline entries found.\"));\n      }\n      public void cancelled(){\n        panel.output(Globals.lang(\"%0 import cancelled.\",\"Medline\"));\n      }\n      public void stopFetching(){\n        keepOn=false;\n      }\n    }\n);\n    for (int jj=0; jj < count; jj+=PACING) {\n      if (!keepOn)       break;\n      result=getIds(searchTerm,jj,PACING);\n      final ArrayList bibs=fetchMedline(result.ids);\n      if (!keepOn)       break;\n      diag.addEntries(bibs);\n      diag.setProgress(jj + PACING,count);\n    }\n    diag.entryListComplete();\n  }\n}\n"}
{"INPUT": "public static TypeMirror erasure(Types types,TypeMirror t){\n// bug_start\n  if (t.getKind() == TypeKind.VOID) {\n// bug_end\n    return t;\n  }\n else {\n    return types.erasure(t);\n  }\n}\n"}
{"INPUT": "@Override public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(@Nullable ComponentName who){\n  if (!mHasFeature) {\n    return null;\n  }\n  final int frpManagementAgentUid=getFrpManagementAgentUidOrThrow();\n  ActiveAdmin admin;\nsynchronized (getLockObject()) {\n    if (who == null) {\n// bug_start\n      if ((frpManagementAgentUid != mInjector.binderGetCallingUid())) {\n// bug_end\n        throw new SecurityException(\"Must be called by the FRP management agent on device\");\n      }\n      admin=getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(UserHandle.getUserId(frpManagementAgentUid));\n    }\n else {\n      admin=getActiveAdminForCallerLocked(who,DeviceAdminInfo.USES_POLICY_ORGANIZATION_OWNED_PROFILE_OWNER);\n    }\n  }\n  return admin != null ? admin.mFactoryResetProtectionPolicy : null;\n}\n"}
{"INPUT": "@SuppressWarnings({\"unchecked\"}) private Tuple<String,Map<String,Object>> extractMapping(String type,Map<String,Object> root) throws MapperParsingException {\n  if (root.size() == 0) {\n    if (type != null) {\n      return new Tuple<>(type,root);\n    }\n else {\n      throw new MapperParsingException(\"malformed mapping, no type name found\");\n    }\n  }\n  String rootName=root.keySet().iterator().next();\n  Tuple<String,Map<String,Object>> mapping;\n// bug_start\n  if (type == null || type.equals(rootName)) {\n// bug_end\n    mapping=new Tuple<>(rootName,(Map<String,Object>)root.get(rootName));\n  }\n else {\n    mapping=new Tuple<>(type,root);\n  }\n  return mapping;\n}\n"}
{"INPUT": "protected ODatabaseComplex<?> openDatabase(final ODatabaseComplex<?> database,final String iUser,final String iPassword){\n// bug_start\n  if (database.isClosed())   if (database.getStorage() instanceof OStorageMemory)   database.create();\n// bug_end\n else {\n    try {\n      database.open(iUser,iPassword);\n    }\n catch (    OSecurityException e) {\n      try {\n        serverUser=OServerMain.server().serverLogin(iUser,iPassword,\"database.passthrough\");\n      }\n catch (      OSecurityException ex) {\n        throw e;\n      }\n      database.setProperty(ODatabase.OPTIONS.SECURITY.toString(),Boolean.FALSE);\n      database.open(iUser,iPassword);\n    }\n  }\n  return database;\n}\n"}
{"INPUT": "public void visit(BLangUnaryExpr unaryExpr){\n  genNode(unaryExpr.expr,this.env);\n  int opcode;\n  int exprIndex;\n  if (OperatorKind.TYPEOF.equals(unaryExpr.operator)) {\n// bug_start\n    if (unaryExpr.expr.type.tag == TypeTags.ANY) {\n// bug_end\n      exprIndex=++regIndexes.tRef;\n      opcode=unaryExpr.opSymbol.opcode;\n      emit(opcode,unaryExpr.expr.regIndex,exprIndex);\n    }\n else {\n      int typeSigCPIndex=addUTF8CPEntry(currentPkgInfo,unaryExpr.expr.type.getDesc());\n      TypeRefCPEntry typeRefCPEntry=new TypeRefCPEntry(typeSigCPIndex);\n      int typeCPIndex=currentPkgInfo.addCPEntry(typeRefCPEntry);\n      exprIndex=++regIndexes.tRef;\n      opcode=unaryExpr.opSymbol.opcode;\n      emit(opcode,typeCPIndex,exprIndex);\n    }\n    unaryExpr.regIndex=exprIndex;\n  }\n else   if (OperatorKind.ADD.equals(unaryExpr.operator)) {\n    unaryExpr.regIndex=unaryExpr.expr.regIndex;\n  }\n else {\n    opcode=unaryExpr.opSymbol.opcode;\n    exprIndex=getNextIndex(unaryExpr.type.tag,regIndexes);\n    unaryExpr.regIndex=exprIndex;\n    emit(opcode,unaryExpr.expr.regIndex,exprIndex);\n  }\n}\n"}
{"INPUT": "public void run(){\n  Configure config=null;\n  TraceContext traceContext=null;\n  long elapsedTime=0L;\n  try {\n    config=Configure.getInstance();\n    config.scouter_stop=true;\n    traceContext=TraceContext.getInstance();\n    traceContext.endTime=System.currentTimeMillis();\n    elapsedTime=(traceContext.endTime - traceContext.startTime);\n    if (config.batch_log_send_elapsed_ms <= elapsedTime) {\n      traceContext.caculateLast();\n      String result=traceContext.toString();\n// bug_start\n      if (config.scouter_standalone) {\n// bug_end\n        saveStandAloneResult(traceContext,result);\n      }\n      Logger.println(result);\n    }\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n finally {\n    try {\n      if (config != null && traceContext != null) {\n        if (!config.scouter_standalone) {\n          if (config.batch_log_send_elapsed_ms <= elapsedTime) {\n            if (config.sfa_dump_enabled && config.sfa_dump_send_elapsed_ms > elapsedTime) {\n              traceContext.isStackLogFile=false;\n            }\n            UdpLocalAgent.sendUdpPackToServer(traceContext.makePack());\n          }\n          if (config.sfa_dump_enabled && config.sfa_dump_send_elapsed_ms <= elapsedTime) {\n            UdpLocalAgent.sendDumpFileInfo(traceContext);\n          }\n        }\n        if (config.sfa_dump_enabled && config.sfa_dump_enabled && config.sfa_dump_send_elapsed_ms > elapsedTime) {\n          deleteFiles(traceContext);\n        }\n        UdpLocalAgent.sendEndInfo(traceContext);\n      }\n    }\n catch (    Exception ex) {\n      ex.printStackTrace();\n    }\n  }\n}\n"}
{"INPUT": "public boolean checkAndSleep(){\n  try {\n    Thread.sleep(TIMEOUT);\n  }\n catch (  InterruptedException e) {\n  }\n// bug_start\n  return (!proverProcess.isTerminated());\n// bug_end\n}\n"}
{"INPUT": "public String getSanitizedValue(){\n  BrowserInfo browser=BrowserInfo.get();\n  String result=getValue();\n  if (browser.isFirefox()) {\n    if (\"<br>\".equals(result)) {\n      result=\"\";\n    }\n  }\n// bug_start\n else   if (browser.isWebkit()) {\n// bug_end\n    if (\"<br>\".equals(result) || \"<div><br></div>\".equals(result)) {\n      result=\"\";\n    }\n  }\n else   if (browser.isIE()) {\n    if (\"<P>&nbsp;</P>\".equals(result)) {\n      result=\"\";\n    }\n  }\n else   if (browser.isOpera()) {\n    if (\"<br>\".equals(result) || \"<p><br></p>\".equals(result)) {\n      result=\"\";\n    }\n  }\n  return result;\n}\n"}
{"INPUT": "@Override protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, UnknownHostException {\n  request.setAttribute(\"debug\",Constants.DEBUG);\n  request.setAttribute(\"masterNodeAddress\",mMasterInfo.getMasterAddress().toString());\n  request.setAttribute(\"invalidPathError\",\"\");\n  List<ClientFileInfo> filesInfo=null;\n  String currentPath=request.getParameter(\"path\");\n// bug_start\n  if (currentPath.isEmpty()) {\n// bug_end\n    currentPath=Constants.PATH_SEPARATOR;\n  }\n  request.setAttribute(\"currentPath\",currentPath);\n  request.setAttribute(\"viewingOffset\",0);\n  try {\n    UiFileInfo currentFileInfo=new UiFileInfo(mMasterInfo.getClientFileInfo(currentPath));\n    request.setAttribute(\"currentDirectory\",currentFileInfo);\n    request.setAttribute(\"blockSizeByte\",currentFileInfo.getBlockSizeBytes());\n    if (!currentFileInfo.getIsDirectory()) {\n      String tmpParam=request.getParameter(\"offset\");\n      int offset=(tmpParam == null ? 0 : Integer.valueOf(tmpParam));\n      displayFile(currentFileInfo.getAbsolutePath(),request,offset);\n      request.setAttribute(\"viewingOffset\",offset);\n      getServletContext().getRequestDispatcher(\"/viewFile.jsp\").forward(request,response);\n      return;\n    }\n    CommonUtils.validatePath(currentPath);\n    setPathDirectories(currentPath,request);\n    filesInfo=mMasterInfo.getFilesInfo(currentPath);\n  }\n catch (  FileDoesNotExistException fdne) {\n    request.setAttribute(\"invalidPathError\",\"Error: Invalid Path \" + fdne.getMessage());\n    getServletContext().getRequestDispatcher(\"/browse.jsp\").forward(request,response);\n    return;\n  }\ncatch (  InvalidPathException ipe) {\n    request.setAttribute(\"invalidPathError\",\"Error: Invalid Path \" + ipe.getLocalizedMessage());\n    getServletContext().getRequestDispatcher(\"/browse.jsp\").forward(request,response);\n    return;\n  }\n  List<UiFileInfo> fileInfos=new ArrayList<UiFileInfo>(filesInfo.size());\n  for (  ClientFileInfo fileInfo : filesInfo) {\n    UiFileInfo toAdd=new UiFileInfo(fileInfo);\n    try {\n      if (!toAdd.getIsDirectory() && fileInfo.getLength() > 0) {\n        toAdd.setFileLocations(mMasterInfo.getFileLocations(toAdd.getId()).get(0).getLocations());\n      }\n    }\n catch (    FileDoesNotExistException fdne) {\n      request.setAttribute(\"invalidPathError\",\"Error: Invalid Path \" + fdne.getMessage());\n      getServletContext().getRequestDispatcher(\"/browse.jsp\").forward(request,response);\n      return;\n    }\n    fileInfos.add(toAdd);\n  }\n  Collections.sort(fileInfos);\n  request.setAttribute(\"fileInfos\",fileInfos);\n  getServletContext().getRequestDispatcher(\"/browse.jsp\").forward(request,response);\n}\n"}
{"INPUT": "public Set<String> getToPropertyNames(String fromEntityName,String fromPropertyName,String toEntityName){\n  Set<String> entityAndParentsNames=getEntityAndParentsNames(fromEntityName);\n  Set<String> toPropertyNames=new HashSet<String>();\n  for (  RelationDescription relationDescription : getRelationDescriptions(toEntityName)) {\n    String relToEntityName=relationDescription.getToEntityName();\n    String mappedByPropertyName=relationDescription.getMappedByPropertyName();\n// bug_start\n    if (entityAndParentsNames.contains(relToEntityName) && mappedByPropertyName.equals(fromPropertyName)) {\n// bug_end\n      toPropertyNames.add(relationDescription.getFromPropertyName());\n    }\n  }\n  return toPropertyNames;\n}\n"}
{"INPUT": "private boolean processUnqualifiedResolve(@NotNull GoFile file,@NotNull MyScopeProcessor processor,@NotNull ResolveState state,boolean localResolve){\n  String id=getName();\n  if (\"_\".equals(id))   return processor.execute(myElement,state);\n  PsiElement parent=myElement.getParent();\n  if (parent instanceof GoSelectorExpr) {\n    boolean result=processSelector((GoSelectorExpr)parent,processor,state,myElement);\n    if (processor.isCompletion())     return result;\n// bug_start\n    if (!result)     return false;\n// bug_end\n  }\n  PsiElement grandPa=parent.getParent();\n  if (grandPa instanceof GoSelectorExpr && !processSelector((GoSelectorExpr)grandPa,processor,state,parent))   return false;\n  if (prevDot(parent))   return false;\n  GoScopeProcessorBase delegate=createDelegate(processor);\n  ResolveUtil.treeWalkUp(myElement,delegate);\n  if (!processNamedElements(processor,state,delegate.getVariants(),localResolve))   return false;\n  processReceiver(delegate);\n  if (!processNamedElements(processor,state,delegate.getVariants(),localResolve))   return false;\n  processFunctionParameters(myElement,delegate);\n  if (!processNamedElements(processor,state,delegate.getVariants(),localResolve))   return false;\n  if (!processFileEntities(file,processor,state,localResolve))   return false;\n  if (!processDirectory(file.getOriginalFile().getParent(),file,file.getPackageName(),processor,state,true))   return false;\n  if (processImports(file,processor,state,myElement))   return false;\n  if (processBuiltin(processor,state,myElement))   return false;\n  return true;\n}\n"}
{"INPUT": "private synchronized OutputStream getOutputStream0() throws IOException {\n  try {\n    if (!doOutput) {\n      throw new ProtocolException(\"cannot write to a URLConnection\" + \" if doOutput=false - call setDoOutput(true)\");\n    }\n    if (method.equals(\"GET\")) {\n      method=\"POST\";\n    }\n    if (!\"POST\".equals(method) && !\"PUT\".equals(method) && \"http\".equals(url.getProtocol())) {\n      throw new ProtocolException(\"HTTP method \" + method + \" doesn't support output\");\n    }\n    if (inputStream != null) {\n      throw new ProtocolException(\"Cannot write output after reading input.\");\n    }\n    if (!checkReuseConnection())     connect();\n    boolean expectContinue=false;\n    String expects=requests.findValue(\"Expect\");\n// bug_start\n    if (\"100-Continue\".equalsIgnoreCase(expects)) {\n// bug_end\n      http.setIgnoreContinue(false);\n      expectContinue=true;\n    }\n    if (streaming() && strOutputStream == null) {\n      writeRequests();\n    }\n    if (expectContinue) {\n      expect100Continue();\n    }\n    ps=(PrintStream)http.getOutputStream();\n    if (streaming()) {\n      if (strOutputStream == null) {\n        if (chunkLength != -1) {\n          strOutputStream=new StreamingOutputStream(new ChunkedOutputStream(ps,chunkLength),-1L);\n        }\n else {\n          long length=0L;\n          if (fixedContentLengthLong != -1) {\n            length=fixedContentLengthLong;\n          }\n else           if (fixedContentLength != -1) {\n            length=fixedContentLength;\n          }\n          strOutputStream=new StreamingOutputStream(ps,length);\n        }\n      }\n      return strOutputStream;\n    }\n else {\n      if (poster == null) {\n        poster=new PosterOutputStream();\n      }\n      return poster;\n    }\n  }\n catch (  RuntimeException e) {\n    disconnectInternal();\n    throw e;\n  }\ncatch (  ProtocolException e) {\n    int i=responseCode;\n    disconnectInternal();\n    responseCode=i;\n    throw e;\n  }\ncatch (  IOException e) {\n    disconnectInternal();\n    throw e;\n  }\n}\n"}
{"INPUT": "@Inject public FileOpenRequestHandler(@Named(\"launchEventQueue\") BlockingQueue<AppLaunchEvent> launchEventQueue){\n  this.launchEventQueue=launchEventQueue;\n// bug_start\n  if (Desktop.getDesktop().isSupported(Desktop.Action.APP_OPEN_FILE)) {\n// bug_end\n    Desktop.getDesktop().setOpenFileHandler(null);\n  }\n}\n"}
{"INPUT": "private void readItemMouseOver(Canvas canvas,int i){\n// bug_start\n  if (optionListeners.get(i).isMouseOver()) {\n// bug_end\n    canvas.setMode(HOVER_MODE);\n  }\n else {\n    canvas.setMode(DEFAULT_MODE);\n  }\n}\n"}
{"INPUT": "public void run(){\n  long now=_time.milliseconds();\n// bug_start\n  if (_loadMonitorTaskRunner.compareAndSetState(LoadMonitorTaskRunner.LoadMonitorTaskRunnerState.RUNNING,LoadMonitorTaskRunner.LoadMonitorTaskRunnerState.SAMPLING)) {\n// bug_end\n    long samplingPeriodEndMs=now;\n    try {\n      boolean hasSamplingError;\n      long deadline=_time.milliseconds() + _samplingIntervalMs;\n      do {\n        _metadataClient.refreshMetadata();\n        samplingPeriodEndMs=_time.milliseconds();\n        hasSamplingError=_metricFetcherManager.fetchPartitionMetricSamples(_lastSamplingPeriodEndTimeMs,samplingPeriodEndMs,deadline - now,_sampleStore);\n        if (!hasSamplingError) {\n          _lastSamplingPeriodEndTimeMs=samplingPeriodEndMs;\n        }\n        now=_time.milliseconds();\n        if (now > deadline) {\n          throw new TimeoutException();\n        }\n      }\n while (hasSamplingError);\n    }\n catch (    TimeoutException e) {\n      LOG.warn(\"Sampling did not finish in {} ms, skipping this sampling interval.\",_samplingIntervalMs);\n      _lastSamplingPeriodEndTimeMs=samplingPeriodEndMs;\n    }\ncatch (    Throwable t) {\n      LOG.error(\"Uncaught exception in sampling\",t);\n      throw t;\n    }\n finally {\n      _loadMonitorTaskRunner.compareAndSetState(LoadMonitorTaskRunner.LoadMonitorTaskRunnerState.SAMPLING,LoadMonitorTaskRunner.LoadMonitorTaskRunnerState.RUNNING);\n    }\n  }\n else {\n    LOG.info(\"Skip sampling because the load monitor is in {} state.\",_loadMonitorTaskRunner.state());\n    _lastSamplingPeriodEndTimeMs=now - _samplingIntervalMs;\n  }\n}\n"}
{"INPUT": "public void init(IClass testClass,Object instance,ITestNGMethod method,Throwable throwable,long start,long end,ITestContext context){\n  m_testClass=testClass;\n  m_throwable=throwable;\n  m_instanceName=m_testClass.getName();\n  if (null == m_throwable) {\n    m_status=ITestResult.SUCCESS;\n  }\n  m_startMillis=start;\n  m_endMillis=end;\n  m_method=method;\n  m_context=context;\n  m_instance=instance;\n  if (m_instance == null) {\n    m_name=m_method.getMethodName();\n  }\n else {\n    if (m_instance instanceof ITest) {\n      m_name=((ITest)m_instance).getTestName();\n    }\n// bug_start\n else     if (testClass.getTestName() != null) {\n// bug_end\n      m_name=testClass.getTestName();\n    }\n else {\n      String string=m_instance.toString();\n      m_name=getMethod().getMethodName();\n      try {\n        if (!Object.class.getMethod(\"toString\").equals(m_instance.getClass().getMethod(\"toString\"))) {\n          m_instanceName=string.startsWith(\"class \") ? string.substring(\"class \".length()) : string;\n          m_name=m_name + \" on \" + m_instanceName;\n        }\n      }\n catch (      NoSuchMethodException ignore) {\n      }\n    }\n  }\n}\n"}
{"INPUT": "protected void onDensityOrFontScaleChanged(){\n  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();\n  for (int i=0; i < activeNotifications.size(); i++) {\n    Entry entry=activeNotifications.get(i);\n// bug_start\n    boolean exposedGuts=entry.row.getGuts() == mNotificationGutsExposed;\n// bug_end\n    entry.row.reInflateViews();\n    if (exposedGuts) {\n      mNotificationGutsExposed=entry.row.getGuts();\n      bindGuts(entry.row,mGutsMenuItem);\n    }\n    inflateViews(entry,mStackScroller);\n  }\n}\n"}
{"INPUT": "public View getView(int position,View convertView,ViewGroup parent){\n  Tag tag=tags.get(position);\n  TextView txtTitle;\n  ImageView imgIcon;\n  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n  View itemView=inflater.inflate(R.layout.drawer_list_item,parent,false);\n  txtTitle=(TextView)itemView.findViewById(R.id.title);\n  imgIcon=(ImageView)itemView.findViewById(R.id.icon);\n  txtTitle.setText(tag.getName());\n  if (isSelected(parent,position)) {\n    txtTitle.setTextColor(mContext.getResources().getColor(R.color.drawer_text_selected));\n  }\n// bug_start\n  if (tag.getColor().length() > 0) {\n// bug_end\n    Drawable img=mContext.getResources().getDrawable(R.drawable.circle);\n    ColorFilter cf=new LightingColorFilter(Color.parseColor(\"#000000\"),Integer.parseInt(tag.getColor()));\n    if (Build.VERSION.SDK_INT >= 16) {\n      img.mutate().setColorFilter(cf);\n    }\n else {\n      img.setColorFilter(cf);\n    }\n    imgIcon.setImageDrawable(img);\n    imgIcon.setPadding(25,25,-25,25);\n  }\n  return itemView;\n}\n"}
{"INPUT": "@Nullable @Override public <T>T getAdapter(Class<T> required){\n  if (resultTabs != null && !resultTabs.isDisposed()) {\n    if (required == IFindReplaceTarget.class) {\n      return required.cast(findReplaceTarget);\n    }\n    CTabItem activeResultsTab=getActiveResultsTab();\n// bug_start\n    if (activeResultsTab != null) {\n// bug_end\n      Object tabControl=activeResultsTab.getData();\n      if (tabControl instanceof QueryResultsContainer) {\n        tabControl=((QueryResultsContainer)tabControl).viewer;\n      }\n      if (tabControl instanceof IAdaptable) {\n        T adapter=((IAdaptable)tabControl).getAdapter(required);\n        if (adapter != null) {\n          return adapter;\n        }\n      }\n      if (tabControl instanceof ResultSetViewer && (required == IResultSetController.class || required == ResultSetViewer.class)) {\n        return required.cast(tabControl);\n      }\n    }\n  }\n  return super.getAdapter(required);\n}\n"}
{"INPUT": "@Override public boolean equals(final Object o){\n  if (this == o) {\n    return true;\n  }\n  if (o == null || !Objects.equals(getClass(),o.getClass())) {\n    return false;\n  }\n  final BiTuple<?,?> other=(BiTuple<?,?>)o;\n// bug_start\n  return Objects.equals(a,other.a) && Objects.equals(b,other.b);\n// bug_end\n}\n"}
{"INPUT": "protected void setContainerStyles(){\n  Composite pageContainer=getContainer();\n// bug_start\n  if (pageContainer instanceof CTabFolder) {\n// bug_end\n    CTabFolder tabFolder=(CTabFolder)pageContainer;\n    tabFolder.setSimple(true);\n    tabFolder.setMRUVisible(true);\n    tabFolder.setTabPosition(SWT.TOP);\n    Control topRight=createTopRightControl(tabFolder);\n    if (topRight != null) {\n      Point trSize=topRight.computeSize(SWT.DEFAULT,SWT.DEFAULT);\n      tabFolder.setTabHeight(trSize.y);\n      tabFolder.setTopRight(topRight,SWT.RIGHT | SWT.WRAP);\n    }\n    Layout parentLayout=tabFolder.getParent().getLayout();\n    if (parentLayout instanceof FillLayout) {\n      ((FillLayout)parentLayout).marginHeight=0;\n    }\n  }\n}\n"}
{"INPUT": "public Atom<Iterable<Edge>> compute(final List<Operation> arguments,final GremlinScriptContext context) throws RuntimeException {\n  final int size=arguments.size();\n  if (size != 2 && size != 3 && size != 4)   throw new RuntimeException(this.createUnsupportedArgumentMessage());\n  final IndexableGraph graph;\n  List<Object> objects=FunctionHelper.generateObjects(arguments);\n// bug_start\n  if (objects.get(0) instanceof Graph)   graph=(IndexableGraph)objects.get(0);\n// bug_end\n else   graph=(IndexableGraph)FunctionHelper.getGlobalGraph(context);\n  final String indexName;\n  final String key;\n  final Object value;\n  if (size == 2) {\n    indexName=Index.EDGES;\n    key=(String)objects.get(0);\n    value=objects.get(1);\n  }\n else   if (size == 3) {\n    if (objects.get(0) instanceof Graph) {\n      indexName=Index.EDGES;\n      key=(String)objects.get(1);\n      value=objects.get(2);\n    }\n else {\n      indexName=(String)objects.get(0);\n      key=(String)objects.get(1);\n      value=objects.get(2);\n    }\n  }\n else {\n    indexName=(String)objects.get(1);\n    key=(String)objects.get(2);\n    value=objects.get(3);\n  }\n  return new Atom<Iterable<Edge>>(graph.getIndex(indexName,Edge.class).get(key,value));\n}\n"}
{"INPUT": "final private int findIndexOfEqualElement(Object key){\n// bug_start\n  if (key == null) {\n// bug_end\n    return INVALID_INDEX;\n  }\n  int slot=slot(elements,key);\n  for (int seen=0; seen < elements.length; seen++) {\n    Element element=elements[slot];\n    if (element == null) {\n      return INVALID_INDEX;\n    }\n    if (key.equals(element)) {\n      return slot;\n    }\n    slot=(slot + 1) % elements.length;\n  }\n  return INVALID_INDEX;\n}\n"}
{"INPUT": "public static void enableIndexBlock(String index,String block){\n// bug_start\n  if (randomBoolean()) {\n// bug_end\n    Settings settings=Settings.builder().put(block,true).build();\n    client().admin().indices().prepareUpdateSettings(index).setSettings(settings).get();\n  }\n else {\n    client().admin().indices().prepareAddBlock(IndexMetadata.APIBlock.fromSetting(block),index).get();\n  }\n}\n"}
{"INPUT": "Window getApplicationWindow(HttpServletRequest request,AbstractApplicationServlet applicationServlet,Application application,Window assumedWindow) throws ServletException {\n  Window window=null;\n  String windowClientRequestedName=request.getParameter(\"windowName\");\n  if (assumedWindow != null && application.getWindows().contains(assumedWindow)) {\n    windowClientRequestedName=assumedWindow.getName();\n  }\n  if (windowClientRequestedName != null) {\n    window=application.getWindow(windowClientRequestedName);\n    if (window != null) {\n      return window;\n    }\n  }\n  if (window == null) {\n    String path=applicationServlet.getRequestPathInfo(request);\n// bug_start\n    if (path.startsWith(\"/UIDL\")) {\n// bug_end\n      path=path.substring(\"/UIDL\".length());\n    }\n    if (path != null && path.length() > 0 && !path.equals(\"/\")) {\n      String windowUrlName=null;\n      if (path.charAt(0) == '/') {\n        path=path.substring(1);\n      }\n      final int index=path.indexOf('/');\n      if (index < 0) {\n        windowUrlName=path;\n        path=\"\";\n      }\n else {\n        windowUrlName=path.substring(0,index);\n        path=path.substring(index + 1);\n      }\n      window=application.getWindow(windowUrlName);\n    }\n  }\n  if (window == null) {\n    window=application.getMainWindow();\n  }\n  if (currentlyOpenWindowsInClient.contains(window.getName())) {\n    String newWindowName=window.getName();\n    while (currentlyOpenWindowsInClient.contains(newWindowName)) {\n      newWindowName=window.getName() + \"_\" + ((int)(Math.random() * 100000000));\n    }\n    window=application.getWindow(newWindowName);\n    if (window == null) {\n      window=application.getMainWindow();\n    }\n  }\n  return window;\n}\n"}
{"INPUT": "@GET @Timed @Produces(MediaType.APPLICATION_JSON) public RegexTesterResponse regexTester(@QueryParam(\"regex\") @NotEmpty String regex,@QueryParam(\"string\") @NotNull String string){\n  final Matcher matcher=Pattern.compile(regex,Pattern.DOTALL).matcher(string);\n  boolean matched=matcher.find();\n  final RegexTesterResponse.Match match;\n// bug_start\n  if (matcher.groupCount() > 0) {\n// bug_end\n    match=RegexTesterResponse.Match.create(matcher.group(1),matcher.start(1),matcher.end(1));\n  }\n else {\n    match=null;\n  }\n  return RegexTesterResponse.create(matched,match,regex,string);\n}\n"}
{"INPUT": "boolean containsNewErrors(List<Violation> violations){\n  boolean isTxOpen=session.transaction != null && session.transaction.isOpen();\n  if (violations.size() > originalViolations.size())   return true;\n  for (  Violation v : violations) {\n    if (isTxOpen && v.getClause().hasComputedValue)     continue;\n    int idx=originalViolations.indexOf(v);\n// bug_start\n    if (idx < 0)     return true;\n// bug_end\n  }\n  return false;\n}\n"}
{"INPUT": "@Override public boolean onTextContextMenuItem(int id){\n  if (mIME != null && mIME.onExtractTextContextMenuItem(id)) {\n// bug_start\n    if (id == android.R.id.copy)     stopTextActionMode();\n// bug_end\n    return true;\n  }\n  return super.onTextContextMenuItem(id);\n}\n"}
{"INPUT": "public static byte[] encode(Object input){\n  Value val=new Value(input);\n  if (val.isList()) {\n    List<Object> inputArray=val.asList();\n    if (inputArray.size() == 0) {\n      return encodeLength(inputArray.size(),OFFSET_SHORT_LIST);\n    }\n    byte[] output=ByteUtil.EMPTY_BYTE_ARRAY;\n    for (    Object object : inputArray) {\n      output=concatenate(output,encode(object));\n    }\n    byte[] prefix=encodeLength(output.length,OFFSET_SHORT_LIST);\n    return concatenate(prefix,output);\n  }\n else {\n    byte[] inputAsBytes=toBytes(input);\n// bug_start\n    if (inputAsBytes.length == 1) {\n// bug_end\n      return inputAsBytes;\n    }\n else {\n      byte[] firstByte=encodeLength(inputAsBytes.length,OFFSET_SHORT_ITEM);\n      return concatenate(firstByte,inputAsBytes);\n    }\n  }\n}\n"}
{"INPUT": "@Override public void onPrepareBufferImage(Canvas canvas,RotatedTileBox tilesRect,DrawSettings drawSettings){\n  if (!visible) {\n    return;\n  }\n  final MapRendererView mapRenderer=view.getMapRenderer();\n  if (mapRenderer != null && !oldRender) {\n    NativeCoreContext.getMapRendererContext().setNightMode(drawSettings.isNightMode());\n    OsmandSettings st=view.getApplication().getSettings();\n    if (!Algorithms.objectEquals(st.MAP_TRANSPARENCY.get(),cachedMapTransparency)) {\n      cachedMapTransparency=st.MAP_TRANSPARENCY.get();\n      MapLayerConfiguration mapLayerConfiguration=new MapLayerConfiguration();\n      mapLayerConfiguration.setOpacityFactor(((float)cachedMapTransparency) / 255.0f);\n      mapRenderer.setMapLayerConfiguration(0,mapLayerConfiguration);\n    }\n    LatLon ll=tilesRect.getLatLonFromPixel(tilesRect.getPixWidth() / 2,tilesRect.getPixHeight() / 2);\n    mapRenderer.setTarget(new PointI(MapUtils.get31TileNumberX(ll.getLongitude()),MapUtils.get31TileNumberY(ll.getLatitude())));\n    mapRenderer.setAzimuth(-tilesRect.getRotate());\n    mapRenderer.setZoom((float)(tilesRect.getZoom() + tilesRect.getZoomAnimation() + tilesRect.getZoomFloatPart()));\n    float zoomMagnifier=st.MAP_DENSITY.get();\n    mapRenderer.setVisualZoomShift(zoomMagnifier - 1.0f);\n  }\n else {\n    if (!view.isZooming()) {\n// bug_start\n      if (resourceManager.updateRenderedMapNeeded(tilesRect,drawSettings)) {\n// bug_end\n        final RotatedTileBox copy=tilesRect.copy();\n        copy.increasePixelDimensions(copy.getPixWidth() / 3,copy.getPixHeight() / 4);\n        resourceManager.updateRendererMap(copy,null);\n      }\n    }\n    MapRenderRepositories renderer=resourceManager.getRenderer();\n    drawRenderedMap(canvas,renderer.getBitmap(),renderer.getBitmapLocation(),tilesRect);\n    drawRenderedMap(canvas,renderer.getPrevBitmap(),renderer.getPrevBmpLocation(),tilesRect);\n  }\n}\n"}
{"INPUT": "private boolean isUpperCase(String name){\n  for (int i=0; i < name.length(); i++) {\n// bug_start\n    if (!Character.isUpperCase(name.charAt(i))) {\n// bug_end\n      return false;\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "public static boolean start(RootDoc root) throws FileNotFoundException {\n  final String fileName=getDestFileName(root.options());\n  final FileOutputStream fos=new FileOutputStream(fileName);\n  final Writer osw=new OutputStreamWriter(fos,StandardCharsets.UTF_8);\n  final PrintWriter writer=new PrintWriter(osw,false);\n  try {\n    final ClassDoc[] classes=root.classes();\n    final FieldDoc[] fields=classes[0].fields();\n    for (    final FieldDoc field : fields) {\n      if (field.isStatic() && field.isPublic() && field.isFinal()&& \"int\".equals(field.type().qualifiedTypeName())) {\n// bug_start\n        if (field.firstSentenceTags().length != 1) {\n// bug_end\n          final List<Tag> tags=Arrays.asList(field.firstSentenceTags());\n          final String joinedTags=tags.stream().map(null).collect(Collectors.joining(\"\\\", \\\"\",\"[\\\"\",\"\\\"]\"));\n          final String message=String.format(Locale.ROOT,\"Should be only one tag for %s. Tags %s.\",field.toString(),joinedTags);\n          throw new IllegalArgumentException(message);\n        }\n        writer.println(field.name() + \"=\" + field.firstSentenceTags()[0].text());\n      }\n    }\n  }\n  finally {\n    writer.close();\n  }\n  return true;\n}\n"}
{"INPUT": "@Override public void prepare(CallableStatement statement,int startIndex) throws SQLException {\n  if (mode == ParameterMode.REF_CURSOR) {\n    throw new NotYetImplementedException(\"Support for REF_CURSOR parameters not yet supported\");\n  }\n  Type typeToUse=hibernateType;\n  int[] sqlTypesToUse=sqlTypes;\n// bug_start\n  if (bind.getExplicitTemporalType() != null) {\n// bug_end\n    if (Calendar.class.isInstance(bind.getValue())) {\nswitch (bind.getExplicitTemporalType()) {\ncase TIMESTAMP:\n{\n          typeToUse=CalendarType.INSTANCE;\n          sqlTypesToUse=typeToUse.sqlTypes(session().getFactory());\n          break;\n        }\ncase DATE:\n{\n        typeToUse=CalendarDateType.INSTANCE;\n        sqlTypesToUse=typeToUse.sqlTypes(session().getFactory());\n        break;\n      }\ncase TIME:\n{\n      typeToUse=CalendarTimeType.INSTANCE;\n      sqlTypesToUse=typeToUse.sqlTypes(session().getFactory());\n      break;\n    }\n}\n}\n}\nthis.startIndex=startIndex;\nif (mode == ParameterMode.IN || mode == ParameterMode.INOUT || mode == ParameterMode.OUT) {\nif (mode == ParameterMode.INOUT || mode == ParameterMode.OUT) {\nif (sqlTypesToUse.length > 1) {\n  final boolean canHandleMultiParamExtraction=ProcedureParameterExtractionAware.class.isInstance(hibernateType) && ((ProcedureParameterExtractionAware)hibernateType).canDoExtraction();\n  if (!canHandleMultiParamExtraction) {\n    throw new UnsupportedOperationException(\"Type [\" + hibernateType + \"] does support multi-parameter value extraction\");\n  }\n}\nfor (int i=0; i < sqlTypesToUse.length; i++) {\n  statement.registerOutParameter(startIndex + i,sqlTypesToUse[i]);\n}\n}\nif (mode == ParameterMode.INOUT || mode == ParameterMode.IN) {\nif (bind == null || bind.getValue() == null) {\n  log.debugf(\"Stored procedure [%s] IN/INOUT parameter [%s] not bound; assuming procedure defines default value\",procedureCall.getProcedureName(),this);\n}\n else {\n  typeToUse.nullSafeSet(statement,bind.getValue(),startIndex,session());\n}\n}\n}\n else {\nif (procedureCall.getParameterStrategy() == ParameterStrategy.NAMED) {\nsession().getFactory().getServiceRegistry().getService(RefCursorSupport.class).registerRefCursorParameter(statement,getName());\n}\n else {\nsession().getFactory().getServiceRegistry().getService(RefCursorSupport.class).registerRefCursorParameter(statement,getPosition());\n}\n}\n}\n"}
{"INPUT": "@Override public Deferred<ArrayList<ArrayList<KeyValue>>> answer(final InvocationOnMock invocation) throws Throwable {\n  if (called) {\n    return Deferred.fromResult(null);\n  }\n  called=true;\n  Pattern pattern=null;\n  if (regex != null && !regex.isEmpty()) {\n    try {\n      pattern=Pattern.compile(regex);\n    }\n catch (    PatternSyntaxException e) {\n      e.printStackTrace();\n    }\n  }\n  ArrayList<ArrayList<KeyValue>> results=new ArrayList<ArrayList<KeyValue>>();\n  for (  Map.Entry<byte[],ByteMap<ByteMap<TreeMap<Long,byte[]>>>> row : storage.entrySet()) {\n    if (start != null && Bytes.memcmp(row.getKey(),start) < 0) {\n      continue;\n    }\n// bug_start\n    if (stop != null && Bytes.memcmp(row.getKey(),stop) >= 0 && Bytes.memcmp(start,stop) != 0) {\n// bug_end\n      continue;\n    }\n    if (pattern != null) {\n      final String from_bytes=new String(row.getKey(),MockBase.ASCII);\n      if (!pattern.matcher(from_bytes).find()) {\n        continue;\n      }\n    }\n    final ArrayList<KeyValue> kvs=new ArrayList<KeyValue>(row.getValue().size());\n    for (    Map.Entry<byte[],ByteMap<TreeMap<Long,byte[]>>> cf : row.getValue().entrySet()) {\n      if (family != null && family.length > 0 && !Bytes.equals(family,cf.getKey())) {\n        continue;\n      }\n      for (      Map.Entry<byte[],TreeMap<Long,byte[]>> column : cf.getValue().entrySet()) {\n        if (scnr_qualifiers != null && !scnr_qualifiers.contains(bytesToString(column.getKey()))) {\n          continue;\n        }\n        kvs.add(new KeyValue(row.getKey(),cf.getKey(),column.getKey(),column.getValue().firstKey(),column.getValue().firstEntry().getValue()));\n      }\n    }\n    if (!kvs.isEmpty()) {\n      results.add(kvs);\n    }\n  }\n  if (results.isEmpty()) {\n    return Deferred.fromResult(null);\n  }\n  return Deferred.fromResult(results);\n}\n"}
{"INPUT": "public void fromDBObject(final DBObject dbObject,final MappedField mf,final Object entity,EntityCache cache,Mapper mapr){\n  try {\n    if (mf.isMap()) {\n      readMap(dbObject,mf,entity,cache,mapr);\n    }\n else     if (mf.isMultipleValues()) {\n      readCollection(dbObject,mf,entity,cache,mapr);\n    }\n else {\n      Object dbVal=mf.getDbObjectValue(dbObject);\n      if (dbVal != null) {\n// bug_start\n        boolean isDBObject=dbVal instanceof DBObject;\n// bug_end\n        if (isDBObject && (mapr.converters.hasDbObjectConverter(mf) || mapr.converters.hasDbObjectConverter(mf.getType()))) {\n          mapr.converters.fromDBObject(((DBObject)dbVal),mf,entity);\n          return;\n        }\n else {\n          Object refObj=null;\n          if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(mf.getType()))           refObj=mapr.converters.decode(mf.getType(),dbVal,mf);\n else {\n            refObj=mapr.getOptions().objectFactory.createInstance(mapr,mf,((DBObject)dbVal));\n            refObj=mapr.fromDb(((DBObject)dbVal),refObj,cache);\n          }\n          if (refObj != null) {\n            mf.setFieldValue(entity,refObj);\n          }\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n"}
{"INPUT": "@Override public final RuleMatch[] match(final AnalyzedSentence text){\n  List<RuleMatch> ruleMatches=new ArrayList<>();\n  AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();\n  for (  AnalyzedTokenReadings tokenReadings : tokens) {\n// bug_start\n    if (tokenReadings.isImmunized()) {\n// bug_end\n      continue;\n    }\n    String originalTokenStr=tokenReadings.getToken();\n    if (ignoreTaggedWords && tokenReadings.isTagged()) {\n      continue;\n    }\n    String tokenString=cleanup(originalTokenStr);\n    if (!wrongWords.containsKey(tokenString)) {\n      for (      AnalyzedToken analyzedToken : tokenReadings.getReadings()) {\n        String lemma=analyzedToken.getLemma();\n        if (lemma != null) {\n          lemma=cleanup(lemma);\n          if (wrongWords.containsKey(lemma)) {\n            tokenString=lemma;\n            break;\n          }\n        }\n      }\n    }\n    List<String> possibleReplacements=wrongWords.get(originalTokenStr);\n    if (possibleReplacements == null) {\n      possibleReplacements=wrongWords.get(tokenString);\n    }\n    if (possibleReplacements != null && possibleReplacements.size() > 0) {\n      List<String> replacements=new ArrayList<>();\n      replacements.addAll(possibleReplacements);\n      if (replacements.contains(originalTokenStr)) {\n        replacements.remove(originalTokenStr);\n      }\n      if (replacements.size() > 0) {\n        RuleMatch potentialRuleMatch=createRuleMatch(tokenReadings,replacements);\n        ruleMatches.add(potentialRuleMatch);\n      }\n    }\n  }\n  return toRuleMatchArray(ruleMatches);\n}\n"}
{"INPUT": "private void callStateChanged(CallChangeEvent callChangeEvent){\n  Call call=callChangeEvent.getSourceCall();\n  if (CallState.CALL_INITIALIZATION.equals(callChangeEvent.getOldValue()) && CallState.CALL_IN_PROGRESS.equals(call.getCallState()) && ProtocolProviderActivator.getConfigurationService().getBoolean(PNAME_SINGLE_CALL_IN_PROGRESS_POLICY_ENABLED,true)) {\nsynchronized (calls) {\n      for (      Call otherCall : calls) {\n        if (!call.equals(otherCall) && CallState.CALL_IN_PROGRESS.equals(otherCall.getCallState())) {\n// bug_start\n          if ((call.getCallGroup() != null || otherCall.getCallGroup() != null) && call.getCallGroup() != otherCall.getCallGroup())           putOnHold(otherCall);\n// bug_end\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override public List<? extends Module> getJacksonModules(){\n// bug_start\n  return Collections.<Module>singletonList(new SimpleModule(\"IndexingHadoopModule\").registerSubtypes(new NamedType(HadoopyStringInputRowParser.class,\"hadoopyString\")));\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@SuppressLint(\"WrongConstant\") @TargetApi(Build.VERSION_CODES.M) private boolean needsMirroring(){\n// bug_end\n  return isAutoMirrored() && getLayoutDirection() == LayoutDirection.RTL;\n}\n"}
{"INPUT": "@Test public void testSparkW2VonBiggerCorpus() throws Exception {\n  SparkConf sparkConf=new SparkConf().setMaster(\"local[8]\").setAppName(\"sparktest\").set(\"spark.driver.maxResultSize\",\"4g\").set(\"spark.driver.memory\",\"8g\").set(\"spark.executor.memory\",\"8g\");\n  JavaSparkContext sc=new JavaSparkContext(sparkConf);\n// bug_start\n  String dataPath=\"/ext/Temp/SampleRussianCorpus.txt\";\n// bug_end\n  JavaRDD<String> corpus=sc.textFile(dataPath);\n  TokenizerFactory t=new DefaultTokenizerFactory();\n  t.setTokenPreProcessor(new LowCasePreProcessor());\n  Word2Vec word2Vec=new Word2Vec.Builder().setNGrams(1).tokenizerFactory(t).seed(42L).negative(3).useAdaGrad(false).layerSize(100).windowSize(5).learningRate(0.025).minLearningRate(0.0001).iterations(1).batchSize(100).minWordFrequency(5).useUnknown(true).build();\n  word2Vec.train(corpus);\n  sc.stop();\n  WordVectorSerializer.writeWordVectors(word2Vec.getLookupTable(),\"/ext/Temp/sparkRuModel.txt\");\n}\n"}
{"INPUT": "@Override protected String getMessageInternal(final String code,final Object[] args,final Locale locale){\n  boolean foundCode=false;\n  if (!locale.equals(Locale.ENGLISH)) {\n    for (int i=0; !foundCode && i < this.basenames.length; i++) {\n// bug_start\n      final String filename=this.basenames[i] + \"_\" + locale;\n// bug_end\n      logger.debug(\"Examining language bundle [{}] for the code [{}]\",filename,code);\n      final PropertiesHolder holder=this.getProperties(filename);\n      foundCode=holder != null && holder.getProperties() != null && holder.getProperty(code) != null;\n    }\n    if (!foundCode) {\n      logger.debug(\"The code [{}] cannot be found in the language bundle for the locale [{}]\",code,locale);\n    }\n  }\n  return super.getMessageInternal(code,args,locale);\n}\n"}
{"INPUT": "public SymbolTable(int tableSize){\n  this.indexMask=tableSize - 1;\n  this.symbols=new String[tableSize];\n  this.addSymbol(\"$ref\",0,4,\"$ref\".hashCode());\n// bug_start\n  this.addSymbol(JSON.DEFAULT_TYPE_KEY,0,5,JSON.DEFAULT_TYPE_KEY.hashCode());\n// bug_end\n}\n"}
{"INPUT": "public void run(){\n  try (Socket s=srv.accept()){\n    readOneRequest(s.getInputStream());\n    try (OutputStreamWriter ow=new OutputStreamWriter((s.getOutputStream()))){\n// bug_start\n      FileInputStream fin=new FileInputStream(\"foo1.jar\");\n// bug_end\n      int length=fin.available();\n      byte[] b=new byte[length - 10];\n      fin.read(b,0,length - 10);\n      ow.write(\"HTTP/1.0 200 OK\\r\\n\");\n      ow.write(\"Content-Length: \" + length + \"\\r\\n\");\n      ow.write(\"Content-Type: text/html\\r\\n\");\n      ow.write(\"\\r\\n\");\n      ow.write(new String(b));\n      ow.flush();\n    }\n   }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n"}
{"INPUT": "@Override public void arrowClick(Status status,int position){\n// bug_start\n  TimelineArrowWindow popupWindow=new TimelineArrowWindow(mContext,mDatas.get(position),mAdapter,position,\"\");\n// bug_end\n  popupWindow.showAtLocation(mRecyclerView,Gravity.CENTER,0,0);\n}\n"}
{"INPUT": "@Override public final boolean preHandle(final HttpServletRequest request,final HttpServletResponse response,final Object o) throws Exception {\n  if (!\"POST\".equals(request.getMethod())) {\n    return true;\n  }\n  if (exceedsThreshold(request)) {\n    recordThrottle(request);\n    request.setAttribute(WebUtils.CAS_ACCESS_DENIED_REASON,\"screen.blocked.message\");\n// bug_start\n    response.sendError(HttpStatus.SC_FORBIDDEN,\"Access Denied for user [\" + request.getParameter(usernameParameter) + \"] from IP Address [\"+ request.getRemoteAddr()+ \"]\");\n// bug_end\n    return false;\n  }\n  return true;\n}\n"}
{"INPUT": "private void log(String string){\n// bug_start\n  System.out.print(\".\");\n// bug_end\n  if (m_count++ % 40 == 0) {\n    System.out.println(\"\");\n  }\n}\n"}
{"INPUT": "@Override public boolean onTouchEvent(@NonNull MotionEvent event){\n  if (singleTapDetector.onTouchEvent(event)) {\n    if (tag != null) {\n      tag.onClick();\n    }\n    touchEventsCancelled();\n// bug_start\n    return true;\n// bug_end\n  }\nswitch (event.getAction() & MotionEvent.ACTION_MASK) {\ncase MotionEvent.ACTION_DOWN:\n    if (!mCellIsMobile && mHoverCell == null) {\n      View v=findViewAtPositionWithDragIconTag(getRootView(),(int)event.getRawX(),(int)event.getRawY());\n      if ((v != null) && (v.getTag() != null) && (v.getTag() instanceof DragIcon)) {\n        mDownX=(int)event.getX();\n        mDownY=(int)event.getY();\n        mActivePointerId=event.getPointerId(0);\n        mTotalOffset=0;\n        tag=(DragIcon)v.getTag();\n        int position=pointToPosition(mDownX,mDownY);\n        if (position != INVALID_POSITION) {\n          Object item=getAdapter().getItem(position);\n          if (mActiveItemsList == null || mActiveItemsList.contains(item)) {\n            int itemNum=position - getFirstVisiblePosition();\n            itemsSwapped=false;\n            View selectedView=getChildAt(itemNum);\n            mMobileItemId=getAdapter().getItemId(position);\n            mHoverCell=getAndAddHoverView(selectedView);\n            selectedView.setVisibility(INVISIBLE);\n            mCellIsMobile=true;\n            updateNeighborViewsForID(mMobileItemId);\n            if (dCallbacks != null) {\n              dCallbacks.onItemSwapping(position);\n            }\n          }\n        }\n      }\n    }\n  break;\ncase MotionEvent.ACTION_MOVE:\nif (mActivePointerId == INVALID_POINTER_ID) {\n  break;\n}\nint pointerIndex=event.findPointerIndex(mActivePointerId);\nmLastEventY=(int)event.getY(pointerIndex);\nint deltaY=mLastEventY - mDownY;\nif (mCellIsMobile && mHoverCell != null) {\nmHoverCellCurrentBounds.offsetTo(mHoverCellOriginalBounds.left,mHoverCellOriginalBounds.top + deltaY + mTotalOffset);\nmHoverCell.setBounds(mHoverCellCurrentBounds);\ninvalidate();\nhandleCellSwitch();\nmIsMobileScrolling=false;\nhandleMobileCellScroll();\nreturn false;\n}\nbreak;\ncase MotionEvent.ACTION_UP:\ntouchEventsEnded();\nbreak;\ncase MotionEvent.ACTION_CANCEL:\ntouchEventsCancelled();\nbreak;\ncase MotionEvent.ACTION_POINTER_UP:\npointerIndex=(event.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;\nfinal int pointerId=event.getPointerId(pointerIndex);\nif (pointerId == mActivePointerId) {\ntouchEventsEnded();\n}\nbreak;\ndefault :\nbreak;\n}\nreturn super.onTouchEvent(event);\n}\n"}
{"INPUT": "protected static HttpURLConnection connect(String apiUrl,String accessToken) throws IOException {\n  HttpURLConnection connection=(HttpURLConnection)new URL(apiUrl).openConnection();\n  connection.setDoOutput(true);\n  connection.setRequestMethod(\"GET\");\n  connection.setRequestProperty(\"Content-type\",\"application/json\");\n  connection.setRequestProperty(\"Authorization\",\"token \" + accessToken);\n  connection.connect();\n  int status=connection.getResponseCode();\n  if (status == 401) {\n    throw new ServiceException.PreconditionRequired(\"Invalid accessToken\");\n  }\n  if (status == 403) {\n    throw new ServiceException.PreconditionRequired(\"Github accessToken does not have required scopes. Expected scopes 'user:email, repo'\");\n  }\n  if (status == 404) {\n// bug_start\n    throw new ServiceException.NotFoundException(\"Not Found\");\n// bug_end\n  }\n  if (status != 200) {\n    throw new ServiceException.BadRequestException(String.format(\"Github Api returned error: %s. Error message: %s.\",connection.getResponseCode(),connection.getResponseMessage()));\n  }\n  return connection;\n}\n"}
{"INPUT": "@Override public boolean readFrom(ByteBuffer buf,MessageReader reader){\n  reader.setBuffer(buf);\n  if (!reader.beforeMessageRead())   return false;\nswitch (reader.state()) {\ncase 0:\n    isUndeploy=reader.readBoolean(\"isUndeploy\");\n  if (!reader.isLastRead())   return false;\nreader.incrementState();\ncase 1:\nldrId=reader.readIgniteUuid(\"ldrId\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 2:\nnodeIds=reader.readCollection(\"nodeIds\",MessageCollectionItemType.UUID);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 3:\nresTopicBytes=reader.readByteArray(\"resTopicBytes\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 4:\nrsrcName=reader.readString(\"rsrcName\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\n}\n// bug_start\nreturn true;\n// bug_end\n}\n"}
{"INPUT": "private static void assertContains(GraphVertex<StateDescriptor> graph,Class<? extends StateDescriptor> state){\n// bug_start\n  throw new Error(\"Implement me\");\n// bug_end\n}\n"}
{"INPUT": "public String getDDL(DBRProgressMonitor monitor) throws DBException {\n  if (!isPersisted()) {\n// bug_start\n    return \"\";\n// bug_end\n  }\n  try (JDBCSession session=DBUtils.openMetaSession(monitor,getDataSource(),\"Retrieve table DDL\")){\n    try (PreparedStatement dbStat=session.prepareStatement(\"SHOW CREATE \" + (isView() ? \"VIEW\" : \"TABLE\") + \" \"+ getFullyQualifiedName(DBPEvaluationContext.DDL))){\n      try (ResultSet dbResult=dbStat.executeQuery()){\n        if (dbResult.next()) {\n          byte[] ddl;\n          if (isView()) {\n            ddl=dbResult.getBytes(\"Create View\");\n          }\n else {\n            ddl=dbResult.getBytes(\"Create Table\");\n          }\n          if (ddl == null) {\n            return null;\n          }\n else {\n            try {\n              return new String(ddl,getContainer().getDefaultCharset().getName());\n            }\n catch (            UnsupportedEncodingException e) {\n              log.debug(e);\n              return new String(ddl);\n            }\n          }\n        }\n else {\n          return \"DDL is not available\";\n        }\n      }\n     }\n   }\n catch (  SQLException ex) {\n    throw new DBException(ex,getDataSource());\n  }\n}\n"}
{"INPUT": "@Override public Deferred<String> metricNameAsync(){\n  if (row_key == null) {\n    throw new IllegalStateException(\"Instance was not properly constructed!\");\n  }\n// bug_start\n  final byte[] id=Arrays.copyOfRange(row_key,0,tsdb.metrics.width() + Const.SALT_WIDTH());\n// bug_end\n  return tsdb.metrics.getNameAsync(id);\n}\n"}
{"INPUT": "public void GenVarDecl(Vector varVec,Vector varVecSource){\n  if (varVec.size() == 0) {\n    return;\n  }\n  ;\n  if (varVec.size() > 1) {\n    addOneTokenToTLA(\"VARIABLES \");\n  }\n else {\n// bug_start\n    addOneTokenToTLA(\"VARIABLE \");\n// bug_end\n  }\n  ;\n  for (int i=0; i < varVec.size(); i++) {\n    if (i > 0) {\n      addOneTokenToTLA(\", \");\n    }\n    ;\n    String vbl=(String)varVec.elementAt(i);\n    AST vblsource=(AST)varVecSource.elementAt(i);\n    if (tlacodeNextLine.length() + vbl.length() + 1 > wrapColumn) {\n      endCurrentLineOfTLA();\n      if (varVec.size() > 1) {\n        tlacodeNextLine=tlacodeNextLine + NSpaces(\"VARIABLES \".length());\n      }\n else {\n        tlacodeNextLine=tlacodeNextLine + NSpaces(\"VARIABLE \".length());\n      }\n      ;\n    }\n    ;\n    addOneSourceTokenToTLA(vbl,vblsource.getOrigin());\n  }\n  ;\n  endCurrentLineOfTLA();\n}\n"}
{"INPUT": "public String getCreateSQL(){\n  StatementBuilder buff=new StatementBuilder(\"CREATE \");\n  if (isTemporary()) {\n    if (isGlobalTemporary()) {\n      buff.append(\"GLOBAL \");\n    }\n else {\n      buff.append(\"LOCAL \");\n    }\n    buff.append(\"TEMPORARY \");\n  }\n else   if (isPersistIndexes()) {\n    buff.append(\"CACHED \");\n  }\n else {\n    buff.append(\"MEMORY \");\n  }\n  buff.append(\"TABLE \");\n  if (isHidden) {\n    buff.append(\"IF NOT EXISTS \");\n  }\n  buff.append(getSQL());\n  if (comment != null) {\n    buff.append(\" COMMENT \").append(StringUtils.quoteStringSQL(comment));\n  }\n  buff.append(\"(\\n    \");\n  for (  Column column : columns) {\n    buff.appendExceptFirst(\",\\n    \");\n    buff.append(column.getCreateSQL());\n  }\n  buff.append(\"\\n)\");\n  if (tableEngine != null) {\n    buff.append(\"\\nENGINE \\\"\");\n    buff.append(tableEngine);\n// bug_start\n    buff.append(\"\\\"\");\n// bug_end\n  }\n  if (!isPersistIndexes() && !isPersistData()) {\n    buff.append(\"\\nNOT PERSISTENT\");\n  }\n  if (isHidden) {\n    buff.append(\"\\nHIDDEN\");\n  }\n  return buff.toString();\n}\n"}
{"INPUT": "private int runBundler(final List<String> arguments,final Path path,final EmbulkSystemProperties embulkSystemProperties){\n  final ScriptingContainerDelegate localJRubyContainer;\n  try {\n    localJRubyContainer=createJRubyForRubyCommand(embulkSystemProperties,\"bundle\");\n  }\n catch (  final NullPointerException ex) {\n    System.err.println(ex.getMessage());\n    return -1;\n  }\n  localJRubyContainer.runScriptlet(\"require 'bundler'\");\n  localJRubyContainer.runScriptlet(\"Bundler.define_singleton_method(:which_orig, Bundler.method(:which))\");\n  localJRubyContainer.runScriptlet(\"Bundler.define_singleton_method(:which) { |executable| (executable == 'man' ? false : which_orig(executable)) }\");\n  localJRubyContainer.runScriptlet(\"require 'bundler/friendly_errors'\");\n  localJRubyContainer.runScriptlet(\"require 'bundler/cli'\");\n  localJRubyContainer.put(\"__internal_argv_java__\",arguments);\n  if (path == null) {\n    localJRubyContainer.runScriptlet(\"Bundler.with_friendly_errors { Bundler::CLI.start(Array.new(__internal_argv_java__), debug: true) }\");\n  }\n else {\n    localJRubyContainer.put(\"__internal_working_dir__\",path.toString());\n// bug_start\n    localJRubyContainer.runScriptlet(\"Dir.chdir(__internal_working_dir__) { Bundler.with_friendly_errors { Bundler::CLI.start(__internal_argv__, debug: true) } }\");\n// bug_end\n    localJRubyContainer.remove(\"__internal_working_dir__\");\n  }\n  localJRubyContainer.remove(\"__internal_argv_java__\");\n  return 0;\n}\n"}
{"INPUT": "public void testBasic() throws Exception {\n// bug_start\n  Feed feed=new Feed(new PackagedFeed(\"caltrain_gtfs.zip\"));\n// bug_end\n  Graph gg=new Graph();\n  GTFSHopLoader hl=new GTFSHopLoader(gg,feed);\n  hl.load();\n  ShortestPathTree spt=Dijkstra.getShortestPathTree(gg,\"Millbrae Caltrain\",\"Mountain View Caltrain\",new State(new GregorianCalendar(2009,8,7,12,0,0)),new WalkOptions());\n  assertTrue(((Hop)spt.getPath(gg.getVertex(\"Mountain View Caltrain\")).vertices.lastElement().incoming.payload).end.arrival_time.getSecondsSinceMidnight() == 48540);\n}\n"}
{"INPUT": "public SSLContext load(SSLSettings sslSettings){\n  if (logger.isDebugEnabled()) {\n// bug_start\n    logger.debug(\"using keystore[{}], key_algorithm[{}], truststore[{}], truststore_algorithm[{}], tls_protocol[{}], session_cache_size[{}], session_cache_timeout[{}]\",sslSettings.keyStorePath,sslSettings.keyStoreAlgorithm,sslSettings.trustStorePath,sslSettings.trustStoreAlgorithm,sslSettings.sslProtocol,sslSettings.sessionCacheSize,sslSettings.sessionCacheTimeout);\n// bug_end\n  }\n  TrustManager[] trustManagers=trustManagers(sslSettings.trustStorePath,sslSettings.trustStorePassword,sslSettings.trustStoreAlgorithm);\n  KeyManager[] keyManagers=keyManagers(sslSettings.keyStorePath,sslSettings.keyStorePassword,sslSettings.keyStoreAlgorithm,sslSettings.keyPassword);\n  return createSslContext(keyManagers,trustManagers,sslSettings.sslProtocol,sslSettings.sessionCacheSize,sslSettings.sessionCacheTimeout);\n}\n"}
{"INPUT": "@Before public void createComponents() throws Exception {\n  Settings.Builder builder=Settings.builder().put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(),TimeValue.timeValueSeconds(1));\n  jobProvider=new JobResultsProvider(client(),builder.build(),new IndexNameExpressionResolver());\n  ThreadPool tp=mock(ThreadPool.class);\n  ClusterSettings clusterSettings=new ClusterSettings(builder.build(),new HashSet<>(Arrays.asList(InferenceProcessor.MAX_INFERENCE_PROCESSORS,MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING,OperationRouting.USE_ADAPTIVE_REPLICA_SELECTION_SETTING,ResultsPersisterService.PERSIST_RESULTS_MAX_RETRIES,ClusterService.USER_DEFINED_METADATA,ClusterApplierService.CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING)));\n  ClusterService clusterService=new ClusterService(builder.build(),clusterSettings,tp);\n  OriginSettingClient originSettingClient=new OriginSettingClient(client(),ClientHelper.ML_ORIGIN);\n  resultsPersisterService=new ResultsPersisterService(originSettingClient,clusterService,builder.build());\n// bug_start\n  auditor=new AnomalyDetectionAuditor(client(),\"test_node\");\n// bug_end\n  waitForMlTemplates();\n}\n"}
{"INPUT": "@Override public void onChildrenLoaded(String parentId,List<MediaBrowser.MediaItem> children){\n  if (children.size() == 0) {\n// bug_start\n    Log.e(TAG,\"No children found\");\n// bug_end\n    return;\n  }\n  MediaBrowser.MediaItem child=children.get(0);\n  MediaDescription desc=child.getDescription();\n  if (child.isPlayable()) {\n    mCallback.addTrack(desc,mMediaBrowser.getServiceComponent(),QSMediaBrowser.this);\n  }\n else {\n    Log.e(TAG,\"Child found but not playable for \" + mComponentName);\n  }\n  mMediaBrowser.disconnect();\n}\n"}
{"INPUT": "protected void doStop() throws Exception {\n  LOG.debug(\"Stopping connection: {}\",transport.getRemoteAddress());\n  connector.onStopped(this);\n  try {\nsynchronized (this) {\n      if (duplexBridge != null) {\n        duplexBridge.stop();\n      }\n    }\n  }\n catch (  Exception ignore) {\n    LOG.trace(\"Exception caught stopping. This exception is ignored.\",ignore);\n  }\n  try {\n    transport.stop();\n    LOG.debug(\"Stopped transport: {}\",transport.getRemoteAddress());\n  }\n catch (  Exception e) {\n    LOG.debug(\"Could not stop transport to {}. This exception is ignored.\",transport.getRemoteAddress(),e);\n  }\n  if (taskRunner != null) {\n    taskRunner.shutdown(1);\n    taskRunner=null;\n  }\n  active=false;\nsynchronized (dispatchQueue) {\n    for (Iterator<Command> iter=dispatchQueue.iterator(); iter.hasNext(); ) {\n      Command command=iter.next();\n      if (command.isMessageDispatch()) {\n        MessageDispatch md=(MessageDispatch)command;\n        TransmitCallback sub=md.getTransmitCallback();\n        broker.postProcessDispatch(md);\n        if (sub != null) {\n          sub.onFailure();\n        }\n      }\n    }\n    dispatchQueue.clear();\n  }\n  if (!broker.isStopped()) {\n    List<TransportConnectionState> connectionStates=listConnectionStates();\n    connectionStates=listConnectionStates();\n    for (    TransportConnectionState cs : connectionStates) {\n      cs.getContext().getStopping().set(true);\n      try {\n        LOG.debug(\"Cleaning up connection resources: {}\",getRemoteAddress());\n// bug_start\n        processRemoveConnection(cs.getInfo().getConnectionId(),0l);\n// bug_end\n      }\n catch (      Throwable ignore) {\n        ignore.printStackTrace();\n      }\n    }\n  }\n  LOG.debug(\"Connection Stopped: {}\",getRemoteAddress());\n}\n"}
{"INPUT": "public static KafkaBridgeCluster fromCrd(KafkaBridge kafkaBridge,KafkaVersion.Lookup versions){\n  KafkaBridgeCluster kafkaBridgeCluster=new KafkaBridgeCluster(kafkaBridge.getMetadata().getNamespace(),kafkaBridge.getMetadata().getName(),Labels.fromResource(kafkaBridge).withKind(kafkaBridge.getKind()));\n  KafkaBridgeSpec spec=kafkaBridge.getSpec();\n  kafkaBridgeCluster.tracing=spec.getTracing();\n  kafkaBridgeCluster.setResources(spec.getResources());\n  kafkaBridgeCluster.setLogging(spec.getLogging());\n// bug_start\n  kafkaBridgeCluster.setGcLoggingEnabled(spec.getJvmOptions() == null ? true : spec.getJvmOptions().isGcLoggingEnabled());\n// bug_end\n  String image=spec.getImage();\n  if (image == null) {\n    image=System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_KAFKA_BRIDGE_IMAGE,\"strimzi/kafka-bridge:latest\");\n  }\n  kafkaBridgeCluster.setImage(image);\n  kafkaBridgeCluster.setReplicas(spec.getReplicas() > 0 ? spec.getReplicas() : DEFAULT_REPLICAS);\n  kafkaBridgeCluster.setBootstrapServers(spec.getBootstrapServers());\n  kafkaBridgeCluster.setKafkaConsumerConfiguration(spec.getConsumer());\n  kafkaBridgeCluster.setKafkaProducerConfiguration(spec.getProducer());\n  if (kafkaBridge.getSpec().getLivenessProbe() != null) {\n    kafkaBridgeCluster.setLivenessProbe(kafkaBridge.getSpec().getLivenessProbe());\n  }\n  if (kafkaBridge.getSpec().getReadinessProbe() != null) {\n    kafkaBridgeCluster.setReadinessProbe(kafkaBridge.getSpec().getReadinessProbe());\n  }\n  Map<String,Object> metrics=spec.getMetrics();\n  if (metrics != null) {\n    kafkaBridgeCluster.setMetricsEnabled(true);\n    kafkaBridgeCluster.setMetricsConfig(metrics.entrySet());\n  }\n  kafkaBridgeCluster.setTls(spec.getTls() != null ? spec.getTls() : null);\n  AuthenticationUtils.validateClientAuthentication(spec.getAuthentication(),spec.getTls() != null);\n  kafkaBridgeCluster.setAuthentication(spec.getAuthentication());\n  if (spec.getTemplate() != null) {\n    KafkaBridgeTemplate template=spec.getTemplate();\n    if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n      kafkaBridgeCluster.templateDeploymentLabels=template.getDeployment().getMetadata().getLabels();\n      kafkaBridgeCluster.templateDeploymentAnnotations=template.getDeployment().getMetadata().getAnnotations();\n    }\n    ModelUtils.parsePodTemplate(kafkaBridgeCluster,template.getPod());\n    if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n      kafkaBridgeCluster.templateServiceLabels=template.getApiService().getMetadata().getLabels();\n      kafkaBridgeCluster.templateServiceAnnotations=template.getApiService().getMetadata().getAnnotations();\n    }\n    if (template.getBridgeContainer() != null && template.getBridgeContainer().getEnv() != null) {\n      kafkaBridgeCluster.templateContainerEnvVars=template.getBridgeContainer().getEnv();\n    }\n    ModelUtils.parsePodDisruptionBudgetTemplate(kafkaBridgeCluster,template.getPodDisruptionBudget());\n  }\n  if (spec.getHttp() != null) {\n    kafkaBridgeCluster.setHttpEnabled(true);\n    kafkaBridgeCluster.setKafkaBridgeHttpConfig(spec.getHttp());\n  }\n else {\n    log.warn(\"No protocol specified.\");\n    throw new InvalidResourceException(\"No protocol for communication with Bridge specified. Use HTTP.\");\n  }\n  kafkaBridgeCluster.setOwnerReference(kafkaBridge);\n  return kafkaBridgeCluster;\n}\n"}
{"INPUT": "private void deptSetPids(Dept dept){\n// bug_start\n  if (ToolUtil.isEmpty(dept.getPid()) || dept.getPid().equals(\"0\")) {\n// bug_end\n    dept.setPid(0);\n    dept.setPids(\"[0],\");\n  }\n else {\n    int pid=dept.getPid();\n    Dept temp=deptMapper.selectById(pid);\n    String pids=temp.getPids();\n    dept.setPid(pid);\n    dept.setPids(pids + \"[\" + pid+ \"],\");\n  }\n}\n"}
{"INPUT": "@Override public void setBackgroundDrawable(@NonNull Drawable background){\n  if (isUsingOriginalBackground()) {\n    if (background != this.getBackground()) {\n// bug_start\n      Log.w(LOG_TAG,\"Do not set the background; MaterialButton manages its own background drawable.\");\n// bug_end\n      materialButtonHelper.setBackgroundOverwritten();\n      super.setBackgroundDrawable(background);\n    }\n else {\n      getBackground().setState(background.getState());\n    }\n  }\n else {\n    super.setBackgroundDrawable(background);\n  }\n}\n"}
{"INPUT": "private void validateReplay(final ArchiveProxy archiveProxy,final int messageCount){\n  final int replayStreamId=(int)correlationId;\n  try (Subscription replay=aeron.addSubscription(REPLAY_URI,replayStreamId)){\n    final long correlationId=this.correlationId++;\n    TestUtil.waitFor(null);\n    awaitSubscriptionIsConnected(replay);\n    fragmentCount=0;\n    remaining=totalDataLength;\n    while (remaining > 0) {\n      int numFragments=replay.poll(validateFragmentHandler,128);\n      if (0 == numFragments && replay.hasNoImages() && remaining > 0) {\n// bug_start\n        System.err.println(\"Unexpected close of image\");\n// bug_end\n        break;\n      }\n    }\n    assertThat(fragmentCount,is(messageCount));\n    assertThat(remaining,is(0L));\n  }\n }\n"}
{"INPUT": "@Override protected boolean isContentAlwaysEmpty(HttpMessage msg){\n  final int statusCode=((HttpResponse)msg).getStatus().code();\n  if (statusCode == 100 || statusCode == 101) {\n// bug_start\n    return true;\n// bug_end\n  }\n  HttpMethod method=queue.poll();\n  char firstChar=method.name().charAt(0);\nswitch (firstChar) {\ncase 'H':\n    if (HttpMethod.HEAD.equals(method)) {\n      return true;\n    }\n  break;\ncase 'C':\nif (statusCode == 200) {\n  if (HttpMethod.CONNECT.equals(method)) {\n    done=true;\n    queue.clear();\n    return true;\n  }\n}\nbreak;\n}\nreturn super.isContentAlwaysEmpty(msg);\n}\n"}
{"INPUT": "public static QueryOptions forInternalCalls(ConsistencyLevel consistency,ConsistencyLevel serialConsistency,List<ByteBuffer> values){\n// bug_start\n  return new DefaultQueryOptions(consistency,values,false,new SpecificOptions(-1,null,serialConsistency,Long.MIN_VALUE),3);\n// bug_end\n}\n"}
{"INPUT": "@Override public QueryBuilder fromXContent(QueryParseContext parseContext) throws IOException {\n  XContentParser parser=parseContext.parser();\n  XContentParser.Token token=parser.nextToken();\n  if (token != XContentParser.Token.FIELD_NAME) {\n    throw new ParsingException(parser.getTokenLocation(),\"[wrapper] query malformed\");\n  }\n  String fieldName=parser.currentName();\n  if (!fieldName.equals(\"query\")) {\n// bug_start\n    throw new ParsingException(parser.getTokenLocation(),\"[wrapper] query malformed\");\n// bug_end\n  }\n  parser.nextToken();\n  byte[] source=parser.binaryValue();\n  parser.nextToken();\n  if (source == null) {\n    throw new ParsingException(parser.getTokenLocation(),\"wrapper query has no [query] specified\");\n  }\n  return new WrapperQueryBuilder(source);\n}\n"}
{"INPUT": "private BValueArray constructTablesForResultSets(List<ResultSet> resultSets,TableResourceManager rm,Context context,BValueArray structTypes,String databaseProductName) throws SQLException {\n  BValueArray bTables=new BValueArray(new BArrayType(BTypes.typeTable));\n  if (databaseProductName.contains(MYSQL) && (structTypes != null && structTypes.size() > 1)) {\n// bug_start\n    throw new BallerinaException(\"Retrieving result sets from stored procedures returning more than one result set, is not supported \");\n// bug_end\n  }\n else   if (structTypes == null || resultSets.size() != structTypes.size()) {\n    throw new BallerinaException(\"Mismatching record type count: \" + (structTypes == null ? 0 : structTypes.size()) + \" and \"+ \"returned result set count: \"+ resultSets.size()+ \" from the stored procedure\");\n  }\n  for (int i=0; i < resultSets.size(); i++) {\n    bTables.add(i,constructTable(rm,context,resultSets.get(i),(BStructureType)structTypes.getRefValue(i).value(),databaseProductName));\n  }\n  return bTables;\n}\n"}
{"INPUT": "public static Node replaceNode(NodesHolder self,Closure c){\n  if (self.getLength() <= 0 || self.getLength() > 1) {\n// bug_start\n    throw new GroovyRuntimeException(\"replaceNode() can only be used to replace a single element.\");\n// bug_end\n  }\n  return replaceNode(self.item(0),c);\n}\n"}
{"INPUT": "void resetIterator(final AbstractHistogram histogram){\n  this.histogram=histogram;\n  this.savedHistogramTotalRawCount=histogram.getTotalCount();\n  this.arrayTotalCount=histogram.getTotalCount();\n  this.currentBucketIndex=0;\n  this.currentSubBucketIndex=0;\n  this.currentValueAtIndex=0;\n  this.nextBucketIndex=0;\n  this.nextSubBucketIndex=1;\n// bug_start\n  this.nextValueAtIndex=1;\n// bug_end\n  this.prevValueIteratedTo=0;\n  this.totalCountToPrevIndex=0;\n  this.totalCountToCurrentIndex=0;\n  this.totalValueToCurrentIndex=0;\n  this.countAtThisValue=0;\n  this.freshSubBucket=true;\n  if (this.currentIterationValue == null)   this.currentIterationValue=new HistogramIterationValue();\n  currentIterationValue.reset();\n}\n"}
{"INPUT": "private Flow confirmOpened(MasterProcedureEnv env,RegionStateNode regionNode) throws IOException {\n  if (regionNode.isInState(State.OPEN)) {\n    retryCounter=null;\n    if (lastState == RegionStateTransitionState.REGION_STATE_TRANSITION_CONFIRM_OPENED) {\n      regionNode.unsetProcedure(this);\n      ServerCrashProcedure.updateProgress(env,getParentProcId());\n      return Flow.NO_MORE_STATE;\n    }\n    setNextState(RegionStateTransitionState.REGION_STATE_TRANSITION_CLOSE);\n    return Flow.HAS_MORE_STATE;\n  }\n  int retries=env.getAssignmentManager().getRegionStates().addToFailedOpen(regionNode).incrementAndGetRetries();\n  int maxAttempts=env.getAssignmentManager().getAssignMaxAttempts();\n  LOG.info(\"Retry={} of max={}; {}; {}\",retries,maxAttempts,this,regionNode.toShortString());\n  if (retries >= maxAttempts) {\n    env.getAssignmentManager().regionFailedOpen(regionNode,true);\n    setFailure(getClass().getSimpleName(),new RetriesExhaustedException(\"Max attempts \" + env.getAssignmentManager().getAssignMaxAttempts() + \" exceeded\"));\n    regionNode.unsetProcedure(this);\n    return Flow.NO_MORE_STATE;\n  }\n  env.getAssignmentManager().regionFailedOpen(regionNode,false);\n  forceNewPlan=true;\n  regionNode.setRegionLocation(null);\n  setNextState(RegionStateTransitionState.REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE);\n  if (retries > env.getAssignmentManager().getAssignRetryImmediatelyMaxAttempts()) {\n// bug_start\n    throw new HBaseIOException(\"Failed to open region\");\n// bug_end\n  }\n else {\n    return Flow.HAS_MORE_STATE;\n  }\n}\n"}
{"INPUT": "public TomcatServer(String contextPath,int port,String appBase) throws MalformedURLException, ServletException {\n  if (contextPath == null || appBase == null || appBase.length() == 0) {\n    throw new IllegalArgumentException(\"Context path or appbase should not be null\");\n  }\n  if (!contextPath.startsWith(\"/\")) {\n    contextPath=\"/\" + contextPath;\n  }\n  tomcat.setBaseDir(\".\");\n  tomcat.setPort(port);\n// bug_start\n  tomcat.getHost().setAppBase(\".\");\n// bug_end\n  tomcat.addWebapp(contextPath,appBase + \"webapp\");\n}\n"}
{"INPUT": "public boolean checkSelectedPinger(){\n  if (scannerConfig.selectedPinger.startsWith(\"pinger.icmp\")) {\n    try {\n      Pinger icmpPinger=createPinger(scannerConfig.selectedPinger,250);\n      icmpPinger.ping(new ScanningSubject(InetAddress.getLocalHost()),1);\n    }\n catch (    Throwable e) {\n      LOG.info(\"ICMP pinger failed: \" + e);\n// bug_start\n      scannerConfig.selectedPinger=Platform.WINDOWS ? \"pinger.windows\" : \"pinger.combined\";\n// bug_end\n      return false;\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "@Override public void commence(HttpServletRequest request,HttpServletResponse response,AuthenticationException authException) throws IOException, ServletException {\n  response.addHeader(\"WWW-Authenticate\",\"Basic realm=\\\"GEODE\\\"\");\n  response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n  response.setContentType(MediaType.APPLICATION_JSON_UTF8.getType());\n// bug_start\n  ClusterManagementResult result=new ClusterManagementResult(false,authException.getMessage());\n// bug_end\n  objectMapper.writeValue(response.getWriter(),result);\n}\n"}
{"INPUT": "public void run(){\n  final String methodName=\"run\";\n  MqttToken token=null;\n  while (running && (in != null)) {\n    try {\n      log.fine(CLASS_NAME,methodName,\"852\");\n// bug_start\n      receiving=true;\n// bug_end\n      MqttWireMessage message=in.readMqttWireMessage();\n      receiving=false;\n      if (message instanceof MqttAck) {\n        token=tokenStore.getToken(message);\n        if (token != null) {\nsynchronized (token) {\n            clientState.notifyReceivedAck((MqttAck)message);\n          }\n        }\n else {\n          throw new MqttException(MqttException.REASON_CODE_UNEXPECTED_ERROR);\n        }\n      }\n else {\n        clientState.notifyReceivedMsg(message);\n      }\n    }\n catch (    MqttException ex) {\n      log.fine(CLASS_NAME,methodName,\"856\",null,ex);\n      running=false;\n      clientComms.shutdownConnection(token,ex);\n    }\ncatch (    IOException ioe) {\n      log.fine(CLASS_NAME,methodName,\"853\");\n      running=false;\n      if (!clientComms.isDisconnecting()) {\n        clientComms.shutdownConnection(token,new MqttException(MqttException.REASON_CODE_CONNECTION_LOST,ioe));\n      }\n    }\n finally {\n      receiving=false;\n    }\n  }\n  log.fine(CLASS_NAME,methodName,\"854\");\n}\n"}
{"INPUT": "@Test public void callingLengthModificationFunctionsOnFixedLengthLists(){\n  CompileResult negativeResult=BCompileUtil.compile(\"test-src/arraylib_test_negative.bal\");\n  BAssertUtil.validateError(negativeResult,0,\"cannot call 'push' on fixed length list(s) of type 'int[1]'\",3,22);\n  BAssertUtil.validateError(negativeResult,1,\"cannot call 'push' on fixed length list(s) of type '[int,int]'\",8,22);\n  BAssertUtil.validateError(negativeResult,2,\"cannot call 'pop' on fixed length list(s) of type 'int[1]'\",13,35);\n  BAssertUtil.validateError(negativeResult,3,\"cannot call 'pop' on fixed length list(s) of type '[int,int]'\",18,35);\n  BAssertUtil.validateError(negativeResult,4,\"cannot call 'shift' on fixed length list(s) of type 'int[1]'\",29,30);\n  BAssertUtil.validateError(negativeResult,5,\"cannot call 'unshift' on fixed length list(s) of type 'int[1]'\",34,22);\n  BAssertUtil.validateError(negativeResult,6,\"cannot call 'shift' on fixed length list(s) of type '[int,int]'\",39,35);\n  BAssertUtil.validateError(negativeResult,7,\"cannot call 'unshift' on fixed length list(s) of type '[int,int]'\",44,22);\n  BAssertUtil.validateError(negativeResult,8,\"cannot call 'push' on fixed length list(s) of type 'int[2]'\",50,22);\n  BAssertUtil.validateError(negativeResult,9,\"cannot call 'pop' on fixed length list(s) of type 'int[2]'\",51,30);\n  BAssertUtil.validateError(negativeResult,10,\"cannot call 'shift' on fixed length list(s) of type 'int[2]'\",52,26);\n  BAssertUtil.validateError(negativeResult,11,\"cannot call 'unshift' on fixed length list(s) of type 'int[2]'\",53,22);\n  BAssertUtil.validateError(negativeResult,12,\"cannot call 'push' on fixed length list(s) of type '(int[1]|float[1])'\",58,22);\n// bug_start\n  BAssertUtil.validateError(negativeResult,13,\"cannot call 'push' on fixed length list(s) of type '([int,int][1]|[float,float][1])'\",63,22);\n// bug_end\n  Assert.assertEquals(negativeResult.getErrorCount(),14);\n}\n"}
{"INPUT": "public void configure(){\n// bug_start\n  BindyCsvDataFormat camelDataFormat=new BindyCsvDataFormat(\"org.apache.camel.dataformat.bindy.model.simple.oneclass\");\n// bug_end\n  from(\"file://src/test/data/big?noop=true\").unmarshal(camelDataFormat).to(\"mock:result\");\n}\n"}
{"INPUT": "@Override protected void openInternal(InputSplit inputSplit) throws IOException {\n  if (inputSplit.getSplitNumber() != 0) {\n    LOG.info(\"binlog openInternal split number:{} abort...\",inputSplit.getSplitNumber());\n    return;\n  }\n  LOG.info(\"binlog openInternal split number:{} start...\",inputSplit.getSplitNumber());\n  controller=new MysqlEventParser();\n  controller.setConnectionCharset(Charset.forName(\"UTF-8\"));\n// bug_start\n  controller.setSlaveId(3344L);\n// bug_end\n  controller.setDetectingEnable(false);\n  controller.setMasterInfo(new AuthenticationInfo(new InetSocketAddress(host,port),username,password));\n  controller.setEnableTsdb(true);\n  controller.setDestination(\"example\");\n  controller.setParallel(true);\n  controller.setParallelBufferSize(bufferSize);\n  controller.setParallelThreadSize(2);\n  controller.setIsGTIDMode(false);\n  controller.setAlarmHandler(new BinlogAlarmHandler(this));\n  BinlogEventSink sink=new BinlogEventSink(this);\n  sink.setPavingData(pavingData);\n  binlogEventSink=sink;\n  controller.setEventSink(sink);\n  controller.setLogPositionManager(new BinlogPositionManager(this));\n  EntryPosition startPosition=findStartPosition();\n  if (startPosition != null) {\n    controller.setMasterPosition(startPosition);\n  }\n  if (filter != null) {\n    controller.setEventFilter(new AviaterRegexFilter(filter));\n  }\n  controller.start();\n}\n"}
{"INPUT": "@Override public boolean readFrom(ByteBuffer buf,MessageReader reader){\n  reader.setBuffer(buf);\n  if (!reader.beforeMessageRead())   return false;\nswitch (reader.state()) {\ncase 0:\n    clsLdrId=reader.readIgniteUuid(\"clsLdrId\");\n  if (!reader.isLastRead())   return false;\nreader.incrementState();\ncase 1:\nbyte depModeOrd;\ndepModeOrd=reader.readByte(\"depMode\");\nif (!reader.isLastRead()) return false;\ndepMode=DeploymentMode.fromOrdinal(depModeOrd);\nreader.incrementState();\ncase 2:\nevtsBytes=reader.readByteArray(\"evtsBytes\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 3:\nexBytes=reader.readByteArray(\"exBytes\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 4:\nfilter=reader.readByteArray(\"filter\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 5:\nfilterClsName=reader.readString(\"filterClsName\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 6:\nldrParties=reader.readMap(\"ldrParties\",MessageCollectionItemType.UUID,MessageCollectionItemType.IGNITE_UUID,false);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 7:\nresTopicBytes=reader.readByteArray(\"resTopicBytes\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 8:\nuserVer=reader.readString(\"userVer\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\n}\n// bug_start\nreturn true;\n// bug_end\n}\n"}
{"INPUT": "public void removeSourceName(String name){\n  if (sourceNamesField == null || mapField == null) {\n    return;\n  }\n  try {\n    Object sourceNames=sourceNamesField.get(DefaultMetricsSystem.INSTANCE);\n    HashMap map=(HashMap)mapField.get(sourceNames);\nsynchronized (sourceNames) {\n      map.remove(name);\n    }\n  }\n catch (  Exception ex) {\n    if (LOG.isTraceEnabled()) {\n// bug_start\n      LOG.trace(\"Received exception while trying to access Hadoop Metrics classes via reflection.\",ex);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "public LocalNotificationSchedule(JSONObject jsonNotification) throws ParseException {\n  JSONObject schedule=null;\n  try {\n    schedule=jsonNotification.getJSONObject(\"schedule\");\n  }\n catch (  JSONException e) {\n    return;\n  }\n  this.repeats=JsonParserUtils.getBoolean(\"repeats\",schedule);\n  this.every=JsonParserUtils.getString(\"every\",schedule);\n  String dateStr=JsonParserUtils.getString(\"at\",schedule);\n  if (dateStr != null) {\n// bug_start\n    SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSX\");\n// bug_end\n    this.at=sdf.parse(dateStr);\n  }\n}\n"}
{"INPUT": "@Override public void init(CmdArgs args){\n  landmarkCount=args.getInt(Landmark.COUNT,landmarkCount);\n  activeLandmarkCount=args.getInt(Landmark.ACTIVE_COUNT_DEFAULT,Math.max(2,landmarkCount / 2));\n// bug_start\n  String lmWeightingsStr=args.get(\"prepare.lm.weightings\",\"\");\n// bug_end\n  if (!lmWeightingsStr.isEmpty()) {\n    List<String> tmpLMWeightingList=Arrays.asList(lmWeightingsStr.split(\",\"));\n    setWeightingsAsStrings(tmpLMWeightingList);\n  }\n  boolean enableThis=!weightingsAsStrings.isEmpty();\n  setEnabled(enableThis);\n  if (enableThis)   setDisablingAllowed(args.getBool(Landmark.INIT_DISABLING_ALLOWED,isDisablingAllowed()));\n}\n"}
{"INPUT": "@Override protected Settings nodeSettings(int nodeOrdinal){\n// bug_start\n  return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(SslConfigSettings.SSL_HTTP_ENABLED.getKey(),true).put(SslConfigSettings.SSL_KEYSTORE_FILEPATH.getKey(),keyStoreFile.getAbsolutePath()).put(SslConfigSettings.SSL_TRUSTSTORE_FILEPATH.getKey(),trustStoreFile.getAbsolutePath()).put(SslConfigSettings.SSL_RESOURCE_POLL_INTERVAL.getKey(),1).build();\n// bug_end\n}\n"}
{"INPUT": "@Override public InternalAggregation buildEmptyAggregation(){\n// bug_start\n  return new InternalExtendedStats(name,0,0d,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,0d,0d,formatter,pipelineAggregators(),metaData());\n// bug_end\n}\n"}
{"INPUT": "public WordRepeatRule(final ResourceBundle messages,final Language language){\n  super(messages);\n  super.setCategory(new Category(messages.getString(\"category_misc\")));\n// bug_start\n  setLocQualityIssueType(\"duplication\");\n// bug_end\n}\n"}
{"INPUT": "private static DependencySymbolFileProvider valueOf(String text,FileSystem fileSystem){\n  if (!VALID_REGEX.matcher(text).find()) {\n    throw new IllegalArgumentException(text + \" is not in the format \" + commandlineFormat(\"\"));\n  }\n// bug_start\n  String[] parts=text.split(\":\");\n// bug_end\n  return new DependencySymbolFileProvider(getFile(parts[0],fileSystem),getFile(parts[1],fileSystem));\n}\n"}
{"INPUT": "@Override public final int getLevel(int nodeIndex){\n// bug_start\n  if (nodeIndex >= getNodes())   return 0;\n// bug_end\n  return nodes.getInt((long)nodeIndex * nodeEntryBytes + I_LEVEL);\n}\n"}
{"INPUT": "@Override public void createControl(Composite parent){\n  Composite composite=UIUtils.createPlaceholder(parent,1);\n  Group methodGroup=UIUtils.createControlGroup(composite,MySQLMessages.tools_db_export_wizard_page_settings_group_exe_method,1,GridData.FILL_HORIZONTAL,0);\n  methodCombo=new Combo(methodGroup,SWT.DROP_DOWN | SWT.READ_ONLY);\n  methodCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n  methodCombo.add(MySQLMessages.tools_db_export_wizard_page_settings_combo_item_online_backup);\n  methodCombo.add(MySQLMessages.tools_db_export_wizard_page_settings_combo_item_lock_tables);\n  methodCombo.add(MySQLMessages.tools_db_export_wizard_page_settings_combo_item_normal);\n  methodCombo.select(wizard.method.ordinal());\n  Group settingsGroup=UIUtils.createControlGroup(composite,MySQLMessages.tools_db_export_wizard_page_settings_group_settings,2,GridData.FILL_HORIZONTAL,0);\n  noCreateStatementsCheck=UIUtils.createCheckbox(settingsGroup,MySQLMessages.tools_db_export_wizard_page_settings_checkbox_no_create,wizard.noCreateStatements);\n  addDropStatementsCheck=UIUtils.createCheckbox(settingsGroup,MySQLMessages.tools_db_export_wizard_page_settings_checkbox_add_drop,wizard.addDropStatements);\n  disableKeysCheck=UIUtils.createCheckbox(settingsGroup,MySQLMessages.tools_db_export_wizard_page_settings_checkbox_disable_keys,wizard.disableKeys);\n  extendedInsertsCheck=UIUtils.createCheckbox(settingsGroup,MySQLMessages.tools_db_export_wizard_page_settings_checkbox_ext_inserts,wizard.extendedInserts);\n  dumpEventsCheck=UIUtils.createCheckbox(settingsGroup,MySQLMessages.tools_db_export_wizard_page_settings_checkbox_dump_events,wizard.dumpEvents);\n  commentsCheck=UIUtils.createCheckbox(settingsGroup,MySQLMessages.tools_db_export_wizard_page_settings_checkbox_addnl_comments,wizard.comments);\n  Group outputGroup=UIUtils.createControlGroup(composite,MySQLMessages.tools_db_export_wizard_page_settings_group_output,3,GridData.FILL_HORIZONTAL,0);\n// bug_start\n  outputFileText=UIUtils.createLabelText(outputGroup,MySQLMessages.tools_db_export_wizard_page_settings_label_out_text,\"\");\n// bug_end\n  if (wizard.getOutputFile() != null) {\n    outputFileText.setText(wizard.getOutputFile().getAbsolutePath());\n  }\n  outputFileText.addModifyListener(new ModifyListener(){\n    @Override public void modifyText(    ModifyEvent e){\n      updateState();\n    }\n  }\n);\n  Button browseButton=new Button(outputGroup,SWT.PUSH);\n  browseButton.setImage(DBIcon.TREE_FOLDER.getImage());\n  browseButton.addSelectionListener(new SelectionAdapter(){\n    @Override public void widgetSelected(    SelectionEvent e){\n      File file=ContentUtils.selectFileForSave(getShell(),MySQLMessages.tools_db_export_wizard_page_settings_file_selector_title,new String[]{\"*.sql\",\"*.txt\",\"*.*\"},outputFileText.getText());\n      if (file != null) {\n        outputFileText.setText(file.getAbsolutePath());\n      }\n    }\n  }\n);\n  setControl(composite);\n}\n"}
{"INPUT": "public CompletableFuture<RESP> sendRequest(final InetSocketAddress serverAddress,final REQ request){\n  if (shutDown.get()) {\n// bug_start\n    return FutureUtils.getFailedFuture(new IllegalStateException(\"Shut down\"));\n// bug_end\n  }\n  EstablishedConnection connection=establishedConnections.get(serverAddress);\n  if (connection != null) {\n    return connection.sendRequest(request);\n  }\n else {\n    PendingConnection pendingConnection=pendingConnections.get(serverAddress);\n    if (pendingConnection != null) {\n      return pendingConnection.sendRequest(request);\n    }\n else {\n      PendingConnection pending=new PendingConnection(serverAddress,messageSerializer);\n      PendingConnection previous=pendingConnections.putIfAbsent(serverAddress,pending);\n      if (previous == null) {\n        bootstrap.connect(serverAddress.getAddress(),serverAddress.getPort()).addListener(pending);\n        return pending.sendRequest(request);\n      }\n else {\n        return previous.sendRequest(request);\n      }\n    }\n  }\n}\n"}
{"INPUT": "public void updateActiveAndAccessibilityFocusedWindowLocked(int windowId,long nodeId,int eventType,int eventAction){\nswitch (eventType) {\ncase AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:\n{\nsynchronized (mLock) {\n        if (mWindowsForAccessibilityCallback == null) {\n          mFocusedWindowId=getFocusedWindowId();\n          if (windowId == mFocusedWindowId) {\n            mActiveWindowId=windowId;\n          }\n        }\n      }\n    }\n  break;\ncase AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:\n{\nsynchronized (mLock) {\n    if (mTouchInteractionInProgress && mActiveWindowId != windowId) {\n      setActiveWindowLocked(windowId);\n    }\n  }\n}\nbreak;\ncase AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:\n{\nsynchronized (mLock) {\nif (mAccessibilityFocusedWindowId != windowId) {\n// bug_start\n  mMainHandler.sendMessage(obtainMessage(null,AccessibilityManagerService.this,0));\n// bug_end\n  mSecurityPolicy.setAccessibilityFocusedWindowLocked(windowId);\n  mAccessibilityFocusNodeId=nodeId;\n}\n}\n}\nbreak;\ncase AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:\n{\nsynchronized (mLock) {\nif (mAccessibilityFocusNodeId == nodeId) {\nmAccessibilityFocusNodeId=AccessibilityNodeInfo.UNDEFINED_ITEM_ID;\n}\nif ((mAccessibilityFocusNodeId == AccessibilityNodeInfo.UNDEFINED_ITEM_ID) && (mAccessibilityFocusedWindowId == windowId) && (eventAction != AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS)) {\nmAccessibilityFocusedWindowId=INVALID_WINDOW_ID;\n}\n}\n}\nbreak;\n}\n}\n"}
{"INPUT": "private void alterTableAddColumn(int tableNamePosition,TableWriter writer) throws SqlException {\n  expectKeyword(lexer,\"column\");\n  do {\n    CharSequence tok=expectToken(lexer,\"column name\");\n    int index=writer.getMetadata().getColumnIndexQuiet(tok);\n    if (index != -1) {\n      throw SqlException.$(lexer.lastTokenPosition(),\"column '\").put(tok).put(\"' already exists\");\n    }\n    CharSequence columnName=GenericLexer.immutableOf(tok);\n    tok=expectToken(lexer,\"column type\");\n    int type=ColumnType.columnTypeOf(tok);\n    if (type == -1) {\n      throw SqlException.$(lexer.lastTokenPosition(),\"invalid type\");\n    }\n    tok=SqlUtil.fetchNext(lexer);\n    final int indexValueBlockCapacity;\n    final boolean cache;\n    int symbolCapacity;\n    final boolean indexed;\n    if (type == ColumnType.SYMBOL && tok != null && !Chars.equals(tok,',')) {\n      if (isCapacityKeyword(tok)) {\n        tok=expectToken(lexer,\"symbol capacity\");\n        final boolean negative;\n        final int errorPos=lexer.lastTokenPosition();\n        if (Chars.equals(tok,'-')) {\n          negative=true;\n          tok=expectToken(lexer,\"symbol capacity\");\n        }\n else {\n          negative=false;\n        }\n        try {\n          symbolCapacity=Numbers.parseInt(tok);\n        }\n catch (        NumericException e) {\n          throw SqlException.$(lexer.lastTokenPosition(),\"numeric capacity expected\");\n        }\n        if (negative) {\n          symbolCapacity=-symbolCapacity;\n        }\n        TableUtils.validateSymbolCapacity(errorPos,symbolCapacity);\n        tok=SqlUtil.fetchNext(lexer);\n      }\n else {\n        symbolCapacity=configuration.getDefaultSymbolCapacity();\n      }\n      if (Chars.equalsLowerCaseAsciiNc(tok,\"cache\")) {\n        cache=true;\n        tok=SqlUtil.fetchNext(lexer);\n      }\n else       if (Chars.equalsLowerCaseAsciiNc(tok,\"nocache\")) {\n        cache=false;\n        tok=SqlUtil.fetchNext(lexer);\n      }\n else {\n        cache=configuration.getDefaultSymbolCacheFlag();\n      }\n      TableUtils.validateSymbolCapacityCached(cache,symbolCapacity,lexer.lastTokenPosition());\n      indexed=Chars.equalsLowerCaseAsciiNc(tok,\"index\");\n      if (indexed) {\n        tok=SqlUtil.fetchNext(lexer);\n      }\n      if (Chars.equalsLowerCaseAsciiNc(tok,\"capacity\")) {\n        tok=expectToken(lexer,\"symbol index capacity\");\n        try {\n          indexValueBlockCapacity=Numbers.parseInt(tok);\n        }\n catch (        NumericException e) {\n          throw SqlException.$(lexer.lastTokenPosition(),\"numeric capacity expected\");\n        }\n        tok=SqlUtil.fetchNext(lexer);\n      }\n else {\n        indexValueBlockCapacity=configuration.getIndexValueBlockSize();\n      }\n    }\n else {\n// bug_start\n      cache=false;\n// bug_end\n      indexValueBlockCapacity=configuration.getIndexValueBlockSize();\n      symbolCapacity=configuration.getDefaultSymbolCapacity();\n      indexed=false;\n    }\n    try {\n      writer.addColumn(columnName,type,Numbers.ceilPow2(symbolCapacity),cache,indexed,Numbers.ceilPow2(indexValueBlockCapacity),false);\n    }\n catch (    CairoException e) {\n      LOG.error().$(\"Cannot add column '\").$(writer.getName()).$('.').$(columnName).$(\"'. Exception: \").$((Sinkable)e).$();\n      throw SqlException.$(tableNamePosition,\"Cannot add column [error=\").put(e.getFlyweightMessage()).put(']');\n    }\n    if (tok == null) {\n      break;\n    }\n    if (!Chars.equals(tok,',')) {\n      throw SqlException.$(lexer.lastTokenPosition(),\"',' expected\");\n    }\n  }\n while (true);\n}\n"}
{"INPUT": "@Test public void testDeletePathIfEmpty() throws IOException {\n  final Path basePath=new Path(hdfsURI);\n  final Path directory=new Path(basePath,UUID.randomUUID().toString());\n  final Path directoryFile=new Path(directory,UUID.randomUUID().toString());\n  final Path singleFile=new Path(basePath,UUID.randomUUID().toString());\n  FileSystem fs=basePath.getFileSystem();\n  fs.mkdirs(directory);\n  byte[] data=\"HDFSTest#testDeletePathIfEmpty\".getBytes(ConfigConstants.DEFAULT_CHARSET);\n  for (  Path file : Arrays.asList(singleFile,directoryFile)) {\n// bug_start\n    org.apache.flink.core.fs.FSDataOutputStream outputStream=fs.create(file,true);\n// bug_end\n    outputStream.write(data);\n    outputStream.close();\n  }\n  assertTrue(fs.exists(singleFile));\n  assertTrue(fs.exists(directoryFile));\n  assertFalse(FileUtils.deletePathIfEmpty(fs,singleFile));\n  assertTrue(fs.exists(singleFile));\n  assertFalse(FileUtils.deletePathIfEmpty(fs,directory));\n  assertTrue(fs.exists(directory));\n  assertTrue(fs.delete(directoryFile,false));\n  assertTrue(FileUtils.deletePathIfEmpty(fs,directory));\n  assertFalse(fs.exists(directory));\n}\n"}
{"INPUT": "// bug_start\n@Override @SuppressWarnings(\"unchecked\") public int compareTo(ControlData cd){\n// bug_end\n  Comparable c1=(Comparable)data[0];\n  Comparable c2=(Comparable)cd.data[0];\n  return c1.compareTo(c2);\n}\n"}
{"INPUT": "public void testDsEnumerateDomainTrusts(){\n  if (Netapi32Util.getJoinStatus() != LMJoin.NETSETUP_JOIN_STATUS.NetSetupDomainName) {\n    return;\n  }\n  IntByReference domainTrustCount=new IntByReference();\n  PointerByReference domainsPointerRef=new PointerByReference();\n  assertEquals(W32Errors.NO_ERROR,Netapi32.INSTANCE.DsEnumerateDomainTrusts(null,DsGetDC.DS_DOMAIN_VALID_FLAGS,domainsPointerRef,domainTrustCount));\n  assertTrue(domainTrustCount.getValue() >= 0);\n  DS_DOMAIN_TRUSTS domainTrustRefs=new DS_DOMAIN_TRUSTS(domainsPointerRef.getValue());\n// bug_start\n  DS_DOMAIN_TRUSTS[] domainTrusts=(DS_DOMAIN_TRUSTS[])domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[0]);\n// bug_end\n  for (  DS_DOMAIN_TRUSTS trust : domainTrusts) {\n    assertTrue(trust.DnsDomainName.length() > 0);\n    assertTrue(Advapi32.INSTANCE.IsValidSid(trust.DomainSid));\n    assertTrue(Advapi32Util.convertSidToStringSid(trust.DomainSid).startsWith(\"S-\"));\n    assertTrue(Ole32Util.getStringFromGUID(trust.DomainGuid).startsWith(\"{\"));\n  }\n  assertEquals(W32Errors.ERROR_SUCCESS,Netapi32.INSTANCE.NetApiBufferFree(domainTrustRefs.getPointer()));\n}\n"}
{"INPUT": "private static String stripTypeParameters(String type){\n// bug_start\n  int typeParamStart=type.indexOf(\"<\");\n// bug_end\n  if (typeParamStart != -1) {\n    return type.substring(0,typeParamStart);\n  }\n else {\n    return type;\n  }\n}\n"}
{"INPUT": "@Override public void onAttach(Activity activity){\n  if (!(activity instanceof SherlockFragmentActivity)) {\n// bug_start\n    throw new IllegalStateException(\"SherlockFragment must be attached only to a SherlockFragmenActivity.\");\n// bug_end\n  }\n  mActivity=(SherlockFragmentActivity)activity;\n  super.onAttach(activity);\n}\n"}
{"INPUT": "@Override protected void executeSetup(Properties properties,TngpClient client){\n// bug_start\n  client.taskTopic(DEFAULT_TOPIC_NAME,DEFAULT_PARTITION_ID).newTaskSubscription().taskType(\"another\" + TASK_TYPE).handler(null).lockTime(10000L).lockOwner(0).open();\n// bug_end\n}\n"}
{"INPUT": "@Override protected void doInitialize(){\n  final Flow flow=getLoginFlow();\n  if (flow != null) {\n    final ActionState actionState=createActionState(flow,\"digestAuthenticationCheck\",createEvaluateAction(\"digestAuthenticationAction\"));\n    actionState.getTransitionSet().add(createTransition(CasWebflowConstants.TRANSITION_ID_SUCCESS,CasWebflowConstants.STATE_ID_SEND_TICKET_GRANTING_TICKET));\n    actionState.getTransitionSet().add(createTransition(CasWebflowConstants.TRANSITION_ID_WARN,CasWebflowConstants.TRANSITION_ID_WARN));\n// bug_start\n    actionState.getExitActionList().add(createEvaluateAction(\"clearWebflowCredentialsAction\"));\n// bug_end\n    registerMultifactorProvidersStateTransitionsIntoWebflow(actionState);\n    createStateDefaultTransition(actionState,getStartState(flow).getId());\n    setStartState(flow,actionState);\n  }\n}\n"}
{"INPUT": "public List<I> joinWithTimeout(){\n  if (timeout < 0) {\n    join();\n    return null;\n  }\n  if (!threadPool.isShutdown()) {\n    try {\n      List<I> leftover=null;\n      int i;\n      for (i=nThreads; i > 0; --i) {\n        if (idleProcessors.poll(timeout,TimeUnit.MILLISECONDS) == null) {\n          leftover=shutdownNow();\n          break;\n        }\n      }\n      if (i > 0) {\n// bug_start\n        for (; i > 0; --i) {\n// bug_end\n          idleProcessors.take();\n        }\n        return leftover;\n      }\n else {\n        threadPool.shutdown();\n        threadPool.awaitTermination(10,TimeUnit.SECONDS);\n      }\n    }\n catch (    InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "@Override public void addContent(ChannelBuffer buffer,boolean last) throws IOException {\n  if (attribute instanceof MemoryAttribute) {\n    if (attribute.length() + buffer.readableBytes() > limitSize) {\n      DiskAttribute diskAttribute=new DiskAttribute(attribute.getName());\n// bug_start\n      diskAttribute.addContent(((MemoryAttribute)attribute).getChannelBuffer(),false);\n// bug_end\n      attribute=diskAttribute;\n    }\n  }\n  attribute.addContent(buffer,last);\n}\n"}
{"INPUT": "@Override public void run(){\n  do {\n    try {\n      final Socket finalAccept=myServerSocket.accept();\n      InputStream inputStream=finalAccept.getInputStream();\n      OutputStream outputStream=finalAccept.getOutputStream();\n      TempFileManager tempFileManager=tempFileManagerFactory.create();\n      final HTTPSession session=new HTTPSession(tempFileManager,inputStream,outputStream);\n      asyncRunner.exec(new Runnable(){\n        @Override public void run(){\n          session.run();\n          if (finalAccept != null) {\n            try {\n              finalAccept.close();\n            }\n catch (            IOException ignored) {\n            }\n          }\n        }\n      }\n);\n    }\n catch (    IOException e) {\n    }\n  }\n// bug_start\n while (true);\n// bug_end\n}\n"}
{"INPUT": "@Test public void testWhereClauseObjectArrayField() throws Exception {\n  expectedException.expect(UnsupportedOperationException.class);\n// bug_start\n  expectedException.expectMessage(\"unknown function: op_=(bigint_array, integer)\");\n// bug_end\n  e.analyze(\"delete from users where friends['id'] = 5\");\n}\n"}
{"INPUT": "public static final ArrayList<URIMetadataRow> findMetadata(final QueryParams query,final ReferenceOrder order){\n// bug_start\n  RankingProcess rankedCache=new RankingProcess(query,order,1000,2);\n// bug_end\n  rankedCache.run();\n  ArrayList<URIMetadataRow> result=new ArrayList<URIMetadataRow>();\n  URIMetadataRow r;\n  while ((r=rankedCache.takeURL(false,1)) != null)   result.add(r);\n  return result;\n}\n"}
{"INPUT": "public InputMethodSubtype(int nameId,int iconId,String locale,String mode,String extraValue,boolean isAuxiliary){\n// bug_start\n  this(nameId,iconId,locale,mode,extraValue,false,false);\n// bug_end\n}\n"}
{"INPUT": "public static void main(String[] args) throws Exception {\n  LinkedHashSet<File> filesToProcess=new LinkedHashSet<File>();\n  boolean getFilesFromStdin=false;\n  String outputFilename=\"classes.dex\";\n  String dumpFilename=null;\n  int dumpWidth=120;\n  int i;\n  for (i=0; i < args.length; i++) {\n    String arg=args[i];\n    if (arg.equals(\"--\") || !arg.startsWith(\"--\")) {\n      break;\n    }\n    if (arg.startsWith(\"--output=\")) {\n      outputFilename=arg.substring(arg.indexOf('=') + 1);\n    }\n else     if (arg.startsWith(\"--dump-to=\")) {\n      dumpFilename=arg.substring(arg.indexOf(\"=\") + 1);\n    }\n else     if (arg.startsWith(\"--dump-width=\")) {\n      dumpWidth=Integer.parseInt(arg.substring(arg.indexOf(\"=\") + 1));\n    }\n else {\n      System.err.println(\"unknown option: \" + arg);\n      throw new UsageException();\n    }\n  }\n  for (i=i; i < args.length; i++) {\n    String arg=args[i];\n    if (arg.compareTo(\"-\") == 0) {\n      getFilesFromStdin=true;\n    }\n else {\n      File argFile=new File(arg);\n      if (!argFile.exists()) {\n        throw new RuntimeException(\"Cannot find file or directory \\\"\" + arg + \"\\\"\");\n      }\n      if (argFile.isDirectory()) {\n        getSmaliFilesInDir(argFile,filesToProcess);\n      }\n else       if (argFile.isFile()) {\n        filesToProcess.add(argFile);\n      }\n    }\n  }\n  if (getFilesFromStdin) {\n    InputStreamReader isr=new InputStreamReader(System.in);\n    BufferedReader in=new BufferedReader(isr);\n    String line=in.readLine();\n    while (line != null) {\n      File file=new File(line);\n      if (!file.exists()) {\n        throw new RuntimeException(\"Cannot find file or directory \\\"\" + line + \"\\\"\");\n      }\n      if (file.isDirectory()) {\n        getSmaliFilesInDir(file,filesToProcess);\n      }\n else {\n        filesToProcess.add(file);\n      }\n      line=in.readLine();\n    }\n  }\n  DexFile dexFile=DexFile.makeBlankDexFile();\n  boolean errors=false;\n  for (  File file : filesToProcess) {\n    if (!assembleSmaliFile(file,dexFile)) {\n      errors=true;\n    }\n  }\n  if (errors) {\n    System.exit(1);\n  }\n  dexFile.place();\n  try {\n    ByteArrayAnnotatedOutput out=new ByteArrayAnnotatedOutput();\n    if (dumpFilename != null) {\n      out.enableAnnotations(dumpWidth,true);\n    }\n    dexFile.writeTo(out);\n    byte[] bytes=out.toByteArray();\n    DexFile.calcSignature(bytes);\n    DexFile.calcChecksum(bytes);\n    if (dumpFilename != null) {\n      out.finishAnnotating();\n// bug_start\n      FileWriter fileWriter=new FileWriter(\"classes.dump\");\n// bug_end\n      out.writeAnnotationsTo(fileWriter);\n      fileWriter.close();\n    }\n    FileOutputStream fileOutputStream=new FileOutputStream(outputFilename);\n    fileOutputStream.write(bytes);\n    fileOutputStream.close();\n  }\n catch (  Exception ex) {\n    System.out.println(ex.toString());\n    System.exit(1);\n  }\n}\n"}
{"INPUT": "@Override public boolean readFrom(ByteBuffer buf,MessageReader reader){\n  reader.setBuffer(buf);\n  if (!reader.beforeMessageRead())   return false;\n  if (!super.readFrom(buf,reader))   return false;\nswitch (reader.state()) {\ncase 3:\n    conflictExpireTimes=reader.readMessage(\"conflictExpireTimes\");\n  if (!reader.isLastRead())   return false;\nreader.incrementState();\ncase 4:\nconflictVers=reader.readCollection(\"conflictVers\",MessageCollectionItemType.MSG);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 5:\nentryProcessorsBytes=reader.readCollection(\"entryProcessorsBytes\",MessageCollectionItemType.BYTE_ARR);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 6:\nforceTransformBackups=reader.readBoolean(\"forceTransformBackups\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 7:\nfutVer=reader.readMessage(\"futVer\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 8:\ninvokeArgsBytes=reader.readObjectArray(\"invokeArgsBytes\",MessageCollectionItemType.BYTE_ARR,byte[].class);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 9:\nkeys=reader.readCollection(\"keys\",MessageCollectionItemType.MSG);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 10:\nnearEntryProcessorsBytes=reader.readCollection(\"nearEntryProcessorsBytes\",MessageCollectionItemType.BYTE_ARR);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 11:\nnearExpireTimes=reader.readMessage(\"nearExpireTimes\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 12:\nnearKeys=reader.readCollection(\"nearKeys\",MessageCollectionItemType.MSG);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 13:\nnearTtls=reader.readMessage(\"nearTtls\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 14:\nnearVals=reader.readCollection(\"nearVals\",MessageCollectionItemType.MSG);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 15:\nnodeId=reader.readUuid(\"nodeId\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 16:\nsubjId=reader.readUuid(\"subjId\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 17:\nbyte syncModeOrd;\nsyncModeOrd=reader.readByte(\"syncMode\");\nif (!reader.isLastRead()) return false;\nsyncMode=CacheWriteSynchronizationMode.fromOrdinal(syncModeOrd);\nreader.incrementState();\ncase 18:\ntaskNameHash=reader.readInt(\"taskNameHash\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 19:\ntopVer=reader.readMessage(\"topVer\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 20:\nttls=reader.readMessage(\"ttls\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 21:\nvals=reader.readCollection(\"vals\",MessageCollectionItemType.MSG);\nif (!reader.isLastRead()) return false;\nreader.incrementState();\ncase 22:\nwriteVer=reader.readMessage(\"writeVer\");\nif (!reader.isLastRead()) return false;\nreader.incrementState();\n}\n// bug_start\nreturn true;\n// bug_end\n}\n"}
{"INPUT": "@Override public StringEncryptor get(){\n  PooledPBEStringEncryptor encryptor=new PooledPBEStringEncryptor();\n  SimpleStringPBEConfig config=new SimpleStringPBEConfig();\n  config.setPassword(getRequiredProperty(environment,\"jasypt.encryptor.password\"));\n  config.setAlgorithm(getProperty(environment,\"jasypt.encryptor.algorithm\",\"PBEWithMD5AndDES\"));\n  config.setKeyObtentionIterations(getProperty(environment,\"jasypt.encryptor.keyObtentionIterations\",\"1000\"));\n  config.setPoolSize(getProperty(environment,\"jasypt.encryptor.poolSize\",\"1\"));\n// bug_start\n  config.setProviderName(getProperty(environment,\"jasypt.encryptor.providerName\",\"SunJCE\"));\n// bug_end\n  config.setSaltGeneratorClassName(getProperty(environment,\"jasypt.encryptor.saltGeneratorClassname\",\"org.jasypt.salt.RandomSaltGenerator\"));\n  config.setStringOutputType(getProperty(environment,\"jasypt.encryptor.stringOutputType\",\"base64\"));\n  encryptor.setConfig(config);\n  return encryptor;\n}\n"}
{"INPUT": "public void startAutoSaveTimer(){\n  if (t != null) {\n    t.cancel();\n  }\n  TimerTask task=new AutoSaveTask();\n  t=new Timer();\n// bug_start\n  long interval=60000 * Globals.prefs.getInt(JabRefPreferences.AUTO_SAVE_INTERVAL);\n// bug_end\n  t.scheduleAtFixedRate(task,interval,interval);\n}\n"}
{"INPUT": "// bug_start\n@Bean(BEAN_NAME_SEATA_DATA_SOURCE_BEAN_POST_PROCESSOR) @ConditionalOnProperty(prefix=StarterConstants.SEATA_PREFIX,name=\"enableAutoDataSourceProxy\",havingValue=\"true\",matchIfMissing=true) @ConditionalOnMissingBean(SeataDataSourceBeanPostProcessor.class) public SeataDataSourceBeanPostProcessor seataDataSourceBeanPostProcessor(SeataProperties seataProperties){\n// bug_end\n  return new SeataDataSourceBeanPostProcessor(seataProperties.isUseJdkProxy());\n}\n"}
{"INPUT": "private void drawPreviewItem(Canvas canvas,PreviewItemDrawingParams params){\n// bug_start\n  canvas.save(Canvas.MATRIX_SAVE_FLAG);\n// bug_end\n  canvas.translate(params.transX,params.transY);\n  canvas.scale(params.scale,params.scale);\n  Drawable d=params.drawable;\n  if (d != null) {\n    Rect bounds=d.getBounds();\n    canvas.save();\n    canvas.translate(-bounds.left,-bounds.top);\n    canvas.scale(mIntrinsicIconSize / bounds.width(),mIntrinsicIconSize / bounds.height());\n    d.draw(canvas);\n    canvas.restore();\n  }\n  canvas.restore();\n}\n"}
{"INPUT": "private void clearJobFinishedTime(String jobId,ActionListener<AcknowledgedResponse> listener){\n  JobUpdate update=new JobUpdate.Builder(jobId).setClearFinishTime(true).build();\n// bug_start\n  jobConfigProvider.updateJob(jobId,update,null,clusterService.state().nodes().getMinNodeVersion(),ActionListener.wrap(null,null));\n// bug_end\n}\n"}
{"INPUT": "@Inject public RestDeleteWatchAction(Settings settings,RestController controller,Client client){\n// bug_start\n  super(settings,controller,client);\n// bug_end\n  controller.registerHandler(DELETE,URI_BASE + \"/watch/{id}\",this);\n}\n"}
{"INPUT": "static StreamOperator newOperator(FlinkJoinType type,boolean leftIsSmaller){\n// bug_start\n  return new SortMergeJoinOperator(32 * 32 * 1024,1024 * 1024,type,leftIsSmaller,new GeneratedJoinCondition(\"\",\"\",new Object[0]){\n// bug_end\n    @Override public JoinCondition newInstance(    ClassLoader classLoader){\n      return new Int2HashJoinOperatorTest.TrueCondition();\n    }\n  }\n,new GeneratedProjection(\"\",\"\",new Object[0]){\n    @Override public Projection newInstance(    ClassLoader classLoader){\n      return new MyProjection();\n    }\n  }\n,new GeneratedProjection(\"\",\"\",new Object[0]){\n    @Override public Projection newInstance(    ClassLoader classLoader){\n      return new MyProjection();\n    }\n  }\n,new GeneratedNormalizedKeyComputer(\"\",\"\"){\n    @Override public NormalizedKeyComputer newInstance(    ClassLoader classLoader){\n      return new IntNormalizedKeyComputer();\n    }\n  }\n,new GeneratedRecordComparator(\"\",\"\",new Object[0]){\n    @Override public RecordComparator newInstance(    ClassLoader classLoader){\n      return new IntRecordComparator();\n    }\n  }\n,new GeneratedNormalizedKeyComputer(\"\",\"\"){\n    @Override public NormalizedKeyComputer newInstance(    ClassLoader classLoader){\n      return new IntNormalizedKeyComputer();\n    }\n  }\n,new GeneratedRecordComparator(\"\",\"\",new Object[0]){\n    @Override public RecordComparator newInstance(    ClassLoader classLoader){\n      return new IntRecordComparator();\n    }\n  }\n,new GeneratedRecordComparator(\"\",\"\",new Object[0]){\n    @Override public RecordComparator newInstance(    ClassLoader classLoader){\n      return new IntRecordComparator();\n    }\n  }\n,new boolean[]{true});\n}\n"}
{"INPUT": "private static void evaluateRuleActivations(StatefulKnowledgeSessionImpl wm){\n  boolean dirty=true;\n  while (dirty) {\n    for (    Activation activation : ((InternalAgenda)wm.getAgenda()).getActivations()) {\n      if (activation.isRuleAgendaItem()) {\n// bug_start\n        ((RuleAgendaItem)activation).getRuleExecutor().reEvaluateNetwork(wm,null,false);\n// bug_end\n        ((RuleAgendaItem)activation).getRuleExecutor().removeRuleAgendaItemWhenEmpty(wm);\n      }\n    }\n    dirty=false;\n    if (wm.getKnowledgeBase().getConfiguration().isPhreakEnabled()) {\n      for (      Activation activation : ((InternalAgenda)wm.getAgenda()).getActivations()) {\n        if (activation.isRuleAgendaItem() && ((RuleAgendaItem)activation).getRuleExecutor().isDirty()) {\n          dirty=true;\n          break;\n        }\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Test public void noPropertiesAnywhere() throws Exception {\n  try (Closeable p=new SystemPropertyRule(PropertyKey.TEST_MODE.toString(),\"false\").toResource()){\n// bug_start\n    Configuration.set(PropertyKey.SITE_CONF_DIR,\"\");\n// bug_end\n    Configuration.reset();\n    assertEquals(\"0.0.0.0\",Configuration.get(PropertyKey.PROXY_WEB_BIND_HOST));\n  }\n }\n"}
{"INPUT": "@Override @Before public void setUp() throws Exception {\n  ssc=ServerSocketChannel.open();\n  InetSocketAddress addr=new InetSocketAddress(InetAddress.getLoopbackAddress(),21212);\n  ssc.bind(addr);\n  rawChannel=SocketChannel.open();\n  rawChannel.configureBlocking(false);\n  rawChannel.connect(addr);\n  networkChannel=ssc.accept();\n  rawChannel.finishConnect();\n  rawChannel.configureBlocking(true);\n// bug_start\n  pn=new PicoNetwork(networkChannel,true);\n// bug_end\n  handler=new MockInputHandler();\n  pn.start(handler,new HashSet<Long>());\n}\n"}
{"INPUT": "@Before public void setup() throws ExecutionException, InterruptedException {\n  assumeTrue(CameraUtil.deviceHasCamera());\n// bug_start\n  mDefaultConfig=VideoCapture.DEFAULT_CONFIG.getConfig(null);\n// bug_end\n  CameraXConfig cameraXConfig=CameraXConfig.Builder.fromConfig(FakeAppConfig.create()).build();\n  Context context=ApplicationProvider.getApplicationContext();\n  CameraX.initialize(context,cameraXConfig).get();\n  mCameraX=CameraX.getOrCreateInstance(context).get();\n  mCameraUseCaseAdapter=new CameraUseCaseAdapter(mMockCameraInternal,new LinkedHashSet<>(Collections.singleton(mMockCameraInternal)),mCameraX.getCameraDeviceSurfaceManager());\n}\n"}
{"INPUT": "public static Field make() throws IOException, ClassNotFoundException, NoSuchFieldException {\n  ClassReader classReader=new ClassReader(InconsistentGenerics.class.getName());\n// bug_start\n  ClassWriter classWriter=new ClassWriter(classReader,ClassWriter.COMPUTE_MAXS);\n// bug_end\n  classReader.accept(new GenericDisintegrator(classWriter),0);\n  return new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,Collections.singletonMap(InconsistentGenerics.class.getName(),classWriter.toByteArray()),ByteArrayClassLoader.PersistenceHandler.MANIFEST).loadClass(InconsistentGenerics.class.getName()).getDeclaredField(FOO);\n}\n"}
{"INPUT": "public boolean verifyServerHostKey(String hostname,int port,String serverHostKeyAlgorithm,byte[] serverHostKey) throws IOException {\n  KnownHosts hosts=manager.hostdb.getKnownHosts();\n  Boolean result;\n  String matchName=String.format(Locale.US,\"%s:%d\",hostname,port);\n  String fingerprint=KnownHosts.createHexFingerprint(serverHostKeyAlgorithm,serverHostKey);\n  String algorithmName;\n  if (\"ssh-rsa\".equals(serverHostKeyAlgorithm))   algorithmName=\"RSA\";\n else   if (\"ssh-dss\".equals(serverHostKeyAlgorithm))   algorithmName=\"DSA\";\n else   if (serverHostKeyAlgorithm.startsWith(\"ecdsa-\"))   algorithmName=\"EC\";\n else   algorithmName=serverHostKeyAlgorithm;\nswitch (hosts.verifyHostkey(matchName,serverHostKeyAlgorithm,serverHostKey)) {\ncase KnownHosts.HOSTKEY_IS_OK:\n    bridge.outputLine(manager.res.getString(R.string.terminal_sucess,algorithmName,fingerprint));\n  return true;\ncase KnownHosts.HOSTKEY_IS_NEW:\nbridge.outputLine(manager.res.getString(R.string.host_authenticity_warning,hostname));\nbridge.outputLine(manager.res.getString(R.string.host_fingerprint,algorithmName,fingerprint));\nresult=bridge.promptHelper.requestBooleanPrompt(null,manager.res.getString(R.string.prompt_continue_connecting));\nif (result == null) return false;\nif (result.booleanValue()) {\nmanager.hostdb.saveKnownHost(hostname,port,serverHostKeyAlgorithm,serverHostKey);\n}\nreturn result.booleanValue();\ncase KnownHosts.HOSTKEY_HAS_CHANGED:\nString header=String.format(\"@   %s   @\",manager.res.getString(R.string.host_verification_failure_warning_header));\nchar[] atsigns=new char[header.length()];\nArrays.fill(atsigns,'@');\nString border=new String(atsigns);\nbridge.outputLine(border);\nbridge.outputLine(header);\nbridge.outputLine(border);\nbridge.outputLine(manager.res.getString(R.string.host_verification_failure_warning));\nbridge.outputLine(String.format(manager.res.getString(R.string.host_fingerprint),algorithmName,fingerprint));\nresult=bridge.promptHelper.requestBooleanPrompt(null,manager.res.getString(R.string.prompt_continue_connecting));\nif (result != null && result.booleanValue()) {\nmanager.hostdb.saveKnownHost(hostname,port,serverHostKeyAlgorithm,serverHostKey);\nreturn true;\n}\n else {\nreturn false;\n}\ndefault :\n// bug_start\nbridge.outputLine(manager.res.getString(R.string.terminal_failed,algorithmName,fingerprint));\n// bug_end\nreturn false;\n}\n}\n"}
{"INPUT": "private ParallelIndexSupervisorTask newTask(@Nullable TimestampSpec timestampSpec,@Nullable DimensionsSpec dimensionsSpec,@Nullable InputFormat inputFormat,@Nullable ParseSpec parseSpec,Interval interval,File inputDir,String filter,PartitionsSpec partitionsSpec,int maxNumConcurrentSubTasks,boolean appendToExisting){\n  GranularitySpec granularitySpec=new UniformGranularitySpec(Granularities.DAY,Granularities.MINUTE,interval == null ? null : Collections.singletonList(interval));\n  ParallelIndexTuningConfig tuningConfig=newTuningConfig(partitionsSpec,maxNumConcurrentSubTasks,!appendToExisting);\n  final ParallelIndexIngestionSpec ingestionSpec;\n  if (useInputFormatApi) {\n    Preconditions.checkArgument(parseSpec == null);\n    ParallelIndexIOConfig ioConfig=new ParallelIndexIOConfig(null,new LocalInputSource(inputDir,filter),inputFormat,appendToExisting);\n    ingestionSpec=new ParallelIndexIngestionSpec(new DataSchema(DATASOURCE,timestampSpec,dimensionsSpec,new AggregatorFactory[]{new LongSumAggregatorFactory(\"val\",\"val\")},granularitySpec,null),ioConfig,tuningConfig);\n  }\n else {\n    Preconditions.checkArgument(inputFormat == null);\n    ParallelIndexIOConfig ioConfig=new ParallelIndexIOConfig(new LocalFirehoseFactory(inputDir,filter,null),appendToExisting);\n    ingestionSpec=new ParallelIndexIngestionSpec(new DataSchema(\"dataSource\",getObjectMapper().convertValue(new StringInputRowParser(parseSpec,null),Map.class),new AggregatorFactory[]{new LongSumAggregatorFactory(\"val\",\"val\")},granularitySpec,null,getObjectMapper()),ioConfig,tuningConfig);\n  }\n// bug_start\n  return new ParallelIndexSupervisorTask(null,null,null,ingestionSpec,Collections.emptyMap(),null,null,null,null,null);\n// bug_end\n}\n"}
{"INPUT": "private void createDriver(){\n  if (onlyManagableProvider != null || selectedProvider != null) {\n    DataSourceProviderDescriptor provider=selectedProvider;\n    if (provider == null || !provider.isDriversManagable()) {\n      provider=onlyManagableProvider;\n    }\n    DriverEditDialog dialog=new DriverEditDialog(getShell(),provider,selectedCategory);\n    if (dialog.open() == IDialogConstants.OK_ID) {\n// bug_start\n      treeControl.refresh(provider);\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "public LLVMAMD64SyscallRecvmsgNode(){\n// bug_start\n  recvmsg=LLVMAMD64PosixCallNodeGen.create(\"recvmsg\",\"(SINT32,UINT64,SINT32):SINT64\",3);\n// bug_end\n}\n"}
{"INPUT": "protected RedisClusterClient(ClientResources clientResources,Iterable<RedisURI> redisURIs){\n  super(clientResources);\n  assertNotEmpty(redisURIs);\n  assertSameOptions(redisURIs);\n  this.initialUris=Collections.unmodifiableList(LettuceLists.newList(redisURIs));\n// bug_start\n  setDefaultTimeout(getFirstUri().getTimeout(),getFirstUri().getUnit());\n// bug_end\n  setOptions(ClusterClientOptions.builder().build());\n}\n"}
{"INPUT": "@Override protected Field parseCreateField(ParseContext context) throws IOException {\n  byte[] value;\n  if (context.parser().currentToken() == XContentParser.Token.VALUE_NULL) {\n    return null;\n  }\n else {\n    value=context.parser().binaryValue();\n  }\n  if (value == null) {\n    return null;\n  }\n// bug_start\n  return new Field(names.indexName(),value,Field.Store.YES);\n// bug_end\n}\n"}
{"INPUT": "@Override public Map<? extends GridComputeJob,GridNode> map(List<GridNode> subgrid,String arg){\n  String[] words=arg.split(\" \");\n// bug_start\n  Map<GridComputeJob,GridNode> map=new HashMap<>(words.length);\n// bug_end\n  Iterator<GridNode> it=subgrid.iterator();\n  for (  final String word : arg.split(\" \")) {\n    if (!it.hasNext())     it=subgrid.iterator();\n    GridNode node=it.next();\n    map.put(new GridComputeJobAdapter(){\n      @Nullable @Override public Object execute(){\n        System.out.println();\n        System.out.println(\">>> Printing '\" + word + \"' on this node from grid job.\");\n        return word.length();\n      }\n    }\n,node);\n  }\n  return map;\n}\n"}
{"INPUT": "@Override public FilePageStore createPageStore(byte type,File file) throws IgniteCheckedException {\n  if (!file.exists())   return createPageStore(type,file,latestVersion());\n// bug_start\n  try (FileIO fileIO=fileIOFactory.create(file,\"r\")){\n// bug_end\n    int minHdr=FilePageStore.HEADER_SIZE;\n    if (fileIO.size() < minHdr)     return createPageStore(type,file,latestVersion());\n    ByteBuffer hdr=ByteBuffer.allocate(minHdr).order(ByteOrder.LITTLE_ENDIAN);\n    while (hdr.remaining() > 0)     fileIO.read(hdr);\n    hdr.rewind();\n    hdr.getLong();\n    int ver=hdr.getInt();\n    return createPageStore(type,file,ver);\n  }\n catch (  IOException e) {\n    throw new IgniteCheckedException(\"Error while creating file page store [file=\" + file + \"]:\",e);\n  }\n}\n"}
{"INPUT": "public ZenModeConditions(ZenModeHelper helper,ConditionProviders conditionProviders){\n  mHelper=helper;\n  mConditionProviders=conditionProviders;\n  if (mConditionProviders.isSystemProviderEnabled(ZenModeConfig.COUNTDOWN_PATH)) {\n    mConditionProviders.addSystemProvider(new CountdownConditionProvider());\n  }\n  if (mConditionProviders.isSystemProviderEnabled(ZenModeConfig.SCHEDULE_PATH)) {\n    mConditionProviders.addSystemProvider(new ScheduleConditionProvider());\n  }\n  if (mConditionProviders.isSystemProviderEnabled(ZenModeConfig.EVENT_PATH)) {\n// bug_start\n    mConditionProviders.addSystemProvider(new EventConditionProvider(helper.getLooper()));\n// bug_end\n  }\n  mConditionProviders.setCallback(this);\n}\n"}
{"INPUT": "@Before public void setUp() throws Exception {\n  preferences=Preferences.userRoot().node(\"ipscan-test\");\n  preferences.clear();\n  ipFetcher=new IPFetcher();\n  pingFetcher=new PingFetcher(null,null);\n// bug_start\n  hostnameFetcher=new HostnameFetcher(null);\n// bug_end\n  commentFetcher=new CommentFetcher(null);\n  portsFetcher=new PortsFetcher(null);\n  fetcherRegistry=new FetcherRegistry(new Fetcher[]{ipFetcher,pingFetcher,hostnameFetcher,commentFetcher,portsFetcher},preferences,null);\n}\n"}
{"INPUT": "@Override public Set<Class<? extends CoreAnnotation>> requires(){\n// bug_start\n  Set<Class<? extends CoreAnnotation>> requirements=new HashSet<>(Arrays.asList(CoreAnnotations.TextAnnotation.class,CoreAnnotations.TokensAnnotation.class,CoreAnnotations.IndexAnnotation.class,CoreAnnotations.SentencesAnnotation.class,CoreAnnotations.SentenceIndexAnnotation.class,CoreAnnotations.PartOfSpeechAnnotation.class,CoreAnnotations.LemmaAnnotation.class,NaturalLogicAnnotations.PolarityAnnotation.class,SemanticGraphCoreAnnotations.EnhancedPlusPlusDependenciesAnnotation.class,CoreAnnotations.OriginalTextAnnotation.class));\n// bug_end\n  if (resolveCoref) {\n    requirements.add(edu.stanford.nlp.coref.CorefCoreAnnotations.CorefChainAnnotation.class);\n  }\n  return Collections.unmodifiableSet(requirements);\n}\n"}
{"INPUT": "@Override public void setNextReader(AtomicReaderContext context) throws IOException {\n  if (current != null) {\n    missing+=current.missing;\n    total+=current.total;\n    if (current.values.ordinals().getMaxOrd() > Ordinals.MIN_ORDINAL) {\n      aggregators.add(current);\n    }\n else {\n      Releasables.close(current);\n    }\n  }\n// bug_start\n  values=indexFieldData.load(context).getBytesValues(false);\n// bug_end\n  current=new ReaderAggregator(values,ordinalsCacheAbove,cacheRecycler);\n  ordinals=values.ordinals();\n}\n"}
{"INPUT": "@BeforeAll public static void createClientAndEventLoopGroup(){\n  clientEventLoopGroup=new NioEventLoopGroup(3,new Scheduler.SchedulerThreadFactory(AbstractMockingIntegrationTestBase.class.getSimpleName() + \"-eventLoop\"));\n// bug_start\n  httpClient=new NettyHttpClient(new MockServerLogger(),clientEventLoopGroup,null,false,null);\n// bug_end\n}\n"}
{"INPUT": "public void testUnassignedShardAndEmptyNodesInRoutingTable() throws Exception {\n  internalCluster().startNode();\n  createIndex(\"a\");\n  ensureSearchable(\"a\");\n  ClusterState current=clusterService().state();\n  GatewayAllocator allocator=internalCluster().getInstance(GatewayAllocator.class);\n  AllocationDeciders allocationDeciders=new AllocationDeciders(Settings.EMPTY,Collections.emptyList());\n  RoutingNodes routingNodes=new RoutingNodes(ClusterState.builder(current).routingTable(RoutingTable.builder(current.routingTable()).remove(\"a\").addAsRecovery(current.metaData().index(\"a\")).build()).nodes(DiscoveryNodes.EMPTY_NODES).build(),false);\n// bug_start\n  RoutingAllocation routingAllocation=new RoutingAllocation(allocationDeciders,routingNodes,current,ClusterInfo.EMPTY,System.nanoTime(),false);\n// bug_end\n  allocator.allocateUnassigned(routingAllocation);\n}\n"}
{"INPUT": "public void testSliceEquals(){\n  int length=randomIntBetween(100,PAGE_SIZE * randomIntBetween(2,5));\n  ByteArray ba1=bigarrays.newByteArray(length,false);\n// bug_start\n  BytesReference pbr=new PagedBytesReference(bigarrays,ba1,length);\n// bug_end\n  int sliceFrom=randomIntBetween(0,pbr.length());\n  int sliceLength=randomIntBetween(0,pbr.length() - sliceFrom);\n  BytesReference slice1=pbr.slice(sliceFrom,sliceLength);\n  BytesReference slice2=pbr.slice(sliceFrom,sliceLength);\n  assertArrayEquals(BytesReference.toBytes(slice1),BytesReference.toBytes(slice2));\n  if (sliceLength > 0) {\n    BytesReference slice3=pbr.slice(sliceFrom,sliceLength / 2);\n    assertFalse(Arrays.equals(BytesReference.toBytes(slice1),BytesReference.toBytes(slice3)));\n  }\n}\n"}
{"INPUT": "@Test public void linkerFlagsLocationMacro(){\n  assumeThat(Platform.detect(),is(Platform.MACOS));\n// bug_start\n  BuildTarget sandboxTarget=BuildTargetFactory.newInstance(\"//:rule\").withFlavors(CxxDescriptionEnhancer.SANDBOX_TREE_FLAVOR,DefaultCxxPlatforms.FLAVOR);\n// bug_end\n  ActionGraphBuilder graphBuilder=new TestActionGraphBuilder(TargetGraphFactory.newInstance(new AppleLibraryBuilder(sandboxTarget).build()));\n  SourcePathResolver pathResolver=DefaultSourcePathResolver.from(new SourcePathRuleFinder(graphBuilder));\n  BuildTarget target=BuildTargetFactory.newInstance(\"//:rule\").withFlavors(DefaultCxxPlatforms.FLAVOR,CxxDescriptionEnhancer.SHARED_FLAVOR);\n  Genrule dep=GenruleBuilder.newGenruleBuilder(BuildTargetFactory.newInstance(\"//:dep\")).setOut(\"out\").build(graphBuilder);\n  AppleLibraryBuilder builder=new AppleLibraryBuilder(target).setLinkerFlags(ImmutableList.of(StringWithMacrosUtils.format(\"--linker-script=%s\",LocationMacro.of(dep.getBuildTarget())))).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(FakeSourcePath.of(\"foo.c\"))));\n  assertThat(builder.build().getExtraDeps(),Matchers.hasItem(dep.getBuildTarget()));\n  BuildRule binary=builder.build(graphBuilder);\n  assertThat(binary,Matchers.instanceOf(CxxLink.class));\n  assertThat(Arg.stringify(((CxxLink)binary).getArgs(),pathResolver),Matchers.hasItem(String.format(\"--linker-script=%s\",dep.getAbsoluteOutputFilePath())));\n  assertThat(binary.getBuildDeps(),Matchers.hasItem(dep));\n}\n"}
{"INPUT": "@BeforeEach public void setUp() throws Exception {\n// bug_start\n  table=Table.read().csv(CsvReadOptions.builder(\"../data/bush.csv\").minimizeColumnSizes(true));\n// bug_end\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") @Override public CompatibilityResult<T> ensureCompatibility(TypeSerializerConfigSnapshot configSnapshot){\n  if (configSnapshot instanceof ValueSerializerConfigSnapshot) {\n    final ValueSerializerConfigSnapshot<T> config=(ValueSerializerConfigSnapshot<T>)configSnapshot;\n    if (type.equals(config.getTypeClass())) {\n      return CompatibilityResult.compatible();\n    }\n  }\n// bug_start\n  return CompatibilityResult.requiresMigration(null);\n// bug_end\n}\n"}
{"INPUT": "PathHierarchyTokenizerFactory(IndexSettings indexSettings,Environment environment,String name,Settings settings){\n// bug_start\n  super(indexSettings,name,settings);\n// bug_end\n  bufferSize=settings.getAsInt(\"buffer_size\",1024);\n  String delimiter=settings.get(\"delimiter\");\n  if (delimiter == null) {\n    this.delimiter=PathHierarchyTokenizer.DEFAULT_DELIMITER;\n  }\n else   if (delimiter.length() != 1) {\n    throw new IllegalArgumentException(\"delimiter must be a one char value\");\n  }\n else {\n    this.delimiter=delimiter.charAt(0);\n  }\n  String replacement=settings.get(\"replacement\");\n  if (replacement == null) {\n    this.replacement=this.delimiter;\n  }\n else   if (replacement.length() != 1) {\n    throw new IllegalArgumentException(\"replacement must be a one char value\");\n  }\n else {\n    this.replacement=replacement.charAt(0);\n  }\n  this.skip=settings.getAsInt(\"skip\",PathHierarchyTokenizer.DEFAULT_SKIP);\n  this.reverse=settings.getAsBoolean(\"reverse\",false);\n}\n"}
{"INPUT": "private FacebookEndpointConfiguration copyComponentProperties() throws Exception {\n  Map<String,Object> componentProperties=new HashMap<String,Object>();\n  IntrospectionSupport.getProperties(configuration,componentProperties,null,false);\n  FacebookEndpointConfiguration config=new FacebookEndpointConfiguration();\n// bug_start\n  IntrospectionSupport.setProperties(config,componentProperties,null);\n// bug_end\n  return config;\n}\n"}
{"INPUT": "@Override public void setUp() throws Exception {\n  server=ServerBuilder.forPort(0).addService(new GithubApiService()).directExecutor().build();\n  server.start();\n// bug_start\n  channel=ManagedChannelBuilder.forAddress(\"127.0.0.1\",port()).directExecutor().usePlaintext(true).build();\n// bug_end\n  githubApiClient=GithubServiceGrpc.newBlockingStub(channel);\n  githubApiFutureClient=GithubServiceGrpc.newFutureStub(channel);\n}\n"}
{"INPUT": "protected QueryShardContext createQueryShardContext(MapperService mapperService){\n  QueryShardContext queryShardContext=mock(QueryShardContext.class);\n  when(queryShardContext.getFieldType(anyString())).thenAnswer(null);\n  when(queryShardContext.isFieldMapped(anyString())).thenAnswer(null);\n  when(queryShardContext.getIndexAnalyzers()).thenReturn(mapperService.getIndexAnalyzers());\n  when(queryShardContext.getIndexSettings()).thenReturn(mapperService.getIndexSettings());\n  when(queryShardContext.getObjectMapper(anyString())).thenAnswer(null);\n  when(queryShardContext.simpleMatchToIndexNames(anyObject())).thenAnswer(null);\n  when(queryShardContext.allowExpensiveQueries()).thenReturn(true);\n// bug_start\n  when(queryShardContext.lookup()).thenReturn(new SearchLookup(null,null,null));\n// bug_end\n  return queryShardContext;\n}\n"}
{"INPUT": "public StatefulSet generateStatefulSet(boolean isOpenShift){\n// bug_start\n  return createStatefulSet(getVolumes(isOpenShift),getVolumeClaims(),getVolumeMounts(),getMergedAffinity(),getInitContainers(),getContainers(),isOpenShift);\n// bug_end\n}\n"}
{"INPUT": "public void setDrawerSubList(){\n  ArrayList<String> copy=new ArrayList<>(usedArray);\n  e=((EditText)headerMain.findViewById(R.id.sort));\n  headerMain.findViewById(R.id.close).setOnClickListener(new View.OnClickListener(){\n    @Override public void onClick(    View v){\n      e.setText(\"\");\n    }\n  }\n);\n// bug_start\n  sideArrayAdapter=new SideArrayAdapter(this,copy,copy,UserSubscriptions.getHistory(),UserSubscriptions.getAllSubreddits(this));\n// bug_end\n  drawerSubList.setAdapter(sideArrayAdapter);\n  e.setOnFocusChangeListener(new View.OnFocusChangeListener(){\n    @Override public void onFocusChange(    View v,    boolean hasFocus){\n      drawerSubList.smoothScrollToPositionFromTop(1,e.getHeight());\n    }\n  }\n);\n  e.setOnEditorActionListener(new TextView.OnEditorActionListener(){\n    @Override public boolean onEditorAction(    TextView arg0,    int arg1,    KeyEvent arg2){\n      if (arg1 == EditorInfo.IME_ACTION_SEARCH) {\n        if (sideArrayAdapter.fitems == null || sideArrayAdapter.openInSubView || !usedArray.contains(e.getText().toString().toLowerCase())) {\n          Intent inte=new Intent(MainActivity.this,SubredditView.class);\n          inte.putExtra(SubredditView.EXTRA_SUBREDDIT,e.getText().toString());\n          MainActivity.this.startActivity(inte);\n        }\n else {\n          if (usedArray.contains(e.getText().toString().toLowerCase())) {\n            pager.setCurrentItem(usedArray.indexOf(e.getText().toString().toLowerCase()));\n          }\n else {\n            pager.setCurrentItem(usedArray.indexOf(sideArrayAdapter.fitems.get(0)));\n          }\n        }\n        View view=MainActivity.this.getCurrentFocus();\n        if (view != null) {\n          InputMethodManager imm=(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);\n          imm.hideSoftInputFromWindow(view.getWindowToken(),0);\n        }\n        drawerLayout.closeDrawers();\n        e.setText(\"\");\n      }\n      return false;\n    }\n  }\n);\n  final View close=findViewById(R.id.close);\n  close.setVisibility(View.GONE);\n  e.addTextChangedListener(new TextWatcher(){\n    @Override public void beforeTextChanged(    CharSequence charSequence,    int i,    int i2,    int i3){\n    }\n    @Override public void onTextChanged(    CharSequence charSequence,    int i,    int i2,    int i3){\n    }\n    @Override public void afterTextChanged(    Editable editable){\n      String result=e.getText().toString().replaceAll(\" \",\"\");\n      if (result.isEmpty()) {\n        close.setVisibility(View.GONE);\n      }\n else {\n        close.setVisibility(View.VISIBLE);\n      }\n      sideArrayAdapter.getFilter().filter(result);\n    }\n  }\n);\n}\n"}
{"INPUT": "@BeforeMethod public void setup() throws Exception {\n  temporary=createTempDir();\n  Map<String,String> properties=ImmutableMap.<String,String>builder().put(\"backup.http.uri\",\"http://localhost:8080\").build();\n// bug_start\n  Bootstrap app=new Bootstrap(new TestingNodeModule(),new TestingHttpServerModule(),new JsonModule(),new JaxrsModule(true),null,null,override(new HttpBackupModule()).with(new TestingModule()));\n// bug_end\n  Injector injector=app.strictConfig().setRequiredConfigurationProperties(properties).doNotInitializeLogging().quiet().initialize();\n  lifeCycleManager=injector.getInstance(LifeCycleManager.class);\n  store=injector.getInstance(BackupStore.class);\n}\n"}
{"INPUT": "@Override public AutoCommandResult query(AutoCommandParam autoCommandParam){\n  String key=autoCommandParam.getKey();\n  int count=autoCommandParam.getCount();\n  String type=type(key);\n  long ttl=ttl(key);\n  Object value=null;\nswitch (type) {\ncase TYPE_STRING:\n    value=jedisCluster.get(key);\n  break;\ncase TYPE_HASH:\nvalue=jedisCluster.hgetAll(key);\nbreak;\ncase TYPE_LIST:\nvalue=jedisCluster.lrange(key,0,count);\nbreak;\ncase TYPE_SET:\n// bug_start\nvalue=jedisCluster.srandmember(key,count);\n// bug_end\nbreak;\ncase TYPE_ZSET:\nvalue=jedisCluster.zrangeWithScores(key,0,count);\nbreak;\ndefault :\nbreak;\n}\nreturn new AutoCommandResult(ttl,type,value);\n}\n"}
{"INPUT": "@Test public void testFilterRedundant(){\n// bug_start\n  assertModel(MODEL).query(\"select * from zips where state > 'CA' and state < 'AZ' and state = 'OK'\").runs().queryContains(mongoChecker(\"{\\n\" + \"  \\\"$match\\\": {\\n\" + \"    \\\"state\\\": \\\"OK\\\"\\n\"+ \"  }\\n\"+ \"}\",\"{$project: {CITY: '$city', LONGITUDE: '$loc[0]', LATITUDE: '$loc[1]', POP: '$pop', STATE: '$state', ID: '$_id'}}\"));\n// bug_end\n}\n"}
{"INPUT": "protected LLVMForeignWriteNode[] createForeignWrites(){\n  LLVMForeignWriteNode[] writes=new LLVMForeignWriteNode[values.length];\n  for (int i=0; i < writes.length; i++) {\n// bug_start\n    writes[i]=LLVMForeignWriteNodeGen.create(PointerType.VOID,8);\n// bug_end\n  }\n  return writes;\n}\n"}
{"INPUT": "public static BuckQueryEnvironment from(CommandRunnerParams params,PerBuildState parserState,ListeningExecutorService executor,boolean enableProfiling){\n// bug_start\n  return from(params.getCell(),OwnersReport.builder(params.getCell(),params.getParser(),params.getBuckEventBus(),params.getConsole()),parserState,executor,new TargetPatternEvaluator(params.getCell(),params.getBuckConfig(),params.getParser(),params.getBuckEventBus(),enableProfiling));\n// bug_end\n}\n"}
{"INPUT": "private Renderer createRenderer(){\n  if (format.equals(TEXT_FORMAT)) {\n    return new SimpleRenderer();\n  }\n else   if (format.equals(CSV_FORMAT)) {\n    return new CSVRenderer();\n  }\n// bug_start\n  return new XMLRenderer(encoding);\n// bug_end\n}\n"}
{"INPUT": "private void initializeSocketReader() throws IOException {\n  if (socketReader == null) {\n    final ByteBuffer protocolBuffer=ByteBuffer.allocate(3);\n    int readBytes=socketChannel.read(protocolBuffer);\n    if (readBytes == -1) {\n      throw new EOFException(\"Could not read protocol type!\");\n    }\n    if (readBytes == 0 && connectionManager.isSSLEnabled()) {\n      return;\n    }\n    if (!protocolBuffer.hasRemaining()) {\n      String protocol=bytesToString(protocolBuffer.array());\n      WriteHandler writeHandler=connection.getWriteHandler();\n      if (Protocols.CLUSTER.equals(protocol)) {\n        configureBuffers(connectionManager.socketReceiveBufferSize);\n        connection.setType(ConnectionType.MEMBER);\n        writeHandler.setProtocol(Protocols.CLUSTER);\n        socketReader=new SocketPacketReader(connection);\n      }\n else       if (Protocols.CLIENT_BINARY.equals(protocol)) {\n        configureBuffers(connectionManager.socketClientReceiveBufferSize);\n        writeHandler.setProtocol(Protocols.CLIENT_BINARY);\n        socketReader=new SocketClientDataReader(connection);\n      }\n else       if (Protocols.CLIENT_BINARY_NEW.equals(protocol)) {\n        configureBuffers(connectionManager.socketClientReceiveBufferSize);\n        writeHandler.setProtocol(Protocols.CLIENT_BINARY_NEW);\n// bug_start\n        socketReader=new SocketClientMessageReader(connection,socketChannel);\n// bug_end\n      }\n else {\n        configureBuffers(connectionManager.socketClientReceiveBufferSize);\n        writeHandler.setProtocol(Protocols.TEXT);\n        inputBuffer.put(protocolBuffer.array());\n        socketReader=new SocketTextReader(connection);\n        connection.getConnectionManager().incrementTextConnections();\n      }\n    }\n    if (socketReader == null) {\n      throw new IOException(\"Could not initialize SocketReader!\");\n    }\n  }\n}\n"}
{"INPUT": "@Test public void testTwoDataSources() throws Exception {\n// bug_start\n  EnvironmentTestUtils.addEnvironment(this.context,\"datasource.one.url=jdbc:hsqldb:mem:/one\",\"datasource.one.driverClassName=org.hsqldb.Driver\",\"datasource.two.url=jdbc:hsqldb:mem:/two\",\"datasource.two.driverClassName=org.hsqldb.Driver\");\n// bug_end\n  this.context.register(TwoDataSources.class,DataSourceInitializer.class,PropertyPlaceholderAutoConfiguration.class,DataSourceProperties.class);\n  this.context.refresh();\n  assertThat(this.context.getBeanNamesForType(DataSource.class).length).isEqualTo(2);\n}\n"}
{"INPUT": "private static PageParameters getPageParameters(Project project){\n  String query=null;\n  List<String> queries=new ArrayList<>();\n  if (project.getIssueQuerySettingOfCurrentUser() != null) {\n    for (    NamedQuery namedQuery : project.getIssueQuerySettingOfCurrentUser().getUserQueries())     queries.add(namedQuery.getQuery());\n  }\n  for (  NamedQuery namedQuery : project.getSavedIssueQueries())   queries.add(namedQuery.getQuery());\n  for (  String each : queries) {\n    try {\n// bug_start\n      if (SecurityUtils.getUser() != null || !IssueQuery.parse(project,each,true,true).needsLogin()) {\n// bug_end\n        query=each;\n        break;\n      }\n    }\n catch (    Exception e) {\n    }\n  }\n  return IssueListPage.paramsOf(project,query);\n}\n"}
{"INPUT": "@Test public void testGroupSummaryNotShowingIconWhenPublic(){\n  mGroup.setSensitive(true,true);\n// bug_start\n  mGroup.setHideSensitive(true,false,0,0);\n// bug_end\n  Assert.assertTrue(mGroup.isSummaryWithChildren());\n  Assert.assertFalse(mGroup.isShowingIcon());\n}\n"}
{"INPUT": "public void process(Iterable<QueryExecution> queries){\n  if (!enabled) {\n    return;\n  }\n  long totalBytes=0;\n  for (  QueryExecution query : queries) {\n    long bytes=query.getTotalMemoryReservation();\n// bug_start\n    DataSize sessionMaxQueryMemory=getQueryMaxMemory(query.getSession(),maxQueryMemory);\n// bug_end\n    long queryMemoryLimit=Math.min(maxQueryMemory.toBytes(),sessionMaxQueryMemory.toBytes());\n    totalBytes+=bytes;\n    if (bytes > queryMemoryLimit) {\n      query.fail(new ExceededMemoryLimitException(\"Query\",DataSize.succinctDataSize(queryMemoryLimit,Unit.BYTE)));\n    }\n  }\n  clusterMemoryUsageBytes.set(totalBytes);\n  Map<MemoryPoolId,Integer> countByPool=new HashMap<>();\n  for (  QueryExecution query : queries) {\n    MemoryPoolId id=query.getMemoryPool().getId();\n    countByPool.put(id,countByPool.getOrDefault(id,0) + 1);\n  }\n  updatePools(countByPool);\n  updateNodes(updateAssignments(queries));\n}\n"}
{"INPUT": "@Override public List<Task<? extends Serializable>> handle(Context context) throws SemanticException {\n  AddForeignKeyMessage msg=deserializer.getAddForeignKeyMessage(context.dmd.getPayload());\n  List<SQLForeignKey> fks=null;\n  try {\n    fks=msg.getForeignKeys();\n  }\n catch (  Exception e) {\n    if (!(e instanceof SemanticException)) {\n      throw new SemanticException(\"Error reading message members\",e);\n    }\n else {\n      throw (SemanticException)e;\n    }\n  }\n  List<Task<? extends Serializable>> tasks=new ArrayList<Task<? extends Serializable>>();\n  if (fks.isEmpty()) {\n    return tasks;\n  }\n  String actualDbName=context.isDbNameEmpty() ? fks.get(0).getFktable_db() : context.dbName;\n  String actualTblName=context.isTableNameEmpty() ? fks.get(0).getFktable_name() : context.tableName;\n  for (  SQLForeignKey fk : fks) {\n    if (fk.getPktable_db().equals(fk.getFktable_db())) {\n      fk.setPktable_db(actualDbName);\n    }\n    fk.setFktable_db(actualDbName);\n    fk.setFktable_name(actualTblName);\n  }\n  AlterTableDesc addConstraintsDesc=new AlterTableDesc(actualDbName + \".\" + actualTblName,new ArrayList<SQLPrimaryKey>(),fks,new ArrayList<SQLUniqueConstraint>(),context.eventOnlyReplicationSpec());\n// bug_start\n  Task<DDLWork> addConstraintsTask=TaskFactory.get(new DDLWork(readEntitySet,writeEntitySet,addConstraintsDesc),context.hiveConf);\n// bug_end\n  tasks.add(addConstraintsTask);\n  context.log.debug(\"Added add constrains task : {}:{}\",addConstraintsTask.getId(),actualTblName);\n  updatedMetadata.set(context.dmd.getEventTo().toString(),actualDbName,actualTblName,null);\n  return Collections.singletonList(addConstraintsTask);\n}\n"}
{"INPUT": "private int setTaskFromInTask(){\n  if (mSupervisor.isLockTaskModeViolation(mInTask)) {\n    Slog.e(TAG,\"Attempted Lock Task Mode violation mStartActivity=\" + mStartActivity);\n    return START_RETURN_LOCK_TASK_MODE_VIOLATION;\n  }\n  if (mLaunchBounds != null) {\n    mInTask.updateOverrideConfiguration(mLaunchBounds);\n    int stackId=mInTask.getLaunchStackId();\n    if (stackId != mInTask.getStackId()) {\n// bug_start\n      final ActivityStack stack=mSupervisor.moveTaskToStackUncheckedLocked(mInTask,stackId,ON_TOP,!FORCE_FOCUS,\"inTaskToFront\",true);\n// bug_end\n      stackId=stack.mStackId;\n    }\n    if (StackId.resizeStackWithLaunchBounds(stackId)) {\n      mService.resizeStack(stackId,mLaunchBounds,true,!PRESERVE_WINDOWS,ANIMATE,-1);\n    }\n  }\n  mTargetStack=mInTask.getStack();\n  mTargetStack.moveTaskToFrontLocked(mInTask,mNoAnimation,mOptions,mStartActivity.appTimeTracker,\"inTaskToFront\");\n  ActivityRecord top=mInTask.getTopActivity();\n  if (top != null && top.realActivity.equals(mStartActivity.realActivity) && top.userId == mStartActivity.userId) {\n    if ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask) {\n      ActivityStack.logStartActivity(AM_NEW_INTENT,top,top.task);\n      if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {\n        return START_RETURN_INTENT_TO_CALLER;\n      }\n      top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);\n      return START_DELIVERED_TO_TOP;\n    }\n  }\n  if (!mAddingToTask) {\n    ActivityOptions.abort(mOptions);\n    return START_TASK_TO_FRONT;\n  }\n  mStartActivity.setTask(mInTask,null);\n  if (DEBUG_TASKS)   Slog.v(TAG_TASKS,\"Starting new activity \" + mStartActivity + \" in explicit task \"+ mStartActivity.task);\n  return START_SUCCESS;\n}\n"}
{"INPUT": "public ParquetRecordWriter(FragmentContext context,ParquetWriter writer) throws OutOfMemoryException {\n  super();\n// bug_start\n  this.oContext=context.newOperatorContext(writer,true);\n// bug_end\n  this.codecFactory=CodecFactory.createDirectCodecFactory(writer.getFormatPlugin().getFsConf(),new ParquetDirectByteBufferAllocator(oContext.getAllocator()),pageSize);\n  this.partitionColumns=writer.getPartitionColumns();\n  this.hasPartitions=partitionColumns != null && partitionColumns.size() > 0;\n  this.extraMetaData.put(DRILL_VERSION_PROPERTY,DrillVersionInfo.getVersion());\n}\n"}
{"INPUT": "void dispatchRequest(final RestRequest restRequest,final RestChannel channel,final Throwable badRequestCause){\n  final ThreadContext threadContext=threadPool.getThreadContext();\n  try (ThreadContext.StoredContext ignore=threadContext.stashContext()){\n    if (badRequestCause != null) {\n// bug_start\n      dispatcher.dispatchBadRequest(restRequest,channel,threadContext,badRequestCause);\n// bug_end\n    }\n else {\n      dispatcher.dispatchRequest(restRequest,channel,threadContext);\n    }\n  }\n }\n"}
{"INPUT": "@Test public void whenRunningAComputeQueryThenExiting_TheComputeQueryIsKilled() throws ExecutionException, InterruptedException {\n  Session jettySesssion=mock(Session.class,RETURNS_DEEP_STUBS);\n  GraknSession factory=mock(GraknSession.class);\n  GraknTx graph=mock(GraknTx.class,RETURNS_DEEP_STUBS);\n  QueryBuilder qb=mock(QueryBuilder.class);\n  QueryParser parser=mock(QueryParser.class);\n  CountQuery count=mock(CountQuery.class);\n  when(factory.open(GraknTxType.WRITE)).thenReturn(graph);\n  when(graph.graql()).thenReturn(qb);\n  when(qb.infer(false)).thenReturn(qb);\n  when(qb.materialise(false)).thenReturn(qb);\n  when(qb.parser()).thenReturn(parser);\n  when(parser.parseList(\"compute count;\")).thenReturn(Stream.of(count));\n// bug_start\n  GraqlSession session=new GraqlSession(jettySesssion,factory,\"json\",false,false);\n// bug_end\n  session.receiveQuery(Json.object(QUERY,\"compute count;\"));\n  session.executeQuery().get();\n  verify(count,never()).kill();\n  session.close();\n  verify(count).kill();\n}\n"}
{"INPUT": "@Setup public void setup() throws IOException {\n  log.info(\"SETUP CALLED AT \" + System.currentTimeMillis());\n  if (ComplexMetrics.getSerdeForType(\"hyperUnique\") == null) {\n    ComplexMetrics.registerSerde(\"hyperUnique\",new HyperUniquesSerde(HyperLogLogHash.getDefault()));\n  }\n  executorService=Execs.multiThreaded(numSegments,\"SelectThreadPool\");\n  setupQueries();\n  String[] schemaQuery=schemaAndQuery.split(\"\\\\.\");\n  String schemaName=schemaQuery[0];\n  String queryName=schemaQuery[1];\n  schemaInfo=BenchmarkSchemas.SCHEMA_MAP.get(schemaName);\n  queryBuilder=SCHEMA_QUERY_MAP.get(schemaName).get(queryName);\n  queryBuilder.pagingSpec(PagingSpec.newSpec(pagingThreshold));\n  query=queryBuilder.build();\n  incIndexes=new ArrayList<>();\n  for (int i=0; i < numSegments; i++) {\n    BenchmarkDataGenerator gen=new BenchmarkDataGenerator(schemaInfo.getColumnSchemas(),RNG_SEED + i,schemaInfo.getDataInterval(),rowsPerSegment);\n    IncrementalIndex incIndex=makeIncIndex();\n    for (int j=0; j < rowsPerSegment; j++) {\n      InputRow row=gen.nextRow();\n      if (j % 10000 == 0) {\n        log.info(j + \" rows generated.\");\n      }\n      incIndex.add(row);\n    }\n    incIndexes.add(incIndex);\n  }\n  tmpDir=Files.createTempDir();\n  log.info(\"Using temp dir: \" + tmpDir.getAbsolutePath());\n  qIndexes=new ArrayList<>();\n  for (int i=0; i < numSegments; i++) {\n    File indexFile=INDEX_MERGER_V9.persist(incIndexes.get(i),tmpDir,new IndexSpec());\n    QueryableIndex qIndex=INDEX_IO.loadIndex(indexFile);\n    qIndexes.add(qIndex);\n  }\n  final Supplier<SelectQueryConfig> selectConfigSupplier=Suppliers.ofInstance(new SelectQueryConfig(true));\n// bug_start\n  factory=new SelectQueryRunnerFactory(new SelectQueryQueryToolChest(JSON_MAPPER,QueryBenchmarkUtil.NoopIntervalChunkingQueryRunnerDecorator(),selectConfigSupplier),new SelectQueryEngine(selectConfigSupplier),QueryBenchmarkUtil.NOOP_QUERYWATCHER);\n// bug_end\n}\n"}
{"INPUT": "@Override public void serviceInit(Configuration conf) throws IOException, InterruptedException {\n  int rpcPort=0;\n  int mngPort=0;\n  int shufflePort=0;\n  int webPort=0;\n  int outputFormatServicePort=0;\n  boolean usePortsFromConf=conf.getBoolean(\"minillap.usePortsFromConf\",false);\n  LOG.info(\"MiniLlap configured to use ports from conf: {}\",usePortsFromConf);\n  if (usePortsFromConf) {\n    rpcPort=HiveConf.getIntVar(conf,HiveConf.ConfVars.LLAP_DAEMON_RPC_PORT);\n    mngPort=HiveConf.getIntVar(conf,HiveConf.ConfVars.LLAP_MANAGEMENT_RPC_PORT);\n    shufflePort=conf.getInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY,ShuffleHandler.DEFAULT_SHUFFLE_PORT);\n    webPort=HiveConf.getIntVar(conf,ConfVars.LLAP_DAEMON_WEB_PORT);\n    outputFormatServicePort=HiveConf.getIntVar(conf,ConfVars.LLAP_DAEMON_OUTPUT_SERVICE_PORT);\n  }\n  HiveConf.setIntVar(conf,ConfVars.LLAP_DAEMON_OUTPUT_SERVICE_PORT,outputFormatServicePort);\n  if (ownZkCluster) {\n    miniZooKeeperCluster=new MiniZooKeeperCluster();\n    miniZooKeeperCluster.startup(zkWorkDir);\n  }\n else {\n  }\n  conf.set(ConfVars.LLAP_DAEMON_SERVICE_HOSTS.varname,\"@\" + clusterNameTrimmed);\n  conf.set(ConfVars.HIVE_ZOOKEEPER_QUORUM.varname,\"localhost\");\n  conf.setInt(ConfVars.HIVE_ZOOKEEPER_CLIENT_PORT.varname,miniZooKeeperCluster.getClientPort());\n  clusterSpecificConfiguration.set(ConfVars.LLAP_DAEMON_SERVICE_HOSTS.varname,\"@\" + clusterNameTrimmed);\n  clusterSpecificConfiguration.set(ConfVars.HIVE_ZOOKEEPER_QUORUM.varname,\"localhost\");\n  clusterSpecificConfiguration.setInt(ConfVars.HIVE_ZOOKEEPER_CLIENT_PORT.varname,miniZooKeeperCluster.getClientPort());\n  LOG.info(\"Initializing {} llap instances for MiniLlapCluster with name={}\",numInstances,clusterNameTrimmed);\n  for (int i=0; i < numInstances; i++) {\n// bug_start\n    llapDaemons[i]=new LlapDaemon(conf,numExecutorsPerService,execBytesPerService,llapIoEnabled,ioIsDirect,ioBytesPerService,localDirs,rpcPort,mngPort,shufflePort,webPort,clusterNameTrimmed,0);\n// bug_end\n    llapDaemons[i].init(new Configuration(conf));\n  }\n  LOG.info(\"Initialized {} llap instances for MiniLlapCluster with name={}\",numInstances,clusterNameTrimmed);\n}\n"}
{"INPUT": "public TableFunctionCollectPhase(UUID jobId,int phaseId,Routing routing,TableFunctionImplementation functionImplementation,List<Literal<?>> functionArguments,List<Projection> projections,List<Symbol> outputs,Symbol where){\n// bug_start\n  super(jobId,phaseId,functionImplementation.info().ident().name(),routing,RowGranularity.DOC,outputs,projections,where,DistributionInfo.DEFAULT_BROADCAST,null);\n// bug_end\n  this.functionImplementation=functionImplementation;\n  this.functionArguments=functionArguments;\n}\n"}
{"INPUT": "private static AppContext createAppContext(){\n  ApplicationId appId=ApplicationId.newInstance(1,1);\n  ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(appId,1);\n  Job job=mock(Job.class);\n  @SuppressWarnings(\"rawtypes\") EventHandler eventHandler=mock(EventHandler.class);\n  AppContext ctx=mock(AppContext.class);\n  when(ctx.getApplicationID()).thenReturn(appId);\n  when(ctx.getApplicationAttemptId()).thenReturn(attemptId);\n  when(ctx.getJob(isA(JobId.class))).thenReturn(job);\n// bug_start\n  when(ctx.getClusterInfo()).thenReturn(new ClusterInfo(Resource.newInstance(1024,1),Resource.newInstance(10240,1)));\n// bug_end\n  when(ctx.getEventHandler()).thenReturn(eventHandler);\n  return ctx;\n}\n"}
{"INPUT": "private String getSuggestedFileName(String suffix){\n// bug_start\n  String plannedName=FileUtil.createFileNameFromPattern(databaseContext.getDatabase(),entry,Globals.prefs.get(JabRefPreferences.IMPORT_FILENAMEPATTERN),Globals.prefs.getLayoutFormatterPreferences(Globals.journalAbbreviationLoader));\n// bug_end\n  if (!suffix.isEmpty()) {\n    plannedName+=\".\" + suffix;\n  }\n  if (OS.WINDOWS) {\n    plannedName=plannedName.replaceAll(\"\\\\?|\\\\*|\\\\<|\\\\>|\\\\||\\\\\\\"|\\\\:|\\\\.$|\\\\[|\\\\]\",\"\");\n  }\n else   if (OS.OS_X) {\n    plannedName=plannedName.replace(\":\",\"\");\n  }\n  return plannedName;\n}\n"}
{"INPUT": "@Override public String toString(){\n// bug_start\n  return \"MultiModelLoader{\" + \"modelLoaders=\" + Arrays.toString(modelLoaders.toArray(new ModelLoader<?,?>[modelLoaders.size()])) + '}';\n// bug_end\n}\n"}
{"INPUT": "@Override public void parseOneFile(Project project,ProjectMetadata metadata,ImportingJob job,String fileSource,Reader reader,int limit,ObjectNode options,List<Exception> exceptions){\n  final int[] columnWidths=JSONUtilities.getIntArray(options,\"columnWidths\");\n  List<Object> retrievedColumnNames=null;\n  if (options.has(\"columnNames\")) {\n    String[] strings=JSONUtilities.getStringArray(options,\"columnNames\");\n    if (strings.length > 0) {\n      retrievedColumnNames=new ArrayList<Object>();\n      for (      String s : strings) {\n        s=s.trim();\n        if (!s.isEmpty()) {\n          retrievedColumnNames.add(s);\n        }\n      }\n      if (retrievedColumnNames.size() > 0) {\n        JSONUtilities.safePut(options,\"headerLines\",1);\n      }\n else {\n        retrievedColumnNames=null;\n      }\n    }\n  }\n  final List<Object> columnNames=retrievedColumnNames;\n  final LineNumberReader lnReader=new LineNumberReader(reader);\n  TableDataReader dataReader=new TableDataReader(){\n    boolean usedColumnNames=false;\n    @Override public List<Object> getNextRowOfCells() throws IOException {\n      if (columnNames != null && !usedColumnNames) {\n        usedColumnNames=true;\n        return columnNames;\n      }\n else {\n        String line=lnReader.readLine();\n        if (line == null) {\n          return null;\n        }\n else {\n          return getCells(line,columnWidths);\n        }\n      }\n    }\n  }\n;\n// bug_start\n  TabularImportingParserBase.readTable(project,metadata,job,dataReader,fileSource,limit,options,exceptions);\n// bug_end\n}\n"}
{"INPUT": "@Inject public InsertTableHandleJacksonModule(HandleResolver handleResolver){\n// bug_start\n  super(ConnectorInsertTableHandle.class,\"type\",new InsertTableHandleJsonTypeIdResolver(handleResolver));\n// bug_end\n}\n"}
{"INPUT": "private WriteEntry doWALAppend(WALEdit walEdit,Durability durability,List<UUID> clusterIds,long now,long nonceGroup,long nonce,long origLogSeqNum) throws IOException {\n  Preconditions.checkArgument(walEdit != null && !walEdit.isEmpty(),\"WALEdit is null or empty!\");\n  Preconditions.checkArgument(!walEdit.isReplay() || origLogSeqNum != SequenceId.NO_SEQUENCE_ID,\"Invalid replay sequence Id for replay WALEdit!\");\n  WALKeyImpl walKey=walEdit.isReplay() ? new WALKeyImpl(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),SequenceId.NO_SEQUENCE_ID,now,clusterIds,nonceGroup,nonce,mvcc) : new WALKeyImpl(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),SequenceId.NO_SEQUENCE_ID,now,clusterIds,nonceGroup,nonce,mvcc,this.getReplicationScope());\n  if (walEdit.isReplay()) {\n    walKey.setOrigLogSeqNum(origLogSeqNum);\n  }\n  WriteEntry writeEntry=null;\n  try {\n// bug_start\n    long txid=this.wal.append(this.getRegionInfo(),walKey,walEdit,true);\n// bug_end\n    if (txid != 0) {\n      sync(txid,durability);\n    }\n    writeEntry=walKey.getWriteEntry();\n  }\n catch (  IOException ioe) {\n    if (walKey != null && walKey.getWriteEntry() != null) {\n      mvcc.complete(walKey.getWriteEntry());\n    }\n    throw ioe;\n  }\n  return writeEntry;\n}\n"}
{"INPUT": "@BeforeClass public static void generateClasses() throws ClassNotFoundException, IOException {\n// bug_start\n  File outputDirectory=generate(\"/schema/description/description.json\",\"com.example\",true,false,false);\n// bug_end\n  File generatedJavaFile=new File(outputDirectory,\"com/example/Description.java\");\n  compile(outputDirectory);\n  JavaDocBuilder javaDocBuilder=new JavaDocBuilder();\n  javaDocBuilder.addSource(generatedJavaFile);\n  classWithDescription=javaDocBuilder.getClassByName(\"com.example.Description\");\n}\n"}
{"INPUT": "public DDLIntegrateTest(final String sqlCaseId,final String path,final DDLIntegrateTestCaseAssertion integrateTestCaseAssertion,final DatabaseTypeEnvironment databaseTypeEnvironment,final SQLCaseType caseType) throws IOException, JAXBException, SQLException {\n  this.databaseTypeEnvironment=databaseTypeEnvironment;\n  this.caseType=caseType;\n  if (databaseTypeEnvironment.isEnabled()) {\n    Map<String,DataSource> dataSourceMap=createDataSourceMap(integrateTestCaseAssertion);\n    dataSetEnvironmentManager=new DataSetEnvironmentManager(EnvironmentPath.getDataInitializeResourceFile(integrateTestCaseAssertion.getShardingRuleType()),dataSourceMap);\n// bug_start\n    ddlAssertEngine=new DDLAssertEngine(sqlCaseId,path,integrateTestCaseAssertion,dataSourceMap,databaseTypeEnvironment.getDatabaseType());\n// bug_end\n  }\n else {\n    dataSetEnvironmentManager=null;\n    ddlAssertEngine=null;\n  }\n}\n"}
{"INPUT": "@Override public Google2Profile extractUserProfile(final String body){\n  final Google2Profile profile=(Google2Profile)newProfile();\n  final JsonNode json=JsonHelper.getFirstNode(body);\n  if (json != null) {\n// bug_start\n    profile.setId(ProfileHelper.sanitizeIdentifier(profile,JsonHelper.getElement(json,\"sub\")));\n// bug_end\n    for (    final String attribute : getPrimaryAttributes()) {\n      convertAndAdd(profile,PROFILE_ATTRIBUTE,attribute,JsonHelper.getElement(json,attribute));\n    }\n  }\n else {\n    raiseProfileExtractionJsonError(body);\n  }\n  return profile;\n}\n"}
{"INPUT": "@Test public void newNodeSimpleBinary() throws Exception {\n  BinaryExpressionNodeFactory factory=new BinaryExpressionNodeFactory();\n  ExpressionConfig config=(ExpressionConfig)ExpressionConfig.newBuilder().setExpression(\"a + b\").setJoinConfig(JOIN_CONFIG).addInterpolatorConfig(NUMERIC_CONFIG).setId(\"e1\").setId(\"expression\").build();\n  ExpressionParseNode expression_config=(ExpressionParseNode)ExpressionParseNode.newBuilder().setLeft(\"a\").setLeftType(OperandType.VARIABLE).setRight(\"b\").setRightType(OperandType.VARIABLE).setExpressionOp(ExpressionOp.ADD).setExpressionConfig(config).setId(\"expression\").build();\n// bug_start\n  QueryNode new_node=factory.newNode(CONTEXT,null,(QueryNodeConfig)expression_config);\n// bug_end\n  assertTrue(new_node instanceof BinaryExpressionNode);\n  assertSame(config,new_node.config());\n}\n"}
{"INPUT": "@Override protected void processOptions(LinkedList<String> args) throws IOException {\n// bug_start\n  CommandFormat cf=new CommandFormat(null,1,Integer.MAX_VALUE,\"R\");\n// bug_end\n  cf.parse(args);\n  setRecursive(cf.getOpt(\"R\"));\n  if (args.getFirst().contains(\"%\"))   format=args.removeFirst();\n  cf.parse(args);\n}\n"}
{"INPUT": "private SearchResponseData setType(DbSession session,String issueKey,String severity){\n  IssueDto issueDto=issueFinder.getByKey(session,issueKey);\n  DefaultIssue issue=issueDto.toDefaultIssue();\n  userSession.checkComponentUuidPermission(ISSUE_ADMIN,issue.projectUuid());\n  IssueChangeContext context=IssueChangeContext.createUser(new Date(),userSession.getUuid());\n  if (issueFieldsSetter.setManualSeverity(issue,severity,context)) {\n// bug_start\n    return issueUpdater.saveIssueAndPreloadSearchResponseData(session,issue,context,null,true);\n// bug_end\n  }\n  return new SearchResponseData(issueDto);\n}\n"}
{"INPUT": "private void setupRecyclerView(){\n// bug_start\n  eventListAdapter=new EventsListAdapter(events,context);\n// bug_end\n  recyclerView=binding.eventRecyclerView;\n  recyclerView.setLayoutManager(new LinearLayoutManager(context));\n  recyclerView.setAdapter(eventListAdapter);\n  recyclerView.addItemDecoration(new DividerItemDecoration(context,DividerItemDecoration.VERTICAL));\n  recyclerView.setItemAnimator(new DefaultItemAnimator());\n  StickyRecyclerHeadersDecoration decoration=new StickyRecyclerHeadersDecoration(eventListAdapter);\n  recyclerView.addItemDecoration(decoration);\n  adapterDataObserver=new RecyclerView.AdapterDataObserver(){\n    @Override public void onChanged(){\n      decoration.invalidateHeaders();\n    }\n  }\n;\n  eventListAdapter.registerAdapterDataObserver(adapterDataObserver);\n}\n"}
{"INPUT": "@Test public void submitCallableToKeyOwner_withExecutionCallback() throws Exception {\n  IExecutorService service=client.getExecutorService(randomString());\n  String msg=randomString();\n  Callable<String> callable=new AppendCallable(msg);\n  final CountDownLatch responseLatch=new CountDownLatch(1);\n  final AtomicReference<String> result=new AtomicReference<String>();\n  service.submitToKeyOwner(callable,\"key\",new ExecutionCallback<String>(){\n    public void onResponse(    String response){\n      result.set(response);\n      responseLatch.countDown();\n    }\n    public void onFailure(    Throwable t){\n    }\n  }\n);\n// bug_start\n  assertOpenEventually(\"responseLatch\",responseLatch,5);\n// bug_end\n  assertEquals(msg + AppendCallable.APPENDAGE,result.get());\n}\n"}
{"INPUT": "private void handleTouchEvent(MotionEvent ev){\n  int action=ev.getAction();\nswitch (action & MotionEvent.ACTION_MASK) {\ncase MotionEvent.ACTION_DOWN:\n    mDownPos.set((int)ev.getX(),(int)ev.getY());\n  break;\ncase MotionEvent.ACTION_MOVE:\n{\n  if (mDragging) {\n    int width=mRv.getMeasuredWidth();\n    int height=mRv.getMeasuredHeight();\n    float evX=ev.getX();\n    float evY=ev.getY();\n    float x=evX - mTaskViewOffset.x;\n    float y=evY - mTaskViewOffset.y;\n    DropTarget currentDropTarget=null;\n    for (    DropTarget target : mDropTargets) {\n      if (target.acceptsDrop((int)evX,(int)evY,width,height)) {\n        currentDropTarget=target;\n        break;\n      }\n    }\n    if (mLastDropTarget != currentDropTarget) {\n      mLastDropTarget=currentDropTarget;\n      EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));\n    }\n    mTaskView.setTranslationX(x);\n    mTaskView.setTranslationY(y);\n  }\n  break;\n}\ncase MotionEvent.ACTION_UP:\ncase MotionEvent.ACTION_CANCEL:\n{\nif (mDragging) {\n// bug_start\n  ReferenceCountedTrigger postAnimationTrigger=new ReferenceCountedTrigger(mRv.getContext(),null,null,null);\n// bug_end\n  postAnimationTrigger.increment();\n  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,mLastDropTarget,postAnimationTrigger));\n  postAnimationTrigger.decrement();\n  break;\n}\n}\n}\n}\n"}
{"INPUT": "void updateModelAndChooserCounts(TargetInfo info){\n  if (info != null) {\n    sendClickToAppPredictor(info);\n    final ResolveInfo ri=info.getResolveInfo();\n    Intent targetIntent=getTargetIntent();\n    if (ri != null && ri.activityInfo != null && targetIntent != null) {\n      ChooserListAdapter currentListAdapter=mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n      if (currentListAdapter != null) {\n        currentListAdapter.updateModel(info.getResolvedComponentName());\n// bug_start\n        currentListAdapter.updateChooserCounts(ri.activityInfo.packageName,getUserId(),targetIntent.getAction());\n// bug_end\n      }\n      if (DEBUG) {\n        Log.d(TAG,\"ResolveInfo Package is \" + ri.activityInfo.packageName);\n        Log.d(TAG,\"Action to be updated is \" + targetIntent.getAction());\n      }\n    }\n else     if (DEBUG) {\n      Log.d(TAG,\"Can not log Chooser Counts of null ResovleInfo\");\n    }\n  }\n  mIsSuccessfullySelected=true;\n}\n"}
{"INPUT": "@Test public void disableNameResolverServiceConfig(){\n  Builder builder=new Builder(\"target\");\n  assertThat(builder.lookUpServiceConfig).isTrue();\n// bug_start\n  builder.lookUpServiceConfig(false);\n// bug_end\n  assertThat(builder.lookUpServiceConfig).isFalse();\n}\n"}
{"INPUT": "public static void write(Path self,String text) throws IOException {\n  Writer writer=null;\n  try {\n// bug_start\n    writer=new OutputStreamWriter(Files.newOutputStream(self,CREATE,APPEND),Charset.defaultCharset());\n// bug_end\n    writer.write(text);\n    writer.flush();\n    Writer temp=writer;\n    writer=null;\n    temp.close();\n  }\n  finally {\n    closeWithWarning(writer);\n  }\n}\n"}
{"INPUT": "public void run(){\n// bug_start\n  final StringBuilder args=new StringBuilder(\"-p null\");\n// bug_end\n  for (  final String arg : runtimeArgs) {\n    args.append(\" \").append(arg);\n  }\n  final ClassLoader classLoader=Thread.currentThread().getContextClassLoader();\n  final ClasspathResourceLoader resourceLoader=new ClasspathResourceLoader(classLoader);\n  final RuntimeGlue glue;\n  try {\n    glue=createMockedRuntimeGlueThatMatchesTheSteps(stepsToResult,stepsToLocation,hooks,hookLocations,hookActions);\n  }\n catch (  final Throwable e) {\n    throw new RuntimeException(e);\n  }\n  final GlueSupplier glueSupplier=new GlueSupplier(){\n    @Override public Glue get(){\n      return glue;\n    }\n  }\n;\n  final BackendSupplier backendSupplier=new BackendSupplier(){\n    @Override public Collection<? extends Backend> get(){\n      return backends;\n    }\n  }\n;\n  final FeatureSupplier featureSupplier=features.isEmpty() ? null : new FeatureSupplier(){\n    @Override public List<CucumberFeature> get(){\n      return features;\n    }\n  }\n;\n  Runtime.Builder runtimeBuilder=Runtime.builder().withArg(args.toString()).withClassLoader(classLoader).withResourceLoader(resourceLoader).withGlueSupplier(glueSupplier).withBackendSupplier(backendSupplier).withFeatureSupplier(featureSupplier);\n  if (TimeServiceType.REAL_TIME.equals(this.timeServiceType)) {\n    if (formatterUnderTest instanceof Plugin) {\n      runtimeBuilder.withAdditionalPlugins((Plugin)formatterUnderTest);\n    }\n  }\n else {\n    EventBus bus=null;\n    if (TimeServiceType.FIXED_INCREMENT_ON_STEP_START.equals(this.timeServiceType)) {\n      final StepDurationTimeService timeService=new StepDurationTimeService(this.timeServiceIncrement);\n      bus=new TimeServiceEventBus(timeService);\n      timeService.setEventPublisher(bus);\n    }\n else     if (TimeServiceType.FIXED_INCREMENT.equals(this.timeServiceType)) {\n      bus=new TimeServiceEventBus(new TimeServiceStub(this.timeServiceIncrement));\n    }\n    runtimeBuilder.withEventBus(bus);\n    if (formatterUnderTest instanceof ConcurrentEventListener) {\n      ((ConcurrentEventListener)formatterUnderTest).setEventPublisher(bus);\n    }\n else     if (formatterUnderTest instanceof EventListener) {\n      ((EventListener)formatterUnderTest).setEventPublisher(bus);\n    }\n  }\n  runtimeBuilder.build().run();\n}\n"}
{"INPUT": "@Override public XContentBuilder toXContent(XContentBuilder builder,ToXContent.Params params) throws IOException {\n  builder.startObject(Fields.SEARCH);\n  builder.field(Fields.OPEN_CONTEXTS,openContexts);\n  totalStats.toXContent(builder,params);\n  if (groupStats != null && !groupStats.isEmpty()) {\n    builder.startObject(Fields.GROUPS);\n    for (    Map.Entry<String,Stats> entry : groupStats.entrySet()) {\n// bug_start\n      builder.startObject(entry.getKey(),XContentBuilder.FieldCaseConversion.NONE);\n// bug_end\n      entry.getValue().toXContent(builder,params);\n      builder.endObject();\n    }\n    builder.endObject();\n  }\n  builder.endObject();\n  return builder;\n}\n"}
{"INPUT": "public void testNoDir() throws Throwable {\n  Directory dir=newFSSwitchDirectory(Collections.<String>emptySet());\n  try {\n// bug_start\n    IndexReader.open(dir,true);\n// bug_end\n    fail(\"did not hit expected exception\");\n  }\n catch (  NoSuchDirectoryException nsde) {\n  }\n  dir.close();\n}\n"}
{"INPUT": "@Override protected void populateItem(ListItem<PullRequest> item){\n  PullRequest request=item.getModelObject();\n// bug_start\n  Link<Void> link=new BookmarkablePageLink<Void>(\"title\",PullRequestActivitiesPage.class,PullRequestActivitiesPage.paramsOf(request,null));\n// bug_end\n  link.add(new Label(\"label\",\"#\" + request.getNumber() + \" - \"+ request.getTitle()));\n  item.add(link);\n  item.add(new RequestStatusLabel(\"status\",item.getModel()));\n}\n"}
{"INPUT": "private void sortAndCombine() throws Exception {\n  final InMemorySorter<T> sorter=this.sorter;\n  if (objectReuseEnabled) {\n    if (!sorter.isEmpty()) {\n      this.sortAlgo.sort(sorter);\n      final ReusingKeyGroupedIterator<T> keyIter=new ReusingKeyGroupedIterator<T>(sorter.getIterator(),this.serializer,this.groupingComparator);\n      final FlatCombineFunction<T> combiner=this.combiner;\n      final Collector<T> output=this.output;\n      while (this.running && keyIter.nextKey()) {\n        combiner.combine(keyIter.getValues(),output);\n      }\n    }\n  }\n else {\n    if (!sorter.isEmpty()) {\n      this.sortAlgo.sort(sorter);\n// bug_start\n      final NonReusingKeyGroupedIterator<T> keyIter=new NonReusingKeyGroupedIterator<T>(sorter.getIterator(),this.serializer,this.groupingComparator);\n// bug_end\n      final FlatCombineFunction<T> combiner=this.combiner;\n      final Collector<T> output=this.output;\n      while (this.running && keyIter.nextKey()) {\n        combiner.combine(keyIter.getValues(),output);\n      }\n    }\n  }\n}\n"}
{"INPUT": "public void testPrint(){\n  ByteArrayOutputStream bytes=new ByteArrayOutputStream();\n  PrintStream printStream=new PrintStream(bytes);\n// bug_start\n  String ls=System.getProperty(\"line.separator\");\n// bug_end\n  String[] first={\"a\",\"b\"};\n  String[] second={\"x\",\"y\"};\n  Object[] memberInfo={first,second};\n  Inspector.print(printStream,memberInfo);\n  assertEquals(\"0:\\ta b \" + ls + \"1:\\tx y \"+ ls,bytes.toString());\n  Inspector.print(memberInfo);\n}\n"}
{"INPUT": "public Topology getClusterTopology(Step step,long startTimeBucket,long endTimeBucket,long startSecondTimeBucket,long endSecondTimeBucket){\n  logger.debug(\"startTimeBucket: {}, endTimeBucket: {}, startSecondTimeBucket: {}, endSecondTimeBucket: {}\",startTimeBucket,endTimeBucket,startSecondTimeBucket,endSecondTimeBucket);\n  List<IApplicationComponentUIDAO.ApplicationComponent> applicationComponents=applicationComponentUIDAO.load(step,startTimeBucket,endTimeBucket);\n  List<IApplicationMappingUIDAO.ApplicationMapping> applicationMappings=applicationMappingUIDAO.load(step,startTimeBucket,endTimeBucket);\n  Map<Integer,String> components=new HashMap<>();\n  applicationComponents.forEach(null);\n  List<IApplicationMetricUIDAO.ApplicationMetric> applicationMetrics=applicationMetricUIDAO.getApplications(step,startTimeBucket,endTimeBucket,MetricSource.Callee);\n  List<IApplicationReferenceMetricUIDAO.ApplicationReferenceMetric> callerReferenceMetric=applicationReferenceMetricUIDAO.getReferences(step,startTimeBucket,endTimeBucket,MetricSource.Caller);\n  List<IApplicationReferenceMetricUIDAO.ApplicationReferenceMetric> calleeReferenceMetric=applicationReferenceMetricUIDAO.getReferences(step,startTimeBucket,endTimeBucket,MetricSource.Callee);\n  TopologyBuilder builder=new TopologyBuilder(moduleManager);\n// bug_start\n  return builder.build(applicationComponents,applicationMappings,applicationMetrics,callerReferenceMetric,calleeReferenceMetric,step,startTimeBucket,endTimeBucket,startSecondTimeBucket,endSecondTimeBucket);\n// bug_end\n}\n"}
{"INPUT": "private WriteEntry doWALAppend(WALEdit walEdit,Durability durability,List<UUID> clusterIds,long now,long nonceGroup,long nonce,long origLogSeqNum) throws IOException {\n  Preconditions.checkArgument(walEdit != null && !walEdit.isEmpty(),\"WALEdit is null or empty!\");\n  Preconditions.checkArgument(!walEdit.isReplay() || origLogSeqNum != SequenceId.NO_SEQUENCE_ID,\"Invalid replay sequence Id for replay WALEdit!\");\n  WALKeyImpl walKey=walEdit.isReplay() ? new WALKeyImpl(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),SequenceId.NO_SEQUENCE_ID,now,clusterIds,nonceGroup,nonce,mvcc) : new WALKeyImpl(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),SequenceId.NO_SEQUENCE_ID,now,clusterIds,nonceGroup,nonce,mvcc,this.getReplicationScope());\n  if (walEdit.isReplay()) {\n    walKey.setOrigLogSeqNum(origLogSeqNum);\n  }\n  if (this.coprocessorHost != null && !walEdit.isMetaEdit()) {\n    this.coprocessorHost.preWALAppend(walKey,walEdit);\n  }\n  WriteEntry writeEntry=null;\n  try {\n// bug_start\n    long txid=this.wal.append(this.getRegionInfo(),walKey,walEdit,true);\n// bug_end\n    if (txid != 0) {\n      sync(txid,durability);\n    }\n    writeEntry=walKey.getWriteEntry();\n  }\n catch (  IOException ioe) {\n    if (walKey != null && walKey.getWriteEntry() != null) {\n      mvcc.complete(walKey.getWriteEntry());\n    }\n    throw ioe;\n  }\n  return writeEntry;\n}\n"}
{"INPUT": "public LLVMAMD64SyscallSendtoNode(){\n// bug_start\n  sendto=LLVMAMD64PosixCallNodeGen.create(\"sendto\",\"(SINT32,UINT64,UINT64,SINT32,UINT64,SINT32):SINT64\",6);\n// bug_end\n}\n"}
{"INPUT": "@SuppressWarnings(\"unchecked\") public Result prepare(UpdateRequest request,IndexShard indexShard){\n// bug_start\n  final GetResult getResult=indexShard.getService().get(request.type(),request.id(),new String[]{RoutingFieldMapper.NAME,ParentFieldMapper.NAME,TTLFieldMapper.NAME,TimestampFieldMapper.NAME},true,request.version(),request.versionType(),FetchSourceContext.FETCH_SOURCE,false);\n// bug_end\n  return prepare(indexShard.shardId(),request,getResult);\n}\n"}
{"INPUT": "public static void logLikeCLI(ResultSet rs,Logger logger) throws SQLException {\n  ResultSetMetaData metaData=rs.getMetaData();\n  int columns=metaData.getColumnCount();\n  List<ColumnInfo> cols=new ArrayList<>(columns);\n  for (int i=1; i <= columns; i++) {\n// bug_start\n    cols.add(new ColumnInfo(metaData.getTableName(i),metaData.getColumnName(i),metaData.getColumnTypeName(i),metaData.getColumnType(i),metaData.getColumnDisplaySize(i)));\n// bug_end\n  }\n  List<List<Object>> data=new ArrayList<>();\n  while (rs.next()) {\n    List<Object> entry=new ArrayList<>(columns);\n    for (int i=1; i <= columns; i++) {\n      entry.add(rs.getObject(i));\n    }\n    data.add(entry);\n  }\n  CliFormatter formatter=new CliFormatter(cols,data);\n  logger.info(\"\\n\" + formatter.formatWithHeader(cols,data));\n}\n"}
{"INPUT": "Map<UseCase,Size> getSuggestedResolutions(List<UseCase> originalUseCases,List<UseCase> newUseCases){\n  Map<UseCase,Size> suggestedResolutionsMap=new HashMap<>();\n  List<Integer> useCasesPriorityOrder=getUseCasesPriorityOrder(newUseCases);\n  List<List<Size>> supportedOutputSizesList=new ArrayList<>();\n  for (  Integer index : useCasesPriorityOrder) {\n    List<Size> supportedOutputSizes=getSupportedOutputSizes(newUseCases.get(index));\n    supportedOutputSizesList.add(supportedOutputSizes);\n  }\n  List<List<Size>> allPossibleSizeArrangements=getAllPossibleSizeArrangements(supportedOutputSizesList);\n  for (  List<Size> possibleSizeList : allPossibleSizeArrangements) {\n    List<SurfaceConfig> surfaceConfigList=new ArrayList<>();\n    if (originalUseCases != null) {\n      for (      UseCase useCase : originalUseCases) {\n// bug_start\n        Size resolution=useCase.getAttachedSurfaceResolution(useCase.getBoundCamera().getCameraInfoInternal().getCameraId());\n// bug_end\n        surfaceConfigList.add(transformSurfaceConfig(useCase.getImageFormat(),resolution));\n      }\n    }\n    for (int i=0; i < possibleSizeList.size(); i++) {\n      Size size=possibleSizeList.get(i);\n      UseCase newUseCase=newUseCases.get(useCasesPriorityOrder.get(i));\n      surfaceConfigList.add(transformSurfaceConfig(newUseCase.getImageFormat(),size));\n    }\n    if (checkSupported(surfaceConfigList)) {\n      for (      UseCase useCase : newUseCases) {\n        suggestedResolutionsMap.put(useCase,possibleSizeList.get(useCasesPriorityOrder.indexOf(newUseCases.indexOf(useCase))));\n      }\n      break;\n    }\n  }\n  return suggestedResolutionsMap;\n}\n"}
{"INPUT": "@Override public RecordSetWriter createWriter(final ComponentLog logger,final RecordSchema schema,final OutputStream out) throws SchemaNotFoundException, IOException {\n  final String nullSuppression=getConfigurationContext().getProperty(SUPPRESS_NULLS).getValue();\n  final NullSuppression nullSuppressionEnum;\n  if (nullSuppression.equals(ALWAYS_SUPPRESS.getValue())) {\n    nullSuppressionEnum=NullSuppression.ALWAYS_SUPPRESS;\n  }\n else   if (nullSuppression.equals(NEVER_SUPPRESS.getValue())) {\n    nullSuppressionEnum=NullSuppression.NEVER_SUPPRESS;\n  }\n else {\n    nullSuppressionEnum=NullSuppression.SUPPRESS_MISSING;\n  }\n  final boolean prettyPrint=getConfigurationContext().getProperty(PRETTY_PRINT_XML).getValue().equals(\"true\");\n  final String rootTagName=getConfigurationContext().getProperty(ROOT_TAG_NAME).isSet() ? getConfigurationContext().getProperty(ROOT_TAG_NAME).getValue() : null;\n  final String recordTagName=getConfigurationContext().getProperty(RECORD_TAG_NAME).isSet() ? getConfigurationContext().getProperty(RECORD_TAG_NAME).getValue() : null;\n  final String arrayWrapping=getConfigurationContext().getProperty(ARRAY_WRAPPING).getValue();\n  final ArrayWrapping arrayWrappingEnum;\n  if (arrayWrapping.equals(NO_WRAPPING.getValue())) {\n    arrayWrappingEnum=ArrayWrapping.NO_WRAPPING;\n  }\n else   if (arrayWrapping.equals(USE_PROPERTY_AS_WRAPPER.getValue())) {\n    arrayWrappingEnum=ArrayWrapping.USE_PROPERTY_AS_WRAPPER;\n  }\n else {\n    arrayWrappingEnum=ArrayWrapping.USE_PROPERTY_FOR_ELEMENTS;\n  }\n  final String arrayTagName;\n  if (getConfigurationContext().getProperty(ARRAY_TAG_NAME).isSet()) {\n    arrayTagName=getConfigurationContext().getProperty(ARRAY_TAG_NAME).getValue();\n  }\n else {\n    arrayTagName=null;\n  }\n  final String charSet=getConfigurationContext().getProperty(CHARACTER_SET).getValue();\n// bug_start\n  return new WriteXMLResult(logger,schema,getSchemaAccessWriter(schema),out,prettyPrint,nullSuppressionEnum,arrayWrappingEnum,arrayTagName,rootTagName,recordTagName,charSet,getDateFormat().orElse(null),getTimeFormat().orElse(null),getTimestampFormat().orElse(null));\n// bug_end\n}\n"}
{"INPUT": "@Before public void setUp(){\n  MockitoAnnotations.initMocks(this);\n  when(mockLoadBalancerFactory.newLoadBalancer(any(Helper.class))).thenReturn(mockLoadBalancer);\n  when(mockNameResolver.getServiceAuthority()).thenReturn(AUTHORITY);\n  when(mockNameResolverFactory.newNameResolver(any(URI.class),any(Attributes.class))).thenReturn(mockNameResolver);\n  when(mockTransportFactory.getScheduledExecutorService()).thenReturn(timer.getScheduledExecutorService());\nclass Builder extends AbstractManagedChannelImplBuilder<Builder> {\n    Builder(    String target){\n      super(target);\n    }\n    @Override protected ClientTransportFactory buildTransportFactory(){\n      throw new UnsupportedOperationException();\n    }\n    @Override public Builder usePlaintext(){\n      throw new UnsupportedOperationException();\n    }\n  }\n  Builder builder=new Builder(\"fake://target\").nameResolverFactory(mockNameResolverFactory).loadBalancerFactory(mockLoadBalancerFactory).idleTimeout(IDLE_TIMEOUT_SECONDS,TimeUnit.SECONDS).userAgent(USER_AGENT);\n  builder.executorPool=executorPool;\n// bug_start\n  channel=new ManagedChannelImpl(builder,mockTransportFactory,new FakeBackoffPolicyProvider(),oobExecutorPool,timer.getStopwatchSupplier(),Collections.<ClientInterceptor>emptyList(),GrpcUtil.NOOP_PROXY_DETECTOR,CallTracer.getDefaultFactory());\n// bug_end\n  newTransports=TestUtils.captureTransports(mockTransportFactory);\n  for (int i=0; i < 2; i++) {\n    ArrayList<SocketAddress> addrs=Lists.newArrayList();\n    for (int j=0; j < 2; j++) {\n      addrs.add(new FakeSocketAddress(\"servergroup\" + i + \"server\"+ j));\n    }\n    servers.add(new EquivalentAddressGroup(addrs));\n  }\n  verify(mockNameResolverFactory).newNameResolver(any(URI.class),any(Attributes.class));\n  verify(mockLoadBalancerFactory,never()).newLoadBalancer(any(Helper.class));\n  verify(mockTransportFactory,never()).newClientTransport(any(SocketAddress.class),anyString(),anyString(),any(ProxyParameters.class));\n  verify(mockNameResolver,never()).start(any(NameResolver.Listener.class));\n}\n"}
{"INPUT": "public MockNioTransport(Settings settings,Version version,ThreadPool threadPool,NetworkService networkService,PageCacheRecycler pageCacheRecycler,NamedWriteableRegistry namedWriteableRegistry,CircuitBreakerService circuitBreakerService){\n// bug_start\n  super(\"mock-nio\",settings,version,threadPool,pageCacheRecycler,circuitBreakerService,namedWriteableRegistry,networkService);\n// bug_end\n}\n"}
{"INPUT": "@BeforeClass public void beforeClass() throws Exception {\n  database.open(\"admin\",\"admin\");\n  final OSchema schema=database.getMetadata().getSchema();\n  final OClass testClass=schema.createClass(\"SQLSelectCompositeIndexDirectSearchTestClass\");\n  testClass.createProperty(\"prop1\",OType.INTEGER);\n  testClass.createProperty(\"prop2\",OType.INTEGER);\n  schema.save();\n  for (int i=0; i < 10; i++) {\n    for (int j=0; j < 10; j++) {\n// bug_start\n      final ODocument document=new ODocument(database,\"SQLSelectCompositeIndexDirectSearchTestClass\");\n// bug_end\n      document.field(\"prop1\",i);\n      document.field(\"prop2\",j);\n      document.save();\n      rids.add(document.getRecord().getIdentity());\n    }\n  }\n  database.command(new OCommandSQL(\"create index SQLSelectCompositeIndexDirectSearchTestIndex on SQLSelectCompositeIndexDirectSearchTestClass (prop1, prop2) NOTUNIQUE\")).execute();\n  database.close();\n}\n"}
{"INPUT": "@OnClick(R.id.upload) void upload(){\n// bug_start\n  Aria.upload(HttpUploadActivity.this).load(FILE_PATH).setUploadUrl(\"http://lib-test.xzxyun.com:8042/Api/upload?data={\\\"type\\\":\\\"1\\\",\\\"fileType\\\":\\\".apk\\\"}\").setRequestMode(RequestEnum.POST).start();\n// bug_end\n}\n"}
{"INPUT": "@Override public <A extends Arg>BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver buildRuleResolver,A args) throws NoSuchBuildTargetException {\n  BuildTarget target=params.getBuildTarget();\n  SourcePathResolver pathResolver=new SourcePathResolver(buildRuleResolver);\n  SymlinkTree sourceTree=buildRuleResolver.addToIndex(DDescriptionUtils.createSourceSymlinkTree(DDescriptionUtils.getSymlinkTreeTarget(params.getBuildTarget()),params,pathResolver,args.srcs));\n  BuildTarget binaryTarget=DDescriptionUtils.createBuildTargetForFile(target,\"build-\",target.getFullyQualifiedName(),cxxPlatform);\n  BuildRule binaryRule=DDescriptionUtils.createNativeLinkable(params.copyWithBuildTarget(binaryTarget),buildRuleResolver,cxxPlatform,dBuckConfig,cxxBuckConfig,ImmutableList.of(\"-unittest\"),args.srcs,args.linkerFlags.or(ImmutableList.<String>of()),DIncludes.builder().setLinkTree(new BuildTargetSourcePath(sourceTree.getBuildTarget())).addAllSources(args.srcs.getPaths()).build());\n// bug_start\n  return new DTest(params.appendExtraDeps(ImmutableList.of(binaryRule)),new SourcePathResolver(buildRuleResolver),binaryRule,args.contacts.get(),args.labels.get(),args.testRuleTimeoutMs.or(defaultTestRuleTimeoutMs),buildRuleResolver.getAllRules(args.sourceUnderTest.or(ImmutableSortedSet.<BuildTarget>of())));\n// bug_end\n}\n"}
{"INPUT": "protected void executeJob(final boolean unlock){\n  try {\n    jobServiceConfiguration.getCommandExecutor().execute(new Command<Void>(){\n      @Override public Void execute(      CommandContext commandContext){\n        new ExecuteAsyncJobCmd(jobId,jobEntityManager).execute(commandContext);\n        if (unlock) {\n          new UnlockExclusiveJobCmd((Job)job).execute(commandContext);\n        }\n        return null;\n      }\n    }\n);\n  }\n catch (  final FlowableOptimisticLockingException e) {\n// bug_start\n    handleFailedJob(e);\n// bug_end\n    if (LOGGER.isDebugEnabled()) {\n      LOGGER.debug(\"Optimistic locking exception during job execution. If you have multiple async executors running against the same database, \" + \"this exception means that this thread tried to acquire an exclusive job, which already was changed by another async executor thread.\" + \"This is expected behavior in a clustered environment. \"+ \"You can ignore this message if you indeed have multiple job executor threads running against the same database. \"+ \"Exception message: {}\",e.getMessage());\n    }\n  }\ncatch (  Throwable exception) {\n    handleFailedJob(exception);\n  }\n}\n"}
{"INPUT": "@Override public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){\n// bug_start\n  if (roundEnv.processingOver()) {\n    return true;\n// bug_end\n  }\n// bug_start\n  Set<? extends Element> elements=roundEnv.getElementsAnnotatedWith(XmlRootElement.class);\n  for (  Element element : elements) {\n    if (element instanceof TypeElement) {\n      processModelClass(roundEnv,(TypeElement)element);\n    }\n// bug_end\n  }\n  return true;\n}\n"}
{"INPUT": "protected final void assertMetadata(final Connection connection) throws IOException, JAXBException, SQLException {\n  if (null == assertion.getExpectedDataFile()) {\n    log.warn(\"Have empty expectedDataFile `{}`\",super.getSql());\n    return;\n  }\n  DataSet expected;\n  try (FileReader reader=new FileReader(getExpectedDataFile())){\n    expected=(DataSet)JAXBContext.newInstance(DataSet.class).createUnmarshaller().unmarshal(reader);\n  }\n   String tableName=assertion.getTable();\n  List<DataSetColumn> actualColumns=getActualColumns(connection,tableName);\n  List<DataSetIndex> actualIndexes=getActualIndexes(connection,tableName);\n  if (actualColumns.isEmpty() || actualIndexes.isEmpty()) {\n    assertIfDropTable(actualColumns);\n    assertIfDropIndex(actualIndexes);\n    return;\n  }\n// bug_start\n  assertMetadata(actualColumns,actualIndexes,expected.findMetadata(tableName));\n// bug_end\n}\n"}
{"INPUT": "@Test(dataProvider=\"bTypes\") public void serializeAndDeserializeBTypeTest(BType type,String source){\n  ConstantPool cp=new ConstantPool();\n  byte[] typeBinary=serializeBType(type,cp);\n  byte[] cpBinary=cp.serialize();\n// bug_start\n  BValue[] testParseTypes=executeTestFuncInBalx(typeBinary,cpBinary);\n  Assert.assertEquals(testParseTypes[0].stringValue(),source,\"Unable to recover type info from \" + Arrays.toString(typeBinary));\n// bug_end\n}\n"}
{"INPUT": "@Scheduled(fixedRate=5L * 60 * 1000) public void sync(){\n  Map<Long,Queue<DeferredResult<Object>>> oldMap=userIdToDeferredResultMap;\n  userIdToDeferredResultMap=new ConcurrentHashMap<Long,Queue<DeferredResult<Object>>>();\n  for (  Queue<DeferredResult<Object>> queue : oldMap.values()) {\n    if (queue == null) {\n      continue;\n    }\n    for (    DeferredResult<Object> deferredResult : queue) {\n// bug_start\n      deferredResult.setResult(\"\");\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "@Override public void run(){\n  for (int i=0; i < songPaths.size(); i++) {\n    String songPath=songPaths.get(i);\n    final int finalI=i;\n    runOnUiThread(new Runnable(){\n      @Override public void run(){\n        progressText.setText((finalI + 1) + \"/\" + songPaths.size());\n      }\n    }\n);\n    try {\n      AudioFile audioFile=AudioFileIO.read(new File(songPath));\n      Tag tag=audioFile.getTagOrCreateAndSetDefault();\n      for (      Map.Entry<FieldKey,String> entry : fieldKeyValueMap.entrySet()) {\n// bug_start\n        tag.setField(entry.getKey(),entry.getValue());\n// bug_end\n      }\n      if (deleteArtwork) {\n        tag.deleteArtworkField();\n      }\n else       if (artwork != null) {\n        tag.deleteArtworkField();\n        tag.setField(artwork);\n      }\n      audioFile.commit();\n    }\n catch (    CannotReadException|IOException|TagException|ReadOnlyFileException|InvalidAudioFrameException e) {\n      Log.e(TAG,\"Error while reading audio file.\",e);\n    }\ncatch (    CannotWriteException e) {\n      Log.e(TAG,\"Error while writing audio file.\",e);\n    }\n  }\n  if (deleteArtwork) {\n    String imagePath=MusicUtil.getAlbumArtUri(getId()).toString();\n    ImageLoader.getInstance().getDiskCache().remove(imagePath);\n    MemoryCacheUtils.removeFromCache(imagePath,ImageLoader.getInstance().getMemoryCache());\n    MusicUtil.deleteAlbumArt(AbsTagEditorActivity.this,getId());\n  }\n else   if (artwork != null) {\n    String imagePath=MusicUtil.getAlbumArtUri(getId()).toString();\n    MemoryCacheUtils.removeFromCache(imagePath,ImageLoader.getInstance().getMemoryCache());\n    ImageLoader.getInstance().getDiskCache().remove(imagePath);\n  }\n  progressDialog.dismiss();\n  rescanMedia();\n  restartApp();\n}\n"}
{"INPUT": "private static Object toAnnoType(Annotation anno,ClassPool cp) throws ClassNotFoundException {\n  try {\n    ClassLoader cl=cp.getClassLoader();\n    return anno.toAnnotationType(cl,cp);\n  }\n catch (  ClassNotFoundException e) {\n    ClassLoader cl2=cp.getClass().getClassLoader();\n// bug_start\n    return anno.toAnnotationType(cl2,cp);\n// bug_end\n  }\n}\n"}
{"INPUT": "@Override protected void onPause(){\n  super.onPause();\n  stopWaitingView();\n// bug_start\n  unregisterReceiver(mBrdRcvStopWaitingView);\n// bug_end\n  if (mSession.isAlive()) {\n    mSession.getDataHandler().removeListener(mEventsListener);\n  }\nsynchronized (this) {\n    if (null != mRoomCreationViewTimer) {\n      mRoomCreationViewTimer.cancel();\n      mRoomCreationViewTimer=null;\n    }\n  }\n  mRecentsListFragment.setIsDirectoryDisplayed(false);\n}\n"}
{"INPUT": "public final Number decimalValue(boolean decimal){\n  char chLocal=charAt(np + sp - 1);\n// bug_start\n  if (chLocal == 'F') {\n    return Float.parseFloat(numberString());\n// bug_end\n  }\n// bug_start\n  if (chLocal == 'D') {\n    return Double.parseDouble(numberString());\n  }\n  if (decimal) {\n    return decimalValue();\n  }\n else {\n    return doubleValue();\n// bug_end\n  }\n}\n"}
{"INPUT": "public void create(){\n  acquireExclusiveLock();\n  try {\n// bug_start\n    save(OMetadata.CLUSTER_INTERNAL_NAME);\n// bug_end\n    getDatabase().getStorage().getConfiguration().indexMgrRecordId=document.getIdentity().toString();\n    getDatabase().getStorage().getConfiguration().update();\n    createIndex(DICTIONARY_NAME,OClass.INDEX_TYPE.DICTIONARY.toString(),new OSimpleKeyIndexDefinition(OType.STRING),null,null);\n  }\n  finally {\n    releaseExclusiveLock();\n  }\n}\n"}
{"INPUT": "private String userObjectToString(Object o){\n  if (o == this) {\n    return \"this future\";\n  }\n// bug_start\n  return String.valueOf(o);\n// bug_end\n}\n"}
{"INPUT": "@Test public void test(){\n  UserEntity user=new UserEntity();\n  user.setName(\"test_man\");\n  user.setMis(\"test_group\");\n  user.setEmail(\"test_man@meituan.com\");\n// bug_start\n  userDao.insert(user);\n  UserEntity searchUser=userDao.searchUserById(user.getId());\n  System.out.println(searchUser.getName());\n  System.out.println(searchUser.getMis());\n  System.out.println(searchUser.getEmail());\n// bug_end\n}\n"}
{"INPUT": "private void serializeField(SerializationContext context,CodedOutputStream codedOut,Object obj,Class<?> type,long offset) throws SerializationException, IOException {\n  if (type.isPrimitive()) {\n    if (type.equals(boolean.class)) {\n      codedOut.writeBoolNoTag(UnsafeProvider.getInstance().getBoolean(obj,offset));\n    }\n else     if (type.equals(byte.class)) {\n      codedOut.writeRawByte(UnsafeProvider.getInstance().getByte(obj,offset));\n    }\n else     if (type.equals(short.class)) {\n      ByteBuffer buffer=ByteBuffer.allocate(2).putShort(UnsafeProvider.getInstance().getShort(obj,offset));\n      codedOut.writeRawBytes(buffer);\n    }\n else     if (type.equals(char.class)) {\n      ByteBuffer buffer=ByteBuffer.allocate(2).putChar(UnsafeProvider.getInstance().getChar(obj,offset));\n      codedOut.writeRawBytes(buffer);\n    }\n else     if (type.equals(int.class)) {\n      codedOut.writeInt32NoTag(UnsafeProvider.getInstance().getInt(obj,offset));\n    }\n else     if (type.equals(long.class)) {\n      codedOut.writeInt64NoTag(UnsafeProvider.getInstance().getLong(obj,offset));\n    }\n else     if (type.equals(float.class)) {\n      codedOut.writeFloatNoTag(UnsafeProvider.getInstance().getFloat(obj,offset));\n    }\n else     if (type.equals(double.class)) {\n      codedOut.writeDoubleNoTag(UnsafeProvider.getInstance().getDouble(obj,offset));\n    }\n else     if (type.equals(void.class)) {\n    }\n else {\n      throw new UnsupportedOperationException(\"Unknown primitive type: \" + type);\n    }\n  }\n else   if (type.isArray()) {\n    Object arr=UnsafeProvider.getInstance().getObject(obj,offset);\n    if (arr == null) {\n      codedOut.writeInt32NoTag(-1);\n      return;\n    }\n    int length=Array.getLength(arr);\n    codedOut.writeInt32NoTag(length);\n    int base=UnsafeProvider.getInstance().arrayBaseOffset(type);\n    int scale=UnsafeProvider.getInstance().arrayIndexScale(type);\n    if (scale == 0) {\n      throw new SerializationException(\"Failed to get index scale for type: \" + type);\n    }\n    for (int i=0; i < length; ++i) {\n      serializeField(context,codedOut,arr,type.getComponentType(),base + scale * i);\n    }\n  }\n else {\n// bug_start\n    context.serialize(UnsafeProvider.getInstance().getObject(obj,offset),codedOut);\n// bug_end\n  }\n}\n"}
{"INPUT": "public static synchronized void destroy(){\n// bug_start\n  if (instrumentInfo != null) {\n    instrumentInfo.reset();\n    for (    InstrumentClient client : clients) {\n      client.destroy();\n// bug_end\n    }\n  }\n// bug_start\n// bug_end\n}\n"}
{"INPUT": "@Override public void run(){\n  try {\n    Injector injector=makeInjector();\n    try {\n      final Lifecycle lifecycle=initLifecycle(injector);\n      final Thread hook=new Thread(new Runnable(){\n        @Override public void run(){\n          log.info(\"Running shutdown hook\");\n          lifecycle.stop();\n        }\n      }\n);\n      Runtime.getRuntime().addShutdownHook(hook);\n      injector.getInstance(ExecutorLifecycle.class).join();\n      final Set<Thread> threadSet=Thread.getAllStackTraces().keySet();\n      for (      Thread thread : threadSet) {\n        if (!thread.isDaemon() && thread != Thread.currentThread()) {\n          log.info(\"Thread [%s] is non daemon.\",thread);\n        }\n      }\n      lifecycle.stop();\n// bug_start\n      Runtime.getRuntime().removeShutdownHook(hook);\n// bug_end\n    }\n catch (    Throwable t) {\n      log.error(t,\"Error when starting up.  Failing.\");\n      System.exit(1);\n    }\n    log.info(\"Finished peon task\");\n  }\n catch (  Exception e) {\n    throw Throwables.propagate(e);\n  }\n}\n"}
{"INPUT": "public JSONObject postQuery(String query,String brokerBaseApiUrl) throws Exception {\n  final JSONObject json=new JSONObject();\n  json.put(\"pql\",query);\n  json.put(\"trace\",isTraceEnabled);\n  final long start=System.currentTimeMillis();\n  final URLConnection conn=new URL(brokerBaseApiUrl + \"/query\").openConnection();\n  conn.setDoOutput(true);\n  final BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(),\"UTF-8\"));\n  final String reqStr=json.toString();\n  writer.write(reqStr,0,reqStr.length());\n  writer.flush();\n  final BufferedReader reader=new BufferedReader(new InputStreamReader(conn.getInputStream(),\"UTF-8\"));\n  final StringBuilder sb=new StringBuilder();\n  String line=null;\n  while ((line=reader.readLine()) != null) {\n    sb.append(line);\n  }\n  final long stop=System.currentTimeMillis();\n  LOGGER.debug(\"Time taken for '{}':{}ms\",query,(stop - start));\n  final String res=sb.toString();\n// bug_start\n  final JSONObject ret=new JSONObject(res);\n  ret.put(\"totalTime\",(stop - start));\n  return ret;\n// bug_end\n}\n"}
{"INPUT": "@Test public void testFullHeader() throws Exception {\n  configureServer(new HelloWorldHandler());\n  try (Socket client=newSocket(_serverURI.getHost(),_serverURI.getPort());StacklessLogging stackless=new StacklessLogging(HttpConnection.class)){\n    Log.getLogger(HttpConnection.class).info(\"expect header is too large, then ISE extra data ...\");\n    OutputStream os=client.getOutputStream();\n    byte[] buffer=new byte[64 * 1024];\n    buffer[0]='G';\n    buffer[1]='E';\n    buffer[2]='T';\n    buffer[3]=' ';\n    buffer[4]='/';\n    buffer[5]=' ';\n    buffer[6]='H';\n    buffer[7]='T';\n    buffer[8]='T';\n    buffer[9]='P';\n    buffer[10]='/';\n    buffer[11]='1';\n    buffer[12]='.';\n    buffer[13]='0';\n    buffer[14]='\\n';\n    buffer[15]='H';\n    buffer[16]=':';\n    Arrays.fill(buffer,17,buffer.length - 1,(byte)'A');\n    os.write(buffer);\n    os.flush();\n// bug_start\n    String response=readResponse(client);\n    Assert.assertThat(response,Matchers.containsString(\"HTTP/1.1 431 \"));\n// bug_end\n  }\n }\n"}
{"INPUT": "protected ValidationResult validateIfAboveDust(String input){\n// bug_start\n  final Coin coin=Coin.parseCoin(input);\n  if (Restrictions.isAboveDust(coin))   return new ValidationResult(true);\n else   return new ValidationResult(false,Res.get(\"validation.btc.amountBelowDust\"));\n// bug_end\n}\n"}
{"INPUT": "private void doWorkLoop() throws Exception {\n  do {\n// bug_start\n    doWork();\n// bug_end\n  }\n while (autoRequeue.get() && (state.get() == State.STARTED) && !Thread.currentThread().isInterrupted());\n}\n"}
{"INPUT": "@Override public void onConfigurationChanged(Configuration newConfig){\n  super.onConfigurationChanged(newConfig);\n  int currentOrientation=newConfig.orientation;\n  int i=0;\n  if (rv.getLayoutManager() instanceof LinearLayoutManager && currentOrientation == Configuration.ORIENTATION_LANDSCAPE) {\n    if (rv.getAdapter() != null) {\n      i=((LinearLayoutManager)rv.getLayoutManager()).findFirstVisibleItemPosition();\n    }\n    final RecyclerView.LayoutManager mLayoutManager;\n    if (currentOrientation == Configuration.ORIENTATION_LANDSCAPE && SettingValues.tabletUI) {\n      mLayoutManager=new StaggeredGridLayoutManager(Reddit.dpWidth,StaggeredGridLayoutManager.VERTICAL);\n    }\n else     if (currentOrientation == Configuration.ORIENTATION_PORTRAIT && SettingValues.dualPortrait) {\n      mLayoutManager=new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL);\n    }\n else {\n      mLayoutManager=new PreCachingLayoutManager(getContext());\n    }\n    rv.setLayoutManager(mLayoutManager);\n  }\n else {\n    final RecyclerView.LayoutManager mLayoutManager;\n    if (rv.getAdapter() != null) {\n      if (rv.getLayoutManager() instanceof StaggeredGridLayoutManager) {\n        int[] firstVisibleItems=null;\n// bug_start\n        firstVisibleItems=((StaggeredGridLayoutManager)rv.getLayoutManager()).findFirstVisibleItemPositions(firstVisibleItems);\n// bug_end\n        if (firstVisibleItems != null && firstVisibleItems.length > 0) {\n          i=firstVisibleItems[0];\n        }\n      }\n else {\n        i=((PreCachingLayoutManager)rv.getLayoutManager()).findFirstCompletelyVisibleItemPosition();\n      }\n    }\n    if (currentOrientation == Configuration.ORIENTATION_LANDSCAPE && SettingValues.tabletUI) {\n      mLayoutManager=new StaggeredGridLayoutManager(Reddit.dpWidth,StaggeredGridLayoutManager.VERTICAL);\n    }\n else     if (currentOrientation == Configuration.ORIENTATION_PORTRAIT && SettingValues.dualPortrait) {\n      mLayoutManager=new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL);\n    }\n else {\n      mLayoutManager=new PreCachingLayoutManager(getContext());\n    }\n    rv.setLayoutManager(mLayoutManager);\n  }\n  rv.getLayoutManager().scrollToPosition(i);\n}\n"}
{"INPUT": "@Override public void onLoad(ItemGroup<? extends Item> parent,String name) throws IOException {\n  super.onLoad(parent,name);\n  if (buildMixIn == null) {\n    buildMixIn=createBuildMixIn();\n  }\n  buildMixIn.onLoad(parent,name);\n  builds=buildMixIn.getRunMap();\n  triggers().setOwner(this);\n  for (  Trigger t : triggers()) {\n// bug_start\n    t.start(this,Items.currentlyUpdatingByXml());\n// bug_end\n  }\n  if (scm == null)   scm=new NullSCM();\n  if (transientActions == null)   transientActions=new Vector<Action>();\n  updateTransientActions();\n}\n"}
{"INPUT": "@Override public Bundle call(Method method,Object[] args) throws InvocationTargetException, IllegalAccessException {\n  String methodName=(String)args[args.length - 3];\n  String arg=(String)args[args.length - 2];\n  int methodType=getMethodType(methodName);\n  if (METHOD_GET == methodType) {\n    String presetValue=PRE_SET_VALUES.get(arg);\n    if (presetValue != null) {\n      Bundle res=new Bundle();\n      res.putString(\"value\",presetValue);\n      return res;\n    }\n  }\n  if (METHOD_PUT == methodType) {\n    if (isSecureMethod(methodName)) {\n      return null;\n    }\n  }\n// bug_start\n  return super.call(method,args);\n// bug_end\n}\n"}
{"INPUT": "@Override public FsServerDefaults getServerDefaults(Path f) throws IOException {\n// bug_start\n  InodeTree.ResolveResult<FileSystem> res=fsState.resolve(getUriPath(f),true);\n  return res.targetFileSystem.getServerDefaults(res.remainingPath);\n// bug_end\n}\n"}
{"INPUT": "@Override public void sendRequest(final DiscoveryNode node,final long requestId,final String action,final TransportRequest request,TransportRequestOptions options) throws IOException, TransportException {\n  Channel targetChannel=nodeChannel(node,options);\n  if (compress) {\n    options=TransportRequestOptions.builder(options).withCompress(true).build();\n  }\n  byte status=0;\n  status=TransportStatus.setRequest(status);\n  ReleasableBytesStreamOutput bStream=new ReleasableBytesStreamOutput(bigArrays);\n  boolean addedReleaseListener=false;\n  StreamOutput stream=bStream;\n  try {\n    if (options.compress() && canCompress(request)) {\n      status=TransportStatus.setCompress(status);\n      stream=CompressorFactory.COMPRESSOR.streamOutput(stream);\n    }\n    Version version=Version.smallest(getCurrentVersion(),node.getVersion());\n    stream.setVersion(version);\n    threadPool.getThreadContext().writeTo(stream);\n    stream.writeString(action);\n    BytesReference message=buildMessage(requestId,status,node.getVersion(),request,stream,bStream);\n    final TransportRequestOptions finalOptions=options;\n    Runnable onRequestSent=null;\n// bug_start\n    sendMessage(targetChannel,message,onRequestSent,false);\n// bug_end\n    addedReleaseListener=true;\n  }\n  finally {\n    IOUtils.close(stream);\n    if (!addedReleaseListener) {\n      Releasables.close(bStream.bytes());\n    }\n  }\n}\n"}
{"INPUT": "private static int compareToWithEqualityCheck(Object left,Object right,boolean equalityCheckOnly){\n  if (left == right) {\n    return 0;\n  }\n  if (left == null) {\n    return -1;\n  }\n else   if (right == null) {\n    return 1;\n  }\n  if (left instanceof Comparable) {\n    if (left instanceof Number) {\n      if (right instanceof Character || right instanceof Number) {\n        return DefaultGroovyMethods.compareTo((Number)left,castToNumber(right));\n      }\n      if (isValidCharacterString(right)) {\n        return DefaultGroovyMethods.compareTo((Number)left,ShortTypeHandling.castToChar(right));\n      }\n    }\n else     if (left instanceof Character) {\n      if (isValidCharacterString(right)) {\n        return DefaultGroovyMethods.compareTo((Character)left,ShortTypeHandling.castToChar(right));\n      }\n      if (right instanceof Number) {\n        return DefaultGroovyMethods.compareTo((Character)left,(Number)right);\n      }\n    }\n else     if (right instanceof Number) {\n      if (isValidCharacterString(left)) {\n        return DefaultGroovyMethods.compareTo(ShortTypeHandling.castToChar(left),(Number)right);\n      }\n    }\n else     if (left instanceof String && right instanceof Character) {\n      return ((String)left).compareTo(right.toString());\n    }\n else     if (left instanceof String && right instanceof GString) {\n      return ((String)left).compareTo(right.toString());\n    }\n    if (!equalityCheckOnly || left.getClass().isAssignableFrom(right.getClass()) || (right.getClass() != Object.class && right.getClass().isAssignableFrom(left.getClass()))|| (left instanceof GString && right instanceof String)) {\n      Comparable comparable=(Comparable)left;\n// bug_start\n      return comparable.compareTo(right);\n// bug_end\n    }\n  }\n  if (equalityCheckOnly) {\n    return -1;\n  }\n  throw new GroovyRuntimeException(MessageFormat.format(\"Cannot compare {0} with value ''{1}'' and {2} with value ''{3}''\",left.getClass().getName(),left,right.getClass().getName(),right));\n}\n"}
{"INPUT": "@Override public View onCreateView(View parent,String name,Context context,AttributeSet attrs){\n  Activity activity=mActivityWeakReference.get();\n  View view=null;\n  if (activity instanceof AppCompatActivity) {\n    view=((AppCompatActivity)activity).getDelegate().createView(parent,name,context,attrs);\n  }\n  if (view == null) {\n    try {\n      if (!name.contains(\".\")) {\n        if (sSuccessClassNamePrefixMap.containsKey(name)) {\n          view=mOriginLayoutInflater.createView(name,sSuccessClassNamePrefixMap.get(name),attrs);\n        }\n else {\n          for (          String prefix : sClassPrefixList) {\n// bug_start\n            view=mOriginLayoutInflater.createView(name,prefix,attrs);\n            if (view != null) {\n              sSuccessClassNamePrefixMap.put(name,prefix);\n              break;\n// bug_end\n            }\n          }\n        }\n      }\n else {\n        view=mOriginLayoutInflater.cloneInContext(context).createView(name,null,attrs);\n      }\n    }\n catch (    ClassNotFoundException ignore) {\n    }\ncatch (    Exception e) {\n      QMUILog.e(TAG,\"Failed to inflate view \" + name + \"; error: \"+ e.getMessage());\n    }\n  }\n  if (view != null) {\n    QMUISkinValueBuilder builder=QMUISkinValueBuilder.acquire();\n    getSkinValueFromAttributeSet(view.getContext(),attrs,builder);\n    if (!builder.isEmpty()) {\n      QMUISkinHelper.setSkinValue(view,builder);\n    }\n    QMUISkinValueBuilder.release(builder);\n  }\n  return view;\n}\n"}
{"INPUT": "@Override @Nullable public Authorization call() throws IOException, NonexistentDockerCredentialHelperException {\n  try (Timer ignored=new Timer(buildConfiguration.getBuildLogger(),String.format(DESCRIPTION,buildConfiguration.getTargetRegistry()))){\n    for (    String credentialHelperSuffix : buildConfiguration.getCredentialHelperNames()) {\n      Authorization authorization=retrieveFromCredentialHelper(credentialHelperSuffix);\n      if (authorization != null) {\n        return authorization;\n      }\n    }\n    String credentialSource=buildConfiguration.getKnownRegistryCredentials().getCredentialSource(registry);\n    if (credentialSource != null) {\n      logGotCredentialsFrom(credentialSource);\n      return buildConfiguration.getKnownRegistryCredentials().getAuthorization(registry);\n    }\n// bug_start\n    Authorization dockerConfigAuthorization=dockerConfigCredentialRetriever.retrieve();\n    if (dockerConfigAuthorization != null) {\n      buildConfiguration.getBuildLogger().info(\"Using credentials from Docker config for \" + registry);\n      return dockerConfigAuthorization;\n// bug_end\n    }\n    for (    String registrySuffix : COMMON_CREDENTIAL_HELPERS.keySet()) {\n      if (registry.endsWith(registrySuffix)) {\n        try {\n          String commonCredentialHelper=COMMON_CREDENTIAL_HELPERS.get(registrySuffix);\n          if (commonCredentialHelper == null) {\n            throw new IllegalStateException(\"No COMMON_CREDENTIAL_HELPERS should be null\");\n          }\n          Authorization authorization=retrieveFromCredentialHelper(commonCredentialHelper);\n          if (authorization != null) {\n            return authorization;\n          }\n        }\n catch (        NonexistentDockerCredentialHelperException ex) {\n          if (ex.getMessage() != null) {\n            buildConfiguration.getBuildLogger().warn(ex.getMessage());\n          }\n        }\n      }\n    }\n    buildConfiguration.getBuildLogger().info(\"No credentials could be retrieved for registry \" + registry);\n    return null;\n  }\n }\n"}
{"INPUT": "static void installContext(SecurityConfiguration config) throws Exception {\n  for (  String contextFactoryClass : config.getSecurityContextFactories()) {\n    try {\n      SecurityContextFactory contextFactory=SecurityFactoryServiceLoader.findContextFactory(contextFactoryClass);\n      if (contextFactory.isCompatibleWith(config)) {\n// bug_start\n        installedContext=contextFactory.createContext(config);\n        break;\n// bug_end\n      }\n else {\n        LOG.warn(\"Unable to install incompatible security context factory {}\",contextFactoryClass);\n      }\n    }\n catch (    NoMatchSecurityFactoryException ne) {\n      LOG.warn(\"Unable to instantiate security context factory {}\",contextFactoryClass);\n    }\n  }\n  if (installedContext == null) {\n    LOG.error(\"Unable to install a valid security context factory!\");\n    throw new Exception(\"Unable to install a valid security context factory!\");\n  }\n}\n"}
{"INPUT": "public void checkCodeValidation(){\n  editor.goToCursorPositionVisible(24,12);\n  for (int i=0; i < 9; i++) {\n    editor.typeTextIntoEditor(BACK_SPACE.toString());\n  }\n// bug_start\n  editor.waitMarkerInPosition(INFO,23);\n// bug_end\n  editor.waitMarkerInPosition(ERROR,21);\n  checkAutocompletion();\n}\n"}
{"INPUT": "@SuppressWarnings(\"unused\") private static void callChangeCallbacks(){\nsynchronized (sChangeCallbacks) {\n    if (sChangeCallbacks.size() == 0) {\n      return;\n    }\n    ArrayList<Runnable> callbacks=new ArrayList<Runnable>(sChangeCallbacks);\n    for (int i=0; i < callbacks.size(); i++) {\n// bug_start\n      callbacks.get(i).run();\n// bug_end\n    }\n  }\n}\n"}
{"INPUT": "private boolean installApksInSession(@NonNull PackageInstallerSession session){\n  if (!session.isMultiPackage() && !isApexSession(session)) {\n    PackageInstallerSession apkSession=createAndWriteApkSession(session);\n    if (apkSession == null) {\n      return false;\n    }\n    return commitApkSession(apkSession,session.sessionId);\n  }\n else   if (session.isMultiPackage()) {\n    List<PackageInstallerSession> childSessions;\nsynchronized (mStagedSessions) {\n      childSessions=Arrays.stream(session.getChildSessionIds()).mapToObj(null).filter(null).collect(Collectors.toList());\n    }\n    if (childSessions.isEmpty()) {\n      return true;\n    }\n    PackageInstaller.SessionParams params=session.params.copy();\n    params.isStaged=false;\n    int apkParentSessionId=mPi.createSession(params,session.getInstallerPackageName(),session.userId);\n    PackageInstallerSession apkParentSession=mPi.getSession(apkParentSessionId);\n    try {\n      apkParentSession.open();\n    }\n catch (    IOException e) {\n      Slog.e(TAG,\"Unable to prepare multi-package session for staged session \" + session.sessionId);\n      return false;\n    }\n    for (    PackageInstallerSession sessionToClone : childSessions) {\n      PackageInstallerSession apkChildSession=createAndWriteApkSession(sessionToClone);\n      if (apkChildSession == null) {\n        return false;\n      }\n// bug_start\n      apkParentSession.addChildSessionId(apkChildSession.sessionId);\n// bug_end\n    }\n    return commitApkSession(apkParentSession,session.sessionId);\n  }\n  return true;\n}\n"}
{"INPUT": "public static void shutdown(FactoryImpl factory){\nsynchronized (factoryLock) {\n// bug_start\n    ManagementService.unregister(factory);\n// bug_end\n    factory.node.shutdown();\n    factories.remove(factory.getName());\n  }\n}\n"}
{"INPUT": "public LongValue(final String value){\n  String val=value;\n  if (val.charAt(0) == '+') {\n    val=val.substring(1);\n  }\n// bug_start\n  this.value=Long.parseLong(val);\n// bug_end\n  this.stringValue=val;\n}\n"}
{"INPUT": "@Override public void onDictionaryLoadingDone(Dictionary dictionary){\n  final int expectedDictionaries=mExpectedDictionaries.decrementAndGet();\n  Logger.d(\"WordListDictionaryListener\",\"onDictionaryLoadingDone for %s\",dictionary);\n// bug_start\n  char[][] words=dictionary.getWords();\n  if (words != null && words.length > 0) {\n    mWords.add(words);\n// bug_end\n  }\n// bug_start\n  Logger.d(\"WordListDictionaryListener\",\"onDictionaryLoadingDone got words with length %d\",(words == null ? 0 : words.length));\n// bug_end\n  if (expectedDictionaries == 0)   doCallback();\n}\n"}
{"INPUT": "@RequiresApi(Build.VERSION_CODES.O) public void createIcon(Context context){\n  ShortcutManager shortcutManager=context.getSystemService(ShortcutManager.class);\n  ShortcutInfo info=new ShortcutInfo.Builder(context,Long.toString(mContextMenuDid)).setIntent(new Intent(context,Reviewer.class).setAction(Intent.ACTION_VIEW).putExtra(\"deckId\",mContextMenuDid)).setShortLabel(Decks.basename(getCol().getDecks().name(mContextMenuDid))).setLongLabel(getCol().getDecks().name(mContextMenuDid)).setIcon(Icon.createWithResource(context,R.mipmap.ic_launcher)).build();\n// bug_start\n  shortcutManager.requestPinShortcut(info,null);\n// bug_end\n}\n"}
{"INPUT": "@Override public ByteBuffer read(long offset,long length) throws IOException {\n  Preconditions.checkState(!mClosed);\n  updateUnderFileSystemInputStream(offset);\n  updateBlockWriter(offset);\n  long bytesToRead=Math.min(length,mBlockMeta.getBlockSize() - offset);\n  if (bytesToRead <= 0) {\n    return ByteBuffer.allocate(0);\n  }\n  byte[] data=new byte[(int)bytesToRead];\n  int bytesRead=0;\n  Preconditions.checkNotNull(mUnderFileSystemInputStream);\n  while (bytesRead < bytesToRead) {\n    int read;\n    try {\n      read=mUnderFileSystemInputStream.read(data,bytesRead,(int)(bytesToRead - bytesRead));\n    }\n catch (    IOException e) {\n      throw AlluxioStatusException.fromIOException(e);\n    }\n    if (read == -1) {\n      break;\n    }\n    bytesRead+=read;\n  }\n  mInStreamPos+=bytesRead;\n  Preconditions.checkState(bytesRead == bytesToRead,PreconditionMessage.NOT_ENOUGH_BYTES_READ.toString(),bytesRead,bytesToRead,mBlockMeta.getUnderFileSystemPath());\n  if (mBlockWriter != null && mBlockWriter.getPosition() < mInStreamPos) {\n    try {\n      Preconditions.checkState(mBlockWriter.getPosition() >= offset);\n      mLocalBlockStore.requestSpace(mBlockMeta.getSessionId(),mBlockMeta.getBlockId(),mInStreamPos - mBlockWriter.getPosition());\n      ByteBuffer buffer=ByteBuffer.wrap(data,(int)(mBlockWriter.getPosition() - offset),(int)(mInStreamPos - mBlockWriter.getPosition()));\n      mBlockWriter.append(buffer.duplicate());\n    }\n catch (    Exception e) {\n      LOG.warn(\"Failed to cache data read from UFS (on read()): {}\",e.getMessage());\n// bug_start\n      cancelBlockWriter();\n// bug_end\n    }\n  }\n  return ByteBuffer.wrap(data,0,bytesRead);\n}\n"}
{"INPUT": "// bug_start\n@Override public void log(String tag,String message,Exception exception){\n// bug_end\n  if (logLevel > LOG_NONE) {\n    System.out.println(\"[info] \" + tag + \": \"+ message);\n    exception.printStackTrace();\n  }\n}\n"}
{"INPUT": "public void testKitsTrackerCallable() throws Exception {\n// bug_start\n  Class clazz=getClass().getClassLoader().loadClass(\"org.netbeans.modules.editor.lib.KitsTracker\");\n// bug_end\n  Method getInstanceMethod=clazz.getDeclaredMethod(\"getInstance\");\n  Method findMimeTypeMethod=clazz.getDeclaredMethod(\"findMimeType\",Class.class);\n  Object kitsTracker=getInstanceMethod.invoke(null);\n  String mimeType=(String)findMimeTypeMethod.invoke(kitsTracker,EditorKit.class);\n  assertNull(\"EditorKit.class should not have a mime type\",mimeType);\n}\n"}
{"INPUT": "private void putUnknownInfo(Map<String,Object> meta) throws AndrolibException {\n// bug_start\n  Map<String,String> info=mAndrolib.mResUnknownFiles.getUnknownFiles();\n// bug_end\n  if (info.size() > 0) {\n    meta.put(\"unknownFiles\",info);\n  }\n}\n"}
{"INPUT": "@Override public OpenSSLALPNMethods run(){\n  try {\n    Class<?> openSSLEngine=Class.forName(OPENSSL_ENGINE,true,OpenSSLAlpnProvider.class.getClassLoader());\n    Method setApplicationProtocols=openSSLEngine.getMethod(\"setApplicationProtocols\",String[].class);\n    Method getApplicationProtocol=openSSLEngine.getMethod(\"getSelectedApplicationProtocol\");\n    UndertowLogger.ROOT_LOGGER.debug(\"OpenSSL ALPN Enabled\");\n    return new OpenSSLALPNMethods(setApplicationProtocols,getApplicationProtocol);\n  }\n// bug_start\n catch (  Exception e) {\n// bug_end\n    UndertowLogger.ROOT_LOGGER.debug(\"OpenSSL ALPN Enabled\",e);\n    return null;\n  }\n}\n"}
{"INPUT": "// bug_start\npublic void createTable(final IDBI dbi,final String tableName,final List<String> sql){\n// bug_end\n  try {\n    dbi.withHandle(new HandleCallback<Void>(){\n      @Override public Void withHandle(      Handle handle) throws Exception {\n        if (!tableExists(handle,tableName)) {\n          log.info(\"Creating table[%s]\",tableName);\n          final Batch batch=handle.createBatch();\n          for (          String s : sql) {\n            batch.add(s);\n          }\n          batch.execute();\n        }\n else {\n          log.info(\"Table[%s] already exists\",tableName);\n        }\n        return null;\n      }\n    }\n);\n  }\n catch (  Exception e) {\n    log.warn(e,\"Exception creating table\");\n  }\n}\n"}
{"INPUT": "// bug_start\npublic static DocumentationStringNode createDocumentationStringNode(NodeList<Token> documentationLines){\n// bug_end\n  Objects.requireNonNull(documentationLines,\"documentationLines must not be null\");\n  STNode stDocumentationStringNode=STNodeFactory.createDocumentationStringNode(documentationLines.underlyingListNode().internalNode());\n  return stDocumentationStringNode.createUnlinkedFacade();\n}\n"}
{"INPUT": "public void execute() throws Exception {\n  if (registry == null) {\n    registry=Registry.getRegistry(null,null);\n  }\n  InputStream stream=(InputStream)source;\n// bug_start\n  ArrayList<ManagedBean> loadedMbeans=new ArrayList<>();\n// bug_end\nsynchronized (dLock) {\n    if (digester == null) {\n      digester=createDigester();\n    }\n    try {\n      digester.push(loadedMbeans);\n      digester.parse(stream);\n    }\n catch (    Exception e) {\n      log.error(\"Error digesting Registry data\",e);\n      throw e;\n    }\n finally {\n      digester.reset();\n    }\n  }\n  Iterator<ManagedBean> iter=loadedMbeans.iterator();\n  while (iter.hasNext()) {\n    registry.addManagedBean(iter.next());\n  }\n}\n"}
{"INPUT": "public void setAll(Properties properties){\n// bug_start\n  Enumeration names=properties.propertyNames();\n// bug_end\n  while (names.hasMoreElements()) {\n    String name=(String)names.nextElement();\n    metadata.put(name,new String[]{properties.getProperty(name)});\n  }\n}\n"}
{"INPUT": "public void addMessage(Message packet){\n  Type strategyType;\n  int strategyMaxNumber;\n  if (type == Type.defaulType && parent != null) {\n    strategyType=parent.getType();\n    strategyMaxNumber=parent.getMaxNumber();\n  }\n else {\n    strategyType=type;\n    strategyMaxNumber=maxNumber;\n  }\n  boolean subjectChange=false;\n  if (packet.getSubject() != null && packet.getSubject().length() > 0) {\n    subjectChange=true;\n    roomSubject=packet;\n  }\n  if (strategyType == Type.none) {\n    if (subjectChange) {\n      history.clear();\n      history.add(packet);\n    }\n  }\n else   if (strategyType == Type.all) {\n    history.add(packet);\n  }\n else   if (strategyType == Type.number) {\n    if (history.size() >= strategyMaxNumber) {\n// bug_start\n      Iterator historyIter=history.iterator();\n// bug_end\n      while (historyIter.hasNext() && history.size() > strategyMaxNumber) {\n        if (historyIter.next() != roomSubject) {\n          historyIter.remove();\n        }\n      }\n    }\n    history.add(packet);\n  }\n}\n"}
{"INPUT": "// bug_start\npublic SourceSimpleFragmentsBuilder(FieldMapper<?> mapper,SearchContext searchContext,FetchSubPhase.HitContext hitContext,String[] preTags,String[] postTags,BoundaryScanner boundaryScanner){\n// bug_end\n  super(mapper,preTags,postTags,boundaryScanner);\n  this.searchContext=searchContext;\n  this.hitContext=hitContext;\n}\n"}
{"INPUT": "public void testModifyFieldsOutsideArray() throws Exception {\n  List<Object> values=new ArrayList<>();\n  values.add(\"string\");\n  values.add(1);\n  values.add(null);\n  IngestDocument ingestDocument=new IngestDocument(\"_index\",\"_type\",\"_id\",null,null,null,null,Collections.singletonMap(\"values\",values));\n  TemplateService ts=TestTemplateService.instance();\n  ForEachProcessor processor=new ForEachProcessor(\"_tag\",\"values\",new CompoundProcessor(false,Collections.singletonList(new UppercaseProcessor(\"_tag_upper\",\"_ingest._value\")),Collections.singletonList(new AppendProcessor(\"_tag\",ts.compile(\"errors\"),null))));\n  processor.execute(ingestDocument);\n// bug_start\n  List<String> result=ingestDocument.getFieldValue(\"values\",List.class);\n// bug_end\n  assertThat(result.get(0),equalTo(\"STRING\"));\n  assertThat(result.get(1),equalTo(1));\n  assertThat(result.get(2),equalTo(null));\n  List<String> errors=ingestDocument.getFieldValue(\"errors\",List.class);\n  assertThat(errors.size(),equalTo(2));\n}\n"}
{"INPUT": "// bug_start\n@Override protected void handleResponse(Response response,Request request){\n// bug_end\n  if (response.isOk())   request.onSuccess(null);\n else   request.onFailure(response);\n}\n"}
{"INPUT": "// bug_start\npublic DefaultProjectGenerationController(InitializrMetadataProvider metadataProvider,ProjectGenerationInvoker projectGenerationInvoker){\n// bug_end\n  super(metadataProvider,projectGenerationInvoker);\n}\n"}
{"INPUT": "// bug_start\npublic SStore(PathMetadata<?> metadata){\n// bug_end\n  super(SStore.class,metadata,\"\",\"store_\");\n  addMetadata();\n}\n"}
{"INPUT": "@Test public void testHandSQL(){\n  Session s=openSession();\n  Transaction t=s.beginTransaction();\n  Organization ifa=new Organization(\"IFA\");\n  Organization jboss=new Organization(\"JBoss\");\n  Person gavin=new Person(\"Gavin\");\n  Employment emp=new Employment(gavin,jboss,\"AU\");\n// bug_start\n  Serializable orgId=s.save(jboss);\n// bug_end\n  s.save(ifa);\n  s.save(gavin);\n  s.save(emp);\n  t.commit();\n  t=s.beginTransaction();\n  Person christian=new Person(\"Christian\");\n  s.save(christian);\n  Employment emp2=new Employment(christian,jboss,\"EU\");\n  s.save(emp2);\n  t.commit();\n  s.close();\n  sessionFactory().getCache().evictEntityRegion(Organization.class);\n  sessionFactory().getCache().evictEntityRegion(Person.class);\n  sessionFactory().getCache().evictEntityRegion(Employment.class);\n  s=openSession();\n  t=s.beginTransaction();\n  jboss=(Organization)s.get(Organization.class,orgId);\n  assertEquals(jboss.getEmployments().size(),2);\n  assertEquals(jboss.getName(),\"JBOSS\");\n  emp=(Employment)jboss.getEmployments().iterator().next();\n  gavin=emp.getEmployee();\n  assertEquals(\"GAVIN\",gavin.getName());\n  assertEquals(LockMode.UPGRADE,s.getCurrentLockMode(gavin));\n  emp.setEndDate(new Date());\n  Employment emp3=new Employment(gavin,jboss,\"US\");\n  s.save(emp3);\n  t.commit();\n  s.close();\n  s=openSession();\n  t=s.beginTransaction();\n  Iterator itr=s.getNamedQuery(\"allOrganizationsWithEmployees\").list().iterator();\n  assertTrue(itr.hasNext());\n  Organization o=(Organization)itr.next();\n  assertEquals(o.getEmployments().size(),3);\n  Iterator itr2=o.getEmployments().iterator();\n  while (itr2.hasNext()) {\n    Employment e=(Employment)itr2.next();\n    s.delete(e);\n  }\n  itr2=o.getEmployments().iterator();\n  while (itr2.hasNext()) {\n    Employment e=(Employment)itr2.next();\n    s.delete(e.getEmployee());\n  }\n  s.delete(o);\n  assertFalse(itr.hasNext());\n  s.delete(ifa);\n  t.commit();\n  s.close();\n}\n"}
{"INPUT": "// bug_start\n@Override public boolean shouldReplicate(FieldMetadata field,boolean initial,boolean toOwner){\n// bug_end\nswitch (field.getName()) {\ncase \"lightDiffuseIntensity\":\ncase \"lightAmbientIntensity\":\n    return initial || !simulateFading;\n}\nreturn true;\n}\n"}
{"INPUT": "// bug_start\npublic static void parseField(FieldMapper.Builder<?> builder,String name,Map<String,Object> fieldNode,Mapper.TypeParser.ParserContext parserContext){\n// bug_end\n  for (Iterator<Map.Entry<String,Object>> iterator=fieldNode.entrySet().iterator(); iterator.hasNext(); ) {\n    Map.Entry<String,Object> entry=iterator.next();\n    final String propName=entry.getKey();\n    final Object propNode=entry.getValue();\n    checkNull(propName,propNode);\n    if (propName.equals(\"store\")) {\n      builder.store(XContentMapValues.nodeBooleanValue(propNode,name + \".store\"));\n      iterator.remove();\n    }\n else     if (propName.equals(\"meta\")) {\n      builder.meta(parseMeta(name,propNode));\n      iterator.remove();\n    }\n else     if (propName.equals(\"index\")) {\n      builder.index(XContentMapValues.nodeBooleanValue(propNode,name + \".index\"));\n      iterator.remove();\n    }\n else     if (propName.equals(DOC_VALUES)) {\n      builder.docValues(XContentMapValues.nodeBooleanValue(propNode,name + \".\" + DOC_VALUES));\n      iterator.remove();\n    }\n else     if (propName.equals(\"boost\")) {\n      if (parserContext.indexVersionCreated().before(Version.V_8_0_0)) {\n        deprecationLogger.deprecate(\"boost\",\"Parameter [boost] on field [{}] is deprecated and has no effect\",name);\n        iterator.remove();\n      }\n else {\n        throw new MapperParsingException(\"Unknown parameter [boost] on mapper [\" + name + \"]\");\n      }\n    }\n else     if (propName.equals(\"index_options\")) {\n      builder.indexOptions(nodeIndexOptionValue(propNode));\n      iterator.remove();\n    }\n else     if (propName.equals(\"similarity\")) {\n      deprecationLogger.deprecate(\"similarity\",\"The [similarity] parameter has no effect on field [\" + name + \"] and will be removed in 8.0\");\n      iterator.remove();\n    }\n else     if (parseMultiField(null,name,parserContext,propName,propNode)) {\n      iterator.remove();\n    }\n else     if (propName.equals(\"copy_to\")) {\n      if (parserContext.isWithinMultiField()) {\n        throw new MapperParsingException(\"copy_to in multi fields is not allowed. Found the copy_to in field [\" + name + \"] \"+ \"which is within a multi field.\");\n      }\n else {\n        List<String> copyFields=parseCopyFields(propNode);\n        FieldMapper.CopyTo.Builder cpBuilder=new FieldMapper.CopyTo.Builder();\n        copyFields.forEach(null);\n        builder.copyTo(cpBuilder.build());\n      }\n      iterator.remove();\n    }\n  }\n}\n"}
{"INPUT": "// bug_start\npublic SqmCaseSearched(BasicValuedExpressableType<R> inherentType,NodeBuilder nodeBuilder){\n// bug_end\n  super(inherentType,nodeBuilder);\n}\n"}
{"INPUT": "// bug_start\nCombinedFutureRunningState(ImmutableCollection<? extends ListenableFuture<? extends Object>> futures,boolean allMustSucceed,CombinedFutureInterruptibleTask task){\n// bug_end\n  super(futures,allMustSucceed,false);\n  this.task=task;\n}\n"}
{"INPUT": "private void createDatabaseIfNecessary(){\n  if (!config.autoCreateDb())   return;\n  HttpURLConnection con=null;\n  try {\n    URL queryEndpoint=URI.create(config.uri() + \"/query?q=\" + URLEncoder.encode(\"CREATE DATABASE \\\"\" + config.db() + \"\\\"\",\"UTF-8\")).toURL();\n    con=(HttpURLConnection)queryEndpoint.openConnection();\n    con.setConnectTimeout((int)config.connectTimeout().toMillis());\n    con.setReadTimeout((int)config.readTimeout().toMillis());\n    con.setRequestMethod(\"POST\");\n    authenticateRequest(con);\n    int status=con.getResponseCode();\n    if (status >= 200 && status < 300) {\n      logger.debug(\"influx database {} is ready to receive metrics\",config.db());\n    }\n else     if (status >= 400) {\n      try (InputStream in=con.getErrorStream()){\n        logger.error(\"unable to create database '{}': {}\",config.db(),new BufferedReader(new InputStreamReader(in)).lines().collect(joining(\"\\n\")));\n      }\n     }\n  }\n// bug_start\n catch (  IOException e) {\n// bug_end\n    logger.warn(\"unable to create database '{}'\",config.db(),e);\n  }\n finally {\n    quietlyCloseUrlConnection(con);\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){\n// bug_end\n  GraphTargetItem a=stack.pop();\n  stack.push(new MBCharToAsciiActionItem(this,a));\n}\n"}
{"INPUT": "// bug_start\npublic GithubRepository(GHRepository ghRepository,StandardUsernamePasswordCredentials credentials,Reachable parent){\n// bug_end\n  this.ghRepository=ghRepository;\n  this.credentials=credentials;\n  this.self=parent.getLink().rel(ghRepository.getName());\n}\n"}
{"INPUT": "// bug_start\npublic AsExternalTypeDeserializer(JavaType bt,TypeIdResolver idRes,String typePropertyName,boolean typeIdVisible,Class<?> defaultImpl){\n// bug_end\n  super(bt,idRes,typePropertyName,typeIdVisible,defaultImpl);\n}\n"}
{"INPUT": "// bug_start\npublic void startScan(BleScanCallback<T> callback,int scanPeriod){\n// bug_end\n  if (mScanning)   return;\n  if (callback != null) {\n    mScanCallback=callback;\n  }\n  mScanning=true;\n  BleHandler.of().postDelayed(new Runnable(){\n    @Override public void run(){\n      if (mScanning) {\n        stopScan();\n      }\n    }\n  }\n,scanPeriod);\n  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\n    mBluetoothAdapter.startLeScan(mLeScanCallback);\n  }\n else {\n    if (mBluetoothAdapter.isEnabled()) {\n      if (mScanner == null) {\n        mScanner=mBluetoothAdapter.getBluetoothLeScanner();\n      }\n      mScanner.startScan(mFilters,mScannerSetting,mScannerCallback);\n    }\n  }\n  if (callback != null) {\n    mScanCallback.onStart();\n  }\n}\n"}
{"INPUT": "// bug_start\npublic void registerThrowable(RetryContext context,Exception throwable){\n// bug_end\n  SimpleRetryContext simpleContext=((SimpleRetryContext)context);\n  simpleContext.registerThrowable(throwable);\n}\n"}
{"INPUT": "@Override public void invoke(NSNotification a){\n// bug_start\n  NSDictionary<NSString,NSObject> data=a.getUserInfo();\n// bug_end\n  NSError error=null;\n  if (data.containsKey(FailedToDecodeNotificationErrorKey())) {\n    error=(NSError)data.get(FailedToDecodeNotificationErrorKey());\n  }\n  block.invoke((AVSampleBufferDisplayLayer)a.getObject(),error);\n}\n"}
{"INPUT": "// bug_start\n@Override public BaseFunction repositoryRule(BaseFunction implementation,Object attrs,Boolean local,SkylarkList<String> environ,Boolean configure,String doc,FuncallExpression ast,StarlarkThread funcallThread) throws EvalException {\n// bug_end\n  SkylarkUtils.checkLoadingOrWorkspacePhase(funcallThread,\"repository_rule\",ast.getLocation());\n  RuleClass.Builder builder=new RuleClass.Builder(\"\",RuleClassType.WORKSPACE,true);\n  builder.addOrOverrideAttribute(attr(\"$local\",BOOLEAN).defaultValue(local).build());\n  builder.addOrOverrideAttribute(attr(\"$configure\",BOOLEAN).defaultValue(configure).build());\n  builder.addOrOverrideAttribute(attr(\"$environ\",STRING_LIST).defaultValue(environ).build());\n  BaseRuleClasses.nameAttribute(builder);\n  BaseRuleClasses.commonCoreAndSkylarkAttributes(builder);\n  builder.add(attr(\"expect_failure\",STRING));\n  if (attrs != Runtime.NONE) {\n    for (    Map.Entry<String,Descriptor> attr : castMap(attrs,String.class,Descriptor.class,\"attrs\").entrySet()) {\n      Descriptor attrDescriptor=attr.getValue();\n      AttributeValueSource source=attrDescriptor.getValueSource();\n      String attrName=source.convertToNativeName(attr.getKey(),ast.getLocation());\n      builder.addOrOverrideAttribute(attrDescriptor.build(attrName));\n    }\n  }\n  builder.setConfiguredTargetFunction(implementation);\n  builder.setRuleDefinitionEnvironmentLabelAndHashCode((Label)funcallThread.getGlobals().getLabel(),funcallThread.getTransitiveContentHashCode());\n  builder.setWorkspaceOnly();\n  return new RepositoryRuleFunction(builder,ast.getLocation());\n}\n"}
{"INPUT": "@Test public void testAbortBeforeQueued() throws Exception {\n  start(new EmptyServerHandler());\n  Exception failure=new Exception(\"oops\");\n  try {\n    Request request=client.newRequest(\"localhost\",connector.getLocalPort()).scheme(scheme).timeout(5,TimeUnit.SECONDS);\n    request.abort(failure);\n    request.send();\n    Assert.fail();\n  }\n catch (  ExecutionException x) {\n    Assert.assertSame(failure,x.getCause());\n    HttpDestinationOverHTTP destination=(HttpDestinationOverHTTP)client.getDestination(scheme,\"localhost\",connector.getLocalPort());\n// bug_start\n    ConnectionPool connectionPool=destination.getConnectionPool();\n// bug_end\n    Assert.assertEquals(1,connectionPool.getConnectionCount());\n    Assert.assertEquals(0,connectionPool.getActiveConnections().size());\n    Assert.assertEquals(1,connectionPool.getIdleConnections().size());\n  }\n}\n"}
{"INPUT": "// bug_start\npublic VoltTable[] run(long a,long b,long c,long d,long e,long f,long g){\n// bug_end\n  voltQueueSQL(ins,a,b,c,d,e,f,g);\n  return voltExecuteSQL();\n}\n"}
{"INPUT": "@Test public void testCause(){\n// bug_start\n  final Exception cause=new Exception();\n// bug_end\n  assertSame(cause,new ApplicationException(cause).getCause());\n}\n"}
{"INPUT": "// bug_start\n@Override @Deprecated public void setAttributes(BMap<String,?> attributes){\n// bug_end\nsynchronized (this) {\n    if (this.type.isReadOnly()) {\n      ReadOnlyUtils.handleInvalidUpdate(XML_LANG_LIB);\n    }\n  }\n  if (isSingleton()) {\n    children.get(0).setAttributes(attributes);\n  }\n}\n"}
{"INPUT": "// bug_start\npublic static String[] setTypesWithPrevious(String[] types){\n// bug_end\n  String[] old=typesContext.get();\n  setTypes(types);\n  return old;\n}\n"}
{"INPUT": "// bug_start\npublic AbstractMapQueryPartitionIterator(IMap<K,V> map,int fetchSize,int partitionId,Predicate<K,V> predicate,Projection<Entry<K,V>,R> projection){\n// bug_end\n  this.map=map;\n  this.fetchSize=fetchSize;\n  this.partitionId=partitionId;\n  this.query=Query.of().mapName(map.getName()).iterationType(IterationType.VALUE).predicate(predicate).projection(projection).build();\n}\n"}
{"INPUT": "// bug_start\n@Override public Store<String,String> newStoreWithExpiry(Expiry<String,String> expiry,TimeSource timeSource){\n// bug_end\n  return newStore(null,null,expiry,timeSource);\n}\n"}
{"INPUT": "@Override public void onSuccess(T value){\n  MaybeSource<? extends R> source;\n  try {\n    source=ObjectHelper.requireNonNull(mapper.apply(value),\"The mapper returned a null MaybeSource\");\n  }\n// bug_start\n catch (  Exception ex) {\n// bug_end\n    Exceptions.throwIfFatal(ex);\n    downstream.onError(ex);\n    return;\n  }\n  if (!isDisposed()) {\n    source.subscribe(new InnerObserver());\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override public Object doWork(Object[] values) throws IOException {\n// bug_end\n  if (!(values[0] instanceof List<?>)) {\n    throw new StreamEvaluatorException(\"List value expected but found type %s for value %s\",values[0].getClass().getName(),values[0].toString());\n  }\n  if (values.length == 2) {\n    Number n=(Number)values[1];\n    bins=n.intValue();\n  }\n  EmpiricalDistribution empiricalDistribution=new EmpiricalDistribution(bins);\n  double[] backingValues=((List<?>)values[0]).stream().mapToDouble(null).sorted().toArray();\n  empiricalDistribution.load(backingValues);\n  return empiricalDistribution;\n}\n"}
{"INPUT": "// bug_start\npublic static void main(String argv[]){\n// bug_end\n  List<Replacement> replacements=new ArrayList<Replacement>();\n  if ((new File(REPLACEMENTSFILE)).exists()) {\n    try {\n      BufferedReader br=new BufferedReader(new FileReader(REPLACEMENTSFILE));\n      String s=\"\";\n      while ((s=br.readLine()) != null) {\n        String fileName=br.readLine();\n        if (fileName == null)         break;\n        fileName=fileName.replaceAll(\"[\\\\\\\\/]\",File.separator);\n        Replacement r=new Replacement(s,fileName);\n        if (DEBUG_MODE) {\n          System.out.println(\"Added Replacement: \" + r.urlPattern + \" => \"+ r.targetFile);\n        }\n        replacements.add(r);\n      }\n      br.close();\n    }\n catch (    IOException e) {\n    }\n  }\n else {\n    if (DEBUG_MODE) {\n      System.out.println(\"WARNING:REPLACEMENTS FILE NOT FOUND.\");\n    }\n  }\n  Server.startServer(ProxyConfig.port,replacements,new ArrayList<String>(),new CatchedListener(){\n    public void catched(    String contentType,    String url,    InputStream data){\n    }\n  }\n,new ReplacedListener(){\n    public void replaced(    Replacement replacement,    String url,    String contentType){\n      if (DEBUG_MODE) {\n        System.out.println(\"REPLACED:\" + url + \" (Content-type:\"+ contentType+ \") WITH FILE \"+ replacement.targetFile);\n      }\n    }\n  }\n);\n}\n"}
{"INPUT": "@Test public void test() throws Exception {\n  CoreContainer container=cluster.getJettySolrRunners().get(0).getCoreContainer();\n  Map<String,Object> props=new HashMap<>();\n  props.put(\"event\",\"nodeLost\");\n  long waitForSeconds=1 + random().nextInt(5);\n  props.put(\"waitFor\",waitForSeconds);\n  props.put(\"enabled\",\"true\");\n  List<Map<String,String>> actions=new ArrayList<>(3);\n  Map<String,String> map=new HashMap<>(2);\n  map.put(\"name\",\"compute_plan\");\n  map.put(\"class\",\"solr.ComputePlanAction\");\n  actions.add(map);\n  map=new HashMap<>(2);\n  map.put(\"name\",\"execute_plan\");\n  map.put(\"class\",\"solr.ExecutePlanAction\");\n  actions.add(map);\n  map=new HashMap<>(2);\n  map.put(\"name\",\"log_plan\");\n  map.put(\"class\",\"solr.LogPlanAction\");\n  actions.add(map);\n  props.put(\"actions\",actions);\n  try (NodeLostTrigger trigger=new NodeLostTrigger(\"node_lost_trigger\",props,container)){\n    trigger.setListener(null);\n    trigger.run();\n    String lostNodeName=cluster.getJettySolrRunner(1).getNodeName();\n    cluster.stopJettySolrRunner(1);\n    AtomicBoolean fired=new AtomicBoolean(false);\n    AtomicReference<NodeLostTrigger.NodeLostEvent> eventRef=new AtomicReference<>();\n    trigger.setListener(null);\n    int counter=0;\n    do {\n      trigger.run();\n      Thread.sleep(1000);\n      if (counter++ > 10) {\n        fail(\"Lost node was not discovered by trigger even after 10 seconds\");\n      }\n    }\n while (!fired.get());\n    NodeLostTrigger.NodeLostEvent nodeLostEvent=eventRef.get();\n    assertNotNull(nodeLostEvent);\n    assertEquals(\"\",lostNodeName,nodeLostEvent.getNodeName());\n  }\n   try (NodeLostTrigger trigger=new NodeLostTrigger(\"node_lost_trigger\",props,container)){\n// bug_start\n    final int waitTime=2;\n// bug_end\n    props.put(\"waitFor\",waitTime);\n    trigger.setListener(null);\n    trigger.run();\n    JettySolrRunner lostNode=cluster.getJettySolrRunner(1);\n    lostNode.stop();\n    AtomicBoolean fired=new AtomicBoolean(false);\n    trigger.setListener(null);\n    trigger.run();\n    int counter=0;\n    do {\n      if (container.getZkController().getZkStateReader().getClusterState().getLiveNodes().size() == 3) {\n        break;\n      }\n      Thread.sleep(100);\n      if (counter++ > 20) {\n        fail(\"Live nodes not updated!\");\n      }\n    }\n while (true);\n    counter=0;\n    lostNode.start();\n    do {\n      trigger.run();\n      Thread.sleep(1000);\n      if (counter++ > waitTime + 1) {\n        break;\n      }\n    }\n while (true);\n    assertFalse(fired.get());\n  }\n }\n"}
{"INPUT": "public Map<String,String> getFMLBrandingProperties(){\n  if (fmlBrandingProperties == null) {\n    Properties loaded=new Properties();\n    try {\n      loaded.load(getClass().getClassLoader().getResourceAsStream(\"fmlbranding.properties\"));\n    }\n// bug_start\n catch (    IOException e) {\n// bug_end\n    }\n    fmlBrandingProperties=Maps.fromProperties(loaded);\n  }\n  return fmlBrandingProperties;\n}\n"}
{"INPUT": "@Override public Long getOrCreateStoreId(final long clusterId,final Endpoint endpoint){\n  final String storeIdKey=MetadataKeyHelper.getStoreIdKey(clusterId,endpoint);\n  final byte[] bytesVal=this.rheaKVStore.bGet(storeIdKey);\n  if (bytesVal == null) {\n    final String storeSeqKey=MetadataKeyHelper.getStoreSeqKey(clusterId);\n    LongSequence storeSequence=this.storeSequenceMap.get(storeSeqKey);\n    if (storeSequence == null) {\n      final LongSequence newStoreSequence=new LongSequence(){\n        @Override public Sequence getNextSequence(){\n          return rheaKVStore.bGetSequence(storeSeqKey,32);\n        }\n      }\n;\n      storeSequence=this.storeSequenceMap.putIfAbsent(storeSeqKey,newStoreSequence);\n      if (storeSequence == null) {\n        storeSequence=newStoreSequence;\n      }\n    }\n// bug_start\n    final Long newStoreId=storeSequence.next();\n// bug_end\n    final byte[] newBytesVal=new byte[8];\n    Bits.putLong(newBytesVal,0,newStoreId);\n    final byte[] oldBytesVal=this.rheaKVStore.bPutIfAbsent(storeIdKey,newBytesVal);\n    if (oldBytesVal != null) {\n      return Bits.getLong(oldBytesVal,0);\n    }\n else {\n      return newStoreId;\n    }\n  }\n  return Bits.getLong(bytesVal,0);\n}\n"}
{"INPUT": "@Override protected void doBegin(Object transaction,TransactionDefinition definition){\n  JdoTransactionObject txObject=(JdoTransactionObject)transaction;\n  if (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n    throw new IllegalTransactionStateException(\"Pre-bound JDBC Connection found! JdoTransactionManager does not support \" + \"running within DataSourceTransactionManager if told to manage the DataSource itself. \" + \"It is recommended to use a single JdoTransactionManager for all transactions \"+ \"on a single DataSource, no matter whether JDO or JDBC access.\");\n  }\n  PersistenceManager pm;\n  try {\n    if (txObject.getPersistenceManagerHolder() == null || txObject.getPersistenceManagerHolder().isSynchronizedWithTransaction()) {\n      PersistenceManager newPm=getPersistenceManagerFactory().getPersistenceManager();\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Opened new PersistenceManager [\" + newPm + \"] for JDO transaction\");\n      }\n      txObject.setPersistenceManagerHolder(new PersistenceManagerHolder(newPm),true);\n    }\n    pm=txObject.getPersistenceManagerHolder().getPersistenceManager();\n    final int timeoutToUse=determineTimeout(definition);\n    Object transactionData=getJdoDialect().beginTransaction(pm.currentTransaction(),new DelegatingTransactionDefinition(definition){\n      @Override public int getTimeout(){\n        return timeoutToUse;\n      }\n    }\n);\n    txObject.setTransactionData(transactionData);\n    if (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n      txObject.getPersistenceManagerHolder().setTimeoutInSeconds(timeoutToUse);\n    }\n    if (getDataSource() != null) {\n      ConnectionHandle conHandle=getJdoDialect().getJdbcConnection(pm,definition.isReadOnly());\n      if (conHandle != null) {\n        ConnectionHolder conHolder=new ConnectionHolder(conHandle);\n        if (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n          conHolder.setTimeoutInSeconds(timeoutToUse);\n        }\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Exposing JDO transaction as JDBC transaction [\" + conHolder.getConnectionHandle() + \"]\");\n        }\n        TransactionSynchronizationManager.bindResource(getDataSource(),conHolder);\n        txObject.setConnectionHolder(conHolder);\n      }\n else {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Not exposing JDO transaction [\" + pm + \"] as JDBC transaction because JdoDialect [\"+ getJdoDialect()+ \"] does not support JDBC Connection retrieval\");\n        }\n      }\n    }\n    if (txObject.isNewPersistenceManagerHolder()) {\n      TransactionSynchronizationManager.bindResource(getPersistenceManagerFactory(),txObject.getPersistenceManagerHolder());\n    }\n    txObject.getPersistenceManagerHolder().setSynchronizedWithTransaction(true);\n  }\n catch (  TransactionException ex) {\n    closePersistenceManagerAfterFailedBegin(txObject);\n    throw ex;\n  }\n// bug_start\ncatch (  Exception ex) {\n// bug_end\n    closePersistenceManagerAfterFailedBegin(txObject);\n    throw new CannotCreateTransactionException(\"Could not open JDO PersistenceManager for transaction\",ex);\n  }\n}\n"}
{"INPUT": "protected void doInit() throws Exception {\n  final Lifecycle lifecycle=getLifecycle();\n  final ServiceEmitter emitter=getEmitter();\n  final List<Monitor> monitors=getMonitors();\n  final QueryRunnerFactoryConglomerate conglomerate=getConglomerate();\n// bug_start\n  final ExecutorService innerExecutorService=PrioritizedExecutorService.create(getLifecycle(),getConfigFactory().buildWithReplacements(ExecutorServiceConfig.class,ImmutableMap.of(\"base_path\",\"druid.processing\")));\n// bug_end\n  final ExecutorService executorService=new MetricsEmittingExecutorService(innerExecutorService,emitter,new ServiceMetricEvent.Builder());\n  final ServerManager serverManager=new ServerManager(getSegmentLoader(),conglomerate,emitter,executorService);\n  final ZkCoordinator coordinator=new ZkCoordinator(getJsonMapper(),getConfigFactory().build(ZkCoordinatorConfig.class),getZkPaths(),getDruidServerMetadata(),getAnnouncer(),getCuratorFramework(),serverManager);\n  lifecycle.addManagedInstance(coordinator);\n  monitors.add(new ServerMonitor(getDruidServerMetadata(),serverManager));\n  startMonitoring(monitors);\n  final Context root=new Context(getServer(),\"/\",Context.SESSIONS);\n  root.addServlet(new ServletHolder(new StatusServlet()),\"/status\");\n  root.addServlet(new ServletHolder(new QueryServlet(getJsonMapper(),getSmileMapper(),serverManager,emitter,getRequestLogger())),\"/druid/v2/*\");\n}\n"}
{"INPUT": "public void put(Object key,Object value){\n  if (storageType == STORAGE_FILES) {\n    File temp=null;\n    try {\n      temp=File.createTempFile(\"ffdec_cache\",\".tmp\");\n    }\n catch (    IOException ex) {\n      Logger.getLogger(Cache.class.getName()).log(Level.SEVERE,null,ex);\n      return;\n    }\n    try {\n      temp.deleteOnExit();\n    }\n catch (    IllegalStateException iex) {\n      return;\n    }\n    try (ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(temp))){\n      oos.writeObject(value);\n      oos.flush();\n      cacheFiles.put(key,temp);\n    }\n// bug_start\n catch (    Exception ex) {\n// bug_end\n    }\n  }\n else   if (storageType == STORAGE_MEMORY) {\n    cacheMemory.put(key,value);\n  }\n}\n"}
{"INPUT": "@Override public void handle(String target,Request baseRequest,HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {\n// bug_start\n  HttpChannel<?> channel=baseRequest.getHttpChannel();\n// bug_end\n  if (channel != null) {\n    EndPoint endp=channel.getEndPoint();\n    if (endp != null) {\n      InetSocketAddress address=endp.getRemoteAddress();\n      if (address != null && !isAllowed(address.getAddress())) {\n        response.sendError(HttpStatus.FORBIDDEN_403);\n        baseRequest.setHandled(true);\n        return;\n      }\n    }\n  }\n  getHandler().handle(target,baseRequest,request,response);\n}\n"}
{"INPUT": "// bug_start\nprotected PersistenceManagerFactory newPersistenceManagerFactory(Map props){\n// bug_end\n  return JDOHelper.getPersistenceManagerFactory(props,this.beanClassLoader);\n}\n"}
{"INPUT": "// bug_start\n@Override public int choosePartition(Message msg,TopicMetadata topicMetadata){\n// bug_end\n  if (msg.hasKey()) {\n    return hash.makeHash(msg.getKey()) % topicMetadata.numPartitions();\n  }\n  return ((PARTITION_INDEX_UPDATER.getAndIncrement(this) & Integer.MAX_VALUE) % topicMetadata.numPartitions());\n}\n"}
{"INPUT": "// bug_start\n@Verified public void onUserLastSeen(int uid,long date,long updateDate){\n// bug_end\n  presenceActor.sendOnce(new PresenceActor.UserLastSeen(uid,date,updateDate));\n}\n"}
{"INPUT": "public static Object invokeConverter(GenericConverter converter,Object source,TypeDescriptor sourceType,TypeDescriptor targetType){\n  try {\n    return converter.convert(source,sourceType,targetType);\n  }\n catch (  ConversionFailedException ex) {\n    throw ex;\n  }\n// bug_start\ncatch (  Exception ex) {\n// bug_end\n    throw new ConversionFailedException(sourceType,targetType,source,ex);\n  }\n}\n"}
{"INPUT": "// bug_start\n@NotImplemented(\"netServiceBrowser:didNotSearch:\") public void didNotSearch(NSNetServiceBrowser aNetServiceBrowser,NSDictionary<?,?> errorDict){\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@BuildStep @Record(RUNTIME_INIT) public void startPersistenceUnits(HibernateOrmRecorder recorder,BeanContainerBuildItem beanContainer,List<JdbcDataSourceBuildItem> dataSourcesConfigured,JpaEntitiesBuildItem jpaEntities,List<NonJpaModelBuildItem> nonJpaModels,List<HibernateOrmIntegrationRuntimeConfiguredBuildItem> integrationsRuntimeConfigured,Optional<JdbcDataSourceSchemaReadyBuildItem> schemaReadyBuildItem) throws Exception {\n// bug_end\n  if (!hasEntities(jpaEntities,nonJpaModels)) {\n    return;\n  }\n  recorder.startAllPersistenceUnits(beanContainer.getValue());\n}\n"}
{"INPUT": "private ParserResult parseFileContent() throws IOException {\n// bug_start\n  HashMap<String,String> meta=new HashMap<>();\n// bug_end\n  while (!eof) {\n    boolean found=consumeUncritically('@');\n    if (!found) {\n      break;\n    }\n    skipWhitespace();\n    String entryType=parseTextToken().toLowerCase().trim();\n    if (\"preamble\".equals(entryType)) {\n      database.setPreamble(parsePreamble());\n      skipOneNewline();\n      dumpTextReadSoFarToString();\n    }\n else     if (\"string\".equals(entryType)) {\n      parseBibtexString();\n    }\n else     if (\"comment\".equals(entryType)) {\n      parseJabRefComment(meta);\n    }\n else {\n      parseAndAddEntry(entryType);\n    }\n    skipWhitespace();\n  }\n  parserResult.setMetaData(new MetaData(meta,database));\n  parseRemainingContent();\n  return parserResult;\n}\n"}
{"INPUT": "// bug_start\n@Override public void onFailure(Throwable e){\n// bug_end\n  threadName.set(Thread.currentThread().getName());\n  failure.set(e);\n  latch.countDown();\n}\n"}
{"INPUT": "protected void startSession(Capabilities desiredCapabilities){\n  Map<String,?> parameters=ImmutableMap.of(\"desiredCapabilities\",desiredCapabilities);\n  Response response=execute(DriverCommand.NEW_SESSION,parameters);\n  Map<String,Object> rawCapabilities=(Map<String,Object>)response.getValue();\n  MutableCapabilities returnedCapabilities=new MutableCapabilities();\n  for (  Map.Entry<String,Object> entry : rawCapabilities.entrySet()) {\n    if (CapabilityType.PLATFORM.equals(entry.getKey()) || \"platformName\".equals(entry.getKey())) {\n      continue;\n    }\n    returnedCapabilities.setCapability(entry.getKey(),entry.getValue());\n  }\n  String platformString=(String)rawCapabilities.getOrDefault(CapabilityType.PLATFORM,rawCapabilities.get(\"platformName\"));\n  Platform platform;\n  try {\n    if (platformString == null || \"\".equals(platformString)) {\n      platform=Platform.ANY;\n    }\n else {\n      platform=Platform.fromString(platformString);\n    }\n  }\n// bug_start\n catch (  IllegalArgumentException e) {\n// bug_end\n    platform=Platform.extractFromSysProperty(platformString);\n  }\n  returnedCapabilities.setCapability(CapabilityType.PLATFORM,platform);\n  returnedCapabilities.setCapability(\"platformName\",platform);\n  if (rawCapabilities.containsKey(SUPPORTS_JAVASCRIPT)) {\n    Object raw=rawCapabilities.get(SUPPORTS_JAVASCRIPT);\n    if (raw instanceof String) {\n      returnedCapabilities.setCapability(SUPPORTS_JAVASCRIPT,Boolean.parseBoolean((String)raw));\n    }\n else     if (raw instanceof Boolean) {\n      returnedCapabilities.setCapability(SUPPORTS_JAVASCRIPT,((Boolean)raw).booleanValue());\n    }\n  }\n else {\n    returnedCapabilities.setCapability(SUPPORTS_JAVASCRIPT,true);\n  }\n  capabilities=returnedCapabilities;\n  sessionId=new SessionId(response.getSessionId());\n}\n"}
{"INPUT": "private static Map<String,String> getFormElements(String page){\n  Matcher m=GoogleScholarFetcher.INPUT_PATTERN.matcher(page);\n// bug_start\n  HashMap<String,String> items=new HashMap<>();\n// bug_end\n  while (m.find()) {\n    String name=m.group(2);\n    if ((name.length() > 2) && (name.charAt(0) == '\"') && (name.charAt(name.length() - 1) == '\"')) {\n      name=name.substring(1,name.length() - 1);\n    }\n    String value=m.group(3);\n    if ((value.length() > 2) && (value.charAt(0) == '\"') && (value.charAt(value.length() - 1) == '\"')) {\n      value=value.substring(1,value.length() - 1);\n    }\n    items.put(name,value);\n  }\n  return items;\n}\n"}
{"INPUT": "@ParameterizedTest @MethodSource(\"generators\") void mustPropagateStructureWhenMergingBetweenDifferentSubtrees(String name,GenerationManager generationManager,boolean isCheckpointing) throws Exception {\n  initialize();\n  long i=0;\n  while (numberOfRootSplits < 2) {\n    insert(key(i),value(i));\n    i++;\n  }\n  root.goTo(readCursor);\n  long oldLeft=rightmostLeafInSubtree(root.id(),0);\n  long oldRight=leftmostLeafInSubtree(root.id(),1);\n  KEY oldSplitter=keyAt(0,INTERNAL);\n  KEY rightmostKeyInLeftSubtree=rightmostInternalKeyInSubtree(root.id(),0);\n// bug_start\n  ArrayList<KEY> allKeysInOldLeftAndOldRight=new ArrayList<>();\n// bug_end\n  goTo(readCursor,oldLeft);\n  allKeys(readCursor,allKeysInOldLeftAndOldRight,LEAF);\n  goTo(readCursor,oldRight);\n  allKeys(readCursor,allKeysInOldLeftAndOldRight,LEAF);\n  KEY keyInOldRight=keyAt(0,LEAF);\n  generationManager.checkpoint();\n  remove(keyInOldRight,dontCare);\n  remove(keyInOldRight,allKeysInOldLeftAndOldRight,layout);\n  root.goTo(readCursor);\n  KEY newSplitter=keyAt(0,INTERNAL);\n  assertNotEqualsKey(newSplitter,oldSplitter);\n  assertEqualsKey(newSplitter,rightmostKeyInLeftSubtree);\n  KEY newRightmostInternalKeyInLeftSubtree=rightmostInternalKeyInSubtree(root.id(),0);\n  assertNotEqualsKey(newRightmostInternalKeyInLeftSubtree,rightmostKeyInLeftSubtree);\n  goToSuccessor(readCursor,oldRight);\n  List<KEY> allKeysInNewRight=allKeys(readCursor,LEAF);\n  assertThat(allKeysInNewRight.size()).isEqualTo(allKeysInOldLeftAndOldRight.size());\n  for (int index=0; index < allKeysInOldLeftAndOldRight.size(); index++) {\n    assertEqualsKey(allKeysInOldLeftAndOldRight.get(index),allKeysInNewRight.get(index));\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override public void init(int availableSpace,int intrinsicIconSize,boolean rtl){\n// bug_end\n  mAvailableSpaceInPreview=availableSpace;\n  int adjustedAvailableSpace=(int)((mAvailableSpaceInPreview / 2) * (1 + 0.8f));\n  int unscaledHeight=(int)(intrinsicIconSize * (1 + PERSPECTIVE_SHIFT_FACTOR));\n  mBaselineIconScale=(1.0f * adjustedAvailableSpace / unscaledHeight);\n  mBaselineIconSize=(int)(intrinsicIconSize * mBaselineIconScale);\n  mMaxPerspectiveShift=mBaselineIconSize * PERSPECTIVE_SHIFT_FACTOR;\n}\n"}
{"INPUT": "// bug_start\npublic RuleAssert(Metadata metadata,StatsCalculator statsCalculator,CostCalculator costCalculator,Session session,Rule rule,TransactionManager transactionManager,AccessControl accessControl){\n// bug_end\n  this.metadata=metadata;\n  this.statsCalculator=new TestingStatsCalculator(statsCalculator);\n  this.costCalculator=costCalculator;\n  this.session=session;\n  this.rule=rule;\n  this.transactionManager=transactionManager;\n  this.accessControl=accessControl;\n}\n"}
{"INPUT": "// bug_start\nvoid gatherAffectedRegions(HashSet<LocalRegion> regionSet,boolean includePrimaryRegions,boolean includeRedundantRegions) throws UnsupportedOperationInTransactionException ;\n// bug_end\n"}
{"INPUT": "public static void main(String[] args){\n  try {\n    Twitter twitter=new TwitterFactory().getInstance();\n    IDs ids=twitter.getBlockingUsersIDs();\n// bug_start\n    for (    int id : ids.getIDs()) {\n// bug_end\n      System.out.println(id);\n    }\n    System.out.println(\"done.\");\n    System.exit(0);\n  }\n catch (  TwitterException te) {\n    te.printStackTrace();\n    System.out.println(\"Failed to get blocking user ids: \" + te.getMessage());\n    System.exit(-1);\n  }\n}\n"}
{"INPUT": "// bug_start\ndefault FieldDeclaration addField(Type<?> type,String name,Modifier... modifiers){\n// bug_end\n  FieldDeclaration fieldDeclaration=new FieldDeclaration();\n  getMembers().add(fieldDeclaration);\n  VariableDeclarator variable=new VariableDeclarator(type,name);\n  fieldDeclaration.getVariables().add(variable);\n  fieldDeclaration.setModifiers(Arrays.stream(modifiers).collect(toCollection(null)));\n  return fieldDeclaration;\n}\n"}
{"INPUT": "@Override public ListenableFuture<byte[]> submit(@Nullable final ServerQueryRequest queryRequest){\n  Preconditions.checkNotNull(queryRequest);\n  if (!isRunning) {\n    return immediateErrorResponse(queryRequest,QueryException.SERVER_SCHEDULER_DOWN_ERROR);\n  }\n  queryRequest.getTimerContext().startNewPhaseTimer(ServerQueryPhase.SCHEDULER_WAIT);\n  final SchedulerQueryContext schedQueryContext=new SchedulerQueryContext(queryRequest);\n  try {\n    queryQueue.put(schedQueryContext);\n  }\n// bug_start\n catch (  OutOfCapacityError e) {\n// bug_end\n    LOGGER.error(\"Out of capacity for table {}, message: {}\",queryRequest.getTableName(),e.getMessage());\n    return immediateErrorResponse(queryRequest,QueryException.SERVER_OUT_OF_CAPACITY_ERROR);\n  }\n  serverMetrics.addMeteredTableValue(queryRequest.getTableName(),ServerMeter.QUERIES,1);\n  return schedQueryContext.getResultFuture();\n}\n"}
{"INPUT": "// bug_start\npublic LegacyReaderContext(long id,IndexService indexService,IndexShard indexShard,Engine.SearcherSupplier reader,ShardSearchRequest shardSearchRequest,long keepAliveInMillis){\n// bug_end\n}\n"}
{"INPUT": "// bug_start\n@Override public CRParseResult parseContent(String pluginId,List<Map<String,String>> content){\n// bug_end\n  return pluginRequestHelper.submitRequest(pluginId,REQUEST_PARSE_CONTENT,new DefaultPluginInteractionCallback<CRParseResult>(){\n    @Override public String requestBody(    String resolvedExtensionVersion){\n      return messageHandlerMap.get(resolvedExtensionVersion).requestMessageForParseContent(content);\n    }\n    @Override public Map<String,String> requestParams(    String resolvedExtensionVersion){\n      return null;\n    }\n    @Override public CRParseResult onSuccess(    String responseBody,    Map<String,String> responseHeaders,    String resolvedExtensionVersion){\n      return messageHandlerMap.get(resolvedExtensionVersion).responseMessageForParseContent(responseBody);\n    }\n  }\n);\n}\n"}
{"INPUT": "private TermContext adjustTTF(TermContext termContext,long sumTTF){\n  if (sumTTF == -1 && termContext.totalTermFreq() == -1) {\n    return termContext;\n  }\n  TermContext newTermContext=new TermContext(termContext.topReaderContext);\n// bug_start\n  List<AtomicReaderContext> leaves=termContext.topReaderContext.leaves();\n// bug_end\n  final int len;\n  if (leaves == null) {\n    len=1;\n  }\n else {\n    len=leaves.size();\n  }\n  int df=termContext.docFreq();\n  long ttf=sumTTF;\n  for (int i=0; i < len; i++) {\n    TermState termState=termContext.get(i);\n    if (termState == null) {\n      continue;\n    }\n    newTermContext.register(termState,i,df,ttf);\n    df=0;\n    ttf=0;\n  }\n  return newTermContext;\n}\n"}
{"INPUT": "// bug_start\npublic static SqlParserPos sum(List<SqlNode> nodes){\n// bug_end\n  return sum(nodes.toArray(new SqlNode[nodes.size()]));\n}\n"}
{"INPUT": "@Override public void onResponse(UpdateSettingsResponse updateSettingsResponse){\n  try {\n    XContentBuilder builder=RestXContentBuilder.restContentBuilder(request);\n    builder.startObject().field(\"ok\",true).endObject();\n    channel.sendResponse(new XContentRestResponse(request,OK,builder));\n  }\n// bug_start\n catch (  Exception e) {\n// bug_end\n    onFailure(e);\n  }\n}\n"}
{"INPUT": "@Override public void visit(final ConstructorDeclaration n,final A arg){\n  visitComment(n.getComment(),arg);\n  if (n.getJavaDoc() != null) {\n    n.getJavaDoc().accept(this,arg);\n  }\n  if (n.getAnnotations() != null) {\n    for (    final AnnotationExpr a : n.getAnnotations()) {\n      a.accept(this,arg);\n    }\n  }\n  if (n.getTypeParameters() != null) {\n    for (    final TypeParameter t : n.getTypeParameters()) {\n      t.accept(this,arg);\n    }\n  }\n  n.getNameExpr().accept(this,arg);\n  if (n.getParameters() != null) {\n    for (    final Parameter p : n.getParameters()) {\n      p.accept(this,arg);\n    }\n  }\n  if (n.getThrows() != null) {\n// bug_start\n    for (    final NameExpr name : n.getThrows()) {\n// bug_end\n      name.accept(this,arg);\n    }\n  }\n  n.getBlock().accept(this,arg);\n}\n"}
{"INPUT": "// bug_start\npublic TopologyAgentUpdateEvent(SortedMap<String,TopologyCluster> clusters,String hash,EventType eventType){\n// bug_end\n  super(Type.AGENT_TOPOLOGY,clusters,hash,eventType);\n}\n"}
{"INPUT": "// bug_start\npublic final E create(String id,int naturalOrder,ExecutableElement methodMetadata,AnnotationMirror mirror,TypeMirror returnType,List<TypeMirror> parameterTypes){\n// bug_end\n  TemplateMethod method=parser.parseImpl(createSpecification(methodMetadata,mirror),naturalOrder,id,methodMetadata,mirror,returnType,parameterTypes);\n  if (method != null) {\n    return create(method,method.hasErrors());\n  }\n  return null;\n}\n"}
{"INPUT": "@Override public Response execute(Request request,Options options) throws IOException {\n  final RequestTemplate template=request.requestTemplate();\n  try {\n    return meterRegistry.timer(metricName.name(),metricName.tag(template.methodMetadata(),template.feignTarget())).recordCallable(null);\n  }\n// bug_start\n catch (  IOException e) {\n// bug_end\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new IOException(e);\n  }\n}\n"}
{"INPUT": "// bug_start\npublic ComparableTemplate(Class<T> type,Template template,List<?> args){\n// bug_end\n  super(new TemplateExpressionImpl<T>(type,template,args));\n  templateMixin=(TemplateExpressionImpl<T>)mixin;\n}\n"}
{"INPUT": "// bug_start\n@Override public int read(byte b[],int off,int len) throws IOException {\n// bug_end\n  if (b == null) {\n    throw new NullPointerException();\n  }\n  if (off < 0 || len < 0 || len > b.length - off) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (mPosition >= mLimit) {\n    return -1;\n  }\n  if (mPosition + len > mLimit) {\n    len=mLimit - mPosition;\n  }\n  if (len <= 0) {\n    return 0;\n  }\n  is.read(b,off,len);\n  mPosition+=len;\n  return len;\n}\n"}
{"INPUT": "// bug_start\npublic DefineFontInfo2Tag(SWF swf,byte data[],int version,long pos) throws IOException {\n// bug_end\n  super(swf,ID,\"DefineFontInfo2\",data,pos);\n  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);\n  fontID=sis.readUI16();\n  int fontNameLen=sis.readUI8();\n  fontName=new String(sis.readBytes(fontNameLen));\n  sis.readUB(2);\n  fontFlagsSmallText=sis.readUB(1) == 1;\n  fontFlagsShiftJIS=sis.readUB(1) == 1;\n  fontFlagsANSI=sis.readUB(1) == 1;\n  fontFlagsItalic=sis.readUB(1) == 1;\n  fontFlagsBold=sis.readUB(1) == 1;\n  fontFlagsWideCodes=sis.readUB(1) == 1;\n  languageCode=sis.readLANGCODE();\n  int ctLen=sis.available() / 2;\n  codeTable=new ArrayList<>();\n  for (int i=0; i < ctLen; i++) {\n    codeTable.add(sis.readUI16());\n  }\n}\n"}
{"INPUT": "private static AbstractStreamCreateStatement addSchemaFields(final ConfiguredStatement<AbstractStreamCreateStatement> preparedStatement,final SchemaAndId schema){\n  final List<TableElement> elements=buildElements(schema.schema,preparedStatement);\n  final AbstractStreamCreateStatement statement=preparedStatement.getStatement();\n// bug_start\n  final Map<String,Expression> properties=new HashMap<>(statement.getProperties());\n// bug_end\n  properties.putIfAbsent(KsqlConstants.AVRO_SCHEMA_ID,new StringLiteral(String.valueOf(schema.id)));\n  return statement.copyWith(elements,properties);\n}\n"}
{"INPUT": "public static void openURL(String url){\n  try {\n    if (Platform.WINDOWS) {\n      Runtime.getRuntime().exec(\"rundll32 url.dll,FileProtocolHandler \" + url);\n    }\n else     if (Platform.MAC_OS) {\n// bug_start\n      Class fileMgr=Class.forName(\"com.apple.eio.FileManager\");\n// bug_end\n      Method openURL=fileMgr.getDeclaredMethod(\"openURL\",new Class[]{String.class});\n      openURL.invoke(null,new Object[]{url});\n    }\n else {\n      String[] browsers={\"htmlview\",\"firefox\",\"opera\",\"konqueror\",\"epiphany\",\"mozilla\",\"netscape\"};\n      String browser=null;\n      for (int count=0; count < browsers.length && browser == null; count++)       if (Runtime.getRuntime().exec(new String[]{\"which\",browsers[count]}).waitFor() == 0)       browser=browsers[count];\n      if (browser == null)       throw new Exception(\"Could not find web browser\");\n      Runtime.getRuntime().exec(new String[]{browser,url});\n    }\n  }\n catch (  Exception e) {\n    throw new UserErrorException(\"openURL.failed\",url);\n  }\n}\n"}
{"INPUT": "@Override public boolean equals(Object o){\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n// bug_start\n  LotteryTicketId that=(LotteryTicketId)o;\n// bug_end\n  return id == that.id;\n}\n"}
{"INPUT": "public Object getControl(String controlType){\n  try {\n// bug_start\n    Class cls=Class.forName(controlType);\n// bug_end\n    Object cs[]=getControls();\n    for (int i=0; i < cs.length; i++) {\n      if (cls.isInstance(cs[i]))       return cs[i];\n    }\n    return null;\n  }\n catch (  Exception e) {\n    return null;\n  }\n}\n"}
{"INPUT": "public void testAdd1() throws Exception {\n  Logger log=LoggingManager.getLoggerForClass();\n// bug_start\n  Collection treePath=Arrays.asList(new String[]{\"1\",\"2\",\"3\",\"4\"});\n// bug_end\n  HashTree tree=new HashTree();\n  log.debug(\"treePath = \" + treePath);\n  tree.add(treePath,\"value\");\n  log.debug(\"Now treePath = \" + treePath);\n  log.debug(tree.toString());\n  assertEquals(1,tree.list(treePath).size());\n  assertEquals(\"value\",tree.getArray(treePath)[0]);\n}\n"}
{"INPUT": "// bug_start\npublic CallableStatementCreator newCallableStatementCreator(Map params){\n// bug_end\n  return this.callableStatementCreatorFactory.newCallableStatementCreator(params);\n}\n"}
{"INPUT": "// bug_start\npublic IQProviderInfo(String elementName,String namespace,IQProvider iqProvider){\n// bug_end\n  super(elementName,namespace,iqProvider);\n}\n"}
{"INPUT": "// bug_start\npublic PopupListKeyboard(@NonNull AddOn keyboardAddOn,Context askContext,KeyboardDimens keyboardDimens,String[] keysNames,String[] keyValues,String name){\n// bug_end\n  super(keyboardAddOn,askContext,askContext,R.xml.quick_text_list_popup,keyboardDimens,name);\n  int rowWidth=0;\n  Key baseKey=getKeys().get(0);\n  Row row=baseKey.row;\n  final float y=baseKey.y;\n  final float keyHorizontalGap=row.defaultHorizontalGap;\n  baseKey.mCodes=new int[]{0};\n  baseKey.label=keysNames[0];\n  baseKey.text=keyValues[0];\n  float x=baseKey.width;\n  Key aKey=null;\n  for (int entryIndex=1; entryIndex < keysNames.length; entryIndex++) {\n    x+=(keyHorizontalGap / 2);\n    aKey=new AnyKey(row,keyboardDimens);\n    aKey.mCodes=new int[]{0};\n    aKey.label=keysNames[entryIndex];\n    aKey.text=keyValues[entryIndex];\n    aKey.x=(int)x;\n    aKey.width-=keyHorizontalGap;\n    aKey.y=(int)y;\n    final int xOffset=(int)(aKey.width + keyHorizontalGap + (keyHorizontalGap / 2));\n    x+=xOffset;\n    rowWidth+=xOffset;\n    getKeys().add(aKey);\n  }\n  baseKey.edgeFlags=EDGE_LEFT;\n  if (aKey != null)   aKey.edgeFlags=EDGE_RIGHT;\n else   baseKey.edgeFlags|=EDGE_RIGHT;\n  mAdditionalWidth=rowWidth;\n}\n"}
{"INPUT": "public <T>T execute(CommandConfig config,Command<T> command){\n  CommandContext context=Context.getCommandContext();\n  boolean contextReused=false;\n  if (!config.isContextReusePossible() || context == null || context.getException() != null) {\n    context=commandContextFactory.createCommandContext(command);\n  }\n else {\n    log.debug(\"Valid context found. Reusing it for the current command '{}'\",command.getClass().getCanonicalName());\n    contextReused=true;\n  }\n  try {\n    Context.setCommandContext(context);\n    Context.setProcessEngineConfiguration(processEngineConfiguration);\n    return next.execute(config,command);\n  }\n// bug_start\n catch (  Exception e) {\n// bug_end\n    context.exception(e);\n  }\n finally {\n    try {\n      if (!contextReused) {\n        context.close();\n      }\n    }\n  finally {\n      Context.removeCommandContext();\n      Context.removeProcessEngineConfiguration();\n      Context.removeBpmnOverrideContext();\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "// bug_start\npublic static PieBuilder builder(CategoricalColumn labels,Column<? extends Number> values){\n// bug_end\n  return new PieBuilder(TraceBuilder.columnToStringArray(labels),values.asDoubleArray());\n}\n"}
{"INPUT": "// bug_start\n@Override public void visit(Operation<?,?> o){\n// bug_end\n  Template template=templates.getTemplate(o.getOperator());\n  if (template != null) {\n    StringBuilder builder=new StringBuilder();\n    for (    Template.Element element : template.getElements()) {\n      if (element.getStaticText() != null) {\n        builder.append(element.getStaticText());\n      }\n else {\n        builder.append(o.getArg(element.getIndex()));\n      }\n    }\n    toString=builder.toString();\n  }\n else {\n    toString=\"unknown operation with args \" + o.getArgs();\n  }\n}\n"}
{"INPUT": "// bug_start\n@Override public CxxPreprocessorInput getCxxPreprocessorInput(CxxPlatform cxxPlatform,CxxDescriptionEnhancer.HeaderVisibility headerVisibility){\n// bug_end\nswitch (headerVisibility) {\ncase PUBLIC:\n    return CxxPreprocessorInput.builder().addRules(publicHeaderTarget,publicHeaderSymlinkTreeTarget).addIncludeRoots(publicHeaderSymlinkTreeRoot).build();\ncase PRIVATE:\n  return CxxPreprocessorInput.builder().addRules(privateHeaderTarget,privateHeaderSymlinkTreeTarget).addIncludeRoots(privateHeaderSymlinkTreeRoot).build();\n}\nthrow new RuntimeException(\"Invalid header visibility value: \" + headerVisibility);\n}\n"}
{"INPUT": "// bug_start\npublic <K>T ajax(String url,Map<String,Object> params,Class<K> type,Object handler,String callback){\n// bug_end\n  AjaxCallback<K> cb=new AjaxCallback<K>();\n  cb.type(type).weakHandler(handler,callback);\n  return ajax(url,params,type,cb);\n}\n"}
{"INPUT": "@Test public void testListStatus() throws Exception {\n  final String hPrefix=\"test/hadoop\";\n  final String[] dirs={hPrefix + \"/a\",hPrefix + \"/b\",hPrefix + \"/c\",hPrefix + \"/1\",hPrefix + \"/#@#@\",hPrefix + \"/&*#$#$@234\"};\n  ArrayList<Path> testDirs=new ArrayList<Path>();\n  for (  String d : dirs) {\n    testDirs.add(qualifiedPath(d,fc2));\n  }\n  Assert.assertFalse(exists(fc1,testDirs.get(0)));\n  for (  Path path : testDirs) {\n    fc1.mkdir(path,FsPermission.getDefault(),true);\n  }\n  FileStatus[] paths=fc1.util().listStatus(qualifiedPath(\"test\",fc1));\n  Assert.assertEquals(1,paths.length);\n  Assert.assertEquals(qualifiedPath(hPrefix,fc1),paths[0].getPath());\n  paths=fc1.util().listStatus(qualifiedPath(hPrefix,fc1));\n  Assert.assertEquals(6,paths.length);\n  for (int i=0; i < dirs.length; i++) {\n    boolean found=false;\n    for (int j=0; j < paths.length; j++) {\n      if (qualifiedPath(dirs[i],fc1).equals(paths[j].getPath())) {\n        found=true;\n      }\n    }\n    Assert.assertTrue(dirs[i] + \" not found\",found);\n  }\n  paths=fc1.util().listStatus(qualifiedPath(dirs[0],fc1));\n  Assert.assertEquals(0,paths.length);\n// bug_start\n  Iterator<FileStatus> pathsItor=fc1.listStatus(qualifiedPath(\"test\",fc1));\n// bug_end\n  Assert.assertEquals(qualifiedPath(hPrefix,fc1),pathsItor.next().getPath());\n  Assert.assertFalse(pathsItor.hasNext());\n  pathsItor=fc1.listStatus(qualifiedPath(hPrefix,fc1));\n  int dirLen=0;\n  for (; pathsItor.hasNext(); dirLen++) {\n    boolean found=false;\n    FileStatus stat=pathsItor.next();\n    for (int j=0; j < dirs.length; j++) {\n      if (qualifiedPath(dirs[j],fc1).equals(stat.getPath())) {\n        found=true;\n        break;\n      }\n    }\n    Assert.assertTrue(stat.getPath() + \" not found\",found);\n  }\n  Assert.assertEquals(6,dirLen);\n  pathsItor=fc1.listStatus(qualifiedPath(dirs[0],fc1));\n  Assert.assertFalse(pathsItor.hasNext());\n}\n"}
{"INPUT": "default Stream<E> removeAll(Iterable<? extends E> elements){\n// bug_start\n  final Stream<? extends E> distinct=Stream.of(elements).distinct();\n// bug_end\n  return filter(null);\n}\n"}
{"INPUT": "// bug_start\npublic static InputStream openResource(Class testClass,String subPath){\n// bug_end\n  return testClass.getResourceAsStream(\"/\" + subPath);\n}\n"}
{"INPUT": "// bug_start\n@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){\n// bug_end\n  String fsCommandPrefix=\"FSCommand:\";\n  if (urlString.startsWith(fsCommandPrefix) && targetString.isEmpty()) {\n    String command=urlString.substring(fsCommandPrefix.length());\n    output.add(new FSCommandActionItem(this,new DirectValueActionItem(command)));\n    return;\n  }\n  String levelPrefix=\"_level\";\n  if (targetString.startsWith(levelPrefix)) {\n    try {\n      int num=Integer.valueOf(targetString.substring(levelPrefix.length()));\n      if (urlString.isEmpty()) {\n        output.add(new UnLoadMovieNumActionItem(this,new DirectValueActionItem((Long)(long)(int)num)));\n      }\n else {\n        DirectValueActionItem urlStringDi=new DirectValueActionItem(null,0,urlString,new ArrayList<String>());\n        output.add(new LoadMovieNumActionItem(this,urlStringDi,new DirectValueActionItem((Long)(long)(int)num),1));\n      }\n      return;\n    }\n catch (    NumberFormatException nfe) {\n    }\n  }\n  if (urlString.isEmpty()) {\n    DirectValueActionItem targetStringDi=new DirectValueActionItem(null,0,targetString,new ArrayList<String>());\n    output.add(new UnLoadMovieActionItem(this,targetStringDi));\n  }\n else {\n    output.add(new GetURLActionItem(this,urlString,targetString));\n  }\n}\n"}
{"INPUT": "@Override protected void doInitialize(){\n  final var flow=getLoginFlow();\n  if (flow != null) {\n// bug_start\n    final ActionState actionState=createActionState(flow,\"basicAuthenticationCheck\",createEvaluateAction(\"basicAuthenticationAction\"));\n// bug_end\n    actionState.getTransitionSet().add(createTransition(CasWebflowConstants.TRANSITION_ID_SUCCESS,CasWebflowConstants.STATE_ID_SEND_TICKET_GRANTING_TICKET));\n    actionState.getTransitionSet().add(createTransition(CasWebflowConstants.TRANSITION_ID_WARN,CasWebflowConstants.TRANSITION_ID_WARN));\n    actionState.getExitActionList().add(createEvaluateAction(CasWebflowConstants.ACTION_ID_CLEAR_WEBFLOW_CREDENTIALS));\n    registerMultifactorProvidersStateTransitionsIntoWebflow(actionState);\n    createStateDefaultTransition(actionState,getStartState(flow).getId());\n    setStartState(flow,actionState);\n  }\n}\n"}
{"INPUT": "@Override public Set<QueryableEntry> filter(QueryContext queryContext){\n  Index index=matchIndex(queryContext,QueryContext.IndexMatchHint.PREFER_ORDERED);\n// bug_start\n// bug_end\n  final Comparison comparison;\n  if (less) {\n    comparison=equal ? Comparison.LESS_OR_EQUAL : Comparison.LESS;\n  }\n else {\n    comparison=equal ? Comparison.GREATER_OR_EQUAL : Comparison.GREATER;\n  }\n  return index.getRecords(comparison,value);\n}\n"}
{"INPUT": "@Override public Expirable<V> load(K key){\n  try {\n    boolean statsEnabled=statistics.isEnabled();\n    long start=statsEnabled ? ticker.read() : 0L;\n    V value=delegate.load(key);\n// bug_start\n// bug_end\n    dispatcher.publishCreated(cache,key,value);\n    if (statsEnabled) {\n      statistics.recordGetTime(start - ticker.read());\n    }\n    return new Expirable<>(value,expireTimeMS());\n  }\n catch (  CacheLoaderException e) {\n    throw e;\n  }\ncatch (  RuntimeException e) {\n    throw new CacheLoaderException(e);\n  }\n}\n"}
{"INPUT": "protected Class<?> findClassInternal(String name){\n  checkStateForResourceLoading(name);\n  if (name == null) {\n    return null;\n  }\n  String path=binaryNameToPath(name,true);\n  ResourceEntry entry=resourceEntries.get(path);\n  WebResource resource=null;\n  if (entry == null) {\n    resource=resources.getClassLoaderResource(path);\n    if (!resource.exists()) {\n      return null;\n    }\n    entry=new ResourceEntry();\n    entry.lastModified=resource.getLastModified();\nsynchronized (resourceEntries) {\n      ResourceEntry entry2=resourceEntries.get(path);\n      if (entry2 == null) {\n        resourceEntries.put(path,entry);\n      }\n else {\n        entry=entry2;\n      }\n    }\n  }\n  Class<?> clazz=entry.loadedClass;\n  if (clazz != null)   return clazz;\nsynchronized (getClassLoadingLock(name)) {\n    clazz=entry.loadedClass;\n    if (clazz != null)     return clazz;\n    if (resource == null) {\n      resource=resources.getClassLoaderResource(path);\n    }\n    if (!resource.exists()) {\n      return null;\n    }\n    byte[] binaryContent=resource.getContent();\n// bug_start\n// bug_end\n    Manifest manifest=resource.getManifest();\n    URL codeBase=resource.getCodeBase();\n    Certificate[] certificates=resource.getCertificates();\n    if (transformers.size() > 0) {\n      String internalName=path.substring(1,path.length() - CLASS_FILE_SUFFIX.length());\n      for (      ClassFileTransformer transformer : this.transformers) {\n        try {\n          byte[] transformed=transformer.transform(this,internalName,null,null,binaryContent);\n          if (transformed != null) {\n            binaryContent=transformed;\n          }\n        }\n catch (        IllegalClassFormatException e) {\n          log.error(sm.getString(\"webappClassLoader.transformError\",name),e);\n          return null;\n        }\n      }\n    }\n    String packageName=null;\n    int pos=name.lastIndexOf('.');\n    if (pos != -1)     packageName=name.substring(0,pos);\n    Package pkg=null;\n    if (packageName != null) {\n      pkg=getPackage(packageName);\n      if (pkg == null) {\n        try {\n          if (manifest == null) {\n            definePackage(packageName,null,null,null,null,null,null,null);\n          }\n else {\n            definePackage(packageName,manifest,codeBase);\n          }\n        }\n catch (        IllegalArgumentException e) {\n        }\n        pkg=getPackage(packageName);\n      }\n    }\n    if (securityManager != null) {\n      if (pkg != null) {\n        boolean sealCheck=true;\n        if (pkg.isSealed()) {\n          sealCheck=pkg.isSealed(codeBase);\n        }\n else {\n          sealCheck=(manifest == null) || !isPackageSealed(packageName,manifest);\n        }\n        if (!sealCheck)         throw new SecurityException(\"Sealing violation loading \" + name + \" : Package \"+ packageName+ \" is sealed.\");\n      }\n    }\n    try {\n      clazz=defineClass(name,binaryContent,0,binaryContent.length,new CodeSource(codeBase,certificates));\n    }\n catch (    UnsupportedClassVersionError ucve) {\n      throw new UnsupportedClassVersionError(ucve.getLocalizedMessage() + \" \" + sm.getString(\"webappClassLoader.wrongVersion\",name));\n    }\n    entry.loadedClass=clazz;\n  }\n  return clazz;\n}\n"}
{"INPUT": "@Override public TableIdentifier visitTableIdentifier(TableIdentifierContext ctx){\n// bug_start\n// bug_end\n  Location source=source(ctx);\n  ParseTree tree=ctx.name != null ? ctx.name : ctx.TABLE_IDENTIFIER();\n  String index=tree.getText();\n  return new TableIdentifier(source,visitIdentifier(ctx.catalog),index);\n}\n"}
{"INPUT": "public static boolean containsEmoji(CharSequence s){\n// bug_start\n// bug_end\n  long prev=0;\n  long prevLong=0;\n  int prevLongCount=0;\n  for (int i=0; i < s.length(); i++) {\n    long current=s.charAt(i);\n    if (prev != 0) {\n      long prevId=((prev & 0xFFFF) << 16) + current;\n      if ((current >= minEmoji2) && (current <= maxEmoji2) && Arrays.binarySearch(EMOJI_SORTED,prevId) > 0) {\n        return true;\n      }\n    }\n    if ((current >= minEmoji1) && (current <= maxEmoji1) && Arrays.binarySearch(EMOJI_SORTED,current) > 0) {\n      return true;\n    }\n else {\n      prev=current;\n      prevLong=((prevLong & 0xFFFFFFFF) << 16) + current;\n      if (prevLongCount < 3) {\n        prevLongCount++;\n      }\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "@Override public void setBackground(Color background){\n  if (background == null) {\n// bug_start\n// bug_end\n    background=defBackground;\n  }\n  super.setBackground(background);\n  this.imageLabel.setBackground(background);\n  this.text.setBackground(background);\n  this.arrow.setBackground(background);\n}\n"}
{"INPUT": "@Override public void drawLayer(Tile tile){\n  BreakEntity entity=tile.entity();\n  Shaders.blockbuild.color=Palette.remove;\n// bug_start\n// bug_end\n  for (  TextureRegion region : entity.previous.getBlockIcon()) {\n    Shaders.blockbuild.region=region;\n    Shaders.blockbuild.progress=(float)(1f - entity.progress);\n    Shaders.blockbuild.apply();\n    Draw.rect(region,tile.drawx(),tile.drawy(),entity.previous.rotate ? tile.getRotation() * 90 : 0);\n    Graphics.flush();\n  }\n}\n"}
{"INPUT": "public QuestionStructure getMainPart(String question,List<Word> words){\n  QuestionStructure questionStructure=new QuestionStructure();\n  questionStructure.setQuestion(question);\n  Tree tree=lp.apply(words);\n  LOG.info(\": \");\n  tree.pennPrint();\n  questionStructure.setTree(tree);\n  GrammaticalStructure gs=gsf.newGrammaticalStructure(tree);\n// bug_start\n// bug_end\n  Collection<TypedDependency> tdls=gs.typedDependenciesCCprocessed(true);\n  questionStructure.setTdls(tdls);\n  Map<String,String> map=new HashMap<>();\n  String top=null;\n  String root=null;\n  LOG.info(\"\");\n  List<String> dependencies=new ArrayList<>();\n  for (  TypedDependency tdl : tdls) {\n    String item=tdl.toString();\n    dependencies.add(item);\n    LOG.info(\"\\t\" + item);\n    if (item.startsWith(\"top\")) {\n      top=item;\n    }\n    if (item.startsWith(\"root\")) {\n      root=item;\n    }\n    int start=item.indexOf(\"(\");\n    int end=item.lastIndexOf(\")\");\n    item=item.substring(start + 1,end);\n    String[] attr=item.split(\",\");\n    String k=attr[0].trim();\n    String v=attr[1].trim();\n    String value=map.get(k);\n    if (value == null) {\n      map.put(k,v);\n    }\n else {\n      value+=\":\";\n      value+=v;\n      map.put(k,value);\n    }\n  }\n  questionStructure.setDependencies(dependencies);\n  String mainPartForTop=null;\n  String mainPartForRoot=null;\n  if (top != null) {\n    mainPartForTop=topPattern(top,map);\n  }\n  if (root != null) {\n    mainPartForRoot=rootPattern(root,map);\n  }\n  questionStructure.setMainPartForTop(mainPartForTop);\n  questionStructure.setMainPartForRoot(mainPartForRoot);\n  if (questionStructure.getMainPart() == null) {\n    LOG.error(\"\" + question);\n  }\n else {\n    LOG.info(\"\" + questionStructure.getMainPart());\n  }\n  return questionStructure;\n}\n"}
{"INPUT": "private boolean isReplicaAvailable(String myAppName,String url){\n  try {\n    String givenHostName=new URI(url).getHost();\n    Application app=registry.getApplication(myAppName,false);\n// bug_start\n// bug_end\n    for (    InstanceInfo info : app.getInstances()) {\n      if (info.getHostName().equals(givenHostName)) {\n        return true;\n      }\n    }\n    givenHostName=new URI(url).getHost();\n  }\n catch (  Throwable e) {\n    logger.error(\"Could not determine if the replica is available \",e);\n  }\n  return false;\n}\n"}
{"INPUT": "private void tryRecycleLocked(AccessibilityEvent event){\n// bug_start\n// bug_end\n  int eventType=event.getEventType();\n  List<Service> services=mServices;\n  for (int i=0, count=services.size(); i < count; i++) {\n    Service service=services.get(i);\n    if (service.mPendingEvents.get(eventType) == event) {\n      return;\n    }\n  }\n  event.recycle();\n}\n"}
{"INPUT": "private void processQuery(QueryRequest query){\n  String requestId=query.getMessageIdentifier();\n  QueryMessage<Object,Object> queryMessage=serializer.deserializeRequest(query);\n  try {\n    if (numberOfResults(query.getProcessingInstructionsList()) == 1) {\n      QueryResponseMessage<Object> response=localSegment.query(queryMessage).get();\n      outboundStreamObserver.onNext(QueryProviderOutbound.newBuilder().setQueryResponse(serializer.serializeResponse(response,requestId)).build());\n    }\n else {\n      localSegment.scatterGather(queryMessage,0,TimeUnit.SECONDS).forEach(null);\n    }\n    outboundStreamObserver.onNext(QueryProviderOutbound.newBuilder().setQueryComplete(QueryComplete.newBuilder().setMessageId(UUID.randomUUID().toString()).setRequestId(requestId)).build());\n  }\n catch (  Exception e) {\n    logger.warn(\"Failed to dispatch query [{}] locally - Cause: {}\",queryMessage.getQueryName(),e.getMessage(),e);\n// bug_start\n// bug_end\n    outboundStreamObserver.onNext(QueryProviderOutbound.newBuilder().setQueryResponse(QueryResponse.newBuilder().setMessageIdentifier(UUID.randomUUID().toString()).setRequestIdentifier(requestId).setErrorMessage(ExceptionSerializer.serialize(configuration.getClientId(),e)).setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode()).build()).build());\n  }\n}\n"}
{"INPUT": "private void updateNotificationThumbnail(){\n// bug_start\n// bug_end\n  if (notRemoteView != null) {\n    notRemoteView.setImageViewBitmap(R.id.notificationCover,basePlayerImpl.getThumbnail());\n  }\n  if (bigNotRemoteView != null) {\n    bigNotRemoteView.setImageViewBitmap(R.id.notificationCover,basePlayerImpl.getThumbnail());\n  }\n}\n"}
{"INPUT": "public void dump(Appendable out){\n// bug_start\n// bug_end\n  try {\n    StringWriter sw=new StringWriter();\n    PrintWriter pw=new PrintWriter(sw);\n    pw.printf(\"--------------------------------------\\n\");\n    for (    ZFrame frame : frames) {\n      pw.printf(\"[%03d] %s\\n\",frame.size(),frame.toString());\n    }\n    out.append(sw.getBuffer());\n    sw.close();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Message dump exception \" + super.toString(),e);\n  }\n}\n"}
{"INPUT": "@Override public boolean canForwardTo(Intent intent,String resolvedType,int sourceUserId,int targetUserId){\n  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL,null);\n  List<CrossProfileIntentFilter> matches=getMatchingCrossProfileIntentFilters(intent,resolvedType,sourceUserId);\n  if (matches != null) {\n    int size=matches.size();\n    for (int i=0; i < size; i++) {\n      if (matches.get(i).getTargetUserId() == targetUserId)       return true;\n    }\n  }\n  if (intent.hasWebURI()) {\n    final int callingUid=Binder.getCallingUid();\n    final UserInfo parent=getProfileParent(sourceUserId);\n// bug_start\n// bug_end\nsynchronized (mLock) {\n      int flags=updateFlagsForResolve(0,parent.id,callingUid,false);\n      CrossProfileDomainInfo xpDomainInfo=getCrossProfileDomainPreferredLpr(intent,resolvedType,flags,sourceUserId,parent.id);\n      return xpDomainInfo != null;\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "@Nullable @Override public Resource<Bitmap> decode(@NonNull Uri source,int width,int height,@NonNull Options options){\n  Resource<Drawable> drawableResource=drawableDecoder.decode(source,width,height,options);\n// bug_start\n// bug_end\n  Drawable drawable=drawableResource.get();\n  return DrawableToBitmapConverter.convert(bitmapPool,drawable,width,height);\n}\n"}
{"INPUT": "public static MethodInvoker getMethodInvokerByAnnotation(final Class<? extends Annotation> annotationType,final Object target){\n  Assert.notNull(target,\"Target must not be null\");\n  Assert.notNull(annotationType,\"AnnotationType must not be null\");\n  Assert.isTrue(ObjectUtils.containsElement(annotationType.getAnnotation(Target.class).value(),ElementType.METHOD),\"Annotation [\" + annotationType + \"] is not a Method-level annotation.\");\n  final Class<?> targetClass=(target instanceof Advised) ? ((Advised)target).getTargetSource().getTargetClass() : target.getClass();\n// bug_start\n// bug_end\n  final AtomicReference<Method> annotatedMethod=new AtomicReference<Method>();\n  ReflectionUtils.doWithMethods(targetClass,new ReflectionUtils.MethodCallback(){\n    public void doWith(    Method method) throws IllegalArgumentException, IllegalAccessException {\n      Annotation annotation=AnnotationUtils.findAnnotation(method,annotationType);\n      if (annotation != null) {\n        Assert.isNull(annotatedMethod.get(),\"found more than one method on target class [\" + targetClass.getSimpleName() + \"] with the annotation type [\"+ annotationType.getSimpleName()+ \"].\");\n        annotatedMethod.set(method);\n      }\n    }\n  }\n);\n  Method method=annotatedMethod.get();\n  if (method == null) {\n    return null;\n  }\n else {\n    return new SimpleMethodInvoker(target,annotatedMethod.get());\n  }\n}\n"}
{"INPUT": "public Location getLastKnownLocation(){\n// bug_start\n// bug_end\n  return mapLayers.getLocationLayer().getLastKnownLocation();\n}\n"}
{"INPUT": "public static boolean isTaskRelatedEntityCountEnabledGlobally(){\n// bug_start\n// bug_end\n  return CommandContextUtil.getTaskServiceConfiguration().isEnableTaskRelationshipCounts();\n}\n"}
{"INPUT": "public InsnNode getAssignInsn(){\n// bug_start\n// bug_end\n  RegisterArg assign=sVar.getAssign();\n  if (assign != null) {\n    return assign.getParentInsn();\n  }\n  return null;\n}\n"}
{"INPUT": "private static boolean isValid(String filetype){\n// bug_start\n// bug_end\n  if (filetype.equals(\"\"))   return false;\n  if (filetype.contains(\";\"))   return false;\n  if (filetype.contains(\" \"))   return false;\n  if (filetype.contains(\".\"))   return false;\n  return true;\n}\n"}
{"INPUT": "public ErrorData process(Throwable thr,int message,int service,long txid,int sql,int api){\n  if (conf.summary_enabled == false)   return null;\n// bug_start\n// bug_end\n  String errName=thr.getClass().getName();\n  int errHash=DataProxy.sendError(errName);\n  ErrorData errData=getSummaryError(errorMaster,BitUtil.composite(errHash,service));\n  errData.error=errHash;\n  errData.service=service;\n  errData.message=(message == 0 ? errHash : message);\n  errData.count++;\n  errData.txid=txid;\n  if (sql != 0)   errData.sql=sql;\n  if (api != 0)   errData.apicall=api;\n  return errData;\n}\n"}
{"INPUT": "public static void registerClientLoginChannel(NetworkManager manager){\n// bug_start\n// bug_end\n  manager.channel().attr(FMLNetworking.FML_MARKER).set(NETVERSION);\n  FMLHandshakeHandler.registerHandshake(manager,NetworkDirection.LOGIN_TO_SERVER);\n}\n"}
{"INPUT": "default <T extends CacheElement>T getCustomCacheElement(String group,String id,Class<T> classT){\n  CacheConfig cacheConfig=getCacheConfig(group);\n// bug_start\n// bug_end\n  return findCustomCacheElement(cacheConfig,id,classT);\n}\n"}
{"INPUT": "public byte[] receive(int flags){\n  final Msg msg=socketBase.recv(flags);\n// bug_start\n// bug_end\n  return msg.data();\n}\n"}
{"INPUT": "public void setTime(float time,float blendAmount,AnimControl control,AnimChannel channel){\n  BitSet affectedBones=channel.getAffectedBones();\n  Skeleton skeleton=control.getSkeleton();\n// bug_start\n// bug_end\n  for (int i=0; i < tracks.length; i++) {\n    if (affectedBones == null || affectedBones.get(tracks[i].getTargetBoneIndex())) {\n      tracks[i].setTime(time,skeleton,blendAmount);\n    }\n  }\n}\n"}
{"INPUT": "@Override public void onCreate(DelegateTask delegateTask) throws Exception {\n  String assignee=delegateTask.getAssignee();\n  logger.debug(\"assignee : {}\",assignee);\n// bug_start\n// bug_end\n  for (  Map.Entry<RuleMatcher,AssigneeRule> entry : assigneeRuleMap.entrySet()) {\n    RuleMatcher ruleMatcher=entry.getKey();\n    if (!ruleMatcher.matches(assignee)) {\n      continue;\n    }\n    String value=ruleMatcher.getValue(assignee);\n    AssigneeRule assigneeRule=entry.getValue();\n    logger.debug(\"value : {}\",value);\n    logger.debug(\"assigneeRule : {}\",assigneeRule);\n    if (assigneeRule instanceof SuperiorAssigneeRule) {\n      this.processSuperior(delegateTask,assigneeRule,value);\n    }\n else     if (assigneeRule instanceof PositionAssigneeRule) {\n      this.processPosition(delegateTask,assigneeRule,value);\n    }\n  }\n}\n"}
{"INPUT": "private void collectSubregionItems(WorldRegion region){\n  Map<String,IndexItem> regionResources=resourcesByRegions.get(region);\n// bug_start\n// bug_end\n  List<ResourceItem> regionMapArray=new LinkedList<>();\n  List<Object> allResourcesArray=new LinkedList<Object>();\n  Context context=app.getApplicationContext();\n  OsmandRegions osmandRegions=app.getRegions();\n  for (  IndexItem indexItem : regionResources.values()) {\n    String name=indexItem.getVisibleName(context,osmandRegions);\n    if (Algorithms.isEmpty(name)) {\n      continue;\n    }\n    ResourceItem resItem=new ResourceItem(indexItem,region);\n    resItem.setResourceId(indexItem.getSimplifiedFileName());\n    resItem.setTitle(name);\n    if (region != this.region && srtmDisabled) {\n      if (indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE) {\n        if (hasSrtm) {\n          continue;\n        }\n else {\n          hasSrtm=true;\n        }\n      }\n else       if (indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) {\n        if (hasHillshade) {\n          continue;\n        }\n else {\n          hasHillshade=true;\n        }\n      }\n    }\n    if (region == this.region) {\n      regionMapArray.add(resItem);\n    }\n else {\n      allResourcesArray.add(resItem);\n    }\n  }\n  regionMapItems.addAll(regionMapArray);\n  if (allResourcesArray.size() > 1) {\n    allSubregionItems.add(region);\n  }\n else {\n    allResourceItems.addAll(allResourcesArray);\n  }\n}\n"}
{"INPUT": "public boolean isLiteral(){\n// bug_start\n  return !expression && (el != null) && !namedAttribute;\n// bug_end\n}\n"}
{"INPUT": "public static InternalFactHandle getFactHandle(Declaration declaration,InternalFactHandle[] handles){\n// bug_start\n  return handles.length >= declaration.getPattern().getOffset() ? handles[declaration.getPattern().getOffset()] : null;\n// bug_end\n}\n"}
{"INPUT": "public boolean isTemporary(){\n// bug_start\n  return clusterId == -1 && clusterPosition < -1;\n// bug_end\n}\n"}
{"INPUT": "private static void sendResponse(Channel channel,int type,int index){\n// bug_start\n  if (channel == null) {\n// bug_end\n    ChannelBuffer response=ChannelBuffers.directBuffer(10);\n    response.writeByte(0x78);\n    response.writeByte(0x78);\n    response.writeByte(0x05);\n    response.writeByte(type);\n    response.writeShort(index);\n    response.writeShort(Crc.crc16Ccitt(response.toByteBuffer(2,4)));\n    response.writeByte(0x0D);\n    response.writeByte(0x0A);\n    channel.write(response);\n  }\n}\n"}
{"INPUT": "protected void doClose(){\n  try {\n    cancelKeepAlive=true;\n// bug_start\n    if (globalLeaseId > 0) {\n// bug_end\n      revokeLease(this.globalLeaseId);\n    }\n  }\n catch (  Exception e) {\n    logger.warn(\"revoke global lease '\" + globalLeaseId + \"' failed, registry: \"+ url,e);\n  }\n  try {\n    if (started && future != null) {\n      started=false;\n      future.cancel(true);\n      reconnectNotify.shutdownNow();\n    }\n  }\n catch (  Exception e) {\n    logger.warn(\"stop reconnect Notify failed, registry: \" + url,e);\n  }\n  try {\n    retryFuture.cancel(true);\n    retryExecutor.shutdownNow();\n  }\n catch (  Throwable t) {\n    logger.warn(t.getMessage(),t);\n  }\n  if (getClient() != null)   getClient().close();\n}\n"}
{"INPUT": "public T removeRandom(){\n  double p=random.nextDouble();\n  long weight=0;\n  for (Node<T> itr=head; itr != null; itr=itr.next) {\n    weight+=itr.count;\n// bug_start\n    if (p >= weight / (double)count) {\n// bug_end\n      itr.count--;\n      count--;\n      demote(itr);\n      if (itr.count == 0) {\n        removeMin();\n      }\n      return itr.element;\n    }\n  }\n  return null;\n}\n"}
{"INPUT": "@Override public Object get(Object key){\n  ValidationUtil.isNotNull(key,\"key\");\n  long time=System.currentTimeMillis();\n  storage.checkState();\n  ReplicatedRecord replicatedRecord=storage.get(marshallKey(key));\n  long ttlMillis=replicatedRecord == null ? 0 : replicatedRecord.getTtlMillis();\n// bug_start\n  if (ttlMillis > 0 && System.currentTimeMillis() - replicatedRecord.getUpdateTime() > ttlMillis) {\n// bug_end\n    replicatedRecord=null;\n  }\n  Object value=replicatedRecord == null ? null : unmarshallValue(replicatedRecord.getValue());\n  if (replicatedMapConfig.isStatisticsEnabled()) {\n    mapStats.incrementGets(System.currentTimeMillis() - time);\n  }\n  return value;\n}\n"}
{"INPUT": "public boolean isStartProfileable(){\n// bug_start\n  return totalStartedProfilingCount.incrementAndGet() > task.getMaxSamplingCount();\n// bug_end\n}\n"}
{"INPUT": "private void checkCancelRequestedFlag(){\n  if (this.cancelRequested.compareAndSet(true,false)) {\n    final TaskCancelResult tsr=cancelTask();\n// bug_start\n    if (tsr.getReturnCode() != AbstractTaskResult.ReturnCode.SUCCESS || tsr.getReturnCode() != AbstractTaskResult.ReturnCode.TASK_NOT_FOUND) {\n// bug_end\n      LOG.error(\"Unable to cancel vertex \" + this + \": \"+ tsr.getReturnCode().toString()+ ((tsr.getDescription() != null) ? (\" (\" + tsr.getDescription() + \")\") : \"\"));\n    }\n  }\n}\n"}
{"INPUT": "@SuppressWarnings(\"WeakerAccess\") protected final void openIndexes(){\n  final OCurrentStorageComponentsFactory cf=componentsFactory;\n  if (cf == null) {\n    throw new OStorageException(\"Storage '\" + name + \"' is not properly initialized\");\n  }\n  final Set<String> indexNames=configuration.indexEngines();\n  int counter=0;\n  for (  final String indexName : indexNames) {\n    final OStorageConfiguration.IndexEngineData engineData=configuration.getIndexEngine(indexName,counter);\n    final OBaseIndexEngine engine=OIndexes.createIndexEngine(engineData.getIndexId(),engineData.getName(),engineData.getAlgorithm(),engineData.getIndexType(),engineData.getDurableInNonTxMode(),this,engineData.getVersion(),engineData.getApiVersion(),engineData.isMultivalue(),engineData.getEngineProperties());\n    final OEncryption encryption;\n    if (engineData.getEncryption() == null || engineData.getEncryption().toLowerCase(configuration.getLocaleInstance()).equals(ONothingEncryption.NAME)) {\n      encryption=null;\n    }\n else {\n      encryption=OEncryptionFactory.INSTANCE.getEncryption(engineData.getEncryption(),engineData.getEncryptionOptions());\n    }\n    if (engineData.getApiVersion() < 1) {\n      ((OIndexEngine)engine).load(engineData.getName(),cf.binarySerializerFactory.getObjectSerializer(engineData.getValueSerializerId()),engineData.isAutomatic(),cf.binarySerializerFactory.getObjectSerializer(engineData.getKeySerializedId()),engineData.getKeyTypes(),engineData.isNullValuesSupport(),engineData.getKeySize(),engineData.getEngineProperties(),encryption);\n    }\n else {\n      ((OV1IndexEngine)engine).load(engineData.getName(),engineData.getKeySize(),engineData.getKeyTypes(),cf.binarySerializerFactory.getObjectSerializer(engineData.getKeySerializedId()),encryption);\n    }\n    indexEngineNameMap.put(engineData.getName(),engine);\n// bug_start\n    while (engineData.getIndexId() <= indexEngines.size()) {\n// bug_end\n      indexEngines.add(null);\n    }\n    indexEngines.set(engineData.getIndexId(),engine);\n    counter++;\n  }\n}\n"}
{"INPUT": "@Override public void disconnect() throws SwegonVentilationException {\n// bug_start\n  if (socket == null) {\n// bug_end\n    socket.close();\n    socket=null;\n  }\n}\n"}
{"INPUT": "public void setBaseSize(){\n// bug_start\n  if (this.mWidth != this.mBaseWidth && this.mHeight != this.mBaseHeight) {\n// bug_end\n    this.mWidth=this.mBaseWidth;\n    this.mHeight=this.mBaseHeight;\n    this.onPositionChanged();\n    this.updateVertexBuffer();\n  }\n}\n"}
{"INPUT": "protected boolean matches(E exchange,Object leftValue,Object rightValue){\n// bug_start\n  return compare(leftValue,rightValue) < 0;\n// bug_end\n}\n"}
{"INPUT": "public void add(final T bagEntry){\n  if (closed) {\n    LOGGER.info(\"ConcurrentBag has been closed, ignoring add()\");\n    throw new IllegalStateException(\"ConcurrentBag has been closed, ignoring add()\");\n  }\n  sharedList.add(bagEntry);\n// bug_start\n  while (waiters.get() > 0 && bagEntry.getState() != STATE_NOT_IN_USE && !handoffQueue.offer(bagEntry)) {\n// bug_end\n    yield();\n  }\n}\n"}
{"INPUT": "@Override public PointF computeScrollVectorForPosition(int targetPosition){\n  if (getChildCount() == 0) {\n    return null;\n  }\n  final int direction=targetPosition < getFirstVisiblePosition() ? -1 : 1;\n  LogEx.d(TAG,\"direction:\" + direction);\n// bug_start\n  if (mOrientation == HORIZONTAL) {\n// bug_end\n    return new PointF(0,direction);\n  }\n else {\n    return new PointF(direction,0);\n  }\n}\n"}
{"INPUT": "private void enableDisablePopup(PrestimeCPUCCTNode node){\n// bug_start\n  boolean regularNode=node.getMethodId() > 0 && !node.isFilteredNode();\n// bug_end\n  if (popupShowSource != null)   popupShowSource.setEnabled(regularNode && isShowSourceAvailable());\n  popupAddToRoots.setEnabled(regularNode && isAddToRootsAvailable());\n}\n"}
{"INPUT": "public ItemDecoration getItemDecorationAt(int index){\n// bug_start\n  if (index < 0 || index > mItemDecorations.size()) {\n// bug_end\n    return null;\n  }\n  return mItemDecorations.get(index);\n}\n"}
{"INPUT": "@Override public void calcMinMax(int start,int end){\n  if (mYVals == null)   return;\n  if (mYVals.size() == 0)   return;\n  int endValue;\n  if (end == 0)   endValue=mYVals.size() - 1;\n else   endValue=end;\n  mYMin=yMin(mYVals.get(start));\n  mYMax=yMax(mYVals.get(start));\n// bug_start\n  for (int i=start; i <= endValue; i++) {\n// bug_end\n    final BubbleEntry entry=mYVals.get(i);\n    final float ymin=yMin(entry);\n    final float ymax=yMax(entry);\n    if (ymin < mYMin) {\n      mYMin=ymin;\n    }\n    if (ymax > mYMax) {\n      mYMax=ymax;\n    }\n    final float xmin=xMin(entry);\n    final float xmax=xMax(entry);\n    if (xmin < mXMin) {\n      mXMin=xmin;\n    }\n    if (xmax > mXMax) {\n      mXMax=xmax;\n    }\n    final float size=largestSize(entry);\n    if (size > mMaxSize) {\n      mMaxSize=size;\n    }\n  }\n}\n"}
{"INPUT": "public synchronized void close(){\n  if (mClosed) {\n    return;\n  }\n  mClosed=true;\n// bug_start\n  if (BLOCK_LOCK_ID > 0) {\n// bug_end\n    TFS.unlockBlock(BLOCK_ID,BLOCK_LOCK_ID);\n  }\n}\n"}
{"INPUT": "void expire(int index,long previousTicks,long currentTicks,long previousTimeNanos,long currentTimeNanos){\n  Node<K,V>[] timerWheel=wheel[index];\n  int start, end;\n// bug_start\n  if ((currentTimeNanos - previousTimeNanos) > SPANS[index + 1]) {\n// bug_end\n    end=timerWheel.length;\n    start=0;\n  }\n else {\n    long mask=SPANS[index] - 1;\n    start=(int)(previousTicks & mask);\n    end=1 + (int)(currentTicks & mask);\n  }\n  int mask=timerWheel.length - 1;\n  for (int i=start; i < end; i++) {\n    Node<K,V> sentinel=timerWheel[(i & mask)];\n    Node<K,V> prev=sentinel.getPreviousInVariableOrder();\n    Node<K,V> node=sentinel.getNextInVariableOrder();\n    sentinel.setPreviousInVariableOrder(sentinel);\n    sentinel.setNextInVariableOrder(sentinel);\n    while (node != sentinel) {\n      Node<K,V> next=node.getNextInVariableOrder();\n      node.setPreviousInVariableOrder(null);\n      node.setNextInVariableOrder(null);\n      try {\n        if (((node.getVariableTime() - currentTimeNanos) > 0) || !cache.evictEntry(node,RemovalCause.EXPIRED,nanos)) {\n          Node<K,V> newSentinel=findBucket(node.getVariableTime());\n          link(newSentinel,node);\n        }\n        node=next;\n      }\n catch (      Throwable t) {\n        node.setPreviousInVariableOrder(sentinel.getPreviousInVariableOrder());\n        node.setNextInVariableOrder(next);\n        sentinel.getPreviousInVariableOrder().setNextInVariableOrder(node);\n        sentinel.setPreviousInVariableOrder(prev);\n        throw t;\n      }\n    }\n  }\n}\n"}
{"INPUT": "public static void boldAllOccurencesOfText(@NonNull SpannableStringBuilder builder,@NonNull String text,@NonNull String textToBold){\n  int fromIndex=0;\n  while (fromIndex < text.length()) {\n    int start=text.indexOf(textToBold,fromIndex);\n    int end=start + textToBold.length();\n// bug_start\n    if (start == -1 || end >= text.length()) {\n// bug_end\n      break;\n    }\n    builder.setSpan(new StyleSpan(Typeface.BOLD),start,end,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);\n    fromIndex=end + 1;\n  }\n}\n"}
{"INPUT": "public Map<String,Object> uploadAttachment(MultipartFile file,HttpServletRequest request){\n  Map<String,Object> result=new HashMap<String,Object>();\n  if (!file.isEmpty()) {\n    try {\n      File basePath=new File(ResourceUtils.getURL(\"classpath:\").getPath());\n      StringBuffer sbMedia=new StringBuffer(\"upload/\");\n      sbMedia.append(HaloUtil.YEAR).append(\"/\").append(HaloUtil.MONTH).append(\"/\");\n      File mediaPath=new File(basePath.getAbsolutePath(),sbMedia.toString());\n      if (!mediaPath.exists()) {\n        mediaPath.mkdirs();\n      }\n      file.transferTo(new File(mediaPath.getAbsoluteFile(),file.getOriginalFilename()));\n      String fileName=file.getOriginalFilename();\n      String nameWithOutSuffix=fileName.substring(0,fileName.lastIndexOf('.'));\n      String fileSuffix=file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf('.') + 1);\n      Attachment attachment=new Attachment();\n      attachment.setAttachName(fileName);\n      attachment.setAttachPath(new StringBuffer(\"/upload/\").append(HaloUtil.YEAR).append(\"/\").append(HaloUtil.MONTH).append(\"/\").append(fileName).toString());\n      System.out.println(mediaPath.getAbsolutePath() + \"/\" + fileName);\n      BufferedImage sourceImg=ImageIO.read(new FileInputStream(mediaPath.getPath() + \"/\" + fileName));\n// bug_start\n      if (sourceImg.getWidth() < 500 && sourceImg.getHeight() < 500) {\n// bug_end\n        attachment.setAttachSmallPath(new StringBuffer(\"/upload/\").append(HaloUtil.YEAR).append(\"/\").append(HaloUtil.MONTH).append(\"/\").append(fileName).toString());\n      }\n else {\n        attachment.setAttachSmallPath(new StringBuffer(\"/upload/\").append(HaloUtil.YEAR).append(\"/\").append(HaloUtil.MONTH).append(\"/\").append(nameWithOutSuffix).append(\"_small.\").append(fileSuffix).toString());\n        HaloUtil.cutCenterImage(new StringBuffer(mediaPath.getAbsolutePath()).append(\"/\").append(fileName).toString(),new StringBuffer(mediaPath.getAbsolutePath()).append(\"/\").append(nameWithOutSuffix).append(\"_small.\").append(fileSuffix).toString(),500,500,fileSuffix);\n      }\n      attachment.setAttachType(file.getContentType());\n      attachment.setAttachSuffix(new StringBuffer(\".\").append(fileSuffix).toString());\n      attachment.setAttachCreated(HaloUtil.getDate());\n      attachmentService.saveByAttachment(attachment);\n      updateConst();\n      log.info(\"[\" + file.getOriginalFilename() + \"][\"+ mediaPath.getAbsolutePath()+ \"]\");\n      logsService.saveByLogs(new Logs(LogsRecord.UPLOAD_FILE,file.getOriginalFilename(),HaloUtil.getIpAddr(request),HaloUtil.getDate()));\n      result.put(\"success\",1);\n      result.put(\"message\",\"\");\n      result.put(\"url\",attachment.getAttachPath());\n    }\n catch (    Exception e) {\n      log.error(\"{0}\",e.getMessage());\n      result.put(\"success\",0);\n      result.put(\"message\",\"\");\n    }\n  }\n else {\n    log.error(\"\");\n  }\n  return result;\n}\n"}
{"INPUT": "public boolean isSQLMapTableCreated(String tableName1,String tableName2){\n// bug_start\n  return mSqlTableMap.get(getMapTableName(tableName1,tableName2)) == null;\n// bug_end\n}\n"}
{"INPUT": "@Override public Set<GroupModel> getGroups(){\n// bug_start\n  if (user.getGroupIds() == null && user.getGroupIds().size() == 0)   return Collections.EMPTY_SET;\n// bug_end\n  Set<GroupModel> groups=new HashSet<>();\n  for (  String id : user.getGroupIds()) {\n    groups.add(realm.getGroupById(id));\n  }\n  return groups;\n}\n"}
{"INPUT": "@Override public ServerServiceDefinition getObject() throws Exception {\n  final ServerInterceptor interceptor=serverInterceptor;\n// bug_start\n  if (interceptor != null) {\n// bug_end\n    return newServerServiceDefinition();\n  }\n  final ServerServiceDefinition spanService=newServerServiceDefinition();\n  return ServerInterceptors.intercept(spanService,interceptor);\n}\n"}
{"INPUT": "@Override public void visitMethodInsn(int opcode,String owner,String name,String desc){\n  if (opcode == Opcodes.INVOKEINTERFACE)   return;\n// bug_start\n  if (desc.indexOf('[') == -1 || desc.indexOf('L') == -1)   return;\n// bug_end\n  if (ClassParserUsingASM.this.slashedClassName.equals(owner))   return;\n  ClassDescriptor classDescriptor=DescriptorFactory.instance().getClassDescriptor(owner);\n  calledClassSet.add(classDescriptor);\n}\n"}
{"INPUT": "public boolean sink(LogEvent event){\n  EntryPosition entryPosition=null;\n  try {\n    CanalEntry.Entry entry=parseAndProfilingIfNecessary(event,true);\n    if (justForPositionTimestamp && logPosition.getPostion() == null && event.getWhen() > 0) {\n      entryPosition=new EntryPosition(searchBinlogFile,event.getLogPos(),event.getWhen() * 1000,event.getServerId());\n      logPosition.setPostion(entryPosition);\n    }\n    if (entry == null) {\n      return true;\n    }\n    String logfilename=entry.getHeader().getLogfileName();\n    Long logfileoffset=entry.getHeader().getLogfileOffset();\n    Long logposTimestamp=entry.getHeader().getExecuteTime();\n    Long serverId=entry.getHeader().getServerId();\n    if (CanalEntry.EntryType.TRANSACTIONBEGIN.equals(entry.getEntryType()) || CanalEntry.EntryType.TRANSACTIONEND.equals(entry.getEntryType())) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"compare exit condition:{},{},{}, startTimestamp={}...\",new Object[]{logfilename,logfileoffset,logposTimestamp,startTimestamp});\n      }\n      if (logposTimestamp >= startTimestamp) {\n        return false;\n      }\n    }\n// bug_start\n    if (StringUtils.equals(endPosition.getJournalName(),logfilename) && endPosition.getPosition() < logfileoffset) {\n// bug_end\n      return false;\n    }\n    if (CanalEntry.EntryType.TRANSACTIONEND.equals(entry.getEntryType())) {\n      entryPosition=new EntryPosition(logfilename,logfileoffset,logposTimestamp,serverId);\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"set {} to be pending start position before finding another proper one...\",entryPosition);\n      }\n      logPosition.setPostion(entryPosition);\n    }\n else     if (CanalEntry.EntryType.TRANSACTIONBEGIN.equals(entry.getEntryType())) {\n      entryPosition=new EntryPosition(logfilename,logfileoffset,logposTimestamp,serverId);\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"set {} to be pending start position before finding another proper one...\",entryPosition);\n      }\n      logPosition.setPostion(entryPosition);\n    }\n    lastPosition=buildLastPosition(entry);\n  }\n catch (  Throwable e) {\n    processSinkError(e,lastPosition,searchBinlogFile,4L);\n  }\n  return running;\n}\n"}
{"INPUT": "protected DB database(){\n// bug_start\n  if (!database.isAuthenticated() & (userName != null || password != null)) {\n// bug_end\n    if (!database.authenticate(userName,password)) {\n      logger.warn(\"Failed to authenticate user '{}' against database. Incorrect credentials.\",userName);\n    }\n  }\n  return database;\n}\n"}
{"INPUT": "@Override protected boolean removeEldestEntry(Map.Entry<K,V> eldest){\n// bug_start\n  if (size() >= maximumCacheSize) {\n// bug_end\n    V value=eldest.getValue();\n    evict.accept(value);\n    return true;\n  }\n  return false;\n}\n"}
{"INPUT": "public void testGetFolderPath(){\n// bug_start\n  assertTrue(WinspoolUtil.getPrinterInfo1().length > 0);\n// bug_end\n}\n"}
{"INPUT": "@Override public InputType getOutputType(int layerIndex,InputType... vertexInputs) throws InvalidInputTypeException {\n  if (vertexInputs.length != 1)   throw new InvalidInputTypeException(\"Invalid input type: cannot duplicate more than 1 input\");\n  int tsLength=1;\n  if (vertexInputs[0].getType() == InputType.Type.FF) {\n    return InputType.recurrent(((InputType.InputTypeFeedForward)vertexInputs[0]).getSize(),tsLength);\n  }\n// bug_start\n else   if (vertexInputs[0].getType() != InputType.Type.CNNFlat) {\n// bug_end\n    return InputType.recurrent(((InputType.InputTypeConvolutionalFlat)vertexInputs[0]).getFlattenedSize(),tsLength);\n  }\n else {\n    throw new InvalidInputTypeException(\"Invalid input type: cannot duplicate to time series non feed forward (or CNN flat) input (got: \" + vertexInputs[0] + \")\");\n  }\n}\n"}
{"INPUT": "private boolean eight_byte_size_ready(){\n  final long payload_length=ByteBuffer.wrap(tmpbuf).getLong();\n// bug_start\n  if (payload_length == 0) {\n// bug_end\n    decoding_error();\n    return false;\n  }\n  if (maxmsgsize >= 0 && payload_length - 1 > maxmsgsize) {\n    decoding_error();\n    return false;\n  }\n  if (payload_length - 1 > Integer.MAX_VALUE) {\n    decoding_error();\n    return false;\n  }\n  final int msg_size=(int)(payload_length - 1);\n  in_progress=new Msg(msg_size);\n  next_step(tmpbuf,1,flags_ready);\n  return true;\n}\n"}
{"INPUT": "@Override public Map<String,Object> postProcessModels(Map<String,Object> objs){\n  List<Object> models=(List<Object>)objs.get(\"models\");\n  for (  Object _mo : models) {\n    Map<String,Object> mo=(Map<String,Object>)_mo;\n    CodegenModel cm=(CodegenModel)mo.get(\"model\");\n    for (    CodegenProperty var : cm.vars) {\n      Map<String,Object> allowableValues=var.allowableValues;\n      if (allowableValues == null)       continue;\n      List<String> values=(List<String>)allowableValues.get(\"values\");\n// bug_start\n// bug_end\n      List<Map<String,String>> enumVars=new ArrayList<Map<String,String>>();\n      for (      String value : values) {\n        Map<String,String> enumVar=new HashMap<String,String>();\n        enumVar.put(\"name\",toVarName(value.toUpperCase()));\n        enumVar.put(\"value\",value);\n        enumVars.add(enumVar);\n      }\n      allowableValues.put(\"enumVars\",enumVars);\n    }\n  }\n  return objs;\n}\n"}
{"INPUT": "private void addDependentLanguages(PolyglotEngineImpl engine,Map<String,LanguageInfo> resolvedLanguages,PolyglotLanguage currentLanguage){\n  for (  String dependentLanguage : currentLanguage.cache.getDependentLanguages()) {\n    PolyglotLanguage dependent=engine.idToLanguage.get(dependentLanguage);\n// bug_start\n// bug_end\n    if (resolvedLanguages.containsKey(dependentLanguage)) {\n      continue;\n    }\n    resolvedLanguages.put(dependentLanguage,dependent.info);\n    addDependentLanguages(engine,resolvedLanguages,dependent);\n  }\n}\n"}
{"INPUT": "private GenericRow getGenericRow(GenericRecord rawRecord){\n  for (  final Field field : _dataStream.getSchema().getFields()) {\n    FieldSpec spec=_schemaExtractor.getSchema().getFieldSpecFor(field.name());\n// bug_start\n// bug_end\n    Object value=rawRecord.get(field.name());\n    if (value instanceof Utf8) {\n      value=((Utf8)value).toString();\n    }\n    if (value instanceof Array) {\n      value=transformAvroArrayToObjectArray((Array)value,spec);\n    }\n    if (value == null && spec.isSingleValueField()) {\n      value=getDefaultNullValue(spec);\n    }\n    _fieldMap.put(field.name(),value);\n  }\n  _genericRow.init(_fieldMap);\n  return _genericRow;\n}\n"}
{"INPUT": "@Override protected FieldStatsResponse newResponse(FieldStatsRequest request,AtomicReferenceArray shardsResponses,ClusterState clusterState){\n  int successfulShards=0;\n  int failedShards=0;\n  Map<String,Map<String,FieldStats>> indicesMergedFieldStats=new HashMap<>();\n  List<ShardOperationFailedException> shardFailures=new ArrayList<>();\n  for (int i=0; i < shardsResponses.length(); i++) {\n    Object shardValue=shardsResponses.get(i);\n    if (shardValue == null) {\n    }\n else     if (shardValue instanceof BroadcastShardOperationFailedException) {\n      failedShards++;\n      shardFailures.add(new DefaultShardOperationFailedException((BroadcastShardOperationFailedException)shardValue));\n    }\n else {\n      successfulShards++;\n      FieldStatsShardResponse shardResponse=(FieldStatsShardResponse)shardValue;\n      final String indexName;\n      if (\"cluster\".equals(request.level())) {\n        indexName=\"_all\";\n      }\n else       if (\"indices\".equals(request.level())) {\n        indexName=shardResponse.getIndex();\n      }\n else {\n        throw new IllegalArgumentException(\"Illegal level option [\" + request.level() + \"]\");\n      }\n      Map<String,FieldStats> indexMergedFieldStats=indicesMergedFieldStats.get(indexName);\n      if (indexMergedFieldStats == null) {\n        indicesMergedFieldStats.put(indexName,indexMergedFieldStats=new HashMap<>());\n      }\n      Map<String,FieldStats> fieldStats=shardResponse.getFieldStats();\n      for (      Map.Entry<String,FieldStats> entry : fieldStats.entrySet()) {\n        FieldStats existing=indexMergedFieldStats.get(entry.getKey());\n        if (existing != null) {\n          if (existing.getType() != entry.getValue().getType()) {\n            throw new IllegalStateException(\"trying to merge the field stats of field [\" + entry.getKey() + \"] from index [\"+ shardResponse.getIndex()+ \"] but the field type is incompatible, try to set the 'level' option to 'indices'\");\n          }\n          existing.append(entry.getValue());\n        }\n else {\n          indexMergedFieldStats.put(entry.getKey(),entry.getValue());\n        }\n      }\n    }\n  }\n  if (request.getIndexConstraints().length != 0) {\n    Set<String> fieldStatFields=new HashSet<>(Arrays.asList(request.getFields()));\n    for (    IndexConstraint indexConstraint : request.getIndexConstraints()) {\n      Iterator<Map.Entry<String,Map<String,FieldStats>>> iterator=indicesMergedFieldStats.entrySet().iterator();\n      while (iterator.hasNext()) {\n        Map.Entry<String,Map<String,FieldStats>> entry=iterator.next();\n        FieldStats indexConstraintFieldStats=entry.getValue().get(indexConstraint.getField());\n// bug_start\n// bug_end\n        if (indexConstraintFieldStats.match(indexConstraint)) {\n          if (fieldStatFields.contains(indexConstraint.getField()) == false) {\n            entry.getValue().remove(indexConstraint.getField());\n          }\n        }\n else {\n          iterator.remove();\n        }\n      }\n    }\n  }\n  return new FieldStatsResponse(shardsResponses.length(),successfulShards,failedShards,shardFailures,indicesMergedFieldStats);\n}\n"}
{"INPUT": "private void appendPhotos(final StringBuilder builder,final Map<String,List<ContentValues>> contentValuesListMap){\n  List<ContentValues> contentValuesList=contentValuesListMap.get(Photo.CONTENT_ITEM_TYPE);\n  if (contentValuesList != null) {\n    for (    ContentValues contentValues : contentValuesList) {\n      byte[] data=contentValues.getAsByteArray(Photo.PHOTO);\n// bug_start\n// bug_end\n      final String photoType;\n      if (data.length >= 3 && data[0] == 'G' && data[1] == 'I' && data[2] == 'F') {\n        photoType=\"GIF\";\n      }\n else       if (data.length >= 4 && data[0] == (byte)0x89 && data[1] == 'P' && data[2] == 'N' && data[3] == 'G') {\n        photoType=\"PNG\";\n      }\n else       if (data.length >= 2 && data[0] == (byte)0xff && data[1] == (byte)0xd8) {\n        photoType=\"JPEG\";\n      }\n else {\n        Log.d(LOG_TAG,\"Unknown photo type. Ignore.\");\n        continue;\n      }\n      String photoString=VCardUtils.encodeBase64(data);\n      if (photoString.length() > 0) {\n        appendVCardPhotoLine(builder,photoString,photoType);\n      }\n    }\n  }\n}\n"}
{"INPUT": "@Override public <A>boolean compareAndSwap(long recid,A expectedOldValue,A newValue,Serializer<A> serializer){\n  try {\n    locks.lock(recid);\n    CacheItem item=checkClosed(items).get(recid);\n    Object oldValue=item == null ? null : item.get();\n// bug_start\n    if (item != null && oldValue != null && item.getRecid() == recid && (oldValue == expectedOldValue || oldValue.equals(expectedOldValue))) {\n// bug_end\n      putItemIntoCache(recid,newValue);\n      getWrappedEngine().update(recid,newValue,serializer);\n      return true;\n    }\n else {\n      boolean ret=getWrappedEngine().compareAndSwap(recid,expectedOldValue,newValue,serializer);\n      if (ret)       putItemIntoCache(recid,newValue);\n      return ret;\n    }\n  }\n  finally {\n    locks.unlock(recid);\n  }\n}\n"}
{"INPUT": "public static AddressBookParsedResult parse(Result result){\n  String rawText=result.getText();\n// bug_start\n  if (rawText == null || rawText.indexOf(\"MEMORY\") < 0 || rawText.indexOf(\"\\r\\n\") < 0) {\n// bug_end\n    return null;\n  }\n  String name=matchSinglePrefixedField(\"NAME1:\",rawText,'\\r',true);\n  String pronunciation=matchSinglePrefixedField(\"NAME2:\",rawText,'\\r',true);\n  String[] phoneNumbers=matchMultipleValuePrefix(\"TEL\",3,rawText,true);\n  String[] emails=matchMultipleValuePrefix(\"MAIL\",3,rawText,true);\n  String note=matchSinglePrefixedField(\"MEMORY:\",rawText,'\\r',false);\n  String address=matchSinglePrefixedField(\"ADD:\",rawText,'\\r',true);\n  String[] addresses=address == null ? null : new String[]{address};\n  return new AddressBookParsedResult(maybeWrap(name),pronunciation,phoneNumbers,null,emails,null,null,note,addresses,null,null,null,null,null);\n}\n"}
{"INPUT": "public boolean usesSUTime(){\n// bug_start\n  return useSUTime && applyNumericClassifiers;\n// bug_end\n}\n"}
{"INPUT": "private void validateEntityBodyParam(ParamDetail entityBodyParam){\n  String entityBodyAttributeValue=resource.getEntityBodyAttributeValue();\n  if (!entityBodyAttributeValue.equals(entityBodyParam.getVarName())) {\n    throw new BallerinaConnectorException(\"expected '\" + entityBodyAttributeValue + \"' as param name, but found '\"+ entityBodyParam.getVarName()+ \"'\");\n  }\n  int type=entityBodyParam.getVarType().getTag();\n// bug_start\n  if (type == TypeTags.STRUCT_TAG || type == TypeTags.JSON_TAG || type == TypeTags.XML_TAG || type == TypeTags.STRING_TAG || type == TypeTags.BLOB_TAG) {\n// bug_end\n    this.entityBody=entityBodyParam;\n    paramCount++;\n  }\n else {\n    throw new BallerinaConnectorException(\"incompatible entity-body type : \" + entityBodyParam.getVarType().getName());\n  }\n}\n"}
{"INPUT": "private Object getValue(@NotNull Object value){\n  if (isPrepared()) {\n    preparedValueList.add(value);\n    return \"?\";\n  }\n// bug_start\n  return (value instanceof Number || value instanceof Boolean) && DATABASE_POSTGRESQL.equals(getDatabase()) ? value : \"'\" + value + \"'\";\n// bug_end\n}\n"}
{"INPUT": "private static boolean skipCTX(Class c){\n// bug_start\n  return (c.getName().startsWith(\"java.lang.invoke.\") || c.getName().contains(\"$$Lambda$\"));\n// bug_end\n}\n"}
{"INPUT": "protected boolean determineTraitStatus(){\n// bug_start\n  return typeDecl != null && (typeDecl.getKind() == TypeDeclaration.Kind.TRAIT || typeDecl.getTypeClassDef().isTraitable() || typeDecl.getTypeClass().getAnnotation(Traitable.class) != null) || Thing.class.isAssignableFrom(cls) || TraitableBean.class.isAssignableFrom(cls) || (this.getTypeDeclaration() != null);\n// bug_end\n}\n"}
{"INPUT": "private AtmosphereFramework getPreInitializedAtmosphere(ServletConfig vaadinServletConfig){\n  String attributeName=JSR356WebsocketInitializer.getAttributeName(vaadinServletConfig.getServletName());\n  Object framework=vaadinServletConfig.getServletContext().getAttribute(attributeName);\n// bug_start\n  if (framework != null && framework instanceof AtmosphereFramework) {\n// bug_end\n    return (AtmosphereFramework)framework;\n  }\n  return null;\n}\n"}
{"INPUT": "@Override public void onRemoteOperationFinish(RemoteOperation operation,RemoteOperationResult result){\n  Log_OC.d(TAG,\"Received result of operation in FileActivity - common behaviour for all the \" + \"FileActivities \");\n  mFileOperationsHelper.setOpIdWaitingFor(Long.MAX_VALUE);\n  dismissLoadingDialog();\n// bug_start\n  if (!result.isSuccess() && (result.getCode() == ResultCode.UNAUTHORIZED || result.isIdPRedirection() || (result.isException() && result.getException() instanceof AuthenticatorException))) {\n// bug_end\n    requestCredentialsUpdate(this);\n    if (result.getCode() == ResultCode.UNAUTHORIZED) {\n      dismissLoadingDialog();\n      Toast t=Toast.makeText(this,ErrorMessageAdapter.getErrorCauseMessage(result,operation,getResources()),Toast.LENGTH_LONG);\n      t.show();\n    }\n  }\n else   if (operation == null || operation instanceof CreateShareWithShareeOperation || operation instanceof UnshareOperation || operation instanceof SynchronizeFolderOperation || operation instanceof UpdateShareViaLinkOperation || operation instanceof UpdateSharePermissionsOperation) {\n    if (result.isSuccess()) {\n      updateFileFromDB();\n    }\n else     if (result.getCode() != ResultCode.CANCELLED) {\n      Toast t=Toast.makeText(this,ErrorMessageAdapter.getErrorCauseMessage(result,operation,getResources()),Toast.LENGTH_LONG);\n      t.show();\n    }\n  }\n else   if (operation instanceof CreateShareViaLinkOperation) {\n    onCreateShareViaLinkOperationFinish((CreateShareViaLinkOperation)operation,result);\n  }\n else   if (operation instanceof SynchronizeFileOperation) {\n    onSynchronizeFileOperationFinish((SynchronizeFileOperation)operation,result);\n  }\n else   if (operation instanceof GetSharesForFileOperation) {\n    if (result.isSuccess() || result.getCode() == ResultCode.SHARE_NOT_FOUND) {\n      updateFileFromDB();\n    }\n else {\n      Toast t=Toast.makeText(this,ErrorMessageAdapter.getErrorCauseMessage(result,operation,getResources()),Toast.LENGTH_LONG);\n      t.show();\n    }\n  }\n}\n"}
{"INPUT": "@Override public void damage(float amount){\n  CallEntity.onPlayerDamage(this,calculateDamage(amount));\n// bug_start\n  if (health <= 0 && !dead && isLocal) {\n// bug_end\n    CallEntity.onPlayerDeath(this);\n  }\n}\n"}
{"INPUT": "public boolean updateTopicRouteInfoFromNameServer(final String topic,boolean isDefault,DefaultMQProducer defaultMQProducer){\n  try {\n    if (this.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS,TimeUnit.MILLISECONDS)) {\n      try {\n        TopicRouteData topicRouteData;\n        if (isDefault && defaultMQProducer != null) {\n          topicRouteData=this.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),1000 * 3);\n          if (topicRouteData != null) {\n            for (            QueueData data : topicRouteData.getQueueDatas()) {\n              int queueNums=Math.min(defaultMQProducer.getDefaultTopicQueueNums(),data.getReadQueueNums());\n              data.setReadQueueNums(queueNums);\n              data.setWriteQueueNums(queueNums);\n            }\n          }\n        }\n else {\n          topicRouteData=this.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic,1000 * 3);\n        }\n        if (topicRouteData != null) {\n          TopicRouteData old=this.topicRouteTable.get(topic);\n          boolean changed=topicRouteDataIsChange(old,topicRouteData);\n          if (!changed) {\n            changed=this.isNeedUpdateTopicRouteInfo(topic);\n          }\n else {\n            log.info(\"the topic[{}] route info changed, old[{}] ,new[{}]\",topic,old,topicRouteData);\n          }\n          if (changed) {\n            TopicRouteData cloneTopicRouteData=topicRouteData.cloneTopicRouteData();\n            for (            BrokerData bd : topicRouteData.getBrokerDatas()) {\n              this.brokerAddrTable.put(bd.getBrokerName(),bd.getBrokerAddrs());\n            }\n{\n              TopicPublishInfo publishInfo=topicRouteData2TopicPublishInfo(topic,topicRouteData);\n              publishInfo.setHaveTopicRouterInfo(true);\n              Iterator<Entry<String,MQProducerInner>> it=this.producerTable.entrySet().iterator();\n              while (it.hasNext()) {\n                Entry<String,MQProducerInner> entry=it.next();\n                MQProducerInner impl=entry.getValue();\n                if (impl != null) {\n                  impl.updateTopicPublishInfo(topic,publishInfo);\n                }\n              }\n            }\n{\n              Set<MessageQueue> subscribeInfo=topicRouteData2TopicSubscribeInfo(topic,topicRouteData);\n              Iterator<Entry<String,MQConsumerInner>> it=this.consumerTable.entrySet().iterator();\n              while (it.hasNext()) {\n                Entry<String,MQConsumerInner> entry=it.next();\n                MQConsumerInner impl=entry.getValue();\n                if (impl != null) {\n                  impl.updateTopicSubscribeInfo(topic,subscribeInfo);\n                }\n              }\n            }\n            log.info(\"topicRouteTable.put. Topic = {}, TopicRouteData[{}]\",topic,cloneTopicRouteData);\n            this.topicRouteTable.put(topic,cloneTopicRouteData);\n            return true;\n          }\n        }\n else {\n          log.warn(\"updateTopicRouteInfoFromNameServer, getTopicRouteInfoFromNameServer return null, Topic: {}\",topic);\n        }\n      }\n catch (      MQClientException e) {\n// bug_start\n        if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX) && !topic.equals(MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC)) {\n// bug_end\n          log.warn(\"updateTopicRouteInfoFromNameServer Exception\",e);\n        }\n      }\ncatch (      RemotingException e) {\n        log.error(\"updateTopicRouteInfoFromNameServer Exception\",e);\n        throw new IllegalStateException(e);\n      }\n finally {\n        this.lockNamesrv.unlock();\n      }\n    }\n else {\n      log.warn(\"updateTopicRouteInfoFromNameServer tryLock timeout {}ms\",LOCK_TIMEOUT_MILLIS);\n    }\n  }\n catch (  InterruptedException e) {\n    log.warn(\"updateTopicRouteInfoFromNameServer Exception\",e);\n  }\n  return false;\n}\n"}
{"INPUT": "private boolean isCallerTestClient(){\n// bug_start\n  if (Build.VERSION.SDK_INT >= 21 && Build.VERSION.SDK_INT < 28) {\n// bug_end\n    return true;\n  }\n  RemoteUserInfo info=mSession.getCurrentControllerInfo();\n  assertNotNull(info);\n  return mExpectedCallerPackageName.equals(info.getPackageName());\n}\n"}
{"INPUT": "public void onBarrierReleased(BarrierReleasedEvent event){\n  String switchToProject=new String(switchToProject_);\n  if (Desktop.isDesktop()) {\n// bug_start\n    if (Desktop.getFrame().isCocoa() && switchToProject_ != null && switchToProject_ != \"none\") {\n// bug_end\n      Desktop.getFrame().setPendingProject(switchToProject_);\n      switchToProject=null;\n    }\n else {\n      Desktop.getFrame().setPendingQuit(switchToProject_ != null ? DesktopFrame.PENDING_QUIT_RESTART_AND_RELOAD : DesktopFrame.PENDING_QUIT_AND_EXIT);\n    }\n  }\n  server_.quitSession(saveChanges_,switchToProject,switchToRVersion_,GWT.getHostPageBaseURL(),new ServerRequestCallback<Boolean>(){\n    @Override public void onResponseReceived(    Boolean response){\n      if (response) {\n        if (switchToProject_ == null)         progress.dismiss();\n        if (onQuitAcknowledged_ != null)         onQuitAcknowledged_.execute();\n      }\n else {\n        onFailedToQuit();\n      }\n    }\n    @Override public void onError(    ServerError error){\n      onFailedToQuit();\n    }\n    private void onFailedToQuit(){\n      progress.dismiss();\n      if (Desktop.isDesktop()) {\n        Desktop.getFrame().setPendingQuit(DesktopFrame.PENDING_QUIT_NONE);\n      }\n    }\n  }\n);\n}\n"}
{"INPUT": "@Override public void onResume(){\n  super.onResume();\n// bug_start\n  if (!descriptionEdit.getText().toString().isEmpty() || descriptionCaption.getVisibility() != View.VISIBLE || descriptionEdit.hasFocus()) {\n// bug_end\n    descriptionCaption.setVisibility(View.VISIBLE);\n    addDelDescription.setText(app.getString(R.string.delete_description));\n  }\n else {\n    descriptionCaption.setVisibility(View.GONE);\n    addDelDescription.setText(app.getString(R.string.add_description));\n  }\n}\n"}
{"INPUT": "static ParamDescriptor of(Param param,StarlarkSemantics starlarkSemantics){\n  Class<?> type=param.type();\n  Class<?> generic=param.generic1();\n  boolean noneable=param.noneable();\n  String defaultExpr=param.defaultValue();\n  String disabledByFlag=null;\n  if (!starlarkSemantics.isFeatureEnabledBasedOnTogglingFlags(param.enableOnlyWithFlag(),param.disableWithFlag())) {\n    defaultExpr=param.valueWhenDisabled();\n    disabledByFlag=!param.enableOnlyWithFlag().isEmpty() ? param.enableOnlyWithFlag() : param.disableWithFlag();\n    Preconditions.checkState(!disabledByFlag.isEmpty());\n  }\n// bug_start\n  return new ParamDescriptor(param.name(),defaultExpr,type,generic,noneable,param.named() || (param.legacyNamed() && !starlarkSemantics.incompatibleRestrictNamedParams()),param.positional(),getType(type,generic,param.allowedTypes(),noneable),disabledByFlag);\n// bug_end\n}\n"}
{"INPUT": "@Override public SocketState process(SocketWrapperBase<?> socketWrapper,SocketEvent status) throws IOException {\n  SocketState state=SocketState.CLOSED;\n  Iterator<DispatchType> dispatches=null;\n  do {\n    if (dispatches != null) {\n      DispatchType nextDispatch=dispatches.next();\n      if (getLog().isDebugEnabled()) {\n        getLog().debug(\"Processing dispatch type: [\" + nextDispatch + \"]\");\n      }\n      state=dispatch(nextDispatch.getSocketStatus());\n      if (!dispatches.hasNext()) {\n        state=checkForPipelinedData(state,socketWrapper);\n      }\n    }\n else     if (status == SocketEvent.DISCONNECT) {\n    }\n else     if (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) {\n      state=dispatch(status);\n      state=checkForPipelinedData(state,socketWrapper);\n    }\n else     if (status == SocketEvent.OPEN_WRITE) {\n      state=SocketState.LONG;\n    }\n else     if (status == SocketEvent.OPEN_READ) {\n      state=service(socketWrapper);\n    }\n else     if (status == SocketEvent.CONNECT_FAIL) {\n      logAccess(socketWrapper);\n    }\n else {\n      state=SocketState.CLOSED;\n    }\n    if (getLog().isDebugEnabled()) {\n      getLog().debug(\"Socket: [\" + socketWrapper + \"], Status in: [\"+ status+ \"], State out: [\"+ state+ \"]\");\n    }\n// bug_start\n    if (state != SocketState.CLOSED && isAsync()) {\n// bug_end\n      state=asyncPostProcess();\n      if (getLog().isDebugEnabled()) {\n        getLog().debug(\"Socket: [\" + socketWrapper + \"], State after async post processing: [\"+ state+ \"]\");\n      }\n    }\n    if (dispatches == null || !dispatches.hasNext()) {\n      dispatches=getIteratorAndClearDispatches();\n    }\n  }\n while (state == SocketState.ASYNC_END || dispatches != null && state != SocketState.CLOSED);\n  return state;\n}\n"}
{"INPUT": "public static ImmutableSegment load(File indexDir,IndexLoadingConfig indexLoadingConfig,@Nullable Schema schema) throws Exception {\n  Preconditions.checkArgument(indexDir.isDirectory(),\"Index directory: {} does not exist or is not a directory\",indexDir);\n  String segmentName=indexDir.getName();\n  SegmentVersion segmentVersionToLoad=indexLoadingConfig.getSegmentVersion();\n  if (segmentVersionToLoad != null && !SegmentDirectoryPaths.segmentDirectoryFor(indexDir,segmentVersionToLoad).isDirectory()) {\n    SegmentVersion segmentVersionOnDisk=new SegmentMetadataImpl(indexDir).getSegmentVersion();\n    if (segmentVersionOnDisk != segmentVersionToLoad) {\n      LOGGER.info(\"Segment: {} needs to be converted from version: {} to {}\",segmentName,segmentVersionOnDisk,segmentVersionToLoad);\n      SegmentFormatConverter converter=SegmentFormatConverterFactory.getConverter(segmentVersionOnDisk,segmentVersionToLoad);\n      LOGGER.info(\"Using converter: {} to up-convert segment: {}\",converter.getClass().getName(),segmentName);\n      converter.convert(indexDir);\n      LOGGER.info(\"Successfully up-converted segment: {} from version: {} to {}\",segmentName,segmentVersionOnDisk,segmentVersionToLoad);\n    }\n  }\n  try (SegmentPreProcessor preProcessor=new SegmentPreProcessor(indexDir,indexLoadingConfig,schema)){\n    preProcessor.process();\n  }\n   SegmentMetadataImpl segmentMetadata=new SegmentMetadataImpl(indexDir);\n  ReadMode readMode=indexLoadingConfig.getReadMode();\n  SegmentDirectory segmentDirectory=SegmentDirectory.createFromLocalFS(indexDir,segmentMetadata,readMode);\n  SegmentDirectory.Reader segmentReader=segmentDirectory.createReader();\n  Map<String,ColumnIndexContainer> indexContainerMap=new HashMap<>();\n  for (  Map.Entry<String,ColumnMetadata> entry : segmentMetadata.getColumnMetadataMap().entrySet()) {\n    indexContainerMap.put(entry.getKey(),new PhysicalColumnIndexContainer(segmentReader,entry.getValue(),indexLoadingConfig,indexDir));\n  }\n  if (schema == null) {\n    schema=segmentMetadata.getSchema();\n  }\n  VirtualColumnProviderFactory.addBuiltInVirtualColumnsToSegmentSchema(schema,segmentName);\n  for (  FieldSpec fieldSpec : schema.getAllFieldSpecs()) {\n    if (fieldSpec.isVirtualColumn()) {\n      String columnName=fieldSpec.getName();\n      VirtualColumnProvider provider=VirtualColumnProviderFactory.buildProvider(fieldSpec.getVirtualColumnProvider());\n      VirtualColumnContext context=new VirtualColumnContext(fieldSpec,segmentMetadata.getTotalDocs());\n      indexContainerMap.put(columnName,provider.buildColumnIndexContainer(context));\n      segmentMetadata.getColumnMetadataMap().put(columnName,provider.buildMetadata(context));\n    }\n  }\n  StarTreeIndexContainer starTreeIndexContainer=null;\n// bug_start\n  if (segmentMetadata.getStarTreeV2MetadataList() != null || segmentMetadata.getStarTreeMetadata() != null) {\n// bug_end\n    starTreeIndexContainer=new StarTreeIndexContainer(SegmentDirectoryPaths.findSegmentDirectory(indexDir),segmentMetadata,indexContainerMap,readMode);\n  }\n  return new ImmutableSegmentImpl(segmentDirectory,segmentMetadata,indexContainerMap,starTreeIndexContainer);\n}\n"}
{"INPUT": "@Override public final void start() throws Exception {\nsynchronized (_lock) {\n    try {\n// bug_start\n      if (_state == __STARTED || _state == __STARTING || _state == __FAILED)       return;\n// bug_end\n      setStarting();\n      doStart();\n      setStarted();\n    }\n catch (    Throwable e) {\n      setFailed(e);\n      throw e;\n    }\n  }\n}\n"}
{"INPUT": "private static int validateContentVersion(String versionString) throws SettingsImportExportException {\n  if (versionString == null) {\n    throw new SettingsImportExportException(\"Missing content version\");\n  }\n  int version;\n  try {\n    version=Integer.parseInt(versionString);\n  }\n catch (  NumberFormatException e) {\n    throw new SettingsImportExportException(\"Invalid content version: \" + versionString);\n  }\n// bug_start\n  if (version < 1 || version > Settings.VERSION) {\n// bug_end\n    throw new SettingsImportExportException(\"Unsupported content version: \" + versionString);\n  }\n  return version;\n}\n"}
{"INPUT": "@Override public boolean include(List<SpanBo> transaction){\n// bug_start\n  if (includeServiceType(fromServiceCode,ServiceType.CLIENT) || includeServiceType(fromServiceCode,ServiceType.USER)) {\n// bug_end\n    for (    SpanBo span : transaction) {\n      if (span.isRoot() && includeServiceType(toServiceCode,span.getServiceType()) && toApplicationName.equals(span.getApplicationId())) {\n        if (findError) {\n          return span.getErrCode() > 0 && checkResponseCondition(span.getElapsed());\n        }\n else {\n          return span.getErrCode() == 0 && checkResponseCondition(span.getElapsed());\n        }\n      }\n    }\n  }\n else   if (includeUnknown(toServiceCode)) {\n    for (    SpanBo span : transaction) {\n      if (includeServiceType(fromServiceCode,span.getServiceType()) && fromApplicationName.equals(span.getApplicationId())) {\n        List<SpanEventBo> eventBoList=span.getSpanEventBoList();\n        if (eventBoList == null) {\n          continue;\n        }\n        for (        SpanEventBo event : eventBoList) {\n          if (event.getServiceType().isRpcClient() && toApplicationName.equals(event.getDestinationId())) {\n            if (findError) {\n              return event.hasException() && checkResponseCondition(event.getEndElapsed());\n            }\n else {\n              return !event.hasException() && checkResponseCondition(event.getEndElapsed());\n            }\n          }\n        }\n      }\n    }\n  }\n else   if (includeWas(toServiceCode)) {\n    for (    SpanBo srcSpan : transaction) {\n      if (includeServiceType(fromServiceCode,srcSpan.getServiceType()) && fromApplicationName.equals(srcSpan.getApplicationId())) {\n        for (        SpanBo destSpan : transaction) {\n          if (destSpan.getParentSpanId() != srcSpan.getSpanId()) {\n            continue;\n          }\n          if (includeServiceType(toServiceCode,destSpan.getServiceType()) && toApplicationName.equals(destSpan.getApplicationId())) {\n            if (findError) {\n              return destSpan.getErrCode() > 0 && checkResponseCondition(destSpan.getElapsed());\n            }\n else {\n              return destSpan.getErrCode() == 0 && checkResponseCondition(destSpan.getElapsed());\n            }\n          }\n        }\n      }\n    }\n  }\n else {\n    for (    SpanBo span : transaction) {\n      if (includeServiceType(fromServiceCode,span.getServiceType()) && fromApplicationName.equals(span.getApplicationId())) {\n        List<SpanEventBo> eventBoList=span.getSpanEventBoList();\n        if (eventBoList == null) {\n          continue;\n        }\n        for (        SpanEventBo event : eventBoList) {\n          if (includeServiceType(toServiceCode,event.getServiceType()) && toApplicationName.equals(event.getDestinationId())) {\n            if (findError) {\n              return event.hasException() && checkResponseCondition(event.getEndElapsed());\n            }\n else {\n              return !event.hasException() && checkResponseCondition(event.getEndElapsed());\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "@Override public Iterator<E> iterator(){\n  Iterator<E> it=singletonList(field).iterator();\n  if (field instanceof EmbeddableTableField)   return new FlatteningIterator<E>(it){\n    @Override List<E> flatten(    E e){\n      return (List<E>)Arrays.asList(((EmbeddableTableField<?,?>)e).fields);\n    }\n  }\n;\n// bug_start\n else   if (field instanceof Val && EmbeddableRecord.class.isAssignableFrom(field.getType()))   return new FlatteningIterator<E>(it){\n// bug_end\n    @Override List<E> flatten(    E e){\n      return (List<E>)Arrays.asList(embeddedFields(field));\n    }\n  }\n;\n else   return it;\n}\n"}
{"INPUT": "public List<RuleMatch> check(AnnotatedText annotatedText,boolean tokenizeText,ParagraphHandling paraMode,RuleMatchListener listener,Mode mode,Level level,@Nullable ExecutorService remoteRulesThreadPool) throws IOException {\n  List<String> sentences;\n  if (tokenizeText) {\n    sentences=sentenceTokenize(annotatedText.getPlainText());\n  }\n else {\n    sentences=new ArrayList<>();\n    sentences.add(annotatedText.getPlainText());\n  }\n  List<Rule> allRules=getAllRules();\n  if (printStream != null) {\n    printIfVerbose(allRules.size() + \" rules activated for language \" + language);\n  }\n  unknownWords=new HashSet<>();\n  List<AnalyzedSentence> analyzedSentences=analyzeSentences(sentences);\n// bug_start\n  if (mode != Mode.TEXTLEVEL_ONLY && level == Level.DEFAULT) {\n// bug_end\n    allRules=allRules.stream().filter(null).collect(Collectors.toList());\n  }\n  List<RuleMatch> remoteMatches=new LinkedList<>();\n  List<FutureTask<RemoteRuleResult>> remoteRuleTasks=null;\n  List<RemoteRule> remoteRules=new LinkedList<>();\n  Map<Integer,List<RuleMatch>> cachedResults=new HashMap<>();\n  Map<Integer,Integer> matchOffset=new HashMap<>();\n  if (remoteRulesThreadPool != null && mode != Mode.TEXTLEVEL_ONLY) {\n    remoteRuleTasks=new LinkedList<>();\n    checkRemoteRules(remoteRulesThreadPool,allRules,analyzedSentences,mode,level,remoteRuleTasks,remoteRules,cachedResults,matchOffset);\n  }\n  List<RuleMatch> ruleMatches=performCheck(analyzedSentences,sentences,allRules,paraMode,annotatedText,listener,mode,level,remoteRulesThreadPool == null);\n  fetchRemoteRuleResults(mode,level,analyzedSentences,remoteMatches,remoteRuleTasks,remoteRules,cachedResults,matchOffset,annotatedText);\n  ruleMatches.addAll(remoteMatches);\n  ruleMatches=new SameRuleGroupFilter().filter(ruleMatches);\n  if (cleanOverlappingMatches) {\n    ruleMatches=new CleanOverlappingFilter(language).filter(ruleMatches);\n  }\n  ruleMatches=new LanguageDependentFilter(language,this.enabledRules,this.disabledRuleCategories).filter(ruleMatches);\n  ruleMatches=applyCustomFilters(ruleMatches,annotatedText);\n  return ruleMatches;\n}\n"}
{"INPUT": "private Sampler next2(){\n  if (isFirst()) {\n    calls=0;\n    noFailingSamples=0;\n    res=new SampleResult();\n    res.setSampleLabel(getName());\n    res.setSuccessful(true);\n    res.sampleStart();\n    prevEndTime=res.getStartTime();\n    pauseTime=0;\n  }\n  Sampler returnValue=super.next();\n// bug_start\n  if (returnValue == null && !(calls == 0)) {\n// bug_end\n    if (res != null) {\n      res.setIdleTime(pauseTime + res.getIdleTime());\n      res.sampleEnd();\n      res.setResponseMessage(\"Number of samples in transaction : \" + calls + \", number of failing samples : \"+ noFailingSamples);\n      if (res.isSuccessful()) {\n        res.setResponseCodeOK();\n      }\n      JMeterContext threadContext=getThreadContext();\n      JMeterVariables threadVars=threadContext.getVariables();\n      SamplePackage pack=(SamplePackage)threadVars.getObject(JMeterThread.PACKAGE_OBJECT);\n      if (pack == null) {\n        log.warn(\"Could not fetch SamplePackage\");\n      }\n else {\n        SampleEvent event=new SampleEvent(res,threadContext.getThreadGroup().getName(),threadVars,true);\n        res=null;\n        if (!getThreadContext().isReinitializingSubControllers()) {\n          lnf.notifyListeners(event,pack.getSampleListeners());\n        }\n      }\n    }\n  }\n else {\n    calls++;\n  }\n  return returnValue;\n}\n"}
{"INPUT": "public Request<DescribeElasticLoadBalancersRequest> marshall(DescribeElasticLoadBalancersRequest describeElasticLoadBalancersRequest){\n  if (describeElasticLoadBalancersRequest == null) {\n    throw new AmazonClientException(\"Invalid argument passed to marshall(...)\");\n  }\n  Request<DescribeElasticLoadBalancersRequest> request=new DefaultRequest<DescribeElasticLoadBalancersRequest>(describeElasticLoadBalancersRequest,\"AWSOpsWorks\");\n  String target=\"OpsWorks_20130218.DescribeElasticLoadBalancers\";\n  request.addHeader(\"X-Amz-Target\",target);\n  request.addHeader(\"Content-Type\",\"application/x-amz-json-1.1\");\n  request.setHttpMethod(HttpMethodName.POST);\n  String uriResourcePath=\"\";\n  uriResourcePath=uriResourcePath.replaceAll(\"//\",\"/\");\n  if (uriResourcePath.contains(\"?\")) {\n    String queryString=uriResourcePath.substring(uriResourcePath.indexOf(\"?\") + 1);\n    uriResourcePath=uriResourcePath.substring(0,uriResourcePath.indexOf(\"?\"));\n    for (    String s : queryString.split(\"[;&]\")) {\n      String[] nameValuePair=s.split(\"=\");\n      if (nameValuePair.length == 2) {\n        request.addParameter(nameValuePair[0],nameValuePair[1]);\n      }\n else {\n        request.addParameter(s,null);\n      }\n    }\n  }\n  request.setResourcePath(uriResourcePath);\n  try {\n    StringWriter stringWriter=new StringWriter();\n    JSONWriter jsonWriter=new JSONWriter(stringWriter);\n    jsonWriter.object();\n    if (describeElasticLoadBalancersRequest.getStackId() != null) {\n      jsonWriter.key(\"StackId\").value(describeElasticLoadBalancersRequest.getStackId());\n    }\n    java.util.List<String> layerIdsList=describeElasticLoadBalancersRequest.getLayerIds();\n// bug_start\n    if (layerIdsList != null && layerIdsList.size() > 0) {\n// bug_end\n      jsonWriter.key(\"LayerIds\");\n      jsonWriter.array();\n      for (      String layerIdsListValue : layerIdsList) {\n        if (layerIdsListValue != null) {\n          jsonWriter.value(layerIdsListValue);\n        }\n      }\n      jsonWriter.endArray();\n    }\n    jsonWriter.endObject();\n    String snippet=stringWriter.toString();\n    byte[] content=snippet.getBytes(\"UTF-8\");\n    request.setContent(new StringInputStream(snippet));\n    request.addHeader(\"Content-Length\",Integer.toString(content.length));\n  }\n catch (  Throwable t) {\n    throw new AmazonClientException(\"Unable to marshall request to JSON: \" + t.getMessage(),t);\n  }\n  return request;\n}\n"}
{"INPUT": "public Distribution(Path path){\n  this.path=path;\n  String filename=path.getFileName().toString();\n  if (filename.endsWith(\".gz\")) {\n    this.packaging=Packaging.TAR;\n  }\n else   if (filename.endsWith(\".docker.tar\")) {\n    this.packaging=Packaging.DOCKER;\n  }\n else {\n    int lastDot=filename.lastIndexOf('.');\n    this.packaging=Packaging.valueOf(filename.substring(lastDot + 1).toUpperCase(Locale.ROOT));\n  }\n  this.platform=filename.contains(\"windows\") ? Platform.WINDOWS : Platform.LINUX;\n  this.flavor=filename.contains(\"oss\") ? Flavor.OSS : Flavor.DEFAULT;\n// bug_start\n  this.hasJdk=filename.contains(\"no-jdk\") == false && Platforms.IS_BUNDLED_JDK_SUPPORTED;\n// bug_end\n  String version=filename.split(\"-\",3)[1];\n  if (filename.contains(\"-SNAPSHOT\")) {\n    version+=\"-SNAPSHOT\";\n  }\n  this.version=version;\n}\n"}
{"INPUT": "private void maintainCqStats(Object event,long incrementAmount){\n  CqService cqService=region.getGemFireCache().getCqService();\n  if (cqService != null) {\n    try {\n      if (event instanceof HAEventWrapper) {\n        HAEventWrapper hw=(HAEventWrapper)event;\n        if (hw.getClientUpdateMessage() != null) {\n          event=hw.getClientUpdateMessage();\n        }\n else {\n          event=(Conflatable)this.haContainer.get(event);\n        }\n        if (event instanceof ClientUpdateMessage) {\n          if (((ClientUpdateMessage)event).hasCqs() && ((ClientUpdateMessage)event).hasCqs(clientProxyID)) {\n            CqNameToOp cqNames=((ClientUpdateMessage)event).getClientCq(clientProxyID);\n            if (cqNames != null) {\n              for (              String cqName : cqNames.getNames()) {\n                InternalCqQuery cq=((InternalCqQuery)cqService.getClientCqFromServer(clientProxyID,cqName));\n                CqQueryVsdStats cqStats=cq.getVsdStats();\n// bug_start\n                if (cq != null && cqStats != null) {\n// bug_end\n                  cqStats.incNumHAQueuedEvents(incrementAmount);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n catch (    Exception e) {\n      if (logger.isTraceEnabled()) {\n        logger.trace(\"Exception while maintaining cq events stats.\",e);\n      }\n    }\n  }\n}\n"}
{"INPUT": "private void addBook(Book book){\n// bug_start\n  if (book != null && BookUtil.fileByBook(book).getPhysicalFile() != null) {\n// bug_end\n    myQueue.add(book);\n  }\n}\n"}
{"INPUT": "@Override public void remove(){\n// bug_start\n  if (!tx().isRemovedRelation(super.longId()) && !tx().getConfiguration().isReadOnly()) {\n// bug_end\n    tx().removeRelation(this);\n  }\n}\n"}
{"INPUT": "public static String generateSignature(TypeInference typeInference,String name,FunctionDefinition definition){\n// bug_start\n  if (typeInference.getNamedArguments().isPresent() || typeInference.getTypedArguments().isPresent()) {\n// bug_end\n    return formatNamedOrTypedArguments(name,typeInference);\n  }\n  return typeInference.getInputTypeStrategy().getExpectedSignatures(definition).stream().map(null).collect(Collectors.joining(\"\\n\"));\n}\n"}
{"INPUT": "@Override public TransactionAttribute getTransactionAttribute(Method method,@Nullable Class<?> targetClass){\n// bug_start\n  return (method == null || ClassUtils.isUserLevelMethod(method) ? this.transactionAttribute : null);\n// bug_end\n}\n"}
{"INPUT": "public boolean invokeFunctor(long functor,boolean waitForCompletion){\n// bug_start\n  if (mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {\n// bug_end\n    return false;\n  }\n  mAttachInfo.mHardwareRenderer.invokeFunctor(functor,waitForCompletion);\n  return true;\n}\n"}
{"INPUT": "public static final boolean isApkFile(File file){\n// bug_start\n  return file.isFile() && file.getName().endsWith(\".apk\");\n// bug_end\n}\n"}
{"INPUT": "@Override protected void onProvideStructure(@NonNull ViewStructure structure,@ViewStructureType int viewFor,int flags){\n  super.onProvideStructure(structure,viewFor,flags);\n// bug_start\n  if (viewFor == VIEW_STRUCTURE_FOR_AUTOFILL || viewFor == VIEW_STRUCTURE_FOR_CONTENT_CAPTURE) {\n// bug_end\n    final Adapter adapter=getAdapter();\n    if (adapter == null)     return;\n    final CharSequence[] options=adapter.getAutofillOptions();\n    if (options != null) {\n      structure.setAutofillOptions(options);\n    }\n  }\n}\n"}
{"INPUT": "private void logAppTransitionMultiEvents(){\n  for (int index=mStackTransitionInfo.size() - 1; index >= 0; index--) {\n    final StackTransitionInfo info=mStackTransitionInfo.valueAt(index);\n    final int type=getTransitionType(info);\n    if (type == -1) {\n      return;\n    }\n    final LogMaker builder=new LogMaker(APP_TRANSITION);\n    builder.setPackageName(info.launchedActivity.packageName);\n    builder.setType(type);\n    builder.addTaggedData(FIELD_CLASS_NAME,info.launchedActivity.info.name);\n    final boolean isInstantApp=info.launchedActivity.info.applicationInfo.isInstantApp();\n// bug_start\n    if (isInstantApp && info.launchedActivity.launchedFromPackage != null) {\n// bug_end\n      builder.addTaggedData(APP_TRANSITION_CALLING_PACKAGE_NAME,info.launchedActivity.launchedFromPackage);\n    }\n    if (info.launchedActivity.info.launchToken != null) {\n      builder.addTaggedData(FIELD_INSTANT_APP_LAUNCH_TOKEN,info.launchedActivity.info.launchToken);\n      info.launchedActivity.info.launchToken=null;\n    }\n    builder.addTaggedData(APP_TRANSITION_IS_EPHEMERAL,isInstantApp ? 1 : 0);\n    builder.addTaggedData(APP_TRANSITION_DEVICE_UPTIME_SECONDS,mCurrentTransitionDeviceUptime);\n    builder.addTaggedData(APP_TRANSITION_DELAY_MS,mCurrentTransitionDelayMs);\n    builder.setSubtype(info.reason);\n    if (info.startingWindowDelayMs != -1) {\n      builder.addTaggedData(APP_TRANSITION_STARTING_WINDOW_DELAY_MS,info.startingWindowDelayMs);\n    }\n    if (info.bindApplicationDelayMs != -1) {\n      builder.addTaggedData(APP_TRANSITION_BIND_APPLICATION_DELAY_MS,info.bindApplicationDelayMs);\n    }\n    builder.addTaggedData(APP_TRANSITION_WINDOWS_DRAWN_DELAY_MS,info.windowsDrawnDelayMs);\n    mMetricsLogger.write(builder);\n  }\n}\n"}
{"INPUT": "@Override public final void writeData(ObjectDataOutput out,Data data){\n  try {\n// bug_start\n    boolean isNull=data == null || isNullData(data);\n// bug_end\n    out.writeBoolean(isNull);\n    if (isNull) {\n      return;\n    }\n    writeDataInternal(out,data);\n  }\n catch (  Throwable e) {\n    throw handleException(e);\n  }\n}\n"}
{"INPUT": "private void processImport(DetailAST ast,DetailAST nextToken,int astType){\n// bug_start\n  if (astType != nextToken.getType() && !hasEmptyLineAfter(ast) || ast.getLineNo() > 1 && !hasEmptyLineBefore(ast) && ast.getPreviousSibling() == null) {\n// bug_end\n    log(nextToken.getLineNo(),MSG_SHOULD_BE_SEPARATED,nextToken.getText());\n  }\n  if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n    log(ast.getLineNo(),MSG_MULTIPLE_LINES,ast.getText());\n  }\n}\n"}
{"INPUT": "public void suspend(long timeout,boolean flushComment){\n  if (!event.isResumedOnTimeout()) {\n    String upgrade=req.getHeader(\"Connection\");\n    if (upgrade != null && upgrade.equalsIgnoreCase(\"Upgrade\") && !cometSupport.supportWebSocket()) {\n      res.addHeader(\"X-Atmosphere-error\",\"Websocket protocol not supported\");\n    }\n    res.setHeader(\"Expires\",\"-1\");\n    res.setHeader(\"Cache-Control\",\"no-store, no-cache, must-revalidate\");\n    res.setHeader(\"Pragma\",\"no-cache\");\n// bug_start\n    if (flushComment && !Boolean.valueOf(config.getInitParameter(AtmosphereServlet.SUSPEND_WITHOUT_COMMENT))) {\n// bug_end\n      write();\n    }\n    req.setAttribute(PRE_SUSPEND,\"true\");\n    action.type=AtmosphereServlet.Action.TYPE.SUSPEND;\n    action.timeout=timeout;\n    broadcaster.addAtmosphereResource(this);\n    req.removeAttribute(PRE_SUSPEND);\n    notifyListeners();\n  }\n}\n"}
{"INPUT": "@Override public boolean matches(PullRequest request){\n  if (User.get() != null) {\n    PullRequestReview review=request.getReview(User.get());\n// bug_start\n    return review != null && review.getExcludeDate() == null && review.getResult() != null && review.getResult().isApproved();\n// bug_end\n  }\n else {\n    throw new OneException(\"Please login to perform this query\");\n  }\n}\n"}
{"INPUT": "public void pushLayer(Box master){\n  Layer layer=null;\n  if (rootLayer == null) {\n    layer=new Layer(master);\n    rootLayer=layer;\n  }\n else {\n    Layer parent=getLayer();\n// bug_start\n    if (master.getStyle().isFixed() || master.getStyle().isAlternateFlow()) {\n// bug_end\n      while (parent.getParent() != null) {\n        parent=parent.getParent();\n      }\n    }\n    layer=new Layer(parent,master);\n    parent.addChild(layer);\n  }\n  pushLayer(layer);\n}\n"}
{"INPUT": "public void poll() throws Exception {\n  getDocument();\n  Feed feed=document.getRoot();\n  while (hasNextEntry()) {\n    Entry entry=list.get(entryIndex--);\n    boolean valid=true;\n    if (entryFilter != null) {\n      valid=entryFilter.isValidEntry(endpoint,document,entry);\n    }\n    if (valid) {\n      Exchange exchange=endpoint.createExchange(feed,entry);\n      getProcessor().process(exchange);\n// bug_start\n// bug_end\n    }\n  }\n  document=null;\n}\n"}
{"INPUT": "@Override public boolean onMenuItemClick(MenuItem item){\nswitch (item.getItemId()) {\ncase R.id.action_delete_from_disk:\n    DeleteSongsDialogHelper.getDialog(activity,dataSet.get(getAdapterPosition())).show();\n  return true;\ncase R.id.action_add_to_playlist:\nAddToPlaylistDialogHelper.getDialog(activity,dataSet.get(getAdapterPosition())).show();\nreturn true;\ncase R.id.action_play_next:\nMusicPlayerRemote.playNext(dataSet.get(getAdapterPosition()));\nreturn true;\ncase R.id.action_add_to_current_playing:\nMusicPlayerRemote.enqueue(dataSet.get(getAdapterPosition()));\n// bug_start\n// bug_end\ncase R.id.action_tag_editor:\nIntent intent=new Intent(activity,SongTagEditorActivity.class);\nintent.putExtra(AppKeys.E_ID,dataSet.get(getAdapterPosition()).id);\nactivity.startActivity(intent);\nreturn true;\ncase R.id.action_details:\nString songFilePath=SongFilePathLoader.getSongFilePath(activity,dataSet.get(getAdapterPosition()).id);\nFile songFile=new File(songFilePath);\nSongDetailDialogHelper.getDialog(activity,songFile).show();\nreturn true;\ncase R.id.action_go_to_album:\nPair[] albumPairs=null;\nif (activity instanceof AbsFabActivity) albumPairs=((AbsFabActivity)activity).getSharedViewsWithFab(albumPairs);\nNavigationUtil.goToAlbum(activity,dataSet.get(getAdapterPosition()).albumId,albumPairs);\nreturn true;\ncase R.id.action_go_to_artist:\nPair[] artistPairs=null;\nif (activity instanceof AbsFabActivity) artistPairs=((AbsFabActivity)activity).getSharedViewsWithFab(artistPairs);\nNavigationUtil.goToArtist(activity,dataSet.get(getAdapterPosition()).artistId,artistPairs);\nreturn true;\n}\nreturn false;\n}\n"}
{"INPUT": "public void merge(GalleryInfo info){\n  if (info == null) {\n    return;\n  }\n  if (info.gid != gid || !ObjectUtils.equals(info.token,token)) {\n    Log.w(LOG_TAG,\"Can't merge different GalleryInfo\");\n// bug_start\n// bug_end\n  }\n  if (info.title != null) {\n    title=info.title;\n  }\n  if (info.titleJpn != null) {\n    titleJpn=info.titleJpn;\n  }\n  if (info.cover != null) {\n    cover=info.cover;\n  }\n  if (info.coverUrl != null) {\n    coverUrl=info.coverUrl;\n  }\n  if (info.coverRatio != -1.0f) {\n    coverRatio=info.coverRatio;\n  }\n  if (info.category != EhUtils.UNKNOWN) {\n    category=info.category;\n  }\n  if (info.date != 0) {\n    date=info.date;\n  }\n  if (info.uploader != null) {\n    uploader=info.uploader;\n  }\n  if (info.rating != 0.0f) {\n    rating=info.rating;\n  }\n  if (info.language != EhUtils.LANG_UNKNOWN) {\n    language=info.language;\n  }\n  if (info.favouriteSlot != EhUtils.FAV_CAT_UNKNOWN) {\n    favouriteSlot=info.favouriteSlot;\n  }\n  if (info.invalid) {\n    invalid=true;\n  }\n  if (info.archiverKey != null) {\n    archiverKey=info.archiverKey;\n  }\n  if (info.pages != -1) {\n    pages=info.pages;\n  }\n  if (info.size != -1) {\n    size=info.size;\n  }\n  if (info.torrentCount != 0) {\n    torrentCount=info.torrentCount;\n  }\n  if (info.tags != null && !info.tags.isEmpty()) {\n    if (tags == null) {\n      tags=new HashMap<>(info.tags.size());\n    }\n    tags.clear();\n    tags.putAll(info.tags);\n  }\n}\n"}
{"INPUT": "@Override public boolean onSingleTap(PointF point,RotatedTileBox tileBox){\n  if (pressedContextMarker(tileBox,point.x,point.y)) {\n    showMapContextMenu(latLon);\n    return true;\n  }\n  boolean nativeMode=(Build.VERSION.SDK_INT >= 14) || view.getSettings().SCROLL_MAP_BY_GESTURES.get();\n  int val=pressedInTextView(tileBox,point.x,point.y);\n  if (selectOnMap != null) {\n    LatLon latlon=tileBox.getLatLonFromPixel(point.x,point.y);\n    CallbackWithObject<LatLon> cb=selectOnMap;\n    selectOnMap=null;\n    cb.processResult(latlon);\n    setLocation(latlon,null);\n    return true;\n  }\n  if (val == 2) {\n    setLocation(null,\"\");\n    view.refreshMap();\n    return true;\n  }\n else   if (val == 1 || !nativeMode) {\n    if (!selectedObjects.isEmpty()) {\n      showContextMenuForSelectedObjects(latLon);\n    }\n else     if (nativeMode) {\n      activity.getMapActions().contextMenuPoint(latLon.getLatitude(),latLon.getLongitude());\n    }\n    return true;\n  }\n else   if (!disableSingleTap()) {\n    LatLon latLon=selectObjectsForContextMenu(tileBox,point);\n    if (latLon != null) {\n      if (selectedObjects.size() == 1) {\n        setLocation(null,\"\");\n        selectedObj=selectedObjects.keySet().iterator().next();\n        contextObject=selectedObjects.get(selectedObj);\n        showMapContextMenu(latLon);\n// bug_start\n// bug_end\n      }\n else       if (selectedObjects.size() > 1) {\n        showContextMenuForSelectedObjects(latLon);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"}
{"INPUT": "protected boolean matchesForwardingFilter(Message message){\n  if (contains(message.getBrokerPath(),remoteBrokerPath[0])) {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Message all ready routed once through this broker - ignoring: \" + message);\n    }\n// bug_start\n// bug_end\n  }\n  int hops=message.getBrokerPath() == null ? 0 : message.getBrokerPath().length;\n  if (hops >= networkTTL) {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Message restricted to \" + networkTTL + \" network hops ignoring: \"+ message);\n    }\n    return false;\n  }\n  if (message.isAdvisory() && message.getDataStructure() != null && message.getDataStructure().getDataStructureType() == CommandTypes.CONSUMER_INFO) {\n    ConsumerInfo info=(ConsumerInfo)message.getDataStructure();\n    hops=info.getBrokerPath() == null ? 0 : message.getBrokerPath().length;\n    if (hops >= networkTTL) {\n      if (log.isTraceEnabled()) {\n        log.trace(\"ConsumerInfo advisory restricted to \" + networkTTL + \" network hops ignoring: \"+ message);\n      }\n      return false;\n    }\n  }\n  return true;\n}\n"}
{"INPUT": "public <T>T inject(String name,T value) throws NoSuchFieldException {\n  for (Class c=mojo.getClass(); c != Object.class; c=c.getSuperclass()) {\n    try {\n      Field f=c.getDeclaredField(name);\n      f.setAccessible(true);\n      Object oldValue=f.get(mojo);\n      f.set(mojo,value);\n// bug_start\n// bug_end\n    }\n catch (    NoSuchFieldException e) {\n      continue;\n    }\ncatch (    IllegalAccessException e) {\n      IllegalAccessError x=new IllegalAccessError(e.getMessage());\n      x.initCause(e);\n      throw x;\n    }\n  }\n  throw new NoSuchFieldException(name);\n}\n"}
{"INPUT": "private static Analyzer getAnalyzer(AnalyzeAction.Request request,AnalysisRegistry analysisRegistry,IndexService indexService) throws IOException {\n  if (request.analyzer() != null) {\n    if (indexService == null) {\n      Analyzer analyzer=analysisRegistry.getAnalyzer(request.analyzer());\n      if (analyzer == null) {\n        throw new IllegalArgumentException(\"failed to find global analyzer [\" + request.analyzer() + \"]\");\n      }\n      return analyzer;\n    }\n else {\n      Analyzer analyzer=indexService.getIndexAnalyzers().get(request.analyzer());\n      if (analyzer == null) {\n        throw new IllegalArgumentException(\"failed to find analyzer [\" + request.analyzer() + \"]\");\n      }\n      return analyzer;\n    }\n  }\n  if (request.normalizer() != null) {\n    if (indexService == null) {\n      throw new IllegalArgumentException(\"analysis based on a normalizer requires an index\");\n    }\n    Analyzer analyzer=indexService.getIndexAnalyzers().getNormalizer(request.normalizer());\n    if (analyzer == null) {\n      throw new IllegalArgumentException(\"failed to find normalizer under [\" + request.normalizer() + \"]\");\n    }\n// bug_start\n// bug_end\n  }\n  if (request.field() != null) {\n    if (indexService == null) {\n      throw new IllegalArgumentException(\"analysis based on a specific field requires an index\");\n    }\n    MappedFieldType fieldType=indexService.mapperService().fullName(request.field());\n    if (fieldType != null) {\n      if (fieldType.tokenized() || fieldType instanceof KeywordFieldMapper.KeywordFieldType) {\n        return fieldType.indexAnalyzer();\n      }\n else {\n        throw new IllegalArgumentException(\"Can't process field [\" + request.field() + \"], Analysis requests are only supported on tokenized fields\");\n      }\n    }\n  }\n  if (indexService == null) {\n    return analysisRegistry.getAnalyzer(\"standard\");\n  }\n else {\n    return indexService.getIndexAnalyzers().getDefaultIndexAnalyzer();\n  }\n}\n"}
{"INPUT": "@Override public void render(){\n// bug_start\n  if (mesh == null)   return;\n// bug_end\n  if (mesh.isDisposed()) {\n    return;\n  }\n  if (shadow != null) {\n    CoreRegistry.get(ShaderManager.class).enableDefaultTextured();\n    glBindTexture(GL11.GL_TEXTURE_2D,shadow.getId());\n    if (direction == EShadowDirection.INSIDE) {\n      renderInside();\n    }\n else     if (direction == EShadowDirection.OUTSIDE) {\n      renderOutside();\n    }\n  }\n}\n"}
{"INPUT": "@Override public TextLinks generateLinks(@NonNull CharSequence text,@Nullable TextLinks.Options options){\n  Utils.validate(text,false);\n  final String textString=text.toString();\n  final TextLinks.Builder builder=new TextLinks.Builder(textString);\n  if (!getSettings().isSmartLinkifyEnabled()) {\n    return builder.build();\n  }\n  try {\n    final LocaleList defaultLocales=options != null ? options.getDefaultLocales() : null;\n    final Collection<String> entitiesToIdentify=options != null && options.getEntityConfig() != null ? options.getEntityConfig().getEntities(this) : ENTITY_TYPES_ALL;\n    final SmartSelection smartSelection=getSmartSelection(defaultLocales);\n    final SmartSelection.AnnotatedSpan[] annotations=smartSelection.annotate(textString);\n    for (    SmartSelection.AnnotatedSpan span : annotations) {\n      final SmartSelection.ClassificationResult[] results=span.getClassification();\n      if (results.length == 0 || !entitiesToIdentify.contains(results[0].mCollection)) {\n        continue;\n      }\n      final Map<String,Float> entityScores=new HashMap<>();\n      for (int i=0; i < results.length; i++) {\n        entityScores.put(results[i].mCollection,results[i].mScore);\n      }\n      builder.addLink(span.getStartIndex(),span.getEndIndex(),entityScores);\n    }\n// bug_start\n// bug_end\n  }\n catch (  Throwable t) {\n    Log.e(LOG_TAG,\"Error getting links info.\",t);\n  }\n  return mFallback.generateLinks(text,options);\n}\n"}
{"INPUT": "@Override public boolean onOptionsItemSelected(MenuItem item){\nswitch (item.getItemId()) {\ncase R.id.share_tracks_url:\n    Intent intent=new Intent(Intent.ACTION_SEND);\n  intent.putExtra(Intent.EXTRA_TEXT,Urls.WEB_APP_URL_BASIC + Urls.TRACKS);\nintent.putExtra(Intent.EXTRA_SUBJECT,R.string.share_links);\nintent.setType(\"text/plain\");\nstartActivity(Intent.createChooser(intent,getResources().getString(R.string.share_links)));\n// bug_start\n// bug_end\n}\nreturn super.onOptionsItemSelected(item);\n}\n"}
{"INPUT": "public void finish(int resultCode,Bundle results){\n  if (mAutomaticPerformanceSnapshots) {\n    endPerformanceSnapshot();\n  }\n  if (mPerfMetrics != null) {\n// bug_start\n// bug_end\n    results.putAll(mPerfMetrics);\n  }\n  if (mUiAutomation != null) {\n    mUiAutomation.disconnect();\n    mUiAutomation=null;\n  }\n  mThread.finishInstrumentation(resultCode,results);\n}\n"}
{"INPUT": "private void validate(Object value,String text){\n  if (!areEqual(value,this.editor.getValue()))   throw new Error(\"value should be \" + value);\n// bug_start\n// bug_end\n  if (!areEqual(text,this.editor.getAsText()))   throw new Error(\"text should be \" + text);\n}\n"}
{"INPUT": "protected void onInitialized(ActivitiEvent event){\n  if (!(event instanceof ActivitiEntityEventImpl)) {\n    return;\n  }\n  ActivitiEntityEventImpl activitiEntityEventImpl=(ActivitiEntityEventImpl)event;\n  Object entity=activitiEntityEventImpl.getEntity();\n  if (!(entity instanceof ExecutionEntity)) {\n    return;\n  }\n  ExecutionEntity executionEntity=(ExecutionEntity)entity;\n  if (!executionEntity.isProcessInstanceType()) {\n    return;\n  }\n  String processInstanceId=executionEntity.getId();\n  String processDefinitionId=executionEntity.getProcessDefinitionId();\n  CommandContext commandContext=Context.getCommandContext();\n  ProcessDefinitionEntity processDefinition=new GetDeploymentProcessDefinitionCmd(processDefinitionId).execute(commandContext);\n  String processDefinitionName=processDefinition.getName();\n// bug_start\n// bug_end\n  String userId=Authentication.getAuthenticatedUserId();\n  String displayName=userConnector.findById(userId).getDisplayName();\n  String processInstanceName=processDefinitionName + \"-\" + displayName+ \"-\"+ new SimpleDateFormat(\"yyyy-MM-dd HH:mm\").format(new Date());\n  executionEntity.setName(processInstanceName);\n  HistoricProcessInstanceEntity historicProcessInstanceEntity=commandContext.getHistoricProcessInstanceEntityManager().findHistoricProcessInstance(processInstanceId);\n  historicProcessInstanceEntity.setName(processInstanceName);\n}\n"}
{"INPUT": "private void setErrorPlaceholder(){\n  if (!canNotifyStatusChanged()) {\n    return;\n  }\n  Drawable error=null;\n  if (model == null) {\n    error=getFallbackDrawable();\n  }\n  if (error == null) {\n    error=getErrorDrawable();\n  }\n// bug_start\n// bug_end\n  target.onLoadFailed(error);\n}\n"}
{"INPUT": "public void handleEvent(Event event){\n  if (event.index != columnIndex)   return;\n  String text=textFor((TreeItem)event.item,getter);\n// bug_start\n// bug_end\n  Point size=event.gc.textExtent(text);\n  event.width=size.x + 2 * (3);\n}\n"}
{"INPUT": "private static Set<String> getSchemaNames(DatabaseMetaData meta,String schemaFilter){\n  Set<String> res=new HashSet<>();\n  try {\n    ResultSet schemas=meta.getSchemas();\n    try {\n      while (schemas.next()) {\n        String schemaName=schemas.getString(\"TABLE_SCHEM\");\n// bug_start\n// bug_end\n        if (schemaFilter.equals(\"\") || schemaFilter == null || schemaName.matches(schemaFilter.replace(\"_\",\".\").replace(\"%\",\".*?\"))) {\n          res.add(schemaName);\n        }\n      }\n    }\n  finally {\n      schemas.close();\n    }\n  }\n catch (  SQLException t) {\n    logger.error(\"Failed to retrieve the schema names\",t);\n  }\n  return res;\n}\n"}
{"INPUT": "@Override public void visitEventTypes(JFREventTypeVisitor... visitors){\n  for (  JFREventTypeVisitor visitor : visitors)   visitor.initTypes();\n  try {\n    List<JFREventTypeVisitor> _visitors=new ArrayList(Arrays.asList(visitors));\n    int typeIdx=0;\n    while (!_visitors.isEmpty() && typeIdx < types.length) {\n      EventArray type=types[typeIdx];\n      IType<IItem> itype=type.getType();\n      String typeId=itype.getIdentifier();\n      String[] typeCategory=type.getTypeCategory();\n// bug_start\n// bug_end\n      JFREventType event=new JFRGenericEventType(typeIdx++,itype,typeCategory);\n      Iterator<JFREventTypeVisitor> _visitorsI=_visitors.iterator();\n      while (_visitorsI.hasNext())       if (_visitorsI.next().visitType(typeId,event))       _visitorsI.remove();\n    }\n  }\n catch (  Exception e) {\n    LOGGER.log(Level.INFO,\"Error visiting JFR event types (generic loader)\",e);\n  }\n finally {\n    for (    JFREventTypeVisitor visitor : visitors)     visitor.doneTypes();\n  }\n}\n"}
{"INPUT": "public void mouseClicked(MouseEvent event){\n  TreePath selected=_dependenciesTree.getSelectionPath();\n  if (event.getClickCount() == 2 && event.getButton() == MouseEvent.BUTTON1 && selected != null) {\n    DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)_dependenciesTree.getSelectionPath().getLastPathComponent();\n    Object selectedObject=selectedNode.getUserObject();\n    if (selectedNode.getParent() instanceof InjectedPagesNode || selectedNode.getParent() instanceof EmbeddedComponentsNode) {\n// bug_start\n      ((IntellijJavaField)((InjectedElement)selectedObject).getField()).getPsiField().navigate(true);\n// bug_end\n    }\n  }\n  if (event.getButton() == MouseEvent.BUTTON3) {\n    if (selected != null) {\n      DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)_dependenciesTree.getSelectionPath().getLastPathComponent();\n      Object selectedObject=selectedNode.getUserObject();\n      if (selectedObject instanceof InjectedElement || selectedObject instanceof PresentationLibraryElement || selectedObject instanceof IResource) {\n        DefaultActionGroup actions=new DefaultActionGroup(\"NavigateToGroup\",true);\n        actions.add(_navigateToElementAction);\n        actions.add(_navigateToUsageAction);\n        actions.addSeparator();\n        actions.add(new CollapseAllAction(_dependenciesTree));\n        actions.add(new ExpandAllAction(_dependenciesTree));\n        ActionPopupMenu popupMenu=ActionManager.getInstance().createActionPopupMenu(\"ElementUsagesTree\",actions);\n        popupMenu.getComponent().show(event.getComponent(),event.getX(),event.getY());\n        event.consume();\n      }\n    }\n    if (selected == null) {\n      DefaultActionGroup actions=new DefaultActionGroup(\"NavigateToGroup\",true);\n      actions.add(new CollapseAllAction(_dependenciesTree));\n      actions.add(new ExpandAllAction(_dependenciesTree));\n      ActionPopupMenu popupMenu=ActionManager.getInstance().createActionPopupMenu(\"ElementUsagesTree\",actions);\n      popupMenu.getComponent().show(event.getComponent(),event.getX(),event.getY());\n      event.consume();\n    }\n  }\n}\n"}
{"INPUT": "Properties getProps(){\n  Properties props=endpoint.getConfiguration().createConsumerProperties();\n  endpoint.updateClassProperties(props);\n  String brokers=endpoint.getConfiguration().getBrokers();\n  if (brokers == null) {\n    brokers=endpoint.getComponent().getBrokers();\n// bug_start\n// bug_end\n  }\n  props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,brokers);\n  if (endpoint.getConfiguration().getGroupId() != null) {\n    String groupId=endpoint.getConfiguration().getGroupId();\n    props.put(ConsumerConfig.GROUP_ID_CONFIG,groupId);\n    log.debug(\"Kafka consumer groupId is {}\",groupId);\n  }\n else {\n    String randomGroupId=UUID.randomUUID().toString();\n    props.put(ConsumerConfig.GROUP_ID_CONFIG,randomGroupId);\n    log.debug(\"Kafka consumer groupId is {} (generated)\",randomGroupId);\n  }\n  return props;\n}\n"}
{"INPUT": "@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\") public CubeInstance deleteSegment(CubeInstance cube,String segmentName) throws IOException {\n  if (!segmentName.equals(cube.getSegments().get(0).getName()) && !segmentName.equals(cube.getSegments().get(cube.getSegments().size() - 1).getName())) {\n    throw new IllegalArgumentException(\"Cannot delete segment '\" + segmentName + \"' as it is neither the first nor the last segment.\");\n  }\n  CubeSegment toDelete=null;\n  for (  CubeSegment seg : cube.getSegments()) {\n    if (seg.getName().equals(segmentName)) {\n      toDelete=seg;\n    }\n  }\n// bug_start\n// bug_end\n  if (toDelete.getStatus() != SegmentStatusEnum.READY) {\n    throw new IllegalArgumentException(\"Cannot delete segment '\" + segmentName + \"' as its status is not READY. Discard the on-going job for it.\");\n  }\n  CubeUpdate update=new CubeUpdate(cube);\n  update.setToRemoveSegs(new CubeSegment[]{toDelete});\n  return CubeManager.getInstance(getConfig()).updateCube(update);\n}\n"}
{"INPUT": "protected PullToRefreshAttacher(Activity activity,Options options){\n// bug_start\n// bug_end\n  if (options == null) {\n    Log.i(LOG_TAG,\"Given null options so using default options.\");\n    options=new Options();\n  }\n  mActivity=activity;\n  mRefreshableViews=new WeakHashMap<View,ViewDelegate>();\n  mRefreshScrollDistance=options.refreshScrollDistance;\n  mRefreshOnUp=options.refreshOnUp;\n  mRefreshMinimizeDelay=options.refreshMinimizeDelay;\n  mRefreshMinimize=options.refreshMinimize;\n  mEnvironmentDelegate=options.environmentDelegate != null ? options.environmentDelegate : createDefaultEnvironmentDelegate();\n  mHeaderTransformer=options.headerTransformer != null ? options.headerTransformer : createDefaultHeaderTransformer();\n  mTouchSlop=ViewConfiguration.get(activity).getScaledTouchSlop();\n  final ViewGroup decorView=(ViewGroup)activity.getWindow().getDecorView();\n  mHeaderView=LayoutInflater.from(mEnvironmentDelegate.getContextForInflater(activity)).inflate(options.headerLayout,decorView,false);\n  if (mHeaderView == null) {\n    throw new IllegalArgumentException(\"Must supply valid layout id for header.\");\n  }\n  mHeaderView.setVisibility(View.INVISIBLE);\n  mHeaderTransformer.onViewCreated(activity,mHeaderView);\n  mHandler.post(new Runnable(){\n    @Override public void run(){\n      if (decorView.getWindowToken() != null) {\n        addHeaderViewToActivity(mHeaderView,mActivity);\n      }\n else {\n        mHandler.post(this);\n      }\n    }\n  }\n);\n}\n"}
{"INPUT": "private BufferSizeAdaptiveTrackSelection(TrackGroup trackGroup,int[] tracks,BandwidthMeter bandwidthMeter,int minBufferMs,int maxBufferMs,int hysteresisBufferMs,float startUpBandwidthFraction,int startUpMinBufferForQualityIncreaseMs,DynamicFormatFilter dynamicFormatFilter,Clock clock){\n  super(trackGroup,tracks);\n  this.bandwidthMeter=bandwidthMeter;\n  this.minBufferUs=C.msToUs(minBufferMs);\n  this.maxBufferUs=C.msToUs(maxBufferMs);\n  this.hysteresisBufferUs=C.msToUs(hysteresisBufferMs);\n  this.startUpBandwidthFraction=startUpBandwidthFraction;\n  this.startUpMinBufferForQualityIncreaseUs=C.msToUs(startUpMinBufferForQualityIncreaseMs);\n  this.dynamicFormatFilter=dynamicFormatFilter;\n  this.clock=clock;\n  formatBitrates=new int[length];\n  maxBitrate=getFormat(0).bitrate;\n  minBitrate=getFormat(length - 1).bitrate;\n  selectionReason=C.SELECTION_REASON_UNKNOWN;\n  playbackSpeed=1.0f;\n// bug_start\n  bitrateToBufferFunctionSlope=(maxBufferUs - hysteresisBufferUs - minBufferUs) / Math.log(maxBitrate / minBitrate);\n// bug_end\n  bitrateToBufferFunctionIntercept=minBufferUs - bitrateToBufferFunctionSlope * Math.log(minBitrate);\n}\n"}
