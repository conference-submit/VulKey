{"source": " static MagickBooleanType GetEXIFProperty(const Image *image,\n   const char *property)\n {\n #define MaxDirectoryStack  16\n #define EXIF_DELIMITER  \"\\n\"\n #define EXIF_NUM_FORMATS  12\n #define EXIF_FMT_BYTE  1\n #define EXIF_FMT_STRING  2\n #define EXIF_FMT_USHORT  3\n #define EXIF_FMT_ULONG  4\n #define EXIF_FMT_URATIONAL  5\n #define EXIF_FMT_SBYTE  6\n #define EXIF_FMT_UNDEFINED  7\n #define EXIF_FMT_SSHORT  8\n #define EXIF_FMT_SLONG  9\n #define EXIF_FMT_SRATIONAL  10\n #define EXIF_FMT_SINGLE  11\n #define EXIF_FMT_DOUBLE  12\n #define TAG_EXIF_OFFSET  0x8769\n #define TAG_GPS_OFFSET  0x8825\n #define TAG_INTEROP_OFFSET  0xa005\n \n #define EXIFMultipleValues(size,format,arg) \\\n { \\\n    ssize_t \\\n      component; \\\n  \\\n    size_t \\\n      length; \\\n  \\\n    unsigned char \\\n      *p1; \\\n  \\\n    length=0; \\\n    p1=p; \\\n    for (component=0; component < components; component++) \\\n    { \\\n      length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \\\n        format\", \",arg); \\\n      if (length >= (MaxTextExtent-1)) \\\n        length=MaxTextExtent-1; \\\n      p1+=size; \\\n    } \\\n    if (length > 1) \\\n      buffer[length-2]='\\0'; \\\n    value=AcquireString(buffer); \\\n }\n \n #define EXIFMultipleFractions(size,format,arg1,arg2) \\\n { \\\n    ssize_t \\\n      component; \\\n  \\\n    size_t \\\n      length; \\\n  \\\n    unsigned char \\\n      *p1; \\\n  \\\n    length=0; \\\n    p1=p; \\\n    for (component=0; component < components; component++) \\\n    { \\\n      length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \\\n        format\", \",(arg1),(arg2)); \\\n      if (length >= (MaxTextExtent-1)) \\\n        length=MaxTextExtent-1; \\\n      p1+=size; \\\n    } \\\n    if (length > 1) \\\n      buffer[length-2]='\\0'; \\\n    value=AcquireString(buffer); \\\n }\n \n   typedef struct _DirectoryInfo\n   {\n     const unsigned char\n       *directory;\n \n     size_t\n       entry;\n \n     ssize_t\n       offset;\n   } DirectoryInfo;\n \n   typedef struct _TagInfo\n   {\n     size_t\n       tag;\n \n     const char\n       description[36];\n   } TagInfo;\n \n   static const TagInfo\n     EXIFTag[] =\n     {\n       {  0x001, \"exif:InteroperabilityIndex\" },\n       {  0x002, \"exif:InteroperabilityVersion\" },\n       {  0x100, \"exif:ImageWidth\" },\n       {  0x101, \"exif:ImageLength\" },\n       {  0x102, \"exif:BitsPerSample\" },\n       {  0x103, \"exif:Compression\" },\n       {  0x106, \"exif:PhotometricInterpretation\" },\n       {  0x10a, \"exif:FillOrder\" },\n       {  0x10d, \"exif:DocumentName\" },\n       {  0x10e, \"exif:ImageDescription\" },\n       {  0x10f, \"exif:Make\" },\n       {  0x110, \"exif:Model\" },\n       {  0x111, \"exif:StripOffsets\" },\n       {  0x112, \"exif:Orientation\" },\n       {  0x115, \"exif:SamplesPerPixel\" },\n       {  0x116, \"exif:RowsPerStrip\" },\n       {  0x117, \"exif:StripByteCounts\" },\n       {  0x11a, \"exif:XResolution\" },\n       {  0x11b, \"exif:YResolution\" },\n       {  0x11c, \"exif:PlanarConfiguration\" },\n       {  0x11d, \"exif:PageName\" },\n       {  0x11e, \"exif:XPosition\" },\n       {  0x11f, \"exif:YPosition\" },\n       {  0x118, \"exif:MinSampleValue\" },\n       {  0x119, \"exif:MaxSampleValue\" },\n       {  0x120, \"exif:FreeOffsets\" },\n       {  0x121, \"exif:FreeByteCounts\" },\n       {  0x122, \"exif:GrayResponseUnit\" },\n       {  0x123, \"exif:GrayResponseCurve\" },\n       {  0x124, \"exif:T4Options\" },\n       {  0x125, \"exif:T6Options\" },\n       {  0x128, \"exif:ResolutionUnit\" },\n       {  0x12d, \"exif:TransferFunction\" },\n       {  0x131, \"exif:Software\" },\n       {  0x132, \"exif:DateTime\" },\n       {  0x13b, \"exif:Artist\" },\n       {  0x13e, \"exif:WhitePoint\" },\n       {  0x13f, \"exif:PrimaryChromaticities\" },\n       {  0x140, \"exif:ColorMap\" },\n       {  0x141, \"exif:HalfToneHints\" },\n       {  0x142, \"exif:TileWidth\" },\n       {  0x143, \"exif:TileLength\" },\n       {  0x144, \"exif:TileOffsets\" },\n       {  0x145, \"exif:TileByteCounts\" },\n       {  0x14a, \"exif:SubIFD\" },\n       {  0x14c, \"exif:InkSet\" },\n       {  0x14d, \"exif:InkNames\" },\n       {  0x14e, \"exif:NumberOfInks\" },\n       {  0x150, \"exif:DotRange\" },\n       {  0x151, \"exif:TargetPrinter\" },\n       {  0x152, \"exif:ExtraSample\" },\n       {  0x153, \"exif:SampleFormat\" },\n       {  0x154, \"exif:SMinSampleValue\" },\n       {  0x155, \"exif:SMaxSampleValue\" },\n       {  0x156, \"exif:TransferRange\" },\n       {  0x157, \"exif:ClipPath\" },\n       {  0x158, \"exif:XClipPathUnits\" },\n       {  0x159, \"exif:YClipPathUnits\" },\n       {  0x15a, \"exif:Indexed\" },\n       {  0x15b, \"exif:JPEGTables\" },\n       {  0x15f, \"exif:OPIProxy\" },\n       {  0x200, \"exif:JPEGProc\" },\n       {  0x201, \"exif:JPEGInterchangeFormat\" },\n       {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n       {  0x203, \"exif:JPEGRestartInterval\" },\n       {  0x205, \"exif:JPEGLosslessPredictors\" },\n       {  0x206, \"exif:JPEGPointTransforms\" },\n       {  0x207, \"exif:JPEGQTables\" },\n       {  0x208, \"exif:JPEGDCTables\" },\n       {  0x209, \"exif:JPEGACTables\" },\n       {  0x211, \"exif:YCbCrCoefficients\" },\n       {  0x212, \"exif:YCbCrSubSampling\" },\n       {  0x213, \"exif:YCbCrPositioning\" },\n       {  0x214, \"exif:ReferenceBlackWhite\" },\n       {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n       {  0x301, \"exif:Gamma\" },\n       {  0x302, \"exif:ICCProfileDescriptor\" },\n       {  0x303, \"exif:SRGBRenderingIntent\" },\n       {  0x320, \"exif:ImageTitle\" },\n       {  0x5001, \"exif:ResolutionXUnit\" },\n       {  0x5002, \"exif:ResolutionYUnit\" },\n       {  0x5003, \"exif:ResolutionXLengthUnit\" },\n       {  0x5004, \"exif:ResolutionYLengthUnit\" },\n       {  0x5005, \"exif:PrintFlags\" },\n       {  0x5006, \"exif:PrintFlagsVersion\" },\n       {  0x5007, \"exif:PrintFlagsCrop\" },\n       {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n       {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n       {  0x500A, \"exif:HalftoneLPI\" },\n       {  0x500B, \"exif:HalftoneLPIUnit\" },\n       {  0x500C, \"exif:HalftoneDegree\" },\n       {  0x500D, \"exif:HalftoneShape\" },\n       {  0x500E, \"exif:HalftoneMisc\" },\n       {  0x500F, \"exif:HalftoneScreen\" },\n       {  0x5010, \"exif:JPEGQuality\" },\n       {  0x5011, \"exif:GridSize\" },\n       {  0x5012, \"exif:ThumbnailFormat\" },\n       {  0x5013, \"exif:ThumbnailWidth\" },\n       {  0x5014, \"exif:ThumbnailHeight\" },\n       {  0x5015, \"exif:ThumbnailColorDepth\" },\n       {  0x5016, \"exif:ThumbnailPlanes\" },\n       {  0x5017, \"exif:ThumbnailRawBytes\" },\n       {  0x5018, \"exif:ThumbnailSize\" },\n       {  0x5019, \"exif:ThumbnailCompressedSize\" },\n       {  0x501a, \"exif:ColorTransferFunction\" },\n       {  0x501b, \"exif:ThumbnailData\" },\n       {  0x5020, \"exif:ThumbnailImageWidth\" },\n       {  0x5021, \"exif:ThumbnailImageHeight\" },\n       {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n       {  0x5023, \"exif:ThumbnailCompression\" },\n       {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n       {  0x5025, \"exif:ThumbnailImageDescription\" },\n       {  0x5026, \"exif:ThumbnailEquipMake\" },\n       {  0x5027, \"exif:ThumbnailEquipModel\" },\n       {  0x5028, \"exif:ThumbnailStripOffsets\" },\n       {  0x5029, \"exif:ThumbnailOrientation\" },\n       {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n       {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n       {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n       {  0x502d, \"exif:ThumbnailResolutionX\" },\n       {  0x502e, \"exif:ThumbnailResolutionY\" },\n       {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n       {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n       {  0x5031, \"exif:ThumbnailTransferFunction\" },\n       {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n       {  0x5033, \"exif:ThumbnailDateTime\" },\n       {  0x5034, \"exif:ThumbnailArtist\" },\n       {  0x5035, \"exif:ThumbnailWhitePoint\" },\n       {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n       {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n       {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n       {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n       {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n       {  0x503B, \"exif:ThumbnailCopyRight\" },\n       {  0x5090, \"exif:LuminanceTable\" },\n       {  0x5091, \"exif:ChrominanceTable\" },\n       {  0x5100, \"exif:FrameDelay\" },\n       {  0x5101, \"exif:LoopCount\" },\n       {  0x5110, \"exif:PixelUnit\" },\n       {  0x5111, \"exif:PixelPerUnitX\" },\n       {  0x5112, \"exif:PixelPerUnitY\" },\n       {  0x5113, \"exif:PaletteHistogram\" },\n       {  0x1000, \"exif:RelatedImageFileFormat\" },\n       {  0x1001, \"exif:RelatedImageLength\" },\n       {  0x1002, \"exif:RelatedImageWidth\" },\n       {  0x800d, \"exif:ImageID\" },\n       {  0x80e3, \"exif:Matteing\" },\n       {  0x80e4, \"exif:DataType\" },\n       {  0x80e5, \"exif:ImageDepth\" },\n       {  0x80e6, \"exif:TileDepth\" },\n       {  0x828d, \"exif:CFARepeatPatternDim\" },\n       {  0x828e, \"exif:CFAPattern2\" },\n       {  0x828f, \"exif:BatteryLevel\" },\n       {  0x8298, \"exif:Copyright\" },\n       {  0x829a, \"exif:ExposureTime\" },\n       {  0x829d, \"exif:FNumber\" },\n       {  0x83bb, \"exif:IPTC/NAA\" },\n       {  0x84e3, \"exif:IT8RasterPadding\" },\n       {  0x84e5, \"exif:IT8ColorTable\" },\n       {  0x8649, \"exif:ImageResourceInformation\" },\n       {  0x8769, \"exif:ExifOffset\" },\n       {  0x8773, \"exif:InterColorProfile\" },\n       {  0x8822, \"exif:ExposureProgram\" },\n       {  0x8824, \"exif:SpectralSensitivity\" },\n       {  0x8825, \"exif:GPSInfo\" },\n       {  0x8827, \"exif:PhotographicSensitivity\" },\n       {  0x8828, \"exif:OECF\" },\n       {  0x8829, \"exif:Interlace\" },\n       {  0x882a, \"exif:TimeZoneOffset\" },\n       {  0x882b, \"exif:SelfTimerMode\" },\n       {  0x8830, \"exif:SensitivityType\" },\n       {  0x8831, \"exif:StandardOutputSensitivity\" },\n       {  0x8832, \"exif:RecommendedExposureIndex\" },\n       {  0x8833, \"exif:ISOSpeed\" },\n       {  0x8834, \"exif:ISOSpeedLatitudeyyy\" },\n       {  0x8835, \"exif:ISOSpeedLatitudezzz\" },\n       {  0x9000, \"exif:ExifVersion\" },\n       {  0x9003, \"exif:DateTimeOriginal\" },\n       {  0x9004, \"exif:DateTimeDigitized\" },\n       {  0x9010, \"exif:OffsetTime\" },\n       {  0x9011, \"exif:OffsetTimeOriginal\" },\n       {  0x9012, \"exif:OffsetTimeDigitized\" },\n       {  0x9101, \"exif:ComponentsConfiguration\" },\n       {  0x9102, \"exif:CompressedBitsPerPixel\" },\n       {  0x9201, \"exif:ShutterSpeedValue\" },\n       {  0x9202, \"exif:ApertureValue\" },\n       {  0x9203, \"exif:BrightnessValue\" },\n       {  0x9204, \"exif:ExposureBiasValue\" },\n       {  0x9205, \"exif:MaxApertureValue\" },\n       {  0x9206, \"exif:SubjectDistance\" },\n       {  0x9207, \"exif:MeteringMode\" },\n       {  0x9208, \"exif:LightSource\" },\n       {  0x9209, \"exif:Flash\" },\n       {  0x920a, \"exif:FocalLength\" },\n       {  0x920b, \"exif:FlashEnergy\" },\n       {  0x920c, \"exif:SpatialFrequencyResponse\" },\n       {  0x920d, \"exif:Noise\" },\n       {  0x9214, \"exif:SubjectArea\" },\n       {  0x9290, \"exif:SubSecTime\" },\n       {  0x9291, \"exif:SubSecTimeOriginal\" },\n       {  0x9292, \"exif:SubSecTimeDigitized\" },\n       {  0x9211, \"exif:ImageNumber\" },\n       {  0x9212, \"exif:SecurityClassification\" },\n       {  0x9213, \"exif:ImageHistory\" },\n       {  0x9214, \"exif:SubjectArea\" },\n       {  0x9215, \"exif:ExposureIndex\" },\n       {  0x9216, \"exif:TIFF-EPStandardID\" },\n       {  0x927c, \"exif:MakerNote\" },\n       {  0x9286, \"exif:UserComment\" },\n       {  0x9290, \"exif:SubSecTime\" },\n       {  0x9291, \"exif:SubSecTimeOriginal\" },\n       {  0x9292, \"exif:SubSecTimeDigitized\" },\n       {  0x9400, \"exif:Temperature\" },\n       {  0x9401, \"exif:Humidity\" },\n       {  0x9402, \"exif:Pressure\" },\n       {  0x9403, \"exif:WaterDepth\" },\n       {  0x9404, \"exif:Acceleration\" },\n       {  0x9405, \"exif:CameraElevationAngle\" },\n       {  0x9C9b, \"exif:WinXP-Title\" },\n       {  0x9C9c, \"exif:WinXP-Comments\" },\n       {  0x9C9d, \"exif:WinXP-Author\" },\n       {  0x9C9e, \"exif:WinXP-Keywords\" },\n       {  0x9C9f, \"exif:WinXP-Subject\" },\n       {  0xa000, \"exif:FlashPixVersion\" },\n       {  0xa001, \"exif:ColorSpace\" },\n       {  0xa002, \"exif:PixelXDimension\" },\n       {  0xa003, \"exif:PixelYDimension\" },\n       {  0xa004, \"exif:RelatedSoundFile\" },\n       {  0xa005, \"exif:InteroperabilityOffset\" },\n       {  0xa20b, \"exif:FlashEnergy\" },\n       {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n       {  0xa20d, \"exif:Noise\" },\n       {  0xa20e, \"exif:FocalPlaneXResolution\" },\n       {  0xa20f, \"exif:FocalPlaneYResolution\" },\n       {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n       {  0xa214, \"exif:SubjectLocation\" },\n       {  0xa215, \"exif:ExposureIndex\" },\n       {  0xa216, \"exif:TIFF/EPStandardID\" },\n       {  0xa217, \"exif:SensingMethod\" },\n       {  0xa300, \"exif:FileSource\" },\n       {  0xa301, \"exif:SceneType\" },\n       {  0xa302, \"exif:CFAPattern\" },\n       {  0xa401, \"exif:CustomRendered\" },\n       {  0xa402, \"exif:ExposureMode\" },\n       {  0xa403, \"exif:WhiteBalance\" },\n       {  0xa404, \"exif:DigitalZoomRatio\" },\n       {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n       {  0xa406, \"exif:SceneCaptureType\" },\n       {  0xa407, \"exif:GainControl\" },\n       {  0xa408, \"exif:Contrast\" },\n       {  0xa409, \"exif:Saturation\" },\n       {  0xa40a, \"exif:Sharpness\" },\n       {  0xa40b, \"exif:DeviceSettingDescription\" },\n       {  0xa40c, \"exif:SubjectDistanceRange\" },\n       {  0xa420, \"exif:ImageUniqueID\" },\n       {  0xa430, \"exif:CameraOwnerName\" },\n       {  0xa431, \"exif:BodySerialNumber\" },\n       {  0xa432, \"exif:LensSpecification\" },\n       {  0xa433, \"exif:LensMake\" },\n       {  0xa434, \"exif:LensModel\" },\n       {  0xa435, \"exif:LensSerialNumber\" },\n       {  0xc4a5, \"exif:PrintImageMatching\" },\n       {  0xa500, \"exif:Gamma\" },\n       {  0xc640, \"exif:CR2Slice\" },\n       { 0x10000, \"exif:GPSVersionID\" },\n       { 0x10001, \"exif:GPSLatitudeRef\" },\n       { 0x10002, \"exif:GPSLatitude\" },\n       { 0x10003, \"exif:GPSLongitudeRef\" },\n       { 0x10004, \"exif:GPSLongitude\" },\n       { 0x10005, \"exif:GPSAltitudeRef\" },\n       { 0x10006, \"exif:GPSAltitude\" },\n       { 0x10007, \"exif:GPSTimeStamp\" },\n       { 0x10008, \"exif:GPSSatellites\" },\n       { 0x10009, \"exif:GPSStatus\" },\n       { 0x1000a, \"exif:GPSMeasureMode\" },\n       { 0x1000b, \"exif:GPSDop\" },\n       { 0x1000c, \"exif:GPSSpeedRef\" },\n       { 0x1000d, \"exif:GPSSpeed\" },\n       { 0x1000e, \"exif:GPSTrackRef\" },\n       { 0x1000f, \"exif:GPSTrack\" },\n       { 0x10010, \"exif:GPSImgDirectionRef\" },\n       { 0x10011, \"exif:GPSImgDirection\" },\n       { 0x10012, \"exif:GPSMapDatum\" },\n       { 0x10013, \"exif:GPSDestLatitudeRef\" },\n       { 0x10014, \"exif:GPSDestLatitude\" },\n       { 0x10015, \"exif:GPSDestLongitudeRef\" },\n       { 0x10016, \"exif:GPSDestLongitude\" },\n       { 0x10017, \"exif:GPSDestBearingRef\" },\n       { 0x10018, \"exif:GPSDestBearing\" },\n       { 0x10019, \"exif:GPSDestDistanceRef\" },\n       { 0x1001a, \"exif:GPSDestDistance\" },\n       { 0x1001b, \"exif:GPSProcessingMethod\" },\n       { 0x1001c, \"exif:GPSAreaInformation\" },\n       { 0x1001d, \"exif:GPSDateStamp\" },\n       { 0x1001e, \"exif:GPSDifferential\" },\n       { 0x1001f, \"exif:GPSHPositioningError\" },\n       { 0x00000, \"\" }\n     };\n \n   const StringInfo\n     *profile;\n \n   const unsigned char\n     *directory,\n     *exif;\n \n   DirectoryInfo\n     directory_stack[MaxDirectoryStack];\n \n   EndianType\n     endian;\n \n   MagickBooleanType\n     status;\n \n   ssize_t\n     i;\n \n   size_t\n     entry,\n     length,\n     number_entries,\n     tag,\n     tag_value;\n \n   SplayTreeInfo\n     *exif_resources;\n \n   ssize_t\n     all,\n     id,\n     level,\n     offset,\n     tag_offset;\n \n   static int\n     tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n \n   profile=GetImageProfile(image,\"exif\");\n   if (profile == (const StringInfo *) NULL)\n     return(MagickFalse);\n   if ((property == (const char *) NULL) || (*property == '\\0'))\n     return(MagickFalse);\n   while (isspace((int) ((unsigned char) *property)) != 0)\n     property++;\n   if (strlen(property) <= 5)\n     return(MagickFalse);\n   all=0;\n   tag=(~0UL);\n   switch (*(property+5))\n   {\n     case '*':\n     {\n       tag=0;\n       all=1;\n       break;\n     }\n     case '!':\n     {\n       tag=0;\n       all=2;\n       break;\n     }\n     case '#':\n     case '@':\n     {\n       int\n         c;\n \n       size_t\n         n;\n \n       tag=(*(property+5) == '@') ? 1UL : 0UL;\n       property+=6;\n       n=strlen(property);\n       if (n != 4)\n         return(MagickFalse);\n       n/=4;\n       do\n       {\n         for (i=(ssize_t) n-1L; i >= 0; i--)\n         {\n           c=(*property++);\n           tag<<=4;\n           if ((c >= '0') && (c <= '9'))\n             tag|=(c-'0');\n           else\n             if ((c >= 'A') && (c <= 'F'))\n               tag|=(c-('A'-10));\n             else\n               if ((c >= 'a') && (c <= 'f'))\n                 tag|=(c-('a'-10));\n               else\n                 return(MagickFalse);\n         }\n       } while (*property != '\\0');\n       break;\n     }\n     default:\n     {\n       for (i=0; ; i++)\n       {\n         if (EXIFTag[i].tag == 0)\n           break;\n         if (LocaleCompare(EXIFTag[i].description,property) == 0)\n           {\n             tag=(size_t) EXIFTag[i].tag;\n             break;\n           }\n       }\n       break;\n     }\n   }\n   if (tag == (~0UL))\n     return(MagickFalse);\n   length=GetStringInfoLength(profile);\n   if (length < 6)\n     return(MagickFalse);\n   exif=GetStringInfoDatum(profile);\n   while (length != 0)\n   {\n     if (ReadPropertyByte(&exif,&length) != 0x45)\n       continue;\n     if (ReadPropertyByte(&exif,&length) != 0x78)\n       continue;\n     if (ReadPropertyByte(&exif,&length) != 0x69)\n       continue;\n     if (ReadPropertyByte(&exif,&length) != 0x66)\n       continue;\n     if (ReadPropertyByte(&exif,&length) != 0x00)\n       continue;\n     if (ReadPropertyByte(&exif,&length) != 0x00)\n       continue;\n     break;\n   }\n   if (length < 16)\n     return(MagickFalse);\n   id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n   endian=LSBEndian;\n   if (id == 0x4949)\n     endian=LSBEndian;\n   else\n     if (id == 0x4D4D)\n       endian=MSBEndian;\n     else\n       return(MagickFalse);\n   if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n     return(MagickFalse);\n   offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n   if ((offset < 0) || (size_t) offset >= length)\n     return(MagickFalse);\n   status=MagickFalse;\n   directory=exif+offset;\n   level=0;\n   entry=0;\n   tag_offset=0;\n   exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n     (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n   do\n   {\n     if (level > 0)\n       {\n         level--;\n         directory=directory_stack[level].directory;\n         entry=directory_stack[level].entry;\n         tag_offset=directory_stack[level].offset;\n       }\n     if ((directory < exif) || (directory > (exif+length-2)))\n       break;\n     number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n     for ( ; entry < number_entries; entry++)\n     {\n       unsigned char\n         *p,\n         *q;\n \n       size_t\n         format;\n \n       ssize_t\n         number_bytes,\n         components;\n \n       q=(unsigned char *) (directory+(12*entry)+2);\n       if (q > (exif+length-12))\n         break;\n       if (GetValueFromSplayTree(exif_resources,q) == q)\n         break;\n       (void) AddValueToSplayTree(exif_resources,q,q);\n       tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n       format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n       if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n         break;\n       if (format == 0)\n         break;\n       components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n       if (components < 0)\n         break;\n       number_bytes=(size_t) components*tag_bytes[format];\n       if (number_bytes < components)\n         break;\n       if (number_bytes <= 4)\n         p=q+8;\n       else\n         {\n           ssize_t\n             dir_offset;\n \n           dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n           if ((dir_offset < 0) || (size_t) dir_offset >= length)\n             continue;\n           if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)\n             continue;\n           if (((size_t) dir_offset+number_bytes) > length)\n             continue;\n           p=(unsigned char *) (exif+dir_offset);\n         }\n       if ((all != 0) || (tag == (size_t) tag_value))\n         {\n           char\n             buffer[MaxTextExtent],\n             *value;\n \n           if ((p < exif) || (p > (exif+length-tag_bytes[format])))\n             break;\n           value=(char *) NULL;\n           *buffer='\\0';\n           switch (format)\n           {\n             case EXIF_FMT_BYTE:\n             case EXIF_FMT_UNDEFINED:\n             {\n               value=(char *) NULL;\n               if (~((size_t) number_bytes) >= 1)\n                 value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                   sizeof(*value));\n               if (value != (char *) NULL)\n                 {\n                   for (i=0; i < (ssize_t) number_bytes; i++)\n                   {\n                     value[i]='.';\n                     if (isprint((int) p[i]) != 0)\n                       value[i]=(char) p[i];\n                   }\n                   value[i]='\\0';\n                 }\n               break;\n             }\n             case EXIF_FMT_SBYTE:\n             {\n               EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n               break;\n             }\n             case EXIF_FMT_SSHORT:\n             {\n               EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n               break;\n             }\n             case EXIF_FMT_USHORT:\n             {\n               EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n               break;\n             }\n             case EXIF_FMT_ULONG:\n             {\n               EXIFMultipleValues(4,\"%.20g\",(double)\n                 ReadPropertyUnsignedLong(endian,p1));\n               break;\n             }\n             case EXIF_FMT_SLONG:\n             {\n               EXIFMultipleValues(4,\"%.20g\",(double)\n                 ReadPropertySignedLong(endian,p1));\n               break;\n             }\n             case EXIF_FMT_URATIONAL:\n             {\n               EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                 ReadPropertyUnsignedLong(endian,p1),(double)\n                 ReadPropertyUnsignedLong(endian,p1+4));\n               break;\n             }\n             case EXIF_FMT_SRATIONAL:\n             {\n               EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                 ReadPropertySignedLong(endian,p1),(double)\n                 ReadPropertySignedLong(endian,p1+4));\n               break;\n             }\n             case EXIF_FMT_SINGLE:\n             {\n// bug_start\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n// bug_end\n               break;\n             }\n             case EXIF_FMT_DOUBLE:\n             {\n// bug_start\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n// bug_end\n               break;\n             }\n             case EXIF_FMT_STRING:\n             default:\n             {\n               if ((p < exif) || (p > (exif+length-number_bytes)))\n                 break;\n               value=(char *) NULL;\n               if (~((size_t) number_bytes) >= 1)\n                 value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                   sizeof(*value));\n               if (value != (char *) NULL)\n                 {\n                   ssize_t\n                     i;\n \n                   for (i=0; i < (ssize_t) number_bytes; i++)\n                   {\n                     value[i]='.';\n                     if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                       value[i]=(char) p[i];\n                   }\n                   value[i]='\\0';\n                 }\n               break;\n             }\n           }\n           if (value != (char *) NULL)\n             {\n               char\n                 *key;\n \n               const char\n                 *p;\n \n               key=AcquireString(property);\n               switch (all)\n               {\n                 case 1:\n                 {\n                   const char\n                     *description;\n \n                   ssize_t\n                     i;\n \n                   description=\"unknown\";\n                   for (i=0; ; i++)\n                   {\n                     if (EXIFTag[i].tag == 0)\n                       break;\n                     if (EXIFTag[i].tag == tag_value)\n                       {\n                         description=EXIFTag[i].description;\n                         break;\n                       }\n                   }\n                   (void) FormatLocaleString(key,MaxTextExtent,\"%s\",\n                     description);\n                   if (level == 2)\n                     (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                   break;\n                 }\n                 case 2:\n                 {\n                   if (tag_value < 0x10000)\n                     (void) FormatLocaleString(key,MaxTextExtent,\"#%04lx\",\n                       (unsigned long) tag_value);\n                   else\n                     if (tag_value < 0x20000)\n                       (void) FormatLocaleString(key,MaxTextExtent,\"@%04lx\",\n                         (unsigned long) (tag_value & 0xffff));\n                     else\n                       (void) FormatLocaleString(key,MaxTextExtent,\"unknown\");\n                   break;\n                 }\n                 default:\n                 {\n                   if (level == 2)\n                     (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                 }\n               }\n               p=(const char *) NULL;\n               if (image->properties != (void *) NULL)\n                 p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                   image->properties,key);\n               if (p == (const char *) NULL)\n                 (void) SetImageProperty((Image *) image,key,value);\n               value=DestroyString(value);\n               key=DestroyString(key);\n               status=MagickTrue;\n             }\n         }\n         if ((tag_value == TAG_EXIF_OFFSET) ||\n             (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n           {\n             ssize_t\n               offset;\n \n             offset=(ssize_t) ReadPropertySignedLong(endian,p);\n             if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n               {\n                 ssize_t\n                   tag_offset1;\n \n                 tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                   0);\n                 directory_stack[level].directory=directory;\n                 entry++;\n                 directory_stack[level].entry=entry;\n                 directory_stack[level].offset=tag_offset;\n                 level++;\n                 for (i=0; i < level; i++)\n                   if (directory_stack[i].directory == (exif+tag_offset1))\n                     break;\n                 if (i < level)\n                   break;\n                 directory_stack[level].directory=exif+offset;\n                 directory_stack[level].offset=tag_offset1;\n                 directory_stack[level].entry=0;\n                 level++;\n                 if ((directory+2+(12*number_entries)+4) > (exif+length))\n                   break;\n                 offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                   number_entries));\n                 if ((offset != 0) && ((size_t) offset < length) &&\n                     (level < (MaxDirectoryStack-2)))\n                   {\n                     directory_stack[level].directory=exif+offset;\n                     directory_stack[level].entry=0;\n                     directory_stack[level].offset=tag_offset1;\n                     level++;\n                   }\n               }\n             break;\n           }\n     }\n   } while (level > 0);\n   exif_resources=DestroySplayTree(exif_resources);\n   return(status);\n }\n \n", "target": "// fix_start\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n// fix_end\n// fix_start\n              EXIFMultipleValues(8,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n// fix_end\n", "cwe": "CWE-704", "cwe_name": "Incorrect Type Conversion or Cast", "cve": "CVE-2022-32547", "cve_desc": "In ImageMagick, there is load of misaligned address for type 'double', which requires 8 byte alignment and for type 'float', which requires 4 byte alignment at MagickCore/property.c. Whenever crafted or untrusted input is processed by ImageMagick, this causes a negative impact to application availability or other problems related to undefined behavior.", "project": "ImageMagick6", "idx": 194963}
{"source": " static MagickBooleanType ReadPSDChannelPixels(Image *image,\n   const size_t channels,const ssize_t row,const ssize_t type,\n   const unsigned char *pixels,ExceptionInfo *exception)\n {\n   Quantum\n     pixel;\n \n   const unsigned char\n     *p;\n \n   IndexPacket\n     *indexes;\n \n   PixelPacket\n     *q;\n \n   ssize_t\n     x;\n \n   size_t\n     packet_size;\n \n   unsigned short\n     nibble;\n \n   p=pixels;\n   q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n   if (q == (PixelPacket *) NULL)\n     return MagickFalse;\n   indexes=GetAuthenticIndexQueue(image);\n   packet_size=GetPSDPacketSize(image);\n   for (x=0; x < (ssize_t) image->columns; x++)\n   {\n     if (packet_size == 1)\n       pixel=ScaleCharToQuantum(*p++);\n     else\n       if (packet_size == 2)\n         {\n           p=PushShortPixel(MSBEndian,p,&nibble);\n           pixel=ScaleShortToQuantum(nibble);\n         }\n       else\n         {\n           MagickFloatType\n             nibble;\n \n           p=PushFloatPixel(MSBEndian,p,&nibble);\n           pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n         }\n     if (image->depth > 1)\n       {\n         SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n         q++;\n       }\n     else\n       {\n         ssize_t\n           bit,\n           number_bits;\n \n         number_bits=(ssize_t) image->columns-x;\n         if (number_bits > 8)\n           number_bits=8;\n         for (bit=0; bit < number_bits; bit++)\n         {\n// bug_start\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n// bug_end\n         }\n         if (x != (ssize_t) image->columns)\n           x--;\n         continue;\n       }\n   }\n   return(SyncAuthenticPixels(image,exception));\n }\n \n", "target": "// fix_start\n          SetPSDPixel(image,channels,type,packet_size,\n            (((unsigned char) ((ssize_t) pixel)) & (0x01 << (7-bit))) != 0 ? 0 :\n            QuantumRange,q++,indexes,x++);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "project": "ImageMagick6", "idx": 194989}
{"source": " Status ImmutableExecutorState::Initialize(const Graph& graph) {\n   TF_RETURN_IF_ERROR(gview_.Initialize(&graph));\n \n   ControlFlowInfo cf_info;\n   TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));\n \n   for (auto& it : cf_info.unique_frame_names) {\n     EnsureFrameInfo(it)->nodes =\n         absl::make_unique<std::vector<const NodeItem*>>();\n   }\n   root_frame_info_ = frame_info_[\"\"].get();\n \n   pending_ids_.resize(gview_.num_nodes());\n \n   requires_control_flow_ = false;\n   for (const Node* n : graph.nodes()) {\n     if (IsSink(n)) continue;\n     if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {\n       requires_control_flow_ = true;\n     } else if (IsRecv(n)) {\n       string send_device;\n       string recv_device;\n       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"send_device\", &send_device));\n       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"recv_device\", &recv_device));\n       if (send_device != recv_device) {\n         requires_control_flow_ = true;\n       }\n     }\n \n     const int id = n->id();\n     const string& frame_name = cf_info.frame_names[id];\n     FrameInfo* frame_info = EnsureFrameInfo(frame_name);\n \n     NodeItem* item = gview_.node(id);\n     item->node_id = id;\n \n     item->input_start = frame_info->total_inputs;\n     frame_info->total_inputs += n->num_inputs();\n \n     Status s = params_.create_kernel(n->properties(), &item->kernel);\n     if (!s.ok()) {\n// bug_start\n// bug_end\n       item->kernel = nullptr;\n       s = AttachDef(s, *n);\n       return s;\n     }\n     CHECK(item->kernel);\n     item->kernel_is_async = (item->kernel->AsAsync() != nullptr);\n     item->is_merge = IsMerge(n);\n     item->is_any_consumer_merge_or_control_trigger = false;\n     for (const Node* consumer : n->out_nodes()) {\n       if (IsMerge(consumer) || IsControlTrigger(consumer)) {\n         item->is_any_consumer_merge_or_control_trigger = true;\n         break;\n       }\n     }\n     const Tensor* const_tensor = item->kernel->const_tensor();\n     if (const_tensor) {\n       const_tensors_.emplace_back(*const_tensor);\n     }\n     item->const_tensor = const_tensor;\n     item->is_noop = (item->kernel->type_string_view() == \"NoOp\");\n     item->is_enter = IsEnter(n);\n     if (item->is_enter) {\n       bool is_constant_enter;\n       TF_RETURN_IF_ERROR(\n           GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter));\n       item->is_constant_enter = is_constant_enter;\n \n       string frame_name;\n       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &frame_name));\n       FrameInfo* frame_info = frame_info_[frame_name].get();\n \n       int parallel_iterations;\n       TF_RETURN_IF_ERROR(\n           GetNodeAttr(n->attrs(), \"parallel_iterations\", &parallel_iterations));\n \n       if (frame_info->parallel_iterations == -1) {\n         frame_info->parallel_iterations = parallel_iterations;\n       } else if (frame_info->parallel_iterations != parallel_iterations) {\n         LOG(WARNING) << \"Loop frame \\\"\" << frame_name\n                      << \"\\\" had two different values for parallel_iterations: \"\n                      << frame_info->parallel_iterations << \" vs. \"\n                      << parallel_iterations << \".\";\n       }\n \n       if (enter_frame_info_.size() <= id) {\n         enter_frame_info_.resize(id + 1);\n       }\n       enter_frame_info_[id] = frame_info;\n     } else {\n       item->is_constant_enter = false;\n     }\n     item->is_exit = IsExit(n);\n     item->is_control_trigger = IsControlTrigger(n);\n     item->is_source = IsSource(n);\n     item->is_enter_exit_or_next_iter =\n         (IsEnter(n) || IsExit(n) || IsNextIteration(n));\n     item->is_transfer_node = IsTransferNode(n);\n     item->is_initialization_op = IsInitializationOp(n);\n     item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);\n     item->is_next_iteration = IsNextIteration(n);\n     item->is_distributed_communication = IsDistributedCommunication(n);\n \n     size_t max_pending, max_dead;\n     GetMaxPendingCounts(n, &max_pending, &max_dead);\n     pending_ids_[id] =\n         frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);\n \n     if (n->in_edges().empty()) {\n       root_nodes_.push_back(item);\n     }\n \n     frame_info->nodes->push_back(item);\n     if (item->is_enter) {\n       string enter_name;\n       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &enter_name));\n       EnsureFrameInfo(enter_name)->input_count++;\n     }\n \n     std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);\n     std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);\n     int32_t unused_outputs = n->num_outputs();\n     for (const Edge* e : n->out_edges()) {\n       if (IsSink(e->dst())) continue;\n       if (e->src_output() >= 0) {\n         if (!outputs_required[e->src_output()]) {\n           --unused_outputs;\n           outputs_required[e->src_output()] = true;\n         }\n       }\n     }\n     if (unused_outputs > 0) {\n       for (int i = 0; i < n->num_outputs(); ++i) {\n         if (!outputs_required[i]) {\n           metrics::RecordUnusedOutput(n->type_string());\n         }\n       }\n       item->outputs_required = std::move(outputs_required);\n     }\n   }\n \n   for (const Node* n : graph.nodes()) {\n     if (IsSink(n)) continue;\n     const int id = n->id();\n     NodeItem* item = gview_.node(id);\n \n     for (EdgeInfo& e : item->mutable_output_edges()) {\n       const int dst_id = e.dst_id;\n       NodeItem* dst_item = gview_.node(dst_id);\n       e.input_slot += dst_item->input_start;\n     }\n   }\n \n   InitializePending(&graph, cf_info);\n   return gview_.SetAllocAttrs(&graph, params_.device);\n }\n \n", "target": "// fix_start\n      params_.delete_kernel(item->kernel);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2022-23578", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. If a graph node is invalid, TensorFlow can leak memory in the implementation of `ImmutableExecutorState::Initialize`. Here, we set `item->kernel` to `nullptr` but it is a simple `OpKernel*` pointer so the memory that was previously allocated to it would leak. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 194994}
{"source": " Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                  string* init_op_name) {\n   const auto& sig_def_map = meta_graph_def.signature_def();\n   const auto& init_op_sig_it =\n       meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n   if (init_op_sig_it != sig_def_map.end()) {\n// bug_start\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n// bug_end\n     return Status::OK();\n   }\n \n   const auto& collection_def_map = meta_graph_def.collection_def();\n   string init_op_collection_key;\n   if (collection_def_map.find(kSavedModelMainOpKey) !=\n       collection_def_map.end()) {\n     init_op_collection_key = kSavedModelMainOpKey;\n   } else {\n     init_op_collection_key = kSavedModelLegacyInitOpKey;\n   }\n \n   const auto init_op_it = collection_def_map.find(init_op_collection_key);\n   if (init_op_it != collection_def_map.end()) {\n     if (init_op_it->second.node_list().value_size() != 1) {\n       return errors::FailedPrecondition(\n           strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n     }\n     *init_op_name = init_op_it->second.node_list().value(0);\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n    const auto& sig_def_outputs = init_op_sig_it->second.outputs();\n    const auto& sig_def_outputs_it =\n        sig_def_outputs.find(kSavedModelInitOpSignatureKey);\n    if (sig_def_outputs_it == sig_def_outputs.end()) {\n      return errors::FailedPrecondition(\"Could not find output \",\n                                        kSavedModelInitOpSignatureKey);\n    }\n    *init_op_name = sig_def_outputs_it->second.name();\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-23577", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `GetInitOp` is vulnerable to a crash caused by dereferencing a null pointer. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 194996}
{"source": " Status ConstantFolding::IsSimplifiableReshape(\n     const NodeDef& node, const GraphProperties& properties) const {\n   if (!IsReshape(node)) {\n     return errors::Internal(\"Node \", node.name(), \" is not a Reshape node\");\n   }\n   if (2 > node.input_size()) {\n     return errors::Internal(\"Node \", node.name(),\n                             \" must have at most 2 inputs but has \",\n                             node.input_size());\n   }\n   const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n   if (!IsReallyConstant(*new_shape)) {\n     return errors::Internal(\"Node \", node.name(), \" has shape \",\n                             new_shape->DebugString(),\n                             \" which is not a constant\");\n   }\n   TensorVector outputs;\n   auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n     for (const auto& output : outputs) {\n       delete output.tensor;\n     }\n   });\n \n   Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n   if (!s.ok()) {\n     return errors::Internal(\"Could not evaluate node \", node.name());\n   }\n   if (outputs.size() != 1) {\n     return errors::Internal(\"Node \", node.name(),\n                             \" must have exactly 1 output but has \",\n                             outputs.size());\n   }\n \n   const std::vector<OpInfo::TensorProperties>& props =\n       properties.GetInputProperties(node.name());\n   if (props.empty()) {\n     return errors::Internal(\"Node \", node.name(), \" has no properties\");\n   }\n   const OpInfo::TensorProperties& prop = props[0];\n   if (prop.dtype() == DT_INVALID) {\n     return errors::Internal(\"Node \", node.name(), \" has property \",\n                             prop.DebugString(), \" with invalid dtype\");\n   }\n   const PartialTensorShape shape(prop.shape());\n   if (!shape.IsFullyDefined()) {\n     return errors::Internal(\"Node \", node.name(), \" has property \",\n                             prop.DebugString(), \" with shape \",\n                             shape.DebugString(), \" which is not fully defined\");\n   }\n \n   PartialTensorShape new_dims;\n   if (outputs[0]->dtype() == DT_INT32) {\n     std::vector<int32> shp;\n     for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n       int32_t dim = outputs[0]->flat<int32>()(i);\n       shp.push_back(dim);\n     }\n// bug_start\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n// bug_end\n   } else {\n     std::vector<int64_t> shp;\n     for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n       int64_t dim = outputs[0]->flat<int64_t>()(i);\n       shp.push_back(dim);\n     }\n// bug_start\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n// bug_end\n   }\n \n   if (!shape.IsCompatibleWith(new_dims)) {\n     return errors::Internal(\"Expected shape \", shape.DebugString(),\n                             \"to be compatible with \", new_dims.DebugString());\n   }\n \n   return Status::OK();\n }\n \n", "target": "// fix_start\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n// fix_end\n// fix_start\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 194998}
{"source": " u32 GetHintFormat(GF_TrackBox *trak)\n {\n \tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n// bug_start\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n// bug_end\n \t\treturn 0;\n \n \tif (!hmhd || !hmhd->subType) {\n \t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n \t\tif (!hmhd) return a ? a->type : 0;\n \t\tif (a) hmhd->subType = a->type;\n \t\treturn hmhd->subType;\n \t}\n \treturn hmhd->subType;\n }\n \n", "target": "// fix_start\n\tif (!hmhd || (hmhd->type != GF_ISOM_BOX_TYPE_HMHD))\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-40576", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the gf_isom_get_payt_count function in hint_track.c, which allows attackers to cause a denial of service.", "project": "gpac", "idx": 195017}
{"source": " Status ConstantFolding::EvaluateOneFoldable(const NodeDef& node,\n                                             std::vector<NodeDef>* outputs,\n                                             bool* result_too_large) {\n   TensorVector inputs;\n   TensorVector output_tensors;\n   auto inputs_cleanup = gtl::MakeCleanup([&inputs, &output_tensors] {\n     for (const auto& input : inputs) {\n       delete input.tensor;\n     }\n     for (const auto& output : output_tensors) {\n       if (output.tensor) {\n         delete output.tensor;\n       }\n     }\n   });\n \n   size_t total_inputs_size = 0;\n   for (const auto& input : node.input()) {\n     const TensorId input_tensor = ParseTensorName(input);\n     if (input_tensor.index() < 0) {\n       break;\n     }\n     const NodeDef* input_node = node_map_->GetNode(input);\n     if (!IsReallyConstant(*input_node)) {\n       return Status(error::INVALID_ARGUMENT,\n                     strings::StrCat(\"Can't fold \", node.name(), \", its \", input,\n                                     \" isn't constant\"));\n     }\n     TF_RETURN_IF_ERROR(CheckAttrExists(*input_node, \"value\"));\n     const TensorProto& raw_val = input_node->attr().at(\"value\").tensor();\n     if (raw_val.dtype() == DT_INVALID) {\n       return Status(\n           error::INVALID_ARGUMENT,\n           strings::StrCat(\"A tensor in the input node, with TensorId of \",\n                           input_tensor.ToString(),\n                           \" has a dtype of DT_INVALID.\"));\n     }\n// bug_start\n// bug_end\n     Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());\n     if (!value->FromProto(raw_val)) {\n       delete (value);\n       return errors::InvalidArgument(\"Unable to make Tensor from proto for \",\n                                      node.name(), \" with shape \",\n                                      raw_val.tensor_shape().DebugString());\n     }\n     inputs.emplace_back(value);\n     total_inputs_size += value->TotalBytes();\n   }\n \n   TF_RETURN_IF_ERROR(EvaluateNode(node, inputs, &output_tensors));\n   if (output_tensors.empty()) {\n     return Status(error::INVALID_ARGUMENT, \"Expected at least one output.\");\n   }\n \n   outputs->resize(output_tensors.size());\n   for (size_t i = 0; i < output_tensors.size(); i++) {\n     string node_name = OptimizedNodeName(node, \"-folded\");\n     if (output_tensors.size() > 1) {\n       node_name = strings::StrCat(node_name, \"-\", i);\n     }\n     if (output_tensors[i].tensor) {\n       Status s = CreateNodeDef(node_name, output_tensors[i], &outputs->at(i),\n                                total_inputs_size);\n       if (!s.ok()) {\n         *result_too_large = true;\n         return s;\n       }\n     } else {\n       outputs->at(i) = NodeDef();\n     }\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n    if (IsRefType(raw_val.dtype())) {\n      return errors::InvalidArgument(\n          \"Not allowed to construct a tensor with reference dtype, got \",\n          DataTypeString(raw_val.dtype()));\n    }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-23588", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that Grappler optimizer would attempt to build a tensor using a reference `dtype`. This would result in a crash due to a `CHECK`-fail in the `Tensor` constructor as reference types are not allowed. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195019}
{"source": " int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {\n   struct config_elements * config = (struct config_elements *)user_data;\n   json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;\n   const char * ip_source = get_ip_source(request);\n   char * issued_for = get_client_hostname(request);\n   char * session_uid, expires[129];\n   time_t now;\n   struct tm ts;\n \n   time(&now);\n   now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;\n   gmtime_r(&now, &ts);\n   strftime(expires, 128, \"%a, %d %b %Y %T %Z\", &ts);\n   if (j_param != NULL) {\n     if (json_string_length(json_object_get(j_param, \"username\"))) {\n       if (json_object_get(j_param, \"scheme_type\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, \"scheme_type\")), \"password\")) {\n         if (json_string_length(json_object_get(j_param, \"password\"))) {\n           j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"password\")));\n           if (check_result_value(j_result, G_OK)) {\n             if ((session_uid = get_session_id(config, request)) == NULL) {\n               session_uid = generate_session_id();\n             }\n             if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n               y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (1)\");\n               response->status = 500;\n             } else {\n               ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n               y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with password\", json_string_value(json_object_get(j_param, \"username\")));\n             }\n             o_free(session_uid);\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n           } else {\n             if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n               y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n             }\n// bug_start\n            if ((session_uid = get_session_id(config, request)) != NULL && user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (2)\");\n            }\n            o_free(session_uid);\n// bug_end\n             response->status = 401;\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n           }\n           json_decref(j_result);\n         } else if (json_object_get(j_param, \"password\") != NULL && !json_is_string(json_object_get(j_param, \"password\"))) {\n           ulfius_set_string_body_response(response, 400, \"password must be a string\");\n         } else {\n           session_uid = get_session_id(config, request);\n           j_result = get_users_for_session(config, session_uid);\n           if (check_result_value(j_result, G_OK)) {\n             if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 0) != G_OK) {\n               y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (3)\");\n               response->status = 500;\n             } else {\n               ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n             }\n           } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n             response->status = 401;\n           } else {\n             y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error get_users_for_session\");\n             response->status = 500;\n           }\n           o_free(session_uid);\n           json_decref(j_result);\n         }\n       } else {\n         if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n           j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_string_value(json_object_get(j_param, \"username\")), json_object_get(j_param, \"value\"), request);\n           if (check_result_value(j_result, G_ERROR_PARAM)) {\n             ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n           } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n             y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n             response->status = 401;\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n           } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n             response->status = 404;\n           } else if (check_result_value(j_result, G_OK)) {\n             if ((session_uid = get_session_id(config, request)) == NULL) {\n               session_uid = generate_session_id();\n             }\n             if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n               y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n               response->status = 500;\n             } else {\n               ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n               y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n             }\n             o_free(session_uid);\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n           } else {\n             y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n             response->status = 500;\n           }\n           json_decref(j_result);\n         } else {\n           ulfius_set_string_body_response(response, 400, \"scheme_type, scheme_name and value are mandatory\");\n         }\n       }\n     } else {\n       if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n         j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_object_get(j_param, \"value\"), request);\n         if (check_result_value(j_result, G_ERROR_PARAM)) {\n           ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n         } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n           y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username <UNKNOWN> at IP Address %s\", ip_source);\n           response->status = 401;\n         } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n           response->status = 404;\n         } else if (check_result_value(j_result, G_OK)) {\n           if ((session_uid = get_session_id(config, request)) == NULL) {\n             session_uid = generate_session_id();\n           }\n           if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n             y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n             response->status = 500;\n           } else {\n             ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n             y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n           }\n           o_free(session_uid);\n         } else {\n           y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n           response->status = 500;\n         }\n         json_decref(j_result);\n       } else {\n         ulfius_set_string_body_response(response, 400, \"username is mandatory\");\n       }\n     }\n   } else {\n     ulfius_set_string_body_response(response, 400, \"Input parameters must be in JSON format\");\n   }\n   json_decref(j_param);\n   o_free(issued_for);\n \n   return U_CALLBACK_CONTINUE;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "project": "glewlwyd", "idx": 195022}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor* input_indices;\n     const Tensor* input_values;\n     const Tensor* input_shape;\n     SparseTensorsMap* map;\n \n     OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n     OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n     OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n     OP_REQUIRES_OK(context, GetMap(context, true , &map));\n \n     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                 errors::InvalidArgument(\n                     \"Input indices should be a matrix but received shape \",\n                     input_indices->shape().DebugString()));\n     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                 errors::InvalidArgument(\n                     \"Input values should be a vector but received shape \",\n                     input_values->shape().DebugString()));\n     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                 errors::InvalidArgument(\n                     \"Input shape should be a vector but received shape \",\n                     input_shape->shape().DebugString()));\n     OP_REQUIRES(\n         context,\n         input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n         errors::InvalidArgument(\n             \"Number of values must match first dimension of indices. \", \"Got \",\n             input_values->shape().dim_size(0),\n             \" values, indices shape: \", input_indices->shape().DebugString()));\n     OP_REQUIRES(\n         context,\n         input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n         errors::InvalidArgument(\n             \"Number of dimensions must match second dimension of indices. \",\n             \"Got \", input_shape->shape().dim_size(0),\n             \" dimensions, indices shape: \",\n             input_indices->shape().DebugString()));\n \n     int rank = input_shape->NumElements();\n \n     OP_REQUIRES(\n         context, rank > 1,\n         errors::InvalidArgument(\n             \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n \n     auto input_shape_vec = input_shape->vec<int64_t>();\n// bug_start\n    int new_num_elements = 1;\n    bool overflow_ocurred = false;\n    for (int i = 0; i < input_shape_vec.size(); i++) {\n      new_num_elements =\n          MultiplyWithoutOverflow(new_num_elements, input_shape_vec(i));\n      if (new_num_elements < 0) {\n        overflow_ocurred = true;\n        break;\n      }\n    }\n// bug_end\n \n// bug_start\n    OP_REQUIRES(\n        context, !overflow_ocurred,\n        errors::Internal(\"Encountered overflow from large input shape.\"));\n\n    TensorShape tensor_input_shape(input_shape_vec);\n// bug_end\n     gtl::InlinedVector<int64_t, 8> std_order(rank);\n     std::iota(std_order.begin(), std_order.end(), 0);\n     SparseTensor input_st;\n     OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                  tensor_input_shape, std_order,\n                                                  &input_st));\n \n     const int64_t N = input_shape_vec(0);\n \n     Tensor sparse_handles(DT_INT64, TensorShape({N}));\n     auto sparse_handles_t = sparse_handles.vec<int64_t>();\n \n     OP_REQUIRES_OK(context, input_st.IndicesValid());\n \n     TensorShape output_shape;\n     OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                 input_shape_vec.data() + 1,\n                                 input_shape->NumElements() - 1, &output_shape));\n \n     std::unordered_set<int64_t> visited;\n     sparse::GroupIterable minibatch = input_st.group({0});\n     for (const auto& subset : minibatch) {\n       const int64_t b = subset.group()[0];\n       visited.insert(b);\n       OP_REQUIRES(\n           context, b > -1 && b < N,\n           errors::InvalidArgument(\n               \"Received unexpected column 0 value in input SparseTensor: \", b,\n               \" < 0 or >= N (= \", N, \")\"));\n \n       const auto indices = subset.indices();\n       const auto values = subset.values<T>();\n       const int64_t num_entries = values.size();\n \n       Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n       Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});\n \n       auto output_indices_t = output_indices.matrix<int64_t>();\n       auto output_values_t = output_values.vec<T>();\n \n       for (int i = 0; i < num_entries; ++i) {\n         for (int d = 1; d < rank; ++d) {\n           output_indices_t(i, d - 1) = indices(i, d);\n         }\n         output_values_t(i) = values(i);\n       }\n \n       SparseTensor st_i;\n       OP_REQUIRES_OK(context,\n                      SparseTensor::Create(output_indices, output_values,\n                                           output_shape, &st_i));\n       int64_t handle;\n       OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));\n       sparse_handles_t(b) = handle;\n     }\n \n     if (visited.size() < N) {\n       Tensor empty_indices(DT_INT64, {0, rank - 1});\n       Tensor empty_values(DataTypeToEnum<T>::value, {0});\n       SparseTensor empty_st;\n       OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                    output_shape, &empty_st));\n \n       for (int64_t b = 0; b < N; ++b) {\n         if (visited.find(b) == visited.end()) {\n           int64_t handle;\n           OP_REQUIRES_OK(context,\n                          map->AddSparseTensor(context, empty_st, &handle));\n           sparse_handles_t(b) = handle;\n         }\n       }\n     }\n \n     context->set_output(0, sparse_handles);\n   }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    TensorShape tensor_input_shape;\n    OP_REQUIRES_OK(context, TensorShape::BuildTensorShape(input_shape_vec,\n                                                          &tensor_input_shape));\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2022-23568", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `AddManySparseToTensorsMap` is vulnerable to an integer overflow which results in a `CHECK`-fail when building new `TensorShape` objects (so, an assert failure based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195023}
{"source": " nfs4_file_open(struct inode *inode, struct file *filp)\n {\n \tstruct nfs_open_context *ctx;\n \tstruct dentry *dentry = file_dentry(filp);\n \tstruct dentry *parent = NULL;\n \tstruct inode *dir;\n \tunsigned openflags = filp->f_flags;\n \tstruct iattr attr;\n \tint err;\n \n \n \tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n \n \terr = nfs_check_flags(openflags);\n \tif (err)\n \t\treturn err;\n \n \tif ((openflags & O_ACCMODE) == 3)\n// bug_start\n\t\treturn nfs_open(inode, filp);\n// bug_end\n \n \topenflags &= ~(O_CREAT|O_EXCL);\n \n \tparent = dget_parent(dentry);\n \tdir = d_inode(parent);\n \n \tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n \terr = PTR_ERR(ctx);\n \tif (IS_ERR(ctx))\n \t\tgoto out;\n \n \tattr.ia_valid = ATTR_OPEN;\n \tif (openflags & O_TRUNC) {\n \t\tattr.ia_valid |= ATTR_SIZE;\n \t\tattr.ia_size = 0;\n \t\tfilemap_write_and_wait(inode->i_mapping);\n \t}\n \n \tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n \tif (IS_ERR(inode)) {\n \t\terr = PTR_ERR(inode);\n \t\tswitch (err) {\n \t\tdefault:\n \t\t\tgoto out_put_ctx;\n \t\tcase -ENOENT:\n \t\tcase -ESTALE:\n \t\tcase -EISDIR:\n \t\tcase -ENOTDIR:\n \t\tcase -ELOOP:\n \t\t\tgoto out_drop;\n \t\t}\n \t}\n \tif (inode != d_inode(dentry))\n \t\tgoto out_drop;\n \n \tnfs_file_set_open_context(filp, ctx);\n \tnfs_fscache_open_file(inode, filp);\n \terr = 0;\n \n out_put_ctx:\n \tput_nfs_open_context(ctx);\n out:\n \tdput(parent);\n \treturn err;\n \n out_drop:\n \td_drop(dentry);\n \terr = -EOPENSTALE;\n \tgoto out_put_ctx;\n }\n \n", "target": "// fix_start\n\t\topenflags--;\n// fix_end\n", "cwe": "CWE-909", "cwe_name": "Missing Initialization of Resource", "cve": "CVE-2022-24448", "cve_desc": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.", "project": "linux", "idx": 195026}
{"source": "   void DecodePngV2(OpKernelContext* context, StringPiece input) {\n     int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n     png::DecodeContext decode;\n     OP_REQUIRES(\n         context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n         errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n// bug_start\n// bug_end\n \n     const int width = static_cast<int>(decode.width);\n     const int height = static_cast<int>(decode.height);\n     const int64_t total_size =\n         static_cast<int64_t>(width) * static_cast<int64_t>(height);\n     if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n         width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n         height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n       OP_REQUIRES(context, false,\n                   errors::InvalidArgument(\"PNG size too large for int: \",\n                                           decode.width, \" by \", decode.height));\n     }\n \n     Tensor* output = nullptr;\n     if (op_type_ == \"DecodeGif\") {\n       OP_REQUIRES_OK(\n           context,\n           context->allocate_output(\n               0, TensorShape({1, height, width, decode.channels}), &output));\n     } else {\n       OP_REQUIRES_OK(\n           context,\n           context->allocate_output(\n               0, TensorShape({height, width, decode.channels}), &output));\n     }\n \n     if (op_type_ == \"DecodeBmp\") {\n       OP_REQUIRES(context, false,\n                   errors::InvalidArgument(\n                       \"Trying to decode PNG format using DecodeBmp op. Use \"\n                       \"`decode_png` or `decode_image` instead.\"));\n     } else if (op_type_ == \"DecodeAndCropJpeg\") {\n       OP_REQUIRES(context, false,\n                   errors::InvalidArgument(\n                       \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                       \"detected PNG.\"));\n     }\n \n     if (data_type_ == DataType::DT_UINT8) {\n       OP_REQUIRES(\n           context,\n           png::CommonFinishDecode(\n               reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n               decode.channels * width * sizeof(uint8), &decode),\n           errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n     } else if (data_type_ == DataType::DT_UINT16) {\n       OP_REQUIRES(\n           context,\n           png::CommonFinishDecode(\n               reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n               decode.channels * width * sizeof(uint16), &decode),\n           errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n     } else if (data_type_ == DataType::DT_FLOAT) {\n       std::unique_ptr<uint16[]> buffer(\n           new uint16[height * width * decode.channels]);\n       OP_REQUIRES(\n           context,\n           png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                   decode.channels * width * sizeof(uint16),\n                                   &decode),\n           errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n \n       const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n       TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                   decode.channels);\n       float scale = 1. / std::numeric_limits<uint16>::max();\n       output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n     }\n   }\n \n", "target": "// fix_start\n\n    auto cleanup = gtl::MakeCleanup([&decode]() {\n      std::cerr << \"Cleanup called...\\n\";\n      png::CommonFreeDecode(&decode);\n    });\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2022-23585", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When decoding PNG images TensorFlow can produce a memory leak if the image is invalid. After calling `png::CommonInitDecode(..., &decode)`, the `decode` value contains allocated buffers which can only be freed by calling `png::CommonFreeDecode(&decode)`. However, several error case in the function implementation invoke the `OP_REQUIRES` macro which immediately terminates the execution of the function, without allowing for the memory free to occur. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195028}
{"source": " void Node::RunForwardTypeInference() {\n   VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n \n   if (props_->fwd_type_fn == nullptr) {\n     return;\n   }\n \n   std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n   std::vector<int> input_idx(props_->input_types.size(), 0);\n   for (const auto& edge : in_edges_) {\n     if (edge->IsControlEdge()) {\n       continue;\n     }\n     DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n     int i = edge->dst_input();\n     input_nodes.at(i) = edge->src();\n     input_idx.at(i) = edge->src_output();\n   }\n \n \n   for (const auto* node : input_nodes) {\n     if (node == nullptr) {\n       ClearTypeInfo();\n       return;\n     }\n   }\n \n   static FullTypeDef* no_type = new FullTypeDef();\n \n   std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n   for (int i = 0; i < input_nodes.size(); i++) {\n     const auto* node = input_nodes[i];\n     if (node->def().has_experimental_type()) {\n       const auto& node_t = node->def().experimental_type();\n       if (node_t.type_id() != TFT_UNSET) {\n         int ix = input_idx[i];\n// bug_start\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n// bug_end\n         input_types.emplace_back(node_t.args(ix));\n       } else {\n         input_types.emplace_back(*no_type);\n       }\n     } else {\n       ClearTypeInfo();\n       return;\n     }\n   }\n \n   const auto infer_type = props_->fwd_type_fn(input_types);\n   const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n   if (infer_typedef.type_id() != TFT_UNSET) {\n     MaybeCopyOnWrite();\n     *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n   }\n }\n \n", "target": "// fix_start\n        if (ix >= node_t.args_size()) {\n          LOG(WARNING) << name() << \" has bad type information: input \" << i\n                       << \" should have an output \" << ix\n                       << \" but instead only has \" << node_t.args_size()\n                       << \" outputs: \" << node_t.DebugString()\n                       << \"\\nThis indicates either \"\n                          \"a bug in op registration or a corrupted graph.\";\n          ClearTypeInfo();\n          return;\n        }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "project": "tensorflow", "idx": 195029}
{"source": " mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n {\n// bug_start\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n// bug_end\n   mrb_int n;\n// bug_start\n  mrb_value val;\n// bug_end\n \n   if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n     return mrb_ary_shift(mrb, self);\n// bug_start\n  };\n// bug_end\n   ary_modify_check(mrb, a);\n   if (len == 0 || n == 0) return mrb_ary_new(mrb);\n   if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n   if (n > len) n = len;\n   val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n   if (ARY_SHARED_P(a)) {\n   L_SHIFT:\n     a->as.heap.ptr+=n;\n     a->as.heap.len-=n;\n     return val;\n   }\n   if (len > ARY_SHIFT_SHARED_MIN) {\n     ary_make_shared(mrb, a);\n     goto L_SHIFT;\n   }\n   else if (len == n) {\n     ARY_SET_LEN(a, 0);\n   }\n   else {\n     mrb_value *ptr = ARY_PTR(a);\n     mrb_int size = len-n;\n \n     while (size--) {\n       *ptr = *(ptr+n);\n       ++ptr;\n     }\n     ARY_SET_LEN(a, len-n);\n   }\n   return val;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n  }\n\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_value val;\n\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "project": "mruby", "idx": 195038}
{"source": "   void operator()(OpKernelContext* ctx, const Tensor& input,\n                   const Tensor& filter, int row_stride, int col_stride,\n                   int row_dilation, int col_dilation, const Padding& padding,\n                   const std::vector<int64_t>& explicit_paddings, Tensor* output,\n                   TensorFormat data_format) {\n     DCHECK(data_format == FORMAT_NHWC)\n         << \"Grouped conv implementation only \"\n            \"supports NHWC tensor format for now.\";\n \n     const int64_t in_depth = input.dim_size(3);\n     const int64_t patch_depth = filter.dim_size(2);\n     const int64_t num_groups = in_depth / patch_depth;\n \n     std::array<int64_t, 5> shuffle({3, 0, 1, 2, 4});\n \n     auto pre_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n       return {tensor.dim_size(0), tensor.dim_size(1), tensor.dim_size(2),\n               num_groups, tensor.dim_size(3) / num_groups};\n     };\n \n     auto post_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n       return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n               tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n     };\n \n     auto& device = ctx->eigen_device<CPUDevice>();\n \n     absl::BlockingCounter shuffles_completed(2);\n     auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n \n// bug_start\n    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));\n// bug_end\n     input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n         input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n \n// bug_start\n    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));\n// bug_end\n     filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n         filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n \n     shuffles_completed.Wait();\n \n// bug_start\n    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));\n// bug_end\n \n     for (int64_t i = 0; i < num_groups; ++i) {\n \n \n       auto input_slice = input_shuffled.tensor<T, 5>().template chip<0>(i);\n       auto filter_slice = filter_shuffled.tensor<T, 5>().template chip<0>(i);\n       auto output_slice = output_shuffled.tensor<T, 5>().template chip<0>(i);\n \n       if (padding == EXPLICIT) {\n         functor::SpatialConvolution<CPUDevice, T>()(\n             ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n             filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n             static_cast<int>(explicit_paddings[2]),\n             static_cast<int>(explicit_paddings[3]),\n             static_cast<int>(explicit_paddings[4]),\n             static_cast<int>(explicit_paddings[5]));\n       } else {\n         functor::SpatialConvolution<CPUDevice, T>()(\n             ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n             filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n             BrainPadding2EigenPadding(padding));\n       }\n     }\n \n     std::array<int64_t, 5> rev_shuffle({1, 2, 3, 0, 4});\n     output->shaped<T, 5>(pre_shuffle(*output)).device(device) =\n         output_shuffled.tensor<T, 5>().shuffle(rev_shuffle);\n   }\n \n", "target": "// fix_start\n    Tensor input_shuffled;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(input.dtype(), TensorShape(post_shuffle(input)),\n                                &input_shuffled));\n// fix_end\n// fix_start\n    Tensor filter_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(filter.dtype(),\n                                           TensorShape(post_shuffle(filter)),\n                                           &filter_shuffled));\n// fix_end\n// fix_start\n    Tensor output_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(output->dtype(),\n                                           TensorShape(post_shuffle(*output)),\n                                           &output_shuffled));\n// fix_end\n", "cwe": "CWE-354", "cwe_name": "Improper Validation of Integrity Check Value", "cve": "CVE-2021-41206", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195039}
{"source": " Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                 const XlaPlatformInfo& platform_info,\n                                 XlaCompilationCache** cache) {\n   if (platform_info.xla_device_metadata()) {\n     *cache = new XlaCompilationCache(\n         platform_info.xla_device_metadata()->client(),\n         platform_info.xla_device_metadata()->jit_device_type());\n     return Status::OK();\n   }\n \n   auto platform =\n       se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n   if (!platform.ok()) {\n     return platform.status();\n   }\n \n   StatusOr<xla::Compiler*> compiler_for_platform =\n       xla::Compiler::GetForPlatform(platform.ValueOrDie());\n   if (!compiler_for_platform.ok()) {\n     const Status& status = compiler_for_platform.status();\n     if (status.code() == error::NOT_FOUND) {\n       return errors::Unimplemented(\"Could not find compiler for platform \",\n                                    platform.ValueOrDie()->Name(), \": \",\n                                    status.ToString());\n     }\n   }\n \n   xla::LocalClientOptions client_options;\n   client_options.set_platform(platform.ValueOrDie());\n   client_options.set_intra_op_parallelism_threads(\n       device->tensorflow_cpu_worker_threads()->num_threads);\n \n// bug_start\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n// bug_end\n \n   auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n   if (!client.ok()) {\n     return client.status();\n   }\n   const XlaOpRegistry::DeviceRegistration* registration;\n   if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                            &registration)) {\n     return errors::InvalidArgument(\"No JIT device registered for \",\n                                    platform_info.device_type().type());\n   }\n   *cache = new XlaCompilationCache(\n       client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  if (flr->config_proto()) {\n    string allowed_gpus =\n        flr->config_proto()->gpu_options().visible_device_list();\n    TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                        ParseVisibleDeviceList(allowed_gpus));\n    client_options.set_allowed_devices(gpu_ids);\n  }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-23595", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When building an XLA compilation cache, if default settings are used, TensorFlow triggers a null pointer dereference. In the default scenario, all devices are allowed, so `flr->config_proto` is `nullptr`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195040}
{"source": "   void Compute(OpKernelContext* context) override {\n// bug_start\n    const Tensor& indices = context->input(0);\n// bug_end\n     const Tensor& values = context->input(1);\n// bug_start\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n// bug_end\n     bool use_weights = weights.NumElements() > 0;\n// bug_start\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n// bug_end\n \n     if (use_weights) {\n       OP_REQUIRES(\n           context, weights.shape() == values.shape(),\n           errors::InvalidArgument(\n               \"Weights and values must have the same shape. Weight shape: \",\n               weights.shape().DebugString(),\n               \"; values shape: \", values.shape().DebugString()));\n     }\n \n// bug_start\n    OP_REQUIRES(context, shape.NumElements() != 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n\n    bool is_1d = shape.NumElements() == 1;\n    auto shape_vector = shape.flat<int64_t>();\n    int num_batches = is_1d ? 1 : shape_vector(0);\n// bug_end\n     int num_values = values.NumElements();\n \n// bug_start\n    for (int b = 0; b < shape_vector.size(); b++) {\n      OP_REQUIRES(context, shape_vector(b) >= 0,\n                  errors::InvalidArgument(\n                      \"Elements in dense_shape must be >= 0. Instead got:\",\n                      shape.DebugString()));\n    }\n\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n// bug_end\n                 errors::InvalidArgument(\n// bug_start\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", num_values,\n                    \" values, indices shape: \", indices.shape().DebugString()));\n\n    const auto indices_values = indices.matrix<int64_t>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n// bug_end\n \n     auto per_batch_counts = BatchedMap<W>(num_batches);\n// bug_start\n\n// bug_end\n     T max_value = 0;\n// bug_start\n\n    OP_REQUIRES(context, num_values <= indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"The first dimension of indices must be equal to or \"\n                    \"greather than number of values. ( \",\n                    indices.shape().dim_size(0), \" vs. \", num_values, \" )\"));\n    OP_REQUIRES(context, indices.shape().dim_size(1) > 0,\n                errors::InvalidArgument(\"The second dimension of indices must \"\n                                        \"be greater than 0. Received: \",\n                                        indices.shape().dim_size(1)));\n// bug_end\n \n     for (int idx = 0; idx < num_values; ++idx) {\n// bug_start\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      if (batch >= num_batches) {\n        OP_REQUIRES(context, batch < num_batches,\n                    errors::InvalidArgument(\n                        \"Indices value along the first dimension must be \",\n                        \"lower than the first index of the shape.\", \"Got \",\n                        batch, \" as batch and \", num_batches,\n                        \" as the first dimension of the shape.\"));\n// bug_end\n       }\n       const auto& value = values_values(idx);\n       if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n         if (binary_output_) {\n// bug_start\n          per_batch_counts[batch][value] = 1;\n// bug_end\n         } else if (use_weights) {\n// bug_start\n          per_batch_counts[batch][value] += weight_values(idx);\n// bug_end\n         } else {\n// bug_start\n          per_batch_counts[batch][value]++;\n// bug_end\n         }\n         if (value > max_value) {\n           max_value = value;\n         }\n       }\n     }\n \n     int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n     OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                             is_1d, context));\n   }\n \n", "target": "// fix_start\n    const Tensor& splits = context->input(0);\n// fix_end\n// fix_start\n    const Tensor& weights = context->input(2);\n// fix_end\n// fix_start\n    bool is_1d = false;\n// fix_end\n// fix_start\n    const auto splits_values = splits.flat<int64_t>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int num_batches = splits.NumElements() - 1;\n// fix_end\n// fix_start\n    OP_REQUIRES(\n        context, num_batches > 0,\n        errors::InvalidArgument(\n            \"Must provide at least 2 elements for the splits argument\"));\n    OP_REQUIRES(context, splits_values(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits_values(0)));\n    OP_REQUIRES(context, splits_values(num_batches) == num_values,\n// fix_end\n// fix_start\n                    \"Splits must end with the number of values, got \",\n                    splits_values(num_batches), \" instead of \", num_values));\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    int batch_idx = 0;\n// fix_end\n// fix_start\n      while (idx >= splits_values(batch_idx)) {\n        batch_idx++;\n// fix_end\n// fix_start\n          per_batch_counts[batch_idx - 1][value] = 1;\n// fix_end\n// fix_start\n          per_batch_counts[batch_idx - 1][value] += weight_values(idx);\n// fix_end\n// fix_start\n          per_batch_counts[batch_idx - 1][value]++;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-21740", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `SparseCountSparseOutput` is vulnerable to a heap overflow. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195055}
{"source": " inline void BiasAndClamp(float clamp_min, float clamp_max, int bias_size,\n                          const float* bias_data, int array_size,\n                          float* array_data) {\n// bug_start\n// bug_end\n   TFLITE_DCHECK_EQ((array_size % bias_size), 0);\n #ifdef USE_NEON\n   float* array_ptr = array_data;\n   float* array_end_ptr = array_ptr + array_size;\n   const auto clamp_min_vec = vdupq_n_f32(clamp_min);\n   const auto clamp_max_vec = vdupq_n_f32(clamp_max);\n   for (; array_ptr != array_end_ptr; array_ptr += bias_size) {\n     int i = 0;\n     for (; i <= bias_size - 16; i += 16) {\n       auto b0 = vld1q_f32(bias_data + i);\n       auto b1 = vld1q_f32(bias_data + i + 4);\n       auto b2 = vld1q_f32(bias_data + i + 8);\n       auto b3 = vld1q_f32(bias_data + i + 12);\n       auto a0 = vld1q_f32(array_ptr + i);\n       auto a1 = vld1q_f32(array_ptr + i + 4);\n       auto a2 = vld1q_f32(array_ptr + i + 8);\n       auto a3 = vld1q_f32(array_ptr + i + 12);\n       auto x0 = vaddq_f32(a0, b0);\n       auto x1 = vaddq_f32(a1, b1);\n       auto x2 = vaddq_f32(a2, b2);\n       auto x3 = vaddq_f32(a3, b3);\n       x0 = vmaxq_f32(clamp_min_vec, x0);\n       x1 = vmaxq_f32(clamp_min_vec, x1);\n       x2 = vmaxq_f32(clamp_min_vec, x2);\n       x3 = vmaxq_f32(clamp_min_vec, x3);\n       x0 = vminq_f32(clamp_max_vec, x0);\n       x1 = vminq_f32(clamp_max_vec, x1);\n       x2 = vminq_f32(clamp_max_vec, x2);\n       x3 = vminq_f32(clamp_max_vec, x3);\n       vst1q_f32(array_ptr + i, x0);\n       vst1q_f32(array_ptr + i + 4, x1);\n       vst1q_f32(array_ptr + i + 8, x2);\n       vst1q_f32(array_ptr + i + 12, x3);\n     }\n     for (; i <= bias_size - 4; i += 4) {\n       auto b = vld1q_f32(bias_data + i);\n       auto a = vld1q_f32(array_ptr + i);\n       auto x = vaddq_f32(a, b);\n       x = vmaxq_f32(clamp_min_vec, x);\n       x = vminq_f32(clamp_max_vec, x);\n       vst1q_f32(array_ptr + i, x);\n     }\n     for (; i < bias_size; i++) {\n       array_ptr[i] = ActivationFunctionWithMinMax(array_ptr[i] + bias_data[i],\n                                                   clamp_min, clamp_max);\n     }\n   }\n #else\n   for (int array_offset = 0; array_offset < array_size;\n        array_offset += bias_size) {\n     for (int i = 0; i < bias_size; i++) {\n       array_data[array_offset + i] = ActivationFunctionWithMinMax(\n           array_data[array_offset + i] + bias_data[i], clamp_min, clamp_max);\n     }\n   }\n #endif\n }\n \n", "target": "// fix_start\n  if (bias_size == 0) return;\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195056}
{"source": " bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n   if (!IsIdentity(node) && !IsIdentityN(node)) {\n     return true;\n   }\n \n   if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n     return false;\n   }\n   if (!fetch_nodes_known_) {\n     return false;\n   }\n \n   if (node.input_size() < 1) {\n     return false;\n   }\n \n   const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n// bug_start\n  CHECK(input != nullptr) << \"node = \" << node.name()\n                          << \" input = \" << node.input(0);\n// bug_end\n   if (IsVariable(*input) || IsRecv(*input)) {\n     return false;\n   }\n   for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n     if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n       return false;\n     }\n     if (IsSwitch(*input)) {\n       for (const string& consumer_input : consumer->input()) {\n         if (consumer_input == AsControlDependency(node.name())) {\n           return false;\n         }\n       }\n     }\n   }\n   return true;\n }\n \n", "target": "// fix_start\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-23579", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `SafeToRemoveIdentity` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195059}
{"source": " GF_Err mpgviddmx_process(GF_Filter *filter)\n {\n \tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n \tGF_FilterPacket *pck, *dst_pck;\n \tu64 byte_offset;\n \ts64 vosh_start = -1;\n \ts64 vosh_end = -1;\n \tGF_Err e;\n \tchar *data;\n \tu8 *start;\n \tu32 pck_size;\n \ts32 remain;\n \n \tif (!ctx->duration.num)\n \t\tmpgviddmx_check_dur(filter, ctx);\n \n \tpck = gf_filter_pid_get_packet(ctx->ipid);\n \tif (!pck) {\n \t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n \t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n \t\t\tif (ctx->opid)\n \t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n \t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n \t\t\tctx->src_pck = NULL;\n \t\t\treturn GF_EOS;\n \t\t}\n \t\treturn GF_OK;\n \t}\n \n \tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n \tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n \n \tstart = data;\n \tremain = pck_size;\n \n \tif (!ctx->resume_from && ctx->timescale) {\n \t\tu64 ts = gf_filter_pck_get_cts(pck);\n \t\tif (ts != GF_FILTER_NO_TS) {\n \t\t\tif (!ctx->cts || !ctx->recompute_cts)\n \t\t\t\tctx->cts = ts;\n \t\t}\n \t\tts = gf_filter_pck_get_dts(pck);\n \t\tif (ts != GF_FILTER_NO_TS) {\n \t\t\tif (!ctx->dts || !ctx->recompute_cts)\n \t\t\t\tctx->dts = ts;\n \n \t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n \t\t\telse if (ctx->prev_dts != ts) {\n \t\t\t\tu64 diff = ts;\n \t\t\t\tdiff -= ctx->prev_dts;\n \t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n \t\t\t\telse if (ctx->cur_fps.den > diff)\n \t\t\t\t\tctx->cur_fps.den = (u32) diff;\n \t\t\t}\n \t\t}\n \t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n \t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n \t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n \t\tctx->src_pck = pck;\n \t\tgf_filter_pck_ref_props(&ctx->src_pck);\n \t}\n \n \tif (!ctx->resume_from && ctx->hdr_store_size) {\n \t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n \t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n \t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n \t\t}\n \t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n \t\tif (byte_offset != GF_FILTER_NO_BO) {\n \t\t\tif (byte_offset >= ctx->hdr_store_size)\n \t\t\t\tbyte_offset -= ctx->hdr_store_size;\n \t\t\telse\n \t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n \t\t}\n \t\tctx->hdr_store_size += pck_size;\n \t\tstart = data = ctx->hdr_store;\n \t\tremain = pck_size = ctx->hdr_store_size;\n \t}\n \n \tif (ctx->resume_from) {\n \t\tif (gf_filter_pid_would_block(ctx->opid))\n \t\t\treturn GF_OK;\n \n \t\tif (ctx->hdr_store_size) {\n \t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n \t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n \t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n \t\t} else {\n \t\t\tassert(remain >= (s32) ctx->resume_from);\n \t\t\tstart += ctx->resume_from;\n \t\t\tremain -= ctx->resume_from;\n \t\t}\n \t\tctx->resume_from = 0;\n \t}\n \n \tif (!ctx->bs) {\n \t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n \t} else {\n \t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n \t}\n \tif (!ctx->vparser) {\n \t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n \t}\n \n \n \twhile (remain) {\n \t\tBool full_frame;\n \t\tu8 *pck_data;\n \t\ts32 current;\n \t\tu8 sc_type, forced_sc_type=0;\n \t\tBool sc_type_forced = GF_FALSE;\n \t\tBool skip_pck = GF_FALSE;\n \t\tu8 ftype;\n \t\tu32 tinc;\n \t\tu64 size=0;\n \t\tu64 fstart;\n \t\tBool is_coded;\n \t\tu32 bytes_from_store = 0;\n \t\tu32 hdr_offset = 0;\n \t\tBool copy_last_bytes = GF_FALSE;\n \n \t\tif (remain<5) {\n \t\t\tmemcpy(ctx->hdr_store, start, remain);\n \t\t\tctx->bytes_in_header = remain;\n \t\t\tbreak;\n \t\t}\n \t\tcurrent = -1;\n \n \t\tif (ctx->bytes_in_header) {\n \n \t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n \t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n \n \t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n \t\t\t\tif (ctx->opid) {\n \t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n \t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n \n \t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n \t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n \t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n \t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n \t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n \n \t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n \t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n \t\t\t\t\t}\n \n \t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n \t\t\t\t}\n \n \t\t\t\tif (current<0) current = -1;\n \t\t\t\telse current -= ctx->bytes_in_header;\n \t\t\t\tctx->bytes_in_header = 0;\n \t\t\t} else {\n \t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n \t\t\t\tbytes_from_store = ctx->bytes_in_header;\n \t\t\t\tctx->bytes_in_header = 0;\n \t\t\t\tif (!hdr_offset) {\n \t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n \t\t\t\t} else {\n \t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n \t\t\t\t}\n \t\t\t\tsc_type_forced = GF_TRUE;\n \t\t\t}\n \t\t}\n \t\tif (current == -1) {\n \t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n \t\t\tif (current<0) {\n \t\t\t\tu8 b3, b2, b1;\n \t\t\t\tif (! ctx->frame_started) {\n \t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tsize = remain;\n \t\t\t\tb3 = start[remain-3];\n \t\t\t\tb2 = start[remain-2];\n \t\t\t\tb1 = start[remain-1];\n \t\t\t\tif (!b1 || !b2 || !b3) {\n \t\t\t\t\tcopy_last_bytes = GF_TRUE;\n \t\t\t\t\tassert(size >= 3);\n \t\t\t\t\tsize -= 3;\n \t\t\t\t\tctx->bytes_in_header = 3;\n \t\t\t\t}\n \n \t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n \t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n \n \t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n \t\t\t\tmemcpy(pck_data, start, (size_t) size);\n \t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n \t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n \t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n \n \t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n \t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n \t\t\t\t}\n \n \t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n \t\t\t\tif (copy_last_bytes) {\n \t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tassert(current>=0);\n \n \t\tif ((vosh_start>=0) && current) {\n \t\t\tassert(remain>=current);\n \t\t\tstart += current;\n \t\t\tremain -= current;\n \t\t\tcurrent = 0;\n \t\t}\n \t\tif (!ctx->opid && current) {\n \t\t\tassert(remain>=current);\n \t\t\tstart += current;\n \t\t\tremain -= current;\n \t\t\tcurrent = 0;\n \t\t}\n \t\tif (current>0) {\n \t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n \t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n \n \t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n \t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n \t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n \t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n \t\t\tif (bytes_from_store) {\n \t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n \t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n \t\t\t\t}\n \t\t\t\tassert(bytes_from_store>=(u32) current);\n \t\t\t\tbytes_from_store -= current;\n \t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n \t\t\t} else {\n \t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n \t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n \t\t\t\t}\n \t\t\t\tmemcpy(pck_data, start, current);\n \t\t\t\tassert(remain>=current);\n \t\t\t\tstart += current;\n \t\t\t\tremain -= current;\n \t\t\t\tcurrent = 0;\n \t\t\t}\n \t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n \n \t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n \t\t}\n \n// bug_start\n// bug_end\n \n \t\tif (sc_type_forced) {\n \t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n \t\t\tsc_type = forced_sc_type;\n \t\t} else {\n \t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n \t\t\tgf_bs_read_int(ctx->bs, 24);\n \t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n \t\t}\n \n \t\tif (ctx->is_mpg12) {\n \t\t\tswitch (sc_type) {\n \t\t\tcase M2V_SEQ_START_CODE:\n \t\t\tcase M2V_EXT_START_CODE:\n \t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n \t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n \t\t\t\tif (e==GF_EOS) {\n \t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n \t\t\t\t\tif (data == ctx->hdr_store) {\n \t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n \t\t\t\t\t\tctx->hdr_store_size = remain;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n \t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n \t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n \t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n \t\t\t\t\t}\n \t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n \t\t\t\t\treturn GF_OK;\n \t\t\t\t} else if (e != GF_OK) {\n \t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n \t\t\t\t} else {\n \t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase M2V_PIC_START_CODE:\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t} else {\n \t\t\tu8 PL;\n \t\t\tswitch (sc_type) {\n \t\t\tcase M4V_VOS_START_CODE:\n \t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n \t\t\t\tvosh_start = start - (u8 *)data;\n \t\t\t\tskip_pck = GF_TRUE;\n \t\t\t\tassert(remain>=5);\n \t\t\t\tstart += 5;\n \t\t\t\tremain -= 5;\n \t\t\t\tbreak;\n \t\t\tcase M4V_VOL_START_CODE:\n \t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n \t\t\t\tPL = ctx->dsi.VideoPL;\n \t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n \t\t\t\tctx->dsi.VideoPL = PL;\n \t\t\t\tif (e==GF_EOS) {\n \t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n \t\t\t\t\tif (data == ctx->hdr_store) {\n \t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n \t\t\t\t\t\tctx->hdr_store_size = remain;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n \t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n \t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n \t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n \t\t\t\t\t}\n \t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n \t\t\t\t\treturn GF_OK;\n \t\t\t\t} else if (e != GF_OK) {\n \t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n \t\t\t\t} else {\n \t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n \t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n \t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n \t\t\t\t\tvosh_end -= vosh_start;\n \t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n \t\t\t\t\tskip_pck = GF_TRUE;\n \t\t\t\t\tassert(remain>=(s32) obj_size);\n \t\t\t\t\tstart += obj_size;\n \t\t\t\t\tremain -= obj_size;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase M4V_VOP_START_CODE:\n \t\t\tcase M4V_GOV_START_CODE:\n \t\t\t\tbreak;\n \n \t\t\tcase M4V_VO_START_CODE:\n \t\t\tcase M4V_VISOBJ_START_CODE:\n \t\t\tdefault:\n \t\t\t\tif (vosh_start>=0) {\n \t\t\t\t\tskip_pck = GF_TRUE;\n \t\t\t\t\tassert(remain>=4);\n \t\t\t\t\tstart += 4;\n \t\t\t\t\tremain -= 4;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (skip_pck) {\n \t\t\tcontinue;\n \t\t}\n \n \t\tif (!ctx->opid) {\n \t\t\tassert(remain>=4);\n \t\t\tstart += 4;\n \t\t\tremain -= 4;\n \t\t\tcontinue;\n \t\t}\n \n \t\tif (!ctx->is_playing) {\n \t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n \t\t\treturn GF_OK;\n \t\t}\n \t\tctx->hdr_store_size = 0;\n \n \t\tif (ctx->in_seek) {\n \t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n \t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n \t\t\t\tctx->in_seek = GF_FALSE;\n \t\t\t}\n \t\t}\n \t\tif (remain<5)\n \t\t\tcontinue;\n \n \t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n \t\tsize = 0;\n \t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n \n \t\tif (bytes_from_store) {\n \t\t\tsize += bytes_from_store + hdr_offset;\n \t\t}\n \n \t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n \t\t\tu8 b3 = start[remain-3];\n \t\t\tu8 b2 = start[remain-2];\n \t\t\tu8 b1 = start[remain-1];\n \n \t\t\tif (!b1 || !b2 || !b3) {\n \t\t\t\tcopy_last_bytes = GF_TRUE;\n \t\t\t\tassert(size >= 3);\n \t\t\t\tsize -= 3;\n \t\t\t\tctx->bytes_in_header = 3;\n \t\t\t}\n \t\t\tfull_frame = GF_FALSE;\n \t\t} else {\n \t\t\tfull_frame = GF_TRUE;\n \t\t}\n \n \t\tif (!is_coded) {\n \t\t\tif (ctx->forced_packed && ctx->b_frames) {\n \t\t\t\tctx->is_packed = GF_TRUE;\n \t\t\t\tassert(remain>=size);\n \t\t\t\tstart += size;\n \t\t\t\tremain -= (s32) size;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (ctx->vfr) {\n \t\t\t\tctx->is_vfr = GF_TRUE;\n \t\t\t\tmpgviddmx_update_time(ctx);\n \t\t\t\tassert(remain>=size);\n \t\t\t\tstart += size;\n \t\t\t\tremain -= (s32) size;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n \n \t\tif (ftype==2) {\n \t\t\tctx->b_frames++;\n \t\t\tctx->nb_b++;\n \t\t} else {\n \t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n \t\t\tctx->last_ref_cts = ctx->cts;\n \t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n \n \t\t\tctx->b_frames = 0;\n \t\t\tif (ftype)\n \t\t\t\tctx->nb_p++;\n \t\t\telse\n \t\t\t\tctx->nb_i++;\n \t\t}\n \t\tctx->nb_frames++;\n \n \t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n \t\tif (!dst_pck) return GF_OUT_OF_MEM;\n \n \t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n \t\tif (bytes_from_store) {\n \t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n \t\t\tassert(size >= bytes_from_store);\n \t\t\tsize -= bytes_from_store;\n \t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n \t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n \t\t\t}\n \t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n \t\t} else {\n \t\t\tmemcpy(pck_data, start, (size_t) size);\n \t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n \t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n \t\t\t}\n \t\t}\n \t\tassert(pck_data[0] == 0);\n \t\tassert(pck_data[1] == 0);\n \t\tassert(pck_data[2] == 0x01);\n \n \t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n \t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n \t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n \t\tif (ctx->input_is_au_start) {\n \t\t\tctx->input_is_au_start = GF_FALSE;\n \t\t} else {\n \t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n \t\t}\n \t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n \t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n \t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n \t\tctx->frame_started = GF_TRUE;\n \n \t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n \n \t\tmpgviddmx_update_time(ctx);\n \n \t\tif (!full_frame) {\n \t\t\tif (copy_last_bytes) {\n \t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tassert(remain>=size);\n \t\tstart += size;\n \t\tremain -= (s32) size;\n \t}\n \tgf_filter_pid_drop_packet(ctx->ipid);\n \n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-40575", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the mpgviddmx_process function in reframe_mpgvid.c, which allows attackers to cause a denial of service. This vulnerability is possibly due to an incomplete fix for CVE-2021-40566.", "project": "gpac", "idx": 195063}
{"source": " static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n {\n \ts32 pps_id;\n \n \tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n \tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n \tif (si->slice_type > 9) return -1;\n \n \tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n// bug_start\n\tif (pps_id > 255)\n// bug_end\n \t\treturn -1;\n \tsi->pps = &avc->pps[pps_id];\n \tsi->pps->id = pps_id;\n \tif (!si->pps->slice_group_count)\n \t\treturn -2;\n \tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n \tif (!si->sps->log2_max_frame_num)\n \t\treturn -2;\n \n \tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n \n \tsi->field_pic_flag = 0;\n \tif (si->sps->frame_mbs_only_flag) {\n \t}\n \telse {\n \t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n \t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n \t}\n \tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)\n \t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n \n \tif (si->sps->poc_type == 0) {\n \t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n \t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n \t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"delta_poc_bottom\");\n \t\t}\n \t}\n \telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n \t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n \t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n \t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n \t}\n \tif (si->pps->redundant_pic_cnt_present) {\n \t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif ((pps_id<0) || (pps_id > 255))\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-40568", "cve_desc": "A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "project": "gpac", "idx": 195069}
{"source": "   void DecodePngV2(OpKernelContext* context, StringPiece input) {\n     int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n     png::DecodeContext decode;\n     OP_REQUIRES(\n         context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n         errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n \n     const int width = static_cast<int>(decode.width);\n     const int height = static_cast<int>(decode.height);\n     const int64_t total_size =\n         static_cast<int64_t>(width) * static_cast<int64_t>(height);\n     if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n         width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n         height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n// bug_start\n      png::CommonFreeDecode(&decode);\n// bug_end\n       OP_REQUIRES(context, false,\n                   errors::InvalidArgument(\"PNG size too large for int: \",\n                                           decode.width, \" by \", decode.height));\n     }\n \n     Tensor* output = nullptr;\n     Status status;\n     if (op_type_ == \"DecodeGif\") {\n       status = context->allocate_output(\n           0, TensorShape({1, height, width, decode.channels}), &output);\n     } else {\n       status = context->allocate_output(\n           0, TensorShape({height, width, decode.channels}), &output);\n     }\n \n     if (op_type_ == \"DecodeBmp\") {\n       OP_REQUIRES(context, false,\n                   errors::InvalidArgument(\n                       \"Trying to decode PNG format using DecodeBmp op. Use \"\n                       \"`decode_png` or `decode_image` instead.\"));\n     } else if (op_type_ == \"DecodeAndCropJpeg\") {\n       OP_REQUIRES(context, false,\n                   errors::InvalidArgument(\n                       \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                       \"detected PNG.\"));\n     }\n \n     if (!status.ok()) png::CommonFreeDecode(&decode);\n     OP_REQUIRES_OK(context, status);\n \n     if (data_type_ == DataType::DT_UINT8) {\n       OP_REQUIRES(\n           context,\n           png::CommonFinishDecode(\n               reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n               decode.channels * width * sizeof(uint8), &decode),\n           errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n     } else if (data_type_ == DataType::DT_UINT16) {\n       OP_REQUIRES(\n           context,\n           png::CommonFinishDecode(\n               reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n               decode.channels * width * sizeof(uint16), &decode),\n           errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n     } else if (data_type_ == DataType::DT_FLOAT) {\n       std::unique_ptr<uint16[]> buffer(\n           new uint16[height * width * decode.channels]);\n       OP_REQUIRES(\n           context,\n           png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                   decode.channels * width * sizeof(uint16),\n                                   &decode),\n           errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n \n       const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n       TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                   decode.channels);\n       float scale = 1. / std::numeric_limits<uint16>::max();\n       output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n     }\n   }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-23584", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a use after free behavior when decoding PNG images. After `png::CommonFreeDecode(&decode)` gets called, the values of `decode.width` and `decode.height` are in an unspecified state. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195073}
{"source": " GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n {\n #ifndef GPAC_DISABLE_AV_PARSERS\n \tAV1State state;\n \tu8 reserved;\n \tGF_AV1Config *cfg;\n \n \tif (!size) size = (u32) gf_bs_available(bs);\n \tif (!size) return NULL;\n \n \tcfg = gf_odf_av1_cfg_new();\n \tgf_av1_init_state(&state);\n \tstate.config = cfg;\n \n \tcfg->marker = gf_bs_read_int(bs, 1);\n \tcfg->version = gf_bs_read_int(bs, 7);\n \tcfg->seq_profile = gf_bs_read_int(bs, 3);\n \tcfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);\n \tcfg->seq_tier_0 = gf_bs_read_int(bs, 1);\n \tcfg->high_bitdepth = gf_bs_read_int(bs, 1);\n \tcfg->twelve_bit = gf_bs_read_int(bs, 1);\n \tcfg->monochrome = gf_bs_read_int(bs, 1);\n \tcfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);\n \tcfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);\n \tcfg->chroma_sample_position = gf_bs_read_int(bs, 2);\n \n \treserved = gf_bs_read_int(bs, 3);\n \tif (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {\n \t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));\n \t\tgf_odf_av1_cfg_del(cfg);\n \t\treturn NULL;\n \t}\n \tcfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);\n \tif (cfg->initial_presentation_delay_present) {\n \t\tcfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);\n \t} else {\n \t\tgf_bs_read_int(bs, 4);\n \t\tcfg->initial_presentation_delay_minus_one = 0;\n \t}\n \tsize -= 4;\n \n \twhile (size) {\n \t\tu64 pos, obu_size;\n \t\tObuType obu_type;\n \t\tGF_AV1_OBUArrayEntry *a;\n \n \t\tpos = gf_bs_get_position(bs);\n \t\tobu_size = 0;\n \t\tif (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));\n \t\t\tbreak;\n \t\t}\n \t\tassert(obu_size == gf_bs_get_position(bs) - pos);\n \t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));\n \n \t\tif (!av1_is_obu_header(obu_type)) {\n \t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));\n \t\t}\n \t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n \t\tif (!a) break;\n \t\ta->obu = gf_malloc((size_t)obu_size);\n \t\tif (!a->obu) {\n \t\t\tgf_free(a);\n \t\t\tbreak;\n \t\t}\n \t\tgf_bs_seek(bs, pos);\n \t\tgf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);\n \t\ta->obu_length = obu_size;\n \t\ta->obu_type = obu_type;\n \t\tgf_list_add(cfg->obu_array, a);\n \n \t\tif (size<obu_size) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));\n \t\t\tbreak;\n \t\t}\n \t\tsize -= (u32) obu_size;\n \t}\n \tgf_av1_reset_state(& state, GF_TRUE);\n// bug_start\n// bug_end\n \treturn cfg;\n #else\n \treturn NULL;\n #endif\n }\n \n", "target": "// fix_start\n\tgf_bs_align(bs);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "project": "gpac", "idx": 195074}
{"source": " void recalc_intercepts(struct vcpu_svm *svm)\n {\n \tstruct vmcb_control_area *c, *h, *g;\n \tunsigned int i;\n \n \tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n \n \tif (!is_guest_mode(&svm->vcpu))\n \t\treturn;\n \n \tc = &svm->vmcb->control;\n \th = &svm->vmcb01.ptr->control;\n \tg = &svm->nested.ctl;\n \n \tfor (i = 0; i < MAX_INTERCEPT; i++)\n \t\tc->intercepts[i] = h->intercepts[i];\n \n \tif (g->int_ctl & V_INTR_MASKING_MASK) {\n \t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n \t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n \n \t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n \t}\n \n \tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n \n \tfor (i = 0; i < MAX_INTERCEPT; i++)\n \t\tc->intercepts[i] |= g->intercepts[i];\n \n \tif (!intercept_smi)\n \t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "cve": "CVE-2021-3656", "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.", "project": "linux", "idx": 195082}
{"source": " bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n   CHECK_NOTNULL(a);\n   TensorBuffer* p = nullptr;\n   if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n   if (proto.dtype() == DT_INVALID) return false;\n   TensorShape shape(proto.tensor_shape());\n   const int64_t N = shape.num_elements();\n   if (N > 0 && proto.dtype()) {\n     bool dtype_error = false;\n     if (!proto.tensor_content().empty()) {\n       const auto& content = proto.tensor_content();\n       CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                          dtype_error = true, dtype_error = true);\n     } else {\n       CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                          dtype_error = true, dtype_error = true);\n     }\n     if (dtype_error || p == nullptr) return false;\n// bug_start\n// bug_end\n   }\n   shape_ = shape;\n   set_dtype(proto.dtype());\n   UnrefIfNonNull(buf_);\n   buf_ = p;\n   if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n     LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                       LogMemory::UNKNOWN_STEP_ID, *this);\n   }\n   return true;\n }\n \n", "target": "// fix_start\n  } else {\n    bool dtype_error = false;\n    CASES_WITH_DEFAULT(proto.dtype(), break, dtype_error = true,\n                       dtype_error = true);\n    if (dtype_error) return false;\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-23571", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When decoding a tensor from protobuf, a TensorFlow process can encounter cases where a `CHECK` assertion is invalidated based on user controlled arguments, if the tensors have an invalid `dtype` and 0 elements or an invalid shape. This allows attackers to cause denial of services in TensorFlow processes. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195083}
{"source": " llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                         ValueRange shapes, Location loc,\n                                         OpBuilder* builder) {\n   SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n   size_t maxRank = 0;\n   for (const auto &shape : llvm::enumerate(shapes)) {\n     auto found_shape = analysis.GetValueInfo(shape.value());\n     if (!found_shape) return {};\n     shapes_found.push_back(*found_shape);\n     maxRank = std::max(maxRank, found_shape->size());\n// bug_start\n// bug_end\n   }\n \n   SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n       maxRank);\n   SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n   for (const auto &shape : llvm::enumerate(shapes_found)) {\n     for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n       if (dim.value().isConstant(1)) continue;\n       auto index = maxRank - dim.index() - 1;\n       if (!joined_dimensions[index]) {\n         joined_dimensions[index] = &dim.value();\n         shape_and_rank_for_dim[index] =\n             std::make_pair(shapes[shape.index()], shape.value().size());\n         continue;\n       }\n       if (*joined_dimensions[index] != dim.value()) return {};\n     }\n   }\n   if (llvm::is_splat(shape_and_rank_for_dim) &&\n       shape_and_rank_for_dim[0].first) {\n     return shape_and_rank_for_dim[0].first;\n   }\n   SmallVector<Value> elements;\n   for (int i = 0; i != maxRank; ++i) {\n     if (!shape_and_rank_for_dim[i].first) {\n       auto one = builder->getIntegerAttr(\n           shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n       elements.push_back(builder->create<ConstantOp>(loc, one));\n       continue;\n     }\n     Value index = builder->create<ConstantIndexOp>(\n         loc, i - maxRank + shape_and_rank_for_dim[i].second);\n     elements.push_back(builder->create<tensor::ExtractOp>(\n         loc, shape_and_rank_for_dim[i].first, index));\n   }\n   return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n }\n \n", "target": "// fix_start\n  }\n  if (maxRank == 0) {\n    return Value(builder->create<tensor::FromElementsOp>(\n        loc, shapes[0].getType(), SmallVector<Value>()));\n// fix_end\n", "cwe": "CWE-754", "cwe_name": "Improper Check for Unusual or Exceptional Conditions", "cve": "CVE-2022-23593", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The `simplifyBroadcast` function in the MLIR-TFRT infrastructure in TensorFlow is vulnerable to a segfault (hence, denial of service), if called with scalar shapes. If all shapes are scalar, then `maxRank` is 0, so we build an empty `SmallVector`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "project": "tensorflow", "idx": 195091}
{"source": " Literal *hermes::evalUnaryOperator(\n     UnaryOperatorInst::OpKind kind,\n     IRBuilder &builder,\n     Literal *operand) {\n   switch (kind) {\n     case UnaryOperatorInst::OpKind::MinusKind:\n       switch (operand->getKind()) {\n         case ValueKind::LiteralNumberKind:\n           if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n             auto V = -literalNum->getValue();\n             return builder.getLiteralNumber(V);\n           }\n           break;\n         case ValueKind::LiteralUndefinedKind:\n           return builder.getLiteralNaN();\n         case ValueKind::LiteralBoolKind:\n           if (evalIsTrue(builder, operand)) {\n             return builder.getLiteralNumber(-1);\n           } else {\n             return builder.getLiteralNegativeZero();\n           }\n         case ValueKind::LiteralNullKind:\n           return builder.getLiteralNegativeZero();\n         default:\n           break;\n       }\n       break;\n     case UnaryOperatorInst::OpKind::TypeofKind:\n       switch (operand->getKind()) {\n         case ValueKind::GlobalObjectKind:\n         case ValueKind::LiteralNullKind:\n           return builder.getLiteralString(\"object\");\n         case ValueKind::LiteralUndefinedKind:\n           return builder.getLiteralString(\"undefined\");\n         case ValueKind::LiteralBoolKind:\n           return builder.getLiteralString(\"boolean\");\n         case ValueKind::LiteralNumberKind:\n           return builder.getLiteralString(\"number\");\n         case ValueKind::LiteralStringKind:\n           return builder.getLiteralString(\"string\");\n         default:\n// bug_start\n          llvm_unreachable(\"Invalid literal kind.\");\n// bug_end\n       }\n       break;\n \n     case UnaryOperatorInst::OpKind::BangKind:\n       if (evalIsTrue(builder, operand)) {\n         return builder.getLiteralBool(false);\n       }\n       if (evalIsFalse(builder, operand)) {\n         return builder.getLiteralBool(true);\n       }\n       break;\n \n     case UnaryOperatorInst::OpKind::VoidKind:\n       return builder.getLiteralUndefined();\n \n     default:\n       break;\n   }\n \n   return nullptr;\n }\n \n", "target": "// fix_start\n          break;\n// fix_end\n", "cwe": "CWE-843", "cwe_name": "Access of Resource Using Incompatible Type ('Type Confusion')", "cve": "CVE-2021-24045", "cve_desc": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "project": "hermes", "idx": 195092}
{"source": " int Socket::startSslClient(const std::string &certificate_path, String hostname)\n {\n     if (isssl) {\n         stopSsl();\n     }\n \n     ERR_clear_error();\n #if OPENSSL_VERSION_NUMBER < 0x10100000L\n     ctx = SSL_CTX_new(SSLv23_client_method());\n #else\n     ctx = SSL_CTX_new(TLS_client_method());\n #endif\n \n     if (ctx == NULL) {\n #ifdef NETDEBUG\n         std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n #endif\n         log_ssl_errors(\"Error ssl context is null for %s\", hostname.c_str());\n         return -1;\n     }\n \n     if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n             SSL_CTX_free(ctx);\n             ctx = NULL;\n         return -1;\n     }\n \n     ERR_clear_error();\n     if (certificate_path.length()) {\n         if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) {\n #ifdef NETDEBUG\n             std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n #endif\n             log_ssl_errors(\"couldnt load certificates from %s\", certificate_path.c_str());\n             SSL_CTX_free(ctx);\n             ctx = NULL;\n             return -2;\n         }\n     } else if (!SSL_CTX_set_default_verify_paths(ctx))\n     {\n #ifdef NETDEBUG\n         std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n #endif\n             log_ssl_errors(\"couldnt load default certificates for %s\", hostname.c_str());\n         SSL_CTX_free(ctx);\n         ctx = NULL;\n         return -2;\n     }\n \n     ERR_clear_error();\n     X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();\n     if (!x509_param) {\n         log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n             SSL_CTX_free(ctx);\n             ctx = NULL;\n         return -2;\n     }\n \n     ERR_clear_error();\n     if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {\n         log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n         X509_VERIFY_PARAM_free(x509_param);\n             SSL_CTX_free(ctx);\n             ctx = NULL;\n         return -2;\n     }\n \n     ERR_clear_error();\n     if (!SSL_CTX_set1_param(ctx, x509_param)) {\n         log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n         X509_VERIFY_PARAM_free(x509_param);\n             SSL_CTX_free(ctx);\n             ctx = NULL;\n         return -2;\n     }\n \n     X509_VERIFY_PARAM_free(x509_param);\n \n     ERR_clear_error();\n     ssl = SSL_new(ctx);\n     SSL_set_options(ssl, SSL_OP_ALL);\n     SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n     SSL_set_connect_state(ssl);\n \n     SSL_set_fd(ssl, this->getFD());\n     SSL_set_tlsext_host_name(ssl, hostname.c_str());\n// bug_start\n// bug_end\n \n     ERR_clear_error();\n     int rc = SSL_connect(ssl);\n     if (rc < 0) {\n         log_ssl_errors(\"ssl_connect failed to %s\", hostname.c_str());\n #ifdef NETDEBUG\n         std::cout << thread_id << \"ssl_connect failed with error \" << SSL_get_error(ssl, rc) << std::endl;\n #endif\n         SSL_free(ssl);\n         ssl = NULL;\n         SSL_CTX_free(ctx);\n         ctx = NULL;\n         return -3;\n     }\n \n     isssl = true;\n     issslserver = false;\n     return 0;\n }\n \n", "target": "// fix_start\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#else\n  X509_VERIFY_PARAM_set1_host(SSL_get0_param(ssl),hostname.c_str(),0);\n#endif\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "project": "e2guardian", "idx": 195095}
{"source": " int main(int argc, char **argv, char **envp)\n {\n \tint opt;\n \n \twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n \t\tswitch (opt) {\n \t\tcase 'b':\n \t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n \t\t\tbreak;\n \t\tcase 'h':\n \t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n \t\t\tbreak;\n \t\tcase 'k':\n \t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n \t\t\tbreak;\n \t\tcase 'p':\n \t\t\ttmate_settings->ssh_port = atoi(optarg);\n \t\t\tbreak;\n \t\tcase 'q':\n \t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n \t\t\tbreak;\n \t\tcase 'w':\n \t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n \t\t\tbreak;\n \t\tcase 'z':\n \t\t\ttmate_settings->websocket_port = atoi(optarg);\n \t\t\tbreak;\n \t\tcase 'x':\n \t\t\ttmate_settings->use_proxy_protocol = true;\n \t\t\tbreak;\n \t\tcase 'v':\n \t\t\ttmate_settings->log_level++;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tusage();\n \t\t\treturn 1;\n \t\t}\n \t}\n \n \tinit_logging(tmate_settings->log_level);\n \n \tsetup_locale();\n \n \tif (!tmate_settings->tmate_host)\n \t\ttmate_settings->tmate_host = get_full_hostname();\n \n \tcmdline = *argv;\n \tcmdline_end = *envp;\n \n \ttmate_preload_trace_lib();\n \ttmate_catch_sigsegv();\n \ttmate_init_rand();\n \n// bug_start\n\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||\n// bug_end\n \t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n \t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n \n// bug_start\n\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||\n// bug_end\n \t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n \t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n// bug_start\n// bug_end\n \n \ttmate_ssh_server_main(tmate_session,\n \t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif ((mkdir(TMATE_WORKDIR, 0700)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0700) < 0 && errno != EEXIST) ||\n// fix_end\n// fix_start\n\tif ((chmod(TMATE_WORKDIR, 0700)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0700) < 0) ||\n// fix_end\n// fix_start\n\n\tif (check_owned_directory_mode(TMATE_WORKDIR, 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/sessions\", 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/jail\", 0700))\n\t\ttmate_fatal(TMATE_WORKDIR \" and subdirectories has incorrect ownership/mode. \"\n\t\t\t    \"Try deleting \" TMATE_WORKDIR \" and try again\");\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2021-44512", "cve_desc": "World-writable permissions on the /tmp/tmate/sessions directory in tmate-ssh-server 2.3.0 allow a local attacker to compromise the integrity of session handling, or obtain the read-write session ID from a read-only session symlink in this directory.", "project": "tmate-ssh-server", "idx": 195220}
{"source": " void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,\n \t\t\t\t const void *pkt,\n \t\t\t\t pj_size_t size)\n {\n     const pjmedia_rtcp_xr_pkt\t      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;\n     const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;\n     const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;\n     const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;\n     const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;\n     const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*)\n \t\t\t\t\t\trtcp_xr->buf;\n     unsigned pkt_len, rb_len;\n \n     if (rtcp_xr->common.pt != RTCP_XR)\n \treturn;\n \n     pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);\n \n     if ((pkt_len + 1) > (size / 4))\n \treturn;\n \n     while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n     {\n \trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n \n \tif (rb_len) {\n \t    switch (rb_hdr->bt) {\n \t\tcase BT_RR_TIME:\n// bug_start\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n// bug_end\n \t\t    break;\n \t\tcase BT_DLRR:\n// bug_start\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n// bug_end\n \t\t    break;\n \t\tcase BT_STATS:\n// bug_start\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n// bug_end\n \t\t    break;\n \t\tcase BT_VOIP_METRICS:\n// bug_start\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n// bug_end\n \t\t    break;\n \t\tdefault:\n \t\t    break;\n \t    }\n \t}\n \trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n \t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n     }\n \n     if (rb_rr_time) {\n \tsess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) |\n \t\t       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);\n \n \tpj_get_timestamp(&sess->rx_lrr_time);\n \n \tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", sess->rx_lrr,\n \t       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/\n \t\t\t     sess->rtcp_session->ts_freq.u64)));\n     }\n \n     if (rb_dlrr) {\n \tpj_uint32_t lrr, now, dlrr;\n \tpj_uint64_t eedelay;\n \tpjmedia_rtcp_ntp_rec ntp;\n \n \tlrr = pj_ntohl(rb_dlrr->item.lrr);\n \n \tdlrr = pj_ntohl(rb_dlrr->item.dlrr);\n \n \tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n \tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n \n \teedelay = now - lrr - dlrr;\n \n \tif (eedelay < 4294) {\n \t    eedelay = (eedelay * 1000000) >> 16;\n \t} else {\n \t    eedelay = (eedelay * 1000) >> 16;\n \t    eedelay *= 1000;\n \t}\n \n \tTRACE_((sess->name, \"Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), \"\n \t\t\t   \"now=%p, rtt=%p\",\n \t\tlrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,\n \t\tnow, (pj_uint32_t)eedelay));\n \n \tif (now-dlrr >= lrr) {\n \t    unsigned rtt = (pj_uint32_t)eedelay;\n \n \t    if (eedelay <= 30 * 1000 * 1000UL) {\n \t\tif (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)\n \t\t{\n \t\t    unsigned orig_rtt = rtt;\n \t\t    rtt = (unsigned)sess->stat.rtt.mean*3;\n \t\t    PJ_LOG(5,(sess->name,\n \t\t\t      \"RTT value %d usec is normalized to %d usec\",\n \t\t\t      orig_rtt, rtt));\n \t\t}\n \n \t\tTRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n \t\tpj_math_stat_update(&sess->stat.rtt, rtt);\n \t    }\n \t} else {\n \t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n \t\t\t\t   \"lrr=%p, now=%p, dlrr=%p (%d:%03dms), \"\n \t\t\t\t   \"diff=%d\",\n \t\t\t\t   lrr, now, dlrr, dlrr/65536,\n \t\t\t\t   (dlrr%65536)*1000/65536,\n \t\t\t\t   dlrr-(now-lrr)));\n \t}\n     }\n \n     if (rb_stats) {\n \tpj_uint8_t flags = rb_stats->header.specific;\n \n \tpj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));\n \n \tsess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);\n \tsess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);\n \n \tsess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;\n \tsess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;\n \tsess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;\n \tsess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;\n \n \tif (sess->stat.tx.stat_sum.l) {\n \t    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);\n \t}\n \n \tif (sess->stat.tx.stat_sum.d) {\n \t    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);\n \t}\n \n \tif (sess->stat.tx.stat_sum.j) {\n \t    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);\n \t    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);\n \t    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);\n \t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter,\n \t\t\t\t    pj_ntohl(rb_stats->jitter_dev));\n \t}\n \n \tif (sess->stat.tx.stat_sum.t) {\n \t    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;\n \t    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;\n \t    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;\n \t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh,\n \t\t\t\t    pj_ntohl(rb_stats->toh_dev));\n \t}\n \n \tpj_gettimeofday(&sess->stat.tx.stat_sum.update);\n     }\n \n     if (rb_voip_mtc) {\n \tsess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;\n \tsess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;\n \tsess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;\n \tsess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;\n \tsess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);\n \tsess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);\n \tsess->stat.tx.voip_mtc.rnd_trip_delay =\n \t\t\t\t\tpj_ntohs(rb_voip_mtc->rnd_trip_delay);\n \tsess->stat.tx.voip_mtc.end_sys_delay =\n \t\t\t\t\tpj_ntohs(rb_voip_mtc->end_sys_delay);\n \tsess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)\n \t\t\t\t    ((rb_voip_mtc->signal_lvl > 127)?\n \t\t\t\t     ((int)rb_voip_mtc->signal_lvl - 256) :\n \t\t\t\t     rb_voip_mtc->signal_lvl);\n \tsess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)\n \t\t\t\t    ((rb_voip_mtc->noise_lvl > 127)?\n \t\t\t\t     ((int)rb_voip_mtc->noise_lvl - 256) :\n \t\t\t\t     rb_voip_mtc->noise_lvl);\n \tsess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;\n \tsess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;\n \tsess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;\n \tsess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;\n \tsess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;\n \tsess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;\n \tsess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;\n \tsess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);\n \tsess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);\n \tsess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);\n \n \tpj_gettimeofday(&sess->stat.tx.voip_mtc.update);\n     }\n }\n \n", "target": "// fix_start\n\t\t    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;\n\t\t    }\n// fix_end\n// fix_start\n\t\t    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;\n\t\t    }\n// fix_end\n// fix_start\n\t\t    if ((char*)rb_hdr + sizeof(*rb_stats) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;\n\t\t    }\n// fix_end\n// fix_start\n\t\t    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;\n\t\t    }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-43845", "cve_desc": "PJSIP is a free and open source multimedia communication library. In version 2.11.1 and prior, if incoming RTCP XR message contain block, the data field is not checked against the received packet size, potentially resulting in an out-of-bound read access. This affects all users that use PJMEDIA and RTCP XR. A malicious actor can send a RTCP XR message with an invalid packet size.", "project": "pjproject", "idx": 195230}
{"source": " s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n {\n \tu8 idr_flag;\n \ts32 slice, ret;\n \tu32 nal_hdr;\n \tAVCSliceInfo n_state;\n \n \tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n \n \tnal_hdr = gf_bs_read_u8(bs);\n \n \tslice = 0;\n \tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n \tavc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;\n \tn_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;\n \n \tidr_flag = 0;\n \n \tswitch (n_state.nal_unit_type) {\n \tcase GF_AVC_NALU_ACCESS_UNIT:\n \tcase GF_AVC_NALU_END_OF_SEQ:\n \tcase GF_AVC_NALU_END_OF_STREAM:\n \t\tret = 1;\n \t\tbreak;\n \n \tcase GF_AVC_NALU_SVC_SLICE:\n \t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n \t\tsvc_parse_slice(bs, avc, &n_state);\n \t\tif (avc->s_info.nal_ref_idc) {\n \t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n \t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n \t\t}\n \t\tavc_compute_poc(&n_state);\n \n \t\tif (avc->s_info.poc != n_state.poc) {\n \t\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n \t\t\treturn 1;\n \t\t}\n \t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n \t\treturn 0;\n \n \tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n \t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n \t\treturn 0;\n \n \tcase GF_AVC_NALU_IDR_SLICE:\n \tcase GF_AVC_NALU_NON_IDR_SLICE:\n \tcase GF_AVC_NALU_DP_A_SLICE:\n \tcase GF_AVC_NALU_DP_B_SLICE:\n \tcase GF_AVC_NALU_DP_C_SLICE:\n \t\tslice = 1;\n \t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n \t\tif (ret < 0) return ret;\n \t\tret = 0;\n \t\tif (\n \t\t\t((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n \t\t\t&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n \t\t\t) {\n \t\t\tbreak;\n \t\t}\n \t\tif (avc->s_info.frame_num != n_state.frame_num) {\n \t\t\tret = 1;\n \t\t\tbreak;\n \t\t}\n \n \t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n \t\t\tret = 1;\n \t\t\tbreak;\n \t\t}\n \t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n \t\t\t(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n \t\t\tret = 1;\n \t\t\tbreak;\n \t\t}\n// bug_start\n\t\tassert(avc->s_info.sps);\n// bug_end\n \n \t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n \t\t\tif (!avc->s_info.sps->poc_type) {\n \t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n \t\t\t\t\tret = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n \t\t\t\t\tret = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (avc->s_info.sps->poc_type == 1) {\n \t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n \t\t\t\t\tret = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n \t\t\t\t\tret = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n \t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) {\n \t\t\t\tret = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) {\n \t\t\t\tret = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tbreak;\n \tcase GF_AVC_NALU_SEQ_PARAM:\n \t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);\n \t\tif (avc->last_ps_idx < 0) return -1;\n \t\treturn 0;\n \n \tcase GF_AVC_NALU_PIC_PARAM:\n \t\tavc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);\n \t\tif (avc->last_ps_idx < 0) return -1;\n \t\treturn 0;\n \tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n \t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);\n \t\tif (avc->last_ps_idx < 0) return -1;\n \t\treturn 0;\n \tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n \t\tavc->last_ps_idx = (s32) gf_bs_read_ue(bs);\n \t\tif (avc->last_ps_idx < 0) return -1;\n \t\treturn 0;\n \n \tcase GF_AVC_NALU_SEI:\n \tcase GF_AVC_NALU_FILLER_DATA:\n \t\treturn 0;\n \n \tdefault:\n \t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n \t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n \t\t\tret = 1;\n \t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n \t\t\tret = 1;\n \t\telse\n \t\t\tret = 0;\n \t\tbreak;\n \t}\n \n \tif (ret && avc->s_info.sps) {\n \t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n \t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n \t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n \t\tif (avc->s_info.nal_ref_idc) {\n \t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n \t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n \t\t}\n \t}\n \tif (slice)\n \t\tavc_compute_poc(&n_state);\n \tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\tif (!avc->s_info.sps)\n\t\t\treturn -1;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-40565", "cve_desc": "A Segmentation fault caused by a null pointer dereference vulnerability exists in Gpac through 1.0.1 via the gf_avc_parse_nalu function in av_parsers.c when using mp4box, which causes a denial of service.", "project": "gpac", "idx": 195231}
{"source": "   Status SetUnknownShape(const NodeDef* node, int output_port) {\n     shape_inference::ShapeHandle shape =\n         GetUnknownOutputShape(node, output_port);\n     InferenceContext* ctx = GetContext(node);\n     if (ctx == nullptr) {\n// bug_start\n      return errors::InvalidArgument(\"Missing context\");\n// bug_end\n     }\n     ctx->set_output(output_port, shape);\n     return Status::OK();\n   }\n \n", "target": "// fix_start\n      return errors::InvalidArgument(\"SetUnknownShape: Missing context\");\n    }\n    if (output_port < 0 || output_port >= ctx->num_outputs()) {\n      return errors::InvalidArgument(\n          \"SetUnknownShape: output_port must be in [0, \", ctx->num_outputs(),\n          \") but was \", output_port);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-23566", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow is vulnerable to a heap OOB write in `Grappler`. The `set_output` function writes to an array at the specified index. Hence, this gives a malicious user a write primitive. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195233}
{"source": "   Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                             const FunctionDef::ArgAttrs* arg_attrs,\n                             bool ints_on_device,\n                             int64_t resource_arg_unique_id) {\n     bool is_type_list;\n     DataTypeVector dtypes;\n     TF_RETURN_IF_ERROR(\n         ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n     if (dtypes.size() < size_t{1}) {\n       return errors::Internal(\"Expected a list of at least one dtype\");\n     }\n     int arg_index = result_.nodes.size();\n     TF_RETURN_IF_ERROR(\n         AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n     for (size_t i = 0; i < dtypes.size(); ++i) {\n       TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                  {true, arg_index, 0, false, {dtypes[i]}}));\n// bug_start\n      DCHECK_EQ(arg_index, result_.nodes.size());\n// bug_end\n       string name = arg_def.name();\n       if (dtypes.size() > 1) {\n         strings::StrAppend(&name, \"_\", i);\n       }\n       NodeDef* gnode = AddNode(name);\n       if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n         gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n       } else {\n         gnode->set_op(FunctionLibraryDefinition::kArgOp);\n       }\n       DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n       AddAttr(\"T\", dtype, gnode);\n       AddAttr(\"index\", arg_index, gnode);\n       if (resource_arg_unique_id >= 0) {\n         AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n       }\n       if (arg_attrs) {\n         for (const auto& arg_attr : arg_attrs->attr()) {\n           AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n         }\n       }\n       result_.arg_types.push_back(dtypes[i]);\n       ++arg_index;\n     }\n     return Status::OK();\n   }\n \n", "target": "// fix_start\n      if (arg_index != result_.nodes.size()) {\n        return errors::Internal(\n            \"Expected arg_index to be equal to the number of nodes in result.\",\n            \" Got \", arg_index, \" and \", result_.nodes.size());\n      }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-23586", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that assertions in `function.cc` would be falsified and crash the Python interpreter. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195234}
{"source": " static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n #define CropBox  \"CropBox\"\n #define DeviceCMYK  \"DeviceCMYK\"\n #define MediaBox  \"MediaBox\"\n #define RenderPCLText  \"  Rendering PCL...  \"\n \n   char\n     command[MagickPathExtent],\n     *density,\n     filename[MagickPathExtent],\n     geometry[MagickPathExtent],\n     *options,\n     input_filename[MagickPathExtent];\n \n   const DelegateInfo\n     *delegate_info;\n \n   Image\n     *image,\n     *next_image;\n \n   ImageInfo\n     *read_info;\n \n   MagickBooleanType\n     cmyk,\n     status;\n \n   PointInfo\n     delta;\n \n   RectangleInfo\n     bounding_box,\n     page;\n \n   char\n     *p;\n \n   ssize_t\n     c;\n \n   SegmentInfo\n     bounds;\n \n   size_t\n     height,\n     width;\n \n   ssize_t\n     count;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n   if (status == MagickFalse)\n     {\n       ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n         image_info->filename);\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   delta.x=DefaultResolution;\n   delta.y=DefaultResolution;\n   if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n     {\n       GeometryInfo\n         geometry_info;\n \n       MagickStatusType\n         flags;\n \n       flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n       if ((flags & RhoValue) != 0)\n         image->resolution.x=geometry_info.rho;\n       image->resolution.y=image->resolution.x;\n       if ((flags & SigmaValue) != 0)\n         image->resolution.y=geometry_info.sigma;\n     }\n   cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n   count=0;\n   (void) memset(&bounding_box,0,sizeof(bounding_box));\n   (void) memset(&bounds,0,sizeof(bounds));\n   (void) memset(&page,0,sizeof(page));\n   (void) memset(command,0,sizeof(command));\n   p=command;\n   for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n   {\n     if (image_info->page != (char *) NULL)\n       continue;\n     *p++=(char) c;\n     if ((c != (int) '/') && (c != '\\n') &&\n         ((size_t) (p-command) < (MagickPathExtent-1)))\n       continue;\n     *p='\\0';\n     p=command;\n     if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n       cmyk=MagickTrue;\n     if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n       {\n         count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n         if (count != 4)\n           count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n       }\n     if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n       {\n         count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n         if (count != 4)\n           count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n       }\n     if (count != 4)\n       continue;\n// bug_start\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n// bug_end\n     if (width > page.width)\n       page.width=width;\n     if (height > page.height)\n       page.height=height;\n   }\n   (void) CloseBlob(image);\n   if ((page.width == 0) || (page.height == 0))\n     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n   if (image_info->page != (char *) NULL)\n     (void) ParseAbsoluteGeometry(image_info->page,&page);\n   (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n     page.width,(double) page.height);\n   if (image_info->monochrome != MagickFalse)\n     delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n   else\n      if (cmyk != MagickFalse)\n        delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n      else\n        delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n   if (delegate_info == (const DelegateInfo *) NULL)\n     {\n       image=DestroyImage(image);\n       return((Image *) NULL);\n     }\n   if ((page.width == 0) || (page.height == 0))\n     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n   if (image_info->page != (char *) NULL)\n     (void) ParseAbsoluteGeometry(image_info->page,&page);\n   density=AcquireString(\"\");\n   options=AcquireString(\"\");\n   (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n     image->resolution.x,image->resolution.y);\n   if (image_info->ping != MagickFalse)\n     (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n   page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n   page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n   (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n     page.width,(double) page.height);\n   image=DestroyImage(image);\n   read_info=CloneImageInfo(image_info);\n   *read_info->magick='\\0';\n   if (read_info->number_scenes != 0)\n     {\n       if (read_info->number_scenes != 1)\n         (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n           (double) (read_info->scene+read_info->number_scenes));\n       else\n         (void) FormatLocaleString(options,MagickPathExtent,\n           \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n           (double) (read_info->scene+read_info->number_scenes));\n       read_info->number_scenes=0;\n       if (read_info->scenes != (char *) NULL)\n         *read_info->scenes='\\0';\n     }\n   (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n   (void) AcquireUniqueFilename(read_info->filename);\n   (void) FormatLocaleString(command,MagickPathExtent,\n     GetDelegateCommands(delegate_info),\n     read_info->antialias != MagickFalse ? 4 : 1,\n     read_info->antialias != MagickFalse ? 4 : 1,density,options,\n     read_info->filename,input_filename);\n   options=DestroyString(options);\n   density=DestroyString(density);\n   status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n     (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n   image=ReadImage(read_info,exception);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   (void) RelinquishUniqueFileResource(input_filename);\n   read_info=DestroyImageInfo(read_info);\n   if (image == (Image *) NULL)\n     ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n   if (LocaleCompare(image->magick,\"BMP\") == 0)\n     {\n       Image\n         *cmyk_image;\n \n       cmyk_image=ConsolidateCMYKImages(image,exception);\n       if (cmyk_image != (Image *) NULL)\n         {\n           image=DestroyImageList(image);\n           image=cmyk_image;\n         }\n     }\n   do\n   {\n     (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n     image->page=page;\n     if (image_info->ping != MagickFalse)\n       {\n         image->magick_columns*=image->resolution.x/2.0;\n         image->magick_rows*=image->resolution.y/2.0;\n         image->columns*=image->resolution.x/2.0;\n         image->rows*=image->resolution.y/2.0;\n       }\n     next_image=SyncNextImageInList(image);\n     if (next_image != (Image *) NULL)\n       image=next_image;\n   } while (next_image != (Image *) NULL);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2022-32546", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned long' at coders/pcl.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "project": "ImageMagick", "idx": 195237}
{"source": " static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n {\n DEFINE_COMPILER;\n jump_list *found = NULL;\n jump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\n sljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\n struct sljit_jump *jump = NULL;\n PCRE2_SPTR ccbegin;\n int compares, invertcmp, numberofcmps;\n #if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n BOOL utf = common->utf;\n #endif\n \n #ifdef SUPPORT_UNICODE\n sljit_u32 unicode_status = 0;\n int typereg = TMP1;\n const sljit_u32 *other_cases;\n sljit_uw typeoffset;\n #endif\n \n cc++;\n ccbegin = cc;\n compares = 0;\n \n if (cc[-1] & XCL_MAP)\n   {\n   min = 0;\n   cc += 32 / sizeof(PCRE2_UCHAR);\n   }\n \n while (*cc != XCL_END)\n   {\n   compares++;\n   if (*cc == XCL_SINGLE)\n     {\n     cc ++;\n     GETCHARINCTEST(c, cc);\n     if (c > max) max = c;\n     if (c < min) min = c;\n #ifdef SUPPORT_UNICODE\n     unicode_status |= XCLASS_SAVE_CHAR;\n #endif\n     }\n   else if (*cc == XCL_RANGE)\n     {\n     cc ++;\n     GETCHARINCTEST(c, cc);\n     if (c < min) min = c;\n     GETCHARINCTEST(c, cc);\n     if (c > max) max = c;\n #ifdef SUPPORT_UNICODE\n     unicode_status |= XCLASS_SAVE_CHAR;\n #endif\n     }\n #ifdef SUPPORT_UNICODE\n   else\n     {\n     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n     cc++;\n// bug_start\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n// bug_end\n       {\n       other_cases = PRIV(ucd_caseless_sets) + cc[1];\n       while (*other_cases != NOTACHAR)\n         {\n         if (*other_cases > max) max = *other_cases;\n         if (*other_cases < min) min = *other_cases;\n         other_cases++;\n         }\n       }\n     else\n       {\n       max = READ_CHAR_MAX;\n       min = 0;\n       }\n \n     switch(*cc)\n       {\n       case PT_ANY:\n       if (cc[-1] == XCL_PROP)\n         {\n         compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n         if (list == backtracks)\n           add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n         return;\n         }\n       break;\n \n       case PT_LAMP:\n       case PT_GC:\n       case PT_PC:\n       case PT_ALNUM:\n       unicode_status |= XCLASS_HAS_TYPE;\n       break;\n \n       case PT_SCX:\n       unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n       if (cc[-1] == XCL_NOTPROP)\n         {\n         unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n         break;\n         }\n       compares++;\n \n       case PT_SC:\n       unicode_status |= XCLASS_HAS_SCRIPT;\n       break;\n \n       case PT_SPACE:\n       case PT_PXSPACE:\n       case PT_WORD:\n       case PT_PXGRAPH:\n       case PT_PXPRINT:\n       case PT_PXPUNCT:\n       unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n       break;\n \n       case PT_CLIST:\n       case PT_UCNC:\n       unicode_status |= XCLASS_SAVE_CHAR;\n       break;\n \n       case PT_BOOL:\n       unicode_status |= XCLASS_HAS_BOOL;\n       break;\n \n       case PT_BIDICL:\n       unicode_status |= XCLASS_HAS_BIDICL;\n       break;\n \n       default:\n       SLJIT_UNREACHABLE();\n       break;\n       }\n     cc += 2;\n     }\n #endif\n   }\n SLJIT_ASSERT(compares > 0);\n \n cc = ccbegin;\n if ((cc[-1] & XCL_NOT) != 0)\n   read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\n else\n   {\n #ifdef SUPPORT_UNICODE\n   read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n #else\n   read_char(common, min, max, NULL, 0);\n #endif\n   }\n \n if ((cc[-1] & XCL_HASPROP) == 0)\n   {\n   if ((cc[-1] & XCL_MAP) != 0)\n     {\n     jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n     if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n       {\n       OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n       OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n       OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n       OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n       OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n       add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n       }\n \n     add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n     JUMPHERE(jump);\n \n     cc += 32 / sizeof(PCRE2_UCHAR);\n     }\n   else\n     {\n     OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n     add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n     }\n   }\n else if ((cc[-1] & XCL_MAP) != 0)\n   {\n   OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n #ifdef SUPPORT_UNICODE\n   unicode_status |= XCLASS_CHAR_SAVED;\n #endif\n   if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n     {\n #if PCRE2_CODE_UNIT_WIDTH == 8\n     jump = NULL;\n     if (common->utf)\n #endif\n       jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n \n     OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n     OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n     OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n     OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n     OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n     add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n \n #if PCRE2_CODE_UNIT_WIDTH == 8\n     if (common->utf)\n #endif\n       JUMPHERE(jump);\n     }\n \n   OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n   cc += 32 / sizeof(PCRE2_UCHAR);\n   }\n \n #ifdef SUPPORT_UNICODE\n if (unicode_status & XCLASS_NEEDS_UCD)\n   {\n   if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n     OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n \n #if PCRE2_CODE_UNIT_WIDTH == 32\n   if (!common->utf)\n     {\n     jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n     OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n     JUMPHERE(jump);\n     }\n #endif\n \n   OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n   OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n   OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n   OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n   OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n   OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n   OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n   OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n \n   ccbegin = cc;\n \n   if (unicode_status & XCLASS_HAS_BIDICL)\n     {\n     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n     OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n \n     while (*cc != XCL_END)\n       {\n       if (*cc == XCL_SINGLE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         }\n       else if (*cc == XCL_RANGE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         GETCHARINCTEST(c, cc);\n         }\n       else\n         {\n         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n         cc++;\n         if (*cc == PT_BIDICL)\n           {\n           compares--;\n           invertcmp = (compares == 0 && list != backtracks);\n           if (cc[-1] == XCL_NOTPROP)\n             invertcmp ^= 0x1;\n           jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n           add_jump(compiler, compares > 0 ? list : backtracks, jump);\n           }\n         cc += 2;\n         }\n       }\n \n     cc = ccbegin;\n     }\n \n   if (unicode_status & XCLASS_HAS_BOOL)\n     {\n     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n     OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n     OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n \n     while (*cc != XCL_END)\n       {\n       if (*cc == XCL_SINGLE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         }\n       else if (*cc == XCL_RANGE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         GETCHARINCTEST(c, cc);\n         }\n       else\n         {\n         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n         cc++;\n         if (*cc == PT_BOOL)\n           {\n           compares--;\n           invertcmp = (compares == 0 && list != backtracks);\n           if (cc[-1] == XCL_NOTPROP)\n             invertcmp ^= 0x1;\n \n           OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n           add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n           }\n         cc += 2;\n         }\n       }\n \n     cc = ccbegin;\n     }\n \n   if (unicode_status & XCLASS_HAS_SCRIPT)\n     {\n     OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n \n     while (*cc != XCL_END)\n       {\n       if (*cc == XCL_SINGLE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         }\n       else if (*cc == XCL_RANGE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         GETCHARINCTEST(c, cc);\n         }\n       else\n         {\n         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n         cc++;\n         switch (*cc)\n           {\n           case PT_SCX:\n           if (cc[-1] == XCL_NOTPROP)\n             break;\n \n           case PT_SC:\n           compares--;\n           invertcmp = (compares == 0 && list != backtracks);\n           if (cc[-1] == XCL_NOTPROP)\n             invertcmp ^= 0x1;\n \n           add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n           }\n         cc += 2;\n         }\n       }\n \n     cc = ccbegin;\n     }\n \n   if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n     {\n     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n     OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n     OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n \n     if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n       {\n       if (unicode_status & XCLASS_HAS_TYPE)\n         {\n         if (unicode_status & XCLASS_SAVE_CHAR)\n           {\n           OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n           unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n           }\n         else\n           {\n           OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n           unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n           }\n         }\n       OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n       }\n \n     while (*cc != XCL_END)\n       {\n       if (*cc == XCL_SINGLE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         }\n       else if (*cc == XCL_RANGE)\n         {\n         cc ++;\n         GETCHARINCTEST(c, cc);\n         GETCHARINCTEST(c, cc);\n         }\n       else\n         {\n         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n         cc++;\n         if (*cc == PT_SCX)\n           {\n           compares--;\n           invertcmp = (compares == 0 && list != backtracks);\n \n           jump = NULL;\n           if (cc[-1] == XCL_NOTPROP)\n             {\n             jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n             if (invertcmp)\n               {\n               add_jump(compiler, backtracks, jump);\n               jump = NULL;\n               }\n             invertcmp ^= 0x1;\n             }\n \n           OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n           add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n \n           if (jump != NULL)\n             JUMPHERE(jump);\n           }\n         cc += 2;\n         }\n       }\n \n     if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n       OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n     else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n       OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n     cc = ccbegin;\n     }\n \n   if (unicode_status & XCLASS_SAVE_CHAR)\n     OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n \n   if (unicode_status & XCLASS_HAS_TYPE)\n     {\n     if (unicode_status & XCLASS_SAVE_CHAR)\n       typereg = RETURN_ADDR;\n \n     OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n     }\n   }\n #endif\n \n charoffset = 0;\n numberofcmps = 0;\n #ifdef SUPPORT_UNICODE\n typeoffset = 0;\n #endif\n \n while (*cc != XCL_END)\n   {\n   compares--;\n   invertcmp = (compares == 0 && list != backtracks);\n   jump = NULL;\n \n   if (*cc == XCL_SINGLE)\n     {\n     cc ++;\n     GETCHARINCTEST(c, cc);\n \n     if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n       {\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n       OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n       numberofcmps++;\n       }\n     else if (numberofcmps > 0)\n       {\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       numberofcmps = 0;\n       }\n     else\n       {\n       jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n       numberofcmps = 0;\n       }\n     }\n   else if (*cc == XCL_RANGE)\n     {\n     cc ++;\n     GETCHARINCTEST(c, cc);\n     SET_CHAR_OFFSET(c);\n     GETCHARINCTEST(c, cc);\n \n     if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n       {\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n       OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n       numberofcmps++;\n       }\n     else if (numberofcmps > 0)\n       {\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       numberofcmps = 0;\n       }\n     else\n       {\n       jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n       numberofcmps = 0;\n       }\n     }\n #ifdef SUPPORT_UNICODE\n   else\n     {\n     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n     if (*cc == XCL_NOTPROP)\n       invertcmp ^= 0x1;\n     cc++;\n     switch(*cc)\n       {\n       case PT_ANY:\n       if (!invertcmp)\n         jump = JUMP(SLJIT_JUMP);\n       break;\n \n       case PT_LAMP:\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       break;\n \n       case PT_GC:\n       c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n       SET_TYPE_OFFSET(c);\n       jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n       break;\n \n       case PT_PC:\n       jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n       break;\n \n       case PT_SC:\n       case PT_SCX:\n       case PT_BOOL:\n       case PT_BIDICL:\n       compares++;\n       break;\n \n       case PT_SPACE:\n       case PT_PXSPACE:\n       SET_CHAR_OFFSET(9);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n \n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n \n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n \n       SET_TYPE_OFFSET(ucp_Zl);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       break;\n \n       case PT_WORD:\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n \n       case PT_ALNUM:\n       SET_TYPE_OFFSET(ucp_Ll);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n       OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n       SET_TYPE_OFFSET(ucp_Nd);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       break;\n \n       case PT_CLIST:\n       other_cases = PRIV(ucd_caseless_sets) + cc[1];\n \n       SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n       SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n \n       if (is_powerof2(other_cases[1] ^ other_cases[0]))\n         {\n         if (charoffset == 0)\n           OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n         else\n           {\n           OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n           OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n           }\n         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n         other_cases += 2;\n         }\n       else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n         {\n         if (charoffset == 0)\n           OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n         else\n           {\n           OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n           OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n           }\n         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n \n         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n         OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n \n         other_cases += 3;\n         }\n       else\n         {\n         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n         }\n \n       while (*other_cases != NOTACHAR)\n         {\n         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n         OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n         }\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       break;\n \n       case PT_UCNC:\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n \n       SET_CHAR_OFFSET(0xa0);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n       SET_CHAR_OFFSET(0);\n       OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       break;\n \n       case PT_PXGRAPH:\n       SET_TYPE_OFFSET(ucp_Ll);\n       OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n \n       jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n \n       SET_CHAR_OFFSET(0x2066);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n \n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n \n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n \n       JUMPHERE(jump);\n       jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n       break;\n \n       case PT_PXPRINT:\n       SET_TYPE_OFFSET(ucp_Ll);\n       OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n \n       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n       OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n \n       jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n \n       SET_CHAR_OFFSET(0x2066);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n \n       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n \n       JUMPHERE(jump);\n       jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n       break;\n \n       case PT_PXPUNCT:\n       SET_TYPE_OFFSET(ucp_Sc);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n \n       SET_CHAR_OFFSET(0);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n       OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n \n       SET_TYPE_OFFSET(ucp_Pc);\n       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n       break;\n \n       default:\n       SLJIT_UNREACHABLE();\n       break;\n       }\n     cc += 2;\n     }\n #endif\n \n   if (jump != NULL)\n     add_jump(compiler, compares > 0 ? list : backtracks, jump);\n   }\n \n if (found != NULL)\n   set_jumps(found, LABEL());\n }\n \n", "target": "// fix_start\n    if (*cc == PT_CLIST && cc[-1] == XCL_PROP)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-1586", "cve_desc": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the compile_xclass_matchingpath() function of the pcre2_jit_compile.c file. This involves a unicode property matching issue in JIT-compiled regular expressions. The issue occurs because the character was not fully read in case-less matching within JIT.", "project": "pcre2", "idx": 195264}
{"source": " bool ConstantFolding::MulConvPushDown(GraphDef* optimized_graph, NodeDef* node,\n                                       const GraphProperties& properties) {\n \n   if (!IsAnyMul(*node) || NumNonControlInputs(*node) != 2) return false;\n \n   NodeDef* mul_left_child = node_map_->GetNode(node->input(0));\n   NodeDef* mul_right_child = node_map_->GetNode(node->input(1));\n// bug_start\n// bug_end\n   const bool left_child_is_constant = IsReallyConstant(*mul_left_child);\n   const bool right_child_is_constant = IsReallyConstant(*mul_right_child);\n   if (!left_child_is_constant && !right_child_is_constant) {\n     return false;\n   }\n   NodeDef* conv_node =\n       left_child_is_constant ? mul_right_child : mul_left_child;\n   if (!IsConv2D(*conv_node) && !IsConv3D(*conv_node)) {\n     return false;\n   }\n   if (node->device() != mul_left_child->device() ||\n       node->device() != mul_right_child->device()) {\n     return false;\n   }\n \n   if (conv_node->input_size() < 2 ||\n       NumNonControlOutputs(*conv_node, *node_map_) > 1 ||\n       nodes_to_preserve_.find(conv_node->name()) != nodes_to_preserve_.end()) {\n     return false;\n   }\n \n   NodeDef* conv_left_child = node_map_->GetNode(conv_node->input(0));\n   NodeDef* conv_right_child = node_map_->GetNode(conv_node->input(1));\n   const bool conv_left_is_constant = IsReallyConstant(*conv_left_child);\n   const bool conv_right_is_constant = IsReallyConstant(*conv_right_child);\n   if (!conv_left_is_constant && !conv_right_is_constant) {\n     return false;\n   }\n   if (conv_left_is_constant && conv_right_is_constant) {\n     return false;\n   }\n   const auto& mul_props = properties.GetOutputProperties(node->name());\n   const auto& conv_props = properties.GetOutputProperties(conv_node->name());\n   if (mul_props.empty() || conv_props.empty()) {\n     return false;\n   }\n   const auto& mul_shape = mul_props[0].shape();\n   const auto& conv_shape = conv_props[0].shape();\n   if (!ShapesSymbolicallyEqual(mul_shape, conv_shape)) {\n     return false;\n   }\n \n   const auto& input_props = properties.GetInputProperties(conv_node->name());\n   if (input_props.size() < 2) {\n     return false;\n   }\n   const auto& filter_shape = input_props[1].shape();\n \n   NodeDef* const_node =\n       left_child_is_constant ? mul_left_child : mul_right_child;\n   const auto& const_props = properties.GetOutputProperties(const_node->name());\n   if (const_props.empty()) {\n     return false;\n   }\n   const auto& const_shape = const_props[0].shape();\n   if (!IsValidConstShapeForMulConvPushDown(\n           conv_node->attr().at(\"data_format\").s(), filter_shape, const_shape)) {\n     return false;\n   }\n \n   string mul_new_name = AddPrefixToNodeName(\"merged_input\", conv_node->name());\n   if (node_map_->NodeExists(mul_new_name)) {\n     return false;\n   }\n   string conv_const_input =\n       conv_left_is_constant ? conv_node->input(0) : conv_node->input(1);\n   if (MaybeRemoveControlInput(conv_node->name(), const_node, optimized_graph,\n                               node_map_.get())) {\n     MaybeAddControlInput(conv_const_input, const_node, optimized_graph,\n                          node_map_.get());\n   }\n \n   conv_node->set_name(node->name());\n   node->set_name(mul_new_name);\n   if (conv_left_is_constant) {\n     node_map_->UpdateInput(conv_node->name(), node->input(0), mul_new_name);\n     conv_node->set_input(0, mul_new_name);\n   } else {\n     node_map_->UpdateInput(conv_node->name(), node->input(1), mul_new_name);\n     conv_node->set_input(1, mul_new_name);\n   }\n   NodeDef* conv_const_node =\n       conv_left_is_constant ? conv_left_child : conv_right_child;\n   if (left_child_is_constant) {\n     node->set_input(1, conv_const_node->name());\n   } else {\n     node->set_input(0, conv_const_node->name());\n   }\n   node_map_->AddNode(mul_new_name, node);\n \n   return true;\n }\n \n", "target": "// fix_start\n  if (mul_left_child == nullptr || mul_right_child == nullptr) {\n    return false;\n  }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-23589", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. Under certain scenarios, Grappler component of TensorFlow can trigger a null pointer dereference. There are 2 places where this can occur, for the same malicious alteration of a `SavedModel` file (fixing the first one would trigger the same dereference in the second place). First, during constant folding, the `GraphDef` might not have the required nodes for the binary operation. If a node is missing, the correposning `mul_*child` would be null, and the dereference in the subsequent line would be incorrect. We have a similar issue during `IsIdentityConsumingSwitch`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195274}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& rhs = context->input(1);\n \n     context->forward_ref_input_to_ref_output(0, 0);\n// bug_start\n// bug_end\n \n     AllocatorAttributes attr;\n     if (!relax_constraints_) {\n       attr.set_gpu_compatible(true);\n       attr.set_nic_compatible(true);\n     }\n \n     {\n       mutex_lock l(*context->input_ref_mutex(0));\n       const Tensor& old_lhs = context->mutable_input(0,  true);\n       const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n       if (validate_shape_) {\n         OP_REQUIRES(context, same_shape,\n                     errors::InvalidArgument(\n                         \"Assign requires shapes of both tensors to match. \"\n                         \"lhs shape= \",\n                         old_lhs.shape().DebugString(),\n                         \" rhs shape= \", rhs.shape().DebugString()));\n       }\n \n \n       if (old_lhs.IsInitialized() &&\n           old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n         Tensor reshaped_old_lhs;\n         if (same_shape) {\n           reshaped_old_lhs = old_lhs;\n         } else {\n           CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n           context->replace_ref_input(0, reshaped_old_lhs,\n                                       true);\n         }\n         if (use_exclusive_lock_) {\n           Copy(context, &reshaped_old_lhs, rhs);\n           return;\n         }\n       } else {\n         std::unique_ptr<Tensor> input_alias = context->forward_input(\n             1, OpKernelContext::Params::kNoReservation ,\n             rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n         if (input_alias != nullptr) {\n           context->replace_ref_input(0, *input_alias,  true);\n           return;\n         }\n \n         Tensor copy_tensor;\n         OP_REQUIRES_OK(context,\n                        context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                               &copy_tensor, attr));\n         context->clear_recorded_memory();\n         context->replace_ref_input(0, copy_tensor,  true);\n         if (use_exclusive_lock_) {\n           Copy(context, &copy_tensor, rhs);\n           return;\n         }\n       }\n     }\n \n     Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n     Copy(context, &old_unlocked_lhs, rhs);\n   }\n \n", "target": "// fix_start\n\n    OP_REQUIRES(\n        context, rhs.IsInitialized(),\n        errors::Internal(\"Right hand side of AssignOp is not initialized\"));\n// fix_end\n", "cwe": "CWE-908", "cwe_name": "Use of Uninitialized Resource", "cve": "CVE-2022-23573", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `AssignOp` can result in copying uninitialized data to a new tensor. This later results in undefined behavior. The implementation has a check that the left hand side of the assignment is initialized (to minimize number of allocations), but does not check that the right hand side is also initialized. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195291}
{"source": " gen_hash(codegen_scope *s, node *tree, int val, int limit)\n {\n   int slimit = GEN_VAL_STACK_MAX;\n   if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n   int len = 0;\n   mrb_bool update = FALSE;\n \n   while (tree) {\n     if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n// bug_start\n      if (len > 0) {\n// bug_end\n         pop_n(len*2);\n         if (!update) {\n           genop_2(s, OP_HASH, cursp(), len);\n         }\n         else {\n           pop();\n           genop_2(s, OP_HASHADD, cursp(), len);\n         }\n         push();\n       }\n       codegen(s, tree->car->cdr, val);\n// bug_start\n      if (len > 0 || update) {\n// bug_end\n         pop(); pop();\n         genop_1(s, OP_HASHCAT, cursp());\n         push();\n       }\n       update = TRUE;\n       len = 0;\n     }\n     else {\n       codegen(s, tree->car->car, val);\n       codegen(s, tree->car->cdr, val);\n       len++;\n     }\n     tree = tree->cdr;\n     if (val && cursp() >= slimit) {\n       pop_n(len*2);\n       if (!update) {\n         genop_2(s, OP_HASH, cursp(), len);\n       }\n       else {\n         pop();\n         genop_2(s, OP_HASHADD, cursp(), len);\n       }\n       push();\n       update = TRUE;\n       len = 0;\n     }\n   }\n   if (update) {\n     if (val && len > 0) {\n       pop_n(len*2+1);\n       genop_2(s, OP_HASHADD, cursp(), len);\n       push();\n     }\n     return -1;\n   }\n   return len;\n }\n \n", "target": "// fix_start\n      if (val && len > 0) {\n// fix_end\n// fix_start\n      if (val && (len > 0 || update)) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-0481", "cve_desc": "NULL Pointer Dereference in Homebrew mruby prior to 3.2.", "project": "mruby", "idx": 195293}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     StagingMap<Ordered>* map = nullptr;\n     OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n     core::ScopedUnref scope(map);\n     typename StagingMap<Ordered>::OptionalTuple tuple;\n \n     const Tensor* key_tensor;\n     const Tensor* indices_tensor;\n     OpInputList values_tensor;\n \n     OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n     OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n     OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n     OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                 errors::InvalidArgument(\"key must not be empty\"));\n \n// bug_start\n// bug_end\n     Tensor key(*key_tensor);\n \n     for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n       tuple.push_back(values_tensor[i]);\n     }\n \n     OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, key_tensor->NumElements() == 1,\n                errors::InvalidArgument(\n                    \"key must be an int64 scalar, got tensor with shape: \",\n                    key_tensor->shape()));\n\n// fix_end\n", "cwe": "CWE-843", "cwe_name": "Access of Resource Using Incompatible Type ('Type Confusion')", "cve": "CVE-2022-21734", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `MapStage` is vulnerable a `CHECK`-fail if the key tensor is not a scalar. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195294}
{"source": " gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n {\n   int idx;\n   int type = nint(tree->car);\n \n   switch (type) {\n   case NODE_GVAR:\n   case NODE_ARG:\n   case NODE_LVAR:\n   case NODE_IVAR:\n   case NODE_CVAR:\n   case NODE_CONST:\n   case NODE_NIL:\n   case NODE_MASGN:\n     if (rhs) {\n       codegen(s, rhs, VAL);\n       pop();\n       sp = cursp();\n     }\n     break;\n \n   case NODE_COLON2:\n   case NODE_CALL:\n   case NODE_SCALL:\n     break;\n \n   case NODE_NVAR:\n     codegen_error(s, \"Can't assign to numbered parameter\");\n     break;\n \n   default:\n     codegen_error(s, \"unknown lhs\");\n     break;\n   }\n \n   tree = tree->cdr;\n   switch (type) {\n   case NODE_GVAR:\n     gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n     break;\n   case NODE_ARG:\n   case NODE_LVAR:\n     idx = lv_idx(s, nsym(tree));\n     if (idx > 0) {\n       if (idx != sp) {\n         gen_move(s, idx, sp, val);\n       }\n       break;\n     }\n     else {\n       gen_setupvar(s, sp, nsym(tree));\n     }\n     break;\n   case NODE_IVAR:\n     gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n     break;\n   case NODE_CVAR:\n     gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n     break;\n   case NODE_CONST:\n     gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n     break;\n   case NODE_COLON2:\n     if (sp) {\n       gen_move(s, cursp(), sp, 0);\n     }\n     sp = cursp();\n     push();\n     codegen(s, tree->car, VAL);\n     if (rhs) {\n       codegen(s, rhs, VAL); pop();\n       gen_move(s, sp, cursp(), 0);\n     }\n     pop_n(2);\n     idx = new_sym(s, nsym(tree->cdr));\n     genop_2(s, OP_SETMCNST, sp, idx);\n     break;\n \n   case NODE_CALL:\n   case NODE_SCALL:\n     {\n       int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n       mrb_sym mid = nsym(tree->cdr->car);\n \n       top = cursp();\n       if (val || sp == cursp()) {\n         push();\n       }\n       call = cursp();\n       if (!tree->car) {\n         noself = 1;\n         push();\n       }\n       else {\n         codegen(s, tree->car, VAL);\n       }\n       if (safe) {\n         int recv = cursp()-1;\n         gen_move(s, cursp(), recv, 1);\n         skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n       }\n       tree = tree->cdr->cdr->car;\n       if (tree) {\n         if (tree->car) {\n           n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n           if (n < 0) {\n             n = 15;\n             push();\n           }\n         }\n         if (tree->cdr->car) {\n// bug_start\n          if (n == 14) {\n// bug_end\n             pop_n(n);\n             genop_2(s, OP_ARRAY, cursp(), n);\n             push();\n             n = 15;\n           }\n           gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n           if (n < 14) {\n             n++;\n           }\n           else {\n             pop_n(2);\n             genop_2(s, OP_ARYPUSH, cursp(), 1);\n           }\n           push();\n         }\n       }\n       if (rhs) {\n         codegen(s, rhs, VAL);\n         pop();\n       }\n       else {\n         gen_move(s, cursp(), sp, 0);\n       }\n       if (val) {\n         gen_move(s, top, cursp(), 1);\n       }\n       if (n < 15) {\n         n++;\n         if (n == 15) {\n           pop_n(14);\n           genop_2(s, OP_ARRAY, cursp(), 15);\n         }\n       }\n       else {\n         pop();\n         genop_2(s, OP_ARYPUSH, cursp(), 1);\n       }\n       s->sp = call;\n       if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n         genop_1(s, OP_SETIDX, cursp());\n       }\n       else {\n         genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n       }\n       if (safe) {\n         dispatch(s, skip);\n       }\n       s->sp = top;\n     }\n     break;\n \n   case NODE_MASGN:\n     gen_massignment(s, tree->car, sp, val);\n     break;\n \n   case NODE_NIL:\n     break;\n \n   default:\n     codegen_error(s, \"unknown lhs\");\n     break;\n   }\n   if (val) push();\n }\n \n", "target": "// fix_start\n          if (n == 13 || n == 14) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-1276", "cve_desc": "Out-of-bounds Read in mrb_get_args in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.", "project": "mruby", "idx": 195295}
{"source": "     void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n// bug_start\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n// bug_end\n \n         for (; stop != std::string::npos; start = stop + 1) {\n             stop = topic.find('/', start);\n             std::string_view segment = topic.substr(start, stop - start);\n \n             if (segment.length() == 1) {\n                 if (segment[0] == '+' || segment[0] == '#') {\n                     return;\n                 }\n             }\n \n             if (iterator->terminatingWildcardChild) {\n                 iterator->terminatingWildcardChild->messages[messageId] = message;\n \n                 if (!iterator->terminatingWildcardChild->triggered) {\n// bug_start\n// bug_end\n                     triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                     iterator->terminatingWildcardChild->triggered = true;\n                 }\n             }\n \n             if (iterator->wildcardChild) {\n                 publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n             }\n \n             std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n             if (it == iterator->children.end()) {\n                 return;\n             }\n \n             iterator = it->second;\n         }\n \n         iterator->messages[messageId] = message;\n \n         if (!iterator->triggered) {\n// bug_start\n// bug_end\n             triggeredTopics[numTriggeredTopics++] = iterator;\n             iterator->triggered = true;\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n                    if (numTriggeredTopics == 64) {\n                        drain();\n                    }\n\n// fix_end\n// fix_start\n            if (numTriggeredTopics == 64) {\n                drain();\n            }\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-36406", "cve_desc": "uWebSockets 18.11.0 and 18.12.0 has a stack-based buffer overflow in uWS::TopicTree::trimTree (called from uWS::TopicTree::unsubscribeAll). NOTE: the vendor's position is that this is \"a minor issue or not even an issue at all\" because the developer of an application (that uses uWebSockets) should not be allowing the large number of triggered topics to accumulate", "project": "uWebSockets", "idx": 195296}
{"source": " setup_seccomp (FlatpakBwrap   *bwrap,\n                const char     *arch,\n                gulong          allowed_personality,\n                FlatpakRunFlags run_flags,\n                GError        **error)\n {\n   gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n   gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n \n   __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n \n   struct\n   {\n     int                  scall;\n     int                  errnum;\n     struct scmp_arg_cmp *arg;\n   } syscall_blocklist[] = {\n     {SCMP_SYS (syslog), EPERM},\n     {SCMP_SYS (uselib), EPERM},\n     {SCMP_SYS (acct), EPERM},\n     {SCMP_SYS (modify_ldt), EPERM},\n     {SCMP_SYS (quotactl), EPERM},\n \n     {SCMP_SYS (add_key), EPERM},\n     {SCMP_SYS (keyctl), EPERM},\n     {SCMP_SYS (request_key), EPERM},\n \n     {SCMP_SYS (move_pages), EPERM},\n     {SCMP_SYS (mbind), EPERM},\n     {SCMP_SYS (get_mempolicy), EPERM},\n     {SCMP_SYS (set_mempolicy), EPERM},\n     {SCMP_SYS (migrate_pages), EPERM},\n \n     {SCMP_SYS (unshare), EPERM},\n     {SCMP_SYS (setns), EPERM},\n     {SCMP_SYS (mount), EPERM},\n     {SCMP_SYS (umount), EPERM},\n     {SCMP_SYS (umount2), EPERM},\n     {SCMP_SYS (pivot_root), EPERM},\n// bug_start\n// bug_end\n #if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n     {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n #else\n     {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n #endif\n \n     {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n \n     {SCMP_SYS (clone3), ENOSYS},\n \n     {SCMP_SYS (open_tree), ENOSYS},\n     {SCMP_SYS (move_mount), ENOSYS},\n     {SCMP_SYS (fsopen), ENOSYS},\n     {SCMP_SYS (fsconfig), ENOSYS},\n     {SCMP_SYS (fsmount), ENOSYS},\n     {SCMP_SYS (fspick), ENOSYS},\n     {SCMP_SYS (mount_setattr), ENOSYS},\n   };\n \n   struct\n   {\n     int                  scall;\n     int                  errnum;\n     struct scmp_arg_cmp *arg;\n   } syscall_nondevel_blocklist[] = {\n     {SCMP_SYS (perf_event_open), EPERM},\n     {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n     {SCMP_SYS (ptrace), EPERM}\n   };\n   struct\n   {\n     int             family;\n     FlatpakRunFlags flags_mask;\n   } socket_family_allowlist[] = {\n     { AF_UNSPEC, 0 },\n     { AF_LOCAL, 0 },\n     { AF_INET, 0 },\n     { AF_INET6, 0 },\n     { AF_NETLINK, 0 },\n     { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n     { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n   };\n   int last_allowed_family;\n   int i, r;\n   g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n \n   seccomp = seccomp_init (SCMP_ACT_ALLOW);\n   if (!seccomp)\n     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n \n   if (arch != NULL)\n     {\n       uint32_t arch_id = 0;\n       const uint32_t *extra_arches = NULL;\n \n       if (strcmp (arch, \"i386\") == 0)\n         {\n           arch_id = SCMP_ARCH_X86;\n         }\n       else if (strcmp (arch, \"x86_64\") == 0)\n         {\n           arch_id = SCMP_ARCH_X86_64;\n           extra_arches = seccomp_x86_64_extra_arches;\n         }\n       else if (strcmp (arch, \"arm\") == 0)\n         {\n           arch_id = SCMP_ARCH_ARM;\n         }\n #ifdef SCMP_ARCH_AARCH64\n       else if (strcmp (arch, \"aarch64\") == 0)\n         {\n           arch_id = SCMP_ARCH_AARCH64;\n           extra_arches = seccomp_aarch64_extra_arches;\n         }\n #endif\n \n       if (arch_id != 0)\n         {\n           r = seccomp_arch_add (seccomp, arch_id);\n           if (r < 0 && r != -EEXIST)\n             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n \n           if (multiarch && extra_arches != NULL)\n             {\n               for (i = 0; extra_arches[i] != 0; i++)\n                 {\n                   r = seccomp_arch_add (seccomp, extra_arches[i]);\n                   if (r < 0 && r != -EEXIST)\n                     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                 }\n             }\n         }\n     }\n \n \n   for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n     {\n       int scall = syscall_blocklist[i].scall;\n       int errnum = syscall_blocklist[i].errnum;\n \n       g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n \n       if (syscall_blocklist[i].arg)\n         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n       else\n         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n       if (r < 0 && r == -EFAULT )\n         return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n     }\n \n   if (!devel)\n     {\n       for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n         {\n           int scall = syscall_nondevel_blocklist[i].scall;\n           int errnum = syscall_nondevel_blocklist[i].errnum;\n \n           g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n \n           if (syscall_nondevel_blocklist[i].arg)\n             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);\n           else\n             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n \n           if (r < 0 && r == -EFAULT )\n             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n         }\n     }\n \n   last_allowed_family = -1;\n   for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n     {\n       int family = socket_family_allowlist[i].family;\n       int disallowed;\n \n       if (socket_family_allowlist[i].flags_mask != 0 &&\n           (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n         continue;\n \n       for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n         {\n           seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n         }\n       last_allowed_family = family;\n     }\n   seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n \n   if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n     return FALSE;\n \n   if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n \n   lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n \n   flatpak_bwrap_add_args_data_fd (bwrap,\n                                   \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n \n   return TRUE;\n }\n \n", "target": "// fix_start\n    {SCMP_SYS (chroot), EPERM},\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "project": "flatpak", "idx": 195308}
{"source": " gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)\n {\n     char *pos = inbuf;\n     char *lpos = NULL;\n     char *tline = NULL;\n     LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);\n// bug_start\n    LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);\n// bug_end\n     char *name = NULL;\n     char *selector = NULL;\n     char *host = NULL;\n     char *port = NULL;\n     char *escaped_selector = NULL;\n     const char *icon_url = NULL;\n     char gtype;\n     StoreEntry *entry = NULL;\n \n// bug_start\n    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n// bug_end\n     memset(line, '\\0', TEMP_BUF_SIZE);\n \n     entry = gopherState->entry;\n \n     if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {\n         char *html_url = html_quote(entry->url());\n         gopherHTMLHeader(entry, \"Gopher Index %s\", html_url);\n         storeAppendPrintf(entry,\n                           \"<p>This is a searchable Gopher index. Use the search\\n\"\n                           \"function of your browser to enter search terms.\\n\"\n                           \"<ISINDEX>\\n\");\n         gopherHTMLFooter(entry);\n         entry->flush();\n         gopherState->HTML_header_added = 1;\n \n         return;\n     }\n \n     if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {\n         char *html_url = html_quote(entry->url());\n         gopherHTMLHeader(entry, \"CSO Search of %s\", html_url);\n         storeAppendPrintf(entry,\n                           \"<P>A CSO database usually contains a phonebook or\\n\"\n                           \"directory.  Use the search function of your browser to enter\\n\"\n                           \"search terms.</P><ISINDEX>\\n\");\n         gopherHTMLFooter(entry);\n         entry->flush();\n         gopherState->HTML_header_added = 1;\n \n         return;\n     }\n \n// bug_start\n    String outbuf;\n// bug_end\n \n     if (!gopherState->HTML_header_added) {\n         if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)\n             gopherHTMLHeader(entry, \"CSO Search Result\", NULL);\n         else\n             gopherHTMLHeader(entry, \"Gopher Menu\", NULL);\n \n         outbuf.append (\"<PRE>\");\n \n         gopherState->HTML_header_added = 1;\n \n         gopherState->HTML_pre = 1;\n     }\n \n     while (pos < inbuf + len) {\n         int llen;\n         int left = len - (pos - inbuf);\n         lpos = (char *)memchr(pos, '\\n', left);\n         if (lpos) {\n             ++lpos;\n             llen = lpos - pos;\n         } else {\n             llen = left;\n         }\n         if (gopherState->len + llen >= TEMP_BUF_SIZE) {\n             debugs(10, DBG_IMPORTANT, \"GopherHTML: Buffer overflow. Lost some data on URL: \" << entry->url()  );\n             llen = TEMP_BUF_SIZE - gopherState->len - 1;\n             gopherState->overflowed = true;\n         }\n         if (!lpos) {\n             memcpy(gopherState->buf + gopherState->len, pos, llen);\n             gopherState->len += llen;\n             break;\n         }\n         if (gopherState->len != 0) {\n             memcpy(line, gopherState->buf, gopherState->len);\n             memcpy(line + gopherState->len, pos, llen);\n             llen += gopherState->len;\n             gopherState->len = 0;\n         } else {\n             memcpy(line, pos, llen);\n         }\n         line[llen + 1] = '\\0';\n         pos = lpos;\n \n \n         if (*line == '.') {\n             memset(line, '\\0', TEMP_BUF_SIZE);\n             continue;\n         }\n \n         switch (gopherState->conversion) {\n \n         case GopherStateData::HTML_INDEX_RESULT:\n \n         case GopherStateData::HTML_DIR: {\n             tline = line;\n             gtype = *tline;\n             ++tline;\n             name = tline;\n             selector = strchr(tline, TAB);\n \n             if (selector) {\n                 *selector = '\\0';\n                 ++selector;\n                 host = strchr(selector, TAB);\n \n                 if (host) {\n                     *host = '\\0';\n                     ++host;\n                     port = strchr(host, TAB);\n \n                     if (port) {\n                         char *junk;\n                         port[0] = ':';\n                         junk = strchr(host, TAB);\n \n                         if (junk)\n                             *junk++ = 0;\n                         else {\n                             junk = strchr(host, '\\r');\n \n                             if (junk)\n                                 *junk++ = 0;\n                             else {\n                                 junk = strchr(host, '\\n');\n \n                                 if (junk)\n                                     *junk++ = 0;\n                             }\n                         }\n \n                         if ((port[1] == '0') && (!port[2]))\n                             port[0] = 0;\n                     }\n \n                     escaped_selector = xstrdup(rfc1738_escape_part(selector));\n \n                     switch (gtype) {\n \n                     case GOPHER_DIRECTORY:\n                         icon_url = mimeGetIconURL(\"internal-menu\");\n                         break;\n \n                     case GOPHER_HTML:\n \n                     case GOPHER_FILE:\n                         icon_url = mimeGetIconURL(\"internal-text\");\n                         break;\n \n                     case GOPHER_INDEX:\n \n                     case GOPHER_CSO:\n                         icon_url = mimeGetIconURL(\"internal-index\");\n                         break;\n \n                     case GOPHER_IMAGE:\n \n                     case GOPHER_GIF:\n \n                     case GOPHER_PLUS_IMAGE:\n                         icon_url = mimeGetIconURL(\"internal-image\");\n                         break;\n \n                     case GOPHER_SOUND:\n \n                     case GOPHER_PLUS_SOUND:\n                         icon_url = mimeGetIconURL(\"internal-sound\");\n                         break;\n \n                     case GOPHER_PLUS_MOVIE:\n                         icon_url = mimeGetIconURL(\"internal-movie\");\n                         break;\n \n                     case GOPHER_TELNET:\n \n                     case GOPHER_3270:\n                         icon_url = mimeGetIconURL(\"internal-telnet\");\n                         break;\n \n                     case GOPHER_BIN:\n \n                     case GOPHER_MACBINHEX:\n \n                     case GOPHER_DOSBIN:\n \n                     case GOPHER_UUENCODED:\n                         icon_url = mimeGetIconURL(\"internal-binary\");\n                         break;\n \n                     case GOPHER_INFO:\n                         icon_url = NULL;\n                         break;\n \n                     case GOPHER_WWW:\n                         icon_url = mimeGetIconURL(\"internal-link\");\n                         break;\n \n                     default:\n                         icon_url = mimeGetIconURL(\"internal-unknown\");\n                         break;\n                     }\n \n// bug_start\n                    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n\n// bug_end\n                     if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {\n                         if (strlen(escaped_selector) != 0)\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n// bug_end\n                                      icon_url, escaped_selector, rfc1738_escape_part(host),\n                                      *port ? \":\" : \"\", port, html_quote(name));\n                         else\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n// bug_end\n                                      icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                      port, html_quote(name));\n \n                     } else if (gtype == GOPHER_INFO) {\n// bug_start\n                        snprintf(tmpbuf, TEMP_BUF_SIZE, \"\\t%s\\n\", html_quote(name));\n// bug_end\n                     } else {\n                         if (strncmp(selector, \"GET /\", 5) == 0) {\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n// bug_end\n                                      icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n                         } else if (gtype == GOPHER_WWW) {\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"%s\\\">%s</A>\\n\",\n// bug_end\n                                      icon_url, rfc1738_escape_unescaped(selector), html_quote(name));\n                         } else {\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n// bug_end\n                                      icon_url, host, gtype, escaped_selector, html_quote(name));\n                         }\n                     }\n \n                     safe_free(escaped_selector);\n// bug_start\n                    outbuf.append(tmpbuf);\n// bug_end\n                 } else {\n                     memset(line, '\\0', TEMP_BUF_SIZE);\n                     continue;\n                 }\n             } else {\n                 memset(line, '\\0', TEMP_BUF_SIZE);\n                 continue;\n             }\n \n             break;\n             }\n \n         case GopherStateData::HTML_CSO_RESULT: {\n             if (line[0] == '-') {\n                 int code, recno;\n                 char *s_code, *s_recno, *result;\n \n                 s_code = strtok(line + 1, \":\\n\");\n                 s_recno = strtok(NULL, \":\\n\");\n                 result = strtok(NULL, \"\\n\");\n \n                 if (!result)\n                     break;\n \n                 code = atoi(s_code);\n \n                 recno = atoi(s_recno);\n \n                 if (code != 200)\n                     break;\n \n                 if (gopherState->cso_recno != recno) {\n// bug_start\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n// bug_end\n                     gopherState->cso_recno = recno;\n                 } else {\n// bug_start\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"%s\\n\", html_quote(result));\n                }\n\n                outbuf.append(tmpbuf);\n// bug_end\n                 break;\n             } else {\n                 int code;\n                 char *s_code, *result;\n \n                 s_code = strtok(line, \":\");\n                 result = strtok(NULL, \"\\n\");\n \n                 if (!result)\n                     break;\n \n                 code = atoi(s_code);\n \n                 switch (code) {\n \n                 case 200: {\n                     break;\n                 }\n \n                 case 102:\n \n                 case 501:\n \n                 case 502: {\n// bug_start\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n                    outbuf.append(tmpbuf);\n// bug_end\n                     break;\n                 }\n \n                 }\n             }\n \n             break;\n             }\n         default:\n             break;\n \n         }\n \n     }\n \n// bug_start\n    if (outbuf.size() > 0) {\n        entry->append(outbuf.rawBuf(), outbuf.size());\n// bug_end\n         entry->flush();\n     }\n \n// bug_start\n    outbuf.clean();\n// bug_end\n     return;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    SBuf outbuf;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n// fix_end\n// fix_start\n                        outbuf.appendf(\"\\t%s\\n\", html_quote(name));\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n// fix_end\n// fix_start\n                    outbuf.appendf(\"%s\\n\", html_quote(result));\n                }\n\n// fix_end\n// fix_start\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n// fix_end\n// fix_start\n    if (outbuf.length() > 0) {\n        entry->append(outbuf.rawContent(), outbuf.length());\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "cve": "CVE-2021-46784", "cve_desc": "In Squid 3.x through 3.5.28, 4.x through 4.17, and 5.x before 5.6, due to improper buffer management, a Denial of Service can occur when processing long Gopher server responses.", "project": "squid", "idx": 195309}
{"source": " char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n {\n \tu32 i, j, len;\n \tchar *sOK;\n// bug_start\n\tchar szLineConv[1024];\n// bug_end\n \tunsigned short *sptr;\n \n \tmemset(szLine, 0, sizeof(char)*lineSize);\n \tsOK = gf_fgets(szLine, lineSize, txt_in);\n \tif (!sOK) return NULL;\n \tif (unicode_type<=1) {\n \t\tj=0;\n \t\tlen = (u32) strlen(szLine);\n \t\tfor (i=0; i<len; i++) {\n \t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n \t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n \t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n \t\t\t\t\tj++;\n \t\t\t\t\tszLine[i] &= 0xbf;\n \t\t\t\t}\n \t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n \t\t\t\t}\n \t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n \t\t\t\t}\n \t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n \t\t\t\t} else {\n \t\t\t\t\ti+=1;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \t\t\tszLineConv[j] = szLine[i];\n \t\t\tj++;\n \t\t}\n \t\tszLineConv[j] = 0;\n \t\tstrcpy(szLine, szLineConv);\n \t\treturn sOK;\n \t}\n \n #ifdef GPAC_BIG_ENDIAN\n \tif (unicode_type==3)\n #else\n \tif (unicode_type==2)\n #endif\n \t{\n \t\ti=0;\n \t\twhile (1) {\n \t\t\tchar c;\n \t\t\tif (!szLine[i] && !szLine[i+1]) break;\n \t\t\tc = szLine[i+1];\n \t\t\tszLine[i+1] = szLine[i];\n \t\t\tszLine[i] = c;\n \t\t\ti+=2;\n \t\t}\n \t}\n \tsptr = (u16 *)szLine;\n// bug_start\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n// bug_end\n \tszLineConv[i] = 0;\n \tstrcpy(szLine, szLineConv);\n \tif (unicode_type==3) gf_fgetc(txt_in);\n \treturn sOK;\n }\n \n", "target": "// fix_start\n\tchar szLineConv[2048];\n// fix_end\n// fix_start\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2021-40574", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "project": "gpac", "idx": 195328}
{"source": " Status ConcatShapeHelper(InferenceContext* c, int start_value_index,\n                          int end_value_index, int dim_index) {\n   ShapeHandle unused;\n   TF_RETURN_IF_ERROR(c->WithRank(c->input(dim_index), 0, &unused));\n   const Tensor* concat_dim_t = c->input_tensor(dim_index);\n   if (concat_dim_t == nullptr) {\n \n     int32_t rank = InferenceContext::kUnknownRank;\n     for (int i = start_value_index; i < end_value_index; ++i) {\n       if (rank == InferenceContext::kUnknownRank) rank = c->Rank(c->input(i));\n       if (rank != InferenceContext::kUnknownRank) {\n         break;\n       }\n     }\n     if (rank == InferenceContext::kUnknownRank) {\n       c->set_output(0, c->UnknownShape());\n       return Status::OK();\n     } else if (rank == 0) {\n       return errors::InvalidArgument(\n           \"Can't concatenate scalars (use tf.stack instead)\");\n     } else {\n       for (int i = start_value_index; i < end_value_index; ++i) {\n         TF_RETURN_IF_ERROR(c->WithRank(c->input(i), rank, &unused));\n       }\n     }\n     std::vector<DimensionHandle> dims;\n     dims.reserve(rank);\n     for (int i = 0; i < rank; ++i) dims.push_back(c->UnknownDim());\n     c->set_output(0, c->MakeShape(dims));\n     return Status::OK();\n   }\n \n   int64_t concat_dim;\n   if (concat_dim_t->dtype() == DT_INT32) {\n     concat_dim = static_cast<int64_t>(concat_dim_t->flat<int32>()(0));\n   } else {\n     concat_dim = concat_dim_t->flat<int64_t>()(0);\n   }\n \n// bug_start\n  const int min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n// bug_end\n \n   ShapeHandle output_before;\n   ShapeHandle output_after;\n \n   ShapeHandle input = c->input(end_value_index - 1);\n   TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n   TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &output_before));\n   DimensionHandle output_middle = c->Dim(input, concat_dim);\n   if (concat_dim == -1) {\n     output_after = c->Scalar();\n   } else {\n     TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &output_after));\n   }\n \n   for (int i = end_value_index - 2; i >= start_value_index; --i) {\n     ShapeHandle before;\n     ShapeHandle after;\n     input = c->input(i);\n     TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n     TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &before));\n     DimensionHandle middle = c->Dim(input, concat_dim);\n     if (concat_dim == -1) {\n       after = c->Scalar();\n     } else {\n       TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &after));\n     }\n \n     TF_RETURN_IF_ERROR(c->Merge(before, output_before, &output_before));\n     TF_RETURN_IF_ERROR(c->Add(output_middle, middle, &output_middle));\n     TF_RETURN_IF_ERROR(c->Merge(after, output_after, &output_after));\n   }\n \n   ShapeHandle s;\n   TF_RETURN_IF_ERROR(\n       c->Concatenate(output_before, c->Vector(output_middle), &s));\n   TF_RETURN_IF_ERROR(c->Concatenate(s, output_after, &s));\n   c->set_output(0, s);\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  const int64 min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n// fix_end\n", "cwe": "CWE-843", "cwe_name": "Access of Resource Using Incompatible Type ('Type Confusion')", "cve": "CVE-2022-21731", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of shape inference for `ConcatV2` can be used to trigger a denial of service attack via a segfault caused by a type confusion. The `axis` argument is translated into `concat_dim` in the `ConcatShapeHelper` helper function. Then, a value for `min_rank` is computed based on `concat_dim`. This is then used to validate that the `values` tensor has at least the required rank. However, `WithRankAtLeast` receives the lower bound as a 64-bits value and then compares it against the maximum 32-bits integer value that could be represented. Due to the fact that `min_rank` is a 32-bits value and the value of `axis`, the `rank` argument is a negative value, so the error check is bypassed. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195331}
{"source": " GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n {\n \tu32 item_count, extent_count, i, j;\n \tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n \n \tISOM_DECREASE_SIZE(ptr, 2)\n \tptr->offset_size = gf_bs_read_int(bs, 4);\n \tptr->length_size = gf_bs_read_int(bs, 4);\n \tptr->base_offset_size = gf_bs_read_int(bs, 4);\n \tif (ptr->version == 1 || ptr->version == 2) {\n \t\tptr->index_size = gf_bs_read_int(bs, 4);\n \t} else {\n \t\tgf_bs_read_int(bs, 4);\n \t}\n \tif (ptr->version < 2) {\n \t\tISOM_DECREASE_SIZE(ptr, 2)\n \t\titem_count = gf_bs_read_u16(bs);\n \t} else {\n \t\tISOM_DECREASE_SIZE(ptr, 4)\n \t\titem_count = gf_bs_read_u32(bs);\n \t}\n \n \tfor (i = 0; i < item_count; i++) {\n// bug_start\n\t\tGF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));\n// bug_end\n \t\tif (!location_entry) return GF_OUT_OF_MEM;\n \n \t\tgf_list_add(ptr->location_entries, location_entry);\n \t\tif (ptr->version < 2) {\n \t\t\tISOM_DECREASE_SIZE(ptr, 2)\n \t\t\tlocation_entry->item_ID = gf_bs_read_u16(bs);\n \t\t} else {\n \t\t\tISOM_DECREASE_SIZE(ptr, 4)\n \t\t\tlocation_entry->item_ID = gf_bs_read_u32(bs);\n \t\t}\n \t\tif (ptr->version == 1 || ptr->version == 2) {\n \t\t\tISOM_DECREASE_SIZE(ptr, 2)\n \t\t\tlocation_entry->construction_method = gf_bs_read_u16(bs);\n \t\t}\n \t\telse {\n \t\t\tlocation_entry->construction_method = 0;\n \t\t}\n \t\tISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )\n \t\tlocation_entry->data_reference_index = gf_bs_read_u16(bs);\n \t\tlocation_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);\n #ifndef GPAC_DISABLE_ISOM_WRITE\n \t\tlocation_entry->original_base_offset = location_entry->base_offset;\n #endif\n \n \t\tISOM_DECREASE_SIZE(ptr, 2)\n \t\textent_count = gf_bs_read_u16(bs);\n \t\tlocation_entry->extent_entries = gf_list_new();\n \t\tfor (j = 0; j < extent_count; j++) {\n// bug_start\n\t\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));\n// bug_end\n \t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n \n \t\t\tgf_list_add(location_entry->extent_entries, extent_entry);\n \t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n \t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->index_size)\n \t\t\t\textent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);\n \t\t\t}\n \t\t\telse {\n \t\t\t\textent_entry->extent_index = 0;\n \t\t\t}\n \t\t\tISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )\n \n \t\t\textent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);\n \t\t\textent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);\n #ifndef GPAC_DISABLE_ISOM_WRITE\n \t\t\textent_entry->original_extent_offset = extent_entry->extent_offset;\n #endif\n \t\t}\n \t}\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\tGF_ItemLocationEntry *location_entry;\n\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);\n// fix_end\n// fix_start\n\t\t\tGF_ItemExtentEntry *extent_entry;\n\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2021-40573", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_list_del function in list.c, which allows attackers to cause a denial of service.", "project": "gpac", "idx": 195334}
{"source": "   void Compute(OpKernelContext *ctx) override {\n     const Tensor *indices_t, *values_t, *shape_t, *dense_t;\n     OP_REQUIRES_OK(ctx, ctx->input(\"sp_indices\", &indices_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"sp_values\", &values_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"sp_shape\", &shape_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"dense\", &dense_t));\n \n     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),\n                 errors::InvalidArgument(\n                     \"Input sp_indices should be a matrix but received shape: \",\n                     indices_t->shape().DebugString()));\n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(values_t->shape()) &&\n                     TensorShapeUtils::IsVector(shape_t->shape()),\n                 errors::InvalidArgument(\n                     \"Inputs sp_values and sp_shape should be vectors \"\n                     \"but received shapes: \",\n                     values_t->shape().DebugString(), \" and \",\n                     shape_t->shape().DebugString()));\n     OP_REQUIRES(\n         ctx, TensorShapeUtils::IsVector(shape_t->shape()),\n         errors::InvalidArgument(\"Input sp_shape must be a vector. Got: \",\n                                 shape_t->shape().DebugString()));\n     OP_REQUIRES(\n         ctx, values_t->dim_size(0) == indices_t->dim_size(0),\n         errors::InvalidArgument(\n             \"The first dimension of values and indices should match. (\",\n             values_t->dim_size(0), \" vs. \", indices_t->dim_size(0), \")\"));\n     OP_REQUIRES(\n         ctx, shape_t->shape().dim_size(0) == indices_t->shape().dim_size(1),\n         errors::InvalidArgument(\n             \"Number of dimensions must match second dimension of indices. \",\n             \"Got \", shape_t->shape().dim_size(0),\n             \" dimensions, indices shape: \", indices_t->shape().DebugString()));\n     OP_REQUIRES(ctx, shape_t->NumElements() > 0,\n                 errors::InvalidArgument(\n                     \"The shape argument requires at least one element.\"));\n \n     const auto indices_mat = indices_t->matrix<int64_t>();\n     const auto shape_vec = shape_t->vec<int64_t>();\n// bug_start\n    const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));\n// bug_end\n     const auto rhs_dims = BCast::FromShape(dense_t->shape());\n     BCast b(lhs_dims, rhs_dims, false);\n \n     auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {\n       if (lhs.size() < rhs.size()) return false;\n       for (size_t i = 0; i < rhs.size(); ++i) {\n         if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;\n       }\n       return true;\n     };\n     OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),\n                 errors::InvalidArgument(\n                     \"SparseDenseBinaryOpShared broadcasts dense to sparse \"\n                     \"only; got incompatible shapes: [\",\n                     absl::StrJoin(lhs_dims, \",\"), \"] vs. [\",\n                     absl::StrJoin(rhs_dims, \",\"), \"]\"));\n \n     Tensor *output_values = nullptr;\n     Tensor dense_gathered;\n     const int64_t nnz = indices_t->dim_size(0);\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(0, TensorShape({nnz}), &output_values));\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),\n                                 &dense_gathered));\n     bool op_is_div = false;\n     if (absl::StrContains(ctx->op_kernel().type_string_view(), \"Div\")) {\n       op_is_div = true;\n     }\n     auto dense_gathered_flat = dense_gathered.flat<T>();\n     const int ndims = lhs_dims.size();\n     switch (ndims) {\n #define CASE(NDIM)                                                             \\\n   case NDIM: {                                                                 \\\n     TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \\\n         dense_t->shaped<T, NDIM>(b.y_reshape())                                \\\n             .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \\\n     Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \\\n     bool indices_valid = true;                                                 \\\n     for (int i = 0; i < nnz; ++i) {                                            \\\n       for (int d = 0; d < NDIM; ++d) {                                         \\\n         idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \\\n         if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \\\n           indices_valid = false;                                               \\\n         }                                                                      \\\n       }                                                                        \\\n       OP_REQUIRES(                                                             \\\n           ctx, indices_valid,                                                  \\\n           errors::InvalidArgument(\"Provided indices are out-of-bounds w.r.t. \" \\\n                                   \"dense side with broadcasted shape\"));       \\\n       dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \\\n       if (op_is_div) {                                                         \\\n         OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \\\n                     errors::InvalidArgument(                                   \\\n                         \"SparseDenseCwiseDiv cannot divide by zero,\"           \\\n                         \"but input dense tensor contains zero \"));             \\\n       }                                                                        \\\n     }                                                                          \\\n     break;                                                                     \\\n   }\n \n       CASE(1);\n       CASE(2);\n       CASE(3);\n       CASE(4);\n       CASE(5);\n       default:\n         OP_REQUIRES(\n             ctx, false,\n             errors::InvalidArgument(\"Only tensors with ranks between 1 and 5 \"\n                                     \"are currently supported.  Tensor rank: \",\n                                     ndims));\n #undef CASE\n     }\n \n     output_values->flat<T>().device(ctx->eigen_device<Device>()) =\n         values_t->flat<T>().binaryExpr(dense_gathered_flat,\n                                        typename Functor::func());\n   }\n \n", "target": "// fix_start\n    TensorShape lhs_shape;\n    OP_REQUIRES_OK(ctx, TensorShape::BuildTensorShape(shape_vec, &lhs_shape));\n    const auto lhs_dims = BCast::FromShape(lhs_shape);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2022-23567", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementations of `Sparse*Cwise*` ops are vulnerable to integer overflows. These can be used to trigger large allocations (so, OOM based denial of service) or `CHECK`-fails when building new `TensorShape` objects (so, assert failures based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195340}
{"source": "   void Compute(OpKernelContext* context) override {\n     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n         ConstEigenMatrixMap;\n     typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n         EigenDoubleMatrixMap;\n \n     const Tensor& orig_input_tensor_shape = context->input(0);\n     OP_REQUIRES(context,\n                 orig_input_tensor_shape.dims() == 1 &&\n                     orig_input_tensor_shape.NumElements() == 4,\n                 errors::InvalidArgument(\"original input tensor shape must be\"\n                                         \"1-dimensional and 4 elements\"));\n     const Tensor& out_backprop = context->input(1);\n     const Tensor& row_seq_tensor = context->input(2);\n     const Tensor& col_seq_tensor = context->input(3);\n \n     const int64_t out_batch = out_backprop.dim_size(0);\n     const int64_t out_rows = out_backprop.dim_size(1);\n     const int64_t out_cols = out_backprop.dim_size(2);\n     const int64_t out_depth = out_backprop.dim_size(3);\n \n     OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                 errors::InvalidArgument(\"Given out_backprop shape \",\n                                         out_backprop.shape().DebugString(),\n                                         \", row_seq_tensor must have at least \",\n                                         out_rows + 1, \" elements, but got \",\n                                         row_seq_tensor.NumElements()));\n     OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                 errors::InvalidArgument(\"Given out_backprop shape \",\n                                         out_backprop.shape().DebugString(),\n                                         \", col_seq_tensor must have at least \",\n                                         out_cols + 1, \" elements, but got \",\n                                         col_seq_tensor.NumElements()));\n \n     auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>();\n     auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>();\n     auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>();\n \n     const int64_t in_batch = orig_input_tensor_shape_flat(0);\n     const int64_t in_rows = orig_input_tensor_shape_flat(1);\n     const int64_t in_cols = orig_input_tensor_shape_flat(2);\n     const int64_t in_depth = orig_input_tensor_shape_flat(3);\n     OP_REQUIRES(\n         context, in_batch != 0,\n         errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n     OP_REQUIRES(\n         context, in_rows != 0,\n         errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n     OP_REQUIRES(\n         context, in_cols != 0,\n         errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n     OP_REQUIRES(\n         context, in_depth != 0,\n         errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n \n     constexpr int tensor_in_and_out_dims = 4;\n     TensorShape in_shape;\n     for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n       in_shape.AddDim(orig_input_tensor_shape_flat(i));\n     }\n \n     Tensor in_backprop_tensor_temp;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                 {0}, DataTypeToEnum<double>::v(), in_shape,\n                                 &in_backprop_tensor_temp));\n     in_backprop_tensor_temp.flat<double>().setZero();\n     EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n         in_backprop_tensor_temp.flat<double>().data(), in_depth,\n         in_cols * in_rows * in_batch);\n     ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                          out_depth,\n                                          out_cols * out_rows * out_batch);\n     const int64_t in_max_row_index = in_rows - 1;\n     const int64_t in_max_col_index = in_cols - 1;\n     for (int64_t b = 0; b < out_batch; ++b) {\n       for (int64_t r = 0; r < out_rows; ++r) {\n         const int64_t in_row_start = row_seq_tensor_flat(r);\n// bug_start\n// bug_end\n         int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                           : row_seq_tensor_flat(r + 1) - 1;\n         in_row_end = std::min(in_row_end, in_max_row_index);\n// bug_start\n// bug_end\n         for (int64_t c = 0; c < out_cols; ++c) {\n           const int64_t in_col_start = col_seq_tensor_flat(c);\n           int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                             : col_seq_tensor_flat(c + 1) - 1;\n           in_col_end = std::min(in_col_end, in_max_col_index);\n \n// bug_start\n// bug_end\n           const int64_t num_elements_in_pooling_cell =\n               (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n           const int64_t out_index = (b * out_rows + r) * out_cols + c;\n           for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n             for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n               const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n               for (int64_t d = 0; d < out_depth; ++d) {\n                 const double out_backprop_element = static_cast<double>(\n                     out_backprop_mat.coeffRef(d, out_index));\n                 double& in_backprop_ref =\n                     in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                 in_backprop_ref +=\n                     out_backprop_element / num_elements_in_pooling_cell;\n               }\n             }\n           }\n         }\n       }\n     }\n \n     Tensor* in_backprop_tensor = nullptr;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                 {0}, 0, in_shape, &in_backprop_tensor));\n     auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n     auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n     for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n       in_backprop_tensor_flat(i) =\n           static_cast<T>(in_backprop_tensor_temp_flat(i));\n     }\n   }\n \n", "target": "// fix_start\n\n// fix_end\n// fix_start\n        OP_REQUIRES(context, in_row_start >= 0 && in_row_end >= 0,\n                    errors::InvalidArgument(\n                        \"Row sequence tensor values must not be negative, got \",\n                        row_seq_tensor_flat));\n\n// fix_end\n// fix_start\n          OP_REQUIRES(\n              context, in_col_start >= 0 && in_col_end >= 0,\n              errors::InvalidArgument(\n                  \"Column sequence tensor values must not be negative, got \",\n                  col_seq_tensor_flat));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-21730", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `FractionalAvgPoolGrad` does not consider cases where the input tensors are invalid allowing an attacker to read from outside of bounds of heap. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195343}
{"source": " flatpak_dir_ensure_bundle_remote (FlatpakDir         *self,\n                                   GFile              *file,\n                                   GBytes             *extra_gpg_data,\n                                   FlatpakDecomposed **out_ref,\n                                   char              **out_checksum,\n                                   char              **out_metadata,\n                                   gboolean           *out_created_remote,\n                                   GCancellable       *cancellable,\n                                   GError            **error)\n {\n   g_autoptr(FlatpakDecomposed) ref = NULL;\n   gboolean created_remote = FALSE;\n   g_autoptr(GBytes) deploy_data = NULL;\n   g_autoptr(GVariant) metadata = NULL;\n   g_autofree char *origin = NULL;\n   g_autofree char *fp_metadata = NULL;\n   g_autofree char *basename = NULL;\n   g_autoptr(GBytes) included_gpg_data = NULL;\n   GBytes *gpg_data = NULL;\n   g_autofree char *to_checksum = NULL;\n   g_autofree char *remote = NULL;\n   g_autofree char *collection_id = NULL;\n \n   if (!flatpak_dir_ensure_repo (self, cancellable, error))\n     return NULL;\n \n   metadata = flatpak_bundle_load (file, &to_checksum,\n                                   &ref,\n                                   &origin,\n                                   NULL, &fp_metadata, NULL,\n                                   &included_gpg_data,\n                                   &collection_id,\n                                   error);\n   if (metadata == NULL)\n     return NULL;\n// bug_start\n// bug_end\n \n   gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data;\n \n   deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n   if (deploy_data != NULL)\n     {\n       remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n \n       if (gpg_data != NULL)\n         {\n           g_autoptr(GKeyFile) new_config = NULL;\n \n           new_config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n \n           if (!flatpak_dir_modify_remote (self, remote, new_config,\n                                           gpg_data, cancellable, error))\n             return NULL;\n         }\n     }\n   else\n     {\n       g_autofree char *id = flatpak_decomposed_dup_id (ref);\n       basename = g_file_get_basename (file);\n       remote = flatpak_dir_create_origin_remote (self,\n                                                  origin,\n                                                  id,\n                                                  basename,\n                                                  flatpak_decomposed_get_ref (ref),\n                                                  gpg_data,\n                                                  collection_id,\n                                                  &created_remote,\n                                                  cancellable,\n                                                  error);\n       if (remote == NULL)\n         return NULL;\n     }\n \n   if (out_created_remote)\n     *out_created_remote = created_remote;\n \n   if (out_ref)\n     *out_ref = g_steal_pointer (&ref);\n \n   if (out_checksum)\n     *out_checksum = g_steal_pointer (&to_checksum);\n \n   if (out_metadata)\n     *out_metadata = g_steal_pointer (&fp_metadata);\n \n \n   return g_steal_pointer (&remote);\n }\n \n", "target": "// fix_start\n\n  if (out_metadata && fp_metadata == NULL)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, \"No metadata in bundler header\");\n      return NULL;\n    }\n// fix_end\n", "cwe": "CWE-276", "cwe_name": "Incorrect Default Permissions", "cve": "CVE-2021-43860", "cve_desc": "Flatpak is a Linux application sandboxing and distribution framework. Prior to versions 1.12.3 and 1.10.6, Flatpak doesn't properly validate that the permissions displayed to the user for an app at install time match the actual permissions granted to the app at runtime, in the case that there's a null byte in the metadata file of an app. Therefore apps can grant themselves permissions without the consent of the user. Flatpak shows permissions to the user during install by reading them from the \"xa.metadata\" key in the commit metadata. This cannot contain a null terminator, because it is an untrusted GVariant. Flatpak compares these permissions to the *actual* metadata, from the \"metadata\" file to ensure it wasn't lied to. However, the actual metadata contents are loaded in several places where they are read as simple C-style strings. That means that, if the metadata file includes a null terminator, only the content of the file from *before* the terminator gets compared to xa.metadata. Thus, any permissions that appear in the metadata file after a null terminator are applied at runtime but not shown to the user. So maliciously crafted apps can give themselves hidden permissions. Users who have Flatpaks installed from untrusted sources are at risk in case the Flatpak has a maliciously crafted metadata file, either initially or in an update. This issue is patched in versions 1.12.3 and 1.10.6. As a workaround, users can manually check the permissions of installed apps by checking the metadata file or the xa.metadata key on the commit metadata.", "project": "flatpak", "idx": 195385}
{"source": " PQconnectPoll(PGconn *conn)\n {\n \tbool\t\treset_connection_state_machine = false;\n \tbool\t\tneed_new_connection = false;\n \tPGresult   *res;\n \tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n \tint\t\t\toptval;\n \n \tif (conn == NULL)\n \t\treturn PGRES_POLLING_FAILED;\n \n \tswitch (conn->status)\n \t{\n \t\tcase CONNECTION_BAD:\n \t\t\treturn PGRES_POLLING_FAILED;\n \t\tcase CONNECTION_OK:\n \t\t\treturn PGRES_POLLING_OK;\n \n \t\tcase CONNECTION_AWAITING_RESPONSE:\n \t\tcase CONNECTION_AUTH_OK:\n \t\tcase CONNECTION_CHECK_WRITABLE:\n \t\tcase CONNECTION_CONSUME:\n \t\tcase CONNECTION_CHECK_STANDBY:\n \t\t\t{\n \t\t\t\tint\t\t\tn = pqReadData(conn);\n \n \t\t\t\tif (n < 0)\n \t\t\t\t\tgoto error_return;\n \t\t\t\tif (n == 0)\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \n \t\t\t\tbreak;\n \t\t\t}\n \n \t\tcase CONNECTION_STARTED:\n \t\tcase CONNECTION_MADE:\n \t\t\tbreak;\n \n \t\tcase CONNECTION_SSL_STARTUP:\n \t\tcase CONNECTION_NEEDED:\n \t\tcase CONNECTION_GSS_STARTUP:\n \t\tcase CONNECTION_CHECK_TARGET:\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t libpq_gettext(\"invalid connection state, probably indicative of memory corruption\\n\"));\n \t\t\tgoto error_return;\n \t}\n \n \n keep_going:\n \n \tif (conn->try_next_addr)\n \t{\n \t\tif (conn->addr_cur && conn->addr_cur->ai_next)\n \t\t{\n \t\t\tconn->addr_cur = conn->addr_cur->ai_next;\n \t\t\treset_connection_state_machine = true;\n \t\t}\n \t\telse\n \t\t\tconn->try_next_host = true;\n \t\tconn->try_next_addr = false;\n \t}\n \n \tif (conn->try_next_host)\n \t{\n \t\tpg_conn_host *ch;\n \t\tstruct addrinfo hint;\n \t\tint\t\t\tthisport;\n \t\tint\t\t\tret;\n \t\tchar\t\tportstr[MAXPGPATH];\n \n \t\tif (conn->whichhost + 1 < conn->nconnhost)\n \t\t\tconn->whichhost++;\n \t\telse\n \t\t{\n \t\t\tif (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&\n \t\t\t\tconn->nconnhost > 0)\n \t\t\t{\n \t\t\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;\n \t\t\t\tconn->whichhost = 0;\n \t\t\t}\n \t\t\telse\n \t\t\t\tgoto error_return;\n \t\t}\n \n \t\trelease_conn_addrinfo(conn);\n \n \t\tch = &conn->connhost[conn->whichhost];\n \n \t\tMemSet(&hint, 0, sizeof(hint));\n \t\thint.ai_socktype = SOCK_STREAM;\n \t\tconn->addrlist_family = hint.ai_family = AF_UNSPEC;\n \n \t\tif (ch->port == NULL || ch->port[0] == '\\0')\n \t\t\tthisport = DEF_PGPORT;\n \t\telse\n \t\t{\n \t\t\tif (!parse_int_param(ch->port, &thisport, conn, \"port\"))\n \t\t\t\tgoto error_return;\n \n \t\t\tif (thisport < 1 || thisport > 65535)\n \t\t\t{\n \t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t  libpq_gettext(\"invalid port number: \\\"%s\\\"\\n\"),\n \t\t\t\t\t\t\t\t  ch->port);\n \t\t\t\tgoto keep_going;\n \t\t\t}\n \t\t}\n \t\tsnprintf(portstr, sizeof(portstr), \"%d\", thisport);\n \n \t\tswitch (ch->type)\n \t\t{\n \t\t\tcase CHT_HOST_NAME:\n \t\t\t\tret = pg_getaddrinfo_all(ch->host, portstr, &hint,\n \t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n \t\t\t\tif (ret || !conn->addrlist)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate host name \\\"%s\\\" to address: %s\\n\"),\n \t\t\t\t\t\t\t\t\t  ch->host, gai_strerror(ret));\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CHT_HOST_ADDRESS:\n \t\t\t\thint.ai_flags = AI_NUMERICHOST;\n \t\t\t\tret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,\n \t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n \t\t\t\tif (ret || !conn->addrlist)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not parse network address \\\"%s\\\": %s\\n\"),\n \t\t\t\t\t\t\t\t\t  ch->hostaddr, gai_strerror(ret));\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CHT_UNIX_SOCKET:\n #ifdef HAVE_UNIX_SOCKETS\n \t\t\t\tconn->addrlist_family = hint.ai_family = AF_UNIX;\n \t\t\t\tUNIXSOCK_PATH(portstr, thisport, ch->host);\n \t\t\t\tif (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\\n\"),\n \t\t\t\t\t\t\t\t\t  portstr,\n \t\t\t\t\t\t\t\t\t  (int) (UNIXSOCK_PATH_BUFLEN - 1));\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \n \t\t\t\tret = pg_getaddrinfo_all(NULL, portstr, &hint,\n \t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n \t\t\t\tif (ret || !conn->addrlist)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate Unix-domain socket path \\\"%s\\\" to address: %s\\n\"),\n \t\t\t\t\t\t\t\t\t  portstr, gai_strerror(ret));\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n #else\n \t\t\t\tAssert(false);\n #endif\n \t\t\t\tbreak;\n \t\t}\n \n \t\tconn->addr_cur = conn->addrlist;\n \t\treset_connection_state_machine = true;\n \t\tconn->try_next_host = false;\n \t}\n \n \tif (reset_connection_state_machine)\n \t{\n \t\tconn->pversion = PG_PROTOCOL(3, 0);\n \t\tconn->send_appname = true;\n #ifdef USE_SSL\n \t\tconn->allow_ssl_try = (conn->sslmode[0] != 'd');\n \t\tconn->wait_ssl_try = (conn->sslmode[0] == 'a');\n #endif\n #ifdef ENABLE_GSS\n \t\tconn->try_gss = (conn->gssencmode[0] != 'd');\n #endif\n \n \t\treset_connection_state_machine = false;\n \t\tneed_new_connection = true;\n \t}\n \n \tif (need_new_connection)\n \t{\n \t\tpqDropConnection(conn, true);\n \n \t\tpqDropServerData(conn);\n \n \t\tconn->asyncStatus = PGASYNC_IDLE;\n \t\tconn->xactStatus = PQTRANS_IDLE;\n \t\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n \t\tpqClearAsyncResult(conn);\n \n \t\tconn->status = CONNECTION_NEEDED;\n \n \t\tneed_new_connection = false;\n \t}\n \n \tswitch (conn->status)\n \t{\n \t\tcase CONNECTION_NEEDED:\n \t\t\t{\n \t\t\t\t{\n \t\t\t\t\tstruct addrinfo *addr_cur = conn->addr_cur;\n \t\t\t\t\tchar\t\thost_addr[NI_MAXHOST];\n \n \t\t\t\t\tif (addr_cur == NULL)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->try_next_host = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \n \t\t\t\t\tmemcpy(&conn->raddr.addr, addr_cur->ai_addr,\n \t\t\t\t\t\t   addr_cur->ai_addrlen);\n \t\t\t\t\tconn->raddr.salen = addr_cur->ai_addrlen;\n \n \t\t\t\t\tif (conn->connip != NULL)\n \t\t\t\t\t{\n \t\t\t\t\t\tfree(conn->connip);\n \t\t\t\t\t\tconn->connip = NULL;\n \t\t\t\t\t}\n \t\t\t\t\tgetHostaddr(conn, host_addr, NI_MAXHOST);\n \t\t\t\t\tif (host_addr[0])\n \t\t\t\t\t\tconn->connip = strdup(host_addr);\n \n \t\t\t\t\tconn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);\n \t\t\t\t\tif (conn->sock == PGINVALID_SOCKET)\n \t\t\t\t\t{\n \t\t\t\t\t\tint\t\t\terrorno = SOCK_ERRNO;\n \n \t\t\t\t\t\tif (addr_cur->ai_next != NULL ||\n \t\t\t\t\t\t\tconn->whichhost + 1 < conn->nconnhost)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tconn->try_next_addr = true;\n \t\t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t\t}\n \t\t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not create socket: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \n \t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n \n \t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n \t\t\t\t\t{\n \t\t\t\t\t\tif (!connectNoDelay(conn))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tconn->try_next_addr = true;\n \t\t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (!pg_set_noblock(conn->sock))\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to nonblocking mode: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\tconn->try_next_addr = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \n #ifdef F_SETFD\n \t\t\t\t\tif (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to close-on-exec mode: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\tconn->try_next_addr = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n #endif\n \n \t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n \t\t\t\t\t{\n #ifndef WIN32\n \t\t\t\t\t\tint\t\t\ton = 1;\n #endif\n \t\t\t\t\t\tint\t\t\tusekeepalives = useKeepalives(conn);\n \t\t\t\t\t\tint\t\t\terr = 0;\n \n \t\t\t\t\t\tif (usekeepalives < 0)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"keepalives parameter must be an integer\\n\"));\n \t\t\t\t\t\t\terr = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (usekeepalives == 0)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t}\n #ifndef WIN32\n \t\t\t\t\t\telse if (setsockopt(conn->sock,\n \t\t\t\t\t\t\t\t\t\t\tSOL_SOCKET, SO_KEEPALIVE,\n \t\t\t\t\t\t\t\t\t\t\t(char *) &on, sizeof(on)) < 0)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t\t  \"setsockopt\",\n \t\t\t\t\t\t\t\t\t\t\t  \"SO_KEEPALIVE\",\n \t\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\t\terr = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (!setKeepalivesIdle(conn)\n \t\t\t\t\t\t\t\t || !setKeepalivesInterval(conn)\n \t\t\t\t\t\t\t\t || !setKeepalivesCount(conn))\n \t\t\t\t\t\t\terr = 1;\n #else\n #ifdef SIO_KEEPALIVE_VALS\n \t\t\t\t\t\telse if (!setKeepalivesWin32(conn))\n \t\t\t\t\t\t\terr = 1;\n #endif\n #endif\n \t\t\t\t\t\telse if (!setTCPUserTimeout(conn))\n \t\t\t\t\t\t\terr = 1;\n \n \t\t\t\t\t\tif (err)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tconn->try_next_addr = true;\n \t\t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tconn->sigpipe_so = false;\n #ifdef MSG_NOSIGNAL\n \t\t\t\t\tconn->sigpipe_flag = true;\n #else\n \t\t\t\t\tconn->sigpipe_flag = false;\n #endif\n \n #ifdef SO_NOSIGPIPE\n \t\t\t\t\toptval = 1;\n \t\t\t\t\tif (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,\n \t\t\t\t\t\t\t\t   (char *) &optval, sizeof(optval)) == 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->sigpipe_so = true;\n \t\t\t\t\t\tconn->sigpipe_flag = false;\n \t\t\t\t\t}\n #endif\n \n \t\t\t\t\tif (connect(conn->sock, addr_cur->ai_addr,\n \t\t\t\t\t\t\t\taddr_cur->ai_addrlen) < 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (SOCK_ERRNO == EINPROGRESS ||\n #ifdef WIN32\n \t\t\t\t\t\t\tSOCK_ERRNO == EWOULDBLOCK ||\n #endif\n \t\t\t\t\t\t\tSOCK_ERRNO == EINTR)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n \t\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \n \t\t\t\t\tconnectFailureMessage(conn, SOCK_ERRNO);\n \t\t\t\t\tconn->try_next_addr = true;\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \t\t\t}\n \n \t\tcase CONNECTION_STARTED:\n \t\t\t{\n \t\t\t\tACCEPT_TYPE_ARG3 optlen = sizeof(optval);\n \n \n \n \t\t\t\tif (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,\n \t\t\t\t\t\t\t   (char *) &optval, &optlen) == -1)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get socket error status: %s\\n\"),\n \t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \t\t\t\telse if (optval != 0)\n \t\t\t\t{\n \t\t\t\t\tconnectFailureMessage(conn, optval);\n \n \t\t\t\t\tconn->try_next_addr = true;\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \n \t\t\t\tconn->laddr.salen = sizeof(conn->laddr.addr);\n \t\t\t\tif (getsockname(conn->sock,\n \t\t\t\t\t\t\t\t(struct sockaddr *) &conn->laddr.addr,\n \t\t\t\t\t\t\t\t&conn->laddr.salen) < 0)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get client address from socket: %s\\n\"),\n \t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tconn->status = CONNECTION_MADE;\n \t\t\t\treturn PGRES_POLLING_WRITING;\n \t\t\t}\n \n \t\tcase CONNECTION_MADE:\n \t\t\t{\n \t\t\t\tchar\t   *startpacket;\n \t\t\t\tint\t\t\tpacketlen;\n \n \t\t\t\tif (conn->requirepeer && conn->requirepeer[0] &&\n \t\t\t\t\tIS_AF_UNIX(conn->raddr.addr.ss_family))\n \t\t\t\t{\n #ifndef WIN32\n \t\t\t\t\tchar\t\tpwdbuf[BUFSIZ];\n \t\t\t\t\tstruct passwd pass_buf;\n \t\t\t\t\tstruct passwd *pass;\n \t\t\t\t\tint\t\t\tpasserr;\n #endif\n \t\t\t\t\tuid_t\t\tuid;\n \t\t\t\t\tgid_t\t\tgid;\n \n \t\t\t\t\terrno = 0;\n \t\t\t\t\tif (getpeereid(conn->sock, &uid, &gid) != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (errno == ENOSYS)\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"requirepeer parameter is not supported on this platform\\n\"));\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get peer credentials: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t\t  strerror_r(errno, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \n #ifndef WIN32\n \t\t\t\t\tpasserr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);\n \t\t\t\t\tif (pass == NULL)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (passerr != 0)\n \t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not look up local user ID %d: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t\t  (int) uid,\n \t\t\t\t\t\t\t\t\t\t\t  strerror_r(passerr, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"local user with ID %d does not exist\\n\"),\n \t\t\t\t\t\t\t\t\t\t\t  (int) uid);\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (strcmp(pass->pw_name, conn->requirepeer) != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"requirepeer specifies \\\"%s\\\", but actual peer user name is \\\"%s\\\"\\n\"),\n \t\t\t\t\t\t\t\t\t\t  conn->requirepeer, pass->pw_name);\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n #else\n \t\t\t\t\tAssert(false);\n #endif\n \t\t\t\t}\n \n \t\t\t\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n \t\t\t\t{\n #ifdef USE_SSL\n \t\t\t\t\tconn->allow_ssl_try = false;\n #endif\n #ifdef ENABLE_GSS\n \t\t\t\t\tconn->try_gss = false;\n #endif\n \t\t\t\t}\n \n #ifdef ENABLE_GSS\n \n \t\t\t\tif (conn->try_gss && !conn->gctx)\n \t\t\t\t\tconn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);\n \t\t\t\tif (conn->try_gss && !conn->gctx)\n \t\t\t\t{\n \t\t\t\t\tProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);\n \n \t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send GSSAPI negotiation packet: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \n \t\t\t\t\tconn->status = CONNECTION_GSS_STARTUP;\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \t\t\t\telse if (!conn->gctx && conn->gssencmode[0] == 'r')\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t libpq_gettext(\"GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\\n\"));\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n #endif\n \n #ifdef USE_SSL\n \n \t\t\t\tif (pqsecure_initialize(conn, false, true) < 0)\n \t\t\t\t\tgoto error_return;\n \n \t\t\t\tif (conn->allow_ssl_try && !conn->wait_ssl_try &&\n \t\t\t\t\t!conn->ssl_in_use\n #ifdef ENABLE_GSS\n \t\t\t\t\t&& !conn->gssenc\n #endif\n \t\t\t\t\t)\n \t\t\t\t{\n \t\t\t\t\tProtocolVersion pv;\n \n \t\t\t\t\tpv = pg_hton32(NEGOTIATE_SSL_CODE);\n \t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send SSL negotiation packet: %s\\n\"),\n \t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \t\t\t\t\tconn->status = CONNECTION_SSL_STARTUP;\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n #endif\n \n \t\t\t\tstartpacket = pqBuildStartupPacket3(conn, &packetlen,\n \t\t\t\t\t\t\t\t\t\t\t\t\tEnvironmentOptions);\n \t\t\t\tif (!startpacket)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tif (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send startup packet: %s\\n\"),\n \t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n \t\t\t\t\tfree(startpacket);\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tfree(startpacket);\n \n \t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n \t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t}\n \n \t\tcase CONNECTION_SSL_STARTUP:\n \t\t\t{\n #ifdef USE_SSL\n \t\t\t\tPostgresPollingStatusType pollres;\n \n \t\t\t\tif (!conn->ssl_in_use)\n \t\t\t\t{\n \t\t\t\t\tchar\t\tSSLok;\n \t\t\t\t\tint\t\t\trdresult;\n \n \t\t\t\t\trdresult = pqReadData(conn);\n \t\t\t\t\tif (rdresult < 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \t\t\t\t\tif (rdresult == 0)\n \t\t\t\t\t{\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t\t}\n \t\t\t\t\tif (pqGetc(&SSLok, conn) < 0)\n \t\t\t\t\t{\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t\t}\n \t\t\t\t\tif (SSLok == 'S')\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->inStart = conn->inCursor;\n \n \t\t\t\t\t\tif (pqsecure_initialize(conn, true, false) != 0)\n \t\t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \t\t\t\t\telse if (SSLok == 'N')\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->inStart = conn->inCursor;\n \t\t\t\t\t\tif (conn->sslmode[0] == 'r' ||\n \t\t\t\t\t\t\tconn->sslmode[0] == 'v')\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server does not support SSL, but SSL was required\\n\"));\n \t\t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tconn->allow_ssl_try = false;\n \t\t\t\t\t\tconn->status = CONNECTION_MADE;\n \t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n \t\t\t\t\t}\n \t\t\t\t\telse if (SSLok == 'E')\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to SSL negotiation: %c\\n\"),\n \t\t\t\t\t\t\t\t\t\t  SSLok);\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tpollres = pqsecure_open_client(conn);\n \t\t\t\tif (pollres == PGRES_POLLING_OK)\n \t\t\t\t{\n// bug_start\n// bug_end\n \t\t\t\t\tconn->status = CONNECTION_MADE;\n \t\t\t\t\treturn PGRES_POLLING_WRITING;\n \t\t\t\t}\n \t\t\t\tif (pollres == PGRES_POLLING_FAILED)\n \t\t\t\t{\n \t\t\t\t\tif (conn->sslmode[0] == 'p'\n \t\t\t\t\t\t&& conn->allow_ssl_try\n \t\t\t\t\t\t&& !conn->wait_ssl_try)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->allow_ssl_try = false;\n \t\t\t\t\t\tneed_new_connection = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \t\t\t\treturn pollres;\n #else\n \t\t\t\tgoto error_return;\n #endif\n \t\t\t}\n \n \t\tcase CONNECTION_GSS_STARTUP:\n \t\t\t{\n #ifdef ENABLE_GSS\n \t\t\t\tPostgresPollingStatusType pollres;\n \n \t\t\t\tif (conn->try_gss && !conn->gctx)\n \t\t\t\t{\n \t\t\t\t\tchar\t\tgss_ok;\n \t\t\t\t\tint\t\t\trdresult = pqReadData(conn);\n \n \t\t\t\t\tif (rdresult < 0)\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\telse if (rdresult == 0)\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t\tif (pqGetc(&gss_ok, conn) < 0)\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \n \t\t\t\t\tif (gss_ok == 'E')\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->try_gss = false;\n \t\t\t\t\t\tneed_new_connection = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \n \t\t\t\t\tconn->inStart = conn->inCursor;\n \n \t\t\t\t\tif (gss_ok == 'N')\n \t\t\t\t\t{\n \t\t\t\t\t\tif (conn->gssencmode[0] == 'r')\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server doesn't support GSSAPI encryption, but it was required\\n\"));\n \t\t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tconn->try_gss = false;\n \t\t\t\t\t\tconn->status = CONNECTION_MADE;\n \t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n \t\t\t\t\t}\n \t\t\t\t\telse if (gss_ok != 'G')\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to GSSAPI negotiation: %c\\n\"),\n \t\t\t\t\t\t\t\t\t\t  gss_ok);\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tpollres = pqsecure_open_gss(conn);\n \t\t\t\tif (pollres == PGRES_POLLING_OK)\n \t\t\t\t{\n// bug_start\n// bug_end\n \t\t\t\t\tconn->status = CONNECTION_MADE;\n \t\t\t\t\treturn PGRES_POLLING_WRITING;\n \t\t\t\t}\n \t\t\t\telse if (pollres == PGRES_POLLING_FAILED &&\n \t\t\t\t\t\t conn->gssencmode[0] == 'p')\n \t\t\t\t{\n \t\t\t\t\tconn->try_gss = false;\n \t\t\t\t\tneed_new_connection = true;\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \t\t\t\treturn pollres;\n #else\n \t\t\t\tgoto error_return;\n #endif\n \t\t\t}\n \n \t\tcase CONNECTION_AWAITING_RESPONSE:\n \t\t\t{\n \t\t\t\tchar\t\tberesp;\n \t\t\t\tint\t\t\tmsgLength;\n \t\t\t\tint\t\t\tavail;\n \t\t\t\tAuthRequest areq;\n \t\t\t\tint\t\t\tres;\n \n \t\t\t\tconn->inCursor = conn->inStart;\n \n \t\t\t\tif (pqGetc(&beresp, conn))\n \t\t\t\t{\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \n \t\t\t\tif (!(beresp == 'R' || beresp == 'E'))\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n \t\t\t\t\t\t\t\t\t  beresp);\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tif (pqGetInt(&msgLength, 4, conn))\n \t\t\t\t{\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \n \t\t\t\tif (beresp == 'R' && (msgLength < 8 || msgLength > 2000))\n \t\t\t\t{\n \t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n \t\t\t\t\t\t\t\t\t  beresp);\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tif (beresp == 'E' && (msgLength < 8 || msgLength > 30000))\n \t\t\t\t{\n \t\t\t\t\tconn->inCursor = conn->inStart + 1;\n \t\t\t\t\tif (pqGets_append(&conn->errorMessage, conn))\n \t\t\t\t\t{\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t\t}\n \t\t\t\t\tconn->inStart = conn->inCursor;\n \n \t\t\t\t\tif (conn->errorMessage.len == 0 ||\n \t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n \t\t\t\t\t{\n \t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n \t\t\t\t\t}\n \n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tmsgLength -= 4;\n \t\t\t\tavail = conn->inEnd - conn->inCursor;\n \t\t\t\tif (avail < msgLength)\n \t\t\t\t{\n \t\t\t\t\tif (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,\n \t\t\t\t\t\t\t\t\t\t\t conn))\n \t\t\t\t\t\tgoto error_return;\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \n \t\t\t\tif (beresp == 'E')\n \t\t\t\t{\n \t\t\t\t\tif (pqGetErrorNotice3(conn, true))\n \t\t\t\t\t{\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t\t}\n \t\t\t\t\tconn->inStart = conn->inCursor;\n \n \t\t\t\t\tif (strcmp(conn->last_sqlstate,\n \t\t\t\t\t\t\t   ERRCODE_CANNOT_CONNECT_NOW) == 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->try_next_host = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \n \t\t\t\t\tpgpassfileWarning(conn);\n \n #ifdef ENABLE_GSS\n \n \t\t\t\t\tif (conn->gssenc && conn->gssencmode[0] == 'p')\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->try_gss = false;\n \t\t\t\t\t\tneed_new_connection = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n #endif\n \n #ifdef USE_SSL\n \n \t\t\t\t\tif (conn->sslmode[0] == 'a'\n \t\t\t\t\t\t&& !conn->ssl_in_use\n \t\t\t\t\t\t&& conn->allow_ssl_try\n \t\t\t\t\t\t&& conn->wait_ssl_try)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->wait_ssl_try = false;\n \t\t\t\t\t\tneed_new_connection = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (conn->sslmode[0] == 'p'\n \t\t\t\t\t\t&& conn->ssl_in_use\n \t\t\t\t\t\t&& conn->allow_ssl_try\n \t\t\t\t\t\t&& !conn->wait_ssl_try)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->allow_ssl_try = false;\n \t\t\t\t\t\tneed_new_connection = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n #endif\n \n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tconn->auth_req_received = true;\n \n \t\t\t\tif (pqGetInt((int *) &areq, 4, conn))\n \t\t\t\t{\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \t\t\t\tmsgLength -= 4;\n \n \t\t\t\tres = pg_fe_sendauth(areq, msgLength, conn);\n \n \t\t\t\tconn->inStart = conn->inCursor;\n \n \t\t\t\tif (res != STATUS_OK)\n \t\t\t\t\tgoto error_return;\n \n \t\t\t\tif (pqFlush(conn))\n \t\t\t\t\tgoto error_return;\n \n \t\t\t\tif (areq == AUTH_REQ_OK)\n \t\t\t\t{\n \t\t\t\t\tconn->status = CONNECTION_AUTH_OK;\n \n \t\t\t\t\tconn->asyncStatus = PGASYNC_BUSY;\n \t\t\t\t}\n \n \t\t\t\tgoto keep_going;\n \t\t\t}\n \n \t\tcase CONNECTION_AUTH_OK:\n \t\t\t{\n \n \t\t\t\tif (PQisBusy(conn))\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \n \t\t\t\tres = PQgetResult(conn);\n \n \t\t\t\tif (res)\n \t\t\t\t{\n \t\t\t\t\tif (res->resultStatus != PGRES_FATAL_ERROR)\n \t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"unexpected message from server during startup\\n\"));\n \t\t\t\t\telse if (conn->send_appname &&\n \t\t\t\t\t\t\t (conn->appname || conn->fbappname))\n \t\t\t\t\t{\n \t\t\t\t\t\tconst char *sqlstate;\n \n \t\t\t\t\t\tsqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);\n \t\t\t\t\t\tif (sqlstate &&\n \t\t\t\t\t\t\tstrcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tPQclear(res);\n \t\t\t\t\t\t\tconn->send_appname = false;\n \t\t\t\t\t\t\tneed_new_connection = true;\n \t\t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tif (conn->errorMessage.len <= 0 ||\n \t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n \t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n \t\t\t\t\tPQclear(res);\n \t\t\t\t\tgoto error_return;\n \t\t\t\t}\n \n \t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n \t\t\t\tgoto keep_going;\n \t\t\t}\n \n \t\tcase CONNECTION_CHECK_TARGET:\n \t\t\t{\n \t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE ||\n \t\t\t\t\tconn->target_server_type == SERVER_TYPE_READ_ONLY)\n \t\t\t\t{\n \t\t\t\t\tbool\t\tread_only_server;\n \n \t\t\t\t\tif (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||\n \t\t\t\t\t\tconn->in_hot_standby == PG_BOOL_UNKNOWN)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n \t\t\t\t\t\t\t\t\t\t\t\t \"SHOW transaction_read_only\"))\n \t\t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t\t}\n \n \t\t\t\t\tread_only_server =\n \t\t\t\t\t\t(conn->default_transaction_read_only == PG_BOOL_YES ||\n \t\t\t\t\t\t conn->in_hot_standby == PG_BOOL_YES);\n \n \t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?\n \t\t\t\t\t\tread_only_server : !read_only_server)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE)\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is read-only\\n\"));\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is not read-only\\n\"));\n \n \t\t\t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\t\t\tsendTerminateConn(conn);\n \n \t\t\t\t\t\tconn->try_next_host = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (conn->target_server_type == SERVER_TYPE_PRIMARY ||\n \t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_STANDBY ||\n \t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)\n \t\t\t\t{\n \t\t\t\t\tif (conn->sversion < 90000)\n \t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n \n \t\t\t\t\tif (conn->in_hot_standby == PG_BOOL_UNKNOWN)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n \t\t\t\t\t\t\t\t\t\t\t\t \"SELECT pg_catalog.pg_is_in_recovery()\"))\n \t\t\t\t\t\t\tgoto error_return;\n \t\t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n \t\t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t\t}\n \n \t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?\n \t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_YES) :\n \t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_NO))\n \t\t\t\t\t{\n \t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_PRIMARY)\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is in hot standby mode\\n\"));\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is not in hot standby mode\\n\"));\n \n \t\t\t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\t\t\tsendTerminateConn(conn);\n \n \t\t\t\t\t\tconn->try_next_host = true;\n \t\t\t\t\t\tgoto keep_going;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\trelease_conn_addrinfo(conn);\n \n \t\t\t\tresetPQExpBuffer(&conn->errorMessage);\n \n \t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\treturn PGRES_POLLING_OK;\n \t\t\t}\n \n \t\tcase CONNECTION_CONSUME:\n \t\t\t{\n \t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\tif (!PQconsumeInput(conn))\n \t\t\t\t\tgoto error_return;\n \n \t\t\t\tif (PQisBusy(conn))\n \t\t\t\t{\n \t\t\t\t\tconn->status = CONNECTION_CONSUME;\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \n \t\t\t\tres = PQgetResult(conn);\n \t\t\t\tif (res != NULL)\n \t\t\t\t{\n \t\t\t\t\tPQclear(res);\n \t\t\t\t\tconn->status = CONNECTION_CONSUME;\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \n \t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n \t\t\t\tgoto keep_going;\n \t\t\t}\n \n \t\tcase CONNECTION_CHECK_WRITABLE:\n \t\t\t{\n \t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\tif (!PQconsumeInput(conn))\n \t\t\t\t\tgoto error_return;\n \n \t\t\t\tif (PQisBusy(conn))\n \t\t\t\t{\n \t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \n \t\t\t\tres = PQgetResult(conn);\n \t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n \t\t\t\t\tPQntuples(res) == 1)\n \t\t\t\t{\n \t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n \n \t\t\t\t\tif (strncmp(val, \"on\", 2) == 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_YES;\n \t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n \t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_NO;\n \t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n \t\t\t\t\t}\n \t\t\t\t\tPQclear(res);\n \n \t\t\t\t\tconn->status = CONNECTION_CONSUME;\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \n \t\t\t\tif (res)\n \t\t\t\t\tPQclear(res);\n \n \t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n \t\t\t\t\t\t\t\t  \"SHOW transaction_read_only\");\n \n \t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\tsendTerminateConn(conn);\n \n \t\t\t\tconn->try_next_host = true;\n \t\t\t\tgoto keep_going;\n \t\t\t}\n \n \t\tcase CONNECTION_CHECK_STANDBY:\n \t\t\t{\n \t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\tif (!PQconsumeInput(conn))\n \t\t\t\t\tgoto error_return;\n \n \t\t\t\tif (PQisBusy(conn))\n \t\t\t\t{\n \t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n \t\t\t\t\treturn PGRES_POLLING_READING;\n \t\t\t\t}\n \n \t\t\t\tres = PQgetResult(conn);\n \t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n \t\t\t\t\tPQntuples(res) == 1)\n \t\t\t\t{\n \t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n \n \t\t\t\t\tif (strncmp(val, \"t\", 1) == 0)\n \t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n \t\t\t\t\telse\n \t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n \t\t\t\t\tPQclear(res);\n \n \t\t\t\t\tconn->status = CONNECTION_CONSUME;\n \t\t\t\t\tgoto keep_going;\n \t\t\t\t}\n \n \t\t\t\tif (res)\n \t\t\t\t\tPQclear(res);\n \n \t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n \t\t\t\t\t\t\t\t  \"SELECT pg_is_in_recovery()\");\n \n \t\t\t\tconn->status = CONNECTION_OK;\n \t\t\t\tsendTerminateConn(conn);\n \n \t\t\t\tconn->try_next_host = true;\n \t\t\t\tgoto keep_going;\n \t\t\t}\n \n \t\tdefault:\n \t\t\tappendPQExpBuffer(&conn->errorMessage,\n \t\t\t\t\t\t\t  libpq_gettext(\"invalid connection state %d, \"\n \t\t\t\t\t\t\t\t\t\t\t\"probably indicative of memory corruption\\n\"),\n \t\t\t\t\t\t\t  conn->status);\n \t\t\tgoto error_return;\n \t}\n \n \n error_return:\n \n \tconn->status = CONNECTION_BAD;\n \treturn PGRES_POLLING_FAILED;\n }\n \n", "target": "// fix_start\n\t\t\t\t\tif (conn->inCursor != conn->inEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"received unencrypted data after SSL response\\n\"));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n// fix_end\n// fix_start\n\t\t\t\t\tif (conn->inCursor != conn->inEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"received unencrypted data after GSSAPI encryption response\\n\"));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n// fix_end\n", "cwe": "CWE-522", "cwe_name": "Insufficiently Protected Credentials", "cve": "CVE-2021-23222", "cve_desc": "A man-in-the-middle attacker can inject false responses to the client's first few queries, despite the use of SSL certificate verification and encryption.", "project": "postgres", "idx": 195388}
{"source": " bool RepeatedAttrDefEqual(\n     const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n     const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n   std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n   for (const OpDef::AttrDef& def : a1) {\n// bug_start\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n// bug_end\n     a1_set[def.name()] = &def;\n   }\n   for (const OpDef::AttrDef& def : a2) {\n     auto iter = a1_set.find(def.name());\n     if (iter == a1_set.end()) return false;\n     if (!AttrDefEqual(*iter->second, def)) return false;\n     a1_set.erase(iter);\n   }\n   if (!a1_set.empty()) return false;\n   return true;\n }\n \n", "target": "// fix_start\n    if (a1_set.find(def.name()) != a1_set.end()) {\n      LOG(ERROR) << \"AttrDef names must be unique, but '\" << def.name()\n                 << \"' appears more than once\";\n    }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-23565", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can trigger denial of service via assertion failure by altering a `SavedModel` on disk such that `AttrDef`s of some operation are duplicated. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195389}
{"source": "   void Compute(tensorflow::OpKernelContext* context) override {\n     for (int ngram_width : ngram_widths_) {\n       OP_REQUIRES(\n           context, ngram_width > 0,\n           errors::InvalidArgument(\"ngram_widths must contain positive values\"));\n     }\n \n     const tensorflow::Tensor* data;\n     OP_REQUIRES_OK(context, context->input(\"data\", &data));\n     const auto& input_data = data->flat<tstring>().data();\n \n     const tensorflow::Tensor* splits;\n     OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n     const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n \n     const int input_data_size = data->flat<tstring>().size();\n     const int splits_vec_size = splits_vec.size();\n     if (splits_vec_size > 0) {\n       int prev_split = splits_vec(0);\n       OP_REQUIRES(context, prev_split == 0,\n                   errors::InvalidArgument(\"First split value must be 0, got \",\n                                           prev_split));\n       for (int i = 1; i < splits_vec_size; ++i) {\n         bool valid_splits = splits_vec(i) >= prev_split;\n         valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n         OP_REQUIRES(context, valid_splits,\n                     errors::InvalidArgument(\n                         \"Invalid split value \", splits_vec(i), \", must be in [\",\n                         prev_split, \", \", input_data_size, \"]\"));\n         prev_split = splits_vec(i);\n       }\n       OP_REQUIRES(context, prev_split == input_data_size,\n                   errors::InvalidArgument(\n                       \"Last split value must be data size. Expected \",\n                       input_data_size, \", got \", prev_split));\n     }\n \n     int num_batch_items = splits_vec.size() - 1;\n     tensorflow::Tensor* ngrams_splits;\n     OP_REQUIRES_OK(\n         context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n     auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n \n     if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n       tensorflow::Tensor* empty;\n       OP_REQUIRES_OK(context,\n                      context->allocate_output(0, data->shape(), &empty));\n       for (int i = 0; i <= num_batch_items; ++i) {\n         ngrams_splits_data[i] = 0;\n       }\n       return;\n     }\n \n     ngrams_splits_data[0] = 0;\n     for (int i = 1; i <= num_batch_items; ++i) {\n       int length = splits_vec(i) - splits_vec(i - 1);\n       int num_ngrams = 0;\n       for (int ngram_width : ngram_widths_)\n         num_ngrams += get_num_ngrams(length, ngram_width);\n       if (preserve_short_ && length > 0 && num_ngrams == 0) {\n         num_ngrams = 1;\n       }\n       ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n     }\n \n     tensorflow::Tensor* ngrams;\n     OP_REQUIRES_OK(\n         context,\n         context->allocate_output(\n             0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n     auto ngrams_data = ngrams->flat<tstring>().data();\n \n     for (int i = 0; i < num_batch_items; ++i) {\n       auto data_start = &input_data[splits_vec(i)];\n       int output_start_idx = ngrams_splits_data[i];\n       for (int ngram_width : ngram_widths_) {\n         auto output_start = &ngrams_data[output_start_idx];\n         int length = splits_vec(i + 1) - splits_vec(i);\n         int num_ngrams = get_num_ngrams(length, ngram_width);\n         CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n         output_start_idx += num_ngrams;\n       }\n       if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n         int data_length = splits_vec(i + 1) - splits_vec(i);\n         if (data_length == 0) {\n           continue;\n         }\n// bug_start\n// bug_end\n         int ngram_width = data_length + 2 * pad_width_;\n         auto output_start = &ngrams_data[output_start_idx];\n         int num_ngrams = 1;\n         CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n       }\n     }\n   }\n \n", "target": "// fix_start\n\n        OP_REQUIRES(\n            context, pad_width_ >= 0,\n            errors::InvalidArgument(\"Pad width should be >= 0 when \"\n                                    \"preserve_short_sequences is True and \"\n                                    \"ngram_widths are not provided, got \",\n                                    pad_width_));\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2022-21733", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `StringNGrams` can be used to trigger a denial of service attack by causing an out of memory condition after an integer overflow. We are missing a validation on `pad_witdh` and that result in computing a negative value for `ngram_width` which is later used to allocate parts of the output. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195391}
{"source": " static int vidioc_querycap(struct file *file, void *priv,\n \t\t\t   struct v4l2_capability *cap)\n {\n \tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n \tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n \t\t\t       sizeof(cap->card) :\n \t\t\t\t     sizeof(dev->card_label);\n \tint device_nr =\n \t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n \t\t\t->device_nr;\n \t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n \n \tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n// bug_start\n\tsnprintf(cap->card, labellen, dev->card_label);\n// bug_end\n \tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n \t\t \"platform:v4l2loopback-%03d\", device_nr);\n \n #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n \tcap->version = V4L2LOOPBACK_VERSION_CODE;\n #endif\n \n #ifdef V4L2_CAP_VIDEO_M2M\n \tcapabilities |= V4L2_CAP_VIDEO_M2M;\n #endif\n \n \tif (dev->announce_all_caps) {\n \t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n \t} else {\n \t\tif (dev->ready_for_capture) {\n \t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n \t\t}\n \t\tif (dev->ready_for_output) {\n \t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n \t\t}\n \t}\n \n #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n \tdev->vdev->device_caps =\n #endif\n \t\tcap->device_caps = cap->capabilities = capabilities;\n \n #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n \tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n #endif\n \n \tmemset(cap->reserved, 0, sizeof(cap->reserved));\n \treturn 0;\n }\n \n", "target": "// fix_start\n\tsnprintf(cap->card, labellen, \"%s\", dev->card_label);\n// fix_end\n", "cwe": "CWE-134", "cwe_name": "Use of Externally-Controlled Format String", "cve": "CVE-2022-2652", "cve_desc": "Depending on the way the format strings in the card label are crafted it's possible to leak kernel stack memory. There is also the possibility for DoS due to the v4l2loopback kernel module crashing when providing the card label on request (reproduce e.g. with many %s modifiers in a row).", "project": "v4l2loopback", "idx": 195398}
{"source": " bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                                const NodeDef& node) {\n   if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n       node.input_size() > 0) {\n     TensorId tensor_id = ParseTensorName(node.input(0));\n     if (IsTensorIdControlling(tensor_id)) {\n       return false;\n     }\n \n     NodeDef* input_node = graph.GetNode(tensor_id.node());\n// bug_start\n// bug_end\n     return IsSwitch(*input_node);\n   }\n   return false;\n }\n \n", "target": "// fix_start\n    if (input_node == nullptr) {\n      return false;\n    }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-23589", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. Under certain scenarios, Grappler component of TensorFlow can trigger a null pointer dereference. There are 2 places where this can occur, for the same malicious alteration of a `SavedModel` file (fixing the first one would trigger the same dereference in the second place). First, during constant folding, the `GraphDef` might not have the required nodes for the binary operation. If a node is missing, the correposning `mul_*child` would be null, and the dereference in the subsequent line would be incorrect. We have a similar issue during `IsIdentityConsumingSwitch`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195399}
{"source": "// bug_start\nint TfLiteIntArrayGetSizeInBytes(int size) {\n// bug_end\n   static TfLiteIntArray dummy;\n \n// bug_start\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n// bug_end\n #if defined(_MSC_VER)\n   computed_size -= sizeof(dummy.data[0]);\n #endif\n   return computed_size;\n }\n \n", "target": "// fix_start\nsize_t TfLiteIntArrayGetSizeInBytes(int size) {\n// fix_end\n// fix_start\n  size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2022-23558", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in `TfLiteIntArrayCreate`. The `TfLiteIntArrayGetSizeInBytes` returns an `int` instead of a `size_t. An attacker can control model inputs such that `computed_size` overflows the size of `int` datatype. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195402}
{"source": " TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n// bug_start\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n// bug_end\n   if (alloc_size <= 0) return NULL;\n   TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n   if (!ret) return ret;\n   ret->size = size;\n   return ret;\n }\n \n", "target": "// fix_start\n  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2022-23558", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in `TfLiteIntArrayCreate`. The `TfLiteIntArrayGetSizeInBytes` returns an `int` instead of a `size_t. An attacker can control model inputs such that `computed_size` overflows the size of `int` datatype. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195403}
{"source": "   void Compute(OpKernelContext* context) override {\n     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n         ConstEigenMatrixMap;\n     typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n         EigenMatrixMap;\n \n     constexpr int tensor_in_and_out_dims = 4;\n \n     const Tensor& tensor_in = context->input(0);\n     OP_REQUIRES(context, tensor_in.dims() == tensor_in_and_out_dims,\n                 errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n \n     std::vector<int> input_size(tensor_in_and_out_dims);\n     std::vector<int> output_size(tensor_in_and_out_dims);\n     for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n       input_size[i] = tensor_in.dim_size(i);\n// bug_start\n// bug_end\n     }\n     for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n       output_size[i] =\n           static_cast<int>(std::floor(input_size[i] / pooling_ratio_[i]));\n       DCHECK_GT(output_size[i], 0);\n     }\n \n     std::vector<int64_t> height_cum_seq;\n     std::vector<int64_t> width_cum_seq;\n     GuardedPhiloxRandom generator;\n     generator.Init(seed_, seed2_);\n     height_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n                                              &generator, pseudo_random_);\n     width_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n                                             &generator, pseudo_random_);\n \n     Tensor* output_tensor = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(\n                                 0,\n                                 TensorShape({output_size[0], output_size[1],\n                                              output_size[2], output_size[3]}),\n                                 &output_tensor));\n     Tensor* output_height_seq_tensor = nullptr;\n     OP_REQUIRES_OK(\n         context,\n         context->allocate_output(\n             1, TensorShape({static_cast<int64_t>(height_cum_seq.size())}),\n             &output_height_seq_tensor));\n     Tensor* output_width_seq_tensor = nullptr;\n     OP_REQUIRES_OK(\n         context,\n         context->allocate_output(\n             2, TensorShape({static_cast<int64_t>(width_cum_seq.size())}),\n             &output_width_seq_tensor));\n \n     ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(), input_size[3],\n                                input_size[2] * input_size[1] * input_size[0]);\n \n     EigenMatrixMap out_mat(output_tensor->flat<T>().data(), output_size[3],\n                            output_size[2] * output_size[1] * output_size[0]);\n \n     output_tensor->flat<T>().setConstant(Eigen::NumTraits<T>::lowest());\n \n     auto output_height_seq_flat = output_height_seq_tensor->flat<int64_t>();\n     auto output_width_seq_flat = output_width_seq_tensor->flat<int64_t>();\n \n     for (int i = 0; i < height_cum_seq.size(); ++i) {\n       output_height_seq_flat(i) = height_cum_seq[i];\n     }\n \n     for (int i = 0; i < width_cum_seq.size(); ++i) {\n       output_width_seq_flat(i) = width_cum_seq[i];\n     }\n \n     const int64_t height_max = input_size[1] - 1;\n     const int64_t width_max = input_size[2] - 1;\n     for (int64_t b = 0; b < input_size[0]; ++b) {\n       for (int64_t hs = 0; hs < height_cum_seq.size() - 1; ++hs) {\n         const int64_t height_start = height_cum_seq[hs];\n         int64_t height_end =\n             overlapping_ ? height_cum_seq[hs + 1] : height_cum_seq[hs + 1] - 1;\n         height_end = std::min(height_end, height_max);\n \n         for (int64_t ws = 0; ws < width_cum_seq.size() - 1; ++ws) {\n           const int64_t out_offset =\n               (b * output_size[1] + hs) * output_size[2] + ws;\n           const int64_t width_start = width_cum_seq[ws];\n           int64_t width_end =\n               overlapping_ ? width_cum_seq[ws + 1] : width_cum_seq[ws + 1] - 1;\n           width_end = std::min(width_end, width_max);\n           for (int64_t h = height_start; h <= height_end; ++h) {\n             for (int64_t w = width_start; w <= width_end; ++w) {\n               const int64_t in_offset =\n                   (b * input_size[1] + h) * input_size[2] + w;\n               out_mat.col(out_offset) =\n                   out_mat.col(out_offset).cwiseMax(in_mat.col(in_offset));\n             }\n           }\n         }\n       }\n     }\n   }\n \n", "target": "// fix_start\n\n      OP_REQUIRES(\n          context, input_size[i] >= pooling_ratio_[i],\n          errors::InvalidArgument(\"Pooling ratio is higher than input \"\n                                  \"dimension size for dimension \",\n                                  i, \". Input dim size: \", input_size[i],\n                                  \" pooling ratio: \", pooling_ratio_[i]));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2022-21735", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `FractionalMaxPool` can be made to crash a TensorFlow process via a division by 0. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195404}
{"source": " static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n #define CropBox  \"CropBox\"\n #define DeviceCMYK  \"DeviceCMYK\"\n #define MediaBox  \"MediaBox\"\n #define RenderPCLText  \"  Rendering PCL...  \"\n \n   char\n     command[MaxTextExtent],\n     *density,\n     filename[MaxTextExtent],\n     geometry[MaxTextExtent],\n     *options,\n     input_filename[MaxTextExtent];\n \n   const DelegateInfo\n     *delegate_info;\n \n   Image\n     *image,\n     *next_image;\n \n   ImageInfo\n     *read_info;\n \n   int\n     c;\n \n   MagickBooleanType\n     cmyk,\n     status;\n \n   PointInfo\n     delta;\n \n   RectangleInfo\n     bounding_box,\n     page;\n \n   char\n     *p;\n \n   SegmentInfo\n     bounds;\n \n   size_t\n     height,\n     width;\n \n   ssize_t\n     count;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n   if (status == MagickFalse)\n     {\n       ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n         image_info->filename);\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   delta.x=DefaultResolution;\n   delta.y=DefaultResolution;\n   if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))\n     {\n       GeometryInfo\n         geometry_info;\n \n       MagickStatusType\n         flags;\n \n       flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n       if ((flags & RhoValue) != 0)\n         image->x_resolution=geometry_info.rho;\n       image->y_resolution=image->x_resolution;\n       if ((flags & SigmaValue) != 0)\n         image->y_resolution=geometry_info.sigma;\n     }\n   cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n   count=0;\n   (void) memset(&bounding_box,0,sizeof(bounding_box));\n   (void) memset(&bounds,0,sizeof(bounds));\n   (void) memset(&page,0,sizeof(page));\n   (void) memset(command,0,sizeof(command));\n   p=command;\n   for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n   {\n     if (image_info->page != (char *) NULL)\n       continue;\n     *p++=(char) c;\n     if ((c != (int) '/') && (c != '\\n') &&\n         ((size_t) (p-command) < (MaxTextExtent-1)))\n       continue;\n     *p='\\0';\n     p=command;\n     if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n       cmyk=MagickTrue;\n     if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n       {\n         count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n         if (count != 4)\n           count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n       }\n     if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n       {\n         count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n         if (count != 4)\n           count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n       }\n     if (count != 4)\n       continue;\n// bug_start\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n// bug_end\n     if (width > page.width)\n       page.width=width;\n     if (height > page.height)\n       page.height=height;\n   }\n   (void) CloseBlob(image);\n   if ((page.width == 0) || (page.height == 0))\n     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n   if (image_info->page != (char *) NULL)\n     (void) ParseAbsoluteGeometry(image_info->page,&page);\n   (void) FormatLocaleString(geometry,MaxTextExtent,\"%.20gx%.20g\",(double)\n     page.width,(double) page.height);\n   if (image_info->monochrome != MagickFalse)\n     delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n   else\n      if (cmyk != MagickFalse)\n        delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n      else\n        delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n   if (delegate_info == (const DelegateInfo *) NULL)\n     {\n       image=DestroyImage(image);\n       return((Image *) NULL);\n     }\n   if ((page.width == 0) || (page.height == 0))\n     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n   if (image_info->page != (char *) NULL)\n     (void) ParseAbsoluteGeometry(image_info->page,&page);\n   density=AcquireString(\"\");\n   options=AcquireString(\"\");\n   (void) FormatLocaleString(density,MaxTextExtent,\"%gx%g\",\n     image->x_resolution,image->y_resolution);\n   if (image_info->ping != MagickFalse)\n     (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n   page.width=(size_t) floor((double) page.width*image->x_resolution/delta.x+\n     0.5);\n   page.height=(size_t) floor((double) page.height*image->y_resolution/delta.y+\n     0.5);\n   (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g \",(double)\n      page.width,(double) page.height);\n   image=DestroyImage(image);\n   read_info=CloneImageInfo(image_info);\n   *read_info->magick='\\0';\n   if (read_info->number_scenes != 0)\n     {\n       if (read_info->number_scenes != 1)\n         (void) FormatLocaleString(options,MaxTextExtent,\"-dLastPage=%.20g\",\n           (double) (read_info->scene+read_info->number_scenes));\n       else\n         (void) FormatLocaleString(options,MaxTextExtent,\n           \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n           (double) (read_info->scene+read_info->number_scenes));\n       read_info->number_scenes=0;\n       if (read_info->scenes != (char *) NULL)\n         *read_info->scenes='\\0';\n     }\n   (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n   (void) AcquireUniqueFilename(read_info->filename);\n   (void) FormatLocaleString(command,MaxTextExtent,\n     GetDelegateCommands(delegate_info),\n     read_info->antialias != MagickFalse ? 4 : 1,\n     read_info->antialias != MagickFalse ? 4 : 1,density,options,\n     read_info->filename,input_filename);\n   options=DestroyString(options);\n   density=DestroyString(density);\n   status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n     (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n   image=ReadImage(read_info,exception);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   (void) RelinquishUniqueFileResource(input_filename);\n   read_info=DestroyImageInfo(read_info);\n   if (image == (Image *) NULL)\n     ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n   if (LocaleCompare(image->magick,\"BMP\") == 0)\n     {\n       Image\n         *cmyk_image;\n \n       cmyk_image=ConsolidateCMYKImages(image,&image->exception);\n       if (cmyk_image != (Image *) NULL)\n         {\n           image=DestroyImageList(image);\n           image=cmyk_image;\n         }\n     }\n   do\n   {\n     (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n     image->page=page;\n     if (image_info->ping != MagickFalse)\n       {\n         image->magick_columns*=image->x_resolution/2.0;\n         image->magick_rows*=image->y_resolution/2.0;\n         image->columns*=image->x_resolution/2.0;\n         image->rows*=image->y_resolution/2.0;\n       }\n     next_image=SyncNextImageInList(image);\n     if (next_image != (Image *) NULL)\n       image=next_image;\n   } while (next_image != (Image *) NULL);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n    width=(size_t) CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n    height=(size_t) CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2022-32546", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned long' at coders/pcl.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "project": "ImageMagick6", "idx": 195405}
{"source": " \n void gitn_box_del(GF_Box *s)\n {\n \tu32 i;\n \tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n \tif (ptr == NULL) return;\n// bug_start\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n// bug_end\n \t}\n// bug_start\n\tif (ptr->entries) gf_free(ptr->entries);\n// bug_end\n \tgf_free(ptr);\n \n", "target": "// fix_start\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-4043", "cve_desc": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 1.1.0.", "project": "gpac", "idx": 195409}
{"source": "   void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n     const Tensor* indices;\n     OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n     const Tensor* values;\n     OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n     const Tensor* dense_shape;\n     OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n \n     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n// bug_start\n// bug_end\n                 errors::InvalidArgument(\n// bug_start\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n// bug_end\n \n     int64_t previous_batch_index = -1;\n     for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n       int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n       OP_REQUIRES(\n           ctx, next_batch_index >= previous_batch_index,\n           errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                 \"dimension; handling arbitrarily ordered input \"\n                                 \"is not currently supported.\"));\n       previous_batch_index = next_batch_index;\n     }\n     gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n     sparse::SparseTensor tensor;\n     OP_REQUIRES_OK(\n         ctx, sparse::SparseTensor::Create(\n                  *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                  std_order, &tensor));\n     *output = new Dataset<T>(ctx, std::move(tensor));\n   }\n \n", "target": "// fix_start\n                errors::InvalidArgument(\"Input indices must be a matrix. Got: \",\n                                        indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\"Input values must be a vector. Got: \",\n                                        values->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\"Input shape must be a vector. Got: \",\n                                        dense_shape->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, values->shape().dim_size(0) == indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            values->shape().dim_size(0),\n            \" values, indices shape: \", indices->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, dense_shape->shape().dim_size(0) == indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", dense_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \", indices->shape().DebugString()));\n    OP_REQUIRES(ctx, dense_shape->NumElements() > 0,\n// fix_end\n// fix_start\n                    \"The shape argument requires at least one element.\"));\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-21736", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `SparseTensorSliceDataset` has an undefined behavior: under certain condition it can be made to dereference a `nullptr` value. The 3 input arguments to `SparseTensorSliceDataset` represent a sparse tensor. However, there are some preconditions that these arguments must satisfy but these are not validated in the implementation. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195410}
{"source": " IRC_PROTOCOL_CALLBACK(352)\n {\n     char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n     int arg_start, length;\n     struct t_irc_channel *ptr_channel;\n     struct t_irc_nick *ptr_nick;\n \n     IRC_PROTOCOL_MIN_ARGS(5);\n \n     if (argc < 8)\n         return WEECHAT_RC_OK;\n \n     pos_attr = NULL;\n     pos_hopcount = NULL;\n     pos_realname = NULL;\n \n     if (argc > 8)\n     {\n// bug_start\n        arg_start = (strcmp (argv[8], \"*\") == 0) ? 9 : 8;\n// bug_end\n         if (argv[arg_start][0] == ':')\n         {\n             pos_attr = NULL;\n             pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n             pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n         }\n         else\n         {\n             pos_attr = argv[arg_start];\n             pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n             pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n         }\n     }\n \n     ptr_channel = irc_channel_search (server, argv[3]);\n     ptr_nick = (ptr_channel) ?\n         irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n \n     if (ptr_nick)\n     {\n         length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n         str_host = malloc (length);\n         if (str_host)\n         {\n             snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n             irc_nick_set_host (ptr_nick, str_host);\n             free (str_host);\n         }\n     }\n \n     if (ptr_channel && ptr_nick && pos_attr)\n     {\n         irc_nick_set_away (server, ptr_channel, ptr_nick,\n                            (pos_attr[0] == 'G') ? 1 : 0);\n     }\n \n     if (ptr_channel && ptr_nick && pos_realname)\n     {\n         if (ptr_nick->realname)\n             free (ptr_nick->realname);\n         if (pos_realname &&\n             weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n         {\n             ptr_nick->realname = strdup (pos_realname);\n         }\n         else\n         {\n             ptr_nick->realname = NULL;\n         }\n     }\n \n     if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n     {\n         weechat_printf_date_tags (\n             irc_msgbuffer_get_target_buffer (\n                 server, NULL, command, \"who\", NULL),\n             date,\n             irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n             \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n             weechat_prefix (\"network\"),\n             IRC_COLOR_CHAT_DELIMITERS,\n             IRC_COLOR_CHAT_CHANNEL,\n             argv[3],\n             IRC_COLOR_CHAT_DELIMITERS,\n             irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n             argv[7],\n             IRC_COLOR_CHAT_DELIMITERS,\n             IRC_COLOR_CHAT_HOST,\n             argv[4],\n             argv[5],\n             IRC_COLOR_CHAT_DELIMITERS,\n             IRC_COLOR_RESET,\n             (pos_attr) ? pos_attr : \"\",\n             (pos_attr) ? \" \" : \"\",\n             (pos_hopcount) ? pos_hopcount : \"\",\n             (pos_hopcount) ? \" \" : \"\",\n             (pos_realname) ? pos_realname : \"\");\n     }\n \n     return WEECHAT_RC_OK;\n }\n \n", "target": "// fix_start\n        arg_start = ((argc > 9) && (strcmp (argv[8], \"*\") == 0)) ? 9 : 8;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-9759", "cve_desc": "A Vulnerability of LG Electronic web OS TV Emulator could allow an attacker to escalate privileges and overwrite certain files. This vulnerability is due to wrong environment setting. An attacker could exploit this vulnerability through crafted configuration files and executable files.", "project": "weechat", "idx": 195471}
{"source": " String string_number_format(double d, int dec,\n                             const String& dec_point,\n                             const String& thousand_sep) {\n   char *tmpbuf = nullptr, *resbuf;\n   char *s, *t;\n   char *dp;\n   int integral;\n   int tmplen, reslen=0;\n   int count=0;\n   int is_negative=0;\n \n   if (d < 0) {\n     is_negative = 1;\n     d = -d;\n   }\n \n   if (dec < 0) dec = 0;\n   d = php_math_round(d, dec);\n \n   String tmpstr(63, ReserveString);\n   tmpbuf = tmpstr.mutableData();\n   tmplen = snprintf(tmpbuf, 64, \"%.*F\", dec, d);\n   if (tmplen < 0) return empty_string();\n// bug_start\n  if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {\n// bug_end\n     tmpstr.setSize(tmplen);\n     return tmpstr;\n   }\n   if (tmplen >= 64) {\n     tmpstr = String(tmplen, ReserveString);\n     tmpbuf = tmpstr.mutableData();\n     tmplen = snprintf(tmpbuf, tmplen + 1, \"%.*F\", dec, d);\n     if (tmplen < 0) return empty_string();\n     if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {\n       tmpstr.setSize(tmplen);\n       return tmpstr;\n     }\n   }\n \n   if (dec) {\n     dp = strpbrk(tmpbuf, \".,\");\n   } else {\n     dp = nullptr;\n   }\n \n   if (dp) {\n     integral = dp - tmpbuf;\n   } else {\n     integral = tmplen;\n   }\n \n   if (!thousand_sep.empty()) {\n     if (integral + thousand_sep.size() * ((integral-1) / 3) < integral) {\n       raise_error(\"String overflow\");\n     }\n \n     integral += ((integral-1) / 3) * thousand_sep.size();\n   }\n \n   reslen = integral;\n \n   if (dec) {\n     reslen += dec;\n \n     if (!dec_point.empty()) {\n       if (reslen + dec_point.size() < dec_point.size()) {\n         raise_error(\"String overflow\");\n       }\n       reslen += dec_point.size();\n     }\n   }\n \n   if (is_negative) {\n     reslen++;\n   }\n   String resstr(reslen, ReserveString);\n   resbuf = resstr.mutableData();\n \n   s = tmpbuf+tmplen-1;\n   t = resbuf+reslen-1;\n \n   if (dec) {\n     int declen = dp ? s - dp : 0;\n     int topad = dec > declen ? dec - declen : 0;\n \n     while (topad--) {\n       *t-- = '0';\n     }\n \n     if (dp) {\n       s -= declen + 1;\n       t -= declen;\n \n       memcpy(t + 1, dp + 1, declen);\n     }\n \n     if (!dec_point.empty()) {\n       memcpy(t + (1 - dec_point.size()), dec_point.data(), dec_point.size());\n       t -= dec_point.size();\n     }\n   }\n \n   while(s >= tmpbuf) {\n     *t-- = *s--;\n     if (thousand_sep && (++count%3)==0 && s>=tmpbuf) {\n       memcpy(t + (1 - thousand_sep.size()),\n              thousand_sep.data(),\n              thousand_sep.size());\n       t -= thousand_sep.size();\n     }\n   }\n \n   if (is_negative) {\n     *t-- = '-';\n   }\n \n   resstr.setSize(reslen);\n   return resstr;\n }\n \n", "target": "// fix_start\n  if (tmplen < 64 && (tmpbuf == nullptr || !isdigit((int)tmpbuf[0]))) {\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2019-11929", "cve_desc": "Insufficient boundary checks when formatting numbers in number_format allows read/write access to out-of-bounds memory, potentially leading to remote code execution. This issue affects HHVM versions prior to 3.30.10, all versions between 4.0.0 and 4.8.5, all versions between 4.9.0 and 4.18.2, and versions 4.19.0, 4.19.1, 4.20.0, 4.20.1, 4.20.2, 4.21.0, 4.22.0, 4.23.0.", "project": "hhvm", "idx": 195565}
{"source": " static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n {\n     VirtQueueElement elem;\n     VirtQueue *vq;\n \n     vq = vser->c_ivq;\n     if (!virtio_queue_ready(vq)) {\n         return 0;\n     }\n     if (!virtqueue_pop(vq, &elem)) {\n         return 0;\n     }\n \n// bug_start\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n// bug_end\n \n     virtqueue_push(vq, &elem, len);\n     virtio_notify(VIRTIO_DEVICE(vser), vq);\n     return len;\n }\n \n", "target": "// fix_start\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2015-5745", "cve_desc": "Buffer overflow in the send_control_msg function in hw/char/virtio-serial-bus.c in QEMU before 2.4.0 allows guest users to cause a denial of service (QEMU process crash) via a crafted virtio control message.", "project": "qemu", "idx": 195626}
{"source": " Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                          TensorHandle* tensor_handle, Device** result) {\n   Device* cpu_device = ctx.HostCPU();\n   string device_name;\n   if (tensor_handle->Type() != TensorHandle::LOCAL) {\n     Device* device = tensor_handle->device();\n     device_name = device != nullptr ? device->name() : cpu_device->name();\n     *result = (device == nullptr ? cpu_device : device);\n   } else if (tensor_handle->dtype == DT_RESOURCE) {\n     const Tensor* tensor;\n     TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n// bug_start\n// bug_end\n     const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n     device_name = handle.device();\n \n     Device* input_device;\n     TF_RETURN_IF_ERROR(\n         ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n     *result = input_device;\n   } else {\n     Device* device = tensor_handle->device();\n     const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n     const bool use_host_memory =\n         is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n                : MTypeFromDType(tensor_handle->dtype);\n     if (use_host_memory) {\n       *result = cpu_device;\n     } else {\n       if (!op.is_function() && device != nullptr && device != cpu_device) {\n         device = absl::get<Device*>(op.Device());\n       }\n       *result = (device == nullptr ? cpu_device : device);\n     }\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-29207", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, multiple TensorFlow operations misbehave in eager mode when the resource handle provided to them is invalid. In graph mode, it would have been impossible to perform these API calls, but migration to TF 2.x eager mode opened up this vulnerability. If the resource handle is empty, then a reference is bound to a null pointer inside TensorFlow codebase (various codepaths). This is undefined behavior. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 195629}
{"source": " njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n     njs_index_t unused)\n {\n     int64_t      i, n, start, length, items, delta, delete;\n     njs_int_t    ret;\n     njs_value_t  *this, value, del_object;\n     njs_array_t  *array, *deleted;\n \n     this = njs_argument(args, 0);\n \n     ret = njs_value_to_object(vm, this);\n     if (njs_slow_path(ret != NJS_OK)) {\n         return ret;\n     }\n \n     ret = njs_object_length(vm, this, &length);\n     if (njs_slow_path(ret == NJS_ERROR)) {\n         return ret;\n     }\n \n     ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n     if (njs_slow_path(ret != NJS_OK)) {\n         return ret;\n     }\n \n     start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n \n     items = 0;\n     delete = 0;\n \n     if (nargs == 2) {\n         delete = length - start;\n \n     } else if (nargs > 2) {\n         items = nargs - 3;\n \n         ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n         if (njs_slow_path(ret != NJS_OK)) {\n             return ret;\n         }\n \n         delete = njs_min(njs_max(delete, 0), length - start);\n     }\n \n     delta = items - delete;\n \n     if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n         njs_type_error(vm, \"Invalid length\");\n         return NJS_ERROR;\n     }\n \n \n     deleted = njs_array_alloc(vm, 0, delete, 0);\n     if (njs_slow_path(deleted == NULL)) {\n         return NJS_ERROR;\n     }\n \n     if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n         array = njs_array(this);\n         for (i = 0, n = start; i < delete; i++, n++) {\n             deleted->start[i] = array->start[n];\n         }\n \n     } else {\n         njs_set_array(&del_object, deleted);\n \n         for (i = 0, n = start; i < delete; i++, n++) {\n             ret = njs_value_property_i64(vm, this, n, &value);\n             if (njs_slow_path(ret == NJS_ERROR)) {\n                 return NJS_ERROR;\n             }\n \n             if (ret == NJS_OK) {\n                 ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                 if (njs_slow_path(ret == NJS_ERROR)) {\n                     return ret;\n                 }\n// bug_start\n// bug_end\n             }\n         }\n \n         ret = njs_object_length_set(vm, &del_object, delete);\n         if (njs_slow_path(ret != NJS_OK)) {\n             return NJS_ERROR;\n         }\n     }\n \n     if (njs_fast_path(njs_is_fast_array(this))) {\n         array = njs_array(this);\n \n         if (delta != 0) {\n             if (delta > 0) {\n                 ret = njs_array_expand(vm, array, 0, delta);\n                 if (njs_slow_path(ret != NJS_OK)) {\n                     return ret;\n                 }\n             }\n \n             ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                         array->length - (start + delete), 0);\n             if (njs_slow_path(ret != NJS_OK)) {\n                 return ret;\n             }\n \n             array->length += delta;\n         }\n \n \n         if (items > 0) {\n             memcpy(&array->start[start], &args[3],\n                    items * sizeof(njs_value_t));\n         }\n \n     } else {\n \n        if (delta != 0) {\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        length - (start + delete), delta < 0);\n             if (njs_slow_path(ret != NJS_OK)) {\n                 return ret;\n             }\n \n             for (i = length - 1; i >= length + delta; i--) {\n                 ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                 if (njs_slow_path(ret == NJS_ERROR)) {\n                     return NJS_ERROR;\n                 }\n             }\n        }\n \n \n         for (i = 3, n = start; items-- > 0; i++, n++) {\n             ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n             if (njs_slow_path(ret == NJS_ERROR)) {\n                 return NJS_ERROR;\n             }\n         }\n \n         ret = njs_object_length_set(vm, this, length + delta);\n         if (njs_slow_path(ret != NJS_OK)) {\n             return NJS_ERROR;\n         }\n     }\n \n     njs_set_array(&vm->retval, deleted);\n \n     return NJS_OK;\n }\n \n", "target": "// fix_start\n\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-29779", "cve_desc": "Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the function njs_value_own_enumerate at src/njs_value.c.", "project": "njs", "idx": 195665}
{"source": " static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n {\n     pj_xml_node *node;\n     pj_str_t end_name;\n \n     PJ_CHECK_STACK();\n \n     if (*scanner->curptr != '<')\n \ton_syntax_error(scanner);\n \n     if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n \tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n \tfor (;;) {\n \t    pj_str_t dummy;\n \t    pj_scan_get_until_ch(scanner, '?', &dummy);\n \t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n \t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n \t\tbreak;\n \t    } else {\n \t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n \t    }\n \t}\n \treturn xml_parse_node(pool, scanner);\n     }\n \n     if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n \tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n \tfor (;;) {\n \t    pj_str_t dummy;\n \t    pj_scan_get_until_ch(scanner, '>', &dummy);\n \t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n \t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n \t\tbreak;\n \t    } else {\n \t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n \t    }\n \t}\n \treturn xml_parse_node(pool, scanner);\n     }\n \n     node = alloc_node(pool);\n \n     pj_scan_get_char(scanner);\n \n     pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n \n     while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n \tpj_xml_attr *attr = alloc_attr(pool);\n \n \tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n \tif (*scanner->curptr == '=') {\n \t    pj_scan_get_char( scanner );\n             pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n \t    ++attr->value.ptr;\n \t    attr->value.slen -= 2;\n \t}\n \n \tpj_list_push_back( &node->attr_head, attr );\n     }\n \n     if (*scanner->curptr == '/') {\n \tpj_scan_get_char(scanner);\n \tif (pj_scan_get_char(scanner) != '>')\n \t    on_syntax_error(scanner);\n \treturn node;\n     }\n \n     if (pj_scan_get_char(scanner) != '>')\n \ton_syntax_error(scanner);\n \n     while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n \t\t\t\t   && *(scanner->curptr+1) != '!')\n     {\n \tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n \tpj_list_push_back( &node->node_head, sub_node );\n     }\n \n     if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n \tpj_scan_get_until_ch(scanner, '<', &node->content);\n     }\n \n     if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n \tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n     {\n \tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n \tpj_scan_get_until_ch(scanner, ']', &node->content);\n \twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n \t    pj_str_t dummy;\n// bug_start\n// bug_end\n \t    pj_scan_get_until_ch(scanner, ']', &dummy);\n \t}\n \tnode->content.slen = scanner->curptr - node->content.ptr;\n \tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n     }\n \n     if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n \ton_syntax_error(scanner);\n \n     pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n \n     if (pj_stricmp(&node->name, &end_name) != 0)\n \ton_syntax_error(scanner);\n \n     if (pj_scan_get_char(scanner) != '>')\n \ton_syntax_error(scanner);\n \n     return node;\n }\n \n", "target": "// fix_start\n\n\t    pj_scan_advance_n(scanner, 1, PJ_FALSE);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-24763", "cve_desc": "PJSIP is a free and open source multimedia communication library written in the C language. Versions 2.12 and prior contain a denial-of-service vulnerability that affects PJSIP users that consume PJSIP's XML parsing in their apps. Users are advised to update. There are no known workarounds.", "project": "pjproject", "idx": 195670}
{"source": " mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n {\n   const mrb_irep *irep = proc->body.irep;\n   const mrb_pool_value *pool = irep->pool;\n   const mrb_sym *syms = irep->syms;\n   mrb_code insn;\n   int ai = mrb_gc_arena_save(mrb);\n   struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n   struct mrb_jmpbuf c_jmp;\n   uint32_t a;\n   uint16_t b;\n   uint16_t c;\n   mrb_sym mid;\n   const struct mrb_irep_catch_handler *ch;\n \n #ifdef DIRECT_THREADED\n   static const void * const optable[] = {\n #define OPCODE(x,_) &&L_OP_ ## x,\n #include \"mruby/ops.h\"\n #undef OPCODE\n   };\n #endif\n \n   mrb_bool exc_catched = FALSE;\n RETRY_TRY_BLOCK:\n \n   MRB_TRY(&c_jmp) {\n \n   if (exc_catched) {\n     exc_catched = FALSE;\n     mrb_gc_arena_restore(mrb, ai);\n     if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n       goto L_BREAK;\n     goto L_RAISE;\n   }\n   mrb->jmp = &c_jmp;\n   mrb_vm_ci_proc_set(mrb->c->ci, proc);\n \n #define regs (mrb->c->ci->stack)\n   INIT_DISPATCH {\n     CASE(OP_NOP, Z) {\n       NEXT;\n     }\n \n     CASE(OP_MOVE, BB) {\n       regs[a] = regs[b];\n       NEXT;\n     }\n \n     CASE(OP_LOADL, BB) {\n       switch (pool[b].tt) {\n       case IREP_TT_INT32:\n         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n         break;\n       case IREP_TT_INT64:\n #if defined(MRB_INT64)\n         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n         break;\n #else\n #if defined(MRB_64BIT)\n         if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n           regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n           break;\n         }\n #endif\n         goto L_INT_OVERFLOW;\n #endif\n       case IREP_TT_BIGINT:\n #ifdef MRB_USE_BIGINT\n         {\n           const char *s = pool[b].u.str;\n           regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n         }\n         break;\n #else\n         goto L_INT_OVERFLOW;\n #endif\n #ifndef MRB_NO_FLOAT\n       case IREP_TT_FLOAT:\n         regs[a] = mrb_float_value(mrb, pool[b].u.f);\n         break;\n #endif\n       default:\n         regs[a] = mrb_nil_value();\n         break;\n       }\n       NEXT;\n     }\n \n     CASE(OP_LOADI, BB) {\n       SET_FIXNUM_VALUE(regs[a], b);\n       NEXT;\n     }\n \n     CASE(OP_LOADINEG, BB) {\n       SET_FIXNUM_VALUE(regs[a], -b);\n       NEXT;\n     }\n \n     CASE(OP_LOADI__1,B) goto L_LOADI;\n     CASE(OP_LOADI_0,B) goto L_LOADI;\n     CASE(OP_LOADI_1,B) goto L_LOADI;\n     CASE(OP_LOADI_2,B) goto L_LOADI;\n     CASE(OP_LOADI_3,B) goto L_LOADI;\n     CASE(OP_LOADI_4,B) goto L_LOADI;\n     CASE(OP_LOADI_5,B) goto L_LOADI;\n     CASE(OP_LOADI_6,B) goto L_LOADI;\n     CASE(OP_LOADI_7, B) {\n     L_LOADI:\n       SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n       NEXT;\n     }\n \n     CASE(OP_LOADI16, BS) {\n       SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n       NEXT;\n     }\n \n     CASE(OP_LOADI32, BSS) {\n       SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n       NEXT;\n     }\n \n     CASE(OP_LOADSYM, BB) {\n       SET_SYM_VALUE(regs[a], syms[b]);\n       NEXT;\n     }\n \n     CASE(OP_LOADNIL, B) {\n       SET_NIL_VALUE(regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_LOADSELF, B) {\n       regs[a] = regs[0];\n       NEXT;\n     }\n \n     CASE(OP_LOADT, B) {\n       SET_TRUE_VALUE(regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_LOADF, B) {\n       SET_FALSE_VALUE(regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETGV, BB) {\n       mrb_value val = mrb_gv_get(mrb, syms[b]);\n       regs[a] = val;\n       NEXT;\n     }\n \n     CASE(OP_SETGV, BB) {\n       mrb_gv_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETSV, BB) {\n       mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n       regs[a] = val;\n       NEXT;\n     }\n \n     CASE(OP_SETSV, BB) {\n       mrb_vm_special_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETIV, BB) {\n       regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n       NEXT;\n     }\n \n     CASE(OP_SETIV, BB) {\n       mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETCV, BB) {\n       mrb_value val;\n       val = mrb_vm_cv_get(mrb, syms[b]);\n       regs[a] = val;\n       NEXT;\n     }\n \n     CASE(OP_SETCV, BB) {\n       mrb_vm_cv_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETIDX, B) {\n       mrb_value va = regs[a], vb = regs[a+1];\n       switch (mrb_type(va)) {\n       case MRB_TT_ARRAY:\n         if (!mrb_integer_p(vb)) goto getidx_fallback;\n         regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n         break;\n       case MRB_TT_HASH:\n         va = mrb_hash_get(mrb, va, vb);\n         regs[a] = va;\n         break;\n       case MRB_TT_STRING:\n         switch (mrb_type(vb)) {\n         case MRB_TT_INTEGER:\n         case MRB_TT_STRING:\n         case MRB_TT_RANGE:\n           va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n           regs[a] = va;\n           break;\n         default:\n           goto getidx_fallback;\n         }\n         break;\n       default:\n       getidx_fallback:\n         mid = MRB_OPSYM(aref);\n         goto L_SEND_SYM;\n       }\n       NEXT;\n     }\n \n     CASE(OP_SETIDX, B) {\n       c = 2;\n       mid = MRB_OPSYM(aset);\n       SET_NIL_VALUE(regs[a+3]);\n       goto L_SENDB_SYM;\n     }\n \n     CASE(OP_GETCONST, BB) {\n       mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n       regs[a] = v;\n       NEXT;\n     }\n \n     CASE(OP_SETCONST, BB) {\n       mrb_vm_const_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETMCNST, BB) {\n       mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n       regs[a] = v;\n       NEXT;\n     }\n \n     CASE(OP_SETMCNST, BB) {\n       mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETUPVAR, BBB) {\n       mrb_value *regs_a = regs + a;\n       struct REnv *e = uvenv(mrb, c);\n \n       if (e && b < MRB_ENV_LEN(e)) {\n         *regs_a = e->stack[b];\n       }\n       else {\n         *regs_a = mrb_nil_value();\n       }\n       NEXT;\n     }\n \n     CASE(OP_SETUPVAR, BBB) {\n       struct REnv *e = uvenv(mrb, c);\n \n       if (e) {\n         mrb_value *regs_a = regs + a;\n \n         if (b < MRB_ENV_LEN(e)) {\n           e->stack[b] = *regs_a;\n           mrb_write_barrier(mrb, (struct RBasic*)e);\n         }\n       }\n       NEXT;\n     }\n \n     CASE(OP_JMP, S) {\n       pc += (int16_t)a;\n       JUMP;\n     }\n     CASE(OP_JMPIF, BS) {\n       if (mrb_test(regs[a])) {\n         pc += (int16_t)b;\n         JUMP;\n       }\n       NEXT;\n     }\n     CASE(OP_JMPNOT, BS) {\n       if (!mrb_test(regs[a])) {\n         pc += (int16_t)b;\n         JUMP;\n       }\n       NEXT;\n     }\n     CASE(OP_JMPNIL, BS) {\n       if (mrb_nil_p(regs[a])) {\n         pc += (int16_t)b;\n         JUMP;\n       }\n       NEXT;\n     }\n \n     CASE(OP_JMPUW, S) {\n       a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n       CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n         struct RBreak *brk = (struct RBreak*)mrb->exc;\n         mrb_value target = mrb_break_value_get(brk);\n         mrb_assert(mrb_integer_p(target));\n         a = (uint32_t)mrb_integer(target);\n         mrb_assert(a >= 0 && a < irep->ilen);\n       }\n       CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n         ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n         if (ch) {\n           if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n             THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n           }\n         }\n       }\n       CHECKPOINT_END(RBREAK_TAG_JUMP);\n \n       mrb->exc = NULL;\n       pc = irep->iseq + a;\n       JUMP;\n     }\n \n     CASE(OP_EXCEPT, B) {\n       mrb_value exc;\n \n       if (mrb->exc == NULL) {\n         exc = mrb_nil_value();\n       }\n       else {\n         switch (mrb->exc->tt) {\n         case MRB_TT_BREAK:\n         case MRB_TT_EXCEPTION:\n           exc = mrb_obj_value(mrb->exc);\n           break;\n         default:\n           mrb_assert(!\"bad mrb_type\");\n           exc = mrb_nil_value();\n           break;\n         }\n         mrb->exc = NULL;\n       }\n       regs[a] = exc;\n       NEXT;\n     }\n     CASE(OP_RESCUE, BB) {\n       mrb_value exc = regs[a];\n       mrb_value e = regs[b];\n       struct RClass *ec;\n \n       switch (mrb_type(e)) {\n       case MRB_TT_CLASS:\n       case MRB_TT_MODULE:\n         break;\n       default:\n         {\n           mrb_value exc;\n \n           exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                     \"class or module required for rescue clause\");\n           mrb_exc_set(mrb, exc);\n           goto L_RAISE;\n         }\n       }\n       ec = mrb_class_ptr(e);\n       regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n       NEXT;\n     }\n \n     CASE(OP_RAISEIF, B) {\n       mrb_value exc = regs[a];\n       if (mrb_break_p(exc)) {\n         mrb->exc = mrb_obj_ptr(exc);\n         goto L_BREAK;\n       }\n       mrb_exc_set(mrb, exc);\n       if (mrb->exc) {\n         goto L_RAISE;\n       }\n       NEXT;\n     }\n \n     CASE(OP_SSEND, BBB) {\n       regs[a] = regs[0];\n       insn = OP_SEND;\n     }\n     goto L_SENDB;\n \n     CASE(OP_SSENDB, BBB) {\n       regs[a] = regs[0];\n     }\n     goto L_SENDB;\n \n     CASE(OP_SEND, BBB)\n     goto L_SENDB;\n \n     L_SEND_SYM:\n     c = 1;\n     SET_NIL_VALUE(regs[a+2]);\n     goto L_SENDB_SYM;\n \n     CASE(OP_SENDB, BBB)\n     L_SENDB:\n     mid = syms[b];\n     L_SENDB_SYM:\n     {\n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_method_t m;\n       struct RClass *cls;\n       mrb_value recv, blk;\n \n       ARGUMENT_NORMALIZE(a, &c, insn);\n \n       recv = regs[a];\n       cls = mrb_class(mrb, recv);\n       m = mrb_method_search_vm(mrb, &cls, mid);\n       if (MRB_METHOD_UNDEF_P(m)) {\n         m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n         mid = MRB_SYM(method_missing);\n       }\n \n       ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n \n       if (MRB_METHOD_CFUNC_P(m)) {\n         if (MRB_METHOD_PROC_P(m)) {\n           struct RProc *p = MRB_METHOD_PROC(m);\n \n           mrb_vm_ci_proc_set(ci, p);\n           recv = p->body.func(mrb, recv);\n         }\n         else {\n           if (MRB_METHOD_NOARG_P(m)) {\n             check_method_noarg(mrb, ci);\n           }\n           recv = MRB_METHOD_FUNC(m)(mrb, recv);\n         }\n         mrb_gc_arena_shrink(mrb, ai);\n         if (mrb->exc) goto L_RAISE;\n         ci = mrb->c->ci;\n         if (mrb_proc_p(blk)) {\n           struct RProc *p = mrb_proc_ptr(blk);\n           if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n             p->flags |= MRB_PROC_ORPHAN;\n           }\n         }\n         if (!ci->u.target_class) {\n           if (ci->cci == CINFO_RESUMED) {\n             mrb->jmp = prev_jmp;\n             return recv;\n           }\n           else {\n             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n             proc = ci[-1].proc;\n             irep = proc->body.irep;\n             pool = irep->pool;\n             syms = irep->syms;\n           }\n         }\n         ci->stack[0] = recv;\n         ci = cipop(mrb);\n         pc = ci->pc;\n       }\n       else {\n         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n         pc = irep->iseq;\n       }\n     }\n     JUMP;\n \n     CASE(OP_CALL, Z) {\n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_value recv = ci->stack[0];\n       struct RProc *m = mrb_proc_ptr(recv);\n \n       ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n       mrb_vm_ci_proc_set(ci, m);\n       if (MRB_PROC_ENV_P(m)) {\n         ci->mid = MRB_PROC_ENV(m)->mid;\n       }\n \n       if (MRB_PROC_CFUNC_P(m)) {\n         recv = MRB_PROC_CFUNC(m)(mrb, recv);\n         mrb_gc_arena_shrink(mrb, ai);\n         if (mrb->exc) goto L_RAISE;\n         ci = cipop(mrb);\n         pc = ci->pc;\n         ci[1].stack[0] = recv;\n         irep = mrb->c->ci->proc->body.irep;\n       }\n       else {\n         proc = m;\n         irep = m->body.irep;\n         if (!irep) {\n           mrb->c->ci->stack[0] = mrb_nil_value();\n           a = 0;\n           c = OP_R_NORMAL;\n           goto L_OP_RETURN_BODY;\n         }\n         mrb_int nargs = mrb_ci_bidx(ci)+1;\n         if (nargs < irep->nregs) {\n           mrb_stack_extend(mrb, irep->nregs);\n           stack_clear(regs+nargs, irep->nregs-nargs);\n         }\n         if (MRB_PROC_ENV_P(m)) {\n           regs[0] = MRB_PROC_ENV(m)->stack[0];\n         }\n         pc = irep->iseq;\n       }\n       pool = irep->pool;\n       syms = irep->syms;\n       JUMP;\n     }\n \n     CASE(OP_SUPER, BB) {\n       mrb_method_t m;\n       struct RClass *cls;\n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_value recv, blk;\n       const struct RProc *p = ci->proc;\n       mrb_sym mid = ci->mid;\n       struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n \n       if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) {\n         mid = p->e.env->mid;\n       }\n \n       if (mid == 0 || !target_class) {\n         mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n         mrb_exc_set(mrb, exc);\n         goto L_RAISE;\n       }\n// bug_start\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n// bug_end\n         target_class = mrb_vm_ci_target_class(ci);\n         if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n           goto super_typeerror;\n         }\n       }\n       recv = regs[0];\n       if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n       super_typeerror: ;\n         mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                             \"self has wrong type to call super in this context\");\n         mrb_exc_set(mrb, exc);\n         goto L_RAISE;\n       }\n \n       ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n \n       cls = target_class->super;\n       m = mrb_method_search_vm(mrb, &cls, mid);\n       if (MRB_METHOD_UNDEF_P(m)) {\n         m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n         mid = MRB_SYM(method_missing);\n       }\n \n       ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n \n       ci->stack[0] = recv;\n \n       if (MRB_METHOD_CFUNC_P(m)) {\n         mrb_value v;\n \n         if (MRB_METHOD_PROC_P(m)) {\n           mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n         }\n         v = MRB_METHOD_CFUNC(m)(mrb, recv);\n         mrb_gc_arena_restore(mrb, ai);\n         if (mrb->exc) goto L_RAISE;\n         ci = mrb->c->ci;\n         mrb_assert(!mrb_break_p(v));\n         if (!mrb_vm_ci_target_class(ci)) {\n           if (ci->cci == CINFO_RESUMED) {\n             mrb->jmp = prev_jmp;\n             return v;\n           }\n           else {\n             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n             proc = ci[-1].proc;\n             irep = proc->body.irep;\n             pool = irep->pool;\n             syms = irep->syms;\n           }\n         }\n         mrb->c->ci->stack[0] = v;\n         ci = cipop(mrb);\n         pc = ci->pc;\n       }\n       else {\n         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n         pc = irep->iseq;\n       }\n       JUMP;\n     }\n \n     CASE(OP_ARGARY, BS) {\n       mrb_int m1 = (b>>11)&0x3f;\n       mrb_int r  = (b>>10)&0x1;\n       mrb_int m2 = (b>>5)&0x1f;\n       mrb_int kd = (b>>4)&0x1;\n       mrb_int lv = (b>>0)&0xf;\n       mrb_value *stack;\n \n       if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n         mrb_value exc;\n \n       L_NOSUPER:\n         exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n         mrb_exc_set(mrb, exc);\n         goto L_RAISE;\n       }\n       if (lv == 0) stack = regs + 1;\n       else {\n         struct REnv *e = uvenv(mrb, lv-1);\n         if (!e) goto L_NOSUPER;\n         if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n           goto L_NOSUPER;\n         stack = e->stack + 1;\n       }\n       if (r == 0) {\n         regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n       }\n       else {\n         mrb_value *pp = NULL;\n         struct RArray *rest;\n         mrb_int len = 0;\n \n         if (mrb_array_p(stack[m1])) {\n           struct RArray *ary = mrb_ary_ptr(stack[m1]);\n \n           pp = ARY_PTR(ary);\n           len = ARY_LEN(ary);\n         }\n         regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n         rest = mrb_ary_ptr(regs[a]);\n         if (m1 > 0) {\n           stack_copy(ARY_PTR(rest), stack, m1);\n         }\n         if (len > 0) {\n           stack_copy(ARY_PTR(rest)+m1, pp, len);\n         }\n         if (m2 > 0) {\n           stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n         }\n         ARY_SET_LEN(rest, m1+len+m2);\n       }\n       if (kd) {\n         regs[a+1] = stack[m1+r+m2];\n         regs[a+2] = stack[m1+r+m2+1];\n       }\n       else {\n         regs[a+1] = stack[m1+r+m2];\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_ENTER, W) {\n       mrb_int m1 = MRB_ASPEC_REQ(a);\n       mrb_int o  = MRB_ASPEC_OPT(a);\n       mrb_int r  = MRB_ASPEC_REST(a);\n       mrb_int m2 = MRB_ASPEC_POST(a);\n       mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n       mrb_int const len = m1 + o + r + m2;\n \n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_int argc = ci->n;\n       mrb_value *argv = regs+1;\n       mrb_value * const argv0 = argv;\n       mrb_int const kw_pos = len + kd;\n       mrb_int const blk_pos = kw_pos + 1;\n       mrb_value blk = regs[mrb_ci_bidx(ci)];\n       mrb_value kdict = mrb_nil_value();\n \n       if (ci->nk > 0) {\n         mrb_int kidx = mrb_ci_kidx(ci);\n         kdict = regs[kidx];\n         if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n           kdict = mrb_nil_value();\n           ci->nk = 0;\n         }\n       }\n       if (!kd && !mrb_nil_p(kdict)) {\n         if (argc < 14) {\n           ci->n++;\n           argc++;\n         }\n         else if (argc == 14) {\n           regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n           argc = ci->n = 15;\n         }\n         else {\n           mrb_ary_push(mrb, regs[1], regs[2]);\n         }\n         ci->nk = 0;\n       }\n       if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n         kdict = mrb_hash_dup(mrb, kdict);\n       }\n \n       if (argc == 15) {\n         struct RArray *ary = mrb_ary_ptr(regs[1]);\n         argv = ARY_PTR(ary);\n         argc = (int)ARY_LEN(ary);\n         mrb_gc_protect(mrb, regs[1]);\n       }\n \n       if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n         if (argc < m1 + m2 || (r == 0 && argc > len)) {\n           argnum_error(mrb, m1+m2);\n           goto L_RAISE;\n         }\n       }\n       else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n         mrb_gc_protect(mrb, argv[0]);\n         argc = (int)RARRAY_LEN(argv[0]);\n         argv = RARRAY_PTR(argv[0]);\n       }\n \n       mrb_value rest = mrb_nil_value();\n       if (argc < len) {\n         mrb_int mlen = m2;\n         if (argc < m1+m2) {\n           mlen = m1 < argc ? argc - m1 : 0;\n         }\n \n         if (argv0 != argv && argv) {\n           value_move(&regs[1], argv, argc-mlen);\n         }\n         if (argc < m1) {\n           stack_clear(&regs[argc+1], m1-argc);\n         }\n         if (mlen) {\n           value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n         }\n         if (mlen < m2) {\n           stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n         }\n         if (r) {\n           rest = mrb_ary_new_capa(mrb, 0);\n           regs[m1+o+1] = rest;\n         }\n         if (o > 0 && argc > m1+m2)\n           pc += (argc - m1 - m2)*3;\n       }\n       else {\n         mrb_int rnum = 0;\n         if (argv0 != argv) {\n           value_move(&regs[1], argv, m1+o);\n         }\n         if (r) {\n           rnum = argc-m1-o-m2;\n           rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n           regs[m1+o+1] = rest;\n         }\n         if (m2 > 0 && argc-m2 > m1) {\n           value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n         }\n         pc += o*3;\n       }\n \n       regs[blk_pos] = blk;\n       if (kd) {\n         if (mrb_nil_p(kdict))\n           kdict = mrb_hash_new_capa(mrb, 0);\n         regs[kw_pos] = kdict;\n       }\n \n       mrb->c->ci->n = (uint8_t)len;\n \n       if (irep->nlocals-blk_pos-1 > 0) {\n         stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n       }\n       JUMP;\n     }\n \n     CASE(OP_KARG, BB) {\n       mrb_value k = mrb_symbol_value(syms[b]);\n       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n       mrb_value kdict, v;\n \n       if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n         mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n         goto L_RAISE;\n       }\n       v = mrb_hash_get(mrb, kdict, k);\n       regs[a] = v;\n       mrb_hash_delete_key(mrb, kdict, k);\n       NEXT;\n     }\n \n     CASE(OP_KEY_P, BB) {\n       mrb_value k = mrb_symbol_value(syms[b]);\n       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n       mrb_value kdict;\n       mrb_bool key_p = FALSE;\n \n       if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n         key_p = mrb_hash_key_p(mrb, kdict, k);\n       }\n       regs[a] = mrb_bool_value(key_p);\n       NEXT;\n     }\n \n     CASE(OP_KEYEND, Z) {\n       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n       mrb_value kdict;\n \n       if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n         mrb_value keys = mrb_hash_keys(mrb, kdict);\n         mrb_value key1 = RARRAY_PTR(keys)[0];\n         mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n         goto L_RAISE;\n       }\n       NEXT;\n     }\n \n     CASE(OP_BREAK, B) {\n       c = OP_R_BREAK;\n       goto L_RETURN;\n     }\n     CASE(OP_RETURN_BLK, B) {\n       c = OP_R_RETURN;\n       goto L_RETURN;\n     }\n     CASE(OP_RETURN, B)\n     c = OP_R_NORMAL;\n     L_RETURN:\n     {\n       mrb_callinfo *ci;\n \n       ci = mrb->c->ci;\n       if (ci->mid) {\n         mrb_value blk = regs[mrb_ci_bidx(ci)];\n \n         if (mrb_proc_p(blk)) {\n           struct RProc *p = mrb_proc_ptr(blk);\n \n           if (!MRB_PROC_STRICT_P(p) &&\n               ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n             p->flags |= MRB_PROC_ORPHAN;\n           }\n         }\n       }\n \n       if (mrb->exc) {\n       L_RAISE:\n         ci = mrb->c->ci;\n         if (ci == mrb->c->cibase) {\n           ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n           if (ch == NULL) goto L_FTOP;\n           goto L_CATCH;\n         }\n         while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n           ci = cipop(mrb);\n           if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n             mrb->jmp = prev_jmp;\n             MRB_THROW(prev_jmp);\n           }\n           pc = ci[0].pc;\n           if (ci == mrb->c->cibase) {\n             ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n             if (ch == NULL) {\n             L_FTOP:\n               if (mrb->c == mrb->root_c) {\n                 mrb->c->ci->stack = mrb->c->stbase;\n                 goto L_STOP;\n               }\n               else {\n                 struct mrb_context *c = mrb->c;\n \n                 c->status = MRB_FIBER_TERMINATED;\n                 mrb->c = c->prev;\n                 c->prev = NULL;\n                 goto L_RAISE;\n               }\n             }\n             break;\n           }\n         }\n       L_CATCH:\n         if (ch == NULL) goto L_STOP;\n         if (FALSE) {\n         L_CATCH_TAGGED_BREAK:\n           ci = mrb->c->ci;\n         }\n         proc = ci->proc;\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n         mrb_stack_extend(mrb, irep->nregs);\n         pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n       }\n       else {\n         mrb_int acc;\n         mrb_value v;\n \n         ci = mrb->c->ci;\n         v = regs[a];\n         mrb_gc_protect(mrb, v);\n         switch (c) {\n         case OP_R_RETURN:\n           if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n             const struct RProc *dst;\n             mrb_callinfo *cibase;\n             cibase = mrb->c->cibase;\n             dst = top_proc(mrb, proc);\n \n             if (MRB_PROC_ENV_P(dst)) {\n               struct REnv *e = MRB_PROC_ENV(dst);\n \n               if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                 goto L_RAISE;\n               }\n             }\n             while (cibase <= ci && ci->proc != dst) {\n               if (ci->cci > CINFO_NONE) {\n                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                 goto L_RAISE;\n               }\n               ci--;\n             }\n             if (ci <= cibase) {\n               localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n               goto L_RAISE;\n             }\n             ci = mrb->c->ci;\n             while (cibase <= ci && ci->proc != dst) {\n               CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                 cibase = mrb->c->cibase;\n                 dst = top_proc(mrb, proc);\n               }\n               CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                 UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n               }\n               CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n               ci = cipop(mrb);\n               pc = ci->pc;\n             }\n             proc = ci->proc;\n             mrb->exc = NULL;\n             break;\n           }\n         case OP_R_NORMAL:\n         NORMAL_RETURN:\n           if (ci == mrb->c->cibase) {\n             struct mrb_context *c;\n             c = mrb->c;\n \n             if (!c->prev) {\n               regs[irep->nlocals] = v;\n               goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n             }\n             if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n               mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n               mrb_exc_set(mrb, exc);\n               goto L_RAISE;\n             }\n             CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n               c = mrb->c;\n             }\n             CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n             }\n             CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n             c->status = MRB_FIBER_TERMINATED;\n             mrb->c = c->prev;\n             mrb->c->status = MRB_FIBER_RUNNING;\n             c->prev = NULL;\n             if (c->vmexec) {\n               mrb_gc_arena_restore(mrb, ai);\n               c->vmexec = FALSE;\n               mrb->jmp = prev_jmp;\n               return v;\n             }\n             ci = mrb->c->ci;\n           }\n           CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n           }\n           CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n           }\n           CHECKPOINT_END(RBREAK_TAG_RETURN);\n           mrb->exc = NULL;\n           break;\n         case OP_R_BREAK:\n           if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n           if (MRB_PROC_ORPHAN_P(proc)) {\n             mrb_value exc;\n \n           L_BREAK_ERROR:\n             exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                       \"break from proc-closure\");\n             mrb_exc_set(mrb, exc);\n             goto L_RAISE;\n           }\n           if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n             goto L_BREAK_ERROR;\n           }\n           else {\n             struct REnv *e = MRB_PROC_ENV(proc);\n \n             if (e->cxt != mrb->c) {\n               goto L_BREAK_ERROR;\n             }\n           }\n           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n           }\n           CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n           }\n           CHECKPOINT_END(RBREAK_TAG_BREAK);\n           if (ci == mrb->c->cibase && ci->pc) {\n             struct mrb_context *c = mrb->c;\n \n             mrb->c = c->prev;\n             c->prev = NULL;\n             ci = mrb->c->ci;\n           }\n           if (ci->cci > CINFO_NONE) {\n             ci = cipop(mrb);\n             mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n             mrb_gc_arena_restore(mrb, ai);\n             mrb->c->vmexec = FALSE;\n             mrb->jmp = prev_jmp;\n             MRB_THROW(prev_jmp);\n           }\n           if (FALSE) {\n             struct RBreak *brk;\n \n           L_BREAK:\n             brk = (struct RBreak*)mrb->exc;\n             proc = mrb_break_proc_get(brk);\n             v = mrb_break_value_get(brk);\n             ci = mrb->c->ci;\n \n             switch (mrb_break_tag_get(brk)) {\n #define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n               RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n #undef DISPATCH_CHECKPOINTS\n               default:\n                 mrb_assert(!\"wrong break tag\");\n             }\n           }\n           while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n             if (ci[-1].cci == CINFO_SKIP) {\n               goto L_BREAK_ERROR;\n             }\n             CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n             }\n             CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n             }\n             CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n             ci = cipop(mrb);\n             pc = ci->pc;\n           }\n           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n           }\n           CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n           }\n           CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n           if (ci == mrb->c->cibase) {\n             goto L_BREAK_ERROR;\n           }\n           mrb->exc = NULL;\n           break;\n         default:\n           break;\n         }\n         mrb_assert(ci == mrb->c->ci);\n         mrb_assert(mrb->exc == NULL);\n \n         if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n           mrb_gc_arena_restore(mrb, ai);\n           mrb->c->vmexec = FALSE;\n           mrb->jmp = prev_jmp;\n           return v;\n         }\n         acc = ci->cci;\n         ci = cipop(mrb);\n         if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n           mrb_gc_arena_restore(mrb, ai);\n           mrb->jmp = prev_jmp;\n           return v;\n         }\n         pc = ci->pc;\n         DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n         proc = ci->proc;\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n \n         ci[1].stack[0] = v;\n         mrb_gc_arena_restore(mrb, ai);\n       }\n       JUMP;\n     }\n \n     CASE(OP_BLKPUSH, BS) {\n       int m1 = (b>>11)&0x3f;\n       int r  = (b>>10)&0x1;\n       int m2 = (b>>5)&0x1f;\n       int kd = (b>>4)&0x1;\n       int lv = (b>>0)&0xf;\n       mrb_value *stack;\n \n       if (lv == 0) stack = regs + 1;\n       else {\n         struct REnv *e = uvenv(mrb, lv-1);\n         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n             MRB_ENV_LEN(e) <= m1+r+m2+1) {\n           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n           goto L_RAISE;\n         }\n         stack = e->stack + 1;\n       }\n       if (mrb_nil_p(stack[m1+r+m2+kd])) {\n         localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n         goto L_RAISE;\n       }\n       regs[a] = stack[m1+r+m2+kd];\n       NEXT;\n     }\n \n #if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)\n   L_INT_OVERFLOW:\n     {\n       mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n       mrb_exc_set(mrb, exc);\n     }\n     goto L_RAISE;\n #endif\n \n #define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n #define OP_MATH(op_name)                                                    \\\n                                      \\\n   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n     OP_MATH_CASE_INTEGER(op_name);                                          \\\n     OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n     OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n     OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n     OP_MATH_CASE_STRING_##op_name();                                        \\\n     default:                                                                \\\n       mid = MRB_OPSYM(op_name);                                             \\\n       goto L_SEND_SYM;                                                      \\\n   }                                                                         \\\n   NEXT;\n #define OP_MATH_CASE_INTEGER(op_name)                                       \\\n   case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n     {                                                                       \\\n       mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n       if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n         OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n       }                                                                     \\\n       else                                                                  \\\n         SET_INT_VALUE(mrb,regs[a], z);                                      \\\n     }                                                                       \\\n     break\n #ifdef MRB_NO_FLOAT\n #define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n #else\n #define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n   case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n     {                                                                           \\\n       mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n       SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n     }                                                                           \\\n     break\n #endif\n #ifdef MRB_USE_BIGINT\n #define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y)\n #else\n #define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW\n #endif\n #define OP_MATH_CASE_STRING_add()                                           \\\n   case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n     regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n     mrb_gc_arena_restore(mrb, ai);                                          \\\n     break\n #define OP_MATH_CASE_STRING_sub() (void)0\n #define OP_MATH_CASE_STRING_mul() (void)0\n #define OP_MATH_OP_add +\n #define OP_MATH_OP_sub -\n #define OP_MATH_OP_mul *\n #define OP_MATH_TT_integer MRB_TT_INTEGER\n #define OP_MATH_TT_float   MRB_TT_FLOAT\n \n     CASE(OP_ADD, B) {\n       OP_MATH(add);\n     }\n \n     CASE(OP_SUB, B) {\n       OP_MATH(sub);\n     }\n \n     CASE(OP_MUL, B) {\n       OP_MATH(mul);\n     }\n \n     CASE(OP_DIV, B) {\n #ifndef MRB_NO_FLOAT\n       mrb_float x, y, f;\n #endif\n \n       switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n       case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n         {\n           mrb_int x = mrb_integer(regs[a]);\n           mrb_int y = mrb_integer(regs[a+1]);\n           mrb_int div = mrb_div_int(mrb, x, y);\n           SET_INT_VALUE(mrb, regs[a], div);\n         }\n         NEXT;\n #ifndef MRB_NO_FLOAT\n       case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n         x = (mrb_float)mrb_integer(regs[a]);\n         y = mrb_float(regs[a+1]);\n         break;\n       case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n         x = mrb_float(regs[a]);\n         y = (mrb_float)mrb_integer(regs[a+1]);\n         break;\n       case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n         x = mrb_float(regs[a]);\n         y = mrb_float(regs[a+1]);\n         break;\n #endif\n       default:\n         mid = MRB_OPSYM(div);\n         goto L_SEND_SYM;\n       }\n \n #ifndef MRB_NO_FLOAT\n       f = mrb_div_float(x, y);\n       SET_FLOAT_VALUE(mrb, regs[a], f);\n #endif\n       NEXT;\n     }\n \n #define OP_MATHI(op_name)                                                   \\\n                                      \\\n   switch (mrb_type(regs[a])) {                                              \\\n     OP_MATHI_CASE_INTEGER(op_name);                                         \\\n     OP_MATHI_CASE_FLOAT(op_name);                                           \\\n     default:                                                                \\\n       SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n       mid = MRB_OPSYM(op_name);                                             \\\n       goto L_SEND_SYM;                                                      \\\n   }                                                                         \\\n   NEXT;\n #define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n   case MRB_TT_INTEGER:                                                      \\\n     {                                                                       \\\n       mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n       if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n         OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n       }                                                                     \\\n       else                                                                  \\\n         SET_INT_VALUE(mrb,regs[a], z);                                      \\\n     }                                                                       \\\n     break\n #ifdef MRB_NO_FLOAT\n #define OP_MATHI_CASE_FLOAT(op_name) (void)0\n #else\n #define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n   case MRB_TT_FLOAT:                                                        \\\n     {                                                                       \\\n       mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n       SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n     }                                                                       \\\n     break\n #endif\n \n     CASE(OP_ADDI, BB) {\n       OP_MATHI(add);\n     }\n \n     CASE(OP_SUBI, BB) {\n       OP_MATHI(sub);\n     }\n \n #define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n \n #ifdef MRB_NO_FLOAT\n #define OP_CMP(op,sym) do {\\\n   int result;\\\n   \\\n   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n     break;\\\n   default:\\\n     mid = MRB_OPSYM(sym);\\\n     goto L_SEND_SYM;\\\n   }\\\n   if (result) {\\\n     SET_TRUE_VALUE(regs[a]);\\\n   }\\\n   else {\\\n     SET_FALSE_VALUE(regs[a]);\\\n   }\\\n } while(0)\n #else\n #define OP_CMP(op, sym) do {\\\n   int result;\\\n   \\\n   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n     break;\\\n   case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n     result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n     break;\\\n   case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n     result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n     break;\\\n   case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n     result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n     break;\\\n   default:\\\n     mid = MRB_OPSYM(sym);\\\n     goto L_SEND_SYM;\\\n   }\\\n   if (result) {\\\n     SET_TRUE_VALUE(regs[a]);\\\n   }\\\n   else {\\\n     SET_FALSE_VALUE(regs[a]);\\\n   }\\\n } while(0)\n #endif\n \n     CASE(OP_EQ, B) {\n       if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n         SET_TRUE_VALUE(regs[a]);\n       }\n       else {\n         OP_CMP(==,eq);\n       }\n       NEXT;\n     }\n \n     CASE(OP_LT, B) {\n       OP_CMP(<,lt);\n       NEXT;\n     }\n \n     CASE(OP_LE, B) {\n       OP_CMP(<=,le);\n       NEXT;\n     }\n \n     CASE(OP_GT, B) {\n       OP_CMP(>,gt);\n       NEXT;\n     }\n \n     CASE(OP_GE, B) {\n       OP_CMP(>=,ge);\n       NEXT;\n     }\n \n     CASE(OP_ARRAY, BB) {\n       regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n     CASE(OP_ARRAY2, BBB) {\n       regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_ARYCAT, B) {\n       mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n       if (mrb_nil_p(regs[a])) {\n         regs[a] = splat;\n       }\n       else {\n         mrb_assert(mrb_array_p(regs[a]));\n         mrb_ary_concat(mrb, regs[a], splat);\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_ARYPUSH, BB) {\n       mrb_assert(mrb_array_p(regs[a]));\n       for (mrb_int i=0; i<b; i++) {\n         mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n       }\n       NEXT;\n     }\n \n     CASE(OP_ARYDUP, B) {\n       mrb_value ary = regs[a];\n       if (mrb_array_p(ary)) {\n         ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n       }\n       else {\n         ary = mrb_ary_new_from_values(mrb, 1, &ary);\n       }\n       regs[a] = ary;\n       NEXT;\n     }\n \n     CASE(OP_AREF, BBB) {\n       mrb_value v = regs[b];\n \n       if (!mrb_array_p(v)) {\n         if (c == 0) {\n           regs[a] = v;\n         }\n         else {\n           SET_NIL_VALUE(regs[a]);\n         }\n       }\n       else {\n         v = mrb_ary_ref(mrb, v, c);\n         regs[a] = v;\n       }\n       NEXT;\n     }\n \n     CASE(OP_ASET, BBB) {\n       mrb_assert(mrb_array_p(regs[a]));\n       mrb_ary_set(mrb, regs[b], c, regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_APOST, BBB) {\n       mrb_value v = regs[a];\n       int pre  = b;\n       int post = c;\n       struct RArray *ary;\n       int len, idx;\n \n       if (!mrb_array_p(v)) {\n         v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n       }\n       ary = mrb_ary_ptr(v);\n       len = (int)ARY_LEN(ary);\n       if (len > pre + post) {\n         v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n         regs[a++] = v;\n         while (post--) {\n           regs[a++] = ARY_PTR(ary)[len-post-1];\n         }\n       }\n       else {\n         v = mrb_ary_new_capa(mrb, 0);\n         regs[a++] = v;\n         for (idx=0; idx+pre<len; idx++) {\n           regs[a+idx] = ARY_PTR(ary)[pre+idx];\n         }\n         while (idx < post) {\n           SET_NIL_VALUE(regs[a+idx]);\n           idx++;\n         }\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_INTERN, B) {\n       mrb_assert(mrb_string_p(regs[a]));\n       mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n       regs[a] = mrb_symbol_value(sym);\n       NEXT;\n     }\n \n     CASE(OP_SYMBOL, BB) {\n       size_t len;\n       mrb_sym sym;\n \n       mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n       len = pool[b].tt >> 2;\n       if (pool[b].tt & IREP_TT_SFLAG) {\n         sym = mrb_intern_static(mrb, pool[b].u.str, len);\n       }\n       else {\n         sym  = mrb_intern(mrb, pool[b].u.str, len);\n       }\n       regs[a] = mrb_symbol_value(sym);\n       NEXT;\n     }\n \n     CASE(OP_STRING, BB) {\n       mrb_int len;\n \n       mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n       len = pool[b].tt >> 2;\n       if (pool[b].tt & IREP_TT_SFLAG) {\n         regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n       }\n       else {\n         regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_STRCAT, B) {\n       mrb_assert(mrb_string_p(regs[a]));\n       mrb_str_concat(mrb, regs[a], regs[a+1]);\n       NEXT;\n     }\n \n     CASE(OP_HASH, BB) {\n       mrb_value hash = mrb_hash_new_capa(mrb, b);\n       int i;\n       int lim = a+b*2;\n \n       for (i=a; i<lim; i+=2) {\n         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n       }\n       regs[a] = hash;\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_HASHADD, BB) {\n       mrb_value hash;\n       int i;\n", "target": "// fix_start\n      if ((target_class->flags & MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-1427", "cve_desc": "Out-of-bounds Read in mrb_obj_is_kind_of in in GitHub repository mruby/mruby prior to 3.2. # Impact: Possible arbitrary code execution if being exploited.", "project": "mruby", "idx": 195691}
{"source": "     QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                        const UBaseType_t uxItemSize,\n                                        const uint8_t ucQueueType )\n     {\n         Queue_t * pxNewQueue;\n         size_t xQueueSizeInBytes;\n         uint8_t * pucQueueStorage;\n \n         configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n \n         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize );\n \n         configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n// bug_start\n// bug_end\n \n         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );\n \n         if( pxNewQueue != NULL )\n         {\n             pucQueueStorage = ( uint8_t * ) pxNewQueue;\n             pucQueueStorage += sizeof( Queue_t );\n \n             #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                 {\n                     pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                 }\n             #endif\n \n             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n         }\n         else\n         {\n             traceQUEUE_CREATE_FAILED( ucQueueType );\n             mtCOVERAGE_TEST_MARKER();\n         }\n \n         return pxNewQueue;\n     }\n \n", "target": "// fix_start\n\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-31571", "cve_desc": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in queue.c for queue creation.", "project": "FreeRTOS-Kernel", "idx": 195692}
{"source": " void updateHandshakeState(QuicServerConnectionState& conn) {\n   auto handshakeLayer = conn.serverHandshakeLayer;\n   auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();\n   auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();\n   auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();\n   auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();\n \n   auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();\n   auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();\n \n   if (zeroRttReadCipher) {\n     if (conn.qLogger) {\n       conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);\n     }\n     QUIC_TRACE(fst_trace, conn, \"derived 0-rtt read cipher\");\n     conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));\n   }\n   if (zeroRttHeaderCipher) {\n     conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));\n   }\n   if (oneRttWriteHeaderCipher) {\n     conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);\n   }\n   if (oneRttReadHeaderCipher) {\n     conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));\n   }\n \n   if (oneRttWriteCipher) {\n     if (conn.qLogger) {\n       conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);\n     }\n     QUIC_TRACE(fst_trace, conn, \"derived 1-rtt write cipher\");\n// bug_start\n    CHECK(!conn.oneRttWriteCipher.get());\n// bug_end\n     conn.oneRttWriteCipher = std::move(oneRttWriteCipher);\n \n     updatePacingOnKeyEstablished(conn);\n \n     auto clientParams = handshakeLayer->getClientTransportParams();\n     if (!clientParams) {\n       throw QuicTransportException(\n           \"No client transport params\",\n           TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n     }\n     processClientInitialParams(conn, std::move(*clientParams));\n   }\n   if (oneRttReadCipher) {\n     if (conn.qLogger) {\n       conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);\n     }\n     QUIC_TRACE(fst_trace, conn, \"derived 1-rtt read cipher\");\n     conn.writableBytesLimit = folly::none;\n     conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));\n   }\n   auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();\n   auto handshakeReadHeaderCipher =\n       handshakeLayer->getHandshakeReadHeaderCipher();\n   if (handshakeReadCipher) {\n     CHECK(handshakeReadHeaderCipher);\n     conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));\n     conn.readCodec->setHandshakeHeaderCipher(\n         std::move(handshakeReadHeaderCipher));\n   }\n   if (handshakeLayer->isHandshakeDone()) {\n     CHECK(conn.oneRttWriteCipher);\n     if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {\n       sendSimpleFrame(conn, HandshakeDoneFrame());\n       conn.sentHandshakeDone = true;\n     }\n   }\n }\n \n", "target": "// fix_start\n    if (conn.oneRttWriteCipher) {\n      throw QuicTransportException(\n          \"Duplicate 1-rtt write cipher\", TransportErrorCode::CRYPTO_ERROR);\n    }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-24029", "cve_desc": "A packet of death scenario is possible in mvfst via a specially crafted message during a QUIC session, which causes a crash via a failed assertion. Per QUIC specification, this particular message should be treated as a connection error. This issue affects mvfst versions prior to commit a67083ff4b8dcbb7ee2839da6338032030d712b0 and proxygen versions prior to v2021.03.15.00.", "project": "mvfst", "idx": 195720}
{"source": " bool SampleInterleavedLSScan::ParseMCU(void)\n {\n #if ACCUSOFT_CODE\n   int lines             = m_ulRemaining[0];\n   UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n   struct Line *line[4];\n   UBYTE cx;\n \n   if (m_pFrame->HeightOf() == 0) {\n     assert(lines == 0);\n     lines = 8;\n   }\n   if (lines > 8) {\n     lines = 8;\n   }\n// bug_start\n// bug_end\n   if (m_pFrame->HeightOf() > 0)\n     m_ulRemaining[0] -= lines;\n// bug_start\n  assert(lines > 0);\n// bug_end\n   assert(m_ucCount < 4);\n \n   for(cx = 0;cx < m_ucCount;cx++) {\n     line[cx] = CurrentLine(cx);\n   }\n \n   do {\n     LONG length = m_ulWidth[0];\n     LONG *lp[4];\n \n     for(cx = 0;cx < m_ucCount;cx++) {\n       lp[cx] = line[cx]->m_pData;\n       StartLine(cx);\n     }\n \n     if (BeginReadMCU(m_Stream.ByteStreamOf())) {\n       do {\n         LONG a[4],b[4],c[4],d[4];\n         LONG d1[4],d2[4],d3[4];\n         bool isrun = true;\n \n         for(cx = 0;cx < m_ucCount;cx++) {\n           GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n \n           d1[cx]  = d[cx] - b[cx];\n           d2[cx]  = b[cx] - c[cx];\n           d3[cx]  = c[cx] - a[cx];\n \n           if (isrun && !isRunMode(d1[cx],d2[cx],d3[cx]))\n             isrun = false;\n         }\n \n         if (isrun) {\n           LONG run = DecodeRun(length,m_lRunIndex[0]);\n           while(run) {\n             for(cx = 0;cx < m_ucCount;cx++) {\n               UpdateContext(cx,a[cx]);\n               *lp[cx]++ = a[cx] << preshift;\n             }\n             run--,length--;\n           }\n           if (length) {\n             bool negative;\n             LONG errval;\n             LONG merr;\n             LONG rx;\n             UBYTE k;\n             for(cx = 0;cx < m_ucCount;cx++) {\n               GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n               negative = a[cx] > b[cx];\n               k       = GolombParameter(false);\n               merr    = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n               errval  = InverseErrorMapping(merr,ErrorMappingOffset(false,merr != 0,k));\n               rx      = Reconstruct(negative,b[cx],errval);\n               UpdateContext(cx,rx);\n               *lp[cx]++ = rx << preshift;\n               UpdateState(false,errval);\n             }\n             if (m_lRunIndex[0] > 0)\n               m_lRunIndex[0]--;\n           } else break;\n         } else {\n           UWORD ctxt;\n           bool  negative;\n           LONG  px;\n           LONG  rx;\n           LONG  errval;\n           LONG  merr;\n           UBYTE k;\n           for(cx = 0;cx < m_ucCount;cx++) {\n             d1[cx]  = QuantizedGradient(d1[cx]);\n             d2[cx]  = QuantizedGradient(d2[cx]);\n             d3[cx]  = QuantizedGradient(d3[cx]);\n             ctxt    = Context(negative,d1[cx],d2[cx],d3[cx]);\n             px      = Predict(a[cx],b[cx],c[cx]);\n             px      = CorrectPrediction(ctxt,negative,px);\n             k       = GolombParameter(ctxt);\n             merr    = GolombDecode(k,m_lLimit);\n             errval  = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n             UpdateState(ctxt,errval);\n             rx      = Reconstruct(negative,px,errval);\n             UpdateContext(cx,rx);\n             *lp[cx]++ = rx << preshift;\n           }\n         }\n       } while(--length);\n     }\n     for(cx = 0;cx < m_ucCount;cx++) {\n       EndLine(cx);\n       line[cx] = line[cx]->m_pNext;\n     }\n   } while(--lines);\n   m_Stream.SkipStuffing();\n #endif\n   return false;\n }\n \n", "target": "// fix_start\n\n  if (lines == 0)\n    return false;\n\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-32978", "cve_desc": "There is an assertion failure in SingleComponentLSScan::ParseMCU in singlecomponentlsscan.cpp in libjpeg before 1.64 via an empty JPEG-LS scan.", "project": "libjpeg", "idx": 195740}
{"source": " bool SingleComponentLSScan::ParseMCU(void)\n {\n #if ACCUSOFT_CODE\n   int lines             = m_ulRemaining[0];\n   UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n   struct Line *line     = CurrentLine(0);\n \n   if (m_pFrame->HeightOf() == 0) {\n     assert(lines == 0);\n     lines = 8;\n   }\n \n   assert(m_ucCount == 1);\n \n   if (lines > 8) {\n     lines = 8;\n   }\n   if (m_pFrame->HeightOf() > 0)\n     m_ulRemaining[0] -= lines;\n \n// bug_start\n  assert(lines > 0);\n// bug_end\n \n   do {\n     LONG length = m_ulWidth[0];\n     LONG *lp    = line->m_pData;\n \n #ifdef DEBUG_LS\n     int xpos    = 0;\n     static int linenumber = 0;\n     printf(\"\\n%4d : \",++linenumber);\n #endif\n \n     StartLine(0);\n     if (BeginReadMCU(m_Stream.ByteStreamOf())) {\n       do {\n         LONG a,b,c,d;\n         LONG d1,d2,d3;\n \n         GetContext(0,a,b,c,d);\n         d1  = d - b;\n         d2  = b - c;\n         d3  = c - a;\n \n         if (isRunMode(d1,d2,d3)) {\n           LONG run = DecodeRun(length,m_lRunIndex[0]);\n           while(run) {\n             UpdateContext(0,a);\n             *lp++ = a << preshift;\n #ifdef DEBUG_LS\n             printf(\"%4d:<%2x> \",xpos++,a);\n #endif\n             run--,length--;\n           }\n           if (length) {\n             bool negative;\n             bool rtype;\n             LONG errval;\n             LONG merr;\n             LONG rx;\n             UBYTE k;\n             GetContext(0,a,b,c,d);\n             rtype  = InterruptedPredictionMode(negative,a,b);\n             k      = GolombParameter(rtype);\n             merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n             errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n             rx     = Reconstruct(negative,rtype?a:b,errval);\n             UpdateContext(0,rx);\n             *lp    = rx << preshift;\n #ifdef DEBUG_LS\n             printf(\"%4d:<%2x> \",xpos++,*lp);\n #endif\n             UpdateState(rtype,errval);\n             if (m_lRunIndex[0] > 0)\n               m_lRunIndex[0]--;\n           } else break;\n         } else {\n           UWORD ctxt;\n           bool  negative;\n           LONG  px;\n           LONG  rx;\n           LONG  errval;\n           LONG  merr;\n           UBYTE k;\n           d1     = QuantizedGradient(d1);\n           d2     = QuantizedGradient(d2);\n           d3     = QuantizedGradient(d3);\n           ctxt   = Context(negative,d1,d2,d3);\n           px     = Predict(a,b,c);\n           px     = CorrectPrediction(ctxt,negative,px);\n           k      = GolombParameter(ctxt);\n           merr   = GolombDecode(k,m_lLimit);\n           errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n           UpdateState(ctxt,errval);\n           rx     = Reconstruct(negative,px,errval);\n           UpdateContext(0,rx);\n           *lp    = rx << preshift;\n #ifdef DEBUG_LS\n           printf(\"%4d:<%2x> \",xpos++,*lp);\n #endif\n         }\n       } while(++lp,--length);\n     }\n     EndLine(0);\n     line = line->m_pNext;\n   } while(--lines);\n   m_Stream.SkipStuffing();\n #endif\n   return false;\n }\n \n", "target": "// fix_start\n  if (lines == 0)\n    return false;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-32978", "cve_desc": "There is an assertion failure in SingleComponentLSScan::ParseMCU in singlecomponentlsscan.cpp in libjpeg before 1.64 via an empty JPEG-LS scan.", "project": "libjpeg", "idx": 195741}
{"source": " static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n {\n \tGF_Box *a;\n \tu64 totSize, mdat_end=0;\n \tGF_Err e = GF_OK;\n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n \t\treturn e;\n \t}\n \n \ttotSize = mov->current_top_box_start;\n \tif (mov->bytes_removed) {\n \t\tassert(totSize >= mov->bytes_removed);\n \t\ttotSize -= mov->bytes_removed;\n \t}\n \tgf_bs_seek(mov->movieFileMap->bs, totSize);\n #endif\n \n \n \twhile (gf_bs_available(mov->movieFileMap->bs)) {\n \t\t*bytesMissing = 0;\n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n \t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n #endif\n \n \t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n \n \t\tif (e >= 0) {\n// bug_start\n\n// bug_end\n \t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n \t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\treturn e;\n \t\t} else {\n \t\t\treturn e;\n \t\t}\n \n \t\tswitch (a->type) {\n \t\tcase GF_ISOM_BOX_TYPE_MOOV:\n \t\t\tif (mov->moov) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->moov = (GF_MovieBox *)a;\n \t\t\tmov->original_moov_offset = mov->current_top_box_start;\n \t\t\tmov->moov->mov = mov;\n #ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n \n #ifdef GF_ENABLE_CTRN\n \t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\tgf_isom_setup_traf_inheritance(mov);\n \t\t\t}\n #endif\n \n #endif\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \n \t\t\ttotSize += a->size;\n \n             if (!mov->moov->mvhd) {\n                 GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                 return GF_ISOM_INVALID_FILE;\n             }\n \n             if (mov->meta) {\n \t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n \t\t\t}\n \n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\tu32 k;\n \t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n \t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n \n \t\t\t\t\tif (trak->sample_encryption) {\n \t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n \t\t\t\t\t\tif (e) return e;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tu32 k;\n \t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n \t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n \t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n \t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n             if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                 gf_isom_push_mdat_end(mov, mdat_end);\n                 mdat_end=0;\n             }\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_META:\n \t\t\tif (mov->meta) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->meta = (GF_MetaBox *)a;\n \t\t\tmov->original_meta_offset = mov->current_top_box_start;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) {\n \t\t\t\treturn e;\n \t\t\t}\n \t\t\ttotSize += a->size;\n \t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_MDAT:\n \t\t\tif (!mov->first_data_toplevel_offset) {\n \t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n \t\t\t\tmov->first_data_toplevel_size = a->size;\n \t\t\t}\n \t\t\ttotSize += a->size;\n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\tif (mov->emsgs) {\n \t\t\t\tgf_isom_box_array_del(mov->emsgs);\n \t\t\t\tmov->emsgs = NULL;\n \t\t\t}\n #endif\n \n \t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n \t\t\t\tif (!mov->mdat) {\n \t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n \t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n \t\t\t\t\tif (e) {\n \t\t\t\t\t\treturn e;\n \t\t\t\t\t}\n \t\t\t\t}\n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n #endif\n \t\t\t\telse gf_isom_box_del(a);\n \n \n \t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                     mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                     if (mov->moov) {\n                         gf_isom_push_mdat_end(mov, mdat_end);\n                         mdat_end=0;\n                     }\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n \t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n \t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n \t\t\t\tif (e) {\n \t\t\t\t\treturn e;\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase GF_ISOM_BOX_TYPE_FTYP:\n \t\t\tif (mov->brand) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->brand = (GF_FileTypeBox *)a;\n \t\t\ttotSize += a->size;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_OTYP:\n \t\t\tif (mov->otyp) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\tmov->otyp = (GF_Box *)a;\n \t\t\t\ttotSize += a->size;\n \t\t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (e) return e;\n \t\t\t} else {\n \t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n \t\t\t\tif (brand) {\n \t\t\t\t\ts32 pos;\n \t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n \t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n \t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n \t\t\t\t\tmov->brand = brand;\n \t\t\t\t\tif (pos<0) pos=0;\n \t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n \t\t\t\t}\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_PDIN:\n \t\t\tif (mov->pdin) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n \t\t\ttotSize += a->size;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \t\t\tbreak;\n \n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tcase GF_ISOM_BOX_TYPE_STYP:\n \t\t{\n \t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n \t\t\tswitch (brand) {\n \t\t\tcase GF_ISOM_BRAND_SISX:\n \t\t\tcase GF_ISOM_BRAND_RISX:\n \t\t\tcase GF_ISOM_BRAND_SSSS:\n \t\t\t\tmov->is_index_segment = GF_TRUE;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tcase GF_ISOM_BOX_TYPE_SIDX:\n \t\tcase GF_ISOM_BOX_TYPE_SSIX:\n \t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n \t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n \t\t\t\tmov->first_data_toplevel_size = a->size;\n \t\t\t}\n \t\t\ttotSize += a->size;\n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (e) return e;\n \t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n \t\t\t) {\n \t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n \t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n \t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n \t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n \t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n \n \t\t\t\t}\n \t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n \t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n \n \t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n \t\t\t\t\tmov->seg_styp = a;\n \t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n \t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n \t\t\t\t\tmov->seg_ssix = a;\n \t\t\t\t} else {\n \t\t\t\t\tgf_isom_box_del(a);\n \t\t\t\t}\n \t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n \t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n \t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n \t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n \t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n \t\t\t} else {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_MOOF:\n \t\t\tgf_isom_disable_inplace_rewrite(mov);\n \t\t\tif (!mov->moov) {\n \t\t\t\tGF_LOG(mov->moof ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n \t\t\t}\n \t\t\tif (mov->single_moof_mode) {\n \t\t\t\tmov->single_moof_state++;\n \t\t\t\tif (mov->single_moof_state > 1) {\n \t\t\t\t\tgf_isom_box_del(a);\n \t\t\t\t\treturn GF_OK;\n \t\t\t\t}\n \t\t\t}\n \t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n \n \t\t\ttotSize += a->size;\n \t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n \n \t\t\tFixTrackID(mov);\n \t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\tFixSDTPInTRAF(mov->moof);\n \t\t\t} else {\n \t\t\t\tu32 k;\n \t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n \t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n \t\t\t\t\tif (traf->sampleGroups) {\n \t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\tu32 k;\n \t\t\t\tgf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (mov->moov) {\n \t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n \t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n \t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n \t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n \t\t\t\t\t\t\tu32 j=0;\n \t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n \t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n \t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n \t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\ttraf->trex = NULL;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n \t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n \t\t\t\t\t\t\tif (trak) {\n \t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n \t\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n \t\t\t\t\t\t\t\tif (e) return e;\n \t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n \t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n \t\t\t\t\t\tif (traf->sample_encryption) {\n \t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n \t\t\t\t\t\t\tif (e) return e;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t}\n \t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n \t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n \t\t\t\tmov->moof = NULL;\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t} else {\n \t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tif (e) return e;\n \t\t\t}\n \n \t\t\tif (mov->root_sidx) {\n \t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n \t\t\t\tmov->root_sidx = NULL;\n \t\t\t}\n \t\t\tif (mov->root_ssix) {\n \t\t\t\tgf_isom_box_del(mov->seg_ssix);\n \t\t\t\tmov->root_ssix = NULL;\n \t\t\t}\n \t\t\tif (mov->seg_styp) {\n \t\t\t\tgf_isom_box_del(mov->seg_styp);\n \t\t\t\tmov->seg_styp = NULL;\n \t\t\t}\n \t\t\tmov->sidx_start_offset = 0;\n \t\t\tmov->sidx_end_offset = 0;\n \t\t\tmov->styp_start_offset = 0;\n \t\t\tbreak;\n #endif\n \t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n \t\t{\n \t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n \t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n \t\t\t\tu8 *c = (u8 *) box->data;\n \t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n \t\t\t\t\tmov->is_jp2 = 1;\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t} else {\n \t\t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (e) return e;\n \t\t\t}\n \t\t}\n \t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_PRFT:\n #ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\tif (mov->last_producer_ref_time)\n \t\t\t\t\tgf_isom_box_del(a);\n \t\t\t\telse\n \t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n \t\t\t\tbreak;\n \t\t\t}\n #endif\n \t\tcase GF_ISOM_BOX_TYPE_EMSG:\n #ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\tif (!mov->emsgs) mov->emsgs = gf_list_new();\n \t\t\t\tgf_list_add(mov->emsgs, a);\n \t\t\t\tbreak;\n \t\t\t}\n #endif\n \t\tcase GF_ISOM_BOX_TYPE_MFRA:\n \t\tcase GF_ISOM_BOX_TYPE_MFRO:\n \t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\ttotSize += a->size;\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tbreak;\n \t\t\t}\n \t\tdefault:\n \t\t\ttotSize += a->size;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \t\t\tbreak;\n \t\t}\n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n #endif\n \t}\n \n \tif (!mov->moov && !mov->meta\n #ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n \t        && !mov->moof && !mov->is_index_segment\n #endif\n \t   ) {\n \t\treturn GF_ISOM_INCOMPLETE_FILE;\n \t}\n \tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n \t\tif (mov->moov && !mov->moov->mvhd) {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n \t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t}\n \n \t\tif (mov->meta && !mov->meta->handler) {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n \t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t}\n \t}\n \n #ifndef GPAC_DISABLE_ISOM_WRITE\n \n \tif (mov->moov) {\n \t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n \t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n \t\t\tmov->moov->mvex = NULL;\n \t\t}\n #endif\n \n \t}\n \n \tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n \t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n \t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n \t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n \t\tif (e) return e;\n \t}\n #endif\n \n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\t\tif (!a) return GF_ISOM_INVALID_FILE;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-29340", "cve_desc": "GPAC 2.1-DEV-rev87-g053aae8-master. has a Null Pointer Dereference vulnerability in gf_isom_parse_movie_boxes_internal due to improper return value handling of GF_SKIP_BOX, which causes a Denial of Service. This vulnerability was fixed in commit 37592ad.", "project": "gpac", "idx": 195742}
{"source": "   void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n     const Tensor* indices;\n     OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n     const Tensor* values;\n     OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n     const Tensor* dense_shape;\n     OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n \n     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                 errors::InvalidArgument(\n                     \"Input indices should be a matrix but received shape \",\n                     indices->shape().DebugString()));\n// bug_start\n// bug_end\n     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                 errors::InvalidArgument(\n                     \"Input values should be a vector but received shape \",\n                     indices->shape().DebugString()));\n     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                 errors::InvalidArgument(\n                     \"Input shape should be a vector but received shape \",\n                     dense_shape->shape().DebugString()));\n \n     int64_t previous_batch_index = -1;\n     for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n       int64_t next_batch_index = indices->matrix<int64>()(i, 0);\n       OP_REQUIRES(\n           ctx, next_batch_index >= previous_batch_index,\n           errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                 \"dimension; handling arbitrarily ordered input \"\n                                 \"is not currently supported.\"));\n       previous_batch_index = next_batch_index;\n     }\n     gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);\n     sparse::SparseTensor tensor;\n     OP_REQUIRES_OK(\n         ctx, sparse::SparseTensor::Create(\n                  *indices, *values, TensorShape(dense_shape->vec<int64>()),\n                  std_order, &tensor));\n     *output = new Dataset<T>(ctx, std::move(tensor));\n   }\n \n", "target": "// fix_start\n\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-37647", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices->dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195752}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor* epsilon_t;\n     OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n     float epsilon = epsilon_t->scalar<float>()();\n     OP_REQUIRES(\n         context, epsilon > 0,\n         errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n \n     const Tensor* num_streams_t;\n     OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n     int64_t num_streams = num_streams_t->scalar<int64>()();\n// bug_start\n// bug_end\n \n     auto result =\n         new QuantileStreamResource(epsilon, max_elements_, num_streams);\n     auto status = CreateResource(context, HandleFromInput(context, 0), result);\n     if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n       OP_REQUIRES(context, false, status);\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(context, num_streams >= 0,\n                errors::InvalidArgument(\n                    \"Num_streams input cannot be a negative integer\"));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-37661", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195768}
{"source": " void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n \ti64 pos)\n {\n \ti64 pixmap_version;\n \ti64 pack_size;\n \ti64 plane_bytes;\n \ti64 n;\n \n \tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n \tde_dbg_indent(c, 1);\n \n \tpixmap_version = dbuf_getu16be(f, pos+0);\n \tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n \n \tbi->packing_type = dbuf_getu16be(f, pos+2);\n \tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n \n \tpack_size = dbuf_getu32be(f, pos+4);\n \tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n \n \tbi->hdpi = pict_read_fixed(f, pos+8);\n \tbi->vdpi = pict_read_fixed(f, pos+12);\n \tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n \n \tbi->pixeltype = dbuf_getu16be(f, pos+16);\n \tbi->pixelsize = dbuf_getu16be(f, pos+18);\n \tbi->cmpcount = dbuf_getu16be(f, pos+20);\n \tbi->cmpsize = dbuf_getu16be(f, pos+22);\n \tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n \t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n \n// bug_start\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n// bug_end\n \tif(bi->pdwidth < bi->npwidth) {\n \t\tbi->pdwidth = bi->npwidth;\n \t}\n \n \tplane_bytes = dbuf_getu32be(f, pos+24);\n \tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n \n \tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n \tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n \n \tn = dbuf_getu32be(f, pos+32);\n \tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n \n \tde_dbg_indent(c, -1);\n }\n \n", "target": "// fix_start\n\tif(bi->pixelsize>0) {\n\t\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\t}\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-28856", "cve_desc": "In Deark before v1.5.8, a specially crafted input file can cause a division by zero in (src/fmtutil.c) because of the value of pixelsize.", "project": "deark", "idx": 195800}
{"source": "  */\n static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n {\n \tst_entry \t\t\t*ent1, *ent2;\n \twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n \tHashTable \t\t\t*target_hash;\n \tzend_class_entry \t*pce;\n \tzval\t\t\t\tobj;\n \n \tif (stack->top == 0) {\n \t\treturn;\n \t}\n \n \tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n \t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n \t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n \t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n \t\t!strcmp((char *)name, EL_DATETIME)) {\n \t\twddx_stack_top(stack, (void**)&ent1);\n \n \t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n \t\t\tif (stack->top > 1) {\n \t\t\t\tstack->top--;\n// bug_start\n// bug_end\n \t\t\t} else {\n \t\t\t\tstack->done = 1;\n \t\t\t}\n// bug_start\n\t\t\tefree(ent1);\n// bug_end\n \t\t\treturn;\n \t\t}\n \n \t\tif (!strcmp((char *)name, EL_BINARY)) {\n \t\t\tzend_string *new_str = php_base64_decode(\n \t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n \t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\tZVAL_STR(&ent1->data, new_str);\n \t\t}\n \n \t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n \t\t\tzval fname, retval;\n \n \t\t\tZVAL_STRING(&fname, \"__wakeup\");\n \n \t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n \n \t\t\tzval_ptr_dtor(&fname);\n \t\t\tzval_ptr_dtor(&retval);\n \t\t}\n \n \t\tif (stack->top > 1) {\n \t\t\tstack->top--;\n \t\t\twddx_stack_top(stack, (void**)&ent2);\n \n \t\t\tif (ent2->type == ST_FIELD && Z_ISUNDEF(ent2->data)) {\n \t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\tefree(ent1);\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n \t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n \n \t\t\t\tif (ent1->varname) {\n \t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n \t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n \t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n \t\t\t\t\t\tzend_bool incomplete_class = 0;\n \n \t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n \t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n \t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n \t\t\t\t\t\t\tincomplete_class = 1;\n \t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tobject_init_ex(&obj, pce);\n \n \t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n \t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n \t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n \n \t\t\t\t\t\tif (incomplete_class) {\n \t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n \n \t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n \n \t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n \t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n \n \t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n \t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n \t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n \t\t\t\t\t\tEG(scope) = old_scope;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n \t\t\t\t\t}\n \t\t\t\t\tefree(ent1->varname);\n \t\t\t\t} else\t{\n \t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n \t\t\t\t}\n \t\t\t}\n \t\t\tefree(ent1);\n \t\t} else {\n \t\t\tstack->done = 1;\n \t\t}\n \t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n \t\tefree(stack->varname);\n \t\tstack->varname = NULL;\n \t} else if (!strcmp((char *)name, EL_FIELD)) {\n \t\tst_entry *ent;\n \t\twddx_stack_top(stack, (void **)&ent);\n \t\tefree(ent);\n \t\tstack->top--;\n \t}\n \n", "target": "// fix_start\n\t\t\t\tefree(ent1);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2016-7132", "cve_desc": "ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid wddxPacket XML document that is mishandled in a wddx_deserialize call, as demonstrated by a stray element inside a boolean element, leading to incorrect pop processing.", "project": "php-src", "idx": 195801}
{"source": " int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n \t\t    u64 devid)\n {\n \tstruct btrfs_device *device;\n \tstruct btrfs_fs_devices *cur_devices;\n \tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n \tu64 num_devices;\n \tint ret = 0;\n \n \tmutex_lock(&uuid_mutex);\n \n \tnum_devices = btrfs_num_devices(fs_info);\n \n \tret = btrfs_check_raid_min_devices(fs_info, num_devices - 1);\n \tif (ret)\n \t\tgoto out;\n \n \tdevice = btrfs_find_device_by_devspec(fs_info, devid, device_path);\n \n \tif (IS_ERR(device)) {\n \t\tif (PTR_ERR(device) == -ENOENT &&\n// bug_start\n\t\t    strcmp(device_path, \"missing\") == 0)\n// bug_end\n \t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n \t\telse\n \t\t\tret = PTR_ERR(device);\n \t\tgoto out;\n \t}\n \n \tif (btrfs_pinned_by_swapfile(fs_info, device)) {\n \t\tbtrfs_warn_in_rcu(fs_info,\n \t\t  \"cannot remove device %s (devid %llu) due to active swapfile\",\n \t\t\t\t  rcu_str_deref(device->name), device->devid);\n \t\tret = -ETXTBSY;\n \t\tgoto out;\n \t}\n \n \tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n \t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n \t\tgoto out;\n \t}\n \n \tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n \t    fs_info->fs_devices->rw_devices == 1) {\n \t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n \t\tgoto out;\n \t}\n \n \tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n \t\tmutex_lock(&fs_info->chunk_mutex);\n \t\tlist_del_init(&device->dev_alloc_list);\n \t\tdevice->fs_devices->rw_devices--;\n \t\tmutex_unlock(&fs_info->chunk_mutex);\n \t}\n \n \tmutex_unlock(&uuid_mutex);\n \tret = btrfs_shrink_device(device, 0);\n \tif (!ret)\n \t\tbtrfs_reada_remove_dev(device);\n \tmutex_lock(&uuid_mutex);\n \tif (ret)\n \t\tgoto error_undo;\n \n \tret = btrfs_rm_dev_item(device);\n \tif (ret)\n \t\tgoto error_undo;\n \n \tclear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n \tbtrfs_scrub_cancel_dev(device);\n \n \n \tcur_devices = device->fs_devices;\n \tmutex_lock(&fs_devices->device_list_mutex);\n \tlist_del_rcu(&device->dev_list);\n \n \tcur_devices->num_devices--;\n \tcur_devices->total_devices--;\n \tif (cur_devices != fs_devices)\n \t\tfs_devices->total_devices--;\n \n \tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n \t\tcur_devices->missing_devices--;\n \n \tbtrfs_assign_next_active_device(device, NULL);\n \n \tif (device->bdev) {\n \t\tcur_devices->open_devices--;\n \t\tbtrfs_sysfs_remove_device(device);\n \t}\n \n \tnum_devices = btrfs_super_num_devices(fs_info->super_copy) - 1;\n \tbtrfs_set_super_num_devices(fs_info->super_copy, num_devices);\n \tmutex_unlock(&fs_devices->device_list_mutex);\n \n \tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n \t\tbtrfs_scratch_superblocks(fs_info, device->bdev,\n \t\t\t\t\t  device->name->str);\n \n \tbtrfs_close_bdev(device);\n \tsynchronize_rcu();\n \tbtrfs_free_device(device);\n \n \tif (cur_devices->open_devices == 0) {\n \t\tlist_del_init(&cur_devices->seed_list);\n \t\tclose_fs_devices(cur_devices);\n \t\tfree_fs_devices(cur_devices);\n \t}\n \n out:\n \tmutex_unlock(&uuid_mutex);\n \treturn ret;\n \n error_undo:\n \tbtrfs_reada_undo_remove_dev(device);\n \tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n \t\tmutex_lock(&fs_info->chunk_mutex);\n \t\tlist_add(&device->dev_alloc_list,\n \t\t\t &fs_devices->alloc_list);\n \t\tdevice->fs_devices->rw_devices++;\n \t\tmutex_unlock(&fs_info->chunk_mutex);\n \t}\n \tgoto out;\n }\n \n", "target": "// fix_start\n\t\t    device_path && strcmp(device_path, \"missing\") == 0)\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-3739", "cve_desc": "A NULL pointer dereference flaw was found in the btrfs_rm_device function in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system or leak kernel internal information. The highest threat from this vulnerability is to system availability.", "project": "linux", "idx": 195908}
{"source": " static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n      ExceptionInfo *exception)\n {\n   char\n     page_geometry[MagickPathExtent];\n \n   Image\n     *image;\n \n   MagickBooleanType\n     logging;\n \n   volatile int\n     first_mng_object,\n     object_id,\n     term_chunk_found,\n     skip_to_iend;\n \n   volatile ssize_t\n     image_count=0;\n \n   MagickBooleanType\n     status;\n \n   MagickOffsetType\n     offset;\n \n   MngBox\n     default_fb,\n     fb,\n     previous_fb;\n \n #if defined(MNG_INSERT_LAYERS)\n   PixelInfo\n     mng_background_color;\n #endif\n \n   register unsigned char\n     *p;\n \n   register ssize_t\n     i;\n \n   size_t\n     count;\n \n   ssize_t\n     loop_level;\n \n   volatile short\n     skipping_loop;\n \n #if defined(MNG_INSERT_LAYERS)\n   unsigned int\n     mandatory_back=0;\n #endif\n \n   volatile unsigned int\n #ifdef MNG_OBJECT_BUFFERS\n     mng_background_object=0,\n #endif\n     mng_type=0;\n \n   size_t\n     default_frame_timeout,\n     frame_timeout,\n #if defined(MNG_INSERT_LAYERS)\n     image_height,\n     image_width,\n #endif\n     length;\n \n   volatile size_t\n     default_frame_delay,\n     final_delay,\n     final_image_delay,\n     frame_delay,\n #if defined(MNG_INSERT_LAYERS)\n     insert_layers,\n #endif\n     mng_iterations=1,\n     simplicity=0,\n     subframe_height=0,\n     subframe_width=0;\n \n   previous_fb.top=0;\n   previous_fb.bottom=0;\n   previous_fb.left=0;\n   previous_fb.right=0;\n   default_fb.top=0;\n   default_fb.bottom=0;\n   default_fb.left=0;\n   default_fb.right=0;\n \n   logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"  Enter ReadOneMNGImage()\");\n \n   image=mng_info->image;\n \n   if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n     {\n       char\n         magic_number[MagickPathExtent];\n \n       count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n       if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n       for (i=0; i < MNG_MAX_OBJECTS; i++)\n       {\n         mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n         mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n       }\n       mng_info->exists[0]=MagickTrue;\n     }\n \n   skipping_loop=(-1);\n   first_mng_object=MagickTrue;\n   mng_type=0;\n #if defined(MNG_INSERT_LAYERS)\n   insert_layers=MagickFalse;\n #endif\n   default_frame_delay=0;\n   default_frame_timeout=0;\n   frame_delay=0;\n   final_delay=1;\n   mng_info->ticks_per_second=1UL*image->ticks_per_second;\n   object_id=0;\n   skip_to_iend=MagickFalse;\n   term_chunk_found=MagickFalse;\n   mng_info->framing_mode=1;\n #if defined(MNG_INSERT_LAYERS)\n   mandatory_back=MagickFalse;\n #endif\n #if defined(MNG_INSERT_LAYERS)\n   mng_background_color=image->background_color;\n #endif\n   default_fb=mng_info->frame;\n   previous_fb=mng_info->frame;\n   do\n   {\n     char\n       type[MagickPathExtent];\n \n     if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n       {\n         unsigned char\n           *chunk;\n \n         type[0]='\\0';\n         (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n         length=ReadBlobMSBLong(image);\n         count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n \n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n            type[0],type[1],type[2],type[3],(double) length);\n \n         if (length > PNG_UINT_31_MAX)\n           {\n             status=MagickFalse;\n             break;\n           }\n \n         if (count == 0)\n           ThrowReaderException(CorruptImageError,\"CorruptImage\");\n \n         p=NULL;\n         chunk=(unsigned char *) NULL;\n \n         if (length != 0)\n           {\n             if (length > GetBlobSize(image))\n               ThrowReaderException(CorruptImageError,\n                 \"InsufficientImageDataInFile\");\n             chunk=(unsigned char *) AcquireQuantumMemory(length+\n              MagickPathExtent,sizeof(*chunk));\n \n             if (chunk == (unsigned char *) NULL)\n               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n \n             for (i=0; i < (ssize_t) length; i++)\n             {\n               int\n                 c;\n \n               c=ReadBlobByte(image);\n               if (c == EOF)\n                 break;\n               chunk[i]=(unsigned char) c;\n             }\n \n             p=chunk;\n           }\n \n         (void) ReadBlobMSBLong(image);\n \n #if !defined(JNG_SUPPORTED)\n         if (memcmp(type,mng_JHDR,4) == 0)\n           {\n             skip_to_iend=MagickTrue;\n \n             if (mng_info->jhdr_warning == 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n \n             mng_info->jhdr_warning++;\n           }\n #endif\n         if (memcmp(type,mng_DHDR,4) == 0)\n           {\n             skip_to_iend=MagickTrue;\n \n             if (mng_info->dhdr_warning == 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n \n             mng_info->dhdr_warning++;\n           }\n         if (memcmp(type,mng_MEND,4) == 0)\n           break;\n \n         if (skip_to_iend)\n           {\n             if (memcmp(type,mng_IEND,4) == 0)\n               skip_to_iend=MagickFalse;\n \n             if (length != 0)\n               chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n \n             if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Skip to IEND.\");\n \n             continue;\n           }\n \n         if (memcmp(type,mng_MHDR,4) == 0)\n           {\n             if (length != 28)\n               {\n                 chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                 ThrowReaderException(CorruptImageError,\"CorruptImage\");\n               }\n \n             mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                 (p[2] << 8) | p[3]);\n \n             mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                 (p[6] << 8) | p[7]);\n \n             if (logging != MagickFalse)\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  MNG height: %.20g\",(double) mng_info->mng_height);\n               }\n \n             p+=8;\n             mng_info->ticks_per_second=(size_t) mng_get_long(p);\n \n             if (mng_info->ticks_per_second == 0)\n               default_frame_delay=0;\n \n             else\n               default_frame_delay=1UL*image->ticks_per_second/\n                 mng_info->ticks_per_second;\n \n             frame_delay=default_frame_delay;\n             simplicity=0;\n \n             p+=16;\n             simplicity=(size_t) mng_get_long(p);\n \n             mng_type=1;\n \n             if ((simplicity != 0) && ((simplicity | 11) == 11))\n               mng_type=2;\n \n             if ((simplicity != 0) && ((simplicity | 9) == 9))\n               mng_type=3;\n \n #if defined(MNG_INSERT_LAYERS)\n             if (mng_type != 3)\n               insert_layers=MagickTrue;\n #endif\n             if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n               {\n                 AcquireNextImage(image_info,image,exception);\n \n                 if (GetNextImageInList(image) == (Image *) NULL)\n                   return((Image *) NULL);\n \n                 image=SyncNextImageInList(image);\n                 mng_info->image=image;\n               }\n \n             if ((mng_info->mng_width > 65535L) ||\n                 (mng_info->mng_height > 65535L))\n               {\n                 chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                 ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n               }\n \n             (void) FormatLocaleString(page_geometry,MagickPathExtent,\n               \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n               mng_info->mng_height);\n \n             mng_info->frame.left=0;\n             mng_info->frame.right=(ssize_t) mng_info->mng_width;\n             mng_info->frame.top=0;\n             mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n             mng_info->clip=default_fb=previous_fb=mng_info->frame;\n \n             for (i=0; i < MNG_MAX_OBJECTS; i++)\n               mng_info->object_clip[i]=mng_info->frame;\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_TERM,4) == 0)\n           {\n             int\n               repeat=0;\n \n             if (length != 0)\n               repeat=p[0];\n \n             if (repeat == 3)\n               {\n                 final_delay=(png_uint_32) mng_get_long(&p[2]);\n                 mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n \n                 if (mng_iterations == PNG_UINT_31_MAX)\n                   mng_iterations=0;\n \n                 image->iterations=mng_iterations;\n                 term_chunk_found=MagickTrue;\n               }\n \n             if (logging != MagickFalse)\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                   repeat,(double) final_delay, (double) image->iterations);\n               }\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n         if (memcmp(type,mng_DEFI,4) == 0)\n           {\n             if (mng_type == 3)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                 image->filename);\n \n             if (length < 2)\n               {\n                 if (chunk)\n                   chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                 ThrowReaderException(CorruptImageError,\"CorruptImage\");\n               }\n \n             object_id=(p[0] << 8) | p[1];\n \n             if (mng_type == 2 && object_id != 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\",\n                 image->filename);\n \n             if (object_id > MNG_MAX_OBJECTS)\n               {\n                 (void) ThrowMagickException(exception,GetMagickModule(),\n                   CoderError,\"object id too large\",\"`%s'\",image->filename);\n                 object_id=MNG_MAX_OBJECTS;\n               }\n \n             if (mng_info->exists[object_id])\n               if (mng_info->frozen[object_id])\n                 {\n                   chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                   (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                     image->filename);\n                   continue;\n                 }\n \n             mng_info->exists[object_id]=MagickTrue;\n \n             if (length > 2)\n               mng_info->invisible[object_id]=p[2];\n \n             if (length > 11)\n               {\n                 mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                     (p[5] << 16) | (p[6] << 8) | p[7]);\n \n                 mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                     (p[9] << 16) | (p[10] << 8) | p[11]);\n \n                 if (logging != MagickFalse)\n                   {\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                       object_id,(double) mng_info->x_off[object_id],\n                       object_id,(double) mng_info->y_off[object_id]);\n                   }\n               }\n \n             if (length > 27)\n               mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n                 &p[12]);\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n         if (memcmp(type,mng_bKGD,4) == 0)\n           {\n             mng_info->have_global_bkgd=MagickFalse;\n \n             if (length > 5)\n               {\n                 mng_info->mng_global_bkgd.red=\n                   ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n \n                 mng_info->mng_global_bkgd.green=\n                   ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n \n                 mng_info->mng_global_bkgd.blue=\n                   ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n \n                 mng_info->have_global_bkgd=MagickTrue;\n               }\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n         if (memcmp(type,mng_BACK,4) == 0)\n           {\n #if defined(MNG_INSERT_LAYERS)\n             if (length > 6)\n               mandatory_back=p[6];\n \n             else\n               mandatory_back=0;\n \n             if (mandatory_back && length > 5)\n               {\n                 mng_background_color.red=\n                     ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n \n                 mng_background_color.green=\n                     ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n \n                 mng_background_color.blue=\n                     ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n \n                 mng_background_color.alpha=OpaqueAlpha;\n               }\n \n #ifdef MNG_OBJECT_BUFFERS\n             if (length > 8)\n               mng_background_object=(p[7] << 8) | p[8];\n #endif\n #endif\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_PLTE,4) == 0)\n           {\n \n             if (length && (length < 769))\n               {\n                 if (mng_info->global_plte == (png_colorp) NULL)\n                   mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                     sizeof(*mng_info->global_plte));\n \n                 for (i=0; i < (ssize_t) (length/3); i++)\n                 {\n                   mng_info->global_plte[i].red=p[3*i];\n                   mng_info->global_plte[i].green=p[3*i+1];\n                   mng_info->global_plte[i].blue=p[3*i+2];\n                 }\n \n                 mng_info->global_plte_length=(unsigned int) (length/3);\n               }\n #ifdef MNG_LOOSE\n             for ( ; i < 256; i++)\n             {\n               mng_info->global_plte[i].red=i;\n               mng_info->global_plte[i].green=i;\n               mng_info->global_plte[i].blue=i;\n             }\n \n             if (length != 0)\n               mng_info->global_plte_length=256;\n #endif\n             else\n               mng_info->global_plte_length=0;\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_tRNS,4) == 0)\n           {\n \n             if (length > 0 && length < 257)\n               for (i=0; i < (ssize_t) length; i++)\n                 mng_info->global_trns[i]=p[i];\n \n #ifdef MNG_LOOSE\n             for ( ; i < 256; i++)\n               mng_info->global_trns[i]=255;\n #endif\n             mng_info->global_trns_length=(unsigned int) length;\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n         if (memcmp(type,mng_gAMA,4) == 0)\n           {\n             if (length == 4)\n               {\n                 ssize_t\n                   igamma;\n \n                 igamma=mng_get_long(p);\n                 mng_info->global_gamma=((float) igamma)*0.00001;\n                 mng_info->have_global_gama=MagickTrue;\n               }\n \n             else\n               mng_info->have_global_gama=MagickFalse;\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_cHRM,4) == 0)\n           {\n \n             if (length == 32)\n               {\n                 mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                 mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                 mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                 mng_info->global_chrm.red_primary.y=0.00001*\n                   mng_get_long(&p[12]);\n                 mng_info->global_chrm.green_primary.x=0.00001*\n                   mng_get_long(&p[16]);\n                 mng_info->global_chrm.green_primary.y=0.00001*\n                   mng_get_long(&p[20]);\n                 mng_info->global_chrm.blue_primary.x=0.00001*\n                   mng_get_long(&p[24]);\n                 mng_info->global_chrm.blue_primary.y=0.00001*\n                   mng_get_long(&p[28]);\n                 mng_info->have_global_chrm=MagickTrue;\n               }\n             else\n               mng_info->have_global_chrm=MagickFalse;\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_sRGB,4) == 0)\n           {\n             if (length != 0)\n               {\n                 mng_info->global_srgb_intent=\n                   Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                 mng_info->have_global_srgb=MagickTrue;\n               }\n             else\n               mng_info->have_global_srgb=MagickFalse;\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_iCCP,4) == 0)\n           {\n \n             if (length != 0)\n               chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n \n             continue;\n           }\n \n         if (memcmp(type,mng_FRAM,4) == 0)\n           {\n             if (mng_type == 3)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                 image->filename);\n \n             if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n               image->delay=frame_delay;\n \n             frame_delay=default_frame_delay;\n             frame_timeout=default_frame_timeout;\n             fb=default_fb;\n \n             if (length != 0)\n               if (p[0])\n                 mng_info->framing_mode=p[0];\n \n             if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Framing_mode=%d\",mng_info->framing_mode);\n \n             if (length > 6)\n               {\n \n                 p++;\n \n                 while (*p && ((p-chunk) < (ssize_t) length))\n                   p++;\n \n                 p++;\n \n                 if ((p-chunk) < (ssize_t) (length-4))\n                   {\n                     int\n                       change_delay,\n                       change_timeout,\n                       change_clipping;\n \n                     change_delay=(*p++);\n                     change_timeout=(*p++);\n                     change_clipping=(*p++);\n                     p++;\n \n                     if (change_delay)\n                       {\n                         frame_delay=1UL*image->ticks_per_second*\n                           mng_get_long(p);\n \n                         if (mng_info->ticks_per_second != 0)\n                           frame_delay/=mng_info->ticks_per_second;\n \n                         else\n                           frame_delay=PNG_UINT_31_MAX;\n \n                         if (change_delay == 2)\n                           default_frame_delay=frame_delay;\n \n                         p+=4;\n \n                         if (logging != MagickFalse)\n                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                             \"    Framing_delay=%.20g\",(double) frame_delay);\n                       }\n \n                     if (change_timeout)\n                       {\n                         frame_timeout=1UL*image->ticks_per_second*\n                           mng_get_long(p);\n \n                         if (mng_info->ticks_per_second != 0)\n                           frame_timeout/=mng_info->ticks_per_second;\n \n                         else\n                           frame_timeout=PNG_UINT_31_MAX;\n \n                         if (change_timeout == 2)\n                           default_frame_timeout=frame_timeout;\n \n                         p+=4;\n \n                         if (logging != MagickFalse)\n                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                             \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                       }\n \n                     if (change_clipping)\n                       {\n                         fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                         p+=17;\n                         previous_fb=fb;\n \n                         if (logging != MagickFalse)\n                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                             \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                             (double) fb.left,(double) fb.right,(double) fb.top,\n                             (double) fb.bottom);\n \n                         if (change_clipping == 2)\n                           default_fb=fb;\n                       }\n                   }\n               }\n             mng_info->clip=fb;\n             mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n \n             subframe_width=(size_t) (mng_info->clip.right\n                -mng_info->clip.left);\n \n             subframe_height=(size_t) (mng_info->clip.bottom\n                -mng_info->clip.top);\n #if defined(MNG_INSERT_LAYERS)\n             if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                 subframe_width,(double) subframe_height);\n \n             if (insert_layers && (mng_info->framing_mode == 4) &&\n                 (subframe_width) && (subframe_height))\n               {\n                 if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                   {\n                     AcquireNextImage(image_info,image,exception);\n \n                     if (GetNextImageInList(image) == (Image *) NULL)\n                       return(DestroyImageList(image));\n \n                     image=SyncNextImageInList(image);\n                   }\n \n                 mng_info->image=image;\n \n                 if (term_chunk_found)\n                   {\n                     image->start_loop=MagickTrue;\n                     image->iterations=mng_iterations;\n                     term_chunk_found=MagickFalse;\n                   }\n \n                 else\n                     image->start_loop=MagickFalse;\n \n                 image->columns=subframe_width;\n                 image->rows=subframe_height;\n                 image->page.width=subframe_width;\n                 image->page.height=subframe_height;\n                 image->page.x=mng_info->clip.left;\n                 image->page.y=mng_info->clip.top;\n                 image->background_color=mng_background_color;\n                 image->alpha_trait=UndefinedPixelTrait;\n                 image->delay=0;\n                 (void) SetImageBackgroundColor(image,exception);\n \n                 if (logging != MagickFalse)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                     (double) mng_info->clip.left,\n                     (double) mng_info->clip.right,\n                     (double) mng_info->clip.top,\n                     (double) mng_info->clip.bottom);\n               }\n #endif\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_CLIP,4) == 0)\n           {\n             unsigned int\n               first_object,\n               last_object;\n \n             if (length > 3)\n               {\n                 first_object=(p[0] << 8) | p[1];\n                 last_object=(p[2] << 8) | p[3];\n                 p+=4;\n \n                 for (i=(int) first_object; i <= (int) last_object; i++)\n                 {\n// bug_start\n// bug_end\n                   if (mng_info->exists[i] && !mng_info->frozen[i])\n                     {\n                       MngBox\n                         box;\n \n                       box=mng_info->object_clip[i];\n                       if ((p-chunk) < (ssize_t) (length-17))\n                         mng_info->object_clip[i]=\n                            mng_read_box(box,(char) p[0],&p[1]);\n                     }\n                 }\n \n               }\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_SAVE,4) == 0)\n           {\n             for (i=1; i < MNG_MAX_OBJECTS; i++)\n               if (mng_info->exists[i])\n                 {\n                  mng_info->frozen[i]=MagickTrue;\n #ifdef MNG_OBJECT_BUFFERS\n                  if (mng_info->ob[i] != (MngBuffer *) NULL)\n                     mng_info->ob[i]->frozen=MagickTrue;\n #endif\n                 }\n \n             if (length != 0)\n               chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n \n             continue;\n           }\n \n         if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n           {\n \n             if ((length == 0) || !memcmp(type,mng_SEEK,4))\n               {\n                 for (i=1; i < MNG_MAX_OBJECTS; i++)\n                   MngInfoDiscardObject(mng_info,i);\n               }\n \n             else\n               {\n                 register ssize_t\n                   j;\n \n                 for (j=1; j < (ssize_t) length; j+=2)\n                 {\n                   i=p[j-1] << 8 | p[j];\n                   MngInfoDiscardObject(mng_info,i);\n                 }\n               }\n \n             if (length != 0)\n               chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n \n             continue;\n           }\n \n         if (memcmp(type,mng_MOVE,4) == 0)\n           {\n             size_t\n               first_object,\n               last_object;\n \n \n             if (length > 3)\n             {\n               first_object=(p[0] << 8) | p[1];\n               last_object=(p[2] << 8) | p[3];\n               p+=4;\n \n               for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n               {\n                 if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                   continue;\n \n                 if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                     (p-chunk) < (ssize_t) (length-8))\n                   {\n                     MngPair\n                       new_pair;\n \n                     MngPair\n                       old_pair;\n \n                     old_pair.a=mng_info->x_off[i];\n                     old_pair.b=mng_info->y_off[i];\n                     new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                     mng_info->x_off[i]=new_pair.a;\n                     mng_info->y_off[i]=new_pair.b;\n                   }\n               }\n             }\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_LOOP,4) == 0)\n           {\n             ssize_t loop_iters=1;\n             if (length > 4)\n               {\n                 loop_level=chunk[0];\n                 mng_info->loop_active[loop_level]=1;\n \n                 loop_iters=mng_get_long(&chunk[1]);\n \n                 if (logging != MagickFalse)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  LOOP level %.20g has %.20g iterations \",\n                     (double) loop_level, (double) loop_iters);\n \n                 if (loop_iters == 0)\n                   skipping_loop=loop_level;\n \n                 else\n                   {\n                     mng_info->loop_jump[loop_level]=TellBlob(image);\n                     mng_info->loop_count[loop_level]=loop_iters;\n                   }\n \n                 mng_info->loop_iteration[loop_level]=0;\n               }\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_ENDL,4) == 0)\n           {\n             if (length > 0)\n               {\n                 loop_level=chunk[0];\n \n                 if (skipping_loop > 0)\n                   {\n                     if (skipping_loop == loop_level)\n                       {\n                         skipping_loop=(-1);\n                         mng_info->loop_active[loop_level]=0;\n                       }\n                   }\n \n                 else\n                   {\n                     if (mng_info->loop_active[loop_level] == 1)\n                       {\n                         mng_info->loop_count[loop_level]--;\n                         mng_info->loop_iteration[loop_level]++;\n \n                         if (logging != MagickFalse)\n                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  ENDL: LOOP level %.20g has %.20g remaining iters\",\n                             (double) loop_level,(double)\n                             mng_info->loop_count[loop_level]);\n \n                         if (mng_info->loop_count[loop_level] != 0)\n                           {\n                             offset=\n                               SeekBlob(image,mng_info->loop_jump[loop_level],\n                               SEEK_SET);\n \n                             if (offset < 0)\n                               {\n                                 chunk=(unsigned char *) RelinquishMagickMemory(\n                                   chunk);\n                                 ThrowReaderException(CorruptImageError,\n                                   \"ImproperImageHeader\");\n                               }\n                           }\n \n                         else\n                           {\n                             short\n                               last_level;\n \n                             mng_info->loop_active[loop_level]=0;\n                             last_level=(-1);\n                             for (i=0; i < loop_level; i++)\n                               if (mng_info->loop_active[i] == 1)\n                                 last_level=(short) i;\n                             loop_level=last_level;\n                           }\n                       }\n                   }\n               }\n \n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_CLON,4) == 0)\n           {\n             if (mng_info->clon_warning == 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                 image->filename);\n \n             mng_info->clon_warning++;\n           }\n \n         if (memcmp(type,mng_MAGN,4) == 0)\n           {\n             png_uint_16\n               magn_first,\n               magn_last,\n               magn_mb,\n               magn_ml,\n               magn_mr,\n               magn_mt,\n               magn_mx,\n               magn_my,\n               magn_methx,\n               magn_methy;\n \n             if (length > 1)\n               magn_first=(p[0] << 8) | p[1];\n \n             else\n               magn_first=0;\n \n             if (length > 3)\n               magn_last=(p[2] << 8) | p[3];\n \n             else\n               magn_last=magn_first;\n #ifndef MNG_OBJECT_BUFFERS\n             if (magn_first || magn_last)\n               if (mng_info->magn_warning == 0)\n                 {\n                   (void) ThrowMagickException(exception,\n                      GetMagickModule(),CoderError,\n                      \"MAGN is not implemented yet for nonzero objects\",\n                      \"`%s'\",image->filename);\n \n                    mng_info->magn_warning++;\n                 }\n #endif\n             if (length > 4)\n               magn_methx=p[4];\n \n             else\n               magn_methx=0;\n \n             if (length > 6)\n               magn_mx=(p[5] << 8) | p[6];\n \n             else\n               magn_mx=1;\n \n             if (magn_mx == 0)\n               magn_mx=1;\n \n             if (length > 8)\n               magn_my=(p[7] << 8) | p[8];\n \n             else\n               magn_my=magn_mx;\n \n             if (magn_my == 0)\n               magn_my=1;\n \n             if (length > 10)\n               magn_ml=(p[9] << 8) | p[10];\n \n             else\n               magn_ml=magn_mx;\n \n             if (magn_ml == 0)\n               magn_ml=1;\n \n             if (length > 12)\n               magn_mr=(p[11] << 8) | p[12];\n \n             else\n               magn_mr=magn_mx;\n \n             if (magn_mr == 0)\n               magn_mr=1;\n \n             if (length > 14)\n               magn_mt=(p[13] << 8) | p[14];\n \n             else\n               magn_mt=magn_my;\n \n             if (magn_mt == 0)\n               magn_mt=1;\n \n             if (length > 16)\n               magn_mb=(p[15] << 8) | p[16];\n \n             else\n               magn_mb=magn_my;\n \n             if (magn_mb == 0)\n               magn_mb=1;\n \n             if (length > 17)\n               magn_methy=p[17];\n \n             else\n               magn_methy=magn_methx;\n \n \n             if (magn_methx > 5 || magn_methy > 5)\n               if (mng_info->magn_warning == 0)\n                 {\n                   (void) ThrowMagickException(exception,\n                      GetMagickModule(),CoderError,\n                      \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                      image->filename);\n \n                    mng_info->magn_warning++;\n                 }\n #ifdef MNG_OBJECT_BUFFERS\n #endif\n             if (magn_first == 0 || magn_last == 0)\n               {\n                 mng_info->magn_mb=magn_mb;\n                 mng_info->magn_ml=magn_ml;\n                 mng_info->magn_mr=magn_mr;\n                 mng_info->magn_mt=magn_mt;\n                 mng_info->magn_mx=magn_mx;\n                 mng_info->magn_my=magn_my;\n                 mng_info->magn_methx=magn_methx;\n                 mng_info->magn_methy=magn_methy;\n               }\n           }\n \n         if (memcmp(type,mng_PAST,4) == 0)\n           {\n             if (mng_info->past_warning == 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                 image->filename);\n \n             mng_info->past_warning++;\n           }\n \n         if (memcmp(type,mng_SHOW,4) == 0)\n           {\n             if (mng_info->show_warning == 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                 image->filename);\n \n             mng_info->show_warning++;\n           }\n \n         if (memcmp(type,mng_sBIT,4) == 0)\n           {\n             if (length < 4)\n               mng_info->have_global_sbit=MagickFalse;\n \n             else\n               {\n                 mng_info->global_sbit.gray=p[0];\n                 mng_info->global_sbit.red=p[0];\n                 mng_info->global_sbit.green=p[1];\n                 mng_info->global_sbit.blue=p[2];\n                 mng_info->global_sbit.alpha=p[3];\n                 mng_info->have_global_sbit=MagickTrue;\n              }\n           }\n         if (memcmp(type,mng_pHYs,4) == 0)\n           {\n             if (length > 8)\n               {\n                 mng_info->global_x_pixels_per_unit=\n                     (size_t) mng_get_long(p);\n                 mng_info->global_y_pixels_per_unit=\n                     (size_t) mng_get_long(&p[4]);\n                 mng_info->global_phys_unit_type=p[8];\n                 mng_info->have_global_phys=MagickTrue;\n               }\n \n             else\n               mng_info->have_global_phys=MagickFalse;\n           }\n         if (memcmp(type,mng_pHYg,4) == 0)\n           {\n             if (mng_info->phyg_warning == 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n \n             mng_info->phyg_warning++;\n           }\n         if (memcmp(type,mng_BASI,4) == 0)\n           {\n             skip_to_iend=MagickTrue;\n \n             if (mng_info->basi_warning == 0)\n               (void) ThrowMagickException(exception,GetMagickModule(),\n                 CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                 image->filename);\n \n             mng_info->basi_warning++;\n #ifdef MNG_BASI_SUPPORTED\n             basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n             basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n             basi_color_type=p[8];\n             basi_compression_method=p[9];\n             basi_filter_type=p[10];\n             basi_interlace_method=p[11];\n             if (length > 11)\n               basi_red=(p[12] << 8) & p[13];\n \n             else\n               basi_red=0;\n \n             if (length > 13)\n               basi_green=(p[14] << 8) & p[15];\n \n             else\n               basi_green=0;\n \n             if (length > 15)\n               basi_blue=(p[16] << 8) & p[17];\n \n             else\n               basi_blue=0;\n \n             if (length > 17)\n               basi_alpha=(p[18] << 8) & p[19];\n \n             else\n               {\n                 if (basi_sample_depth == 16)\n                   basi_alpha=65535L;\n                 else\n                   basi_alpha=255;\n               }\n \n             if (length > 19)\n               basi_viewable=p[20];\n \n             else\n               basi_viewable=0;\n \n #endif\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n \n         if (memcmp(type,mng_IHDR,4)\n #if defined(JNG_SUPPORTED)\n             && memcmp(type,mng_JHDR,4)\n #endif\n             )\n           {\n             if (length != 0)\n               chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n \n             continue;\n           }\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n \n         mng_info->exists[object_id]=MagickTrue;\n         mng_info->viewable[object_id]=MagickTrue;\n \n         if (mng_info->invisible[object_id])\n           {\n             if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Skipping invisible object\");\n \n             skip_to_iend=MagickTrue;\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             continue;\n           }\n #if defined(MNG_INSERT_LAYERS)\n         if (length < 8)\n           {\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n \n         image_width=(size_t) mng_get_long(p);\n         image_height=(size_t) mng_get_long(&p[4]);\n #endif\n         chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n \n #if defined(MNG_INSERT_LAYERS)\n         if (insert_layers && mng_type && first_mng_object)\n           {\n             if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                 (image_width < mng_info->mng_width) ||\n                 (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                 (image_height < mng_info->mng_height) ||\n                 (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n               {\n                 if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                   {\n                     AcquireNextImage(image_info,image,exception);\n \n                     if (GetNextImageInList(image) == (Image *) NULL)\n                       return(DestroyImageList(image));\n \n                     image=SyncNextImageInList(image);\n                   }\n                 mng_info->image=image;\n \n                 if (term_chunk_found)\n                   {\n                     image->start_loop=MagickTrue;\n                     image->iterations=mng_iterations;\n                     term_chunk_found=MagickFalse;\n                   }\n \n                 else\n                     image->start_loop=MagickFalse;\n \n \n                 image->delay=0;\n                 image->columns=mng_info->mng_width;\n                 image->rows=mng_info->mng_height;\n                 image->page.width=mng_info->mng_width;\n                 image->page.height=mng_info->mng_height;\n                 image->page.x=0;\n                 image->page.y=0;\n                 image->background_color=mng_background_color;\n                 (void) SetImageBackgroundColor(image,exception);\n                 if (logging != MagickFalse)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                     (double) mng_info->mng_width,(double) mng_info->mng_height);\n               }\n           }\n         if (insert_layers && (mng_info->framing_mode == 3) &&\n                 (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                 (simplicity & 0x08)))\n           {\n             if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n             {\n               AcquireNextImage(image_info,image,exception);\n \n               if (GetNextImageInList(image) == (Image *) NULL)\n                 return(DestroyImageList(image));\n \n               image=SyncNextImageInList(image);\n             }\n \n             mng_info->image=image;\n \n             if (term_chunk_found)\n               {\n                 image->start_loop=MagickTrue;\n                 image->iterations=mng_iterations;\n                 term_chunk_found=MagickFalse;\n               }\n \n             else\n                 image->start_loop=MagickFalse;\n \n             image->delay=0;\n             image->columns=subframe_width;\n             image->rows=subframe_height;\n             image->page.width=subframe_width;\n             image->page.height=subframe_height;\n             image->page.x=mng_info->clip.left;\n             image->page.y=mng_info->clip.top;\n             image->background_color=mng_background_color;\n             image->alpha_trait=UndefinedPixelTrait;\n             (void) SetImageBackgroundColor(image,exception);\n \n             if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                 (double) mng_info->clip.left,(double) mng_info->clip.right,\n                 (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n           }\n #endif\n         first_mng_object=MagickFalse;\n \n         if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n           {\n             AcquireNextImage(image_info,image,exception);\n \n             if (GetNextImageInList(image) == (Image *) NULL)\n               return(DestroyImageList(image));\n \n             image=SyncNextImageInList(image);\n           }\n         mng_info->image=image;\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n           GetBlobSize(image));\n \n         if (status == MagickFalse)\n           break;\n \n         if (term_chunk_found)\n           {\n             image->start_loop=MagickTrue;\n             term_chunk_found=MagickFalse;\n           }\n \n         else\n             image->start_loop=MagickFalse;\n \n         if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n           {\n             image->delay=frame_delay;\n             frame_delay=default_frame_delay;\n           }\n \n         else\n           image->delay=0;\n \n         image->page.width=mng_info->mng_width;\n         image->page.height=mng_info->mng_height;\n         image->page.x=mng_info->x_off[object_id];\n         image->page.y=mng_info->y_off[object_id];\n         image->iterations=mng_iterations;\n \n \n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n             type[2],type[3]);\n \n         offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n \n         if (offset < 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n \n     mng_info->image=image;\n     mng_info->mng_type=mng_type;\n     mng_info->object_id=object_id;\n \n     if (memcmp(type,mng_IHDR,4) == 0)\n       image=ReadOnePNGImage(mng_info,image_info,exception);\n \n #if defined(JNG_SUPPORTED)\n     else\n       image=ReadOneJNGImage(mng_info,image_info,exception);\n #endif\n \n     if (image == (Image *) NULL)\n       {\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"exit ReadJNGImage() with error\");\n \n         return((Image *) NULL);\n       }\n \n     if (image->columns == 0 || image->rows == 0)\n       {\n         (void) CloseBlob(image);\n         return(DestroyImageList(image));\n       }\n \n     mng_info->image=image;\n \n     if (mng_type)\n       {\n         MngBox\n           crop_box;\n \n         if (mng_info->magn_methx || mng_info->magn_methy)\n           {\n             png_uint_32\n                magnified_height,\n                magnified_width;\n \n             if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Processing MNG MAGN chunk\");\n \n             if (mng_info->magn_methx == 1)\n               {\n                 magnified_width=mng_info->magn_ml;\n \n                 if (image->columns > 1)\n                    magnified_width += mng_info->magn_mr;\n \n                 if (image->columns > 2)\n                    magnified_width += (png_uint_32)\n                       ((image->columns-2)*(mng_info->magn_mx));\n               }\n \n             else\n               {\n                 magnified_width=(png_uint_32) image->columns;\n \n                 if (image->columns > 1)\n                    magnified_width += mng_info->magn_ml-1;\n \n                 if (image->columns > 2)\n                    magnified_width += mng_info->magn_mr-1;\n \n                 if (image->columns > 3)\n                    magnified_width += (png_uint_32)\n                       ((image->columns-3)*(mng_info->magn_mx-1));\n               }\n \n             if (mng_info->magn_methy == 1)\n               {\n                 magnified_height=mng_info->magn_mt;\n \n                 if (image->rows > 1)\n                    magnified_height += mng_info->magn_mb;\n \n                 if (image->rows > 2)\n                    magnified_height += (png_uint_32)\n                       ((image->rows-2)*(mng_info->magn_my));\n               }\n \n             else\n               {\n                 magnified_height=(png_uint_32) image->rows;\n \n                 if (image->rows > 1)\n                    magnified_height += mng_info->magn_mt-1;\n \n                 if (image->rows > 2)\n                    magnified_height += mng_info->magn_mb-1;\n \n                 if (image->rows > 3)\n                    magnified_height += (png_uint_32)\n                       ((image->rows-3)*(mng_info->magn_my-1));\n               }\n \n             if (magnified_height > image->rows ||\n                 magnified_width > image->columns)\n               {\n                 Image\n                   *large_image;\n \n                 int\n                   yy;\n \n                 Quantum\n                   *next,\n                   *prev;\n \n                 png_uint_16\n                   magn_methx,\n                   magn_methy;\n \n                 ssize_t\n                   m,\n                   y;\n \n                 register Quantum\n                   *n,\n                   *q;\n \n                 register ssize_t\n                   x;\n \n \n                 if (logging != MagickFalse)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"    Allocate magnified image\");\n \n                 AcquireNextImage(image_info,image,exception);\n \n                 if (GetNextImageInList(image) == (Image *) NULL)\n                   return(DestroyImageList(image));\n \n                 large_image=SyncNextImageInList(image);\n \n                 large_image->columns=magnified_width;\n                 large_image->rows=magnified_height;\n \n                 magn_methx=mng_info->magn_methx;\n                 magn_methy=mng_info->magn_methy;\n \n #if (MAGICKCORE_QUANTUM_DEPTH > 16)\n #define QM unsigned short\n                 if (magn_methx != 1 || magn_methy != 1)\n                   {\n                      for (y=0; y < (ssize_t) image->rows; y++)\n                      {\n                        q=GetAuthenticPixels(image,0,y,image->columns,1,\n                           exception);\n \n                        for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                        {\n                           SetPixelRed(image,ScaleQuantumToShort(\n                             GetPixelRed(image,q)),q);\n                           SetPixelGreen(image,ScaleQuantumToShort(\n                             GetPixelGreen(image,q)),q);\n                           SetPixelBlue(image,ScaleQuantumToShort(\n                             GetPixelBlue(image,q)),q);\n                           SetPixelAlpha(image,ScaleQuantumToShort(\n                             GetPixelAlpha(image,q)),q);\n                           q+=GetPixelChannels(image);\n                        }\n \n                        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                          break;\n                      }\n                   }\n #else\n #define QM Quantum\n #endif\n \n                 if (image->alpha_trait != UndefinedPixelTrait)\n                    (void) SetImageBackgroundColor(large_image,exception);\n \n                 else\n                   {\n                     large_image->background_color.alpha=OpaqueAlpha;\n                     (void) SetImageBackgroundColor(large_image,exception);\n \n                     if (magn_methx == 4)\n                       magn_methx=2;\n \n                     if (magn_methx == 5)\n                       magn_methx=3;\n \n                     if (magn_methy == 4)\n                       magn_methy=2;\n \n                     if (magn_methy == 5)\n                       magn_methy=3;\n                   }\n \n \n                 if (logging != MagickFalse)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"    Magnify the rows to %.20g\",\n                     (double) large_image->rows);\n                 m=(ssize_t) mng_info->magn_mt;\n                 yy=0;\n                 length=(size_t) GetPixelChannels(image)*image->columns;\n                 next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                 prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n \n                 if ((prev == (Quantum *) NULL) ||\n                     (next == (Quantum *) NULL))\n                   {\n                      image=DestroyImageList(image);\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                   }\n \n                 n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                 (void) CopyMagickMemory(next,n,length);\n \n                 for (y=0; y < (ssize_t) image->rows; y++)\n                 {\n                   if (y == 0)\n                     m=(ssize_t) mng_info->magn_mt;\n \n                   else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                     m=(ssize_t) mng_info->magn_mb;\n \n                   else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                     m=(ssize_t) mng_info->magn_mb;\n \n                   else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                     m=1;\n \n                   else\n                     m=(ssize_t) mng_info->magn_my;\n \n                   n=prev;\n                   prev=next;\n                   next=n;\n \n                   if (y < (ssize_t) image->rows-1)\n                     {\n                       n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                           exception);\n                       (void) CopyMagickMemory(next,n,length);\n                     }\n \n                   for (i=0; i < m; i++, yy++)\n                   {\n                     register Quantum\n                       *pixels;\n \n                     assert(yy < (ssize_t) large_image->rows);\n                     pixels=prev;\n                     n=next;\n                     q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                       1,exception);\n                     q+=(large_image->columns-image->columns)*\n                       GetPixelChannels(large_image);\n \n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n \n                       if (magn_methy <= 1)\n                         {\n                           SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                           SetPixelGreen(large_image,GetPixelGreen(image,\n                              pixels),q);\n                           SetPixelBlue(large_image,GetPixelBlue(image,\n                              pixels),q);\n                           SetPixelAlpha(large_image,GetPixelAlpha(image,\n                              pixels),q);\n                         }\n \n                       else if (magn_methy == 2 || magn_methy == 4)\n                         {\n                           if (i == 0)\n                             {\n                               SetPixelRed(large_image,GetPixelRed(image,\n                                  pixels),q);\n                               SetPixelGreen(large_image,GetPixelGreen(image,\n                                  pixels),q);\n                               SetPixelBlue(large_image,GetPixelBlue(image,\n                                  pixels),q);\n                               SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                  pixels),q);\n                             }\n \n                           else\n                             {\n                               SetPixelRed(large_image,((QM) (((ssize_t)\n                                  (2*i*(GetPixelRed(image,n)\n                                  -GetPixelRed(image,pixels)+m))/\n                                  ((ssize_t) (m*2))\n                                  +GetPixelRed(image,pixels)))),q);\n                               SetPixelGreen(large_image,((QM) (((ssize_t)\n                                  (2*i*(GetPixelGreen(image,n)\n                                  -GetPixelGreen(image,pixels)+m))/\n                                  ((ssize_t) (m*2))\n                                  +GetPixelGreen(image,pixels)))),q);\n                               SetPixelBlue(large_image,((QM) (((ssize_t)\n                                  (2*i*(GetPixelBlue(image,n)\n                                  -GetPixelBlue(image,pixels)+m))/\n                                  ((ssize_t) (m*2))\n                                  +GetPixelBlue(image,pixels)))),q);\n \n                               if (image->alpha_trait != UndefinedPixelTrait)\n                                  SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                     (2*i*(GetPixelAlpha(image,n)\n                                     -GetPixelAlpha(image,pixels)+m))\n                                     /((ssize_t) (m*2))+\n                                    GetPixelAlpha(image,pixels)))),q);\n                             }\n \n                           if (magn_methy == 4)\n                             {\n                               if (i <= ((m+1) << 1))\n                                  SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                     pixels),q);\n                               else\n                                  SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                     n),q);\n                             }\n                         }\n \n                       else\n                         {\n                           if (i <= ((m+1) << 1))\n                           {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                     pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                     pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                     pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                     pixels),q);\n                           }\n \n                           else\n                           {\n                              SetPixelRed(large_image,GetPixelRed(image,n),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                     q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                     q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                     q);\n                           }\n \n                           if (magn_methy == 5)\n                             {\n                               SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                  (GetPixelAlpha(image,n)\n                                  -GetPixelAlpha(image,pixels))\n                                  +m))/((ssize_t) (m*2))\n                                  +GetPixelAlpha(image,pixels)),q);\n                             }\n                         }\n                       n+=GetPixelChannels(image);\n                       q+=GetPixelChannels(large_image);\n                       pixels+=GetPixelChannels(image);\n                     }\n \n                     if (SyncAuthenticPixels(large_image,exception) == 0)\n                       break;\n \n", "target": "// fix_start\n                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                    continue;\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2017-13139", "cve_desc": "In ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1, the ReadOneMNGImage function in coders/png.c has an out-of-bounds read with the MNG CLIP chunk.", "project": "ImageMagick", "idx": 195909}
{"source": " static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n \t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n \t\t\t       const pj_uint8_t *max, int *parsed_len)\n {\n     const pj_uint8_t *p = start;\n     int name_len, name_part_len;\n     pj_status_t status;\n \n     status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n     if (status != PJ_SUCCESS)\n \treturn status;\n \n     q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n     q->name.slen = 0;\n \n     status = get_name(0, pkt, start, max, &q->name);\n     if (status != PJ_SUCCESS)\n \treturn status;\n \n     p = (start + name_part_len);\n \n// bug_start\n// bug_end\n     pj_memcpy(&q->type, p, 2);\n     q->type = pj_ntohs(q->type);\n     p += 2;\n \n     pj_memcpy(&q->dnsclass, p, 2);\n     q->dnsclass = pj_ntohs(q->dnsclass);\n     p += 2;\n \n     *parsed_len = (int)(p - start);\n \n     return PJ_SUCCESS;\n }\n \n", "target": "// fix_start\n    if (p + 4 > max)\n    \treturn PJLIB_UTIL_EDNSINSIZE;\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-24793", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.12 and prior affects applications that use PJSIP DNS resolution. It doesn't affect PJSIP users who utilize an external resolver. This vulnerability is related to CVE-2023-27585. The difference is that this issue is in parsing the query record `parse_rr()`, while the issue in CVE-2023-27585 is in `parse_query()`. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver instead.", "project": "pjproject", "idx": 195954}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor* hypothesis_indices;\n     const Tensor* hypothesis_values;\n     const Tensor* hypothesis_shape;\n     const Tensor* truth_indices;\n     const Tensor* truth_values;\n     const Tensor* truth_shape;\n     OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_indices\", &hypothesis_indices));\n     OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_values\", &hypothesis_values));\n     OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_shape\", &hypothesis_shape));\n     OP_REQUIRES_OK(ctx, ctx->input(\"truth_indices\", &truth_indices));\n     OP_REQUIRES_OK(ctx, ctx->input(\"truth_values\", &truth_values));\n     OP_REQUIRES_OK(ctx, ctx->input(\"truth_shape\", &truth_shape));\n \n     OP_REQUIRES_OK(\n         ctx, ValidateShapes(ctx, *hypothesis_indices, *hypothesis_values,\n                             *hypothesis_shape, *truth_indices, *truth_values,\n                             *truth_shape));\n \n     TensorShape hypothesis_st_shape;\n     OP_REQUIRES_OK(ctx,\n                    TensorShapeUtils::MakeShape(\n                        hypothesis_shape->vec<int64_t>().data(),\n                        hypothesis_shape->NumElements(), &hypothesis_st_shape));\n     TensorShape truth_st_shape;\n     OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                             truth_shape->vec<int64_t>().data(),\n                             truth_shape->NumElements(), &truth_st_shape));\n \n     std::vector<int64_t> sorted_order(truth_st_shape.dims());\n     std::iota(sorted_order.begin(), sorted_order.end(), 0);\n \n     sparse::SparseTensor hypothesis;\n     OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                             *hypothesis_indices, *hypothesis_values,\n                             hypothesis_st_shape, sorted_order, &hypothesis));\n \n     sparse::SparseTensor truth;\n     OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                             *truth_indices, *truth_values, truth_st_shape,\n                             sorted_order, &truth));\n \n     std::vector<int64_t> group_dims(truth_st_shape.dims() - 1);\n     std::iota(group_dims.begin(), group_dims.end(), 0);\n \n     TensorShape output_shape;\n     for (int d = 0; d < static_cast<int>(group_dims.size()); ++d) {\n       output_shape.AddDim(std::max(hypothesis_st_shape.dim_size(d),\n                                    truth_st_shape.dim_size(d)));\n     }\n     const auto output_elements = output_shape.num_elements();\n     OP_REQUIRES(\n         ctx, output_elements > 0,\n         errors::InvalidArgument(\"Got output shape \", output_shape.DebugString(),\n                                 \" which has 0 elements\"));\n \n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(\"output\", output_shape, &output));\n     auto output_t = output->flat<float>();\n     output_t.setZero();\n \n     std::vector<int64_t> output_strides(output_shape.dims());\n     output_strides[output_shape.dims() - 1] = 1;\n     for (int d = output_shape.dims() - 2; d >= 0; --d) {\n       output_strides[d] = output_strides[d + 1] * output_shape.dim_size(d + 1);\n     }\n \n     auto hypothesis_grouper = hypothesis.group(group_dims);\n     auto truth_grouper = truth.group(group_dims);\n \n     auto hypothesis_iter = hypothesis_grouper.begin();\n     auto truth_iter = truth_grouper.begin();\n \n     auto cmp = std::equal_to<T>();\n \n     while (hypothesis_iter != hypothesis_grouper.end() &&\n            truth_iter != truth_grouper.end()) {\n       sparse::Group truth_i = *truth_iter;\n       sparse::Group hypothesis_j = *hypothesis_iter;\n       std::vector<int64_t> g_truth = truth_i.group();\n       std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n       auto truth_seq = truth_i.values<T>();\n       auto hypothesis_seq = hypothesis_j.values<T>();\n \n       if (g_truth == g_hypothesis) {\n         auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                       output_strides.begin(), int64_t{0});\n         OP_REQUIRES(\n// bug_start\n            ctx, loc < output_elements,\n// bug_end\n             errors::Internal(\"Got an inner product \", loc,\n// bug_start\n                             \" which would require in writing to outside of \"\n// bug_end\n                              \"the buffer for the output tensor (max elements \",\n                              output_elements, \")\"));\n         output_t(loc) =\n             gtl::LevenshteinDistance<T>(truth_seq, hypothesis_seq, cmp);\n         if (normalize_) output_t(loc) /= truth_seq.size();\n \n         ++hypothesis_iter;\n         ++truth_iter;\n       } else if (g_truth > g_hypothesis) {\n         auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                       output_strides.begin(), int64_t{0});\n         OP_REQUIRES(\n// bug_start\n            ctx, loc < output_elements,\n// bug_end\n             errors::Internal(\"Got an inner product \", loc,\n// bug_start\n                             \" which would require in writing to outside of \"\n// bug_end\n                              \"the buffer for the output tensor (max elements \",\n                              output_elements, \")\"));\n         output_t(loc) = hypothesis_seq.size();\n         if (normalize_ && output_t(loc) != 0.0f) {\n           output_t(loc) = std::numeric_limits<float>::infinity();\n         }\n         ++hypothesis_iter;\n       } else {\n         auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                       output_strides.begin(), int64_t{0});\n         OP_REQUIRES(\n// bug_start\n            ctx, loc < output_elements,\n// bug_end\n             errors::Internal(\"Got an inner product \", loc,\n// bug_start\n                             \" which would require in writing to outside of \"\n// bug_end\n                              \"the buffer for the output tensor (max elements \",\n                              output_elements, \")\"));\n         output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n         ++truth_iter;\n       }\n     }\n     while (hypothesis_iter != hypothesis_grouper.end()) {\n       sparse::Group hypothesis_j = *hypothesis_iter;\n       std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n       auto hypothesis_seq = hypothesis_j.values<T>();\n       auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                     output_strides.begin(), int64_t{0});\n       OP_REQUIRES(\n// bug_start\n          ctx, loc < output_elements,\n// bug_end\n           errors::Internal(\"Got an inner product \", loc,\n// bug_start\n                           \" which would require in writing to outside of the \"\n// bug_end\n                            \"buffer for the output tensor (max elements \",\n                            output_elements, \")\"));\n       output_t(loc) = hypothesis_seq.size();\n       if (normalize_ && output_t(loc) != 0.0f) {\n         output_t(loc) = std::numeric_limits<float>::infinity();\n       }\n       ++hypothesis_iter;\n     }\n     while (truth_iter != truth_grouper.end()) {\n       sparse::Group truth_i = *truth_iter;\n       std::vector<int64_t> g_truth = truth_i.group();\n       auto truth_seq = truth_i.values<T>();\n       auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                     output_strides.begin(), int64_t{0});\n       OP_REQUIRES(\n// bug_start\n          ctx, loc < output_elements,\n// bug_end\n           errors::Internal(\"Got an inner product \", loc,\n// bug_start\n                           \" which would require in writing to outside of the \"\n// bug_end\n                            \"buffer for the output tensor (max elements \",\n                            output_elements, \")\"));\n       output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n       ++truth_iter;\n     }\n   }\n \n", "target": "// fix_start\n            ctx, 0 <= loc && loc < output_elements,\n// fix_end\n// fix_start\n                             \" which would require writing to outside of \"\n// fix_end\n// fix_start\n            ctx, 0 <= loc && loc < output_elements,\n// fix_end\n// fix_start\n                             \" which would require writing to outside of \"\n// fix_end\n// fix_start\n            ctx, 0 <= loc && loc < output_elements,\n// fix_end\n// fix_start\n                             \" which would require writing to outside of \"\n// fix_end\n// fix_start\n          ctx, 0 <= loc && loc < output_elements,\n// fix_end\n// fix_start\n                           \" which would require writing to outside of the \"\n// fix_end\n// fix_start\n          ctx, 0 <= loc && loc < output_elements,\n// fix_end\n// fix_start\n                           \" which would require writing to outside of the \"\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-29208", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.EditDistance` has incomplete validation. Users can pass negative values to cause a segmentation fault based denial of service. In multiple places throughout the code, one may compute an index for a write operation. However, the existing validation only checks against the upper bound of the array. Hence, it is possible to write before the array by massaging the input to generate negative values for `loc`. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 195965}
{"source": " GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n {\n// bug_start\n\tu32 i;\n\tchar str[1024];\n// bug_end\n \tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n \n// bug_start\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->content_script_types = gf_strdup(str);\n// bug_end\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\tp->content_script_types = gf_malloc(sizeof(char) * (s->size+1));\n\tif (!p->content_script_types) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, p->content_script_types, s->size);\n\tp->content_script_types[s->size] = 0;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-1441", "cve_desc": "MP4Box is a component of GPAC-2.0.0, which is a widely-used third-party package on RPM Fusion. When MP4Box tries to parse a MP4 file, it calls the function `diST_box_read()` to read from video. In this function, it allocates a buffer `str` with fixed length. However, content read from `bs` is controllable by user, so is the length, which causes a buffer overflow.", "project": "gpac", "idx": 195984}
{"source": " lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n              unsigned dyn_table_size, unsigned max_risked_streams, int server)\n {\n     enum lsqpack_enc_opts enc_opts;\n \n     assert(qeh->qeh_flags & QEH_INITIALIZED);\n \n     if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n     {\n         LSQ_WARN(\"settings already set\");\n         return -1;\n     }\n \n     enc_opts = LSQPACK_ENC_OPT_STAGE_2\n              | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n     qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n// bug_start\n// bug_end\n     if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                 max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                 qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n     {\n         LSQ_INFO(\"could not initialize QPACK encoder\");\n         return -1;\n     }\n     LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n     qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n     qeh->qeh_max_prefix_size =\n                         lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n     LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n         \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n     if (qeh->qeh_enc_sm_out)\n         qeh_begin_out(qeh);\n     return 0;\n }\n \n", "target": "// fix_start\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "cve": "CVE-2022-30592", "cve_desc": "liblsquic/lsquic_qenc_hdl.c in LiteSpeed QUIC (aka LSQUIC) before 3.1.0 mishandles MAX_TABLE_CAPACITY.", "project": "lsquic", "idx": 196276}
{"source": " int digest_generic_verify(struct digest *d, const unsigned char *md)\n {\n \tint ret;\n \tint len = digest_length(d);\n \tunsigned char *tmp;\n \n \ttmp = xmalloc(len);\n \n \tret = digest_final(d, tmp);\n \tif (ret)\n \t\tgoto end;\n \n// bug_start\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\n// bug_end\n end:\n \tfree(tmp);\n \treturn ret;\n }\n \n", "target": "// fix_start\n\tif (crypto_memneq(md, tmp, len))\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-37847", "cve_desc": "crypto/digest.c in Pengutronix barebox through 2021.07.0 leaks timing information because memcmp is used during digest verification.", "project": "barebox", "idx": 196316}
{"source": " find_pattern_in_path(\n     char_u\t*ptr,\n     int\t\tdir UNUSED,\n     int\t\tlen,\n     int\t\twhole,\n     int\t\tskip_comments,\n     int\t\ttype,\n     long\tcount,\n     int\t\taction,\n     linenr_T\tstart_lnum,\n     linenr_T\tend_lnum)\n {\n     SearchedFile *files;\n     SearchedFile *bigger;\n     int\t\tmax_path_depth = 50;\n     long\tmatch_count = 1;\n \n     char_u\t*pat;\n     char_u\t*new_fname;\n     char_u\t*curr_fname = curbuf->b_fname;\n     char_u\t*prev_fname = NULL;\n     linenr_T\tlnum;\n     int\t\tdepth;\n     int\t\tdepth_displayed;\n     int\t\told_files;\n     int\t\talready_searched;\n     char_u\t*file_line;\n     char_u\t*line;\n     char_u\t*p;\n     char_u\tsave_char;\n     int\t\tdefine_matched;\n     regmatch_T\tregmatch;\n     regmatch_T\tincl_regmatch;\n     regmatch_T\tdef_regmatch;\n     int\t\tmatched = FALSE;\n     int\t\tdid_show = FALSE;\n     int\t\tfound = FALSE;\n     int\t\ti;\n     char_u\t*already = NULL;\n     char_u\t*startp = NULL;\n     char_u\t*inc_opt = NULL;\n #if defined(FEAT_QUICKFIX)\n     win_T\t*curwin_save = NULL;\n #endif\n \n     regmatch.regprog = NULL;\n     incl_regmatch.regprog = NULL;\n     def_regmatch.regprog = NULL;\n \n     file_line = alloc(LSIZE);\n     if (file_line == NULL)\n \treturn;\n \n     if (type != CHECK_PATH && type != FIND_DEFINE\n \t    && !compl_status_sol())\n     {\n \tpat = alloc(len + 5);\n \tif (pat == NULL)\n \t    goto fpip_end;\n \tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n \tregmatch.rm_ic = ignorecase(pat);\n \tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n \tvim_free(pat);\n \tif (regmatch.regprog == NULL)\n \t    goto fpip_end;\n     }\n     inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n     if (*inc_opt != NUL)\n     {\n \tincl_regmatch.regprog = vim_regcomp(inc_opt,\n \t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n \tif (incl_regmatch.regprog == NULL)\n \t    goto fpip_end;\n \tincl_regmatch.rm_ic = FALSE;\n     }\n     if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n     {\n \tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n \t\t\t   ? p_def : curbuf->b_p_def,\n \t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n \tif (def_regmatch.regprog == NULL)\n \t    goto fpip_end;\n \tdef_regmatch.rm_ic = FALSE;\n     }\n     files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n     if (files == NULL)\n \tgoto fpip_end;\n     old_files = max_path_depth;\n     depth = depth_displayed = -1;\n \n     lnum = start_lnum;\n     if (end_lnum > curbuf->b_ml.ml_line_count)\n \tend_lnum = curbuf->b_ml.ml_line_count;\n     if (lnum > end_lnum)\n \tlnum = end_lnum;\n// bug_start\n    line = ml_get(lnum);\n// bug_end\n \n     for (;;)\n     {\n \tif (incl_regmatch.regprog != NULL\n \t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n \t{\n \t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n \t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n \n \t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n \t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n \t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n \t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n \t    else\n \t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n \t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n \t    already_searched = FALSE;\n \t    if (new_fname != NULL)\n \t    {\n \t\tfor (i = 0;; i++)\n \t\t{\n \t\t    if (i == depth + 1)\n \t\t\ti = old_files;\n \t\t    if (i == max_path_depth)\n \t\t\tbreak;\n \t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n \t\t\t\t\t\t\t\t    & FPC_SAME)\n \t\t    {\n \t\t\tif (type != CHECK_PATH\n \t\t\t\t&& action == ACTION_SHOW_ALL\n \t\t\t\t&& files[i].matched)\n \t\t\t{\n \t\t\t    msg_putchar('\\n');\n \t\t\t    if (!got_int)\n \t\t\t    {\n \t\t\t\tmsg_home_replace_hl(new_fname);\n \t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n \t\t\t\tprev_fname = NULL;\n \t\t\t    }\n \t\t\t}\n \t\t\tVIM_CLEAR(new_fname);\n \t\t\talready_searched = TRUE;\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \t    }\n \n \t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n \t\t\t\t || (new_fname == NULL && !already_searched)))\n \t    {\n \t\tif (did_show)\n \t\t    msg_putchar('\\n');\n \t\telse\n \t\t{\n \t\t    gotocmdline(TRUE);\n \t\t    msg_puts_title(_(\"--- Included files \"));\n \t\t    if (action != ACTION_SHOW_ALL)\n \t\t\tmsg_puts_title(_(\"not found \"));\n \t\t    msg_puts_title(_(\"in path ---\\n\"));\n \t\t}\n \t\tdid_show = TRUE;\n \t\twhile (depth_displayed < depth && !got_int)\n \t\t{\n \t\t    ++depth_displayed;\n \t\t    for (i = 0; i < depth_displayed; i++)\n \t\t\tmsg_puts(\"  \");\n \t\t    msg_home_replace(files[depth_displayed].name);\n \t\t    msg_puts(\" -->\\n\");\n \t\t}\n \t\tif (!got_int)\n \t\t{\n \t\t    for (i = 0; i <= depth_displayed; i++)\n \t\t\tmsg_puts(\"  \");\n \t\t    if (new_fname != NULL)\n \t\t    {\n \t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tif (inc_opt != NULL\n \t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n \t\t\t{\n \t\t\t    p = incl_regmatch.startp[0];\n \t\t\t    i = (int)(incl_regmatch.endp[0]\n \t\t\t\t\t\t   - incl_regmatch.startp[0]);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    for (p = incl_regmatch.endp[0];\n \t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n \t\t\t\t;\n \t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n \t\t\t\t;\n \t\t\t}\n \n \t\t\tif (i == 0)\n \t\t\t{\n \t\t\t    p = incl_regmatch.endp[0];\n \t\t\t    i = (int)STRLEN(p);\n \t\t\t}\n \t\t\telse if (p > line)\n \t\t\t{\n \t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n \t\t\t    {\n \t\t\t\t--p;\n \t\t\t\t++i;\n \t\t\t    }\n \t\t\t    if (p[i] == '\"' || p[i] == '>')\n \t\t\t\t++i;\n \t\t\t}\n \t\t\tsave_char = p[i];\n \t\t\tp[i] = NUL;\n \t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n \t\t\tp[i] = save_char;\n \t\t    }\n \n \t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n \t\t    {\n \t\t\tif (already_searched)\n \t\t\t    msg_puts(_(\"  (Already listed)\"));\n \t\t\telse\n \t\t\t    msg_puts(_(\"  NOT FOUND\"));\n \t\t    }\n \t\t}\n \t\tout_flush();\n \t    }\n \n \t    if (new_fname != NULL)\n \t    {\n \t\tif (depth + 1 == old_files)\n \t\t{\n \t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n \t\t    if (bigger != NULL)\n \t\t    {\n \t\t\tfor (i = 0; i <= depth; i++)\n \t\t\t    bigger[i] = files[i];\n \t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n \t\t\t{\n \t\t\t    bigger[i].fp = NULL;\n \t\t\t    bigger[i].name = NULL;\n \t\t\t    bigger[i].lnum = 0;\n \t\t\t    bigger[i].matched = FALSE;\n \t\t\t}\n \t\t\tfor (i = old_files; i < max_path_depth; i++)\n \t\t\t    bigger[i + max_path_depth] = files[i];\n \t\t\told_files += max_path_depth;\n \t\t\tmax_path_depth *= 2;\n \t\t\tvim_free(files);\n \t\t\tfiles = bigger;\n \t\t    }\n \t\t}\n \t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n \t\t\t\t\t\t\t\t    == NULL)\n \t\t    vim_free(new_fname);\n \t\telse\n \t\t{\n \t\t    if (++depth == old_files)\n \t\t    {\n \t\t\tvim_free(files[old_files].name);\n \t\t\t++old_files;\n \t\t    }\n \t\t    files[depth].name = curr_fname = new_fname;\n \t\t    files[depth].lnum = 0;\n \t\t    files[depth].matched = FALSE;\n \t\t    if (action == ACTION_EXPAND)\n \t\t    {\n \t\t\tmsg_hist_off = TRUE;\n \t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n \t\t\t\t_(\"Scanning included file: %s\"),\n \t\t\t\t(char *)new_fname);\n \t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n \t\t    }\n \t\t    else if (p_verbose >= 5)\n \t\t    {\n \t\t\tverbose_enter();\n \t\t\tsmsg(_(\"Searching included file %s\"),\n \t\t\t\t\t\t\t   (char *)new_fname);\n \t\t\tverbose_leave();\n \t\t    }\n \n \t\t}\n \t    }\n \t}\n \telse\n \t{\n \t    p = line;\n search_line:\n \t    define_matched = FALSE;\n \t    if (def_regmatch.regprog != NULL\n \t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n \t    {\n \t\tp = def_regmatch.endp[0];\n \t\twhile (*p && !vim_iswordc(*p))\n \t\t    p++;\n \t\tdefine_matched = TRUE;\n \t    }\n \n \t    if (def_regmatch.regprog == NULL || define_matched)\n \t    {\n \t\tif (define_matched || compl_status_sol())\n \t\t{\n \t\t    startp = skipwhite(p);\n \t\t    if (p_ic)\n \t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n \t\t    else\n \t\t\tmatched = !STRNCMP(startp, ptr, len);\n \t\t    if (matched && define_matched && whole\n \t\t\t\t\t\t  && vim_iswordc(startp[len]))\n \t\t\tmatched = FALSE;\n \t\t}\n \t\telse if (regmatch.regprog != NULL\n \t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n \t\t{\n \t\t    matched = TRUE;\n \t\t    startp = regmatch.startp[0];\n \t\t    if (!define_matched && skip_comments)\n \t\t    {\n \t\t\tif ((*line != '#' ||\n \t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n \t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n \t\t\t    matched = FALSE;\n \n \t\t\tp = skipwhite(line);\n \t\t\tif (matched\n \t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n \t\t\t    for (p = line; *p && p < startp; ++p)\n \t\t\t    {\n \t\t\t\tif (matched\n \t\t\t\t\t&& p[0] == '/'\n \t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n \t\t\t\t{\n \t\t\t\t    matched = FALSE;\n \t\t\t\t    if (p[1] == '/')\n \t\t\t\t\tbreak;\n \t\t\t\t    ++p;\n \t\t\t\t}\n \t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n \t\t\t\t{\n \t\t\t\t    matched = TRUE;\n \t\t\t\t    ++p;\n \t\t\t\t}\n \t\t\t    }\n \t\t    }\n \t\t}\n \t    }\n \t}\n \tif (matched)\n \t{\n \t    if (action == ACTION_EXPAND)\n \t    {\n \t\tint\tcont_s_ipos = FALSE;\n \t\tint\tadd_r;\n \t\tchar_u\t*aux;\n \n \t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n \t\t    break;\n \t\tfound = TRUE;\n \t\taux = p = startp;\n \t\tif (compl_status_adding())\n \t\t{\n \t\t    p += ins_compl_len();\n \t\t    if (vim_iswordp(p))\n \t\t\tgoto exit_matched;\n \t\t    p = find_word_start(p);\n \t\t}\n \t\tp = find_word_end(p);\n \t\ti = (int)(p - aux);\n \n \t\tif (compl_status_adding() && i == ins_compl_len())\n \t\t{\n \t\t    STRNCPY(IObuff, aux, i);\n \n \t\t    if (depth < 0)\n \t\t    {\n \t\t\tif (lnum >= end_lnum)\n \t\t\t    goto exit_matched;\n// bug_start\n\t\t\tline = ml_get(++lnum);\n// bug_end\n \t\t    }\n \t\t    else if (vim_fgets(line = file_line,\n \t\t\t\t\t\t      LSIZE, files[depth].fp))\n \t\t\tgoto exit_matched;\n \n \t\t    already = aux = p = skipwhite(line);\n \t\t    p = find_word_start(p);\n \t\t    p = find_word_end(p);\n \t\t    if (p > aux)\n \t\t    {\n \t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n \t\t\t{\n \t\t\t    if (IObuff[i-1] != ' ')\n \t\t\t\tIObuff[i++] = ' ';\n \t\t\t    if (p_js\n \t\t\t\t&& (IObuff[i-2] == '.'\n \t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n \t\t\t\t\t&& (IObuff[i-2] == '?'\n \t\t\t\t\t    || IObuff[i-2] == '!'))))\n \t\t\t\tIObuff[i++] = ' ';\n \t\t\t}\n \t\t\tif (p - aux >= IOSIZE - i)\n \t\t\t    p = aux + IOSIZE - i - 1;\n \t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n \t\t\ti += (int)(p - aux);\n \t\t\tcont_s_ipos = TRUE;\n \t\t    }\n \t\t    IObuff[i] = NUL;\n \t\t    aux = IObuff;\n \n \t\t    if (i == ins_compl_len())\n \t\t\tgoto exit_matched;\n \t\t}\n \n \t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n \t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n \t\t\tdir, cont_s_ipos);\n \t\tif (add_r == OK)\n \t\t    dir = FORWARD;\n \t\telse if (add_r == FAIL)\n \t\t    break;\n \t    }\n \t    else if (action == ACTION_SHOW_ALL)\n \t    {\n \t\tfound = TRUE;\n \t\tif (!did_show)\n \t\t    gotocmdline(TRUE);\n \t\tif (curr_fname != prev_fname)\n \t\t{\n \t\t    if (did_show)\n \t\t\tmsg_putchar('\\n');\n \t\t    if (!got_int)\n \t\t\tmsg_home_replace_hl(curr_fname);\n \t\t    prev_fname = curr_fname;\n \t\t}\n \t\tdid_show = TRUE;\n \t\tif (!got_int)\n \t\t    show_pat_in_path(line, type, TRUE, action,\n \t\t\t    (depth == -1) ? NULL : files[depth].fp,\n \t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n \t\t\t    match_count++);\n \n \t\tfor (i = 0; i <= depth; ++i)\n \t\t    files[i].matched = TRUE;\n \t    }\n \t    else if (--count <= 0)\n \t    {\n \t\tfound = TRUE;\n \t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n #if defined(FEAT_QUICKFIX)\n \t\t\t\t\t\t      && g_do_tagpreview == 0\n #endif\n \t\t\t\t\t\t      )\n \t\t    emsg(_(e_match_is_on_current_line));\n \t\telse if (action == ACTION_SHOW)\n \t\t{\n \t\t    show_pat_in_path(line, type, did_show, action,\n \t\t\t(depth == -1) ? NULL : files[depth].fp,\n \t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n \t\t    did_show = TRUE;\n \t\t}\n \t\telse\n \t\t{\n #ifdef FEAT_GUI\n \t\t    need_mouse_correct = TRUE;\n #endif\n #if defined(FEAT_QUICKFIX)\n \t\t    if (g_do_tagpreview != 0)\n \t\t    {\n \t\t\tcurwin_save = curwin;\n \t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n \t\t    }\n #endif\n \t\t    if (action == ACTION_SPLIT)\n \t\t    {\n \t\t\tif (win_split(0, 0) == FAIL)\n \t\t\t    break;\n \t\t\tRESET_BINDING(curwin);\n \t\t    }\n \t\t    if (depth == -1)\n \t\t    {\n #if defined(FEAT_QUICKFIX)\n \t\t\tif (g_do_tagpreview != 0)\n \t\t\t{\n \t\t\t    if (!win_valid(curwin_save))\n \t\t\t\tbreak;\n \t\t\t    if (!GETFILE_SUCCESS(getfile(\n \t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n \t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse\n #endif\n \t\t\t    setpcmark();\n \t\t\tcurwin->w_cursor.lnum = lnum;\n \t\t\tcheck_cursor();\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tif (!GETFILE_SUCCESS(getfile(\n \t\t\t\t\t0, files[depth].name, NULL, TRUE,\n \t\t\t\t\t\t    files[depth].lnum, FALSE)))\n \t\t\t    break;\n \t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n \t\t    }\n \t\t}\n \t\tif (action != ACTION_SHOW)\n \t\t{\n \t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n \t\t    curwin->w_set_curswant = TRUE;\n \t\t}\n \n #if defined(FEAT_QUICKFIX)\n \t\tif (g_do_tagpreview != 0\n \t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n \t\t{\n \t\t    validate_cursor();\n \t\t    redraw_later(VALID);\n \t\t    win_enter(curwin_save, TRUE);\n \t\t}\n # ifdef FEAT_PROP_POPUP\n \t\telse if (WIN_IS_POPUP(curwin))\n \t\t    win_enter(firstwin, TRUE);\n # endif\n #endif\n \t\tbreak;\n \t    }\n exit_matched:\n \t    matched = FALSE;\n \t    if (def_regmatch.regprog == NULL\n \t\t    && action == ACTION_EXPAND\n \t\t    && !compl_status_sol()\n \t\t    && *startp != NUL\n \t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n \t\tgoto search_line;\n \t}\n \tline_breakcheck();\n \tif (action == ACTION_EXPAND)\n \t    ins_compl_check_keys(30, FALSE);\n \tif (got_int || ins_compl_interrupted())\n \t    break;\n \n \twhile (depth >= 0 && !already\n \t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n \t{\n \t    fclose(files[depth].fp);\n \t    --old_files;\n \t    files[old_files].name = files[depth].name;\n \t    files[old_files].matched = files[depth].matched;\n \t    --depth;\n \t    curr_fname = (depth == -1) ? curbuf->b_fname\n \t\t\t\t       : files[depth].name;\n \t    if (depth < depth_displayed)\n \t\tdepth_displayed = depth;\n \t}\n \tif (depth >= 0)\n \t{\n \t    files[depth].lnum++;\n \t    i = (int)STRLEN(line);\n \t    if (i > 0 && line[i - 1] == '\\n')\n \t\tline[--i] = NUL;\n \t    if (i > 0 && line[i - 1] == '\\r')\n \t\tline[--i] = NUL;\n \t}\n \telse if (!already)\n \t{\n \t    if (++lnum > end_lnum)\n \t\tbreak;\n// bug_start\n\t    line = ml_get(lnum);\n// bug_end\n \t}\n \talready = NULL;\n     }\n \n     for (i = 0; i <= depth; i++)\n     {\n \tfclose(files[i].fp);\n \tvim_free(files[i].name);\n     }\n     for (i = old_files; i < max_path_depth; i++)\n \tvim_free(files[i].name);\n     vim_free(files);\n \n     if (type == CHECK_PATH)\n     {\n \tif (!did_show)\n \t{\n \t    if (action != ACTION_SHOW_ALL)\n \t\tmsg(_(\"All included files were found\"));\n \t    else\n \t\tmsg(_(\"No included files\"));\n \t}\n     }\n     else if (!found && action != ACTION_EXPAND)\n     {\n \tif (got_int || ins_compl_interrupted())\n \t    emsg(_(e_interrupted));\n \telse if (type == FIND_DEFINE)\n \t    emsg(_(e_couldnt_find_definition));\n \telse\n \t    emsg(_(e_couldnt_find_pattern));\n     }\n     if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n \tmsg_end();\n \n fpip_end:\n     vim_free(file_line);\n     vim_regfree(regmatch.regprog);\n     vim_regfree(incl_regmatch.regprog);\n     vim_regfree(def_regmatch.regprog);\n }\n \n", "target": "// fix_start\n    line = get_line_and_copy(lnum, file_line);\n// fix_end\n// fix_start\n\t\t\tline = get_line_and_copy(++lnum, file_line);\n// fix_end\n// fix_start\n\t    line = get_line_and_copy(lnum, file_line);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-1968", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 196328}
{"source": " yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n {\n     char_u\t*pnew;\n \n     if (exclude_trailing_space)\n \tbd->endspaces = 0;\n     if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n \t\t\t\t\t\t\t\t      == NULL)\n \treturn FAIL;\n     y_current->y_array[y_idx] = pnew;\n     vim_memset(pnew, ' ', (size_t)bd->startspaces);\n     pnew += bd->startspaces;\n     mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n     pnew += bd->textlen;\n     vim_memset(pnew, ' ', (size_t)bd->endspaces);\n     pnew += bd->endspaces;\n     if (exclude_trailing_space)\n     {\n \tint s = bd->textlen + bd->endspaces;\n \n// bug_start\n\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)\n// bug_end\n \t{\n \t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n \t    pnew--;\n \t}\n     }\n     *pnew = NUL;\n     return OK;\n }\n \n", "target": "// fix_start\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0407", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 196578}
{"source": "   void DoCompute(OpKernelContext* c) {\n     core::RefCountPtr<Var> v;\n     OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));\n     Tensor* params = v->tensor();\n     const Tensor& indices = c->input(1);\n     const Tensor& updates = c->input(2);\n \n     OP_REQUIRES(c,\n                 updates.dims() == 0 ||\n                     updates.dims() == indices.dims() + params->dims() - 1,\n                 errors::InvalidArgument(\n                     \"Must have updates.shape = indices.shape + \"\n                     \"params.shape[1:] or updates.shape = [], got \",\n                     \"updates.shape \", updates.shape().DebugString(),\n                     \", indices.shape \", indices.shape().DebugString(),\n                     \", params.shape \", params->shape().DebugString()));\n \n     const int64_t N_big = indices.NumElements();\n     OP_REQUIRES(\n         c, N_big <= std::numeric_limits<Index>::max(),\n         errors::InvalidArgument(\"indices has too many elements for \",\n                                 DataTypeString(DataTypeToEnum<Index>::v()),\n                                 \" indexing: \", N_big, \" > \",\n                                 std::numeric_limits<Index>::max()));\n     const Index N = static_cast<Index>(N_big);\n     OP_REQUIRES(\n         c, params->dim_size(0) <= std::numeric_limits<Index>::max(),\n         errors::InvalidArgument(\"params.shape[0] too large for \",\n                                 DataTypeString(DataTypeToEnum<Index>::v()),\n                                 \" indexing: \", params->dim_size(0), \" > \",\n                                 std::numeric_limits<Index>::max()));\n// bug_start\n// bug_end\n \n     if (N > 0) {\n       auto indices_flat = indices.flat<Index>();\n       auto params_flat = params->flat_outer_dims<T>();\n       if (TensorShapeUtils::IsScalar(updates.shape())) {\n         const auto update = updates.scalar<T>();\n \n         functor::ScatterScalarFunctor<Device, T, Index, op> functor;\n         const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                     params_flat, update, indices_flat);\n         OP_REQUIRES(c, bad_i < 0,\n                     errors::InvalidArgument(\n                         \"indices\", SliceDebugString(indices.shape(), bad_i),\n                         \" = \", indices_flat(bad_i), \" is not in [0, \",\n                         params->dim_size(0), \")\"));\n       } else {\n         int64_t num_updates = updates.NumElements();\n         OP_REQUIRES(\n             c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),\n             errors::InvalidArgument(\n                 \"The shape of indices (\", indices.shape().DebugString(),\n                 \") must be a prefix of the shape of updates (\",\n                 updates.shape().DebugString(), \")\"));\n         auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});\n \n         functor::ScatterFunctor<Device, T, Index, op> functor;\n         const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                     params_flat, updates_flat, indices_flat);\n         OP_REQUIRES(c, bad_i < 0,\n                     errors::InvalidArgument(\n                         \"indices\", SliceDebugString(indices.shape(), bad_i),\n                         \" = \", indices_flat(bad_i), \" is not in [0, \",\n                         params->dim_size(0), \")\"));\n       }\n     }\n   }\n \n", "target": "// fix_start\n\n    if (isCPUDevice<Device>() && op == tensorflow::scatter_op::UpdateOp::DIV) {\n      OP_REQUIRES(c, ValidateInput<T>(updates),\n                  errors::InvalidArgument(\"updates must not contain 0\"));\n    }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37642", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196587}
{"source": " static int setup_config(int type)\n {\n \tint rv;\n \n \trv = read_config(cl.configfile, type);\n \tif (rv < 0)\n \t\tgoto out;\n \n// bug_start\n\tif (is_auth_req()) {\n// bug_end\n \t\trv = read_authkey();\n \t\tif (rv < 0)\n \t\t\tgoto out;\n #if HAVE_LIBGCRYPT\n \t\tif (!gcry_check_version(NULL)) {\n \t\t\tlog_error(\"gcry_check_version\");\n \t\t\trv = -ENOENT;\n \t\t\tgoto out;\n \t\t}\n \t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n \t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n #endif\n \t}\n \n \tif (cl.type == DAEMON && cl.site[0]) {\n \t\tif (!find_site_by_name(cl.site, &local, 1)) {\n \t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n \t\t\t\t\tcl.site);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\tlocal->local = 1;\n \t} else\n \t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n \n \n \trv = check_config(type);\n \tif (rv < 0)\n \t\tgoto out;\n \n \n \tif (!cl.lockfile[0]) {\n \t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n \t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n \t}\n \n out:\n \treturn rv;\n }\n \n", "target": "// fix_start\n\tif (booth_conf->authfile[0] != '\\0') {\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2022-2553", "cve_desc": "The authfile directive in the booth config file is ignored, preventing use of authentication in communications from node to node. As a result, nodes that do not have the correct authentication key are not prevented from communicating with other nodes in the cluster.", "project": "booth", "idx": 196611}
{"source": " mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n {\n   mt_tbl *h;\n \n   MRB_CLASS_ORIGIN(c);\n   h = c->mt;\n \n// bug_start\n  if (h && mt_del(mrb, h, mid)) return;\n// bug_end\n   mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n }\n \n", "target": "// fix_start\n  if (h && mt_del(mrb, h, mid)) {\n    mrb_mc_clear_by_class(mrb, c);\n    return;\n  }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-1286", "cve_desc": "heap-buffer-overflow in mrb_vm_exec in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.", "project": "mruby", "idx": 196621}
{"source": "   void ComputeAsync(OpKernelContext* context, DoneCallback done) final {\n     const Tensor& input = context->input(0);\n     const Tensor& rhs = context->input(1);\n     const int ndims = input.dims();\n     const int64 n = input.dim_size(ndims - 1);\n     const int64 nrhs = rhs.dim_size(ndims - 1);\n     OP_REQUIRES_ASYNC(\n         context, ndims >= 2,\n         errors::InvalidArgument(\"Input must have rank >= 2, got \", ndims),\n         done);\n     OP_REQUIRES_ASYNC(context, rhs.dims() == ndims,\n                       errors::InvalidArgument(\n                           \"Input and right-hand side must have same rank, got \",\n                           ndims, \" != \", rhs.dims()),\n                       done);\n     OP_REQUIRES_ASYNC(\n         context, input.dim_size(ndims - 2) == n,\n// bug_start\n        errors::InvalidArgument(\"Input matrices must be squares, got\",\n// bug_end\n                                 input.dim_size(ndims - 2), \" != \", n),\n         done);\n     OP_REQUIRES_ASYNC(context, rhs.dim_size(ndims - 2) == n,\n                       errors::InvalidArgument(\n                           \"Input matrix and right-hand side must have the \"\n// bug_start\n                          \"same number of rows, got\",\n// bug_end\n                           n, \" != \", rhs.dim_size(ndims - 2)),\n                       done);\n// bug_start\n// bug_end\n \n     Tensor* output;\n     OP_REQUIRES_OK_ASYNC(\n         context,\n         context->forward_input_or_allocate_output({1}, 0, rhs.shape(), &output),\n         done);\n \n     if (input.NumElements() == 0 || rhs.NumElements() == 0) {\n       done();\n       return;\n     }\n \n     std::unique_ptr<CudaSolver> solver(new CudaSolver(context));\n \n     Tensor input_copy;\n     const GPUDevice& device = context->eigen_device<GPUDevice>();\n     if (adjoint_) {\n       OP_REQUIRES_OK_ASYNC(\n           context,\n           solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,\n                                          input.shape(), &input_copy),\n           done);\n       OP_REQUIRES_OK_ASYNC(context,\n                            DoMatrixTranspose(device, input, &input_copy), done);\n     } else {\n       OP_REQUIRES_OK_ASYNC(\n           context,\n           solver->forward_input_or_allocate_scoped_tensor(\n               {0}, DataTypeToEnum<Scalar>::value, input.shape(), &input_copy),\n           done);\n       if (!input.SharesBufferWith(input_copy)) {\n         device.memcpy(input_copy.flat<Scalar>().data(),\n                       input.flat<Scalar>().data(),\n                       input.NumElements() * sizeof(Scalar));\n       }\n     }\n     auto input_copy_reshaped = input_copy.template flat_inner_dims<Scalar, 3>();\n     const int64 batch_size = input_copy_reshaped.dimension(0);\n \n     Tensor pivots;\n     OP_REQUIRES_OK_ASYNC(\n         context,\n         solver->allocate_scoped_tensor(DataTypeToEnum<int>::value,\n                                        TensorShape{batch_size, n}, &pivots),\n         done);\n     auto pivots_mat = pivots.template matrix<int>();\n \n     std::vector<DeviceLapackInfo> dev_info;\n     auto input_copy_ptrs = solver->GetScratchSpace<uint8>(\n         sizeof(Scalar*) * batch_size, \"input_copt_ptrs\",\n          true);\n     const int kMaxMatrixSizeToBatchSizeRatio = 128;\n     const bool use_batched_solver =\n         n <= kMaxMatrixSizeToBatchSizeRatio * batch_size;\n     if (use_batched_solver) {\n       const Scalar** input_copy_ptrs_base =\n           reinterpret_cast<const Scalar**>(input_copy_ptrs.mutable_data());\n       for (int batch = 0; batch < batch_size; ++batch) {\n         input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);\n       }\n       dev_info.push_back(\n           solver->GetDeviceLapackInfo(batch_size, \"getrfBatched\"));\n       OP_REQUIRES_OK_ASYNC(\n           context,\n           solver->GetrfBatched(n, input_copy_ptrs_base, n, pivots_mat.data(),\n                                &dev_info.back(), batch_size),\n           done);\n     } else {\n       dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"getrf\"));\n       for (int batch = 0; batch < batch_size; ++batch) {\n         OP_REQUIRES_OK_ASYNC(\n             context,\n             solver->Getrf(n, n, &input_copy_reshaped(batch, 0, 0), n,\n                           &pivots_mat(batch, 0), &dev_info.back()(batch)),\n             done);\n       }\n     }\n \n     TensorShape transposed_rhs_shape(rhs.shape());\n     transposed_rhs_shape.RemoveLastDims(2);\n     transposed_rhs_shape.AddDim(nrhs);\n     transposed_rhs_shape.AddDim(n);\n     Tensor transposed_rhs;\n     OP_REQUIRES_OK_ASYNC(\n         context,\n         solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,\n                                        transposed_rhs_shape, &transposed_rhs),\n         done);\n     if (nrhs > 1) {\n       OP_REQUIRES_OK_ASYNC(\n           context, DoMatrixTranspose(device, rhs, &transposed_rhs), done);\n     } else {\n       device.memcpy(transposed_rhs.flat<Scalar>().data(),\n                     rhs.flat<Scalar>().data(),\n                     rhs.NumElements() * sizeof(Scalar));\n     }\n \n     auto input_copy_ptr_array = solver->GetScratchSpace<uint8>(\n         sizeof(Scalar*) * batch_size, \"input_copy_ptr_array\",\n          true);\n     auto transposed_rhs_ptr_array = solver->GetScratchSpace<uint8>(\n         sizeof(Scalar*) * batch_size, \"transposed_rhs_ptr_array\",\n          true);\n     auto transposed_rhs_reshaped =\n         transposed_rhs.template flat_inner_dims<Scalar, 3>();\n     if (use_batched_solver) {\n       const Scalar** input_copy_ptrs_base =\n           reinterpret_cast<const Scalar**>(input_copy_ptr_array.mutable_data());\n       const Scalar** transposed_rhs_ptrs_base =\n           reinterpret_cast<const Scalar**>(\n               transposed_rhs_ptr_array.mutable_data());\n       for (int batch = 0; batch < batch_size; ++batch) {\n         input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);\n         transposed_rhs_ptrs_base[batch] = &transposed_rhs_reshaped(batch, 0, 0);\n       }\n       int host_info = 0;\n       OP_REQUIRES_OK_ASYNC(\n           context,\n           solver->GetrsBatched(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,\n                                input_copy_ptrs_base, n, pivots_mat.data(),\n                                transposed_rhs_ptrs_base, n, &host_info,\n                                batch_size),\n           done);\n       OP_REQUIRES_ASYNC(\n           context, host_info == 0,\n           errors::InvalidArgument(\"The \", -host_info,\n                                   \"'th argument to cublas*getrsBatched had \"\n                                   \"an illegal value.\"),\n           done);\n     } else {\n       dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"getrs\"));\n       for (int batch = 0; batch < batch_size; ++batch) {\n         OP_REQUIRES_OK_ASYNC(\n             context,\n             solver->Getrs(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,\n                           &input_copy_reshaped(batch, 0, 0), n,\n                           &pivots_mat(batch, 0),\n                           &transposed_rhs_reshaped(batch, 0, 0), n,\n                           &dev_info.back()(batch)),\n             done);\n       }\n     }\n \n     if (nrhs > 1) {\n       OP_REQUIRES_OK_ASYNC(\n           context, DoMatrixTranspose(device, transposed_rhs, output), done);\n     } else {\n       device.memcpy(output->flat<Scalar>().data(),\n                     transposed_rhs.flat<Scalar>().data(),\n                     transposed_rhs.NumElements() * sizeof(Scalar));\n     }\n \n     auto info_checker = [context, done, dev_info](\n                             const Status& status,\n                             const std::vector<HostLapackInfo>& host_infos) {\n       if (!status.ok() && errors::IsInvalidArgument(status) &&\n           !host_infos.empty()) {\n         for (int i = 0; i < host_infos[0].size(); ++i) {\n           OP_REQUIRES_ASYNC(context, host_infos[0].data()[i] <= 0,\n                             errors::InvalidArgument(kErrMsg), done);\n         }\n       }\n       OP_REQUIRES_OK_ASYNC(context, status, done);\n       done();\n     };\n     CudaSolver::CheckLapackInfoAndDeleteSolverAsync(std::move(solver), dev_info,\n                                                     std::move(info_checker));\n   }\n \n", "target": "// fix_start\n        errors::InvalidArgument(\"Input matrices must be squares, got \",\n// fix_end\n// fix_start\n                          \"same number of rows, got \",\n// fix_end\n// fix_start\n    for (int dim = 0; dim < ndims - 2; dim++) {\n      OP_REQUIRES_ASYNC(\n          context, input.dim_size(dim) == rhs.dim_size(dim),\n          errors::InvalidArgument(\n              \"All input tensors must have the same outer dimensions.\"),\n          done);\n    }\n// fix_end\n", "cwe": "CWE-354", "cwe_name": "Improper Validation of Integrity Check Value", "cve": "CVE-2021-41206", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196629}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     Buffer* buf = nullptr;\n     OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));\n     core::ScopedUnref scope(buf);\n     Buffer::Tuple tuple;\n \n// bug_start\n    std::size_t index = ctx->input(0).scalar<int>()();\n\n    OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));\n// bug_end\n \n     OP_REQUIRES(\n         ctx, tuple.size() == (size_t)ctx->num_outputs(),\n         errors::InvalidArgument(\"Mismatch stage/unstage: \", tuple.size(),\n                                 \" vs. \", ctx->num_outputs()));\n \n     for (size_t i = 0; i < tuple.size(); ++i) {\n       ctx->set_output(i, tuple[i]);\n     }\n   }\n \n", "target": "// fix_start\n    buf->Get(&tuple);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-29195", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.StagePeek` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `index` is a scalar but there is no validation for this before accessing its value. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 196689}
{"source": " static GF_Err isoffin_process(GF_Filter *filter)\n {\n \tISOMReader *read = gf_filter_get_udta(filter);\n \tu32 i, count = gf_list_count(read->channels);\n \tBool is_active = GF_FALSE;\n \tBool in_is_eos = GF_FALSE;\n \tBool check_forced_end = GF_FALSE;\n \tBool has_new_data = GF_FALSE;\n \tu64 min_offset_plus_one = 0;\n \tu32 nb_forced_end=0;\n \tif (read->in_error)\n \t\treturn read->in_error;\n \n \tif (read->pid) {\n \t\tBool fetch_input = GF_TRUE;\n \n \t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n \t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n \t\t\tif (read->moov_not_loaded) return GF_OK;\n \t\t}\n \t\tif (read->mem_load_mode==2) {\n \t\t\tif (!read->force_fetch && read->mem_blob.size > read->mstore_size) {\n \t\t\t\tfetch_input = GF_FALSE;\n \t\t\t}\n \t\t\tread->force_fetch = GF_FALSE;\n \t\t}\n \t\twhile (fetch_input) {\n \t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n \t\t\tif (!pck) {\n \t\t\t\tif (read->wait_for_source) {\n \t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n \t\t\t\t\t\treturn GF_EOS;\n \t\t\t\t\treturn GF_OK;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tread->wait_for_source = GF_FALSE;\n \n \t\t\tif (read->mem_load_mode) {\n \t\t\t\tu32 data_size;\n \t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n \t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n \t\t\t}\n \t\t\telse if (read->moov_not_loaded==2) {\n \t\t\t\tgf_filter_pid_drop_packet(read->pid);\n \t\t\t\treturn GF_OK;\n \t\t\t}\n \t\t\tgf_filter_pid_drop_packet(read->pid);\n \t\t\thas_new_data = GF_TRUE;\n \t\t\tif (read->in_error)\n \t\t\t\treturn read->in_error;\n \t\t}\n \t\tif (gf_filter_pid_is_eos(read->pid)) {\n \t\t\tread->input_loaded = GF_TRUE;\n \t\t\tin_is_eos = GF_TRUE;\n \t\t}\n \t\tif (read->input_is_stop) {\n \t\t\tread->input_loaded = GF_TRUE;\n \t\t\tin_is_eos = GF_TRUE;\n \t\t\tread->input_is_stop = GF_FALSE;\n \t\t}\n \t\tif (!read->frag_type && read->input_loaded) {\n \t\t\tin_is_eos = GF_TRUE;\n \t\t}\n         if (read->invalid_segment) {\n             if (!in_is_eos) return GF_OK;\n             read->invalid_segment = GF_FALSE;\n \n             for (i=0; i<count; i++) {\n                 ISOMChannel *ch = gf_list_get(read->channels, i);\n                 if (!ch->playing) {\n                     continue;\n                 }\n                 if (!ch->eos_sent) {\n                     ch->eos_sent = GF_TRUE;\n                     gf_filter_pid_set_eos(ch->pid);\n                 }\n             }\n             read->eos_signaled = GF_TRUE;\n             return GF_EOS;\n         }\n \t} else if (read->extern_mov) {\n \t\tin_is_eos = GF_TRUE;\n \t\tread->input_loaded = GF_TRUE;\n \t}\n \tif (read->moov_not_loaded==1) {\n \t\tif (read->mem_load_mode)\n \t\t\treturn GF_OK;\n \t\tread->moov_not_loaded = GF_FALSE;\n \t\treturn isoffin_setup(filter, read);\n \t}\n \n \tif (read->refresh_fragmented) {\n \t\tconst GF_PropertyValue *prop;\n \n \t\tif (in_is_eos) {\n \t\t\tread->refresh_fragmented = GF_FALSE;\n \t\t} else {\n \t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n \t\t\tif (prop && prop->value.boolean)\n \t\t\t\tread->refresh_fragmented = GF_FALSE;\n \t\t}\n \n \t\tif (has_new_data) {\n \t\t\tu64 bytesMissing=0;\n \t\t\tGF_Err e;\n \t\t\tconst char *new_url = NULL;\n \t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n \t\t\tif (prop) new_url = prop->value.string;\n \n \t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n \n \t\t\tif (e && (e!= GF_ISOM_INCOMPLETE_FILE)) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n \t\t\t\tread->refresh_fragmented = GF_FALSE;\n \t\t\t} else {\n \t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n \t\t\t}\n \n \t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n \t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n \t\t\t}\n \n #ifndef GPAC_DISABLE_LOG\n \t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n \t\t\t\tfor (i=0; i<count; i++) {\n \t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n \t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n \t\t\t\t}\n \t\t\t}\n #endif\n \t\t\tisor_check_producer_ref_time(read);\n \t\t\tif (!read->frag_type)\n \t\t\t\tread->refresh_fragmented = GF_FALSE;\n \t\t}\n \t}\n \n \tfor (i=0; i<count; i++) {\n \t\tu8 *data;\n \t\tu32 nb_pck=50;\n \t\tISOMChannel *ch;\n \t\tch = gf_list_get(read->channels, i);\n \t\tif (!ch->playing) {\n \t\t\tnb_forced_end++;\n \t\t\tcontinue;\n \t\t}\n \t\tif (!ch->eos_sent)\n \t\t\tis_active = GF_TRUE;\n \n \t\twhile (nb_pck) {\n \t\t\tch->sample_data_offset = 0;\n \t\t\tif (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n \t\t\t\tbreak;\n \n \t\t\tif (ch->item_id) {\n \t\t\t\tisor_reader_get_sample_from_item(ch);\n \t\t\t} else {\n \t\t\t\tisor_reader_get_sample(ch);\n \t\t\t}\n \n \t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n \t\t\t\tisor_reader_release_sample(ch);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (ch->sample) {\n \t\t\t\tu32 sample_dur;\n \t\t\t\tu8 dep_flags;\n \t\t\t\tu8 *subs_buf;\n \t\t\t\tu32 subs_buf_size;\n \t\t\t\tGF_FilterPacket *pck;\n \t\t\t\tif (ch->needs_pid_reconfig) {\n \t\t\t\t\tisor_update_channel_config(ch);\n \t\t\t\t\tch->needs_pid_reconfig = GF_FALSE;\n \t\t\t\t}\n \n \t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n \t\t\t\t\tch->check_has_rap = GF_FALSE;\n \t\t\t\t\tch->has_rap = GF_TRUE;\n \t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n \t\t\t\t}\n \n \t\t\t\tisor_reader_check_config(ch);\n \n \t\t\t\tif (read->nodata) {\n \t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n \t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n \t\t\t\t} else {\n \t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n \t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n \n \t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n \t\t\t\t}\n \t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n \t\t\t\tgf_filter_pck_set_cts(pck, ch->cts);\n \t\t\t\tif (ch->sample->IsRAP==-1) {\n \t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n \t\t\t\t\tch->redundant = 1;\n \t\t\t\t} else {\n \t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n \t\t\t\t}\n \n \t\t\t\tif (ch->sap_3)\n \t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n \t\t\t\telse if (ch->sap_4_type) {\n \t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n \t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n \t\t\t\t}\n \n \t\t\t\tsample_dur = ch->au_duration;\n \t\t\t\tif (ch->sample->nb_pack)\n \t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n \t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n \t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n \n \t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n \t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n \t\t\t\t}\n \n \t\t\t\tdep_flags = ch->isLeading;\n \t\t\t\tdep_flags <<= 2;\n \t\t\t\tdep_flags |= ch->dependsOn;\n \t\t\t\tdep_flags <<= 2;\n \t\t\t\tdep_flags |= ch->dependedOn;\n \t\t\t\tdep_flags <<= 2;\n \t\t\t\tdep_flags |= ch->redundant;\n \n \t\t\t\tif (dep_flags)\n \t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n \n \t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n \t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n \n \n \t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n \t\t\t\tif (subs_buf) {\n \t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n \t\t\t\t}\n \n \t\t\t\tif (ch->sai_buffer && ch->pck_encrypted) {\n \t\t\t\t\tassert(ch->sai_buffer_size);\n \t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n \t\t\t\t}\n \n \t\t\t\tif (read->sigfrag) {\n \t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n \t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n \t\t\t\t\t\tu64 start=0;\n \t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n \n \t\t\t\t\t\tif (finfo.seg_start_plus_one)\n \t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n \n \t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n \n \t\t\t\t\t\tstart = finfo.frag_start;\n \t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n \t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n \t\t\t\t\t\tif (finfo.moof_template) {\n \t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (finfo.sidx_end) {\n \t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (read->seg_name_changed) {\n \t\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n \t\t\t\t\t\t\tread->seg_name_changed = GF_FALSE;\n \t\t\t\t\t\t\tif (p && p->value.string) {\n \t\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string));\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (ch->sender_ntp) {\n \t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n \t\t\t\t\tif (ch->ntp_at_server_ntp) {\n \t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tch->eos_sent = GF_FALSE;\n \n \t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n \t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n \t\t\t\t}\n \n \t\t\t\tgf_filter_pck_send(pck);\n \t\t\t\tisor_reader_release_sample(ch);\n \n \t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n \t\t\t\tnb_pck--;\n \t\t\t} else if (ch->last_state==GF_EOS) {\n \t\t\t\tif (ch->playing == 2) {\n \t\t\t\t\tif (in_is_eos) {\n \t\t\t\t\t\tch->playing = GF_FALSE;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tnb_forced_end++;\n \t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (in_is_eos && !ch->eos_sent) {\n \t\t\t\t\tvoid *tfrf;\n \t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n \n \t\t\t\t\tch->eos_sent = GF_TRUE;\n \t\t\t\t\tread->eos_signaled = GF_TRUE;\n \n \t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n \t\t\t\t\tif (tfrf) {\n \t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n \t\t\t\t\t\tch->last_has_tfrf = GF_TRUE;\n \t\t\t\t\t} else if (ch->last_has_tfrf) {\n \t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n \t\t\t\t\t\tch->last_has_tfrf = GF_FALSE;\n \t\t\t\t\t}\n \n \t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n \t\t\t\t}\n \t\t\t\tbreak;\n// bug_start\n// bug_end\n \t\t\t} else {\n \t\t\t\tread->force_fetch = GF_TRUE;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n \t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n \t}\n \tif (read->mem_load_mode && min_offset_plus_one) {\n \t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n \t}\n \n \tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n \t\tGF_FilterEvent evt;\n \t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n \t\tgf_filter_pid_send_event(read->pid, &evt);\n \t}\n \n \n \tif (!is_active) {\n \t\treturn GF_EOS;\n \t}\n \treturn GF_OK;\n \n }\n \n", "target": "// fix_start\n\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE) {\n\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\treturn ch->last_state;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-40592", "cve_desc": "GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop') vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process() can result in DoS by infinite loop. To exploit, the victim must open a specially crafted mp4 file.", "project": "gpac", "idx": 196691}
{"source": " void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                                AsyncOpKernel::DoneCallback done = nullptr) {\n   if (!done) {\n     done = [] {};\n   }\n \n   const int kIndicesInput = 0;\n   const int kValuesInput = 1;\n   const int kDenseShapeInput = 2;\n   const int kDefaultValueInput = 3;\n \n   const Tensor& indices_t = context->input(kIndicesInput);\n   const Tensor& values_t = context->input(kValuesInput);\n   const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n   const Tensor& default_value_t = context->input(kDefaultValueInput);\n \n   OP_REQUIRES_ASYNC(\n       context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n       errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                               dense_shape_t.shape().DebugString()),\n       done);\n   OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                     errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                             indices_t.shape().DebugString()),\n                     done);\n   OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                     errors::InvalidArgument(\"values must be a vector, saw: \",\n                                             values_t.shape().DebugString()),\n                     done);\n   OP_REQUIRES_ASYNC(\n// bug_start\n// bug_end\n       context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n       errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                               default_value_t.shape().DebugString()),\n       done);\n   OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                     errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                     done);\n \n   using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n   OP_REQUIRES_OK_ASYNC(context,\n                        FunctorType()(context, default_value_t, indices_t,\n                                      values_t, dense_shape_t, done),\n                        done);\n }\n \n", "target": "// fix_start\n      context, indices_t.dim_size(0) == values_t.dim_size(0),\n      errors::InvalidArgument(\"The length of `values` (\", values_t.dim_size(0),\n                              \") must match the first dimension of `indices` (\",\n                              indices_t.dim_size(0), \").\"),\n      done);\n  OP_REQUIRES_ASYNC(\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-41224", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseFillEmptyRows` can be made to trigger a heap OOB access. This occurs whenever the size of `indices` does not match the size of `values`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196698}
{"source": " Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                       const Tensor *a_shape, const Tensor *b) {\n   if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n     return errors::InvalidArgument(\n         \"Input a_indices should be a matrix but received shape: \",\n         a_indices->shape().DebugString());\n   }\n   if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n       !TensorShapeUtils::IsVector(a_shape->shape())) {\n     return errors::InvalidArgument(\n         \"Inputs a_values and a_shape should be vectors \"\n         \"but received shapes: \",\n         a_values->shape().DebugString(), \" and \",\n         a_shape->shape().DebugString());\n   }\n// bug_start\n// bug_end\n   if (a_shape->NumElements() != b->dims()) {\n     return errors::InvalidArgument(\n         \"Two operands have different ranks; received: \", a_shape->NumElements(),\n         \" and \", b->dims());\n   }\n   const auto a_shape_flat = a_shape->flat<Index>();\n   for (int i = 0; i < b->dims(); ++i) {\n     if (a_shape_flat(i) != b->dim_size(i)) {\n       return errors::InvalidArgument(\n           \"Dimension \", i,\n           \" does not equal (no broadcasting is supported): sparse side \",\n           a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n     }\n   }\n// bug_start\n// bug_end\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n// fix_end\n// fix_start\n\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2022-29206", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SparseTensorDenseAdd` does not fully validate the input arguments. In this case, a reference gets bound to a `nullptr` during kernel execution. This is undefined behavior. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 196705}
{"source": " Status Examples::Initialize(OpKernelContext* const context,\n                             const ModelWeights& weights,\n                             const int num_sparse_features,\n                             const int num_sparse_features_with_values,\n                             const int num_dense_features) {\n   num_features_ = num_sparse_features + num_dense_features;\n \n   OpInputList sparse_example_indices_inputs;\n   TF_RETURN_IF_ERROR(context->input_list(\"sparse_example_indices\",\n                                          &sparse_example_indices_inputs));\n   if (sparse_example_indices_inputs.size() != num_sparse_features)\n     return errors::InvalidArgument(\n         \"Expected \", num_sparse_features,\n         \" tensors in sparse_example_indices but got \",\n         sparse_example_indices_inputs.size());\n   OpInputList sparse_feature_indices_inputs;\n   TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_indices\",\n                                          &sparse_feature_indices_inputs));\n   if (sparse_feature_indices_inputs.size() != num_sparse_features)\n     return errors::InvalidArgument(\n         \"Expected \", num_sparse_features,\n         \" tensors in sparse_feature_indices but got \",\n         sparse_feature_indices_inputs.size());\n   OpInputList sparse_feature_values_inputs;\n   if (num_sparse_features_with_values > 0) {\n     TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_values\",\n                                            &sparse_feature_values_inputs));\n     if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)\n       return errors::InvalidArgument(\n           \"Expected \", num_sparse_features_with_values,\n           \" tensors in sparse_feature_values but got \",\n           sparse_feature_values_inputs.size());\n   }\n \n   const Tensor* example_weights_t;\n   TF_RETURN_IF_ERROR(context->input(\"example_weights\", &example_weights_t));\n   auto example_weights = example_weights_t->flat<float>();\n \n   if (example_weights.size() >= std::numeric_limits<int>::max()) {\n     return errors::InvalidArgument(strings::Printf(\n         \"Too many examples in a mini-batch: %zu > %d\", example_weights.size(),\n         std::numeric_limits<int>::max()));\n   }\n \n   const int num_examples = static_cast<int>(example_weights.size());\n   const Tensor* example_labels_t;\n   TF_RETURN_IF_ERROR(context->input(\"example_labels\", &example_labels_t));\n   auto example_labels = example_labels_t->flat<float>();\n// bug_start\n// bug_end\n \n   OpInputList dense_features_inputs;\n   TF_RETURN_IF_ERROR(\n       context->input_list(\"dense_features\", &dense_features_inputs));\n \n   examples_.clear();\n   examples_.resize(num_examples);\n   probabilities_.resize(num_examples);\n   sampled_index_.resize(num_examples);\n   sampled_count_.resize(num_examples);\n   for (int example_id = 0; example_id < num_examples; ++example_id) {\n     Example* const example = &examples_[example_id];\n     example->sparse_features_.resize(num_sparse_features);\n     example->dense_vectors_.resize(num_dense_features);\n     example->example_weight_ = example_weights(example_id);\n     example->example_label_ = example_labels(example_id);\n   }\n   const DeviceBase::CpuWorkerThreads& worker_threads =\n       *context->device()->tensorflow_cpu_worker_threads();\n   TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(\n       worker_threads, num_examples, num_sparse_features, weights,\n       sparse_example_indices_inputs, sparse_feature_indices_inputs,\n       sparse_feature_values_inputs, &examples_));\n   TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(\n       worker_threads, num_examples, num_dense_features, weights,\n       dense_features_inputs, &examples_));\n   TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(\n       worker_threads, num_examples, num_sparse_features, num_dense_features,\n       &examples_));\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  if (example_labels.size() != num_examples) {\n    return errors::InvalidArgument(\"Expected \", num_examples,\n                                   \" example labels but got \",\n                                   example_labels.size());\n  }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-37672", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.SdcaOptimizerV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/sdca_internal.cc#L320-L353) does not check that the length of `example_labels` is the same as the number of examples. We have patched the issue in GitHub commit a4e138660270e7599793fa438cd7b2fc2ce215a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196790}
{"source": " GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n {\n \tu32 i, sceneT, odT, descIndex, size, size64;\n \tGF_InitialObjectDescriptor *iod;\n \tGF_SLConfig slc;\n \tGF_ISOSample *samp;\n \tBool remove_ocr;\n \tu8 *buffer;\n \tchar buf64[5000], sdpLine[5100];\n \n \n \tgf_isom_sdp_clean(file);\n \n \tif (bandwidth) {\n \t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n \t\tgf_isom_sdp_add_line(file, buf64);\n \t}\n     if (gf_sys_is_test_mode()) {\n         sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n     } else {\n         sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n     }\n \tgf_isom_sdp_add_line(file, buf64);\n \n \tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n \n \todT = sceneT = 0;\n \tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n \t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n \t\tswitch (gf_isom_get_media_type(file,i+1)) {\n \t\tcase GF_ISOM_MEDIA_OD:\n \t\t\todT = i+1;\n \t\t\tbreak;\n \t\tcase GF_ISOM_MEDIA_SCENE:\n \t\t\tsceneT = i+1;\n \t\t\tbreak;\n \t\t}\n \t}\n \tremove_ocr = 0;\n \tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n \t\tIOD_Profile = GF_SDP_IOD_ISMA;\n \t\tremove_ocr = 1;\n \t}\n \n \tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n \n \tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n \tif (!iod) return GF_NOT_SUPPORTED;\n \n \tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n \t\tGF_ESD *esd;\n \t\tBool is_ok = 1;\n \t\twhile (gf_list_count(iod->ESDescriptors)) {\n \t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n \t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n \t\t\tgf_list_rem(iod->ESDescriptors, 0);\n \t\t}\n \n \n \t\tif (odT) {\n \t\t\tesd = gf_isom_get_esd(file, odT, 1);\n \t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n \t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n \t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n \t\t\t\t\tInitSL_NULL(&slc);\n \t\t\t\t\tslc.predefined = 0;\n \t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n \t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n \t\t\t\t\tslc.OCRResolution = 1000;\n \t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n \t\t\t\t\tslc.startDTS = samp->DTS;\n \t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n \n \t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n \t\t\t\t\tbuf64[size64] = 0;\n \t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n \n \t\t\t\t\tif (esd->decoderConfig) {\n \t\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n \t\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n \t\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n \t\t\t\t\t}\n \t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n \t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n \t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n \t\t\t\t} else {\n \t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n \t\t\t\t\tis_ok = 0;\n \t\t\t\t}\n \t\t\t\tgf_isom_sample_del(&samp);\n \t\t\t}\n \t\t\tif (remove_ocr) esd->OCRESID = 0;\n \t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n \n \t\t\tgf_list_add(iod->ESDescriptors, esd);\n \t\t}\n \n \t\tesd = gf_isom_get_esd(file, sceneT, 1);\n \t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n \t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n \t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n// bug_start\n\n// bug_end\n \t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n \t\t\t\tslc.OCRResolution = 1000;\n \t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n \t\t\t\tslc.startDTS = samp->DTS;\n \t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n \t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n \t\t\t\tbuf64[size64] = 0;\n \t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n \n \t\t\t\tif (esd->decoderConfig) {\n \t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n \t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n \t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n \t\t\t\t}\n \t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n \t\t\t\tstrcpy(esd->URLString, sdpLine);\n \t\t\t} else {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n \t\t\t\tis_ok = 0;\n \t\t\t}\n \t\t\tgf_isom_sample_del(&samp);\n \t\t}\n \t\tif (remove_ocr) esd->OCRESID = 0;\n \t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n \n \t\tgf_list_add(iod->ESDescriptors, esd);\n \n \t\tif (is_ok) {\n \t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n \t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n \t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n \t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n \t\t\t\tif (!esd) continue;\n \t\t\t\tif (esd->decoderConfig) {\n \t\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n \t\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n \t\t\t\t\t\telse has_v++;\n \t\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n \t\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n \t\t\t\t\t\telse has_a++;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n \t\t\t}\n \t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n \t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n \t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n \t\t\t}\n \t\t}\n \t}\n \n \tbuffer = NULL;\n \tsize = 0;\n \tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n \tgf_odf_desc_del((GF_Descriptor *)iod);\n \n \tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n \tbuf64[size64] = 0;\n \tgf_free(buffer);\n \n \tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n \tgf_isom_sdp_add_line(file, sdpLine);\n \n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\t\t\tInitSL_NULL(&slc);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-40567", "cve_desc": "Segmentation fault vulnerability exists in Gpac through 1.0.1 via the gf_odf_size_descriptor function in desc_private.c when using mp4box, which causes a denial of service.", "project": "gpac", "idx": 196801}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& val = ctx->input(0);\n// bug_start\n    int64 id = ctx->session_state()->GetNewId();\n// bug_end\n     TensorStore::TensorAndKey tk{val, id, requested_device()};\n     OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n \n     Tensor* handle = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n     if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n       ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n           ctx, SessionState::kTensorHandleResourceTypeName,\n           tk.GetHandle(name()));\n       resource_handle.set_maybe_type_name(\n           SessionState::kTensorHandleResourceTypeName);\n       handle->scalar<ResourceHandle>()() = resource_handle;\n     } else {\n       handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n     }\n   }\n \n", "target": "// fix_start\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));\n    int64 id = session_state->GetNewId();\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-15204", "cve_desc": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.", "project": "tensorflow", "idx": 196829}
{"source": " Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n// bug_start\n// bug_end\n   auto rank = c->Dim(c->input(0), 1);\n   auto nvals = c->UnknownDim();\n   c->set_output(0, c->Matrix(nvals, rank));\n   c->set_output(1, c->Vector(nvals));\n   c->set_output(2, c->Vector(rank));\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-41210", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196834}
{"source": " inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n   static char id[32];\n   bool selectedRow=(i>=sel1.y && i<=sel2.y);\n   ImGui::TableNextRow(0,lineHeight);\n   ImGui::TableNextColumn();\n   float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n   if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n     return;\n   }\n   if (ord<0 || ord>=e->song.ordersLen) {\n     return;\n   }\n   if (i<0 || i>=e->song.patLen) {\n     return;\n   }\n   bool isPushing=false;\n   ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n   ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n   ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n   if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n     activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n     inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n     rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n   } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n     activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n     inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n     rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n   }\n   if (settings.overflowHighlight) {\n     if (edit && cursor.y==i) {\n       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n     } else if (isPlaying && oldRow==i) {\n       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n     } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n     } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n     }\n   } else {\n     isPushing=true;\n     if (edit && cursor.y==i) {\n       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n     } else if (isPlaying && oldRow==i) {\n       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n     } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n     } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n     } else {\n       isPushing=false;\n     }\n   }\n   if (settings.patRowsBase==1) {\n     ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n   } else {\n     ImGui::TextColored(rowIndexColor,\"%3d \",i);\n   }\n   for (int j=0; j<chans; j++) {\n     if (!e->song.chanShow[j]) {\n       patChanX[j]=ImGui::GetCursorPosX();\n       continue;\n     }\n     int chanVolMax=e->getMaxVolumeChan(j);\n     if (chanVolMax<1) chanVolMax=1;\n     const DivPattern* pat=patCache[j];\n     ImGui::TableNextColumn();\n     patChanX[j]=ImGui::GetCursorPosX();\n \n     int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n     int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n     int j32=j*32;\n     bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n     bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n     bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n     bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n     bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n     bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n \n     sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n     if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n       ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n     } else {\n       ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n     }\n     if (cursorNote) {\n       ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n       ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n       ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n       ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n       demandX=ImGui::GetCursorPosX();\n       ImGui::PopStyleColor(3);\n     } else {\n       if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n       ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n       if (selectedNote) ImGui::PopStyleColor();\n     }\n     if (ImGui::IsItemClicked()) {\n       startSelection(j,0,i);\n     }\n     if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n       updateSelection(j,0,i);\n     }\n     ImGui::PopStyleColor();\n \n     if (!e->song.chanCollapse[j]) {\n       if (pat->data[i][2]==-1) {\n         ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n         sprintf(id,\"..##PI_%d_%d\",i,j);\n       } else {\n         if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n           ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n         } else {\n           DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n           if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n           } else {\n             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n           }\n         }\n         sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n       }\n       ImGui::SameLine(0.0f,0.0f);\n       if (cursorIns) {\n         ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n         ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n         ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n         ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n         demandX=ImGui::GetCursorPosX();\n         ImGui::PopStyleColor(3);\n       } else {\n         if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n         ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n         if (selectedIns) ImGui::PopStyleColor();\n       }\n       if (ImGui::IsItemClicked()) {\n         startSelection(j,1,i);\n       }\n       if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n         updateSelection(j,1,i);\n       }\n       ImGui::PopStyleColor();\n \n       if (pat->data[i][3]==-1) {\n         sprintf(id,\"..##PV_%d_%d\",i,j);\n         ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n       } else {\n         int volColor=(pat->data[i][3]*127)/chanVolMax;\n         if (volColor>127) volColor=127;\n         if (volColor<0) volColor=0;\n         sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n         ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n       }\n       ImGui::SameLine(0.0f,0.0f);\n       if (cursorVol) {\n         ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n         ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n         ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n         ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n         demandX=ImGui::GetCursorPosX();\n         ImGui::PopStyleColor(3);\n       } else {\n         if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n         ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n         if (selectedVol) ImGui::PopStyleColor();\n       }\n       if (ImGui::IsItemClicked()) {\n         startSelection(j,2,i);\n       }\n       if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n         updateSelection(j,2,i);\n       }\n       ImGui::PopStyleColor();\n \n       for (int k=0; k<e->song.pat[j].effectRows; k++) {\n         int index=4+(k<<1);\n         bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n         bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n         bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n         bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n \n         if (pat->data[i][index]==-1) {\n           sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n           ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n         } else {\n// bug_start\n          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n          if (pat->data[i][index]<0x10) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n          } else if (pat->data[i][index]<0x20) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x30) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n          } else if (pat->data[i][index]<0x48) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x90) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xa0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n          } else if (pat->data[i][index]<0xc0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xd0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n          } else if (pat->data[i][index]<0xe0) {\n// bug_end\n             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n           } else {\n// bug_start\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n// bug_end\n           }\n         }\n         ImGui::SameLine(0.0f,0.0f);\n         if (cursorEffect) {\n           ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n           ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n           ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n           ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n           demandX=ImGui::GetCursorPosX();\n           ImGui::PopStyleColor(3);\n         } else {\n           if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n           ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n           if (selectedEffect) ImGui::PopStyleColor();\n         }\n         if (ImGui::IsItemClicked()) {\n           startSelection(j,index-1,i);\n         }\n         if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n           updateSelection(j,index-1,i);\n         }\n \n         if (pat->data[i][index+1]==-1) {\n           sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n         } else {\n           sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n         }\n         ImGui::SameLine(0.0f,0.0f);\n         if (cursorEffectVal) {\n           ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n           ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n           ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n           ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n           demandX=ImGui::GetCursorPosX();\n           ImGui::PopStyleColor(3);\n         } else {\n           if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n           ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n           if (selectedEffectVal) ImGui::PopStyleColor();\n         }\n         if (ImGui::IsItemClicked()) {\n           startSelection(j,index,i);\n         }\n         if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n           updateSelection(j,index,i);\n         }\n         ImGui::PopStyleColor();\n       }\n     }\n   }\n   if (isPushing) {\n     ImGui::PopStyleColor();\n   }\n   ImGui::TableNextColumn();\n   patChanX[chans]=ImGui::GetCursorPosX();\n }\n \n", "target": "// fix_start\n          if (pat->data[i][index]>0xff) {\n            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n// fix_end\n// fix_start\n            const unsigned char data=pat->data[i][index];\n            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n            if (data<0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data<0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data<0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data<0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data<0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-1289", "cve_desc": "A denial of service vulnerability was found in tildearrow Furnace. It has been classified as problematic. This is due to an incomplete fix of CVE-2022-1211. It is possible to initiate the attack remotely but it requires user interaction. The issue got fixed with the patch 0eb02422d5161767e9983bdaa5c429762d3477ce.", "project": "furnace", "idx": 196841}
{"source": " TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n   auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n   OpData* data = reinterpret_cast<OpData*>(node->user_data);\n \n   const TfLiteTensor* input1;\n   TF_LITE_ENSURE_OK(context,\n                     GetInputSafe(context, node, kInputTensor1, &input1));\n   const TfLiteTensor* input2;\n   TF_LITE_ENSURE_OK(context,\n                     GetInputSafe(context, node, kInputTensor2, &input2));\n   TfLiteTensor* output;\n   TF_LITE_ENSURE_OK(context,\n                     GetOutputSafe(context, node, kOutputTensor, &output));\n \n// bug_start\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n// bug_end\n     EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n   } else if (output->type == kTfLiteUInt8) {\n// bug_start\n// bug_end\n     TF_LITE_ENSURE_OK(\n         context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                             input2, output));\n   } else {\n     context->ReportError(\n         context,\n         \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n         output->type);\n     return kTfLiteError;\n   }\n// bug_start\n// bug_end\n \n   return kTfLiteOk;\n }\n \n", "target": "// fix_start\n#define TF_LITE_CHECK_DIV_NON_ZERO(data_type)                       \\\n  const auto* input2_data = GetTensorData<data_type>(input2);       \\\n  const size_t input2_elements = input2->bytes / sizeof(data_type); \\\n  for (size_t i = 0; i < input2_elements; i++) {                    \\\n    TF_LITE_ENSURE(context, input2_data[i] != 0);                   \\\n  }\n\n  if (output->type == kTfLiteFloat32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    TF_LITE_CHECK_DIV_NON_ZERO(int32_t);\n// fix_end\n// fix_start\n    TF_LITE_CHECK_DIV_NON_ZERO(uint8_t);\n// fix_end\n// fix_start\n#undef TF_LITE_CHECK_DIV_NON_ZERO\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37683", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196846}
{"source": " GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n {\n \tunsigned int i;\n \tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n \n \tISOM_DECREASE_SIZE(ptr, 9)\n \tptr->long_ids = gf_bs_read_int(bs, 1);\n \tptr->long_offsets = gf_bs_read_int(bs, 1);\n \tptr->global_entries = gf_bs_read_int(bs, 1);\n \tptr->reserved = gf_bs_read_int(bs, 5);\n \tptr->time_scale = gf_bs_read_u32(bs);\n \n \tptr->entry_count = gf_bs_read_u32(bs);\n \tif (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)\n \t\treturn GF_ISOM_INVALID_FILE;\n \n \tfor (i=0; i<ptr->entry_count; i++) {\n \t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n \t\tif (!ae) return GF_OUT_OF_MEM;\n// bug_start\n// bug_end\n \n \t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\tae->time = gf_bs_read_u64(bs);\n \t\tif (ptr->long_offsets) {\n \t\t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\t\tae->offset = gf_bs_read_u64(bs);\n \t\t} else {\n \t\t\tISOM_DECREASE_SIZE(ptr, 4)\n \t\t\tae->offset = gf_bs_read_u32(bs);\n \t\t}\n// bug_start\n\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n// bug_end\n \t}\n \n \tif (ptr->global_entries) {\n \t\tISOM_DECREASE_SIZE(ptr, 4)\n \t\tptr->global_entry_count = gf_bs_read_u32(bs);\n \t\tfor (i=0; i<ptr->global_entry_count; i++) {\n \t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n \t\t\tif (!ae) return GF_OUT_OF_MEM;\n// bug_start\n// bug_end\n \t\t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\t\tae->time = gf_bs_read_u64(bs);\n \t\t\tif (ptr->long_ids) {\n \t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\t\t\tae->segment = gf_bs_read_u32(bs);\n \t\t\t\tae->fragment = gf_bs_read_u32(bs);\n \t\t\t} else {\n \t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n \t\t\t\tae->segment = gf_bs_read_u16(bs);\n \t\t\t\tae->fragment = gf_bs_read_u16(bs);\n \t\t\t}\n \t\t\tif (ptr->long_offsets) {\n \t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n \t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n \t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n \t\t\t} else {\n \t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n \t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n \t\t\t}\n// bug_start\n\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n// bug_end\n \t\t}\n \t}\n \n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-33361", "cve_desc": "Memory leak in the afra_box_read function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.", "project": "gpac", "idx": 196860}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(kInputTensorIndex);\n     const Tensor& input_min = ctx->input(kInputMinIndex);\n     const Tensor& input_max = ctx->input(kInputMaxIndex);\n \n     const size_t depth = input_max.NumElements();\n     OP_REQUIRES(\n         ctx, input_min.dim_size(0) == depth,\n         errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                 depth, \" was \", input_min.dim_size(0)));\n     OP_REQUIRES(\n         ctx, input_max.dim_size(0) == depth,\n         errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                 depth, \" was \", input_max.dim_size(0)));\n// bug_start\n// bug_end\n \n     const float* input_min_data = input_min.flat<float>().data();\n     const float* input_max_data = input_max.flat<float>().data();\n     std::vector<float> ranges(depth);\n     bool is_non_negative = true;\n     Eigen::array<int, 2> shuffling({1, 0});\n     auto input_matrix = input.flat_inner_dims<qint32>();\n \n     auto transposed_input = input_matrix.shuffle(shuffling);\n \n     float out_min_max = std::numeric_limits<float>::min();\n \n #ifdef ENABLE_ONEDNN_OPENMP\n #ifdef _MSC_VER\n #pragma omp parallel for\n #else\n #pragma omp parallel for reduction(max : out_min_max)\n #endif\n #endif\n     for (int64_t i = 0; i < depth; ++i) {\n       Eigen::Tensor<qint32, 0, Eigen::RowMajor> min =\n           transposed_input.chip<0>(i).minimum();\n       Eigen::Tensor<qint32, 0, Eigen::RowMajor> max =\n           transposed_input.chip<0>(i).maximum();\n       const int32_t min_per_channel = min();\n       const int32_t max_per_channel = max();\n       const int32_t abs_max =\n           std::max(std::abs(min_per_channel), std::abs(max_per_channel));\n       float scale =\n           std::max(std::abs(input_min_data[i]), std::abs(input_max_data[i]));\n       ranges[i] =\n           scale * static_cast<float>(abs_max) / static_cast<float>(1L << 31);\n       if (min_per_channel < 0) is_non_negative = false;\n \n       out_min_max = std::max(out_min_max, ranges[i]);\n     }\n \n \n     if (out_min_max > clip_value_max_) out_min_max = clip_value_max_;\n \n     Tensor* output_min = nullptr;\n     Tensor* output_max = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n     output_min->flat<float>()(0) = is_non_negative ? 0.0f : -out_min_max;\n     output_max->flat<float>()(0) = out_min_max;\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        ctx, input_min.NumElements() == depth,\n        errors::InvalidArgument(\"input_min must have the same number of \"\n                                \"elements as input_max, got \",\n                                input_min.NumElements(), \" and \", depth));\n    OP_REQUIRES(ctx, input.NumElements() > 0,\n                errors::InvalidArgument(\"input must not be empty\"));\n    OP_REQUIRES(ctx, input.dims() == 4,\n                errors::InvalidArgument(\"input must be in NHWC format\"));\n    OP_REQUIRES(\n        ctx, input.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input must have same number of channels as length of input_min: \",\n            input.dim_size(3), \" vs \", depth));\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2021-37665", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196885}
{"source": " int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n \t\t pgpDigParams * ret)\n {\n     const uint8_t *p = pkts;\n     const uint8_t *pend = pkts + pktlen;\n     pgpDigParams digp = NULL;\n// bug_start\n    struct pgpPkt pkt;\n// bug_end\n     int rc = -1;\n// bug_start\n// bug_end\n \n     while (p < pend) {\n// bug_start\n\tif (decodePkt(p, (pend - p), &pkt))\n// bug_end\n \t    break;\n \n \tif (digp == NULL) {\n// bug_start\n\t    if (pkttype && pkt.tag != pkttype) {\n// bug_end\n \t\tbreak;\n \t    } else {\n// bug_start\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n// bug_end\n \t    }\n \t}\n \n// bug_start\n\tif (pgpPrtPkt(&pkt, digp))\n// bug_end\n \t    break;\n \n// bug_start\n\tp += (pkt.body - pkt.head) + pkt.blen;\n// bug_end\n \tif (pkttype == PGPTAG_SIGNATURE)\n \t    break;\n// bug_start\n// bug_end\n     }\n \n// bug_start\n    rc = (digp && (p == pend)) ? 0 : -1;\n// bug_end\n \n// bug_start\n// bug_end\n     if (ret && rc == 0) {\n \t*ret = digp;\n     } else {\n \tpgpDigParamsFree(digp);\n     }\n     return rc;\n }\n \n", "target": "// fix_start\n    pgpDigParams selfsig = NULL;\n    int i = 0;\n    int alloced = 16;\n    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));\n// fix_end\n// fix_start\n    int expect = 0;\n    int prevtag = 0;\n// fix_end\n// fix_start\n\tstruct pgpPkt *pkt = &all[i];\n\tif (decodePkt(p, (pend - p), pkt))\n// fix_end\n// fix_start\n\t    if (pkttype && pkt->tag != pkttype) {\n// fix_end\n// fix_start\n\t\tdigp = pgpDigParamsNew(pkt->tag);\n// fix_end\n// fix_start\n\tif (expect) {\n\t    if (pkt->tag != expect)\n\t\tbreak;\n\t    selfsig = pgpDigParamsNew(pkt->tag);\n\t}\n\n\tif (pgpPrtPkt(pkt, selfsig ? selfsig : digp))\n// fix_end\n// fix_start\n\tif (selfsig) {\n\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {\n\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)\n\t\t    break;\n\t    }\n\n\t    int xx = pgpVerifySelf(digp, selfsig, all, i);\n\n\t    selfsig = pgpDigParamsFree(selfsig);\n\t    if (xx)\n\t\tbreak;\n\t    expect = 0;\n\t}\n\n\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)\n\t    expect = PGPTAG_SIGNATURE;\n\tprevtag = pkt->tag;\n\n\ti++;\n\tp += (pkt->body - pkt->head) + pkt->blen;\n// fix_end\n// fix_start\n\n\tif (alloced <= i) {\n\t    alloced *= 2;\n\t    all = xrealloc(all, alloced * sizeof(*all));\n\t}\n// fix_end\n// fix_start\n    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;\n// fix_end\n// fix_start\n    free(all);\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2021-3521", "cve_desc": "There is a flaw in RPM's signature functionality. OpenPGP subkeys are associated with a primary key via a \"binding signature.\" RPM does not check the binding signature of subkeys prior to importing them. If an attacker is able to add or socially engineer another party to add a malicious subkey to a legitimate public key, RPM could wrongly trust a malicious signature. The greatest impact of this flaw is to data integrity. To exploit this flaw, an attacker must either compromise an RPM repository or convince an administrator to install an untrusted RPM or public key. It is strongly recommended to only use RPMs and public keys from trusted sources.", "project": "rpm", "idx": 196889}
{"source": " void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                     uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                     unsigned hash_length) {\n   int rc;\n \n   if (ca_cert_ != nullptr) {\n     rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n     RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                    fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n \n     rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n   }\n \n   for (const auto& hash : verify_certificate_hash_list_) {\n     rc = EVP_DigestUpdate(md.get(), hash.data(),\n                           hash.size() *\n                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n   }\n \n   for (const auto& hash : verify_certificate_spki_list_) {\n     rc = EVP_DigestUpdate(md.get(), hash.data(),\n                           hash.size() *\n                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n   }\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n\n  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));\n  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n  if (config_ != nullptr) {\n    for (const auto& matcher : config_->subjectAltNameMatchers()) {\n      size_t hash = MessageUtil::hash(matcher);\n      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    const std::string& crl = config_->certificateRevocationList();\n    if (!crl.empty()) {\n      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    bool allow_expired = config_->allowExpiredCertificate();\n    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto trust_chain_verification = config_->trustChainVerification();\n    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();\n    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2022-21654", "cve_desc": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade.", "project": "envoy", "idx": 196893}
{"source": " Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n {\n \tDoQuickSanityCheck();\n \tModularArithmetic modn(m_n);\n \tInteger r, rInv;\n// bug_start\n// bug_end\n \tdo {\n \t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n// bug_start\n// bug_end\n \t\trInv = modn.MultiplicativeInverse(r);\n \t} while (rInv.IsZero());\n// bug_start\n// bug_end\n \tInteger re = modn.Square(r);\n \tre = modn.Multiply(re, x);\n \n \tInteger cp=re%m_p, cq=re%m_q;\n \tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n \t{\n \t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n \t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n \t}\n \n \t#pragma omp parallel\n \t\t#pragma omp sections\n \t\t{\n \t\t\t#pragma omp section\n \t\t\t\tcp = ModularSquareRoot(cp, m_p);\n \t\t\t#pragma omp section\n \t\t\t\tcq = ModularSquareRoot(cq, m_q);\n \t\t}\n \n \tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n \ty = modn.Multiply(y, rInv);\n \ty = STDMIN(y, m_n-y);\n \tif (ApplyFunction(y) != x)\n \t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n \treturn y;\n }\n \n", "target": "// fix_start\n\n// fix_end\n// fix_start\n\t\tr = modn.Square(r);\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "cve": "CVE-2015-2141", "cve_desc": "The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack.", "project": "cryptopp", "idx": 196894}
{"source": " Status DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,\n                        CodecInOut* io) {\n   Reader r;\n   unsigned int id, i, j, w, h, w0, h0, x0, y0;\n   unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;\n   unsigned char sig[8];\n   png_structp png_ptr;\n   png_infop info_ptr;\n   CHUNK chunk;\n   CHUNK chunkIHDR;\n   std::vector<CHUNK> chunksInfo;\n   bool isAnimated = false;\n   bool skipFirst = false;\n   bool hasInfo = false;\n   bool all_dispose_bg = true;\n   APNGFrame frameRaw = {};\n \n   r = {bytes.data(), bytes.data() + bytes.size()};\n   unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n   if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {\n     return false;\n   }\n   id = read_chunk(&r, &chunkIHDR);\n \n   io->frames.clear();\n   io->dec_pixels = 0;\n   io->metadata.m.SetUintSamples(8);\n   io->metadata.m.SetAlphaBits(8);\n   io->metadata.m.color_encoding =\n       ColorEncoding::SRGB();\n   (void)io->dec_hints.Foreach(\n       [](const std::string& key, const std::string& ) {\n         JXL_WARNING(\"APNG decoder ignoring %s hint\", key.c_str());\n         return true;\n       });\n \n   bool errorstate = true;\n   if (id == kId_IHDR && chunkIHDR.size == 25) {\n     w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n     h0 = h = png_get_uint_32(chunkIHDR.p + 12);\n \n     if (w > cMaxPNGSize || h > cMaxPNGSize) {\n       return false;\n     }\n \n     x0 = 0;\n     y0 = 0;\n     delay_num = 1;\n     delay_den = 10;\n     dop = 0;\n     bop = 0;\n     rowbytes = w * 4;\n     imagesize = h * rowbytes;\n \n     frameRaw.p = new unsigned char[imagesize];\n     frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];\n     for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;\n \n     if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                           chunkIHDR, chunksInfo)) {\n       bool last_base_was_none = true;\n       while (!r.Eof()) {\n         id = read_chunk(&r, &chunk);\n         if (!id) break;\n         JXL_ASSERT(chunk.p != nullptr);\n \n         if (id == kId_acTL && !hasInfo && !isAnimated) {\n           isAnimated = true;\n           skipFirst = true;\n           io->metadata.m.have_animation = true;\n           io->metadata.m.animation.tps_numerator = 1000;\n         } else if (id == kId_IEND ||\n                    (id == kId_fcTL && (!hasInfo || isAnimated))) {\n           if (hasInfo) {\n             if (!processing_finish(png_ptr, info_ptr)) {\n               ImageBundle bundle(&io->metadata.m);\n               bundle.duration = delay_num * 1000 / delay_den;\n               bundle.origin.x0 = x0;\n               bundle.origin.y0 = y0;\n               if (last_base_was_none && !all_dispose_bg &&\n                   (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {\n                 return JXL_FAILURE(\n                     \"APNG with dispose-to-0 is not supported for non-full or \"\n                     \"blended frames\");\n               }\n               switch (dop) {\n                 case 0:\n                   bundle.use_for_next_frame = true;\n                   last_base_was_none = false;\n                   all_dispose_bg = false;\n                   break;\n                 case 2:\n                   bundle.use_for_next_frame = false;\n                   all_dispose_bg = false;\n                   break;\n                 default:\n                   bundle.use_for_next_frame = false;\n                   last_base_was_none = true;\n               }\n               bundle.blend = bop != 0;\n               io->dec_pixels += w0 * h0;\n \n               Image3F sub_frame(w0, h0);\n               ImageF sub_frame_alpha(w0, h0);\n               for (size_t y = 0; y < h0; ++y) {\n                 float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);\n                 float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);\n                 float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);\n                 float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);\n                 uint8_t* const f = frameRaw.rows[y];\n                 for (size_t x = 0; x < w0; ++x) {\n                   if (f[4 * x + 3] == 0) {\n                     row_alpha[x] = 0;\n                     row_r[x] = 0;\n                     row_g[x] = 0;\n                     row_b[x] = 0;\n                     continue;\n                   }\n                   row_r[x] = f[4 * x + 0] * (1.f / 255);\n                   row_g[x] = f[4 * x + 1] * (1.f / 255);\n                   row_b[x] = f[4 * x + 2] * (1.f / 255);\n                   row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n                 }\n               }\n               bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());\n               bundle.SetAlpha(std::move(sub_frame_alpha),\n                               false);\n               io->frames.push_back(std::move(bundle));\n             } else {\n               delete[] chunk.p;\n               break;\n             }\n           }\n \n           if (id == kId_IEND) {\n             errorstate = false;\n             break;\n           }\n           w0 = png_get_uint_32(chunk.p + 12);\n           h0 = png_get_uint_32(chunk.p + 16);\n           x0 = png_get_uint_32(chunk.p + 20);\n           y0 = png_get_uint_32(chunk.p + 24);\n           delay_num = png_get_uint_16(chunk.p + 28);\n           delay_den = png_get_uint_16(chunk.p + 30);\n           dop = chunk.p[32];\n           bop = chunk.p[33];\n \n// bug_start\n// bug_end\n           if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n               y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n               bop > 1) {\n             delete[] chunk.p;\n             break;\n           }\n \n           if (hasInfo) {\n             memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n             if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                                  chunkIHDR, chunksInfo)) {\n               delete[] chunk.p;\n               break;\n             }\n           } else\n             skipFirst = false;\n \n           if (io->frames.size() == (skipFirst ? 1 : 0)) {\n             bop = 0;\n             if (dop == 2) dop = 1;\n           }\n         } else if (id == kId_IDAT) {\n           hasInfo = true;\n           if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n             delete[] chunk.p;\n             break;\n           }\n         } else if (id == kId_fdAT && isAnimated) {\n           png_save_uint_32(chunk.p + 4, chunk.size - 16);\n           memcpy(chunk.p + 8, \"IDAT\", 4);\n           if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n             delete[] chunk.p;\n             break;\n           }\n         } else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                    !isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {\n           delete[] chunk.p;\n           break;\n         } else if (!hasInfo) {\n           if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n             delete[] chunk.p;\n             break;\n           }\n           chunksInfo.push_back(chunk);\n           continue;\n         }\n         delete[] chunk.p;\n       }\n     }\n     delete[] frameRaw.rows;\n     delete[] frameRaw.p;\n   }\n \n   for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;\n \n   chunksInfo.clear();\n   delete[] chunkIHDR.p;\n \n   if (errorstate) return false;\n   SetIntensityTarget(io);\n   return true;\n }\n \n", "target": "// fix_start\n          if (!delay_den) delay_den = 100;\n\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-36692", "cve_desc": "libjxl v0.3.7 is affected by a Divide By Zero in issue in lib/extras/codec_apng.cc jxl::DecodeImageAPNG(). When encoding a malicous APNG file using cjxl, an attacker can trigger a denial of service.", "project": "libjxl", "idx": 196993}
{"source": " GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)\n {\n \tu32 i, trackCount;\n \tTrackWriter *writer;\n \tGF_TrackBox *trak;\n \tGF_ISOFile *movie = mw->movie;\n \n \tmw->total_samples = mw->nb_done = 0;\n \tif (!movie->moov) return GF_OK;\n \n \ttrackCount = gf_list_count(movie->moov->trackList);\n \tfor (i = 0; i < trackCount; i++) {\n// bug_start\n// bug_end\n \t\ttrak = gf_isom_get_track(movie->moov, i+1);\n// bug_start\n// bug_end\n \n \t\tGF_SAFEALLOC(writer, TrackWriter);\n \t\tif (!writer) goto exit;\n \t\twriter->sampleNumber = 1;\n \t\twriter->mdia = trak->Media;\n \t\twriter->stbl = trak->Media->information->sampleTable;\n \t\twriter->timeScale = trak->Media->mediaHeader->timeScale;\n \t\twriter->all_dref_mode = Media_SelfContainedType(writer->mdia);\n \n \t\tif (trak->sample_encryption)\n \t\t\twriter->prevent_dispatch = GF_TRUE;\n \n \t\twriter->isDone = 0;\n \t\twriter->DTSprev = 0;\n \t\twriter->chunkDur = 0;\n \t\twriter->chunkSize = 0;\n \t\twriter->constant_size = writer->constant_dur = 0;\n \t\tif (writer->stbl->SampleSize->sampleSize)\n \t\t\twriter->constant_size = writer->stbl->SampleSize->sampleSize;\n \t\tif (writer->stbl->TimeToSample->nb_entries==1) {\n \t\t\twriter->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;\n \t\t\tif (writer->constant_dur>1) writer->constant_dur = 0;\n \t\t}\n \t\tif (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))\n \t\t\twriter->constant_size = writer->constant_dur = 0;\n \n \t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n \t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n \t\tif (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n \t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n \t\t} else {\n \t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n \t\t}\n \t\tif (!writer->stco) return GF_OUT_OF_MEM;\n \t\tif (interleaving) writer->stbl->MaxSamplePerChunk = 0;\n \t\tif (Media_IsSelfContained(writer->mdia, 1))\n \t\t\tmw->total_samples += writer->stbl->SampleSize->sampleCount;\n \t\tif (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {\n \t\t\tgf_list_add(writers, writer);\n \t\t} else {\n \t\t\tif (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {\n \t\t\t\tgf_list_add(writers, writer);\n \t\t\t} else {\n \t\t\t\tgf_list_insert(writers, writer, 0);\n \t\t\t}\n \t\t}\n \t\tif (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {\n \t\t\tgf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);\n \t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = NULL;\n \t\t}\n \t}\n \treturn GF_OK;\n \n exit:\n \tCleanWriters(writers);\n \treturn GF_OUT_OF_MEM;\n }\n \n", "target": "// fix_start\n\t\tGF_SampleTableBox *stbl;\n// fix_end\n// fix_start\n\n\t\tstbl = (trak->Media && trak->Media->information) ? trak->Media->information->sampleTable : NULL;\n\t\tif (!stbl || !stbl->SampleSize || !stbl->ChunkOffset || !stbl->SampleToChunk) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-35981", "cve_desc": "An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is an invalid pointer dereference in the function SetupWriters() in isomedia/isom_store.c.", "project": "gpac", "idx": 197015}
{"source": "// bug_start\nint HttpFileImpl::save(const std::string &path) const\n// bug_end\n {\n// bug_start\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsPath(utils::toNativePath(path));\n    if (!fsPath.is_absolute() &&\n        (!fsPath.has_parent_path() ||\n         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n// bug_end\n     {\n         filesystem::path fsUploadPath(utils::toNativePath(\n             HttpAppFrameworkImpl::instance().getUploadPath()));\n// bug_start\n        fsPath = fsUploadPath / fsPath;\n// bug_end\n     }\n// bug_start\n    filesystem::path fsFileName(utils::toNativePath(fileName_));\n    if (!filesystem::exists(fsPath))\n// bug_end\n     {\n// bug_start\n        LOG_TRACE << \"create path:\" << fsPath;\n// bug_end\n         drogon::error_code err;\n// bug_start\n        filesystem::create_directories(fsPath, err);\n// bug_end\n         if (err)\n         {\n             LOG_SYSERR;\n             return -1;\n         }\n     }\n// bug_start\n    return saveTo(fsPath / fsFileName);\n// bug_end\n }\n \n", "target": "// fix_start\nint HttpFileImpl::saveAs(const std::string &fileName) const\n// fix_end\n// fix_start\n    assert(!fileName.empty());\n    filesystem::path fsFileName(utils::toNativePath(fileName));\n    if (!fsFileName.is_absolute() && (!fsFileName.has_parent_path() ||\n                                      (fsFileName.begin()->string() != \".\" &&\n                                       fsFileName.begin()->string() != \"..\")))\n// fix_end\n// fix_start\n        fsFileName = fsUploadPath / fsFileName;\n// fix_end\n// fix_start\n    if (fsFileName.has_parent_path() &&\n        !filesystem::exists(fsFileName.parent_path()))\n// fix_end\n// fix_start\n        LOG_TRACE << \"create path:\" << fsFileName.parent_path();\n// fix_end\n// fix_start\n        filesystem::create_directories(fsFileName.parent_path(), err);\n// fix_end\n// fix_start\n    return saveTo(fsFileName);\n// fix_end\n", "cwe": "CWE-552", "cwe_name": "Files or Directories Accessible to External Parties", "cve": "CVE-2022-25297", "cve_desc": "This affects the package drogonframework/drogon before 1.7.5. The unsafe handling of file names during upload using HttpFile::save() method may enable attackers to write files to arbitrary locations outside the designated target folder.", "project": "drogon", "idx": 197057}
{"source": " inline void BinaryBroadcastFiveFold(const ArithmeticParams& unswitched_params,\n                                     const RuntimeShape& unswitched_input1_shape,\n                                     const T* unswitched_input1_data,\n                                     const RuntimeShape& unswitched_input2_shape,\n                                     const T* unswitched_input2_data,\n                                     const RuntimeShape& output_shape,\n                                     T* output_data, ElementwiseF elementwise_f,\n                                     ScalarBroadcastF scalar_broadcast_f) {\n   ArithmeticParams switched_params = unswitched_params;\n   switched_params.input1_offset = unswitched_params.input2_offset;\n   switched_params.input1_multiplier = unswitched_params.input2_multiplier;\n   switched_params.input1_shift = unswitched_params.input2_shift;\n   switched_params.input2_offset = unswitched_params.input1_offset;\n   switched_params.input2_multiplier = unswitched_params.input1_multiplier;\n   switched_params.input2_shift = unswitched_params.input1_shift;\n \n   const bool use_unswitched =\n       unswitched_params.broadcast_category ==\n       tflite::BroadcastableOpCategory::kFirstInputBroadcastsFast;\n \n   const ArithmeticParams& params =\n       use_unswitched ? unswitched_params : switched_params;\n   const T* input1_data =\n       use_unswitched ? unswitched_input1_data : unswitched_input2_data;\n   const T* input2_data =\n       use_unswitched ? unswitched_input2_data : unswitched_input1_data;\n \n   T* output_data_ptr = output_data;\n   const T* input1_data_ptr = input1_data;\n   const T* input2_data_reset = input2_data;\n   int y0 = params.broadcast_shape[0];\n   int y1 = params.broadcast_shape[1];\n   int y2 = params.broadcast_shape[2];\n   int y3 = params.broadcast_shape[3];\n   int y4 = params.broadcast_shape[4];\n   if (y4 > 1) {\n     for (int i0 = 0; i0 < y0; ++i0) {\n       const T* input2_data_ptr = nullptr;\n       for (int i1 = 0; i1 < y1; ++i1) {\n         input2_data_ptr = input2_data_reset;\n         for (int i2 = 0; i2 < y2; ++i2) {\n           for (int i3 = 0; i3 < y3; ++i3) {\n             elementwise_f(y4, params, input1_data_ptr, input2_data_ptr,\n                           output_data_ptr);\n             input2_data_ptr += y4;\n             output_data_ptr += y4;\n           }\n           input1_data_ptr += y4;\n         }\n       }\n       input2_data_reset = input2_data_ptr;\n     }\n// bug_start\n  } else {\n// bug_end\n     for (int i0 = 0; i0 < y0; ++i0) {\n       const T* input2_data_ptr = nullptr;\n       for (int i1 = 0; i1 < y1; ++i1) {\n         input2_data_ptr = input2_data_reset;\n         for (int i2 = 0; i2 < y2; ++i2) {\n           scalar_broadcast_f(y3, params, *input1_data_ptr, input2_data_ptr,\n                              output_data_ptr);\n           input2_data_ptr += y3;\n           output_data_ptr += y3;\n           input1_data_ptr += 1;\n         }\n       }\n       input2_data_reset = input2_data_ptr;\n     }\n   }\n }\n \n", "target": "// fix_start\n  } else if (input1_data_ptr != nullptr) {\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37688", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L268-L285) unconditionally dereferences a pointer. We have patched the issue in GitHub commit 15691e456c7dc9bd6be203b09765b063bf4a380c. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197095}
{"source": " static int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,\n                        const std::vector<tinyexr::tinyexr_uint64> &offsets,\n                        const unsigned char *head, const size_t size,\n                        std::string *err) {\n   int num_channels = exr_header->num_channels;\n \n   int num_scanline_blocks = 1;\n   if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n     num_scanline_blocks = 16;\n   } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n     num_scanline_blocks = 32;\n   } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n     num_scanline_blocks = 16;\n   }\n \n   int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n   int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n \n   if ((data_width < 0) || (data_height < 0)) {\n     if (err) {\n       std::stringstream ss;\n       ss << \"Invalid data width or data height: \" << data_width << \", \"\n          << data_height << std::endl;\n       (*err) += ss.str();\n     }\n     return TINYEXR_ERROR_INVALID_DATA;\n   }\n \n   {\n     const int threshold = 1024 * 8192;\n     if ((data_width > threshold) || (data_height > threshold)) {\n       if (err) {\n         std::stringstream ss;\n         ss << \"data_with or data_height too large. data_width: \" << data_width\n            << \", \"\n            << \"data_height = \" << data_height << std::endl;\n         (*err) += ss.str();\n       }\n       return TINYEXR_ERROR_INVALID_DATA;\n     }\n   }\n \n   size_t num_blocks = offsets.size();\n \n   std::vector<size_t> channel_offset_list;\n   int pixel_data_size = 0;\n   size_t channel_offset = 0;\n   if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,\n                                      &channel_offset, num_channels,\n                                      exr_header->channels)) {\n     if (err) {\n       (*err) += \"Failed to compute channel layout.\\n\";\n     }\n     return TINYEXR_ERROR_INVALID_DATA;\n   }\n \n   bool invalid_data = false;\n \n   if (exr_header->tiled) {\n     if (exr_header->tile_size_x < 0) {\n       if (err) {\n         std::stringstream ss;\n         ss << \"Invalid tile size x : \" << exr_header->tile_size_x << \"\\n\";\n         (*err) += ss.str();\n       }\n       return TINYEXR_ERROR_INVALID_HEADER;\n     }\n \n     if (exr_header->tile_size_y < 0) {\n       if (err) {\n         std::stringstream ss;\n         ss << \"Invalid tile size y : \" << exr_header->tile_size_y << \"\\n\";\n         (*err) += ss.str();\n       }\n       return TINYEXR_ERROR_INVALID_HEADER;\n     }\n \n     size_t num_tiles = offsets.size();\n \n     exr_image->tiles = static_cast<EXRTile *>(\n         calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));\n \n     for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {\n       exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(\n           num_channels, exr_header->channels, exr_header->requested_pixel_types,\n           exr_header->tile_size_x, exr_header->tile_size_y);\n \n       if (offsets[tile_idx] + sizeof(int) * 5 > size) {\n         if (err) {\n           (*err) += \"Insufficient data size.\\n\";\n         }\n         return TINYEXR_ERROR_INVALID_DATA;\n       }\n \n       size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));\n       const unsigned char *data_ptr =\n           reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);\n \n       int tile_coordinates[4];\n       memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);\n       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));\n       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));\n       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));\n       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));\n \n       if (tile_coordinates[2] != 0) {\n         return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n       }\n       if (tile_coordinates[3] != 0) {\n         return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n       }\n \n       int data_len;\n       memcpy(&data_len, data_ptr + 16,\n              sizeof(int));\n       tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n \n       if (data_len < 4 || size_t(data_len) > data_size) {\n         if (err) {\n           (*err) += \"Insufficient data length.\\n\";\n         }\n         return TINYEXR_ERROR_INVALID_DATA;\n       }\n \n       data_ptr += 20;\n \n       tinyexr::DecodeTiledPixelData(\n           exr_image->tiles[tile_idx].images,\n           &(exr_image->tiles[tile_idx].width),\n           &(exr_image->tiles[tile_idx].height),\n           exr_header->requested_pixel_types, data_ptr,\n           static_cast<size_t>(data_len), exr_header->compression_type,\n           exr_header->line_order, data_width, data_height, tile_coordinates[0],\n           tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,\n           static_cast<size_t>(pixel_data_size),\n           static_cast<size_t>(exr_header->num_custom_attributes),\n           exr_header->custom_attributes,\n           static_cast<size_t>(exr_header->num_channels), exr_header->channels,\n           channel_offset_list);\n \n       exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];\n       exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];\n       exr_image->tiles[tile_idx].level_x = tile_coordinates[2];\n       exr_image->tiles[tile_idx].level_y = tile_coordinates[3];\n \n       exr_image->num_tiles = static_cast<int>(num_tiles);\n     }\n   } else {\n \n     size_t total_data_len =\n         size_t(data_width) * size_t(data_height) * size_t(num_channels);\n     const bool total_data_len_overflown = sizeof(void*) == 8 ? (total_data_len >= 0x4000000000) : false;\n     if ((total_data_len == 0) || total_data_len_overflown ) {\n       if (err) {\n         std::stringstream ss;\n         ss << \"Image data size is zero or too large: width = \" << data_width\n            << \", height = \" << data_height << \", channels = \" << num_channels\n            << std::endl;\n         (*err) += ss.str();\n       }\n       return TINYEXR_ERROR_INVALID_DATA;\n     }\n \n     exr_image->images = tinyexr::AllocateImage(\n         num_channels, exr_header->channels, exr_header->requested_pixel_types,\n         data_width, data_height);\n \n #ifdef _OPENMP\n #pragma omp parallel for\n #endif\n     for (int y = 0; y < static_cast<int>(num_blocks); y++) {\n       size_t y_idx = static_cast<size_t>(y);\n \n       if (offsets[y_idx] + sizeof(int) * 2 > size) {\n         invalid_data = true;\n       } else {\n         size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));\n         const unsigned char *data_ptr =\n             reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);\n \n         int line_no;\n         memcpy(&line_no, data_ptr, sizeof(int));\n         int data_len;\n         memcpy(&data_len, data_ptr + 4, sizeof(int));\n         tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n         tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n \n         if (size_t(data_len) > data_size) {\n// bug_start\n// bug_end\n           invalid_data = true;\n         } else if (data_len == 0) {\n           invalid_data = true;\n         } else {\n           int end_line_no = (std::min)(line_no + num_scanline_blocks,\n                                        (exr_header->data_window[3] + 1));\n \n           int num_lines = end_line_no - line_no;\n \n           if (num_lines <= 0) {\n             invalid_data = true;\n           } else {\n             data_ptr += 8;\n \n \n             tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]);\n             if (lno > std::numeric_limits<int>::max()) {\n               line_no = -1;\n             } else if (lno < -std::numeric_limits<int>::max()) {\n               line_no = -1;\n             } else {\n               line_no -= exr_header->data_window[1];\n             }\n \n             if (line_no < 0) {\n               invalid_data = true;\n             } else {\n               if (!tinyexr::DecodePixelData(\n                       exr_image->images, exr_header->requested_pixel_types,\n                       data_ptr, static_cast<size_t>(data_len),\n                       exr_header->compression_type, exr_header->line_order,\n                       data_width, data_height, data_width, y, line_no,\n                       num_lines, static_cast<size_t>(pixel_data_size),\n                       static_cast<size_t>(exr_header->num_custom_attributes),\n                       exr_header->custom_attributes,\n                       static_cast<size_t>(exr_header->num_channels),\n                       exr_header->channels, channel_offset_list)) {\n                 invalid_data = true;\n               }\n             }\n           }\n         }\n       }\n     }\n   }\n \n   if (invalid_data) {\n     if (err) {\n       std::stringstream ss;\n       (*err) += \"Invalid data found when decoding pixels.\\n\";\n     }\n     return TINYEXR_ERROR_INVALID_DATA;\n   }\n \n   {\n     for (int c = 0; c < exr_header->num_channels; c++) {\n       exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];\n     }\n   }\n \n   {\n     exr_image->num_channels = num_channels;\n \n     exr_image->width = data_width;\n     exr_image->height = data_height;\n   }\n \n   return TINYEXR_SUCCESS;\n }\n \n", "target": "// fix_start\n          invalid_data = true;\n\n        } else if ((line_no > (2 << 20)) || (line_no < -(2 << 20))) {\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2020-19490", "cve_desc": "tinyexr 0.9.5 has a integer overflow over-write in tinyexr::DecodePixelData in tinyexr.h, related to OpenEXR code.", "project": "tinyexr", "idx": 197111}
{"source": " gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n {\n   int idx;\n   int type = nint(tree->car);\n \n   switch (type) {\n   case NODE_GVAR:\n   case NODE_ARG:\n   case NODE_LVAR:\n   case NODE_IVAR:\n   case NODE_CVAR:\n   case NODE_CONST:\n   case NODE_NIL:\n   case NODE_MASGN:\n     if (rhs) {\n       codegen(s, rhs, VAL);\n       pop();\n       sp = cursp();\n     }\n     break;\n \n   case NODE_COLON2:\n   case NODE_CALL:\n   case NODE_SCALL:\n     break;\n \n   case NODE_NVAR:\n     codegen_error(s, \"Can't assign to numbered parameter\");\n     break;\n \n   default:\n     codegen_error(s, \"unknown lhs\");\n     break;\n   }\n \n   tree = tree->cdr;\n   switch (type) {\n   case NODE_GVAR:\n     gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n     break;\n   case NODE_ARG:\n   case NODE_LVAR:\n     idx = lv_idx(s, nsym(tree));\n     if (idx > 0) {\n       if (idx != sp) {\n         gen_move(s, idx, sp, val);\n       }\n       break;\n     }\n     else {\n       gen_setupvar(s, sp, nsym(tree));\n     }\n     break;\n   case NODE_IVAR:\n     gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n     break;\n   case NODE_CVAR:\n     gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n     break;\n   case NODE_CONST:\n     gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n     break;\n   case NODE_COLON2:\n     if (sp) {\n       gen_move(s, cursp(), sp, 0);\n     }\n     sp = cursp();\n     push();\n     codegen(s, tree->car, VAL);\n     if (rhs) {\n       codegen(s, rhs, VAL); pop();\n       gen_move(s, sp, cursp(), 0);\n     }\n     pop_n(2);\n     idx = new_sym(s, nsym(tree->cdr));\n     genop_2(s, OP_SETMCNST, sp, idx);\n     break;\n \n   case NODE_CALL:\n   case NODE_SCALL:\n     {\n       int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n       mrb_sym mid = nsym(tree->cdr->car);\n \n       top = cursp();\n       if (val || sp == cursp()) {\n         push();\n       }\n       call = cursp();\n       if (!tree->car) {\n         noself = 1;\n         push();\n       }\n       else {\n         codegen(s, tree->car, VAL);\n       }\n       if (safe) {\n         int recv = cursp()-1;\n         gen_move(s, cursp(), recv, 1);\n         skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n       }\n       tree = tree->cdr->cdr->car;\n       if (tree) {\n         if (tree->car) {\n           n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n           if (n < 0) {\n             n = 15;\n             push();\n           }\n         }\n         if (tree->cdr->car) {\n           if (n == 14) {\n             pop_n(n);\n             genop_2(s, OP_ARRAY, cursp(), n);\n             push();\n             n = 15;\n           }\n           gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n           if (n < 14) {\n             n++;\n           }\n           else {\n             pop_n(2);\n             genop_2(s, OP_ARYPUSH, cursp(), 1);\n           }\n           push();\n         }\n       }\n       if (rhs) {\n         codegen(s, rhs, VAL);\n         pop();\n       }\n       else {\n         gen_move(s, cursp(), sp, 0);\n       }\n       if (val) {\n         gen_move(s, top, cursp(), 1);\n       }\n// bug_start\n      if (n < 14) {\n// bug_end\n         n++;\n// bug_start\n// bug_end\n       }\n       else {\n         pop();\n         genop_2(s, OP_ARYPUSH, cursp(), 1);\n       }\n       s->sp = call;\n       if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n         genop_1(s, OP_SETIDX, cursp());\n       }\n       else {\n         genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n       }\n       if (safe) {\n         dispatch(s, skip);\n       }\n       s->sp = top;\n     }\n     break;\n \n   case NODE_MASGN:\n     gen_vmassignment(s, tree->car, sp, val);\n     break;\n \n   case NODE_NIL:\n     break;\n \n   default:\n     codegen_error(s, \"unknown lhs\");\n     break;\n   }\n   if (val) push();\n }\n \n", "target": "// fix_start\n      if (n < 15) {\n// fix_end\n// fix_start\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-0717", "cve_desc": "Out-of-bounds Read in GitHub repository mruby/mruby prior to 3.2.", "project": "mruby", "idx": 197128}
{"source": " ccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\n {\n \tstruct ccp_aes_engine *aes = &cmd->u.aes;\n \tstruct ccp_dm_workarea key, ctx, final_wa, tag;\n \tstruct ccp_data src, dst;\n \tstruct ccp_data aad;\n \tstruct ccp_op op;\n \tunsigned int dm_offset;\n \tunsigned int authsize;\n \tunsigned int jobid;\n \tunsigned int ilen;\n \tbool in_place = true;\n \t__be64 *final;\n \tint ret;\n \n \tstruct scatterlist *p_inp, sg_inp[2];\n \tstruct scatterlist *p_tag, sg_tag[2];\n \tstruct scatterlist *p_outp, sg_outp[2];\n \tstruct scatterlist *p_aad;\n \n \tif (!aes->iv)\n \t\treturn -EINVAL;\n \n \tif (!((aes->key_len == AES_KEYSIZE_128) ||\n \t\t(aes->key_len == AES_KEYSIZE_192) ||\n \t\t(aes->key_len == AES_KEYSIZE_256)))\n \t\treturn -EINVAL;\n \n \tif (!aes->key)\n \t\treturn -EINVAL;\n \n \tauthsize = aes->authsize ? aes->authsize : AES_BLOCK_SIZE;\n \tswitch (authsize) {\n \tcase 16:\n \tcase 15:\n \tcase 14:\n \tcase 13:\n \tcase 12:\n \tcase 8:\n \tcase 4:\n \t\tbreak;\n \tdefault:\n \t\treturn -EINVAL;\n \t}\n \n \tp_aad = aes->src;\n \tp_inp = scatterwalk_ffwd(sg_inp, aes->src, aes->aad_len);\n \tp_outp = scatterwalk_ffwd(sg_outp, aes->dst, aes->aad_len);\n \tif (aes->action == CCP_AES_ACTION_ENCRYPT) {\n \t\tilen = aes->src_len;\n \t\tp_tag = scatterwalk_ffwd(sg_tag, p_outp, ilen);\n \t} else {\n \t\tilen = aes->src_len - authsize;\n \t\tp_tag = scatterwalk_ffwd(sg_tag, p_inp, ilen);\n \t}\n \n \tjobid = CCP_NEW_JOBID(cmd_q->ccp);\n \n \tmemset(&op, 0, sizeof(op));\n \top.cmd_q = cmd_q;\n \top.jobid = jobid;\n \top.sb_key = cmd_q->sb_key;\n \top.sb_ctx = cmd_q->sb_ctx;\n \top.init = 1;\n \top.u.aes.type = aes->type;\n \n \tret = ccp_init_dm_workarea(&key, cmd_q,\n \t\t\t\t   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,\n \t\t\t\t   DMA_TO_DEVICE);\n \tif (ret)\n \t\treturn ret;\n \n \tdm_offset = CCP_SB_BYTES - aes->key_len;\n \tret = ccp_set_dm_area(&key, dm_offset, aes->key, 0, aes->key_len);\n \tif (ret)\n \t\tgoto e_key;\n \tret = ccp_copy_to_sb(cmd_q, &key, op.jobid, op.sb_key,\n \t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n \tif (ret) {\n \t\tcmd->engine_error = cmd_q->cmd_error;\n \t\tgoto e_key;\n \t}\n \n \tret = ccp_init_dm_workarea(&ctx, cmd_q,\n \t\t\t\t   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,\n \t\t\t\t   DMA_BIDIRECTIONAL);\n \tif (ret)\n \t\tgoto e_key;\n \n \tdm_offset = CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES - aes->iv_len;\n \tret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\n \tif (ret)\n \t\tgoto e_ctx;\n \n \tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n \t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n \tif (ret) {\n \t\tcmd->engine_error = cmd_q->cmd_error;\n \t\tgoto e_ctx;\n \t}\n \n \top.init = 1;\n \tif (aes->aad_len > 0) {\n \t\tret = ccp_init_data(&aad, cmd_q, p_aad, aes->aad_len,\n \t\t\t\t    AES_BLOCK_SIZE,\n \t\t\t\t    DMA_TO_DEVICE);\n \t\tif (ret)\n \t\t\tgoto e_ctx;\n \n \t\top.u.aes.mode = CCP_AES_MODE_GHASH;\n \t\top.u.aes.action = CCP_AES_GHASHAAD;\n \n \t\twhile (aad.sg_wa.bytes_left) {\n \t\t\tccp_prepare_data(&aad, NULL, &op, AES_BLOCK_SIZE, true);\n \n \t\t\tret = cmd_q->ccp->vdata->perform->aes(&op);\n \t\t\tif (ret) {\n \t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n \t\t\t\tgoto e_aad;\n \t\t\t}\n \n \t\t\tccp_process_data(&aad, NULL, &op);\n \t\t\top.init = 0;\n \t\t}\n \t}\n \n \top.u.aes.mode = CCP_AES_MODE_GCTR;\n \top.u.aes.action = aes->action;\n \n \tif (ilen > 0) {\n \t\tin_place = (sg_virt(p_inp) == sg_virt(p_outp)) ? true : false;\n \n \t\tret = ccp_init_data(&src, cmd_q, p_inp, ilen,\n \t\t\t\t    AES_BLOCK_SIZE,\n \t\t\t\t    in_place ? DMA_BIDIRECTIONAL\n \t\t\t\t\t     : DMA_TO_DEVICE);\n \t\tif (ret)\n// bug_start\n\t\t\tgoto e_ctx;\n// bug_end\n \n \t\tif (in_place) {\n \t\t\tdst = src;\n \t\t} else {\n \t\t\tret = ccp_init_data(&dst, cmd_q, p_outp, ilen,\n \t\t\t\t\t    AES_BLOCK_SIZE, DMA_FROM_DEVICE);\n \t\t\tif (ret)\n \t\t\t\tgoto e_src;\n \t\t}\n \n \t\top.soc = 0;\n \t\top.eom = 0;\n \t\top.init = 1;\n \t\twhile (src.sg_wa.bytes_left) {\n \t\t\tccp_prepare_data(&src, &dst, &op, AES_BLOCK_SIZE, true);\n \t\t\tif (!src.sg_wa.bytes_left) {\n \t\t\t\tunsigned int nbytes = ilen % AES_BLOCK_SIZE;\n \n \t\t\t\tif (nbytes) {\n \t\t\t\t\top.eom = 1;\n \t\t\t\t\top.u.aes.size = (nbytes * 8) - 1;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tret = cmd_q->ccp->vdata->perform->aes(&op);\n \t\t\tif (ret) {\n \t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n \t\t\t\tgoto e_dst;\n \t\t\t}\n \n \t\t\tccp_process_data(&src, &dst, &op);\n \t\t\top.init = 0;\n \t\t}\n \t}\n \n \tret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n \t\t\t       CCP_PASSTHRU_BYTESWAP_256BIT);\n \tif (ret) {\n \t\tcmd->engine_error = cmd_q->cmd_error;\n \t\tgoto e_dst;\n \t}\n \n \tret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\n \tif (ret)\n \t\tgoto e_dst;\n \n \tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n \t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n \tif (ret) {\n \t\tcmd->engine_error = cmd_q->cmd_error;\n \t\tgoto e_dst;\n \t}\n \n \tret = ccp_init_dm_workarea(&final_wa, cmd_q, AES_BLOCK_SIZE,\n \t\t\t\t   DMA_BIDIRECTIONAL);\n \tif (ret)\n \t\tgoto e_dst;\n \tfinal = (__be64 *)final_wa.address;\n \tfinal[0] = cpu_to_be64(aes->aad_len * 8);\n \tfinal[1] = cpu_to_be64(ilen * 8);\n \n \tmemset(&op, 0, sizeof(op));\n \top.cmd_q = cmd_q;\n \top.jobid = jobid;\n \top.sb_key = cmd_q->sb_key;\n \top.sb_ctx = cmd_q->sb_ctx;\n \top.init = 1;\n \top.u.aes.type = aes->type;\n \top.u.aes.mode = CCP_AES_MODE_GHASH;\n \top.u.aes.action = CCP_AES_GHASHFINAL;\n \top.src.type = CCP_MEMTYPE_SYSTEM;\n \top.src.u.dma.address = final_wa.dma.address;\n \top.src.u.dma.length = AES_BLOCK_SIZE;\n \top.dst.type = CCP_MEMTYPE_SYSTEM;\n \top.dst.u.dma.address = final_wa.dma.address;\n \top.dst.u.dma.length = AES_BLOCK_SIZE;\n \top.eom = 1;\n \top.u.aes.size = 0;\n \tret = cmd_q->ccp->vdata->perform->aes(&op);\n \tif (ret)\n// bug_start\n\t\tgoto e_dst;\n// bug_end\n \n \tif (aes->action == CCP_AES_ACTION_ENCRYPT) {\n \t\tccp_get_dm_area(&final_wa, 0, p_tag, 0, authsize);\n \t} else {\n \t\tret = ccp_init_dm_workarea(&tag, cmd_q, authsize,\n \t\t\t\t\t   DMA_BIDIRECTIONAL);\n \t\tif (ret)\n// bug_start\n\t\t\tgoto e_tag;\n// bug_end\n \t\tret = ccp_set_dm_area(&tag, 0, p_tag, 0, authsize);\n// bug_start\n\t\tif (ret)\n\t\t\tgoto e_tag;\n// bug_end\n \n \t\tret = crypto_memneq(tag.address, final_wa.address,\n \t\t\t\t    authsize) ? -EBADMSG : 0;\n \t\tccp_dm_free(&tag);\n \t}\n \n// bug_start\ne_tag:\n// bug_end\n \tccp_dm_free(&final_wa);\n \n e_dst:\n \tif (ilen > 0 && !in_place)\n \t\tccp_free_data(&dst, cmd_q);\n \n e_src:\n \tif (ilen > 0)\n \t\tccp_free_data(&src, cmd_q);\n \n e_aad:\n \tif (aes->aad_len)\n \t\tccp_free_data(&aad, cmd_q);\n \n e_ctx:\n \tccp_dm_free(&ctx);\n \n e_key:\n \tccp_dm_free(&key);\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\t\tgoto e_aad;\n// fix_end\n// fix_start\n\t\tgoto e_final_wa;\n// fix_end\n// fix_start\n\t\t\tgoto e_final_wa;\n// fix_end\n// fix_start\n\t\tif (ret) {\n\t\t\tccp_dm_free(&tag);\n\t\t\tgoto e_final_wa;\n\t\t}\n// fix_end\n// fix_start\ne_final_wa:\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-3744", "cve_desc": "A memory leak flaw was found in the Linux kernel in the ccp_run_aes_gcm_cmd() function in drivers/crypto/ccp/ccp-ops.c, which allows attackers to cause a denial of service (memory consumption). This vulnerability is similar with the older CVE-2019-18808.", "project": "linux", "idx": 197135}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(0);\n     const Tensor& input_min_range = ctx->input(1);\n     const Tensor& input_max_range = ctx->input(2);\n \n     int num_slices = 1;\n     if (axis_ > -1) {\n// bug_start\n// bug_end\n       num_slices = input.dim_size(axis_);\n// bug_start\n// bug_end\n     }\n \n     const TensorShape& minmax_shape = ctx->input(1).shape();\n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n \n     Tensor* output_min_tensor = nullptr;\n     Tensor* output_max_tensor = nullptr;\n \n     if (num_slices == 1) {\n       OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));\n       OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));\n       const float min_range = input_min_range.template flat<float>()(0);\n       const float max_range = input_max_range.template flat<float>()(0);\n       QuantizeTensor(ctx, input, min_range, max_range, output,\n                      output_min_tensor, output_max_tensor);\n       return;\n     }\n \n     OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                 errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                       \"Quantize with axis != -1.\"));\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(1, minmax_shape, &output_min_tensor));\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(2, minmax_shape, &output_max_tensor));\n \n     auto input_tensor =\n         input.template flat_inner_outer_dims<float, 3>(axis_ - 1);\n     int64_t pre_dim = 1, post_dim = 1;\n     for (int i = 0; i < axis_; ++i) {\n       pre_dim *= output->dim_size(i);\n     }\n     for (int i = axis_ + 1; i < output->dims(); ++i) {\n       post_dim *= output->dim_size(i);\n     }\n     auto output_tensor = output->template bit_casted_shaped<T, 3>(\n         {pre_dim, num_slices, post_dim});\n     auto min_ranges = input_min_range.template vec<float>();\n     auto max_ranges = input_max_range.template vec<float>();\n     for (int i = 0; i < num_slices; ++i) {\n       QuantizeSlice(ctx->eigen_device<Device>(), ctx,\n                     input_tensor.template chip<1>(i), min_ranges(i),\n                     max_ranges(i), output_tensor.template chip<1>(i),\n                     &output_min_tensor->flat<float>()(i),\n                     &output_max_tensor->flat<float>()(i));\n     }\n   }\n \n", "target": "// fix_start\n      OP_REQUIRES(\n          ctx, input.dims() > axis_,\n          errors::InvalidArgument(\n              \"Axis is on a zero-based index, so its value must always be less \"\n              \"than number of input's dims, but given axis value was \",\n              axis_, \" and input's dims was \", input.dims()));\n// fix_end\n// fix_start\n      OP_REQUIRES(ctx, input_min_range.dims() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is specified, min_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but min_range dims are \",\n                      input_min_range.dims()));\n      OP_REQUIRES(ctx, input_min_range.dim_size(0) == num_slices,\n                  errors::InvalidArgument(\n                      \"If axis is specified, min_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but min_range is a 1-D tensor of size \",\n                      input_min_range.dim_size(0),\n                      \" and input's axis dimension is of size \", num_slices));\n      OP_REQUIRES(ctx, input_max_range.dims() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is specified, max_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but max_range dims are \",\n                      input_max_range.dims()));\n      OP_REQUIRES(ctx, input_max_range.dim_size(0) == num_slices,\n                  errors::InvalidArgument(\n                      \"If axis is specified, max_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but max_range is a 1-D tensor of size \",\n                      input_max_range.dim_size(0),\n                      \" and input's axis dimension is of size \", num_slices));\n    } else {\n      OP_REQUIRES(ctx, input_min_range.NumElements() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is not specified, min_range must contain a \"\n                      \"single float element, but it contains \",\n                      input_min_range.NumElements(), \" elements\"));\n      OP_REQUIRES(ctx, input_max_range.NumElements() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is not specified, max_range must contain a \"\n                      \"single float element, but it contains \",\n                      input_max_range.NumElements(), \" elements\"));\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-37663", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197142}
{"source": " static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n {\n     GetBitContext gb;\n     PutBitContext pb;\n     MPEG4AudioConfig m4ac;\n// bug_start\n    int off;\n// bug_end\n \n// bug_start\n    init_get_bits(&gb, buf, size * 8);\n// bug_end\n     off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n     if (off < 0)\n         return off;\n     skip_bits_long(&gb, off);\n     adts->objecttype        = m4ac.object_type - 1;\n     adts->sample_rate_index = m4ac.sampling_index;\n     adts->channel_conf      = m4ac.chan_config;\n \n     if (adts->objecttype > 3U) {\n         av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n         return AVERROR_INVALIDDATA;\n     }\n     if (adts->sample_rate_index == 15) {\n         av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n     if (get_bits(&gb, 1)) {\n         av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n     if (get_bits(&gb, 1)) {\n         av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n     if (get_bits(&gb, 1)) {\n         av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n     if (!adts->channel_conf) {\n         init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n \n         put_bits(&pb, 3, 5);\n         adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n         flush_put_bits(&pb);\n     }\n \n     adts->write_adts = 1;\n \n     return 0;\n }\n \n", "target": "// fix_start\n    int off, ret;\n// fix_end\n// fix_start\n    ret = init_get_bits8(&gb, buf, size);\n    if (ret < 0)\n        return ret;\n// fix_end\n", "cwe": "CWE-252", "cwe_name": "Unchecked Return Value", "cve": "CVE-2021-38171", "cve_desc": "adts_decode_extradata in libavformat/adtsenc.c in FFmpeg 4.4 does not check the init_get_bits return value, which is a necessary step because the second argument to init_get_bits can be crafted.", "project": "FFmpeg", "idx": 197185}
{"source": " njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n {\n     char        *p;\n     size_t      length;\n     njs_bool_t  trail;\n     char        src[NJS_MAX_PATH + 1];\n \n     trail = 0;\n     length = info->name.length;\n \n     if (dir != NULL) {\n// bug_start\n        length = dir->length;\n// bug_end\n \n         if (length == 0) {\n             return NJS_DECLINED;\n         }\n \n         trail = (dir->start[dir->length - 1] != '/');\n \n         if (trail) {\n             length++;\n         }\n     }\n \n     if (njs_slow_path(length > NJS_MAX_PATH)) {\n         return NJS_ERROR;\n     }\n \n     p = &src[0];\n \n     if (dir != NULL) {\n         p = (char *) njs_cpymem(p, dir->start, dir->length);\n \n         if (trail) {\n             *p++ = '/';\n         }\n     }\n \n     p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n     *p = '\\0';\n \n     p = realpath(&src[0], &info->path[0]);\n     if (p == NULL) {\n         return NJS_DECLINED;\n     }\n \n     info->fd = open(&info->path[0], O_RDONLY);\n     if (info->fd < 0) {\n         return NJS_DECLINED;\n     }\n \n \n     info->file.start = (u_char *) &info->path[0];\n     info->file.length = njs_strlen(info->file.start);\n \n     return NJS_OK;\n }\n \n", "target": "// fix_start\n        length += dir->length;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-29379", "cve_desc": "Nginx NJS v0.7.3 was discovered to contain a stack overflow in the function njs_default_module_loader at /src/njs/src/njs_module.c. NOTE: multiple third parties dispute this report, e.g., the behavior is only found in unreleased development code that was not part of the 0.7.2, 0.7.3, or 0.7.4 release", "project": "njs", "idx": 197223}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     try {\n       const Tensor& input = ctx->input(kInputTensorIndex);\n// bug_start\n// bug_end\n       const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);\n// bug_start\n// bug_end\n       float* input_min_vec_data = (float*)const_cast<void*>(\n           static_cast<const void*>(input_min_vec.flat<float>().data()));\n// bug_start\n// bug_end\n       const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);\n// bug_start\n// bug_end\n       float* input_max_vec_data = (float*)const_cast<void*>(\n           static_cast<const void*>(input_max_vec.flat<float>().data()));\n \n       const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);\n// bug_start\n// bug_end\n       const float input_requested_min_float =\n           input_requested_min.flat<float>()(0);\n// bug_start\n// bug_end\n       const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);\n// bug_start\n// bug_end\n       const float input_requested_max_float =\n           input_requested_max.flat<float>()(0);\n \n// bug_start\n      size_t depth = input_min_vec.NumElements();\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n      OP_REQUIRES(\n          ctx, input_min_vec.dim_size(0) == depth,\n          errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                  depth, \" was \", input_min_vec.dim_size(0)));\n      OP_REQUIRES(\n          ctx, input_max_vec.dim_size(0) == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.dim_size(0)));\n\n      if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);\n// bug_end\n \n       const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;\n       const float requested_min_max =\n           std::max(std::abs(input_requested_min_float),\n                    std::abs(input_requested_max_float));\n       Tensor* output = nullptr;\n       OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputTensorIndex,\n                                                input.shape(), &output));\n \n       std::vector<float> scales(depth);\n       for (int i = 0; i < depth; ++i) {\n         float min_max_from_vec = std::max(std::abs(input_min_vec_data[i]),\n                                           std::abs(input_max_vec_data[i]));\n         scales[i] = factor * (min_max_from_vec / requested_min_max /\n                               static_cast<float>(1L << 31));\n       }\n \n       mkldnn::primitive_attr reorder_attr;\n       reorder_attr.set_output_scales(2, scales);\n \n       memory::dims dims_mkl_order =\n           TFShapeToMklDnnDimsInNCHW(input.shape(), FORMAT_NHWC);\n       memory::desc input_md = memory::desc(dims_mkl_order, MklDnnType<qint32>(),\n                                            memory::format_tag::nhwc);\n       memory::desc output_md =\n           (out_type_ == DT_QINT8)\n               ? memory::desc(dims_mkl_order, MklDnnType<qint8>(),\n                              memory::format_tag::nhwc)\n               : memory::desc(dims_mkl_order, MklDnnType<quint8>(),\n                              memory::format_tag::nhwc);\n \n       void* input_buf =\n           static_cast<void*>(const_cast<qint32*>(input.flat<qint32>().data()));\n       void* output_buf;\n       if (out_type_ == DT_QINT8) {\n         output_buf = static_cast<void*>(\n             const_cast<qint8*>(output->flat<qint8>().data()));\n       } else {\n         output_buf = static_cast<void*>(\n             const_cast<quint8*>(output->flat<quint8>().data()));\n       }\n \n       std::unique_ptr<memory> input_mem_prim(\n           new memory(input_md, cpu_engine_, input_buf));\n       std::unique_ptr<memory> output_mem_prim(\n           new memory(output_md, cpu_engine_, output_buf));\n \n       mkldnn::reorder::primitive_desc reorder_pd =\n           ReorderPd(cpu_engine_, input_mem_prim->get_desc(), cpu_engine_,\n                     output_mem_prim->get_desc(), reorder_attr);\n       std::shared_ptr<stream> reorder_stream;\n       MklDnnThreadPool eigen_tp(ctx);\n       reorder_stream.reset(CreateStream(&eigen_tp, cpu_engine_));\n       std::unordered_map<int, mkldnn::memory> reorder_args = {\n           {MKLDNN_ARG_FROM, *input_mem_prim},\n           {MKLDNN_ARG_TO, *output_mem_prim}};\n       std::unique_ptr<mkldnn::primitive> reorder_prim(\n           new mkldnn::reorder(reorder_pd));\n       reorder_prim->execute(*reorder_stream, reorder_args);\n \n       Tensor* output_min = nullptr;\n       Tensor* output_max = nullptr;\n       OP_REQUIRES_OK(ctx,\n                      ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n       OP_REQUIRES_OK(ctx,\n                      ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n \n       output_min->flat<float>()(0) = input_requested_min_float;\n       output_max->flat<float>()(0) = input_requested_max_float;\n     } catch (mkldnn::error& e) {\n       string error_msg = \"Status: \" + std::to_string(e.status) +\n                          \", message: \" + std::string(e.message) + \", in file \" +\n                          std::string(__FILE__) + \":\" + std::to_string(__LINE__);\n       OP_REQUIRES_OK(\n           ctx, errors::Aborted(\"Operation received an exception:\", error_msg));\n     }\n   }\n \n", "target": "// fix_start\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n\n// fix_end\n// fix_start\n      size_t depth = input_min_vec.NumElements();\n// fix_end\n// fix_start\n\n// fix_end\n// fix_start\n      OP_REQUIRES(\n          ctx, input_max_vec.NumElements() == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.NumElements()));\n// fix_end\n// fix_start\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_min must be a scalar\"));\n// fix_end\n// fix_start\n\n// fix_end\n// fix_start\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_max must be a scalar\"));\n// fix_end\n// fix_start\n      if (out_type_ == DT_QINT8) {\n        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,\n                    errors::InvalidArgument(\n                        \"If out_type is QINT8, requested_output_max must be \"\n                        \"non negative, got \",\n                        input_requested_min_float));\n      }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2021-37665", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197239}
{"source": " TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n   OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n   int scratch_tensor_index = op_data->scratch_tensor_index;\n \n   TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n   TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n \n   const TfLiteTensor* input;\n   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   const TfLiteTensor* weights_feature;\n   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                           &weights_feature));\n   const TfLiteTensor* weights_time;\n   TF_LITE_ENSURE_OK(\n       context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n \n   TF_LITE_ENSURE(context,\n                  input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);\n \n   const int rank = params->rank;\n   const int batch_size = input->dims->data[0];\n   const int num_filters = weights_feature->dims->data[0];\n   TF_LITE_ENSURE(context, rank != 0);\n   TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);\n   const int num_units = num_filters / rank;\n   const int memory_size = weights_time->dims->data[1];\n   TF_LITE_ENSURE_EQ(context, input->dims->data[1],\n                     weights_feature->dims->data[1]);\n   TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);\n \n   const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n   if (bias) {\n     TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);\n   }\n \n   const TfLiteTensor* state;\n   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));\n   TfLiteTensor* output;\n   TF_LITE_ENSURE_OK(context,\n                     GetOutputSafe(context, node, kOutputTensor, &output));\n \n   TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);\n   TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);\n   TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),\n                     memory_size * num_filters);\n \n   TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);\n   output_size_array->data[0] = batch_size;\n   output_size_array->data[1] = num_units;\n   TF_LITE_ENSURE_OK(context,\n                     context->ResizeTensor(context, output, output_size_array));\n \n   const bool is_hybrid_op = IsHybridOp(input, weights_feature);\n   const bool is_full_integer = input->type == kTfLiteInt8;\n \n   TfLiteIntArrayFree(node->temporaries);\n   if (is_hybrid_op) {\n     node->temporaries = TfLiteIntArrayCreate(6);\n   } else if (is_full_integer) {\n     node->temporaries = TfLiteIntArrayCreate(2);\n   } else {\n     node->temporaries = TfLiteIntArrayCreate(1);\n   }\n   node->temporaries->data[0] = scratch_tensor_index;\n \n   TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);\n   scratch_size_array->data[0] = batch_size;\n   scratch_size_array->data[1] = num_filters;\n \n   TfLiteTensor* scratch_tensor;\n   TF_LITE_ENSURE_OK(\n       context, GetTemporarySafe(context, node, 0, &scratch_tensor));\n \n   if (is_full_integer) {\n     scratch_tensor->type = kTfLiteInt32;\n   } else {\n     scratch_tensor->type = kTfLiteFloat32;\n   }\n   scratch_tensor->allocation_type = kTfLiteArenaRw;\n   TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,\n                                                    scratch_size_array));\n \n   if (is_hybrid_op) {\n     op_data->compute_row_sums = true;\n     node->temporaries->data[1] = scratch_tensor_index + 1;\n     TfLiteTensor* input_quantized;\n     TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 1,\n                                                 &input_quantized));\n     input_quantized->type = weights_feature->type;\n     input_quantized->allocation_type = kTfLiteArenaRw;\n     if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n       TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                        input_quantized_size));\n     }\n \n     node->temporaries->data[2] = scratch_tensor_index + 2;\n     TfLiteTensor* scaling_factors;\n     TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 2,\n                                                 &scaling_factors));\n     scaling_factors->type = kTfLiteFloat32;\n     scaling_factors->allocation_type = kTfLiteArenaRw;\n     int scaling_dims[1] = {batch_size};\n     if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n       TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n       scaling_factors_size->data[0] = batch_size;\n       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                        scaling_factors_size));\n     }\n \n     node->temporaries->data[3] = scratch_tensor_index + 3;\n     TfLiteTensor* float_weights_time;\n     TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 3,\n                                                 &float_weights_time));\n     float_weights_time->type = kTfLiteFloat32;\n     float_weights_time->allocation_type = kTfLiteArenaRwPersistent;\n     if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {\n       TfLiteIntArray* float_weights_time_size =\n           TfLiteIntArrayCopy(weights_time->dims);\n       TF_LITE_ENSURE_OK(context,\n                         context->ResizeTensor(context, float_weights_time,\n                                               float_weights_time_size));\n     }\n \n     node->temporaries->data[4] = scratch_tensor_index + 4;\n     TfLiteTensor* zero_points;\n     TF_LITE_ENSURE_OK(\n         context, GetTemporarySafe(context, node, 4, &zero_points));\n     zero_points->type = kTfLiteFloat32;\n     zero_points->allocation_type = kTfLiteArenaRw;\n     int zero_points_dims[1] = {batch_size};\n     if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n       TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n       zero_points_size->data[0] = zero_points_dims[0];\n       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                        zero_points_size));\n     }\n \n     node->temporaries->data[5] = scratch_tensor_index + 5;\n     TfLiteTensor* row_sums;\n     TF_LITE_ENSURE_OK(context,\n                       GetTemporarySafe(context, node, 5, &row_sums));\n     row_sums->type = kTfLiteFloat32;\n     row_sums->allocation_type = kTfLiteArenaRwPersistent;\n     int row_sums_dims[1] = {num_filters};\n     if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n       TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n       row_sums_size->data[0] = row_sums_dims[0];\n       TF_LITE_ENSURE_OK(\n           context, context->ResizeTensor(context, row_sums, row_sums_size));\n     }\n   }\n   if (is_full_integer) {\n     TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);\n     output_temp_size_array->data[0] = num_units;\n     output_temp_size_array->data[1] = batch_size;\n     node->temporaries->data[1] = scratch_tensor_index + 1;\n     TfLiteTensor* output_temp;\n     TF_LITE_ENSURE_OK(\n         context, GetTemporarySafe(context, node, 1, &output_temp));\n     output_temp->type = kTfLiteInt32;\n     output_temp->allocation_type = kTfLiteArenaRw;\n     TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,\n                                                      output_temp_size_array));\n \n// bug_start\n// bug_end\n     auto* input_params =\n         reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);\n// bug_start\n// bug_end\n     auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(\n         weights_feature->quantization.params);\n// bug_start\n// bug_end\n     auto* state_params =\n         reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);\n// bug_start\n// bug_end\n     auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(\n         weights_time->quantization.params);\n// bug_start\n// bug_end\n     auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n         output->quantization.params);\n     const double effective_scale_1 = input_params->scale->data[0] *\n                                      weights_feature_params->scale->data[0] /\n                                      state_params->scale->data[0];\n     const double effective_scale_2 = state_params->scale->data[0] *\n                                      weight_time_params->scale->data[0] /\n                                      output_params->scale->data[0];\n     QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,\n                        &op_data->effective_scale_1_b);\n     QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,\n                        &op_data->effective_scale_2_b);\n   }\n   return kTfLiteOk;\n }\n \n", "target": "// fix_start\n    TF_LITE_ENSURE(context, input->quantization.type != kTfLiteNoQuantization);\n// fix_end\n// fix_start\n    TF_LITE_ENSURE(context,\n                   weights_feature->quantization.type != kTfLiteNoQuantization);\n// fix_end\n// fix_start\n    TF_LITE_ENSURE(context, state->quantization.type != kTfLiteNoQuantization);\n// fix_end\n// fix_start\n    TF_LITE_ENSURE(context,\n                   weights_time->quantization.type != kTfLiteNoQuantization);\n// fix_end\n// fix_start\n    TF_LITE_ENSURE(context, output->quantization.type != kTfLiteNoQuantization);\n// fix_end\n", "cwe": "CWE-908", "cwe_name": "Use of Uninitialized Resource", "cve": "CVE-2021-37682", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197242}
{"source": " Status ShapeRefiner::InferShapesForFunctionSubNode(\n     const Node* node, InferenceContext* outer_context) {\n   TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n   InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n \n   if (StringPiece(node->type_string()) == kArgOp) {\n \n     int index;\n     TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n \n     if (index < 0 || outer_context->num_inputs() <= index) {\n       return errors::Internal(\n           \"Function instantiation included invalid input index: \", index,\n           \" not in [0, \", outer_context->num_inputs(), \").\");\n     }\n \n     if (outer_context->input(index).SameHandle(ShapeHandle())) {\n       VLOG(1) << \"Function instantiation has undefined input shape at \"\n               << \"index: \" << index << \" in the outer inference context.\";\n       node_context->set_output(0, node_context->UnknownShape());\n     } else {\n       node_context->set_output(0, outer_context->input(index));\n     }\n \n     auto* resource = outer_context->input_handle_shapes_and_types(index);\n     if (resource) {\n       node_context->set_output_handle_shapes_and_types(0, *resource);\n     }\n   } else if (StringPiece(node->type_string()) == kRetvalOp) {\n \n     int index;\n     TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n \n     if (index < 0 || outer_context->num_outputs() <= index) {\n       return errors::Internal(\n           \"Function instantiation included invalid output index: \", index,\n           \" not in [0, \", outer_context->num_outputs(), \").\");\n     }\n \n     ShapeHandle handle;\n     TensorShapeProto proto;\n     node_context->ShapeHandleToProto(node_context->input(0), &proto);\n     TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n     outer_context->set_output(index, handle);\n \n// bug_start\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n// bug_end\n     if (resource) {\n// bug_start\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n// bug_end\n     }\n   }\n \n   return Status::OK();\n }\n \n", "target": "// fix_start\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n// fix_end\n// fix_start\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37690", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions when running shape functions, some functions (such as `MutableHashTableShape`) produce extra output information in the form of a `ShapeAndType` struct. The shapes embedded in this struct are owned by an inference context that is cleaned up almost immediately; if the upstream code attempts to access this shape information, it can trigger a segfault. `ShapeRefiner` is mitigating this for normal output shapes by cloning them (and thus putting the newly created shape under ownership of an inference context that will not die), but we were not doing the same for shapes and types. This commit fixes that by doing similar logic on output shapes and types. We have patched the issue in GitHub commit ee119d4a498979525046fba1c3dd3f13a039fbb1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197247}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& a = ctx->input(0);\n     const Tensor& b = ctx->input(1);\n     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n                 errors::InvalidArgument(\"a is not a matrix\"));\n     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n                 errors::InvalidArgument(\"b is not a matrix\"));\n \n     const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n     const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n     const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n     const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n \n     OP_REQUIRES(ctx, k == k2,\n                 errors::InvalidArgument(\n                     \"Matrix size incompatible: a: \", a.shape().DebugString(),\n                     \", b: \", b.shape().DebugString()));\n// bug_start\n// bug_end\n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));\n// bug_start\n// bug_end\n \n     if (k == 0) {\n       functor::SetZeroFunctor<CPUDevice, float> f;\n       f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n       return;\n     }\n \n     auto out = output->matrix<float>();\n \n     std::unique_ptr<Tensor> a_float;\n     std::unique_ptr<Tensor> b_float;\n     if (!a_is_sparse_ && !b_is_sparse_) {\n       auto left = &a;\n       auto right = &b;\n       if (std::is_same<TL, bfloat16>::value) {\n         a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n         BFloat16ToFloat(a.flat<bfloat16>().data(),\n                         a_float->flat<float>().data(), a.NumElements());\n         left = a_float.get();\n       }\n       if (std::is_same<TR, bfloat16>::value) {\n         b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n         BFloat16ToFloat(b.flat<bfloat16>().data(),\n                         b_float->flat<float>().data(), b.NumElements());\n         right = b_float.get();\n       }\n       Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n       dim_pair[0].first = transpose_a_ ? 0 : 1;\n       dim_pair[0].second = transpose_b_ ? 1 : 0;\n \n       out.device(ctx->template eigen_device<CPUDevice>()) =\n           left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n       return;\n     }\n \n     auto left = &a;\n     auto right = &b;\n     bool transpose_output = false;\n     bool transpose_a = transpose_a_;\n     bool transpose_b = transpose_b_;\n     if (!a_is_sparse_) {\n       std::swap(left, right);\n       std::swap(transpose_a, transpose_b);\n       transpose_a = !transpose_a;\n       transpose_b = !transpose_b;\n       transpose_output = !transpose_output;\n     }\n \n     std::unique_ptr<Tensor> right_tr;\n     if (transpose_b) {\n       OP_REQUIRES(ctx, right->dim_size(0) != 0,\n                   errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n       OP_REQUIRES(ctx, right->dim_size(1) != 0,\n                   errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n       right_tr.reset(\n           new Tensor(right->dtype(),\n                      TensorShape({right->dim_size(1), right->dim_size(0)})));\n \n       const auto perm = dsizes_10();\n       if (transpose_output) {\n         right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =\n             right->matrix<TL>().shuffle(perm);\n       } else {\n         right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =\n             right->matrix<TR>().shuffle(perm);\n       }\n       right = right_tr.get();\n     }\n \n     if (transpose_output) {\n       DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n                                 right->matrix<TL>(), transpose_a,\n                                 ctx->device()->tensorflow_cpu_worker_threads(),\n                                 transpose_output, &out);\n     } else {\n       DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                                 right->matrix<TR>(), transpose_a,\n                                 ctx->device()->tensorflow_cpu_worker_threads(),\n                                 transpose_output, &out);\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,\n                errors::InvalidArgument(\n                    \"Matrix dimensions cannot be negative: a: \",\n                    a.shape().DebugString(), \", b: \", b.shape().DebugString()));\n// fix_end\n// fix_start\n\n    if (m == 0 || n == 0) {\n      return;\n    }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-41219", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197262}
{"source": " PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n \t\t\t\t\tconst void *buf,\n \t\t\t\t\tpj_size_t length,\n \t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n {\n// bug_start\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n// bug_end\n     pj_uint8_t *p;\n     pj_uint8_t padlen;\n     pj_size_t rpsi_len;\n \n     PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n// bug_start\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n// bug_end\n \n// bug_start\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n// bug_end\n \treturn PJ_ENOTFOUND;\n \n// bug_start\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n// bug_end\n     if (length < rpsi_len + 12)\n \treturn PJ_ETOOSMALL;\n \n     p = (pj_uint8_t*)hdr + sizeof(*hdr);\n     padlen = *p++;\n// bug_start\n// bug_end\n     rpsi->pt = (*p++ & 0x7F);\n     rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n     pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n \n     return PJ_SUCCESS;\n }\n \n", "target": "// fix_start\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n// fix_end\n// fix_start\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n// fix_end\n// fix_start\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)\n// fix_end\n// fix_start\n    if (hdr->rtcp_common.length < 3) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid header length\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;\n// fix_end\n// fix_start\n\n    if (padlen >= 32) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,\n                      \"Failed parsing FB RPSI, invalid RPSI padding len\"));\n\treturn PJ_ETOOBIG;\n    }\n\n    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid RPSI bit len\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2022-24786", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.", "project": "pjproject", "idx": 197305}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& handle = ctx->input(0);\n// bug_start\n// bug_end\n     const string& name = handle.scalar<tstring>()();\n     auto session_state = ctx->session_state();\n     OP_REQUIRES(ctx, session_state != nullptr,\n                 errors::FailedPrecondition(\n                     \"DeleteSessionTensor called on null session state\"));\n     OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"`handle` must be scalar\"));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-29194", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.DeleteSessionTensor` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 197318}
{"source": "   static Status ParseEquation(const string& equation,\n                               OperandLabels* input_labels,\n                               Labels* output_labels,\n                               std::vector<DimensionType>* label_types,\n                               OperandLabelCounts* input_label_counts,\n                               LabelCounts* output_label_counts,\n                               gtl::InlinedVector<bool, 2>* input_has_ellipsis,\n                               bool* output_has_ellipsis) {\n     gtl::InlinedVector<string, 2> input_str;\n     string output_str;\n     TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));\n \n     absl::flat_hash_map<char, int> label_mapping;\n     int num_inputs = input_str.size();\n     input_labels->resize(num_inputs);\n \n     for (int i = 0; i < num_inputs; ++i) {\n       MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);\n     }\n     MapToLabels(output_str, output_labels, &label_mapping);\n \n     int num_labels = label_mapping.size();\n     input_label_counts->resize(num_inputs);\n     input_has_ellipsis->resize(num_inputs);\n     for (int i = 0; i < num_inputs; ++i) {\n       input_label_counts->at(i).resize(num_labels);\n// bug_start\n// bug_end\n       for (const int label : input_labels->at(i)) {\n         if (label != kEllipsisLabel)\n           input_label_counts->at(i)[label] += 1;\n         else\n           input_has_ellipsis->at(i) = true;\n       }\n     }\n     output_label_counts->resize(num_labels);\n// bug_start\n// bug_end\n     for (const int label : *output_labels) {\n       if (label != kEllipsisLabel)\n         output_label_counts->at(label) += 1;\n       else\n         *output_has_ellipsis = true;\n     }\n \n     label_types->resize(num_labels);\n     for (int label = 0; label < num_labels; ++label) {\n       if (label == kEllipsisLabel) continue;\n       bool removed = (*output_label_counts)[label] == 0;\n       bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||\n                     (*input_label_counts)[1][label] == 0;\n       (*label_types)[label] = GetDimensionType(removed, unique);\n     }\n     return Status::OK();\n   }\n \n", "target": "// fix_start\n      input_has_ellipsis->at(i) = false;\n// fix_end\n// fix_start\n    *output_has_ellipsis = false;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-41201", "cve_desc": "TensorFlow is an open source platform for machine learning. In affeced versions during execution, `EinsumHelper::ParseEquation()` is supposed to set the flags in `input_has_ellipsis` vector and `*output_has_ellipsis` boolean to indicate whether there is ellipsis in the corresponding inputs and output. However, the code only changes these flags to `true` and never assigns `false`. This results in unitialized variable access if callers assume that `EinsumHelper::ParseEquation()` always sets these flags. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197326}
{"source": " Status AutoParallel::Initialize(const GrapplerItem& item) {\n   num_gpus_ = GetNumAvailableGPUs();\n   LOG(INFO) << \"Number of GPUs: \" << num_gpus_;\n   item_ = &item;\n   graph_ = item.graph;\n   LOG(INFO) << \"Original graph size: \" << graph_.node_size();\n   if (item.fetch.empty()) {\n     return Status(error::INVALID_ARGUMENT, \"No fetch nodes provided.\");\n   }\n \n   if (item.MainVariables().empty()) {\n     return Status(error::INVALID_ARGUMENT, \"No variables provided.\");\n   }\n \n   for (const auto& init : item.init_ops) {\n     VLOG(1) << \"Init node: \" << init;\n   }\n \n   for (const auto& fetch : item.fetch) {\n     VLOG(1) << \"Fetch node: \" << fetch;\n   }\n \n   for (const auto& var : item.MainVariables()) {\n     VLOG(2) << \"Variable: \" << var->name();\n   }\n \n   const std::set<string> apply_gradients_ops = {\"ApplyGradientDescent\",\n                                                 \"ApplyProximalGradientDescent\",\n                                                 \"ApplyAdadelta\",\n                                                 \"ApplyAdagrad\",\n                                                 \"ApplyProximalAdagrad\",\n                                                 \"ApplyAdagradDA\",\n                                                 \"ApplyFtrl\",\n                                                 \"ApplyMomentum\",\n                                                 \"ApplyAdam\",\n                                                 \"ApplyRMSProp\",\n                                                 \"ApplyCenteredRMSProp\"};\n   for (int i = 0; i < graph_.node_size(); i++) {\n     all_nodes_.insert(\n         std::make_pair(graph_.node(i).name(), graph_.mutable_node(i)));\n     if (apply_gradients_ops.find(graph_.node(i).op()) !=\n         apply_gradients_ops.end()) {\n       apply_gradients_nodes_.insert(graph_.node(i).name());\n       VLOG(2) << \"Apply gradients node: \" << graph_.node(i).name();\n     }\n   }\n \n   auto div_const_node = AddNodeDivConst();\n   all_nodes_.insert(std::make_pair(div_const_node->name(), div_const_node));\n   std::map<string, int> gradient_pos = {{\"ApplyGradientDescent\", 2},\n                                         {\"ApplyProximalGradientDescent\", 4},\n                                         {\"ApplyAdadelta\", 6},\n                                         {\"ApplyAdagrad\", 3},\n                                         {\"ApplyProximalAdagrad\", 5},\n                                         {\"ApplyAdagradDA\", 3},\n                                         {\"ApplyFtrl\", 3},\n                                         {\"ApplyMomentum\", 3},\n                                         {\"ApplyAdam\", 9},\n                                         {\"ApplyRMSProp\", 7},\n                                         {\"ApplyCenteredRMSProp\", 8}};\n   for (const auto& apply_gradient_node_name : apply_gradients_nodes_) {\n     auto apply_gradients_op = all_nodes_[apply_gradient_node_name]->op();\n     auto apply_gradients_node = all_nodes_[apply_gradient_node_name];\n \n     auto div_node = AddNodeDiv(\n         apply_gradient_node_name,\n         apply_gradients_node->input(gradient_pos[apply_gradients_op]),\n         div_const_node->name());\n     all_nodes_.insert(std::make_pair(div_node->name(), div_node));\n     *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) =\n         div_node->name();\n   }\n   LOG(INFO) << \"Graph size after adding div nodes: \" << all_nodes_.size();\n \n   std::vector<const NodeDef*> train_nodes;\n   TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));\n   LOG(INFO) << \"Number of training nodes: \" << train_nodes.size();\n \n// bug_start\n  const NodeDef* dequeue_node;\n// bug_end\n   for (const auto& train_node : train_nodes) {\n     if (IsDequeueOp(*train_node)) {\n       dequeue_node = train_node;\n       break;\n     }\n   }\n \n   std::vector<const NodeDef*> input_nodes;\n   if (dequeue_node) {\n     LOG(INFO) << \"Dequeue node: \" << dequeue_node->name();\n     TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, {dequeue_node->name()},\n                                               {}, &input_nodes));\n   }\n   LOG(INFO) << \"Number of input nodes: \" << input_nodes.size();\n \n   std::set<string> dont_replicate_nodes;\n   for (const auto& variable : item.MainVariables()) {\n     dont_replicate_nodes.insert(variable->name());\n   }\n \n   for (const auto& init : item.init_ops) {\n     dont_replicate_nodes.insert(NodeName(init));\n   }\n \n   for (const auto& input_node : input_nodes) {\n     if (input_node->name() != dequeue_node->name()) {\n       dont_replicate_nodes.insert(input_node->name());\n     }\n   }\n \n   for (const auto& node : train_nodes) {\n     if (dont_replicate_nodes.find(node->name()) == dont_replicate_nodes.end()) {\n       replica_nodes_.insert(node->name());\n     }\n   }\n   LOG(INFO) << \"Number of replica nodes: \" << replica_nodes_.size();\n \n   for (const auto& node : all_nodes_) {\n     if (replica_nodes_.find(node.first) == replica_nodes_.end()) {\n       shared_nodes_.insert(node.first);\n     }\n   }\n   LOG(INFO) << \"Number of shared nodes: \" << shared_nodes_.size();\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  const NodeDef* dequeue_node = nullptr;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-41225", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's Grappler optimizer has a use of unitialized variable. If the `train_nodes` vector (obtained from the saved model that gets optimized) does not contain a `Dequeue` node, then `dequeue_node` is left unitialized. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197359}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& input = context->input(0);\n// bug_start\n// bug_end\n     const Tensor& dims = context->input(1);\n \n     if (TensorShapeUtils::IsScalar(input.shape())) {\n       context->set_output(0, input);\n     } else {\n       const int input_dims = input.dims();\n       OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                   errors::InvalidArgument(\"'dims' must be 1-dimension, not \",\n                                           dims.dims()));\n \n       OP_REQUIRES(\n           context, input_dims == dims.dim_size(0),\n           errors::InvalidArgument(\n               \"'dims' must have the same number of values as 'input' has \"\n               \"dimensions. 'input' has \",\n               input_dims, \"'dims' has \", dims.dim_size(0), \" values\"));\n       OP_REQUIRES(context, input_dims <= 8,\n                   errors::Unimplemented(\n                       \"reverse is not implemented for tensors of rank > 8.\"));\n \n       Tensor* output = nullptr;\n       OP_REQUIRES_OK(context,\n                      context->allocate_output(0, input.shape(), &output));\n \n #define HANDLE_REVERSE(NDIMS)                                               \\\n   case NDIMS:                                                               \\\n     HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n     return;\n \n       switch (input_dims) {\n         HANDLE_REVERSE(0);\n         HANDLE_REVERSE(1);\n         HANDLE_REVERSE(2);\n         HANDLE_REVERSE(3);\n         HANDLE_REVERSE(4);\n         HANDLE_REVERSE(5);\n         HANDLE_REVERSE(6);\n         HANDLE_REVERSE(7);\n         HANDLE_REVERSE(8);\n       }\n #undef HANDLE_REVERSE\n     }\n   }\n \n", "target": "// fix_start\n    if (input.dims() > 0) {\n      OP_REQUIRES(\n          context, input.dim_size(0) != 0,\n          errors::InvalidArgument(\"Invalid input first dimension. Found 0.\"));\n    }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29556", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197395}
{"source": " void RestoreTensor(OpKernelContext* context,\n                    checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                    int preferred_shard, bool restore_slice, int restore_index) {\n   const Tensor& file_pattern_t = context->input(0);\n   {\n     const int64_t size = file_pattern_t.NumElements();\n     OP_REQUIRES(\n         context, size == 1,\n         errors::InvalidArgument(\n             \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n// bug_start\n            size, \"elements\"));\n// bug_end\n   }\n   const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n \n   const Tensor& tensor_name_t = context->input(1);\n// bug_start\n// bug_end\n   const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n \n   std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n \n   const checkpoint::TensorSliceReader* reader = nullptr;\n \n   if (context->slice_reader_cache()) {\n     reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                       preferred_shard);\n   }\n   if (!reader) {\n     allocated_reader.reset(new checkpoint::TensorSliceReader(\n         file_pattern, open_func, preferred_shard));\n     reader = allocated_reader.get();\n   }\n   OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n \n   DataType type;\n   TensorShape saved_shape;\n   OP_REQUIRES(\n       context, reader->HasTensor(tensor_name, &saved_shape, &type),\n       errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                        \"\\\" not found in checkpoint files \", file_pattern));\n   OP_REQUIRES(\n       context, type == context->expected_output_dtype(restore_index),\n       errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                               DataTypeString(context->expected_output_dtype(0)),\n                               \", got a tensor of type \", DataTypeString(type),\n                               \" instead: tensor_name = \", tensor_name));\n \n   TensorShape output_shape(saved_shape);\n   TensorSlice slice_to_load(saved_shape.dims());\n   if (restore_slice) {\n     const tstring& shape_spec =\n         context->input(2).flat<tstring>()(restore_index);\n     if (!shape_spec.empty()) {\n       TensorShape parsed_shape;\n       OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                   shape_spec, &parsed_shape, &slice_to_load,\n                                   &output_shape));\n       OP_REQUIRES(\n           context, parsed_shape.IsSameSize(saved_shape),\n           errors::InvalidArgument(\n               \"Shape in shape_and_slice spec does not match the shape in the \"\n               \"save file: \",\n               parsed_shape.DebugString(),\n               \", save file shape: \", saved_shape.DebugString()));\n     }\n   }\n \n   Tensor* t = nullptr;\n   OP_REQUIRES_OK(context,\n                  context->allocate_output(restore_index, output_shape, &t));\n \n   if (output_shape.num_elements() == 0) return;\n \n #define READER_COPY(T)                                                \\\n   case DataTypeToEnum<T>::value:                                      \\\n     OP_REQUIRES(context,                                              \\\n                 reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                       t->flat<T>().data()),           \\\n                 errors::InvalidArgument(\"Error copying slice data\")); \\\n     break;\n \n   switch (type) {\n     TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n     default:\n       context->SetStatus(errors::Unimplemented(\n           \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n   }\n #undef READER_COPY\n }\n \n", "target": "// fix_start\n            size, \" elements\"));\n// fix_end\n// fix_start\n  {\n    const int64_t size = tensor_name_t.NumElements();\n    OP_REQUIRES(context, size > restore_index,\n                errors::InvalidArgument(\n                    \"Input 1 (file_pattern) must be a have at least \",\n                    restore_index + 1, \" elements\"));\n  }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-37639", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197466}
{"source": " GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n {\n \tGF_Err e;\n \tu32 NbBits, nbFields;\n \tu32 i;\n \tGF_ChildNodeItem *last;\n \tu8 qp_local, qp_on, initial_qp;\n \tGF_FieldInfo sffield;\n \n \tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n \tsffield.fieldIndex = field->fieldIndex;\n \tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n \tsffield.NDTtype = field->NDTtype;\n \tsffield.name = field->name;\n \n \tinitial_qp = qp_local = qp_on = 0;\n \n \tNbBits = gf_bs_read_int(bs, 5);\n \tnbFields = gf_bs_read_int(bs, NbBits);\n \n \tif (codec->ActiveQP) {\n \t\tinitial_qp = 1;\n \t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n \t}\n \n \tif (field->fieldType != GF_SG_VRML_MFNODE) {\n \t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n \t\tif (e) return e;\n \n \t\tfor (i=0; i<nbFields; i++) {\n \t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n \t\t\tif (e) return e;\n \t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n \t\t\tif (e) return e;\n \t\t}\n// bug_start\n\t} else {\n\t\tlast = NULL;\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n// bug_end\n \n// bug_start\n\t\t\t\tif (node) {\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n// bug_end\n \n// bug_start\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n// bug_end\n \t\t\t\t\t} else {\n// bug_start\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) return e;\n// bug_end\n \t\t\t\t\t}\n// bug_start\n// bug_end\n \t\t\t\t}\n// bug_start\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n// bug_end\n \t\t\t}\n// bug_start\n\t\t}\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n\t\t\t} else {\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n// bug_end\n \t\t\t}\n// bug_start\n// bug_end\n \t\t}\n \t}\n// bug_start\n// bug_end\n \tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n// bug_start\n\treturn GF_OK;\n// bug_end\n }\n \n", "target": "// fix_start\n\t\treturn GF_OK;\n\t}\n// fix_end\n// fix_start\n\te = GF_OK;\n\tlast = NULL;\n\tfor (i=0; i<nbFields; i++) {\n\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) goto exit;\n// fix_end\n// fix_start\n\t\t\tif (node) {\n\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tqp_on = 1;\n\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) goto exit;\n// fix_end\n// fix_start\n\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\tgf_node_unregister(new_node, node);\n// fix_end\n// fix_start\n\t\t\t\t} else {\n\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) goto exit;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\tif (e)goto exit;\n// fix_end\n// fix_start\n\t\t} else {\n\t\t\te = codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n// fix_end\n// fix_start\n\nexit:\n\n\tif (qp_on && qp_local) {\n\t\tif (qp_local == 2) {\n\t\t} else {\n\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n\t\t}\n\t}\n\n// fix_end\n// fix_start\n\treturn e;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-2453", "cve_desc": "Use After Free in GitHub repository gpac/gpac prior to 2.1-DEV.", "project": "gpac", "idx": 197499}
{"source": "// bug_start\nvoid HierarchicalBitmapRequester::PrepareForDecoding(void)\n// bug_end\n {\n #if ACCUSOFT_CODE\n \n// bug_start\n  UBYTE i;\n\n// bug_end\n   BuildCommon();\n \n// bug_start\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n// bug_end\n   }\n \n// bug_start\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n// bug_end\n \n// bug_start\n    for(i = 0;i < m_ucCount;i++) {\n// bug_end\n       class Component *comp = m_pFrame->ComponentOf(i);\n       UBYTE sx = comp->SubXOf();\n       UBYTE sy = comp->SubYOf();\n \n       if (sx > 1 || sy > 1) {\n// bug_start\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n// bug_end\n       }\n     }\n   }\n \n   if (m_pLargestScale)\n// bug_start\n    m_pLargestScale->PrepareForDecoding();\n// bug_end\n #endif\n }\n \n", "target": "// fix_start\nvoid HierarchicalBitmapRequester::PrepareForEncoding(void)\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n  if (m_ppEncodingMCU == NULL) {\n    m_ppEncodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount *8);\n    memset(m_ppEncodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n// fix_end\n// fix_start\n  if (m_ppDownsampler == NULL) {\n    m_ppDownsampler = (class DownsamplerBase **)m_pEnviron->AllocMem(sizeof(class DownsamplerBase *) * m_ucCount);\n    memset(m_ppDownsampler,0,sizeof(class DownsamplerBase *) * m_ucCount);\n// fix_end\n// fix_start\n    for(UBYTE i = 0;i < m_ucCount;i++) {\n// fix_end\n// fix_start\n        m_ppDownsampler[i] = DownsamplerBase::CreateDownsampler(m_pEnviron,sx,sy,\n                                                                m_ulPixelWidth,m_ulPixelHeight,\n                                                                m_pFrame->TablesOf()->\n                                                                isDownsamplingInterpolated());\n        m_bSubsampling     = true;\n// fix_end\n// fix_start\n    m_pLargestScale->PrepareForEncoding();\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-31796", "cve_desc": "libjpeg 1.63 has a heap-based buffer over-read in HierarchicalBitmapRequester::FetchRegion in hierarchicalbitmaprequester.cpp because the MCU size can be different between allocation and use.", "project": "libjpeg", "idx": 197511}
{"source": " static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n   json_t * j_error = json_array(), * j_return;\n   cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n   int i, ret;\n   char * message = NULL;\n   gnutls_pubkey_t pubkey = NULL;\n   gnutls_x509_crt_t cert = NULL;\n   gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n// bug_start\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n// bug_end\n   size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n \n   if (j_error != NULL) {\n     do {\n       if (gnutls_x509_crt_init(&cert)) {\n         json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n         break;\n       }\n       if (gnutls_pubkey_init(&pubkey)) {\n         json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n         break;\n       }\n \n       if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n         json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n         break;\n       }\n       for (i=0; i<2; i++) {\n         key = cbor_map_handle(att_stmt)[i].key;\n         if (cbor_isa_string(key)) {\n           if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key)))) {\n             x5c = cbor_map_handle(att_stmt)[i].value;\n           } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key)))) {\n             sig = cbor_map_handle(att_stmt)[i].value;\n           } else {\n             message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n             json_array_append_new(j_error, json_string(message));\n             o_free(message);\n             break;\n           }\n         } else {\n           message = msprintf(\"attStmt map element %d key is not a string\", i);\n           json_array_append_new(j_error, json_string(message));\n           o_free(message);\n           break;\n         }\n       }\n       if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n         json_array_append_new(j_error, json_string(\"CBOR map value 'x5c' invalid format\"));\n         break;\n       }\n       att_cert = cbor_array_get(x5c, 0);\n       cert_dat.data = cbor_bytestring_handle(att_cert);\n       cert_dat.size = cbor_bytestring_length(att_cert);\n       if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n         json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n         y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n         break;\n       }\n       if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n         json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n         if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n           message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n           y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - %s\", message);\n           o_free(message);\n           gnutls_free(cert_issued_by.data);\n         } else {\n           y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)\");\n         }\n         break;\n       }\n       if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n         json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n         y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n         break;\n       }\n       if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n         json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n         y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n         break;\n       }\n       if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n         json_array_append_new(j_error, json_string(\"Internal error\"));\n         y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n         break;\n       }\n       if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n         json_array_append_new(j_error, json_string(\"Internal error\"));\n         y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n         break;\n       }\n \n       if (sig == NULL || !cbor_isa_bytestring(sig)) {\n         json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n         break;\n       }\n \n// bug_start\n// bug_end\n       data_signed[0] = 0x0;\n       data_signed_offset = 1;\n \n       memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n       data_signed_offset += rpid_hash_len;\n \n       memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n       data_signed_offset+=client_data_hash_len;\n \n       memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n       data_signed_offset+=credential_id_len;\n \n       data_signed[data_signed_offset] = 0x04;\n       data_signed_offset++;\n \n       memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n       data_signed_offset+=cert_x_len;\n \n       memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n       data_signed_offset+=cert_y_len;\n \n       data.data = data_signed;\n       data.size = data_signed_offset;\n \n       signature.data = cbor_bytestring_handle(sig);\n       signature.size = cbor_bytestring_length(sig);\n \n       if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n         json_array_append_new(j_error, json_string(\"Invalid signature\"));\n       }\n \n     } while (0);\n// bug_start\n// bug_end\n \n     if (json_array_size(j_error)) {\n       j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n     } else {\n       j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n     }\n     json_decref(j_error);\n     gnutls_pubkey_deinit(pubkey);\n     gnutls_x509_crt_deinit(cert);\n     if (att_cert != NULL) {\n       cbor_decref(&att_cert);\n     }\n \n   } else {\n     y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error allocating resources for j_error\");\n     j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n   }\n   return j_return;\n }\n \n", "target": "// fix_start\n  unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];\n// fix_end\n// fix_start\n      if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error allocating data_signed\");\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        break;\n      }\n\n// fix_end\n// fix_start\n    o_free(data_signed);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-40818", "cve_desc": "scheme/webauthn.c in Glewlwyd SSO server through 2.5.3 has a buffer overflow during FIDO2 signature validation in webauthn registration.", "project": "glewlwyd", "idx": 197517}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& gradient = ctx->input(0);\n     const Tensor& input = ctx->input(1);\n     Tensor* input_backprop = nullptr;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(0, input.shape(), &input_backprop));\n     OP_REQUIRES(\n         ctx, axis_ >= -1,\n         errors::InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n     OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n                 errors::InvalidArgument(\n                     \"Axis should be -1 or 0 or a positive value less than \",\n                     input.shape().dims(), \"but given axis value was \", axis_));\n \n     OP_REQUIRES(\n         ctx, input.IsSameSize(gradient),\n         errors::InvalidArgument(\"gradient and input must be the same size\"));\n     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n     const Tensor& input_min_tensor = ctx->input(2);\n     OP_REQUIRES(ctx,\n                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,\n                 errors::InvalidArgument(\n// bug_start\n                    \"Input min tensor must have dimension 1. Recieved \",\n// bug_end\n                     input_min_tensor.dims(), \".\"));\n     const Tensor& input_max_tensor = ctx->input(3);\n     OP_REQUIRES(ctx,\n                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,\n                 errors::InvalidArgument(\n// bug_start\n                    \"Input max tensor must have dimension 1. Recieved \",\n// bug_end\n                     input_max_tensor.dims(), \".\"));\n     if (axis_ != -1) {\n       OP_REQUIRES(\n           ctx, input_min_tensor.dim_size(0) == depth,\n           errors::InvalidArgument(\"min has incorrect size, expected \", depth,\n                                   \" was \", input_min_tensor.dim_size(0)));\n       OP_REQUIRES(\n           ctx, input_max_tensor.dim_size(0) == depth,\n           errors::InvalidArgument(\"max has incorrect size, expected \", depth,\n                                   \" was \", input_max_tensor.dim_size(0)));\n     }\n \n     TensorShape min_max_shape(input_min_tensor.shape());\n     Tensor* input_min_backprop;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(1, min_max_shape, &input_min_backprop));\n \n     Tensor* input_max_backprop;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));\n \n     if (axis_ == -1) {\n// bug_start\n// bug_end\n       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;\n       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),\n         input.template flat<T>(), input_min_tensor.scalar<T>(),\n         input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),\n         input_min_backprop->template scalar<T>(),\n         input_max_backprop->template scalar<T>());\n     } else {\n       functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;\n       f(ctx->eigen_device<Device>(),\n         gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n         input.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n         &input_min_tensor, &input_max_tensor,\n         input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),\n         input_min_backprop->template flat<T>(),\n         input_max_backprop->template flat<T>());\n     }\n   }\n \n", "target": "// fix_start\n                    \"Input min tensor must have dimension 0 or 1. Received \",\n// fix_end\n// fix_start\n                    \"Input max tensor must have dimension 0 or 1. Received \",\n// fix_end\n// fix_start\n      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"input_min must be a scalar if axis is unspecified\"));\n      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"input_max must be a scalar if axis is unspecified\"));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-29192", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 197518}
{"source": " static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n     byte wait_type, word16 wait_packet_id, int timeout_ms)\n {\n     int rc;\n     word16 packet_id;\n     MqttPacketType packet_type;\n #ifdef WOLFMQTT_MULTITHREAD\n     MqttPendResp *pendResp;\n     int readLocked;\n #endif\n     MqttMsgStat* mms_stat;\n     int waitMatchFound;\n \n     if (client == NULL || packet_obj == NULL) {\n         return MQTT_CODE_ERROR_BAD_ARG;\n     }\n \n     mms_stat = (MqttMsgStat*)packet_obj;\n \n wait_again:\n \n     packet_id = 0;\n     packet_type = MQTT_PACKET_TYPE_RESERVED;\n #ifdef WOLFMQTT_MULTITHREAD\n     pendResp = NULL;\n     readLocked = 0;\n #endif\n     waitMatchFound = 0;\n \n #ifdef WOLFMQTT_DEBUG_CLIENT\n     PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n         MqttPacket_TypeDesc((MqttPacketType)wait_type),\n             wait_type, wait_packet_id);\n #endif\n \n     switch ((int)*mms_stat)\n     {\n         case MQTT_MSG_BEGIN:\n         {\n         #ifdef WOLFMQTT_MULTITHREAD\n             rc = wm_SemLock(&client->lockRecv);\n             if (rc != 0) {\n                 PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                 return rc;\n             }\n             readLocked = 1;\n         #endif\n \n             client->packet.stat = MQTT_PK_BEGIN;\n         }\n         FALL_THROUGH;\n \n     #ifdef WOLFMQTT_V5\n         case MQTT_MSG_AUTH:\n     #endif\n         case MQTT_MSG_WAIT:\n         {\n         #ifdef WOLFMQTT_MULTITHREAD\n             pendResp = NULL;\n             rc = wm_SemLock(&client->lockClient);\n             if (rc == 0) {\n                 if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type,\n                     wait_packet_id, &pendResp)) {\n                     if (pendResp->packetDone) {\n                         rc = pendResp->packet_ret;\n                     #ifdef WOLFMQTT_DEBUG_CLIENT\n                         PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                     #endif\n                         MqttClient_RespList_Remove(client, pendResp);\n                         wm_SemUnlock(&client->lockClient);\n                         wm_SemUnlock(&client->lockRecv);\n                         return rc;\n                     }\n                 }\n                 wm_SemUnlock(&client->lockClient);\n             }\n             else {\n                 break;\n             }\n         #endif\n \n             *mms_stat = MQTT_MSG_WAIT;\n \n             rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                     timeout_ms);\n             if (rc <= 0) {\n                 break;\n             }\n \n             client->packet.buf_len = rc;\n \n             rc = MqttClient_DecodePacket(client, client->rx_buf,\n                 client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n             if (rc < 0) {\n                 break;\n             }\n \n         #ifdef WOLFMQTT_DEBUG_CLIENT\n             PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                 client->packet.buf_len, packet_type, packet_id);\n         #endif\n \n             *mms_stat = MQTT_MSG_READ;\n         }\n         FALL_THROUGH;\n \n         case MQTT_MSG_READ:\n         case MQTT_MSG_READ_PAYLOAD:\n         {\n             MqttPacketType use_packet_type;\n             void* use_packet_obj;\n \n         #ifdef WOLFMQTT_MULTITHREAD\n             readLocked = 1;\n         #endif\n \n             if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                 packet_type = MQTT_PACKET_TYPE_PUBLISH;\n             }\n \n             if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n// bug_start\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n// bug_end\n             {\n                 use_packet_obj = packet_obj;\n                 waitMatchFound = 1;\n             }\n             else {\n                 use_packet_obj = &client->msg;\n             }\n             use_packet_type = packet_type;\n \n         #ifdef WOLFMQTT_MULTITHREAD\n             pendResp = NULL;\n             rc = wm_SemLock(&client->lockClient);\n             if (rc == 0) {\n                 if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                                &pendResp)) {\n                     pendResp->packetProcessing = 1;\n                     use_packet_obj = pendResp->packet_obj;\n                     use_packet_type = pendResp->packet_type;\n                     waitMatchFound = 0;\n                 }\n                 wm_SemUnlock(&client->lockClient);\n             }\n             else {\n                 break;\n             }\n         #endif\n \n             rc = MqttClient_HandlePacket(client, use_packet_type,\n                 use_packet_obj, timeout_ms);\n \n         #ifdef WOLFMQTT_NONBLOCK\n             if (rc == MQTT_CODE_CONTINUE) {\n                 return rc;\n             }\n         #endif\n \n             if (rc >= 0) {\n                 rc = MQTT_CODE_SUCCESS;\n             }\n \n         #ifdef WOLFMQTT_MULTITHREAD\n             if (pendResp) {\n                 if (wm_SemLock(&client->lockClient) == 0) {\n                     pendResp->packetDone = 1;\n                     pendResp->packet_ret = rc;\n                 #ifdef WOLFMQTT_DEBUG_CLIENT\n                     PRINTF(\"PendResp Done %p\", pendResp);\n                 #endif\n                     pendResp = NULL;\n                     wm_SemUnlock(&client->lockClient);\n                 }\n             }\n         #endif\n             break;\n         }\n \n         case MQTT_MSG_WRITE:\n         case MQTT_MSG_WRITE_PAYLOAD:\n         default:\n         {\n         #ifdef WOLFMQTT_DEBUG_CLIENT\n             PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n         #endif\n             rc = MQTT_CODE_ERROR_STAT;\n             break;\n         }\n     }\n \n #ifdef WOLFMQTT_NONBLOCK\n     if (rc != MQTT_CODE_CONTINUE)\n #endif\n     {\n         *mms_stat = MQTT_MSG_BEGIN;\n     }\n \n #ifdef WOLFMQTT_MULTITHREAD\n     if (readLocked) {\n         wm_SemUnlock(&client->lockRecv);\n     }\n #endif\n     if (rc < 0) {\n     #ifdef WOLFMQTT_DEBUG_CLIENT\n         PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n             MqttClient_ReturnCodeToString(rc), rc);\n     #endif\n         return rc;\n     }\n \n     if (!waitMatchFound) {\n         goto wait_again;\n     }\n \n     return rc;\n }\n \n", "target": "// fix_start\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-45936", "cve_desc": "wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttDecode_Disconnect (called from MqttClient_DecodePacket and MqttClient_WaitType).", "project": "wolfMQTT", "idx": 197565}
{"source": " njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n {\n     size_t              value_count, n;\n     njs_value_t         *start, *end, *p, **new, *value, **local;\n     njs_function_t      *function;\n     njs_native_frame_t  *active, *native;\n \n     *frame = *vm->active_frame;\n// bug_start\n// bug_end\n     frame->previous_active_frame = NULL;\n \n     native = &frame->native;\n// bug_start\n// bug_end\n \n     active = &vm->active_frame->native;\n     value_count = njs_function_frame_value_count(active);\n \n     function = active->function;\n \n     new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n     value = (njs_value_t *) (new + value_count\n                              + function->u.lambda->temp);\n \n \n     native->arguments = value;\n     native->arguments_offset = value + (function->args_offset - 1);\n     native->local = new + njs_function_frame_args_count(active);\n     native->temp = new + value_count;\n     native->pc = pc;\n \n     start = njs_function_frame_values(active, &end);\n     p = native->arguments;\n \n     while (start < end) {\n         *p = *start++;\n         *new++ = p++;\n     }\n \n \n     p = native->arguments;\n     local = native->local + function->args_offset;\n \n     for (n = 0; n < function->args_count; n++) {\n         if (!njs_is_valid(p)) {\n             njs_set_undefined(p);\n         }\n \n         *local++ = p++;\n     }\n \n     return NJS_OK;\n }\n \n", "target": "// fix_start\n\n// fix_end\n// fix_start\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-27007", "cve_desc": "nginx njs 0.7.2 is affected suffers from Use-after-free in njs_function_frame_alloc() when it try to invoke from a restored frame saved with njs_function_frame_save().", "project": "njs", "idx": 197593}
{"source": " njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n     njs_iterator_handler_t handler)\n {\n     double              idx;\n     int64_t             i, from, to, length;\n     njs_int_t           ret;\n     njs_array_t         *array, *keys;\n     njs_value_t         *entry, *value, prop, character, string_obj;\n     const u_char        *p, *end, *pos;\n     njs_string_prop_t   string_prop;\n     njs_object_value_t  *object;\n \n     value = args->value;\n     from = args->from;\n     to = args->to;\n \n     if (njs_is_array(value)) {\n         array = njs_array(value);\n \n         from += 1;\n \n         while (from-- > to) {\n             if (njs_slow_path(!array->object.fast_array)) {\n                 goto process_object;\n             }\n \n             if (njs_fast_path(from < array->length\n                               && njs_is_valid(&array->start[from])))\n             {\n                 ret = handler(vm, args, &array->start[from], from);\n \n             } else {\n                 entry = njs_value_arg(&njs_value_invalid);\n                 ret = njs_value_property_i64(vm, value, from, &prop);\n                 if (njs_slow_path(ret != NJS_DECLINED)) {\n                     if (ret == NJS_ERROR) {\n                         return NJS_ERROR;\n                     }\n \n                     entry = &prop;\n                 }\n \n                 ret = handler(vm, args, entry, from);\n             }\n \n             if (njs_slow_path(ret != NJS_OK)) {\n                 if (ret == NJS_DONE) {\n                     return NJS_DONE;\n                 }\n \n                 return NJS_ERROR;\n             }\n         }\n \n         return NJS_OK;\n     }\n \n     if (njs_is_string(value) || njs_is_object_string(value)) {\n \n         if (njs_is_string(value)) {\n             object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n             if (njs_slow_path(object == NULL)) {\n                 return NJS_ERROR;\n             }\n \n             njs_set_object_value(&string_obj, object);\n \n             args->value = &string_obj;\n         }\n         else {\n             value = njs_object_value(value);\n         }\n \n         length = njs_string_prop(&string_prop, value);\n         end = string_prop.start + string_prop.size;\n \n         if ((size_t) length == string_prop.size) {\n \n             p = string_prop.start + from;\n \n             i = from + 1;\n \n             while (i-- > to) {\n                 (void) njs_string_new(vm, &character, p, 1, 1);\n \n                 ret = handler(vm, args, &character, i);\n                 if (njs_slow_path(ret != NJS_OK)) {\n                     if (ret == NJS_DONE) {\n                         return NJS_DONE;\n                     }\n \n                     return NJS_ERROR;\n                 }\n \n                 p--;\n             }\n \n         } else {\n \n// bug_start\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n// bug_end\n \n// bug_start\n            i = from + 1;\n// bug_end\n \n             while (i-- > to) {\n                 pos = njs_utf8_prev(p);\n \n                 (void) njs_string_new(vm, &character, pos, p - pos , 1);\n \n                 ret = handler(vm, args, &character, i);\n                 if (njs_slow_path(ret != NJS_OK)) {\n                     if (ret == NJS_DONE) {\n                         return NJS_DONE;\n                     }\n \n                     return NJS_ERROR;\n                 }\n \n                 p = pos;\n             }\n         }\n \n         return NJS_OK;\n     }\n \n     if (!njs_is_object(value)) {\n         return NJS_OK;\n     }\n \n process_object:\n \n     if (!njs_fast_object(from - to)) {\n         keys = njs_array_indices(vm, value);\n         if (njs_slow_path(keys == NULL)) {\n             return NJS_ERROR;\n         }\n \n         i = keys->length;\n \n         while (i > 0) {\n             idx = njs_string_to_index(&keys->start[--i]);\n \n             if (idx < to || idx > from) {\n                 continue;\n             }\n \n             ret = njs_iterator_object_handler(vm, handler, args,\n                                               &keys->start[i], idx);\n             if (njs_slow_path(ret != NJS_OK)) {\n                 njs_array_destroy(vm, keys);\n                 return ret;\n             }\n         }\n \n         njs_array_destroy(vm, keys);\n \n         return NJS_OK;\n     }\n \n     i = from + 1;\n \n     while (i-- > to) {\n         ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n         if (njs_slow_path(ret != NJS_OK)) {\n             return ret;\n         }\n     }\n \n     return NJS_OK;\n }\n \n", "target": "// fix_start\n            p = NULL;\n            i = from + 1;\n// fix_end\n// fix_start\n            if (i > to) {\n                p = njs_string_offset(string_prop.start, end, from);\n                p = njs_utf8_next(p, end);\n            }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-31307", "cve_desc": "Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the function njs_string_offset at src/njs_string.c.", "project": "njs", "idx": 197666}
{"source": "   void Compute(OpKernelContext* context) override {\n     OpInputList ragged_nested_splits_in;\n     OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                 &ragged_nested_splits_in));\n     const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n     RaggedTensorVariant batched_ragged_input;\n     batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n     batched_ragged_input.mutable_nested_splits()->reserve(\n         ragged_nested_splits_len);\n     for (int i = 0; i < ragged_nested_splits_len; i++) {\n       batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n     }\n \n     if (!batched_input_) {\n       Tensor* encoded_scalar;\n       OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                        &encoded_scalar));\n       encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n       return;\n     }\n \n// bug_start\n// bug_end\n     std::vector<RaggedTensorVariant> unbatched_ragged_input;\n     auto batched_splits_top_vec =\n         batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n     int num_components = batched_splits_top_vec.size() - 1;\n     OP_REQUIRES(context, num_components >= 0,\n                 errors::Internal(\"Invalid split argument.\"));\n     OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                 batched_ragged_input, &unbatched_ragged_input));\n \n     Tensor* encoded_vector;\n     int output_size = unbatched_ragged_input.size();\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(0, TensorShape({output_size}),\n                                             &encoded_vector));\n     auto encoded_vector_t = encoded_vector->vec<Variant>();\n     for (int i = 0; i < output_size; i++) {\n       encoded_vector_t(i) = unbatched_ragged_input[i];\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(context, ragged_nested_splits_len > 0,\n                errors::InvalidArgument(\n                    \"rt_nested_splits must be a list of one or more, but \"\n                    \"received rt_nested_splits of length 0.\"));\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-37666", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToVariant`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L129) has an incomplete validation of the splits values, missing the case when the argument would be empty. We have patched the issue in GitHub commit be7a4de6adfbd303ce08be4332554dff70362612. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197719}
{"source": " Status TransposeShapeFn(InferenceContext* c) {\n   ShapeHandle input = c->input(0);\n   ShapeHandle perm_shape = c->input(1);\n   const Tensor* perm = c->input_tensor(1);\n   DimensionHandle perm_elems = c->NumElements(perm_shape);\n   if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n     c->set_output(0, c->UnknownShape());\n     return Status::OK();\n   }\n \n   int64_t rank;\n   if (c->RankKnown(input)) {\n     rank = c->Rank(input);\n   } else if (c->ValueKnown(perm_elems)) {\n     rank = c->Value(perm_elems);\n   } else {\n     rank = perm->NumElements();\n   }\n   if (!c->RankKnown(input) && rank < 2) {\n     c->set_output(0, input);\n     return Status::OK();\n   }\n \n   std::vector<DimensionHandle> dims;\n   dims.resize(rank);\n   TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n   TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n   TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n \n   if (perm != nullptr) {\n     std::vector<int64_t> data;\n     if (perm->dtype() == DT_INT32) {\n       data = AsInt64<int32>(perm, rank);\n     } else {\n       data = AsInt64<int64_t>(perm, rank);\n     }\n \n     for (int32_t i = 0; i < rank; ++i) {\n       int64_t in_idx = data[i];\n// bug_start\n      if (in_idx >= rank) {\n// bug_end\n         return errors::InvalidArgument(\"perm dim \", in_idx,\n                                        \" is out of range of input rank \", rank);\n       }\n       dims[i] = c->Dim(input, in_idx);\n     }\n   } else {\n     for (int i = 0; i < rank; ++i) {\n       dims[i] = c->UnknownDim();\n     }\n   }\n \n   c->set_output(0, c->MakeShape(dims));\n   return Status::OK();\n }\n \n", "target": "// fix_start\n      if (in_idx >= rank || in_idx <= -rank) {\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-41216", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197748}
{"source": " TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                           const TfLiteTensor* indices, TfLiteTensor* output) {\n// bug_start\n// bug_end\n   switch (params->type) {\n     case kTfLiteFloat32:\n       return GatherNd<float, IndicesT>(params, indices, output);\n     case kTfLiteUInt8:\n       return GatherNd<uint8_t, IndicesT>(params, indices, output);\n     case kTfLiteInt8:\n       return GatherNd<int8_t, IndicesT>(params, indices, output);\n     case kTfLiteInt16:\n       return GatherNd<int16_t, IndicesT>(params, indices, output);\n     case kTfLiteInt32:\n       return GatherNd<int32_t, IndicesT>(params, indices, output);\n     case kTfLiteInt64:\n       return GatherNd<int64_t, IndicesT>(params, indices, output);\n     case kTfLiteString:\n       return GatherNdString<IndicesT>(params, indices, output);\n     default:\n       context->ReportError(context,\n                            \"Params type '%s' are not supported by gather_nd.\",\n                            TfLiteTypeGetName(params->type));\n       return kTfLiteError;\n   }\n }\n \n", "target": "// fix_start\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-37687", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197760}
{"source": " static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n {\n     int i;\n     uint16_t limit;\n     VncDisplay *vd = vs->vd;\n \n     if (data[0] > 3) {\n         update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n     }\n \n     switch (data[0]) {\n     case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n         if (len == 1)\n             return 20;\n \n         set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                          read_u8(data, 6), read_u8(data, 7),\n                          read_u16(data, 8), read_u16(data, 10),\n                          read_u16(data, 12), read_u8(data, 14),\n                          read_u8(data, 15), read_u8(data, 16));\n         break;\n     case VNC_MSG_CLIENT_SET_ENCODINGS:\n         if (len == 1)\n             return 4;\n \n         if (len == 4) {\n             limit = read_u16(data, 2);\n             if (limit > 0)\n                 return 4 + (limit * 4);\n         } else\n             limit = read_u16(data, 2);\n \n         for (i = 0; i < limit; i++) {\n             int32_t val = read_s32(data, 4 + (i * 4));\n             memcpy(data + 4 + (i * 4), &val, sizeof(val));\n         }\n \n         set_encodings(vs, (int32_t *)(data + 4), limit);\n         break;\n     case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n         if (len == 1)\n             return 10;\n \n         framebuffer_update_request(vs,\n                                    read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                    read_u16(data, 6), read_u16(data, 8));\n         break;\n     case VNC_MSG_CLIENT_KEY_EVENT:\n         if (len == 1)\n             return 8;\n \n         key_event(vs, read_u8(data, 1), read_u32(data, 4));\n         break;\n     case VNC_MSG_CLIENT_POINTER_EVENT:\n         if (len == 1)\n             return 6;\n \n         pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n         break;\n     case VNC_MSG_CLIENT_CUT_TEXT:\n// bug_start\n        if (len == 1)\n// bug_end\n             return 8;\n// bug_start\n\n// bug_end\n         if (len == 8) {\n             uint32_t dlen = read_u32(data, 4);\n// bug_start\n            if (dlen > 0)\n// bug_end\n                 return 8 + dlen;\n// bug_start\n// bug_end\n         }\n \n         client_cut_text(vs, read_u32(data, 4), data + 8);\n         break;\n     case VNC_MSG_CLIENT_QEMU:\n         if (len == 1)\n             return 2;\n \n         switch (read_u8(data, 1)) {\n         case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n             if (len == 2)\n                 return 12;\n \n             ext_key_event(vs, read_u16(data, 2),\n                           read_u32(data, 4), read_u32(data, 8));\n             break;\n         case VNC_MSG_CLIENT_QEMU_AUDIO:\n             if (len == 2)\n                 return 4;\n \n             switch (read_u16 (data, 2)) {\n             case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                 audio_add(vs);\n                 break;\n             case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                 audio_del(vs);\n                 break;\n             case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                 if (len == 4)\n                     return 10;\n                 switch (read_u8(data, 4)) {\n                 case 0: vs->as.fmt = AUD_FMT_U8; break;\n                 case 1: vs->as.fmt = AUD_FMT_S8; break;\n                 case 2: vs->as.fmt = AUD_FMT_U16; break;\n                 case 3: vs->as.fmt = AUD_FMT_S16; break;\n                 case 4: vs->as.fmt = AUD_FMT_U32; break;\n                 case 5: vs->as.fmt = AUD_FMT_S32; break;\n                 default:\n                     printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                     vnc_client_error(vs);\n                     break;\n                 }\n                 vs->as.nchannels = read_u8(data, 5);\n                 if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                     printf(\"Invalid audio channel coount %d\\n\",\n                            read_u8(data, 5));\n                     vnc_client_error(vs);\n                     break;\n                 }\n                 vs->as.freq = read_u32(data, 6);\n                 break;\n             default:\n                 printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n                 vnc_client_error(vs);\n                 break;\n             }\n             break;\n \n         default:\n             printf(\"Msg: %d\\n\", read_u16(data, 0));\n             vnc_client_error(vs);\n             break;\n         }\n         break;\n     default:\n         printf(\"Msg: %d\\n\", data[0]);\n         vnc_client_error(vs);\n         break;\n     }\n \n     vnc_read_when(vs, protocol_client_msg, 1);\n     return 0;\n }\n \n", "target": "// fix_start\n        if (len == 1) {\n// fix_end\n// fix_start\n        }\n// fix_end\n// fix_start\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n// fix_end\n// fix_start\n            }\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2015-5239", "cve_desc": "Integer overflow in the VNC display driver in QEMU before 2.1.0 allows attachers to cause a denial of service (process crash) via a CLIENT_CUT_TEXT message, which triggers an infinite loop.", "project": "qemu", "idx": 197796}
{"source": " bool TensorSliceReader::CopySliceData(const string& name,\n                                       const TensorSlice& slice, T* data) const {\n   std::vector<std::pair<TensorSlice, string>> details;\n   const TensorSliceSet* tss;\n   {\n     mutex_lock l(mu_);\n     tss = FindTensorSlice(name, slice, &details);\n     if (!tss && !all_shards_loaded_) {\n       VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n               << name << \": \" << slice.DebugString();\n       LoadAllShards();\n       tss = FindTensorSlice(name, slice, &details);\n     }\n     if (!tss) {\n       return false;\n     }\n   }\n   string value;\n   for (const auto& x : details) {\n     const TensorSlice& slice_s = x.first;\n     const string& fname = x.second;\n     int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n     CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n     const string key = EncodeTensorNameSlice(name, slice_s);\n     if (!sss_[idx]->Get(key, &value)) {\n       VLOG(1) << \"Failed to seek to the record for tensor \" << name\n               << \", slice \" << slice_s.DebugString()\n               << \": computed key = \" << key;\n       return false;\n     }\n     SavedTensorSlices sts;\n     if (!ParseProtoUnlimited(&sts, value)) {\n       VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n               << slice_s.DebugString() << \": computed key = \" << key;\n       return false;\n     }\n// bug_start\n// bug_end\n     CopyDataFromTensorSliceToTensorSlice(\n         tss->shape(), slice_s, slice,\n         checkpoint::TensorProtoData<T>(sts.data().data()), data);\n   }\n   return true;\n }\n \n", "target": "// fix_start\n    TensorShape shp_s;\n    Status s = slice_s.SliceTensorShape(tss->shape(), &shp_s);\n    if (!s.ok()) {\n      VLOG(1) << \"Failed to slice tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": \" << s;\n      return false;\n    }\n    if (checkpoint::TensorProtoDataSize<T>(sts.data().data()) !=\n        shp_s.num_elements()) {\n      VLOG(1) << \"Tensor \" << name << \", slice \" << slice_s.DebugString()\n              << \" had an unexpected amount of data: expected = \"\n              << shp_s.num_elements() << \", got = \"\n              << checkpoint::TensorProtoDataSize<T>(sts.data().data());\n      return false;\n    }\n// fix_end\n", "cwe": "CWE-345", "cwe_name": "Insufficient Verification of Data Authenticity", "cve": "CVE-2021-41203", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197801}
{"source": " static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n {\n \tGF_Node *node;\n \tGF_Command *com;\n \tGF_CommandField *inf;\n \tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n \tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n \n \tif (codec->scenegraph->global_qp) {\n \t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n \t}\n \tcodec->ActiveQP = NULL;\n \tcodec->scenegraph->global_qp = NULL;\n \n \tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n// bug_start\n\t\tgf_node_unregister(node, NULL);\n// bug_end\n \t\treturn GF_NON_COMPLIANT_BITSTREAM;\n \t}\n \n \tcodec->ActiveQP = (M_QuantizationParameter *) node;\n \tcodec->ActiveQP->isLocal = 0;\n \tcodec->scenegraph->global_qp = node;\n \n// bug_start\n\tnode->sgprivate->num_instances = 2;\n// bug_end\n \n \tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n \tinf = gf_sg_command_field_new(com);\n \tinf->new_node = node;\n \tinf->field_ptr = &inf->new_node;\n \tinf->fieldType = GF_SG_VRML_SFNODE;\n \tgf_list_add(com_list, com);\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\tif (!node->sgprivate->num_instances) {\n\t\t\tnode->sgprivate->num_instances = 1;\n\t\t\tgf_node_unregister(node, NULL);\n\t\t}\n// fix_end\n// fix_start\n\tgf_node_unregister(node, NULL);\n\tgf_node_unregister(node, NULL);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-1795", "cve_desc": "Use After Free in GitHub repository gpac/gpac prior to v2.1.0-DEV.", "project": "gpac", "idx": 197824}
{"source": " bool IsConstantFoldable(\n     const Node* n,\n     const std::unordered_map<string, std::vector<PartialTensorShape>>*\n         shape_map,\n     const std::function<bool(const Node*)>& consider,\n     int64_t max_constant_size_in_bytes,\n     std::unordered_map<const Node*, std::vector<Tensor>>*\n         shape_replacement_map) {\n   if (n->IsConstant()) {\n// bug_start\n    return true;\n// bug_end\n   }\n   if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n     return true;\n   }\n   if (n->op_def().is_stateful()) {\n     return false;\n   }\n   if (consider && !consider(n)) {\n     return false;\n   }\n   if (shape_map != nullptr) {\n     auto shape_it = shape_map->find(n->name());\n     if (shape_it != shape_map->end()) {\n       for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n         const auto& out_shape = shape_it->second[i];\n         if (out_shape.IsFullyDefined() &&\n             out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                 max_constant_size_in_bytes) {\n           return false;\n         }\n       }\n     }\n   }\n   if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n     return false;\n   }\n   if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n       n->IsDeleteSessionTensor()) {\n     return false;\n   }\n   if (n->IsSource()) {\n     return false;\n   }\n   if (n->IsSink()) {\n     return false;\n   }\n   if (n->IsFakeParam()) {\n     return false;\n   }\n   if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n     return false;\n   }\n   if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n     VLOG(2) << \"Skip node [\" << n->DebugString()\n             << \"] for constant folding due to scoped allocator\";\n     return false;\n   }\n   return true;\n }\n \n", "target": "// fix_start\n    return n->output_type(0) != DT_RESOURCE;\n// fix_end\n", "cwe": "CWE-824", "cwe_name": "Access of Uninitialized Pointer", "cve": "CVE-2021-41204", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions during TensorFlow's Grappler optimizer phase, constant folding might attempt to deep copy a resource tensor. This results in a segfault, as these tensors are supposed to not change. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197826}
{"source": "// bug_start\nTfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n// bug_end\n   tflite::GatherParams op_params;\n   op_params.axis = params.axis;\n   op_params.batch_dims = params.batch_dims;\n   optimized_ops::Gather(op_params, GetTensorShape(input),\n                         GetTensorData<InputT>(input), GetTensorShape(positions),\n                         GetTensorData<PositionsT>(positions),\n                         GetTensorShape(output), GetTensorData<InputT>(output));\n   return kTfLiteOk;\n }\n \n", "target": "// fix_start\nTfLiteStatus Gather(TfLiteContext* context, const TfLiteGatherParams& params,\n                    const TfLiteTensor* input, const TfLiteTensor* positions,\n                    TfLiteTensor* output) {\n  const PositionsT* indexes = GetTensorData<PositionsT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionsT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-37687", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197893}
{"source": " crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n {\n   int first_arg = 0, ret = 0;\n   libcrun_context_t crun_context = {\n     0,\n   };\n   cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n   struct libcrun_container_exec_options_s exec_opts;\n \n   memset (&exec_opts, 0, sizeof (exec_opts));\n   exec_opts.struct_size = sizeof (exec_opts);\n \n   crun_context.preserve_fds = 0;\n   crun_context.listen_fds = 0;\n \n   argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n   crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n \n   ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n   if (UNLIKELY (ret < 0))\n     return ret;\n \n   crun_context.detach = exec_options.detach;\n   crun_context.console_socket = exec_options.console_socket;\n   crun_context.pid_file = exec_options.pid_file;\n   crun_context.preserve_fds = exec_options.preserve_fds;\n \n   if (getenv (\"LISTEN_FDS\"))\n     {\n       crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n       crun_context.preserve_fds += crun_context.listen_fds;\n     }\n \n   if (exec_options.process)\n     exec_opts.path = exec_options.process;\n   else\n     {\n       process = xmalloc0 (sizeof (*process));\n       int i;\n \n       process->args_len = argc;\n       process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n       for (i = 0; i < argc - first_arg; i++)\n         process->args[i] = xstrdup (argv[first_arg + i + 1]);\n       process->args[i] = NULL;\n       if (exec_options.cwd)\n         process->cwd = exec_options.cwd;\n       process->terminal = exec_options.tty;\n       process->env = exec_options.env;\n       process->env_len = exec_options.env_size;\n       process->user = make_oci_process_user (exec_options.user);\n \n       if (exec_options.process_label != NULL)\n         process->selinux_label = exec_options.process_label;\n \n       if (exec_options.apparmor != NULL)\n         process->apparmor_profile = exec_options.apparmor;\n \n       if (exec_options.cap_size > 0)\n         {\n           runtime_spec_schema_config_schema_process_capabilities *capabilities\n               = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n \n           capabilities->effective = exec_options.cap;\n           capabilities->effective_len = exec_options.cap_size;\n \n// bug_start\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n// bug_end\n \n           capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n           capabilities->bounding_len = exec_options.cap_size;\n \n           capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n           capabilities->ambient_len = exec_options.cap_size;\n \n           capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n           capabilities->permitted_len = exec_options.cap_size;\n \n           process->capabilities = capabilities;\n         }\n \n       if (exec_options.no_new_privs)\n         process->no_new_privileges = 1;\n \n       exec_opts.process = process;\n     }\n \n   exec_opts.cgroup = exec_options.cgroup;\n \n   return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n }\n \n", "target": "// fix_start\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n// fix_end\n", "cwe": "CWE-276", "cwe_name": "Incorrect Default Permissions", "cve": "CVE-2022-27650", "cve_desc": "A flaw was found in crun where containers were incorrectly started with non-empty default permissions. A vulnerability was found in Moby (Docker Engine) where containers were started incorrectly with non-empty inheritable Linux process capabilities. This flaw allows an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs.", "project": "crun", "idx": 197973}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& input = context->input(0);\n     const TensorShape& input_shape = input.shape();\n     const int32 input_dims = input_shape.dims();\n \n     const Tensor& segment_id = context->input(1);\n     const TensorShape& segment_id_shape = segment_id.shape();\n     const int32 segment_dims = segment_id_shape.dims();\n \n     const Tensor& num_segments_tensor = context->input(2);\n// bug_start\n// bug_end\n     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n \n     OP_REQUIRES(context, segment_dims != 0,\n                 errors::InvalidArgument(\"Segment_id cannot have rank 0\"));\n \n     OP_REQUIRES(\n         context, segment_dims <= input_dims,\n         errors::OutOfRange(\"Invalid segment_id rank \", segment_dims,\n                            \" for input with \", input_dims, \" dimension(s)\"));\n     for (auto i = 0; i < segment_dims; i++) {\n       OP_REQUIRES(\n           context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),\n           errors::InvalidArgument(\n               \"Segment dimension is \", segment_id_shape.dim_size(i),\n               \" while input dimension is \", input_dims, \" in rank \", i));\n     }\n \n     Tensor* output_tensor = nullptr;\n     TensorShape output_shape =\n         GetOutputShape(input_shape, segment_id_shape, num_segments);\n     OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                      &output_tensor));\n \n     auto output_flat = output_tensor->flat<tstring>();\n     auto flat_segment_id = segment_id.flat<INDICES_TYPE>();\n     auto flat_input = input.flat<tstring>();\n \n     for (int i = 0; i < flat_segment_id.size(); i++) {\n       OP_REQUIRES(\n           context,\n           ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),\n           errors::InvalidArgument(\n               \"segment_ids are not allowed to exceed num_segments or\"\n               \" to have negative values.\"));\n     }\n \n     int64 big_stride;\n     int64 small_stride;\n     std::tie(big_stride, small_stride) =\n         GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);\n     auto relative_offset_set =\n         GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);\n     for (auto start_offset = 0; start_offset < big_stride; start_offset++) {\n       for (auto i = 0; i < relative_offset_set.size(); i++) {\n         auto output_index = start_offset + flat_segment_id(i) * big_stride;\n         auto offset = start_offset + relative_offset_set[i];\n         if (output_flat(output_index).length() != 0)\n           output_flat(output_index).append(separator_.c_str());\n         output_flat(output_index).append(flat_input(offset));\n       }\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,\n                errors::InvalidArgument(\"Number of segments cannot be empty.\"));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-29552", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by controlling the values of `num_segments` tensor argument for `UnsortedSegmentJoin`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a2a607db15c7cd01d754d37e5448d72a13491bdb/tensorflow/core/kernels/unsorted_segment_join_op.cc#L92-L93) assumes that the `num_segments` tensor is a valid scalar. Since the tensor is empty the `CHECK` involved in `.scalar<T>()()` that checks that the number of elements is exactly 1 will be invalidated and this would result in process termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197998}
{"source": " static int string_scan_range(RList *list, RBinFile *bf, int min,\n \t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n \tRBin *bin = bf->rbin;\n \tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n \tut64 str_start, needle = from;\n \tint count = 0, i, rc, runes;\n \tint str_type = R_STRING_TYPE_DETECT;\n \n \tr_return_val_if_fail (bf, -1);\n \n \tif (type == -1) {\n \t\ttype = R_STRING_TYPE_DETECT;\n \t}\n \tif (from == to) {\n \t\treturn 0;\n \t}\n \tif (from > to) {\n \t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n \t\treturn -1;\n \t}\n \tst64 len = (st64)(to - from);\n \tif (len < 1 || len > ST32_MAX) {\n \t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n \t\treturn -1;\n \t}\n \tut8 *buf = calloc (len, 1);\n \tif (!buf || !min) {\n \t\tfree (buf);\n \t\treturn -1;\n \t}\n \tst64 vdelta = 0, pdelta = 0;\n \tRBinSection *s = NULL;\n \tbool ascii_only = false;\n \tPJ *pj = NULL;\n \tif (bf->strmode == R_MODE_JSON && !list) {\n \t\tpj = pj_new ();\n \t\tif (pj) {\n \t\t\tpj_a (pj);\n \t\t}\n \t}\n \tr_buf_read_at (bf->buf, from, buf, len);\n \tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n \tif (!R_STR_ISEMPTY (charset)) {\n \t\tRCharset *ch = r_charset_new ();\n \t\tif (r_charset_use (ch, charset)) {\n \t\t\tint outlen = len * 4;\n \t\t\tut8 *out = calloc (len, 4);\n \t\t\tif (out) {\n \t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n \t\t\t\tint i;\n \t\t\t\tfor (i = 0; i < res; i++) {\n \t\t\t\t\tif (out[i] == '?') {\n \t\t\t\t\t\tout[i] = 0;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tlen = res;\n \t\t\t\tfree (buf);\n \t\t\t\tbuf = out;\n \t\t\t} else {\n \t\t\t\teprintf (\"Cannot allocate\\n\");\n \t\t\t}\n \t\t} else {\n \t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n \t\t}\n \t\tr_charset_free (ch);\n \t}\n \tfree (charset);\n \tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n// bug_start\n\twhile (needle < to) {\n// bug_end\n \t\tif (is_breaked && is_breaked ()) {\n \t\t\tbreak;\n \t\t}\n// bug_start\n\t\tif (needle + 4 < to) {\n\t\t\tut32 n1 = r_read_le32 (buf + needle - from);\n// bug_end\n \t\t\tif (!n1) {\n \t\t\t\tneedle += 4;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n// bug_start\n\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n// bug_end\n \t\tif (!rc) {\n \t\t\tneedle++;\n \t\t\tcontinue;\n \t\t}\n \t\tbool addr_aligned = !(needle % 4);\n \n \t\tif (type == R_STRING_TYPE_DETECT) {\n// bug_start\n\t\t\tchar *w = (char *)buf + needle + rc - from;\n// bug_end\n \t\t\tif (((to - needle) > 8 + rc)) {\n \t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n \t\t\t\tif (is_wide32le) {\n \t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n \t\t\t\t\t\tis_wide32le = false;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (!addr_aligned) {\n \t\t\t\t\tis_wide32le = false;\n \t\t\t\t}\n \t\t\t\tif (is_wide32le  && addr_aligned) {\n \t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n \t\t\t\t} else {\n \t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n \t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (rc > 1) {\n \t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n \t\t\t\t} else {\n \t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n \t\t\t\t}\n \t\t\t}\n \t\t} else if (type == R_STRING_TYPE_UTF8) {\n \t\t\tstr_type = R_STRING_TYPE_ASCII;\n \t\t} else {\n \t\t\tstr_type = type;\n \t\t}\n \t\trunes = 0;\n \t\tstr_start = needle;\n \n \t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n \t\t\tRRune r = {0};\n \t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n \t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n \t\t\t\tif (rc) {\n \t\t\t\t\trc = 4;\n \t\t\t\t}\n \t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n \t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n \t\t\t\tif (rc == 1) {\n \t\t\t\t\trc = 2;\n \t\t\t\t}\n \t\t\t} else {\n// bug_start\n\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n// bug_end\n \t\t\t\tif (rc > 1) {\n \t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n \t\t\t\tneedle++;\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tneedle += rc;\n \n \t\t\tif (r_isprint (r) && r != '\\\\') {\n \t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n \t\t\t\t\tif (r == 0xff) {\n \t\t\t\t\t\tr = 0;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\trc = r_utf8_encode (tmp + i, r);\n \t\t\t\trunes++;\n \t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n \t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n \t\t\t\t\ttmp[i + 0] = '\\\\';\n \t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n \t\t\t\t\t             \"                              \"\n \t\t\t\t\t             \"                              \"\n \t\t\t\t\t             \"  \\\\\"[r];\n \t\t\t\t} else {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\trc = 2;\n \t\t\t\trunes++;\n \t\t\t} else {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\ttmp[i++] = '\\0';\n \n \t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n \t\t\tneedle -= 2;\n \t\t}\n \t\tif (runes >= min) {\n \t\t\tint j, num_blocks, *block_list;\n \t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n \t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n \t\t\t\tfor (j = 0; j < i; j++) {\n \t\t\t\t\tchar ch = tmp[j];\n \t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n \t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tswitch (str_type) {\n \t\t\tcase R_STRING_TYPE_UTF8:\n \t\t\tcase R_STRING_TYPE_WIDE:\n \t\t\tcase R_STRING_TYPE_WIDE32:\n \t\t\t\tnum_blocks = 0;\n \t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n \t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n \t\t\t\tif (block_list) {\n \t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n \t\t\t\t\t\tnum_blocks++;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (freq_list) {\n \t\t\t\t\tnum_chars = 0;\n \t\t\t\t\tactual_ascii = 0;\n \t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n \t\t\t\t\t\tnum_chars += freq_list[j];\n \t\t\t\t\t\tif (!block_list[j]) {\n \t\t\t\t\t\t\tactual_ascii = freq_list[j];\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfree (freq_list);\n \t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n \t\t\t\t\tif (actual_ascii > expected_ascii) {\n \t\t\t\t\t\tascii_only = true;\n \t\t\t\t\t\tneedle = str_start;\n \t\t\t\t\t\tfree (block_list);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfree (block_list);\n \t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n \t\t\t\t\tneedle++;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \t\t\tRBinString *bs = R_NEW0 (RBinString);\n \t\t\tif (!bs) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tbs->type = str_type;\n \t\t\tbs->length = runes;\n \t\t\tbs->size = needle - str_start;\n \t\t\tbs->ordinal = count++;\n \t\t\tswitch (str_type) {\n \t\t\tcase R_STRING_TYPE_WIDE:\n \t\t\t\tif (str_start - from > 1) {\n \t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n \t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n \t\t\t\t\t\tstr_start -= 2;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase R_STRING_TYPE_WIDE32:\n \t\t\t\tif (str_start - from > 3) {\n \t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n \t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n \t\t\t\t\t\tstr_start -= 4;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tif (!s) {\n \t\t\t\tif (section) {\n \t\t\t\t\ts = section;\n \t\t\t\t} else if (bf->o) {\n \t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n \t\t\t\t}\n \t\t\t\tif (s) {\n \t\t\t\t\tvdelta = s->vaddr;\n \t\t\t\t\tpdelta = s->paddr;\n \t\t\t\t}\n \t\t\t}\n \t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n \t\t\tbs->paddr = str_start + baddr;\n \t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n \t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n \t\t\tif (list) {\n \t\t\t\tr_list_append (list, bs);\n \t\t\t\tif (bf->o) {\n \t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tprint_string (bf, bs, raw, pj);\n \t\t\t\tr_bin_string_free (bs);\n \t\t\t}\n \t\t\tif (from == 0 && to == bf->size) {\n \t\t\t\ts = NULL;\n \t\t\t}\n \t\t}\n \t\tascii_only = false;\n \t}\n \tfree (buf);\n \tif (pj) {\n \t\tpj_end (pj);\n \t\tif (bin) {\n \t\t\tRIO *io = bin->iob.io;\n \t\t\tif (io) {\n \t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n \t\t\t}\n \t\t}\n \t\tpj_free (pj);\n \t}\n \treturn count;\n }\n \n", "target": "// fix_start\n\twhile (needle < to && needle < UT64_MAX - 4) {\n// fix_end\n// fix_start\n\t\tif (needle < to - 4) {\n\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));\n// fix_end\n// fix_start\n\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);\n// fix_end\n// fix_start\n\t\t\tchar *w = (char *)buf + (needle + rc - from);\n// fix_end\n// fix_start\n\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-1899", "cve_desc": "Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0.", "project": "radare2", "idx": 198010}
{"source": "   void Compute(OpKernelContext* context) override {\n     std::unordered_map<int64_t, int64_t> old_row_to_new_row_map;\n     std::vector<bool> row_id_present;\n     const Tensor* row_remapping_t;\n     OP_REQUIRES_OK(context, context->input(\"row_remapping\", &row_remapping_t));\n// bug_start\n// bug_end\n     const auto row_remapping = row_remapping_t->vec<int64_t>();\n     OP_REQUIRES(context, row_remapping.size() == num_rows_,\n                 errors::InvalidArgument(strings::StrCat(\n                     \"Size of row_remapping is \", row_remapping.size(),\n                     \" instead of being equal to num_rows=\", num_rows_)));\n     OP_REQUIRES_OK(context, RemapVectorToMap(row_remapping, &row_id_present,\n                                              &old_row_to_new_row_map));\n \n     int64_t min_old_row = -1;\n     int64_t max_old_row = -1;\n     for (int i = 0; i < row_remapping.size(); ++i) {\n       if (min_old_row < 0 ||\n           (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {\n         min_old_row = row_remapping(i);\n       }\n       if (max_old_row < 0 ||\n           (row_remapping(i) >= 0 && row_remapping(i) > max_old_row)) {\n         max_old_row = row_remapping(i);\n       }\n     }\n \n     std::unordered_map<int64_t, int64_t> old_col_to_new_col_map;\n     std::vector<bool> col_id_present;\n     const Tensor* col_remapping_t;\n     OP_REQUIRES_OK(context, context->input(\"col_remapping\", &col_remapping_t));\n     const auto col_remapping = col_remapping_t->vec<int64_t>();\n     const bool remap_cols = col_remapping.size() > 0;\n     if (remap_cols) {\n       OP_REQUIRES(\n           context, col_remapping.size() == num_cols_,\n           errors::InvalidArgument(strings::StrCat(\n               \"Provided col_remapping, but its size is \", col_remapping.size(),\n               \" instead of being equal to num_cols=\", num_cols_)));\n       OP_REQUIRES_OK(context, RemapVectorToMap(col_remapping, &col_id_present,\n                                                &old_col_to_new_col_map));\n     } else {\n       col_id_present.clear();\n       col_id_present.resize(num_cols_, true);\n     }\n \n     const Tensor* ckpt_path_t;\n     OP_REQUIRES_OK(context, context->input(\"ckpt_path\", &ckpt_path_t));\n     OP_REQUIRES(\n         context, ckpt_path_t->NumElements() == 1,\n         errors::InvalidArgument(\"The `ckpt_path` tensor must have exactly one \"\n                                 \"element, got tensor of shape \",\n                                 ckpt_path_t->shape().DebugString()));\n     const string& ckpt_path = ckpt_path_t->scalar<tstring>()();\n     const Tensor* old_tensor_name_t;\n     OP_REQUIRES_OK(context,\n                    context->input(\"old_tensor_name\", &old_tensor_name_t));\n     const string& old_tensor_name = old_tensor_name_t->scalar<tstring>()();\n \n     LOG(INFO) << \"Processing checkpoint : \" << ckpt_path;\n     BundleReader reader(context->env(), ckpt_path);\n     OP_REQUIRES_OK(context, reader.status());\n \n     DataType tensor_type;\n     TensorShape tensor_shape;\n     OP_REQUIRES_OK(context, reader.LookupDtypeAndShape(\n                                 old_tensor_name, &tensor_type, &tensor_shape));\n     OP_REQUIRES(context, tensor_type == DT_FLOAT,\n                 errors::InvalidArgument(strings::StrCat(\n                     \"Tensor \", old_tensor_name, \" has invalid type \",\n                     DataTypeString(tensor_type), \" instead of expected type \",\n                     DataTypeString(DT_FLOAT))));\n     OP_REQUIRES(\n         context, tensor_shape.dims() == 2,\n         errors::InvalidArgument(strings::StrCat(\n             \"Tensor \", old_tensor_name, \" has shape \",\n             tensor_shape.DebugString(), \" of invalid rank \",\n             tensor_shape.dims(), \" instead of expected shape of rank 2.\")));\n \n     if (!remap_cols) {\n       OP_REQUIRES(context, num_cols_ == tensor_shape.dim_size(1),\n                   errors::InvalidArgument(strings::StrCat(\n                       \"Tensor \", old_tensor_name, \" has shape \",\n                       tensor_shape.DebugString(),\n                       \", where the size of its 2nd dimension is \",\n                       tensor_shape.dim_size(1),\n                       \" instead of being equal to num_cols=\", num_cols_)));\n     }\n \n     std::vector<TensorSlice> tensor_slices;\n     TensorSlice slice(tensor_shape.dims());\n     if (min_old_row >= 0 && max_old_row >= 0) {\n       int64_t row_start = min_old_row;\n       while (row_start <= max_old_row) {\n         const int64_t slice_length =\n             max_rows_in_memory_ <= 0\n                 ? max_old_row - row_start + 1\n                 : std::min(max_rows_in_memory_, max_old_row - row_start + 1);\n         slice.set_start(0, row_start);\n         slice.set_length(0, slice_length);\n         tensor_slices.push_back(slice);\n         row_start += slice_length;\n       }\n     }\n \n     Tensor* output_matrix_t = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(\"output_matrix\",\n                                             TensorShape({num_rows_, num_cols_}),\n                                             &output_matrix_t));\n     auto output_matrix = output_matrix_t->matrix<float>();\n \n     int64_t row_index = min_old_row;\n     int64_t rows_copied = 0;\n     Tensor loaded_tensor_t;\n     for (const TensorSlice& tensor_slice : tensor_slices) {\n       LOG(INFO) << \"Loading slice \" << tensor_slice.DebugString();\n       TensorShape slice_shape;\n       OP_REQUIRES_OK(context,\n                      tensor_slice.SliceTensorShape(tensor_shape, &slice_shape));\n       if (loaded_tensor_t.shape() != slice_shape) {\n         loaded_tensor_t = Tensor(DT_FLOAT, slice_shape);\n       }\n       OP_REQUIRES_OK(context, reader.LookupSlice(old_tensor_name, tensor_slice,\n                                                  &loaded_tensor_t));\n \n       for (int row = 0; row < loaded_tensor_t.dim_size(0); ++row, ++row_index) {\n         if (row_index % 500000 == min_old_row) {\n           LOG(INFO) << \"Processing old row \" << row_index;\n         }\n \n         const int64_t* new_row_ptr =\n             gtl::FindOrNull(old_row_to_new_row_map, row_index);\n         if (new_row_ptr == nullptr) {\n           continue;\n         }\n         ++rows_copied;\n         const int64_t new_row = *new_row_ptr;\n \n         const auto& loaded_tensor = loaded_tensor_t.matrix<float>();\n         for (int old_col = 0; old_col < loaded_tensor_t.dim_size(1);\n              ++old_col) {\n           int64_t new_col = old_col;\n           if (remap_cols) {\n             const int64_t* new_col_ptr =\n                 gtl::FindOrNull(old_col_to_new_col_map, old_col);\n             if (new_col_ptr == nullptr) {\n               continue;\n             }\n             new_col = *new_col_ptr;\n           }\n \n           OP_REQUIRES(context,\n                       new_row < num_rows_ && new_col < num_cols_ &&\n                           new_row >= 0 && new_col >= 0,\n                       errors::Internal(strings::StrCat(\n                           \"new_row=\", new_row, \" and new_col=\", new_col,\n                           \" should have been less than num_rows_=\", num_rows_,\n                           \" and num_cols_=\", num_cols_,\n                           \" and non-negative. This should never have happened \"\n                           \"if the code were correct. Please file a bug.\")));\n           output_matrix(new_row, new_col) = loaded_tensor(row, old_col);\n         }\n       }\n     }\n     LOG(INFO) << \"Copied \" << rows_copied << \" rows from old matrix (with \"\n               << tensor_shape.dim_size(0) << \" rows) to new matrix (with \"\n               << num_rows_ << \" rows).\";\n \n     const Tensor* initializing_values_t;\n     OP_REQUIRES_OK(\n         context, context->input(\"initializing_values\", &initializing_values_t));\n     const auto initializing_values = initializing_values_t->flat<float>();\n     int64_t initializing_values_index = 0;\n     for (int i = 0; i < num_rows_; ++i) {\n       for (int j = 0; j < num_cols_; ++j) {\n         if (row_id_present[i] && col_id_present[j]) continue;\n         OP_REQUIRES(\n             context, initializing_values_index < initializing_values.size(),\n             errors::InvalidArgument(\n                 \"initializing_values contained \", initializing_values.size(),\n                 \" elements, but more missing values remain.\"));\n         output_matrix(i, j) = initializing_values(initializing_values_index);\n         ++initializing_values_index;\n       }\n     }\n \n     OP_REQUIRES(\n         context, initializing_values_index == initializing_values.size(),\n         errors::InvalidArgument(\n             \"initializing_values contained \", initializing_values.size(),\n             \" elements, but only \", initializing_values_index,\n             \" elements were used to fill in missing values.\"));\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        context, row_remapping_t->dims() == 1,\n        errors::InvalidArgument(\"The `row_remapping` tensor must be 1-D, got \"\n                                \"a tensor of shape \",\n                                row_remapping_t->shape().DebugString()));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-29199", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.LoadAndRemapMatrix does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `initializing_values` is a vector but there is no validation for this before accessing its value. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 198013}
{"source": "   void Compute(OpKernelContext *ctx) override {\n     const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n     OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n \n     OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n \n     const auto shape_vec = shape_t->vec<int64>();\n     SparseTensor sp;\n     OP_REQUIRES_OK(ctx, SparseTensor::Create(\n         tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),\n                     TensorShape(shape_vec), &sp));\n     ReduceDetails reduction = SparseTensorReduceHelper(\n         sp, reduction_axes_t->flat<int32>(), keep_dims_);\n \n     Tensor *out_values;\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(0, reduction.reduced_shape, &out_values));\n     auto out_flat = out_values->flat<T>();\n     out_flat.setZero();\n \n     Tensor tmp_reduced_val;\n     OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                            TensorShape({}), &tmp_reduced_val));\n     auto reduced_val = tmp_reduced_val.scalar<T>();\n \n     gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n     if (!output_strides.empty()) {\n       output_strides.back() = 1;\n       for (int d = output_strides.size() - 2; d >= 0; --d) {\n         output_strides[d] =\n             output_strides[d + 1] * shape_vec(reduction.group_by_dims[d + 1]);\n       }\n     }\n \n     auto CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                                      ArraySlice<int64> strides) -> int64 {\n       if (strides.empty()) {\n         return 0;\n       }\n       CHECK_EQ(coords.size(), strides.size());\n       int64_t idx = 0;\n       for (int i = 0; i < coords.size(); ++i) {\n         idx += coords[i] * strides[i];\n       }\n       return idx;\n     };\n \n     sp.Reorder<T>(reduction.reorder_dims);\n     for (const auto &g : sp.group(reduction.group_by_dims)) {\n       Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n// bug_start\n// bug_end\n       const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n// bug_start\n// bug_end\n       out_flat(idx) = reduced_val();\n       VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n               << \"; idx: \" << idx << \"; group \" << Op::Name() << \": \"\n               << reduced_val();\n     }\n   }\n \n", "target": "// fix_start\n      OP_REQUIRES(ctx,\n                  output_strides.empty() ||\n                  (g.group().size() == output_strides.size()),\n                  errors::Internal(\n                      \"Expected group size and output_strides size to match\",\n                      \", but got \", g.group().size(), \" and \",\n                      output_strides.size()));\n// fix_end\n// fix_start\n      OP_REQUIRES(ctx,\n                  idx >= 0 && idx < out_flat.size(),\n                  errors::Internal(\n                      \"Obtained a write index of \", idx,\n                      \" which is outside of bounds of [0, \",\n                      out_flat.size(), \")\"));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-37635", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198116}
{"source": "   void Compute(OpKernelContext* context) override {\n     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n         ConstEigenMatrixMap;\n     typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n         EigenDoubleMatrixMap;\n \n     const Tensor& orig_input_tensor_shape = context->input(0);\n     OP_REQUIRES(context,\n                 orig_input_tensor_shape.dims() == 1 &&\n                     orig_input_tensor_shape.NumElements() == 4,\n                 errors::InvalidArgument(\"original input tensor shape must be\"\n                                         \"1-dimensional and 4 elements\"));\n     const Tensor& out_backprop = context->input(1);\n     const Tensor& row_seq_tensor = context->input(2);\n     const Tensor& col_seq_tensor = context->input(3);\n \n     const int64_t out_batch = out_backprop.dim_size(0);\n     const int64_t out_rows = out_backprop.dim_size(1);\n     const int64_t out_cols = out_backprop.dim_size(2);\n     const int64_t out_depth = out_backprop.dim_size(3);\n \n     OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                 errors::InvalidArgument(\"Given out_backprop shape \",\n                                         out_backprop.shape().DebugString(),\n                                         \", row_seq_tensor must have at least \",\n                                         out_rows + 1, \" elements, but got \",\n                                         row_seq_tensor.NumElements()));\n     OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                 errors::InvalidArgument(\"Given out_backprop shape \",\n                                         out_backprop.shape().DebugString(),\n                                         \", col_seq_tensor must have at least \",\n                                         out_cols + 1, \" elements, but got \",\n                                         col_seq_tensor.NumElements()));\n \n     auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n     auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n     auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n \n     const int64_t in_batch = orig_input_tensor_shape_flat(0);\n     const int64_t in_rows = orig_input_tensor_shape_flat(1);\n     const int64_t in_cols = orig_input_tensor_shape_flat(2);\n     const int64_t in_depth = orig_input_tensor_shape_flat(3);\n// bug_start\n// bug_end\n \n     constexpr int tensor_in_and_out_dims = 4;\n     TensorShape in_shape;\n     for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n       in_shape.AddDim(orig_input_tensor_shape_flat(i));\n     }\n \n     Tensor in_backprop_tensor_temp;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                 {0}, DataTypeToEnum<double>::v(), in_shape,\n                                 &in_backprop_tensor_temp));\n     in_backprop_tensor_temp.flat<double>().setZero();\n     EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n         in_backprop_tensor_temp.flat<double>().data(), in_depth,\n         in_cols * in_rows * in_batch);\n     ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                          out_depth,\n                                          out_cols * out_rows * out_batch);\n     const int64_t in_max_row_index = in_rows - 1;\n     const int64_t in_max_col_index = in_cols - 1;\n     for (int64_t b = 0; b < out_batch; ++b) {\n       for (int64_t r = 0; r < out_rows; ++r) {\n         const int64_t in_row_start = row_seq_tensor_flat(r);\n         int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                           : row_seq_tensor_flat(r + 1) - 1;\n         in_row_end = std::min(in_row_end, in_max_row_index);\n         for (int64_t c = 0; c < out_cols; ++c) {\n           const int64_t in_col_start = col_seq_tensor_flat(c);\n           int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                             : col_seq_tensor_flat(c + 1) - 1;\n           in_col_end = std::min(in_col_end, in_max_col_index);\n \n           const int64_t num_elements_in_pooling_cell =\n               (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n           const int64_t out_index = (b * out_rows + r) * out_cols + c;\n           for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n             for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n               const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n               for (int64_t d = 0; d < out_depth; ++d) {\n                 const double out_backprop_element = static_cast<double>(\n                     out_backprop_mat.coeffRef(d, out_index));\n                 double& in_backprop_ref =\n                     in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                 in_backprop_ref +=\n                     out_backprop_element / num_elements_in_pooling_cell;\n               }\n             }\n           }\n         }\n       }\n     }\n \n     Tensor* in_backprop_tensor = nullptr;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                 {0}, 0, in_shape, &in_backprop_tensor));\n     auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n     auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n     for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n       in_backprop_tensor_flat(i) =\n           static_cast<T>(in_backprop_tensor_temp_flat(i));\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-37651", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198117}
{"source": " static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n   Image *image, *image2=NULL,\n    *rotated_image;\n   register Quantum *q;\n \n   unsigned int status;\n   MATHeader MATLAB_HDR;\n   size_t size;\n   size_t CellType;\n   QuantumInfo *quantum_info;\n   ImageInfo *clone_info;\n   int i;\n   ssize_t ldblk;\n   unsigned char *BImgBuff = NULL;\n   double MinVal, MaxVal;\n   unsigned z, z2;\n   unsigned Frames;\n   int logging;\n   int sample_size;\n   MagickOffsetType filepos=0x80;\n   BlobInfo *blob;\n   size_t one;\n \n   unsigned int (*ReadBlobXXXLong)(Image *image);\n   unsigned short (*ReadBlobXXXShort)(Image *image);\n   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n \n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n \n   image = AcquireImage(image_info,exception);\n \n   status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   clone_info=CloneImageInfo(image_info);\n   if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   MATLAB_HDR.Version = ReadBlobLSBShort(image);\n   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n         MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n   if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n   {\n     ReadBlobXXXLong = ReadBlobLSBLong;\n     ReadBlobXXXShort = ReadBlobLSBShort;\n     ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n     ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n     image->endian = LSBEndian;\n   }\n   else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n   {\n     ReadBlobXXXLong = ReadBlobMSBLong;\n     ReadBlobXXXShort = ReadBlobMSBShort;\n     ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n     ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n     image->endian = MSBEndian;\n   }\n   else\n     goto MATLAB_KO;\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n MATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image))\n   {\n     Frames = 1;\n     (void) SeekBlob(image,filepos,SEEK_SET);\n \n     MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n     if(EOFBlob(image)) break;\n     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n     if(EOFBlob(image)) break;\n     filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n \n     image2 = image;\n #if defined(MAGICKCORE_ZLIB_DELEGATE)\n     if(MATLAB_HDR.DataType == miCOMPRESSED)\n     {\n       image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n       if(image2==NULL) continue;\n       MATLAB_HDR.DataType = ReadBlobXXXLong(image2);\n     }\n #endif\n \n     if(MATLAB_HDR.DataType!=miMATRIX) continue;\n \n     MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n \n     MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n \n     MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n     if(image!=image2)\n       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n \n \n     switch(MATLAB_HDR.DimFlag)\n     {\n       case  8: z2=z=1; break;\n       case 12: z2=z = ReadBlobXXXLong(image2);\n            (void) ReadBlobXXXLong(image2);\n          if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n          break;\n       case 16: z2=z = ReadBlobXXXLong(image2);\n          if(z!=3 && z!=1)\n             ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n            Frames = ReadBlobXXXLong(image2);\n          break;\n       default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n     }\n \n     MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n \n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n         MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&\n         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT64_CLASS)\n       ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n \n     switch (MATLAB_HDR.NameFlag)\n     {\n       case 0:\n         size = ReadBlobXXXLong(image2);\n         size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n         (void) SeekBlob(image2, size, SEEK_CUR);\n         break;\n       case 1:\n       case 2:\n       case 3:\n       case 4:\n         (void) ReadBlob(image2, 4, (unsigned char *) &size);\n         break;\n       default:\n         goto MATLAB_KO;\n     }\n \n     CellType = ReadBlobXXXLong(image2);\n     if (logging)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n \n     (void) ReadBlob(image2, 4, (unsigned char *) &size);\n \n     NEXT_FRAME:\n     switch (CellType)\n     {\n       case miINT8:\n       case miUINT8:\n         sample_size = 8;\n         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n           image->depth = 1;\n         else\n           image->depth = 8;\n         ldblk = (ssize_t) MATLAB_HDR.SizeX;\n         break;\n       case miINT16:\n       case miUINT16:\n         sample_size = 16;\n         image->depth = 16;\n         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n         break;\n       case miINT32:\n       case miUINT32:\n         sample_size = 32;\n         image->depth = 32;\n         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n         break;\n       case miINT64:\n       case miUINT64:\n         sample_size = 64;\n         image->depth = 64;\n         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n         break;\n       case miSINGLE:\n         sample_size = 32;\n         image->depth = 32;\n         (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n   {\n   }\n         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n         break;\n       case miDOUBLE:\n         sample_size = 64;\n         image->depth = 64;\n         (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n DisableMSCWarning(4127)\n         if (sizeof(double) != 8)\n RestoreMSCWarning\n           ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n   {\n   }\n         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n         break;\n       default:\n         ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n     }\n     (void) sample_size;\n     image->columns = MATLAB_HDR.SizeX;\n     image->rows = MATLAB_HDR.SizeY;\n     quantum_info=AcquireQuantumInfo(clone_info,image);\n     if (quantum_info == (QuantumInfo *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     one=1;\n     image->colors = one << image->depth;\n     if (image->columns == 0 || image->rows == 0)\n       goto MATLAB_KO;\n     if ((MATLAB_HDR.DimFlag == 8) &&\n         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n       {\n         image->type=GrayscaleType;\n         SetImageColorspace(image,GRAYColorspace,exception);\n       }\n \n \n     if (image_info->ping)\n     {\n       size_t temp = image->columns;\n       image->columns = image->rows;\n       image->rows = temp;\n       goto done_reading;\n     }\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n     if (status == MagickFalse)\n       return(DestroyImageList(image));\n \n     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));\n     if (BImgBuff == NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n \n     MinVal = 0;\n     MaxVal = 0;\n     if (CellType==miDOUBLE || CellType==miSINGLE)\n     {\n       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n     }\n \n     if(z==1) z=0;\n     do\n     {\n       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n       {\n         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n         if (q == (Quantum *) NULL)\n   {\n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n     goto done_reading;\n   }\n         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n   {\n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n     goto ExitLoop;\n   }\n         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n         {\n           FixLogical((unsigned char *)BImgBuff,ldblk);\n           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n     {\n ImportQuantumPixelsFailed:\n       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n       break;\n     }\n         }\n         else\n         {\n           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n       goto ImportQuantumPixelsFailed;\n \n \n           if (z<=1 &&\n           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n       FixSignedValues(image,q,MATLAB_HDR.SizeX);\n         }\n \n         if (!SyncAuthenticPixels(image,exception))\n   {\n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n     goto ExitLoop;\n   }\n       }\n     } while(z-- >= 2);\n// bug_start\n// bug_end\n ExitLoop:\n \n \n     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n     {\n       CellType = ReadBlobXXXLong(image2);\n       i = ReadBlobXXXLong(image2);\n \n       if (CellType==miDOUBLE || CellType==miSINGLE)\n       {\n         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n       }\n \n       if (CellType==miDOUBLE)\n         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n   {\n           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n           InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n             exception);\n   }\n \n       if (CellType==miSINGLE)\n         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n   {\n           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n           InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n             exception);\n   }\n     }\n \n     if ((MATLAB_HDR.DimFlag == 8) &&\n         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n       image->type=GrayscaleType;\n     if (image->depth == 1)\n       image->type=BilevelType;\n \n     if(image2==image)\n         image2 = NULL;\n \n     rotated_image = RotateImage(image, 90.0, exception);\n     if (rotated_image != (Image *) NULL)\n     {\n       rotated_image->page.x=0;\n       rotated_image->page.y=0;\n \n       blob = rotated_image->blob;\n       rotated_image->blob = image->blob;\n       rotated_image->colors = image->colors;\n       image->blob = blob;\n       AppendImageToList(&image,rotated_image);\n       DeleteImageFromList(&image);\n     }\n \n done_reading:\n \n     if(image2!=NULL)\n       if(image2!=image)\n       {\n         DeleteImageFromList(&image2);\n   if(clone_info)\n   {\n           if(clone_info->file)\n     {\n             fclose(clone_info->file);\n             clone_info->file = NULL;\n             (void) remove_utf8(clone_info->filename);\n     }\n         }\n       }\n \n     AcquireNextImage(image_info,image,exception);\n     if (image->next == (Image *) NULL) break;\n     image=SyncNextImageInList(image);\n     image->columns=image->rows=0;\n     image->colors=0;\n \n     RelinquishMagickMemory(BImgBuff);\n     BImgBuff = NULL;\n \n     if(--Frames>0)\n     {\n       z = z2;\n       if(image2==NULL) image2 = image;\n       goto NEXT_FRAME;\n     }\n     if ((image2!=NULL) && (image2!=image))\n       {\n         DeleteImageFromList(&image2);\n         if(clone_info)\n         {\n           if(clone_info->file)\n           {\n             fclose(clone_info->file);\n             clone_info->file = NULL;\n             (void) remove_utf8(clone_info->filename);\n           }\n         }\n         }\n   }\n \n   clone_info=DestroyImageInfo(clone_info);\n   RelinquishMagickMemory(BImgBuff);\n   CloseBlob(image);\n \n \n   {\n     Image *p;\n     ssize_t scene=0;\n \n     p=image;\n     image=NULL;\n     while (p != (Image *) NULL)\n       {\n         Image *tmp=p;\n         if ((p->rows == 0) || (p->columns == 0)) {\n           p=p->previous;\n           DeleteImageFromList(&tmp);\n         } else {\n           image=p;\n           p=p->previous;\n         }\n       }\n \n     for (p=image; p != (Image *) NULL; p=p->next)\n       p->scene=scene++;\n   }\n \n   if(clone_info != NULL)\n   {\n     if(clone_info->file)\n     {\n       fclose(clone_info->file);\n       clone_info->file = NULL;\n       (void) remove_utf8(clone_info->filename);\n     }\n     DestroyImageInfo(clone_info);\n     clone_info = NULL;\n   }\n   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n   if(image==NULL)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   return (image);\n }\n \n", "target": "// fix_start\n    quantum_info=DestroyQuantumInfo(quantum_info);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2016-10070", "cve_desc": "Heap-based buffer overflow in the CalcMinMax function in coders/mat.c in ImageMagick before 6.9.4-0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted mat file.", "project": "ImageMagick", "idx": 198161}
{"source": " TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                                int index) {\n   TfLiteTensor* tensor = GetMutableInput(context, node, index);\n// bug_start\n// bug_end\n   return tensor->is_variable ? tensor : nullptr;\n }\n \n", "target": "// fix_start\n  if (tensor == nullptr) return nullptr;\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37681", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198169}
{"source": " static int check_passwd(unsigned char *passwd, size_t length)\n {\n \tstruct digest *d = NULL;\n \tunsigned char *passwd1_sum;\n \tunsigned char *passwd2_sum;\n \tint ret = 0;\n \tint hash_len;\n \n \tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n \t\thash_len = PBKDF2_LENGTH;\n \t} else {\n \t\td = digest_alloc(PASSWD_SUM);\n \t\tif (!d) {\n \t\t\tpr_err(\"No such digest: %s\\n\",\n \t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n \t\t\treturn -ENOENT;\n \t\t}\n \n \t\thash_len = digest_length(d);\n \t}\n \n \tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n \tif (!passwd1_sum)\n \t\treturn -ENOMEM;\n \n \tpasswd2_sum = passwd1_sum + hash_len;\n \n \tif (is_passwd_env_enable())\n \t\tret = read_env_passwd(passwd2_sum, hash_len);\n \telse if (is_passwd_default_enable())\n \t\tret = read_default_passwd(passwd2_sum, hash_len);\n \telse\n \t\tret = -EINVAL;\n \n \tif (ret < 0)\n \t\tgoto err;\n \n \tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n \t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n \t\tchar *salt = passwd2_sum;\n \t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n \n \t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n \t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n \t\tif (ret)\n \t\t\tgoto err;\n \n// bug_start\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n// bug_end\n \t\t\tret = 1;\n \t} else {\n \t\tret = digest_digest(d, passwd, length, passwd1_sum);\n \n \t\tif (ret)\n \t\t\tgoto err;\n \n// bug_start\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n// bug_end\n \t\t\tret = 1;\n \t}\n \n err:\n \tfree(passwd1_sum);\n \tdigest_free(d);\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\tif (!crypto_memneq(passwd1_sum, key, keylen))\n// fix_end\n// fix_start\n\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-37848", "cve_desc": "common/password.c in Pengutronix barebox through 2021.07.0 leaks timing information because strncmp is used during hash comparison.", "project": "barebox", "idx": 198239}
{"source": "   void Compute(OpKernelContext* context) override {\n// bug_start\n// bug_end\n     OpInputList params_nested_splits_in;\n     OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                 &params_nested_splits_in));\n// bug_start\n// bug_end\n     const Tensor& params_dense_values_in =\n         context->input(params_nested_splits_in.size());\n     const Tensor& indices_in =\n         context->input(params_nested_splits_in.size() + 1);\n \n// bug_start\n    DCHECK_GT(params_nested_splits_in.size(), 0);\n// bug_end\n     SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n     OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n \n     OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                 errors::InvalidArgument(\"params.rank must be nonzero\"));\n     SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n \n     std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n     SPLITS_TYPE num_values = 0;\n     std::vector<std::vector<SPLITS_TYPE>> out_splits;\n     OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                        num_params_dense_values, &out_splits,\n                                        &value_slices, &num_values));\n \n     OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n     OP_REQUIRES_OK(context,\n                    WriteValues(params_dense_values_in, value_slices,\n                                out_splits.size(), num_values, context));\n   }\n \n", "target": "// fix_start\n\n// fix_end\n// fix_start\n    OP_REQUIRES(\n        context, params_nested_splits_in.size() > 0,\n        errors::InvalidArgument(\"params_nested_splits must be non empty\"));\n\n// fix_end\n// fix_start\n    OP_REQUIRES(context, params_nested_splits_in[0].dims() > 0,\n                errors::InvalidArgument(\"Split tensors must not be scalars\"));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37641", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198259}
{"source": " void ReshapeSparseTensor(OpKernelContext *context,\n                          const Tensor &input_indices_in,\n                          const Tensor &input_shape_in,\n                          const Tensor &target_shape_in, int output_indices_idx,\n                          int output_shape_idx) {\n   OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n               errors::InvalidArgument(\n                   \"Input indices should be a matrix but received shape \",\n                   input_indices_in.shape().DebugString()));\n   OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n               errors::InvalidArgument(\n                   \"Input shape should be a vector but received shape \",\n                   input_shape_in.shape().DebugString()));\n   OP_REQUIRES(context, TensorShapeUtils::IsVector(target_shape_in.shape()),\n               errors::InvalidArgument(\n                   \"Target shape should be a vector but received shape \",\n                   target_shape_in.shape().DebugString()));\n \n   const int64_t output_rank = target_shape_in.NumElements();\n   const TensorShape input_shape(input_shape_in.vec<int64>());\n   const int64_t dense_size = input_shape.num_elements();\n   const int64_t nnz = input_indices_in.shape().dim_size(0);\n \n   TensorShape output_shape;\n   int64_t product = 1;\n   int unknown_index = -1;\n   auto target_shape = target_shape_in.vec<int64>();\n   for (int d = 0; d < output_rank; ++d) {\n     const int64_t size = target_shape(d);\n     if (size == -1) {\n       OP_REQUIRES(\n           context, unknown_index == -1,\n           errors::InvalidArgument(\"only one output dimension may be -1, \"\n                                   \"not both \",\n                                   unknown_index, \" and \", d));\n       unknown_index = d;\n       output_shape.AddDim(1);\n     } else {\n       OP_REQUIRES(context, size >= 0,\n                   errors::InvalidArgument(\"size \", d,\n                                           \" must be non-negative, not \", size));\n       product *= size;\n       output_shape.AddDim(size);\n     }\n   }\n   if (unknown_index != -1) {\n     OP_REQUIRES(\n         context, product > 0,\n         errors::InvalidArgument(\"reshape cannot infer the missing \"\n                                 \"input size for an empty tensor unless all \"\n                                 \"specified input sizes are non-zero\"));\n     const int64_t missing = dense_size / product;\n     OP_REQUIRES(\n         context, product * missing == dense_size,\n         errors::InvalidArgument(\n             \"Input to reshape is a SparseTensor with \", dense_size,\n             \" dense values, but the requested shape requires a multiple of \",\n             product, \". input_shape=\", input_shape.DebugString(),\n             \" output_shape=\", output_shape.DebugString()));\n     output_shape.set_dim(unknown_index, missing);\n   }\n \n   OP_REQUIRES(\n       context, output_shape.num_elements() == dense_size,\n       errors::InvalidArgument(\"Input to reshape is a tensor with \", dense_size,\n                               \" dense values, but the requested shape has \",\n                               output_shape.num_elements(),\n                               \". input_shape=\", input_shape.DebugString(),\n                               \" output_shape=\", output_shape.DebugString()));\n \n   if (input_shape == output_shape) {\n     context->set_output(output_indices_idx, input_indices_in);\n     context->set_output(output_shape_idx, input_shape_in);\n     return;\n   }\n \n   Tensor *result_shape = nullptr;\n   OP_REQUIRES_OK(context, context->allocate_output(output_shape_idx,\n                                                    TensorShape({output_rank}),\n                                                    &result_shape));\n   auto output_shape_vec = result_shape->vec<int64>();\n   for (int j = 0; j < output_shape.dims(); ++j) {\n     output_shape_vec(j) = output_shape.dim_size(j);\n   }\n \n   Tensor *result_indices = nullptr;\n   OP_REQUIRES_OK(context,\n                  context->allocate_output(output_indices_idx,\n                                           TensorShape({nnz, output_rank}),\n                                           &result_indices));\n   if (nnz > 0) {\n// bug_start\n// bug_end\n     OP_REQUIRES_OK(context, functor::ReshapeSparseTensorFunctor<Device>()(\n                                 context, input_shape, output_shape,\n                                 input_indices_in.matrix<int64>(),\n                                 result_indices->matrix<int64>()));\n   }\n }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        context, dense_size > 0 && product > 0,\n        errors::InvalidArgument(\n            \"Input tensor has \", nnz, \" non zero elements but input shape (\",\n            input_shape.DebugString(), \") or output shape (\",\n            output_shape.DebugString(), \") is empty\"));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37640", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.", "project": "tensorflow", "idx": 198282}
{"source": " net_bind(short unsigned *port, int type, const char *log_service_name)\n {\n   struct addrinfo hints = { 0 };\n   struct addrinfo *servinfo;\n   struct addrinfo *ptr;\n// bug_start\n// bug_end\n   const char *cfgaddr;\n   char addr[INET6_ADDRSTRLEN];\n   char strport[8];\n   int yes = 1;\n   int no = 0;\n   int fd;\n   int ret;\n \n   cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n \n   hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM));\n   hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;\n   hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;\n \n   snprintf(strport, sizeof(strport), \"%hu\", *port);\n   ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);\n   if (ret < 0)\n     {\n       DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));\n       return -1;\n     }\n \n   for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)\n     {\n       if (fd >= 0)\n \tclose(fd);\n \n       fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n       if (fd < 0)\n \tcontinue;\n \n       ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));\n       if (ret < 0)\n \tcontinue;\n \n       ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n       if (ret < 0)\n \tcontinue;\n \n       if (ptr->ai_family == AF_INET6)\n \t{\n \t  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));\n \t  if (ret < 0)\n \t    continue;\n \t}\n \n       ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);\n       if (ret < 0)\n \tcontinue;\n \n       break;\n     }\n \n   freeaddrinfo(servinfo);\n \n   if (!ptr)\n     {\n       DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n       goto error;\n     }\n \n// bug_start\n  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);\n// bug_end\n   if (ret < 0)\n     {\n// bug_start\n      DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));\n// bug_end\n       goto error;\n     }\n \n// bug_start\n  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);\n  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);\n// bug_end\n \n   DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n \n   return fd;\n \n  error:\n   close(fd);\n   return -1;\n }\n \n", "target": "// fix_start\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n// fix_end\n// fix_start\n  ret = getsockname(fd, &naddr.sa, &naddr_len);\n// fix_end\n// fix_start\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n// fix_end\n// fix_start\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-38383", "cve_desc": "OwnTone (aka owntone-server) through 28.1 has a use-after-free in net_bind() in misc.c.", "project": "owntone-server", "idx": 198350}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor* x_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x_tensor));\n \n     const Tensor* cs_prev_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n \n     const Tensor* h_prev_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n \n     const Tensor* w_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n \n     const Tensor* wci_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n \n     const Tensor* wcf_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n \n     const Tensor* wco_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n \n     const Tensor* b_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n \n     const int64_t batch_size = x_tensor->dim_size(0);\n     const int64_t input_size = x_tensor->dim_size(1);\n     const int64_t cell_size = cs_prev_tensor->dim_size(1);\n \n     OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,\n                 errors::InvalidArgument(\"cs_prev.dims(0) != batch_size: \",\n                                         cs_prev_tensor->dim_size(0), \" vs. \",\n                                         batch_size));\n     OP_REQUIRES(ctx, cs_prev_tensor->dim_size(1) == cell_size,\n                 errors::InvalidArgument(\"cs_prev.dims(1) != cell_size: \",\n                                         cs_prev_tensor->dim_size(1), \" vs. \",\n                                         cell_size));\n \n     OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,\n                 errors::InvalidArgument(\"h_prev.dims(0) != batch_size: \",\n                                         h_prev_tensor->dim_size(0), \" vs. \",\n                                         batch_size));\n     OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,\n                 errors::InvalidArgument(\n                     \"h_prev.dims(1) != cell_size: \", h_prev_tensor->dim_size(1),\n                     \" vs. \", cell_size));\n \n     OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,\n                 errors::InvalidArgument(\n                     \"w.dim_size(0) != input_size + cell_size: \",\n                     w_tensor->dim_size(0), \" vs. \", input_size + cell_size));\n     OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,\n                 errors::InvalidArgument(\n                     \"w.dim_size(1) != cell_size * 4: \", w_tensor->dim_size(1),\n                     \" vs. \", cell_size * 4));\n \n     OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,\n                 errors::InvalidArgument(\n                     \"b.dim_size(0) != cell_size * 4: \", b_tensor->dim_size(0),\n                     \" vs. \", cell_size * 4));\n \n     Tensor* i_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                             {\"h_prev\"}, \"i\",\n                             TensorShape({batch_size, cell_size}), &i_tensor));\n \n     Tensor* cs_tensor = nullptr;\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(\"cs\", TensorShape({batch_size, cell_size}),\n                                   &cs_tensor));\n \n     Tensor* f_tensor = nullptr;\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(\"f\", TensorShape({batch_size, cell_size}),\n                                   &f_tensor));\n \n     Tensor* o_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                             {\"cs_prev\"}, \"o\",\n                             TensorShape({batch_size, cell_size}), &o_tensor));\n \n     Tensor* ci_tensor = nullptr;\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(\"ci\", TensorShape({batch_size, cell_size}),\n                                   &ci_tensor));\n \n     Tensor* co_tensor = nullptr;\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(\"co\", TensorShape({batch_size, cell_size}),\n                                   &co_tensor));\n \n     Tensor* h_tensor = nullptr;\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(\"h\", TensorShape({batch_size, cell_size}),\n                                   &h_tensor));\n \n     Tensor xh_tensor;\n     OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                             DataTypeToEnum<T>::v(),\n                             TensorShape({batch_size, input_size + cell_size}),\n                             &xh_tensor));\n \n     Tensor gates_tensor;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                       TensorShape({batch_size, cell_size * 4}),\n                                       &gates_tensor));\n \n     const Device& device = ctx->eigen_device<Device>();\n \n// bug_start\n// bug_end\n     functor::LSTMBlockCellFprop<Device, T, USE_CUBLAS, gate_layout>(\n         batch_size, input_size, cell_size)(\n         ctx, device, forget_bias_, cell_clip_, use_peephole_,\n         x_tensor->matrix<T>(), cs_prev_tensor->matrix<T>(),\n         h_prev_tensor->matrix<T>(), w_tensor->matrix<T>(), wci_tensor->vec<T>(),\n         wcf_tensor->vec<T>(), wco_tensor->vec<T>(), b_tensor->vec<T>(),\n         xh_tensor.matrix<T>(), i_tensor->matrix<T>(), cs_tensor->matrix<T>(),\n         f_tensor->matrix<T>(), o_tensor->matrix<T>(), ci_tensor->matrix<T>(),\n         co_tensor->matrix<T>(), gates_tensor.matrix<T>(),\n         h_tensor->matrix<T>());\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, x_tensor->dims() == 2,\n                errors::InvalidArgument(\"x_tensor must be rank 2 but is rank \",\n                                        x_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, cs_prev_tensor->dims() == 2,\n        errors::InvalidArgument(\"cs_prev_tensor must be rank 2 but is rank \",\n                                cs_prev_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, h_prev_tensor->dims() == 2,\n        errors::InvalidArgument(\"h_prev_tensor must be rank 2 but is rank \",\n                                h_prev_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, w_tensor->dims() == 2,\n                errors::InvalidArgument(\"w_tensor must be rank 2 but is rank \",\n                                        w_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, wci_tensor->dims() == 1,\n        errors::InvalidArgument(\"wci_tensor must be rank 1 but is rank \",\n                                wci_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, wcf_tensor->dims() == 1,\n        errors::InvalidArgument(\"wcf_tensor must be rank 1 but is rank \",\n                                wci_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, wco_tensor->dims() == 1,\n        errors::InvalidArgument(\"wco_tensor must be rank 1 but is rank \",\n                                wco_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, b_tensor->dims() == 1,\n                errors::InvalidArgument(\"b_tensor must be rank 1 but is rank \",\n                                        b_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, xh_tensor.dims() == 2,\n                errors::InvalidArgument(\"xh_tensor must be rank 2 but is rank \",\n                                        xh_tensor.dims(), \".\"));\n    OP_REQUIRES(ctx, i_tensor->dims() == 2,\n                errors::InvalidArgument(\"i_tensor must be rank 2 but is rank \",\n                                        i_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, cs_tensor->dims() == 2,\n                errors::InvalidArgument(\"cs_tensor must be rank 2 but is rank \",\n                                        cs_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, f_tensor->dims() == 2,\n                errors::InvalidArgument(\"f_tensor must be rank 2 but is rank \",\n                                        f_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, o_tensor->dims() == 2,\n                errors::InvalidArgument(\"o_tensor must be rank 2 but is rank \",\n                                        o_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, ci_tensor->dims() == 2,\n                errors::InvalidArgument(\"ci_tensor must be rank 2 but is rank \",\n                                        ci_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, co_tensor->dims() == 2,\n                errors::InvalidArgument(\"co_tensor must be rank 2 but is rank \",\n                                        co_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, gates_tensor.dims() == 2,\n        errors::InvalidArgument(\"gates_tensor must be rank 2 but is rank \",\n                                gates_tensor.dims(), \".\"));\n    OP_REQUIRES(ctx, h_tensor->dims() == 2,\n                errors::InvalidArgument(\"h_tensor must be rank 2 but is rank \",\n                                        h_tensor->dims(), \".\"));\n\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-29200", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.LSTMBlockCell` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code does not validate the ranks of any of the arguments to this API call. This results in `CHECK`-failures when the elements of the tensor are accessed. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 198374}
{"source": " static void handle_PORT(ctrl_t *ctrl, char *str)\n {\n \tint a, b, c, d, e, f;\n \tchar addr[INET_ADDRSTRLEN];\n \tstruct sockaddr_in sin;\n \n \tif (ctrl->data_sd > 0) {\n \t\tuev_io_stop(&ctrl->data_watcher);\n \t\tclose(ctrl->data_sd);\n \t\tctrl->data_sd = -1;\n \t}\n \n \tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n// bug_start\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n// bug_end\n \n \tif (!inet_aton(addr, &(sin.sin_addr))) {\n \t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n \t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n \t\treturn;\n \t}\n \n \tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n \tctrl->data_port = e * 256 + f;\n \n \tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n \tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n }\n \n", "target": "// fix_start\n\tsnprintf(addr, sizeof(addr), \"%d.%d.%d.%d\", a, b, c, d);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-20276", "cve_desc": "An unauthenticated stack-based buffer overflow vulnerability in common.c's handle_PORT in uftpd FTP server versions 2.10 and earlier can be abused to cause a crash and could potentially lead to remote code execution.", "project": "uftpd", "idx": 198399}
{"source": "       goto L_BREAK;\n     goto L_RAISE;\n   }\n   mrb->jmp = &c_jmp;\n   mrb_vm_ci_proc_set(mrb->c->ci, proc);\n \n #define regs (mrb->c->ci->stack)\n   INIT_DISPATCH {\n     CASE(OP_NOP, Z) {\n       NEXT;\n     }\n \n     CASE(OP_MOVE, BB) {\n       regs[a] = regs[b];\n       NEXT;\n     }\n \n     CASE(OP_LOADL, BB) {\n       switch (pool[b].tt) {\n       case IREP_TT_INT32:\n         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n         break;\n       case IREP_TT_INT64:\n #if defined(MRB_INT64)\n         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n         break;\n #else\n #if defined(MRB_64BIT)\n         if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n           regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n           break;\n         }\n #endif\n         goto L_INT_OVERFLOW;\n #endif\n       case IREP_TT_BIGINT:\n         goto L_INT_OVERFLOW;\n #ifndef MRB_NO_FLOAT\n       case IREP_TT_FLOAT:\n         regs[a] = mrb_float_value(mrb, pool[b].u.f);\n         break;\n #endif\n       default:\n         regs[a] = mrb_nil_value();\n         break;\n       }\n       NEXT;\n     }\n \n     CASE(OP_LOADI, BB) {\n       SET_FIXNUM_VALUE(regs[a], b);\n       NEXT;\n     }\n \n     CASE(OP_LOADINEG, BB) {\n       SET_FIXNUM_VALUE(regs[a], -b);\n       NEXT;\n     }\n \n     CASE(OP_LOADI__1,B) goto L_LOADI;\n     CASE(OP_LOADI_0,B) goto L_LOADI;\n     CASE(OP_LOADI_1,B) goto L_LOADI;\n     CASE(OP_LOADI_2,B) goto L_LOADI;\n     CASE(OP_LOADI_3,B) goto L_LOADI;\n     CASE(OP_LOADI_4,B) goto L_LOADI;\n     CASE(OP_LOADI_5,B) goto L_LOADI;\n     CASE(OP_LOADI_6,B) goto L_LOADI;\n     CASE(OP_LOADI_7, B) {\n     L_LOADI:\n       SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n       NEXT;\n     }\n \n     CASE(OP_LOADI16, BS) {\n       SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n       NEXT;\n     }\n \n     CASE(OP_LOADI32, BSS) {\n       SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n       NEXT;\n     }\n \n     CASE(OP_LOADSYM, BB) {\n       SET_SYM_VALUE(regs[a], syms[b]);\n       NEXT;\n     }\n \n     CASE(OP_LOADNIL, B) {\n       SET_NIL_VALUE(regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_LOADSELF, B) {\n       regs[a] = regs[0];\n       NEXT;\n     }\n \n     CASE(OP_LOADT, B) {\n       SET_TRUE_VALUE(regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_LOADF, B) {\n       SET_FALSE_VALUE(regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETGV, BB) {\n       mrb_value val = mrb_gv_get(mrb, syms[b]);\n       regs[a] = val;\n       NEXT;\n     }\n \n     CASE(OP_SETGV, BB) {\n       mrb_gv_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETSV, BB) {\n       mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n       regs[a] = val;\n       NEXT;\n     }\n \n     CASE(OP_SETSV, BB) {\n       mrb_vm_special_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETIV, BB) {\n       regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n       NEXT;\n     }\n \n     CASE(OP_SETIV, BB) {\n       mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETCV, BB) {\n       mrb_value val;\n       val = mrb_vm_cv_get(mrb, syms[b]);\n       regs[a] = val;\n       NEXT;\n     }\n \n     CASE(OP_SETCV, BB) {\n       mrb_vm_cv_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETIDX, B) {\n       mrb_value va = regs[a], vb = regs[a+1];\n       switch (mrb_type(va)) {\n       case MRB_TT_ARRAY:\n         if (!mrb_integer_p(vb)) goto getidx_fallback;\n         regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n         break;\n       case MRB_TT_HASH:\n         va = mrb_hash_get(mrb, va, vb);\n         regs[a] = va;\n         break;\n       case MRB_TT_STRING:\n         switch (mrb_type(vb)) {\n         case MRB_TT_INTEGER:\n         case MRB_TT_STRING:\n         case MRB_TT_RANGE:\n           va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n           regs[a] = va;\n           break;\n         default:\n           goto getidx_fallback;\n         }\n         break;\n       default:\n       getidx_fallback:\n         mid = MRB_OPSYM(aref);\n         goto L_SEND_SYM;\n       }\n       NEXT;\n     }\n \n     CASE(OP_SETIDX, B) {\n       c = 2;\n       mid = MRB_OPSYM(aset);\n       SET_NIL_VALUE(regs[a+3]);\n       goto L_SENDB_SYM;\n     }\n \n     CASE(OP_GETCONST, BB) {\n       mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n       regs[a] = v;\n       NEXT;\n     }\n \n     CASE(OP_SETCONST, BB) {\n       mrb_vm_const_set(mrb, syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETMCNST, BB) {\n       mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n       regs[a] = v;\n       NEXT;\n     }\n \n     CASE(OP_SETMCNST, BB) {\n       mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_GETUPVAR, BBB) {\n       mrb_value *regs_a = regs + a;\n       struct REnv *e = uvenv(mrb, c);\n \n       if (e && b < MRB_ENV_LEN(e)) {\n         *regs_a = e->stack[b];\n       }\n       else {\n         *regs_a = mrb_nil_value();\n       }\n       NEXT;\n     }\n \n     CASE(OP_SETUPVAR, BBB) {\n       struct REnv *e = uvenv(mrb, c);\n \n       if (e) {\n         mrb_value *regs_a = regs + a;\n \n         if (b < MRB_ENV_LEN(e)) {\n           e->stack[b] = *regs_a;\n           mrb_write_barrier(mrb, (struct RBasic*)e);\n         }\n       }\n       NEXT;\n     }\n \n     CASE(OP_JMP, S) {\n       pc += (int16_t)a;\n       JUMP;\n     }\n     CASE(OP_JMPIF, BS) {\n       if (mrb_test(regs[a])) {\n         pc += (int16_t)b;\n         JUMP;\n       }\n       NEXT;\n     }\n     CASE(OP_JMPNOT, BS) {\n       if (!mrb_test(regs[a])) {\n         pc += (int16_t)b;\n         JUMP;\n       }\n       NEXT;\n     }\n     CASE(OP_JMPNIL, BS) {\n       if (mrb_nil_p(regs[a])) {\n         pc += (int16_t)b;\n         JUMP;\n       }\n       NEXT;\n     }\n \n     CASE(OP_JMPUW, S) {\n       a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n       CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n         struct RBreak *brk = (struct RBreak*)mrb->exc;\n         mrb_value target = mrb_break_value_get(brk);\n         mrb_assert(mrb_integer_p(target));\n         a = (uint32_t)mrb_integer(target);\n         mrb_assert(a >= 0 && a < irep->ilen);\n       }\n       CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n         ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n         if (ch) {\n           if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n             THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n           }\n         }\n       }\n       CHECKPOINT_END(RBREAK_TAG_JUMP);\n \n       mrb->exc = NULL;\n       pc = irep->iseq + a;\n       JUMP;\n     }\n \n     CASE(OP_EXCEPT, B) {\n       mrb_value exc;\n \n       if (mrb->exc == NULL) {\n         exc = mrb_nil_value();\n       }\n       else {\n         switch (mrb->exc->tt) {\n         case MRB_TT_BREAK:\n         case MRB_TT_EXCEPTION:\n           exc = mrb_obj_value(mrb->exc);\n           break;\n         default:\n           mrb_assert(!\"bad mrb_type\");\n           exc = mrb_nil_value();\n           break;\n         }\n         mrb->exc = NULL;\n       }\n       regs[a] = exc;\n       NEXT;\n     }\n     CASE(OP_RESCUE, BB) {\n       mrb_value exc = regs[a];\n       mrb_value e = regs[b];\n       struct RClass *ec;\n \n       switch (mrb_type(e)) {\n       case MRB_TT_CLASS:\n       case MRB_TT_MODULE:\n         break;\n       default:\n         {\n           mrb_value exc;\n \n           exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                     \"class or module required for rescue clause\");\n           mrb_exc_set(mrb, exc);\n           goto L_RAISE;\n         }\n       }\n       ec = mrb_class_ptr(e);\n       regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n       NEXT;\n     }\n \n     CASE(OP_RAISEIF, B) {\n       mrb_value exc = regs[a];\n       if (mrb_break_p(exc)) {\n         mrb->exc = mrb_obj_ptr(exc);\n         goto L_BREAK;\n       }\n       mrb_exc_set(mrb, exc);\n       if (mrb->exc) {\n         goto L_RAISE;\n       }\n       NEXT;\n     }\n \n     CASE(OP_SSEND, BBB) {\n       regs[a] = regs[0];\n       insn = OP_SEND;\n     }\n     goto L_SENDB;\n \n     CASE(OP_SSENDB, BBB) {\n       regs[a] = regs[0];\n     }\n     goto L_SENDB;\n \n     CASE(OP_SEND, BBB)\n     goto L_SENDB;\n \n     L_SEND_SYM:\n     c = 1;\n     SET_NIL_VALUE(regs[a+2]);\n     goto L_SENDB_SYM;\n \n     CASE(OP_SENDB, BBB)\n     L_SENDB:\n     mid = syms[b];\n     L_SENDB_SYM:\n     {\n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_method_t m;\n       struct RClass *cls;\n       mrb_value recv, blk;\n \n       ARGUMENT_NORMALIZE(a, &c, insn);\n \n       recv = regs[a];\n       cls = mrb_class(mrb, recv);\n       m = mrb_method_search_vm(mrb, &cls, mid);\n       if (MRB_METHOD_UNDEF_P(m)) {\n         m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n         mid = MRB_SYM(method_missing);\n       }\n \n       ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n \n       if (MRB_METHOD_CFUNC_P(m)) {\n         if (MRB_METHOD_PROC_P(m)) {\n           struct RProc *p = MRB_METHOD_PROC(m);\n \n           mrb_vm_ci_proc_set(ci, p);\n           recv = p->body.func(mrb, recv);\n         }\n         else {\n           if (MRB_METHOD_NOARG_P(m)) {\n             check_method_noarg(mrb, ci);\n           }\n           recv = MRB_METHOD_FUNC(m)(mrb, recv);\n         }\n         mrb_gc_arena_shrink(mrb, ai);\n         if (mrb->exc) goto L_RAISE;\n         ci = mrb->c->ci;\n         if (mrb_proc_p(blk)) {\n           struct RProc *p = mrb_proc_ptr(blk);\n           if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n             p->flags |= MRB_PROC_ORPHAN;\n           }\n         }\n         if (!ci->u.target_class) {\n           if (ci->cci == CINFO_RESUMED) {\n             mrb->jmp = prev_jmp;\n             return recv;\n           }\n           else {\n             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n             proc = ci[-1].proc;\n             irep = proc->body.irep;\n             pool = irep->pool;\n             syms = irep->syms;\n           }\n         }\n         ci->stack[0] = recv;\n         ci = cipop(mrb);\n         pc = ci->pc;\n       }\n       else {\n         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n         pc = irep->iseq;\n       }\n     }\n     JUMP;\n \n     CASE(OP_CALL, Z) {\n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_value recv = ci->stack[0];\n       struct RProc *m = mrb_proc_ptr(recv);\n \n       ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n       mrb_vm_ci_proc_set(ci, m);\n       if (MRB_PROC_ENV_P(m)) {\n         ci->mid = MRB_PROC_ENV(m)->mid;\n       }\n \n       if (MRB_PROC_CFUNC_P(m)) {\n         recv = MRB_PROC_CFUNC(m)(mrb, recv);\n         mrb_gc_arena_shrink(mrb, ai);\n         if (mrb->exc) goto L_RAISE;\n         ci = cipop(mrb);\n         pc = ci->pc;\n         ci[1].stack[0] = recv;\n         irep = mrb->c->ci->proc->body.irep;\n       }\n       else {\n         proc = m;\n         irep = m->body.irep;\n         if (!irep) {\n           mrb->c->ci->stack[0] = mrb_nil_value();\n           a = 0;\n           c = OP_R_NORMAL;\n           goto L_OP_RETURN_BODY;\n         }\n         mrb_int nargs = mrb_ci_bidx(ci)+1;\n         if (nargs < irep->nregs) {\n           mrb_stack_extend(mrb, irep->nregs);\n           stack_clear(regs+nargs, irep->nregs-nargs);\n         }\n         if (MRB_PROC_ENV_P(m)) {\n           regs[0] = MRB_PROC_ENV(m)->stack[0];\n         }\n         pc = irep->iseq;\n       }\n       pool = irep->pool;\n       syms = irep->syms;\n       JUMP;\n     }\n \n     CASE(OP_SUPER, BB) {\n       mrb_method_t m;\n       struct RClass *cls;\n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_value recv, blk;\n       const struct RProc *p = ci->proc;\n       mrb_sym mid = ci->mid;\n       struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n \n       if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) {\n         mid = p->e.env->mid;\n       }\n \n       if (mid == 0 || !target_class) {\n         mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n         mrb_exc_set(mrb, exc);\n         goto L_RAISE;\n       }\n       if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n         target_class = mrb_vm_ci_target_class(ci);\n       }\n       else if (target_class->tt == MRB_TT_MODULE) {\n         target_class = mrb_vm_ci_target_class(ci);\n         if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n           goto super_typeerror;\n         }\n       }\n       recv = regs[0];\n       if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n       super_typeerror: ;\n         mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                             \"self has wrong type to call super in this context\");\n         mrb_exc_set(mrb, exc);\n         goto L_RAISE;\n       }\n \n       ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n \n       cls = target_class->super;\n       m = mrb_method_search_vm(mrb, &cls, mid);\n       if (MRB_METHOD_UNDEF_P(m)) {\n         m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n         mid = MRB_SYM(method_missing);\n       }\n \n       ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n \n       ci->stack[0] = recv;\n \n       if (MRB_METHOD_CFUNC_P(m)) {\n         mrb_value v;\n \n         if (MRB_METHOD_PROC_P(m)) {\n           mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n         }\n         v = MRB_METHOD_CFUNC(m)(mrb, recv);\n         mrb_gc_arena_restore(mrb, ai);\n         if (mrb->exc) goto L_RAISE;\n         ci = mrb->c->ci;\n         mrb_assert(!mrb_break_p(v));\n         if (!mrb_vm_ci_target_class(ci)) {\n           if (ci->cci == CINFO_RESUMED) {\n             mrb->jmp = prev_jmp;\n             return v;\n           }\n           else {\n             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n             proc = ci[-1].proc;\n             irep = proc->body.irep;\n             pool = irep->pool;\n             syms = irep->syms;\n           }\n         }\n         mrb->c->ci->stack[0] = v;\n         ci = cipop(mrb);\n         pc = ci->pc;\n       }\n       else {\n         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n         pc = irep->iseq;\n       }\n       JUMP;\n     }\n \n     CASE(OP_ARGARY, BS) {\n       mrb_int m1 = (b>>11)&0x3f;\n       mrb_int r  = (b>>10)&0x1;\n       mrb_int m2 = (b>>5)&0x1f;\n       mrb_int kd = (b>>4)&0x1;\n       mrb_int lv = (b>>0)&0xf;\n       mrb_value *stack;\n \n       if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n         mrb_value exc;\n \n       L_NOSUPER:\n         exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n         mrb_exc_set(mrb, exc);\n         goto L_RAISE;\n       }\n       if (lv == 0) stack = regs + 1;\n       else {\n         struct REnv *e = uvenv(mrb, lv-1);\n         if (!e) goto L_NOSUPER;\n         if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n           goto L_NOSUPER;\n         stack = e->stack + 1;\n       }\n       if (r == 0) {\n         regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n       }\n       else {\n         mrb_value *pp = NULL;\n         struct RArray *rest;\n         mrb_int len = 0;\n \n         if (mrb_array_p(stack[m1])) {\n           struct RArray *ary = mrb_ary_ptr(stack[m1]);\n \n           pp = ARY_PTR(ary);\n           len = ARY_LEN(ary);\n         }\n         regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n         rest = mrb_ary_ptr(regs[a]);\n         if (m1 > 0) {\n           stack_copy(ARY_PTR(rest), stack, m1);\n         }\n         if (len > 0) {\n           stack_copy(ARY_PTR(rest)+m1, pp, len);\n         }\n         if (m2 > 0) {\n           stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n         }\n         ARY_SET_LEN(rest, m1+len+m2);\n       }\n       if (kd) {\n         regs[a+1] = stack[m1+r+m2];\n         regs[a+2] = stack[m1+r+m2+1];\n       }\n       else {\n         regs[a+1] = stack[m1+r+m2];\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_ENTER, W) {\n       mrb_int m1 = MRB_ASPEC_REQ(a);\n       mrb_int o  = MRB_ASPEC_OPT(a);\n       mrb_int r  = MRB_ASPEC_REST(a);\n       mrb_int m2 = MRB_ASPEC_POST(a);\n       mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n       mrb_int const len = m1 + o + r + m2;\n \n       mrb_callinfo *ci = mrb->c->ci;\n       mrb_int argc = ci->n;\n       mrb_value *argv = regs+1;\n       mrb_value * const argv0 = argv;\n       mrb_int const kw_pos = len + kd;\n       mrb_int const blk_pos = kw_pos + 1;\n       mrb_value blk = regs[mrb_ci_bidx(ci)];\n       mrb_value kdict = mrb_nil_value();\n \n       if (ci->nk > 0) {\n         mrb_int kidx = mrb_ci_kidx(ci);\n         kdict = regs[kidx];\n         if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n           kdict = mrb_nil_value();\n           ci->nk = 0;\n         }\n       }\n       if (!kd && !mrb_nil_p(kdict)) {\n         if (argc < 14) {\n           ci->n++;\n           argc++;\n         }\n         else if (argc == 14) {\n           regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n           argc = ci->n = 15;\n         }\n         else {\n           mrb_ary_push(mrb, regs[1], regs[2]);\n         }\n         ci->nk = 0;\n       }\n       if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n         kdict = mrb_hash_dup(mrb, kdict);\n       }\n \n       if (argc == 15) {\n         struct RArray *ary = mrb_ary_ptr(regs[1]);\n         argv = ARY_PTR(ary);\n         argc = (int)ARY_LEN(ary);\n         mrb_gc_protect(mrb, regs[1]);\n       }\n \n       if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n         if (argc < m1 + m2 || (r == 0 && argc > len)) {\n           argnum_error(mrb, m1+m2);\n           goto L_RAISE;\n         }\n       }\n       else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n         mrb_gc_protect(mrb, argv[0]);\n         argc = (int)RARRAY_LEN(argv[0]);\n         argv = RARRAY_PTR(argv[0]);\n       }\n \n       mrb_value rest = mrb_nil_value();\n       if (argc < len) {\n         mrb_int mlen = m2;\n         if (argc < m1+m2) {\n           mlen = m1 < argc ? argc - m1 : 0;\n         }\n \n         if (argv0 != argv && argv) {\n           value_move(&regs[1], argv, argc-mlen);\n         }\n         if (argc < m1) {\n           stack_clear(&regs[argc+1], m1-argc);\n         }\n         if (mlen) {\n           value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n         }\n         if (mlen < m2) {\n           stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n         }\n         if (r) {\n           rest = mrb_ary_new_capa(mrb, 0);\n           regs[m1+o+1] = rest;\n         }\n         if (o > 0 && argc > m1+m2)\n           pc += (argc - m1 - m2)*3;\n       }\n       else {\n         mrb_int rnum = 0;\n         if (argv0 != argv) {\n           value_move(&regs[1], argv, m1+o);\n         }\n         if (r) {\n           rnum = argc-m1-o-m2;\n           rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n           regs[m1+o+1] = rest;\n         }\n         if (m2 > 0 && argc-m2 > m1) {\n           value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n         }\n         pc += o*3;\n       }\n \n       regs[blk_pos] = blk;\n       if (kd) {\n         if (mrb_nil_p(kdict))\n           kdict = mrb_hash_new_capa(mrb, 0);\n         regs[kw_pos] = kdict;\n       }\n \n       mrb->c->ci->n = len;\n \n       if (irep->nlocals-blk_pos-1 > 0) {\n         stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n       }\n       JUMP;\n     }\n \n     CASE(OP_KARG, BB) {\n       mrb_value k = mrb_symbol_value(syms[b]);\n       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n       mrb_value kdict, v;\n \n       if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n         mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n         goto L_RAISE;\n       }\n       v = mrb_hash_get(mrb, kdict, k);\n       regs[a] = v;\n       mrb_hash_delete_key(mrb, kdict, k);\n       NEXT;\n     }\n \n     CASE(OP_KEY_P, BB) {\n       mrb_value k = mrb_symbol_value(syms[b]);\n       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n       mrb_value kdict;\n       mrb_bool key_p = FALSE;\n \n       if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n         key_p = mrb_hash_key_p(mrb, kdict, k);\n       }\n       regs[a] = mrb_bool_value(key_p);\n       NEXT;\n     }\n \n     CASE(OP_KEYEND, Z) {\n       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n       mrb_value kdict;\n \n       if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n         mrb_value keys = mrb_hash_keys(mrb, kdict);\n         mrb_value key1 = RARRAY_PTR(keys)[0];\n         mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n         goto L_RAISE;\n       }\n       NEXT;\n     }\n \n     CASE(OP_BREAK, B) {\n       c = OP_R_BREAK;\n       goto L_RETURN;\n     }\n     CASE(OP_RETURN_BLK, B) {\n       c = OP_R_RETURN;\n       goto L_RETURN;\n     }\n     CASE(OP_RETURN, B)\n     c = OP_R_NORMAL;\n     L_RETURN:\n     {\n       mrb_callinfo *ci;\n \n       ci = mrb->c->ci;\n       if (ci->mid) {\n         mrb_value blk = regs[mrb_ci_bidx(ci)];\n \n         if (mrb_proc_p(blk)) {\n           struct RProc *p = mrb_proc_ptr(blk);\n \n           if (!MRB_PROC_STRICT_P(p) &&\n               ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n             p->flags |= MRB_PROC_ORPHAN;\n           }\n         }\n       }\n \n       if (mrb->exc) {\n       L_RAISE:\n         ci = mrb->c->ci;\n         if (ci == mrb->c->cibase) {\n           ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n           if (ch == NULL) goto L_FTOP;\n           goto L_CATCH;\n         }\n         while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n           ci = cipop(mrb);\n           if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n             mrb->jmp = prev_jmp;\n             MRB_THROW(prev_jmp);\n           }\n           pc = ci[0].pc;\n           if (ci == mrb->c->cibase) {\n             ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n             if (ch == NULL) {\n             L_FTOP:\n               if (mrb->c == mrb->root_c) {\n                 mrb->c->ci->stack = mrb->c->stbase;\n                 goto L_STOP;\n               }\n               else {\n                 struct mrb_context *c = mrb->c;\n \n                 c->status = MRB_FIBER_TERMINATED;\n                 mrb->c = c->prev;\n                 c->prev = NULL;\n                 goto L_RAISE;\n               }\n             }\n             break;\n           }\n         }\n       L_CATCH:\n         if (ch == NULL) goto L_STOP;\n         if (FALSE) {\n         L_CATCH_TAGGED_BREAK:\n           ci = mrb->c->ci;\n         }\n         proc = ci->proc;\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n         mrb_stack_extend(mrb, irep->nregs);\n         pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n       }\n       else {\n         mrb_int acc;\n         mrb_value v;\n \n         ci = mrb->c->ci;\n         v = regs[a];\n         mrb_gc_protect(mrb, v);\n         switch (c) {\n         case OP_R_RETURN:\n           if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n             const struct RProc *dst;\n             mrb_callinfo *cibase;\n             cibase = mrb->c->cibase;\n             dst = top_proc(mrb, proc);\n \n             if (MRB_PROC_ENV_P(dst)) {\n               struct REnv *e = MRB_PROC_ENV(dst);\n \n               if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                 goto L_RAISE;\n               }\n             }\n             while (cibase <= ci && ci->proc != dst) {\n               if (ci->cci > CINFO_NONE) {\n                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                 goto L_RAISE;\n               }\n               ci--;\n             }\n             if (ci <= cibase) {\n               localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n               goto L_RAISE;\n             }\n             ci = mrb->c->ci;\n             while (cibase <= ci && ci->proc != dst) {\n               CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                 cibase = mrb->c->cibase;\n                 dst = top_proc(mrb, proc);\n               }\n               CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                 UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n               }\n               CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n               ci = cipop(mrb);\n               pc = ci->pc;\n             }\n             proc = ci->proc;\n             mrb->exc = NULL;\n             break;\n           }\n         case OP_R_NORMAL:\n         NORMAL_RETURN:\n           if (ci == mrb->c->cibase) {\n             struct mrb_context *c;\n             c = mrb->c;\n \n             if (!c->prev) {\n               regs[irep->nlocals] = v;\n               goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n             }\n             if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n               mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n               mrb_exc_set(mrb, exc);\n               goto L_RAISE;\n             }\n             CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n               c = mrb->c;\n             }\n             CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n             }\n             CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n             c->status = MRB_FIBER_TERMINATED;\n             mrb->c = c->prev;\n             mrb->c->status = MRB_FIBER_RUNNING;\n             c->prev = NULL;\n             if (c->vmexec) {\n               mrb_gc_arena_restore(mrb, ai);\n               c->vmexec = FALSE;\n               mrb->jmp = prev_jmp;\n               return v;\n             }\n             ci = mrb->c->ci;\n           }\n           CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n           }\n           CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n           }\n           CHECKPOINT_END(RBREAK_TAG_RETURN);\n           mrb->exc = NULL;\n           break;\n         case OP_R_BREAK:\n           if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n           if (MRB_PROC_ORPHAN_P(proc)) {\n             mrb_value exc;\n \n           L_BREAK_ERROR:\n             exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                       \"break from proc-closure\");\n             mrb_exc_set(mrb, exc);\n             goto L_RAISE;\n           }\n           if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n             goto L_BREAK_ERROR;\n           }\n           else {\n             struct REnv *e = MRB_PROC_ENV(proc);\n \n             if (e->cxt != mrb->c) {\n               goto L_BREAK_ERROR;\n             }\n           }\n           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n           }\n           CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n           }\n           CHECKPOINT_END(RBREAK_TAG_BREAK);\n           if (ci == mrb->c->cibase && ci->pc) {\n             struct mrb_context *c = mrb->c;\n \n             mrb->c = c->prev;\n             c->prev = NULL;\n             ci = mrb->c->ci;\n           }\n           if (ci->cci > CINFO_NONE) {\n             ci = cipop(mrb);\n// bug_start\n// bug_end\n             mrb_gc_arena_restore(mrb, ai);\n             mrb->c->vmexec = FALSE;\n// bug_start\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n// bug_end\n             mrb->jmp = prev_jmp;\n             MRB_THROW(prev_jmp);\n           }\n           if (FALSE) {\n             struct RBreak *brk;\n \n           L_BREAK:\n             brk = (struct RBreak*)mrb->exc;\n             proc = mrb_break_proc_get(brk);\n             v = mrb_break_value_get(brk);\n             ci = mrb->c->ci;\n \n             switch (mrb_break_tag_get(brk)) {\n #define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n               RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n #undef DISPATCH_CHECKPOINTS\n               default:\n                 mrb_assert(!\"wrong break tag\");\n             }\n           }\n           while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n             if (ci[-1].cci == CINFO_SKIP) {\n               goto L_BREAK_ERROR;\n             }\n             CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n             }\n             CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n             }\n             CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n             ci = cipop(mrb);\n             pc = ci->pc;\n           }\n           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n           }\n           CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n           }\n           CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n           if (ci == mrb->c->cibase) {\n             goto L_BREAK_ERROR;\n           }\n           mrb->exc = NULL;\n           break;\n         default:\n           break;\n         }\n         mrb_assert(ci == mrb->c->ci);\n         mrb_assert(mrb->exc == NULL);\n \n         if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n           mrb_gc_arena_restore(mrb, ai);\n           mrb->c->vmexec = FALSE;\n           mrb->jmp = prev_jmp;\n           return v;\n         }\n         acc = ci->cci;\n         ci = cipop(mrb);\n         if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n           mrb_gc_arena_restore(mrb, ai);\n           mrb->jmp = prev_jmp;\n           return v;\n         }\n         pc = ci->pc;\n         DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n         proc = ci->proc;\n         irep = proc->body.irep;\n         pool = irep->pool;\n         syms = irep->syms;\n \n         ci[1].stack[0] = v;\n         mrb_gc_arena_restore(mrb, ai);\n       }\n       JUMP;\n     }\n \n     CASE(OP_BLKPUSH, BS) {\n       int m1 = (b>>11)&0x3f;\n       int r  = (b>>10)&0x1;\n       int m2 = (b>>5)&0x1f;\n       int kd = (b>>4)&0x1;\n       int lv = (b>>0)&0xf;\n       mrb_value *stack;\n \n       if (lv == 0) stack = regs + 1;\n       else {\n         struct REnv *e = uvenv(mrb, lv-1);\n         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n             MRB_ENV_LEN(e) <= m1+r+m2+1) {\n           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n           goto L_RAISE;\n         }\n         stack = e->stack + 1;\n       }\n       if (mrb_nil_p(stack[m1+r+m2+kd])) {\n         localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n         goto L_RAISE;\n       }\n       regs[a] = stack[m1+r+m2+kd];\n       NEXT;\n     }\n \n   L_INT_OVERFLOW:\n     {\n       mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n       mrb_exc_set(mrb, exc);\n     }\n     goto L_RAISE;\n \n #define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n #define OP_MATH(op_name)                                                    \\\n                                      \\\n   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n     OP_MATH_CASE_INTEGER(op_name);                                          \\\n     OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n     OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n     OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n     OP_MATH_CASE_STRING_##op_name();                                        \\\n     default:                                                                \\\n       mid = MRB_OPSYM(op_name);                                             \\\n       goto L_SEND_SYM;                                                      \\\n   }                                                                         \\\n   NEXT;\n #define OP_MATH_CASE_INTEGER(op_name)                                       \\\n   case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n     {                                                                       \\\n       mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n       if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n         OP_MATH_OVERFLOW_INT();                                             \\\n       else                                                                  \\\n         SET_INT_VALUE(mrb,regs[a], z);                                      \\\n     }                                                                       \\\n     break\n #ifdef MRB_NO_FLOAT\n #define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n #else\n #define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n   case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n     {                                                                           \\\n       mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n       SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n     }                                                                           \\\n     break\n #endif\n #define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n #define OP_MATH_CASE_STRING_add()                                           \\\n   case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n     regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n     mrb_gc_arena_restore(mrb, ai);                                          \\\n     break\n #define OP_MATH_CASE_STRING_sub() (void)0\n #define OP_MATH_CASE_STRING_mul() (void)0\n #define OP_MATH_OP_add +\n #define OP_MATH_OP_sub -\n #define OP_MATH_OP_mul *\n #define OP_MATH_TT_integer MRB_TT_INTEGER\n #define OP_MATH_TT_float   MRB_TT_FLOAT\n \n     CASE(OP_ADD, B) {\n       OP_MATH(add);\n     }\n \n     CASE(OP_SUB, B) {\n       OP_MATH(sub);\n     }\n \n     CASE(OP_MUL, B) {\n       OP_MATH(mul);\n     }\n \n     CASE(OP_DIV, B) {\n #ifndef MRB_NO_FLOAT\n       mrb_float x, y, f;\n #endif\n \n       switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n       case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n         {\n           mrb_int x = mrb_integer(regs[a]);\n           mrb_int y = mrb_integer(regs[a+1]);\n           mrb_int div = mrb_div_int(mrb, x, y);\n           SET_INT_VALUE(mrb, regs[a], div);\n         }\n         NEXT;\n #ifndef MRB_NO_FLOAT\n       case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n         x = (mrb_float)mrb_integer(regs[a]);\n         y = mrb_float(regs[a+1]);\n         break;\n       case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n         x = mrb_float(regs[a]);\n         y = (mrb_float)mrb_integer(regs[a+1]);\n         break;\n       case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n         x = mrb_float(regs[a]);\n         y = mrb_float(regs[a+1]);\n         break;\n #endif\n       default:\n         mid = MRB_OPSYM(div);\n         goto L_SEND_SYM;\n       }\n \n #ifndef MRB_NO_FLOAT\n       f = mrb_div_float(x, y);\n       SET_FLOAT_VALUE(mrb, regs[a], f);\n #endif\n       NEXT;\n     }\n \n #define OP_MATHI(op_name)                                                   \\\n                                      \\\n   switch (mrb_type(regs[a])) {                                              \\\n     OP_MATHI_CASE_INTEGER(op_name);                                         \\\n     OP_MATHI_CASE_FLOAT(op_name);                                           \\\n     default:                                                                \\\n       SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n       mid = MRB_OPSYM(op_name);                                             \\\n       goto L_SEND_SYM;                                                      \\\n   }                                                                         \\\n   NEXT;\n #define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n   case MRB_TT_INTEGER:                                                      \\\n     {                                                                       \\\n       mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n       if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n         OP_MATH_OVERFLOW_INT();                                             \\\n       else                                                                  \\\n         SET_INT_VALUE(mrb,regs[a], z);                                      \\\n     }                                                                       \\\n     break\n #ifdef MRB_NO_FLOAT\n #define OP_MATHI_CASE_FLOAT(op_name) (void)0\n #else\n #define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n   case MRB_TT_FLOAT:                                                        \\\n     {                                                                       \\\n       mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n       SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n     }                                                                       \\\n     break\n #endif\n \n     CASE(OP_ADDI, BB) {\n       OP_MATHI(add);\n     }\n \n     CASE(OP_SUBI, BB) {\n       OP_MATHI(sub);\n     }\n \n #define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n \n #ifdef MRB_NO_FLOAT\n #define OP_CMP(op,sym) do {\\\n   int result;\\\n   \\\n   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n     break;\\\n   default:\\\n     mid = MRB_OPSYM(sym);\\\n     goto L_SEND_SYM;\\\n   }\\\n   if (result) {\\\n     SET_TRUE_VALUE(regs[a]);\\\n   }\\\n   else {\\\n     SET_FALSE_VALUE(regs[a]);\\\n   }\\\n } while(0)\n #else\n #define OP_CMP(op, sym) do {\\\n   int result;\\\n   \\\n   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n     break;\\\n   case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n     result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n     break;\\\n   case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n     result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n     break;\\\n   case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n     result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n     break;\\\n   default:\\\n     mid = MRB_OPSYM(sym);\\\n     goto L_SEND_SYM;\\\n   }\\\n   if (result) {\\\n     SET_TRUE_VALUE(regs[a]);\\\n   }\\\n   else {\\\n     SET_FALSE_VALUE(regs[a]);\\\n   }\\\n } while(0)\n #endif\n \n     CASE(OP_EQ, B) {\n       if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n         SET_TRUE_VALUE(regs[a]);\n       }\n       else {\n         OP_CMP(==,eq);\n       }\n       NEXT;\n     }\n \n     CASE(OP_LT, B) {\n       OP_CMP(<,lt);\n       NEXT;\n     }\n \n     CASE(OP_LE, B) {\n       OP_CMP(<=,le);\n       NEXT;\n     }\n \n     CASE(OP_GT, B) {\n       OP_CMP(>,gt);\n       NEXT;\n     }\n \n     CASE(OP_GE, B) {\n       OP_CMP(>=,ge);\n       NEXT;\n     }\n \n     CASE(OP_ARRAY, BB) {\n       regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n     CASE(OP_ARRAY2, BBB) {\n       regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_ARYCAT, B) {\n       mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n       if (mrb_nil_p(regs[a])) {\n         regs[a] = splat;\n       }\n       else {\n         mrb_assert(mrb_array_p(regs[a]));\n         mrb_ary_concat(mrb, regs[a], splat);\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_ARYPUSH, BB) {\n       mrb_assert(mrb_array_p(regs[a]));\n       for (mrb_int i=0; i<b; i++) {\n         mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n       }\n       NEXT;\n     }\n \n     CASE(OP_ARYDUP, B) {\n       mrb_value ary = regs[a];\n       if (mrb_array_p(ary)) {\n         ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n       }\n       else {\n         ary = mrb_ary_new_from_values(mrb, 1, &ary);\n       }\n       regs[a] = ary;\n       NEXT;\n     }\n \n     CASE(OP_AREF, BBB) {\n       mrb_value v = regs[b];\n \n       if (!mrb_array_p(v)) {\n         if (c == 0) {\n           regs[a] = v;\n         }\n         else {\n           SET_NIL_VALUE(regs[a]);\n         }\n       }\n       else {\n         v = mrb_ary_ref(mrb, v, c);\n         regs[a] = v;\n       }\n       NEXT;\n     }\n \n     CASE(OP_ASET, BBB) {\n       mrb_assert(mrb_array_p(regs[a]));\n       mrb_ary_set(mrb, regs[b], c, regs[a]);\n       NEXT;\n     }\n \n     CASE(OP_APOST, BBB) {\n       mrb_value v = regs[a];\n       int pre  = b;\n       int post = c;\n       struct RArray *ary;\n       int len, idx;\n \n       if (!mrb_array_p(v)) {\n         v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n       }\n       ary = mrb_ary_ptr(v);\n       len = (int)ARY_LEN(ary);\n       if (len > pre + post) {\n         v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n         regs[a++] = v;\n         while (post--) {\n           regs[a++] = ARY_PTR(ary)[len-post-1];\n         }\n       }\n       else {\n         v = mrb_ary_new_capa(mrb, 0);\n         regs[a++] = v;\n         for (idx=0; idx+pre<len; idx++) {\n           regs[a+idx] = ARY_PTR(ary)[pre+idx];\n         }\n         while (idx < post) {\n           SET_NIL_VALUE(regs[a+idx]);\n           idx++;\n         }\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_INTERN, B) {\n       mrb_assert(mrb_string_p(regs[a]));\n       mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n       regs[a] = mrb_symbol_value(sym);\n       NEXT;\n     }\n \n     CASE(OP_SYMBOL, BB) {\n       size_t len;\n       mrb_sym sym;\n \n       mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n       len = pool[b].tt >> 2;\n       if (pool[b].tt & IREP_TT_SFLAG) {\n         sym = mrb_intern_static(mrb, pool[b].u.str, len);\n       }\n       else {\n         sym  = mrb_intern(mrb, pool[b].u.str, len);\n       }\n       regs[a] = mrb_symbol_value(sym);\n       NEXT;\n     }\n \n     CASE(OP_STRING, BB) {\n       mrb_int len;\n \n       mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n       len = pool[b].tt >> 2;\n       if (pool[b].tt & IREP_TT_SFLAG) {\n         regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n       }\n       else {\n         regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_STRCAT, B) {\n       mrb_assert(mrb_string_p(regs[a]));\n       mrb_str_concat(mrb, regs[a], regs[a+1]);\n       NEXT;\n     }\n \n     CASE(OP_HASH, BB) {\n       mrb_value hash = mrb_hash_new_capa(mrb, b);\n       int i;\n       int lim = a+b*2;\n \n       for (i=a; i<lim; i+=2) {\n         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n       }\n       regs[a] = hash;\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_HASHADD, BB) {\n       mrb_value hash;\n       int i;\n       int lim = a+b*2+1;\n \n       hash = regs[a];\n       mrb_ensure_hash_type(mrb, hash);\n       for (i=a+1; i<lim; i+=2) {\n         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n       }\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n     CASE(OP_HASHCAT, B) {\n       mrb_value hash = regs[a];\n \n       mrb_assert(mrb_hash_p(hash));\n       mrb_hash_merge(mrb, hash, regs[a+1]);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_LAMBDA, BB)\n     c = OP_L_LAMBDA;\n     L_MAKE_LAMBDA:\n     {\n       struct RProc *p;\n       const mrb_irep *nirep = irep->reps[b];\n \n       if (c & OP_L_CAPTURE) {\n         p = mrb_closure_new(mrb, nirep);\n       }\n       else {\n         p = mrb_proc_new(mrb, nirep);\n         p->flags |= MRB_PROC_SCOPE;\n       }\n       if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n       regs[a] = mrb_obj_value(p);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n     CASE(OP_BLOCK, BB) {\n       c = OP_L_BLOCK;\n       goto L_MAKE_LAMBDA;\n     }\n     CASE(OP_METHOD, BB) {\n       c = OP_L_METHOD;\n       goto L_MAKE_LAMBDA;\n     }\n \n     CASE(OP_RANGE_INC, B) {\n       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n       regs[a] = v;\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_RANGE_EXC, B) {\n       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n       regs[a] = v;\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_OCLASS, B) {\n       regs[a] = mrb_obj_value(mrb->object_class);\n       NEXT;\n     }\n \n     CASE(OP_CLASS, BB) {\n       struct RClass *c = 0, *baseclass;\n       mrb_value base, super;\n       mrb_sym id = syms[b];\n \n       base = regs[a];\n       super = regs[a+1];\n       if (mrb_nil_p(base)) {\n         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n         if (!baseclass) baseclass = mrb->object_class;\n         base = mrb_obj_value(baseclass);\n       }\n       c = mrb_vm_define_class(mrb, base, super, id);\n       regs[a] = mrb_obj_value(c);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_MODULE, BB) {\n       struct RClass *cls = 0, *baseclass;\n       mrb_value base;\n       mrb_sym id = syms[b];\n \n       base = regs[a];\n       if (mrb_nil_p(base)) {\n         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n         if (!baseclass) baseclass = mrb->object_class;\n         base = mrb_obj_value(baseclass);\n       }\n       cls = mrb_vm_define_module(mrb, base, id);\n       regs[a] = mrb_obj_value(cls);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_EXEC, BB)\n     {\n       mrb_value recv = regs[a];\n       struct RProc *p;\n       const mrb_irep *nirep = irep->reps[b];\n \n       p = mrb_proc_new(mrb, nirep);\n       p->c = NULL;\n       mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n       MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n       p->flags |= MRB_PROC_SCOPE;\n \n       cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n \n       irep = p->body.irep;\n       pool = irep->pool;\n       syms = irep->syms;\n       mrb_stack_extend(mrb, irep->nregs);\n       stack_clear(regs+1, irep->nregs-1);\n       pc = irep->iseq;\n       JUMP;\n     }\n \n     CASE(OP_DEF, BB) {\n       struct RClass *target = mrb_class_ptr(regs[a]);\n       struct RProc *p = mrb_proc_ptr(regs[a+1]);\n       mrb_method_t m;\n       mrb_sym mid = syms[b];\n \n       MRB_METHOD_FROM_PROC(m, p);\n       mrb_define_method_raw(mrb, target, mid, m);\n       mrb_method_added(mrb, target, mid);\n       mrb_gc_arena_restore(mrb, ai);\n       regs[a] = mrb_symbol_value(mid);\n       NEXT;\n     }\n \n     CASE(OP_SCLASS, B) {\n       regs[a] = mrb_singleton_class(mrb, regs[a]);\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_TCLASS, B) {\n       struct RClass *target = check_target_class(mrb);\n       if (!target) goto L_RAISE;\n       regs[a] = mrb_obj_value(target);\n       NEXT;\n     }\n \n     CASE(OP_ALIAS, BB) {\n       struct RClass *target = check_target_class(mrb);\n \n       if (!target) goto L_RAISE;\n       mrb_alias_method(mrb, target, syms[a], syms[b]);\n       mrb_method_added(mrb, target, syms[a]);\n       NEXT;\n     }\n     CASE(OP_UNDEF, B) {\n       struct RClass *target = check_target_class(mrb);\n \n       if (!target) goto L_RAISE;\n       mrb_undef_method_id(mrb, target, syms[a]);\n       NEXT;\n     }\n \n     CASE(OP_DEBUG, Z) {\n       FETCH_BBB();\n #ifdef MRB_USE_DEBUG_HOOK\n       mrb->debug_op_hook(mrb, irep, pc, regs);\n #else\n #ifndef MRB_NO_STDIO\n       printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n #else\n       abort();\n #endif\n #endif\n       NEXT;\n     }\n \n     CASE(OP_ERR, B) {\n       size_t len = pool[a].tt >> 2;\n       mrb_value exc;\n \n       mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n       exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n       mrb_exc_set(mrb, exc);\n       goto L_RAISE;\n     }\n \n     CASE(OP_EXT1, Z) {\n       insn = READ_B();\n       switch (insn) {\n #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n #include \"mruby/ops.h\"\n #undef OPCODE\n       }\n       pc--;\n       NEXT;\n     }\n     CASE(OP_EXT2, Z) {\n       insn = READ_B();\n       switch (insn) {\n #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n #include \"mruby/ops.h\"\n #undef OPCODE\n       }\n       pc--;\n       NEXT;\n     }\n     CASE(OP_EXT3, Z) {\n       uint8_t insn = READ_B();\n       switch (insn) {\n #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n #include \"mruby/ops.h\"\n #undef OPCODE\n       }\n       pc--;\n       NEXT;\n     }\n \n     CASE(OP_STOP, Z) {\n       CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n       }\n       CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n         UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n       }\n       CHECKPOINT_END(RBREAK_TAG_STOP);\n     L_STOP:\n       mrb->jmp = prev_jmp;\n       if (mrb->exc) {\n         mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n         return mrb_obj_value(mrb->exc);\n       }\n       return regs[irep->nlocals];\n     }\n   }\n   END_DISPATCH;\n #undef regs\n   }\n   MRB_CATCH(&c_jmp) {\n     mrb_callinfo *ci = mrb->c->ci;\n     while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n       ci = cipop(mrb);\n     }\n     exc_catched = TRUE;\n     pc = ci->pc;\n     goto RETRY_TRY_BLOCK;\n   }\n   MRB_END_EXC(&c_jmp);\n }\n \n", "target": "// fix_start\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-288", "cwe_name": "Authentication Bypass Using an Alternate Path or Channel", "cve": "CVE-2022-1212", "cve_desc": "Use-After-Free in str_escape in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.", "project": "mruby", "idx": 198439}
{"source": " PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len,\n \t\t\t\t      pjstun_msg *msg)\n {\n     pj_uint16_t msg_type, msg_len;\n     char *p_attr;\n// bug_start\n// bug_end\n \n     PJ_CHECK_STACK();\n \n     msg->hdr = (pjstun_msg_hdr*)buf;\n     msg_type = pj_ntohs(msg->hdr->type);\n \n     switch (msg_type) {\n     case PJSTUN_BINDING_REQUEST:\n     case PJSTUN_BINDING_RESPONSE:\n     case PJSTUN_BINDING_ERROR_RESPONSE:\n     case PJSTUN_SHARED_SECRET_REQUEST:\n     case PJSTUN_SHARED_SECRET_RESPONSE:\n     case PJSTUN_SHARED_SECRET_ERROR_RESPONSE:\n \tbreak;\n     default:\n \tPJ_LOG(4,(THIS_FILE, \"Error: unknown msg type %d\", msg_type));\n \treturn PJLIB_UTIL_ESTUNINMSGTYPE;\n     }\n \n     msg_len = pj_ntohs(msg->hdr->length);\n     if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) {\n \tPJ_LOG(4,(THIS_FILE, \"Error: invalid msg_len %d (expecting %d)\",\n \t\t\t     msg_len, buf_len - sizeof(pjstun_msg_hdr)));\n \treturn PJLIB_UTIL_ESTUNINMSGLEN;\n     }\n \n     msg->attr_count = 0;\n     p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n \n// bug_start\n    while (msg_len > 0) {\n// bug_end\n \tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n \tpj_uint32_t len;\n \tpj_uint16_t attr_type;\n \n \t*attr = (pjstun_attr_hdr*)p_attr;\n \tlen = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr);\n \tlen = (len + 3) & ~3;\n \n \tif (msg_len < len) {\n \t    PJ_LOG(4,(THIS_FILE, \"Error: length mismatch in attr %d\",\n \t\t\t\t msg->attr_count));\n \t    return PJLIB_UTIL_ESTUNINATTRLEN;\n \t}\n \n \tattr_type = pj_ntohs((*attr)->type);\n \tif (attr_type > PJSTUN_ATTR_REFLECTED_FROM &&\n \t    attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR)\n \t{\n \t    PJ_LOG(5,(THIS_FILE, \"Warning: unknown attr type %x in attr %d. \"\n \t\t\t\t \"Attribute was ignored.\",\n \t\t\t\t attr_type, msg->attr_count));\n \t}\n \n \tmsg_len = (pj_uint16_t)(msg_len - len);\n \tp_attr += len;\n \t++msg->attr_count;\n     }\n// bug_start\n// bug_end\n \n     return PJ_SUCCESS;\n }\n \n", "target": "// fix_start\n    int attr_max_cnt = PJ_ARRAY_SIZE(msg->attr);\n// fix_end\n// fix_start\n    while (msg_len > 0 && msg->attr_count < attr_max_cnt) {\n// fix_end\n// fix_start\n    if (msg->attr_count == attr_max_cnt) {\n\tPJ_LOG(4, (THIS_FILE, \"Warning: max number attribute %d reached.\",\n\t\t   attr_max_cnt));\n    }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-31031", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions prior to and including 2.12.1 a stack buffer overflow vulnerability affects PJSIP users that use STUN in their applications, either by: setting a STUN server in their account/media config in PJSUA/PJSUA2 level, or directly using `pjlib-util/stun_simple` API. A patch is available in commit 450baca which should be included in the next release. There are no known workarounds for this issue.", "project": "pjproject", "idx": 198449}
{"source": " void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,\n                          TfLiteTensor* output, bool requires_broadcast) {\n   if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n     auto input1_offset = -input1->params.zero_point;\n     auto input2_offset = -input2->params.zero_point;\n     const int left_shift = 8;\n \n     int32 input1_multiplier;\n// bug_start\n// bug_end\n     int input1_shift;\n// bug_start\n    QuantizeMultiplierSmallerThanOneExp(input1->params.scale,\n                                        &input1_multiplier, &input1_shift);\n    int32 input2_multiplier;\n// bug_end\n     int input2_shift;\n// bug_start\n    QuantizeMultiplierSmallerThanOneExp(input2->params.scale,\n                                        &input2_multiplier, &input2_shift);\n// bug_end\n \n     ComparisonParams op_params;\n     op_params.left_shift = left_shift;\n     op_params.input1_offset = input1_offset;\n     op_params.input1_multiplier = input1_multiplier;\n     op_params.input1_shift = input1_shift;\n     op_params.input2_offset = input2_offset;\n     op_params.input2_multiplier = input2_multiplier;\n     op_params.input2_shift = input2_shift;\n     if (requires_broadcast) {\n       reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(\n           op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n           GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n           GetTensorShape(output), GetTensorData<bool>(output));\n     } else {\n       reference_ops::ComparisonWithScaling<input_dtype, opname>(\n           op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n           GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n           GetTensorShape(output), GetTensorData<bool>(output));\n     }\n   }\n }\n \n", "target": "// fix_start\n    int32 input2_multiplier;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    QuantizeMultiplier(input1->params.scale, &input1_multiplier, &input1_shift);\n    QuantizeMultiplier(input2->params.scale, &input2_multiplier, &input2_shift);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-29212", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, certain TFLite models that were created using TFLite model converter would crash when loaded in the TFLite interpreter. The culprit is that during quantization the scale of values could be greater than 1 but code was always assuming sub-unit scaling. Thus, since code was calling `QuantizeMultiplierSmallerThanOneExp`, the `TFLITE_CHECK_LT` assertion would trigger and abort the process. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "project": "tensorflow", "idx": 198452}
{"source": " njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n     njs_index_t unused)\n {\n     njs_int_t           ret;\n     njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n     njs_frame_t         *frame, *async_frame;\n// bug_start\n    njs_function_t      *function;\n// bug_end\n     njs_async_ctx_t     *ctx;\n     njs_native_frame_t  *top, *async;\n \n     ctx = vm->top_frame->function->context;\n \n     value = njs_arg(args, nargs, 1);\n     if (njs_is_error(value)) {\n         goto failed;\n     }\n \n     async_frame = ctx->await;\n     async = &async_frame->native;\n     async->previous = vm->top_frame;\n// bug_start\n\n    function = async->function;\n// bug_end\n \n     cur_local = vm->levels[NJS_LEVEL_LOCAL];\n     cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n     cur_temp = vm->levels[NJS_LEVEL_TEMP];\n     top = vm->top_frame;\n     frame = vm->active_frame;\n \n     vm->levels[NJS_LEVEL_LOCAL] = async->local;\n     vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n     vm->levels[NJS_LEVEL_TEMP] = async->temp;\n \n     vm->top_frame = async;\n     vm->active_frame = async_frame;\n \n     *njs_scope_value(vm, ctx->index) = *value;\n     vm->retval = *value;\n \n     vm->top_frame->retval = &vm->retval;\n \n// bug_start\n    function->context = ctx->capability;\n    function->await = ctx;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n\n    function->context = NULL;\n    function->await = NULL;\n// bug_end\n \n     vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n     vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n     vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n \n     vm->top_frame = top;\n     vm->active_frame = frame;\n \n     if (ret == NJS_OK) {\n         ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                             &njs_value_undefined, &vm->retval, 1, &vm->retval);\n \n         njs_async_context_free(vm, ctx);\n \n     } else if (ret == NJS_AGAIN) {\n         ret = NJS_OK;\n \n     } else if (ret == NJS_ERROR) {\n         if (njs_is_memory_error(vm, &vm->retval)) {\n             return NJS_ERROR;\n         }\n \n         value = &vm->retval;\n \n         goto failed;\n     }\n \n     return ret;\n \n failed:\n \n     (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                              &njs_value_undefined, value, 1, &vm->retval);\n \n     njs_async_context_free(vm, ctx);\n \n     return NJS_ERROR;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    ret = njs_vmcode_interpreter(vm, ctx->pc, ctx->capability, ctx);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-25139", "cve_desc": "njs through 0.7.0, used in NGINX, was discovered to contain a heap use-after-free in njs_await_fulfilled.", "project": "njs", "idx": 198476}
{"source": " static int uECC_sign_with_k(const uint8_t *private_key,\n                             const uint8_t *message_hash,\n                             unsigned hash_size,\n                             uECC_word_t *k,\n                             uint8_t *signature,\n                             uECC_Curve curve) {\n \n     uECC_word_t tmp[uECC_MAX_WORDS];\n     uECC_word_t s[uECC_MAX_WORDS];\n     uECC_word_t *k2[2] = {tmp, s};\n// bug_start\n// bug_end\n #if uECC_VLI_NATIVE_LITTLE_ENDIAN\n     uECC_word_t *p = (uECC_word_t *)signature;\n #else\n     uECC_word_t p[uECC_MAX_WORDS * 2];\n #endif\n     uECC_word_t carry;\n     wordcount_t num_words = curve->num_words;\n     wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n     bitcount_t num_n_bits = curve->num_n_bits;\n \n     if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {\n         return 0;\n     }\n \n     carry = regularize_k(k, tmp, s, curve);\n// bug_start\n    EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);\n// bug_end\n     if (uECC_vli_isZero(p, num_words)) {\n         return 0;\n     }\n \n     if (!g_rng_function) {\n         uECC_vli_clear(tmp, num_n_words);\n         tmp[0] = 1;\n     } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {\n         return 0;\n     }\n \n     uECC_vli_modMult(k, k, tmp, curve->n, num_n_words);\n     uECC_vli_modInv(k, k, curve->n, num_n_words);\n     uECC_vli_modMult(k, k, tmp, curve->n, num_n_words);\n \n #if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n     uECC_vli_nativeToBytes(signature, curve->num_bytes, p);\n #endif\n \n #if uECC_VLI_NATIVE_LITTLE_ENDIAN\n     bcopy((uint8_t *) tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));\n #else\n     uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));\n #endif\n \n     s[num_n_words - 1] = 0;\n     uECC_vli_set(s, p, num_words);\n     uECC_vli_modMult(s, tmp, s, curve->n, num_n_words);\n \n     bits2int(tmp, message_hash, hash_size, curve);\n     uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words);\n     uECC_vli_modMult(s, s, k, curve->n, num_n_words);\n     if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {\n         return 0;\n     }\n #if uECC_VLI_NATIVE_LITTLE_ENDIAN\n     bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);\n #else\n     uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);\n #endif\n     return 1;\n }\n \n", "target": "// fix_start\n    uECC_word_t *initial_Z = 0;\n// fix_end\n// fix_start\n    if (g_rng_function) {\n        if (!uECC_generate_random_int(k2[carry], curve->p, num_words)) {\n            return 0;\n        }\n        initial_Z = k2[carry];\n    }\n    EccPoint_mult(p, curve->G, k2[!carry], initial_Z, num_n_bits + 1, curve);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2020-27209", "cve_desc": "The ECDSA operation of the micro-ecc library 1.0 is vulnerable to simple power analysis attacks which allows an adversary to extract the private ECC key.", "project": "micro-ecc", "idx": 198499}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor* stamp_token_t;\n     OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n     int64_t stamp_token = stamp_token_t->scalar<int64>()();\n \n     const Tensor* tree_ensemble_serialized_t;\n     OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                            &tree_ensemble_serialized_t));\n     std::unique_ptr<BoostedTreesEnsembleResource> result(\n         new BoostedTreesEnsembleResource());\n     if (!result->InitFromSerialized(\n             tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n       result->Unref();\n// bug_start\n// bug_end\n       OP_REQUIRES(\n           context, false,\n           errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n     }\n \n     auto status =\n         CreateResource(context, HandleFromInput(context, 0), result.release());\n     if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n       OP_REQUIRES_OK(context, status);\n     }\n   }\n \n", "target": "// fix_start\n      result.release();\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-37652", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198523}
{"source": " static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n \t\t     char *const argv[])\n {\n \tuint\tchip;\n \tuint\taddr, length;\n// bug_start\n\tint alen;\n\tint\tj, nbytes, linebytes;\n// bug_end\n \tint ret;\n #if CONFIG_IS_ENABLED(DM_I2C)\n \tstruct udevice *dev;\n #endif\n \n \tchip   = i2c_dp_last_chip;\n \taddr   = i2c_dp_last_addr;\n \talen   = i2c_dp_last_alen;\n \tlength = i2c_dp_last_length;\n \n \tif (argc < 3)\n \t\treturn CMD_RET_USAGE;\n \n \tif ((flag & CMD_FLAG_REPEAT) == 0) {\n \n \t\tchip = hextoul(argv[1], NULL);\n \n \t\taddr = hextoul(argv[2], NULL);\n \t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n \t\tif (alen > 3)\n \t\t\treturn CMD_RET_USAGE;\n \n \t\tif (argc > 3)\n \t\t\tlength = hextoul(argv[3], NULL);\n \t}\n \n #if CONFIG_IS_ENABLED(DM_I2C)\n \tret = i2c_get_cur_bus_chip(chip, &dev);\n \tif (!ret && alen != -1)\n \t\tret = i2c_set_chip_offset_len(dev, alen);\n \tif (ret)\n \t\treturn i2c_report_err(ret, I2C_ERR_READ);\n #endif\n \n \tnbytes = length;\n \tdo {\n \t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n \t\tunsigned char\t*cp;\n \n \t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n \n #if CONFIG_IS_ENABLED(DM_I2C)\n \t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n #else\n \t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n #endif\n \t\tif (ret)\n \t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n \t\telse {\n \t\t\tprintf(\"%04x:\", addr);\n \t\t\tcp = linebuf;\n \t\t\tfor (j=0; j<linebytes; j++) {\n \t\t\t\tprintf(\" %02x\", *cp++);\n \t\t\t\taddr++;\n \t\t\t}\n \t\t\tputs (\"    \");\n \t\t\tcp = linebuf;\n \t\t\tfor (j=0; j<linebytes; j++) {\n \t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n \t\t\t\t\tputs (\".\");\n \t\t\t\telse\n \t\t\t\t\tprintf(\"%c\", *cp);\n \t\t\t\tcp++;\n \t\t\t}\n \t\t\tputc ('\\n');\n \t\t}\n \t\tnbytes -= linebytes;\n \t} while (nbytes > 0);\n \n \ti2c_dp_last_chip   = chip;\n \ti2c_dp_last_addr   = addr;\n \ti2c_dp_last_alen   = alen;\n \ti2c_dp_last_length = length;\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\tuint\talen;\n\tuint\tj, nbytes, linebytes;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-34835", "cve_desc": "In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the \"i2c md\" command enables the corruption of the return address pointer of the do_i2c_md function.", "project": "u-boot", "idx": 198545}
{"source": " fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n {\n   struct mrb_context *c = fiber_check(mrb, self);\n   struct mrb_context *old_c = mrb->c;\n   enum mrb_fiber_state status;\n   mrb_value value;\n \n   fiber_check_cfunc(mrb, c);\n   status = c->status;\n   switch (status) {\n   case MRB_FIBER_TRANSFERRED:\n     if (resume) {\n       mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n     }\n     break;\n   case MRB_FIBER_RUNNING:\n   case MRB_FIBER_RESUMED:\n     mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n     break;\n   case MRB_FIBER_TERMINATED:\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n     break;\n   default:\n     break;\n   }\n   old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n   fiber_switch_context(mrb, c);\n   if (status == MRB_FIBER_CREATED) {\n     mrb_value *b, *e;\n \n     if (!c->ci->proc) {\n       mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n     }\n// bug_start\n    mrb_stack_extend(mrb, len+2);\n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n// bug_end\n     if (vmexec) {\n       c->ci--;\n// bug_start\n// bug_end\n     }\n     c->cibase->n = len;\n     value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n   }\n   else {\n     value = fiber_result(mrb, a, len);\n     if (vmexec) {\n       c->ci[1].stack[0] = value;\n     }\n   }\n \n   if (vmexec) {\n     c->vmexec = TRUE;\n     value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n     mrb->c = old_c;\n   }\n   else {\n     MARK_CONTEXT_MODIFY(c);\n   }\n   return value;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    }\n    if (len >= 15) {\n      mrb_stack_extend(mrb, 3);\n      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);\n      len = 15;\n    }\n    else {\n      mrb_stack_extend(mrb, len+2);\n      b = c->stbase+1;\n      e = b + len;\n      while (b<e) {\n        *b++ = *a++;\n      }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-0890", "cve_desc": "NULL Pointer Dereference in GitHub repository mruby/mruby prior to 3.2.", "project": "mruby", "idx": 198556}
{"source": " MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n     int pos = *decoded_size;\n     char mod = 'i';\n     char dir = '<';\n     char olddir;\n     unsigned char c;\n     while ((c = *rule++)) {\n         if (c <= 4) {\n             mod = (c <= 2) ? 'i' : 'd';\n             olddir = dir;\n             dir = (c & 2) ? '<' : '>';\n             if (olddir != dir && olddir) {\n                 pos = (c & 2) ? *decoded_size : 0;\n             }\n         }\n         else if (c > 10 && c < 20) {\n             if (dir == '>') {\n                 pos = *decoded_size;\n             }\n             pos -= c - 10;\n             dir = 0;\n// bug_start\n            if (pos < 0 || pos > *decoded_size) {\n                debug_print(\"Position setting failed (%s)\\n\", decoded);\n                return MOBI_DATA_CORRUPT;\n            }\n// bug_end\n         }\n         else {\n             if (mod == 'i') {\n                 const unsigned char *s = decoded + pos;\n                 unsigned char *d = decoded + pos + 1;\n                 const int l = *decoded_size - pos;\n// bug_start\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n// bug_end\n                     debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                     return MOBI_DATA_CORRUPT;\n                 }\n                 memmove(d, s, (size_t) l);\n                 decoded[pos] = c;\n                 (*decoded_size)++;\n                 if (dir == '>') { pos++; }\n             } else {\n                 if (dir == '<') { pos--; }\n                 const unsigned char *s = decoded + pos + 1;\n                 unsigned char *d = decoded + pos;\n                 const int l = *decoded_size - pos;\n// bug_start\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n// bug_end\n                     debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                     return MOBI_DATA_CORRUPT;\n                 }\n                 if (decoded[pos] != c) {\n                     debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                     return MOBI_DATA_CORRUPT;\n                 }\n                 memmove(d, s, (size_t) l);\n                 (*decoded_size)--;\n             }\n         }\n     }\n     return MOBI_SUCCESS;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n// fix_end\n// fix_start\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-1533", "cve_desc": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11. This vulnerability is capable of arbitrary code execution.", "project": "libmobi", "idx": 198566}
{"source": " ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n {\n     linenr_T\tcount;\n     char_u\t*p;\n \n     count = line2 - line1 + 1;\n     if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n     {\n \tcurbuf->b_op_start.lnum = n + 1;\n \tcurbuf->b_op_end.lnum = n + count;\n \tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n     }\n \n     if (u_save(n, n + 1) == FAIL)\n \treturn;\n \n     curwin->w_cursor.lnum = n;\n     while (line1 <= line2)\n     {\n \tp = vim_strsave(ml_get(line1));\n \tif (p != NULL)\n \t{\n \t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n \t    vim_free(p);\n \t}\n \tif (line1 == n)\n \t    line1 = curwin->w_cursor.lnum;\n \t++line1;\n \tif (curwin->w_cursor.lnum < line1)\n \t    ++line1;\n \tif (curwin->w_cursor.lnum < line2)\n \t    ++line2;\n \t++curwin->w_cursor.lnum;\n     }\n \n     appended_lines_mark(n, count);\n// bug_start\n// bug_end\n \n     msgmore((long)count);\n }\n \n", "target": "// fix_start\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0361", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 198662}
{"source": " int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n \t\t struct xfrm_migrate *m, int num_migrate,\n \t\t struct xfrm_kmaddress *k, struct net *net,\n \t\t struct xfrm_encap_tmpl *encap)\n {\n \tint i, err, nx_cur = 0, nx_new = 0;\n \tstruct xfrm_policy *pol = NULL;\n \tstruct xfrm_state *x, *xc;\n \tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n \tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n \tstruct xfrm_migrate *mp;\n \n \tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n \t\tgoto out;\n// bug_start\n// bug_end\n \n \tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n \t\terr = -ENOENT;\n \t\tgoto out;\n \t}\n \n \tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n \t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n \t\t\tx_cur[nx_cur] = x;\n \t\t\tnx_cur++;\n \t\t\txc = xfrm_state_migrate(x, mp, encap);\n \t\t\tif (xc) {\n \t\t\t\tx_new[nx_new] = xc;\n \t\t\t\tnx_new++;\n \t\t\t} else {\n \t\t\t\terr = -ENODATA;\n \t\t\t\tgoto restore_state;\n \t\t\t}\n \t\t}\n \t}\n \n \tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n \t\tgoto restore_state;\n \n \tif (nx_cur) {\n \t\txfrm_states_put(x_cur, nx_cur);\n \t\txfrm_states_delete(x_cur, nx_cur);\n \t}\n \n \tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n \n \txfrm_pol_put(pol);\n \n \treturn 0;\n out:\n \treturn err;\n \n restore_state:\n \tif (pol)\n \t\txfrm_pol_put(pol);\n \tif (nx_cur)\n \t\txfrm_states_put(x_cur, nx_cur);\n \tif (nx_new)\n \t\txfrm_states_delete(x_new, nx_new);\n \n \treturn err;\n }\n \n", "target": "// fix_start\n\n\tif (dir >= XFRM_POLICY_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2017-11600", "cve_desc": "net/xfrm/xfrm_policy.c in the Linux kernel through 4.12.3, when CONFIG_XFRM_MIGRATE is enabled, does not ensure that the dir value of xfrm_userpolicy_id is XFRM_POLICY_MAX or less, which allows local users to cause a denial of service (out-of-bounds access) or possibly have unspecified other impact via an XFRM_MSG_MIGRATE xfrm Netlink message.", "project": "ipsec", "idx": 198692}
{"source": " mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n {\n \tmodule->cleanUp();\n \n \tTXMHeader*\t\theader = &module->header;\n \tTXMInstrument*\tinstr  = module->instr;\n \tTXMSample*\t\tsmp\t   = module->smp;\n \tTXMPattern*\t\tphead  = module->phead;\n \n \tif (!phead || !instr || !smp)\n \t\treturn MP_OUT_OF_MEMORY;\n \n \tf.read(&header->name,1,28);\n \theader->whythis1a = f.readByte();\n \n \tif (f.readByte() != 16)\n \t\treturn MP_LOADER_FAILED;\n \n \tf.readByte();\n \tf.readByte();\n \n \theader->ordnum = f.readWord();\n \n \tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n \tif (orders == NULL)\n \t\treturn MP_OUT_OF_MEMORY;\n \n \theader->insnum = f.readWord();\n// bug_start\n// bug_end\n \theader->patnum = f.readWord();\n// bug_start\n// bug_end\n \n \tmp_sint32 flags = f.readWord();\n \n \tmp_sint32 Cvt = f.readWord();\n \n \theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n \n \tif (Cvt == 0x1300 || (flags & 64))\n \t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n \n \theader->flags |= module->MODULE_ST3NOTECUT;\n \n \tf.readWord();\n \n \tf.read(header->sig,1,4);\n \n \theader->mainvol = module->vol64to255(f.readByte());\n \n \theader->tempo = f.readByte();\n \n \theader->speed = f.readByte();\n \n \tf.readByte();\n \n \tf.readByte();\n \n \tf.readByte();\n \n \tf.readDword();\n \tf.readDword();\n \tf.readWord();\n \n \tmp_ubyte channelSettings[32];\n \tf.read(channelSettings,1,32);\n \n \tmp_sint32 numChannels = 0;\n \n \tfor (numChannels = 0; numChannels < 32; numChannels++)\n \t\tif (channelSettings[numChannels] == 255)\n \t\t\tbreak;\n \n \theader->channum = numChannels;\n \n \tf.read(orders,1,header->ordnum);\n \n \tmp_sint32 j = 0, i = 0;\n \tfor (i = 0; i < header->ordnum; i++)\n \t{\n \t\tif (orders[i] == 255)\n \t\t\tbreak;\n \n \t\theader->ord[j++] = orders[i];\n \t}\n \n \theader->ordnum = j;\n \n \tdelete[] orders;\n \n \tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n \n \tif (insParaPtrs == NULL)\n \t\treturn MP_OUT_OF_MEMORY;\n \n \tf.readWords(insParaPtrs,header->insnum);\n \n \tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n \n \tif (patParaPtrs == NULL)\n \t{\n \t\tdelete[] insParaPtrs;\n \t\treturn MP_OUT_OF_MEMORY;\n \t}\n \n \tf.readWords(patParaPtrs,header->patnum);\n \n \n \tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n \tif (samplePtrs == NULL)\n \t{\n \t\tdelete[] insParaPtrs;\n \t\tdelete[] patParaPtrs;\n \t\treturn MP_OUT_OF_MEMORY;\n \t}\n \n \tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n \n \tmp_sint32 s = 0;\n \tfor (i = 0; i < header->insnum; i++)\n \t{\n \t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n \n \t\tif (insOffs)\n \t\t{\n \t\t\tf.seekWithBaseOffset(insOffs);\n \n \t\t\tmp_ubyte type = f.readByte();\n \n \t\t\tif (type == 1)\n \t\t\t{\n \t\t\t\tf.read(smp[s].name,1,12);\n \n \t\t\t\tmp_ubyte bOffs = f.readByte();\n \t\t\t\tmp_uword wOffs = f.readWord();\n \n \t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n \n \t\t\t\tsmp[s].flags = 1;\n \t\t\t\tsmp[s].pan = 0x80;\n \n \t\t\t\tsmp[s].samplen = f.readDword();\n \t\t\t\tsmp[s].loopstart = f.readDword();\n \t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n \t\t\t\tif (looplen < 0)\n \t\t\t\t\tlooplen = 0;\n \t\t\t\tsmp[s].looplen = looplen;\n \n \t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n \n \t\t\t\tf.readByte();\n \n \t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0;\n \n \t\t\t\tmp_ubyte flags = f.readByte();\n \n \t\t\t\tif (flags & 1)\n \t\t\t\t{\n \t\t\t\t\tsmp[s].type = 1;\n \t\t\t\t}\n \n \t\t\t\tif (flags & 4)\n \t\t\t\t{\n \t\t\t\t\tsmp[s].type |= 16;\n \t\t\t\t\tsmp[s].samplen >>= 1;\n \t\t\t\t\tsmp[s].loopstart >>= 1;\n \t\t\t\t\tsmp[s].looplen >>= 1;\n \t\t\t\t}\n \n \t\t\t\tmp_uint32 c4spd = f.readDword();\n \n \t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n \n #ifdef VERBOSE\n \t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\n #endif\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tf.read(instr[i].name,1,28);\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n \t\t\t\t{\n \t\t\t\t\tinstr[i].samp=1;\n \t\t\t\t\tfor (j=0;j<120;j++)\n \t\t\t\t\t\tinstr[i].snum[j] = s;\n \t\t\t\t\ts++;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (type == 0)\n \t\t\t{\n \t\t\t\tsamplePtrs[i] = 0;\n \n \t\t\t\tmp_ubyte buffer[12];\n \t\t\t\tf.read(buffer,1,12);\n \n \t\t\t\tf.readByte();\n \t\t\t\tf.readWord();\n \n \t\t\t\tf.readDword();\n \t\t\t\tf.readDword();\n \t\t\t\tf.readDword();\n \t\t\t\tf.readByte();\n \t\t\t\tf.readByte();\n \t\t\t\tf.readByte();\n \n \t\t\t\tf.readByte();\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tf.readDword();\n \n \t\t\t\tf.read(instr[i].name,1,28);\n \n \t\t\t\tf.readDword();\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tsamplePtrs[i] = 0;\n \t\t\t}\n \n \t\t}\n \n \t}\n \n \tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n \tif (pattern == NULL)\n \t{\n \t\tdelete[] insParaPtrs;\n \t\tdelete[] patParaPtrs;\n \t\tdelete[] samplePtrs;\n \t\treturn MP_OUT_OF_MEMORY;\n \t}\n \n \tmp_uint32 songMaxChannels = 1;\n \n \tfor (i = 0; i < header->patnum; i++)\n \t{\n \t\tfor (j = 0; j < 32*64; j++)\n \t\t{\n \t\t\tpattern[j*5] = 0xFF;\n \t\t\tpattern[j*5+1] = 0;\n \t\t\tpattern[j*5+2] = 0xFF;\n \t\t\tpattern[j*5+3] = 0xFF;\n \t\t\tpattern[j*5+4] = 0;\n \t\t}\n \n \t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n \n \t\tmp_uint32 maxChannels = 1;\n \n \t\tif (patOffs)\n \t\t{\n \t\t\tf.seekWithBaseOffset(patOffs);\n \n \t\t\tmp_uint32 size = f.readWord();\n \n \t\t\tif (size > 2)\n \t\t\t{\n \t\t\t\tsize-=2;\n \n \t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n \t\t\t\tif (packed == NULL)\n \t\t\t\t{\n \t\t\t\t\tdelete[] insParaPtrs;\n \t\t\t\t\tdelete[] patParaPtrs;\n \t\t\t\t\tdelete[] samplePtrs;\n \t\t\t\t\tdelete[] pattern;\n \t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \t\t\t\t}\n \n \t\t\t\tmemset(packed, 0, size);\n \t\t\t\tf.read(packed, 1, size);\n \n \t\t\t\tmp_uint32 index = 0;\n \t\t\t\tmp_uint32 row = 0;\n \n \t\t\t\twhile (index<size)\n \t\t\t\t{\n \n \t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n \n \t\t\t\t\tif (pi == 0)\n \t\t\t\t\t{\n \t\t\t\t\t\trow++;\n \t\t\t\t\t\tif (row >= 64)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tint i = 0;\n \t\t\t\t\t\t\ti++;\n \t\t\t\t\t\t\ti--;\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tmp_uint32 chn = pi&31;\n \n \t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n \t\t\t\t\t{\n \t\t\t\t\t\tmaxChannels = chn;\n \t\t\t\t\t}\n \n \t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n \n \t\t\t\t\tif (pi & 32)\n \t\t\t\t\t{\n \t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n \t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n \t\t\t\t\t}\n \t\t\t\t\tif (pi & 64)\n \t\t\t\t\t{\n \t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n \t\t\t\t\t}\n \t\t\t\t\tif (pi & 128)\n \t\t\t\t\t{\n \t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n \t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n \t\t\t\t\t}\n \n \t\t\t\t}\n \n \t\t\t\tmaxChannels++;\n \n \t\t\t\tif (maxChannels > header->channum)\n \t\t\t\t\tmaxChannels = header->channum;\n \n \t\t\t\tdelete[] packed;\n \t\t\t}\n \n \t\t\tif (maxChannels > songMaxChannels)\n \t\t\t\tsongMaxChannels = maxChannels;\n \n \t\t}\n \n \t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n \n \n \t}\n \n \tif (header->channum > songMaxChannels)\n \t\theader->channum = songMaxChannels;\n \n \tdelete[] pattern;\n \tdelete[] insParaPtrs;\n \tdelete[] patParaPtrs;\n \n \ts = 0;\n \tfor (i = 0; i < header->insnum; i++)\n \t{\n \t\tmp_uint32 smpOffs = samplePtrs[i];\n \n \t\tif (smpOffs)\n \t\t{\n \t\t\tf.seekWithBaseOffset(smpOffs);\n \n \t\t\tif (!smp[s].samplen)\n \t\t\t\tcontinue;\n \n \t\t\tbool adpcm = (smp[s].res == 0xAD);\n \n \t\t\tmp_sint32 result = module->loadModuleSample(f, s,\n \t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED,\n \t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n \t\t\tif (result != MP_OK)\n \t\t\t{\n \t\t\t\tdelete[] samplePtrs;\n \t\t\t\treturn result;\n \t\t\t}\n \n \t\t\tif (adpcm)\n \t\t\t\tsmp[s].res = 0;\n \n \t\t\ts++;\n \n \t\t}\n \n \t}\n \n \tdelete[] samplePtrs;\n \n \theader->smpnum = s;\n \n \tstrcpy(header->tracker,\"Screamtracker 3\");\n \n \tmodule->setDefaultPanning();\n \n \tmodule->postProcessSamples();\n \n \treturn MP_OK;\n }\n \n", "target": "// fix_start\n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n// fix_end\n// fix_start\n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2019-14464", "cve_desc": "XMFile::read in XMFile.cpp in milkyplay in MilkyTracker 1.02.00 has a heap-based buffer overflow.", "project": "MilkyTracker", "idx": 198695}
{"source": " int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n// bug_start\n  int c, tag, len;\n// bug_end\n   uchar data[0x10000];\n   const uchar *dp;\n \n   memset (jh, 0, sizeof *jh);\n   jh->restart = INT_MAX;\n   fread (data, 2, 1, ifp);\n   if (data[1] != 0xd8) return 0;\n   do {\n     fread (data, 2, 2, ifp);\n     tag =  data[0] << 8 | data[1];\n     len = (data[2] << 8 | data[3]) - 2;\n     if (tag <= 0xff00) return 0;\n     fread (data, 1, len, ifp);\n     switch (tag) {\n       case 0xffc3:\n \tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n       case 0xffc0:\n \tjh->bits = data[0];\n \tjh->high = data[1] << 8 | data[2];\n \tjh->wide = data[3] << 8 | data[4];\n \tjh->clrs = data[5] + jh->sraw;\n \tif (len == 9 && !dng_version) getc(ifp);\n \tbreak;\n       case 0xffc4:\n \tif (info_only) break;\n \tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n \t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n \tbreak;\n       case 0xffda:\n \tjh->psv = data[1+data[0]*2];\n \tjh->bits -= data[3+data[0]*2] & 15;\n \tbreak;\n       case 0xffdd:\n \tjh->restart = data[0] << 8 | data[1];\n     }\n   } while (tag != 0xffda);\n   if (info_only) return 1;\n   if (jh->clrs > 6 || !jh->huff[0]) return 0;\n   FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n   if (jh->sraw) {\n     FORC(4)        jh->huff[2+c] = jh->huff[1];\n     FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n   }\n   jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n   merror (jh->row, \"ljpeg_start()\");\n   return zero_after_ff = 1;\n }\n \n", "target": "// fix_start\n  int c, tag;\n  ushort len;\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2015-3885", "cve_desc": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.", "project": "LibRaw", "idx": 198703}
{"source": " static int rsi_send_beacon(struct rsi_common *common)\n {\n \tstruct sk_buff *skb = NULL;\n \tu8 dword_align_bytes = 0;\n \n \tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n \tif (!skb)\n \t\treturn -ENOMEM;\n \n \tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n \n \tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n \tif (dword_align_bytes)\n \t\tskb_pull(skb, (64 - dword_align_bytes));\n \tif (rsi_prepare_beacon(common, skb)) {\n \t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n// bug_start\n// bug_end\n \t\treturn -EINVAL;\n \t}\n \tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n \trsi_set_event(&common->tx_thread.event);\n \trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tdev_kfree_skb(skb);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19071", "cve_desc": "A memory leak in the rsi_send_beacon() function in drivers/net/wireless/rsi/rsi_91x_mgmt.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering rsi_prepare_beacon() failures, aka CID-d563131ef23c.", "project": "linux", "idx": 198736}
{"source": " static ptrdiff_t finderrfunc(lua_State *L)\n {\n   cTValue *frame = L->base-1, *bot = tvref(L->stack);\n   void *cf = L->cframe;\n   while (frame > bot && cf) {\n     while (cframe_nres(cframe_raw(cf)) < 0) {\n       if (frame >= restorestack(L, -cframe_nres(cf)))\n \tbreak;\n       if (cframe_errfunc(cf) >= 0)\n \treturn cframe_errfunc(cf);\n       cf = cframe_prev(cf);\n       if (cf == NULL)\n \treturn 0;\n     }\n     switch (frame_typep(frame)) {\n     case FRAME_LUA:\n     case FRAME_LUAP:\n       frame = frame_prevl(frame);\n       break;\n     case FRAME_C:\n       cf = cframe_prev(cf);\n     case FRAME_VARG:\n       frame = frame_prevd(frame);\n       break;\n     case FRAME_CONT:\n #if LJ_HASFFI\n       if ((frame-1)->u32.lo == LJ_CONT_FFI_CALLBACK)\n \tcf = cframe_prev(cf);\n #endif\n       frame = frame_prevd(frame);\n       break;\n     case FRAME_CP:\n       if (cframe_canyield(cf)) return 0;\n       if (cframe_errfunc(cf) >= 0)\n \treturn cframe_errfunc(cf);\n// bug_start\n// bug_end\n       frame = frame_prevd(frame);\n       break;\n     case FRAME_PCALL:\n     case FRAME_PCALLH:\n       if (frame_ftsz(frame) >= (ptrdiff_t)(2*sizeof(TValue)))\n \treturn savestack(L, frame-1);\n       return 0;\n     default:\n       lua_assert(0);\n       return 0;\n     }\n   }\n   return 0;\n }\n \n", "target": "// fix_start\n      cf = cframe_prev(cf);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-15890", "cve_desc": "LuaJit through 2.1.0-beta3 has an out-of-bounds read because __gc handler frame traversal is mishandled.", "project": "LuaJIT", "idx": 198743}
{"source": " RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n \tif (!bin->entry_table) {\n \t\treturn NULL;\n \t}\n \tRList *entries = r_list_newf (free);\n \tif (!entries) {\n \t\treturn NULL;\n \t}\n \tRList *segments = r_bin_ne_get_segments (bin);\n \tif (!segments) {\n \t\tr_list_free (entries);\n \t\treturn NULL;\n \t}\n \tif (bin->ne_header->csEntryPoint) {\n \t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n \t\tif (!entry) {\n \t\t\tr_list_free (entries);\n \t\t\treturn NULL;\n \t\t}\n \t\tentry->bits = 16;\n \t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n \t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n \t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n \n \t\tr_list_append (entries, entry);\n \t}\n \tint off = 0;\n \tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n \twhile (off < bin->ne_header->EntryTableLength) {\n \t\tif (tableat + off >= r_buf_size (bin->buf)) {\n \t\t\tbreak;\n \t\t}\n \t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n \t\tif (!bundle_length) {\n \t\t\tbreak;\n \t\t}\n \t\toff++;\n \t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n \t\toff++;\n \t\tint i;\n \t\tfor (i = 0; i < bundle_length; i++) {\n \t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n \t\t\tif (!entry) {\n \t\t\t\tr_list_free (entries);\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\toff++;\n \t\t\tif (!bundle_type) {\n \t\t\t\toff--;\n \t\t\t\tfree (entry);\n \t\t\t\tbreak;\n \t\t\t} else if (bundle_type == 0xff) {\n \t\t\t\toff += 2;\n \t\t\t\tut8 segnum = *(bin->entry_table + off);\n \t\t\t\toff++;\n// bug_start\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n// bug_end\n \t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n \t\t\t\t}\n \t\t\t} else {\n// bug_start\n// bug_end\n \t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n \t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n// bug_start\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n// bug_end\n \t\t\t\t}\n \t\t\t}\n \t\t\toff += 2;\n \t\t\tr_list_append (entries, entry);\n \t\t}\n \t}\n \tr_list_free (segments);\n \tbin->entries = entries;\n \treturn entries;\n }\n \n", "target": "// fix_start\n\t\t\t\tif (off > bin->ne_header->EntryTableLength) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 segoff = r_read_le16 (bin->entry_table + off);\n\t\t\t\tif (segnum > 0 && segnum < bin->ne_header->SegCount) {\n// fix_end\n// fix_start\n\t\t\t\tif (off + 2 >= bin->ne_header->EntryTableLength) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 delta = r_read_le16 (bin->entry_table + off);\n// fix_end\n// fix_start\n\t\t\t\t\t\t* bin->alignment + delta;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-1297", "cve_desc": "Out-of-bounds Read in r_bin_ne_get_entrypoints function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read sensitive information or cause a crash.", "project": "radare2", "idx": 198927}
{"source": " SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                         uint32_t *dataoffset, uint16_t *hdrflags,\n                         uint8_t *hdrversion, bool quiet)\n {\n     blobheader *bh = (blobheader *)data;\n// bug_start\n// bug_end\n \n     if (length < sizeof(bh)) {\n         if (!quiet)\n             logprintf(STDERR_FILENO,\n                       \"not enough bytes for header: %u\\n\", length);\n         return TPM_BAD_PARAMETER;\n     }\n \n     if (ntohl(bh->totlen) != length) {\n         if (!quiet)\n             logprintf(STDERR_FILENO,\n                       \"broken header: bh->totlen %u != %u\\n\",\n                       htonl(bh->totlen), length);\n         return TPM_BAD_PARAMETER;\n     }\n \n     if (bh->min_version > BLOB_HEADER_VERSION) {\n         if (!quiet)\n             logprintf(STDERR_FILENO,\n                       \"Minimum required version for the blob is %d, we \"\n                       \"only support version %d\\n\", bh->min_version,\n                       BLOB_HEADER_VERSION);\n         return TPM_BAD_VERSION;\n     }\n \n// bug_start\n// bug_end\n     *hdrversion = bh->version;\n// bug_start\n    *dataoffset = ntohs(bh->hdrsize);\n// bug_end\n     *hdrflags = ntohs(bh->flags);\n \n     return TPM_SUCCESS;\n }\n \n", "target": "// fix_start\n    uint16_t hdrsize;\n// fix_end\n// fix_start\n    hdrsize = ntohs(bh->hdrsize);\n    if (hdrsize != sizeof(blobheader)) {\n        logprintf(STDERR_FILENO,\n                  \"bad header size: %u != %zu\\n\",\n                  hdrsize, sizeof(blobheader));\n        return TPM_BAD_DATASIZE;\n    }\n\n// fix_end\n// fix_start\n    *dataoffset = hdrsize;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-23645", "cve_desc": "swtpm is a libtpms-based TPM emulator with socket, character device, and Linux CUSE interface. Versions prior to 0.5.3, 0.6.2, and 0.7.1 are vulnerable to out-of-bounds read. A specially crafted header of swtpm's state, where the blobheader's hdrsize indicator has an invalid value, may cause an out-of-bounds access when the byte array representing the state of the TPM is accessed. This will likely crash swtpm or prevent it from starting since the state cannot be understood. Users should upgrade to swtpm v0.5.3, v0.6.2, or v0.7.1 to receive a patch. There are currently no known workarounds.", "project": "swtpm", "idx": 198983}
{"source": " static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n {\n \tint err = 0;\n \tunsigned int saved_f_flags;\n \tstruct snd_pcm_substream *substream;\n \tstruct snd_pcm_runtime *runtime;\n \tsnd_pcm_format_t format;\n \tunsigned long width;\n \tsize_t size;\n \n \tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n \tif (substream != NULL) {\n \t\truntime = substream->runtime;\n \t\tif (atomic_read(&substream->mmap_count))\n \t\t\tgoto __direct;\n// bug_start\n\t\terr = snd_pcm_oss_make_ready(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n// bug_end\n \t\tatomic_inc(&runtime->oss.rw_ref);\n \t\tif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\n \t\t\tatomic_dec(&runtime->oss.rw_ref);\n \t\t\treturn -ERESTARTSYS;\n \t\t}\n// bug_start\n// bug_end\n \t\tformat = snd_pcm_oss_format_from(runtime->oss.format);\n \t\twidth = snd_pcm_format_physical_width(format);\n \t\tif (runtime->oss.buffer_used > 0) {\n #ifdef OSS_DEBUG\n \t\t\tpcm_dbg(substream->pcm, \"sync: buffer_used\\n\");\n #endif\n \t\t\tsize = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width;\n \t\t\tsnd_pcm_format_set_silence(format,\n \t\t\t\t\t\t   runtime->oss.buffer + runtime->oss.buffer_used,\n \t\t\t\t\t\t   size);\n \t\t\terr = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);\n \t\t\tif (err < 0)\n \t\t\t\tgoto unlock;\n \t\t} else if (runtime->oss.period_ptr > 0) {\n #ifdef OSS_DEBUG\n \t\t\tpcm_dbg(substream->pcm, \"sync: period_ptr\\n\");\n #endif\n \t\t\tsize = runtime->oss.period_bytes - runtime->oss.period_ptr;\n \t\t\tsnd_pcm_format_set_silence(format,\n \t\t\t\t\t\t   runtime->oss.buffer,\n \t\t\t\t\t\t   size * 8 / width);\n \t\t\terr = snd_pcm_oss_sync1(substream, size);\n \t\t\tif (err < 0)\n \t\t\t\tgoto unlock;\n \t\t}\n \t\tsize = runtime->control->appl_ptr % runtime->period_size;\n \t\tif (size > 0) {\n \t\t\tsize = runtime->period_size - size;\n \t\t\tif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)\n \t\t\t\tsnd_pcm_lib_write(substream, NULL, size);\n \t\t\telse if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n \t\t\t\tsnd_pcm_lib_writev(substream, NULL, size);\n \t\t}\n unlock:\n \t\tmutex_unlock(&runtime->oss.params_lock);\n \t\tatomic_dec(&runtime->oss.rw_ref);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t      __direct:\n \t\tsaved_f_flags = substream->f_flags;\n \t\tsubstream->f_flags &= ~O_NONBLOCK;\n \t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\n \t\tsubstream->f_flags = saved_f_flags;\n \t\tif (err < 0)\n \t\t\treturn err;\n \t\tmutex_lock(&runtime->oss.params_lock);\n \t\truntime->oss.prepare = 1;\n \t\tmutex_unlock(&runtime->oss.params_lock);\n \t}\n \n \tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n \tif (substream != NULL) {\n \t\terr = snd_pcm_oss_make_ready(substream);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t\truntime = substream->runtime;\n \t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t\tmutex_lock(&runtime->oss.params_lock);\n \t\truntime->oss.buffer_used = 0;\n \t\truntime->oss.prepare = 1;\n \t\tmutex_unlock(&runtime->oss.params_lock);\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t\terr = snd_pcm_oss_make_ready_locked(substream);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2022-3303", "cve_desc": "A race condition flaw was found in the Linux kernel sound subsystem due to improper locking. It could lead to a NULL pointer dereference while handling the SNDCTL_DSP_SYNC ioctl. A privileged local user (root or member of the audio group) could use this flaw to crash the system, resulting in a denial of service condition", "project": "linux", "idx": 199159}
{"source": " static void rtrs_clt_dev_release(struct device *dev)\n {\n \tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n \t\t\t\t\t\t dev);\n \n// bug_start\n// bug_end\n \tkfree(clt);\n }\n \n", "target": "// fix_start\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2022-29156", "cve_desc": "drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12 has a double free related to rtrs_clt_dev_release.", "project": "linux", "idx": 199712}
{"source": " inbound_cap_ls (server *serv, char *nick, char *extensions_str,\n \t\t\t\t\t const message_tags_data *tags_data)\n {\n \tchar buffer[256];\n// bug_start\n\tguint32 want_cap;\n\tguint32 want_sasl;\n// bug_end\n \tchar **extensions;\n \tint i;\n \n \tEMIT_SIGNAL_TIMESTAMP (XP_TE_CAPLIST, serv->server_session, nick,\n \t\t\t\t\t\t\t\t  extensions_str, NULL, NULL, 0, tags_data->timestamp);\n// bug_start\n\twant_cap = 0;\n\twant_sasl = 0;\n// bug_end\n \n \textensions = g_strsplit (extensions_str, \" \", 0);\n \n \tstrcpy (buffer, \"CAP REQ :\");\n \n \tfor (i=0; extensions[i]; i++)\n \t{\n \t\tconst char *extension = extensions[i];\n// bug_start\n// bug_end\n \n// bug_start\n\t\tif (!strcmp (extension, \"identify-msg\"))\n// bug_end\n \t\t{\n// bug_start\n\t\t\tstrcat (buffer, \"identify-msg \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"multi-prefix\"))\n\t\t{\n\t\t\tstrcat (buffer, \"multi-prefix \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"away-notify\"))\n\t\t{\n\t\t\tstrcat (buffer, \"away-notify \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"account-notify\"))\n\t\t{\n\t\t\tstrcat (buffer, \"account-notify \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"extended-join\"))\n\t\t{\n\t\t\tstrcat (buffer, \"extended-join \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"userhost-in-names\"))\n\t\t{\n\t\t\tstrcat (buffer, \"userhost-in-names \");\n\t\t\twant_cap = 1;\n// bug_end\n \t\t}\n \n// bug_start\n\t\tif (!strcmp (extension, \"znc.in/server-time-iso\"))\n// bug_end\n \t\t{\n// bug_start\n\t\t\tstrcat (buffer, \"znc.in/server-time-iso \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (!strcmp (extension, \"znc.in/server-time\"))\n\t\t{\n\t\t\tstrcat (buffer, \"znc.in/server-time \");\n\t\t\twant_cap = 1;\n\t\t}\n\t\tif (prefs.hex_irc_cap_server_time\n\t\t\t && !strcmp (extension, \"server-time\"))\n\t\t{\n\t\t\tstrcat (buffer, \"server-time \");\n\t\t\twant_cap = 1;\n\t\t}\n\n\t\tif (!strcmp (extension, \"sasl\")\n\t\t\t&& ((serv->loginmethod == LOGIN_SASL && strlen (serv->password) != 0)\n\t\t\t|| (serv->loginmethod == LOGIN_SASLEXTERNAL && serv->have_cert)))\n\t\t{\n\t\t\tstrcat (buffer, \"sasl \");\n\t\t\twant_cap = 1;\n\t\t\twant_sasl = 1;\n// bug_end\n \t\t}\n \t}\n \n \tg_strfreev (extensions);\n \n \tif (want_cap)\n \t{\n \t\tEMIT_SIGNAL_TIMESTAMP (XP_TE_CAPREQ, serv->server_session,\n \t\t\t\t\t\t\t\t\t  buffer + 9, NULL, NULL, NULL, 0,\n \t\t\t\t\t\t\t\t\t  tags_data->timestamp);\n \t\ttcp_sendf (serv, \"%s\\r\\n\", g_strchomp (buffer));\n \t}\n \tif (!want_sasl)\n \t{\n \t\tserv->sent_capend = TRUE;\n \t\ttcp_send_len (serv, \"CAP END\\r\\n\", 9);\n \t}\n }\n \n", "target": "// fix_start\n\tgboolean want_cap = FALSE;\n\tgboolean want_sasl = FALSE;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tgsize x;\n// fix_end\n// fix_start\n\t\tif (!g_strcmp0 (extension, \"sasl\") &&\n\t\t\t((serv->loginmethod == LOGIN_SASL && strlen (serv->password) != 0)\n\t\t\t\t|| (serv->loginmethod == LOGIN_SASLEXTERNAL && serv->have_cert)))\n// fix_end\n// fix_start\n\t\t\twant_cap = TRUE;\n\t\t\twant_sasl = TRUE;\n\t\t\tg_strlcat (buffer, \"sasl \", sizeof(buffer));\n\t\t\tcontinue;\n// fix_end\n// fix_start\n\t\tfor (x = 0; x < G_N_ELEMENTS(supported_caps); ++x)\n// fix_end\n// fix_start\n\t\t\tif (!g_strcmp0 (extension, supported_caps[x]))\n\t\t\t{\n\t\t\t\tg_strlcat (buffer, extension, sizeof(buffer));\n\t\t\t\tg_strlcat (buffer, \" \", sizeof(buffer));\n\t\t\t\twant_cap = TRUE;\n\t\t\t}\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2016-2087", "cve_desc": "Directory traversal vulnerability in the client in HexChat 2.11.0 allows remote IRC servers to read or modify arbitrary files via a .. (dot dot) in the server name.", "project": "hexchat", "idx": 199767}
{"source": " size_t puma_parser_execute(puma_parser *parser, const char *buffer, size_t len, size_t off)  {\n   const char *p, *pe;\n   int cs = parser->cs;\n \n   assert(off <= len && \"offset past end of buffer\");\n \n   p = buffer+off;\n   pe = buffer+len;\n \n   assert((size_t) (pe - p) == len - off && \"pointers aren't same distance\");\n \n \n #line 87 \"ext/puma_http11/http11_parser.c\"\n \t{\n \tif ( p == pe )\n \t\tgoto _test_eof;\n \tswitch ( cs )\n \t{\n case 1:\n \tswitch( (*p) ) {\n \t\tcase 36: goto tr0;\n \t\tcase 95: goto tr0;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto tr0;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto tr0;\n \t} else\n \t\tgoto tr0;\n \tgoto st0;\n st0:\n cs = 0;\n \tgoto _out;\n tr0:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st2;\n st2:\n \tif ( ++p == pe )\n \t\tgoto _test_eof2;\n case 2:\n #line 118 \"ext/puma_http11/http11_parser.c\"\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st27;\n \t\tcase 95: goto st27;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st27;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st27;\n \t} else\n \t\tgoto st27;\n \tgoto st0;\n tr2:\n #line 50 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_method(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st3;\n st3:\n \tif ( ++p == pe )\n \t\tgoto _test_eof3;\n case 3:\n #line 143 \"ext/puma_http11/http11_parser.c\"\n \tswitch( (*p) ) {\n \t\tcase 42: goto tr4;\n \t\tcase 43: goto tr5;\n \t\tcase 47: goto tr6;\n \t\tcase 58: goto tr7;\n \t}\n \tif ( (*p) < 65 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 57 )\n \t\t\tgoto tr5;\n \t} else if ( (*p) > 90 ) {\n \t\tif ( 97 <= (*p) && (*p) <= 122 )\n \t\t\tgoto tr5;\n \t} else\n \t\tgoto tr5;\n \tgoto st0;\n tr4:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st4;\n st4:\n \tif ( ++p == pe )\n \t\tgoto _test_eof4;\n case 4:\n #line 167 \"ext/puma_http11/http11_parser.c\"\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr8;\n \t\tcase 35: goto tr9;\n \t}\n \tgoto st0;\n tr8:\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st5;\n tr31:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n #line 56 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st5;\n tr33:\n #line 56 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st5;\n tr37:\n #line 69 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n   }\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st5;\n tr41:\n #line 60 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(query_start, p); }\n #line 61 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n   }\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st5;\n tr44:\n #line 61 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n   }\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st5;\n st5:\n \tif ( ++p == pe )\n \t\tgoto _test_eof5;\n case 5:\n #line 229 \"ext/puma_http11/http11_parser.c\"\n \tif ( (*p) == 72 )\n \t\tgoto tr10;\n \tgoto st0;\n tr10:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st6;\n st6:\n \tif ( ++p == pe )\n \t\tgoto _test_eof6;\n case 6:\n #line 241 \"ext/puma_http11/http11_parser.c\"\n \tif ( (*p) == 84 )\n \t\tgoto st7;\n \tgoto st0;\n st7:\n \tif ( ++p == pe )\n \t\tgoto _test_eof7;\n case 7:\n \tif ( (*p) == 84 )\n \t\tgoto st8;\n \tgoto st0;\n st8:\n \tif ( ++p == pe )\n \t\tgoto _test_eof8;\n case 8:\n \tif ( (*p) == 80 )\n \t\tgoto st9;\n \tgoto st0;\n st9:\n \tif ( ++p == pe )\n \t\tgoto _test_eof9;\n case 9:\n \tif ( (*p) == 47 )\n \t\tgoto st10;\n \tgoto st0;\n st10:\n \tif ( ++p == pe )\n \t\tgoto _test_eof10;\n case 10:\n \tif ( 48 <= (*p) && (*p) <= 57 )\n \t\tgoto st11;\n \tgoto st0;\n st11:\n \tif ( ++p == pe )\n \t\tgoto _test_eof11;\n case 11:\n \tif ( (*p) == 46 )\n \t\tgoto st12;\n \tif ( 48 <= (*p) && (*p) <= 57 )\n \t\tgoto st11;\n \tgoto st0;\n st12:\n \tif ( ++p == pe )\n \t\tgoto _test_eof12;\n case 12:\n \tif ( 48 <= (*p) && (*p) <= 57 )\n \t\tgoto st13;\n \tgoto st0;\n st13:\n \tif ( ++p == pe )\n \t\tgoto _test_eof13;\n case 13:\n \tif ( (*p) == 13 )\n \t\tgoto tr18;\n \tif ( 48 <= (*p) && (*p) <= 57 )\n \t\tgoto st13;\n \tgoto st0;\n tr18:\n #line 65 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->http_version(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st14;\n tr26:\n #line 46 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n #line 47 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st14;\n tr29:\n #line 47 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st14;\n st14:\n \tif ( ++p == pe )\n \t\tgoto _test_eof14;\n case 14:\n #line 322 \"ext/puma_http11/http11_parser.c\"\n \tif ( (*p) == 10 )\n \t\tgoto st15;\n \tgoto st0;\n st15:\n \tif ( ++p == pe )\n \t\tgoto _test_eof15;\n case 15:\n \tswitch( (*p) ) {\n \t\tcase 13: goto st16;\n \t\tcase 33: goto tr21;\n \t\tcase 124: goto tr21;\n \t\tcase 126: goto tr21;\n \t}\n \tif ( (*p) < 45 ) {\n \t\tif ( (*p) > 39 ) {\n \t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n \t\t\t\tgoto tr21;\n \t\t} else if ( (*p) >= 35 )\n \t\t\tgoto tr21;\n \t} else if ( (*p) > 46 ) {\n \t\tif ( (*p) < 65 ) {\n \t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n \t\t\t\tgoto tr21;\n \t\t} else if ( (*p) > 90 ) {\n \t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n \t\t\t\tgoto tr21;\n \t\t} else\n \t\t\tgoto tr21;\n \t} else\n \t\tgoto tr21;\n \tgoto st0;\n st16:\n \tif ( ++p == pe )\n \t\tgoto _test_eof16;\n case 16:\n \tif ( (*p) == 10 )\n \t\tgoto tr22;\n \tgoto st0;\n tr22:\n #line 73 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->body_start = p - buffer + 1;\n     parser->header_done(parser, p + 1, pe - p - 1);\n     {p++; cs = 46; goto _out;}\n   }\n \tgoto st46;\n st46:\n \tif ( ++p == pe )\n \t\tgoto _test_eof46;\n case 46:\n #line 373 \"ext/puma_http11/http11_parser.c\"\n \tgoto st0;\n tr21:\n #line 40 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(field_start, p); }\n #line 41 \"ext/puma_http11/http11_parser.rl\"\n \t{ snake_upcase_char((char *)p); }\n \tgoto st17;\n tr23:\n #line 41 \"ext/puma_http11/http11_parser.rl\"\n \t{ snake_upcase_char((char *)p); }\n \tgoto st17;\n st17:\n \tif ( ++p == pe )\n \t\tgoto _test_eof17;\n case 17:\n #line 389 \"ext/puma_http11/http11_parser.c\"\n \tswitch( (*p) ) {\n \t\tcase 33: goto tr23;\n \t\tcase 58: goto tr24;\n \t\tcase 124: goto tr23;\n \t\tcase 126: goto tr23;\n \t}\n \tif ( (*p) < 45 ) {\n \t\tif ( (*p) > 39 ) {\n \t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n \t\t\t\tgoto tr23;\n \t\t} else if ( (*p) >= 35 )\n \t\t\tgoto tr23;\n \t} else if ( (*p) > 46 ) {\n \t\tif ( (*p) < 65 ) {\n \t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n \t\t\t\tgoto tr23;\n \t\t} else if ( (*p) > 90 ) {\n \t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n \t\t\t\tgoto tr23;\n \t\t} else\n \t\t\tgoto tr23;\n \t} else\n \t\tgoto tr23;\n \tgoto st0;\n tr24:\n #line 42 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->field_len = LEN(field_start, p);\n   }\n \tgoto st18;\n tr27:\n #line 46 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st18;\n st18:\n \tif ( ++p == pe )\n \t\tgoto _test_eof18;\n case 18:\n #line 428 \"ext/puma_http11/http11_parser.c\"\n \tswitch( (*p) ) {\n// bug_start\n// bug_end\n \t\tcase 13: goto tr26;\n \t\tcase 32: goto tr27;\n \t}\n// bug_start\n\tgoto tr25;\n// bug_end\n tr25:\n #line 46 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st19;\n st19:\n \tif ( ++p == pe )\n \t\tgoto _test_eof19;\n case 19:\n// bug_start\n#line 442 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 13 )\n\t\tgoto tr29;\n\tgoto st19;\n// bug_end\n tr9:\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st20;\n tr38:\n #line 69 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n   }\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st20;\n tr42:\n #line 60 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(query_start, p); }\n #line 61 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n   }\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st20;\n tr45:\n #line 61 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n   }\n #line 53 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n   }\n \tgoto st20;\n st20:\n \tif ( ++p == pe )\n \t\tgoto _test_eof20;\n case 20:\n// bug_start\n#line 488 \"ext/puma_http11/http11_parser.c\"\n// bug_end\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr31;\n \t\tcase 60: goto st0;\n \t\tcase 62: goto st0;\n \t\tcase 127: goto st0;\n \t}\n \tif ( (*p) > 31 ) {\n \t\tif ( 34 <= (*p) && (*p) <= 35 )\n \t\t\tgoto st0;\n \t} else if ( (*p) >= 0 )\n \t\tgoto st0;\n \tgoto tr30;\n tr30:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st21;\n st21:\n \tif ( ++p == pe )\n \t\tgoto _test_eof21;\n case 21:\n// bug_start\n#line 509 \"ext/puma_http11/http11_parser.c\"\n// bug_end\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr33;\n \t\tcase 60: goto st0;\n \t\tcase 62: goto st0;\n \t\tcase 127: goto st0;\n \t}\n \tif ( (*p) > 31 ) {\n \t\tif ( 34 <= (*p) && (*p) <= 35 )\n \t\t\tgoto st0;\n \t} else if ( (*p) >= 0 )\n \t\tgoto st0;\n \tgoto st21;\n tr5:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st22;\n st22:\n \tif ( ++p == pe )\n \t\tgoto _test_eof22;\n case 22:\n// bug_start\n#line 530 \"ext/puma_http11/http11_parser.c\"\n// bug_end\n \tswitch( (*p) ) {\n \t\tcase 43: goto st22;\n \t\tcase 58: goto st23;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st22;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( (*p) > 90 ) {\n \t\t\tif ( 97 <= (*p) && (*p) <= 122 )\n \t\t\t\tgoto st22;\n \t\t} else if ( (*p) >= 65 )\n \t\t\tgoto st22;\n \t} else\n \t\tgoto st22;\n \tgoto st0;\n tr7:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st23;\n st23:\n \tif ( ++p == pe )\n \t\tgoto _test_eof23;\n case 23:\n// bug_start\n#line 555 \"ext/puma_http11/http11_parser.c\"\n// bug_end\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr8;\n \t\tcase 34: goto st0;\n \t\tcase 35: goto tr9;\n \t\tcase 60: goto st0;\n \t\tcase 62: goto st0;\n \t\tcase 127: goto st0;\n \t}\n \tif ( 0 <= (*p) && (*p) <= 31 )\n \t\tgoto st0;\n \tgoto st23;\n tr6:\n #line 37 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(mark, p); }\n \tgoto st24;\n st24:\n \tif ( ++p == pe )\n \t\tgoto _test_eof24;\n case 24:\n// bug_start\n#line 575 \"ext/puma_http11/http11_parser.c\"\n// bug_end\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr37;\n \t\tcase 34: goto st0;\n \t\tcase 35: goto tr38;\n \t\tcase 60: goto st0;\n \t\tcase 62: goto st0;\n \t\tcase 63: goto tr39;\n \t\tcase 127: goto st0;\n \t}\n \tif ( 0 <= (*p) && (*p) <= 31 )\n \t\tgoto st0;\n \tgoto st24;\n tr39:\n #line 69 \"ext/puma_http11/http11_parser.rl\"\n \t{\n     parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n   }\n \tgoto st25;\n st25:\n \tif ( ++p == pe )\n \t\tgoto _test_eof25;\n case 25:\n// bug_start\n#line 598 \"ext/puma_http11/http11_parser.c\"\n// bug_end\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr41;\n \t\tcase 34: goto st0;\n \t\tcase 35: goto tr42;\n \t\tcase 60: goto st0;\n \t\tcase 62: goto st0;\n \t\tcase 127: goto st0;\n \t}\n \tif ( 0 <= (*p) && (*p) <= 31 )\n \t\tgoto st0;\n \tgoto tr40;\n tr40:\n #line 60 \"ext/puma_http11/http11_parser.rl\"\n \t{ MARK(query_start, p); }\n \tgoto st26;\n st26:\n \tif ( ++p == pe )\n \t\tgoto _test_eof26;\n case 26:\n// bug_start\n#line 618 \"ext/puma_http11/http11_parser.c\"\n// bug_end\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr44;\n \t\tcase 34: goto st0;\n \t\tcase 35: goto tr45;\n \t\tcase 60: goto st0;\n \t\tcase 62: goto st0;\n \t\tcase 127: goto st0;\n \t}\n \tif ( 0 <= (*p) && (*p) <= 31 )\n \t\tgoto st0;\n \tgoto st26;\n st27:\n \tif ( ++p == pe )\n \t\tgoto _test_eof27;\n case 27:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st28;\n \t\tcase 95: goto st28;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st28;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st28;\n \t} else\n \t\tgoto st28;\n \tgoto st0;\n st28:\n \tif ( ++p == pe )\n \t\tgoto _test_eof28;\n case 28:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st29;\n \t\tcase 95: goto st29;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st29;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st29;\n \t} else\n \t\tgoto st29;\n \tgoto st0;\n st29:\n \tif ( ++p == pe )\n \t\tgoto _test_eof29;\n case 29:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st30;\n \t\tcase 95: goto st30;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st30;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st30;\n \t} else\n \t\tgoto st30;\n \tgoto st0;\n st30:\n \tif ( ++p == pe )\n \t\tgoto _test_eof30;\n case 30:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st31;\n \t\tcase 95: goto st31;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st31;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st31;\n \t} else\n \t\tgoto st31;\n \tgoto st0;\n st31:\n \tif ( ++p == pe )\n \t\tgoto _test_eof31;\n case 31:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st32;\n \t\tcase 95: goto st32;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st32;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st32;\n \t} else\n \t\tgoto st32;\n \tgoto st0;\n st32:\n \tif ( ++p == pe )\n \t\tgoto _test_eof32;\n case 32:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st33;\n \t\tcase 95: goto st33;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st33;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st33;\n \t} else\n \t\tgoto st33;\n \tgoto st0;\n st33:\n \tif ( ++p == pe )\n \t\tgoto _test_eof33;\n case 33:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st34;\n \t\tcase 95: goto st34;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st34;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st34;\n \t} else\n \t\tgoto st34;\n \tgoto st0;\n st34:\n \tif ( ++p == pe )\n \t\tgoto _test_eof34;\n case 34:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st35;\n \t\tcase 95: goto st35;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st35;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st35;\n \t} else\n \t\tgoto st35;\n \tgoto st0;\n st35:\n \tif ( ++p == pe )\n \t\tgoto _test_eof35;\n case 35:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st36;\n \t\tcase 95: goto st36;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st36;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st36;\n \t} else\n \t\tgoto st36;\n \tgoto st0;\n st36:\n \tif ( ++p == pe )\n \t\tgoto _test_eof36;\n case 36:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st37;\n \t\tcase 95: goto st37;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st37;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st37;\n \t} else\n \t\tgoto st37;\n \tgoto st0;\n st37:\n \tif ( ++p == pe )\n \t\tgoto _test_eof37;\n case 37:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st38;\n \t\tcase 95: goto st38;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st38;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st38;\n \t} else\n \t\tgoto st38;\n \tgoto st0;\n st38:\n \tif ( ++p == pe )\n \t\tgoto _test_eof38;\n case 38:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st39;\n \t\tcase 95: goto st39;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st39;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st39;\n \t} else\n \t\tgoto st39;\n \tgoto st0;\n st39:\n \tif ( ++p == pe )\n \t\tgoto _test_eof39;\n case 39:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st40;\n \t\tcase 95: goto st40;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st40;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st40;\n \t} else\n \t\tgoto st40;\n \tgoto st0;\n st40:\n \tif ( ++p == pe )\n \t\tgoto _test_eof40;\n case 40:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st41;\n \t\tcase 95: goto st41;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st41;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st41;\n \t} else\n \t\tgoto st41;\n \tgoto st0;\n st41:\n \tif ( ++p == pe )\n \t\tgoto _test_eof41;\n case 41:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st42;\n \t\tcase 95: goto st42;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st42;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st42;\n \t} else\n \t\tgoto st42;\n \tgoto st0;\n st42:\n \tif ( ++p == pe )\n \t\tgoto _test_eof42;\n case 42:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st43;\n \t\tcase 95: goto st43;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st43;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st43;\n \t} else\n \t\tgoto st43;\n \tgoto st0;\n st43:\n \tif ( ++p == pe )\n \t\tgoto _test_eof43;\n case 43:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st44;\n \t\tcase 95: goto st44;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st44;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st44;\n \t} else\n \t\tgoto st44;\n \tgoto st0;\n st44:\n \tif ( ++p == pe )\n \t\tgoto _test_eof44;\n case 44:\n \tswitch( (*p) ) {\n \t\tcase 32: goto tr2;\n \t\tcase 36: goto st45;\n \t\tcase 95: goto st45;\n \t}\n \tif ( (*p) < 48 ) {\n \t\tif ( 45 <= (*p) && (*p) <= 46 )\n \t\t\tgoto st45;\n \t} else if ( (*p) > 57 ) {\n \t\tif ( 65 <= (*p) && (*p) <= 90 )\n \t\t\tgoto st45;\n \t} else\n \t\tgoto st45;\n \tgoto st0;\n st45:\n \tif ( ++p == pe )\n \t\tgoto _test_eof45;\n case 45:\n \tif ( (*p) == 32 )\n \t\tgoto tr2;\n \tgoto st0;\n \t}\n \t_test_eof2: cs = 2; goto _test_eof;\n \t_test_eof3: cs = 3; goto _test_eof;\n \t_test_eof4: cs = 4; goto _test_eof;\n \t_test_eof5: cs = 5; goto _test_eof;\n \t_test_eof6: cs = 6; goto _test_eof;\n \t_test_eof7: cs = 7; goto _test_eof;\n \t_test_eof8: cs = 8; goto _test_eof;\n \t_test_eof9: cs = 9; goto _test_eof;\n \t_test_eof10: cs = 10; goto _test_eof;\n \t_test_eof11: cs = 11; goto _test_eof;\n \t_test_eof12: cs = 12; goto _test_eof;\n \t_test_eof13: cs = 13; goto _test_eof;\n \t_test_eof14: cs = 14; goto _test_eof;\n \t_test_eof15: cs = 15; goto _test_eof;\n \t_test_eof16: cs = 16; goto _test_eof;\n \t_test_eof46: cs = 46; goto _test_eof;\n \t_test_eof17: cs = 17; goto _test_eof;\n \t_test_eof18: cs = 18; goto _test_eof;\n \t_test_eof19: cs = 19; goto _test_eof;\n \t_test_eof20: cs = 20; goto _test_eof;\n \t_test_eof21: cs = 21; goto _test_eof;\n \t_test_eof22: cs = 22; goto _test_eof;\n \t_test_eof23: cs = 23; goto _test_eof;\n \t_test_eof24: cs = 24; goto _test_eof;\n \t_test_eof25: cs = 25; goto _test_eof;\n \t_test_eof26: cs = 26; goto _test_eof;\n \t_test_eof27: cs = 27; goto _test_eof;\n \t_test_eof28: cs = 28; goto _test_eof;\n \t_test_eof29: cs = 29; goto _test_eof;\n \t_test_eof30: cs = 30; goto _test_eof;\n \t_test_eof31: cs = 31; goto _test_eof;\n \t_test_eof32: cs = 32; goto _test_eof;\n \t_test_eof33: cs = 33; goto _test_eof;\n \t_test_eof34: cs = 34; goto _test_eof;\n \t_test_eof35: cs = 35; goto _test_eof;\n \t_test_eof36: cs = 36; goto _test_eof;\n \t_test_eof37: cs = 37; goto _test_eof;\n \t_test_eof38: cs = 38; goto _test_eof;\n \t_test_eof39: cs = 39; goto _test_eof;\n \t_test_eof40: cs = 40; goto _test_eof;\n \t_test_eof41: cs = 41; goto _test_eof;\n \t_test_eof42: cs = 42; goto _test_eof;\n \t_test_eof43: cs = 43; goto _test_eof;\n \t_test_eof44: cs = 44; goto _test_eof;\n \t_test_eof45: cs = 45; goto _test_eof;\n \n \t_test_eof: {}\n \t_out: {}\n \t}\n \n #line 117 \"ext/puma_http11/http11_parser.rl\"\n \n   if (!puma_parser_has_error(parser))\n     parser->cs = cs;\n   parser->nread += p - (buffer + off);\n \n   assert(p <= pe && \"buffer overflow after parsing execute\");\n   assert(parser->nread <= len && \"nread longer than length\");\n   assert(parser->body_start <= len && \"body starts after buffer end\");\n   assert(parser->mark < len && \"mark is after buffer end\");\n   assert(parser->field_len <= len && \"field has length longer than whole buffer\");\n   assert(parser->field_start < len && \"field starts after buffer end\");\n \n   return(parser->nread);\n }\n \n", "target": "// fix_start\n\t\tcase 9: goto tr25;\n// fix_end\n// fix_start\n\tif ( 33 <= (*p) && (*p) <= 126 )\n\t\tgoto tr25;\n\tgoto st0;\n// fix_end\n// fix_start\n#line 445 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 9: goto st19;\n\t\tcase 13: goto tr29;\n\t}\n\tif ( 32 <= (*p) && (*p) <= 126 )\n\t\tgoto st19;\n\tgoto st0;\n// fix_end\n// fix_start\n#line 495 \"ext/puma_http11/http11_parser.c\"\n// fix_end\n// fix_start\n#line 516 \"ext/puma_http11/http11_parser.c\"\n// fix_end\n// fix_start\n#line 537 \"ext/puma_http11/http11_parser.c\"\n// fix_end\n// fix_start\n#line 562 \"ext/puma_http11/http11_parser.c\"\n// fix_end\n// fix_start\n#line 582 \"ext/puma_http11/http11_parser.c\"\n// fix_end\n// fix_start\n#line 605 \"ext/puma_http11/http11_parser.c\"\n// fix_end\n// fix_start\n#line 625 \"ext/puma_http11/http11_parser.c\"\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "cve": "CVE-2021-41136", "cve_desc": "Puma is a HTTP 1.1 server for Ruby/Rack applications. Prior to versions 5.5.1 and 4.3.9, using `puma` with a proxy which forwards HTTP header values which contain the LF character could allow HTTP request smugggling. A client could smuggle a request through a proxy, causing the proxy to send a response back to another unknown client. The only proxy which has this behavior, as far as the Puma team is aware of, is Apache Traffic Server. If the proxy uses persistent connections and the client adds another request in via HTTP pipelining, the proxy may mistake it as the first request's body. Puma, however, would see it as two requests, and when processing the second request, send back a response that the proxy does not expect. If the proxy has reused the persistent connection to Puma to send another request for a different client, the second response from the first client will be sent to the second client. This vulnerability was patched in Puma 5.5.1 and 4.3.9. As a workaround, do not use Apache Traffic Server with `puma`.", "project": "puma", "idx": 199778}
{"source": " gif_internal_decode_frame(gif_animation *gif,\n                           unsigned int frame,\n                           bool clear_image)\n {\n         unsigned int index = 0;\n         const unsigned char *gif_data, *gif_end;\n         ssize_t gif_bytes;\n         unsigned int width, height, offset_x, offset_y;\n         unsigned int flags, colour_table_size, interlace;\n         unsigned int *colour_table;\n         unsigned int *frame_data = 0;\n         unsigned int *frame_scanline;\n         ssize_t save_buffer_position;\n         unsigned int return_value = 0;\n         unsigned int x, y, decode_y, burst_bytes;\n         register unsigned char colour;\n// bug_start\n// bug_end\n \n         if (gif->frames[frame].display == false) {\n                 return GIF_OK;\n         }\n \n         if (frame > gif->frame_count_partial) {\n                 return GIF_INSUFFICIENT_DATA;\n         }\n \n         if ((!clear_image) &&\n             ((int)frame == gif->decoded_frame)) {\n                 return GIF_OK;\n         }\n \n         gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n         gif_end = gif->gif_data + gif->buffer_size;\n         gif_bytes = (gif_end - gif_data);\n \n         if (gif_bytes < 12) {\n                 return GIF_INSUFFICIENT_FRAME_DATA;\n         }\n \n         save_buffer_position = gif->buffer_position;\n         gif->buffer_position = gif_data - gif->gif_data;\n \n         if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                 goto gif_decode_frame_exit;\n         }\n         gif_data = (gif->gif_data + gif->buffer_position);\n         gif_bytes = (gif_end - gif_data);\n \n         if (gif_bytes < 12) {\n                 return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                 goto gif_decode_frame_exit;\n         }\n \n         if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                 return_value = GIF_DATA_ERROR;\n                 goto gif_decode_frame_exit;\n         }\n         offset_x = gif_data[1] | (gif_data[2] << 8);\n         offset_y = gif_data[3] | (gif_data[4] << 8);\n         width = gif_data[5] | (gif_data[6] << 8);\n         height = gif_data[7] | (gif_data[8] << 8);\n \n         if ((offset_x + width > gif->width) ||\n             (offset_y + height > gif->height)) {\n                 return_value = GIF_DATA_ERROR;\n                 goto gif_decode_frame_exit;\n         }\n \n         flags = gif_data[9];\n         colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n         interlace = flags & GIF_INTERLACE_MASK;\n \n         gif_data += 10;\n         gif_bytes = (gif_end - gif_data);\n \n         if (flags & GIF_COLOUR_TABLE_MASK) {\n                 if (gif_bytes < (int)(3 * colour_table_size)) {\n                         return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                         goto gif_decode_frame_exit;\n                 }\n                 colour_table = gif->local_colour_table;\n                 if (!clear_image) {\n                         for (index = 0; index < colour_table_size; index++) {\n                                 unsigned char *entry =\n                                         (unsigned char *) &colour_table[index];\n \n                                 entry[0] = gif_data[0];\n                                 entry[1] = gif_data[1];\n                                 entry[2] = gif_data[2];\n                                 entry[3] = 0xff;\n \n                                 gif_data += 3;\n                         }\n                 } else {\n                         gif_data += 3 * colour_table_size;\n                 }\n                 gif_bytes = (gif_end - gif_data);\n         } else {\n                 colour_table = gif->global_colour_table;\n         }\n \n         if (gif_bytes < 1) {\n                 return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                 goto gif_decode_frame_exit;\n         }\n \n         if (gif_data[0] == GIF_TRAILER) {\n                 return_value = GIF_OK;\n                 goto gif_decode_frame_exit;\n         }\n \n         assert(gif->bitmap_callbacks.bitmap_get_buffer);\n         frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n         if (!frame_data) {\n                 return GIF_INSUFFICIENT_MEMORY;\n         }\n \n         if (!clear_image) {\n                 lzw_result res;\n                 const uint8_t *stack_base;\n                 const uint8_t *stack_pos;\n \n                 if (gif_bytes < 2) {\n                         return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                         goto gif_decode_frame_exit;\n                 }\n \n                 if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {\n                         return_value = GIF_OK;\n                         goto gif_decode_frame_exit;\n                 }\n \n                 if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n                         memset((char*)frame_data,\n                                GIF_TRANSPARENT_COLOUR,\n                                gif->width * gif->height * sizeof(int));\n                         gif->decoded_frame = frame;\n                 } else if ((frame != 0) &&\n                            (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                         return_value = gif_internal_decode_frame(gif,\n                                                                  (frame - 1),\n                                                                  true);\n                         if (return_value != GIF_OK) {\n                                 goto gif_decode_frame_exit;\n                         }\n \n                 } else if ((frame != 0) &&\n                            (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {\n                         int last_undisposed_frame = frame - 2;\n                         while ((last_undisposed_frame >= 0) &&\n                                (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {\n                                 last_undisposed_frame--;\n                         }\n \n                         if (last_undisposed_frame == -1) {\n                                 memset((char*)frame_data,\n                                        GIF_TRANSPARENT_COLOUR,\n                                        gif->width * gif->height * sizeof(int));\n                         } else {\n                                 return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);\n                                 if (return_value != GIF_OK) {\n                                         goto gif_decode_frame_exit;\n                                 }\n                                 assert(gif->bitmap_callbacks.bitmap_get_buffer);\n                                 frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n                                 if (!frame_data) {\n                                         return GIF_INSUFFICIENT_MEMORY;\n                                 }\n                         }\n                 }\n                 gif->decoded_frame = frame;\n                 gif->buffer_position = (gif_data - gif->gif_data) + 1;\n \n                 res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                                 gif->buffer_size, gif->buffer_position,\n                                 gif_data[0], &stack_base, &stack_pos);\n                 if (res != LZW_OK) {\n                         return gif_error_from_lzw(res);\n                 }\n \n                 for (y = 0; y < height; y++) {\n                         if (interlace) {\n                                 decode_y = gif_interlaced_line(height, y) + offset_y;\n                         } else {\n                                 decode_y = y + offset_y;\n                         }\n                         frame_scanline = frame_data + offset_x + (decode_y * gif->width);\n \n                         x = width;\n                         while (x > 0) {\n                                 burst_bytes = (stack_pos - stack_base);\n                                 if (burst_bytes > 0) {\n                                         if (burst_bytes > x) {\n                                                 burst_bytes = x;\n                                         }\n                                         x -= burst_bytes;\n                                         while (burst_bytes-- > 0) {\n                                                 colour = *--stack_pos;\n                                                 if (((gif->frames[frame].transparency) &&\n                                                      (colour != gif->frames[frame].transparency_index)) ||\n                                                     (!gif->frames[frame].transparency)) {\n                                                         *frame_scanline = colour_table[colour];\n                                                 }\n                                                 frame_scanline++;\n                                         }\n                                 } else {\n                                         res = lzw_decode(gif->lzw_ctx, &stack_pos);\n                                         if (res != LZW_OK) {\n                                                 if (res == LZW_OK_EOD) {\n                                                         return_value = GIF_OK;\n                                                 } else {\n                                                         return_value = gif_error_from_lzw(res);\n                                                 }\n                                                 goto gif_decode_frame_exit;\n                                         }\n                                 }\n                         }\n                 }\n         } else {\n                 if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {\n                         for (y = 0; y < height; y++) {\n                                 frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n                                 if (gif->frames[frame].transparency) {\n                                         memset(frame_scanline,\n                                                GIF_TRANSPARENT_COLOUR,\n                                                width * 4);\n                                 } else {\n                                         memset(frame_scanline,\n                                                colour_table[gif->background_index],\n                                                width * 4);\n                                 }\n                         }\n                 }\n         }\n gif_decode_frame_exit:\n \n         if (gif->frames[frame].virgin) {\n                 if (gif->bitmap_callbacks.bitmap_test_opaque) {\n                         gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n                 } else {\n                         gif->frames[frame].opaque = false;\n                 }\n                 gif->frames[frame].virgin = false;\n         }\n \n         if (gif->bitmap_callbacks.bitmap_set_opaque) {\n                 gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n         }\n \n         if (gif->bitmap_callbacks.bitmap_modified) {\n                 gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n         }\n \n         gif->buffer_position = save_buffer_position;\n \n         return return_value;\n }\n \n", "target": "// fix_start\n\n        if (gif->frames == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-1507", "cve_desc": "chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file. in GitHub repository hpjansson/chafa prior to 1.10.2. chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file.", "project": "chafa", "idx": 199833}
{"source": " PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n {\n// bug_start\n    int chr = *scanner->curptr;\n// bug_end\n \n// bug_start\n    if (!chr) {\n// bug_end\n \tpj_scan_syntax_err(scanner);\n \treturn 0;\n     }\n \n// bug_start\n    ++scanner->curptr;\n// bug_end\n \n// bug_start\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n// bug_end\n \tpj_scan_skip_whitespace(scanner);\n     }\n     return chr;\n }\n \n", "target": "// fix_start\n    register char *s = scanner->curptr;\n    int chr;\n// fix_end\n// fix_start\n    if (s >= scanner->end || !*s) {\n// fix_end\n// fix_start\n    chr = *s;\n// fix_end\n// fix_start\n    ++s;\n    scanner->curptr = s;\n    if (PJ_SCAN_CHECK_EOF(s) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n    \tscanner->skip_ws)\n    {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-21723", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions 2.11.1 and prior, parsing an incoming SIP message that contains a malformed multipart can potentially cause out-of-bound read access. This issue affects all PJSIP users that accept SIP multipart. The patch is available as commit in the `master` branch. There are no known workarounds.", "project": "pjproject", "idx": 199836}
{"source": " static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n \tRBuffer *fbuf = r_buf_ref (buf);\n \tstruct MACH0_(opts_t) opts;\n \tMACH0_(opts_set_default) (&opts, bf);\n \tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n \tif (!main_mach0) {\n \t\treturn false;\n \t}\n \n \tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n \tRKernelCacheObj *obj = NULL;\n \n \tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n \tif (!prelink_range) {\n \t\tgoto beach;\n \t}\n \n \tobj = R_NEW0 (RKernelCacheObj);\n \tif (!obj) {\n \t\tR_FREE (prelink_range);\n \t\tgoto beach;\n \t}\n \n \tRCFValueDict *prelink_info = NULL;\n \tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n \t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n \t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n \t\tif (!prelink_info) {\n \t\t\tR_FREE (prelink_range);\n \t\t\tR_FREE (obj);\n \t\t\tgoto beach;\n \t\t}\n \t}\n \n \tif (!pending_bin_files) {\n \t\tpending_bin_files = r_list_new ();\n \t\tif (!pending_bin_files) {\n \t\t\tR_FREE (prelink_range);\n \t\t\tR_FREE (obj);\n \t\t\tR_FREE (prelink_info);\n \t\t\tgoto beach;\n \t\t}\n \t}\n \n \tobj->mach0 = main_mach0;\n \tobj->rebase_info = rebase_info;\n \tobj->prelink_info = prelink_info;\n \tobj->cache_buf = fbuf;\n \tobj->pa2va_exec = prelink_range->pa2va_exec;\n \tobj->pa2va_data = prelink_range->pa2va_data;\n \n \tR_FREE (prelink_range);\n \n \t*bin_obj = obj;\n \n \tr_list_push (pending_bin_files, bf);\n \n \tif (rebase_info || main_mach0->chained_starts) {\n \t\tRIO *io = bf->rbin->iob.io;\n \t\tswizzle_io_read (obj, io);\n \t}\n \n \treturn true;\n \n beach:\n \tr_buf_free (fbuf);\n// bug_start\n\tobj->cache_buf = NULL;\n// bug_end\n \tMACH0_(mach0_free) (main_mach0);\n \treturn false;\n }\n \n", "target": "// fix_start\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-0419", "cve_desc": "NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.0.", "project": "radare2", "idx": 199841}
{"source": " ex_retab(exarg_T *eap)\n {\n     linenr_T\tlnum;\n     int\t\tgot_tab = FALSE;\n     long\tnum_spaces = 0;\n     long\tnum_tabs;\n     long\tlen;\n     long\tcol;\n     long\tvcol;\n     long\tstart_col = 0;\n     long\tstart_vcol = 0;\n     long\told_len;\n     char_u\t*ptr;\n     char_u\t*new_line = (char_u *)1;\n     int\t\tdid_undo;\n #ifdef FEAT_VARTABS\n     int\t\t*new_vts_array = NULL;\n     char_u\t*new_ts_str;\n #else\n     int\t\ttemp;\n     int\t\tnew_ts;\n #endif\n     int\t\tsave_list;\n     linenr_T\tfirst_line = 0;\n     linenr_T\tlast_line = 0;\n \n     save_list = curwin->w_p_list;\n     curwin->w_p_list = 0;\n \n #ifdef FEAT_VARTABS\n     new_ts_str = eap->arg;\n     if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n \treturn;\n     while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n \t++(eap->arg);\n \n     if (new_vts_array == NULL)\n     {\n \tnew_vts_array = curbuf->b_p_vts_array;\n \tnew_ts_str = NULL;\n     }\n     else\n \tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n #else\n     ptr = eap->arg;\n     new_ts = getdigits(&ptr);\n     if (new_ts < 0 && *eap->arg == '-')\n     {\n \temsg(_(e_argument_must_be_positive));\n \treturn;\n     }\n     if (new_ts < 0 || new_ts > TABSTOP_MAX)\n     {\n \tsemsg(_(e_invalid_argument_str), eap->arg);\n \treturn;\n     }\n     if (new_ts == 0)\n \tnew_ts = curbuf->b_p_ts;\n #endif\n     for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n     {\n \tptr = ml_get(lnum);\n \tcol = 0;\n \tvcol = 0;\n \tdid_undo = FALSE;\n \tfor (;;)\n \t{\n \t    if (VIM_ISWHITE(ptr[col]))\n \t    {\n \t\tif (!got_tab && num_spaces == 0)\n \t\t{\n \t\t    start_vcol = vcol;\n \t\t    start_col = col;\n \t\t}\n \t\tif (ptr[col] == ' ')\n \t\t    num_spaces++;\n \t\telse\n \t\t    got_tab = TRUE;\n \t    }\n \t    else\n \t    {\n \t\tif (got_tab || (eap->forceit && num_spaces > 1))\n \t\t{\n \n \t\t    len = num_spaces = vcol - start_vcol;\n \t\t    num_tabs = 0;\n \t\t    if (!curbuf->b_p_et)\n \t\t    {\n #ifdef FEAT_VARTABS\n \t\t\tint t, s;\n \n \t\t\ttabstop_fromto(start_vcol, vcol,\n \t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n \t\t\tnum_tabs = t;\n \t\t\tnum_spaces = s;\n #else\n \t\t\ttemp = new_ts - (start_vcol % new_ts);\n \t\t\tif (num_spaces >= temp)\n \t\t\t{\n \t\t\t    num_spaces -= temp;\n \t\t\t    num_tabs++;\n \t\t\t}\n \t\t\tnum_tabs += num_spaces / new_ts;\n \t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n #endif\n \t\t    }\n \t\t    if (curbuf->b_p_et || got_tab ||\n \t\t\t\t\t(num_spaces + num_tabs < len))\n \t\t    {\n \t\t\tif (did_undo == FALSE)\n \t\t\t{\n \t\t\t    did_undo = TRUE;\n \t\t\t    if (u_save((linenr_T)(lnum - 1),\n \t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n \t\t\t    {\n \t\t\t\tnew_line = NULL;\n \t\t\t\tbreak;\n \t\t\t    }\n \t\t\t}\n \n \t\t\tlen = num_spaces + num_tabs;\n \t\t\told_len = (long)STRLEN(ptr);\n \t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n \t\t\tif (new_line == NULL)\n \t\t\t    break;\n \t\t\tif (start_col > 0)\n \t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n \t\t\tmch_memmove(new_line + start_col + len,\n \t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n \t\t\tptr = new_line + start_col;\n \t\t\tfor (col = 0; col < len; col++)\n \t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n \t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n \t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n \t\t\tif (first_line == 0)\n \t\t\t    first_line = lnum;\n \t\t\tlast_line = lnum;\n \t\t\tptr = new_line;\n \t\t\tcol = start_col + len;\n \t\t    }\n \t\t}\n \t\tgot_tab = FALSE;\n \t\tnum_spaces = 0;\n \t    }\n \t    if (ptr[col] == NUL)\n \t\tbreak;\n \t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n// bug_start\n// bug_end\n \t    if (has_mbyte)\n \t\tcol += (*mb_ptr2len)(ptr + col);\n \t    else\n \t\t++col;\n \t}\n \tif (new_line == NULL)\n \t    break;\n \tline_breakcheck();\n     }\n     if (got_int)\n \temsg(_(e_interrupted));\n \n #ifdef FEAT_VARTABS\n     if (tabstop_count(curbuf->b_p_vts_array) == 0\n \t&& tabstop_count(new_vts_array) == 1\n \t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n \t;\n     else if (tabstop_count(curbuf->b_p_vts_array) > 0\n         && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n \t;\n     else\n \tredraw_curbuf_later(NOT_VALID);\n #else\n     if (curbuf->b_p_ts != new_ts)\n \tredraw_curbuf_later(NOT_VALID);\n #endif\n     if (first_line != 0)\n \tchanged_lines(first_line, 0, last_line + 1, 0L);\n \n     curwin->w_p_list = save_list;\n \n #ifdef FEAT_VARTABS\n     if (new_ts_str != NULL)\n     {\n \tint *old_vts_ary = curbuf->b_p_vts_array;\n \n \tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n \t{\n \t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n \t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n \t    curbuf->b_p_vts_array = new_vts_array;\n \t    vim_free(old_vts_ary);\n \t}\n \telse\n \t{\n \t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n \t    vim_free(new_vts_array);\n \t}\n \tvim_free(new_ts_str);\n     }\n #else\n     curbuf->b_p_ts = new_ts;\n #endif\n     coladvance(curwin->w_curswant);\n \n     u_clearline();\n }\n \n", "target": "// fix_start\n\t    if (vcol >= MAXCOL)\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0572", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 199851}
{"source": " mp_sint32 LoaderXM::load(XMFileBase& f, XModule* module)\n {\n \tmp_ubyte insData[230];\n \tmp_sint32 smpReloc[MP_MAXINSSAMPS];\n \tmp_ubyte nbu[MP_MAXINSSAMPS];\n \tmp_uint32 fileSize = 0;\n \n \tmodule->cleanUp();\n \n \tTXMHeader*\t\theader = &module->header;\n \tTXMInstrument*\tinstr  = module->instr;\n \tTXMSample*\t\tsmp\t   = module->smp;\n \tTXMPattern*\t\tphead  = module->phead;\n \n \tif (!phead || !instr || !smp)\n \t\treturn MP_OUT_OF_MEMORY;\n \n \tfileSize = f.sizeWithBaseOffset();\n \n \tf.read(&header->sig,1,17);\n \tf.read(&header->name,1,20);\n \tf.read(&header->whythis1a,1,1);\n \theader->whythis1a=0;\n \tf.read(&header->tracker,1,20);\n \tf.readWords(&header->ver,1);\n \n \tif (header->ver != 0x102 &&\n \t\theader->ver != 0x103 &&\n \t\theader->ver != 0x104)\n \t\treturn MP_LOADER_FAILED;\n \n \tf.readDwords(&header->hdrsize,1);\n \n \theader->hdrsize-=4;\n \n \tmp_uint32 hdrSize = 0x110;\n \tif (header->hdrsize > hdrSize)\n \t\thdrSize = header->hdrsize;\n \n \tmp_ubyte* hdrBuff = new mp_ubyte[hdrSize];\n \tmemset(hdrBuff, 0, hdrSize);\n \n \tf.read(hdrBuff, 1, header->hdrsize);\n \n \theader->ordnum = LittleEndian::GET_WORD(hdrBuff);\n \theader->restart = LittleEndian::GET_WORD(hdrBuff+2);\n \theader->channum = LittleEndian::GET_WORD(hdrBuff+4);\n \theader->patnum = LittleEndian::GET_WORD(hdrBuff+6);\n \theader->insnum = LittleEndian::GET_WORD(hdrBuff+8);\n \theader->freqtab = LittleEndian::GET_WORD(hdrBuff+10);\n \theader->tempo = LittleEndian::GET_WORD(hdrBuff+12);\n \theader->speed = LittleEndian::GET_WORD(hdrBuff+14);\n \tmemcpy(header->ord, hdrBuff+16, 256);\n \tif(header->ordnum > MP_MAXORDERS)\n \t\theader->ordnum = MP_MAXORDERS;\n \tif(header->insnum > MP_MAXINS)\n \t\treturn MP_LOADER_FAILED;\n \n \tdelete[] hdrBuff;\n \n \theader->mainvol=255;\n \theader->flags = XModule::MODULE_XMNOTECLIPPING |\n \t\tXModule::MODULE_XMARPEGGIO |\n \t\tXModule::MODULE_XMPORTANOTEBUFFER |\n \t\tXModule::MODULE_XMVOLCOLUMNVIBRATO;\n \n \theader->uppernotebound = 119;\n \n \tmp_sint32 i,y,sc;\n \tfor (i=0;i<32;i++) header->pan[i]=0x80;\n \n \tif (header->ver == 0x102 || header->ver == 0x103)\n \t{\n \t\tmp_sint32 s = 0;\n \t\tmp_sint32 e = 0;\n \t\tfor (y=0;y<header->insnum;y++) {\n \n \t\t\tf.readDwords(&instr[y].size,1);\n \t\t\tf.read(&instr[y].name,1,22);\n \t\t\tf.read(&instr[y].type,1,1);\n \t\t\tmp_uword numSamples = 0;\n \t\t\tf.readWords(&numSamples,1);\n \t\t\tif(numSamples > MP_MAXINSSAMPS)\n \t\t\t\treturn MP_LOADER_FAILED;\n \t\t\tinstr[y].samp = numSamples;\n \n \t\t\tif (instr[y].size == 29)\n \t\t\t{\n #ifdef MILKYTRACKER\n \t\t\t\ts+=16;\n #endif\n \t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n \t\t\t\t\tinstr[y].snum[i] = -1;\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tf.readDwords(&instr[y].shsize,1);\n \n \t\t\tmemset(insData, 0, 230);\n \n \t\t\tif (instr[y].size - 33 > 230)\n \t\t\t\treturn MP_OUT_OF_MEMORY;\n \n \t\t\tf.read(insData, 1, instr[y].size - 33);\n \n \t\t\tif (instr[y].samp) {\n \t\t\t\tmp_ubyte* insDataPtr = insData;\n \n \t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n \t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n \n \t\t\t\tTEnvelope venv;\n \t\t\t\tTEnvelope penv;\n \t\t\t\tmemset(&venv,0,sizeof(venv));\n \t\t\t\tmemset(&penv,0,sizeof(penv));\n \n \t\t\t\tmp_sint32 k;\n \t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n \t\t\t\t{\n \t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n \t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n \t\t\t\t\tinsDataPtr+=4;\n \t\t\t\t}\n \t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n \t\t\t\t{\n \t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n \t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n \t\t\t\t\tinsDataPtr+=4;\n \t\t\t\t}\n \n \t\t\t\tvenv.num = *insDataPtr++;\n \t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n \t\t\t\tpenv.num = *insDataPtr++;\n \t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n \t\t\t\tvenv.sustain = *insDataPtr++;\n \t\t\t\tvenv.loops = *insDataPtr++;\n \t\t\t\tvenv.loope = *insDataPtr++;\n \t\t\t\tpenv.sustain = *insDataPtr++;\n \t\t\t\tpenv.loops = *insDataPtr++;\n \t\t\t\tpenv.loope = *insDataPtr++;\n \t\t\t\tvenv.type = *insDataPtr++;\n \t\t\t\tpenv.type = *insDataPtr++;\n \n \t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n \t\t\t\tmp_uword volfade;\n \n \t\t\t\tvibtype = *insDataPtr++;\n \t\t\t\tvibsweep = *insDataPtr++;\n \t\t\t\tvibdepth = *insDataPtr++;\n \t\t\t\tvibrate = *insDataPtr++;\n \n \t\t\t\tvibdepth<<=1;\n \n \t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n \t\t\t\tinsDataPtr+=2;\n \t\t\t\tvolfade<<=1;\n \n \t\t\t\tinsDataPtr+=2;\n \n \t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n \t\t\t\t\tvenv.env[l][1]<<=2;\n \t\t\t\t\tpenv.env[l][1]<<=2;\n \t\t\t\t}\n \n \t\t\t\tif (!module->addVolumeEnvelope(venv))\n \t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \t\t\t\tif (!module->addPanningEnvelope(penv))\n \t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \n \t\t\t\tmp_sint32 g=0, sc;\n \t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n \n \t\t\t\t\tsmp[g+s].flags=3;\n \t\t\t\t\tsmp[g+s].venvnum=e+1;\n \t\t\t\t\tsmp[g+s].penvnum=e+1;\n \n \t\t\t\t\tsmp[g+s].vibtype=vibtype;\n \t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n \t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n \t\t\t\t\tsmp[g+s].vibrate=vibrate;\n \t\t\t\t\tsmp[g+s].volfade=volfade;\n \n \n \t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n \t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n \t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n \t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n \t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n \t\t\t\t\tf.read(&smp[g+s].type,1,1);\n #ifdef VERBOSE\n \t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n #endif\n \t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n \t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n \t\t\t\t\tf.read(&smp[g+s].res,1,1);\n \t\t\t\t\tf.read(&smp[g+s].name,1,22);\n \n \t\t\t\t\tchar line[30];\n \t\t\t\t\tmemset(line, 0, sizeof(line));\n \t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\n \t\t\t\t\tif (line[0])\n \t\t\t\t\t\tmodule->addSongMessageLine(line);\n \n #ifndef MILKYTRACKER\n \t\t\t\t\tif (smp[g+s].samplen) {\n \t\t\t\t\t\tsmpReloc[sc] = g;\n \t\t\t\t\t\tg++;\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t\tsmpReloc[sc] = -1;\n #else\n \t\t\t\t\tsmpReloc[sc] = g;\n \t\t\t\t\tg++;\n #endif\n \t\t\t\t}\n \n \t\t\t\tinstr[y].samp = g;\n \n \t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\n \t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n \t\t\t\t\t\tinstr[y].snum[sc] = -1;\n \t\t\t\t\telse\n \t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\n \t\t\t\t}\n \n \t\t\t\te++;\n \n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n \t\t\t\t\tinstr[y].snum[i] = -1;\n \t\t\t}\n \n #ifdef MILKYTRACKER\n \t\t\ts+=16;\n #else\n \t\t\ts+=instr[y].samp;\n #endif\n \n \n \t\t}\n \n \t\theader->smpnum=s;\n \t\theader->volenvnum=e;\n \t\theader->panenvnum=e;\n \t}\n \n \tfor (y=0;y<header->patnum;y++) {\n \n \t\tif (header->ver == 0x104 || header->ver == 0x103)\n \t\t{\n \t\t\tf.readDwords(&phead[y].len,1);\n \t\t\tf.read(&phead[y].ptype,1,1);\n \t\t\tf.readWords(&phead[y].rows,1);\n \t\t\tf.readWords(&phead[y].patdata,1);\n \t\t}\n \t\telse\n \t\t{\n \t\t\tf.readDwords(&phead[y].len,1);\n \t\t\tf.read(&phead[y].ptype,1,1);\n \t\t\tphead[y].rows = (mp_uword)f.readByte()+1;\n \t\t\tf.readWords(&phead[y].patdata,1);\n \t\t}\n \n \t\tphead[y].effnum=2;\n \t\tphead[y].channum=(mp_ubyte)header->channum;\n \n \t\tphead[y].patternData = new mp_ubyte[phead[y].rows*header->channum*6];\n \n \t\tif (phead[y].patternData == NULL)\n \t\t{\n \t\t\treturn MP_OUT_OF_MEMORY;\n \t\t}\n \n \t\tmemset(phead[y].patternData,0,phead[y].rows*header->channum*6);\n \n \t\tif (phead[y].patdata) {\n \t\t\tmp_ubyte *buffer = new mp_ubyte[phead[y].patdata];\n \n \t\t\tif (buffer == NULL)\n \t\t\t{\n \t\t\t\treturn MP_OUT_OF_MEMORY;\n \t\t\t}\n \n \t\t\tf.read(buffer,1,phead[y].patdata);\n \n \n \t\t\tmp_sint32 pc = 0, bc = 0;\n \t\t\tfor (mp_sint32 r=0;r<phead[y].rows;r++) {\n \t\t\t\tfor (mp_sint32 c=0;c<header->channum;c++) {\n \n \t\t\t\t\tmp_ubyte slot[5];\n \t\t\t\t\tmemset(slot,0,5);\n \n \t\t\t\t\tif ((buffer[pc]&128)) {\n \n \t\t\t\t\t\tmp_ubyte pb = buffer[pc];\n \t\t\t\t\t\tpc++;\n \n \t\t\t\t\t\tif ((pb&1)) {\n \t\t\t\t\t\t\tslot[0]=buffer[pc];\n \t\t\t\t\t\t\tpc++;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif ((pb&2)) {\n \t\t\t\t\t\t\tslot[1]=buffer[pc];\n \t\t\t\t\t\t\tpc++;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif ((pb&4)) {\n \t\t\t\t\t\t\tslot[2]=buffer[pc];\n \t\t\t\t\t\t\tpc++;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif ((pb&8)) {\n \t\t\t\t\t\t\tslot[3]=buffer[pc];\n \t\t\t\t\t\t\tpc++;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif ((pb&16)) {\n \t\t\t\t\t\t\tslot[4]=buffer[pc];\n \t\t\t\t\t\t\tpc++;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tmemcpy(slot,buffer+pc,5);\n \t\t\t\t\t\tpc+=5;\n \t\t\t\t\t}\n \n \t\t\t\t\tchar gl=0;\n \t\t\t\t\tfor (mp_sint32 i=0;i<XModule::numValidXMEffects;i++)\n \t\t\t\t\t\tif (slot[3]==XModule::validXMEffects[i]) gl=1;\n \n \t\t\t\t\tif (!gl) slot[3]=slot[4]=0;\n \n \t\t\t\t\tif ((slot[3]==0xC)||(slot[3]==0x10)) {\n \t\t\t\t\t\tslot[4] = XModule::vol64to255(slot[4]);\n \t\t\t\t\t}\n \n \t\t\t\t\tif ((!slot[3])&&(slot[4])) slot[3]=0x20;\n \n \t\t\t\t\tif (slot[3]==0xE) {\n \t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x30;\n \t\t\t\t\t\tslot[4]=slot[4]&0xf;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (slot[3]==0x21) {\n \t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x40;\n \t\t\t\t\t\tslot[4]=slot[4]&0xf;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (slot[0]==97) slot[0]=XModule::NOTE_OFF;\n \n \t\t\t\t\tphead[y].patternData[bc]=slot[0];\n \t\t\t\t\tphead[y].patternData[bc+1]=slot[1];\n \n \t\t\t\t\tXModule::convertXMVolumeEffects(slot[2], phead[y].patternData[bc+2], phead[y].patternData[bc+3]);\n \n \t\t\t\t\tphead[y].patternData[bc+4]=slot[3];\n \t\t\t\t\tphead[y].patternData[bc+5]=slot[4];\n \n \n \n \t\t\t\t\tbc+=6;\n \t\t\t\t}\n \n \t\t\t}\n \n \t\t\tdelete[] buffer;\n \t\t}\n \n \t}\n \n \tif (header->ver == 0x104)\n \t{\n \t\tmp_sint32 s = 0;\n \t\tmp_sint32 e = 0;\n \t\tfor (y=0;y<header->insnum;y++) {\n \n \t\t\tif (f.posWithBaseOffset() >= fileSize)\n \t\t\t\tbreak;\n \n \n \t\t\tf.readDwords(&instr[y].size,1);\n \n// bug_start\n\t\t\tif (instr[y].size < 29)\n// bug_end\n \t\t\t{\n \t\t\t\tmp_ubyte buffer[29];\n \t\t\t\tmemset(buffer, 0, sizeof(buffer));\n \t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n \t\t\t\tmemcpy(instr[y].name, buffer, 22);\n \t\t\t\tinstr[y].type = buffer[22];\n \t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tf.read(&instr[y].name,1,22);\n \t\t\t\tf.read(&instr[y].type,1,1);\n \t\t\t\tf.readWords(&instr[y].samp,1);\n \t\t\t}\n \t\t\tif (instr[y].samp > MP_MAXINSSAMPS)\n \t\t\t\treturn MP_LOADER_FAILED;\n \n \n \t\t\tif (instr[y].size <= 29)\n \t\t\t{\n #ifdef MILKYTRACKER\n \t\t\t\ts+=16;\n #endif\n \t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n \t\t\t\t\tinstr[y].snum[i] = -1;\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tf.readDwords(&instr[y].shsize,1);\n #ifdef VERBOSE\n \t\t\tprintf(\"%i/%i: %i, %i, %i, %s\\n\",y,header->insnum-1,instr[y].size,instr[y].shsize,instr[y].samp,instr[y].name);\n #endif\n \t\t\tmemset(insData, 0, 230);\n \n \t\t\tif (instr[y].size - 33 > 230)\n \t\t\t{\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tf.read(insData, 1, instr[y].size - 33);\n \n \n \t\t\tmemset(smpReloc, 0, sizeof(smpReloc));\n \n \t\t\tif (instr[y].samp) {\n \t\t\t\tmp_ubyte* insDataPtr = insData;\n \n \n \t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n \t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n \n \t\t\t\tTEnvelope venv;\n \t\t\t\tTEnvelope penv;\n \t\t\t\tmemset(&venv,0,sizeof(venv));\n \t\t\t\tmemset(&penv,0,sizeof(penv));\n \n \t\t\t\tmp_sint32 k;\n \t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n \t\t\t\t{\n \t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n \t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n \t\t\t\t\tinsDataPtr+=4;\n \t\t\t\t}\n \t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n \t\t\t\t{\n \t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n \t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n \t\t\t\t\tinsDataPtr+=4;\n \t\t\t\t}\n \n \t\t\t\tvenv.num = *insDataPtr++;\n \t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n \t\t\t\tpenv.num = *insDataPtr++;\n \t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n \t\t\t\tvenv.sustain = *insDataPtr++;\n \t\t\t\tvenv.loops = *insDataPtr++;\n \t\t\t\tvenv.loope = *insDataPtr++;\n \t\t\t\tpenv.sustain = *insDataPtr++;\n \t\t\t\tpenv.loops = *insDataPtr++;\n \t\t\t\tpenv.loope = *insDataPtr++;\n \t\t\t\tvenv.type = *insDataPtr++;\n \t\t\t\tpenv.type = *insDataPtr++;\n \n \t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n \t\t\t\tmp_uword volfade;\n \n \t\t\t\tvibtype = *insDataPtr++;\n \t\t\t\tvibsweep = *insDataPtr++;\n \t\t\t\tvibdepth = *insDataPtr++;\n \t\t\t\tvibrate = *insDataPtr++;\n \n \t\t\t\tvibdepth<<=1;\n \n \t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n \t\t\t\tinsDataPtr+=2;\n \t\t\t\tvolfade<<=1;\n \n \t\t\t\tinsDataPtr+=2;\n \n \t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n \t\t\t\t\tvenv.env[l][1]<<=2;\n \t\t\t\t\tpenv.env[l][1]<<=2;\n \t\t\t\t}\n \n \t\t\t\tif (!module->addVolumeEnvelope(venv))\n \t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \t\t\t\tif (!module->addPanningEnvelope(penv))\n \t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \n \t\t\t\tmp_sint32 g=0, sc;\n \t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n \n \t\t\t\t\tsmp[g+s].flags=3;\n \t\t\t\t\tsmp[g+s].venvnum=e+1;\n \t\t\t\t\tsmp[g+s].penvnum=e+1;\n \n \t\t\t\t\tsmp[g+s].vibtype=vibtype;\n \t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n \t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n \t\t\t\t\tsmp[g+s].vibrate=vibrate;\n \t\t\t\t\tsmp[g+s].volfade=volfade;\n \n \n \t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n \n \t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n \t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n \t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n \t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n \t\t\t\t\tf.read(&smp[g+s].type,1,1);\n #ifdef VERBOSE\n \t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n #endif\n \t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n \t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n \t\t\t\t\tf.read(&smp[g+s].res,1,1);\n \t\t\t\t\tf.read(&smp[g+s].name,1,22);\n \n \t\t\t\t\tchar line[30];\n \t\t\t\t\tmemset(line, 0, sizeof(line));\n \t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\n \t\t\t\t\tif (line[0])\n \t\t\t\t\t\tmodule->addSongMessageLine(line);\n \n #ifndef MILKYTRACKER\n \t\t\t\t\tif (smp[g+s].samplen) {\n \t\t\t\t\t\tsmpReloc[sc] = g;\n \t\t\t\t\t\tg++;\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t\tsmpReloc[sc] = -1;\n #else\n \t\t\t\t\tsmpReloc[sc] = g;\n \t\t\t\t\tg++;\n #endif\n \t\t\t\t}\n \n \t\t\t\tinstr[y].samp = g;\n \n \t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\n \t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n \t\t\t\t\t\tinstr[y].snum[sc] = -1;\n \t\t\t\t\telse\n \t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\n \t\t\t\t}\n \n \t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n \n \t\t\t\t\tif (smp[s].samplen)\n \t\t\t\t\t{\n \t\t\t\t\t\tbool adpcm = (smp[s].res == 0xAD);\n \n \t\t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n \t\t\t\t\t\tif (smp[s].type&16)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tsmp[s].samplen>>=1;\n \t\t\t\t\t\t\tsmp[s].loopstart>>=1;\n \t\t\t\t\t\t\tsmp[s].looplen>>=1;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s,\n \t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_DELTA,\n \t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? (XModule::ST_PACKING_ADPCM | XModule::ST_16BIT) : (XModule::ST_DELTA | XModule::ST_16BIT),\n \t\t\t\t\t\t\t\t\t\t\t\t\t oldSize);\n \t\t\t\t\t\tif (result != MP_OK)\n \t\t\t\t\t\t\treturn result;\n \n \t\t\t\t\t\tif (adpcm)\n \t\t\t\t\t\t\tsmp[s].res = 0;\n \t\t\t\t\t}\n \n \t\t\t\t\ts++;\n \n \t\t\t\t\tif (s>=MP_MAXSAMPLES)\n \t\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \n \t\t\t\t}\n \n \t\t\t\te++;\n \n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n \t\t\t\t\tinstr[y].snum[i] = -1;\n \t\t\t}\n \n #ifdef MILKYTRACKER\n \t\t\ts+=16 - instr[y].samp;\n #endif\n \n \t\t}\n \n \t\theader->smpnum=s;\n \t\theader->volenvnum=e;\n \t\theader->panenvnum=e;\n \n \t}\n \telse\n \t{\n \t\tmp_sint32 s = 0;\n \t\tfor (y=0;y<header->insnum;y++) {\n \t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n \n \t\t\t\tif (smp[s].samplen)\n \t\t\t\t{\n \t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n \t\t\t\t\tif (smp[s].type&16)\n \t\t\t\t\t{\n \t\t\t\t\t\tsmp[s].samplen>>=1;\n \t\t\t\t\t\tsmp[s].loopstart>>=1;\n \t\t\t\t\t\tsmp[s].looplen>>=1;\n \t\t\t\t\t}\n \n \t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s, XModule::ST_DELTA, XModule::ST_DELTA | XModule::ST_16BIT, oldSize);\n \t\t\t\t\tif (result != MP_OK)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \n \t\t\t\ts++;\n \n \t\t\t\tif (s>=MP_MAXSAMPLES)\n \t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \t\t\t}\n \n #ifdef MILKYTRACKER\n \t\t\ts+=16 - instr[y].samp;\n #endif\n \n \t\t}\n \t}\n \n \tfor (mp_sint32 s = 0; s < header->smpnum; s++)\n \t{\n \t\tif (smp[s].type & 32)\n \t\t{\n \t\t\tsmp[s].type &= 3+16;\n \n \t\t\tif (smp[s].sample == NULL)\n \t\t\t\tcontinue;\n \n \t\t\tif (!(smp[s].type&16)) {\n \t\t\t\tsmp[s].samplen>>=1;\n \t\t\t\tsmp[s].loopstart>>=1;\n \t\t\t\tsmp[s].looplen>>=1;\n \n \t\t\t\tmp_sbyte* sample = (mp_sbyte*)smp[s].sample;\n \t\t\t\tmp_sint32 samplen = smp[s].samplen;\n \t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n \t\t\t\t{\n \t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n \t\t\t\t\tif (s < -128) s = -128;\n \t\t\t\t\tif (s > 127) s = 127;\n \t\t\t\t\tsample[i] = (mp_sbyte)s;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tsmp[s].samplen>>=1;\n \t\t\t\tsmp[s].loopstart>>=1;\n \t\t\t\tsmp[s].looplen>>=1;\n \n \t\t\t\tmp_sword* sample = (mp_sword*)smp[s].sample;\n \t\t\t\tmp_sint32 samplen = smp[s].samplen;\n \t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n \t\t\t\t{\n \t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n \t\t\t\t\tif (s < -32768) s = -32768;\n \t\t\t\t\tif (s > 32767) s = 32767;\n \t\t\t\t\tsample[i] = (mp_sword)s;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ((smp[s].type & 0x3) == 0x3)\n \t\t\tsmp[s].type&=~1;\n \t}\n \n \tbool addPatterns = false;\n \tfor (i = 0; i < header->ordnum; i++)\n \t\tif (header->ord[i]+1 > header->patnum)\n \t\t{\n \t\t\theader->patnum = header->ord[i]+1;\n \t\t\taddPatterns = true;\n \t\t}\n \n \tif (addPatterns)\n \t{\n \t\tfor (i = 0; i < header->patnum; i++)\n \t\t\tif (phead[i].patternData == NULL)\n \t\t\t{\n \t\t\t\tphead[i].rows = 64;\n \t\t\t\tphead[i].effnum = 2;\n \t\t\t\tphead[i].channum = (mp_ubyte)header->channum;\n \n \t\t\t\tphead[i].patternData = new mp_ubyte[phead[i].rows*header->channum*6];\n \n \t\t\t\tif (phead[i].patternData == NULL)\n \t\t\t\t{\n \t\t\t\t\treturn MP_OUT_OF_MEMORY;\n \t\t\t\t}\n \n \t\t\t\tmemset(phead[i].patternData,0,phead[i].rows*header->channum*6);\n \t\t\t}\n \t}\n \n \tif (f.posWithBaseOffset() + 8 <= fileSize)\n \t{\n \t\tchar buffer[4];\n \t\tf.read(buffer, 1, 4);\n \t\tif (memcmp(buffer, \"text\", 4) == 0)\n \t\t{\n \t\t\tmp_uint32 len = f.readDword();\n \t\t\tmodule->allocateSongMessage(len+1);\n \n \t\t\tmemset(module->message, 0, len+1);\n \n \t\t\tf.read(module->message, 1, len);\n \t\t}\n \t}\n \n \tmodule->postProcessSamples();\n \n \treturn MP_OK;\n }\n \n", "target": "// fix_start\n\t\t\tif (instr[y].size >= 4 && instr[y].size < 29)\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-34927", "cve_desc": "MilkyTracker v1.03.00 was discovered to contain a stack overflow via the component LoaderXM::load. This vulnerability is triggered when the program is supplied a crafted XM module file.", "project": "MilkyTracker", "idx": 199952}
{"source": " ex_substitute(exarg_T *eap)\n {\n     linenr_T\tlnum;\n     long\ti = 0;\n     regmmatch_T regmatch;\n     static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n \t\t\t\t\t\t\t      FALSE, FALSE, 0};\n #ifdef FEAT_EVAL\n     subflags_T\tsubflags_save;\n #endif\n     int\t\tsave_do_all;\n     int\t\tsave_do_ask;\n     char_u\t*pat = NULL, *sub = NULL;\n// bug_start\n// bug_end\n     int\t\tdelimiter;\n     int\t\tsublen;\n     int\t\tgot_quit = FALSE;\n     int\t\tgot_match = FALSE;\n     int\t\ttemp;\n     int\t\twhich_pat;\n     char_u\t*cmd;\n     int\t\tsave_State;\n     linenr_T\tfirst_line = 0;\n     linenr_T\tlast_line= 0;\n     linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n     linenr_T\tline2;\n     long\tnmatch;\n     char_u\t*sub_firstline;\n     int\t\tendcolumn = FALSE;\n     pos_T\told_cursor = curwin->w_cursor;\n     int\t\tstart_nsubs;\n #ifdef FEAT_EVAL\n     int\t\tsave_ma = 0;\n #endif\n \n     cmd = eap->arg;\n     if (!global_busy)\n     {\n \tsub_nsubs = 0;\n \tsub_nlines = 0;\n     }\n     start_nsubs = sub_nsubs;\n \n     if (eap->cmdidx == CMD_tilde)\n \twhich_pat = RE_LAST;\n     else\n \twhich_pat = RE_SUBST;\n \n     if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n \t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n     {\n \tif (check_regexp_delim(*cmd) == FAIL)\n \t    return;\n #ifdef FEAT_EVAL\n \tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n \t\t\t\t\t\t\t\t      == FAIL)\n \t    return;\n #endif\n \n \tif (*cmd == '\\\\')\n \t{\n \t    ++cmd;\n \t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n \t    {\n \t\temsg(_(e_backslash_should_be_followed_by));\n \t\treturn;\n \t    }\n \t    if (*cmd != '&')\n \t\twhich_pat = RE_SEARCH;\n \t    pat = (char_u *)\"\";\n \t    delimiter = *cmd++;\n \t}\n \telse\n \t{\n \t    which_pat = RE_LAST;\n \t    delimiter = *cmd++;\n \t    pat = cmd;\n \t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n \t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n \t    if (cmd[0] == delimiter)\n \t\t*cmd++ = NUL;\n \t}\n \n \tsub = cmd;\n \tcmd = skip_substitute(cmd, delimiter);\n \n \tif (!eap->skip)\n \t{\n \t    if (STRCMP(sub, \"%\") == 0\n \t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n \t    {\n \t\tif (old_sub == NULL)\n \t\t{\n \t\t    emsg(_(e_no_previous_substitute_regular_expression));\n \t\t    return;\n \t\t}\n \t\tsub = old_sub;\n \t    }\n \t    else\n \t    {\n \t\tvim_free(old_sub);\n \t\told_sub = vim_strsave(sub);\n \t    }\n \t}\n     }\n     else if (!eap->skip)\n     {\n \tif (old_sub == NULL)\n \t{\n \t    emsg(_(e_no_previous_substitute_regular_expression));\n \t    return;\n \t}\n \tpat = NULL;\n \tsub = old_sub;\n \n \tendcolumn = (curwin->w_curswant == MAXCOL);\n     }\n \n     if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n \t    && *sub == NUL\n \t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n \t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n     {\n \tlinenr_T    joined_lines_count;\n \n \tif (eap->skip)\n \t    return;\n \tcurwin->w_cursor.lnum = eap->line1;\n \tif (*cmd == 'l')\n \t    eap->flags = EXFLAG_LIST;\n \telse if (*cmd == '#')\n \t    eap->flags = EXFLAG_NR;\n \telse if (*cmd == 'p')\n \t    eap->flags = EXFLAG_PRINT;\n \n \tjoined_lines_count = eap->line2 - eap->line1 + 1;\n \tif (eap->line2 < curbuf->b_ml.ml_line_count)\n \t    ++joined_lines_count;\n \tif (joined_lines_count > 1)\n \t{\n \t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n \t    sub_nsubs = joined_lines_count - 1;\n \t    sub_nlines = 1;\n \t    (void)do_sub_msg(FALSE);\n \t    ex_may_print(eap);\n \t}\n \n \tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n \t    save_re_pat(RE_SUBST, pat, magic_isset());\n \tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n \n \treturn;\n     }\n \n     if (*cmd == '&')\n \t++cmd;\n     else\n     {\n #ifdef FEAT_EVAL\n \tif (in_vim9script())\n \t{\n \t    subflags.do_all = FALSE;\n \t    subflags.do_ask = FALSE;\n \t}\n \telse\n #endif\n \tif (!p_ed)\n \t{\n \t    if (p_gd)\n \t\tsubflags.do_all = TRUE;\n \t    else\n \t\tsubflags.do_all = FALSE;\n \t    subflags.do_ask = FALSE;\n \t}\n \tsubflags.do_error = TRUE;\n \tsubflags.do_print = FALSE;\n \tsubflags.do_list = FALSE;\n \tsubflags.do_count = FALSE;\n \tsubflags.do_number = FALSE;\n \tsubflags.do_ic = 0;\n     }\n     while (*cmd)\n     {\n \tif (*cmd == 'g')\n \t    subflags.do_all = !subflags.do_all;\n \telse if (*cmd == 'c')\n \t    subflags.do_ask = !subflags.do_ask;\n \telse if (*cmd == 'n')\n \t    subflags.do_count = TRUE;\n \telse if (*cmd == 'e')\n \t    subflags.do_error = !subflags.do_error;\n \telse if (*cmd == 'r')\n \t    which_pat = RE_LAST;\n \telse if (*cmd == 'p')\n \t    subflags.do_print = TRUE;\n \telse if (*cmd == '#')\n \t{\n \t    subflags.do_print = TRUE;\n \t    subflags.do_number = TRUE;\n \t}\n \telse if (*cmd == 'l')\n \t{\n \t    subflags.do_print = TRUE;\n \t    subflags.do_list = TRUE;\n \t}\n \telse if (*cmd == 'i')\n \t    subflags.do_ic = 'i';\n \telse if (*cmd == 'I')\n \t    subflags.do_ic = 'I';\n \telse\n \t    break;\n \t++cmd;\n     }\n     if (subflags.do_count)\n \tsubflags.do_ask = FALSE;\n \n     save_do_all = subflags.do_all;\n     save_do_ask = subflags.do_ask;\n \n     cmd = skipwhite(cmd);\n     if (VIM_ISDIGIT(*cmd))\n     {\n \ti = getdigits(&cmd);\n \tif (i <= 0 && !eap->skip && subflags.do_error)\n \t{\n \t    emsg(_(e_positive_count_required));\n \t    return;\n \t}\n \teap->line1 = eap->line2;\n \teap->line2 += i - 1;\n \tif (eap->line2 > curbuf->b_ml.ml_line_count)\n \t    eap->line2 = curbuf->b_ml.ml_line_count;\n     }\n \n     cmd = skipwhite(cmd);\n     if (*cmd && *cmd != '\"')\n     {\n \tset_nextcmd(eap, cmd);\n \tif (eap->nextcmd == NULL)\n \t{\n \t    semsg(_(e_trailing_characters_str), cmd);\n \t    return;\n \t}\n     }\n \n     if (eap->skip)\n \treturn;\n \n     if (!subflags.do_count && !curbuf->b_p_ma)\n     {\n \temsg(_(e_cannot_make_changes_modifiable_is_off));\n \treturn;\n     }\n \n     if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n     {\n \tif (subflags.do_error)\n \t    emsg(_(e_invalid_command));\n \treturn;\n     }\n \n     if (subflags.do_ic == 'i')\n \tregmatch.rmm_ic = TRUE;\n     else if (subflags.do_ic == 'I')\n \tregmatch.rmm_ic = FALSE;\n \n     sub_firstline = NULL;\n \n// bug_start\n    if (!(sub[0] == '\\\\' && sub[1] == '='))\n// bug_end\n \tsub = regtilde(sub, magic_isset());\n \n     line2 = eap->line2;\n     for (lnum = eap->line1; lnum <= line2 && !(got_quit\n #if defined(FEAT_EVAL)\n \t\t|| aborting()\n #endif\n \t\t); ++lnum)\n     {\n \tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n \t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n \tif (nmatch)\n \t{\n \t    colnr_T\tcopycol;\n \t    colnr_T\tmatchcol;\n \t    colnr_T\tprev_matchcol = MAXCOL;\n \t    char_u\t*new_end, *new_start = NULL;\n \t    unsigned\tnew_start_len = 0;\n \t    char_u\t*p1;\n \t    int\t\tdid_sub = FALSE;\n \t    int\t\tlastone;\n \t    int\t\tlen, copy_len, needed_len;\n \t    long\tnmatch_tl = 0;\n \t    int\t\tdo_again;\n \t    int\t\tskip_match = FALSE;\n \t    linenr_T\tsub_firstlnum;\n #ifdef FEAT_PROP_POPUP\n \t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n \t    colnr_T\ttotal_added =  0;\n #endif\n \n \t    sub_firstlnum = lnum;\n \t    copycol = 0;\n \t    matchcol = 0;\n \n \t    if (!got_match)\n \t    {\n \t\tsetpcmark();\n \t\tgot_match = TRUE;\n \t    }\n \n \t    for (;;)\n \t    {\n \t\tif (regmatch.startpos[0].lnum > 0)\n \t\t{\n \t\t    lnum += regmatch.startpos[0].lnum;\n \t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n \t\t    nmatch -= regmatch.startpos[0].lnum;\n \t\t    VIM_CLEAR(sub_firstline);\n \t\t}\n \n \t\tif (lnum > curbuf->b_ml.ml_line_count)\n \t\t    break;\n \n \t\tif (sub_firstline == NULL)\n \t\t{\n \t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n \t\t    if (sub_firstline == NULL)\n \t\t    {\n \t\t\tvim_free(new_start);\n \t\t\tgoto outofmem;\n \t\t    }\n \t\t}\n \n \t\tcurwin->w_cursor.lnum = lnum;\n \t\tdo_again = FALSE;\n \n \t\tif (matchcol == prev_matchcol\n \t\t\t&& regmatch.endpos[0].lnum == 0\n \t\t\t&& matchcol == regmatch.endpos[0].col)\n \t\t{\n \t\t    if (sub_firstline[matchcol] == NUL)\n \t\t\tskip_match = TRUE;\n \t\t    else\n \t\t    {\n \t\t\tif (has_mbyte)\n \t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n \t\t\telse\n \t\t\t    ++matchcol;\n \t\t    }\n \t\t    goto skip;\n \t\t}\n \n \t\tmatchcol = regmatch.endpos[0].col;\n \t\tprev_matchcol = matchcol;\n \n \t\tif (subflags.do_count)\n \t\t{\n \t\t    if (nmatch > 1)\n \t\t    {\n \t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n \t\t\tnmatch = 1;\n \t\t\tskip_match = TRUE;\n \t\t    }\n \t\t    sub_nsubs++;\n \t\t    did_sub = TRUE;\n #ifdef FEAT_EVAL\n \t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n #endif\n \t\t\tgoto skip;\n \t\t}\n \n \t\tif (subflags.do_ask)\n \t\t{\n \t\t    int typed = 0;\n \n \t\t    save_State = State;\n \t\t    State = CONFIRM;\n \t\t    setmouse();\n \t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n \t\t    if (curwin->w_p_crb)\n \t\t\tdo_check_cursorbind();\n \n \t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n \t\t\t++no_u_sync;\n \n \t\t    while (subflags.do_ask)\n \t\t    {\n \t\t\tif (exmode_active)\n \t\t\t{\n \t\t\t    char_u\t*resp;\n \t\t\t    colnr_T\tsc, ec;\n \n \t\t\t    print_line_no_prefix(lnum,\n \t\t\t\t\t subflags.do_number, subflags.do_list);\n \n \t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n \t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n \t\t\t    if (curwin->w_cursor.col < 0)\n \t\t\t\tcurwin->w_cursor.col = 0;\n \t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n \t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n \t\t\t    if (subflags.do_number || curwin->w_p_nu)\n \t\t\t    {\n \t\t\t\tint numw = number_width(curwin) + 1;\n \t\t\t\tsc += numw;\n \t\t\t\tec += numw;\n \t\t\t    }\n \t\t\t    msg_start();\n \t\t\t    for (i = 0; i < (long)sc; ++i)\n \t\t\t\tmsg_putchar(' ');\n \t\t\t    for ( ; i <= (long)ec; ++i)\n \t\t\t\tmsg_putchar('^');\n \n \t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n \t\t\t    if (resp != NULL)\n \t\t\t    {\n \t\t\t\ttyped = *resp;\n \t\t\t\tvim_free(resp);\n \t\t\t    }\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    char_u *orig_line = NULL;\n \t\t\t    int    len_change = 0;\n \t\t\t    int\t   save_p_lz = p_lz;\n #ifdef FEAT_FOLDING\n \t\t\t    int save_p_fen = curwin->w_p_fen;\n \n \t\t\t    curwin->w_p_fen = FALSE;\n #endif\n \t\t\t    temp = RedrawingDisabled;\n \t\t\t    RedrawingDisabled = 0;\n \n \t\t\t    p_lz = FALSE;\n \n \t\t\t    if (new_start != NULL)\n \t\t\t    {\n \t\t\t\torig_line = vim_strsave(ml_get(lnum));\n \t\t\t\tif (orig_line != NULL)\n \t\t\t\t{\n \t\t\t\t    char_u *new_line = concat_str(new_start,\n \t\t\t\t\t\t     sub_firstline + copycol);\n \n \t\t\t\t    if (new_line == NULL)\n \t\t\t\t\tVIM_CLEAR(orig_line);\n \t\t\t\t    else\n \t\t\t\t    {\n \t\t\t\t\tlen_change = (int)STRLEN(new_line)\n \t\t\t\t\t\t     - (int)STRLEN(orig_line);\n \t\t\t\t\tcurwin->w_cursor.col += len_change;\n \t\t\t\t\tml_replace(lnum, new_line, FALSE);\n \t\t\t\t    }\n \t\t\t\t}\n \t\t\t    }\n \n \t\t\t    search_match_lines = regmatch.endpos[0].lnum\n \t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n \t\t\t    search_match_endcol = regmatch.endpos[0].col\n \t\t\t\t\t\t\t\t + len_change;\n \t\t\t    highlight_match = TRUE;\n \n \t\t\t    update_topline();\n \t\t\t    validate_cursor();\n \t\t\t    update_screen(SOME_VALID);\n \t\t\t    highlight_match = FALSE;\n \t\t\t    redraw_later(SOME_VALID);\n \n #ifdef FEAT_FOLDING\n \t\t\t    curwin->w_p_fen = save_p_fen;\n #endif\n \t\t\t    if (msg_row == Rows - 1)\n \t\t\t\tmsg_didout = FALSE;\n \t\t\t    msg_starthere();\n \t\t\t    i = msg_scroll;\n \t\t\t    msg_scroll = 0;\n \t\t\t    msg_no_more = TRUE;\n \t\t\t    smsg_attr(HL_ATTR(HLF_R),\n \t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n \t\t\t    msg_no_more = FALSE;\n \t\t\t    msg_scroll = i;\n \t\t\t    showruler(TRUE);\n \t\t\t    windgoto(msg_row, msg_col);\n \t\t\t    RedrawingDisabled = temp;\n \n #ifdef USE_ON_FLY_SCROLL\n \t\t\t    dont_scroll = FALSE;\n #endif\n \t\t\t    ++no_mapping;\n \t\t\t    ++allow_keys;\n \t\t\t    typed = plain_vgetc();\n \t\t\t    --allow_keys;\n \t\t\t    --no_mapping;\n \n \t\t\t    msg_didout = FALSE;\n \t\t\t    msg_col = 0;\n \t\t\t    gotocmdline(TRUE);\n \t\t\t    p_lz = save_p_lz;\n \n \t\t\t    if (orig_line != NULL)\n \t\t\t\tml_replace(lnum, orig_line, FALSE);\n \t\t\t}\n \n \t\t\tneed_wait_return = FALSE;\n \t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n #ifdef UNIX\n \t\t\t\t|| typed == intr_char\n #endif\n \t\t\t\t)\n \t\t\t{\n \t\t\t    got_quit = TRUE;\n \t\t\t    break;\n \t\t\t}\n \t\t\tif (typed == 'n')\n \t\t\t    break;\n \t\t\tif (typed == 'y')\n \t\t\t    break;\n \t\t\tif (typed == 'l')\n \t\t\t{\n \t\t\t    subflags.do_all = FALSE;\n \t\t\t    line2 = lnum;\n \t\t\t    break;\n \t\t\t}\n \t\t\tif (typed == 'a')\n \t\t\t{\n \t\t\t    subflags.do_ask = FALSE;\n \t\t\t    break;\n \t\t\t}\n \t\t\tif (typed == Ctrl_E)\n \t\t\t    scrollup_clamp();\n \t\t\telse if (typed == Ctrl_Y)\n \t\t\t    scrolldown_clamp();\n \t\t    }\n \t\t    State = save_State;\n \t\t    setmouse();\n \t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n \t\t\t--no_u_sync;\n \n \t\t    if (typed == 'n')\n \t\t    {\n \t\t\tif (nmatch > 1)\n \t\t\t{\n \t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n \t\t\t    skip_match = TRUE;\n \t\t\t}\n \t\t\tgoto skip;\n \t\t    }\n \t\t    if (got_quit)\n \t\t\tgoto skip;\n \t\t}\n \n \t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n \n #ifdef FEAT_EVAL\n \t\tsave_ma = curbuf->b_p_ma;\n \t\tif (subflags.do_count)\n \t\t{\n \t\t    curbuf->b_p_ma = FALSE;\n \t\t    sandbox++;\n \t\t}\n \t\tsubflags_save = subflags;\n #endif\n \t\tsublen = vim_regsub_multi(&regmatch,\n \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n \t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n #ifdef FEAT_EVAL\n \t\tsubflags = subflags_save;\n \t\tif (aborting() || subflags.do_count)\n \t\t{\n \t\t    curbuf->b_p_ma = save_ma;\n \t\t    if (sandbox > 0)\n \t\t\tsandbox--;\n \t\t    goto skip;\n \t\t}\n #endif\n \n \t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n \t\t{\n \t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n \t\t    skip_match = TRUE;\n \t\t}\n \n \t\tif (nmatch == 1)\n \t\t{\n \t\t    p1 = sub_firstline;\n #ifdef FEAT_PROP_POPUP\n \t\t    if (curbuf->b_has_textprop)\n \t\t    {\n \t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n \t\t\t\t\t\t   - regmatch.startpos[0].col);\n \n \t\t\tif (adjust_prop_columns(lnum,\n \t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n \t\t\t\t\t\t       bytes_added, apc_flags))\n \t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n \t\t\ttotal_added += bytes_added;\n \t\t    }\n #endif\n \t\t}\n \t\telse\n \t\t{\n \t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n \t\t    nmatch_tl += nmatch - 1;\n \t\t}\n \t\tcopy_len = regmatch.startpos[0].col - copycol;\n \t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n \t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n \t\tif (new_start == NULL)\n \t\t{\n \t\t    new_start_len = needed_len + 50;\n \t\t    if ((new_start = alloc(new_start_len)) == NULL)\n \t\t\tgoto outofmem;\n \t\t    *new_start = NUL;\n \t\t    new_end = new_start;\n \t\t}\n \t\telse\n \t\t{\n \t\t    len = (unsigned)STRLEN(new_start);\n \t\t    needed_len += len;\n \t\t    if (needed_len > (int)new_start_len)\n \t\t    {\n \t\t\tnew_start_len = needed_len + 50;\n \t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n \t\t\t{\n \t\t\t    vim_free(new_start);\n \t\t\t    goto outofmem;\n \t\t\t}\n \t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n \t\t\tvim_free(new_start);\n \t\t\tnew_start = p1;\n \t\t    }\n \t\t    new_end = new_start + len;\n \t\t}\n \n \t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n \t\tnew_end += copy_len;\n \n \t\t(void)vim_regsub_multi(&regmatch,\n \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n \t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n \t\tsub_nsubs++;\n \t\tdid_sub = TRUE;\n \n \t\tcurwin->w_cursor.col = 0;\n \n \t\tif (nmatch > 1)\n \t\t{\n \t\t    sub_firstlnum += nmatch - 1;\n \t\t    vim_free(sub_firstline);\n \t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n \t\t    if (sub_firstlnum <= line2)\n \t\t\tdo_again = TRUE;\n \t\t    else\n \t\t\tsubflags.do_all = FALSE;\n \t\t}\n \n \t\tcopycol = regmatch.endpos[0].col;\n \n \t\tif (skip_match)\n \t\t{\n \t\t    vim_free(sub_firstline);\n \t\t    sub_firstline = vim_strsave((char_u *)\"\");\n \t\t    copycol = 0;\n \t\t}\n \n \t\tfor (p1 = new_end; *p1; ++p1)\n \t\t{\n \t\t    if (p1[0] == '\\\\' && p1[1] != NUL)\n \t\t    {\n \t\t\tSTRMOVE(p1, p1 + 1);\n #ifdef FEAT_PROP_POPUP\n \t\t\tif (curbuf->b_has_textprop)\n \t\t\t{\n \t\t\t    if (adjust_prop_columns(lnum,\n \t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n \t\t\t\t\tapc_flags))\n \t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n \t\t\t}\n #endif\n \t\t    }\n \t\t    else if (*p1 == CAR)\n \t\t    {\n \t\t\tif (u_inssub(lnum) == OK)\n \t\t\t{\n \t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n \n \t\t\t    *p1 = NUL;\n \t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n \t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n \t\t\t    if (subflags.do_ask)\n \t\t\t\tappended_lines(lnum - 1, 1L);\n \t\t\t    else\n \t\t\t    {\n \t\t\t\tif (first_line == 0)\n \t\t\t\t    first_line = lnum;\n \t\t\t\tlast_line = lnum + 1;\n \t\t\t    }\n #ifdef FEAT_PROP_POPUP\n \t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n #endif\n \t\t\t    ++sub_firstlnum;\n \t\t\t    ++lnum;\n \t\t\t    ++line2;\n \t\t\t    ++curwin->w_cursor.lnum;\n \t\t\t    STRMOVE(new_start, p1 + 1);\n \t\t\t    p1 = new_start - 1;\n \t\t\t}\n \t\t    }\n \t\t    else if (has_mbyte)\n \t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n \t\t}\n \n skip:\n \t\tlastone = (skip_match\n \t\t\t|| got_int\n \t\t\t|| got_quit\n \t\t\t|| lnum > line2\n \t\t\t|| !(subflags.do_all || do_again)\n \t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n \t\t\t\t\t && !re_multiline(regmatch.regprog)));\n \t\tnmatch = -1;\n \n \t\tif (lastone\n \t\t\t|| nmatch_tl > 0\n \t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n \t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n \t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n \t\t\t|| regmatch.startpos[0].lnum > 0)\n \t\t{\n \t\t    if (new_start != NULL)\n \t\t    {\n \t\t\tSTRCAT(new_start, sub_firstline + copycol);\n \t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n \t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n \t\t\t\t\t\t\t      - prev_matchcol;\n \n \t\t\tif (u_savesub(lnum) != OK)\n \t\t\t    break;\n \t\t\tml_replace(lnum, new_start, TRUE);\n \n \t\t\tif (nmatch_tl > 0)\n \t\t\t{\n \t\t\t    ++lnum;\n \t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n \t\t\t\tbreak;\n \t\t\t    for (i = 0; i < nmatch_tl; ++i)\n \t\t\t\tml_delete(lnum);\n \t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n \t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n \t\t\t    if (subflags.do_ask)\n \t\t\t\tdeleted_lines(lnum, nmatch_tl);\n \t\t\t    --lnum;\n \t\t\t    line2 -= nmatch_tl;\n \t\t\t    nmatch_tl = 0;\n \t\t\t}\n \n \t\t\tif (subflags.do_ask)\n \t\t\t    changed_bytes(lnum, 0);\n \t\t\telse\n \t\t\t{\n \t\t\t    if (first_line == 0)\n \t\t\t\tfirst_line = lnum;\n \t\t\t    last_line = lnum + 1;\n \t\t\t}\n \n \t\t\tsub_firstlnum = lnum;\n \t\t\tvim_free(sub_firstline);\n \t\t\tsub_firstline = new_start;\n \t\t\tnew_start = NULL;\n \t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n \t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n \t\t\t\t\t\t\t      - prev_matchcol;\n \t\t\tcopycol = 0;\n \t\t    }\n \t\t    if (nmatch == -1 && !lastone)\n \t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n \t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n \n \t\t    if (nmatch <= 0)\n \t\t    {\n \t\t\tif (nmatch == -1)\n \t\t\t    lnum -= regmatch.startpos[0].lnum;\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \n \t\tline_breakcheck();\n \t    }\n \n \t    if (did_sub)\n \t\t++sub_nlines;\n \t    vim_free(new_start);\n \t    VIM_CLEAR(sub_firstline);\n \t}\n \n \tline_breakcheck();\n     }\n \n     if (first_line != 0)\n     {\n \ti = curbuf->b_ml.ml_line_count - old_line_count;\n \tchanged_lines(first_line, 0, last_line - i, i);\n     }\n \n outofmem:\n     vim_free(sub_firstline);\n \n     if (subflags.do_count)\n \tcurwin->w_cursor = old_cursor;\n \n     if (sub_nsubs > start_nsubs)\n     {\n \tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n \t{\n \t    curbuf->b_op_start.lnum = eap->line1;\n \t    curbuf->b_op_end.lnum = line2;\n \t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n \t}\n \n \tif (!global_busy)\n \t{\n \t    if (!subflags.do_ask)\n \t    {\n \t\tif (endcolumn)\n \t\t    coladvance((colnr_T)MAXCOL);\n \t\telse\n \t\t    beginline(BL_WHITE | BL_FIX);\n \t    }\n \t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n \t\tmsg(\"\");\n \t}\n \telse\n \t    global_need_beginline = TRUE;\n \tif (subflags.do_print)\n \t    print_line(curwin->w_cursor.lnum,\n \t\t\t\t\t subflags.do_number, subflags.do_list);\n     }\n     else if (!global_busy)\n     {\n \tif (got_int)\n \t    emsg(_(e_interrupted));\n \telse if (got_match)\n \t    msg(\"\");\n \telse if (subflags.do_error)\n \t    semsg(_(e_pattern_not_found_str), get_search_pat());\n     }\n \n #ifdef FEAT_FOLDING\n     if (subflags.do_ask && hasAnyFolding(curwin))\n \tchanged_window_setting();\n #endif\n \n     vim_regfree(regmatch.regprog);\n// bug_start\n// bug_end\n \n     subflags.do_all = save_do_all;\n     subflags.do_ask = save_do_ask;\n }\n \n", "target": "// fix_start\n    char_u\t*sub_copy = NULL;\n// fix_end\n// fix_start\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n// fix_end\n// fix_start\n    vim_free(sub_copy);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-0413", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 199984}
{"source": " static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n   ExceptionInfo *exception)\n {\n   typedef struct {\n     unsigned char Type[4];\n     unsigned int nRows;\n     unsigned int nCols;\n     unsigned int imagf;\n     unsigned int nameLen;\n   } MAT4_HDR;\n \n   long\n     ldblk;\n \n   EndianType\n     endian;\n \n   Image\n     *rotated_image;\n \n   MagickBooleanType\n     status;\n \n   MAT4_HDR\n     HDR;\n \n   QuantumInfo\n     *quantum_info;\n \n   QuantumFormatType\n     format_type;\n \n   register ssize_t\n     i;\n \n   ssize_t\n     count,\n     y;\n \n   unsigned char\n     *pixels;\n \n   unsigned int\n     depth;\n \n// bug_start\n\n// bug_end\n   quantum_info=(QuantumInfo *) NULL;\n   (void) SeekBlob(image,0,SEEK_SET);\n// bug_start\n// bug_end\n   while (EOFBlob(image) == MagickFalse)\n   {\n     ldblk=ReadBlobLSBLong(image);\n     if ((ldblk > 9999) || (ldblk < 0))\n       break;\n     HDR.Type[3]=ldblk % 10; ldblk /= 10;\n     HDR.Type[2]=ldblk % 10; ldblk /= 10;\n     HDR.Type[1]=ldblk % 10; ldblk /= 10;\n     HDR.Type[0]=ldblk;\n     if (HDR.Type[3] != 0)\n       break;\n     if (HDR.Type[2] != 0)\n       break;\n     if (HDR.Type[0] == 0)\n       {\n         HDR.nRows=ReadBlobLSBLong(image);\n         HDR.nCols=ReadBlobLSBLong(image);\n         HDR.imagf=ReadBlobLSBLong(image);\n         HDR.nameLen=ReadBlobLSBLong(image);\n         endian=LSBEndian;\n       }\n     else\n       {\n         HDR.nRows=ReadBlobMSBLong(image);\n         HDR.nCols=ReadBlobMSBLong(image);\n         HDR.imagf=ReadBlobMSBLong(image);\n         HDR.nameLen=ReadBlobMSBLong(image);\n         endian=MSBEndian;\n       }\n     if ((HDR.imagf != 0) && (HDR.imagf != 1))\n       break;\n     if (HDR.nameLen > 0xFFFF)\n       return(DestroyImageList(image));\n     for (i=0; i < (ssize_t) HDR.nameLen; i++)\n     {\n       int\n         byte;\n \n       byte=ReadBlobByte(image);\n       if (byte == EOF)\n         {\n           ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n             image->filename);\n           break;\n         }\n     }\n     image->columns=(size_t) HDR.nRows;\n     image->rows=(size_t) HDR.nCols;\n     if ((image->columns == 0) || (image->rows == 0))\n       return(DestroyImageList(image));\n     if (image_info->ping != MagickFalse)\n       {\n         Swap(image->columns,image->rows);\n         if(HDR.imagf==1) ldblk *= 2;\n         SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);\n         if ((image->columns == 0) || (image->rows == 0))\n           return(image->previous == (Image *) NULL ? DestroyImageList(image)\n             : image);\n         goto skip_reading_current;\n       }\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n     if (status == MagickFalse)\n       return(DestroyImageList(image));\n     (void) SetImageBackgroundColor(image,exception);\n     (void) SetImageColorspace(image,GRAYColorspace,exception);\n     quantum_info=AcquireQuantumInfo(image_info,image);\n     if (quantum_info == (QuantumInfo *) NULL)\n       return(DestroyImageList(image));\n     switch(HDR.Type[1])\n     {\n       case 0:\n         format_type=FloatingPointQuantumFormat;\n         depth=64;\n         break;\n       case 1:\n         format_type=FloatingPointQuantumFormat;\n         depth=32;\n         break;\n       case 2:\n         format_type=UnsignedQuantumFormat;\n         depth=16;\n         break;\n       case 3:\n         format_type=SignedQuantumFormat;\n         depth=16;\n         break;\n       case 4:\n         format_type=UnsignedQuantumFormat;\n         depth=8;\n         break;\n       default:\n         format_type=UnsignedQuantumFormat;\n         depth=8;\n         break;\n     }\n     image->depth=depth;\n     if (HDR.Type[0] != 0)\n       SetQuantumEndian(image,quantum_info,MSBEndian);\n     status=SetQuantumFormat(image,quantum_info,format_type);\n     status=SetQuantumDepth(image,quantum_info,depth);\n     status=SetQuantumEndian(image,quantum_info,endian);\n     SetQuantumScale(quantum_info,1.0);\n     pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       register Quantum\n         *magick_restrict q;\n \n       count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n       if (count == -1)\n         break;\n       q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n         exception);\n       if (q == (Quantum *) NULL)\n         break;\n       (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n         GrayQuantum,pixels,exception);\n       if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n         FixSignedValues(image,q,(int) image->columns);\n       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n         break;\n       if (image->previous == (Image *) NULL)\n         {\n           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n             image->rows);\n           if (status == MagickFalse)\n             break;\n         }\n     }\n     if (HDR.imagf == 1)\n       for (y=0; y < (ssize_t) image->rows; y++)\n       {\n         count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n         if (count == -1)\n           break;\n         if (HDR.Type[1] == 0)\n           InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n         else\n           InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n       }\n     if (quantum_info != (QuantumInfo *) NULL)\n       quantum_info=DestroyQuantumInfo(quantum_info);\n     if (EOFBlob(image) != MagickFalse)\n       {\n         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n           image->filename);\n         break;\n       }\n     rotated_image=RotateImage(image,90.0,exception);\n     if (rotated_image != (Image *) NULL)\n       {\n         rotated_image->page.x=0;\n         rotated_image->page.y=0;\n         rotated_image->colors = image->colors;\n         DestroyBlob(rotated_image);\n         rotated_image->blob=ReferenceBlob(image->blob);\n         AppendImageToList(&image,rotated_image);\n         DeleteImageFromList(&image);\n       }\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n skip_reading_current:\n     AcquireNextImage(image_info,image,exception);\n     if (GetNextImageInList(image) == (Image *) NULL)\n       {\n         status=MagickFalse;\n         break;\n       }\n     image=SyncNextImageInList(image);\n     status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n       GetBlobSize(image));\n     if (status == MagickFalse)\n       break;\n   }\n   (void) CloseBlob(image);\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n  status=MagickTrue;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2018-14551", "cve_desc": "The ReadMATImageV4 function in coders/mat.c in ImageMagick 7.0.8-7 uses an uninitialized variable, leading to memory corruption.", "project": "ImageMagick", "idx": 200113}
{"source": " readconf_main(void)\n {\n int sep = 0;\n struct stat statbuf;\n uschar *s, *filename;\n uschar *list = config_main_filelist;\n \n \n while((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n        != NULL)\n   {\n \n   #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n   uschar *suffix = filename + Ustrlen(filename);\n \n \n   #ifdef CONFIGURE_FILE_USE_NODE\n   struct utsname uts;\n   if (uname(&uts) >= 0)\n     {\n     #ifdef CONFIGURE_FILE_USE_EUID\n     sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n     config_file = Ufopen(filename, \"rb\");\n     if (config_file == NULL)\n     #endif\n       {\n       sprintf(CS suffix, \".%.256s\", uts.nodename);\n       config_file = Ufopen(filename, \"rb\");\n       }\n     }\n   #endif\n \n \n   #ifdef CONFIGURE_FILE_USE_EUID\n   if (config_file == NULL)\n     {\n     sprintf(CS suffix, \".%ld\", (long int)original_euid);\n     config_file = Ufopen(filename, \"rb\");\n     }\n   #endif\n \n \n   if (config_file == NULL)\n     {\n     *suffix = 0;\n     config_file = Ufopen(filename, \"rb\");\n     }\n   #else\n \n \n   config_file = Ufopen(filename, \"rb\");\n   #endif\n \n \n   if (config_file != NULL || errno != ENOENT) break;\n   }\n \n \n if (config_file != NULL)\n   {\n   config_filename = config_main_filename = string_copy(filename);\n   }\n else\n   {\n   if (filename == NULL)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n       \"%s\", config_main_filelist);\n   else\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n       \"configuration file %s\", filename));\n   }\n \n \n// bug_start\nif (!config_changed)\n// bug_end\n   {\n   if (fstat(fileno(config_file), &statbuf) != 0)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n       big_buffer);\n \n   if ((statbuf.st_uid != root_uid\n        #ifdef CONFIGURE_OWNER\n        && statbuf.st_uid != config_uid\n        #endif\n          ) ||\n       (statbuf.st_gid != root_gid\n        #ifdef CONFIGURE_GROUP\n        && statbuf.st_gid != config_gid\n        #endif\n        && (statbuf.st_mode & 020) != 0) ||\n       ((statbuf.st_mode & 2) != 0))\n \n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n       \"wrong owner, group, or mode\", big_buffer);\n   }\n \n \n while ((s = get_config_line()) != NULL)\n   {\n   if (isupper(s[0])) read_macro_assignment(s);\n \n   else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n     read_named_list(&domainlist_anchor, &domainlist_count,\n       MAX_NAMED_LIST, s+10, US\"domain list\");\n \n   else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n     read_named_list(&hostlist_anchor, &hostlist_count,\n       MAX_NAMED_LIST, s+8, US\"host list\");\n \n   else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n     read_named_list(&addresslist_anchor, &addresslist_count,\n       MAX_NAMED_LIST, s+11, US\"address list\");\n \n   else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n     read_named_list(&localpartlist_anchor, &localpartlist_count,\n       MAX_NAMED_LIST, s+13, US\"local part list\");\n \n   else\n     (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n       NULL, US\"main option \\\"%s\\\" unknown\");\n   }\n \n \n \n if (local_sender_retain && local_from_check)\n   log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n     \"local_sender_retain are set; this combination is not allowed\");\n \n \n if (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\n \n \n if (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\n \n \n if (remote_max_parallel <= 0) remote_max_parallel = 1;\n \n \n freeze_tell_config = freeze_tell;\n \n \n if (primary_hostname == NULL)\n   {\n   uschar *hostname;\n   struct utsname uts;\n   if (uname(&uts) < 0)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n   hostname = US uts.nodename;\n \n   if (Ustrchr(hostname, '.') == NULL)\n     {\n     int af = AF_INET;\n     struct hostent *hostdata;\n \n     #if HAVE_IPV6\n     if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n          match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n            TRUE, NULL) != OK))\n       af = AF_INET6;\n     #else\n     af = AF_INET;\n     #endif\n \n     for (;;)\n       {\n       #if HAVE_IPV6\n         #if HAVE_GETIPNODEBYNAME\n         int error_num;\n         hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n         #else\n         hostdata = gethostbyname2(CS hostname, af);\n         #endif\n       #else\n       hostdata = gethostbyname(CS hostname);\n       #endif\n \n       if (hostdata != NULL)\n         {\n         hostname = US hostdata->h_name;\n         break;\n         }\n \n       if (af == AF_INET) break;\n       af = AF_INET;\n       }\n     }\n \n   primary_hostname = string_copy(hostname);\n   }\n \n \n smtp_active_hostname = primary_hostname;\n \n \n if (*spool_directory == 0)\n   log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n     \"proceed\");\n \n \n s = expand_string(spool_directory);\n if (s == NULL)\n   log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n     \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\n spool_directory = s;\n \n \n if (*log_file_path != 0)\n   {\n   uschar *ss, *sss;\n   int sep = ':';\n   s = expand_string(log_file_path);\n   if (s == NULL)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n       \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n \n   ss = s;\n   while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n     {\n     uschar *t;\n     if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n     t = Ustrstr(sss, \"%s\");\n     if (t == NULL)\n       log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n         \"contain \\\"%%s\\\"\", sss);\n     *t = 'X';\n     t = Ustrchr(sss, '%');\n     if (t != NULL)\n       {\n       if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n         log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n           \"unexpected \\\"%%\\\" character\", s);\n       }\n     }\n \n   log_file_path = s;\n   }\n \n \n if (syslog_facility_str != NULL)\n   {\n   int i;\n   uschar *s = syslog_facility_str;\n \n   if ((Ustrlen(syslog_facility_str) >= 4) &&\n         (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n     s += 4;\n \n   for (i = 0; i < syslog_list_size; i++)\n     {\n     if (strcmpic(s, syslog_list[i].name) == 0)\n       {\n       syslog_facility = syslog_list[i].value;\n       break;\n       }\n     }\n \n   if (i >= syslog_list_size)\n     {\n     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n       \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n     }\n   }\n \n \n if (*pid_file_path != 0)\n   {\n   s = expand_string(pid_file_path);\n   if (s == NULL)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n       \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n   pid_file_path = s;\n   }\n \n \n regex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\n \n \n if (smtp_ratelimit_mail != NULL)\n   {\n   unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n     &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n   }\n \n if (smtp_ratelimit_rcpt != NULL)\n   {\n   unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n     &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n   }\n \n \n if (qualify_domain_sender == NULL)\n   qualify_domain_sender = primary_hostname;\n if (qualify_domain_recipient == NULL)\n   qualify_domain_recipient = qualify_domain_sender;\n \n \n if (system_filter_uid_set && !system_filter_gid_set)\n   {\n   struct passwd *pw = getpwuid(system_filter_uid);\n   if (pw == NULL)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n       (long int)system_filter_uid);\n   system_filter_gid = pw->pw_gid;\n   system_filter_gid_set = TRUE;\n   }\n \n \n if (errors_reply_to != NULL)\n   {\n   uschar *errmess;\n   int start, end, domain;\n   uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n     &start, &end, &domain, FALSE);\n \n   if (recipient == NULL)\n     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n       \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n \n   if (domain == 0)\n     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n       \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n   }\n \n \n if (smtp_accept_max == 0 &&\n     (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n   log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n     \"smtp_accept_max must be set if smtp_accept_queue or \"\n     \"smtp_accept_max_per_host is set\");\n \n \n if (host_number_string != NULL)\n   {\n   uschar *end;\n   uschar *s = expand_string(host_number_string);\n   long int n = Ustrtol(s, &end, 0);\n   while (isspace(*end)) end++;\n   if (*end != 0)\n     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n       \"localhost_number value is not a number: %s\", s);\n   if (n > LOCALHOST_MAX)\n     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n       \"localhost_number is greater than the maximum allowed value (%d)\",\n         LOCALHOST_MAX);\n   host_number = n;\n   }\n \n #ifdef SUPPORT_TLS\n \n if ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n      tls_verify_certificates == NULL)\n   log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n     \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n     (tls_verify_hosts != NULL)? \"\" : \"try_\");\n \n if (openssl_options != NULL)\n   {\n # ifdef USE_GNUTLS\n   log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n     \"openssl_options is set but we're using GnuTLS\");\n # else\n   long dummy;\n   if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n       \"openssl_options parse error: %s\", openssl_options);\n # endif\n   }\n #endif\n }\n \n", "target": "// fix_start\nif (trusted_config)\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "cve": "CVE-2010-4345", "cve_desc": "Exim 4.72 and earlier allows local users to gain privileges by leveraging the ability of the exim user account to specify an alternate configuration file with a directive that contains arbitrary commands, as demonstrated by the spool_directory directive.", "project": "exim", "idx": 200157}
{"source": " static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n {\n \tstruct elo_priv *priv;\n \tint ret;\n \tstruct usb_device *udev;\n \n \tif (!hid_is_usb(hdev))\n \t\treturn -EINVAL;\n \n \tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n \n \tINIT_DELAYED_WORK(&priv->work, elo_work);\n \tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n \tpriv->usbdev = usb_get_dev(udev);\n \n \thid_set_drvdata(hdev, priv);\n \n \tret = hid_parse(hdev);\n \tif (ret) {\n \t\thid_err(hdev, \"parse failed\\n\");\n \t\tgoto err_free;\n \t}\n \n \tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n \tif (ret) {\n \t\thid_err(hdev, \"hw start failed\\n\");\n \t\tgoto err_free;\n \t}\n \n \tif (elo_broken_firmware(priv->usbdev)) {\n \t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n \t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n \t}\n \n \treturn 0;\n err_free:\n// bug_start\n// bug_end\n \tkfree(priv);\n \treturn ret;\n }\n \n", "target": "// fix_start\n\tusb_put_dev(udev);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2022-27950", "cve_desc": "In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition.", "project": "linux", "idx": 200163}
{"source": " static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)\n {\n \tstruct sock *sk = sock->sk;\n \tstruct net *net = sock_net(sk);\n \tstruct tipc_sock *tsk = tipc_sk(sk);\n \tstruct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;\n \tlong timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);\n \tstruct list_head *clinks = &tsk->cong_links;\n \tbool syn = !tipc_sk_type_connectionless(sk);\n \tstruct tipc_group *grp = tsk->group;\n \tstruct tipc_msg *hdr = &tsk->phdr;\n \tstruct tipc_socket_addr skaddr;\n \tstruct sk_buff_head pkts;\n \tint atype, mtu, rc;\n \n \tif (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))\n \t\treturn -EMSGSIZE;\n \n \tif (ua) {\n \t\tif (!tipc_uaddr_valid(ua, m->msg_namelen))\n \t\t\treturn -EINVAL;\n \t\tatype = ua->addrtype;\n \t}\n \n \tif (grp) {\n \t\tif (!ua)\n \t\t\treturn tipc_send_group_bcast(sock, m, dlen, timeout);\n \t\tif (atype == TIPC_SERVICE_ADDR)\n \t\t\treturn tipc_send_group_anycast(sock, m, dlen, timeout);\n \t\tif (atype == TIPC_SOCKET_ADDR)\n \t\t\treturn tipc_send_group_unicast(sock, m, dlen, timeout);\n \t\tif (atype == TIPC_SERVICE_RANGE)\n \t\t\treturn tipc_send_group_mcast(sock, m, dlen, timeout);\n \t\treturn -EINVAL;\n \t}\n \n \tif (!ua) {\n \t\tua = (struct tipc_uaddr *)&tsk->peer;\n \t\tif (!syn && ua->family != AF_TIPC)\n \t\t\treturn -EDESTADDRREQ;\n \t\tatype = ua->addrtype;\n \t}\n \n \tif (unlikely(syn)) {\n \t\tif (sk->sk_state == TIPC_LISTEN)\n \t\t\treturn -EPIPE;\n \t\tif (sk->sk_state != TIPC_OPEN)\n \t\t\treturn -EISCONN;\n \t\tif (tsk->published)\n \t\t\treturn -EOPNOTSUPP;\n \t\tif (atype == TIPC_SERVICE_ADDR)\n \t\t\ttsk->conn_addrtype = atype;\n \t\tmsg_set_syn(hdr, 1);\n \t}\n// bug_start\n// bug_end\n \n \tif (atype == TIPC_SERVICE_RANGE) {\n \t\treturn tipc_sendmcast(sock, ua, m, dlen, timeout);\n \t} else if (atype == TIPC_SERVICE_ADDR) {\n \t\tskaddr.node = ua->lookup_node;\n \t\tua->scope = tipc_node2scope(skaddr.node);\n \t\tif (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))\n \t\t\treturn -EHOSTUNREACH;\n \t} else if (atype == TIPC_SOCKET_ADDR) {\n \t\tskaddr = ua->sk;\n \t} else {\n \t\treturn -EINVAL;\n \t}\n \n \trc = tipc_wait_for_cond(sock, &timeout,\n \t\t\t\t!tipc_dest_find(clinks, skaddr.node, 0));\n \tif (unlikely(rc))\n \t\treturn rc;\n \n \tmsg_set_destnode(hdr, skaddr.node);\n \tmsg_set_destport(hdr, skaddr.ref);\n \tif (atype == TIPC_SERVICE_ADDR) {\n \t\tmsg_set_type(hdr, TIPC_NAMED_MSG);\n \t\tmsg_set_hdr_sz(hdr, NAMED_H_SIZE);\n \t\tmsg_set_nametype(hdr, ua->sa.type);\n \t\tmsg_set_nameinst(hdr, ua->sa.instance);\n \t\tmsg_set_lookup_scope(hdr, ua->scope);\n \t} else {\n \t\tmsg_set_type(hdr, TIPC_DIRECT_MSG);\n \t\tmsg_set_lookup_scope(hdr, 0);\n \t\tmsg_set_hdr_sz(hdr, BASIC_H_SIZE);\n \t}\n \n \t__skb_queue_head_init(&pkts);\n \tmtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);\n \trc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);\n \tif (unlikely(rc != dlen))\n \t\treturn rc;\n \tif (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {\n \t\t__skb_queue_purge(&pkts);\n \t\treturn -ENOMEM;\n \t}\n \n \ttrace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, \" \");\n \trc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);\n \tif (unlikely(rc == -ELINKCONG)) {\n \t\ttipc_dest_push(clinks, skaddr.node, 0);\n \t\ttsk->cong_link_cnt++;\n \t\trc = 0;\n \t}\n \n \tif (unlikely(syn && !rc)) {\n \t\ttipc_set_sk_state(sk, TIPC_CONNECTING);\n \t\tif (dlen && timeout) {\n \t\t\ttimeout = msecs_to_jiffies(timeout);\n \t\t\ttipc_wait_for_connect(sock, &timeout);\n \t\t}\n \t}\n \n \treturn rc ? rc : dlen;\n }\n \n", "target": "// fix_start\n\n\tmemset(&skaddr, 0, sizeof(skaddr));\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2022-0382", "cve_desc": "An information leak flaw was found due to uninitialized memory in the Linux kernel's TIPC protocol subsystem, in the way a user sends a TIPC datagram to one or more destinations. This flaw allows a local user to read some kernel memory. This issue is limited to no more than 7 bytes, and the user cannot control what is read. This flaw affects the Linux kernel versions prior to 5.17-rc1.", "project": "linux", "idx": 200287}
{"source": " pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file)\n {\n #define MAX_RUN_COUNT 15\n     int max_run = step * MAX_RUN_COUNT;\n \n     while (from < end) {\n         byte data = *from;\n \n         from += step;\n// bug_start\n        if (data != *from || from == end) {\n// bug_end\n             if (data >= 0xc0)\n                 gp_fputc(0xc1, file);\n         } else {\n             const byte *start = from;\n \n             while ((from < end) && (*from == data))\n                 from += step;\n             while (from - start >= max_run) {\n                 gp_fputc(0xc0 + MAX_RUN_COUNT, file);\n                 gp_fputc(data, file);\n                 start += max_run;\n             }\n             if (from > start || data >= 0xc0)\n                 gp_fputc((from - start) / step + 0xc1, file);\n         }\n         gp_fputc(data, file);\n     }\n #undef MAX_RUN_COUNT\n }\n \n", "target": "// fix_start\n        if (from >= end || data != *from) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-16305", "cve_desc": "A buffer overflow vulnerability in pcx_write_rle() in contrib/japanese/gdev10v.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.", "project": "ghostpdl", "idx": 200305}
{"source": " static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n \t\t\t      struct files_struct *fsp,\n \t\t\t      TALLOC_CTX *ctx,\n \t\t\t      uint32_t function,\n \t\t\t      uint16_t req_flags,\n \t\t\t      const uint8_t *_in_data,\n \t\t\t      uint32_t in_len,\n \t\t\t      uint8_t **_out_data,\n \t\t\t      uint32_t max_out_len,\n \t\t\t      uint32_t *out_len)\n {\n \tconst char *in_data = (const char *)_in_data;\n \tchar **out_data = (char **)_out_data;\n \n \tswitch (function) {\n \tcase FSCTL_SET_SPARSE:\n \t{\n \t\tbool set_sparse = true;\n \t\tNTSTATUS status;\n \n \t\tif (in_len >= 1 && in_data[0] == 0) {\n \t\t\tset_sparse = false;\n \t\t}\n \n \t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n \n \t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n \t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n \t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse,\n \t\t       nt_errstr(status)));\n \n \t\treturn status;\n \t}\n \n \tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n \t{\n \t\tunsigned char objid[16];\n \t\tchar *return_data = NULL;\n \n \n \t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n \t\t\t  fsp_fnum_dbg(fsp)));\n \n \t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n \t\treturn_data = talloc_array(ctx, char, 64);\n \t\tif (return_data == NULL) {\n \t\t\treturn NT_STATUS_NO_MEMORY;\n \t\t}\n \n \t\tpush_file_id_16(return_data, &fsp->file_id);\n \t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n \t\tpush_file_id_16(return_data+32, &fsp->file_id);\n \t\t*out_data = return_data;\n \t\treturn NT_STATUS_OK;\n \t}\n \n \tcase FSCTL_GET_REPARSE_POINT:\n \t{\n \t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n \t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n \t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n \t}\n \n \tcase FSCTL_SET_REPARSE_POINT:\n \t{\n \t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n \t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n \t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n \t}\n \n \tcase FSCTL_GET_SHADOW_COPY_DATA:\n \t{\n \t\tstruct shadow_copy_data *shadow_data = NULL;\n \t\tbool labels = False;\n \t\tuint32 labels_data_count = 0;\n \t\tuint32 i;\n \t\tchar *cur_pdata = NULL;\n \n \t\tif (max_out_len < 16) {\n \t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n \t\t\t\tmax_out_len));\n \t\t\treturn NT_STATUS_INVALID_PARAMETER;\n \t\t}\n \n \t\tif (max_out_len > 16) {\n \t\t\tlabels = True;\n \t\t}\n \n \t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n \t\tif (shadow_data == NULL) {\n \t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n \t\t\treturn NT_STATUS_NO_MEMORY;\n \t\t}\n \n \t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n \t\t\tTALLOC_FREE(shadow_data);\n \t\t\tif (errno == ENOSYS) {\n \t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\",\n \t\t\t\t\tfsp->conn->connectpath));\n \t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n \t\t\t} else {\n \t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\",\n \t\t\t\t\tfsp->conn->connectpath));\n \t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n \t\t\t}\n \t\t}\n \n \t\tlabels_data_count = (shadow_data->num_volumes * 2 *\n \t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n \n \t\tif (!labels) {\n \t\t\t*out_len = 16;\n \t\t} else {\n// bug_start\n\t\t\t*out_len = 12 + labels_data_count + 4;\n// bug_end\n \t\t}\n \n \t\tif (max_out_len < *out_len) {\n \t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n \t\t\t\tmax_out_len, *out_len));\n \t\t\tTALLOC_FREE(shadow_data);\n \t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n \t\t}\n \n \t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n \t\tif (cur_pdata == NULL) {\n \t\t\tTALLOC_FREE(shadow_data);\n \t\t\treturn NT_STATUS_NO_MEMORY;\n \t\t}\n \n \t\t*out_data = cur_pdata;\n \n \t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n \n \t\tif (labels) {\n \t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n \t\t}\n \n// bug_start\n\t\tSIVAL(cur_pdata, 8, labels_data_count + 4);\n// bug_end\n \n \t\tcur_pdata += 12;\n \n \t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n \t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n \t\tif (labels && shadow_data->labels) {\n \t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n \t\t\t\tsrvstr_push(cur_pdata, req_flags,\n \t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n \t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n \t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n \t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n \t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n \t\t\t}\n \t\t}\n \n \t\tTALLOC_FREE(shadow_data);\n \n \t\treturn NT_STATUS_OK;\n \t}\n \n \tcase FSCTL_FIND_FILES_BY_SID:\n \t{\n \t\tstruct dom_sid sid;\n \t\tuid_t uid;\n \t\tsize_t sid_len;\n \n \t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n \t\t\t   fsp_fnum_dbg(fsp)));\n \n \t\tif (in_len < 8) {\n \t\t\treturn NT_STATUS_INVALID_PARAMETER;\n \t\t}\n \n \t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n \n \n \t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n \t\t\treturn NT_STATUS_INVALID_PARAMETER;\n \t\t}\n \t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n \n \t\tif (!sid_to_uid(&sid, &uid)) {\n \t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n \t\t\t\t sid_string_dbg(&sid),\n \t\t\t\t (unsigned long)sid_len));\n \t\t\tuid = (-1);\n \t\t}\n \n \n \t\treturn NT_STATUS_OK;\n \t}\n \n \tcase FSCTL_QUERY_ALLOCATED_RANGES:\n \t{\n \t\tNTSTATUS status;\n \t\tuint64_t offset, length;\n \t\tchar *out_data_tmp = NULL;\n \n \t\tif (in_len != 16) {\n \t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n \t\t\t\tin_len));\n \t\t\treturn NT_STATUS_INVALID_PARAMETER;\n \t\t}\n \n \t\tif (max_out_len < 16) {\n \t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n \t\t\t\tmax_out_len));\n \t\t\treturn NT_STATUS_INVALID_PARAMETER;\n \t\t}\n \n \t\toffset = BVAL(in_data,0);\n \t\tlength = BVAL(in_data,8);\n \n \t\tif (offset + length < offset) {\n \t\t\treturn NT_STATUS_INVALID_PARAMETER;\n \t\t}\n \n \t\tstatus = vfs_stat_fsp(fsp);\n \t\tif (!NT_STATUS_IS_OK(status)) {\n \t\t\treturn status;\n \t\t}\n \n \t\t*out_len = 16;\n \t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n \t\tif (out_data_tmp == NULL) {\n \t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n \t\t\treturn NT_STATUS_NO_MEMORY;\n \t\t}\n \n \t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n \t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n \t\t\t\tlength == 0) {\n \t\t\tmemset(out_data_tmp, 0, *out_len);\n \t\t} else {\n \t\t\tuint64_t end = offset + length;\n \t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n \t\t\tSBVAL(out_data_tmp, 0, 0);\n \t\t\tSBVAL(out_data_tmp, 8, end);\n \t\t}\n \n \t\t*out_data = out_data_tmp;\n \n \t\treturn NT_STATUS_OK;\n \t}\n \n \tcase FSCTL_IS_VOLUME_DIRTY:\n \t{\n \t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n \t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n \t\treturn NT_STATUS_INVALID_PARAMETER;\n \t}\n \n \tdefault:\n \t\tif (!vfswrap_logged_ioctl_message) {\n \t\t\tvfswrap_logged_ioctl_message = true;\n \t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n \t\t\t__func__, function));\n \t\t}\n \t}\n \n \treturn NT_STATUS_NOT_SUPPORTED;\n }\n \n", "target": "// fix_start\n\t\t\t*out_len = 12 + labels_data_count;\n// fix_end\n// fix_start\n\t\tSIVAL(cur_pdata, 8, labels_data_count);\n// fix_end\n", "cwe": "CWE-665", "cwe_name": "Improper Initialization", "cve": "CVE-2014-0178", "cve_desc": "Samba 3.6.6 through 3.6.23, 4.0.x before 4.0.18, and 4.1.x before 4.1.8, when a certain vfs shadow copy configuration is enabled, does not properly initialize the SRV_SNAPSHOT_ARRAY response field, which allows remote authenticated users to obtain potentially sensitive information from process memory via a (1) FSCTL_GET_SHADOW_COPY_DATA or (2) FSCTL_SRV_ENUMERATE_SNAPSHOTS request.", "project": "samba", "idx": 200320}
{"source": " suggest_trie_walk(\n     suginfo_T\t*su,\n     langp_T\t*lp,\n     char_u\t*fword,\n     int\t\tsoundfold)\n {\n     char_u\ttword[MAXWLEN];\n     trystate_T\tstack[MAXWLEN];\n     char_u\tpreword[MAXWLEN * 3];\n     char_u\tcompflags[MAXWLEN];\n     trystate_T\t*sp;\n     int\t\tnewscore;\n     int\t\tscore;\n     char_u\t*byts, *fbyts, *pbyts;\n     idx_T\t*idxs, *fidxs, *pidxs;\n     int\t\tdepth;\n     int\t\tc, c2, c3;\n     int\t\tn = 0;\n     int\t\tflags;\n     garray_T\t*gap;\n     idx_T\tarridx;\n     int\t\tlen;\n     char_u\t*p;\n     fromto_T\t*ftp;\n     int\t\tfl = 0, tl;\n     int\t\trepextra = 0;\n     slang_T\t*slang = lp->lp_slang;\n     int\t\tfword_ends;\n     int\t\tgoodword_ends;\n #ifdef DEBUG_TRIEWALK\n     char_u\tchangename[MAXWLEN][80];\n #endif\n     int\t\tbreakcheckcount = 1000;\n #ifdef FEAT_RELTIME\n     proftime_T\ttime_limit;\n #endif\n     int\t\tcompound_ok;\n \n     depth = 0;\n     sp = &stack[0];\n     CLEAR_POINTER(sp);\n     sp->ts_curi = 1;\n \n     if (soundfold)\n     {\n \tbyts = fbyts = slang->sl_sbyts;\n \tidxs = fidxs = slang->sl_sidxs;\n \tpbyts = NULL;\n \tpidxs = NULL;\n \tsp->ts_prefixdepth = PFD_NOPREFIX;\n \tsp->ts_state = STATE_START;\n     }\n     else\n     {\n \tfbyts = slang->sl_fbyts;\n \tfidxs = slang->sl_fidxs;\n \tpbyts = slang->sl_pbyts;\n \tpidxs = slang->sl_pidxs;\n \tif (pbyts != NULL)\n \t{\n \t    byts = pbyts;\n \t    idxs = pidxs;\n \t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n \t    sp->ts_state = STATE_NOPREFIX;\n \t}\n \telse\n \t{\n \t    byts = fbyts;\n \t    idxs = fidxs;\n \t    sp->ts_prefixdepth = PFD_NOPREFIX;\n \t    sp->ts_state = STATE_START;\n \t}\n     }\n #ifdef FEAT_RELTIME\n     if (spell_suggest_timeout > 0)\n \tprofile_setlimit(spell_suggest_timeout, &time_limit);\n #endif\n \n     while (depth >= 0 && !got_int)\n     {\n \tsp = &stack[depth];\n \tswitch (sp->ts_state)\n \t{\n \tcase STATE_START:\n \tcase STATE_NOPREFIX:\n \t    arridx = sp->ts_arridx;\n \t    len = byts[arridx];\n \t    arridx += sp->ts_curi;\n \n \t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n \t    {\n \t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n \t\t    ;\n \t\tsp->ts_curi += n;\n \n \t\tn = (int)sp->ts_state;\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_ENDNUL;\n \t\tsp->ts_save_badflags = su->su_badflags;\n \n \t\tif (depth < MAXWLEN - 1\n \t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n \t\t{\n \t\t    if (has_mbyte)\n \t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n \t\t    else\n \t\t\tn = sp->ts_fidx;\n \t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n \t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n \t\t\t\t\t       su->su_badptr + su->su_badlen);\n #ifdef DEBUG_TRIEWALK\n \t\t    sprintf(changename[depth], \"prefix\");\n #endif\n \t\t    go_deeper(stack, depth, 0);\n \t\t    ++depth;\n \t\t    sp = &stack[depth];\n \t\t    sp->ts_prefixdepth = depth - 1;\n \t\t    byts = fbyts;\n \t\t    idxs = fidxs;\n \t\t    sp->ts_arridx = 0;\n \n \t\t    tword[sp->ts_twordlen] = NUL;\n \t\t    make_case_word(tword + sp->ts_splitoff,\n \t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n \t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n \t\t    sp->ts_splitoff = sp->ts_twordlen;\n \t\t}\n \t\tbreak;\n \t    }\n \n \t    if (sp->ts_curi > len || byts[arridx] != 0)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_ENDNUL;\n \t\tsp->ts_save_badflags = su->su_badflags;\n \t\tbreak;\n \t    }\n \n \t    ++sp->ts_curi;\n \n \t    flags = (int)idxs[arridx];\n \n \t    if (flags & WF_NOSUGGEST)\n \t\tbreak;\n \n \t    fword_ends = (fword[sp->ts_fidx] == NUL\n \t\t\t   || (soundfold\n \t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n \t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n \t    tword[sp->ts_twordlen] = NUL;\n \n \t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n \t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n \t\t\t\t\t&& pbyts != NULL)\n \t    {\n \t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n \t\tlen = pbyts[n++];\n \t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n \t\t    ;\n \t\tif (c > 0)\n \t\t{\n \t\t    c = valid_word_prefix(c, n, flags,\n \t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n \t\t    if (c == 0)\n \t\t\tbreak;\n \n \t\t    if (c & WF_RAREPFX)\n \t\t\tflags |= WF_RARE;\n \n \t\t    sp->ts_flags |= TSF_PREFIXOK;\n \t\t}\n \t    }\n \n \t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n \t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n \t\tgoodword_ends = FALSE;\n \t    else\n \t\tgoodword_ends = TRUE;\n \n \t    p = NULL;\n \t    compound_ok = TRUE;\n \t    if (sp->ts_complen > sp->ts_compsplit)\n \t    {\n \t\tif (slang->sl_nobreak)\n \t\t{\n \t\t    if (sp->ts_fidx - sp->ts_splitfidx\n \t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n \t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n \t\t\t\t\ttword + sp->ts_splitoff,\n \t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n \t\t    {\n \t\t\tpreword[sp->ts_prewordlen] = NUL;\n \t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n \t\t\t\t\t\t preword + sp->ts_prewordlen,\n \t\t\t\t\t\t sp->ts_prewordlen > 0);\n \t\t\tif (newscore <= su->su_maxscore)\n \t\t\t    add_suggestion(su, &su->su_ga, preword,\n \t\t\t\t    sp->ts_splitfidx - repextra,\n \t\t\t\t    newscore, 0, FALSE,\n \t\t\t\t    lp->lp_sallang, FALSE);\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \t\telse\n \t\t{\n \t\t    if (((unsigned)flags >> 24) == 0\n \t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n \t\t\t\t\t\t       < slang->sl_compminlen)\n \t\t\tbreak;\n \t\t    if (has_mbyte\n \t\t\t    && slang->sl_compminlen > 0\n \t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n \t\t\t\t\t\t       < slang->sl_compminlen)\n \t\t\tbreak;\n \n \t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n \t\t    compflags[sp->ts_complen + 1] = NUL;\n \t\t    vim_strncpy(preword + sp->ts_prewordlen,\n \t\t\t    tword + sp->ts_splitoff,\n \t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n \n \t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n \t\t\t\t\t\t\t  &slang->sl_comppat))\n \t\t\tcompound_ok = FALSE;\n \n \t\t    if (compound_ok)\n \t\t    {\n \t\t\tp = preword;\n \t\t\twhile (*skiptowhite(p) != NUL)\n \t\t\t    p = skipwhite(skiptowhite(p));\n \t\t\tif (fword_ends && !can_compound(slang, p,\n \t\t\t\t\t\tcompflags + sp->ts_compsplit))\n \t\t\t    compound_ok = FALSE;\n \t\t    }\n \n \t\t    p = preword + sp->ts_prewordlen;\n \t\t    MB_PTR_BACK(preword, p);\n \t\t}\n \t    }\n \n \t    if (soundfold)\n \t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n \t    else if (flags & WF_KEEPCAP)\n \t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n \t\t\t\t\t\t preword + sp->ts_prewordlen);\n \t    else\n \t    {\n \t\tc = su->su_badflags;\n \t\tif ((c & WF_ALLCAP)\n \t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n \t\t    c = WF_ONECAP;\n \t\tc |= flags;\n \n \t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n \t\t    c &= ~WF_ONECAP;\n \t\tmake_case_word(tword + sp->ts_splitoff,\n \t\t\t\t\t      preword + sp->ts_prewordlen, c);\n \t    }\n \n \t    if (!soundfold)\n \t    {\n \t\tif (flags & WF_BANNED)\n \t\t{\n \t\t    add_banned(su, preword + sp->ts_prewordlen);\n \t\t    break;\n \t\t}\n \t\tif ((sp->ts_complen == sp->ts_compsplit\n \t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n \t\t\t\t\t\t   || WAS_BANNED(su, preword))\n \t\t{\n \t\t    if (slang->sl_compprog == NULL)\n \t\t\tbreak;\n \t\t    goodword_ends = FALSE;\n \t\t}\n \t    }\n \n \t    newscore = 0;\n \t    if (!soundfold)\n \t    {\n \t\tif ((flags & WF_REGION)\n \t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n \t\t    newscore += SCORE_REGION;\n \t\tif (flags & WF_RARE)\n \t\t    newscore += SCORE_RARE;\n \n \t\tif (!spell_valid_case(su->su_badflags,\n \t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n \t\t    newscore += SCORE_ICASE;\n \t    }\n \n \t    if (fword_ends\n \t\t    && goodword_ends\n \t\t    && sp->ts_fidx >= sp->ts_fidxtry\n \t\t    && compound_ok)\n \t    {\n #ifdef DEBUG_TRIEWALK\n \t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n \t\t{\n \t\t    int\t    j;\n \n \t\t    smsg(\"------ %s -------\", fword);\n \t\t    for (j = 0; j < depth; ++j)\n \t\t\tsmsg(\"%s\", changename[j]);\n \t\t}\n #endif\n \t\tif (soundfold)\n \t\t{\n \t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n \t\t}\n \t\telse if (sp->ts_fidx > 0)\n \t\t{\n \t\t    p = fword + sp->ts_fidx;\n \t\t    MB_PTR_BACK(fword, p);\n \t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n \t\t    {\n \t\t\tp = preword + STRLEN(preword);\n \t\t\tMB_PTR_BACK(preword, p);\n \t\t\tif (spell_iswordp(p, curwin))\n \t\t\t    newscore += SCORE_NONWORD;\n \t\t    }\n \n \t\t    score = score_wordcount_adj(slang,\n \t\t\t\t\t\tsp->ts_score + newscore,\n \t\t\t\t\t\tpreword + sp->ts_prewordlen,\n \t\t\t\t\t\tsp->ts_prewordlen > 0);\n \n \t\t    if (score <= su->su_maxscore)\n \t\t    {\n \t\t\tadd_suggestion(su, &su->su_ga, preword,\n \t\t\t\t    sp->ts_fidx - repextra,\n \t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n \n \t\t\tif (su->su_badflags & WF_MIXCAP)\n \t\t\t{\n \t\t\t    c = captype(preword, NULL);\n \t\t\t    if (c == 0 || c == WF_ALLCAP)\n \t\t\t    {\n \t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n \t\t\t\t\t      preword + sp->ts_prewordlen,\n \t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n \n \t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n \t\t\t\t\tsp->ts_fidx - repextra,\n \t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n \t\t\t\t\tlp->lp_sallang, FALSE);\n \t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \n \t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n \t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n \t    {\n \t\tint\ttry_compound;\n \t\tint\ttry_split;\n \n \t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n \t\t\t\t\t\t\t\t&& !soundfold;\n \n \t\ttry_compound = FALSE;\n \t\tif (!soundfold\n \t\t\t&& !slang->sl_nocompoundsugs\n \t\t\t&& slang->sl_compprog != NULL\n \t\t\t&& ((unsigned)flags >> 24) != 0\n \t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n \t\t\t\t\t\t       >= slang->sl_compminlen\n \t\t\t&& (!has_mbyte\n \t\t\t    || slang->sl_compminlen == 0\n \t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n \t\t\t\t\t\t      >= slang->sl_compminlen)\n \t\t\t&& (slang->sl_compsylmax < MAXWLEN\n \t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n \t\t\t\t\t\t\t  < slang->sl_compmax)\n \t\t\t&& (can_be_compound(sp, slang,\n \t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n \n \t\t{\n \t\t    try_compound = TRUE;\n \t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n \t\t    compflags[sp->ts_complen + 1] = NUL;\n \t\t}\n \n \t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n \t\t    try_compound = TRUE;\n \n \t\telse if (!fword_ends\n \t\t\t&& try_compound\n \t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n \t\t{\n \t\t    try_compound = FALSE;\n \t\t    sp->ts_flags |= TSF_DIDSPLIT;\n \t\t    --sp->ts_curi;\n \t\t    compflags[sp->ts_complen] = NUL;\n \t\t}\n \t\telse\n \t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n \n \t\tif (try_split || try_compound)\n \t\t{\n \t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n \t\t    {\n \t\t\tif (sp->ts_complen == sp->ts_compsplit\n \t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n \t\t\t    break;\n \t\t\tp = preword;\n \t\t\twhile (*skiptowhite(p) != NUL)\n \t\t\t    p = skipwhite(skiptowhite(p));\n \t\t\tif (sp->ts_complen > sp->ts_compsplit\n \t\t\t\t&& !can_compound(slang, p,\n \t\t\t\t\t\tcompflags + sp->ts_compsplit))\n \t\t\t    break;\n \n \t\t\tif (slang->sl_nosplitsugs)\n \t\t\t    newscore += SCORE_SPLIT_NO;\n \t\t\telse\n \t\t\t    newscore += SCORE_SPLIT;\n \n \t\t\tnewscore = score_wordcount_adj(slang, newscore,\n \t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n \t\t    }\n \n \t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n \t\t    {\n \t\t\tgo_deeper(stack, depth, newscore);\n #ifdef DEBUG_TRIEWALK\n \t\t\tif (!try_compound && !fword_ends)\n \t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n \t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n \t\t\telse\n \t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n \t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n #endif\n \t\t\tsp->ts_save_badflags = su->su_badflags;\n \t\t\tPROF_STORE(sp->ts_state)\n \t\t\tsp->ts_state = STATE_SPLITUNDO;\n \n \t\t\t++depth;\n \t\t\tsp = &stack[depth];\n \n \t\t\tif (!try_compound && !fword_ends)\n \t\t\t    STRCAT(preword, \" \");\n \t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n \t\t\tsp->ts_splitoff = sp->ts_twordlen;\n \t\t\tsp->ts_splitfidx = sp->ts_fidx;\n \n \t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n \t\t\t\t\t\t\t       + sp->ts_fidx,\n \t\t\t\t\t\t\t       curwin))\n \t\t\t\t    || fword_ends)\n \t\t\t\t&& fword[sp->ts_fidx] != NUL\n \t\t\t\t&& goodword_ends)\n \t\t\t{\n \t\t\t    int\t    l;\n \n \t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n \t\t\t    if (fword_ends)\n \t\t\t    {\n \t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n \t\t\t\t\t\t      fword + sp->ts_fidx, l);\n \t\t\t\tsp->ts_prewordlen += l;\n \t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n \t\t\t    }\n \t\t\t    else\n \t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n \t\t\t    sp->ts_fidx += l;\n \t\t\t}\n \n \t\t\tif (try_compound)\n \t\t\t    ++sp->ts_complen;\n \t\t\telse\n \t\t\t    sp->ts_compsplit = sp->ts_complen;\n \t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n \n \t\t\tif (has_mbyte)\n \t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n \t\t\telse\n \t\t\t    n = sp->ts_fidx;\n \t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n \t\t\t\t\t       su->su_badptr + su->su_badlen);\n \n \t\t\tsp->ts_arridx = 0;\n \n \t\t\tif (pbyts != NULL)\n \t\t\t{\n \t\t\t    byts = pbyts;\n \t\t\t    idxs = pidxs;\n \t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n \t\t\t    PROF_STORE(sp->ts_state)\n \t\t\t    sp->ts_state = STATE_NOPREFIX;\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \t    break;\n \n \tcase STATE_SPLITUNDO:\n \t    su->su_badflags = sp->ts_save_badflags;\n \n \t    PROF_STORE(sp->ts_state)\n \t    sp->ts_state = STATE_START;\n \n \t    byts = fbyts;\n \t    idxs = fidxs;\n \t    break;\n \n \tcase STATE_ENDNUL:\n \t    su->su_badflags = sp->ts_save_badflags;\n \t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_DEL;\n \t\tbreak;\n \t    }\n \t    PROF_STORE(sp->ts_state)\n \t    sp->ts_state = STATE_PLAIN;\n \n \tcase STATE_PLAIN:\n \t    arridx = sp->ts_arridx;\n \t    if (sp->ts_curi > byts[arridx])\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n \t\t    sp->ts_state = STATE_DEL;\n \t\telse\n \t\t    sp->ts_state = STATE_FINAL;\n \t    }\n \t    else\n \t    {\n \t\tarridx += sp->ts_curi++;\n \t\tc = byts[arridx];\n \n \t\tif (c == fword[sp->ts_fidx]\n \t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n \t\t    newscore = 0;\n \t\telse\n \t\t    newscore = SCORE_SUBST;\n \t\tif ((newscore == 0\n \t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n \t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n \t\t\t\t    || c != fword[sp->ts_delidx])))\n \t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n \t\t{\n \t\t    go_deeper(stack, depth, newscore);\n #ifdef DEBUG_TRIEWALK\n \t\t    if (newscore > 0)\n \t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n \t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\t\tfword[sp->ts_fidx], c);\n \t\t    else\n \t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n \t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\t\tfword[sp->ts_fidx]);\n #endif\n \t\t    ++depth;\n \t\t    sp = &stack[depth];\n \t\t    if (fword[sp->ts_fidx] != NUL)\n \t\t\t++sp->ts_fidx;\n \t\t    tword[sp->ts_twordlen++] = c;\n \t\t    sp->ts_arridx = idxs[arridx];\n \t\t    if (newscore == SCORE_SUBST)\n \t\t\tsp->ts_isdiff = DIFF_YES;\n \t\t    if (has_mbyte)\n \t\t    {\n \t\t\tif (sp->ts_tcharlen == 0)\n \t\t\t{\n \t\t\t    sp->ts_tcharidx = 0;\n \t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n \t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n \t\t\t    sp->ts_isdiff = (newscore != 0)\n \t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n \t\t\t}\n// bug_start\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n// bug_end\n \t\t\t    --sp->ts_fidx;\n \t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n \t\t\t{\n \t\t\t    if (sp->ts_isdiff == DIFF_YES)\n \t\t\t    {\n \t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n \t\t\t\t\t    + mb_ptr2len(\n \t\t\t\t\t\t    fword + sp->ts_fcharstart);\n \t\t\t\tif (enc_utf8\n \t\t\t\t\t&& utf_iscomposing(\n \t\t\t\t\t    utf_ptr2char(tword\n \t\t\t\t\t\t+ sp->ts_twordlen\n \t\t\t\t\t\t\t   - sp->ts_tcharlen))\n \t\t\t\t\t&& utf_iscomposing(\n \t\t\t\t\t    utf_ptr2char(fword\n \t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n \t\t\t\t    sp->ts_score -=\n \t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n \n \t\t\t\telse if (!soundfold\n \t\t\t\t\t&& slang->sl_has_map\n \t\t\t\t\t&& similar_chars(slang,\n \t\t\t\t\t    mb_ptr2char(tword\n \t\t\t\t\t\t+ sp->ts_twordlen\n \t\t\t\t\t\t\t   - sp->ts_tcharlen),\n \t\t\t\t\t    mb_ptr2char(fword\n \t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n \t\t\t\t    sp->ts_score -=\n \t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n \t\t\t    }\n \t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n \t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n \t\t\t    {\n \t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n \t\t\t\tc = mb_ptr2char(p);\n \t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n \t\t\t\t{\n \t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t    MB_PTR_BACK(tword, p);\n \t\t\t\t    if (c == mb_ptr2char(p))\n \t\t\t\t\tsp->ts_score -= SCORE_INS\n \t\t\t\t\t\t\t       - SCORE_INSDUP;\n \t\t\t\t}\n \t\t\t    }\n \n \t\t\t    sp->ts_tcharlen = 0;\n \t\t\t}\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tif (newscore != 0\n \t\t\t\t&& !soundfold\n \t\t\t\t&& slang->sl_has_map\n \t\t\t\t&& similar_chars(slang,\n \t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n \t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n \t\t    }\n \t\t}\n \t    }\n \t    break;\n \n \tcase STATE_DEL:\n \t    if (has_mbyte && sp->ts_tcharlen > 0)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_FINAL;\n \t\tbreak;\n \t    }\n \t    PROF_STORE(sp->ts_state)\n \t    sp->ts_state = STATE_INS_PREP;\n \t    sp->ts_curi = 1;\n \t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n \t\tnewscore = 2 * SCORE_DEL / 3;\n \t    else\n \t\tnewscore = SCORE_DEL;\n \t    if (fword[sp->ts_fidx] != NUL\n \t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n \t    {\n \t\tgo_deeper(stack, depth, newscore);\n #ifdef DEBUG_TRIEWALK\n \t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n \t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\tfword[sp->ts_fidx]);\n #endif\n \t\t++depth;\n \n \t\tstack[depth].ts_flags |= TSF_DIDDEL;\n \t\tstack[depth].ts_delidx = sp->ts_fidx;\n \n \t\tif (has_mbyte)\n \t\t{\n \t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n \t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n \t\t    if (enc_utf8 && utf_iscomposing(c))\n \t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n \t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n \t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n \t\t}\n \t\telse\n \t\t{\n \t\t    ++stack[depth].ts_fidx;\n \t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n \t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n \t\t}\n \t\tbreak;\n \t    }\n \n \tcase STATE_INS_PREP:\n \t    if (sp->ts_flags & TSF_DIDDEL)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_SWAP;\n \t\tbreak;\n \t    }\n \n \t    n = sp->ts_arridx;\n \t    for (;;)\n \t    {\n \t\tif (sp->ts_curi > byts[n])\n \t\t{\n \t\t    PROF_STORE(sp->ts_state)\n \t\t    sp->ts_state = STATE_SWAP;\n \t\t    break;\n \t\t}\n \t\tif (byts[n + sp->ts_curi] != NUL)\n \t\t{\n \t\t    PROF_STORE(sp->ts_state)\n \t\t    sp->ts_state = STATE_INS;\n \t\t    break;\n \t\t}\n \t\t++sp->ts_curi;\n \t    }\n \t    break;\n \n \n \tcase STATE_INS:\n \t    n = sp->ts_arridx;\n \t    if (sp->ts_curi > byts[n])\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_SWAP;\n \t\tbreak;\n \t    }\n \n \t    n += sp->ts_curi++;\n \t    c = byts[n];\n \t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n \t\tnewscore = 2 * SCORE_INS / 3;\n \t    else\n \t\tnewscore = SCORE_INS;\n \t    if (c != fword[sp->ts_fidx]\n \t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n \t    {\n \t\tgo_deeper(stack, depth, newscore);\n #ifdef DEBUG_TRIEWALK\n \t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n \t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\tc);\n #endif\n \t\t++depth;\n \t\tsp = &stack[depth];\n \t\ttword[sp->ts_twordlen++] = c;\n \t\tsp->ts_arridx = idxs[n];\n \t\tif (has_mbyte)\n \t\t{\n \t\t    fl = MB_BYTE2LEN(c);\n \t\t    if (fl > 1)\n \t\t    {\n \t\t\tsp->ts_tcharlen = fl;\n \t\t\tsp->ts_tcharidx = 1;\n \t\t\tsp->ts_isdiff = DIFF_INSERT;\n \t\t    }\n \t\t}\n \t\telse\n \t\t    fl = 1;\n \t\tif (fl == 1)\n \t\t{\n \t\t    if (sp->ts_twordlen >= 2\n \t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n \t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n \t\t}\n \t    }\n \t    break;\n \n \tcase STATE_SWAP:\n \t    p = fword + sp->ts_fidx;\n \t    c = *p;\n \t    if (c == NUL)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_FINAL;\n \t\tbreak;\n \t    }\n \n \t    if (!soundfold && !spell_iswordp(p, curwin))\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t\tbreak;\n \t    }\n \n \t    if (has_mbyte)\n \t    {\n \t\tn = MB_CPTR2LEN(p);\n \t\tc = mb_ptr2char(p);\n \t\tif (p[n] == NUL)\n \t\t    c2 = NUL;\n \t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n \t\t    c2 = c;\n \t\telse\n \t\t    c2 = mb_ptr2char(p + n);\n \t    }\n \t    else\n \t    {\n \t\tif (p[1] == NUL)\n \t\t    c2 = NUL;\n \t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n \t\t    c2 = c;\n \t\telse\n \t\t    c2 = p[1];\n \t    }\n \n \t    if (c2 == NUL)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t\tbreak;\n \t    }\n \n \t    if (c == c2)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_SWAP3;\n \t\tbreak;\n \t    }\n \t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n \t    {\n \t\tgo_deeper(stack, depth, SCORE_SWAP);\n #ifdef DEBUG_TRIEWALK\n \t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n \t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\tc, c2);\n #endif\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_UNSWAP;\n \t\t++depth;\n \t\tif (has_mbyte)\n \t\t{\n \t\t    fl = mb_char2len(c2);\n \t\t    mch_memmove(p, p + n, fl);\n \t\t    mb_char2bytes(c, p + fl);\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n \t\t}\n \t\telse\n \t\t{\n \t\t    p[0] = c2;\n \t\t    p[1] = c;\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n \t\t}\n \t    }\n \t    else\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t    }\n \t    break;\n \n \tcase STATE_UNSWAP:\n \t    p = fword + sp->ts_fidx;\n \t    if (has_mbyte)\n \t    {\n \t\tn = mb_ptr2len(p);\n \t\tc = mb_ptr2char(p + n);\n \t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n \t\tmb_char2bytes(c, p);\n \t    }\n \t    else\n \t    {\n \t\tc = *p;\n \t\t*p = p[1];\n \t\tp[1] = c;\n \t    }\n \n \tcase STATE_SWAP3:\n \t    p = fword + sp->ts_fidx;\n \t    if (has_mbyte)\n \t    {\n \t\tn = MB_CPTR2LEN(p);\n \t\tc = mb_ptr2char(p);\n \t\tfl = MB_CPTR2LEN(p + n);\n \t\tc2 = mb_ptr2char(p + n);\n \t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n \t\t    c3 = c;\n \t\telse\n \t\t    c3 = mb_ptr2char(p + n + fl);\n \t    }\n \t    else\n \t    {\n \t\tc = *p;\n \t\tc2 = p[1];\n \t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n \t\t    c3 = c;\n \t\telse\n \t\t    c3 = p[2];\n \t    }\n \n \t    if (c == c3 || c3 == NUL)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t\tbreak;\n \t    }\n \t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n \t    {\n \t\tgo_deeper(stack, depth, SCORE_SWAP3);\n #ifdef DEBUG_TRIEWALK\n \t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n \t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\tc, c3);\n #endif\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_UNSWAP3;\n \t\t++depth;\n \t\tif (has_mbyte)\n \t\t{\n \t\t    tl = mb_char2len(c3);\n \t\t    mch_memmove(p, p + n + fl, tl);\n \t\t    mb_char2bytes(c2, p + tl);\n \t\t    mb_char2bytes(c, p + fl + tl);\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n \t\t}\n \t\telse\n \t\t{\n \t\t    p[0] = p[2];\n \t\t    p[2] = c;\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n \t\t}\n \t    }\n \t    else\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t    }\n \t    break;\n \n \tcase STATE_UNSWAP3:\n \t    p = fword + sp->ts_fidx;\n \t    if (has_mbyte)\n \t    {\n \t\tn = mb_ptr2len(p);\n \t\tc2 = mb_ptr2char(p + n);\n \t\tfl = mb_ptr2len(p + n);\n \t\tc = mb_ptr2char(p + n + fl);\n \t\ttl = mb_ptr2len(p + n + fl);\n \t\tmch_memmove(p + fl + tl, p, n);\n \t\tmb_char2bytes(c, p);\n \t\tmb_char2bytes(c2, p + tl);\n \t\tp = p + tl;\n \t    }\n \t    else\n \t    {\n \t\tc = *p;\n \t\t*p = p[2];\n \t\tp[2] = c;\n \t\t++p;\n \t    }\n \n \t    if (!soundfold && !spell_iswordp(p, curwin))\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t\tbreak;\n \t    }\n \n \t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n \t    {\n \t\tgo_deeper(stack, depth, SCORE_SWAP3);\n #ifdef DEBUG_TRIEWALK\n \t\tp = fword + sp->ts_fidx;\n \t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n \t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\tp[0], p[1], p[2]);\n #endif\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_UNROT3L;\n \t\t++depth;\n \t\tp = fword + sp->ts_fidx;\n \t\tif (has_mbyte)\n \t\t{\n \t\t    n = MB_CPTR2LEN(p);\n \t\t    c = mb_ptr2char(p);\n \t\t    fl = MB_CPTR2LEN(p + n);\n \t\t    fl += MB_CPTR2LEN(p + n + fl);\n \t\t    mch_memmove(p, p + n, fl);\n \t\t    mb_char2bytes(c, p + fl);\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n \t\t}\n \t\telse\n \t\t{\n \t\t    c = *p;\n \t\t    *p = p[1];\n \t\t    p[1] = p[2];\n \t\t    p[2] = c;\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n \t\t}\n \t    }\n \t    else\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t    }\n \t    break;\n \n \tcase STATE_UNROT3L:\n \t    p = fword + sp->ts_fidx;\n \t    if (has_mbyte)\n \t    {\n \t\tn = mb_ptr2len(p);\n \t\tn += mb_ptr2len(p + n);\n \t\tc = mb_ptr2char(p + n);\n \t\ttl = mb_ptr2len(p + n);\n \t\tmch_memmove(p + tl, p, n);\n \t\tmb_char2bytes(c, p);\n \t    }\n \t    else\n \t    {\n \t\tc = p[2];\n \t\tp[2] = p[1];\n \t\tp[1] = *p;\n \t\t*p = c;\n \t    }\n \n \t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n \t    {\n \t\tgo_deeper(stack, depth, SCORE_SWAP3);\n #ifdef DEBUG_TRIEWALK\n \t\tp = fword + sp->ts_fidx;\n \t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n \t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\tp[0], p[1], p[2]);\n #endif\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_UNROT3R;\n \t\t++depth;\n \t\tp = fword + sp->ts_fidx;\n \t\tif (has_mbyte)\n \t\t{\n \t\t    n = MB_CPTR2LEN(p);\n \t\t    n += MB_CPTR2LEN(p + n);\n \t\t    c = mb_ptr2char(p + n);\n \t\t    tl = MB_CPTR2LEN(p + n);\n \t\t    mch_memmove(p + tl, p, n);\n \t\t    mb_char2bytes(c, p);\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n \t\t}\n \t\telse\n \t\t{\n \t\t    c = p[2];\n \t\t    p[2] = p[1];\n \t\t    p[1] = *p;\n \t\t    *p = c;\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n \t\t}\n \t    }\n \t    else\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_REP_INI;\n \t    }\n \t    break;\n \n \tcase STATE_UNROT3R:\n \t    p = fword + sp->ts_fidx;\n \t    if (has_mbyte)\n \t    {\n \t\tc = mb_ptr2char(p);\n \t\ttl = mb_ptr2len(p);\n \t\tn = mb_ptr2len(p + tl);\n \t\tn += mb_ptr2len(p + tl + n);\n \t\tmch_memmove(p, p + tl, n);\n \t\tmb_char2bytes(c, p + n);\n \t    }\n \t    else\n \t    {\n \t\tc = *p;\n \t\t*p = p[1];\n \t\tp[1] = p[2];\n \t\tp[2] = c;\n \t    }\n \n \tcase STATE_REP_INI:\n \t    if ((lp->lp_replang == NULL && !soundfold)\n \t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n \t\t    || sp->ts_fidx < sp->ts_fidxtry)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_FINAL;\n \t\tbreak;\n \t    }\n \n \t    if (soundfold)\n \t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n \t    else\n \t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n \n \t    if (sp->ts_curi < 0)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_FINAL;\n \t\tbreak;\n \t    }\n \n \t    PROF_STORE(sp->ts_state)\n \t    sp->ts_state = STATE_REP;\n \n \tcase STATE_REP:\n \t    p = fword + sp->ts_fidx;\n \n \t    if (soundfold)\n \t\tgap = &slang->sl_repsal;\n \t    else\n \t\tgap = &lp->lp_replang->sl_rep;\n \t    while (sp->ts_curi < gap->ga_len)\n \t    {\n \t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n \t\tif (*ftp->ft_from != *p)\n \t\t{\n \t\t    sp->ts_curi = gap->ga_len;\n \t\t    break;\n \t\t}\n \t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n \t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n \t\t{\n \t\t    go_deeper(stack, depth, SCORE_REP);\n #ifdef DEBUG_TRIEWALK\n \t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n \t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n \t\t\t    ftp->ft_from, ftp->ft_to);\n #endif\n \t\t    PROF_STORE(sp->ts_state)\n \t\t    sp->ts_state = STATE_REP_UNDO;\n \n \t\t    ++depth;\n \t\t    fl = (int)STRLEN(ftp->ft_from);\n \t\t    tl = (int)STRLEN(ftp->ft_to);\n \t\t    if (fl != tl)\n \t\t    {\n \t\t\tSTRMOVE(p + tl, p + fl);\n \t\t\trepextra += tl - fl;\n \t\t    }\n \t\t    mch_memmove(p, ftp->ft_to, tl);\n \t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n \t\t    stack[depth].ts_tcharlen = 0;\n \t\t    break;\n \t\t}\n \t    }\n \n \t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n \t    {\n \t\tPROF_STORE(sp->ts_state)\n \t\tsp->ts_state = STATE_FINAL;\n \t    }\n \n \t    break;\n \n \tcase STATE_REP_UNDO:\n \t    if (soundfold)\n \t\tgap = &slang->sl_repsal;\n \t    else\n \t\tgap = &lp->lp_replang->sl_rep;\n \t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n \t    fl = (int)STRLEN(ftp->ft_from);\n \t    tl = (int)STRLEN(ftp->ft_to);\n \t    p = fword + sp->ts_fidx;\n \t    if (fl != tl)\n \t    {\n \t\tSTRMOVE(p + fl, p + tl);\n \t\trepextra -= tl - fl;\n \t    }\n \t    mch_memmove(p, ftp->ft_from, fl);\n \t    PROF_STORE(sp->ts_state)\n \t    sp->ts_state = STATE_REP;\n \t    break;\n \n \tdefault:\n \t    --depth;\n \n \t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n \t    {\n \t\tbyts = pbyts;\n \t\tidxs = pidxs;\n \t    }\n \n \t    if (--breakcheckcount == 0)\n \t    {\n \t\tui_breakcheck();\n \t\tbreakcheckcount = 1000;\n #ifdef FEAT_RELTIME\n \t\tif (spell_suggest_timeout > 0\n \t\t\t\t\t  && profile_passed_limit(&time_limit))\n \t\t    got_int = TRUE;\n #endif\n \t    }\n \t}\n     }\n }\n \n", "target": "// fix_start\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t\t\t    && sp->ts_fidx > 0)\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2126", "cve_desc": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 200323}
{"source": " RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n \tint i;\n// bug_start\n\tif (!bin) {\n// bug_end\n \t\treturn NULL;\n \t}\n \tRList *segments = r_list_newf (free);\n \tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n \t\tRBinSection *bs = R_NEW0 (RBinSection);\n \t\tif (!bs) {\n \t\t\treturn segments;\n \t\t}\n \t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n \t\tbs->size = se->length;\n \t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n \t\tbs->bits = R_SYS_BITS_16;\n \t\tbs->is_data = se->flags & IS_DATA;\n \t\tbs->perm = __translate_perms (se->flags);\n \t\tbs->paddr = (ut64)se->offset * bin->alignment;\n \t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n \t\tbs->is_segment = true;\n \t\tr_list_append (segments, bs);\n \t}\n \tbin->segments = segments;\n \treturn segments;\n }\n \n", "target": "// fix_start\n\tif (!bin || !bin->segment_entries) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-1382", "cve_desc": "NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of making the radare2 crash, thus affecting the availability of the system.", "project": "radare2", "idx": 200379}
{"source": " static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n \t\t\t\t  struct dma_buf_attachment *attachment)\n {\n \tstruct fastrpc_dma_buf_attachment *a;\n \tstruct fastrpc_buf *buffer = dmabuf->priv;\n \tint ret;\n \n \ta = kzalloc(sizeof(*a), GFP_KERNEL);\n \tif (!a)\n \t\treturn -ENOMEM;\n \n \tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n \t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n \tif (ret < 0) {\n \t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n// bug_start\n// bug_end\n \t\treturn -EINVAL;\n \t}\n \n \ta->dev = attachment->dev;\n \tINIT_LIST_HEAD(&a->node);\n \tattachment->priv = a;\n \n \tmutex_lock(&buffer->lock);\n \tlist_add(&a->node, &buffer->attachments);\n \tmutex_unlock(&buffer->lock);\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tkfree(a);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19069", "cve_desc": "A memory leak in the fastrpc_dma_buf_attach() function in drivers/misc/fastrpc.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering dma_get_sgtable() failures, aka CID-fc739a058d99.", "project": "linux", "idx": 200695}
{"source": " cvtchar(register const char *sp)\n {\n     unsigned char c = 0;\n     int len;\n \n     switch (*sp) {\n     case '\\\\':\n \tswitch (*++sp) {\n \tcase '\\'':\n \tcase '$':\n \tcase '\\\\':\n \tcase '%':\n \t    c = UChar(*sp);\n \t    len = 2;\n \t    break;\n \tcase '\\0':\n \t    c = '\\\\';\n \t    len = 1;\n \t    break;\n \tcase '0':\n \tcase '1':\n \tcase '2':\n \tcase '3':\n \t    len = 1;\n \t    while (isdigit(UChar(*sp))) {\n \t\tc = UChar(8 * c + (*sp++ - '0'));\n \t\tlen++;\n \t    }\n \t    break;\n \tdefault:\n \t    c = UChar(*sp);\n \t    len = (c != '\\0') ? 2 : 1;\n \t    break;\n \t}\n \tbreak;\n     case '^':\n// bug_start\n// bug_end\n \tc = UChar(*++sp);\n// bug_start\n\tif (c == '?')\n// bug_end\n \t    c = 127;\n// bug_start\n\telse\n// bug_end\n \t    c &= 0x1f;\n// bug_start\n\tlen = 2;\n// bug_end\n \tbreak;\n     default:\n \tc = UChar(*sp);\n \tlen = (c != '\\0') ? 1 : 0;\n     }\n     if (isgraph(c) && c != ',' && c != '\\'' && c != '\\\\' && c != ':') {\n \tdp = save_string(dp, \"%\\'\");\n \tdp = save_char(dp, c);\n \tdp = save_char(dp, '\\'');\n     } else if (c != '\\0') {\n \tdp = save_string(dp, \"%{\");\n \tif (c > 99)\n \t    dp = save_char(dp, c / 100 + '0');\n \tif (c > 9)\n \t    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');\n \tdp = save_char(dp, c % 10 + '0');\n \tdp = save_char(dp, '}');\n     }\n     return len;\n }\n \n", "target": "// fix_start\n\tlen = 2;\n// fix_end\n// fix_start\n\tif (c == '?') {\n// fix_end\n// fix_start\n\t} else if (c == '\\0') {\n\t    len = 1;\n\t} else {\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-39537", "cve_desc": "An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.", "project": "ncurses", "idx": 200781}
{"source": " call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n {\n     callback_T\t*cb = &qftf_cb;\n     list_T\t*qftf_list = NULL;\n// bug_start\n// bug_end\n \n     if (qfl->qf_qftf_cb.cb_name != NULL)\n \tcb = &qfl->qf_qftf_cb;\n     if (cb->cb_name != NULL)\n     {\n \ttypval_T\targs[1];\n \tdict_T\t\t*d;\n \ttypval_T\trettv;\n \n \tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n// bug_start\n// bug_end\n \t    return NULL;\n// bug_start\n// bug_end\n \tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n \tdict_add_number(d, \"winid\", (long)qf_winid);\n \tdict_add_number(d, \"id\", (long)qfl->qf_id);\n \tdict_add_number(d, \"start_idx\", start_idx);\n \tdict_add_number(d, \"end_idx\", end_idx);\n \t++d->dv_refcount;\n \targs[0].v_type = VAR_DICT;\n \targs[0].vval.v_dict = d;\n \n \tqftf_list = NULL;\n \tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n \t{\n \t    if (rettv.v_type == VAR_LIST)\n \t    {\n \t\tqftf_list = rettv.vval.v_list;\n \t\tqftf_list->lv_refcount++;\n \t    }\n \t    clear_tv(&rettv);\n \t}\n \tdict_unref(d);\n     }\n \n// bug_start\n// bug_end\n     return qftf_list;\n }\n \n", "target": "// fix_start\n    static int\trecursive = FALSE;\n\n    if (recursive)\n\treturn NULL;\n    recursive = TRUE;\n// fix_end\n// fix_start\n\t{\n\t    recursive = FALSE;\n// fix_end\n// fix_start\n\t}\n// fix_end\n// fix_start\n    recursive = FALSE;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-2982", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0260.", "project": "vim", "idx": 200895}
{"source": " testBackingParse(const void *args)\n {\n     const struct testBackingParseData *data = args;\n     g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n     g_autofree char *xml = NULL;\n     g_autoptr(virStorageSource) src = NULL;\n     int rc;\n     int erc = data->rv;\n// bug_start\n// bug_end\n \n     if (!data->expect)\n         erc = -1;\n \n     if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n         fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n         return -1;\n     }\n \n     if (!src)\n         return 0;\n \n     if (src && !data->expect) {\n         fprintf(stderr, \"parsing of backing store string '%s' should \"\n                         \"have failed\\n\", data->backing);\n         return -1;\n     }\n \n// bug_start\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, 0, true, NULL) < 0 ||\n// bug_end\n         !(xml = virBufferContentAndReset(&buf))) {\n         fprintf(stderr, \"failed to format disk source xml\\n\");\n         return -1;\n     }\n \n     if (STRNEQ(xml, data->expect)) {\n         fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                         \"expected storage source xml:\\n%s\\n\"\n                         \"actual storage source xml:\\n%s\\n\",\n                         data->backing, data->expect, xml);\n         return -1;\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n    unsigned int xmlformatflags = VIR_DOMAIN_DEF_FORMAT_SECURE;\n// fix_end\n// fix_start\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, xmlformatflags, true, NULL) < 0 ||\n// fix_end\n", "cwe": "CWE-212", "cwe_name": "Improper Cross-boundary Removal of Sensitive Data", "cve": "CVE-2020-14301", "cve_desc": "An information disclosure vulnerability was found in libvirt in versions before 6.3.0. HTTP cookies used to access network-based disks were saved in the XML dump of the guest domain. This flaw allows an attacker to access potentially sensitive information in the domain configuration via the `dumpxml` command.", "project": "libvirt", "idx": 200934}
{"source": " get_visual_text(\n     cmdarg_T\t*cap,\n     char_u\t**pp,\n     int\t\t*lenp)\n {\n     if (VIsual_mode != 'V')\n \tunadjust_for_sel();\n     if (VIsual.lnum != curwin->w_cursor.lnum)\n     {\n \tif (cap != NULL)\n \t    clearopbeep(cap->oap);\n \treturn FAIL;\n     }\n     if (VIsual_mode == 'V')\n     {\n \t*pp = ml_get_curline();\n \t*lenp = (int)STRLEN(*pp);\n     }\n     else\n     {\n \tif (LT_POS(curwin->w_cursor, VIsual))\n \t{\n \t    *pp = ml_get_pos(&curwin->w_cursor);\n \t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n \t}\n \telse\n \t{\n \t    *pp = ml_get_pos(&VIsual);\n \t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n \t}\n \tif (**pp == NUL)\n \t    *lenp = 0;\n// bug_start\n\tif (has_mbyte && *lenp > 0)\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n// bug_end\n     }\n     reset_VIsual_and_resel();\n     return OK;\n }\n \n", "target": "// fix_start\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t*lenp -= 1;\n\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-1720", "cve_desc": "Buffer Over-read in function grab_file_name in GitHub repository vim/vim prior to 8.2.4956. This vulnerability is capable of crashing the software, memory modification, and possible remote execution.", "project": "vim", "idx": 200976}
{"source": " static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n {\n     char *p = buf;\n     char *end = buf+len;\n     unsigned i;\n     int printed;\n \n     if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n \treturn -1;\n     }\n     *p++ = 'm';\n     *p++ = '=';\n     pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n     p += m->desc.media.slen;\n     *p++ = ' ';\n     printed = pj_utoa(m->desc.port, p);\n     p += printed;\n     if (m->desc.port_count > 1) {\n \t*p++ = '/';\n \tprinted = pj_utoa(m->desc.port_count, p);\n \tp += printed;\n     }\n     *p++ = ' ';\n     pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n     p += m->desc.transport.slen;\n     for (i=0; i<m->desc.fmt_count; ++i) {\n// bug_start\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n// bug_end\n     }\n// bug_start\n    *p++ = '\\r';\n    *p++ = '\\n';\n// bug_end\n \n     if (m->conn) {\n \tprinted = print_connection_info(m->conn, p, (int)(end-p));\n \tif (printed < 0) {\n \t    return -1;\n \t}\n \tp += printed;\n     }\n \n     for (i=0; i<m->bandw_count; ++i) {\n \tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n \tif (printed < 0) {\n \t    return -1;\n \t}\n \tp += printed;\n     }\n \n     for (i=0; i<m->attr_count; ++i) {\n \tprinted = (int)print_attr(m->attr[i], p, end-p);\n \tif (printed < 0) {\n \t    return -1;\n \t}\n \tp += printed;\n     }\n \n     return (int)(p-buf);\n }\n \n", "target": "// fix_start\n\tif (end-p > m->desc.fmt[i].slen) {\n\t    *p++ = ' ';\n\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\t    p += m->desc.fmt[i].slen;\n\t} else {\n\t    return -1;\n\t}\n// fix_end\n// fix_start\n\n    if (end-p >= 2) {\n\t*p++ = '\\r';\n\t*p++ = '\\n';\n    } else {\n\treturn -1;\n    }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-24764", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`. Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()` or `pjmedia_sdp_media_print()` should not be affected. A patch is available on the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.", "project": "pjproject", "idx": 201007}
{"source": " static int selinux_ptrace_traceme(struct task_struct *parent)\n {\n \treturn avc_has_perm(&selinux_state,\n// bug_start\n\t\t\t    task_sid_subj(parent), task_sid_obj(current),\n// bug_end\n \t\t\t    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n }\n \n", "target": "// fix_start\n\t\t\t    task_sid_obj(parent), task_sid_obj(current),\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-43057", "cve_desc": "An issue was discovered in the Linux kernel before 5.14.8. A use-after-free in selinux_ptrace_traceme (aka the SELinux handler for PTRACE_TRACEME) could be used by local attackers to cause memory corruption and escalate privileges, aka CID-a3727a8bac0a. This occurs because of an attempt to access the subjective credentials of another task.", "project": "linux", "idx": 201343}
{"source": " static int rsi_init_usb_interface(struct rsi_hw *adapter,\n \t\t\t\t  struct usb_interface *pfunction)\n {\n \tstruct rsi_91x_usbdev *rsi_dev;\n \tint status;\n \n \trsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);\n \tif (!rsi_dev)\n \t\treturn -ENOMEM;\n \n \tadapter->rsi_dev = rsi_dev;\n \trsi_dev->usbdev = interface_to_usbdev(pfunction);\n \trsi_dev->priv = (void *)adapter;\n \n \tif (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter)) {\n \t\tstatus = -EINVAL;\n \t\tgoto fail_eps;\n \t}\n \n \tadapter->device = &pfunction->dev;\n \tusb_set_intfdata(pfunction, adapter);\n \n \trsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);\n \tif (!rsi_dev->tx_buffer) {\n \t\tstatus = -ENOMEM;\n \t\tgoto fail_eps;\n \t}\n \n \tif (rsi_usb_init_rx(adapter)) {\n \t\trsi_dbg(ERR_ZONE, \"Failed to init RX handle\\n\");\n \t\tstatus = -ENOMEM;\n \t\tgoto fail_rx;\n \t}\n \n \trsi_dev->tx_blk_size = 252;\n \tadapter->block_size = rsi_dev->tx_blk_size;\n \n \tadapter->check_hw_queue_status = rsi_usb_check_queue_status;\n \tadapter->determine_event_timeout = rsi_usb_event_timeout;\n \tadapter->rsi_host_intf = RSI_HOST_INTF_USB;\n \tadapter->host_intf_ops = &usb_host_intf_ops;\n \n #ifdef CONFIG_RSI_DEBUGFS\n \tadapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);\n #endif\n \n \trsi_dbg(INIT_ZONE, \"%s: Enabled the interface\\n\", __func__);\n \treturn 0;\n \n fail_rx:\n \tkfree(rsi_dev->tx_buffer);\n \n fail_eps:\n// bug_start\n\tkfree(rsi_dev);\n// bug_end\n \n \treturn status;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2019-15504", "cve_desc": "drivers/net/wireless/rsi/rsi_91x_usb.c in the Linux kernel through 5.2.9 has a Double Free via crafted USB device traffic (which may be remote via usbip or usbredir).", "project": "wireless-drivers", "idx": 201353}
{"source": " drill_parse_T_code(gerb_file_t *fd, drill_state_t *state,\n \t\t\tgerbv_image_t *image, ssize_t file_line)\n {\n     int tool_num;\n     gboolean done = FALSE;\n     int temp;\n     double size;\n     gerbv_drill_stats_t *stats = image->drill_stats;\n     gerbv_aperture_t *apert;\n     gchar *tmps;\n     gchar *string;\n \n     dprintf(\"---> entering %s()...\\n\", __FUNCTION__);\n \n     temp = gerb_fgetc(fd);\n     dprintf(\"  Found a char '%s' (0x%02x) after the T\\n\",\n \t    gerbv_escape_char(temp), temp);\n \n     if((temp == 'C') && ((fd->ptr + 2) < fd->datalen)){\n     \tif(gerb_fgetc(fd) == 'S'){\n     \t    if (gerb_fgetc(fd) == 'T' ){\n     \t  \tfd->ptr -= 4;\n     \t  \ttmps = get_line(fd++);\n     \t  \tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_NOTE, -1,\n \t\t\t_(\"Tool change stop switch found \\\"%s\\\" \"\n \t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n \t\t\ttmps, file_line, fd->filename);\n \t  \tg_free (tmps);\n \n \t  \treturn -1;\n \t    }\n \t    gerb_ungetc(fd);\n \t}\n \tgerb_ungetc(fd);\n     }\n \n     if( !(isdigit(temp) != 0 || temp == '+' || temp =='-') ) {\n \tif(temp != EOF) {\n \t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n \t\t   _(\"OrCAD bug: Junk text found in place of tool definition\"));\n \t    tmps = get_line(fd);\n \t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n \t\t    _(\"Junk text \\\"%s\\\" \"\n \t\t\t\"at line %ld in file \\\"%s\\\"\"),\n \t\t    tmps, file_line, fd->filename);\n \t    g_free (tmps);\n \t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n \t\t\t\t  _(\"Ignoring junk text\"));\n \t}\n \treturn -1;\n     }\n     gerb_ungetc(fd);\n \n     tool_num = (int) gerb_fgetint(fd, NULL);\n     dprintf (\"  Handling tool T%d at line %ld\\n\", tool_num, file_line);\n \n     if (tool_num == 0)\n \treturn tool_num;\n \n     if (tool_num < TOOL_MIN || tool_num >= TOOL_MAX) {\n \tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n \t\t_(\"Out of bounds drill number %d \"\n \t\t    \"at line %ld in file \\\"%s\\\"\"),\n \t\ttool_num, file_line, fd->filename);\n// bug_start\n// bug_end\n     }\n \n     state->current_tool = tool_num;\n     apert = image->aperture[tool_num];\n \n     temp = gerb_fgetc(fd);\n \n     while (!done) {\n \tswitch((char)temp) {\n \tcase 'C':\n \t    size = read_double(fd, state->header_number_format, GERBV_OMIT_ZEROS_TRAILING, state->decimals);\n \t    dprintf (\"  Read a size of %g\\n\", size);\n \n \t    if (state->unit == GERBV_UNIT_MM) {\n \t\tsize /= 25.4;\n \t    } else if(size >= 4.0) {\n \n \t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n \t\t\t_(\"Read a drill of diameter %g inches \"\n \t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n \t\t\t    size, file_line, fd->filename);\n \t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n \t\t\t_(\"Assuming units are mils\"));\n \t\tsize /= 1000.0;\n \t    }\n \n \t    if (size <= 0. || size >= 10000.) {\n \t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n \t\t\t_(\"Unreasonable drill size %g found for drill %d \"\n \t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n \t\t\t    size, tool_num, file_line, fd->filename);\n \t    } else {\n \t\tif (apert != NULL) {\n \t\t    if (apert->parameter[0] != size\n \t\t    ||  apert->type != GERBV_APTYPE_CIRCLE\n \t\t    ||  apert->nuf_parameters != 1\n \t\t    ||  apert->unit != GERBV_UNIT_INCH) {\n \n \t\t\tgerbv_stats_printf(stats->error_list,\n \t\t\t\tGERBV_MESSAGE_ERROR, -1,\n \t\t\t\t_(\"Found redefinition of drill %d \"\n \t\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n \t\t\t\ttool_num, file_line, fd->filename);\n \t\t    }\n \t\t} else {\n \t\t    apert = image->aperture[tool_num] =\n \t\t\t\t\t\tg_new0(gerbv_aperture_t, 1);\n \t\t    if (apert == NULL)\n \t\t\tGERB_FATAL_ERROR(\"malloc tool failed in %s()\",\n \t\t\t\t\t__FUNCTION__);\n \n \t\t    apert->parameter[0] = size;\n \t\t    apert->type = GERBV_APTYPE_CIRCLE;\n \t\t    apert->nuf_parameters = 1;\n \t\t    apert->unit = GERBV_UNIT_INCH;\n \t\t}\n \t    }\n \n \t    stats = image->drill_stats;\n \t    string = g_strdup_printf(\"%s\", (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n \t    drill_stats_add_to_drill_list(stats->drill_list,\n \t\t\t\t\t  tool_num,\n \t\t\t\t\t  state->unit == GERBV_UNIT_MM ? size*25.4 : size,\n \t\t\t\t\t  string);\n \t    g_free(string);\n \t    break;\n \n \tcase 'F':\n \tcase 'S' :\n \t    gerb_fgetint(fd, NULL);\n \t    break;\n \n \tdefault:\n \t    gerb_ungetc(fd);\n \t    done = TRUE;\n \t    break;\n \t}\n \n \ttemp = gerb_fgetc(fd);\n \tif (EOF == temp) {\n \t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n \t\t    _(\"Unexpected EOF encountered in header of \"\n \t\t\t\"drill file \\\"%s\\\"\"), fd->filename);\n \n \tif ('\\n' == temp || '\\r' == temp)\n \t    gerb_ungetc(fd);\n \t}\n     }\n \n     if (apert == NULL) {\n         double dia;\n \n \tapert = image->aperture[tool_num] = g_new0(gerbv_aperture_t, 1);\n \tif (apert == NULL)\n \t    GERB_FATAL_ERROR(\"malloc tool failed in %s()\", __FUNCTION__);\n \n         dia = gerbv_get_tool_diameter(tool_num);\n         if (dia <= 0) {\n             dia = (double)(16 + 8 * tool_num) / 1000;\n             if (tool_num != 0) {\n \t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n \t\t\t_(\"Tool %02d used without being defined \"\n \t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n \t\t\ttool_num, file_line, fd->filename);\n \t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n \t\t\t_(\"Setting a default size of %g\\\"\"), dia);\n             }\n \t}\n \n \tapert->type = GERBV_APTYPE_CIRCLE;\n \tapert->nuf_parameters = 1;\n \tapert->parameter[0] = dia;\n \n \tif (tool_num != 0) {\n \t    stats = image->drill_stats;\n \t    string = g_strdup_printf(\"%s\",\n \t\t\t\t     (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n \t    drill_stats_add_to_drill_list(stats->drill_list,\n \t\t\t\t\t  tool_num,\n \t\t\t\t\t  state->unit == GERBV_UNIT_MM ? dia*25.4 : dia,\n \t\t\t\t\t  string);\n \t    g_free(string);\n \t}\n     }\n \n     dprintf(\"<----  ...leaving %s()\\n\", __FUNCTION__);\n \n     return tool_num;\n }\n \n", "target": "// fix_start\n\treturn -1;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-40391", "cve_desc": "An out-of-bounds write vulnerability exists in the drill format T-code tool number functionality of Gerbv 2.7.0, dev (commit b5f1eacd), and the forked version of Gerbv (commit 71493260). A specially-crafted drill file can lead to code execution. An attacker can provide a malicious file to trigger this vulnerability.", "project": "gerbv", "idx": 201382}
{"source": " ga_concat_shorten_esc(garray_T *gap, char_u *str)\n {\n     char_u  *p;\n     char_u  *s;\n     int\t    c;\n     int\t    clen;\n     char_u  buf[NUMBUFLEN];\n     int\t    same_len;\n \n     if (str == NULL)\n     {\n \tga_concat(gap, (char_u *)\"NULL\");\n \treturn;\n     }\n \n     for (p = str; *p != NUL; ++p)\n     {\n \tsame_len = 1;\n \ts = p;\n// bug_start\n\tc = mb_ptr2char_adv(&s);\n// bug_end\n \tclen = s - p;\n \twhile (*s != NUL && c == mb_ptr2char(s))\n \t{\n \t    ++same_len;\n \t    s += clen;\n \t}\n \tif (same_len > 20)\n \t{\n \t    ga_concat(gap, (char_u *)\"\\\\[\");\n \t    ga_concat_esc(gap, p, clen);\n \t    ga_concat(gap, (char_u *)\" occurs \");\n \t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n \t    ga_concat(gap, buf);\n \t    ga_concat(gap, (char_u *)\" times]\");\n \t    p = s - 1;\n \t}\n \telse\n \t    ga_concat_esc(gap, p, clen);\n     }\n }\n \n", "target": "// fix_start\n\tc = mb_cptr2char_adv(&s);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0629", "cve_desc": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 201384}
{"source": " static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n #define MonoColorType  1\n #define RGBColorType  3\n \n   char\n     property[MaxTextExtent];\n \n   CINInfo\n     cin;\n \n   Image\n     *image;\n \n   MagickBooleanType\n     status;\n \n   MagickOffsetType\n     offset;\n \n   QuantumInfo\n     *quantum_info;\n \n   QuantumType\n     quantum_type;\n \n   ssize_t\n     i;\n \n   PixelPacket\n     *q;\n \n   size_t\n     extent,\n     length;\n \n   ssize_t\n     count,\n     y;\n \n   unsigned char\n     magick[4],\n     *pixels;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   offset=0;\n   count=ReadBlob(image,4,magick);\n   offset+=count;\n   if ((count != 4) ||\n       ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   memset(&cin,0,sizeof(cin));\n   image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n     (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n   cin.file.image_offset=ReadBlobLong(image);\n// bug_start\n// bug_end\n   offset+=4;\n   cin.file.generic_length=ReadBlobLong(image);\n   offset+=4;\n   cin.file.industry_length=ReadBlobLong(image);\n   offset+=4;\n   cin.file.user_length=ReadBlobLong(image);\n   offset+=4;\n   cin.file.file_size=ReadBlobLong(image);\n   offset+=4;\n   offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n     cin.file.version);\n   (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n   (void) SetImageProperty(image,\"dpx:file.version\",property);\n   offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n     cin.file.filename);\n   (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n   (void) SetImageProperty(image,\"dpx:file.filename\",property);\n   offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n     cin.file.create_date);\n   (void) CopyMagickString(property,cin.file.create_date,\n     sizeof(cin.file.create_date));\n   (void) SetImageProperty(image,\"dpx:file.create_date\",property);\n   offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n     cin.file.create_time);\n   (void) CopyMagickString(property,cin.file.create_time,\n      sizeof(cin.file.create_time));\n   (void) SetImageProperty(image,\"dpx:file.create_time\",property);\n   offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n     cin.file.reserve);\n   cin.image.orientation=(unsigned char) ReadBlobByte(image);\n   offset++;\n   if (cin.image.orientation != (unsigned char) (~0))\n     (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n       cin.image.orientation);\n   switch (cin.image.orientation)\n   {\n     default:\n     case 0: image->orientation=TopLeftOrientation; break;\n     case 1: image->orientation=TopRightOrientation; break;\n     case 2: image->orientation=BottomLeftOrientation; break;\n     case 3: image->orientation=BottomRightOrientation; break;\n     case 4: image->orientation=LeftTopOrientation; break;\n     case 5: image->orientation=RightTopOrientation; break;\n     case 6: image->orientation=LeftBottomOrientation; break;\n     case 7: image->orientation=RightBottomOrientation; break;\n   }\n   cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n   offset++;\n   offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n     cin.image.reserve1);\n   for (i=0; i < 8; i++)\n   {\n     cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n     offset+=4;\n     cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n     offset+=4;\n     cin.image.channel[i].min_data=ReadBlobFloat(image);\n     offset+=4;\n     cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n     offset+=4;\n     cin.image.channel[i].max_data=ReadBlobFloat(image);\n     offset+=4;\n     cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n     offset+=4;\n   }\n   cin.image.white_point[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n     image->chromaticity.white_point.x=cin.image.white_point[0];\n   cin.image.white_point[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n     image->chromaticity.white_point.y=cin.image.white_point[1];\n   cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n     image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n   cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n     image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n   cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n     image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n   cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n     image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n   cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n     image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n   cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n     image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n   offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n     cin.image.label);\n   (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n   (void) SetImageProperty(image,\"dpx:image.label\",property);\n   offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n     cin.image.reserve);\n   cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.line_pad=ReadBlobLong(image);\n   offset+=4;\n   cin.data_format.channel_pad=ReadBlobLong(image);\n   offset+=4;\n   offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n     cin.data_format.reserve);\n   cin.origination.x_offset=ReadBlobSignedLong(image);\n   offset+=4;\n   if ((size_t) cin.origination.x_offset != ~0UL)\n     (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n       (double) cin.origination.x_offset);\n   cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n   offset+=4;\n   if ((size_t) cin.origination.y_offset != ~0UL)\n     (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n       (double) cin.origination.y_offset);\n   offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n     cin.origination.filename);\n   (void) CopyMagickString(property,cin.origination.filename,\n     sizeof(cin.origination.filename));\n   (void) SetImageProperty(image,\"dpx:origination.filename\",property);\n   offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n     cin.origination.create_date);\n   (void) CopyMagickString(property,cin.origination.create_date,\n     sizeof(cin.origination.create_date));\n   (void) SetImageProperty(image,\"dpx:origination.create_date\",property);\n   offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n     cin.origination.create_time);\n   (void) CopyMagickString(property,cin.origination.create_time,\n     sizeof(cin.origination.create_time));\n   (void) SetImageProperty(image,\"dpx:origination.create_time\",property);\n   offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n     cin.origination.device);\n   (void) CopyMagickString(property,cin.origination.device,\n     sizeof(cin.origination.device));\n   (void) SetImageProperty(image,\"dpx:origination.device\",property);\n   offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n     cin.origination.model);\n   (void) CopyMagickString(property,cin.origination.model,\n     sizeof(cin.origination.model));\n   (void) SetImageProperty(image,\"dpx:origination.model\",property);\n   (void) memset(cin.origination.serial,0,\n     sizeof(cin.origination.serial));\n   offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n     cin.origination.serial);\n   (void) CopyMagickString(property,cin.origination.serial,\n     sizeof(cin.origination.serial));\n   (void) SetImageProperty(image,\"dpx:origination.serial\",property);\n   cin.origination.x_pitch=ReadBlobFloat(image);\n   offset+=4;\n   cin.origination.y_pitch=ReadBlobFloat(image);\n   offset+=4;\n   cin.origination.gamma=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n     image->gamma=cin.origination.gamma;\n   offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n     cin.origination.reserve);\n   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n     {\n       int\n         c;\n \n       cin.film.id=ReadBlobByte(image);\n       offset++;\n       c=cin.film.id;\n       if (c != ~0)\n         (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n       cin.film.type=ReadBlobByte(image);\n       offset++;\n       c=cin.film.type;\n       if (c != ~0)\n         (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n       cin.film.offset=ReadBlobByte(image);\n       offset++;\n       c=cin.film.offset;\n       if (c != ~0)\n         (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n           cin.film.offset);\n       cin.film.reserve1=ReadBlobByte(image);\n       offset++;\n       cin.film.prefix=ReadBlobLong(image);\n       offset+=4;\n       if (cin.film.prefix != ~0UL)\n         (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n           cin.film.prefix);\n       cin.film.count=ReadBlobLong(image);\n       offset+=4;\n       offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n         cin.film.format);\n       (void) CopyMagickString(property,cin.film.format,\n         sizeof(cin.film.format));\n       (void) SetImageProperty(image,\"dpx:film.format\",property);\n       cin.film.frame_position=ReadBlobLong(image);\n       offset+=4;\n       if (cin.film.frame_position != ~0UL)\n         (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n           (double) cin.film.frame_position);\n       cin.film.frame_rate=ReadBlobFloat(image);\n       offset+=4;\n       if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n         (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n           cin.film.frame_rate);\n       offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n         cin.film.frame_id);\n       (void) CopyMagickString(property,cin.film.frame_id,\n         sizeof(cin.film.frame_id));\n       (void) SetImageProperty(image,\"dpx:film.frame_id\",property);\n       offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n         cin.film.slate_info);\n       (void) CopyMagickString(property,cin.film.slate_info,\n         sizeof(cin.film.slate_info));\n       (void) SetImageProperty(image,\"dpx:film.slate_info\",property);\n       offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n         cin.film.reserve);\n     }\n   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n     {\n       StringInfo\n         *profile;\n \n       if (cin.file.user_length > GetBlobSize(image))\n         ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n       profile=BlobToStringInfo((const void *) NULL,cin.file.user_length);\n       if (profile == (StringInfo *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       offset+=ReadBlob(image,GetStringInfoLength(profile),\n         GetStringInfoDatum(profile));\n       (void) SetImageProfile(image,\"dpx:user.data\",profile);\n       profile=DestroyStringInfo(profile);\n     }\n   image->depth=cin.image.channel[0].bits_per_pixel;\n   image->columns=cin.image.channel[0].pixels_per_line;\n   image->rows=cin.image.channel[0].lines_per_image;\n   if (image_info->ping != MagickFalse)\n     {\n       (void) CloseBlob(image);\n       return(image);\n     }\n   if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n     ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n   {\n     int\n       c;\n \n     c=ReadBlobByte(image);\n     if (c == EOF)\n       break;\n   }\n   if (offset < (MagickOffsetType) cin.file.image_offset)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   status=SetImageExtent(image,image->columns,image->rows);\n   if (status == MagickFalse)\n     {\n       InheritException(exception,&image->exception);\n       return(DestroyImageList(image));\n     }\n   (void) SetImageBackgroundColor(image);\n   quantum_info=AcquireQuantumInfo(image_info,image);\n   if (quantum_info == (QuantumInfo *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n   SetQuantumQuantum(quantum_info,32);\n   SetQuantumPack(quantum_info,MagickFalse);\n   quantum_type=RGBQuantum;\n   extent=GetQuantumExtent(image,quantum_info,quantum_type);\n   (void) extent;\n   length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n   if (cin.image.number_channels == 1)\n     {\n       quantum_type=GrayQuantum;\n       length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n     }\n   status=SetQuantumPad(image,quantum_info,0);\n   pixels=GetQuantumPixels(quantum_info);\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n     const void\n       *stream;\n \n     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n     if (q == (PixelPacket *) NULL)\n       break;\n     stream=ReadBlobStream(image,length,pixels,&count);\n     if (count != (ssize_t) length)\n       break;\n     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       quantum_type,(unsigned char *) stream,exception);\n     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       break;\n     if (image->previous == (Image *) NULL)\n       {\n         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n           image->rows);\n         if (status == MagickFalse)\n           break;\n       }\n   }\n   SetQuantumImageType(image,quantum_type);\n   quantum_info=DestroyQuantumInfo(quantum_info);\n   if (EOFBlob(image) != MagickFalse)\n     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n       image->filename);\n   SetImageColorspace(image,LogColorspace);\n   (void) CloseBlob(image);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n  if (cin.file.image_offset < 712)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-28463", "cve_desc": "ImageMagick 7.1.0-27 is vulnerable to Buffer Overflow.", "project": "ImageMagick6", "idx": 201451}
{"source": " _gnutls_server_select_suite(gnutls_session_t session, uint8_t * data,\n \t\t\t    unsigned int datalen)\n {\n \tint ret;\n \tunsigned int i, j, cipher_suites_size;\n \tsize_t pk_algos_size;\n \tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE];\n \tint retval;\n \tgnutls_pk_algorithm_t pk_algos[MAX_ALGOS];\n \n \tfor (i = 0; i < datalen; i += 2) {\n \t\tif (session->internals.priorities.sr != SR_DISABLED &&\n \t\t    data[i] == GNUTLS_RENEGO_PROTECTION_REQUEST_MAJOR &&\n \t\t    data[i + 1] == GNUTLS_RENEGO_PROTECTION_REQUEST_MINOR) {\n \t\t\t_gnutls_handshake_log\n \t\t\t    (\"HSK[%p]: Received safe renegotiation CS\\n\",\n \t\t\t     session);\n \t\t\tretval = _gnutls_ext_sr_recv_cs(session);\n \t\t\tif (retval < 0) {\n \t\t\t\tgnutls_assert();\n \t\t\t\treturn retval;\n \t\t\t}\n \t\t}\n \n \t\tif (data[i] == GNUTLS_FALLBACK_SCSV_MAJOR &&\n \t\t    data[i + 1] == GNUTLS_FALLBACK_SCSV_MINOR) {\n// bug_start\n// bug_end\n \t\t\t_gnutls_handshake_log\n \t\t\t    (\"HSK[%p]: Received fallback CS\\n\",\n \t\t\t     session);\n \n// bug_start\n\t\t\tif (gnutls_protocol_get_version(session) !=\n\t\t\t    GNUTLS_TLS_VERSION_MAX)\n\t\t\t\treturn GNUTLS_E_INAPPROPRIATE_FALLBACK;\n// bug_end\n \t\t}\n \t}\n \n \tpk_algos_size = MAX_ALGOS;\n \tret =\n \t    server_find_pk_algos_in_ciphersuites(data, datalen, pk_algos,\n \t\t\t\t\t\t &pk_algos_size);\n \tif (ret < 0)\n \t\treturn gnutls_assert_val(ret);\n \n \tret =\n \t    _gnutls_supported_ciphersuites(session, cipher_suites,\n \t\t\t\t\t   sizeof(cipher_suites));\n \tif (ret < 0)\n \t\treturn gnutls_assert_val(ret);\n \n \tcipher_suites_size = ret;\n \n \tret =\n \t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n \t\t\t\t\t\t cipher_suites_size,\n \t\t\t\t\t\t pk_algos, pk_algos_size);\n \tif (ret <= 0) {\n \t\tgnutls_assert();\n \t\tif (ret < 0)\n \t\t\treturn ret;\n \t\telse\n \t\t\treturn GNUTLS_E_UNKNOWN_CIPHER_SUITE;\n \t}\n \n \tcipher_suites_size = ret;\n \n \tif (datalen % 2 != 0) {\n \t\tgnutls_assert();\n \t\treturn GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n \t}\n \n \tmemset(session->security_parameters.cipher_suite, 0, 2);\n \n \tretval = GNUTLS_E_UNKNOWN_CIPHER_SUITE;\n \n \t_gnutls_handshake_log\n \t    (\"HSK[%p]: Requested cipher suites[size: %d]: \\n\", session,\n \t     (int) datalen);\n \n \tif (session->internals.priorities.server_precedence == 0) {\n \t\tfor (j = 0; j < datalen; j += 2) {\n \t\t\t_gnutls_handshake_log(\"\\t0x%.2x, 0x%.2x %s\\n\",\n \t\t\t\t\t      data[j], data[j + 1],\n \t\t\t\t\t      _gnutls_cipher_suite_get_name\n \t\t\t\t\t      (&data[j]));\n \t\t\tfor (i = 0; i < cipher_suites_size; i += 2) {\n \t\t\t\tif (memcmp(&cipher_suites[i], &data[j], 2)\n \t\t\t\t    == 0) {\n \t\t\t\t\t_gnutls_handshake_log\n \t\t\t\t\t    (\"HSK[%p]: Selected cipher suite: %s\\n\",\n \t\t\t\t\t     session,\n \t\t\t\t\t     _gnutls_cipher_suite_get_name\n \t\t\t\t\t     (&data[j]));\n \t\t\t\t\tmemcpy(session->\n \t\t\t\t\t       security_parameters.\n \t\t\t\t\t       cipher_suite,\n \t\t\t\t\t       &cipher_suites[i], 2);\n \t\t\t\t\t_gnutls_epoch_set_cipher_suite\n \t\t\t\t\t    (session, EPOCH_NEXT,\n \t\t\t\t\t     session->security_parameters.\n \t\t\t\t\t     cipher_suite);\n \n \n \t\t\t\t\tretval = 0;\n \t\t\t\t\tgoto finish;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t} else {\n \n \t\tfor (i = 0; i < cipher_suites_size; i += 2) {\n \t\t\tfor (j = 0; j < datalen; j += 2) {\n \t\t\t\tif (memcmp(&cipher_suites[i], &data[j], 2)\n \t\t\t\t    == 0) {\n \t\t\t\t\t_gnutls_handshake_log\n \t\t\t\t\t    (\"HSK[%p]: Selected cipher suite: %s\\n\",\n \t\t\t\t\t     session,\n \t\t\t\t\t     _gnutls_cipher_suite_get_name\n \t\t\t\t\t     (&data[j]));\n \t\t\t\t\tmemcpy(session->\n \t\t\t\t\t       security_parameters.\n \t\t\t\t\t       cipher_suite,\n \t\t\t\t\t       &cipher_suites[i], 2);\n \t\t\t\t\t_gnutls_epoch_set_cipher_suite\n \t\t\t\t\t    (session, EPOCH_NEXT,\n \t\t\t\t\t     session->security_parameters.\n \t\t\t\t\t     cipher_suite);\n \n \n \t\t\t\t\tretval = 0;\n \t\t\t\t\tgoto finish;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n       finish:\n \n \tif (retval != 0) {\n \t\tgnutls_assert();\n \t\treturn retval;\n \t}\n \n \tif (_gnutls_get_kx_cred\n \t    (session,\n \t     _gnutls_cipher_suite_get_kx_algo(session->security_parameters.\n \t\t\t\t\t      cipher_suite)) == NULL) {\n \t\tgnutls_assert();\n \t\treturn GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n \t}\n \n \n \tsession->internals.auth_struct =\n \t    _gnutls_kx_auth_struct(_gnutls_cipher_suite_get_kx_algo\n \t\t\t\t   (session->security_parameters.\n \t\t\t\t    cipher_suite));\n \tif (session->internals.auth_struct == NULL) {\n \n \t\t_gnutls_handshake_log\n \t\t    (\"HSK[%p]: Cannot find the appropriate handler for the KX algorithm\\n\",\n \t\t     session);\n \t\tgnutls_assert();\n \t\treturn GNUTLS_E_INTERNAL_ERROR;\n \t}\n \n \treturn 0;\n \n }\n \n", "target": "// fix_start\n\t\t\tunsigned max = _gnutls_version_max(session);\n// fix_end\n// fix_start\n\t\t\tif (gnutls_protocol_get_version(session) != max)\n\t\t\t\treturn gnutls_assert_val(GNUTLS_E_INAPPROPRIATE_FALLBACK);\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "cve": "CVE-2014-3566", "cve_desc": "The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding, which makes it easier for man-in-the-middle attackers to obtain cleartext data via a padding-oracle attack, aka the \"POODLE\" issue.", "project": "gnutls", "idx": 201872}
{"source": " regmatch(\n     char_u\t*scan,\n     proftime_T\t*tm UNUSED,\n     int\t\t*timed_out UNUSED)\n {\n   char_u\t*next;\n   int\t\top;\n   int\t\tc;\n   regitem_T\t*rp;\n   int\t\tno;\n   int\t\tstatus;\n #ifdef FEAT_RELTIME\n   int\t\ttm_count = 0;\n #endif\n \n   regstack.ga_len = 0;\n   backpos.ga_len = 0;\n \n   for (;;)\n   {\n     fast_breakcheck();\n \n #ifdef DEBUG\n     if (scan != NULL && regnarrate)\n     {\n \tmch_errmsg((char *)regprop(scan));\n \tmch_errmsg(\"(\\n\");\n     }\n #endif\n \n     for (;;)\n     {\n \tif (got_int || scan == NULL)\n \t{\n \t    status = RA_FAIL;\n \t    break;\n \t}\n #ifdef FEAT_RELTIME\n \tif (tm != NULL && ++tm_count == 100)\n \t{\n \t    tm_count = 0;\n \t    if (profile_passed_limit(tm))\n \t    {\n \t\tif (timed_out != NULL)\n \t\t    *timed_out = TRUE;\n \t\tstatus = RA_FAIL;\n \t\tbreak;\n \t    }\n \t}\n #endif\n \tstatus = RA_CONT;\n \n #ifdef DEBUG\n \tif (regnarrate)\n \t{\n \t    mch_errmsg((char *)regprop(scan));\n \t    mch_errmsg(\"...\\n\");\n # ifdef FEAT_SYN_HL\n \t    if (re_extmatch_in != NULL)\n \t    {\n \t\tint i;\n \n \t\tmch_errmsg(_(\"External submatches:\\n\"));\n \t\tfor (i = 0; i < NSUBEXP; i++)\n \t\t{\n \t\t    mch_errmsg(\"    \\\"\");\n \t\t    if (re_extmatch_in->matches[i] != NULL)\n \t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n \t\t    mch_errmsg(\"\\\"\\n\");\n \t\t}\n \t    }\n # endif\n \t}\n #endif\n \tnext = regnext(scan);\n \n \top = OP(scan);\n \tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n \t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n \t{\n \t    reg_nextline();\n \t}\n \telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n \t{\n \t    ADVANCE_REGINPUT();\n \t}\n \telse\n \t{\n \t  if (WITH_NL(op))\n \t      op -= ADD_NL;\n \t  if (has_mbyte)\n \t      c = (*mb_ptr2char)(rex.input);\n \t  else\n \t      c = *rex.input;\n \t  switch (op)\n \t  {\n \t  case BOL:\n \t    if (rex.input != rex.line)\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case EOL:\n \t    if (c != NUL)\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case RE_BOF:\n \t    if (rex.lnum != 0 || rex.input != rex.line\n \t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case RE_EOF:\n \t    if (rex.lnum != rex.reg_maxline || c != NUL)\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case CURSOR:\n \t    if (rex.reg_win == NULL\n \t\t    || (rex.lnum + rex.reg_firstlnum\n \t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n \t\t    || ((colnr_T)(rex.input - rex.line)\n \t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case RE_MARK:\n \t    {\n \t\tint\tmark = OPERAND(scan)[0];\n \t\tint\tcmp = OPERAND(scan)[1];\n \t\tpos_T\t*pos;\n// bug_start\n// bug_end\n \n \t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n// bug_start\n// bug_end\n \t\tif (pos == NULL\n \t\t\t|| pos->lnum <= 0)\n \t\t{\n \t\t    status = RA_NOMATCH;\n \t\t}\n \t\telse\n \t\t{\n \t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n \t\t\t\t\t\t\t  && pos->col == MAXCOL\n \t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n \t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n \t\t\t\t      : pos->col;\n \n \t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n \t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n \t\t\t\t    ? (cmp == '<' || cmp == '>')\n \t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n \t\t\t\t\t? cmp != '>'\n \t\t\t\t\t: cmp != '<'))\n \t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n \t\t\t\t    ? cmp != '>'\n \t\t\t\t    : cmp != '<')))\n \t\t    status = RA_NOMATCH;\n \t\t}\n \t    }\n \t    break;\n \n \t  case RE_VISUAL:\n \t    if (!reg_match_visual())\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case RE_LNUM:\n \t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n \t\t\t\t\t\t\t\t\tscan))\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case RE_COL:\n \t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case RE_VCOL:\n \t    if (!re_num_cmp((long_u)win_linetabsize(\n \t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n \t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case BOW:\n \t    if (c == NUL)\n \t\tstatus = RA_NOMATCH;\n \t    else if (has_mbyte)\n \t    {\n \t\tint this_class;\n \n \t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n \t\tif (this_class <= 1)\n \t\t    status = RA_NOMATCH;\n \t\telse if (reg_prev_class() == this_class)\n \t\t    status = RA_NOMATCH;\n \t    }\n \t    else\n \t    {\n \t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n \t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n \t\t    status = RA_NOMATCH;\n \t    }\n \t    break;\n \n \t  case EOW:\n \t    if (rex.input == rex.line)\n \t\tstatus = RA_NOMATCH;\n \t    else if (has_mbyte)\n \t    {\n \t\tint this_class, prev_class;\n \n \t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n \t\tprev_class = reg_prev_class();\n \t\tif (this_class == prev_class\n \t\t\t|| prev_class == 0 || prev_class == 1)\n \t\t    status = RA_NOMATCH;\n \t    }\n \t    else\n \t    {\n \t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n \t\t\t|| (rex.input[0] != NUL\n \t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n \t\t    status = RA_NOMATCH;\n \t    }\n \t    break;\n \n \t  case ANY:\n \t    if (c == NUL)\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case IDENT:\n \t    if (!vim_isIDc(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case SIDENT:\n \t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case KWORD:\n \t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case SKWORD:\n \t    if (VIM_ISDIGIT(*rex.input)\n \t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case FNAME:\n \t    if (!vim_isfilec(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case SFNAME:\n \t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case PRINT:\n \t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case SPRINT:\n \t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case WHITE:\n \t    if (!VIM_ISWHITE(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NWHITE:\n \t    if (c == NUL || VIM_ISWHITE(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case DIGIT:\n \t    if (!ri_digit(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NDIGIT:\n \t    if (c == NUL || ri_digit(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case HEX:\n \t    if (!ri_hex(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NHEX:\n \t    if (c == NUL || ri_hex(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case OCTAL:\n \t    if (!ri_octal(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NOCTAL:\n \t    if (c == NUL || ri_octal(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case WORD:\n \t    if (!ri_word(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NWORD:\n \t    if (c == NUL || ri_word(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case HEAD:\n \t    if (!ri_head(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NHEAD:\n \t    if (c == NUL || ri_head(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case ALPHA:\n \t    if (!ri_alpha(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NALPHA:\n \t    if (c == NUL || ri_alpha(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case LOWER:\n \t    if (!ri_lower(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NLOWER:\n \t    if (c == NUL || ri_lower(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case UPPER:\n \t    if (!ri_upper(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case NUPPER:\n \t    if (c == NUL || ri_upper(c))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case EXACTLY:\n \t    {\n \t\tint\tlen;\n \t\tchar_u\t*opnd;\n \n \t\topnd = OPERAND(scan);\n \t\tif (*opnd != *rex.input\n \t\t\t&& (!rex.reg_ic\n \t\t\t    || (!enc_utf8\n \t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n \t\t    status = RA_NOMATCH;\n \t\telse if (*opnd == NUL)\n \t\t{\n \t\t}\n \t\telse\n \t\t{\n \t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n \t\t    {\n \t\t\tlen = 1;\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tlen = (int)STRLEN(opnd);\n \t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n \t\t\t    status = RA_NOMATCH;\n \t\t    }\n \t\t    if (status != RA_NOMATCH\n \t\t\t    && enc_utf8\n \t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n \t\t\t    && !rex.reg_icombine\n \t\t\t    && OP(next) != RE_COMPOSING)\n \t\t    {\n \t\t\tstatus = RA_NOMATCH;\n \t\t    }\n \t\t    if (status != RA_NOMATCH)\n \t\t\trex.input += len;\n \t\t}\n \t    }\n \t    break;\n \n \t  case ANYOF:\n \t  case ANYBUT:\n \t    if (c == NUL)\n \t\tstatus = RA_NOMATCH;\n \t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t\tADVANCE_REGINPUT();\n \t    break;\n \n \t  case MULTIBYTECODE:\n \t    if (has_mbyte)\n \t    {\n \t\tint\ti, len;\n \t\tchar_u\t*opnd;\n \t\tint\topndc = 0, inpc;\n \n \t\topnd = OPERAND(scan);\n \t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n \t\t{\n \t\t    status = RA_NOMATCH;\n \t\t    break;\n \t\t}\n \t\tif (enc_utf8)\n \t\t    opndc = utf_ptr2char(opnd);\n \t\tif (enc_utf8 && utf_iscomposing(opndc))\n \t\t{\n \t\t    status = RA_NOMATCH;\n \t\t    for (i = 0; rex.input[i] != NUL;\n \t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n \t\t    {\n \t\t\tinpc = utf_ptr2char(rex.input + i);\n \t\t\tif (!utf_iscomposing(inpc))\n \t\t\t{\n \t\t\t    if (i > 0)\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (opndc == inpc)\n \t\t\t{\n \t\t\t    len = i + utfc_ptr2len(rex.input + i);\n \t\t\t    status = RA_MATCH;\n \t\t\t    break;\n \t\t\t}\n \t\t    }\n \t\t}\n \t\telse\n \t\t    for (i = 0; i < len; ++i)\n \t\t\tif (opnd[i] != rex.input[i])\n \t\t\t{\n \t\t\t    status = RA_NOMATCH;\n \t\t\t    break;\n \t\t\t}\n \t\trex.input += len;\n \t    }\n \t    else\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \t  case RE_COMPOSING:\n \t    if (enc_utf8)\n \t    {\n \t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n \t\t    MB_CPTR_ADV(rex.input);\n \t    }\n \t    break;\n \n \t  case NOTHING:\n \t    break;\n \n \t  case BACK:\n \t    {\n \t\tint\t\ti;\n \t\tbackpos_T\t*bp;\n \n \t\tbp = (backpos_T *)backpos.ga_data;\n \t\tfor (i = 0; i < backpos.ga_len; ++i)\n \t\t    if (bp[i].bp_scan == scan)\n \t\t\tbreak;\n \t\tif (i == backpos.ga_len)\n \t\t{\n \t\t    if (ga_grow(&backpos, 1) == FAIL)\n \t\t\tstatus = RA_FAIL;\n \t\t    else\n \t\t    {\n \t\t\tbp = (backpos_T *)backpos.ga_data;\n \t\t\tbp[i].bp_scan = scan;\n \t\t\t++backpos.ga_len;\n \t\t    }\n \t\t}\n \t\telse if (reg_save_equal(&bp[i].bp_pos))\n \t\t    status = RA_NOMATCH;\n \n \t\tif (status != RA_FAIL && status != RA_NOMATCH)\n \t\t    reg_save(&bp[i].bp_pos, &backpos);\n \t    }\n \t    break;\n \n \t  case MOPEN + 0:\n \t  case MOPEN + 1:\n \t  case MOPEN + 2:\n \t  case MOPEN + 3:\n \t  case MOPEN + 4:\n \t  case MOPEN + 5:\n \t  case MOPEN + 6:\n \t  case MOPEN + 7:\n \t  case MOPEN + 8:\n \t  case MOPEN + 9:\n \t    {\n \t\tno = op - MOPEN;\n \t\tcleanup_subexpr();\n \t\trp = regstack_push(RS_MOPEN, scan);\n \t\tif (rp == NULL)\n \t\t    status = RA_FAIL;\n \t\telse\n \t\t{\n \t\t    rp->rs_no = no;\n \t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n \t\t\t\t\t\t\t  &rex.reg_startp[no]);\n \t\t}\n \t    }\n \t    break;\n \n \t  case NOPEN:\n \t  case NCLOSE:\n \t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n \t\t    status = RA_FAIL;\n \t\tbreak;\n \n #ifdef FEAT_SYN_HL\n \t  case ZOPEN + 1:\n \t  case ZOPEN + 2:\n \t  case ZOPEN + 3:\n \t  case ZOPEN + 4:\n \t  case ZOPEN + 5:\n \t  case ZOPEN + 6:\n \t  case ZOPEN + 7:\n \t  case ZOPEN + 8:\n \t  case ZOPEN + 9:\n \t    {\n \t\tno = op - ZOPEN;\n \t\tcleanup_zsubexpr();\n \t\trp = regstack_push(RS_ZOPEN, scan);\n \t\tif (rp == NULL)\n \t\t    status = RA_FAIL;\n \t\telse\n \t\t{\n \t\t    rp->rs_no = no;\n \t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n \t\t\t\t\t\t\t     &reg_startzp[no]);\n \t\t}\n \t    }\n \t    break;\n #endif\n \n \t  case MCLOSE + 0:\n \t  case MCLOSE + 1:\n \t  case MCLOSE + 2:\n \t  case MCLOSE + 3:\n \t  case MCLOSE + 4:\n \t  case MCLOSE + 5:\n \t  case MCLOSE + 6:\n \t  case MCLOSE + 7:\n \t  case MCLOSE + 8:\n \t  case MCLOSE + 9:\n \t    {\n \t\tno = op - MCLOSE;\n \t\tcleanup_subexpr();\n \t\trp = regstack_push(RS_MCLOSE, scan);\n \t\tif (rp == NULL)\n \t\t    status = RA_FAIL;\n \t\telse\n \t\t{\n \t\t    rp->rs_no = no;\n \t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n \t\t\t\t\t\t\t    &rex.reg_endp[no]);\n \t\t}\n \t    }\n \t    break;\n \n #ifdef FEAT_SYN_HL\n \t  case ZCLOSE + 1:\n \t  case ZCLOSE + 2:\n \t  case ZCLOSE + 3:\n \t  case ZCLOSE + 4:\n \t  case ZCLOSE + 5:\n \t  case ZCLOSE + 6:\n \t  case ZCLOSE + 7:\n \t  case ZCLOSE + 8:\n \t  case ZCLOSE + 9:\n \t    {\n \t\tno = op - ZCLOSE;\n \t\tcleanup_zsubexpr();\n \t\trp = regstack_push(RS_ZCLOSE, scan);\n \t\tif (rp == NULL)\n \t\t    status = RA_FAIL;\n \t\telse\n \t\t{\n \t\t    rp->rs_no = no;\n \t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n \t\t\t\t\t\t\t      &reg_endzp[no]);\n \t\t}\n \t    }\n \t    break;\n #endif\n \n \t  case BACKREF + 1:\n \t  case BACKREF + 2:\n \t  case BACKREF + 3:\n \t  case BACKREF + 4:\n \t  case BACKREF + 5:\n \t  case BACKREF + 6:\n \t  case BACKREF + 7:\n \t  case BACKREF + 8:\n \t  case BACKREF + 9:\n \t    {\n \t\tint\t\tlen;\n \n \t\tno = op - BACKREF;\n \t\tcleanup_subexpr();\n \t\tif (!REG_MULTI)\n \t\t{\n \t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n \t\t    {\n \t\t\tlen = 0;\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n \t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n \t\t\t    status = RA_NOMATCH;\n \t\t    }\n \t\t}\n \t\telse\n \t\t{\n \t\t    if (rex.reg_startpos[no].lnum < 0\n \t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n \t\t    {\n \t\t\tlen = 0;\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n \t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n \t\t\t{\n \t\t\t    len = rex.reg_endpos[no].col\n \t\t\t\t\t\t    - rex.reg_startpos[no].col;\n \t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n \t\t\t\t\t\t\t  rex.input, &len) != 0)\n \t\t\t\tstatus = RA_NOMATCH;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    int r = match_with_backref(\n \t\t\t\t\t    rex.reg_startpos[no].lnum,\n \t\t\t\t\t    rex.reg_startpos[no].col,\n \t\t\t\t\t    rex.reg_endpos[no].lnum,\n \t\t\t\t\t    rex.reg_endpos[no].col,\n \t\t\t\t\t    &len);\n \n \t\t\t    if (r != RA_MATCH)\n \t\t\t\tstatus = r;\n \t\t\t}\n \t\t    }\n \t\t}\n \n \t\trex.input += len;\n \t    }\n \t    break;\n \n #ifdef FEAT_SYN_HL\n \t  case ZREF + 1:\n \t  case ZREF + 2:\n \t  case ZREF + 3:\n \t  case ZREF + 4:\n \t  case ZREF + 5:\n \t  case ZREF + 6:\n \t  case ZREF + 7:\n \t  case ZREF + 8:\n \t  case ZREF + 9:\n \t    {\n \t\tint\tlen;\n \n \t\tcleanup_zsubexpr();\n \t\tno = op - ZREF;\n \t\tif (re_extmatch_in != NULL\n \t\t\t&& re_extmatch_in->matches[no] != NULL)\n \t\t{\n \t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n \t\t    if (cstrncmp(re_extmatch_in->matches[no],\n \t\t\t\t\t\t\t  rex.input, &len) != 0)\n \t\t\tstatus = RA_NOMATCH;\n \t\t    else\n \t\t\trex.input += len;\n \t\t}\n \t\telse\n \t\t{\n \t\t}\n \t    }\n \t    break;\n #endif\n \n \t  case BRANCH:\n \t    {\n \t\tif (OP(next) != BRANCH)\n \t\t    next = OPERAND(scan);\n \t\telse\n \t\t{\n \t\t    rp = regstack_push(RS_BRANCH, scan);\n \t\t    if (rp == NULL)\n \t\t\tstatus = RA_FAIL;\n \t\t    else\n \t\t\tstatus = RA_BREAK;\n \t\t}\n \t    }\n \t    break;\n \n \t  case BRACE_LIMITS:\n \t    {\n \t\tif (OP(next) == BRACE_SIMPLE)\n \t\t{\n \t\t    bl_minval = OPERAND_MIN(scan);\n \t\t    bl_maxval = OPERAND_MAX(scan);\n \t\t}\n \t\telse if (OP(next) >= BRACE_COMPLEX\n \t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n \t\t{\n \t\t    no = OP(next) - BRACE_COMPLEX;\n \t\t    brace_min[no] = OPERAND_MIN(scan);\n \t\t    brace_max[no] = OPERAND_MAX(scan);\n \t\t    brace_count[no] = 0;\n \t\t}\n \t\telse\n \t\t{\n \t\t    internal_error(\"BRACE_LIMITS\");\n \t\t    status = RA_FAIL;\n \t\t}\n \t    }\n \t    break;\n \n \t  case BRACE_COMPLEX + 0:\n \t  case BRACE_COMPLEX + 1:\n \t  case BRACE_COMPLEX + 2:\n \t  case BRACE_COMPLEX + 3:\n \t  case BRACE_COMPLEX + 4:\n \t  case BRACE_COMPLEX + 5:\n \t  case BRACE_COMPLEX + 6:\n \t  case BRACE_COMPLEX + 7:\n \t  case BRACE_COMPLEX + 8:\n \t  case BRACE_COMPLEX + 9:\n \t    {\n \t\tno = op - BRACE_COMPLEX;\n \t\t++brace_count[no];\n \n \t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n \t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n \t\t{\n \t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n \t\t    if (rp == NULL)\n \t\t\tstatus = RA_FAIL;\n \t\t    else\n \t\t    {\n \t\t\trp->rs_no = no;\n \t\t\treg_save(&rp->rs_un.regsave, &backpos);\n \t\t\tnext = OPERAND(scan);\n \t\t    }\n \t\t    break;\n \t\t}\n \n \t\tif (brace_min[no] <= brace_max[no])\n \t\t{\n \t\t    if (brace_count[no] <= brace_max[no])\n \t\t    {\n \t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n \t\t\tif (rp == NULL)\n \t\t\t    status = RA_FAIL;\n \t\t\telse\n \t\t\t{\n \t\t\t    rp->rs_no = no;\n \t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n \t\t\t    next = OPERAND(scan);\n \t\t\t}\n \t\t    }\n \t\t}\n \t\telse\n \t\t{\n \t\t    if (brace_count[no] <= brace_min[no])\n \t\t    {\n \t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n \t\t\tif (rp == NULL)\n \t\t\t    status = RA_FAIL;\n \t\t\telse\n \t\t\t{\n \t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \t    break;\n \n \t  case BRACE_SIMPLE:\n \t  case STAR:\n \t  case PLUS:\n \t    {\n \t\tregstar_T\trst;\n \n \t\tif (OP(next) == EXACTLY)\n \t\t{\n \t\t    rst.nextb = *OPERAND(next);\n \t\t    if (rex.reg_ic)\n \t\t    {\n \t\t\tif (MB_ISUPPER(rst.nextb))\n \t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n \t\t\telse\n \t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n \t\t    }\n \t\t    else\n \t\t\trst.nextb_ic = rst.nextb;\n \t\t}\n \t\telse\n \t\t{\n \t\t    rst.nextb = NUL;\n \t\t    rst.nextb_ic = NUL;\n \t\t}\n \t\tif (op != BRACE_SIMPLE)\n \t\t{\n \t\t    rst.minval = (op == STAR) ? 0 : 1;\n \t\t    rst.maxval = MAX_LIMIT;\n \t\t}\n \t\telse\n \t\t{\n \t\t    rst.minval = bl_minval;\n \t\t    rst.maxval = bl_maxval;\n \t\t}\n \n \t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n \t\tif (got_int)\n \t\t{\n \t\t    status = RA_FAIL;\n \t\t    break;\n \t\t}\n \t\tif (rst.minval <= rst.maxval\n \t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n \t\t{\n \t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n \t\t    {\n \t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n \t\t\tstatus = RA_FAIL;\n \t\t    }\n \t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n \t\t\tstatus = RA_FAIL;\n \t\t    else\n \t\t    {\n \t\t\tregstack.ga_len += sizeof(regstar_T);\n \t\t\trp = regstack_push(rst.minval <= rst.maxval\n \t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n \t\t\tif (rp == NULL)\n \t\t\t    status = RA_FAIL;\n \t\t\telse\n \t\t\t{\n \t\t\t    *(((regstar_T *)rp) - 1) = rst;\n \t\t\t    status = RA_BREAK;\n \t\t\t}\n \t\t    }\n \t\t}\n \t\telse\n \t\t    status = RA_NOMATCH;\n \n \t    }\n \t    break;\n \n \t  case NOMATCH:\n \t  case MATCH:\n \t  case SUBPAT:\n \t    rp = regstack_push(RS_NOMATCH, scan);\n \t    if (rp == NULL)\n \t\tstatus = RA_FAIL;\n \t    else\n \t    {\n \t\trp->rs_no = op;\n \t\treg_save(&rp->rs_un.regsave, &backpos);\n \t\tnext = OPERAND(scan);\n \t    }\n \t    break;\n \n \t  case BEHIND:\n \t  case NOBEHIND:\n \t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n \t    {\n \t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n \t\tstatus = RA_FAIL;\n \t    }\n \t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n \t\tstatus = RA_FAIL;\n \t    else\n \t    {\n \t\tregstack.ga_len += sizeof(regbehind_T);\n \t\trp = regstack_push(RS_BEHIND1, scan);\n \t\tif (rp == NULL)\n \t\t    status = RA_FAIL;\n \t\telse\n \t\t{\n \t\t    save_subexpr(((regbehind_T *)rp) - 1);\n \n \t\t    rp->rs_no = op;\n \t\t    reg_save(&rp->rs_un.regsave, &backpos);\n \t\t}\n \t    }\n \t    break;\n \n \t  case BHPOS:\n \t    if (REG_MULTI)\n \t    {\n \t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n \t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n \t\t    status = RA_NOMATCH;\n \t    }\n \t    else if (behind_pos.rs_u.ptr != rex.input)\n \t\tstatus = RA_NOMATCH;\n \t    break;\n \n \t  case NEWL:\n \t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n \t\t\t     || rex.reg_line_lbr)\n \t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n \t\tstatus = RA_NOMATCH;\n \t    else if (rex.reg_line_lbr)\n \t\tADVANCE_REGINPUT();\n \t    else\n \t\treg_nextline();\n \t    break;\n \n \t  case END:\n \t    status = RA_MATCH;\n \t    break;\n \n \t  default:\n \t    iemsg(_(e_corrupted_regexp_program));\n #ifdef DEBUG\n \t    printf(\"Illegal op code %d\\n\", op);\n #endif\n \t    status = RA_FAIL;\n \t    break;\n \t  }\n \t}\n \n \tif (status != RA_CONT)\n \t    break;\n \n \tscan = next;\n \n     }\n \n     while (regstack.ga_len > 0 && status != RA_FAIL)\n     {\n \trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n \tswitch (rp->rs_state)\n \t{\n \t  case RS_NOPEN:\n \t    regstack_pop(&scan);\n \t    break;\n \n \t  case RS_MOPEN:\n \t    if (status == RA_NOMATCH)\n \t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n \t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n \t    regstack_pop(&scan);\n \t    break;\n \n #ifdef FEAT_SYN_HL\n \t  case RS_ZOPEN:\n \t    if (status == RA_NOMATCH)\n \t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n \t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n \t    regstack_pop(&scan);\n \t    break;\n #endif\n \n \t  case RS_MCLOSE:\n \t    if (status == RA_NOMATCH)\n \t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n \t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n \t    regstack_pop(&scan);\n \t    break;\n \n #ifdef FEAT_SYN_HL\n \t  case RS_ZCLOSE:\n \t    if (status == RA_NOMATCH)\n \t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n \t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n \t    regstack_pop(&scan);\n \t    break;\n #endif\n \n \t  case RS_BRANCH:\n \t    if (status == RA_MATCH)\n \t\tregstack_pop(&scan);\n \t    else\n \t    {\n \t\tif (status != RA_BREAK)\n \t\t{\n \t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n \t\t    scan = rp->rs_scan;\n \t\t}\n \t\tif (scan == NULL || OP(scan) != BRANCH)\n \t\t{\n \t\t    status = RA_NOMATCH;\n \t\t    regstack_pop(&scan);\n \t\t}\n \t\telse\n \t\t{\n \t\t    rp->rs_scan = regnext(scan);\n \t\t    reg_save(&rp->rs_un.regsave, &backpos);\n \t\t    scan = OPERAND(scan);\n \t\t}\n \t    }\n \t    break;\n \n \t  case RS_BRCPLX_MORE:\n \t    if (status == RA_NOMATCH)\n \t    {\n \t\treg_restore(&rp->rs_un.regsave, &backpos);\n \t\t--brace_count[rp->rs_no];\n \t    }\n \t    regstack_pop(&scan);\n \t    break;\n \n \t  case RS_BRCPLX_LONG:\n \t    if (status == RA_NOMATCH)\n \t    {\n \t\treg_restore(&rp->rs_un.regsave, &backpos);\n \t\t--brace_count[rp->rs_no];\n \t\tstatus = RA_CONT;\n \t    }\n \t    regstack_pop(&scan);\n \t    if (status == RA_CONT)\n \t\tscan = regnext(scan);\n \t    break;\n \n \t  case RS_BRCPLX_SHORT:\n \t    if (status == RA_NOMATCH)\n \t\treg_restore(&rp->rs_un.regsave, &backpos);\n \t    regstack_pop(&scan);\n \t    if (status == RA_NOMATCH)\n \t    {\n \t\tscan = OPERAND(scan);\n \t\tstatus = RA_CONT;\n \t    }\n \t    break;\n \n \t  case RS_NOMATCH:\n \t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n \t\tstatus = RA_NOMATCH;\n \t    else\n \t    {\n \t\tstatus = RA_CONT;\n \t\tif (rp->rs_no != SUBPAT)\n \t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n \t    }\n \t    regstack_pop(&scan);\n \t    if (status == RA_CONT)\n \t\tscan = regnext(scan);\n \t    break;\n \n \t  case RS_BEHIND1:\n \t    if (status == RA_NOMATCH)\n \t    {\n \t\tregstack_pop(&scan);\n \t\tregstack.ga_len -= sizeof(regbehind_T);\n \t    }\n \t    else\n \t    {\n \n \t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n \n \t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n \t\tbehind_pos = rp->rs_un.regsave;\n \n \t\trp->rs_state = RS_BEHIND2;\n", "target": "// fix_start\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n// fix_end\n// fix_start\n\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-1154", "cve_desc": "Use after free in utf_ptr2char in GitHub repository vim/vim prior to 8.2.4646.", "project": "vim", "idx": 201885}
{"source": " set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n     mode_t mode, unsigned long set, unsigned long clear)\n {\n \tint\t\t ret;\n \tint\t\t myfd = fd;\n \tint newflags, oldflags;\n \tconst int sf_mask = 0\n #if defined(FS_IMMUTABLE_FL)\n \t    | FS_IMMUTABLE_FL\n #elif defined(EXT2_IMMUTABLE_FL)\n \t    | EXT2_IMMUTABLE_FL\n #endif\n #if defined(FS_APPEND_FL)\n \t    | FS_APPEND_FL\n #elif defined(EXT2_APPEND_FL)\n \t    | EXT2_APPEND_FL\n #endif\n #if defined(FS_JOURNAL_DATA_FL)\n \t    | FS_JOURNAL_DATA_FL\n #endif\n \t;\n \n \tif (set == 0 && clear == 0)\n \t\treturn (ARCHIVE_OK);\n \tif (!S_ISREG(mode) && !S_ISDIR(mode))\n \t\treturn (ARCHIVE_OK);\n \n \tif (myfd < 0) {\n// bug_start\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n// bug_end\n \t\t__archive_ensure_cloexec_flag(myfd);\n \t}\n \tif (myfd < 0)\n \t\treturn (ARCHIVE_OK);\n \n \tret = ARCHIVE_OK;\n \n \tif (ioctl(myfd,\n #ifdef FS_IOC_GETFLAGS\n \t    FS_IOC_GETFLAGS,\n #else\n \t    EXT2_IOC_GETFLAGS,\n #endif\n \t    &oldflags) < 0)\n \t\tgoto fail;\n \n \tnewflags = (oldflags & ~clear) | set;\n \tif (ioctl(myfd,\n #ifdef FS_IOC_SETFLAGS\n \t    FS_IOC_SETFLAGS,\n #else\n \t    EXT2_IOC_SETFLAGS,\n #endif\n \t    &newflags) >= 0)\n \t\tgoto cleanup;\n \tif (errno != EPERM)\n \t\tgoto fail;\n \n \tnewflags &= ~sf_mask;\n \toldflags &= sf_mask;\n \tnewflags |= oldflags;\n \tif (ioctl(myfd,\n #ifdef FS_IOC_SETFLAGS\n \t    FS_IOC_SETFLAGS,\n #else\n \t    EXT2_IOC_SETFLAGS,\n #endif\n \t    &newflags) >= 0)\n \t\tgoto cleanup;\n \n fail:\n \tarchive_set_error(&a->archive, errno,\n \t    \"Failed to set file flags\");\n \tret = ARCHIVE_WARN;\n cleanup:\n \tif (fd < 0)\n \t\tclose(myfd);\n \treturn (ret);\n }\n \n", "target": "// fix_start\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY |\n\t\t    O_CLOEXEC | O_NOFOLLOW);\n// fix_end\n", "cwe": "CWE-59", "cwe_name": "Improper Link Resolution Before File Access ('Link Following')", "cve": "CVE-2021-31566", "cve_desc": "An improper link resolution flaw can occur while extracting an archive leading to changing modes, times, access control lists, and flags of a file outside of the archive. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to gain more privileges in a system.", "project": "libarchive", "idx": 201913}
{"source": " *vidtv_s302m_encoder_init(struct vidtv_s302m_encoder_init_args args)\n {\n \tu32 priv_sz = sizeof(struct vidtv_s302m_ctx);\n \tstruct vidtv_s302m_ctx *ctx;\n \tstruct vidtv_encoder *e;\n \n \te = kzalloc(sizeof(*e), GFP_KERNEL);\n \tif (!e)\n \t\treturn NULL;\n \n \te->id = S302M;\n \n \tif (args.name)\n \t\te->name = kstrdup(args.name, GFP_KERNEL);\n \n \te->encoder_buf = vzalloc(VIDTV_S302M_BUF_SZ);\n// bug_start\n// bug_end\n \te->encoder_buf_sz = VIDTV_S302M_BUF_SZ;\n \te->encoder_buf_offset = 0;\n \n \te->sample_count = 0;\n \n \te->src_buf = (args.src_buf) ? args.src_buf : NULL;\n \te->src_buf_sz = (args.src_buf) ? args.src_buf_sz : 0;\n \te->src_buf_offset = 0;\n \n \te->is_video_encoder = false;\n \n \tctx = kzalloc(priv_sz, GFP_KERNEL);\n// bug_start\n\tif (!ctx) {\n\t\tkfree(e);\n\t\treturn NULL;\n\t}\n// bug_end\n \n \te->ctx = ctx;\n \tctx->last_duration = 0;\n \n \te->encode = vidtv_s302m_encode;\n \te->clear = vidtv_s302m_clear;\n \n \te->es_pid = cpu_to_be16(args.es_pid);\n \te->stream_id = cpu_to_be16(PES_PRIVATE_STREAM_1);\n \n \te->sync = args.sync;\n \te->sampling_rate_hz = S302M_SAMPLING_RATE_HZ;\n \n \te->last_sample_cb = args.last_sample_cb;\n \n \te->destroy = vidtv_s302m_encoder_destroy;\n \n \tif (args.head) {\n \t\twhile (args.head->next)\n \t\t\targs.head = args.head->next;\n \n \t\targs.head->next = e;\n \t}\n \n \te->next = NULL;\n \n \treturn e;\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n\tif (!e->encoder_buf)\n\t\tgoto out_kfree_e;\n\n// fix_end\n// fix_start\n\tif (!ctx)\n\t\tgoto out_kfree_buf;\n// fix_end\n// fix_start\n\nout_kfree_buf:\n\tkfree(e->encoder_buf);\n\nout_kfree_e:\n\tkfree(e->name);\n\tkfree(e);\n\treturn NULL;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-3078", "cve_desc": "An issue was discovered in the Linux kernel through 5.16-rc6. There is a lack of check after calling vzalloc() and lack of free after allocation in drivers/media/test-drivers/vidtv/vidtv_s302m.c.", "project": "linux", "idx": 201925}
{"source": " do_put(\n     int\t\tregname,\n     char_u\t*expr_result,\n     int\t\tdir,\n     long\tcount,\n     int\t\tflags)\n {\n     char_u\t*ptr;\n     char_u\t*newp, *oldp;\n     int\t\tyanklen;\n     int\t\ttotlen = 0;\n     linenr_T\tlnum;\n     colnr_T\tcol;\n     long\ti;\n     int\t\ty_type;\n     long\ty_size;\n     int\t\toldlen;\n     long\ty_width = 0;\n     colnr_T\tvcol;\n     int\t\tdelcount;\n     int\t\tincr = 0;\n     long\tj;\n     struct block_def bd;\n     char_u\t**y_array = NULL;\n     yankreg_T\t*y_current_used = NULL;\n     long\tnr_lines = 0;\n     pos_T\tnew_cursor;\n     int\t\tindent;\n     int\t\torig_indent = 0;\n     int\t\tindent_diff = 0;\n     int\t\tfirst_indent = TRUE;\n     int\t\tlendiff = 0;\n     pos_T\told_pos;\n     char_u\t*insert_string = NULL;\n     int\t\tallocated = FALSE;\n     long\tcnt;\n     pos_T\torig_start = curbuf->b_op_start;\n     pos_T\torig_end = curbuf->b_op_end;\n     unsigned int cur_ve_flags = get_ve_flags();\n \n #ifdef FEAT_CLIPBOARD\n     adjust_clip_reg(&regname);\n     (void)may_get_selection(regname);\n #endif\n \n     if (flags & PUT_FIXINDENT)\n \torig_indent = get_indent();\n \n     curbuf->b_op_start = curwin->w_cursor;\n     curbuf->b_op_end = curwin->w_cursor;\n \n     if (regname == '.')\n     {\n \tif (VIsual_active)\n \t    stuffcharReadbuff(VIsual_mode);\n \t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n \t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n \tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n \t    stuffcharReadbuff('l');\n \treturn;\n     }\n \n     if (regname == '=' && expr_result != NULL)\n \tinsert_string = expr_result;\n     else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n \t\t&& insert_string == NULL)\n \treturn;\n \n     if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n \tgoto end;\n \n     if (insert_string != NULL)\n     {\n \ty_type = MCHAR;\n #ifdef FEAT_EVAL\n \tif (regname == '=')\n \t{\n \t    for (;;)\n \t    {\n \t\ty_size = 0;\n \t\tptr = insert_string;\n \t\twhile (ptr != NULL)\n \t\t{\n \t\t    if (y_array != NULL)\n \t\t\ty_array[y_size] = ptr;\n \t\t    ++y_size;\n \t\t    ptr = vim_strchr(ptr, '\\n');\n \t\t    if (ptr != NULL)\n \t\t    {\n \t\t\tif (y_array != NULL)\n \t\t\t    *ptr = NUL;\n \t\t\t++ptr;\n \t\t\tif (*ptr == NUL)\n \t\t\t{\n \t\t\t    y_type = MLINE;\n \t\t\t    break;\n \t\t\t}\n \t\t    }\n \t\t}\n \t\tif (y_array != NULL)\n \t\t    break;\n \t\ty_array = ALLOC_MULT(char_u *, y_size);\n \t\tif (y_array == NULL)\n \t\t    goto end;\n \t    }\n \t}\n \telse\n #endif\n \t{\n \t    y_size = 1;\n \t    y_array = &insert_string;\n \t}\n     }\n     else\n     {\n \tget_yank_register(regname, FALSE);\n \n \ty_type = y_current->y_type;\n \ty_width = y_current->y_width;\n \ty_size = y_current->y_size;\n \ty_array = y_current->y_array;\n \ty_current_used = y_current;\n     }\n \n     if (y_type == MLINE)\n     {\n \tif (flags & PUT_LINE_SPLIT)\n \t{\n \t    char_u *p;\n \n \t    if (u_save_cursor() == FAIL)\n \t\tgoto end;\n \t    p = ml_get_cursor();\n \t    if (dir == FORWARD && *p != NUL)\n \t\tMB_PTR_ADV(p);\n \t    ptr = vim_strsave(p);\n \t    if (ptr == NULL)\n \t\tgoto end;\n \t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n \t    vim_free(ptr);\n \n \t    oldp = ml_get_curline();\n \t    p = oldp + curwin->w_cursor.col;\n \t    if (dir == FORWARD && *p != NUL)\n \t\tMB_PTR_ADV(p);\n \t    ptr = vim_strnsave(oldp, p - oldp);\n \t    if (ptr == NULL)\n \t\tgoto end;\n \t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n \t    ++nr_lines;\n \t    dir = FORWARD;\n \t}\n \tif (flags & PUT_LINE_FORWARD)\n \t{\n \t    curwin->w_cursor = curbuf->b_visual.vi_end;\n \t    dir = FORWARD;\n \t}\n \tcurbuf->b_op_start = curwin->w_cursor;\n \tcurbuf->b_op_end = curwin->w_cursor;\n     }\n \n     if (flags & PUT_LINE)\n \ty_type = MLINE;\n \n     if (y_size == 0 || y_array == NULL)\n     {\n \tsemsg(_(e_nothing_in_register_str),\n \t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n \tgoto end;\n     }\n \n     if (y_type == MBLOCK)\n     {\n \tlnum = curwin->w_cursor.lnum + y_size + 1;\n \tif (lnum > curbuf->b_ml.ml_line_count)\n \t    lnum = curbuf->b_ml.ml_line_count + 1;\n \tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n \t    goto end;\n     }\n     else if (y_type == MLINE)\n     {\n \tlnum = curwin->w_cursor.lnum;\n #ifdef FEAT_FOLDING\n \tif (dir == BACKWARD)\n \t    (void)hasFolding(lnum, &lnum, NULL);\n \telse\n \t    (void)hasFolding(lnum, NULL, &lnum);\n #endif\n \tif (dir == FORWARD)\n \t    ++lnum;\n \tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n \t    goto end;\n #ifdef FEAT_FOLDING\n \tif (dir == FORWARD)\n \t    curwin->w_cursor.lnum = lnum - 1;\n \telse\n \t    curwin->w_cursor.lnum = lnum;\n \tcurbuf->b_op_start = curwin->w_cursor;\n #endif\n     }\n     else if (u_save_cursor() == FAIL)\n \tgoto end;\n \n     yanklen = (int)STRLEN(y_array[0]);\n \n     if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n     {\n \tif (gchar_cursor() == TAB)\n \t{\n \t    int viscol = getviscol();\n \t    int ts = curbuf->b_p_ts;\n \n \t    if (dir == FORWARD ?\n #ifdef FEAT_VARTABS\n \t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n #else\n \t\t    ts - (viscol % ts) != 1\n #endif\n \t\t    : curwin->w_cursor.coladd > 0)\n \t\tcoladvance_force(viscol);\n \t    else\n \t\tcurwin->w_cursor.coladd = 0;\n \t}\n \telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n \t    coladvance_force(getviscol() + (dir == FORWARD));\n     }\n \n     lnum = curwin->w_cursor.lnum;\n     col = curwin->w_cursor.col;\n \n     if (y_type == MBLOCK)\n     {\n \tint\tc = gchar_cursor();\n \tcolnr_T\tendcol2 = 0;\n \n \tif (dir == FORWARD && c != NUL)\n \t{\n \t    if (cur_ve_flags == VE_ALL)\n \t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n \t    else\n \t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n \n \t    if (has_mbyte)\n \t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n \t    else\n \t    if (c != TAB || cur_ve_flags != VE_ALL)\n \t\t++curwin->w_cursor.col;\n \t    ++col;\n \t}\n \telse\n \t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n \n \tcol += curwin->w_cursor.coladd;\n \tif (cur_ve_flags == VE_ALL\n \t\t&& (curwin->w_cursor.coladd > 0\n \t\t    || endcol2 == curwin->w_cursor.col))\n \t{\n \t    if (dir == FORWARD && c == NUL)\n \t\t++col;\n \t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n \t\t++curwin->w_cursor.col;\n \t    if (c == TAB)\n \t    {\n \t\tif (dir == BACKWARD && curwin->w_cursor.col)\n \t\t    curwin->w_cursor.col--;\n \t\tif (dir == FORWARD && col - 1 == endcol2)\n \t\t    curwin->w_cursor.col++;\n \t    }\n \t}\n \tcurwin->w_cursor.coladd = 0;\n \tbd.textcol = 0;\n \tfor (i = 0; i < y_size; ++i)\n \t{\n \t    int spaces = 0;\n \t    char shortline;\n \n \t    bd.startspaces = 0;\n \t    bd.endspaces = 0;\n \t    vcol = 0;\n \t    delcount = 0;\n \n \t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n \t    {\n \t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n \t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n \t\t    break;\n \t\t++nr_lines;\n \t    }\n \t    oldp = ml_get_curline();\n \t    oldlen = (int)STRLEN(oldp);\n \t    for (ptr = oldp; vcol < col && *ptr; )\n \t    {\n \t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n \t\tvcol += incr;\n \t    }\n \t    bd.textcol = (colnr_T)(ptr - oldp);\n \n \t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n \n \t    if (vcol < col)\n \t\tbd.startspaces = col - vcol;\n \t    else if (vcol > col)\n \t    {\n \t\tbd.endspaces = vcol - col;\n \t\tbd.startspaces = incr - bd.endspaces;\n \t\t--bd.textcol;\n \t\tdelcount = 1;\n \t\tif (has_mbyte)\n \t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n \t\tif (oldp[bd.textcol] != TAB)\n \t\t{\n \t\t    delcount = 0;\n \t\t    bd.endspaces = 0;\n \t\t}\n \t    }\n \n \t    yanklen = (int)STRLEN(y_array[i]);\n \n \t    if ((flags & PUT_BLOCK_INNER) == 0)\n \t    {\n \t\tspaces = y_width + 1;\n \t\tfor (j = 0; j < yanklen; j++)\n \t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n \t\tif (spaces < 0)\n \t\t    spaces = 0;\n \t    }\n \n \t    if (yanklen + spaces != 0\n \t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n \t\t\t\t\t\t\t/ (yanklen + spaces)))\n \t    {\n \t\temsg(_(e_resulting_text_too_long));\n \t\tbreak;\n \t    }\n \n \t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n \t    newp = alloc(totlen + oldlen + 1);\n \t    if (newp == NULL)\n \t\tbreak;\n \n \t    ptr = newp;\n \t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n \t    ptr += bd.textcol;\n \n \t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n \t    ptr += bd.startspaces;\n \n \t    for (j = 0; j < count; ++j)\n \t    {\n \t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n \t\tptr += yanklen;\n \n \t\tif ((j < count - 1 || !shortline) && spaces)\n \t\t{\n \t\t    vim_memset(ptr, ' ', (size_t)spaces);\n \t\t    ptr += spaces;\n \t\t}\n// bug_start\n// bug_end\n \t    }\n \n \t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n \t    ptr += bd.endspaces;\n \n \t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n \t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n \t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n \n \t    ++curwin->w_cursor.lnum;\n \t    if (i == 0)\n \t\tcurwin->w_cursor.col += bd.startspaces;\n \t}\n \n \tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n \n \tcurbuf->b_op_start = curwin->w_cursor;\n \tcurbuf->b_op_start.lnum = lnum;\n \n \tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n \tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n \tcurbuf->b_op_end.coladd = 0;\n \tif (flags & PUT_CURSEND)\n \t{\n \t    colnr_T len;\n \n \t    curwin->w_cursor = curbuf->b_op_end;\n \t    curwin->w_cursor.col++;\n \n \t    len = (colnr_T)STRLEN(ml_get_curline());\n \t    if (curwin->w_cursor.col > len)\n \t\tcurwin->w_cursor.col = len;\n \t}\n \telse\n \t    curwin->w_cursor.lnum = lnum;\n     }\n     else\n     {\n \tif (y_type == MCHAR)\n \t{\n \t    if (dir == FORWARD && gchar_cursor() != NUL)\n \t    {\n \t\tif (has_mbyte)\n \t\t{\n \t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n \n \t\t    col += bytelen;\n \t\t    if (yanklen)\n \t\t    {\n \t\t\tcurwin->w_cursor.col += bytelen;\n \t\t\tcurbuf->b_op_end.col += bytelen;\n \t\t    }\n \t\t}\n \t\telse\n \t\t{\n \t\t    ++col;\n \t\t    if (yanklen)\n \t\t    {\n \t\t\t++curwin->w_cursor.col;\n \t\t\t++curbuf->b_op_end.col;\n \t\t    }\n \t\t}\n \t    }\n \t    curbuf->b_op_start = curwin->w_cursor;\n \t}\n \telse if (dir == BACKWARD)\n \t    --lnum;\n \tnew_cursor = curwin->w_cursor;\n \n \tif (y_type == MCHAR && y_size == 1)\n \t{\n \t    linenr_T\tend_lnum = 0;\n \t    linenr_T\tstart_lnum = lnum;\n \t    int\t\tfirst_byte_off = 0;\n \n \t    if (VIsual_active)\n \t    {\n \t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n \t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n \t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n \t\tif (end_lnum > start_lnum)\n \t\t{\n \t\t    pos_T   pos;\n \n \t\t    pos.lnum = lnum;\n \t\t    pos.col = col;\n \t\t    pos.coladd = 0;\n \t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n \t\t}\n \t    }\n \n \t    if (count == 0 || yanklen == 0)\n \t    {\n \t\tif (VIsual_active)\n \t\t    lnum = end_lnum;\n \t    }\n \t    else if (count > INT_MAX / yanklen)\n \t\temsg(_(e_resulting_text_too_long));\n \t    else\n \t    {\n \t\ttotlen = count * yanklen;\n \t\tdo {\n \t\t    oldp = ml_get(lnum);\n \t\t    oldlen = (int)STRLEN(oldp);\n \t\t    if (lnum > start_lnum)\n \t\t    {\n \t\t\tpos_T   pos;\n \n \t\t\tpos.lnum = lnum;\n \t\t\tif (getvpos(&pos, vcol) == OK)\n \t\t\t    col = pos.col;\n \t\t\telse\n \t\t\t    col = MAXCOL;\n \t\t    }\n \t\t    if (VIsual_active && col > oldlen)\n \t\t    {\n \t\t\tlnum++;\n \t\t\tcontinue;\n \t\t    }\n \t\t    newp = alloc(totlen + oldlen + 1);\n \t\t    if (newp == NULL)\n \t\t\tgoto end;\n \t\t    mch_memmove(newp, oldp, (size_t)col);\n \t\t    ptr = newp + col;\n \t\t    for (i = 0; i < count; ++i)\n \t\t    {\n \t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n \t\t\tptr += yanklen;\n \t\t    }\n \t\t    STRMOVE(ptr, oldp + col);\n \t\t    ml_replace(lnum, newp, FALSE);\n \n \t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n \n \t\t    if (lnum == curwin->w_cursor.lnum)\n \t\t    {\n \t\t\tchanged_cline_bef_curs();\n \t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n \t\t    }\n \t\t    if (VIsual_active)\n \t\t\tlnum++;\n \t\t} while (VIsual_active && lnum <= end_lnum);\n \n \t\tif (VIsual_active)\n \t\t    lnum--;\n \t    }\n \n \t    curbuf->b_op_end = curwin->w_cursor;\n \t    curbuf->b_op_end.col -= first_byte_off;\n \n \t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n \t\t++curwin->w_cursor.col;\n \t    else\n \t\tcurwin->w_cursor.col -= first_byte_off;\n \t    changed_bytes(lnum, col);\n \t}\n \telse\n \t{\n \t    linenr_T\tnew_lnum = new_cursor.lnum;\n \t    size_t\tlen;\n \n \t    for (cnt = 1; cnt <= count; ++cnt)\n \t    {\n \t\ti = 0;\n \t\tif (y_type == MCHAR)\n \t\t{\n \t\t    lnum = new_cursor.lnum;\n \t\t    ptr = ml_get(lnum) + col;\n \t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n \t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n \t\t    if (newp == NULL)\n \t\t\tgoto error;\n \t\t    STRCPY(newp, y_array[y_size - 1]);\n \t\t    STRCAT(newp, ptr);\n \t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n \t\t    ++new_lnum;\n \t\t    vim_free(newp);\n \n \t\t    oldp = ml_get(lnum);\n \t\t    newp = alloc(col + yanklen + 1);\n \t\t    if (newp == NULL)\n \t\t\tgoto error;\n \t\t    mch_memmove(newp, oldp, (size_t)col);\n \t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n \t\t    ml_replace(lnum, newp, FALSE);\n \n \t\t    curwin->w_cursor.lnum = lnum;\n \t\t    i = 1;\n \t\t}\n \n \t\tfor (; i < y_size; ++i)\n \t\t{\n \t\t    if (y_type != MCHAR || i < y_size - 1)\n \t\t    {\n \t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n \t\t\t\t\t\t\t\t      == FAIL)\n \t\t\t    goto error;\n \t\t\tnew_lnum++;\n \t\t    }\n \t\t    lnum++;\n \t\t    ++nr_lines;\n \t\t    if (flags & PUT_FIXINDENT)\n \t\t    {\n \t\t\told_pos = curwin->w_cursor;\n \t\t\tcurwin->w_cursor.lnum = lnum;\n \t\t\tptr = ml_get(lnum);\n \t\t\tif (cnt == count && i == y_size - 1)\n \t\t\t    lendiff = (int)STRLEN(ptr);\n \t\t\tif (*ptr == '#' && preprocs_left())\n \t\t\t    indent = 0;\n \t\t\telse\n \t\t\t     if (*ptr == NUL)\n \t\t\t    indent = 0;\n \t\t\telse if (first_indent)\n \t\t\t{\n \t\t\t    indent_diff = orig_indent - get_indent();\n \t\t\t    indent = orig_indent;\n \t\t\t    first_indent = FALSE;\n \t\t\t}\n \t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n \t\t\t    indent = 0;\n \t\t\t(void)set_indent(indent, 0);\n \t\t\tcurwin->w_cursor = old_pos;\n \t\t\tif (cnt == count && i == y_size - 1)\n \t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n \t\t    }\n \t\t}\n \t\tif (cnt == 1)\n \t\t    new_lnum = lnum;\n \t    }\n \n error:\n \t    if (y_type == MLINE)\n \t    {\n \t\tcurbuf->b_op_start.col = 0;\n \t\tif (dir == FORWARD)\n \t\t    curbuf->b_op_start.lnum++;\n \t    }\n \t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n \t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n #ifdef FEAT_DIFF\n \t\t\t\t\t\t || curwin->w_p_diff\n #endif\n \t\t\t\t\t\t )\n \t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n \t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n \n \t    if (y_type == MCHAR)\n \t\tchanged_lines(curwin->w_cursor.lnum, col,\n \t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n \t    else\n \t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n \t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n \t    if (y_current_used != NULL && (y_current_used != y_current\n \t\t\t\t\t     || y_current->y_array != y_array))\n \t    {\n \t\temsg(_(e_yank_register_changed_while_using_it));\n \t\tgoto end;\n \t    }\n \n \t    curbuf->b_op_end.lnum = new_lnum;\n \t    len = STRLEN(y_array[y_size - 1]);\n \t    col = (colnr_T)len - lendiff;\n \t    if (col > 1)\n \t    {\n \t\tcurbuf->b_op_end.col = col - 1;\n \t\tif (len > 0)\n \t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n \t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n \t    }\n \t    else\n \t\tcurbuf->b_op_end.col = 0;\n \n \t    if (flags & PUT_CURSLINE)\n \t    {\n \t\tcurwin->w_cursor.lnum = lnum;\n \t\tbeginline(BL_WHITE | BL_FIX);\n \t    }\n \t    else if (flags & PUT_CURSEND)\n \t    {\n \t\tif (y_type == MLINE)\n \t\t{\n \t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n \t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n \t\t    else\n \t\t\tcurwin->w_cursor.lnum = lnum + 1;\n \t\t    curwin->w_cursor.col = 0;\n \t\t}\n \t\telse\n \t\t{\n \t\t    curwin->w_cursor.lnum = new_lnum;\n \t\t    curwin->w_cursor.col = col;\n \t\t    curbuf->b_op_end = curwin->w_cursor;\n \t\t    if (col > 1)\n \t\t\tcurbuf->b_op_end.col = col - 1;\n \t\t}\n \t    }\n \t    else if (y_type == MLINE)\n \t    {\n \t\tcurwin->w_cursor.col = 0;\n \t\tif (dir == FORWARD)\n \t\t    ++curwin->w_cursor.lnum;\n \t\tbeginline(BL_WHITE | BL_FIX);\n \t    }\n \t    else\n \t\tcurwin->w_cursor = new_cursor;\n \t}\n     }\n \n     msgmore(nr_lines);\n     curwin->w_set_curswant = TRUE;\n \n end:\n     if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n     {\n \tcurbuf->b_op_start = orig_start;\n \tcurbuf->b_op_end = orig_end;\n     }\n     if (allocated)\n \tvim_free(insert_string);\n     if (regname == '=')\n \tvim_free(y_array);\n \n     VIsual_active = FALSE;\n \n     adjust_cursor_eol();\n }\n \n", "target": "// fix_start\n\t\telse\n\t\t    totlen -= spaces;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2264", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.", "project": "vim", "idx": 202081}
{"source": " R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n \tRBinJavaBootStrapMethod *bsm = NULL;\n \tut64 offset = 0;\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n \toffset += 6;\n \tif (attr) {\n \t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n// bug_start\n// bug_end\n \t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n \t\toffset += 2;\n \t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n \t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n \t\t\tif (offset >= sz) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n \t\t\tif (bsm) {\n \t\t\t\toffset += bsm->size;\n \t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n \t\t\t} else {\n \t\t\t}\n \t\t}\n \t\tattr->size = offset;\n \t}\n \treturn attr;\n }\n \n", "target": "// fix_start\n\t\tif (offset + 8 > sz)  {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-1452", "cve_desc": "Out-of-bounds Read in r_bin_java_bootstrap_methods_attr_new function in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end 2f the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. More details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).", "project": "radare2", "idx": 202082}
{"source": " _inplace_src_spans (void *abstract_renderer, int y, int h,\n \t\t    const cairo_half_open_span_t *spans,\n \t\t    unsigned num_spans)\n {\n     cairo_image_span_renderer_t *r = abstract_renderer;\n// bug_start\n    uint8_t *m;\n// bug_end\n     int x0;\n \n     if (num_spans == 0)\n \treturn CAIRO_STATUS_SUCCESS;\n \n     x0 = spans[0].x;\n// bug_start\n    m = r->_buf;\n// bug_end\n     do {\n \tint len = spans[1].x - spans[0].x;\n \tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n \t    if (spans[0].x != x0) {\n #if PIXMAN_HAS_OP_LERP\n \t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n \t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n \t\t\t\t\t  x0 + r->u.composite.src_x,\n \t\t\t\t\t  y + r->u.composite.src_y,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  x0, y,\n \t\t\t\t\t  spans[0].x - x0, h);\n #else\n \t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n \t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  x0, y,\n \t\t\t\t\t  spans[0].x - x0, h);\n \t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n \t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n \t\t\t\t\t  x0 + r->u.composite.src_x,\n \t\t\t\t\t  y + r->u.composite.src_y,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  x0, y,\n \t\t\t\t\t  spans[0].x - x0, h);\n #endif\n \t    }\n \n \t    pixman_image_composite32 (PIXMAN_OP_SRC,\n \t\t\t\t      r->src, NULL, r->u.composite.dst,\n \t\t\t\t      spans[0].x + r->u.composite.src_x,\n \t\t\t\t      y + r->u.composite.src_y,\n \t\t\t\t      0, 0,\n \t\t\t\t      spans[0].x, y,\n \t\t\t\t      spans[1].x - spans[0].x, h);\n \n// bug_start\n\t    m = r->_buf;\n// bug_end\n \t    x0 = spans[1].x;\n \t} else if (spans[0].coverage == 0x0) {\n \t    if (spans[0].x != x0) {\n #if PIXMAN_HAS_OP_LERP\n \t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n \t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n \t\t\t\t\t  x0 + r->u.composite.src_x,\n \t\t\t\t\t  y + r->u.composite.src_y,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  x0, y,\n \t\t\t\t\t  spans[0].x - x0, h);\n #else\n \t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n \t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  x0, y,\n \t\t\t\t\t  spans[0].x - x0, h);\n \t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n \t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n \t\t\t\t\t  x0 + r->u.composite.src_x,\n \t\t\t\t\t  y + r->u.composite.src_y,\n \t\t\t\t\t  0, 0,\n \t\t\t\t\t  x0, y,\n \t\t\t\t\t  spans[0].x - x0, h);\n #endif\n \t    }\n \n// bug_start\n\t    m = r->_buf;\n// bug_end\n \t    x0 = spans[1].x;\n \t} else {\n \t    *m++ = spans[0].coverage;\n \t    if (len > 1) {\n \t\tmemset (m, spans[0].coverage, --len);\n \t\tm += len;\n \t    }\n \t}\n \tspans++;\n     } while (--num_spans > 1);\n \n     if (spans[0].x != x0) {\n #if PIXMAN_HAS_OP_LERP\n \tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n \t\t\t\t  r->src, r->mask, r->u.composite.dst,\n \t\t\t\t  x0 + r->u.composite.src_x,\n \t\t\t\t  y + r->u.composite.src_y,\n \t\t\t\t  0, 0,\n \t\t\t\t  x0, y,\n \t\t\t\t  spans[0].x - x0, h);\n #else\n \tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n \t\t\t\t  r->mask, NULL, r->u.composite.dst,\n \t\t\t\t  0, 0,\n \t\t\t\t  0, 0,\n \t\t\t\t  x0, y,\n \t\t\t\t  spans[0].x - x0, h);\n \tpixman_image_composite32 (PIXMAN_OP_ADD,\n \t\t\t\t  r->src, r->mask, r->u.composite.dst,\n \t\t\t\t  x0 + r->u.composite.src_x,\n \t\t\t\t  y + r->u.composite.src_y,\n \t\t\t\t  0, 0,\n \t\t\t\t  x0, y,\n \t\t\t\t  spans[0].x - x0, h);\n #endif\n     }\n \n     return CAIRO_STATUS_SUCCESS;\n }\n \n", "target": "// fix_start\n    uint8_t *m, *base = (uint8_t*)pixman_image_get_data(r->mask);\n// fix_end\n// fix_start\n    m = base;\n// fix_end\n// fix_start\n\t    m = base;\n// fix_end\n// fix_start\n\t    m = base;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-35492", "cve_desc": "A flaw was found in cairo's image-compositor.c in all versions prior to 1.17.4. This flaw allows an attacker who can provide a crafted input file to cairo's image-compositor (for example, by convincing a user to open a file in an application using cairo, or if an application uses cairo on untrusted input) to cause a stack buffer overflow -> out-of-bounds WRITE. The highest impact from this vulnerability is to confidentiality, integrity, as well as system availability.", "project": "cairo", "idx": 202125}
{"source": " void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n {\n #ifdef QT_DEBUG_DRAW\n     qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n #endif\n \n     Q_D(QPaintEngineEx);\n \n     if (path.isEmpty())\n         return;\n \n     if (!d->strokeHandler) {\n         d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n         d->stroker.setMoveToHook(qpaintengineex_moveTo);\n         d->stroker.setLineToHook(qpaintengineex_lineTo);\n         d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n     }\n \n     QRectF clipRect;\n     QPen pen = inPen;\n     if (pen.style() > Qt::SolidLine) {\n         QRectF cpRect = path.controlPointRect();\n         const QTransform &xf = state()->matrix;\n         if (pen.isCosmetic()) {\n             clipRect = d->exDeviceRect;\n             cpRect.translate(xf.dx(), xf.dy());\n         } else {\n             clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n         }\n         QRectF extentRect = cpRect & clipRect;\n         qreal extent = qMax(extentRect.width(), extentRect.height());\n         qreal patternLength = 0;\n         const QList<qreal> pattern = pen.dashPattern();\n         const int patternSize = qMin(pattern.size(), 32);\n         for (int i = 0; i < patternSize; i++)\n             patternLength += qMax(pattern.at(i), qreal(0));\n         if (pen.widthF())\n             patternLength *= pen.widthF();\n         if (qFuzzyIsNull(patternLength)) {\n             pen.setStyle(Qt::NoPen);\n// bug_start\n        } else if (extent / patternLength > 10000) {\n// bug_end\n             pen.setStyle(Qt::SolidLine);\n             QColor color(pen.color());\n             color.setAlpha(color.alpha() / 2);\n             pen.setColor(color);\n         }\n     }\n \n     if (!qpen_fast_equals(pen, d->strokerPen)) {\n         d->strokerPen = pen;\n         d->stroker.setJoinStyle(pen.joinStyle());\n         d->stroker.setCapStyle(pen.capStyle());\n         d->stroker.setMiterLimit(pen.miterLimit());\n         qreal penWidth = pen.widthF();\n         if (penWidth == 0)\n             d->stroker.setStrokeWidth(1);\n         else\n             d->stroker.setStrokeWidth(penWidth);\n \n         Qt::PenStyle style = pen.style();\n         if (style == Qt::SolidLine) {\n             d->activeStroker = &d->stroker;\n         } else if (style == Qt::NoPen) {\n             d->activeStroker = nullptr;\n         } else {\n             d->dasher.setDashPattern(pen.dashPattern());\n             d->dasher.setDashOffset(pen.dashOffset());\n             d->activeStroker = &d->dasher;\n         }\n     }\n \n     if (!d->activeStroker) {\n         return;\n     }\n \n     if (!clipRect.isNull())\n         d->activeStroker->setClipRect(clipRect);\n \n     if (d->activeStroker == &d->stroker)\n         d->stroker.setForceOpen(path.hasExplicitOpen());\n \n     const QPainterPath::ElementType *types = path.elements();\n     const qreal *points = path.points();\n     int pointCount = path.elementCount();\n \n     const qreal *lastPoint = points + (pointCount<<1);\n \n     d->strokeHandler->types.reset();\n     d->strokeHandler->pts.reset();\n \n     uint flags = QVectorPath::WindingFill;\n \n     if (path.elementCount() > 2)\n         flags |= QVectorPath::NonConvexShapeMask;\n \n     if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n         flags |= QVectorPath::CurvedShapeMask;\n \n     if (!pen.isCosmetic()) {\n         d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n         d->activeStroker->begin(d->strokeHandler);\n         if (types) {\n             while (points < lastPoint) {\n                 switch (*types) {\n                 case QPainterPath::MoveToElement:\n                     d->activeStroker->moveTo(points[0], points[1]);\n                     points += 2;\n                     ++types;\n                     break;\n                 case QPainterPath::LineToElement:\n                     d->activeStroker->lineTo(points[0], points[1]);\n                     points += 2;\n                     ++types;\n                     break;\n                 case QPainterPath::CurveToElement:\n                     d->activeStroker->cubicTo(points[0], points[1],\n                                               points[2], points[3],\n                                               points[4], points[5]);\n                     points += 6;\n                     types += 3;\n                     flags |= QVectorPath::CurvedShapeMask;\n                     break;\n                 default:\n                     break;\n                 }\n             }\n             if (path.hasImplicitClose())\n                 d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n \n         } else {\n             d->activeStroker->moveTo(points[0], points[1]);\n             points += 2;\n             while (points < lastPoint) {\n                 d->activeStroker->lineTo(points[0], points[1]);\n                 points += 2;\n             }\n             if (path.hasImplicitClose())\n                 d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n         }\n         d->activeStroker->end();\n \n         if (!d->strokeHandler->types.size())\n             return;\n \n         QVectorPath strokePath(d->strokeHandler->pts.data(),\n                                d->strokeHandler->types.size(),\n                                d->strokeHandler->types.data(),\n                                flags);\n         fill(strokePath, pen.brush());\n     } else {\n         if (state()->matrix.type() >= QTransform::TxProject) {\n             QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n             d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n         } else {\n             d->activeStroker->setCurveThresholdFromTransform(QTransform());\n             d->activeStroker->begin(d->strokeHandler);\n             if (types) {\n                 while (points < lastPoint) {\n                     switch (*types) {\n                     case QPainterPath::MoveToElement: {\n                         QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                         d->activeStroker->moveTo(pt.x(), pt.y());\n                         points += 2;\n                         ++types;\n                         break;\n                     }\n                     case QPainterPath::LineToElement: {\n                         QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                         d->activeStroker->lineTo(pt.x(), pt.y());\n                         points += 2;\n                         ++types;\n                         break;\n                     }\n                     case QPainterPath::CurveToElement: {\n                         QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                         QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                         QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                         d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                         points += 6;\n                         types += 3;\n                         flags |= QVectorPath::CurvedShapeMask;\n                         break;\n                     }\n                     default:\n                         break;\n                     }\n                 }\n                 if (path.hasImplicitClose()) {\n                     QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                     d->activeStroker->lineTo(pt.x(), pt.y());\n                 }\n \n             } else {\n                 QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                 d->activeStroker->moveTo(p.x(), p.y());\n                 points += 2;\n                 while (points < lastPoint) {\n                     QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                     d->activeStroker->lineTo(p.x(), p.y());\n                     points += 2;\n                 }\n                 if (path.hasImplicitClose())\n                     d->activeStroker->lineTo(p.x(), p.y());\n             }\n             d->activeStroker->end();\n         }\n \n         QVectorPath strokePath(d->strokeHandler->pts.data(),\n                                d->strokeHandler->types.size(),\n                                d->strokeHandler->types.data(),\n                                flags);\n \n         QTransform xform = state()->matrix;\n         state()->matrix = QTransform();\n         transformChanged();\n \n         QBrush brush = pen.brush();\n         if (qbrush_style(brush) != Qt::SolidPattern)\n             brush.setTransform(brush.transform() * xform);\n \n         fill(strokePath, brush);\n \n         state()->matrix = xform;\n         transformChanged();\n     }\n }\n \n", "target": "// fix_start\n        } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-38593", "cve_desc": "Qt 5.x before 5.15.6 and 6.x through 6.1.2 has an out-of-bounds write in QOutlineMapper::convertPath (called from QRasterPaintEngine::fill and QPaintEngineEx::stroke).", "project": "qtbase", "idx": 202256}
{"source": " block_insert(\n     oparg_T\t\t*oap,\n     char_u\t\t*s,\n     int\t\t\tb_insert,\n     struct block_def\t*bdp)\n {\n     int\t\tts_val;\n     int\t\tcount = 0;\n     int\t\tspaces = 0;\n     colnr_T\toffset;\n     colnr_T\tstartcol;\n     unsigned\ts_len;\n     char_u\t*newp, *oldp;\n     linenr_T\tlnum;\n     int\t\toldstate = State;\n \n     State = INSERT;\n     s_len = (unsigned)STRLEN(s);\n \n     for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n     {\n \tblock_prep(oap, bdp, lnum, TRUE);\n \tif (bdp->is_short && b_insert)\n \t    continue;\n \n \toldp = ml_get(lnum);\n \n \tif (b_insert)\n \t{\n \t    ts_val = bdp->start_char_vcols;\n \t    spaces = bdp->startspaces;\n \t    if (spaces != 0)\n \t\tcount = ts_val - 1;\n \t    offset = bdp->textcol;\n \t}\n \telse\n \t{\n \t    ts_val = bdp->end_char_vcols;\n \t    if (!bdp->is_short)\n \t    {\n \t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n \t\tif (spaces != 0)\n \t\t    count = ts_val - 1;\n \t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n \t    }\n \t    else\n \t    {\n \t\tif (!bdp->is_MAX)\n \t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n \t\tcount = spaces;\n \t\toffset = bdp->textcol + bdp->textlen;\n \t    }\n \t}\n \n \tif (has_mbyte && spaces > 0)\n// bug_start\n\t{\n\t    int off;\n// bug_end\n \n// bug_start\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t\tspaces -= off;\n\t\tcount -= off;\n\t    }\n\t    else\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset);\n\t\toffset -= off;\n\t    }\n\t}\n// bug_end\n \tif (spaces < 0)\n \t    spaces = 0;\n \n \tnewp = alloc(STRLEN(oldp) + spaces + s_len\n \t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n \t\t\t\t\t\t\t\t  + count + 1);\n \tif (newp == NULL)\n \t    continue;\n \n \tmch_memmove(newp, oldp, (size_t)offset);\n \toldp += offset;\n \n \tvim_memset(newp + offset, ' ', (size_t)spaces);\n \tstartcol = offset + spaces;\n \n \tmch_memmove(newp + startcol, s, (size_t)s_len);\n \toffset += s_len;\n \n \tif (spaces > 0 && !bdp->is_short)\n \t{\n \t    if (*oldp == TAB)\n \t    {\n \t\tvim_memset(newp + offset + spaces, ' ',\n \t\t\t\t\t\t    (size_t)(ts_val - spaces));\n \t\toldp++;\n \t\tcount++;\n \t    }\n \t    else\n \t\tcount = spaces;\n \t}\n \n \tif (spaces > 0)\n \t    offset += count;\n \tSTRMOVE(newp + offset, oldp);\n \n \tml_replace(lnum, newp, FALSE);\n \n \tif (b_insert)\n \t    inserted_bytes(lnum, startcol, s_len);\n \n \tif (lnum == oap->end.lnum)\n \t{\n \t    curbuf->b_op_end.lnum = oap->end.lnum;\n \t    curbuf->b_op_end.col = offset;\n \t}\n     }\n \n     changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n \n     State = oldstate;\n }\n \n", "target": "// fix_start\n\t    offset -= (*mb_head_off)(oldp, oldp + offset);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0318", "cve_desc": "Heap-based Buffer Overflow in vim/vim prior to 8.2.", "project": "vim", "idx": 202276}
{"source": " find_match_text(colnr_T startcol, int regstart, char_u *match_text)\n {\n     colnr_T col = startcol;\n     int\t    c1, c2;\n     int\t    len1, len2;\n     int\t    match;\n \n     for (;;)\n     {\n \tmatch = TRUE;\n \tlen2 = MB_CHAR2LEN(regstart);\n \tfor (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1))\n \t{\n \t    c1 = PTR2CHAR(match_text + len1);\n \t    c2 = PTR2CHAR(rex.line + col + len2);\n \t    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2)))\n \t    {\n \t\tmatch = FALSE;\n \t\tbreak;\n \t    }\n// bug_start\n\t    len2 += MB_CHAR2LEN(c2);\n// bug_end\n \t}\n \tif (match\n \t\t&& !(enc_utf8\n \t\t\t  && utf_iscomposing(PTR2CHAR(rex.line + col + len2))))\n \t{\n \t    cleanup_subexpr();\n \t    if (REG_MULTI)\n \t    {\n \t\trex.reg_startpos[0].lnum = rex.lnum;\n \t\trex.reg_startpos[0].col = col;\n \t\trex.reg_endpos[0].lnum = rex.lnum;\n \t\trex.reg_endpos[0].col = col + len2;\n \t    }\n \t    else\n \t    {\n \t\trex.reg_startp[0] = rex.line + col;\n \t\trex.reg_endp[0] = rex.line + col + len2;\n \t    }\n \t    return 1L;\n \t}\n \n \tcol += MB_CHAR2LEN(regstart);\n \tif (skip_to_start(regstart, &col) == FAIL)\n \t    break;\n     }\n     return 0L;\n }\n \n", "target": "// fix_start\n\t    len2 += enc_utf8 ? utf_ptr2len(rex.line + col + len2)\n\t\t\t\t\t\t\t     : MB_CHAR2LEN(c2);\n// fix_end\n", "cwe": "CWE-122", "cwe_name": "Heap-based Buffer Overflow", "cve": "CVE-2021-3778", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "project": "vim", "idx": 202304}
{"source": " static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n {\n \tunsigned int u = 0;\n \tLineContribType *res;\n \tint overflow_error = 0;\n \n \tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n \tif (!res) {\n \t\treturn NULL;\n \t}\n \tres->WindowSize = windows_size;\n \tres->LineLength = line_length;\n \tif (overflow2(line_length, sizeof(ContributionType))) {\n \t\tgdFree(res);\n \t\treturn NULL;\n \t}\n \tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n \tif (res->ContribRow == NULL) {\n \t\tgdFree(res);\n \t\treturn NULL;\n \t}\n \tfor (u = 0 ; u < line_length ; u++) {\n \t\tif (overflow2(windows_size, sizeof(double))) {\n \t\t\toverflow_error = 1;\n \t\t} else {\n \t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n \t\t}\n \t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n// bug_start\n// bug_end\n \t\t\tu--;\n// bug_start\n\t\t\twhile (u >= 0) {\n\t\t\t\tgdFree(res->ContribRow[u].Weights);\n\t\t\t\tu--;\n// bug_end\n \t\t\t}\n// bug_start\n// bug_end\n \t\t\treturn NULL;\n \t\t}\n \t}\n \treturn res;\n }\n \n", "target": "// fix_start\n\t\t\tunsigned int i;\n// fix_end\n// fix_start\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n// fix_end\n// fix_start\n\t\t\tgdFree(res);\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2016-6207", "cve_desc": "Integer overflow in the _gdContributionsAlloc function in gd_interpolation.c in GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds memory write or memory consumption) via unspecified vectors.", "project": "php-src", "idx": 202392}
{"source": " static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n// bug_start\n\t\tu8 type, u8 code, int offset, __be32 info)\n// bug_end\n {\n// bug_start\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n\t__be16 *p = (__be16 *)(skb->data + offset);\n\tint grehlen = offset + 4;\n// bug_end\n \tstruct ip6_tnl *t;\n// bug_start\n// bug_end\n \t__be16 flags;\n// bug_start\n// bug_end\n \n// bug_start\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n// bug_end\n \t}\n \n// bug_start\n\tif (!pskb_may_pull(skb, grehlen))\n// bug_end\n \t\treturn;\n \tipv6h = (const struct ipv6hdr *)skb->data;\n// bug_start\n\tp = (__be16 *)(skb->data + offset);\n// bug_end\n \n \tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n// bug_start\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n// bug_end\n \tif (!t)\n \t\treturn;\n \n \tswitch (type) {\n \t\t__u32 teli;\n \t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n \t\t__u32 mtu;\n \tcase ICMPV6_DEST_UNREACH:\n \t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n \t\t\t\t    t->parms.name);\n \t\tbreak;\n \tcase ICMPV6_TIME_EXCEED:\n \t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n \t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n \t\t\t\t\t    t->parms.name);\n \t\t}\n \t\tbreak;\n \tcase ICMPV6_PARAMPROB:\n \t\tteli = 0;\n \t\tif (code == ICMPV6_HDR_FIELD)\n \t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n \n \t\tif (teli && teli == be32_to_cpu(info) - 2) {\n \t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n \t\t\tif (tel->encap_limit == 0) {\n \t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n \t\t\t\t\t\t    t->parms.name);\n \t\t\t}\n \t\t} else {\n \t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n \t\t\t\t\t    t->parms.name);\n \t\t}\n \t\tbreak;\n \tcase ICMPV6_PKT_TOOBIG:\n \t\tmtu = be32_to_cpu(info) - offset;\n \t\tif (mtu < IPV6_MIN_MTU)\n \t\t\tmtu = IPV6_MIN_MTU;\n \t\tt->dev->mtu = mtu;\n \t\tbreak;\n \t}\n \n \tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n \t\tt->err_count++;\n \telse\n \t\tt->err_count = 1;\n \tt->err_time = jiffies;\n }\n \n", "target": "// fix_start\n\t\t       u8 type, u8 code, int offset, __be32 info)\n// fix_end\n// fix_start\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n// fix_end\n// fix_start\n\tint key_off = 0;\n// fix_end\n// fix_start\n\t__be32 key;\n// fix_end\n// fix_start\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n// fix_end\n// fix_start\n\tif (!pskb_may_pull(skb, offset + grehlen))\n// fix_end\n// fix_start\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n// fix_end\n// fix_start\n\t\t\t\t key, greh->protocol);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2017-5897", "cve_desc": "The ip6gre_err function in net/ipv6/ip6_gre.c in the Linux kernel allows remote attackers to have unspecified impact via vectors involving GRE flags in an IPv6 packet, which trigger an out-of-bounds access.", "project": "net", "idx": 202659}
{"source": " static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                           Error **errp)\n {\n     BDRVParallelsState *s = bs->opaque;\n     int i;\n     struct parallels_header ph;\n     int ret;\n \n     bs->read_only = 1;\n \n     ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n     if (ret < 0) {\n         goto fail;\n     }\n \n     if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n         (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n         error_setg(errp, \"Image not in Parallels format\");\n         ret = -EINVAL;\n         goto fail;\n     }\n \n     bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n \n     s->tracks = le32_to_cpu(ph.tracks);\n// bug_start\n// bug_end\n \n     s->catalog_size = le32_to_cpu(ph.catalog_entries);\n     if (s->catalog_size > INT_MAX / 4) {\n         error_setg(errp, \"Catalog too large\");\n         ret = -EFBIG;\n         goto fail;\n     }\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n     if (ret < 0) {\n         goto fail;\n     }\n \n     for (i = 0; i < s->catalog_size; i++)\n \tle32_to_cpus(&s->catalog_bitmap[i]);\n \n     qemu_co_mutex_init(&s->lock);\n     return 0;\n \n fail:\n     g_free(s->catalog_bitmap);\n     return ret;\n }\n \n", "target": "// fix_start\n    if (s->tracks == 0) {\n        error_setg(errp, \"Invalid image: Zero sectors per track\");\n        ret = -EINVAL;\n        goto fail;\n    }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2014-0142", "cve_desc": "QEMU, possibly before 2.0.0, allows local users to cause a denial of service (divide-by-zero error and crash) via a zero value in the (1) tracks field to the seek_to_sector function in block/parallels.c or (2) extent_size field in the bochs function in block/bochs.c.", "project": "qemu", "idx": 202677}
{"source": " lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n {\n     gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n \n     int bh = lprn->nBh;\n     int bpl = gdev_mem_bytes_per_scan_line(pdev);\n     int x, y, y0;\n     byte *p;\n     int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n \n     y0 = (r + h - bh) % maxY;\n     for (y = 0; y < bh; y++) {\n         p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n// bug_start\n        for (x = 0; x < lprn->nBw; x++)\n// bug_end\n             if (p[x] != 0)\n                 return 1;\n// bug_start\n// bug_end\n     }\n     return 0;\n }\n \n", "target": "// fix_start\n        for (x = 0; x < lprn->nBw; x++) {\n            if (bx * lprn->nBw + x >= bpl)  break;\n// fix_end\n// fix_start\n        }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-16287", "cve_desc": "A buffer overflow vulnerability in lprn_is_black() in contrib/lips4/gdevlprn.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.", "project": "ghostpdl", "idx": 202688}
{"source": " fname_match(\n     regmatch_T\t*rmp,\n     char_u\t*name,\n     int\t\tignore_case)\n {\n     char_u\t*match = NULL;\n     char_u\t*p;\n \n     if (name != NULL)\n     {\n \trmp->rm_ic = p_fic || ignore_case;\n \tif (vim_regexec(rmp, name, (colnr_T)0))\n \t    match = name;\n// bug_start\n\telse\n// bug_end\n \t{\n \t    p = home_replace_save(NULL, name);\n \t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n \t\tmatch = name;\n \t    vim_free(p);\n \t}\n     }\n \n     return match;\n }\n \n", "target": "// fix_start\n\telse if (rmp->regprog != NULL)\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-1620", "cve_desc": "NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 in GitHub repository vim/vim prior to 8.2.4901. NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 allows attackers to cause a denial of service (application crash) via a crafted input.", "project": "vim", "idx": 202708}
{"source": " struct sctp_chunk *sctp_make_strreset_req(\n \t\t\t\t\tconst struct sctp_association *asoc,\n \t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n \t\t\t\t\tbool out, bool in)\n {\n \t__u16 stream_len = stream_num * sizeof(__u16);\n \tstruct sctp_strreset_outreq outreq;\n \tstruct sctp_strreset_inreq inreq;\n \tstruct sctp_chunk *retval;\n \t__u16 outlen, inlen;\n \n \toutlen = (sizeof(outreq) + stream_len) * out;\n \tinlen = (sizeof(inreq) + stream_len) * in;\n \n// bug_start\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n// bug_end\n \tif (!retval)\n \t\treturn NULL;\n \n \tif (outlen) {\n \t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n \t\toutreq.param_hdr.length = htons(outlen);\n \t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n \t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n \t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n \n \t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n \n \t\tif (stream_len)\n \t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n \t}\n \n \tif (inlen) {\n \t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n \t\tinreq.param_hdr.length = htons(inlen);\n \t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n \n \t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n \n \t\tif (stream_len)\n \t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n \t}\n \n \treturn retval;\n }\n \n", "target": "// fix_start\n\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));\n// fix_end\n", "cwe": "CWE-704", "cwe_name": "Incorrect Type Conversion or Cast", "cve": "CVE-2022-0322", "cve_desc": "A flaw was found in the sctp_make_strreset_req function in net/sctp/sm_make_chunk.c in the SCTP network protocol in the Linux kernel with a local user privilege access. In this flaw, an attempt to use more buffer than is allocated triggers a BUG_ON issue, leading to a denial of service (DOS).", "project": "linux", "idx": 202719}
{"source": " static Image *ReadTGAImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n {\n   Image\n     *image;\n \n   MagickBooleanType\n     status;\n \n   PixelInfo\n     pixel;\n \n   Quantum\n     index;\n \n   register Quantum\n     *q;\n \n   register ssize_t\n     i,\n     x;\n \n   size_t\n     base,\n     flag,\n     offset,\n     real,\n     skip;\n \n   ssize_t\n     count,\n     y;\n \n   TGAInfo\n     tga_info;\n \n   unsigned char\n     j,\n     k,\n     pixels[4],\n     runlength;\n \n   unsigned int\n     alpha_bits;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   count=ReadBlob(image,1,&tga_info.id_length);\n   tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n   tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n   if ((count != 1) ||\n       ((tga_info.image_type != TGAColormap) &&\n        (tga_info.image_type != TGARGB) &&\n        (tga_info.image_type != TGAMonochrome) &&\n        (tga_info.image_type != TGARLEColormap) &&\n        (tga_info.image_type != TGARLERGB) &&\n        (tga_info.image_type != TGARLEMonochrome)) ||\n       (((tga_info.image_type == TGAColormap) ||\n        (tga_info.image_type == TGARLEColormap)) &&\n        (tga_info.colormap_type == 0)))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   tga_info.colormap_index=ReadBlobLSBShort(image);\n   tga_info.colormap_length=ReadBlobLSBShort(image);\n   tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n   tga_info.x_origin=ReadBlobLSBShort(image);\n   tga_info.y_origin=ReadBlobLSBShort(image);\n   tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n   tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n   tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n   tga_info.attributes=(unsigned char) ReadBlobByte(image);\n   if (EOFBlob(image) != MagickFalse)\n     ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n   if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n        (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   image->columns=tga_info.width;\n   image->rows=tga_info.height;\n   alpha_bits=(tga_info.attributes & 0x0FU);\n   image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n     (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n   if ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARLEColormap))\n     image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n       (tga_info.bits_per_pixel <= 16) ? 5 : 8);\n   else\n     image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n       (tga_info.colormap_size <= 16) ? 5 : 8);\n   if ((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGAMonochrome) ||\n       (tga_info.image_type == TGARLEColormap) ||\n       (tga_info.image_type == TGARLEMonochrome))\n     image->storage_class=PseudoClass;\n   image->compression=NoCompression;\n   if ((tga_info.image_type == TGARLEColormap) ||\n       (tga_info.image_type == TGARLEMonochrome) ||\n       (tga_info.image_type == TGARLERGB))\n     image->compression=RLECompression;\n   if (image->storage_class == PseudoClass)\n     {\n       if (tga_info.colormap_type != 0)\n         image->colors=tga_info.colormap_index+tga_info.colormap_length;\n       else\n         {\n           size_t\n             one;\n \n           one=1;\n           image->colors=one << tga_info.bits_per_pixel;\n// bug_start\n// bug_end\n           if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         }\n     }\n   if (tga_info.id_length != 0)\n     {\n       char\n         *comment;\n \n       size_t\n         length;\n \n       length=(size_t) tga_info.id_length;\n       comment=(char *) NULL;\n       if (~length >= (MagickPathExtent-1))\n         comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n           sizeof(*comment));\n       if (comment == (char *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n       comment[tga_info.id_length]='\\0';\n       (void) SetImageProperty(image,\"comment\",comment,exception);\n       comment=DestroyString(comment);\n     }\n   if (tga_info.attributes & (1UL << 4))\n     {\n       if (tga_info.attributes & (1UL << 5))\n         SetImageArtifact(image,\"tga:image-origin\",\"TopRight\");\n       else\n         SetImageArtifact(image,\"tga:image-origin\",\"BottomRight\");\n     }\n   else\n     {\n       if (tga_info.attributes & (1UL << 5))\n         SetImageArtifact(image,\"tga:image-origin\",\"TopLeft\");\n       else\n         SetImageArtifact(image,\"tga:image-origin\",\"BottomLeft\");\n     }\n   if (image_info->ping != MagickFalse)\n     {\n       (void) CloseBlob(image);\n       return(image);\n     }\n   status=SetImageExtent(image,image->columns,image->rows,exception);\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n   pixel.alpha=(MagickRealType) OpaqueAlpha;\n   if (tga_info.colormap_type != 0)\n     {\n       if (image->colors < tga_info.colormap_index)\n         image->colors=tga_info.colormap_index;\n       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n         image->colormap[i]=pixel;\n       for ( ; i < (ssize_t) image->colors; i++)\n       {\n         switch (tga_info.colormap_size)\n         {\n           case 8:\n           default:\n           {\n             pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             pixel.green=pixel.red;\n             pixel.blue=pixel.red;\n             break;\n           }\n           case 15:\n           case 16:\n           {\n             QuantumAny\n               range;\n \n             j=(unsigned char) ReadBlobByte(image);\n             k=(unsigned char) ReadBlobByte(image);\n             range=GetQuantumRange(5UL);\n             pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n               range);\n             pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n               << 3)+(1UL*(j & 0xe0) >> 5),range);\n             pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n             break;\n           }\n           case 24:\n           {\n             pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             break;\n           }\n           case 32:\n           {\n             pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n               ReadBlobByte(image));\n             break;\n           }\n         }\n         image->colormap[i]=pixel;\n       }\n     }\n   base=0;\n   flag=0;\n   skip=MagickFalse;\n   real=0;\n   index=0;\n   runlength=0;\n   offset=0;\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n     real=offset;\n     if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n       real=image->rows-real-1;\n     q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n     if (q == (Quantum *) NULL)\n       break;\n     for (x=0; x < (ssize_t) image->columns; x++)\n     {\n       if ((tga_info.image_type == TGARLEColormap) ||\n           (tga_info.image_type == TGARLERGB) ||\n           (tga_info.image_type == TGARLEMonochrome))\n         {\n           if (runlength != 0)\n             {\n               runlength--;\n               skip=flag != 0;\n             }\n           else\n             {\n               count=ReadBlob(image,1,&runlength);\n               if (count != 1)\n                 ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n               flag=runlength & 0x80;\n               if (flag != 0)\n                 runlength-=128;\n               skip=MagickFalse;\n             }\n         }\n       if (skip == MagickFalse)\n         switch (tga_info.bits_per_pixel)\n         {\n           case 8:\n           default:\n           {\n             index=(Quantum) ReadBlobByte(image);\n             if (tga_info.colormap_type != 0)\n               pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                 (ssize_t) index,exception)];\n             else\n               {\n                 pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                   index);\n                 pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                   index);\n                 pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                   index);\n               }\n             break;\n           }\n           case 15:\n           case 16:\n           {\n             QuantumAny\n               range;\n \n             if (ReadBlob(image,2,pixels) != 2)\n               ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n             j=pixels[0];\n             k=pixels[1];\n             range=GetQuantumRange(5UL);\n             pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n               range);\n             pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n               (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n             pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n             if (image->alpha_trait != UndefinedPixelTrait)\n               pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                 TransparentAlpha : (Quantum) OpaqueAlpha);\n             if (image->storage_class == PseudoClass)\n               index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                 j,exception);\n             break;\n           }\n           case 24:\n           {\n             if (ReadBlob(image,3,pixels) != 3)\n               ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n             pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n             pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n             pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n             break;\n           }\n           case 32:\n           {\n             if (ReadBlob(image,4,pixels) != 4)\n               ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n             pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n             pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n             pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n             pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n             break;\n           }\n         }\n       if (status == MagickFalse)\n         ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n       if (image->storage_class == PseudoClass)\n         SetPixelIndex(image,index,q);\n       SetPixelRed(image,ClampToQuantum(pixel.red),q);\n       SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n       SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n       if (image->alpha_trait != UndefinedPixelTrait)\n         SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n       q+=GetPixelChannels(image);\n     }\n       if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n         offset+=2;\n       else\n         offset++;\n     if (offset >= image->rows)\n       {\n         base++;\n         offset=base;\n       }\n     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       break;\n     if (image->previous == (Image *) NULL)\n       {\n         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n           image->rows);\n         if (status == MagickFalse)\n           break;\n       }\n   }\n   if (EOFBlob(image) != MagickFalse)\n     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n       image->filename);\n   (void) CloseBlob(image);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n          if (image->colors > ((~0UL)/sizeof(*image->colormap)))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n// fix_end\n", "cwe": "CWE-772", "cwe_name": "Missing Release of Resource after Effective Lifetime", "cve": "CVE-2017-11170", "cve_desc": "The ReadTGAImage function in coders\\tga.c in ImageMagick 7.0.5-6 has a memory leak vulnerability that can cause memory exhaustion via invalid colors data in the header of a TGA or VST file.", "project": "ImageMagick", "idx": 202748}
{"source": " static Bigint * Balloc(int k)\n {\n \tint x;\n \tBigint *rv;\n// bug_start\n// bug_end\n \n \t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n \tif ((rv = freelist[k])) {\n \t\tfreelist[k] = rv->next;\n \t} else {\n \t\tx = 1 << k;\n \t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n// bug_start\n// bug_end\n \t\trv->k = k;\n \t\trv->maxwds = x;\n \t}\n \t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n \trv->sign = rv->wds = 0;\n \treturn rv;\n }\n \n", "target": "// fix_start\n\n\tif (k > Kmax) {\n\t\tzend_error(E_ERROR, \"Balloc() allocation exceeds list boundary\");\n\t}\n// fix_end\n// fix_start\n\t\tif (!rv) {\n\t\t\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\t\t\tzend_error(E_ERROR, \"Balloc() failed to allocate memory\");\n\t\t}\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2009-0689", "cve_desc": "Array index error in the (1) dtoa implementation in dtoa.c (aka pdtoa.c) and the (2) gdtoa (aka new dtoa) implementation in gdtoa/misc.c in libc, as used in multiple operating systems and products including in FreeBSD 6.4 and 7.2, NetBSD 5.0, OpenBSD 4.5, Mozilla Firefox 3.0.x before 3.0.15 and 3.5.x before 3.5.4, K-Meleon 1.5.3, SeaMonkey 1.1.8, and other products, allows context-dependent attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a large precision value in the format argument to a printf function, which triggers incorrect memory allocation and a heap-based buffer overflow during conversion to a floating-point number.", "project": "php-src", "idx": 202783}
{"source": " search_impl(i_ctx_t *i_ctx_p, bool forward)\n {\n     os_ptr op = osp;\n     os_ptr op1 = op - 1;\n     uint size = r_size(op);\n     uint count;\n     byte *pat;\n     byte *ptr;\n     byte ch;\n     int incr = forward ? 1 : -1;\n \n     check_read_type(*op1, t_string);\n     check_read_type(*op, t_string);\n     if (size > r_size(op1)) {\n         make_false(op);\n         return 0;\n     }\n     count = r_size(op1) - size;\n     ptr = op1->value.bytes;\n     if (size == 0)\n         goto found;\n     if (!forward)\n         ptr += count;\n     pat = op->value.bytes;\n     ch = pat[0];\n     do {\n         if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n             goto found;\n         ptr += incr;\n     }\n     while (count--);\n     make_false(op);\n     return 0;\n found:\n     op->tas.type_attrs = op1->tas.type_attrs;\n     op->value.bytes = ptr;\n// bug_start\n    r_set_size(op, size);\n// bug_end\n     push(2);\n     op[-1] = *op1;\n// bug_start\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n// bug_end\n     make_true(op);\n     return 0;\n }\n \n", "target": "// fix_start\n    op->tas.rsize = size;\n// fix_end\n// fix_start\n    op[-3].value.bytes = ptr + size;\n    if (forward) {\n        op[-1].tas.rsize = ptr - op[-1].value.bytes;\n        op[-3].tas.rsize = count;\n    } else {\n        op[-1].tas.rsize = count;\n        op[-3].tas.rsize -= count + size;\n    }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-15900", "cve_desc": "A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b.", "project": "ghostpdl", "idx": 202822}
{"source": " int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n {\n \tu8 *tail;\n \tint nfrags;\n \tint esph_offset;\n \tstruct page *page;\n \tstruct sk_buff *trailer;\n \tint tailen = esp->tailen;\n// bug_start\n// bug_end\n \n \tif (x->encap) {\n \t\tint err = esp_output_encap(x, skb, esp);\n \n \t\tif (err < 0)\n \t\t\treturn err;\n \t}\n// bug_start\n// bug_end\n \n \tif (!skb_cloned(skb)) {\n \t\tif (tailen <= skb_tailroom(skb)) {\n \t\t\tnfrags = 1;\n \t\t\ttrailer = skb;\n \t\t\ttail = skb_tail_pointer(trailer);\n \n \t\t\tgoto skip_cow;\n \t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n \t\t\t   && !skb_has_frag_list(skb)) {\n \t\t\tint allocsize;\n \t\t\tstruct sock *sk = skb->sk;\n \t\t\tstruct page_frag *pfrag = &x->xfrag;\n \n \t\t\tesp->inplace = false;\n \n \t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n \n \t\t\tspin_lock_bh(&x->lock);\n \n \t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n \t\t\t\tspin_unlock_bh(&x->lock);\n \t\t\t\tgoto cow;\n \t\t\t}\n \n \t\t\tpage = pfrag->page;\n \t\t\tget_page(page);\n \n \t\t\ttail = page_address(page) + pfrag->offset;\n \n \t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n \n \t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n \n \t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n \t\t\t\t\t     tailen);\n \t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n \n \t\t\tpfrag->offset = pfrag->offset + allocsize;\n \n \t\t\tspin_unlock_bh(&x->lock);\n \n \t\t\tnfrags++;\n \n \t\t\tskb->len += tailen;\n \t\t\tskb->data_len += tailen;\n \t\t\tskb->truesize += tailen;\n \t\t\tif (sk && sk_fullsock(sk))\n \t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n \n \t\t\tgoto out;\n \t\t}\n \t}\n \n cow:\n \tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n \n \tnfrags = skb_cow_data(skb, tailen, &trailer);\n \tif (nfrags < 0)\n \t\tgoto out;\n \ttail = skb_tail_pointer(trailer);\n \tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n \n skip_cow:\n \tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n \tpskb_put(skb, trailer, tailen);\n \n out:\n \treturn nfrags;\n }\n \n", "target": "// fix_start\n\tunsigned int allocsz;\n// fix_end\n// fix_start\n\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-27666", "cve_desc": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.", "project": "linux", "idx": 202888}
{"source": " int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n {\n \tu8 *tail;\n \tint nfrags;\n \tint esph_offset;\n \tstruct page *page;\n \tstruct sk_buff *trailer;\n \tint tailen = esp->tailen;\n// bug_start\n// bug_end\n \n \tif (x->encap) {\n \t\tint err = esp6_output_encap(x, skb, esp);\n \n \t\tif (err < 0)\n \t\t\treturn err;\n \t}\n// bug_start\n// bug_end\n \n \tif (!skb_cloned(skb)) {\n \t\tif (tailen <= skb_tailroom(skb)) {\n \t\t\tnfrags = 1;\n \t\t\ttrailer = skb;\n \t\t\ttail = skb_tail_pointer(trailer);\n \n \t\t\tgoto skip_cow;\n \t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n \t\t\t   && !skb_has_frag_list(skb)) {\n \t\t\tint allocsize;\n \t\t\tstruct sock *sk = skb->sk;\n \t\t\tstruct page_frag *pfrag = &x->xfrag;\n \n \t\t\tesp->inplace = false;\n \n \t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n \n \t\t\tspin_lock_bh(&x->lock);\n \n \t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n \t\t\t\tspin_unlock_bh(&x->lock);\n \t\t\t\tgoto cow;\n \t\t\t}\n \n \t\t\tpage = pfrag->page;\n \t\t\tget_page(page);\n \n \t\t\ttail = page_address(page) + pfrag->offset;\n \n \t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n \n \t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n \n \t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n \t\t\t\t\t     tailen);\n \t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n \n \t\t\tpfrag->offset = pfrag->offset + allocsize;\n \n \t\t\tspin_unlock_bh(&x->lock);\n \n \t\t\tnfrags++;\n \n \t\t\tskb->len += tailen;\n \t\t\tskb->data_len += tailen;\n \t\t\tskb->truesize += tailen;\n \t\t\tif (sk && sk_fullsock(sk))\n \t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n \n \t\t\tgoto out;\n \t\t}\n \t}\n \n cow:\n \tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n \n \tnfrags = skb_cow_data(skb, tailen, &trailer);\n \tif (nfrags < 0)\n \t\tgoto out;\n \ttail = skb_tail_pointer(trailer);\n \tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n \n skip_cow:\n \tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n \tpskb_put(skb, trailer, tailen);\n \n out:\n \treturn nfrags;\n }\n \n", "target": "// fix_start\n\tunsigned int allocsz;\n// fix_end\n// fix_start\n\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-27666", "cve_desc": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.", "project": "linux", "idx": 202889}
{"source": " void dostor(char *name, const int append, const int autorename)\n {\n     ULHandler ulhandler;\n     int f;\n     const char *ul_name = NULL;\n     const char *atomic_file = NULL;\n     off_t filesize = (off_t) 0U;\n     struct stat st;\n     double started = 0.0;\n     signed char overwrite = 0;\n     int overflow = 0;\n     int ret = -1;\n     off_t max_filesize = (off_t) -1;\n #ifdef QUOTAS\n     Quota quota;\n #endif\n     const char *name2 = NULL;\n \n     if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n         addreply_noformat(503, MSG_NO_ASCII_RESUME);\n         goto end;\n     }\n #ifndef ANON_CAN_RESUME\n     if (guest != 0 && anon_noupload != 0) {\n         addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n         goto end;\n     }\n #endif\n     if (ul_check_free_space(name, -1.0) == 0) {\n         addreply_noformat(552, MSG_NO_DISK_SPACE);\n         goto end;\n     }\n     if (checknamesanity(name, dot_write_ok) != 0) {\n         addreply(553, MSG_SANITY_FILE_FAILURE, name);\n         goto end;\n     }\n     if (autorename != 0) {\n         no_truncate = 1;\n     }\n     if (restartat > (off_t) 0 || no_truncate != 0) {\n         if ((atomic_file = get_atomic_file(name)) == NULL) {\n             addreply(553, MSG_SANITY_FILE_FAILURE, name);\n             goto end;\n         }\n         if (restartat > (off_t) 0 &&\n             rename(name, atomic_file) != 0 && errno != ENOENT) {\n             error(553, MSG_RENAME_FAILURE);\n             atomic_file = NULL;\n             goto end;\n         }\n     }\n     if (atomic_file != NULL) {\n         ul_name = atomic_file;\n     } else {\n         ul_name = name;\n     }\n     if (atomic_file == NULL &&\n         (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {\n         overwrite++;\n     } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,\n                          (mode_t) 0777 & ~u_mask)) == -1) {\n         error(553, MSG_OPEN_FAILURE2);\n         goto end;\n     }\n     if (fstat(f, &st) < 0) {\n         (void) close(f);\n         error(553, MSG_STAT_FAILURE2);\n         goto end;\n     }\n     if (!S_ISREG(st.st_mode)) {\n         (void) close(f);\n         addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n         goto end;\n     }\n     alarm(MAX_SESSION_XFER_IDLE);\n \n     if (st.st_size > (off_t) 0) {\n #ifndef ANON_CAN_RESUME\n         if (guest != 0) {\n             addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n             (void) close(f);\n             goto end;\n         }\n #endif\n         if (append != 0) {\n             restartat = st.st_size;\n         }\n     } else {\n         restartat = (off_t) 0;\n     }\n     if (restartat > st.st_size) {\n         restartat = st.st_size;\n     }\n     if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {\n         (void) close(f);\n         error(451, \"seek\");\n         goto end;\n     }\n     if (restartat < st.st_size) {\n         if (ftruncate(f, restartat) < 0) {\n             (void) close(f);\n             error(451, \"ftruncate\");\n             goto end;\n         }\n #ifdef QUOTAS\n         if (restartat != st.st_size) {\n             (void) quota_update(NULL, 0LL,\n                                 (long long) (restartat - st.st_size),\n                                 &overflow);\n         }\n #endif\n     }\n #ifdef QUOTAS\n     if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&\n         (overflow > 0 || quota.files >= user_quota_files ||\n          quota.size > user_quota_size ||\n// bug_start\n         (max_filesize >= (off_t) 0 &&\n          (max_filesize = user_quota_size - quota.size) < (off_t) 0))) {\n// bug_end\n         overflow = 1;\n         (void) close(f);\n         goto afterquota;\n     }\n #endif\n     opendata();\n     if (xferfd == -1) {\n         (void) close(f);\n         goto end;\n     }\n     doreply();\n # ifdef WITH_TLS\n     if (data_protection_level == CPL_PRIVATE) {\n         tls_init_data_session(xferfd, passive);\n     }\n # endif\n     state_needs_update = 1;\n     setprocessname(\"pure-ftpd (UPLOAD)\");\n     filesize = restartat;\n \n #ifdef FTPWHO\n     if (shm_data_cur != NULL) {\n         const size_t sl = strlen(name);\n \n         ftpwho_lock();\n         shm_data_cur->state = FTPWHO_STATE_UPLOAD;\n         shm_data_cur->download_total_size = (off_t) 0U;\n         shm_data_cur->download_current_size = (off_t) filesize;\n         shm_data_cur->restartat = restartat;\n         (void) time(&shm_data_cur->xfer_date);\n         if (sl < sizeof shm_data_cur->filename) {\n             memcpy(shm_data_cur->filename, name, sl);\n             shm_data_cur->filename[sl] = 0;\n         } else {\n             memcpy(shm_data_cur->filename,\n                    &name[sl - sizeof shm_data_cur->filename - 1U],\n                    sizeof shm_data_cur->filename);\n         }\n         ftpwho_unlock();\n     }\n #endif\n \n \n     started = get_usec_time();\n \n     if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,\n                 restartat, type == 1, throttling_bandwidth_ul,\n                 max_filesize) == 0) {\n         ret = ul_send(&ulhandler);\n         ul_exit(&ulhandler);\n     } else {\n         ret = -1;\n     }\n     (void) close(f);\n     closedata();\n \n \n #ifdef SHOW_REAL_DISK_SPACE\n     if (FSTATFS(f, &statfsbuf) == 0) {\n         double space;\n \n         space = (double) STATFS_BAVAIL(statfsbuf) *\n             (double) STATFS_FRSIZE(statfsbuf);\n         if (space > 524288.0) {\n             addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);\n         } else {\n             addreply(0, MSG_SPACE_FREE_K, space / 1024.0);\n         }\n     }\n #endif\n \n     uploaded += (unsigned long long) ulhandler.total_uploaded;\n     {\n         off_t atomic_file_size;\n         off_t original_file_size;\n         int files_count;\n \n         if (overwrite == 0) {\n             files_count = 1;\n         } else {\n             files_count = 0;\n         }\n         if (autorename != 0 && restartat == (off_t) 0) {\n             if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                 goto afterquota;\n             }\n             if (tryautorename(atomic_file, name, &name2) != 0) {\n                 error(553, MSG_RENAME_FAILURE);\n                 goto afterquota;\n             } else {\n #ifdef QUOTAS\n                 ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);\n #endif\n                 atomic_file = NULL;\n             }\n         } else if (atomic_file != NULL) {\n             if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                 goto afterquota;\n             }\n             if ((original_file_size = get_file_size(name)) < (off_t) 0 ||\n                 restartat > original_file_size) {\n                 original_file_size = restartat;\n             }\n             if (rename(atomic_file, name) != 0) {\n                 error(553, MSG_RENAME_FAILURE);\n                 goto afterquota;\n             } else {\n #ifdef QUOTAS\n                 overflow = ul_quota_update\n                     (name, files_count, atomic_file_size - original_file_size);\n #endif\n                 atomic_file = NULL;\n             }\n         } else {\n #ifdef QUOTAS\n             overflow = ul_quota_update\n                 (name, files_count, ulhandler.total_uploaded);\n #endif\n         }\n     }\n     afterquota:\n     if (overflow > 0) {\n         addreply(552, MSG_QUOTA_EXCEEDED, name);\n     } else {\n         if (ret == 0) {\n             addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n         } else {\n             addreply_noformat(451, MSG_ABORTED);\n         }\n         displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,\n                     name2 ? name2 : name, 1);\n     }\n     end:\n     restartat = (off_t) 0;\n     if (atomic_file != NULL) {\n         unlink(atomic_file);\n         atomic_file = NULL;\n     }\n }\n \n", "target": "// fix_start\n         (max_filesize = user_quota_size - quota.size) < (off_t) 0)) {\n// fix_end\n", "cwe": "CWE-434", "cwe_name": "Unrestricted Upload of File with Dangerous Type", "cve": "CVE-2021-40524", "cve_desc": "In Pure-FTPd before 1.0.50, an incorrect max_filesize quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-zero test does not anticipate an initial -1 value. (Versions 1.0.23 through 1.0.49 are affected.)", "project": "pure-ftpd", "idx": 202892}
{"source": " l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n   CallInfo *ci = L->ci;\n   const char *msg;\n   va_list argp;\n   luaC_checkGC(L);\n   va_start(argp, fmt);\n   msg = luaO_pushvfstring(L, fmt, argp);\n   va_end(argp);\n// bug_start\n  if (isLua(ci))\n// bug_end\n     luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n// bug_start\n// bug_end\n   luaG_errormsg(L);\n }\n \n", "target": "// fix_start\n  if (isLua(ci)) {\n// fix_end\n// fix_start\n    setobjs2s(L, L->top - 2, L->top - 1);\n    L->top--;\n  }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-33099", "cve_desc": "An issue in the component luaG_runerror of Lua v5.4.4 and below leads to a heap-buffer overflow when a recursive error occurs.", "project": "lua", "idx": 202943}
{"source": " pxa3xx_gcu_write(struct file *file, const char *buff,\n \t\t size_t count, loff_t *offp)\n {\n \tint ret;\n \tunsigned long flags;\n \tstruct pxa3xx_gcu_batch\t*buffer;\n \tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n \n// bug_start\n\tint words = count / 4;\n// bug_end\n \n \tpriv->shared->num_writes++;\n \tpriv->shared->num_words += words;\n \n \tif (words >= PXA3XX_GCU_BATCH_WORDS)\n \t\treturn -E2BIG;\n \n \tif (!priv->free) {\n \t\tret = pxa3xx_gcu_wait_free(priv);\n \t\tif (ret < 0)\n \t\t\treturn ret;\n \t}\n \n \tspin_lock_irqsave(&priv->spinlock, flags);\n \tbuffer = priv->free;\n \tpriv->free = buffer->next;\n \tspin_unlock_irqrestore(&priv->spinlock, flags);\n \n \n \tret = copy_from_user(buffer->ptr, buff, words * 4);\n \tif (ret) {\n \t\tspin_lock_irqsave(&priv->spinlock, flags);\n \t\tbuffer->next = priv->free;\n \t\tpriv->free = buffer;\n \t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n \t\treturn -EFAULT;\n \t}\n \n \tbuffer->length = words;\n \n \tbuffer->ptr[words] = 0x01000000;\n \n \tspin_lock_irqsave(&priv->spinlock, flags);\n \n \tbuffer->next = NULL;\n \n \tif (priv->ready) {\n \t\tBUG_ON(priv->ready_last == NULL);\n \n \t\tpriv->ready_last->next = buffer;\n \t} else\n \t\tpriv->ready = buffer;\n \n \tpriv->ready_last = buffer;\n \n \tif (!priv->shared->hw_running)\n \t\trun_ready(priv);\n \n \tspin_unlock_irqrestore(&priv->spinlock, flags);\n \n \treturn words * 4;\n }\n \n", "target": "// fix_start\n\tsize_t words = count / 4;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-39842", "cve_desc": "An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen.", "project": "linux", "idx": 203614}
{"source": " get_one_sourceline(source_cookie_T *sp)\n {\n     garray_T\t\tga;\n     int\t\t\tlen;\n     int\t\t\tc;\n     char_u\t\t*buf;\n #ifdef USE_CRNL\n     int\t\t\thas_cr;\n #endif\n     int\t\t\thave_read = FALSE;\n \n     ga_init2(&ga, 1, 250);\n \n     ++sp->sourcing_lnum;\n     for (;;)\n     {\n \tif (ga_grow(&ga, 120) == FAIL)\n \t    break;\n \tif (sp->source_from_buf)\n \t{\n \t    if (sp->buf_lnum >= sp->buflines.ga_len)\n \t\tbreak;\n \t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n \t    sp->buf_lnum++;\n \t    if (ga_grow(&ga, 1) == FAIL)\n \t\tbreak;\n \t    buf = (char_u *)ga.ga_data;\n \t    buf[ga.ga_len++] = NUL;\n// bug_start\n// bug_end\n \t}\n \telse\n \t{\n \t    buf = (char_u *)ga.ga_data;\n \t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n \t\t\tsp->fp) == NULL)\n \t\tbreak;\n// bug_start\n// bug_end\n \t}\n// bug_start\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n// bug_end\n #ifdef USE_CRNL\n \tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n \t\t&& sp->fileformat == EOL_DOS\n \t\t&& buf[len - 1] == Ctrl_Z)\n \t{\n \t    buf[len - 1] = NUL;\n \t    break;\n \t}\n #endif\n \n \thave_read = TRUE;\n \tga.ga_len = len;\n \n \tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n \t    continue;\n \n \tif (len >= 1 && buf[len - 1] == '\\n')\n \t{\n #ifdef USE_CRNL\n \t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n \t    if (sp->fileformat == EOL_UNKNOWN)\n \t    {\n \t\tif (has_cr)\n \t\t    sp->fileformat = EOL_DOS;\n \t\telse\n \t\t    sp->fileformat = EOL_UNIX;\n \t    }\n \n \t    if (sp->fileformat == EOL_DOS)\n \t    {\n \t\tif (has_cr)\n \t\t{\n \t\t    buf[len - 2] = '\\n';\n \t\t    --len;\n \t\t    --ga.ga_len;\n \t\t}\n \t\telse\n \t\t{\n \t\t    if (!sp->error)\n \t\t    {\n \t\t\tmsg_source(HL_ATTR(HLF_W));\n \t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n \t\t    }\n \t\t    sp->error = TRUE;\n \t\t    sp->fileformat = EOL_UNIX;\n \t\t}\n \t    }\n #endif\n \t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n \t\t;\n \t    if ((len & 1) != (c & 1))\n \t    {\n \t\t++sp->sourcing_lnum;\n \t\tcontinue;\n \t    }\n \n \t    buf[len - 1] = NUL;\n \t}\n \n \tline_breakcheck();\n \tbreak;\n     }\n \n     if (have_read)\n \treturn (char_u *)ga.ga_data;\n \n     vim_free(ga.ga_data);\n     return NULL;\n }\n \n", "target": "// fix_start\n\t    len = ga.ga_len;\n// fix_end\n// fix_start\n\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-1769", "cve_desc": "Buffer Over-read in GitHub repository vim/vim prior to 8.2.4974.", "project": "vim", "idx": 203902}
{"source": " static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n \tstruct inode **i)\n {\n// bug_start\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n// bug_end\n \t\t__attribute__((aligned));\n// bug_start\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n// bug_end\n \tlong long start;\n \tint bytes = 0;\n \tint dir_count, size, res;\n \tstruct dir_ent *ent, *cur_ent = NULL;\n \tstruct dir *dir;\n \n \tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n \t\tblock_start, offset);\n \n \t*i = read_inode(block_start, offset);\n \n \tdir = malloc(sizeof(struct dir));\n \tif(dir == NULL)\n \t\tMEM_ERROR();\n \n \tdir->dir_count = 0;\n \tdir->cur_entry = NULL;\n \tdir->mode = (*i)->mode;\n \tdir->uid = (*i)->uid;\n \tdir->guid = (*i)->gid;\n \tdir->mtime = (*i)->time;\n \tdir->xattr = (*i)->xattr;\n \tdir->dirs = NULL;\n \n// bug_start\n\tif ((*i)->data == 0)\n// bug_end\n \t\treturn dir;\n \n \tstart = sBlk.s.directory_table_start + (*i)->start;\n \toffset = (*i)->offset;\n// bug_start\n\tsize = (*i)->data + bytes;\n// bug_end\n \n \twhile(bytes < size) {\n \t\tif(swap) {\n// bug_start\n\t\t\tsquashfs_dir_header_2 sdirh;\n// bug_end\n \t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n \t\t\tif(res)\n// bug_start\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n// bug_end\n \t\t} else\n \t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n \n \t\tif(res == FALSE)\n \t\t\tgoto corrupted;\n \n \t\tdir_count = dirh.count + 1;\n \t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n \t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n \t\tbytes += sizeof(dirh);\n \n \t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n \t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n \t\t\tgoto corrupted;\n \t\t}\n \n \t\twhile(dir_count--) {\n \t\t\tif(swap) {\n// bug_start\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n// bug_end\n \t\t\t\tres = read_directory_data(&sdire, &start,\n \t\t\t\t\t&offset, sizeof(sdire));\n \t\t\t\tif(res)\n// bug_start\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n// bug_end\n \t\t\t} else\n \t\t\t\tres = read_directory_data(dire, &start,\n \t\t\t\t\t&offset, sizeof(*dire));\n \n \t\t\tif(res == FALSE)\n \t\t\t\tgoto corrupted;\n \n \t\t\tbytes += sizeof(*dire);\n \n \t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n \t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tres = read_directory_data(dire->name, &start, &offset,\n \t\t\t\t\t\t\t\tdire->size + 1);\n \n \t\t\tif(res == FALSE)\n \t\t\t\tgoto corrupted;\n \n \t\t\tdire->name[dire->size + 1] = '\\0';\n \n \t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n \t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);\n \n \t\t\tent = malloc(sizeof(struct dir_ent));\n \t\t\tif(ent == NULL)\n \t\t\t\tMEM_ERROR();\n \n \t\t\tent->name = strdup(dire->name);\n \t\t\tent->start_block = dirh.start_block;\n \t\t\tent->offset = dire->offset;\n \t\t\tent->type = dire->type;\n \t\t\tent->next = NULL;\n \t\t\tif(cur_ent == NULL)\n \t\t\t\tdir->dirs = ent;\n \t\t\telse\n \t\t\t\tcur_ent->next = ent;\n \t\t\tcur_ent = ent;\n \t\t\tdir->dir_count ++;\n \t\t\tbytes += dire->size + 1;\n \t\t}\n \t}\n \n// bug_start\n// bug_end\n \treturn dir;\n \n corrupted:\n \tsquashfs_closedir(dir);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n// fix_end\n// fix_start\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n// fix_end\n// fix_start\n\tif ((*i)->data == 3)\n// fix_end\n// fix_start\n\tsize = (*i)->data + bytes - 3;\n// fix_end\n// fix_start\n\t\t\tsquashfs_dir_header_3 sdirh;\n// fix_end\n// fix_start\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n// fix_end\n// fix_start\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n// fix_end\n// fix_start\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n// fix_end\n// fix_start\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-41072", "cve_desc": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.", "project": "squashfs-tools", "idx": 204016}
{"source": " static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n \tstruct inode **i)\n {\n \tsquashfs_dir_header_3 dirh;\n \tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n \t\t__attribute__((aligned));\n \tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n \tlong long start;\n \tint bytes = 0;\n \tint dir_count, size, res;\n \tstruct dir_ent *ent, *cur_ent = NULL;\n \tstruct dir *dir;\n \n \tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n \t\tblock_start, offset);\n \n \t*i = read_inode(block_start, offset);\n \n \tdir = malloc(sizeof(struct dir));\n \tif(dir == NULL)\n \t\tMEM_ERROR();\n \n \tdir->dir_count = 0;\n \tdir->cur_entry = NULL;\n \tdir->mode = (*i)->mode;\n \tdir->uid = (*i)->uid;\n \tdir->guid = (*i)->gid;\n \tdir->mtime = (*i)->time;\n \tdir->xattr = (*i)->xattr;\n \tdir->dirs = NULL;\n \n \tif ((*i)->data == 3)\n \t\treturn dir;\n \n \tstart = sBlk.s.directory_table_start + (*i)->start;\n \toffset = (*i)->offset;\n \tsize = (*i)->data + bytes - 3;\n \n \twhile(bytes < size) {\n \t\tif(swap) {\n \t\t\tsquashfs_dir_header_3 sdirh;\n \t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n \t\t\tif(res)\n \t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n \t\t} else\n \t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n \n \t\tif(res == FALSE)\n \t\t\tgoto corrupted;\n \n \t\tdir_count = dirh.count + 1;\n \t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n \t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n \t\tbytes += sizeof(dirh);\n \n \t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n \t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n \t\t\tgoto corrupted;\n \t\t}\n \n \t\twhile(dir_count--) {\n \t\t\tif(swap) {\n \t\t\t\tsquashfs_dir_entry_3 sdire;\n \t\t\t\tres = read_directory_data(&sdire, &start,\n \t\t\t\t\t&offset, sizeof(sdire));\n \t\t\t\tif(res)\n \t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n \t\t\t} else\n \t\t\t\tres = read_directory_data(dire, &start,\n \t\t\t\t\t&offset, sizeof(*dire));\n \n \t\t\tif(res == FALSE)\n \t\t\t\tgoto corrupted;\n \n \t\t\tbytes += sizeof(*dire);\n \n \t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n \t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tres = read_directory_data(dire->name, &start, &offset,\n \t\t\t\t\t\t\t\tdire->size + 1);\n \n \t\t\tif(res == FALSE)\n \t\t\t\tgoto corrupted;\n \n \t\t\tdire->name[dire->size + 1] = '\\0';\n \n \t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n \t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);\n \n \t\t\tent = malloc(sizeof(struct dir_ent));\n \t\t\tif(ent == NULL)\n \t\t\t\tMEM_ERROR();\n \n \t\t\tent->name = strdup(dire->name);\n \t\t\tent->start_block = dirh.start_block;\n \t\t\tent->offset = dire->offset;\n \t\t\tent->type = dire->type;\n \t\t\tent->next = NULL;\n \t\t\tif(cur_ent == NULL)\n \t\t\t\tdir->dirs = ent;\n \t\t\telse\n \t\t\t\tcur_ent->next = ent;\n \t\t\tcur_ent = ent;\n \t\t\tdir->dir_count ++;\n \t\t\tbytes += dire->size + 1;\n \t\t}\n \t}\n \n// bug_start\n// bug_end\n \treturn dir;\n \n corrupted:\n \tsquashfs_closedir(dir);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-41072", "cve_desc": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.", "project": "squashfs-tools", "idx": 204017}
{"source": " static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n \tstruct inode **i)\n {\n \tstruct squashfs_dir_header dirh;\n \tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n \t\t__attribute__((aligned));\n \tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n \tlong long start;\n \tint bytes = 0, dir_count, size, res;\n \tstruct dir_ent *ent, *cur_ent = NULL;\n \tstruct dir *dir;\n \n \tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n \t\tblock_start, offset);\n \n \t*i = read_inode(block_start, offset);\n \n \tdir = malloc(sizeof(struct dir));\n \tif(dir == NULL)\n \t\tMEM_ERROR();\n \n \tdir->dir_count = 0;\n \tdir->cur_entry = NULL;\n \tdir->mode = (*i)->mode;\n \tdir->uid = (*i)->uid;\n \tdir->guid = (*i)->gid;\n \tdir->mtime = (*i)->time;\n \tdir->xattr = (*i)->xattr;\n \tdir->dirs = NULL;\n \n \tif ((*i)->data == 3)\n \t\treturn dir;\n \n \tstart = sBlk.s.directory_table_start + (*i)->start;\n \toffset = (*i)->offset;\n \tsize = (*i)->data + bytes - 3;\n \n \twhile(bytes < size) {\n \t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n \t\tif(res == FALSE)\n \t\t\tgoto corrupted;\n \n \t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n \n \t\tdir_count = dirh.count + 1;\n \t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n \t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n \t\tbytes += sizeof(dirh);\n \n \t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n \t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n \t\t\tgoto corrupted;\n \t\t}\n \n \t\twhile(dir_count--) {\n \t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n \t\t\tif(res == FALSE)\n \t\t\t\tgoto corrupted;\n \n \t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n \n \t\t\tbytes += sizeof(*dire);\n \n \t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n \t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tres = read_directory_data(dire->name, &start, &offset,\n \t\t\t\t\t\t\t\tdire->size + 1);\n \t\t\tif(res == FALSE)\n \t\t\t\tgoto corrupted;\n \n \t\t\tdire->name[dire->size + 1] = '\\0';\n \n \t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n \t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);\n \n \t\t\tent = malloc(sizeof(struct dir_ent));\n \t\t\tif(ent == NULL)\n \t\t\t\tMEM_ERROR();\n \n \t\t\tent->name = strdup(dire->name);\n \t\t\tent->start_block = dirh.start_block;\n \t\t\tent->offset = dire->offset;\n \t\t\tent->type = dire->type;\n \t\t\tent->next = NULL;\n \t\t\tif(cur_ent == NULL)\n \t\t\t\tdir->dirs = ent;\n \t\t\telse\n \t\t\t\tcur_ent->next = ent;\n \t\t\tcur_ent = ent;\n \t\t\tdir->dir_count ++;\n \t\t\tbytes += dire->size + 1;\n \t\t}\n \t}\n \n// bug_start\n// bug_end\n \treturn dir;\n \n corrupted:\n \tsquashfs_closedir(dir);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-41072", "cve_desc": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.", "project": "squashfs-tools", "idx": 204019}
{"source": " static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n {\n \t__u8 pkt_type;\n \n \tpkt_type = *((__u8 *) skb->data);\n \tskb_pull(skb, 1);\n \n \tswitch (pkt_type) {\n \tcase HCI_EVENT_PKT:\n \tcase HCI_ACLDATA_PKT:\n \tcase HCI_SCODATA_PKT:\n \tcase HCI_ISODATA_PKT:\n \t\thci_skb_pkt_type(skb) = pkt_type;\n \t\thci_recv_frame(vbt->hdev, skb);\n \t\tbreak;\n// bug_start\n// bug_end\n \t}\n }\n \n", "target": "// fix_start\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tbreak;\n// fix_end\n", "cwe": "CWE-772", "cwe_name": "Missing Release of Resource after Effective Lifetime", "cve": "CVE-2022-26878", "cve_desc": "drivers/bluetooth/virtio_bt.c in the Linux kernel before 5.16.3 has a memory leak (socket buffers have memory allocated but not freed).", "project": "linux", "idx": 204032}
{"source": " int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n \t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n {\n \tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n \tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n \tint err = 0;\n \n \tdo {\n \t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n \n \t\tself->rpc_tid = sw.tid;\n \n \t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n \t\t\t\t\t\tself, fw.val,\n \t\t\t\t\t\tsw.tid == fw.tid,\n \t\t\t\t\t\t1000U, 100000U);\n \t\tif (err < 0)\n \t\t\tgoto err_exit;\n \n \t\terr = aq_hw_err_from_flags(self);\n \t\tif (err < 0)\n \t\t\tgoto err_exit;\n \n \t\tif (fw.len == 0xFFFFU) {\n// bug_start\n// bug_end\n \t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n \t\t\tif (err < 0)\n \t\t\t\tgoto err_exit;\n \t\t}\n \t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n \n \tif (rpc) {\n \t\tif (fw.len) {\n// bug_start\n// bug_end\n \t\t\terr =\n \t\t\thw_atl_utils_fw_downld_dwords(self,\n \t\t\t\t\t\t      self->rpc_addr,\n \t\t\t\t\t\t      (u32 *)(void *)\n \t\t\t\t\t\t      &self->rpc,\n \t\t\t\t\t\t      (fw.len + sizeof(u32) -\n \t\t\t\t\t\t       sizeof(u8)) /\n \t\t\t\t\t\t      sizeof(u32));\n \t\t\tif (err < 0)\n \t\t\t\tgoto err_exit;\n \t\t}\n \n \t\t*rpc = &self->rpc;\n \t}\n \n err_exit:\n \treturn err;\n }\n \n", "target": "// fix_start\n\t\t\tif (sw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid sw len: %x\\n\", sw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n// fix_end\n// fix_start\n\t\t\tif (fw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid fw len: %x\\n\", fw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-43975", "cve_desc": "In the Linux kernel through 5.15.2, hw_atl_utils_fw_rpc_wait in drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c allows an attacker (who can introduce a crafted device) to trigger an out-of-bounds write via a crafted length value.", "project": "net", "idx": 204036}
{"source": " static char ** split(const char *arg, const char *delim) {\n   char *copy = dupstr(arg);\n   char **result = NULL;\n   int i = 0;\n \n   for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n     char **tmp = realloc (result, sizeof *result * (i + 1));\n     if (!tmp && result) {\n       while (i > 0) {\n \tfree(result[--i]);\n       }\n       free(result);\n       free(copy);\n       return NULL;\n     }\n     result = tmp;\n     result[i++] = dupstr(cptr);\n   }\n \n   free(copy);\n \n   if (i) {\n     char **tmp = realloc(result, sizeof *result * (i + 1));\n     if (!tmp) {\n       while (i > 0) {\n \tfree(result[--i]);\n       }\n       free(result);\n// bug_start\n      free(copy);\n// bug_end\n       return NULL;\n     }\n     result = tmp;\n     result[i++] = NULL;\n   }\n \n   return result;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2022-0699", "cve_desc": "A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0 and older releases. This issue may allow an attacker to cause a denial of service or have other unspecified impact via control over malloc.", "project": "shapelib", "idx": 204073}
{"source": " issuerAndThisUpdateCheck(\n \tstruct berval *in,\n \tstruct berval *is,\n \tstruct berval *tu,\n \tvoid *ctx )\n {\n \tint numdquotes = 0;\n \tstruct berval x = *in;\n \tstruct berval ni = BER_BVNULL;\n \tenum {\n \t\tHAVE_NONE = 0x0,\n \t\tHAVE_ISSUER = 0x1,\n \t\tHAVE_THISUPDATE = 0x2,\n \t\tHAVE_ALL = ( HAVE_ISSUER | HAVE_THISUPDATE )\n \t} have = HAVE_NONE;\n \n \n \tif ( in->bv_len < STRLENOF( \"{issuer \\\"\\\",thisUpdate \\\"YYMMDDhhmmssZ\\\"}\" ) ) return LDAP_INVALID_SYNTAX;\n \n \tif ( in->bv_val[0] != '{' || in->bv_val[in->bv_len-1] != '}' ) {\n \t\treturn LDAP_INVALID_SYNTAX;\n \t}\n \n \tx.bv_val++;\n \tx.bv_len -= STRLENOF(\"{}\");\n \n \tdo {\n \t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n \t\t\t;\n \t\t}\n \n \t\tif ( strncasecmp( x.bv_val, \"issuer\", STRLENOF(\"issuer\") ) == 0 ) {\n \t\t\tif ( have & HAVE_ISSUER ) return LDAP_INVALID_SYNTAX;\n \n \t\t\tx.bv_val += STRLENOF(\"issuer\");\n \t\t\tx.bv_len -= STRLENOF(\"issuer\");\n \n \t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n \t\t\tx.bv_val++;\n \t\t\tx.bv_len--;\n \n \t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n \t\t\t\t;\n \t\t\t}\n \n \t\t\tif ( strncasecmp( x.bv_val, \"rdnSequence:\", STRLENOF(\"rdnSequence:\") ) != 0 ) {\n \t\t\t\treturn LDAP_INVALID_SYNTAX;\n \t\t\t}\n \t\t\tx.bv_val += STRLENOF(\"rdnSequence:\");\n \t\t\tx.bv_len -= STRLENOF(\"rdnSequence:\");\n \n \t\t\tif ( x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n \t\t\tx.bv_val++;\n \t\t\tx.bv_len--;\n \n \t\t\tis->bv_val = x.bv_val;\n \t\t\tis->bv_len = 0;\n \n \t\t\tfor ( ; is->bv_len < x.bv_len; ) {\n \t\t\t\tif ( is->bv_val[is->bv_len] != '\"' ) {\n \t\t\t\t\tis->bv_len++;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif ( is->bv_val[is->bv_len+1] == '\"' ) {\n \t\t\t\t\tnumdquotes++;\n \t\t\t\t\tis->bv_len += 2;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tx.bv_val += is->bv_len + 1;\n \t\t\tx.bv_len -= is->bv_len + 1;\n \n \t\t\thave |= HAVE_ISSUER;\n \n \t\t} else if ( strncasecmp( x.bv_val, \"thisUpdate\", STRLENOF(\"thisUpdate\") ) == 0 )\n \t\t{\n \t\t\tif ( have & HAVE_THISUPDATE ) return LDAP_INVALID_SYNTAX;\n \n \t\t\tx.bv_val += STRLENOF(\"thisUpdate\");\n \t\t\tx.bv_len -= STRLENOF(\"thisUpdate\");\n \n \t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n \t\t\tx.bv_val++;\n \t\t\tx.bv_len--;\n \n \t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n \t\t\t\t;\n \t\t\t}\n \n \t\t\tif ( !x.bv_len || x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n \t\t\tx.bv_val++;\n \t\t\tx.bv_len--;\n \n \t\t\ttu->bv_val = x.bv_val;\n \t\t\ttu->bv_len = 0;\n \n \t\t\tfor ( ; tu->bv_len < x.bv_len; tu->bv_len++ ) {\n \t\t\t\tif ( tu->bv_val[tu->bv_len] == '\"' ) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n// bug_start\n// bug_end\n \t\t\tx.bv_val += tu->bv_len + 1;\n \t\t\tx.bv_len -= tu->bv_len + 1;\n \n \t\t\thave |= HAVE_THISUPDATE;\n \n \t\t} else {\n \t\t\treturn LDAP_INVALID_SYNTAX;\n \t\t}\n \n \t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n \t\t\t;\n \t\t}\n \n \t\tif ( have == HAVE_ALL ) {\n \t\t\tbreak;\n \t\t}\n \n \t\tif ( x.bv_val[0] != ',' ) {\n \t\t\treturn LDAP_INVALID_SYNTAX;\n \t\t}\n \n \t\tx.bv_val++;\n \t\tx.bv_len--;\n \t} while ( 1 );\n \n \tif ( x.bv_len ) return LDAP_INVALID_SYNTAX;\n \n \tif ( numdquotes == 0 ) {\n \t\tber_dupbv_x( &ni, is, ctx );\n \n \t} else {\n \t\tber_len_t src, dst;\n \n \t\tni.bv_len = is->bv_len - numdquotes;\n \t\tni.bv_val = slap_sl_malloc( ni.bv_len + 1, ctx );\n \t\tfor ( src = 0, dst = 0; src < is->bv_len; src++, dst++ ) {\n \t\t\tif ( is->bv_val[src] == '\"' ) {\n \t\t\t\tsrc++;\n \t\t\t}\n \t\t\tni.bv_val[dst] = is->bv_val[src];\n \t\t}\n \t\tni.bv_val[dst] = '\\0';\n \t}\n \n \t*is = ni;\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\t\tif ( tu->bv_len < STRLENOF(\"YYYYmmddHHmmssZ\") ) return LDAP_INVALID_SYNTAX;\n\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2021-27212", "cve_desc": "In OpenLDAP through 2.4.57 and 2.5.x through 2.5.1alpha, an assertion failure in slapd can occur in the issuerAndThisUpdateCheck function via a crafted packet, resulting in a denial of service (daemon exit) via a short timestamp. This is related to schema_init.c and checkTime.", "project": "openldap", "idx": 204115}
{"source": " bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n \t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n \t\t\t\t\tconst double *mat, const double *bbox,\n \t\t\t\t\tint x0, int y0, int x1, int y1,\n \t\t\t\t\tdouble xStep, double yStep)\n {\n   PDFRectangle box;\n   Gfx *gfx;\n   Splash *formerSplash = splash;\n   SplashBitmap *formerBitmap = bitmap;\n   double width, height;\n   int surface_width, surface_height, result_width, result_height, i;\n   int repeatX, repeatY;\n   SplashCoord matc[6];\n   Matrix m1;\n   const double *ctm;\n   double savedCTM[6];\n   double kx, ky, sx, sy;\n   bool retValue = false;\n \n   width = bbox[2] - bbox[0];\n   height = bbox[3] - bbox[1];\n \n   if (xStep != width || yStep != height)\n     return false;\n \n   ctm = state->getCTM();\n   for (i = 0; i < 6; ++i) {\n     savedCTM[i] = ctm[i];\n   }\n   state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n   state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n   ctm = state->getCTM();\n   for (i = 0; i < 6; ++i) {\n     if (!std::isfinite(ctm[i])) {\n       state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n       return false;\n     }\n   }\n   matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n   matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n   if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n     kx = -ctm[1];\n     ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n   } else {\n     kx = ctm[0];\n     ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n   }\n   result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n   result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n   kx = state->getHDPI() / 72.0;\n   ky = state->getVDPI() / 72.0;\n   m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n   m1.m[1] = 0;\n   m1.m[2] = 0;\n   m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n   m1.m[4] = 0;\n   m1.m[5] = 0;\n   m1.transform(width, height, &kx, &ky);\n   surface_width = (int) ceil (fabs(kx));\n   surface_height = (int) ceil (fabs(ky));\n \n   sx = (double) result_width / (surface_width * (x1 - x0));\n   sy = (double) result_height / (surface_height * (y1 - y0));\n   m1.m[0] *= sx;\n   m1.m[3] *= sy;\n   m1.transform(width, height, &kx, &ky);\n \n   if(fabs(kx) < 1 && fabs(ky) < 1) {\n     kx = std::min<double>(kx, ky);\n     ky = 2 / kx;\n     m1.m[0] *= ky;\n     m1.m[3] *= ky;\n     m1.transform(width, height, &kx, &ky);\n     surface_width = (int) ceil (fabs(kx));\n     surface_height = (int) ceil (fabs(ky));\n     repeatX = x1 - x0;\n     repeatY = y1 - y0;\n   } else {\n     if ((unsigned long) surface_width * surface_height > 0x800000L) {\n       state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n       return false;\n     }\n     while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n       m1.m[0] /= 2;\n       m1.m[3] /= 2;\n       m1.transform(width, height, &kx, &ky);\n     }\n     surface_width = (int) ceil (fabs(kx));\n     surface_height = (int) ceil (fabs(ky));\n// bug_start\n// bug_end\n     repeatX = result_width / surface_width;\n     repeatY = result_height / surface_height;\n     if (surface_width * repeatX < result_width)\n       repeatX++;\n     if (surface_height * repeatY < result_height)\n       repeatY++;\n     if (x1 - x0 > repeatX)\n       repeatX = x1 - x0;\n     if (y1 - y0 > repeatY)\n       repeatY = y1 - y0;\n   }\n   state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n   state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n   state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n   ctm = state->getCTM();\n   matc[0] = ctm[0];\n   matc[1] = ctm[1];\n   matc[2] = ctm[2];\n   matc[3] = ctm[3];\n \n   if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n     state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n     return false;\n   }\n   m1.transform(bbox[0], bbox[1], &kx, &ky);\n   m1.m[4] = -kx;\n   m1.m[5] = -ky;\n \n   bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                             (paintType == 1) ? colorMode : splashModeMono8, true);\n   if (bitmap->getDataPtr() == nullptr) {\n     SplashBitmap *tBitmap = bitmap;\n     bitmap = formerBitmap;\n     delete tBitmap;\n     state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n     return false;\n   }\n   splash = new Splash(bitmap, true);\n   if (paintType == 2) {\n     SplashColor clearColor;\n #ifdef SPLASH_CMYK\n     clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n #else\n     clearColor[0] = 0xFF;\n #endif\n     splash->clear(clearColor, 0);\n   } else {\n     splash->clear(paperColor, 0);\n   }\n   splash->setThinLineMode(formerSplash->getThinLineMode());\n   splash->setMinLineWidth(s_minLineWidth);\n \n   box.x1 = bbox[0]; box.y1 = bbox[1];\n   box.x2 = bbox[2]; box.y2 = bbox[3];\n   gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n   gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n   updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n   gfx->display(str);\n   delete splash;\n   splash = formerSplash;\n   TilingSplashOutBitmap imgData;\n   imgData.bitmap = bitmap;\n   imgData.paintType = paintType;\n   imgData.pattern = splash->getFillPattern();\n   imgData.colorMode = colorMode;\n   imgData.y = 0;\n   imgData.repeatX = repeatX;\n   imgData.repeatY = repeatY;\n   SplashBitmap *tBitmap = bitmap;\n   bitmap = formerBitmap;\n   result_width = tBitmap->getWidth() * imgData.repeatX;\n   result_height = tBitmap->getHeight() * imgData.repeatY;\n \n   if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n     kx = -matc[1];\n     ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n   } else {\n     kx = matc[0];\n     ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n   }\n   kx = result_width / (fabs(kx) + 1);\n   ky = result_height / (fabs(ky) + 1);\n   state->concatCTM(kx, 0, 0, ky, 0, 0);\n   ctm = state->getCTM();\n   matc[0] = ctm[0];\n   matc[1] = ctm[1];\n   matc[2] = ctm[2];\n   matc[3] = ctm[3];\n   bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n   if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n     for (int y = 0; y < imgData.repeatY; ++y) {\n       for (int x = 0; x < imgData.repeatX; ++x) {\n         x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n         y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n         splash->blitImage(tBitmap, true, x0, y0);\n       }\n     }\n     retValue = true;\n   } else {\n     retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n   }\n   delete tBitmap;\n   delete gfx;\n   return retValue;\n }\n \n", "target": "// fix_start\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2019-14494", "cve_desc": "An issue was discovered in Poppler through 0.78.0. There is a divide-by-zero error in the function SplashOutputDev::tilingPatternFill at SplashOutputDev.cc.", "project": "poppler", "idx": 204137}
{"source": " static void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n \t\t\t   const void *pkt,\n \t\t\t   pj_size_t size)\n {\n     pj_str_t reason = {\"-\", 1};\n \n     if (size > 8) {\n \treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                              *((pj_uint8_t*)pkt+8));\n// bug_start\n// bug_end\n \tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n \t\t  reason.slen);\n \treason.ptr = sess->stat.peer_sdes_buf_;\n     }\n \n     PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n \t       reason.slen, reason.ptr));\n }\n \n", "target": "// fix_start\n        reason.slen = PJ_MIN(reason.slen, size-9);\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-43804", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming RTCP BYE message contains a reason's length, this declared length is not checked against the actual received packet size, potentially resulting in an out-of-bound read access. This issue affects all users that use PJMEDIA and RTCP. A malicious actor can send a RTCP BYE message with an invalid reason length. Users are advised to upgrade as soon as possible. There are no known workarounds.", "project": "pjproject", "idx": 204195}
{"source": " eval7(\n     char_u\t**arg,\n     typval_T\t*rettv,\n     evalarg_T\t*evalarg,\n     int\t\twant_string)\n {\n     int\t\tevaluate = evalarg != NULL\n \t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n     int\t\tlen;\n     char_u\t*s;\n     char_u\t*name_start = NULL;\n     char_u\t*start_leader, *end_leader;\n     int\t\tret = OK;\n     char_u\t*alias;\n// bug_start\n// bug_end\n \n     rettv->v_type = VAR_UNKNOWN;\n \n     start_leader = *arg;\n     if (eval_leader(arg, in_vim9script()) == FAIL)\n \treturn FAIL;\n     end_leader = *arg;\n \n     if (**arg == '.' && (!isdigit(*(*arg + 1))\n #ifdef FEAT_FLOAT\n \t    || in_old_script(2)\n #endif\n \t    ))\n     {\n \tsemsg(_(e_invalid_expression_str), *arg);\n \t++*arg;\n \treturn FAIL;\n     }\n// bug_start\n// bug_end\n \n     switch (**arg)\n     {\n     case '0':\n     case '1':\n     case '2':\n     case '3':\n     case '4':\n     case '5':\n     case '6':\n     case '7':\n     case '8':\n     case '9':\n     case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n \n \t\tif (ret == OK && evaluate && end_leader > start_leader\n \t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n \t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n \t\tbreak;\n \n     case '\"':\tret = eval_string(arg, rettv, evaluate);\n \t\tbreak;\n \n     case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n \t\tbreak;\n \n     case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n \t\tbreak;\n \n     case '#':\tif (in_vim9script())\n \t\t{\n \t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n \t\t}\n \t\telse if ((*arg)[1] == '{')\n \t\t{\n \t\t    ++*arg;\n \t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n \t\t}\n \t\telse\n \t\t    ret = NOTDONE;\n \t\tbreak;\n \n     case '{':\tif (in_vim9script())\n \t\t    ret = NOTDONE;\n \t\telse\n \t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n \t\tif (ret == NOTDONE)\n \t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n \t\tbreak;\n \n     case '&':\tret = eval_option(arg, rettv, evaluate);\n \t\tbreak;\n \n     case '$':\tret = eval_env_var(arg, rettv, evaluate);\n \t\tbreak;\n \n     case '@':\t++*arg;\n \t\tif (evaluate)\n \t\t{\n \t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n \t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n \t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n \t\t\temsg_invreg(**arg);\n \t\t    else\n \t\t    {\n \t\t\trettv->v_type = VAR_STRING;\n \t\t\trettv->vval.v_string = get_reg_contents(**arg,\n \t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n \t\t    }\n \t\t}\n \t\tif (**arg != NUL)\n \t\t    ++*arg;\n \t\tbreak;\n \n     case '(':\tret = NOTDONE;\n \t\tif (in_vim9script())\n \t\t{\n \t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n \t\t    if (ret == OK && evaluate)\n \t\t    {\n \t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n \n \t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n \t\t\t    ufunc->uf_ret_type = &t_unknown;\n \t\t\tif (compile_def_function(ufunc,\n \t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n \t\t\t{\n \t\t\t    clear_tv(rettv);\n \t\t\t    ret = FAIL;\n \t\t\t}\n \t\t    }\n \t\t}\n \t\tif (ret == NOTDONE)\n \t\t{\n \t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n \t\t    ret = eval1(arg, rettv, evalarg);\n \n \t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n \t\t    if (**arg == ')')\n \t\t\t++*arg;\n \t\t    else if (ret == OK)\n \t\t    {\n \t\t\temsg(_(e_missing_closing_paren));\n \t\t\tclear_tv(rettv);\n \t\t\tret = FAIL;\n \t\t    }\n \t\t}\n \t\tbreak;\n \n     default:\tret = NOTDONE;\n \t\tbreak;\n     }\n \n     if (ret == NOTDONE)\n     {\n \ts = *arg;\n \tlen = get_name_len(arg, &alias, evaluate, TRUE);\n \tif (alias != NULL)\n \t    s = alias;\n \n \tif (len <= 0)\n \t    ret = FAIL;\n \telse\n \t{\n \t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n \n \t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n \t    {\n \t\temsg(_(e_cannot_use_underscore_here));\n \t\tret = FAIL;\n \t    }\n \t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n \t    {\n \t\t*arg = skipwhite(*arg);\n \t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n \t    }\n \t    else if (flags & EVAL_CONSTANT)\n \t\tret = FAIL;\n \t    else if (evaluate)\n \t    {\n \t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n \t\t{\n \t\t    rettv->v_type = VAR_BOOL;\n \t\t    rettv->vval.v_number = VVAL_TRUE;\n \t\t    ret = OK;\n \t\t}\n \t\telse if (len == 5 && in_vim9script()\n \t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n \t\t{\n \t\t    rettv->v_type = VAR_BOOL;\n \t\t    rettv->vval.v_number = VVAL_FALSE;\n \t\t    ret = OK;\n \t\t}\n \t\telse if (len == 4 && in_vim9script()\n \t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n \t\t{\n \t\t    rettv->v_type = VAR_SPECIAL;\n \t\t    rettv->vval.v_number = VVAL_NULL;\n \t\t    ret = OK;\n \t\t}\n \t\telse\n \t\t{\n \t\t    name_start = s;\n \t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n \t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n \t\t}\n \t    }\n \t    else\n \t    {\n \t\tcheck_vars(s, len);\n \t\tret = OK;\n \t    }\n \t}\n \tvim_free(alias);\n     }\n \n     if (ret == OK)\n \tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n \n     if (ret == OK && evaluate && end_leader > start_leader)\n \tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n// bug_start\n// bug_end\n     return ret;\n }\n \n", "target": "// fix_start\n    static\tint recurse = 0;\n// fix_end\n// fix_start\n\n    if (recurse == 1000)\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n// fix_end\n// fix_start\n\n    --recurse;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0351", "cve_desc": "Access of Memory Location Before Start of Buffer in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 204243}
{"source": " static void build_dirs(char *src, char *dst, size_t src_prefix_len, size_t dst_prefix_len) {\n \tchar *p = src + src_prefix_len + 1;\n \tchar *q = dst + dst_prefix_len + 1;\n \tchar *r = dst + dst_prefix_len;\n \tstruct stat s;\n \tbool last = false;\n \t*r = '\\0';\n \tfor (; !last; p++, q++) {\n \t\tif (*p == '\\0') {\n \t\t\tlast = true;\n \t\t}\n \t\tif (*p == '\\0' || (*p == '/' && *(p - 1) != '/')) {\n \t\t\t*p = '\\0';\n \t\t\tif (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) {\n \t\t\t\t*q = '\\0';\n \t\t\t\t*r = '/';\n \t\t\t\tr = q;\n// bug_start\n\t\t\t\tmkdir_attr(dst, s.st_mode, 0, 0);\n// bug_end\n \t\t\t}\n \t\t\tif (!last) {\n \t\t\t\t*p = '/';\n \t\t\t}\n \t\t}\n \t}\n }\n \n", "target": "// fix_start\n\t\t\t\tif (mkdir(dst, 0700) != 0 && errno != EEXIST)\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(dst, s.st_mode) != 0)\n\t\t\t\t\terrExit(\"chmod\");\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "cve": "CVE-2022-31214", "cve_desc": "A Privilege Context Switching issue was discovered in join.c in Firejail 0.9.68. By crafting a bogus Firejail container that is accepted by the Firejail setuid-root program as a join target, a local attacker can enter an environment in which the Linux user namespace is still the initial user namespace, the NO_NEW_PRIVS prctl is not activated, and the entered mount namespace is under the attacker's control. In this way, the filesystem layout can be adjusted to gain root privileges through execution of available setuid-root binaries such as su or sudo.", "project": "firejail", "idx": 204278}
{"source": " bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n {\n     SQObjectPtr temp;\n     bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n     if(_locked && !belongs_to_static_table)\n         return false;\n     if(_members->Get(key,temp) && _isfield(temp))\n     {\n         _defaultvalues[_member_idx(temp)].val = val;\n         return true;\n     }\n// bug_start\n// bug_end\n     if(belongs_to_static_table) {\n         SQInteger mmidx;\n         if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n             (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n             _metamethods[mmidx] = val;\n         }\n         else {\n             SQObjectPtr theval = val;\n             if(_base && sq_type(val) == OT_CLOSURE) {\n                 theval = _closure(val)->Clone();\n                 _closure(theval)->_base = _base;\n                 __ObjAddRef(_base);\n             }\n             if(sq_type(temp) == OT_NULL) {\n                 bool isconstructor;\n                 SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                 if(isconstructor) {\n                     _constructoridx = (SQInteger)_methods.size();\n                 }\n                 SQClassMember m;\n                 m.val = theval;\n                 _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                 _methods.push_back(m);\n             }\n             else {\n                 _methods[_member_idx(temp)].val = theval;\n             }\n         }\n         return true;\n     }\n     SQClassMember m;\n     m.val = val;\n     _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n     _defaultvalues.push_back(m);\n     return true;\n }\n \n", "target": "// fix_start\n\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n\t\treturn false;\n\t}\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-41556", "cve_desc": "sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds read (in the core interpreter) that can lead to Code Execution. If a victim executes an attacker-controlled squirrel script, it is possible for the attacker to break out of the squirrel script sandbox even if all dangerous functionality such as File System functions has been disabled. An attacker might abuse this bug to target (for example) Cloud services that allow customization via SquirrelScripts, or distribute malware through video games that embed a Squirrel Engine.", "project": "squirrel", "idx": 204351}
{"source": " static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n {\n \tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n \tu32 len, pg_off;\n \tstruct bpf_ringbuf_hdr *hdr;\n \n \tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n \t\treturn NULL;\n \n \tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n// bug_start\n// bug_end\n \tcons_pos = smp_load_acquire(&rb->consumer_pos);\n \n \tif (in_nmi()) {\n \t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n \t\t\treturn NULL;\n \t} else {\n \t\tspin_lock_irqsave(&rb->spinlock, flags);\n \t}\n \n \tprod_pos = rb->producer_pos;\n \tnew_prod_pos = prod_pos + len;\n \n \tif (new_prod_pos - cons_pos > rb->mask) {\n \t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n \t\treturn NULL;\n \t}\n \n \thdr = (void *)rb->data + (prod_pos & rb->mask);\n \tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n \thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n \thdr->pg_off = pg_off;\n \n \tsmp_store_release(&rb->producer_pos, new_prod_pos);\n \n \tspin_unlock_irqrestore(&rb->spinlock, flags);\n \n \treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n }\n \n", "target": "// fix_start\n\tif (len > rb->mask + 1)\n\t\treturn NULL;\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-3489", "cve_desc": "The eBPF RINGBUF bpf_ringbuf_reserve() function in the Linux kernel did not check that the allocated size was smaller than the ringbuf size, allowing an attacker to perform out-of-bounds writes within the kernel and therefore, arbitrary code execution. This issue was fixed via commit 4b81ccebaeee (\"bpf, ringbuf: Deny reserve of buffers larger than ringbuf\") (v5.13-rc4) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced via 457f44363a88 (\"bpf: Implement BPF ring buffer and verifier support for it\") (v5.8-rc1).", "project": "bpf", "idx": 204412}
{"source": " bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n {\n   u_char *end;\n// bug_start\n  struct capability cap;\n// bug_end\n   u_char action;\n   struct bgp *bgp;\n   afi_t afi;\n   safi_t safi;\n \n   bgp = peer->bgp;\n   end = pnt + length;\n \n   while (pnt < end)\n     {\n       if (pnt + 3 > end)\n         {\n           zlog_info (\"%s Capability length error\", peer->host);\n           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n           return -1;\n         }\n// bug_start\n\n// bug_end\n       action = *pnt;\n// bug_start\n\n      memcpy (&cap, pnt + 1, sizeof (struct capability));\n// bug_end\n \n       if (action != CAPABILITY_ACTION_SET\n \t  && action != CAPABILITY_ACTION_UNSET)\n         {\n           zlog_info (\"%s Capability Action Value error %d\",\n \t\t     peer->host, action);\n           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n           return -1;\n         }\n \n       if (BGP_DEBUG (normal, NORMAL))\n \tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n// bug_start\n\t\t   peer->host, action, cap.code, cap.length);\n// bug_end\n \n// bug_start\n      if (pnt + (cap.length + 3) > end)\n// bug_end\n         {\n           zlog_info (\"%s Capability length error\", peer->host);\n           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n           return -1;\n         }\n \n// bug_start\n      if (cap.code == CAPABILITY_CODE_MP)\n// bug_end\n         {\n// bug_start\n\t  afi = ntohs (cap.mpc.afi);\n\t  safi = cap.mpc.safi;\n// bug_end\n \n           if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n \t    continue;\n \n// bug_start\n\t  if ((afi == AFI_IP\n\t       || afi == AFI_IP6)\n\t      && (safi == SAFI_UNICAST\n\t\t  || safi == SAFI_MULTICAST\n\t\t  || safi == BGP_SAFI_VPNV4))\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n\t\t\t   peer->host,\n\t\t\t   action == CAPABILITY_ACTION_SET\n\t\t\t   ? \"Advertising\" : \"Removing\",\n\t\t\t   ntohs(cap.mpc.afi) , cap.mpc.safi);\n// bug_end\n \n// bug_start\n\t      if (safi == BGP_SAFI_VPNV4)\n\t\tsafi = SAFI_MPLS_VPN;\n// bug_end\n \n// bug_start\n\t      if (action == CAPABILITY_ACTION_SET)\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 1;\n\t\t  if (peer->afc[afi][safi])\n\t\t    {\n\t\t      peer->afc_nego[afi][safi] = 1;\n\t\t      bgp_announce_route (peer, afi, safi);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 0;\n\t\t  peer->afc_nego[afi][safi] = 0;\n// bug_end\n \n// bug_start\n\t\t  if (peer_active_nego (peer))\n\t\t    bgp_clear_route (peer, afi, safi);\n\t\t  else\n\t\t    BGP_EVENT_ADD (peer, BGP_Stop);\n\t\t}\n\t    }\n// bug_end\n         }\n       else\n         {\n           zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n// bug_start\n                     peer->host, cap.code);\n// bug_end\n         }\n// bug_start\n      pnt += cap.length + 3;\n// bug_end\n     }\n   return 0;\n }\n \n", "target": "// fix_start\n  struct capability_mp_data mpc;\n  struct capability_header *hdr;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n      hdr = (struct capability_header *)(pnt + 1);\n// fix_end\n// fix_start\n\t\t   peer->host, action, hdr->code, hdr->length);\n// fix_end\n// fix_start\n      if ((pnt + hdr->length + 3) > end)\n// fix_end\n// fix_start\n      memcpy (&mpc, pnt + 3, sizeof (struct capability_mp_data));\n\n      if (hdr->code == CAPABILITY_CODE_MP)\n// fix_end\n// fix_start\n\t  afi = ntohs (mpc.afi);\n\t  safi = mpc.safi;\n// fix_end\n// fix_start\n          if (!bgp_afi_safi_valid_indices (afi, &safi))\n            {\n              if (BGP_DEBUG (normal, NORMAL))\n                zlog_debug (\"%s Dynamic Capability MP_EXT afi/safi invalid\",\n                            peer->host, afi, safi);\n              continue;\n            }\n// fix_end\n// fix_start\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n                       peer->host,\n                       action == CAPABILITY_ACTION_SET\n                       ? \"Advertising\" : \"Removing\",\n                       ntohs(mpc.afi) , mpc.safi);\n// fix_end\n// fix_start\n          if (action == CAPABILITY_ACTION_SET)\n            {\n              peer->afc_recv[afi][safi] = 1;\n              if (peer->afc[afi][safi])\n                {\n                  peer->afc_nego[afi][safi] = 1;\n                  bgp_announce_route (peer, afi, safi);\n                }\n            }\n          else\n            {\n              peer->afc_recv[afi][safi] = 0;\n              peer->afc_nego[afi][safi] = 0;\n// fix_end\n// fix_start\n              if (peer_active_nego (peer))\n                bgp_clear_route (peer, afi, safi);\n              else\n                BGP_EVENT_ADD (peer, BGP_Stop);\n            }\n// fix_end\n// fix_start\n                     peer->host, hdr->code);\n// fix_end\n// fix_start\n      pnt += hdr->length + 3;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "project": "frr", "idx": 204425}
{"source": " WandPrivate void CLINoImageOperator(MagickCLI *cli_wand,\n   const char *option,const char *arg1n,const char *arg2n)\n {\n   const char\n     *arg1,\n     *arg2;\n \n #define _image_info     (cli_wand->wand.image_info)\n #define _images         (cli_wand->wand.images)\n #define _exception      (cli_wand->wand.exception)\n #define _process_flags  (cli_wand->process_flags)\n #define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n #define IfNormalOp      (*option=='-')\n #define IfPlusOp        (*option!='-')\n \n   assert(cli_wand != (MagickCLI *) NULL);\n   assert(cli_wand->signature == MagickWandSignature);\n   assert(cli_wand->wand.signature == MagickWandSignature);\n \n   if (cli_wand->wand.debug != MagickFalse)\n     (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n       \"- NoImage Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n       arg1n != (char *) NULL ? arg1n : \"\",\n       arg2n != (char *) NULL ? arg2n : \"\");\n \n   arg1 = arg1n;\n   arg2 = arg2n;\n \n   if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n         || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n        )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n     if (arg1n != (char *) NULL) {\n       arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n       if (arg1 == (char *) NULL) {\n         CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n         arg1=arg1n;\n       }\n     }\n     if (arg2n != (char *) NULL) {\n       arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n       if (arg2 == (char *) NULL) {\n         CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n         arg2=arg2n;\n       }\n     }\n   }\n #undef _process_flags\n #undef _option_type\n \n   do {\n     if (LocaleCompare(\"noop\",option+1) == 0)\n       break;\n     if (LocaleCompare(\"sans\",option+1) == 0)\n       break;\n     if (LocaleCompare(\"sans0\",option+1) == 0)\n       break;\n     if (LocaleCompare(\"sans1\",option+1) == 0)\n       break;\n     if (LocaleCompare(\"sans2\",option+1) == 0)\n       break;\n     if ( ( LocaleCompare(\"read\",option+1) == 0 ) ||\n       ( LocaleCompare(\"--\",option) == 0 ) ) {\n       int      argc;\n       char     **argv;\n       ssize_t  i;\n \n       argc = 1;\n       argv = (char **) &arg1;\n \n       if (ExpandFilenames(&argc,&argv) == MagickFalse)\n         CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n             option,GetExceptionMessage(errno));\n \n       for (i=0; i < (ssize_t) argc; i++) {\n         Image *\n           new_images;\n         if (_image_info->ping != MagickFalse)\n           new_images=PingImages(_image_info,argv[i],_exception);\n         else\n           new_images=ReadImages(_image_info,argv[i],_exception);\n         AppendImageToList(&_images, new_images);\n         argv[i]=DestroyString(argv[i]);\n       }\n       argv=(char **) RelinquishMagickMemory(argv);\n       break;\n     }\n     if (LocaleCompare(\"write\",option+1) == 0) {\n       char\n         key[MagickPathExtent];\n \n       Image\n         *write_images;\n \n       ImageInfo\n         *write_info;\n \n       if ( _images == (Image *) NULL ) {\n         if ( LocaleCompare(arg1,\"null:\") == 0 )\n           break;\n         CLIWandExceptArgBreak(OptionError,\"NoImagesForWrite\",option,arg1);\n       }\n \n       (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",arg1);\n       (void) DeleteImageRegistry(key);\n       write_images=CloneImageList(_images,_exception);\n       write_info=CloneImageInfo(_image_info);\n// bug_start\n      (void) WriteImages(write_info,write_images,arg1,_exception);\n// bug_end\n       write_info=DestroyImageInfo(write_info);\n       write_images=DestroyImageList(write_images);\n       break;\n     }\n     if (LocaleCompare(\"(\",option) == 0) {\n       Stack\n         *node;\n \n       size_t\n         size;\n \n       size=0;\n       node=cli_wand->image_list_stack;\n       for ( ; node != (Stack *) NULL; node=node->next)\n         size++;\n       if ( size >= MAX_STACK_DEPTH )\n         CLIWandExceptionBreak(OptionError,\"ParenthesisNestedTooDeeply\",option);\n       node=(Stack *) AcquireMagickMemory(sizeof(*node));\n       if (node == (Stack *) NULL)\n         CLIWandExceptionBreak(ResourceLimitFatalError,\n             \"MemoryAllocationFailed\",option);\n       node->data = (void *)cli_wand->wand.images;\n       node->next = cli_wand->image_list_stack;\n       cli_wand->image_list_stack = node;\n       cli_wand->wand.images = NewImageList();\n \n       if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,\n                     \"respect-parenthesis\")) != MagickFalse)\n         option=\"{\";\n       else\n         break;\n     }\n     if (LocaleCompare(\"{\",option) == 0) {\n       Stack\n         *node;\n \n       size_t\n         size;\n \n       size=0;\n       node=cli_wand->image_info_stack;\n       for ( ; node != (Stack *) NULL; node=node->next)\n         size++;\n       if ( size >= MAX_STACK_DEPTH )\n         CLIWandExceptionBreak(OptionError,\"CurlyBracesNestedTooDeeply\",option);\n       node=(Stack *) AcquireMagickMemory(sizeof(*node));\n       if (node == (Stack *) NULL)\n         CLIWandExceptionBreak(ResourceLimitFatalError,\n             \"MemoryAllocationFailed\",option);\n \n       node->data = (void *)cli_wand->wand.image_info;\n       node->next = cli_wand->image_info_stack;\n \n       cli_wand->image_info_stack = node;\n       cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);\n       if (cli_wand->wand.image_info == (ImageInfo *) NULL) {\n         CLIWandException(ResourceLimitFatalError,\"MemoryAllocationFailed\",\n             option);\n         cli_wand->wand.image_info = (ImageInfo *)node->data;\n         node = (Stack *)RelinquishMagickMemory(node);\n         break;\n       }\n \n       break;\n     }\n     if (LocaleCompare(\")\",option) == 0) {\n       Stack\n         *node;\n \n       node = (Stack *)cli_wand->image_list_stack;\n       if ( node == (Stack *) NULL)\n         CLIWandExceptionBreak(OptionError,\"UnbalancedParenthesis\",option);\n       cli_wand->image_list_stack = node->next;\n \n       AppendImageToList((Image **)&node->data,cli_wand->wand.images);\n       cli_wand->wand.images= (Image *)node->data;\n       node = (Stack *)RelinquishMagickMemory(node);\n \n       node = cli_wand->image_info_stack;\n       if ( node != (Stack *) NULL)\n         {\n           if (IsStringTrue(GetImageOption(\n                 cli_wand->wand.image_info,\"respect-parenthesis\")) != MagickFalse)\n             option=\"}\";\n           else\n             break;\n         }\n       else\n         break;\n     }\n     if (LocaleCompare(\"}\",option) == 0) {\n       Stack\n         *node;\n \n       node = (Stack *)cli_wand->image_info_stack;\n       if ( node == (Stack *) NULL)\n         CLIWandExceptionBreak(OptionError,\"UnbalancedCurlyBraces\",option);\n       cli_wand->image_info_stack = node->next;\n \n       (void) DestroyImageInfo(cli_wand->wand.image_info);\n       cli_wand->wand.image_info = (ImageInfo *)node->data;\n       node = (Stack *)RelinquishMagickMemory(node);\n \n       GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);\n       cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);\n       cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);\n \n       break;\n     }\n       if (LocaleCompare(\"print\",option+1) == 0)\n         {\n           (void) FormatLocaleFile(stdout,\"%s\",arg1);\n           break;\n         }\n     if (LocaleCompare(\"set\",option+1) == 0)\n       {\n \n         arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n         if (arg1 == (char *) NULL)\n           CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                 option);\n \n         if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n           {\n             if (IfPlusOp)\n               {\n                 (void) DeleteImageRegistry(arg1+9);\n                 arg1=DestroyString((char *)arg1);\n                 break;\n               }\n             arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n             if (arg2 == (char *) NULL) {\n               arg1=DestroyString((char *)arg1);\n               CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                     option);\n             }\n             (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);\n             arg1=DestroyString((char *)arg1);\n             arg2=DestroyString((char *)arg2);\n             break;\n           }\n         if (LocaleNCompare(arg1,\"option:\",7) == 0)\n           {\n             if (_images != (Image *) NULL)\n               {\n                 MagickResetIterator(&cli_wand->wand);\n                 while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n                   (void) DeleteImageArtifact(_images,arg1+7);\n                 MagickResetIterator(&cli_wand->wand);\n               }\n             arg2=(char *) NULL;\n             if (IfNormalOp)\n               {\n                 arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                 if (arg2 == (char *) NULL)\n                   CLIWandExceptionBreak(OptionWarning,\n                        \"InterpretPropertyFailure\",option);\n               }\n             (void) SetImageOption(_image_info,arg1+7,arg2);\n             arg1=DestroyString((char *)arg1);\n             arg2=DestroyString((char *)arg2);\n             break;\n           }\n         if ( _images == (Image *) NULL )\n           CLIWandExceptArgBreak(OptionWarning,\"NoImageForProperty\",option,arg1);\n \n         MagickResetIterator(&cli_wand->wand);\n         while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n           {\n             arg2=(char *) NULL;\n             if (IfNormalOp)\n               {\n                 arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                 if (arg2 == (char *) NULL)\n                   CLIWandExceptionBreak(OptionWarning,\n                        \"InterpretPropertyFailure\",option);\n               }\n             if (LocaleNCompare(arg1,\"artifact:\",9) == 0)\n               (void) SetImageArtifact(_images,arg1+9,arg2);\n             else if (LocaleNCompare(arg1,\"property:\",9) == 0)\n               (void) SetImageProperty(_images,arg1+9,arg2,_exception);\n             else\n               (void) SetImageProperty(_images,arg1,arg2,_exception);\n             arg2=DestroyString((char *)arg2);\n           }\n         MagickResetIterator(&cli_wand->wand);\n         arg1=DestroyString((char *)arg1);\n         break;\n      }\n     if (LocaleCompare(\"clone\",option+1) == 0) {\n         Image\n           *new_images;\n \n         if (*option == '+')\n           arg1=AcquireString(\"-1\");\n         if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)\n           CLIWandExceptionBreak(OptionError,\"InvalidArgument\",option);\n         if ( cli_wand->image_list_stack == (Stack *) NULL)\n           CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n         new_images = (Image *)cli_wand->image_list_stack->data;\n         if (new_images == (Image *) NULL)\n           CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n         new_images=CloneImages(new_images,arg1,_exception);\n         if (new_images == (Image *) NULL)\n           CLIWandExceptionBreak(OptionError,\"NoSuchImage\",option);\n         AppendImageToList(&_images,new_images);\n         break;\n       }\n     if (LocaleCompare(\"version\",option+1) == 0)\n       {\n         ListMagickVersion(stdout);\n         break;\n       }\n     if (LocaleCompare(\"list\",option+1) == 0) {\n       ssize_t\n         list;\n \n       list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);\n       if ( list < 0 ) {\n         CLIWandExceptionArg(OptionError,\"UnrecognizedListType\",option,arg1);\n         break;\n       }\n       switch (list)\n       {\n         case MagickCoderOptions:\n         {\n           (void) ListCoderInfo((FILE *) NULL,_exception);\n           break;\n         }\n         case MagickColorOptions:\n         {\n           (void) ListColorInfo((FILE *) NULL,_exception);\n           break;\n         }\n         case MagickConfigureOptions:\n         {\n           (void) ListConfigureInfo((FILE *) NULL,_exception);\n           break;\n         }\n         case MagickDelegateOptions:\n         {\n           (void) ListDelegateInfo((FILE *) NULL,_exception);\n           break;\n         }\n         case MagickFontOptions:\n         {\n           (void) ListTypeInfo((FILE *) NULL,_exception);\n           break;\n         }\n         case MagickFormatOptions:\n           (void) ListMagickInfo((FILE *) NULL,_exception);\n           break;\n         case MagickLocaleOptions:\n           (void) ListLocaleInfo((FILE *) NULL,_exception);\n           break;\n         case MagickLogOptions:\n           (void) ListLogInfo((FILE *) NULL,_exception);\n           break;\n         case MagickMagicOptions:\n           (void) ListMagicInfo((FILE *) NULL,_exception);\n           break;\n         case MagickMimeOptions:\n           (void) ListMimeInfo((FILE *) NULL,_exception);\n           break;\n         case MagickModuleOptions:\n           (void) ListModuleInfo((FILE *) NULL,_exception);\n           break;\n         case MagickPolicyOptions:\n           (void) ListPolicyInfo((FILE *) NULL,_exception);\n           break;\n         case MagickResourceOptions:\n           (void) ListMagickResourceInfo((FILE *) NULL,_exception);\n           break;\n         case MagickThresholdOptions:\n           (void) ListThresholdMaps((FILE *) NULL,_exception);\n           break;\n         default:\n           (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n             _exception);\n           break;\n       }\n       break;\n     }\n \n     CLIWandException(OptionError,\"UnrecognizedOption\",option);\n \n DisableMSCWarning(4127)\n   } while (0);\n RestoreMSCWarning\n \n   if (arg1 != arg1n )\n     arg1=DestroyString((char *)arg1);\n   if (arg2 != arg2n )\n     arg2=DestroyString((char *)arg2);\n \n #undef _image_info\n #undef _images\n #undef _exception\n #undef IfNormalOp\n #undef IfPlusOp\n }\n \n", "target": "// fix_start\n      if (write_images != (Image *) NULL)\n        (void) WriteImages(write_info,write_images,arg1,_exception);\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-2719", "cve_desc": "In ImageMagick, a crafted file could trigger an assertion failure when a call to WriteImages was made in MagickWand/operation.c, due to a NULL image list. This could potentially cause a denial of service. This was fixed in upstream ImageMagick version 7.1.0-30.", "project": "ImageMagick", "idx": 204438}
{"source": " static int __io_sync_cancel(struct io_uring_task *tctx,\n \t\t\t    struct io_cancel_data *cd, int fd)\n {\n \tstruct io_ring_ctx *ctx = cd->ctx;\n \n \tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n \t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n \t\tunsigned long file_ptr;\n \n// bug_start\n\t\tif (unlikely(fd > ctx->nr_user_files))\n// bug_end\n \t\t\treturn -EBADF;\n \t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n \t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n \t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n \t\tif (!cd->file)\n \t\t\treturn -EBADF;\n \t}\n \n \treturn __io_async_cancel(cd, tctx, 0);\n }\n \n", "target": "// fix_start\n\t\tif (unlikely(fd >= ctx->nr_user_files))\n// fix_end\n", "cwe": "CWE-193", "cwe_name": "Off-by-one Error", "cve": "CVE-2022-3103", "cve_desc": "off-by-one in io_uring module.", "project": "linux", "idx": 204495}
{"source": " stl_remove_degenerate(stl_file *stl, int facet) {\n   int edge1;\n   int edge2;\n   int edge3;\n   int neighbor1;\n   int neighbor2;\n   int neighbor3;\n   int vnot1;\n   int vnot2;\n   int vnot3;\n \n   if (stl->error) return;\n \n   if(   !memcmp(&stl->facet_start[facet].vertex[0],\n                 &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))\n         && !memcmp(&stl->facet_start[facet].vertex[1],\n                    &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n     printf(\"removing a facet in stl_remove_degenerate\\n\");\n \n     stl_remove_facet(stl, facet);\n     return;\n   }\n \n   if(!memcmp(&stl->facet_start[facet].vertex[0],\n              &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {\n     edge1 = 1;\n     edge2 = 2;\n     edge3 = 0;\n   } else if(!memcmp(&stl->facet_start[facet].vertex[1],\n                     &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n     edge1 = 0;\n     edge2 = 2;\n     edge3 = 1;\n   } else if(!memcmp(&stl->facet_start[facet].vertex[2],\n                     &stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {\n     edge1 = 0;\n     edge2 = 1;\n     edge3 = 2;\n   } else {\n     return;\n   }\n   neighbor1 = stl->neighbors_start[facet].neighbor[edge1];\n   neighbor2 = stl->neighbors_start[facet].neighbor[edge2];\n \n// bug_start\n  if(neighbor1 == -1) {\n// bug_end\n     stl_update_connects_remove_1(stl, neighbor2);\n   }\n// bug_start\n  if(neighbor2 == -1) {\n// bug_end\n     stl_update_connects_remove_1(stl, neighbor1);\n   }\n// bug_start\n\n// bug_end\n \n   neighbor3 = stl->neighbors_start[facet].neighbor[edge3];\n   vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];\n   vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];\n   vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];\n \n   if(neighbor1 != -1){\n     stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;\n     stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;\n   }\n   if(neighbor2 != -1){\n     stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;\n     stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;\n   }\n \n   stl_remove_facet(stl, facet);\n \n   if(neighbor3 != -1) {\n     stl_update_connects_remove_1(stl, neighbor3);\n     stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;\n   }\n }\n \n", "target": "// fix_start\n  if(neighbor1 == -1 && neighbor2 != -1) {\n// fix_end\n// fix_start\n  else if (neighbor2 == -1 && neighbor1 != -1) {\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2018-25033", "cve_desc": "ADMesh through 0.98.4 has a heap-based buffer over-read in stl_update_connects_remove_1 (called from stl_remove_degenerate) in connect.c in libadmesh.a.", "project": "admesh", "idx": 204534}
{"source": " stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n   int j;\n \n// bug_start\n  if (stl->error) return;\n// bug_end\n   j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n        (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n        (stl->neighbors_start[facet_num].neighbor[2] == -1));\n   if(j == 0) {\n     stl->stats.connected_facets_3_edge -= 1;\n   } else if(j == 1) {\n     stl->stats.connected_facets_2_edge -= 1;\n   } else if(j == 2) {\n     stl->stats.connected_facets_1_edge -= 1;\n   }\n }\n \n", "target": "// fix_start\n  if (\n    stl->error ||\n    facet_num < 0\n  ) return;\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2018-25033", "cve_desc": "ADMesh through 0.98.4 has a heap-based buffer over-read in stl_update_connects_remove_1 (called from stl_remove_degenerate) in connect.c in libadmesh.a.", "project": "admesh", "idx": 204535}
{"source": " static int em28xx_usb_probe(struct usb_interface *intf,\n \t\t\t    const struct usb_device_id *id)\n {\n \tstruct usb_device *udev;\n \tstruct em28xx *dev = NULL;\n \tint retval;\n \tbool has_vendor_audio = false, has_video = false, has_dvb = false;\n \tint i, nr, try_bulk;\n \tconst int ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n \tchar *speed;\n \n \tudev = usb_get_dev(interface_to_usbdev(intf));\n \n \tdo {\n \t\tnr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS);\n \t\tif (nr >= EM28XX_MAXBOARDS) {\n \t\t\tdev_err(&intf->dev,\n \t\t\t\t\"Driver supports up to %i em28xx boards.\\n\",\n \t\t\t       EM28XX_MAXBOARDS);\n \t\t\tretval = -ENOMEM;\n \t\t\tgoto err_no_slot;\n \t\t}\n \t} while (test_and_set_bit(nr, em28xx_devused));\n \n \tif (intf->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n \t\tdev_info(&intf->dev,\n \t\t\t\"audio device (%04x:%04x): interface %i, class %i\\n\",\n \t\t\tle16_to_cpu(udev->descriptor.idVendor),\n \t\t\tle16_to_cpu(udev->descriptor.idProduct),\n \t\t\tifnum,\n \t\t\tintf->altsetting[0].desc.bInterfaceClass);\n \n \t\tretval = -ENODEV;\n \t\tgoto err;\n \t}\n \n \tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n \tif (!dev) {\n \t\tretval = -ENOMEM;\n \t\tgoto err;\n \t}\n \n \tdev->alt_max_pkt_size_isoc = kcalloc(intf->num_altsetting,\n \t\t\t\t\t     sizeof(dev->alt_max_pkt_size_isoc[0]),\n \t\t\t\t\t     GFP_KERNEL);\n \tif (!dev->alt_max_pkt_size_isoc) {\n \t\tkfree(dev);\n \t\tretval = -ENOMEM;\n \t\tgoto err;\n \t}\n \n \tfor (i = 0; i < intf->num_altsetting; i++) {\n \t\tint ep;\n \n \t\tfor (ep = 0;\n \t\t     ep < intf->altsetting[i].desc.bNumEndpoints;\n \t\t     ep++)\n \t\t\tem28xx_check_usb_descriptor(dev, udev, intf,\n \t\t\t\t\t\t    i, ep,\n \t\t\t\t\t\t    &has_vendor_audio,\n \t\t\t\t\t\t    &has_video,\n \t\t\t\t\t\t    &has_dvb);\n \t}\n \n \tif (!(has_vendor_audio || has_video || has_dvb)) {\n \t\tretval = -ENODEV;\n \t\tgoto err_free;\n \t}\n \n \tswitch (udev->speed) {\n \tcase USB_SPEED_LOW:\n \t\tspeed = \"1.5\";\n \t\tbreak;\n \tcase USB_SPEED_UNKNOWN:\n \tcase USB_SPEED_FULL:\n \t\tspeed = \"12\";\n \t\tbreak;\n \tcase USB_SPEED_HIGH:\n \t\tspeed = \"480\";\n \t\tbreak;\n \tdefault:\n \t\tspeed = \"unknown\";\n \t}\n \n \tdev_info(&intf->dev,\n \t\t\"New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\\n\",\n \t\tudev->manufacturer ? udev->manufacturer : \"\",\n \t\tudev->product ? udev->product : \"\",\n \t\tspeed,\n \t\tle16_to_cpu(udev->descriptor.idVendor),\n \t\tle16_to_cpu(udev->descriptor.idProduct),\n \t\tifnum,\n \t\tintf->altsetting->desc.bInterfaceNumber);\n \n \tif (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\n \t\tdev_err(&intf->dev, \"Device initialization failed.\\n\");\n \t\tdev_err(&intf->dev,\n \t\t\t\"Device must be connected to a high-speed USB 2.0 port.\\n\");\n \t\tretval = -ENODEV;\n \t\tgoto err_free;\n \t}\n \n// bug_start\n// bug_end\n \tdev->devno = nr;\n \tdev->model = id->driver_info;\n \tdev->alt   = -1;\n \tdev->is_audio_only = has_vendor_audio && !(has_video || has_dvb);\n \tdev->has_video = has_video;\n \tdev->ifnum = ifnum;\n \n \tdev->ts = PRIMARY_TS;\n \tsnprintf(dev->name, 28, \"em28xx\");\n \tdev->dev_next = NULL;\n \n \tif (has_vendor_audio) {\n \t\tdev_info(&intf->dev,\n \t\t\t\"Audio interface %i found (Vendor Class)\\n\", ifnum);\n \t\tdev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR;\n \t}\n \tfor (i = 0; i < udev->config->desc.bNumInterfaces; i++) {\n \t\tstruct usb_interface *uif = udev->config->interface[i];\n \n \t\tif (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n \t\t\tif (has_vendor_audio)\n \t\t\t\tdev_err(&intf->dev,\n \t\t\t\t\t\"em28xx: device seems to have vendor AND usb audio class interfaces !\\n\"\n \t\t\t\t\t\"\\t\\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\\n\");\n \t\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_CLASS;\n \t\t\tbreak;\n \t\t}\n \t}\n \n \tif (has_video)\n \t\tdev_info(&intf->dev, \"Video interface %i found:%s%s\\n\",\n \t\t\tifnum,\n \t\t\tdev->analog_ep_bulk ? \" bulk\" : \"\",\n \t\t\tdev->analog_ep_isoc ? \" isoc\" : \"\");\n \tif (has_dvb)\n \t\tdev_info(&intf->dev, \"DVB interface %i found:%s%s\\n\",\n \t\t\tifnum,\n \t\t\tdev->dvb_ep_bulk ? \" bulk\" : \"\",\n \t\t\tdev->dvb_ep_isoc ? \" isoc\" : \"\");\n \n \tdev->num_alt = intf->num_altsetting;\n \n \tif ((unsigned int)card[nr] < em28xx_bcount)\n \t\tdev->model = card[nr];\n \n \tusb_set_intfdata(intf, dev);\n \n \tmutex_init(&dev->lock);\n \tretval = em28xx_init_dev(dev, udev, intf, nr);\n \tif (retval)\n \t\tgoto err_free;\n \n \tif (usb_xfer_mode < 0) {\n \t\tif (dev->is_webcam)\n \t\t\ttry_bulk = 1;\n \t\telse\n \t\t\ttry_bulk = 0;\n \t} else {\n \t\ttry_bulk = usb_xfer_mode > 0;\n \t}\n \n \tif (has_video &&\n \t    dev->board.decoder == EM28XX_NODECODER &&\n \t    dev->em28xx_sensor == EM28XX_NOSENSOR) {\n \t\tdev_err(&intf->dev,\n \t\t\t\"Currently, V4L2 is not supported on this model\\n\");\n \t\thas_video = false;\n \t\tdev->has_video = false;\n \t}\n \n \tif (dev->board.has_dual_ts &&\n \t    (dev->tuner_type != TUNER_ABSENT || INPUT(0)->type)) {\n \t\tdev_err(&intf->dev,\n \t\t\t\"We currently don't support analog TV or stream capture on dual tuners.\\n\");\n \t\thas_video = false;\n \t}\n \n \tif (has_video) {\n \t\tif (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk))\n \t\t\tdev->analog_xfer_bulk = 1;\n \t\tdev_info(&intf->dev, \"analog set to %s mode.\\n\",\n \t\t\tdev->analog_xfer_bulk ? \"bulk\" : \"isoc\");\n \t}\n \tif (has_dvb) {\n \t\tif (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk))\n \t\t\tdev->dvb_xfer_bulk = 1;\n \t\tdev_info(&intf->dev, \"dvb set to %s mode.\\n\",\n \t\t\tdev->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n \t}\n \n \tif (dev->board.has_dual_ts && em28xx_duplicate_dev(dev) == 0) {\n// bug_start\n// bug_end\n \t\tdev->dev_next->ts = SECONDARY_TS;\n \t\tdev->dev_next->alt   = -1;\n \t\tdev->dev_next->is_audio_only = has_vendor_audio &&\n \t\t\t\t\t\t!(has_video || has_dvb);\n \t\tdev->dev_next->has_video = false;\n \t\tdev->dev_next->ifnum = ifnum;\n \t\tdev->dev_next->model = id->driver_info;\n \n \t\tmutex_init(&dev->dev_next->lock);\n \t\tretval = em28xx_init_dev(dev->dev_next, udev, intf,\n \t\t\t\t\t dev->dev_next->devno);\n \t\tif (retval)\n \t\t\tgoto err_free;\n \n \t\tdev->dev_next->board.ir_codes = NULL;\n \t\tdev->dev_next->board.has_ir_i2c = 0;\n \n \t\tif (usb_xfer_mode < 0) {\n \t\t\tif (dev->dev_next->is_webcam)\n \t\t\t\ttry_bulk = 1;\n \t\t\telse\n \t\t\t\ttry_bulk = 0;\n \t\t} else {\n \t\t\ttry_bulk = usb_xfer_mode > 0;\n \t\t}\n \n \t\tif (has_dvb) {\n \t\t\tif (!dev->dvb_ep_isoc_ts2 ||\n \t\t\t    (try_bulk && dev->dvb_ep_bulk_ts2))\n \t\t\t\tdev->dev_next->dvb_xfer_bulk = 1;\n \t\t\tdev_info(&dev->intf->dev, \"dvb ts2 set to %s mode.\\n\",\n \t\t\t\t dev->dev_next->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n \t\t}\n \n \t\tdev->dev_next->dvb_ep_isoc = dev->dvb_ep_isoc_ts2;\n \t\tdev->dev_next->dvb_ep_bulk = dev->dvb_ep_bulk_ts2;\n \t\tdev->dev_next->dvb_max_pkt_size_isoc = dev->dvb_max_pkt_size_isoc_ts2;\n \t\tdev->dev_next->dvb_alt_isoc = dev->dvb_alt_isoc;\n \n \t\tif (dev->dvb_xfer_bulk) {\n \t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n \t\t\tmdelay(100);\n \t\t\tem28xx_write_reg(dev, 0x0b, 0x80);\n \t\t\tmdelay(100);\n \t\t} else {\n \t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n \t\t\tmdelay(100);\n \t\t\tem28xx_write_reg(dev, 0x0b, 0x82);\n \t\t\tmdelay(100);\n \t\t}\n// bug_start\n\n\t\tkref_init(&dev->dev_next->ref);\n\t}\n\n\tkref_init(&dev->ref);\n// bug_end\n \n \trequest_modules(dev);\n \n #ifdef CONFIG_MEDIA_CONTROLLER\n \tretval = media_device_register(dev->media_dev);\n #endif\n \n \treturn 0;\n \n err_free:\n \tkfree(dev->alt_max_pkt_size_isoc);\n \tkfree(dev);\n \n err:\n \tclear_bit(nr, em28xx_devused);\n \n err_no_slot:\n \tusb_put_dev(udev);\n \treturn retval;\n }\n \n", "target": "// fix_start\n\tkref_init(&dev->ref);\n\n// fix_end\n// fix_start\n\t\tkref_init(&dev->dev_next->ref);\n\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-3239", "cve_desc": "A flaw use after free in the Linux kernel video4linux driver was found in the way user triggers em28xx_usb_probe() for the Empia 28xx based TV cards. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.", "project": "linux", "idx": 204544}
{"source": " static void sixpack_close(struct tty_struct *tty)\n {\n \tstruct sixpack *sp;\n \n \twrite_lock_irq(&disc_data_lock);\n \tsp = tty->disc_data;\n \ttty->disc_data = NULL;\n \twrite_unlock_irq(&disc_data_lock);\n \tif (!sp)\n \t\treturn;\n \n \tif (!refcount_dec_and_test(&sp->refcnt))\n \t\twait_for_completion(&sp->dead);\n \n \tnetif_stop_queue(sp->dev);\n \n// bug_start\n// bug_end\n \tdel_timer_sync(&sp->tx_t);\n \tdel_timer_sync(&sp->resync_t);\n// bug_start\n\n\tunregister_netdev(sp->dev);\n// bug_end\n \n \tkfree(sp->rbuff);\n \tkfree(sp->xbuff);\n \n \tfree_netdev(sp->dev);\n }\n \n", "target": "// fix_start\n\tunregister_netdev(sp->dev);\n\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-1198", "cve_desc": "A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space.", "project": "linux", "idx": 204814}
{"source": " struct vfsmount *clone_private_mount(const struct path *path)\n {\n \tstruct mount *old_mnt = real_mount(path->mnt);\n \tstruct mount *new_mnt;\n \n// bug_start\n// bug_end\n \tif (IS_MNT_UNBINDABLE(old_mnt))\n// bug_start\n\t\treturn ERR_PTR(-EINVAL);\n// bug_end\n \n \tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n// bug_start\n// bug_end\n \tif (IS_ERR(new_mnt))\n \t\treturn ERR_CAST(new_mnt);\n \n \tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n \n \treturn &new_mnt->mnt;\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n\tdown_read(&namespace_sem);\n// fix_end\n// fix_start\n\t\tgoto invalid;\n\n\tif (!check_mnt(old_mnt))\n\t\tgoto invalid;\n\n\tif (has_locked_children(old_mnt, path->dentry))\n\t\tgoto invalid;\n// fix_end\n// fix_start\n\tup_read(&namespace_sem);\n\n// fix_end\n// fix_start\n\ninvalid:\n\tup_read(&namespace_sem);\n\treturn ERR_PTR(-EINVAL);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-3732", "cve_desc": "A flaw was found in the Linux kernel's OverlayFS subsystem in the way the user mounts the TmpFS filesystem with OverlayFS. This flaw allows a local user to gain access to hidden files that should not be accessible.", "project": "linux", "idx": 204830}
{"source": " static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n {\n \tstruct kiocb *kiocb = &req->rw.kiocb;\n \tstruct io_ring_ctx *ctx = req->ctx;\n \tstruct file *file = req->file;\n \tint ret;\n \n \tif (unlikely(!file || !(file->f_mode & mode)))\n \t\treturn -EBADF;\n \n \tif (!io_req_ffs_set(req))\n \t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n \n \tkiocb->ki_flags = iocb_flags(file);\n \tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n \tif (unlikely(ret))\n \t\treturn ret;\n \n \tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n \t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n \t\treq->flags |= REQ_F_NOWAIT;\n \n \tif (ctx->flags & IORING_SETUP_IOPOLL) {\n \t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n \t\t\treturn -EOPNOTSUPP;\n \n// bug_start\n// bug_end\n \t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n \t\tkiocb->ki_complete = io_complete_rw_iopoll;\n \t\treq->iopoll_completed = 0;\n \t} else {\n \t\tif (kiocb->ki_flags & IOCB_HIPRI)\n \t\t\treturn -EINVAL;\n \t\tkiocb->ki_complete = io_complete_rw;\n \t}\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tkiocb->private = NULL;\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "cve": "CVE-2022-29968", "cve_desc": "An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file in fs/io_uring.c lacks initialization of kiocb->private.", "project": "linux", "idx": 205630}
{"source": " static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n \tpyc_object *ret = NULL;\n \tbool error = false;\n// bug_start\n\tut32 size = 0;\n// bug_end\n \tut32 n1 = 0;\n \tut32 n2 = 0;\n \n \tret = RZ_NEW0(pyc_object);\n \tif (!ret) {\n \t\treturn NULL;\n \t}\n \n \tif ((pyc->magic_int & 0xffff) <= 62061) {\n \t\tn1 = get_ut8(buffer, &error);\n \t} else {\n \t\tn1 = get_st32(buffer, &error);\n \t}\n// bug_start\n\tif (error) {\n// bug_end\n \t\tfree(ret);\n \t\treturn NULL;\n \t}\n \tut8 *s1 = malloc(n1 + 1);\n \tif (!s1) {\n \t\treturn NULL;\n \t}\n// bug_start\n\tsize = rz_buf_read(buffer, s1, n1);\n\tif (size != n1) {\n// bug_end\n \t\tRZ_FREE(s1);\n \t\tRZ_FREE(ret);\n \t\treturn NULL;\n \t}\n \ts1[n1] = '\\0';\n \n \tif ((pyc->magic_int & 0xffff) <= 62061) {\n \t\tn2 = get_ut8(buffer, &error);\n// bug_start\n\t} else\n// bug_end\n \t\tn2 = get_st32(buffer, &error);\n// bug_start\n\tif (error) {\n// bug_end\n \t\treturn NULL;\n \t}\n \tut8 *s2 = malloc(n2 + 1);\n \tif (!s2) {\n \t\treturn NULL;\n \t}\n// bug_start\n\tsize = rz_buf_read(buffer, s2, n2);\n\tif (size != n2) {\n// bug_end\n \t\tRZ_FREE(s1);\n \t\tRZ_FREE(s2);\n \t\tRZ_FREE(ret);\n \t\treturn NULL;\n \t}\n \ts2[n2] = '\\0';\n \n \tret->type = TYPE_COMPLEX;\n \tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n \tRZ_FREE(s1);\n \tRZ_FREE(s2);\n \tif (!ret->data) {\n \t\tRZ_FREE(ret);\n \t\treturn NULL;\n \t}\n \treturn ret;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n// fix_end\n// fix_start\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n// fix_end\n// fix_start\n\t} else {\n// fix_end\n// fix_start\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n// fix_end\n// fix_start\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-36040", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from PYC(python) files. A user opening a malicious PYC file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch.", "project": "rizin", "idx": 205734}
{"source": " static inline void fuse_make_bad(struct inode *inode)\n {\n// bug_start\n// bug_end\n \tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n }\n \n", "target": "// fix_start\n\tremove_inode_hash(inode);\n// fix_end\n", "cwe": "CWE-834", "cwe_name": "Excessive Iteration", "cve": "CVE-2021-28950", "cve_desc": "An issue was discovered in fs/fuse/fuse_i.h in the Linux kernel before 5.11.8. A \"stall on CPU\" can occur because a retry loop continually finds the same bad inode, aka CID-775c5033a0d1.", "project": "linux", "idx": 205736}
{"source": " void sdb_edit(procinfo *pi)\n {\n// bug_start\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n// bug_end\n   {\n     Print(\"cannot open %s\\n\",filename);\n     omFree(filename);\n     return;\n   }\n   if (pi->language!= LANG_SINGULAR)\n   {\n     Print(\"cannot edit type %d\\n\",pi->language);\n// bug_start\n    fclose(fp);\n    fp=NULL;\n// bug_end\n   }\n   else\n   {\n     const char *editor=getenv(\"EDITOR\");\n     if (editor==NULL)\n       editor=getenv(\"VISUAL\");\n     if (editor==NULL)\n       editor=\"vi\";\n     editor=omStrDup(editor);\n \n     if (pi->data.s.body==NULL)\n     {\n       iiGetLibProcBuffer(pi);\n       if (pi->data.s.body==NULL)\n       {\n         PrintS(\"cannot get the procedure body\\n\");\n// bug_start\n        fclose(fp);\n// bug_end\n         si_unlink(filename);\n         omFree(filename);\n         return;\n       }\n     }\n \n// bug_start\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n// bug_end\n \n     int pid=fork();\n     if (pid!=0)\n     {\n       si_wait(&pid);\n     }\n     else if(pid==0)\n     {\n       if (strchr(editor,' ')==NULL)\n       {\n         execlp(editor,editor,filename,NULL);\n         Print(\"cannot exec %s\\n\",editor);\n       }\n       else\n       {\n         char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n         sprintf(p,\"%s %s\",editor,filename);\n         system(p);\n       }\n       exit(0);\n     }\n     else\n     {\n       PrintS(\"cannot fork\\n\");\n     }\n \n// bug_start\n    fp=fopen(filename,\"r\");\n// bug_end\n     if (fp==NULL)\n     {\n       Print(\"cannot read from %s\\n\",filename);\n     }\n     else\n     {\n       fseek(fp,0L,SEEK_END);\n       long len=ftell(fp);\n       fseek(fp,0L,SEEK_SET);\n \n       omFree((ADDRESS)pi->data.s.body);\n       pi->data.s.body=(char *)omAlloc((int)len+1);\n       myfread( pi->data.s.body, len, 1, fp);\n       pi->data.s.body[len]='\\0';\n       fclose(fp);\n     }\n   }\n   si_unlink(filename);\n   omFree(filename);\n }\n \n", "target": "// fix_start\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n// fix_end\n// fix_start\n    close(f);\n    f=NULL;\n// fix_end\n// fix_start\n        close(f);\n// fix_end\n// fix_start\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n// fix_end\n// fix_start\n    FILE* fp=fopen(filename,\"r\");\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "cve": "CVE-2022-40299", "cve_desc": "In Singular before 4.3.1, a predictable /tmp pathname is used (e.g., by sdb.cc), which allows local users to gain the privileges of other users via a procedure in a file under /tmp. NOTE: this CVE Record is about sdb.cc and similar files in the Singular interface that have predictable /tmp pathnames; this CVE Record is not about the lack of a safe temporary-file creation capability in the Singular language.", "project": "Singular", "idx": 205806}
{"source": " ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                              ovs_be16 dl_type, uint16_t zone, long long now,\n                              uint32_t hash_basis)\n {\n     const size_t pb_cnt = dp_packet_batch_size(pb);\n     int pb_idx;\n     struct dp_packet *pkt;\n \n     DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n         if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                           ipf_is_valid_v4_frag(ipf, pkt))\n                           ||\n                           (dl_type == htons(ETH_TYPE_IPV6) &&\n                           ipf_is_valid_v6_frag(ipf, pkt)))) {\n \n             ovs_mutex_lock(&ipf->ipf_lock);\n             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                 dp_packet_batch_refill(pb, pkt, pb_idx);\n// bug_start\n// bug_end\n             }\n             ovs_mutex_unlock(&ipf->ipf_lock);\n         } else {\n             dp_packet_batch_refill(pb, pkt, pb_idx);\n         }\n     }\n }\n \n", "target": "// fix_start\n            } else {\n                dp_packet_delete(pkt);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2021-3905", "cve_desc": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.", "project": "ovs", "idx": 205823}
{"source": " gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                        const gchar *keyid)\n {\n// bug_start\n// bug_end\n \tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n \t\treturn;\n \n \tif (!gpg->recipients)\n \t\tgpg->recipients = g_ptr_array_new ();\n \n// bug_start\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n// bug_end\n }\n \n", "target": "// fix_start\n\tgchar *safe_keyid;\n\n// fix_end\n// fix_start\n\tg_return_if_fail (keyid != NULL);\n\n\tif (strchr (keyid, '@') != NULL) {\n\t\tsafe_keyid = g_strdup_printf (\"<%s>\", keyid);\n\t} else {\n\t\tsafe_keyid = g_strdup (keyid);\n\t}\n\n\tg_ptr_array_add (gpg->recipients, safe_keyid);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2013-4166", "cve_desc": "The gpg_ctx_add_recipient function in camel/camel-gpg-context.c in GNOME Evolution 3.8.4 and earlier and Evolution Data Server 3.9.5 and earlier does not properly select the GPG key to use for email encryption, which might cause the email to be encrypted with the wrong key and allow remote attackers to obtain sensitive information.", "project": "evolution-data-server", "idx": 206025}
{"source": " load_image (const gchar  *filename,\n             GError      **error)\n {\n   gchar             *name;\n   gint               fd;\n   BrushHeader        bh;\n   guchar            *brush_buf = NULL;\n   gint32             image_ID;\n   gint32             layer_ID;\n   GimpParasite      *parasite;\n   GimpDrawable      *drawable;\n   GimpPixelRgn       pixel_rgn;\n   gint               bn_size;\n   GimpImageBaseType  base_type;\n   GimpImageType      image_type;\n   gsize              size;\n \n   fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n \n   if (fd == -1)\n     {\n       g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                    _(\"Could not open '%s' for reading: %s\"),\n                    gimp_filename_to_utf8 (filename), g_strerror (errno));\n       return -1;\n     }\n \n   gimp_progress_init_printf (_(\"Opening '%s'\"),\n                              gimp_filename_to_utf8 (filename));\n \n   if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n     {\n       close (fd);\n       return -1;\n     }\n \n   bh.header_size  = g_ntohl (bh.header_size);\n   bh.version      = g_ntohl (bh.version);\n   bh.width        = g_ntohl (bh.width);\n   bh.height       = g_ntohl (bh.height);\n   bh.bytes        = g_ntohl (bh.bytes);\n   bh.magic_number = g_ntohl (bh.magic_number);\n   bh.spacing      = g_ntohl (bh.spacing);\n \n   if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n       (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n       ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n        (bh.bytes != 18)) ||\n       (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n     {\n       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                    _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                      \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                    (unsigned long int)bh.width, (unsigned long int)bh.height,\n                    (unsigned long int)bh.bytes);\n       return -1;\n     }\n \n   switch (bh.version)\n     {\n     case 1:\n       bh.spacing = 25;\n       lseek (fd, -8, SEEK_CUR);\n       bh.header_size += 8;\n       break;\n \n     case 3:\n       if (bh.bytes == 18 )\n         {\n           bh.bytes = 2;\n         }\n       else\n         {\n           g_message (_(\"Unsupported brush format\"));\n           close (fd);\n           return -1;\n         }\n \n     case 2:\n       if (bh.magic_number == GBRUSH_MAGIC &&\n           bh.header_size  >  sizeof (BrushHeader))\n         break;\n \n     default:\n       g_message (_(\"Unsupported brush format\"));\n       close (fd);\n       return -1;\n     }\n \n   if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n     {\n       gchar *temp = g_new (gchar, bn_size);\n \n// bug_start\n      if ((read (fd, temp, bn_size)) < bn_size)\n// bug_end\n         {\n           g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                        _(\"Error in GIMP brush file '%s'\"),\n                        gimp_filename_to_utf8 (filename));\n           close (fd);\n           g_free (temp);\n           return -1;\n         }\n \n       name = gimp_any_to_utf8 (temp, -1,\n                                _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                                gimp_filename_to_utf8 (filename));\n       g_free (temp);\n     }\n   else\n     {\n       name = g_strdup (_(\"Unnamed\"));\n     }\n \n \n   size = bh.width * bh.height * bh.bytes;\n   brush_buf = g_malloc (size);\n \n   if (read (fd, brush_buf, size) != size)\n     {\n       close (fd);\n       g_free (brush_buf);\n       g_free (name);\n       return -1;\n     }\n \n   switch (bh.bytes)\n     {\n     case 1:\n       {\n         PatternHeader ph;\n \n \n         if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n           {\n             ph.header_size  = g_ntohl (ph.header_size);\n             ph.version      = g_ntohl (ph.version);\n             ph.width        = g_ntohl (ph.width);\n             ph.height       = g_ntohl (ph.height);\n             ph.bytes        = g_ntohl (ph.bytes);\n             ph.magic_number = g_ntohl (ph.magic_number);\n \n             if (ph.magic_number == GPATTERN_MAGIC        &&\n                 ph.version      == 1                     &&\n                 ph.header_size  > sizeof (PatternHeader) &&\n                 ph.bytes        == 3                     &&\n                 ph.width        == bh.width              &&\n                 ph.height       == bh.height             &&\n                 lseek (fd, ph.header_size - sizeof (PatternHeader),\n                        SEEK_CUR) > 0)\n               {\n                 guchar *plain_brush = brush_buf;\n                 gint    i;\n \n                 bh.bytes = 4;\n                 brush_buf = g_malloc (4 * bh.width * bh.height);\n \n                 for (i = 0; i < ph.width * ph.height; i++)\n                   {\n                     if (read (fd, brush_buf + i * 4, 3) != 3)\n                       {\n                         close (fd);\n                         g_free (name);\n                         g_free (plain_brush);\n                         g_free (brush_buf);\n                         return -1;\n                       }\n                     brush_buf[i * 4 + 3] = plain_brush[i];\n                   }\n                 g_free (plain_brush);\n               }\n           }\n       }\n       break;\n \n     case 2:\n       {\n         guint16 *buf = (guint16 *) brush_buf;\n         gint     i;\n \n         for (i = 0; i < bh.width * bh.height; i++, buf++)\n           {\n             union\n             {\n               guint16 u[2];\n               gfloat  f;\n             } short_float;\n \n #if G_BYTE_ORDER == G_LITTLE_ENDIAN\n             short_float.u[0] = 0;\n             short_float.u[1] = GUINT16_FROM_BE (*buf);\n #else\n             short_float.u[0] = GUINT16_FROM_BE (*buf);\n             short_float.u[1] = 0;\n #endif\n \n             brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n           }\n \n         bh.bytes = 1;\n       }\n       break;\n \n     default:\n       break;\n     }\n \n \n   switch (bh.bytes)\n     {\n     case 1:\n       base_type = GIMP_GRAY;\n       image_type = GIMP_GRAY_IMAGE;\n       break;\n \n     case 4:\n       base_type = GIMP_RGB;\n       image_type = GIMP_RGBA_IMAGE;\n       break;\n \n     default:\n       g_message (\"Unsupported brush depth: %d\\n\"\n                  \"GIMP Brushes must be GRAY or RGBA\\n\",\n                  bh.bytes);\n       g_free (name);\n       return -1;\n     }\n \n   image_ID = gimp_image_new (bh.width, bh.height, base_type);\n   gimp_image_set_filename (image_ID, filename);\n \n   parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                 GIMP_PARASITE_PERSISTENT,\n                                 strlen (name) + 1, name);\n   gimp_image_attach_parasite (image_ID, parasite);\n   gimp_parasite_free (parasite);\n \n   layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                              image_type, 100, GIMP_NORMAL_MODE);\n   gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n \n   g_free (name);\n \n   drawable = gimp_drawable_get (layer_ID);\n   gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                        0, 0, drawable->width, drawable->height,\n                        TRUE, FALSE);\n \n   gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                            0, 0, bh.width, bh.height);\n   g_free (brush_buf);\n \n   if (image_type == GIMP_GRAY_IMAGE)\n     gimp_invert (layer_ID);\n \n   close (fd);\n \n   gimp_drawable_flush (drawable);\n   gimp_progress_update (1.0);\n \n   return image_ID;\n }\n \n", "target": "// fix_start\n      if ((read (fd, temp, bn_size)) < bn_size ||\n          temp[bn_size - 1] != '\\0')\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2017-17784", "cve_desc": "In GIMP 2.8.22, there is a heap-based buffer over-read in load_image in plug-ins/common/file-gbr.c in the gbr import parser, related to mishandling of UTF-8 data.", "project": "gimp", "idx": 206043}
{"source": " void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                   rdr::ZlibInStream* zis,\n                   const PixelFormat& pf, ModifiablePixelBuffer* pb)\n {\n   int length = is->readU32();\n   zis->setUnderlying(is, length);\n   Rect t;\n   PIXEL_T buf[64 * 64];\n \n   for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n \n     t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n \n     for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n \n       t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n \n       int mode = zis->readU8();\n       bool rle = mode & 128;\n       int palSize = mode & 127;\n       PIXEL_T palette[128];\n \n       for (int i = 0; i < palSize; i++) {\n         palette[i] = READ_PIXEL(zis);\n       }\n \n       if (palSize == 1) {\n         PIXEL_T pix = palette[0];\n         pb->fillRect(pf, t, &pix);\n         continue;\n       }\n \n       if (!rle) {\n         if (palSize == 0) {\n \n \n #ifdef CPIXEL\n           for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n             *ptr = READ_PIXEL(zis);\n           }\n #else\n           zis->readBytes(buf, t.area() * (BPP / 8));\n #endif\n \n         } else {\n \n           int bppp = ((palSize > 16) ? 8 :\n                       ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n \n           PIXEL_T* ptr = buf;\n \n           for (int i = 0; i < t.height(); i++) {\n             PIXEL_T* eol = ptr + t.width();\n             rdr::U8 byte = 0;\n             rdr::U8 nbits = 0;\n \n             while (ptr < eol) {\n               if (nbits == 0) {\n                 byte = zis->readU8();\n                 nbits = 8;\n               }\n               nbits -= bppp;\n               rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n               *ptr++ = palette[index];\n             }\n           }\n         }\n \n       } else {\n \n         if (palSize == 0) {\n \n \n           PIXEL_T* ptr = buf;\n           PIXEL_T* end = ptr + t.area();\n           while (ptr < end) {\n             PIXEL_T pix = READ_PIXEL(zis);\n             int len = 1;\n             int b;\n             do {\n               b = zis->readU8();\n               len += b;\n             } while (b == 255);\n \n             if (end - ptr < len) {\n               throw Exception (\"ZRLE decode error\");\n             }\n \n             while (len-- > 0) *ptr++ = pix;\n \n           }\n         } else {\n \n \n           PIXEL_T* ptr = buf;\n           PIXEL_T* end = ptr + t.area();\n           while (ptr < end) {\n             int index = zis->readU8();\n             int len = 1;\n             if (index & 128) {\n               int b;\n               do {\n                 b = zis->readU8();\n                 len += b;\n               } while (b == 255);\n \n               if (end - ptr < len) {\n                 throw Exception (\"ZRLE decode error\");\n               }\n             }\n \n             index &= 127;\n \n             PIXEL_T pix = palette[index];\n \n             while (len-- > 0) *ptr++ = pix;\n           }\n         }\n       }\n \n       pb->imageRect(pf, t, buf);\n     }\n   }\n \n// bug_start\n  zis->removeUnderlying();\n// bug_end\n }\n \n", "target": "// fix_start\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n// fix_end\n", "cwe": "CWE-672", "cwe_name": "Operation on a Resource after Expiration or Release", "cve": "CVE-2019-15691", "cve_desc": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.", "project": "tigervnc", "idx": 206044}
{"source": " parse_command_modifiers(\n \texarg_T\t    *eap,\n \tchar\t    **errormsg,\n \tcmdmod_T    *cmod,\n \tint\t    skip_only)\n {\n     char_u  *orig_cmd = eap->cmd;\n     char_u  *cmd_start = NULL;\n     int\t    use_plus_cmd = FALSE;\n     int\t    starts_with_colon = FALSE;\n     int\t    vim9script = in_vim9script();\n     int\t    has_visual_range = FALSE;\n \n     CLEAR_POINTER(cmod);\n     cmod->cmod_flags = sticky_cmdmod_flags;\n \n     if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n     {\n \teap->cmd += 5;\n \tcmd_start = eap->cmd;\n \thas_visual_range = TRUE;\n     }\n \n     for (;;)\n     {\n \tchar_u  *p;\n \n \twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n \t{\n \t    if (*eap->cmd == ':')\n \t\tstarts_with_colon = TRUE;\n \t    ++eap->cmd;\n \t}\n \n \tif (*eap->cmd == NUL && exmode_active\n \t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n \t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n \t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n \t{\n \t    use_plus_cmd = TRUE;\n \t    if (!skip_only)\n \t\tex_pressedreturn = TRUE;\n \t    break;\n \t}\n \n \tif (comment_start(eap->cmd, starts_with_colon))\n \t{\n \t    if (eap->nextcmd == NULL)\n \t    {\n \t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n \t\tif (eap->nextcmd != NULL)\n \t\t    ++eap->nextcmd;\n \t    }\n \t    if (vim9script && has_cmdmod(cmod, FALSE))\n \t\t*errormsg = _(e_command_modifier_without_command);\n \t    return FAIL;\n \t}\n \tif (*eap->cmd == NUL)\n \t{\n \t    if (!skip_only)\n \t    {\n \t\tex_pressedreturn = TRUE;\n \t\tif (vim9script && has_cmdmod(cmod, FALSE))\n \t\t    *errormsg = _(e_command_modifier_without_command);\n \t    }\n \t    return FAIL;\n \t}\n \n \tp = skip_range(eap->cmd, TRUE, NULL);\n \n \tif (vim9script)\n \t{\n \t    char_u *s, *n;\n \n \t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n \t\t;\n \t    n = skipwhite(s);\n \t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n \t\t    || *s == '[')\n \t\tbreak;\n \t}\n \n \tswitch (*p)\n \t{\n \t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n \t\t\t    break;\n \t\t\tcmod->cmod_split |= WSP_ABOVE;\n \t\t\tcontinue;\n \n \t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n \t\t\t{\n \t\t\t    cmod->cmod_split |= WSP_BELOW;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n \t\t\t{\n #ifdef FEAT_BROWSE_CMD\n \t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n #endif\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n \t\t\t    break;\n \t\t\tcmod->cmod_split |= WSP_BOT;\n \t\t\tcontinue;\n \n \t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n \t\t\t    break;\n #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n \t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n #endif\n \t\t\tcontinue;\n \n \t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n \t\t\t{\n \t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n \t\t\t{\n \t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n \t\t\t{\n \t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n \t\t\t    break;\n \t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n \t\t\tcontinue;\n \n \t    case 'f':\n \t\t\t{\n \t\t\t    char_u  *reg_pat;\n \t\t\t    char_u  *nulp = NULL;\n \t\t\t    int\t    c = 0;\n \n \t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n \t\t\t\t    || *p == NUL\n \t\t\t\t    || (ends_excmd(*p)\n #ifdef FEAT_EVAL\n \t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n #endif\n \t\t\t\t     ))\n \t\t\t\tbreak;\n \t\t\t    if (*p == '!')\n \t\t\t    {\n \t\t\t\tcmod->cmod_filter_force = TRUE;\n \t\t\t\tp = skipwhite(p + 1);\n \t\t\t\tif (*p == NUL || ends_excmd(*p))\n \t\t\t\t    break;\n \t\t\t    }\n #ifdef FEAT_EVAL\n \t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n \t\t\t\tbreak;\n #endif\n \t\t\t    if (skip_only)\n \t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n \t\t\t    else\n \t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n \t\t\t\t\t\t\t\t    &nulp, &c);\n \t\t\t    if (p == NULL || *p == NUL)\n \t\t\t\tbreak;\n \t\t\t    if (!skip_only)\n \t\t\t    {\n \t\t\t\tcmod->cmod_filter_regmatch.regprog =\n \t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n \t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n \t\t\t\t    break;\n \t\t\t\tif (nulp != NULL)\n \t\t\t\t    *nulp = c;\n \t\t\t    }\n \t\t\t    eap->cmd = p;\n \t\t\t    continue;\n \t\t\t}\n \n \t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n \t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n \t\t\t    break;\n \t\t\teap->cmd = p;\n \t\t\tcmod->cmod_flags |= CMOD_HIDE;\n \t\t\tcontinue;\n \n \t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n \t\t\t{\n \t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n \t\t\t{\n \t\t\t    if (ends_excmd2(p, eap->cmd))\n \t\t\t    {\n \t\t\t\t*errormsg =\n \t\t\t\t      _(e_legacy_must_be_followed_by_command);\n \t\t\t\treturn FAIL;\n \t\t\t    }\n \t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n \t\t\t    continue;\n \t\t\t}\n \n \t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n \t\t\t    break;\n \t\t\tcmod->cmod_split |= WSP_ABOVE;\n \t\t\tcontinue;\n \n \t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n \t\t\t{\n \t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n \t\t\t    break;\n \t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n \t\t\tcontinue;\n \n \t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n \t\t\t    break;\n \t\t\tcmod->cmod_split |= WSP_BELOW;\n \t\t\tcontinue;\n \n \t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n \t\t\t{\n \t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n \t\t\t    break;\n \t\t\tcmod->cmod_flags |= CMOD_SILENT;\n \t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n \t\t\t{\n \t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n \t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n \t\t\t}\n \t\t\tcontinue;\n \n \t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n \t\t\t{\n \t\t\t    if (!skip_only)\n \t\t\t    {\n \t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n \t\t\t\t\t\t    ADDR_TABS, eap->skip,\n \t\t\t\t\t\t    skip_only, FALSE, 1);\n \t\t\t\tif (tabnr == MAXLNUM)\n \t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n \t\t\t\t    {\n \t\t\t\t\t*errormsg = _(e_invalid_range);\n \t\t\t\t\treturn FAIL;\n \t\t\t\t    }\n \t\t\t\t    cmod->cmod_tab = tabnr + 1;\n \t\t\t\t}\n \t\t\t    }\n \t\t\t    eap->cmd = p;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n \t\t\t    break;\n \t\t\tcmod->cmod_split |= WSP_TOP;\n \t\t\tcontinue;\n \n \t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n \t\t\t    break;\n \t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n \t\t\tcontinue;\n \n \t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n \t\t\t{\n \t\t\t    cmod->cmod_split |= WSP_VERT;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n \t\t\t{\n \t\t\t    if (ends_excmd2(p, eap->cmd))\n \t\t\t    {\n \t\t\t\t*errormsg =\n \t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n \t\t\t\treturn FAIL;\n \t\t\t    }\n \t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n \t\t\t    continue;\n \t\t\t}\n \t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n \t\t\t    break;\n \t\t\tif (vim_isdigit(*eap->cmd))\n \t\t\t{\n \t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n \t\t\t}\n \t\t\telse\n \t\t\t    cmod->cmod_verbose = 2;\n \t\t\teap->cmd = p;\n \t\t\tcontinue;\n \t}\n \tbreak;\n     }\n \n     if (has_visual_range)\n     {\n \tif (eap->cmd > cmd_start)\n \t{\n \t    if (use_plus_cmd)\n \t    {\n \t\tsize_t len = STRLEN(cmd_start);\n \n \t\tmch_memmove(orig_cmd, cmd_start, len);\n// bug_start\n\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n// bug_end\n \t    }\n \t    else\n \t    {\n \t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n \t\teap->cmd -= 5;\n \t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n \t    }\n \t}\n \telse\n \t    if (use_plus_cmd)\n \t\teap->cmd = (char_u *)\"'<,'>+\";\n \t    else\n \t\teap->cmd = orig_cmd;\n     }\n     else if (use_plus_cmd)\n \teap->cmd = (char_u *)\"+\";\n \n     return OK;\n }\n \n", "target": "// fix_start\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2288", "cve_desc": "Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.", "project": "vim", "idx": 206262}
{"source": " static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n \tst64 ptr = 0;\n \tchar *addr, *esil_buf = NULL;\n \tconst st64 maxstackframe = 1024 * 8;\n \n \tr_return_if_fail (anal && fcn && op && reg);\n \n \tsize_t i;\n \tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n \t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n \t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n \t\t\t\tst64 delta = op->src[i]->delta;\n \t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n \t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \tif (!ptr) {\n \t\tconst char *op_esil = r_strbuf_get (&op->esil);\n \t\tif (!op_esil) {\n \t\t\treturn;\n \t\t}\n \t\tesil_buf = strdup (op_esil);\n \t\tif (!esil_buf) {\n \t\t\treturn;\n \t\t}\n \t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n \t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n \t\tif (!ptr_end) {\n \t\t\tfree (esil_buf);\n \t\t\treturn;\n \t\t}\n \t\t*ptr_end = 0;\n \t\taddr = ptr_end;\n \t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n \t\t\taddr--;\n \t\t}\n \t\tif (strncmp (addr, \"0x\", 2)) {\n \t\t\tif (!op->stackop && op->dst) {\n \t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n \t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n \t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n \t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n \t\t\t\t\tif (anal->verbose) {\n \t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n \t\t\t\t\t}\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (*addr == ',') {\n \t\t\t\taddr++;\n \t\t\t}\n \t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n \t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n \t\t\t\tptr = (st64)r_num_get (NULL, addr);\n \t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n \t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n \t\t\t\tif (op->ptr % 4) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n \t\t\t\tptr = R_ABS (op->ptr);\n \t\t\t} else {\n \t\t\t\tgoto beach;\n \t\t\t}\n \t\t} else {\n \t\t\tptr = (st64)r_num_get (NULL, addr);\n \t\t}\n \t}\n \n \tif (anal->verbose && (!op->src[0] || !op->dst)) {\n \t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n \t}\n \n \tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n \tif (*sign == '+') {\n \t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n \t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n \t\tst64 frame_off;\n \t\tif (type == R_ANAL_VAR_KIND_SPV) {\n \t\t\tframe_off = ptr - fcn->stack;\n \t\t} else {\n \t\t\tframe_off = ptr - fcn->bp_off;\n \t\t}\n \t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n \t\t\tgoto beach;\n \t\t}\n \t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n \t\tif (var) {\n \t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n \t\t\tgoto beach;\n \t\t}\n \t\tchar *varname = NULL, *vartype = NULL;\n \t\tif (isarg) {\n \t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n \t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n \t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n \t\t\tif (fname) {\n \t\t\t\tut64 sum_sz = 0;\n \t\t\t\tsize_t from, to, i;\n \t\t\t\tif (stack_rev) {\n \t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n \t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n \t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n \t\t\t\t} else {\n \t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n \t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n \t\t\t\t}\n \t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n \t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n \t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n \t\t\t\t\tif (!tp) {\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tif (sum_sz == frame_off) {\n \t\t\t\t\t\tvartype = tp;\n \t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n \t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n \t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n \t\t\t\t\tfree (tp);\n \t\t\t\t}\n \t\t\t\tfree (fname);\n \t\t\t}\n \t\t}\n \t\tif (!varname) {\n \t\t\tif (anal->opt.varname_stack) {\n \t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n \t\t\t} else {\n \t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n \t\t\t}\n \t\t}\n \t\tif (varname) {\n #if 0\n \t\t\tif (isarg && frame_off > 48) {\n \t\t\t\tfree (varname);\n \t\t\t\tgoto beach;\n \t\t\t}\n #endif\n \t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n \t\t\tif (var) {\n \t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n \t\t\t}\n \t\t\tfree (varname);\n \t\t}\n \t\tfree (vartype);\n \t} else {\n \t\tst64 frame_off = -(ptr + fcn->bp_off);\n// bug_start\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n// bug_end\n \t\t\tgoto beach;\n \t\t}\n \t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n \t\tif (var) {\n \t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n \t\t\tgoto beach;\n \t\t}\n \t\tchar *varname = anal->opt.varname_stack\n \t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n \t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n \t\tif (varname) {\n \t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n \t\t\tif (var) {\n \t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n \t\t\t}\n \t\t\tfree (varname);\n \t\t}\n \t}\n beach:\n \tfree (esil_buf);\n }\n \n", "target": "// fix_start\n\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-1031", "cve_desc": "Use After Free in op_is_set_bp in GitHub repository radareorg/radare2 prior to 5.6.6.", "project": "radare2", "idx": 206273}
{"source": " ins_bs(\n     int\t\tc,\n     int\t\tmode,\n     int\t\t*inserted_space_p)\n {\n     linenr_T\tlnum;\n     int\t\tcc;\n     int\t\ttemp = 0;\n     colnr_T\tsave_col;\n     colnr_T\tmincol;\n     int\t\tdid_backspace = FALSE;\n     int\t\tin_indent;\n     int\t\toldState;\n     int\t\tcpc[MAX_MCO];\n     int\t\tcall_fix_indent = FALSE;\n \n     if (       BUFEMPTY()\n \t    || (\n #ifdef FEAT_RIGHTLEFT\n \t\t!revins_on &&\n #endif\n \t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n \t\t    || (!can_bs(BS_START)\n \t\t\t&& ((arrow_used\n #ifdef FEAT_JOB_CHANNEL\n \t\t\t\t&& !bt_prompt(curbuf)\n #endif\n \t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n \t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n \t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n \t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n \t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n     {\n \tvim_beep(BO_BS);\n \treturn FALSE;\n     }\n \n     if (stop_arrow() == FAIL)\n \treturn FALSE;\n     in_indent = inindent(0);\n     if (in_indent)\n \tcan_cindent = FALSE;\n     end_comment_pending = NUL;\n #ifdef FEAT_RIGHTLEFT\n     if (revins_on)\n \tinc_cursor();\n #endif\n \n     if (curwin->w_cursor.coladd > 0)\n     {\n \tif (mode == BACKSPACE_CHAR)\n \t{\n \t    --curwin->w_cursor.coladd;\n \t    return TRUE;\n \t}\n \tif (mode == BACKSPACE_WORD)\n \t{\n \t    curwin->w_cursor.coladd = 0;\n \t    return TRUE;\n \t}\n \tcurwin->w_cursor.coladd = 0;\n     }\n \n     if (curwin->w_cursor.col == 0)\n     {\n \tlnum = Insstart.lnum;\n \tif (curwin->w_cursor.lnum == lnum\n #ifdef FEAT_RIGHTLEFT\n \t\t\t|| revins_on\n #endif\n \t\t\t\t    )\n \t{\n \t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n \t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n \t\treturn FALSE;\n \t    --Insstart.lnum;\n \t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n \t}\n \tcc = -1;\n \tif (State & REPLACE_FLAG)\n \t    cc = replace_pop();\n \tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n \t{\n \t    dec_cursor();\n \t}\n \telse\n \t{\n \t    if (!(State & VREPLACE_FLAG)\n \t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n \t    {\n \t\ttemp = gchar_cursor();\n \t\t--curwin->w_cursor.lnum;\n \n \t\tif (has_format_option(FO_AUTO)\n \t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n \t\t{\n \t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n \t\t\t\t\t\t\t\t\tTRUE);\n \t\t    int\t    len;\n \n \t\t    len = (int)STRLEN(ptr);\n \t\t    if (len > 0 && ptr[len - 1] == ' ')\n \t\t\tptr[len - 1] = NUL;\n \t\t}\n \n \t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n \t\tif (temp == NUL && gchar_cursor() != NUL)\n \t\t    inc_cursor();\n \t    }\n \t    else\n \t\tdec_cursor();\n \n \t    if (State & REPLACE_FLAG)\n \t    {\n \t\toldState = State;\n \t\tState = MODE_NORMAL;\n \t\twhile (cc > 0)\n \t\t{\n \t\t    save_col = curwin->w_cursor.col;\n \t\t    mb_replace_pop_ins(cc);\n \t\t    curwin->w_cursor.col = save_col;\n \t\t    cc = replace_pop();\n \t\t}\n \t\treplace_pop_ins();\n \t\tState = oldState;\n \t    }\n \t}\n \tdid_ai = FALSE;\n     }\n     else\n     {\n #ifdef FEAT_RIGHTLEFT\n \tif (revins_on)\n \t    dec_cursor();\n #endif\n \tmincol = 0;\n \tif (mode == BACKSPACE_LINE\n \t\t&& (curbuf->b_p_ai || cindent_on())\n #ifdef FEAT_RIGHTLEFT\n \t\t&& !revins_on\n #endif\n \t\t\t    )\n \t{\n \t    save_col = curwin->w_cursor.col;\n \t    beginline(BL_WHITE);\n \t    if (curwin->w_cursor.col < save_col)\n \t    {\n \t\tmincol = curwin->w_cursor.col;\n \t\tcall_fix_indent = TRUE;\n \t    }\n \t    curwin->w_cursor.col = save_col;\n \t}\n \n \tif (\t   mode == BACKSPACE_CHAR\n \t\t&& ((p_sta && in_indent)\n \t\t    || ((get_sts_value() != 0\n #ifdef FEAT_VARTABS\n \t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n #endif\n \t\t\t)\n \t\t\t&& curwin->w_cursor.col > 0\n \t\t\t&& (*(ml_get_cursor() - 1) == TAB\n \t\t\t    || (*(ml_get_cursor() - 1) == ' '\n \t\t\t\t&& (!*inserted_space_p\n \t\t\t\t    || arrow_used))))))\n \t{\n \t    int\t\tts;\n \t    colnr_T\tvcol;\n \t    colnr_T\twant_vcol;\n \t    colnr_T\tstart_vcol;\n \n \t    *inserted_space_p = FALSE;\n \t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n \t    start_vcol = vcol;\n \t    dec_cursor();\n \t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n \t    inc_cursor();\n #ifdef FEAT_VARTABS\n \t    if (p_sta && in_indent)\n \t    {\n \t\tts = (int)get_sw_value(curbuf);\n \t\twant_vcol = (want_vcol / ts) * ts;\n \t    }\n \t    else\n \t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n \t\t\t\t\t\t       curbuf->b_p_vsts_array);\n #else\n \t    if (p_sta && in_indent)\n \t\tts = (int)get_sw_value(curbuf);\n \t    else\n \t\tts = (int)get_sts_value();\n \t    want_vcol = (want_vcol / ts) * ts;\n #endif\n \n// bug_start\n\t    while (vcol > want_vcol\n// bug_end\n \t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n \t\tins_bs_one(&vcol);\n \n \t    while (vcol < want_vcol)\n \t    {\n \t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n \t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n \t\t    Insstart_orig.col = curwin->w_cursor.col;\n \n \t\tif (State & VREPLACE_FLAG)\n \t\t    ins_char(' ');\n \t\telse\n \t\t{\n \t\t    ins_str((char_u *)\" \");\n \t\t    if ((State & REPLACE_FLAG))\n \t\t\treplace_push(NUL);\n \t\t}\n \t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n \t    }\n \n \t    if (vcol >= start_vcol)\n \t\tins_bs_one(&vcol);\n \t}\n \n \telse\n \t{\n \t    int cclass = 0, prev_cclass = 0;\n \n \t    if (has_mbyte)\n \t\tcclass = mb_get_class(ml_get_cursor());\n \t    do\n \t    {\n #ifdef FEAT_RIGHTLEFT\n \t\tif (!revins_on)\n #endif\n \t\t    dec_cursor();\n \n \t\tcc = gchar_cursor();\n \t\tif (has_mbyte)\n \t\t{\n \t\t    prev_cclass = cclass;\n \t\t    cclass = mb_get_class(ml_get_cursor());\n \t\t}\n \n \t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n \t\t{\n \t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n \t\t    temp = vim_iswordc(cc);\n \t\t}\n \t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n \t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n \t\t\t|| prev_cclass != cclass))\n \t\t{\n #ifdef FEAT_RIGHTLEFT\n \t\t    if (!revins_on)\n #endif\n \t\t\tinc_cursor();\n #ifdef FEAT_RIGHTLEFT\n \t\t    else if (State & REPLACE_FLAG)\n \t\t\tdec_cursor();\n #endif\n \t\t    break;\n \t\t}\n \t\tif (State & REPLACE_FLAG)\n \t\t    replace_do_bs(-1);\n \t\telse\n \t\t{\n \t\t    if (enc_utf8 && p_deco)\n \t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n \t\t    (void)del_char(FALSE);\n \t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n \t\t\tinc_cursor();\n #ifdef FEAT_RIGHTLEFT\n \t\t    if (revins_chars)\n \t\t    {\n \t\t\trevins_chars--;\n \t\t\trevins_legal++;\n \t\t    }\n \t\t    if (revins_on && gchar_cursor() == NUL)\n \t\t\tbreak;\n #endif\n \t\t}\n \t\tif (mode == BACKSPACE_CHAR)\n \t\t    break;\n \t    } while (\n #ifdef FEAT_RIGHTLEFT\n \t\t    revins_on ||\n #endif\n \t\t    (curwin->w_cursor.col > mincol\n \t\t    &&  (can_bs(BS_NOSTOP)\n \t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n \t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n \t\t    )));\n \t}\n \tdid_backspace = TRUE;\n     }\n     did_si = FALSE;\n     can_si = FALSE;\n     can_si_back = FALSE;\n     if (curwin->w_cursor.col <= 1)\n \tdid_ai = FALSE;\n \n     if (call_fix_indent)\n \tfix_indent();\n \n     AppendCharToRedobuff(c);\n \n     if (curwin->w_cursor.lnum == Insstart_orig.lnum\n \t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n \tInsstart_orig.col = curwin->w_cursor.col;\n \n     if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n \tdollar_vcol = curwin->w_virtcol;\n \n #ifdef FEAT_FOLDING\n     if (did_backspace)\n \tfoldOpenCursor();\n #endif\n \n     return did_backspace;\n }\n \n", "target": "// fix_start\n\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2207", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 206417}
{"source": " static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n {\n \tint rlen, remain;\n \tdpIOCtxPtr dctx;\n \tdynamicPtr *dp;\n \n \tdctx = (dpIOCtxPtr) ctx;\n \tdp = dctx->dp;\n \n \tremain = dp->logicalSize - dp->pos;\n \tif (remain >= len) {\n \t\trlen = len;\n \t} else {\n// bug_start\n\t\tif (remain == 0) {\n// bug_end\n \t\t\treturn EOF;\n \t\t}\n \t\trlen = remain;\n \t}\n \n \tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n \tdp->pos += rlen;\n \n \treturn rlen;\n }\n \n", "target": "// fix_start\n\t\tif (remain <= 0) {\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2016-8670", "cve_desc": "Integer signedness error in the dynamicGetbuf function in gd_io_dp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted imagecreatefromstring call.", "project": "php-src", "idx": 206555}
{"source": "// bug_start\ngdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n// bug_end\n {\n// bug_start\n  int lastBorder;\n  int leftLimit, rightLimit;\n  int i;\n  leftLimit = (-1);\n  if (border < 0)\n    {\n      return;\n    }\n  for (i = x; (i >= 0); i--)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n// bug_end\n \t}\n// bug_start\n      gdImageSetPixel (im, i, y, color);\n      leftLimit = i;\n    }\n  if (leftLimit == (-1))\n    {\n      return;\n    }\n  rightLimit = x;\n  for (i = (x + 1); (i < im->sx); i++)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n// bug_end\n \t}\n// bug_start\n      gdImageSetPixel (im, i, y, color);\n      rightLimit = i;\n    }\n  if (y > 0)\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y - 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y - 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n// bug_end\n \t\t}\n// bug_start\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n// bug_end\n \t}\n// bug_start\n    }\n  if (y < ((im->sy) - 1))\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y + 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y + 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n// bug_end\n \t\t}\n// bug_start\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n// bug_end\n \t}\n// bug_start\n    }\n// bug_end\n }\n \n", "target": "// fix_start\nvoid gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n// fix_end\n// fix_start\n\tint lastBorder;\n\tint leftLimit = -1, rightLimit;\n\tint i;\n\n\tif (border < 0) {\n\t\treturn;\n// fix_end\n// fix_start\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n// fix_end\n// fix_start\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n// fix_end\n// fix_start\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n// fix_end\n// fix_start\n\tif (leftLimit == -1) {\n\t\treturn;\n\t}\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n// fix_end\n// fix_start\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n// fix_end\n// fix_start\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2015-8874", "cve_desc": "Stack consumption vulnerability in GD in PHP before 5.6.12 allows remote attackers to cause a denial of service via a crafted imagefilltoborder call.", "project": "php-src", "idx": 206588}
{"source": " raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                        raptor_xml_element* element,\n                                        int auto_empty)\n {\n   raptor_iostream* iostr = xml_writer->iostr;\n   raptor_namespace_stack *nstack = xml_writer->nstack;\n   int depth = xml_writer->depth;\n   int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n   struct nsd *nspace_declarations = NULL;\n   size_t nspace_declarations_count = 0;\n   unsigned int i;\n \n   if(nstack) {\n// bug_start\n    int nspace_max_count = element->attribute_count+1;\n// bug_end\n     if(element->declared_nspaces)\n       nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n     if(element->xml_language)\n       nspace_max_count++;\n \n     nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                         sizeof(struct nsd));\n     if(!nspace_declarations)\n       return 1;\n   }\n \n   if(element->name->nspace) {\n     if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n       nspace_declarations[0].declaration=\n         raptor_namespace_format_as_xml(element->name->nspace,\n                                        &nspace_declarations[0].length);\n       if(!nspace_declarations[0].declaration)\n         goto error;\n       nspace_declarations[0].nspace = element->name->nspace;\n       nspace_declarations_count++;\n     }\n   }\n \n   if(nstack && element->attributes) {\n     for(i = 0; i < element->attribute_count; i++) {\n       if(element->attributes[i]->nspace) {\n         if(nstack &&\n            !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n           unsigned int j;\n           int declare_me = 1;\n \n           for(j = 0; j < nspace_declarations_count; j++)\n             if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n               declare_me = 0;\n               break;\n             }\n \n           if(declare_me) {\n             nspace_declarations[nspace_declarations_count].declaration=\n               raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                              &nspace_declarations[nspace_declarations_count].length);\n             if(!nspace_declarations[nspace_declarations_count].declaration)\n               goto error;\n             nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n             nspace_declarations_count++;\n           }\n         }\n       }\n \n       nspace_declarations[nspace_declarations_count].declaration=\n         raptor_qname_format_as_xml(element->attributes[i],\n                                    &nspace_declarations[nspace_declarations_count].length);\n       if(!nspace_declarations[nspace_declarations_count].declaration)\n         goto error;\n       nspace_declarations[nspace_declarations_count].nspace = NULL;\n       nspace_declarations_count++;\n \n     }\n   }\n \n   if(nstack && element->declared_nspaces &&\n      raptor_sequence_size(element->declared_nspaces) > 0) {\n     for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n       raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n       unsigned int j;\n       int declare_me = 1;\n \n       for(j = 0; j < nspace_declarations_count; j++)\n         if(nspace_declarations[j].nspace == nspace) {\n           declare_me = 0;\n           break;\n         }\n \n       if(declare_me) {\n         nspace_declarations[nspace_declarations_count].declaration=\n           raptor_namespace_format_as_xml(nspace,\n                                          &nspace_declarations[nspace_declarations_count].length);\n         if(!nspace_declarations[nspace_declarations_count].declaration)\n           goto error;\n         nspace_declarations[nspace_declarations_count].nspace = nspace;\n         nspace_declarations_count++;\n       }\n \n     }\n   }\n \n   if(nstack && element->xml_language) {\n     size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n #define XML_LANG_PREFIX_LEN 10\n     size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n     unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n     const char quote = '\\\"';\n     unsigned char* p;\n \n     memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n     p = buffer + XML_LANG_PREFIX_LEN;\n     p += raptor_xml_escape_string(xml_writer->world,\n                                   element->xml_language, lang_len,\n                                   p, buf_length, quote);\n     *p++ = quote;\n     *p = '\\0';\n \n     nspace_declarations[nspace_declarations_count].declaration = buffer;\n     nspace_declarations[nspace_declarations_count].length = buf_length;\n     nspace_declarations[nspace_declarations_count].nspace = NULL;\n     nspace_declarations_count++;\n   }\n \n \n   raptor_iostream_write_byte('<', iostr);\n \n   if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n     raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix,\n                                          element->name->nspace->prefix_length,\n                                          iostr);\n     raptor_iostream_write_byte(':', iostr);\n   }\n   raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                        element->name->local_name_length,\n                                        iostr);\n \n   if(nspace_declarations_count) {\n     int need_indent = 0;\n \n     qsort((void*)nspace_declarations,\n           nspace_declarations_count, sizeof(struct nsd),\n           raptor_xml_writer_nsd_compare);\n \n     for(i = 0; i < nspace_declarations_count; i++) {\n       if(!nspace_declarations[i].nspace)\n         continue;\n \n       if(auto_indent && need_indent) {\n         raptor_xml_writer_newline(xml_writer);\n         xml_writer->depth++;\n         raptor_xml_writer_indent(xml_writer);\n         xml_writer->depth--;\n       }\n       raptor_iostream_write_byte(' ', iostr);\n       raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                            nspace_declarations[i].length,\n                                            iostr);\n       RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n       nspace_declarations[i].declaration = NULL;\n       need_indent = 1;\n \n       if(raptor_namespace_stack_start_namespace(nstack,\n                                                 (raptor_namespace*)nspace_declarations[i].nspace,\n                                                 depth))\n         goto error;\n     }\n \n     for(i = 0; i < nspace_declarations_count; i++) {\n       if(nspace_declarations[i].nspace)\n         continue;\n \n       if(auto_indent && need_indent) {\n         raptor_xml_writer_newline(xml_writer);\n         xml_writer->depth++;\n         raptor_xml_writer_indent(xml_writer);\n         xml_writer->depth--;\n       }\n       raptor_iostream_write_byte(' ', iostr);\n       raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                            nspace_declarations[i].length,\n                                            iostr);\n       need_indent = 1;\n \n       RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n       nspace_declarations[i].declaration = NULL;\n     }\n   }\n \n   if(!auto_empty)\n     raptor_iostream_write_byte('>', iostr);\n \n   if(nstack)\n     RAPTOR_FREE(stringarray, nspace_declarations);\n \n   return 0;\n \n   error:\n \n   for(i = 0; i < nspace_declarations_count; i++) {\n     if(nspace_declarations[i].declaration)\n       RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n   }\n \n   RAPTOR_FREE(stringarray, nspace_declarations);\n \n   return 1;\n }\n \n", "target": "// fix_start\n    int nspace_max_count = element->attribute_count * 2;\n    if(element->name->nspace)\n      nspace_max_count++;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2017-18926", "cve_desc": "raptor_xml_writer_start_element_common in raptor_xml_writer.c in Raptor RDF Syntax Library 2.0.15 miscalculates the maximum nspace declarations for the XML writer, leading to heap-based buffer overflows (sometimes seen in raptor_qname_format_as_xml).", "project": "raptor", "idx": 206625}
{"source": " static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n \t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n {\n \tu8 genmask = nft_genmask_next(ctx->net);\n \tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n \tstruct nft_chain *chain;\n \tint err;\n \n \terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n \t\t\t\t\t  nft_verdict_policy, NULL);\n \tif (err < 0)\n \t\treturn err;\n \n \tif (!tb[NFTA_VERDICT_CODE])\n \t\treturn -EINVAL;\n \tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n \n \tswitch (data->verdict.code) {\n \tdefault:\n \t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n \t\tcase NF_ACCEPT:\n \t\tcase NF_DROP:\n \t\tcase NF_QUEUE:\n \t\t\tbreak;\n \t\tdefault:\n \t\t\treturn -EINVAL;\n \t\t}\n \t\tfallthrough;\n \tcase NFT_CONTINUE:\n \tcase NFT_BREAK:\n \tcase NFT_RETURN:\n \t\tbreak;\n \tcase NFT_JUMP:\n \tcase NFT_GOTO:\n \t\tif (tb[NFTA_VERDICT_CHAIN]) {\n \t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n \t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n \t\t\t\t\t\t genmask);\n \t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n \t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n \t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n \t\t\tif (IS_ERR(chain))\n \t\t\t\treturn PTR_ERR(chain);\n \t\t} else {\n \t\t\treturn -EINVAL;\n \t\t}\n \n \t\tif (IS_ERR(chain))\n \t\t\treturn PTR_ERR(chain);\n \t\tif (nft_is_base_chain(chain))\n \t\t\treturn -EOPNOTSUPP;\n// bug_start\n// bug_end\n \t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n \t\t    chain->flags & NFT_CHAIN_BINDING)\n \t\t\treturn -EINVAL;\n \n \t\tchain->use++;\n \t\tdata->verdict.chain = chain;\n \t\tbreak;\n \t}\n \n \tdesc->len = sizeof(data->verdict);\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-39190", "cve_desc": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.", "project": "linux", "idx": 206639}
{"source": " negotiate_handshake_newstyle_options (void)\n {\n   GET_CONN;\n   struct nbd_new_option new_option;\n   size_t nr_options;\n   bool list_seen = false;\n   uint64_t version;\n   uint32_t option;\n   uint32_t optlen;\n   struct nbd_export_name_option_reply handshake_finish;\n   const char *optname;\n   uint64_t exportsize;\n   struct backend *b;\n \n   for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {\n     CLEANUP_FREE char *data = NULL;\n \n     if (conn_recv_full (&new_option, sizeof new_option,\n                         \"reading option: conn->recv: %m\") == -1)\n       return -1;\n \n     version = be64toh (new_option.version);\n     if (version != NBD_NEW_VERSION) {\n       nbdkit_error (\"unknown option version %\" PRIx64\n                     \", expecting %\" PRIx64,\n                     version, NBD_NEW_VERSION);\n       return -1;\n     }\n \n     optlen = be32toh (new_option.optlen);\n     if (optlen > MAX_REQUEST_SIZE) {\n       nbdkit_error (\"client option data too long (%\" PRIu32 \")\", optlen);\n       return -1;\n     }\n     data = malloc (optlen + 1);\n     if (data == NULL) {\n       nbdkit_error (\"malloc: %m\");\n       return -1;\n     }\n \n     option = be32toh (new_option.option);\n     optname = name_of_nbd_opt (option);\n \n     if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&\n         option != NBD_OPT_EXPORT_NAME) {\n       if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))\n         return -1;\n       continue;\n     }\n \n     if (tls == 2 && !conn->using_tls &&\n         !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {\n       if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))\n         return -1;\n       continue;\n     }\n \n     switch (option) {\n     case NBD_OPT_EXPORT_NAME:\n       if (conn_recv_full (data, optlen,\n                           \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n         return -1;\n       if (check_export_name (option, data, optlen, optlen) == -1)\n         return -1;\n \n       if (finish_newstyle_options (&exportsize, data, optlen) == -1)\n         return -1;\n \n       memset (&handshake_finish, 0, sizeof handshake_finish);\n       handshake_finish.exportsize = htobe64 (exportsize);\n       handshake_finish.eflags = htobe16 (conn->eflags);\n \n       if (conn->send (&handshake_finish,\n                       (conn->cflags & NBD_FLAG_NO_ZEROES)\n                       ? offsetof (struct nbd_export_name_option_reply, zeroes)\n                       : sizeof handshake_finish, 0) == -1) {\n         nbdkit_error (\"write: %s: %m\", optname);\n         return -1;\n       }\n       break;\n \n     case NBD_OPT_ABORT:\n       if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n         return -1;\n       debug (\"client sent %s to abort the connection\",\n              name_of_nbd_opt (option));\n       return -1;\n \n     case NBD_OPT_LIST:\n       if (optlen != 0) {\n         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n             == -1)\n           return -1;\n         if (conn_recv_full (data, optlen,\n                             \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n           return -1;\n         continue;\n       }\n \n       if (list_seen) {\n         debug (\"newstyle negotiation: %s: export list already advertised\",\n                name_of_nbd_opt (option));\n         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n           return -1;\n         continue;\n       }\n       else {\n         debug (\"newstyle negotiation: %s: advertising exports\",\n                name_of_nbd_opt (option));\n         if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)\n           return -1;\n         list_seen = true;\n       }\n       break;\n \n     case NBD_OPT_STARTTLS:\n       if (optlen != 0) {\n         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n             == -1)\n           return -1;\n         if (conn_recv_full (data, optlen,\n                             \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n           return -1;\n         continue;\n       }\n \n       if (tls == 0) {\n #ifdef HAVE_GNUTLS\n #define NO_TLS_REPLY NBD_REP_ERR_POLICY\n #else\n #define NO_TLS_REPLY NBD_REP_ERR_UNSUP\n #endif\n         if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)\n           return -1;\n       }\n       else  {\n         if (conn->using_tls) {\n           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n             return -1;\n           continue;\n         }\n \n         if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n           return -1;\n \n         if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)\n           return -1;\n         conn->using_tls = true;\n         debug (\"using TLS on this connection\");\n         conn->structured_replies = false;\n// bug_start\n// bug_end\n         for_each_backend (b) {\n           free (conn->default_exportname[b->i]);\n           conn->default_exportname[b->i] = NULL;\n         }\n       }\n       break;\n \n     case NBD_OPT_INFO:\n     case NBD_OPT_GO:\n       if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n         return -1;\n \n       if (optlen < 6) {\n         debug (\"newstyle negotiation: %s option length < 6\", optname);\n \n         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n             == -1)\n           return -1;\n         continue;\n       }\n \n       {\n         uint32_t exportnamelen;\n         uint16_t nrinfos;\n         uint16_t info;\n         size_t i;\n \n         memcpy (&exportnamelen, &data[0], 4);\n         exportnamelen = be32toh (exportnamelen);\n         if (exportnamelen > optlen-6 ) {\n           debug (\"newstyle negotiation: %s: export name too long\", optname);\n           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n               == -1)\n             return -1;\n           continue;\n         }\n         memcpy (&nrinfos, &data[exportnamelen+4], 2);\n         nrinfos = be16toh (nrinfos);\n         if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {\n           debug (\"newstyle negotiation: %s: \"\n                  \"number of information requests incorrect\", optname);\n           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n               == -1)\n             return -1;\n           continue;\n         }\n \n         if (check_export_name (option, &data[4], exportnamelen,\n                                optlen - 6) == -1) {\n           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n               == -1)\n             return -1;\n           continue;\n         }\n \n         if (finish_newstyle_options (&exportsize,\n                                      &data[4], exportnamelen) == -1) {\n           if (conn->top_context) {\n             if (backend_finalize (conn->top_context) == -1)\n               return -1;\n             backend_close (conn->top_context);\n             conn->top_context = NULL;\n           }\n           if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)\n             return -1;\n           continue;\n         }\n \n         if (send_newstyle_option_reply_info_export (option,\n                                                     NBD_REP_INFO,\n                                                     NBD_INFO_EXPORT,\n                                                     exportsize) == -1)\n           return -1;\n \n         for (i = 0; i < nrinfos; ++i) {\n           memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);\n           info = be16toh (info);\n           switch (info) {\n           case NBD_INFO_EXPORT:  break;\n           case NBD_INFO_NAME:\n             {\n               const char *name = &data[4];\n               size_t namelen = exportnamelen;\n \n               if (exportnamelen == 0) {\n                 name = backend_default_export (top, read_only);\n                 if (!name) {\n                   debug (\"newstyle negotiation: %s: \"\n                          \"NBD_INFO_NAME: no name to send\", optname);\n                   break;\n                 }\n                 namelen = -1;\n               }\n               if (send_newstyle_option_reply_info_str (option,\n                                                        NBD_REP_INFO,\n                                                        NBD_INFO_NAME,\n                                                        name, namelen) == -1)\n                 return -1;\n             }\n             break;\n           case NBD_INFO_DESCRIPTION:\n             {\n               const char *desc = backend_export_description (conn->top_context);\n \n               if (!desc) {\n                 debug (\"newstyle negotiation: %s: \"\n                        \"NBD_INFO_DESCRIPTION: no description to send\",\n                        optname);\n                 break;\n               }\n               if (send_newstyle_option_reply_info_str (option,\n                                                        NBD_REP_INFO,\n                                                        NBD_INFO_DESCRIPTION,\n                                                        desc, -1) == -1)\n                 return -1;\n             }\n             break;\n           default:\n             debug (\"newstyle negotiation: %s: \"\n                    \"ignoring NBD_INFO_* request %u (%s)\",\n                    optname, (unsigned) info, name_of_nbd_info (info));\n             break;\n           }\n         }\n       }\n \n       if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n         return -1;\n \n       if (option == NBD_OPT_INFO) {\n         if (backend_finalize (conn->top_context) == -1)\n           return -1;\n         backend_close (conn->top_context);\n         conn->top_context = NULL;\n       }\n \n       break;\n \n     case NBD_OPT_STRUCTURED_REPLY:\n       if (optlen != 0) {\n         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n             == -1)\n           return -1;\n         if (conn_recv_full (data, optlen,\n                             \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n           return -1;\n         continue;\n       }\n \n       debug (\"newstyle negotiation: %s: client requested structured replies\",\n              name_of_nbd_opt (option));\n \n       if (no_sr) {\n         if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n           return -1;\n         debug (\"newstyle negotiation: %s: structured replies are disabled\",\n                name_of_nbd_opt (option));\n         break;\n       }\n \n       if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n         return -1;\n \n       conn->structured_replies = true;\n       break;\n \n     case NBD_OPT_LIST_META_CONTEXT:\n     case NBD_OPT_SET_META_CONTEXT:\n       {\n         uint32_t opt_index;\n         uint32_t exportnamelen;\n         uint32_t nr_queries;\n         uint32_t querylen;\n         const char *what;\n \n         if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n           return -1;\n \n         if (!conn->structured_replies) {\n           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n               == -1)\n             return -1;\n           continue;\n         }\n \n         what = \"optlen < 8\";\n         if (optlen < 8) {\n         opt_meta_invalid_option_len:\n           debug (\"newstyle negotiation: %s: invalid option length: %s\",\n                  optname, what);\n \n           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n               == -1)\n             return -1;\n           continue;\n         }\n \n         memcpy (&exportnamelen, &data[0], 4);\n         exportnamelen = be32toh (exportnamelen);\n         what = \"validating export name\";\n         if (check_export_name (option, &data[4], exportnamelen,\n                                optlen - 8) == -1)\n           goto opt_meta_invalid_option_len;\n \n         if (option == NBD_OPT_SET_META_CONTEXT) {\n           conn->exportname_from_set_meta_context =\n             strndup (&data[4], exportnamelen);\n           if (conn->exportname_from_set_meta_context == NULL) {\n             nbdkit_error (\"malloc: %m\");\n             return -1;\n           }\n         }\n \n         opt_index = 4 + exportnamelen;\n \n         what = \"reading number of queries\";\n         if (opt_index+4 > optlen)\n           goto opt_meta_invalid_option_len;\n         memcpy (&nr_queries, &data[opt_index], 4);\n         nr_queries = be32toh (nr_queries);\n         opt_index += 4;\n \n         debug (\"newstyle negotiation: %s: %s count: %d\", optname,\n                option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n                nr_queries);\n         if (option == NBD_OPT_SET_META_CONTEXT)\n           conn->meta_context_base_allocation = false;\n         if (nr_queries == 0) {\n           if (option == NBD_OPT_LIST_META_CONTEXT) {\n             if (send_newstyle_option_reply_meta_context (option,\n                                                          NBD_REP_META_CONTEXT,\n                                                          0, \"base:allocation\")\n                 == -1)\n               return -1;\n           }\n \n           if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n             return -1;\n         }\n         else {\n           while (nr_queries > 0) {\n             what = \"reading query string length\";\n             if (opt_index+4 > optlen)\n               goto opt_meta_invalid_option_len;\n             memcpy (&querylen, &data[opt_index], 4);\n             querylen = be32toh (querylen);\n             opt_index += 4;\n             what = \"reading query string\";\n             if (check_string (option, &data[opt_index], querylen,\n                               optlen - opt_index, \"meta context query\") == -1)\n               goto opt_meta_invalid_option_len;\n \n             debug (\"newstyle negotiation: %s: %s %.*s\",\n                    optname,\n                    option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n                    (int) querylen, &data[opt_index]);\n \n             if (option == NBD_OPT_LIST_META_CONTEXT &&\n                 querylen == 5 &&\n                 strncmp (&data[opt_index], \"base:\", 5) == 0) {\n               if (send_newstyle_option_reply_meta_context\n                   (option, NBD_REP_META_CONTEXT,\n                    0, \"base:allocation\") == -1)\n                 return -1;\n             }\n             else if (querylen == 15 &&\n                      strncmp (&data[opt_index], \"base:allocation\", 15) == 0) {\n               if (send_newstyle_option_reply_meta_context\n                   (option, NBD_REP_META_CONTEXT,\n                    option == NBD_OPT_SET_META_CONTEXT\n                    ? base_allocation_id : 0,\n                    \"base:allocation\") == -1)\n                 return -1;\n               if (option == NBD_OPT_SET_META_CONTEXT)\n                 conn->meta_context_base_allocation = true;\n             }\n \n             opt_index += querylen;\n             nr_queries--;\n           }\n           if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n             return -1;\n         }\n         debug (\"newstyle negotiation: %s: reply complete\", optname);\n       }\n       break;\n \n     default:\n       if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n         return -1;\n       if (conn_recv_full (data, optlen,\n                           \"reading unknown option data: conn->recv: %m\") == -1)\n         return -1;\n     }\n \n     if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)\n       break;\n   }\n \n   if (nr_options == 0) {\n     nbdkit_error (\"client spent too much time negotiating without selecting \"\n                   \"an export\");\n     return -1;\n   }\n \n   if (tls == 2 && !conn->using_tls) {\n     nbdkit_error (\"non-TLS client tried to connect in --tls=require mode\");\n     return -1;\n   }\n \n   return 0;\n }\n \n", "target": "// fix_start\n        free (conn->exportname_from_set_meta_context);\n        conn->exportname_from_set_meta_context = NULL;\n        conn->meta_context_base_allocation = false;\n// fix_end\n", "cwe": "CWE-924", "cwe_name": "Improper Enforcement of Message Integrity During Transmission in a Communication Channel", "cve": "CVE-2021-3716", "cve_desc": "A flaw was found in nbdkit due to to improperly caching plaintext state across the STARTTLS encryption boundary. A MitM attacker could use this flaw to inject a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a client sends to the server, potentially leading the client to terminate the NBD session. The highest threat from this vulnerability is to system availability.", "project": "nbdkit", "idx": 206670}
{"source": " update_topline(void)\n {\n     long\tline_count;\n     int\t\thalfheight;\n     int\t\tn;\n     linenr_T\told_topline;\n #ifdef FEAT_DIFF\n     int\t\told_topfill;\n #endif\n #ifdef FEAT_FOLDING\n     linenr_T\tlnum;\n #endif\n     int\t\tcheck_topline = FALSE;\n     int\t\tcheck_botline = FALSE;\n     long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n     int\t\tsave_so = *so_ptr;\n \n     if (!screen_valid(TRUE) || curwin->w_height == 0)\n     {\n \tcheck_cursor_lnum();\n \tcurwin->w_topline = curwin->w_cursor.lnum;\n \tcurwin->w_botline = curwin->w_topline;\n// bug_start\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n// bug_end\n \tcurwin->w_scbind_pos = 1;\n \treturn;\n     }\n \n     check_cursor_moved(curwin);\n     if (curwin->w_valid & VALID_TOPLINE)\n \treturn;\n \n     if (mouse_dragging > 0)\n \t*so_ptr = mouse_dragging - 1;\n \n     old_topline = curwin->w_topline;\n #ifdef FEAT_DIFF\n     old_topfill = curwin->w_topfill;\n #endif\n \n     if (BUFEMPTY())\n     {\n \tif (curwin->w_topline != 1)\n \t    redraw_later(NOT_VALID);\n \tcurwin->w_topline = 1;\n \tcurwin->w_botline = 2;\n \tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n \tcurwin->w_scbind_pos = 1;\n     }\n \n     else\n     {\n \tif (curwin->w_topline > 1)\n \t{\n \t    if (curwin->w_cursor.lnum < curwin->w_topline)\n \t\tcheck_topline = TRUE;\n \t    else if (check_top_offset())\n \t\tcheck_topline = TRUE;\n \t}\n #ifdef FEAT_DIFF\n \tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n \t\t\t\t\t\t\t   curwin->w_topline))\n \t    check_topline = TRUE;\n #endif\n \n \tif (check_topline)\n \t{\n \t    halfheight = curwin->w_height / 2 - 1;\n \t    if (halfheight < 2)\n \t\thalfheight = 2;\n \n #ifdef FEAT_FOLDING\n \t    if (hasAnyFolding(curwin))\n \t    {\n \t\tn = 0;\n \t\tfor (lnum = curwin->w_cursor.lnum;\n \t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n \t\t{\n \t\t    ++n;\n \t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n \t\t\tbreak;\n \t\t    (void)hasFolding(lnum, NULL, &lnum);\n \t\t}\n \t    }\n \t    else\n #endif\n \t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n \n \t    if (n >= halfheight)\n \t\tscroll_cursor_halfway(FALSE);\n \t    else\n \t    {\n \t\tscroll_cursor_top(scrolljump_value(), FALSE);\n \t\tcheck_botline = TRUE;\n \t    }\n \t}\n \n \telse\n \t{\n #ifdef FEAT_FOLDING\n \t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n #endif\n \t    check_botline = TRUE;\n \t}\n     }\n \n     if (check_botline)\n     {\n \tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n \t    validate_botline();\n \n \tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n \t{\n \t    if (curwin->w_cursor.lnum < curwin->w_botline)\n \t    {\n \t      if (((long)curwin->w_cursor.lnum\n \t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n #ifdef FEAT_FOLDING\n \t\t\t|| hasAnyFolding(curwin)\n #endif\n \t\t\t))\n \t      {\n \t\tlineoff_T\tloff;\n \n \t\tn = curwin->w_empty_rows;\n \t\tloff.lnum = curwin->w_cursor.lnum;\n #ifdef FEAT_FOLDING\n \t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n #endif\n #ifdef FEAT_DIFF\n \t\tloff.fill = 0;\n \t\tn += curwin->w_filler_rows;\n #endif\n \t\tloff.height = 0;\n \t\twhile (loff.lnum < curwin->w_botline\n #ifdef FEAT_DIFF\n \t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n #endif\n \t\t\t)\n \t\t{\n \t\t    n += loff.height;\n \t\t    if (n >= *so_ptr)\n \t\t\tbreak;\n \t\t    botline_forw(&loff);\n \t\t}\n \t\tif (n >= *so_ptr)\n \t\t    check_botline = FALSE;\n \t      }\n \t      else\n \t\t  check_botline = FALSE;\n \t    }\n \t    if (check_botline)\n \t    {\n #ifdef FEAT_FOLDING\n \t\tif (hasAnyFolding(curwin))\n \t\t{\n \t\t    line_count = 0;\n \t\t    for (lnum = curwin->w_cursor.lnum;\n \t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n \t\t    {\n \t\t\t++line_count;\n \t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n \t\t\t    break;\n \t\t\t(void)hasFolding(lnum, &lnum, NULL);\n \t\t    }\n \t\t}\n \t\telse\n #endif\n \t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n \t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n \t\tif (line_count <= curwin->w_height + 1)\n \t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n \t\telse\n \t\t    scroll_cursor_halfway(FALSE);\n \t    }\n \t}\n     }\n     curwin->w_valid |= VALID_TOPLINE;\n \n     if (curwin->w_topline != old_topline\n #ifdef FEAT_DIFF\n \t    || curwin->w_topfill != old_topfill\n #endif\n \t    )\n     {\n \tdollar_vcol = -1;\n \tif (curwin->w_skipcol != 0)\n \t{\n \t    curwin->w_skipcol = 0;\n \t    redraw_later(NOT_VALID);\n \t}\n \telse\n \t    redraw_later(VALID);\n \tif (curwin->w_cursor.lnum == curwin->w_topline)\n \t    validate_cursor();\n     }\n \n     *so_ptr = save_so;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-122", "cwe_name": "Heap-based Buffer Overflow", "cve": "CVE-2021-3903", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "project": "vim", "idx": 206676}
{"source": " unix_expandpath(\n     garray_T\t*gap,\n     char_u\t*path,\n     int\t\twildoff,\n     int\t\tflags,\n     int\t\tdidstar)\n {\n     char_u\t*buf;\n     char_u\t*path_end;\n     char_u\t*p, *s, *e;\n     int\t\tstart_len = gap->ga_len;\n     char_u\t*pat;\n     regmatch_T\tregmatch;\n     int\t\tstarts_with_dot;\n     int\t\tmatches;\n     int\t\tlen;\n     int\t\tstarstar = FALSE;\n     static int\tstardepth = 0;\n \n     DIR\t\t*dirp;\n     struct dirent *dp;\n \n     if (stardepth > 0)\n     {\n \tui_breakcheck();\n \tif (got_int)\n \t    return 0;\n     }\n \n     buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n     if (buf == NULL)\n \treturn 0;\n \n     p = buf;\n     s = buf;\n     e = NULL;\n     path_end = path;\n     while (*path_end != NUL)\n     {\n \tif (path_end >= path + wildoff && rem_backslash(path_end))\n \t    *p++ = *path_end++;\n \telse if (*path_end == '/')\n \t{\n \t    if (e != NULL)\n \t\tbreak;\n \t    s = p + 1;\n \t}\n \telse if (path_end >= path + wildoff\n \t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n \t\t\t     || (!p_fic && (flags & EW_ICASE)\n// bug_start\n\t\t\t\t\t     && isalpha(PTR2CHAR(path_end)))))\n// bug_end\n \t    e = p;\n \tif (has_mbyte)\n \t{\n \t    len = (*mb_ptr2len)(path_end);\n \t    STRNCPY(p, path_end, len);\n \t    p += len;\n \t    path_end += len;\n \t}\n \telse\n \t    *p++ = *path_end++;\n     }\n     e = p;\n     *e = NUL;\n \n     for (p = buf + wildoff; p < s; ++p)\n \tif (rem_backslash(p))\n \t{\n \t    STRMOVE(p, p + 1);\n \t    --e;\n \t    --s;\n \t}\n \n     for (p = s; p < e; ++p)\n \tif (p[0] == '*' && p[1] == '*')\n \t    starstar = TRUE;\n \n     starts_with_dot = *s == '.';\n     pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n     if (pat == NULL)\n     {\n \tvim_free(buf);\n \treturn 0;\n     }\n \n     if (flags & EW_ICASE)\n \tregmatch.rm_ic = TRUE;\n     else\n \tregmatch.rm_ic = p_fic;\n     if (flags & (EW_NOERROR | EW_NOTWILD))\n \t++emsg_silent;\n     regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n     if (flags & (EW_NOERROR | EW_NOTWILD))\n \t--emsg_silent;\n     vim_free(pat);\n \n     if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n     {\n \tvim_free(buf);\n \treturn 0;\n     }\n \n     if (!didstar && stardepth < 100 && starstar && e - s == 2\n \t\t\t\t\t\t\t  && *path_end == '/')\n     {\n \tSTRCPY(s, path_end + 1);\n \t++stardepth;\n \t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n \t--stardepth;\n     }\n \n     *s = NUL;\n     dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n \n     if (dirp != NULL)\n     {\n \tfor (;;)\n \t{\n \t    dp = readdir(dirp);\n \t    if (dp == NULL)\n \t\tbreak;\n \t    if ((dp->d_name[0] != '.' || starts_with_dot\n \t\t\t|| ((flags & EW_DODOT)\n \t\t\t    && dp->d_name[1] != NUL\n \t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n \t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n \t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n \t\t   || ((flags & EW_NOTWILD)\n \t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n \t    {\n \t\tSTRCPY(s, dp->d_name);\n \t\tlen = STRLEN(buf);\n \n \t\tif (starstar && stardepth < 100)\n \t\t{\n \t\t    STRCPY(buf + len, \"/**\");\n \t\t    STRCPY(buf + len + 3, path_end);\n \t\t    ++stardepth;\n \t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n \t\t    --stardepth;\n \t\t}\n \n \t\tSTRCPY(buf + len, path_end);\n \t\tif (mch_has_exp_wildcard(path_end))\n \t\t{\n \t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n \t\t}\n \t\telse\n \t\t{\n \t\t    stat_T  sb;\n \n \t\t    if (*path_end != NUL)\n \t\t\tbackslash_halve(buf + len + 1);\n \t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n \t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n \t\t    {\n #ifdef MACOS_CONVERT\n \t\t\tsize_t precomp_len = STRLEN(buf)+1;\n \t\t\tchar_u *precomp_buf =\n \t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n \n \t\t\tif (precomp_buf)\n \t\t\t{\n \t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n \t\t\t    vim_free(precomp_buf);\n \t\t\t}\n #endif\n \t\t\taddfile(gap, buf, flags);\n \t\t    }\n \t\t}\n \t    }\n \t}\n \n \tclosedir(dirp);\n     }\n \n     vim_free(buf);\n     vim_regfree(regmatch.regprog);\n \n     matches = gap->ga_len - start_len;\n     if (matches > 0)\n \tqsort(((char_u **)gap->ga_data) + start_len, matches,\n \t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n     return matches;\n }\n \n", "target": "// fix_start\n\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-0685", "cve_desc": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4418.", "project": "vim", "idx": 206677}
{"source": " bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* ) {\n     if (groupCode==90) {\n         maxVertices = toInt(groupValue);\n         if (maxVertices>0) {\n             if (vertices!=NULL) {\n                 delete[] vertices;\n             }\n             vertices = new double[4*maxVertices];\n             for (int i=0; i<maxVertices; ++i) {\n                 vertices[i*4] = 0.0;\n                 vertices[i*4+1] = 0.0;\n                 vertices[i*4+2] = 0.0;\n                 vertices[i*4+3] = 0.0;\n             }\n         }\n         vertexIndex=-1;\n         return true;\n     }\n \n     else if (groupCode==10 || groupCode==20 ||\n              groupCode==30 || groupCode==42) {\n \n         if (vertexIndex<maxVertices-1 && groupCode==10) {\n             vertexIndex++;\n         }\n \n         if (groupCode<=30) {\n// bug_start\n            if (vertexIndex>=0 && vertexIndex<maxVertices) {\n// bug_end\n                 vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);\n             }\n// bug_start\n        } else if (groupCode==42 && vertexIndex<maxVertices) {\n// bug_end\n             vertices[4*vertexIndex + 3] = toReal(groupValue);\n         }\n         return true;\n     }\n     return false;\n }\n \n", "target": "// fix_start\n            if (vertexIndex>=0 && vertexIndex<maxVertices && vertexIndex>=0) {\n// fix_end\n// fix_start\n        } else if (groupCode==42 && vertexIndex<maxVertices && vertexIndex>=0) {\n// fix_end\n", "cwe": "CWE-191", "cwe_name": "Integer Underflow (Wrap or Wraparound)", "cve": "CVE-2021-21897", "cve_desc": "A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.", "project": "qcad", "idx": 206771}
{"source": " int udf_expand_file_adinicb(struct inode *inode)\n {\n \tstruct page *page;\n \tchar *kaddr;\n \tstruct udf_inode_info *iinfo = UDF_I(inode);\n \tint err;\n \n \tWARN_ON_ONCE(!inode_is_locked(inode));\n \tif (!iinfo->i_lenAlloc) {\n \t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n \t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n \t\telse\n \t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n \t\tinode->i_data.a_ops = &udf_aops;\n \t\tup_write(&iinfo->i_data_sem);\n \t\tmark_inode_dirty(inode);\n \t\treturn 0;\n \t}\n \tup_write(&iinfo->i_data_sem);\n \n \tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n \tif (!page)\n \t\treturn -ENOMEM;\n \n \tif (!PageUptodate(page)) {\n \t\tkaddr = kmap_atomic(page);\n \t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n \t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n \t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n \t\t\tiinfo->i_lenAlloc);\n \t\tflush_dcache_page(page);\n \t\tSetPageUptodate(page);\n \t\tkunmap_atomic(kaddr);\n \t}\n \tdown_write(&iinfo->i_data_sem);\n \tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n \t       iinfo->i_lenAlloc);\n \tiinfo->i_lenAlloc = 0;\n \tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n \t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n \telse\n \t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n \tinode->i_data.a_ops = &udf_aops;\n \tset_page_dirty(page);\n \tunlock_page(page);\n \tup_write(&iinfo->i_data_sem);\n \terr = filemap_fdatawrite(inode->i_mapping);\n \tif (err) {\n \t\tlock_page(page);\n \t\tdown_write(&iinfo->i_data_sem);\n \t\tkaddr = kmap_atomic(page);\n \t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n \t\tkunmap_atomic(kaddr);\n \t\tunlock_page(page);\n \t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n \t\tinode->i_data.a_ops = &udf_adinicb_aops;\n// bug_start\n// bug_end\n \t\tup_write(&iinfo->i_data_sem);\n \t}\n \tput_page(page);\n \tmark_inode_dirty(inode);\n \n \treturn err;\n }\n \n", "target": "// fix_start\n\t\tiinfo->i_lenAlloc = inode->i_size;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-0617", "cve_desc": "A flaw null pointer dereference in the Linux kernel UDF file system functionality was found in the way user triggers udf_file_write_iter function for the malicious UDF image. A local user could use this flaw to crash the system. Actual from Linux kernel 4.2-rc1 till 5.17-rc2.", "project": "linux", "idx": 206781}
{"source": " static MagickBooleanType SetGrayscaleImage(Image *image,\n   ExceptionInfo *exception)\n {\n   CacheView\n     *image_view;\n \n   MagickBooleanType\n     status;\n \n   PixelInfo\n     *colormap;\n \n   register ssize_t\n     i;\n \n   ssize_t\n     *colormap_index,\n     j,\n     y;\n \n   assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n   if (image->type != GrayscaleType)\n     (void) TransformImageColorspace(image,GRAYColorspace,exception);\n   if (image->storage_class == PseudoClass)\n// bug_start\n    colormap_index=(ssize_t *) AcquireQuantumMemory(image->colors+1,\n      sizeof(*colormap_index));\n// bug_end\n   else\n// bug_start\n    colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize+1,\n      sizeof(*colormap_index));\n// bug_end\n   if (colormap_index == (ssize_t *) NULL)\n     ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n       image->filename);\n   if (image->storage_class != PseudoClass)\n     {\n       (void) memset(colormap_index,(-1),MaxColormapSize*\n         sizeof(*colormap_index));\n       if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n         {\n           colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n           ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n             image->filename);\n         }\n       image->colors=0;\n       status=MagickTrue;\n       image_view=AcquireAuthenticCacheView(image,exception);\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n       #pragma omp parallel for schedule(static) shared(status) \\\n         magick_number_threads(image,image,image->rows,1)\n #endif\n       for (y=0; y < (ssize_t) image->rows; y++)\n       {\n         register Quantum\n           *magick_restrict q;\n \n         register ssize_t\n           x;\n \n         if (status == MagickFalse)\n           continue;\n         q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n           exception);\n         if (q == (Quantum *) NULL)\n           {\n             status=MagickFalse;\n             continue;\n           }\n         for (x=0; x < (ssize_t) image->columns; x++)\n         {\n           register size_t\n             intensity;\n \n           intensity=ScaleQuantumToMap(GetPixelRed(image,q));\n           if (colormap_index[intensity] < 0)\n             {\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n               #pragma omp critical (MagickCore_SetGrayscaleImage)\n #endif\n               if (colormap_index[intensity] < 0)\n                 {\n                   colormap_index[intensity]=(ssize_t) image->colors;\n                   image->colormap[image->colors].red=(double)\n                     GetPixelRed(image,q);\n                   image->colormap[image->colors].green=(double)\n                     GetPixelGreen(image,q);\n                   image->colormap[image->colors].blue=(double)\n                     GetPixelBlue(image,q);\n                   image->colors++;\n                }\n             }\n           SetPixelIndex(image,(Quantum) colormap_index[intensity],q);\n           q+=GetPixelChannels(image);\n         }\n         if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n           status=MagickFalse;\n       }\n       image_view=DestroyCacheView(image_view);\n     }\n   for (i=0; i < (ssize_t) image->colors; i++)\n     image->colormap[i].alpha=(double) i;\n   qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),\n     IntensityCompare);\n   colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));\n   if (colormap == (PixelInfo *) NULL)\n     {\n       colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n       ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n         image->filename);\n     }\n   j=0;\n   colormap[j]=image->colormap[0];\n   for (i=0; i < (ssize_t) image->colors; i++)\n   {\n     if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)\n       {\n         j++;\n         colormap[j]=image->colormap[i];\n       }\n     colormap_index[(ssize_t) image->colormap[i].alpha]=j;\n   }\n   image->colors=(size_t) (j+1);\n   image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n   image->colormap=colormap;\n   status=MagickTrue;\n   image_view=AcquireAuthenticCacheView(image,exception);\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n   #pragma omp parallel for schedule(static) shared(status) \\\n     magick_number_threads(image,image,image->rows,1)\n #endif\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n     register Quantum\n       *magick_restrict q;\n \n     register ssize_t\n       x;\n \n     if (status == MagickFalse)\n       continue;\n     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n     if (q == (Quantum *) NULL)\n       {\n         status=MagickFalse;\n         continue;\n       }\n     for (x=0; x < (ssize_t) image->columns; x++)\n     {\n       SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(\n         GetPixelIndex(image,q))],q);\n       q+=GetPixelChannels(image);\n     }\n     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n       status=MagickFalse;\n   }\n   image_view=DestroyCacheView(image_view);\n   colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n   image->type=GrayscaleType;\n   if (SetImageMonochrome(image,exception) != MagickFalse)\n     image->type=BilevelType;\n   return(status);\n }\n \n", "target": "// fix_start\n    colormap_index=(ssize_t *) AcquireQuantumMemory(MagickMax(image->colors+1,\n      MaxMap),sizeof(*colormap_index));\n// fix_end\n// fix_start\n    colormap_index=(ssize_t *) AcquireQuantumMemory(MagickMax(MaxColormapSize+1,\n      MaxMap),sizeof(*colormap_index));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-11598", "cve_desc": "In ImageMagick 7.0.8-40 Q16, there is a heap-based buffer over-read in the function WritePNMImage of coders/pnm.c, which allows an attacker to cause a denial of service or possibly information disclosure via a crafted image file. This is related to SetGrayscaleImage in MagickCore/quantize.c.", "project": "ImageMagick", "idx": 206815}
{"source": " static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n {\n \tint i;\n \tunsigned long h;\n \n \th = id->iface;\n \th = MULTIPLIER * h + id->device;\n \th = MULTIPLIER * h + id->subdevice;\n// bug_start\n\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n// bug_end\n \t\th = MULTIPLIER * h + id->name[i];\n \th = MULTIPLIER * h + id->index;\n \th &= LONG_MAX;\n \treturn h;\n }\n \n", "target": "// fix_start\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-3170", "cve_desc": "An out-of-bounds access issue was found in the Linux kernel sound subsystem. It could occur when the 'id->name' provided by the user did not end with '\\0'. A privileged local user could pass a specially crafted name through ioctl() interface and crash the system or potentially escalate their privileges on the system.", "project": "linux", "idx": 206845}
{"source": " eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n {\n     char_u\t*p;\n     char_u\t*end;\n     int\t\textra = interpolate ? 1 : 0;\n     int\t\toff = interpolate ? 0 : 1;\n     int\t\tlen;\n \n     for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n     {\n \tif (*p == '\\\\' && p[1] != NUL)\n \t{\n \t    ++p;\n \t    if (*p == '<')\n// bug_start\n// bug_end\n \t\textra += 5;\n// bug_start\n// bug_end\n \t}\n \telse if (interpolate && (*p == '{' || *p == '}'))\n \t{\n \t    if (*p == '{' && p[1] != '{')\n \t\tbreak;\n \t    ++p;\n \t    if (p[-1] == '}' && *p != '}')\n \t    {\n \t\tsemsg(_(e_stray_closing_curly_str), *arg);\n \t\treturn FAIL;\n \t    }\n \t    --extra;\n \t}\n     }\n \n     if (*p != '\"' && !(interpolate && *p == '{'))\n     {\n \tsemsg(_(e_missing_double_quote_str), *arg);\n \treturn FAIL;\n     }\n \n     if (!evaluate)\n     {\n \t*arg = p + off;\n \treturn OK;\n     }\n \n     rettv->v_type = VAR_STRING;\n     len = (int)(p - *arg + extra);\n     rettv->vval.v_string = alloc(len);\n     if (rettv->vval.v_string == NULL)\n \treturn FAIL;\n     end = rettv->vval.v_string;\n \n     for (p = *arg + off; *p != NUL && *p != '\"'; )\n     {\n \tif (*p == '\\\\')\n \t{\n \t    switch (*++p)\n \t    {\n \t\tcase 'b': *end++ = BS; ++p; break;\n \t\tcase 'e': *end++ = ESC; ++p; break;\n \t\tcase 'f': *end++ = FF; ++p; break;\n \t\tcase 'n': *end++ = NL; ++p; break;\n \t\tcase 'r': *end++ = CAR; ++p; break;\n \t\tcase 't': *end++ = TAB; ++p; break;\n \n \t\tcase 'X':\n \t\tcase 'x':\n \t\tcase 'u':\n \t\tcase 'U':\n \t\t\t  if (vim_isxdigit(p[1]))\n \t\t\t  {\n \t\t\t      int\tn, nr;\n \t\t\t      int\tc = toupper(*p);\n \n \t\t\t      if (c == 'X')\n \t\t\t\t  n = 2;\n \t\t\t      else if (*p == 'u')\n \t\t\t\t  n = 4;\n \t\t\t      else\n \t\t\t\t  n = 8;\n \t\t\t      nr = 0;\n \t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n \t\t\t      {\n \t\t\t\t  ++p;\n \t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n \t\t\t      }\n \t\t\t      ++p;\n \t\t\t      if (c != 'X')\n \t\t\t\t  end += (*mb_char2bytes)(nr, end);\n \t\t\t      else\n \t\t\t\t  *end++ = nr;\n \t\t\t  }\n \t\t\t  break;\n \n \t\tcase '0':\n \t\tcase '1':\n \t\tcase '2':\n \t\tcase '3':\n \t\tcase '4':\n \t\tcase '5':\n \t\tcase '6':\n \t\tcase '7': *end = *p++ - '0';\n \t\t\t  if (*p >= '0' && *p <= '7')\n \t\t\t  {\n \t\t\t      *end = (*end << 3) + *p++ - '0';\n \t\t\t      if (*p >= '0' && *p <= '7')\n \t\t\t\t  *end = (*end << 3) + *p++ - '0';\n \t\t\t  }\n \t\t\t  ++end;\n \t\t\t  break;\n \n \t\tcase '<':\n \t\t\t  {\n \t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n \n \t\t\t      if (p[1] != '*')\n \t\t\t\t  flags |= FSK_SIMPLIFY;\n \t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n \t\t\t      if (extra != 0)\n \t\t\t      {\n \t\t\t\t  end += extra;\n \t\t\t\t  if (end >= rettv->vval.v_string + len)\n \t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n \t\t\t\t  break;\n \t\t\t      }\n \t\t\t  }\n \n \t\tdefault: MB_COPY_CHAR(p, end);\n \t\t\t  break;\n \t    }\n \t}\n \telse\n \t{\n \t    if (interpolate && (*p == '{' || *p == '}'))\n \t    {\n \t\tif (*p == '{' && p[1] != '{')\n \t\t    break;\n \t\t++p;\n \t    }\n \t    MB_COPY_CHAR(p, end);\n \t}\n     }\n     *end = NUL;\n     if (*p == '\"' && !interpolate)\n \t++p;\n     *arg = p;\n \n     return OK;\n }\n \n", "target": "// fix_start\n\t    {\n\t\tint\t\tmodifiers = 0;\n\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n\n// fix_end\n// fix_start\n\n\t\tif (p[1] != '*')\n\t\t    flags |= FSK_SIMPLIFY;\n\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n\t\t    --p;\n\t    }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-2580", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.", "project": "vim", "idx": 206942}
{"source": " cmdopts_t *cmdopts_parse(int argc, char **argv)\n {\n \tenum {\n \t\tCMDOPT_HELP = 0,\n \t\tCMDOPT_VERBOSE,\n \t\tCMDOPT_QUIET,\n \t\tCMDOPT_INFILE,\n \t\tCMDOPT_INFMT,\n \t\tCMDOPT_INOPT,\n \t\tCMDOPT_OUTFILE,\n \t\tCMDOPT_OUTFMT,\n \t\tCMDOPT_OUTOPT,\n \t\tCMDOPT_VERSION,\n \t\tCMDOPT_DEBUG,\n \t\tCMDOPT_CMPTNO,\n \t\tCMDOPT_SRGB,\n \t\tCMDOPT_MAXMEM,\n \t\tCMDOPT_LIST_ENABLED_CODECS,\n \t\tCMDOPT_LIST_ALL_CODECS,\n \t\tCMDOPT_ENABLE_FORMAT,\n \t\tCMDOPT_ENABLE_ALL_FORMATS,\n \t};\n \n \tstatic const jas_opt_t cmdoptions[] = {\n \t\t{CMDOPT_HELP, \"help\", 0},\n \t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n \t\t{CMDOPT_QUIET, \"quiet\", 0},\n \t\t{CMDOPT_QUIET, \"q\", 0},\n \t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n \t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n \t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n \t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n \t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n \t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n \t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n \t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n \t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n \t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n \t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n \t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n \t\t{CMDOPT_VERSION, \"version\", 0},\n \t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n \t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n \t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n \t\t{CMDOPT_SRGB, \"S\", 0},\n \t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n \t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n \t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n \t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n \t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n \t\t{-1, 0, 0}\n \t};\n \n \tcmdopts_t *cmdopts;\n \tint c;\n \n \tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n \t\tfprintf(stderr, \"error: insufficient memory\\n\");\n \t\texit(EXIT_FAILURE);\n \t}\n \n \tcmdopts->infile = 0;\n \tcmdopts->infmt = -1;\n \tcmdopts->infmt_str = 0;\n \tcmdopts->inopts = 0;\n \tcmdopts->inoptsbuf[0] = '\\0';\n \tcmdopts->outfile = 0;\n \tcmdopts->outfmt = -1;\n \tcmdopts->outfmt_str = 0;\n \tcmdopts->outopts = 0;\n \tcmdopts->outoptsbuf[0] = '\\0';\n \tcmdopts->verbose = 0;\n \tcmdopts->version = 0;\n \tcmdopts->cmptno = -1;\n \tcmdopts->debug = 0;\n \tcmdopts->srgb = 0;\n \tcmdopts->list_codecs = 0;\n \tcmdopts->list_codecs_all = 0;\n \tcmdopts->help = 0;\n \tcmdopts->max_mem = get_default_max_mem_usage();\n \tcmdopts->enable_format = 0;\n \tcmdopts->enable_all_formats = 0;\n \n \twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n \t\tswitch (c) {\n \t\tcase CMDOPT_HELP:\n \t\t\tcmdopts->help = 1;\n \t\t\tbreak;\n \t\tcase CMDOPT_VERBOSE:\n \t\t\tcmdopts->verbose = 1;\n \t\t\tbreak;\n \t\tcase CMDOPT_QUIET:\n \t\t\tcmdopts->verbose = -1;\n \t\t\tbreak;\n \t\tcase CMDOPT_VERSION:\n \t\t\tcmdopts->version = 1;\n \t\t\tbreak;\n \t\tcase CMDOPT_LIST_ENABLED_CODECS:\n \t\t\tcmdopts->list_codecs = 1;\n \t\t\tcmdopts->list_codecs_all = 0;\n \t\t\tbreak;\n \t\tcase CMDOPT_LIST_ALL_CODECS:\n \t\t\tcmdopts->list_codecs = 1;\n \t\t\tcmdopts->list_codecs_all = 1;\n \t\t\tbreak;\n \t\tcase CMDOPT_DEBUG:\n \t\t\tcmdopts->debug = atoi(jas_optarg);\n \t\t\tbreak;\n \t\tcase CMDOPT_INFILE:\n \t\t\tcmdopts->infile = jas_optarg;\n \t\t\tbreak;\n \t\tcase CMDOPT_INFMT:\n \t\t\tcmdopts->infmt_str= jas_optarg;\n \t\t\tbreak;\n \t\tcase CMDOPT_INOPT:\n \t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n \t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n \t\t\tbreak;\n \t\tcase CMDOPT_OUTFILE:\n \t\t\tcmdopts->outfile = jas_optarg;\n \t\t\tbreak;\n \t\tcase CMDOPT_OUTFMT:\n \t\t\tcmdopts->outfmt_str = jas_optarg;\n \t\t\tbreak;\n \t\tcase CMDOPT_OUTOPT:\n \t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n \t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n \t\t\tbreak;\n \t\tcase CMDOPT_CMPTNO:\n \t\t\tcmdopts->cmptno = atoi(jas_optarg);\n \t\t\tbreak;\n \t\tcase CMDOPT_SRGB:\n \t\t\tcmdopts->srgb = 1;\n \t\t\tbreak;\n \t\tcase CMDOPT_MAXMEM:\n \t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n \t\t\tbreak;\n \t\tcase CMDOPT_ENABLE_FORMAT:\n \t\t\tcmdopts->enable_format = jas_optarg;\n \t\t\tbreak;\n \t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n \t\t\tcmdopts->enable_all_formats = 1;\n \t\t\tbreak;\n \t\tdefault:\n// bug_start\n// bug_end\n \t\t\tbadusage();\n \t\t\tbreak;\n \t\t}\n \t}\n \n \twhile (jas_optind < argc) {\n \t\tfprintf(stderr,\n \t\t  \"warning: ignoring bogus command line argument %s\\n\",\n \t\t  argv[jas_optind]);\n \t\t++jas_optind;\n \t}\n \n \tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n \t\tgoto done;\n \t}\n \n \tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n \t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n// bug_start\n// bug_end\n \t\tbadusage();\n \t}\n \n done:\n \treturn cmdopts;\n }\n \n", "target": "// fix_start\n\t\t\tcmdopts_destroy(cmdopts);\n// fix_end\n// fix_start\n\t\tcmdopts_destroy(cmdopts);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-2963", "cve_desc": "A vulnerability found in jasper. This security vulnerability happens because of a memory leak bug in function cmdopts_parse that can cause a crash or segmentation fault.", "project": "jasper", "idx": 206946}
{"source": " static ssize_t remove_slot_store(struct kobject *kobj,\n \t\t\t\t struct kobj_attribute *attr,\n \t\t\t\t const char *buf, size_t nbytes)\n {\n \tchar drc_name[MAX_DRC_NAME_LEN];\n \tint rc;\n \tchar *end;\n \n \tif (nbytes >= MAX_DRC_NAME_LEN)\n \t\treturn 0;\n \n// bug_start\n\tmemcpy(drc_name, buf, nbytes);\n// bug_end\n \n \tend = strchr(drc_name, '\\n');\n// bug_start\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n// bug_end\n \n \trc = dlpar_remove_slot(drc_name);\n \tif (rc)\n \t\treturn rc;\n \n \treturn nbytes;\n }\n \n", "target": "// fix_start\n\tstrscpy(drc_name, buf, nbytes + 1);\n// fix_end\n// fix_start\n\tif (end)\n\t\t*end = '\\0';\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-28972", "cve_desc": "In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.", "project": "linux", "idx": 207068}
{"source": " static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n \t\t\t      const char *buf, size_t nbytes)\n {\n \tchar drc_name[MAX_DRC_NAME_LEN];\n \tchar *end;\n \tint rc;\n \n \tif (nbytes >= MAX_DRC_NAME_LEN)\n \t\treturn 0;\n \n// bug_start\n\tmemcpy(drc_name, buf, nbytes);\n// bug_end\n \n \tend = strchr(drc_name, '\\n');\n// bug_start\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n// bug_end\n \n \trc = dlpar_add_slot(drc_name);\n \tif (rc)\n \t\treturn rc;\n \n \treturn nbytes;\n }\n \n", "target": "// fix_start\n\tstrscpy(drc_name, buf, nbytes + 1);\n// fix_end\n// fix_start\n\tif (end)\n\t\t*end = '\\0';\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-28972", "cve_desc": "In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.", "project": "linux", "idx": 207069}
{"source": " static SQInteger thread_call(HSQUIRRELVM v)\n {\n     SQObjectPtr o = stack_get(v,1);\n     if(sq_type(o) == OT_THREAD) {\n         SQInteger nparams = sq_gettop(v);\n// bug_start\n// bug_end\n         _thread(o)->Push(_thread(o)->_roottable);\n         for(SQInteger i = 2; i<(nparams+1); i++)\n             sq_move(_thread(o),v,i);\n         if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n             sq_move(v,_thread(o),-1);\n             sq_pop(_thread(o),1);\n             return 1;\n         }\n         v->_lasterror = _thread(o)->_lasterror;\n         return SQ_ERROR;\n     }\n     return sq_throwerror(v,_SC(\"wrong parameter\"));\n }\n \n", "target": "// fix_start\n        sq_reservestack(_thread(o), nparams + 3);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-30292", "cve_desc": "Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.", "project": "squirrel", "idx": 207150}
{"source": " at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n {\n   FILE *fd;\n// bug_start\n  unsigned char buffer[64];\n// bug_end\n   int ColormapSize, rowbytes, Maps;\n   gboolean Grey = FALSE;\n   unsigned char ColorMap[256][3];\n   at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n   unsigned char *image_storage;\n   at_exception_type exp = at_exception_new(msg_func, msg_data);\n   char magick[2];\n   Bitmap_Channel masks[4];\n \n   fd = fopen(filename, \"rb\");\n \n   if (!fd) {\n     LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n     at_exception_fatal(&exp, \"bmp: cannot open input file\");\n     goto cleanup;\n   }\n \n \n   if (!ReadOK(fd, magick, 2) ||\n \t  !(!strncmp(magick, \"BA\", 2) ||\n \t\t  !strncmp(magick, \"BM\", 2) ||\n \t\t  !strncmp(magick, \"IC\", 2) ||\n \t\t  !strncmp(magick, \"PT\", 2) ||\n \t\t  !strncmp(magick, \"CI\", 2) ||\n \t\t  !strncmp(magick, \"CP\", 2)))\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n   while (!strncmp(magick, \"BA\", 2))\n   {\n \t  if (!ReadOK(fd, buffer, 12))\n \t  {\n \t\t  LOG(\"%s is not a valid BMP file\", filename);\n \t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t\t  goto cleanup;\n \t  }\n \n \t  if (!ReadOK(fd, magick, 2))\n \t  {\n \t\t  LOG(\"%s is not a valid BMP file\", filename);\n \t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t\t  goto cleanup;\n \t  }\n   }\n \n   if (!ReadOK(fd, buffer, 12))\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n \n   Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n   Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n   Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n   Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n \n   if (!ReadOK(fd, buffer, 4))\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n   Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n \n \n   if (Bitmap_File_Head.biSize == 12) {\n     if (!ReadOK(fd, buffer, 8)) {\n       LOG(\"Error reading BMP file header\\n\");\n       at_exception_fatal(&exp, \"Error reading BMP file header\");\n       goto cleanup;\n     }\n \n     Bitmap_Head.biWidth = ToS(&buffer[0x00]);\n     Bitmap_Head.biHeight = ToS(&buffer[0x02]);\n     Bitmap_Head.biPlanes = ToS(&buffer[0x04]);\n     Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);\n     Bitmap_Head.biCompr = 0;\n     Bitmap_Head.biSizeIm = 0;\n     Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n     Bitmap_Head.biClrUsed = 0;\n     Bitmap_Head.biClrImp = 0;\n     Bitmap_Head.masks[0] = 0;\n     Bitmap_Head.masks[1] = 0;\n     Bitmap_Head.masks[2] = 0;\n     Bitmap_Head.masks[3] = 0;\n \n     memset(masks, 0, sizeof(masks));\n     Maps = 3;\n \n   } else if (Bitmap_File_Head.biSize == 40) {\n     if (!ReadOK(fd, buffer, 36))\n     {\n       LOG (\"Error reading BMP file header\\n\");\n       at_exception_fatal(&exp, \"Error reading BMP file header\");\n       goto cleanup;\n     }\n \n \n     Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n     Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n     Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n     Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n     Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n     Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n     Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n     Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n     Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n     Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n     Bitmap_Head.masks[0] = 0;\n     Bitmap_Head.masks[1] = 0;\n     Bitmap_Head.masks[2] = 0;\n     Bitmap_Head.masks[3] = 0;\n \n     Maps = 4;\n     memset(masks, 0, sizeof(masks));\n \n     if (Bitmap_Head.biCompr == BI_BITFIELDS)\n       {\n \tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n \t  {\n \t    LOG(\"Error reading BMP file header\\n\");\n \t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n \t    goto cleanup;\n \t  }\n \n \tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n \tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n \tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n \n \tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n       }\n     else if (Bitmap_Head.biCompr == BI_RGB)\n       {\n \tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n       }\n     else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n \t     (Bitmap_Head.biCompr != BI_RLE8))\n       {\n \tLOG(\"Unsupported compression in BMP file\\n\");\n \tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n \tgoto cleanup;\n       }\n   }\n   else if (Bitmap_File_Head.biSize >= 56 &&\n \t   Bitmap_File_Head.biSize <= 64)\n   {\n \n     if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n     {\n \n       LOG(\"Error reading BMP file header\\n\");\n       at_exception_fatal(&exp, \"Error reading BMP file header\");\n       goto cleanup;\n     }\n \n     Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n     Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n     Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n     Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n     Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n     Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n     Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n     Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n     Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n     Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n     Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n     Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n     Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n     Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n \n     Maps = 4;\n     ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n   }\n   else if (Bitmap_File_Head.biSize == 108 ||\n            Bitmap_File_Head.biSize == 124)\n   {\n \n     if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n     {\n \t    LOG(\"Error reading BMP file header\\n\");\n \t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n \t    goto cleanup;\n     }\n \n     Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n     Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n     Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n     Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n     Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n     Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n     Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n     Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n     Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n     Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n     Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n     Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n     Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n     Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n \n     Maps = 4;\n \n     if (Bitmap_Head.biCompr == BI_BITFIELDS)\n     {\n \t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n     }\n     else if (Bitmap_Head.biCompr == BI_RGB)\n     {\n \t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n     }\n   } else {\n     LOG(\"Error reading BMP file header\\n\");\n     at_exception_fatal(&exp, \"Error reading BMP file header\");\n     goto cleanup;\n   }\n \n \n   switch (Bitmap_Head.biBitCnt)\n   {\n   case 1:\n   case 2:\n   case 4:\n   case 8:\n   case 16:\n   case 24:\n   case 32:\n \t  break;\n   default:\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n \n   ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n \n   if ((Bitmap_Head.biClrUsed == 0) &&\n       (Bitmap_Head.biBitCnt <= 8))\n   {\n \t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n   }\n \n   if (ColormapSize > 256)\n     ColormapSize = 256;\n \n \n   if (Bitmap_Head.biHeight == 0 ||\n \t  Bitmap_Head.biWidth == 0)\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n   if (Bitmap_Head.biWidth < 0 ||\n \t  Bitmap_Head.biHeight == -2147483648)\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n   if (Bitmap_Head.biPlanes != 1)\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n   if (Bitmap_Head.biClrUsed > 256 &&\n \t  Bitmap_Head.biBitCnt <= 8)\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n \n   if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n \t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n   {\n \t  LOG(\"%s is not a valid BMP file\", filename);\n \t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n \t  goto cleanup;\n   }\n \n \n   unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n   if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n     LOG(\"Error reading BMP file header. Width is too large\\n\");\n     at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n     goto cleanup;\n   }\n \n   rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n \n #ifdef DEBUG\n   printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n #endif\n \n \n   if (Bitmap_Head.biBitCnt <= 8)\n   {\n #ifdef DEBUG\n     printf(\"Colormap read\\n\");\n #endif\n \t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n \t\t  goto cleanup;\n   }\n \n   fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n \n   image_storage = ReadImage(fd,\n \tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n \tColorMap,\n         Bitmap_Head.biClrUsed,\n \tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n         Grey,\n \tmasks,\n \t&exp);\n \n   image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\n cleanup:\n   fclose(fd);\n   return (image);\n }\n \n", "target": "// fix_start\n  unsigned char buffer[128];\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-32323", "cve_desc": "AutoTrace v0.40.0 was discovered to contain a heap overflow via the ReadImage function at input-bmp.c:660.", "project": "autotrace", "idx": 207461}
{"source": " static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n \tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n \tsize_t i;\n \tconst char *comp_dir = NULL;\n \tut64 line_info_offset = UT64_MAX;\n// bug_start\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n// bug_end\n \n// bug_start\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n// bug_end\n \n// bug_start\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n// bug_end\n \n// bug_start\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n// bug_end\n \t\t}\n// bug_start\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n// bug_end\n \t}\n \n \tif (comp_dir && line_info_offset != UT64_MAX) {\n \t\tchar *name = strdup(comp_dir);\n \t\tif (name) {\n \t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n \t\t\t\tfree(name);\n \t\t\t}\n \t\t}\n \t}\n \n \treturn buf;\n }\n \n", "target": "// fix_start\n\tif (abbrev->count) {\n\t\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n// fix_end\n// fix_start\n\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n// fix_end\n// fix_start\n\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n// fix_end\n// fix_start\n\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\t\tcomp_dir = attribute->string.content;\n\t\t\t}\n\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie->count++;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-43814", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In versions up to and including 0.3.1 there is a heap-based out of bounds write in parse_die() when reversing an AMD64 ELF binary with DWARF debug info. When a malicious AMD64 ELF binary is opened by a victim user, Rizin may crash or execute unintended actions. No workaround are known and users are advised to upgrade.", "project": "rizin", "idx": 207520}
{"source": " TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {\n// bug_start\n// bug_end\n   auto it = idInfoMap.find(id);\n   if (it == idInfoMap.end()) {\n     STFATAL << \" Tried to read from an id that no longer exists\";\n   }\n   return it->second;\n }\n \n", "target": "// fix_start\n  lock_guard<recursive_mutex> guard(routerMutex);\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2022-24950", "cve_desc": "A race condition exists in Eternal Terminal prior to version 6.2.0 that allows an authenticated attacker to hijack other users' SSH authorization socket, enabling the attacker to login to other systems as the targeted users. The bug is in UserTerminalRouter::getInfoForId().", "project": "EternalTerminal", "idx": 207700}
{"source": " set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {\n   lock_guard<std::recursive_mutex> guard(globalMutex);\n \n   string pipePath = endpoint.name();\n   if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {\n     throw runtime_error(\"Tried to listen twice on the same path\");\n   }\n \n   sockaddr_un local;\n \n   int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n   FATAL_FAIL(fd);\n   initServerSocket(fd);\n   local.sun_family = AF_UNIX;\n// bug_start\n  strcpy(local.sun_path, pipePath.c_str());\n// bug_end\n   unlink(local.sun_path);\n \n   FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));\n   ::listen(fd, 5);\n #ifndef WIN32\n   FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR));\n #endif\n \n   pipeServerSockets[pipePath] = set<int>({fd});\n   return pipeServerSockets[pipePath];\n }\n \n", "target": "// fix_start\n  strncpy(local.sun_path, pipePath.c_str(), sizeof(local.sun_path));\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2022-24950", "cve_desc": "A race condition exists in Eternal Terminal prior to version 6.2.0 that allows an authenticated attacker to hijack other users' SSH authorization socket, enabling the attacker to login to other systems as the targeted users. The bug is in UserTerminalRouter::getInfoForId().", "project": "EternalTerminal", "idx": 207703}
{"source": "// bug_start\ndisplay_dollar(colnr_T col)\n// bug_end\n {\n// bug_start\n// bug_end\n     colnr_T save_col;\n \n     if (!redrawing())\n \treturn;\n \n     cursor_off();\n     save_col = curwin->w_cursor.col;\n     curwin->w_cursor.col = col;\n     if (has_mbyte)\n     {\n \tchar_u *p;\n \n \tp = ml_get_curline();\n \tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n     }\n     curs_columns(FALSE);\n     if (curwin->w_wcol < curwin->w_width)\n     {\n \tedit_putchar('$', FALSE);\n \tdollar_vcol = curwin->w_virtcol;\n     }\n     curwin->w_cursor.col = save_col;\n }\n \n", "target": "// fix_start\ndisplay_dollar(colnr_T col_arg)\n// fix_end\n// fix_start\n    colnr_T col = col_arg < 0 ? 0 : col_arg;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2845", "cve_desc": "Improper Validation of Specified Quantity in Input in GitHub repository vim/vim prior to 9.0.0218.", "project": "vim", "idx": 207719}
{"source": " static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n \t\t\t struct iov_iter *i)\n {\n \tstruct pipe_inode_info *pipe = i->pipe;\n \tstruct pipe_buffer *buf;\n \tunsigned int p_tail = pipe->tail;\n \tunsigned int p_mask = pipe->ring_size - 1;\n \tunsigned int i_head = i->head;\n \tsize_t off;\n \n \tif (unlikely(bytes > i->count))\n \t\tbytes = i->count;\n \n \tif (unlikely(!bytes))\n \t\treturn 0;\n \n \tif (!sanity(i))\n \t\treturn 0;\n \n \toff = i->iov_offset;\n \tbuf = &pipe->bufs[i_head & p_mask];\n \tif (off) {\n \t\tif (offset == off && buf->page == page) {\n \t\t\tbuf->len += bytes;\n \t\t\ti->iov_offset += bytes;\n \t\t\tgoto out;\n \t\t}\n \t\ti_head++;\n \t\tbuf = &pipe->bufs[i_head & p_mask];\n \t}\n \tif (pipe_full(i_head, p_tail, pipe->max_usage))\n \t\treturn 0;\n \n \tbuf->ops = &page_cache_pipe_buf_ops;\n// bug_start\n// bug_end\n \tget_page(page);\n \tbuf->page = page;\n \tbuf->offset = offset;\n \tbuf->len = bytes;\n \n \tpipe->head = i_head + 1;\n \ti->iov_offset = offset + bytes;\n \ti->head = i_head;\n out:\n \ti->count -= bytes;\n \treturn bytes;\n }\n \n", "target": "// fix_start\n\tbuf->flags = 0;\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2022-0847", "cve_desc": "A flaw was found in the way the \"flags\" member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in the Linux kernel and could thus contain stale values. An unprivileged local user could use this flaw to write to pages in the page cache backed by read only files and as such escalate their privileges on the system.", "project": "linux", "idx": 207753}
{"source": " static size_t push_pipe(struct iov_iter *i, size_t size,\n \t\t\tint *iter_headp, size_t *offp)\n {\n \tstruct pipe_inode_info *pipe = i->pipe;\n \tunsigned int p_tail = pipe->tail;\n \tunsigned int p_mask = pipe->ring_size - 1;\n \tunsigned int iter_head;\n \tsize_t off;\n \tssize_t left;\n \n \tif (unlikely(size > i->count))\n \t\tsize = i->count;\n \tif (unlikely(!size))\n \t\treturn 0;\n \n \tleft = size;\n \tdata_start(i, &iter_head, &off);\n \t*iter_headp = iter_head;\n \t*offp = off;\n \tif (off) {\n \t\tleft -= PAGE_SIZE - off;\n \t\tif (left <= 0) {\n \t\t\tpipe->bufs[iter_head & p_mask].len += size;\n \t\t\treturn size;\n \t\t}\n \t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n \t\titer_head++;\n \t}\n \twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n \t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n \t\tstruct page *page = alloc_page(GFP_USER);\n \t\tif (!page)\n \t\t\tbreak;\n \n \t\tbuf->ops = &default_pipe_buf_ops;\n// bug_start\n// bug_end\n \t\tbuf->page = page;\n \t\tbuf->offset = 0;\n \t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n \t\tleft -= buf->len;\n \t\titer_head++;\n \t\tpipe->head = iter_head;\n \n \t\tif (left == 0)\n \t\t\treturn size;\n \t}\n \treturn size - left;\n }\n \n", "target": "// fix_start\n\t\tbuf->flags = 0;\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2022-0847", "cve_desc": "A flaw was found in the way the \"flags\" member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in the Linux kernel and could thus contain stale values. An unprivileged local user could use this flaw to write to pages in the page cache backed by read only files and as such escalate their privileges on the system.", "project": "linux", "idx": 207754}
{"source": "// bug_start\nPHP_FUNCTION(openssl_encrypt)\n// bug_end\n {\n// bug_start\n\tzend_bool raw_output = 0;\n// bug_end\n \tchar *data, *method, *password, *iv = \"\";\n// bug_start\n\tint data_len, method_len, password_len, iv_len = 0, max_iv_len;\n// bug_end\n \tconst EVP_CIPHER *cipher_type;\n \tEVP_CIPHER_CTX cipher_ctx;\n \tint i, outlen, keylen;\n \tunsigned char *outbuf, *key;\n// bug_start\n// bug_end\n \tzend_bool free_iv;\n \n// bug_start\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|bs\", &data, &data_len, &method, &method_len, &password, &password_len, &raw_output, &iv, &iv_len) == FAILURE) {\n// bug_end\n \t\treturn;\n \t}\n// bug_start\n// bug_end\n \tcipher_type = EVP_get_cipherbyname(method);\n \tif (!cipher_type) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n \t\tRETURN_FALSE;\n// bug_start\n// bug_end\n \t}\n \n \tkeylen = EVP_CIPHER_key_length(cipher_type);\n \tif (keylen > password_len) {\n \t\tkey = emalloc(keylen);\n \t\tmemset(key, 0, keylen);\n \t\tmemcpy(key, password, password_len);\n \t} else {\n \t\tkey = (unsigned char*)password;\n \t}\n \n// bug_start\n\tmax_iv_len = EVP_CIPHER_iv_length(cipher_type);\n\tif (iv_len <= 0 && max_iv_len > 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Using an empty Initialization Vector (iv) is potentially insecure and not recommended\");\n\t}\n\tfree_iv = php_openssl_validate_iv(&iv, &iv_len, max_iv_len TSRMLS_CC);\n// bug_end\n \n \toutlen = data_len + EVP_CIPHER_block_size(cipher_type);\n \toutbuf = emalloc(outlen + 1);\n \n// bug_start\n\tEVP_EncryptInit(&cipher_ctx, cipher_type, NULL, NULL);\n// bug_end\n \tif (password_len > keylen) {\n \t\tEVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);\n \t}\n// bug_start\n\tEVP_EncryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);\n\tEVP_EncryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);\n// bug_end\n \toutlen = i;\n// bug_start\n\tif (EVP_EncryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {\n// bug_end\n \t\toutlen += i;\n// bug_start\n\t\tif (raw_output) {\n\t\t\toutbuf[outlen] = '\\0';\n\t\t\tRETVAL_STRINGL((char *)outbuf, outlen, 0);\n\t\t} else {\n\t\t\tint base64_str_len;\n\t\t\tchar *base64_str;\n\n\t\t\tbase64_str = (char*)php_base64_encode(outbuf, outlen, &base64_str_len);\n\t\t\tefree(outbuf);\n\t\t\tRETVAL_STRINGL(base64_str, base64_str_len, 0);\n\t\t}\n// bug_end\n \t} else {\n \t\tefree(outbuf);\n \t\tRETVAL_FALSE;\n \t}\n \tif (key != (unsigned char*)password) {\n \t\tefree(key);\n \t}\n \tif (free_iv) {\n \t\tefree(iv);\n \t}\n// bug_start\n\tEVP_CIPHER_CTX_cleanup(&cipher_ctx);\n// bug_end\n }\n \n", "target": "// fix_start\nPHP_FUNCTION(openssl_decrypt)\n// fix_end\n// fix_start\n\tzend_bool raw_input = 0;\n// fix_end\n// fix_start\n\tint data_len, method_len, password_len, iv_len = 0;\n// fix_end\n// fix_start\n\tint base64_str_len;\n\tchar *base64_str = NULL;\n// fix_end\n// fix_start\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|bs\", &data, &data_len, &method, &method_len, &password, &password_len, &raw_input, &iv, &iv_len) == FAILURE) {\n// fix_end\n// fix_start\n\n\tif (!method_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n// fix_end\n// fix_start\n\t}\n\n\tif (!raw_input) {\n\t\tbase64_str = (char*)php_base64_decode((unsigned char*)data, data_len, &base64_str_len);\n\t\tdata_len = base64_str_len;\n\t\tdata = base64_str;\n// fix_end\n// fix_start\n\tfree_iv = php_openssl_validate_iv(&iv, &iv_len, EVP_CIPHER_iv_length(cipher_type) TSRMLS_CC);\n// fix_end\n// fix_start\n\tEVP_DecryptInit(&cipher_ctx, cipher_type, NULL, NULL);\n// fix_end\n// fix_start\n\tEVP_DecryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);\n\tEVP_DecryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);\n// fix_end\n// fix_start\n\tif (EVP_DecryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {\n// fix_end\n// fix_start\n\t\toutbuf[outlen] = '\\0';\n\t\tRETVAL_STRINGL((char *)outbuf, outlen, 0);\n// fix_end\n// fix_start\n\tif (base64_str) {\n\t\tefree(base64_str);\n\t}\n \tEVP_CIPHER_CTX_cleanup(&cipher_ctx);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2012-6113", "cve_desc": "The openssl_encrypt function in ext/openssl/openssl.c in PHP 5.3.9 through 5.3.13 does not initialize a certain variable, which allows remote attackers to obtain sensitive information from process memory by providing zero bytes of input data.", "project": "php-src", "idx": 207755}
{"source": " static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n \tRList *bins = r_list_newf ((RListFree)free_bin);\n \tut16 *depArray = NULL;\n \tcache_imgxtr_t *extras = NULL;\n \tif (!bins) {\n \t\treturn NULL;\n \t}\n \n \tchar *target_libs = NULL;\n \tRList *target_lib_names = NULL;\n \tint *deps = NULL;\n \ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n \tif (target_libs) {\n \t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n \t\tif (!target_lib_names) {\n \t\t\tr_list_free (bins);\n \t\t\treturn NULL;\n \t\t}\n \t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n \t\tif (!deps) {\n \t\t\tr_list_free (bins);\n \t\t\tr_list_free (target_lib_names);\n \t\t\treturn NULL;\n \t\t}\n \t}\n \n \tut32 i;\n \tfor (i = 0; i < cache->n_hdr; i++) {\n \t\tcache_hdr_t *hdr = &cache->hdr[i];\n \t\tut64 hdr_offset = cache->hdr_offset[i];\n \t\tut32 maps_index = cache->maps_index[i];\n \t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n \t\tif (!img) {\n \t\t\tgoto next;\n \t\t}\n \n \t\tut32 j;\n \t\tif (target_libs) {\n \t\t\tHtPU *path_to_idx = NULL;\n \t\t\tif (cache->accel) {\n \t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n \t\t\t\tif (!depArray) {\n \t\t\t\t\tgoto next;\n \t\t\t\t}\n \n \t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n \t\t\t\t\tgoto next;\n \t\t\t\t}\n \n \t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n \t\t\t\tif (!extras) {\n \t\t\t\t\tgoto next;\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n \t\t\t}\n \n \t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n \t\t\t\tbool printing = !deps[j];\n \t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n \t\t\t\tif (!lib_name) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n \t\t\t\t\tdeps[j]++;\n \t\t\t\t}\n \t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n \t\t\t\t\tR_FREE (lib_name);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (printing) {\n \t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n \t\t\t\t}\n \t\t\t\tR_FREE (lib_name);\n \t\t\t\tdeps[j]++;\n \n \t\t\t\tif (extras && depArray) {\n \t\t\t\t\tut32 k;\n \t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n \t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n \t\t\t\t\t\tdeps[dep_index]++;\n \n \t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n \t\t\t\t\t\tif (!dep_name) {\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (printing) {\n \t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfree (dep_name);\n \t\t\t\t\t}\n \t\t\t\t} else if (path_to_idx) {\n \t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tht_pu_free (path_to_idx);\n \t\t\tR_FREE (depArray);\n \t\t\tR_FREE (extras);\n \t\t}\n \n \t\tfor (j = 0; j < hdr->imagesCount; j++) {\n \t\t\tif (deps && !deps[j]) {\n \t\t\t\tcontinue;\n \t\t\t}\n// bug_start\n\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n// bug_end\n \t\t\tif (pa == UT64_MAX) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tut8 magicbytes[4];\n \t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n \t\t\tint magic = r_read_le32 (magicbytes);\n \t\t\tswitch (magic) {\n \t\t\tcase MH_MAGIC_64:\n \t\t\t{\n \t\t\t\tchar file[256];\n \t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n \t\t\t\tif (!bin) {\n \t\t\t\t\tgoto next;\n \t\t\t\t}\n \t\t\t\tbin->header_at = pa;\n \t\t\t\tbin->hdr_offset = hdr_offset;\n \t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n \t\t\t\tbin->va = img[j].address;\n \t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n \t\t\t\t\tfile[255] = 0;\n \t\t\t\t\tchar *last_slash = strrchr (file, '/');\n \t\t\t\t\tif (last_slash && *last_slash) {\n \t\t\t\t\t\tif (last_slash > file) {\n \t\t\t\t\t\t\tchar *scan = last_slash - 1;\n \t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n \t\t\t\t\t\t\t\tscan--;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (*scan == '/') {\n \t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tbin->file = strdup (file);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tr_list_append (bins, bin);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tdefault:\n \t\t\t\teprintf (\"Unknown sub-bin\\n\");\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n next:\n \t\tR_FREE (depArray);\n \t\tR_FREE (extras);\n \t\tR_FREE (img);\n \t}\n \tif (r_list_empty (bins)) {\n \t\tr_list_free (bins);\n \t\tbins = NULL;\n \t}\n \tR_FREE (deps);\n \tR_FREE (target_libs);\n \tr_list_free (target_lib_names);\n \treturn bins;\n }\n \n", "target": "// fix_start\n\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-1244", "cve_desc": "heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of inducing denial of service.", "project": "radare2", "idx": 207780}
{"source": " void add_interrupt_randomness(int irq, int irq_flags)\n {\n \tstruct entropy_store\t*r;\n \tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n \tstruct pt_regs\t\t*regs = get_irq_regs();\n \tunsigned long\t\tnow = jiffies;\n \tcycles_t\t\tcycles = random_get_entropy();\n \t__u32\t\t\tc_high, j_high;\n \t__u64\t\t\tip;\n \tunsigned long\t\tseed;\n \tint\t\t\tcredit = 0;\n \n \tif (cycles == 0)\n \t\tcycles = get_reg(fast_pool, regs);\n \tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n \tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n \tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n \tfast_pool->pool[1] ^= now ^ c_high;\n \tip = regs ? instruction_pointer(regs) : _RET_IP_;\n \tfast_pool->pool[2] ^= ip;\n \tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n \t\tget_reg(fast_pool, regs);\n \n \tfast_mix(fast_pool);\n \tadd_interrupt_bench(cycles);\n// bug_start\n// bug_end\n \n \tif (unlikely(crng_init == 0)) {\n \t\tif ((fast_pool->count >= 64) &&\n \t\t    crng_fast_load((char *) fast_pool->pool,\n \t\t\t\t   sizeof(fast_pool->pool))) {\n \t\t\tfast_pool->count = 0;\n \t\t\tfast_pool->last = now;\n \t\t}\n \t\treturn;\n \t}\n \n \tif ((fast_pool->count < 64) &&\n \t    !time_after(now, fast_pool->last + HZ))\n \t\treturn;\n \n \tr = &input_pool;\n \tif (!spin_trylock(&r->lock))\n \t\treturn;\n \n \tfast_pool->last = now;\n \t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n \n \tif (arch_get_random_seed_long(&seed)) {\n \t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n \t\tcredit = 1;\n \t}\n \tspin_unlock(&r->lock);\n \n \tfast_pool->count = 0;\n \n \tcredit_entropy_bits(r, credit + 1);\n }\n \n", "target": "// fix_start\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2020-16166", "cve_desc": "The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.", "project": "linux", "idx": 207803}
{"source": " void update_process_times(int user_tick)\n {\n \tstruct task_struct *p = current;\n \n \taccount_process_tick(p, user_tick);\n \trun_local_timers();\n \trcu_sched_clock_irq(user_tick);\n #ifdef CONFIG_IRQ_WORK\n \tif (in_irq())\n \t\tirq_work_tick();\n #endif\n \tscheduler_tick();\n \tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n \t\trun_posix_cpu_timers();\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2020-16166", "cve_desc": "The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.", "project": "linux", "idx": 207804}
{"source": " static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n   BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n {\n int length = 1;\n// bug_start\nint size;\n// bug_end\n PCRE2_SPTR alternative;\n BOOL quit_found = FALSE;\n BOOL accept_found = FALSE;\n BOOL setsom_found = FALSE;\n BOOL setmark_found = FALSE;\n// bug_start\nBOOL capture_last_found = FALSE;\n// bug_end\n BOOL control_head_found = FALSE;\n// bug_start\n// bug_end\n \n #if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\n SLJIT_ASSERT(common->control_head_ptr != 0);\n control_head_found = TRUE;\n #endif\n \n while (cc < ccend)\n   {\n   size = 0;\n   switch(*cc)\n     {\n     case OP_SET_SOM:\n     SLJIT_ASSERT(common->has_set_som);\n     setsom_found = TRUE;\n     cc += 1;\n     break;\n \n     case OP_RECURSE:\n     if (common->has_set_som)\n       setsom_found = TRUE;\n     if (common->mark_ptr != 0)\n       setmark_found = TRUE;\n// bug_start\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n// bug_end\n     cc += 1 + LINK_SIZE;\n     break;\n \n     case OP_KET:\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n// bug_end\n       SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n       cc += PRIVATE_DATA(cc + 1);\n       }\n     cc += 1 + LINK_SIZE;\n     break;\n \n     case OP_ASSERT:\n     case OP_ASSERT_NOT:\n     case OP_ASSERTBACK:\n     case OP_ASSERTBACK_NOT:\n     case OP_ASSERT_NA:\n     case OP_ASSERTBACK_NA:\n     case OP_ONCE:\n     case OP_SCRIPT_RUN:\n     case OP_BRAPOS:\n     case OP_SBRA:\n     case OP_SBRAPOS:\n     case OP_SCOND:\n// bug_start\n    length++;\n// bug_end\n     SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n// bug_start\n// bug_end\n     cc += 1 + LINK_SIZE;\n     break;\n \n     case OP_CBRA:\n     case OP_SCBRA:\n// bug_start\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n// bug_end\n       length++;\n     cc += 1 + LINK_SIZE + IMM2_SIZE;\n     break;\n \n     case OP_CBRAPOS:\n     case OP_SCBRAPOS:\n// bug_start\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n// bug_end\n     cc += 1 + LINK_SIZE + IMM2_SIZE;\n     break;\n \n     case OP_COND:\n     alternative = cc + GET(cc, 1);\n// bug_start\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n// bug_end\n       length++;\n     cc += 1 + LINK_SIZE;\n     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_1\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n// bug_end\n       length++;\n     cc += 2;\n #ifdef SUPPORT_UNICODE\n     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n #endif\n     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_2A\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n// bug_end\n     cc += 2;\n #ifdef SUPPORT_UNICODE\n     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n #endif\n     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_2B\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n// bug_end\n     cc += 2 + IMM2_SIZE;\n #ifdef SUPPORT_UNICODE\n     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n #endif\n     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n// bug_end\n       length++;\n     cc += 1;\n     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n// bug_end\n     cc += 1;\n     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n// bug_end\n     cc += 1 + IMM2_SIZE;\n     break;\n \n     case OP_CLASS:\n     case OP_NCLASS:\n #if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n     case OP_XCLASS:\n     size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n #else\n     size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n #endif\n// bug_start\n    if (PRIVATE_DATA(cc) != 0)\n// bug_end\n       length += get_class_iterator_size(cc + size);\n     cc += size;\n     break;\n \n     case OP_MARK:\n     case OP_COMMIT_ARG:\n     case OP_PRUNE_ARG:\n     case OP_THEN_ARG:\n     SLJIT_ASSERT(common->mark_ptr != 0);\n     if (!setmark_found)\n       setmark_found = TRUE;\n     if (common->control_head_ptr != 0)\n       control_head_found = TRUE;\n     if (*cc != OP_MARK)\n       quit_found = TRUE;\n \n     cc += 1 + 2 + cc[1];\n     break;\n \n     case OP_PRUNE:\n     case OP_SKIP:\n     case OP_COMMIT:\n     quit_found = TRUE;\n     cc++;\n     break;\n \n     case OP_SKIP_ARG:\n     quit_found = TRUE;\n     cc += 1 + 2 + cc[1];\n     break;\n \n     case OP_THEN:\n     SLJIT_ASSERT(common->control_head_ptr != 0);\n     quit_found = TRUE;\n// bug_start\n    if (!control_head_found)\n      control_head_found = TRUE;\n// bug_end\n     cc++;\n     break;\n \n     case OP_ACCEPT:\n     case OP_ASSERT_ACCEPT:\n     accept_found = TRUE;\n     cc++;\n     break;\n \n     default:\n     cc = next_opcode(common, cc);\n     SLJIT_ASSERT(cc != NULL);\n     break;\n     }\n   }\n SLJIT_ASSERT(cc == ccend);\n \n if (control_head_found)\n// bug_start\n  length++;\nif (capture_last_found)\n// bug_end\n   length++;\n if (quit_found)\n   {\n   if (setsom_found)\n     length++;\n   if (setmark_found)\n     length++;\n   }\n \n *needs_control_head = control_head_found;\n *has_quit = quit_found;\n *has_accept = accept_found;\n return length;\n }\n \n", "target": "// fix_start\nint size, offset;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\nmemset(common->recurse_bitset, 0, common->recurse_bitset_size);\n// fix_end\n// fix_start\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n// fix_end\n// fix_start\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0)\n      {\n      if (recurse_check_bit(common, offset))\n        length++;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n// fix_end\n// fix_start\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (common->optimized_cbracket[offset] == 0 && recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n// fix_end\n// fix_start\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n// fix_end\n// fix_start\n    if ((*alternative == OP_KETRMAX || *alternative == OP_KETRMIN) && recurse_check_bit(common, PRIVATE_DATA(cc)))\n// fix_end\n// fix_start\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n// fix_end\n// fix_start\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n// fix_end\n// fix_start\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n// fix_end\n// fix_start\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n// fix_end\n// fix_start\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n// fix_end\n// fix_start\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n// fix_end\n// fix_start\n\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n// fix_end\n// fix_start\n    control_head_found = TRUE;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-1587", "cve_desc": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue affects recursions in JIT-compiled regular expressions caused by duplicate data transfers.", "project": "pcre2", "idx": 207990}
{"source": " static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n \t\t\t\tstruct xfrm_policy **pols,\n \t\t\t\tint *num_pols, int *num_xfrms)\n {\n \tint i;\n \n \tif (*num_pols == 0 || !pols[0]) {\n \t\t*num_pols = 0;\n \t\t*num_xfrms = 0;\n \t\treturn 0;\n \t}\n// bug_start\n\tif (IS_ERR(pols[0]))\n// bug_end\n \t\treturn PTR_ERR(pols[0]);\n// bug_start\n// bug_end\n \n \t*num_xfrms = pols[0]->xfrm_nr;\n \n #ifdef CONFIG_XFRM_SUB_POLICY\n \tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n \t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n \t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n \t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n \t\t\t\t\t\t    fl, family,\n \t\t\t\t\t\t    XFRM_POLICY_OUT,\n \t\t\t\t\t\t    pols[0]->if_id);\n \t\tif (pols[1]) {\n \t\t\tif (IS_ERR(pols[1])) {\n \t\t\t\txfrm_pols_put(pols, *num_pols);\n// bug_start\n// bug_end\n \t\t\t\treturn PTR_ERR(pols[1]);\n \t\t\t}\n \t\t\t(*num_pols)++;\n \t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n \t\t}\n \t}\n #endif\n \tfor (i = 0; i < *num_pols; i++) {\n \t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n \t\t\t*num_xfrms = -1;\n \t\t\tbreak;\n \t\t}\n \t}\n \n \treturn 0;\n \n }\n \n", "target": "// fix_start\n\tif (IS_ERR(pols[0])) {\n\t\t*num_pols = 0;\n// fix_end\n// fix_start\n\t}\n// fix_end\n// fix_start\n\t\t\t\t*num_pols = 0;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-36879", "cve_desc": "An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.", "project": "linux", "idx": 208107}
{"source": " static int xemaclite_of_probe(struct platform_device *ofdev)\n {\n \tstruct resource *res;\n \tstruct net_device *ndev = NULL;\n \tstruct net_local *lp = NULL;\n \tstruct device *dev = &ofdev->dev;\n \n \tint rc = 0;\n \n \tdev_info(dev, \"Device Tree Probing\\n\");\n \n \tndev = alloc_etherdev(sizeof(struct net_local));\n \tif (!ndev)\n \t\treturn -ENOMEM;\n \n \tdev_set_drvdata(dev, ndev);\n \tSET_NETDEV_DEV(ndev, &ofdev->dev);\n \n \tlp = netdev_priv(ndev);\n \tlp->ndev = ndev;\n \n \tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n \tif (!res) {\n \t\tdev_err(dev, \"no IRQ found\\n\");\n \t\trc = -ENXIO;\n \t\tgoto error;\n \t}\n \n \tndev->irq = res->start;\n \n \tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n \tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n \tif (IS_ERR(lp->base_addr)) {\n \t\trc = PTR_ERR(lp->base_addr);\n \t\tgoto error;\n \t}\n \n \tndev->mem_start = res->start;\n \tndev->mem_end = res->end;\n \n \tspin_lock_init(&lp->reset_lock);\n \tlp->next_tx_buf_to_use = 0x0;\n \tlp->next_rx_buf_to_use = 0x0;\n \tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n \tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n \n \trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n \tif (rc) {\n \t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n \t\teth_hw_addr_random(ndev);\n \t}\n \n \txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n \txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n \n \txemaclite_update_address(lp, ndev->dev_addr);\n \n \tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n \txemaclite_mdio_setup(lp, &ofdev->dev);\n \n \tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n \n \tndev->netdev_ops = &xemaclite_netdev_ops;\n \tndev->ethtool_ops = &xemaclite_ethtool_ops;\n \tndev->flags &= ~IFF_MULTICAST;\n \tndev->watchdog_timeo = TX_TIMEOUT;\n \n \trc = register_netdev(ndev);\n \tif (rc) {\n \t\tdev_err(dev,\n \t\t\t\"Cannot register network device, aborting\\n\");\n \t\tgoto error;\n \t}\n \n \tdev_info(dev,\n// bug_start\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%08lX, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start,\n\t\t (unsigned long __force)lp->base_addr, ndev->irq);\n// bug_end\n \treturn 0;\n \n error:\n \tfree_netdev(ndev);\n \treturn rc;\n }\n \n", "target": "// fix_start\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%p, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start, lp->base_addr, ndev->irq);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-38205", "cve_desc": "drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).", "project": "linux", "idx": 208115}
{"source": " int main(int argc, char **argv)\n {\n \tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n \tstruct libmnt_context *cxt;\n \tstruct libmnt_table *fstab = NULL;\n \tchar *srcbuf = NULL;\n \tchar *types = NULL;\n \tunsigned long oper = 0;\n \n \tenum {\n \t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n \t\tMOUNT_OPT_SLAVE,\n \t\tMOUNT_OPT_PRIVATE,\n \t\tMOUNT_OPT_UNBINDABLE,\n \t\tMOUNT_OPT_RSHARED,\n \t\tMOUNT_OPT_RSLAVE,\n \t\tMOUNT_OPT_RPRIVATE,\n \t\tMOUNT_OPT_RUNBINDABLE,\n \t\tMOUNT_OPT_TARGET,\n \t\tMOUNT_OPT_SOURCE\n \t};\n \n \tstatic const struct option longopts[] = {\n \t\t{ \"all\", 0, 0, 'a' },\n \t\t{ \"fake\", 0, 0, 'f' },\n \t\t{ \"fstab\", 1, 0, 'T' },\n \t\t{ \"fork\", 0, 0, 'F' },\n \t\t{ \"help\", 0, 0, 'h' },\n \t\t{ \"no-mtab\", 0, 0, 'n' },\n \t\t{ \"read-only\", 0, 0, 'r' },\n \t\t{ \"ro\", 0, 0, 'r' },\n \t\t{ \"verbose\", 0, 0, 'v' },\n \t\t{ \"version\", 0, 0, 'V' },\n \t\t{ \"read-write\", 0, 0, 'w' },\n \t\t{ \"rw\", 0, 0, 'w' },\n \t\t{ \"options\", 1, 0, 'o' },\n \t\t{ \"test-opts\", 1, 0, 'O' },\n \t\t{ \"pass-fd\", 1, 0, 'p' },\n \t\t{ \"types\", 1, 0, 't' },\n \t\t{ \"uuid\", 1, 0, 'U' },\n \t\t{ \"label\", 1, 0, 'L'},\n \t\t{ \"bind\", 0, 0, 'B' },\n \t\t{ \"move\", 0, 0, 'M' },\n \t\t{ \"rbind\", 0, 0, 'R' },\n \t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n \t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n \t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n \t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n \t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n \t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n \t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n \t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n \t\t{ \"no-canonicalize\", 0, 0, 'c' },\n \t\t{ \"internal-only\", 0, 0, 'i' },\n \t\t{ \"show-labels\", 0, 0, 'l' },\n \t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n \t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n \t\t{ NULL, 0, 0, 0 }\n \t};\n \n \tstatic const ul_excl_t excl[] = {\n \t\t{ 'B','M','R',\n \t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n \t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n \t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n \t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n \n \t\t{ 'L','U', MOUNT_OPT_SOURCE },\n \t\t{ 0 }\n \t};\n \tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n \n \tsanitize_env();\n \tsetlocale(LC_ALL, \"\");\n \tbindtextdomain(PACKAGE, LOCALEDIR);\n \ttextdomain(PACKAGE);\n \tatexit(close_stdout);\n \n \tmnt_init_debug(0);\n \tcxt = mnt_new_context();\n \tif (!cxt)\n \t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n \n \tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n \n \twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n \t\t\t\t\tlongopts, NULL)) != -1) {\n \n \t\tif (mnt_context_is_restricted(cxt) &&\n \t\t    !strchr(\"hlLUVvpris\", c) &&\n \t\t    c != MOUNT_OPT_TARGET &&\n \t\t    c != MOUNT_OPT_SOURCE)\n \t\t\texit_non_root(option_to_longopt(c, longopts));\n \n \t\terr_exclusive_options(c, longopts, excl, excl_st);\n \n \t\tswitch(c) {\n \t\tcase 'a':\n \t\t\tall = 1;\n \t\t\tbreak;\n \t\tcase 'c':\n \t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n \t\t\tbreak;\n \t\tcase 'f':\n \t\t\tmnt_context_enable_fake(cxt, TRUE);\n \t\t\tbreak;\n \t\tcase 'F':\n \t\t\tmnt_context_enable_fork(cxt, TRUE);\n \t\t\tbreak;\n \t\tcase 'h':\n \t\t\tusage(stdout);\n \t\t\tbreak;\n \t\tcase 'i':\n \t\t\tmnt_context_disable_helpers(cxt, TRUE);\n \t\t\tbreak;\n \t\tcase 'n':\n \t\t\tmnt_context_disable_mtab(cxt, TRUE);\n \t\t\tbreak;\n \t\tcase 'r':\n \t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n \t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n \t\t\treadwrite = 0;\n \t\t\tbreak;\n \t\tcase 'v':\n \t\t\tmnt_context_enable_verbose(cxt, TRUE);\n \t\t\tbreak;\n \t\tcase 'V':\n \t\t\tprint_version();\n \t\t\tbreak;\n \t\tcase 'w':\n \t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n \t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n \t\t\treadwrite = 1;\n \t\t\tbreak;\n \t\tcase 'o':\n \t\t\tif (mnt_context_append_options(cxt, optarg))\n \t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n \t\t\tbreak;\n \t\tcase 'O':\n \t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n \t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n \t\t\tbreak;\n \t\tcase 'p':\n                         warnx(_(\"--pass-fd is no longer supported\"));\n \t\t\tbreak;\n \t\tcase 'L':\n \t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n \t\t\tmnt_context_disable_swapmatch(cxt, 1);\n \t\t\tmnt_context_set_source(cxt, srcbuf);\n \t\t\tfree(srcbuf);\n \t\t\tbreak;\n \t\tcase 'U':\n \t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n \t\t\tmnt_context_disable_swapmatch(cxt, 1);\n \t\t\tmnt_context_set_source(cxt, srcbuf);\n \t\t\tfree(srcbuf);\n \t\t\tbreak;\n \t\tcase 'l':\n \t\t\tshow_labels = 1;\n \t\t\tbreak;\n \t\tcase 't':\n \t\t\ttypes = optarg;\n \t\t\tbreak;\n \t\tcase 'T':\n \t\t\tfstab = append_fstab(cxt, fstab, optarg);\n \t\t\tbreak;\n \t\tcase 's':\n \t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n \t\t\tbreak;\n \t\tcase 'B':\n \t\t\toper |= MS_BIND;\n \t\t\tbreak;\n \t\tcase 'M':\n \t\t\toper |= MS_MOVE;\n \t\t\tbreak;\n \t\tcase 'R':\n \t\t\toper |= (MS_BIND | MS_REC);\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_SHARED:\n \t\t\toper |= MS_SHARED;\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_SLAVE:\n \t\t\toper |= MS_SLAVE;\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_PRIVATE:\n \t\t\toper |= MS_PRIVATE;\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_UNBINDABLE:\n \t\t\toper |= MS_UNBINDABLE;\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_RSHARED:\n \t\t\toper |= (MS_SHARED | MS_REC);\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_RSLAVE:\n \t\t\toper |= (MS_SLAVE | MS_REC);\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_RPRIVATE:\n \t\t\toper |= (MS_PRIVATE | MS_REC);\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_RUNBINDABLE:\n \t\t\toper |= (MS_UNBINDABLE | MS_REC);\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_TARGET:\n \t\t\tmnt_context_disable_swapmatch(cxt, 1);\n \t\t\tmnt_context_set_target(cxt, optarg);\n \t\t\tbreak;\n \t\tcase MOUNT_OPT_SOURCE:\n \t\t\tmnt_context_disable_swapmatch(cxt, 1);\n \t\t\tmnt_context_set_source(cxt, optarg);\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tusage(stderr);\n \t\t\tbreak;\n \t\t}\n \t}\n \n \targc -= optind;\n \targv += optind;\n \n \tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n \t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n \t\tmnt_table_set_cache(fstab, cache);\n \t}\n \n \tif (!mnt_context_get_source(cxt) &&\n \t    !mnt_context_get_target(cxt) &&\n \t    !argc &&\n \t    !all) {\n \t\tif (oper)\n \t\t\tusage(stderr);\n \t\tprint_all(cxt, types, show_labels);\n \t\tgoto done;\n \t}\n \n \tif (oper && (types || all || mnt_context_get_source(cxt)))\n \t\tusage(stderr);\n \n \tif (types && (all || strchr(types, ',') ||\n \t\t\t     strncmp(types, \"no\", 2) == 0))\n \t\tmnt_context_set_fstype_pattern(cxt, types);\n \telse if (types)\n \t\tmnt_context_set_fstype(cxt, types);\n \n \tif (all) {\n \t\trc = mount_all(cxt);\n \t\tgoto done;\n \n \t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n \t\t\t\t mnt_context_get_target(cxt))) {\n \t\tif (mnt_context_is_restricted(cxt) &&\n \t\t    mnt_context_get_source(cxt) &&\n \t\t    mnt_context_get_target(cxt))\n \t\t\texit_non_root(NULL);\n \n \t} else if (argc == 1) {\n \t\tif (mnt_context_is_restricted(cxt) &&\n \t\t    mnt_context_get_source(cxt))\n \t\t\texit_non_root(NULL);\n \n \t\tmnt_context_set_target(cxt, argv[0]);\n \n \t} else if (argc == 2 && !mnt_context_get_source(cxt)\n \t\t\t     && !mnt_context_get_target(cxt)) {\n \t\tif (mnt_context_is_restricted(cxt))\n \t\t\texit_non_root(NULL);\n \t\tmnt_context_set_source(cxt, argv[0]);\n \t\tmnt_context_set_target(cxt, argv[1]);\n \n \t} else\n \t\tusage(stderr);\n \n// bug_start\n// bug_end\n \tif (oper) {\n \t\tmnt_context_set_mflags(cxt, oper);\n \n \t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n \t}\n \n \trc = mnt_context_mount(cxt);\n \trc = mk_exit_code(cxt, rc);\n \n \tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n \t\tsuccess_message(cxt);\n done:\n \tmnt_free_context(cxt);\n \tmnt_free_table(fstab);\n \treturn rc;\n }\n \n", "target": "// fix_start\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2013-0157", "cve_desc": "(a) mount and (b) umount in util-linux 2.14.1, 2.17.2, and probably other versions allow local users to determine the existence of restricted directories by (1) using the --guess-fstype command-line option or (2) attempting to mount a non-existent device, which generates different error messages depending on whether the directory exists.", "project": "util-linux", "idx": 208140}
{"source": " bracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n {\n     int\t\tc;\n     char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n     int\t\tidx = 0;\n     char_u\t*end = find_termcode((char_u *)\"PE\");\n     int\t\tret_char = -1;\n     int\t\tsave_allow_keys = allow_keys;\n     int\t\tsave_paste = p_paste;\n \n     if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n \tend = NULL;\n     ++no_mapping;\n     allow_keys = 0;\n     if (!p_paste)\n \tset_option_value((char_u *)\"paste\", TRUE, NULL, 0);\n \n     for (;;)\n     {\n \tif (end == NULL && vpeekc() == NUL)\n \t    break;\n \tdo\n \t    c = vgetc();\n \twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n \tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n \t    break;\n \n \tif (has_mbyte)\n \t    idx += (*mb_char2bytes)(c, buf + idx);\n \telse\n \t    buf[idx++] = c;\n \tbuf[idx] = NUL;\n \tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n \t{\n \t    if (end[idx] == NUL)\n \t\tbreak;\n \t    continue;\n \t}\n \tif (!drop)\n \t{\n \t    switch (mode)\n \t    {\n \t\tcase PASTE_CMDLINE:\n \t\t    put_on_cmdline(buf, idx, TRUE);\n \t\t    break;\n \n \t\tcase PASTE_EX:\n// bug_start\n\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n// bug_end\n \t\t    {\n \t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n \t\t\t\t\t\t\t     buf, (size_t)idx);\n \t\t\tgap->ga_len += idx;\n \t\t    }\n \t\t    break;\n \n \t\tcase PASTE_INSERT:\n \t\t    if (stop_arrow() == OK)\n \t\t    {\n \t\t\tc = buf[0];\n \t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n \t\t\t    ins_eol(c);\n \t\t\telse\n \t\t\t{\n \t\t\t    ins_char_bytes(buf, idx);\n \t\t\t    AppendToRedobuffLit(buf, idx);\n \t\t\t}\n \t\t    }\n \t\t    break;\n \n \t\tcase PASTE_ONE_CHAR:\n \t\t    if (ret_char == -1)\n \t\t    {\n \t\t\tif (has_mbyte)\n \t\t\t    ret_char = (*mb_ptr2char)(buf);\n \t\t\telse\n \t\t\t    ret_char = buf[0];\n \t\t    }\n \t\t    break;\n \t    }\n \t}\n \tidx = 0;\n     }\n \n     --no_mapping;\n     allow_keys = save_allow_keys;\n     if (!save_paste)\n \tset_option_value((char_u *)\"paste\", FALSE, NULL, 0);\n \n     return ret_char;\n }\n \n", "target": "// fix_start\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0392", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim prior to 8.2.", "project": "vim", "idx": 208370}
{"source": " check_termcode(\n     int\t\tmax_offset,\n     char_u\t*buf,\n     int\t\tbufsize,\n     int\t\t*buflen)\n {\n     char_u\t*tp;\n     char_u\t*p;\n     int\t\tslen = 0;\n     int\t\tmodslen;\n     int\t\tlen;\n     int\t\tretval = 0;\n     int\t\toffset;\n     char_u\tkey_name[2];\n     int\t\tmodifiers;\n     char_u\t*modifiers_start = NULL;\n     int\t\tkey;\n     int\t\tnew_slen;\n     char_u\tstring[MAX_KEY_CODE_LEN + 1];\n     int\t\ti, j;\n     int\t\tidx = 0;\n     int\t\tcpo_koffset;\n \n     cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n \n     if (need_gather)\n \tgather_termleader();\n \n     for (offset = 0; offset < max_offset; ++offset)\n     {\n \tif (buf == NULL)\n \t{\n \t    if (offset >= typebuf.tb_len)\n \t\tbreak;\n \t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n \t    len = typebuf.tb_len - offset;\n \t}\n \telse\n \t{\n \t    if (offset >= *buflen)\n \t\tbreak;\n \t    tp = buf + offset;\n \t    len = *buflen - offset;\n \t}\n \n \tif (*tp == K_SPECIAL)\n \t{\n \t    offset += 2;\n \t    continue;\n \t}\n \n \ti = *tp;\n \tfor (p = termleader; *p && *p != i; ++p)\n \t    ;\n \tif (*p == NUL)\n \t    continue;\n \n \tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n \t    continue;\n \n// bug_start\n// bug_end\n \tkey_name[0] = NUL;\n \tkey_name[1] = NUL;\n \tmodifiers = 0;\n \n #ifdef FEAT_GUI\n \tif (gui.in_use)\n \t{\n \t    if (*tp == CSI)\n \t    {\n \t\tif (len < 3)\n \t\t    return -1;\n \t\tslen = 3;\n \t\tkey_name[0] = tp[1];\n \t\tkey_name[1] = tp[2];\n \t    }\n \t}\n \telse\n #endif\n \t{\n \t    int  mouse_index_found = -1;\n \n \t    for (idx = 0; idx < tc_len; ++idx)\n \t    {\n \t\tslen = termcodes[idx].len;\n \t\tmodifiers_start = NULL;\n \t\tif (cpo_koffset && offset && len < slen)\n \t\t    continue;\n \t\tif (STRNCMP(termcodes[idx].code, tp,\n \t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n \t\t{\n \t\t    int\t    looks_like_mouse_start = FALSE;\n \n \t\t    if (len < slen)\n \t\t\treturn -1;\n \n \t\t    if (termcodes[idx].name[0] == 'K'\n \t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n \t\t    {\n \t\t\tfor (j = idx + 1; j < tc_len; ++j)\n \t\t\t    if (termcodes[j].len == slen &&\n \t\t\t\t    STRNCMP(termcodes[idx].code,\n \t\t\t\t\t    termcodes[j].code, slen) == 0)\n \t\t\t    {\n \t\t\t\tidx = j;\n \t\t\t\tbreak;\n \t\t\t    }\n \t\t    }\n \n \t\t    if (slen == 2 && len > 2\n \t\t\t    && termcodes[idx].code[0] == ESC\n \t\t\t    && termcodes[idx].code[1] == '[')\n \t\t    {\n \t\t\tif (!isdigit(tp[2]))\n \t\t\t{\n \t\t\t    looks_like_mouse_start = TRUE;\n \t\t\t}\n \t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n \t\t\t{\n \t\t\t    char_u  *nr = tp + 2;\n \t\t\t    int\t    count = 0;\n \n \t\t\t    for (;;)\n \t\t\t    {\n \t\t\t\t++count;\n \t\t\t\t(void)getdigits(&nr);\n \t\t\t\tif (nr >= tp + len)\n \t\t\t\t    return -1;\n \t\t\t\tif (*nr != ';')\n \t\t\t\t    break;\n \t\t\t\t++nr;\n \t\t\t\tif (nr >= tp + len)\n \t\t\t\t    return -1;\n \t\t\t    }\n \t\t\t    if (count < 4)\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t    }\n \t\t    if (looks_like_mouse_start)\n \t\t    {\n \t\t\tif (mouse_index_found < 0)\n \t\t\t    mouse_index_found = idx;\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tkey_name[0] = termcodes[idx].name[0];\n \t\t\tkey_name[1] = termcodes[idx].name[1];\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \n \t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n \t\t{\n \t\t    int at_code;\n \n \t\t    modslen = termcodes[idx].modlen;\n \t\t    if (cpo_koffset && offset && len < modslen)\n \t\t\tcontinue;\n \t\t    at_code = termcodes[idx].code[modslen] == '@';\n \t\t    if (STRNCMP(termcodes[idx].code, tp,\n \t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n \t\t    {\n \t\t\tint\t    n;\n \n \t\t\tif (len <= modslen)\n \t\t\t    return -1;\n \n \t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n \t\t\t    slen = modslen + 1;\n \t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n \t\t\t    continue;\n \t\t\telse if (at_code && tp[modslen] != '1')\n \t\t\t    continue;\n \t\t\telse\n \t\t\t{\n \t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n \t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n \t\t\t\t;\n \t\t\t    ++j;\n \t\t\t    if (len < j)\n \t\t\t\treturn -1;\n \t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n \t\t\t\tcontinue;\n \n \t\t\t    modifiers_start = tp + slen - 2;\n \n \t\t\t    n = atoi((char *)modifiers_start);\n \t\t\t    modifiers |= decode_modifiers(n);\n \n \t\t\t    slen = j;\n \t\t\t}\n \t\t\tkey_name[0] = termcodes[idx].name[0];\n \t\t\tkey_name[1] = termcodes[idx].name[1];\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \t    }\n \t    if (idx == tc_len && mouse_index_found >= 0)\n \t    {\n \t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n \t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n \t    }\n \t}\n \n #ifdef FEAT_TERMRESPONSE\n \tif (key_name[0] == NUL\n # ifdef FEAT_MOUSE_DEC\n \t    || key_name[0] == KS_DEC_MOUSE\n # endif\n # ifdef FEAT_MOUSE_PTERM\n \t    || key_name[0] == KS_PTERM_MOUSE\n # endif\n \t   )\n \t{\n \t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n \n \t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n \t\t\t    || (tp[0] == CSI && len >= 2))\n \t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n \t    {\n \t\tint resp = handle_csi(tp, len, argp, offset, buf,\n \t\t\t\t\t     bufsize, buflen, key_name, &slen);\n \t\tif (resp != 0)\n \t\t{\n # ifdef DEBUG_TERMRESPONSE\n \t\t    if (resp == -1)\n \t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n # endif\n \t\t    return resp;\n \t\t}\n \t    }\n \n \t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n \t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n \t\t\t    || tp[0] == OSC))\n \t    {\n \t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n \t\t    return -1;\n \t    }\n \n \t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n \t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n \t\t\t|| tp[0] == DCS))\n \t    {\n \t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n \t\t    return -1;\n \t    }\n \t}\n #endif\n \n \tif (key_name[0] == NUL)\n \t    continue;\n \n \n #ifdef FEAT_GUI\n \tif (gui.in_use\n \t\t&& key_name[0] == (int)KS_EXTRA\n \t\t&& (key_name[1] == (int)KE_X1MOUSE\n \t\t    || key_name[1] == (int)KE_X2MOUSE\n \t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n \t\t    || key_name[1] == (int)KE_MOUSELEFT\n \t\t    || key_name[1] == (int)KE_MOUSERIGHT\n \t\t    || key_name[1] == (int)KE_MOUSEDOWN\n \t\t    || key_name[1] == (int)KE_MOUSEUP))\n \t{\n \t    char_u\tbytes[6];\n \t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n \n \t    if (num_bytes == -1)\n \t\treturn -1;\n \t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n \t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n \t    slen += num_bytes;\n \t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n \t\tkey_name[1] = (int)KE_MOUSEMOVE;\n \t}\n \telse\n #endif\n \tif (key_name[0] == KS_MOUSE\n #ifdef FEAT_MOUSE_GPM\n \t\t|| key_name[0] == KS_GPM_MOUSE\n #endif\n #ifdef FEAT_MOUSE_JSB\n \t\t|| key_name[0] == KS_JSBTERM_MOUSE\n #endif\n #ifdef FEAT_MOUSE_NET\n \t\t|| key_name[0] == KS_NETTERM_MOUSE\n #endif\n #ifdef FEAT_MOUSE_DEC\n \t\t|| key_name[0] == KS_DEC_MOUSE\n #endif\n #ifdef FEAT_MOUSE_PTERM\n \t\t|| key_name[0] == KS_PTERM_MOUSE\n #endif\n #ifdef FEAT_MOUSE_URXVT\n \t\t|| key_name[0] == KS_URXVT_MOUSE\n #endif\n \t\t|| key_name[0] == KS_SGR_MOUSE\n \t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n \t{\n \t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n \t\t\t\t\t\t\t     &modifiers) == -1)\n \t\treturn -1;\n \t}\n \n #ifdef FEAT_GUI\n # ifdef FEAT_MENU\n \telse if (key_name[0] == (int)KS_MENU)\n \t{\n \t    long_u\tval;\n \t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n \n \t    if (num_bytes == -1)\n \t\treturn -1;\n \t    current_menu = (vimmenu_T *)val;\n \t    slen += num_bytes;\n \n \t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n \t    {\n \t\tkey_name[0] = KS_EXTRA;\n \t\tkey_name[1] = (int)KE_IGNORE;\n \t    }\n \t}\n # endif\n # ifdef FEAT_GUI_TABLINE\n \telse if (key_name[0] == (int)KS_TABLINE)\n \t{\n \t    char_u\tbytes[6];\n \t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n \n \t    if (num_bytes == -1)\n \t\treturn -1;\n \t    current_tab = (int)bytes[0];\n \t    if (current_tab == 255)\n \t\tcurrent_tab = -1;\n \t    slen += num_bytes;\n \t}\n \telse if (key_name[0] == (int)KS_TABMENU)\n \t{\n \t    char_u\tbytes[6];\n \t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n \n \t    if (num_bytes == -1)\n \t\treturn -1;\n \t    current_tab = (int)bytes[0];\n \t    current_tabmenu = (int)bytes[1];\n \t    slen += num_bytes;\n \t}\n # endif\n # ifndef USE_ON_FLY_SCROLL\n \telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n \t{\n \t    long_u\tval;\n \t    char_u\tbytes[6];\n \t    int\t\tnum_bytes;\n \n \t    j = 0;\n \t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n \t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n \t    {\n \t\tj += 3;\n \t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n \t\tif (num_bytes == -1)\n \t\t    break;\n \t\tif (i == 0)\n \t\t    current_scrollbar = (int)bytes[0];\n \t\telse if (current_scrollbar != (int)bytes[0])\n \t\t    break;\n \t\tj += num_bytes;\n \t\tnum_bytes = get_long_from_buf(tp + j, &val);\n \t\tif (num_bytes == -1)\n \t\t    break;\n \t\tscrollbar_value = val;\n \t\tj += num_bytes;\n \t\tslen = j;\n \t    }\n \t    if (i == 0)\n \t\treturn -1;\n \t}\n \telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n \t{\n \t    long_u\tval;\n \t    int\t\tnum_bytes;\n \n \t    j = 0;\n \t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n \t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n \t    {\n \t\tj += 3;\n \t\tnum_bytes = get_long_from_buf(tp + j, &val);\n \t\tif (num_bytes == -1)\n \t\t    break;\n \t\tscrollbar_value = val;\n \t\tj += num_bytes;\n \t\tslen = j;\n \t    }\n \t    if (i == 0)\n \t\treturn -1;\n \t}\n # endif\n #endif\n \n #if (defined(UNIX) || defined(VMS))\n \tif (key_name[0] == KS_EXTRA\n # ifdef FEAT_GUI\n \t\t&& !gui.in_use\n # endif\n \t    )\n \t{\n \t    if (key_name[1] == KE_FOCUSGAINED)\n \t    {\n \t\tif (!focus_state)\n \t\t{\n \t\t    ui_focus_change(TRUE);\n \t\t    did_cursorhold = TRUE;\n \t\t    focus_state = TRUE;\n \t\t}\n \t\tkey_name[1] = (int)KE_IGNORE;\n \t    }\n \t    else if (key_name[1] == KE_FOCUSLOST)\n \t    {\n \t\tif (focus_state)\n \t\t{\n \t\t    ui_focus_change(FALSE);\n \t\t    did_cursorhold = TRUE;\n \t\t    focus_state = FALSE;\n \t\t}\n \t\tkey_name[1] = (int)KE_IGNORE;\n \t    }\n \t}\n #endif\n \n \tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n \n \tnew_slen = modifiers2keycode(modifiers, &key, string);\n \n \tkey_name[0] = KEY2TERMCAP0(key);\n \tkey_name[1] = KEY2TERMCAP1(key);\n \tif (key_name[0] == KS_KEY)\n \t{\n \t    if (has_mbyte)\n \t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n \t    else\n \t\tstring[new_slen++] = key_name[1];\n \t}\n \telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n \t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n \t{\n \t    retval = KEYLEN_REMOVED;\n \t}\n \telse\n \t{\n \t    string[new_slen++] = K_SPECIAL;\n \t    string[new_slen++] = key_name[0];\n \t    string[new_slen++] = key_name[1];\n \t}\n \tif (put_string_in_typebuf(offset, slen, string, new_slen,\n \t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n \t    return -1;\n \treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n     }\n \n #ifdef FEAT_TERMRESPONSE\n     LOG_TR((\"normal character\"));\n #endif\n \n     return 0;\n }\n \n", "target": "// fix_start\n\ttp[len] = NUL;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2285", "cve_desc": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.", "project": "vim", "idx": 208411}
{"source": " networkstatus_parse_vote_from_string(const char *s, const char **eos_out,\n                                      networkstatus_type_t ns_type)\n {\n   smartlist_t *tokens = smartlist_create();\n   smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;\n   networkstatus_voter_info_t *voter = NULL;\n   networkstatus_t *ns = NULL;\n   digests_t ns_digests;\n   const char *cert, *end_of_header, *end_of_footer, *s_dup = s;\n   directory_token_t *tok;\n   int ok;\n   struct in_addr in;\n   int i, inorder, n_signatures = 0;\n   memarea_t *area = NULL, *rs_area = NULL;\n   consensus_flavor_t flav = FLAV_NS;\n \n   tor_assert(s);\n \n   if (eos_out)\n     *eos_out = NULL;\n \n   if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {\n     log_warn(LD_DIR, \"Unable to compute digest of network-status\");\n     goto err;\n   }\n \n   area = memarea_new();\n   end_of_header = find_start_of_next_routerstatus(s);\n   if (tokenize_string(area, s, end_of_header, tokens,\n                       (ns_type == NS_TYPE_CONSENSUS) ?\n                       networkstatus_consensus_token_table :\n                       networkstatus_token_table, 0)) {\n     log_warn(LD_DIR, \"Error tokenizing network-status vote header\");\n     goto err;\n   }\n \n   ns = tor_malloc_zero(sizeof(networkstatus_t));\n   memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));\n \n   tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);\n   tor_assert(tok);\n   if (tok->n_args > 1) {\n     int flavor = networkstatus_parse_flavor_name(tok->args[1]);\n     if (flavor < 0) {\n       log_warn(LD_DIR, \"Can't parse document with unknown flavor %s\",\n// bug_start\n               escaped(tok->args[2]));\n// bug_end\n       goto err;\n     }\n     ns->flavor = flav = flavor;\n   }\n   if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {\n     log_warn(LD_DIR, \"Flavor found on non-consensus networkstatus.\");\n     goto err;\n   }\n \n   if (ns_type != NS_TYPE_CONSENSUS) {\n     const char *end_of_cert = NULL;\n     if (!(cert = strstr(s, \"\\ndir-key-certificate-version\")))\n       goto err;\n     ++cert;\n     ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);\n     if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)\n       goto err;\n   }\n \n   tok = find_by_keyword(tokens, K_VOTE_STATUS);\n   tor_assert(tok->n_args);\n   if (!strcmp(tok->args[0], \"vote\")) {\n     ns->type = NS_TYPE_VOTE;\n   } else if (!strcmp(tok->args[0], \"consensus\")) {\n     ns->type = NS_TYPE_CONSENSUS;\n   } else if (!strcmp(tok->args[0], \"opinion\")) {\n     ns->type = NS_TYPE_OPINION;\n   } else {\n     log_warn(LD_DIR, \"Unrecognized vote status %s in network-status\",\n              escaped(tok->args[0]));\n     goto err;\n   }\n   if (ns_type != ns->type) {\n     log_warn(LD_DIR, \"Got the wrong kind of v3 networkstatus.\");\n     goto err;\n   }\n \n   if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {\n     tok = find_by_keyword(tokens, K_PUBLISHED);\n     if (parse_iso_time(tok->args[0], &ns->published))\n       goto err;\n \n     ns->supported_methods = smartlist_create();\n     tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);\n     if (tok) {\n       for (i=0; i < tok->n_args; ++i)\n         smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));\n     } else {\n       smartlist_add(ns->supported_methods, tor_strdup(\"1\"));\n     }\n   } else {\n     tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);\n     if (tok) {\n       ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,\n                                                  &ok, NULL);\n       if (!ok)\n         goto err;\n     } else {\n       ns->consensus_method = 1;\n     }\n   }\n \n   tok = find_by_keyword(tokens, K_VALID_AFTER);\n   if (parse_iso_time(tok->args[0], &ns->valid_after))\n     goto err;\n \n   tok = find_by_keyword(tokens, K_FRESH_UNTIL);\n   if (parse_iso_time(tok->args[0], &ns->fresh_until))\n     goto err;\n \n   tok = find_by_keyword(tokens, K_VALID_UNTIL);\n   if (parse_iso_time(tok->args[0], &ns->valid_until))\n     goto err;\n \n   tok = find_by_keyword(tokens, K_VOTING_DELAY);\n   tor_assert(tok->n_args >= 2);\n   ns->vote_seconds =\n     (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);\n   if (!ok)\n     goto err;\n   ns->dist_seconds =\n     (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);\n   if (!ok)\n     goto err;\n   if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {\n     log_warn(LD_DIR, \"Vote/consensus freshness interval is too short\");\n     goto err;\n   }\n   if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {\n     log_warn(LD_DIR, \"Vote/consensus liveness interval is too short\");\n     goto err;\n   }\n   if (ns->vote_seconds < MIN_VOTE_SECONDS) {\n     log_warn(LD_DIR, \"Vote seconds is too short\");\n     goto err;\n   }\n   if (ns->dist_seconds < MIN_DIST_SECONDS) {\n     log_warn(LD_DIR, \"Dist seconds is too short\");\n     goto err;\n   }\n \n   if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {\n     ns->client_versions = tor_strdup(tok->args[0]);\n   }\n   if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {\n     ns->server_versions = tor_strdup(tok->args[0]);\n   }\n \n   tok = find_by_keyword(tokens, K_KNOWN_FLAGS);\n   ns->known_flags = smartlist_create();\n   inorder = 1;\n   for (i = 0; i < tok->n_args; ++i) {\n     smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));\n     if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {\n       log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n       inorder = 0;\n     }\n   }\n   if (!inorder) {\n     log_warn(LD_DIR, \"known-flags not in order\");\n     goto err;\n   }\n \n   tok = find_opt_by_keyword(tokens, K_PARAMS);\n   if (tok) {\n     inorder = 1;\n     ns->net_params = smartlist_create();\n     for (i = 0; i < tok->n_args; ++i) {\n       int ok=0;\n       char *eq = strchr(tok->args[i], '=');\n       if (!eq) {\n         log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n         goto err;\n       }\n       tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n       if (!ok) {\n         log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n         goto err;\n       }\n       if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {\n         log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n         inorder = 0;\n       }\n       smartlist_add(ns->net_params, tor_strdup(tok->args[i]));\n     }\n     if (!inorder) {\n       log_warn(LD_DIR, \"params not in order\");\n       goto err;\n     }\n   }\n \n   ns->voters = smartlist_create();\n \n   SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {\n     tok = _tok;\n     if (tok->tp == K_DIR_SOURCE) {\n       tor_assert(tok->n_args >= 6);\n \n       if (voter)\n         smartlist_add(ns->voters, voter);\n       voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));\n       voter->sigs = smartlist_create();\n       if (ns->type != NS_TYPE_CONSENSUS)\n         memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);\n \n       voter->nickname = tor_strdup(tok->args[0]);\n       if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||\n           base16_decode(voter->identity_digest, sizeof(voter->identity_digest),\n                         tok->args[1], HEX_DIGEST_LEN) < 0) {\n         log_warn(LD_DIR, \"Error decoding identity digest %s in \"\n                  \"network-status vote.\", escaped(tok->args[1]));\n         goto err;\n       }\n       if (ns->type != NS_TYPE_CONSENSUS &&\n           tor_memneq(ns->cert->cache_info.identity_digest,\n                  voter->identity_digest, DIGEST_LEN)) {\n         log_warn(LD_DIR,\"Mismatch between identities in certificate and vote\");\n         goto err;\n       }\n       voter->address = tor_strdup(tok->args[2]);\n       if (!tor_inet_aton(tok->args[3], &in)) {\n         log_warn(LD_DIR, \"Error decoding IP address %s in network-status.\",\n                  escaped(tok->args[3]));\n         goto err;\n       }\n       voter->addr = ntohl(in.s_addr);\n       voter->dir_port = (uint16_t)\n         tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);\n       if (!ok)\n         goto err;\n       voter->or_port = (uint16_t)\n         tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);\n       if (!ok)\n         goto err;\n     } else if (tok->tp == K_CONTACT) {\n       if (!voter || voter->contact) {\n         log_warn(LD_DIR, \"contact element is out of place.\");\n         goto err;\n       }\n       voter->contact = tor_strdup(tok->args[0]);\n     } else if (tok->tp == K_VOTE_DIGEST) {\n       tor_assert(ns->type == NS_TYPE_CONSENSUS);\n       tor_assert(tok->n_args >= 1);\n       if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {\n         log_warn(LD_DIR, \"vote-digest element is out of place.\");\n         goto err;\n       }\n       if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||\n         base16_decode(voter->vote_digest, sizeof(voter->vote_digest),\n                       tok->args[0], HEX_DIGEST_LEN) < 0) {\n         log_warn(LD_DIR, \"Error decoding vote digest %s in \"\n                  \"network-status consensus.\", escaped(tok->args[0]));\n         goto err;\n       }\n     }\n   } SMARTLIST_FOREACH_END(_tok);\n   if (voter) {\n     smartlist_add(ns->voters, voter);\n     voter = NULL;\n   }\n   if (smartlist_len(ns->voters) == 0) {\n     log_warn(LD_DIR, \"Missing dir-source elements in a vote networkstatus.\");\n     goto err;\n   } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {\n     log_warn(LD_DIR, \"Too many dir-source elements in a vote networkstatus.\");\n     goto err;\n   }\n \n   if (ns->type != NS_TYPE_CONSENSUS &&\n       (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {\n     int bad = 1;\n     if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {\n       networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);\n       if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,\n                         tok->args[0], HEX_DIGEST_LEN)<0)\n         bad = 1;\n       else\n         bad = 0;\n     }\n     if (bad) {\n       log_warn(LD_DIR, \"Invalid legacy key digest %s on vote.\",\n                escaped(tok->args[0]));\n     }\n   }\n \n   rs_tokens = smartlist_create();\n   rs_area = memarea_new();\n   s = end_of_header;\n   ns->routerstatus_list = smartlist_create();\n \n   while (!strcmpstart(s, \"r \")) {\n     if (ns->type != NS_TYPE_CONSENSUS) {\n       vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));\n       if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,\n                                                rs, 0, 0))\n         smartlist_add(ns->routerstatus_list, rs);\n       else {\n         tor_free(rs->version);\n         tor_free(rs);\n       }\n     } else {\n       routerstatus_t *rs;\n       if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,\n                                                      NULL, NULL,\n                                                      ns->consensus_method,\n                                                      flav)))\n         smartlist_add(ns->routerstatus_list, rs);\n     }\n   }\n   for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {\n     routerstatus_t *rs1, *rs2;\n     if (ns->type != NS_TYPE_CONSENSUS) {\n       vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);\n       vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);\n       rs1 = &a->status; rs2 = &b->status;\n     } else {\n       rs1 = smartlist_get(ns->routerstatus_list, i-1);\n       rs2 = smartlist_get(ns->routerstatus_list, i);\n     }\n     if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)\n         >= 0) {\n       log_warn(LD_DIR, \"Vote networkstatus entries not sorted by identity \"\n                \"digest\");\n       goto err;\n     }\n   }\n \n   footer_tokens = smartlist_create();\n   if ((end_of_footer = strstr(s, \"\\nnetwork-status-version \")))\n     ++end_of_footer;\n   else\n     end_of_footer = s + strlen(s);\n   if (tokenize_string(area,s, end_of_footer, footer_tokens,\n                       networkstatus_vote_footer_token_table, 0)) {\n     log_warn(LD_DIR, \"Error tokenizing network-status vote footer.\");\n     goto err;\n   }\n \n   {\n     int found_sig = 0;\n     SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n       tok = _tok;\n       if (tok->tp == K_DIRECTORY_SIGNATURE)\n         found_sig = 1;\n       else if (found_sig) {\n         log_warn(LD_DIR, \"Extraneous token after first directory-signature\");\n         goto err;\n       }\n     } SMARTLIST_FOREACH_END(_tok);\n   }\n \n   if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {\n     if (tok != smartlist_get(footer_tokens, 0)) {\n       log_warn(LD_DIR, \"Misplaced directory-footer token\");\n       goto err;\n     }\n   }\n \n   tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);\n   if (tok) {\n     ns->weight_params = smartlist_create();\n     for (i = 0; i < tok->n_args; ++i) {\n       int ok=0;\n       char *eq = strchr(tok->args[i], '=');\n       if (!eq) {\n         log_warn(LD_DIR, \"Bad element '%s' in weight params\",\n                  escaped(tok->args[i]));\n         goto err;\n       }\n       tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n       if (!ok) {\n         log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n         goto err;\n       }\n       smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));\n     }\n   }\n \n   SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n     char declared_identity[DIGEST_LEN];\n     networkstatus_voter_info_t *v;\n     document_signature_t *sig;\n     const char *id_hexdigest = NULL;\n     const char *sk_hexdigest = NULL;\n     digest_algorithm_t alg = DIGEST_SHA1;\n     tok = _tok;\n     if (tok->tp != K_DIRECTORY_SIGNATURE)\n       continue;\n     tor_assert(tok->n_args >= 2);\n     if (tok->n_args == 2) {\n       id_hexdigest = tok->args[0];\n       sk_hexdigest = tok->args[1];\n     } else {\n       const char *algname = tok->args[0];\n       int a;\n       id_hexdigest = tok->args[1];\n       sk_hexdigest = tok->args[2];\n       a = crypto_digest_algorithm_parse_name(algname);\n       if (a<0) {\n         log_warn(LD_DIR, \"Unknown digest algorithm %s; skipping\",\n                  escaped(algname));\n         continue;\n       }\n       alg = a;\n     }\n \n     if (!tok->object_type ||\n         strcmp(tok->object_type, \"SIGNATURE\") ||\n         tok->object_size < 128 || tok->object_size > 512) {\n       log_warn(LD_DIR, \"Bad object type or length on directory-signature\");\n       goto err;\n     }\n \n     if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||\n         base16_decode(declared_identity, sizeof(declared_identity),\n                       id_hexdigest, HEX_DIGEST_LEN) < 0) {\n       log_warn(LD_DIR, \"Error decoding declared identity %s in \"\n                \"network-status vote.\", escaped(id_hexdigest));\n       goto err;\n     }\n     if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {\n       log_warn(LD_DIR, \"ID on signature on network-status vote does not match \"\n                \"any declared directory source.\");\n       goto err;\n     }\n     sig = tor_malloc_zero(sizeof(document_signature_t));\n     memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);\n     sig->alg = alg;\n     if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||\n         base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),\n                       sk_hexdigest, HEX_DIGEST_LEN) < 0) {\n       log_warn(LD_DIR, \"Error decoding declared signing key digest %s in \"\n                \"network-status vote.\", escaped(sk_hexdigest));\n       tor_free(sig);\n       goto err;\n     }\n \n     if (ns->type != NS_TYPE_CONSENSUS) {\n       if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,\n                  DIGEST_LEN)) {\n         log_warn(LD_DIR, \"Digest mismatch between declared and actual on \"\n                  \"network-status vote.\");\n         tor_free(sig);\n         goto err;\n       }\n     }\n \n     if (voter_get_sig_by_algorithm(v, sig->alg)) {\n       log_fn(LOG_PROTOCOL_WARN, LD_DIR, \"We received a networkstatus \"\n              \"that contains two votes from the same voter with the same \"\n              \"algorithm. Ignoring the second vote.\");\n       tor_free(sig);\n       continue;\n     }\n \n     if (ns->type != NS_TYPE_CONSENSUS) {\n       if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,\n                                 tok, ns->cert->signing_key, 0,\n                                 \"network-status vote\")) {\n         tor_free(sig);\n         goto err;\n       }\n       sig->good_signature = 1;\n     } else {\n       if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {\n         tor_free(sig);\n         goto err;\n       }\n       sig->signature = tor_memdup(tok->object_body, tok->object_size);\n       sig->signature_len = (int) tok->object_size;\n     }\n     smartlist_add(v->sigs, sig);\n \n     ++n_signatures;\n   } SMARTLIST_FOREACH_END(_tok);\n \n   if (! n_signatures) {\n     log_warn(LD_DIR, \"No signatures on networkstatus vote.\");\n     goto err;\n   } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {\n     log_warn(LD_DIR, \"Received more than one signature on a \"\n              \"network-status vote.\");\n     goto err;\n   }\n \n   if (eos_out)\n     *eos_out = end_of_footer;\n \n   goto done;\n  err:\n   dump_desc(s_dup, \"v3 networkstatus\");\n   networkstatus_vote_free(ns);\n   ns = NULL;\n  done:\n   if (tokens) {\n     SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));\n     smartlist_free(tokens);\n   }\n   if (voter) {\n     if (voter->sigs) {\n       SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,\n                         document_signature_free(sig));\n       smartlist_free(voter->sigs);\n     }\n     tor_free(voter->nickname);\n     tor_free(voter->address);\n     tor_free(voter->contact);\n     tor_free(voter);\n   }\n   if (rs_tokens) {\n     SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));\n     smartlist_free(rs_tokens);\n   }\n   if (footer_tokens) {\n     SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));\n     smartlist_free(footer_tokens);\n   }\n   if (area) {\n     DUMP_AREA(area, \"v3 networkstatus\");\n     memarea_drop_all(area);\n   }\n   if (rs_area)\n     memarea_drop_all(rs_area);\n \n   return ns;\n }\n \n", "target": "// fix_start\n               escaped(tok->args[1]));\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "cve": "CVE-2012-3517", "cve_desc": "Use-after-free vulnerability in dns.c in Tor before 0.2.2.38 might allow remote attackers to cause a denial of service (daemon crash) via vectors related to failed DNS requests.", "project": "tor", "idx": 208505}
{"source": " tgs_build_reply(astgs_request_t priv,\n \t\thdb_entry_ex *krbtgt,\n \t\tkrb5_enctype krbtgt_etype,\n \t\tconst krb5_keyblock *replykey,\n \t\tint rk_is_subkey,\n \t\tkrb5_ticket *ticket,\n \t\tconst char **e_text,\n \t\tAuthorizationData **auth_data,\n \t\tconst struct sockaddr *from_addr)\n {\n     krb5_context context = priv->context;\n     krb5_kdc_configuration *config = priv->config;\n     KDC_REQ *req = &priv->req;\n     KDC_REQ_BODY *b = &priv->req.req_body;\n     const char *from = priv->from;\n     krb5_error_code ret, ret2;\n     krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n     krb5_principal krbtgt_out_principal = NULL;\n     char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n     hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n     HDB *clientdb, *s4u2self_impersonated_clientdb;\n     krb5_realm ref_realm = NULL;\n     EncTicketPart *tgt = &ticket->ticket;\n     krb5_principals spp = NULL;\n     const EncryptionKey *ekey;\n     krb5_keyblock sessionkey;\n     krb5_kvno kvno;\n     krb5_data rspac;\n     const char *tgt_realm =\n         krb5_principal_get_realm(context, krbtgt->entry.principal);\n     const char *our_realm =\n         krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n     char **capath = NULL;\n     size_t num_capath = 0;\n \n     hdb_entry_ex *krbtgt_out = NULL;\n \n     METHOD_DATA enc_pa_data;\n \n     PrincipalName *s;\n     Realm r;\n     EncTicketPart adtkt;\n     char opt_str[128];\n     int signedpath = 0;\n \n     Key *tkey_check;\n     Key *tkey_sign;\n     int flags = HDB_F_FOR_TGS_REQ;\n \n     memset(&sessionkey, 0, sizeof(sessionkey));\n     memset(&adtkt, 0, sizeof(adtkt));\n     krb5_data_zero(&rspac);\n     memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n \n     s = b->sname;\n     r = b->realm;\n \n     if (b->kdc_options.canonicalize)\n \tflags |= HDB_F_CANON;\n \n     if(b->kdc_options.enc_tkt_in_skey){\n \tTicket *t;\n \thdb_entry_ex *uu;\n \tkrb5_principal p;\n \tKey *uukey;\n \tkrb5uint32 second_kvno = 0;\n \tkrb5uint32 *kvno_ptr = NULL;\n \n \tif(b->additional_tickets == NULL ||\n \t   b->additional_tickets->len == 0){\n \t    ret = KRB5KDC_ERR_BADOPTION;\n \t    kdc_log(context, config, 4,\n \t\t    \"No second ticket present in user-to-user request\");\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"No second ticket present in user-to-user request\");\n \t    goto out;\n \t}\n \tt = &b->additional_tickets->val[0];\n \tif(!get_krbtgt_realm(&t->sname)){\n \t    kdc_log(context, config, 4,\n \t\t    \"Additional ticket is not a ticket-granting ticket\");\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"Additional ticket is not a ticket-granting ticket\");\n \t    ret = KRB5KDC_ERR_POLICY;\n \t    goto out;\n \t}\n \t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n \tret = krb5_unparse_name(context, p, &tpn);\n \tif (ret)\n \t\tgoto out;\n \tif(t->enc_part.kvno){\n \t    second_kvno = *t->enc_part.kvno;\n \t    kvno_ptr = &second_kvno;\n \t}\n \tret = _kdc_db_fetch(context, config, p,\n \t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n \t\t\t    NULL, &uu);\n \tkrb5_free_principal(context, p);\n \tif(ret){\n \t    if (ret == HDB_ERR_NOENTRY)\n \t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"User-to-user service principal (TGS) unknown\");\n \t    goto out;\n \t}\n \tret = hdb_enctype2key(context, &uu->entry, NULL,\n \t\t\t      t->enc_part.etype, &uukey);\n \tif(ret){\n \t    _kdc_free_ent(context, uu);\n \t    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"User-to-user enctype not supported\");\n \t    goto out;\n \t}\n \tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n \t_kdc_free_ent(context, uu);\n \tif(ret) {\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"User-to-user TGT decrypt failure\");\n \t    goto out;\n         }\n \n \tret = verify_flags(context, config, &adtkt, tpn);\n \tif (ret) {\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"User-to-user TGT expired or invalid\");\n \t    goto out;\n         }\n \n \ts = &adtkt.cname;\n \tr = adtkt.crealm;\n// bug_start\n// bug_end\n     }\n \n     _krb5_principalname2krb5_principal(context, &sp, *s, r);\n     ret = krb5_unparse_name(context, sp, &priv->sname);\n     if (ret)\n \tgoto out;\n     spn = priv->sname;\n     _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n     ret = krb5_unparse_name(context, cp, &priv->cname);\n     if (ret)\n \tgoto out;\n     cpn = priv->cname;\n     unparse_flags (KDCOptions2int(b->kdc_options),\n \t\t   asn1_KDCOptions_units(),\n \t\t   opt_str, sizeof(opt_str));\n     if(*opt_str)\n \tkdc_log(context, config, 4,\n \t\t\"TGS-REQ %s from %s for %s [%s]\",\n \t\tcpn, from, spn, opt_str);\n     else\n \tkdc_log(context, config, 4,\n \t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n \n \n server_lookup:\n     ret = _kdc_db_fetch(context, config, sp,\n                         HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n \t\t\tNULL, NULL, &server);\n     priv->server = server;\n     if (ret == HDB_ERR_NOT_FOUND_HERE) {\n \tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n         _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n \tgoto out;\n     } else if (ret == HDB_ERR_WRONG_REALM) {\n         free(ref_realm);\n \tref_realm = strdup(server->entry.principal->realm);\n \tif (ref_realm == NULL) {\n             ret = krb5_enomem(context);\n \t    goto out;\n \t}\n \n \tkdc_log(context, config, 4,\n \t\t\"Returning a referral to realm %s for \"\n \t\t\"server %s.\",\n \t\tref_realm, spn);\n \tkrb5_free_principal(context, sp);\n \tsp = NULL;\n \tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n \t\t\t\t  ref_realm, NULL);\n \tif (ret)\n \t    goto out;\n \tfree(priv->sname);\n         priv->sname = NULL;\n \tret = krb5_unparse_name(context, sp, &priv->sname);\n \tif (ret)\n \t    goto out;\n \tspn = priv->sname;\n \n \tgoto server_lookup;\n     } else if (ret) {\n \tconst char *new_rlm, *msg;\n \tRealm req_rlm;\n \tkrb5_realm *realms;\n \n \tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n             if (capath == NULL) {\n                 ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                          req_rlm, TRUE, &capath, &num_capath);\n                 if (ret2) {\n                     ret = ret2;\n                     _kdc_audit_addreason((kdc_request_t)priv,\n                                          \"No trusted path from client realm to ours\");\n                     goto out;\n                 }\n             }\n             new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n             if (new_rlm) {\n                 kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                         \"realm %s not found, trying %s\", tgt->crealm,\n                         our_realm, req_rlm, new_rlm);\n \n                 free(ref_realm);\n                 ref_realm = strdup(new_rlm);\n                 if (ref_realm == NULL) {\n                     ret = krb5_enomem(context);\n                     goto out;\n                 }\n \n                 krb5_free_principal(context, sp);\n                 sp = NULL;\n                 krb5_make_principal(context, &sp, r,\n                                     KRB5_TGS_NAME, ref_realm, NULL);\n                 free(priv->sname);\n                 priv->sname = NULL;\n                 ret = krb5_unparse_name(context, sp, &priv->sname);\n                 if (ret)\n                     goto out;\n                 spn = priv->sname;\n                 goto server_lookup;\n             }\n \t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n \t    if (strcmp(realms[0], sp->realm) != 0) {\n \t\tkdc_log(context, config, 4,\n \t\t\t\"Returning a referral to realm %s for \"\n \t\t\t\"server %s that was not found\",\n \t\t\trealms[0], spn);\n \t\tkrb5_free_principal(context, sp);\n                 sp = NULL;\n \t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n \t\t\t\t    realms[0], NULL);\n \t\tfree(priv->sname);\n                 priv->sname = NULL;\n \t\tret = krb5_unparse_name(context, sp, &priv->sname);\n \t\tif (ret) {\n \t\t    krb5_free_host_realm(context, realms);\n \t\t    goto out;\n \t\t}\n \t\tspn = priv->sname;\n \n                 free(ref_realm);\n \t\tref_realm = strdup(realms[0]);\n \n \t\tkrb5_free_host_realm(context, realms);\n \t\tgoto server_lookup;\n \t    }\n \t    krb5_free_host_realm(context, realms);\n \t}\n \tmsg = krb5_get_error_message(context, ret);\n \tkdc_log(context, config, 3,\n \t\t\"Server not found in database: %s: %s\", spn, msg);\n \tkrb5_free_error_message(context, msg);\n \tif (ret == HDB_ERR_NOENTRY)\n \t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n         _kdc_audit_addreason((kdc_request_t)priv,\n                              \"Service principal unknown\");\n \tgoto out;\n     }\n \n     if (server->entry.flags.force_canonicalize)\n \trsp = server->entry.principal;\n     else\n \trsp = sp;\n \n \n     {\n \tkrb5_enctype etype;\n \n \tif(b->kdc_options.enc_tkt_in_skey) {\n \t    size_t i;\n \t    ekey = &adtkt.key;\n \t    for(i = 0; i < b->etype.len; i++)\n \t\tif (b->etype.val[i] == adtkt.key.keytype)\n \t\t    break;\n \t    if(i == b->etype.len) {\n \t\tkdc_log(context, config, 4,\n \t\t\t\"Addition ticket have not matching etypes\");\n \t\tkrb5_clear_error_message(context);\n \t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                 _kdc_audit_addreason((kdc_request_t)priv,\n                                      \"No matching enctypes for 2nd ticket\");\n \t\tgoto out;\n \t    }\n \t    etype = b->etype.val[i];\n \t    kvno = 0;\n \t} else {\n \t    Key *skey;\n \n \t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n \t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n \t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n \t\t\t\t  NULL);\n \t    if(ret) {\n \t\tkdc_log(context, config, 4,\n \t\t\t\"Server (%s) has no support for etypes\", spn);\n                 _kdc_audit_addreason((kdc_request_t)priv,\n                                      \"Enctype not supported\");\n \t\tgoto out;\n \t    }\n \t    ret = _kdc_get_preferred_key(context, config, server, spn,\n \t\t\t\t\t NULL, &skey);\n \t    if(ret) {\n \t\tkdc_log(context, config, 4,\n \t\t\t\"Server (%s) has no supported etypes\", spn);\n                 _kdc_audit_addreason((kdc_request_t)priv,\n                                      \"Enctype not supported\");\n \t\tgoto out;\n \t    }\n \t    ekey = &skey->key;\n \t    kvno = server->entry.kvno;\n \t}\n \n \tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n \tif (ret)\n \t    goto out;\n     }\n \n \n \n     ret = hdb_enctype2key(context, &krbtgt->entry, NULL,\n \t\t\t  krbtgt_etype, &tkey_check);\n     if(ret) {\n \tkdc_log(context, config, 4,\n \t\t    \"Failed to find key for krbtgt PAC check\");\n         _kdc_audit_addreason((kdc_request_t)priv,\n                              \"No key for krbtgt PAC check\");\n \tgoto out;\n     }\n \n \n     ret = krb5_make_principal(context,\n                               &krbtgt_out_principal,\n                               our_realm,\n                               KRB5_TGS_NAME,\n                               our_realm,\n                               NULL);\n     if (ret) {\n         kdc_log(context, config, 4,\n                 \"Failed to make krbtgt principal name object for \"\n                 \"authz-data signatures\");\n         goto out;\n     }\n     ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n     if (ret) {\n         kdc_log(context, config, 4,\n                 \"Failed to make krbtgt principal name object for \"\n                 \"authz-data signatures\");\n         goto out;\n     }\n \n     ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n \t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n     if (ret) {\n \tchar *ktpn = NULL;\n \tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n \tkdc_log(context, config, 4,\n \t\t\"No such principal %s (needed for authz-data signature keys) \"\n \t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n \t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n \tfree(ktpn);\n \tret = KRB5KRB_AP_ERR_NOT_US;\n \tgoto out;\n     }\n \n     if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n \t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n \tchar *ktpn;\n \tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n \tkdc_log(context, config, 4,\n \t\t\"Request with wrong krbtgt: %s\",\n \t\t(ret == 0) ? ktpn : \"<unknown>\");\n \tif(ret == 0)\n \t    free(ktpn);\n \tret = KRB5KRB_AP_ERR_NOT_US;\n         _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n \tgoto out;\n     }\n \n     ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n \t\t\t\t NULL, &tkey_sign);\n     if (ret) {\n \tkdc_log(context, config, 4,\n \t\t    \"Failed to find key for krbtgt PAC signature\");\n         _kdc_audit_addreason((kdc_request_t)priv,\n                              \"Failed to find key for krbtgt PAC signature\");\n \tgoto out;\n     }\n     ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n \t\t\t  tkey_sign->key.keytype, &tkey_sign);\n     if(ret) {\n \tkdc_log(context, config, 4,\n \t\t    \"Failed to find key for krbtgt PAC signature\");\n         _kdc_audit_addreason((kdc_request_t)priv,\n                              \"Failed to find key for krbtgt PAC signature\");\n \tgoto out;\n     }\n \n     {\n         krb5_data verified_cas;\n \n         ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                       KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                       &verified_cas);\n         if (ret == 0) {\n             krb5_data_free(&verified_cas);\n             flags |= HDB_F_SYNTHETIC_OK;\n         }\n     }\n     ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n \t\t\tNULL, &clientdb, &client);\n     flags &= ~HDB_F_SYNTHETIC_OK;\n     priv->client = client;\n     if(ret == HDB_ERR_NOT_FOUND_HERE) {\n     } else if(ret){\n \tconst char *krbtgt_realm, *msg;\n \n \n \tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n \n \tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n \t    if (ret == HDB_ERR_NOENTRY)\n \t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n \t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n \t\t    cpn);\n             _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n \t    goto out;\n \t}\n \n \tmsg = krb5_get_error_message(context, ret);\n \tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n         _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n \tkrb5_free_error_message(context, msg);\n     } else if (ret == 0 &&\n                (client->entry.flags.invalid || !client->entry.flags.client)) {\n         _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n         kdc_log(context, config, 4, \"Client has invalid bit set\");\n         ret = KRB5KDC_ERR_POLICY;\n         goto out;\n     }\n \n     ret = check_PAC(context, config, cp, NULL,\n \t\t    client, server, krbtgt,\n \t\t    &tkey_check->key,\n \t\t    ekey, &tkey_sign->key,\n \t\t    tgt, &rspac, &signedpath);\n     if (ret) {\n \tconst char *msg = krb5_get_error_message(context, ret);\n         _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n \tkdc_log(context, config, 4,\n \t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n \t\tspn, cpn, from, msg);\n \tkrb5_free_error_message(context, msg);\n \tgoto out;\n     }\n \n     ret = check_KRB5SignedPath(context,\n \t\t\t       config,\n \t\t\t       krbtgt,\n \t\t\t       cp,\n \t\t\t       tgt,\n \t\t\t       &spp,\n \t\t\t       &signedpath);\n     if (ret) {\n \tconst char *msg = krb5_get_error_message(context, ret);\n         _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n \tkdc_log(context, config, 4,\n \t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n \t\tspn, cpn, from, msg);\n \tkrb5_free_error_message(context, msg);\n \tgoto out;\n     }\n \n \n     tp = cp;\n     tpn = cpn;\n \n     if (client) {\n \tconst PA_DATA *sdata;\n \tint i = 0;\n \n \tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n \tif (sdata) {\n \t    struct astgs_request_desc imp_req;\n \t    krb5_crypto crypto;\n \t    krb5_data datack;\n \t    PA_S4U2Self self;\n \t    const char *str;\n \n \t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n \t\t\t\t     sdata->padata_value.length,\n \t\t\t\t     &self, NULL);\n \t    if (ret) {\n                 _kdc_audit_addreason((kdc_request_t)priv,\n                                      \"Failed to decode PA-S4U2Self\");\n \t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n \t\tgoto out;\n \t    }\n \n \t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n \t\tfree_PA_S4U2Self(&self);\n                 _kdc_audit_addreason((kdc_request_t)priv,\n                                      \"PA-S4U2Self with unkeyed checksum\");\n \t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n \t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n \t\tgoto out;\n \t    }\n \n \t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n \t    if (ret)\n \t\tgoto out;\n \n \t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n \t    if (ret) {\n \t\tconst char *msg = krb5_get_error_message(context, ret);\n \t\tfree_PA_S4U2Self(&self);\n \t\tkrb5_data_free(&datack);\n \t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n \t\tkrb5_free_error_message(context, msg);\n \t\tgoto out;\n \t    }\n \n \t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n \t\tstruct krb5_crypto_iov iov;\n \t\tunsigned char csdata[16];\n \t\tChecksum cs;\n \n \t\tcs.checksum.length = sizeof(csdata);\n \t\tcs.checksum.data = &csdata;\n \n \t\tiov.data.data = datack.data;\n \t\tiov.data.length = datack.length;\n \t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n \n \t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n \t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n \t\t\t\t\t      &cs);\n \t\tif (ret == 0 &&\n \t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n \t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n \t    }\n \t    else {\n \t\tret = krb5_verify_checksum(context,\n \t\t\t\t\t   crypto,\n \t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n \t\t\t\t\t   datack.data,\n \t\t\t\t\t   datack.length,\n \t\t\t\t\t   &self.cksum);\n \t    }\n \t    krb5_data_free(&datack);\n \t    krb5_crypto_destroy(context, crypto);\n \t    if (ret) {\n \t\tconst char *msg = krb5_get_error_message(context, ret);\n \t\tfree_PA_S4U2Self(&self);\n                 _kdc_audit_addreason((kdc_request_t)priv,\n                                      \"S4U2Self checksum failed\");\n \t\tkdc_log(context, config, 4,\n \t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n \t\tkrb5_free_error_message(context, msg);\n \t\tgoto out;\n \t    }\n \n \t    ret = _krb5_principalname2krb5_principal(context,\n \t\t\t\t\t\t     &tp,\n \t\t\t\t\t\t     self.name,\n \t\t\t\t\t\t     self.realm);\n \t    free_PA_S4U2Self(&self);\n \t    if (ret)\n \t\tgoto out;\n \n \t    ret = krb5_unparse_name(context, tp, &tpn);\n \t    if (ret)\n \t\tgoto out;\n \n \t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n \t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n \t\t\t\t&s4u2self_impersonated_client);\n \t    if (ret) {\n \t\tconst char *msg;\n \n \n \t\tif (ret == HDB_ERR_NOENTRY)\n \t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n \t\tmsg = krb5_get_error_message(context, ret);\n                 _kdc_audit_addreason((kdc_request_t)priv,\n                                      \"S4U2Self principal to impersonate not found\");\n \t\tkdc_log(context, config, 2,\n \t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n \t\t\ttpn, msg);\n \t\tkrb5_free_error_message(context, msg);\n \t\tgoto out;\n \t    }\n \n \t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n \t    free(s4u2self_impersonated_client->entry.pw_end);\n \t    s4u2self_impersonated_client->entry.pw_end = NULL;\n \n \t    imp_req = *priv;\n \t    imp_req.client = s4u2self_impersonated_client;\n \t    imp_req.client_princ = tp;\n \n \t    ret = kdc_check_flags(&imp_req, FALSE);\n \t    if (ret)\n \t\tgoto out;\n \n \t    if(rspac.data) {\n \t\tkrb5_pac p = NULL;\n \t\tkrb5_data_free(&rspac);\n \t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n \t\tif (ret) {\n                     _kdc_audit_addreason((kdc_request_t)priv,\n                                          \"KRB5SignedPath missing\");\n \t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n \t\t\t    tpn);\n \t\t    goto out;\n \t\t}\n \t\tif (p != NULL) {\n \t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n \t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n \t\t\t\t\t ekey, &tkey_sign->key,\n \t\t\t\t\t &rspac);\n \t\t    krb5_pac_free(context, p);\n \t\t    if (ret) {\n \t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n \t\t\t\ttpn);\n \t\t\tgoto out;\n \t\t    }\n \t\t}\n \t    }\n \n \t    ret = check_s4u2self(context, config, clientdb, client, sp);\n \t    if (ret) {\n \t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n \t\t\t\"to impersonate to service \"\n \t\t\t\"(tried for user %s to service %s)\",\n \t\t\tcpn, tpn, spn);\n \t\tgoto out;\n \t    }\n \n \n \t    if (client->entry.flags.trusted_for_delegation &&\n \t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n \t\tstr = \"[forwardable]\";\n \t    } else {\n \t\tb->kdc_options.forwardable = 0;\n \t\tstr = \"\";\n \t    }\n \t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n \t\t    \"service %s %s\", cpn, tpn, spn, str);\n \t}\n     }\n \n \n     if (client != NULL\n \t&& b->additional_tickets != NULL\n \t&& b->additional_tickets->len != 0\n \t&& b->kdc_options.cname_in_addl_tkt\n \t&& b->kdc_options.enc_tkt_in_skey == 0)\n     {\n \tint ad_signedpath = 0;\n \tKey *clientkey;\n \tTicket *t;\n \n \tif (!signedpath) {\n \t    ret = KRB5KDC_ERR_BADOPTION;\n             _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n \t    kdc_log(context, config, 4,\n \t\t    \"Constrained delegation done on service ticket %s/%s\",\n \t\t    cpn, spn);\n \t    goto out;\n \t}\n \n \tt = &b->additional_tickets->val[0];\n \n \tret = hdb_enctype2key(context, &client->entry,\n \t\t\t      hdb_kvno2keys(context, &client->entry,\n \t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n \t\t\t      t->enc_part.etype, &clientkey);\n \tif(ret){\n \t    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n \t    goto out;\n \t}\n \n \tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n \tif (ret) {\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"Failed to decrypt constrained delegation ticket\");\n \t    kdc_log(context, config, 4,\n \t\t    \"failed to decrypt ticket for \"\n \t\t    \"constrained delegation from %s to %s \", cpn, spn);\n \t    goto out;\n \t}\n \n \tret = _krb5_principalname2krb5_principal(context,\n \t\t\t\t\t\t &tp,\n \t\t\t\t\t\t adtkt.cname,\n \t\t\t\t\t\t adtkt.crealm);\n \tif (ret)\n \t    goto out;\n \n \tret = krb5_unparse_name(context, tp, &tpn);\n \tif (ret)\n \t    goto out;\n \n         _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n \n \tret = _krb5_principalname2krb5_principal(context,\n \t\t\t\t\t\t &dp,\n \t\t\t\t\t\t t->sname,\n \t\t\t\t\t\t t->realm);\n \tif (ret)\n \t    goto out;\n \n \tret = krb5_unparse_name(context, dp, &dpn);\n \tif (ret)\n \t    goto out;\n \n \tif (adtkt.flags.forwardable == 0) {\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"Missing forwardable flag on ticket for constrained delegation\");\n \t    kdc_log(context, config, 4,\n \t\t    \"Missing forwardable flag on ticket for \"\n \t\t    \"constrained delegation from %s (%s) as %s to %s \",\n \t\t    cpn, dpn, tpn, spn);\n \t    ret = KRB5KDC_ERR_BADOPTION;\n \t    goto out;\n \t}\n \n \tret = check_constrained_delegation(context, config, clientdb,\n \t\t\t\t\t   client, server, sp);\n \tif (ret) {\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"Constrained delegation not allowed\");\n \t    kdc_log(context, config, 4,\n \t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n \t\t    cpn, dpn, tpn, spn);\n \t    goto out;\n \t}\n \n \tret = verify_flags(context, config, &adtkt, tpn);\n \tif (ret) {\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"Constrained delegation ticket expired or invalid\");\n \t    goto out;\n \t}\n \n \tkrb5_data_free(&rspac);\n \n \tret = check_PAC(context, config, tp, dp,\n \t\t\tclient, server, krbtgt,\n \t\t\t&clientkey->key,\n \t\t\tekey, &tkey_sign->key,\n \t\t\t&adtkt, &rspac, &ad_signedpath);\n \tif (ret) {\n \t    const char *msg = krb5_get_error_message(context, ret);\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"Constrained delegation ticket PAC check failed\");\n \t    kdc_log(context, config, 4,\n \t\t    \"Verify delegated PAC failed to %s for client\"\n \t\t    \"%s (%s) as %s from %s with %s\",\n \t\t    spn, cpn, dpn, tpn, from, msg);\n \t    krb5_free_error_message(context, msg);\n \t    goto out;\n \t}\n \n \tret = check_KRB5SignedPath(context,\n \t\t\t\t   config,\n \t\t\t\t   krbtgt,\n \t\t\t\t   cp,\n \t\t\t\t   &adtkt,\n \t\t\t\t   NULL,\n \t\t\t\t   &ad_signedpath);\n \tif (ret) {\n \t    const char *msg = krb5_get_error_message(context, ret);\n \t    kdc_log(context, config, 4,\n \t\t    \"KRB5SignedPath check from service %s failed \"\n \t\t    \"for delegation to %s for client %s (%s)\"\n \t\t    \"from %s failed with %s\",\n \t\t    spn, tpn, dpn, cpn, from, msg);\n \t    krb5_free_error_message(context, msg);\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"KRB5SignedPath check failed\");\n \t    goto out;\n \t}\n \n \tif (!ad_signedpath) {\n \t    ret = KRB5KDC_ERR_BADOPTION;\n \t    kdc_log(context, config, 4,\n \t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n \t\t    \"for delegation to %s for client %s (%s)\"\n \t\t    \"from %s\",\n \t\t    spn, tpn, dpn, cpn, from);\n             _kdc_audit_addreason((kdc_request_t)priv,\n                                  \"Constrained delegation ticket not signed\");\n \t    goto out;\n \t}\n \n \tkdc_log(context, config, 4, \"constrained delegation for %s \"\n \t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n     }\n \n \n     ret = kdc_check_flags(priv, FALSE);\n     if(ret)\n \tgoto out;\n \n     if((b->kdc_options.validate || b->kdc_options.renew) &&\n        !krb5_principal_compare(context,\n \t\t\t       krbtgt->entry.principal,\n \t\t\t       server->entry.principal)){\n         _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n \tkdc_log(context, config, 4, \"Inconsistent request.\");\n \tret = KRB5KDC_ERR_SERVER_NOMATCH;\n \tgoto out;\n     }\n \n     if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n         if (config->check_ticket_addresses) {\n             ret = KRB5KRB_AP_ERR_BADADDR;\n             _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n             kdc_log(context, config, 4, \"Request from wrong address\");\n             _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n             goto out;\n         } else if (config->warn_ticket_addresses) {\n             _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n         }\n     }\n \n     if (is_anon_tgs_request_p(b, tgt)) {\n \tret = _kdc_check_anon_policy(priv);\n \tif (ret)\n \t    goto out;\n     }\n \n     if (ref_realm) {\n \tPA_DATA pa;\n \tkrb5_crypto crypto;\n \n \tkdc_log(context, config, 3,\n \t\t\"Adding server referral to %s\", ref_realm);\n \n \tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n \tif (ret)\n \t    goto out;\n \n \tret = build_server_referral(context, config, crypto, ref_realm,\n \t\t\t\t    NULL, s, &pa.padata_value);\n \tkrb5_crypto_destroy(context, crypto);\n \tif (ret) {\n             _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n \t    kdc_log(context, config, 4,\n \t\t    \"Failed building server referral\");\n \t    goto out;\n \t}\n \tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n \n \tret = add_METHOD_DATA(&enc_pa_data, &pa);\n \tkrb5_data_free(&pa.padata_value);\n \tif (ret) {\n \t    kdc_log(context, config, 4,\n \t\t    \"Add server referral METHOD-DATA failed\");\n \t    goto out;\n \t}\n     }\n \n \n     ret = tgs_make_reply(priv,\n \t\t\t tp,\n \t\t\t tgt,\n \t\t\t replykey,\n \t\t\t rk_is_subkey,\n \t\t\t ekey,\n \t\t\t &sessionkey,\n \t\t\t kvno,\n \t\t\t *auth_data,\n \t\t\t server,\n \t\t\t rsp,\n \t\t\t client,\n \t\t\t cp,\n                          tgt_realm,\n \t\t\t krbtgt_out,\n \t\t\t tkey_sign->key.keytype,\n \t\t\t spp,\n \t\t\t &rspac,\n \t\t\t &enc_pa_data);\n \n out:\n     if (tpn != cpn)\n \t    free(tpn);\n     free(dpn);\n     free(krbtgt_out_n);\n     _krb5_free_capath(context, capath);\n \n     krb5_data_free(&rspac);\n     krb5_free_keyblock_contents(context, &sessionkey);\n     if(krbtgt_out)\n \t_kdc_free_ent(context, krbtgt_out);\n     if(server)\n \t_kdc_free_ent(context, server);\n     if(client)\n \t_kdc_free_ent(context, client);\n     if(s4u2self_impersonated_client)\n \t_kdc_free_ent(context, s4u2self_impersonated_client);\n \n     if (tp && tp != cp)\n \tkrb5_free_principal(context, tp);\n     krb5_free_principal(context, cp);\n     krb5_free_principal(context, dp);\n     krb5_free_principal(context, sp);\n     krb5_free_principal(context, krbtgt_out_principal);\n     free(ref_realm);\n     free_METHOD_DATA(&enc_pa_data);\n \n     free_EncTicketPart(&adtkt);\n \n     return ret;\n }\n \n", "target": "// fix_start\n    } else if (s == NULL) {\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t_kdc_set_e_text(r, \"No server in request\");\n\tgoto out;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-3671", "cve_desc": "A null pointer de-reference was found in the way samba kerberos server handled missing sname in TGS-REQ (Ticket Granting Server - Request). An authenticated user could use this flaw to crash the samba server.", "project": "heimdal", "idx": 208506}
{"source": " dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n {\n     size_t i, j;\n     if(!cfg_str2list_insert(&cfg->local_zones,\n                             strdup(dnscenv->provider_name),\n                             strdup(\"deny\"))) {\n         log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                 dnscenv->provider_name);\n         return -1;\n     }\n \n     for(i=0; i<dnscenv->signed_certs_count; i++) {\n         const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n         int rotated_cert = 0;\n \tuint32_t serial;\n \tuint16_t rrlen;\n \tchar* rr;\n         struct SignedCert *cert = dnscenv->signed_certs + i;\n         for(j=0; j<dnscenv->rotated_certs_count; j++){\n             if(cert == dnscenv->rotated_certs[j]) {\n                 rotated_cert = 1;\n                 break;\n             }\n         }\n \t\tmemcpy(&serial, cert->serial, sizeof serial);\n \t\tserial = htonl(serial);\n         if(rotated_cert) {\n             verbose(VERB_OPS,\n                 \"DNSCrypt: not adding cert with serial #%\"\n                 PRIu32\n                 \" to local-data as it is rotated\",\n                 serial\n             );\n             continue;\n         }\n// bug_start\n// bug_end\n         rrlen = strlen(dnscenv->provider_name) +\n                          strlen(ttl_class_type) +\n                          4 * sizeof(struct SignedCert) +\n                          1 +\n                          1;\n         rr = malloc(rrlen);\n         if(!rr) {\n             log_err(\"Could not allocate memory\");\n             return -2;\n         }\n         snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n         for(j=0; j<sizeof(struct SignedCert); j++) {\n \t\t\tint c = (int)*((const uint8_t *) cert + j);\n             if (isprint(c) && c != '\"' && c != '\\\\') {\n                 snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n             } else {\n                 snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n             }\n         }\n         verbose(VERB_OPS,\n \t\t\t\"DNSCrypt: adding cert with serial #%\"\n \t\t\tPRIu32\n \t\t\t\" to local-data to config: %s\",\n \t\t\tserial, rr\n \t\t);\n         snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n         cfg_strlist_insert(&cfg->local_data, strdup(rr));\n         free(rr);\n     }\n     return dnscenv->signed_certs_count;\n }\n \n", "target": "// fix_start\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2019-25038", "cve_desc": "Unbound before 1.9.5 allows an integer overflow in a size calculation in dnscrypt/dnscrypt.c. NOTE: The vendor disputes that this is a vulnerability. Although the code may be vulnerable, a running Unbound installation cannot be remotely or locally exploited", "project": "unbound", "idx": 208522}
{"source": " cmdline_insert_reg(int *gotesc UNUSED)\n {\n     int\t\ti;\n     int\t\tc;\n// bug_start\n// bug_end\n \n #ifdef USE_ON_FLY_SCROLL\n     dont_scroll = TRUE;\n #endif\n     putcmdline('\"', TRUE);\n     ++no_mapping;\n     ++allow_keys;\n     i = c = plain_vgetc();\n     if (i == Ctrl_O)\n \ti = Ctrl_R;\n     if (i == Ctrl_R)\n \tc = plain_vgetc();\n     extra_char = NUL;\n     --no_mapping;\n     --allow_keys;\n #ifdef FEAT_EVAL\n     new_cmdpos = -1;\n     if (c == '=')\n     {\n \tif (ccline.cmdfirstc == '='\n \t\t|| cmdline_star > 0)\n \t{\n \t    beep_flush();\n \t    c = ESC;\n \t}\n \telse\n \t    c = get_expr_register();\n     }\n #endif\n     if (c != ESC)\n     {\n \tcmdline_paste(c, i == Ctrl_R, FALSE);\n \n #ifdef FEAT_EVAL\n \tif (aborting())\n \t{\n \t    *gotesc = TRUE;\n \t    return GOTO_NORMAL_MODE;\n \t}\n #endif\n \tKeyTyped = FALSE;\n #ifdef FEAT_EVAL\n \tif (new_cmdpos >= 0)\n \t{\n \t    if (new_cmdpos > ccline.cmdlen)\n \t\tccline.cmdpos = ccline.cmdlen;\n \t    else\n \t\tccline.cmdpos = new_cmdpos;\n \t}\n #endif\n     }\n// bug_start\n// bug_end\n     redrawcmd();\n \n     return CMDLINE_NOT_CHANGED;\n }\n \n", "target": "// fix_start\n    int\t\tsave_new_cmdpos = new_cmdpos;\n// fix_end\n// fix_start\n    new_cmdpos = save_new_cmdpos;\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2175", "cve_desc": "Buffer Over-read in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 208525}
{"source": "// bug_start\nstatic RzList *relocs(RzBinFile *bf) {\n// bug_end\n \trz_return_val_if_fail(bf && bf->o, NULL);\n \tQnxObj *qo = bf->o->bin_obj;\n// bug_start\n\treturn rz_list_clone(qo->fixups);\n// bug_end\n }\n \n", "target": "// fix_start\nstatic RzList *maps(RzBinFile *bf) {\n// fix_end\n// fix_start\n\treturn rz_list_clone(qo->maps);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2022-36043", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free() when freeing relocations generated from qnx binary plugin. A user opening a malicious qnx binary could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784 contains a patch for this issue.", "project": "rizin", "idx": 208535}
{"source": " PHP_MINIT_FUNCTION(snmp)\n {\n \tnetsnmp_log_handler *logh;\n \tzend_class_entry ce, cex;\n \n \tle_snmp_session = zend_register_list_destructors_ex(php_snmp_session_destructor, NULL, PHP_SNMP_SESSION_RES_NAME, module_number);\n \n \tinit_snmp(\"snmpapp\");\n \n #ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE\n \tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PERSIST_STATE, 1);\n #endif\n \n \tshutdown_snmp_logging();\n \tlogh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_NONE, LOG_ERR);\n \tif (logh) {\n \t\tlogh->pri_max = LOG_ERR;\n \t}\n \n \tmemcpy(&php_snmp_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n \tphp_snmp_object_handlers.read_property = php_snmp_read_property;\n \tphp_snmp_object_handlers.write_property = php_snmp_write_property;\n \tphp_snmp_object_handlers.has_property = php_snmp_has_property;\n \tphp_snmp_object_handlers.get_properties = php_snmp_get_properties;\n// bug_start\n// bug_end\n \n \tINIT_CLASS_ENTRY(ce, \"SNMP\", php_snmp_class_methods);\n \tce.create_object = php_snmp_object_new;\n \tphp_snmp_object_handlers.clone_obj = NULL;\n \tphp_snmp_ce = zend_register_internal_class(&ce TSRMLS_CC);\n \n \tzend_hash_init(&php_snmp_properties, 0, NULL, NULL, 1);\n \tPHP_SNMP_ADD_PROPERTIES(&php_snmp_properties, php_snmp_property_entries);\n \n \tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_SUFFIX\",\tNETSNMP_OID_OUTPUT_SUFFIX,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_MODULE\",\tNETSNMP_OID_OUTPUT_MODULE,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_FULL\",\t\tNETSNMP_OID_OUTPUT_FULL,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NUMERIC\",\tNETSNMP_OID_OUTPUT_NUMERIC,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_UCD\",\t\tNETSNMP_OID_OUTPUT_UCD,\t\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OID_OUTPUT_NONE\",\t\tNETSNMP_OID_OUTPUT_NONE,\tCONST_CS | CONST_PERSISTENT);\n \n \tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_LIBRARY\",\tSNMP_VALUE_LIBRARY,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_PLAIN\",\tSNMP_VALUE_PLAIN,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_VALUE_OBJECT\",\tSNMP_VALUE_OBJECT,\tCONST_CS | CONST_PERSISTENT);\n \n \tREGISTER_LONG_CONSTANT(\"SNMP_BIT_STR\",\t\tASN_BIT_STR,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OCTET_STR\",\tASN_OCTET_STR,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OPAQUE\",\t\tASN_OPAQUE,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_NULL\",\t\tASN_NULL,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_OBJECT_ID\",\tASN_OBJECT_ID,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_IPADDRESS\",\tASN_IPADDRESS,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER\",\t\tASN_GAUGE,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_UNSIGNED\",\t\tASN_UNSIGNED,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_TIMETICKS\",\tASN_TIMETICKS,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_UINTEGER\",\t\tASN_UINTEGER,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_INTEGER\",\t\tASN_INTEGER,\tCONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"SNMP_COUNTER64\",\tASN_COUNTER64,\tCONST_CS | CONST_PERSISTENT);\n \n \tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_1\",\t\t\tSNMP_VERSION_1);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2c\",\t\t\tSNMP_VERSION_2c);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_2C\",\t\t\tSNMP_VERSION_2c);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"VERSION_3\",\t\t\tSNMP_VERSION_3);\n \n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_NOERROR\",\t\t\tPHP_SNMP_ERRNO_NOERROR);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ANY\",\t\t\tPHP_SNMP_ERRNO_ANY);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_GENERIC\",\t\t\tPHP_SNMP_ERRNO_GENERIC);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_TIMEOUT\",\t\t\tPHP_SNMP_ERRNO_TIMEOUT);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_ERROR_IN_REPLY\",\t\tPHP_SNMP_ERRNO_ERROR_IN_REPLY);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_NOT_INCREASING\",\tPHP_SNMP_ERRNO_OID_NOT_INCREASING);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_OID_PARSING_ERROR\",\tPHP_SNMP_ERRNO_OID_PARSING_ERROR);\n \tREGISTER_SNMP_CLASS_CONST_LONG(\"ERRNO_MULTIPLE_SET_QUERIES\",\tPHP_SNMP_ERRNO_MULTIPLE_SET_QUERIES);\n \n \tINIT_CLASS_ENTRY(cex, \"SNMPException\", NULL);\n #ifdef HAVE_SPL\n \tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, spl_ce_RuntimeException, NULL TSRMLS_CC);\n #else\n \tphp_snmp_exception_ce = zend_register_internal_class_ex(&cex, zend_exception_get_default(TSRMLS_C), NULL TSRMLS_CC);\n #endif\n \n \treturn SUCCESS;\n }\n \n", "target": "// fix_start\n\tphp_snmp_object_handlers.get_gc = php_snmp_get_gc;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2016-6295", "cve_desc": "ext/snmp/snmp.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 improperly interacts with the unserialize implementation and garbage collection, which allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact via crafted serialized data, a related issue to CVE-2016-5773.", "project": "php-src", "idx": 208654}
{"source": " R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n \tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n \tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n \tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n \tRAnalEsil *ESIL = core->anal->esil;\n \tut64 refptr = 0LL;\n// bug_start\n\tconst char *pcname;\n// bug_end\n \tRAnalOp op = R_EMPTY;\n \tut8 *buf = NULL;\n \tbool end_address_set = false;\n \tint iend;\n \tint minopsize = 4;\n \tbool archIsArm = false;\n \tut64 addr = core->offset;\n \tut64 start = addr;\n \tut64 end = 0LL;\n \tut64 cur;\n \tif (esil_anal_stop || r_cons_is_breaked ()) {\n \t\treturn;\n \t}\n \n \tmycore = core;\n \tif (!strcmp (str, \"?\")) {\n \t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n \t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n \t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n \t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n \t\treturn;\n \t}\n #define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n \tif (target) {\n \t\tconst char *expr = r_str_trim_head_ro (target);\n \t\tif (*expr) {\n \t\t\trefptr = ntarget = r_num_math (core->num, expr);\n \t\t\tif (!refptr) {\n \t\t\t\tntarget = refptr = addr;\n \t\t\t}\n \t\t} else {\n \t\t\tntarget = UT64_MAX;\n \t\t\trefptr = 0LL;\n \t\t}\n \t} else {\n \t\tntarget = UT64_MAX;\n \t\trefptr = 0LL;\n \t}\n \tRAnalFunction *fcn = NULL;\n \tif (!strcmp (str, \"f\")) {\n \t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n \t\tif (fcn) {\n \t\t\tstart = r_anal_function_min_addr (fcn);\n \t\t\taddr = fcn->addr;\n \t\t\tend = r_anal_function_max_addr (fcn);\n \t\t\tend_address_set = true;\n \t\t}\n \t}\n \n \tif (!end_address_set) {\n \t\tif (str[0] == ' ') {\n \t\t\tend = addr + r_num_math (core->num, str + 1);\n \t\t} else {\n \t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n \t\t\tif (map) {\n \t\t\t\tend = r_io_map_end (map);\n \t\t\t} else {\n \t\t\t\tend = addr + core->blocksize;\n \t\t\t}\n \t\t}\n \t}\n \n \tiend = end - start;\n \tif (iend < 0) {\n \t\treturn;\n \t}\n \tif (iend > MAX_SCAN_SIZE) {\n \t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n \t\treturn;\n \t}\n \tbuf = malloc ((size_t)iend + 2);\n \tif (!buf) {\n \t\tperror (\"malloc\");\n \t\treturn;\n \t}\n \tesilbreak_last_read = UT64_MAX;\n \tr_io_read_at (core->io, start, buf, iend + 1);\n \tif (!ESIL) {\n \t\tr_core_cmd0 (core, \"aei\");\n \t\tESIL = core->anal->esil;\n \t\tif (!ESIL) {\n \t\t\teprintf (\"ESIL not initialized\\n\");\n \t\t\treturn;\n \t\t}\n \t\tr_core_cmd0 (core, \"aeim\");\n \t\tESIL = core->anal->esil;\n \t}\n// bug_start\n\tconst char *spname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (!spname) {\n// bug_end\n \t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n \t\treturn;\n \t}\n// bug_start\n// bug_end\n \tEsilBreakCtx ctx = {\n \t\t&op,\n \t\tfcn,\n \t\tspname,\n \t\tr_reg_getv (core->anal->reg, spname)\n \t};\n \tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n \tESIL->user = &ctx;\n \tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n \tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n \n \tif (fcn && fcn->reg_save_area) {\n \t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n \t}\n// bug_start\n\tpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!pcname || !*pcname) {\n// bug_end\n \t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n \t\treturn;\n \t}\n// bug_start\n// bug_end\n \tesil_anal_stop = false;\n \tr_cons_break_push (cccb, core);\n \n \tint arch = -1;\n \tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n \t\tswitch (core->anal->cur->bits) {\n \t\tcase 64: arch = R2_ARCH_ARM64; break;\n \t\tcase 32: arch = R2_ARCH_ARM32; break;\n \t\tcase 16: arch = R2_ARCH_THUMB; break;\n \t\t}\n \t\tarchIsArm = true;\n \t}\n \n \tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n \tconst char *gp_reg = NULL;\n \tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n \t\tgp_reg = \"gp\";\n \t\tarch = R2_ARCH_MIPS;\n \t}\n \n \tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n \tif (!sn) {\n \t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n \t}\n \tr_reg_arena_push (core->anal->reg);\n \n \tIterCtx ictx = { start, end, fcn, NULL };\n \tsize_t i = addr - start;\n \tsize_t i_old = 0;\n \tdo {\n \t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n \t\t\tbreak;\n \t\t}\n \t\tcur = start + i;\n \t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n \t\t\tbreak;\n \t\t}\n #if 0\n \t\t{\n \t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n \t\t\tvoid **it;\n \t\t\tr_pvector_foreach (list, it) {\n \t\t\t\tRIntervalNode *node = *it;\n \t\t\t\tRAnalMetaItem *meta = node->data;\n \t\t\t\tswitch (meta->type) {\n \t\t\t\tcase R_META_TYPE_DATA:\n \t\t\t\tcase R_META_TYPE_STRING:\n \t\t\t\tcase R_META_TYPE_FORMAT:\n #if 0\n \t\t\t\t\t{\n \t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n \t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n \t\t\t\t\t}\n \t\t\t\t\tr_pvector_free (list);\n \t\t\t\t\tgoto loopback;\n #elif 0\n \t\t\t\t\t{\n \t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n \t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n \t\t\t\t\t\ti--;\n \t\t\t\t\t}\n #else\n \t\t\t\t\ti += 4;\n \t\t\t\t\tgoto repeat;\n #endif\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\tr_pvector_free (list);\n \t\t}\n #endif\n \n \t\tr_core_seek_arch_bits (core, cur);\n \t\tint opalign = core->anal->pcalign;\n \t\tif (opalign > 0) {\n \t\t\tcur -= (cur % opalign);\n \t\t}\n \n \t\tr_anal_op_fini (&op);\n \t\tr_asm_set_pc (core->rasm, cur);\n \t\ti_old = i;\n// bug_start\n#if 1\n// bug_end\n \t\tif (i > iend) {\n \t\t\tgoto repeat;\n \t\t}\n// bug_start\n#endif\n// bug_end\n \t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n \t\t\ti += minopsize - 1;\n \t\t}\n \t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n \t\t\tr_anal_op_fini (&op);\n \t\t\tgoto repeat;\n \t\t}\n \t\tif (op.size < 1) {\n \t\t\ti += minopsize - 1;\n \t\t\tgoto repeat;\n \t\t}\n \t\tif (emu_lazy) {\n \t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n \t\t\t\ti += op.size - 1;\n \t\t\t\tgoto repeat;\n \t\t\t}\n \t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n \t\t\tcase R_ANAL_OP_TYPE_JMP:\n \t\t\tcase R_ANAL_OP_TYPE_CJMP:\n \t\t\tcase R_ANAL_OP_TYPE_CALL:\n \t\t\tcase R_ANAL_OP_TYPE_RET:\n \t\t\tcase R_ANAL_OP_TYPE_ILL:\n \t\t\tcase R_ANAL_OP_TYPE_NOP:\n \t\t\tcase R_ANAL_OP_TYPE_UJMP:\n \t\t\tcase R_ANAL_OP_TYPE_IO:\n \t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n \t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n \t\t\tcase R_ANAL_OP_TYPE_CPL:\n \t\t\tcase R_ANAL_OP_TYPE_SYNC:\n \t\t\tcase R_ANAL_OP_TYPE_SWI:\n \t\t\tcase R_ANAL_OP_TYPE_CMP:\n \t\t\tcase R_ANAL_OP_TYPE_ACMP:\n \t\t\tcase R_ANAL_OP_TYPE_NULL:\n \t\t\tcase R_ANAL_OP_TYPE_CSWI:\n \t\t\tcase R_ANAL_OP_TYPE_TRAP:\n \t\t\t\ti += op.size - 1;\n \t\t\t\tgoto repeat;\n \t\t\tcase R_ANAL_OP_TYPE_PUSH:\n \t\t\tcase R_ANAL_OP_TYPE_POP:\n \t\t\t\ti += op.size - 1;\n \t\t\t\tgoto repeat;\n \t\t\t}\n \t\t}\n \t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n \t\t\tr_strf_buffer (64);\n \t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n \t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n \t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n \t\t\tif (si) {\n \t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n \t\t\t} else {\n \t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n \t\t\t}\n \t\t\tr_flag_space_set (core->flags, NULL);\n \t\t\tr_syscall_item_free (si);\n \t\t}\n \t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n \t\ti += op.size - 1;\n \t\tif (R_STR_ISEMPTY (esilstr)) {\n \t\t\tgoto repeat;\n \t\t}\n \t\tr_anal_esil_set_pc (ESIL, cur);\n \t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n \t\tif (gp_fixed && gp_reg) {\n \t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n \t\t}\n \t\t(void)r_anal_esil_parse (ESIL, esilstr);\n \t\tswitch (op.type) {\n \t\tcase R_ANAL_OP_TYPE_LEA:\n \t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n \t\t\t\tif (CHECKREF (ESIL->cur)) {\n \t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n \t\t\t\t}\n \t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n \t\t\t\tif (CHECKREF (ESIL->cur)) {\n \t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (cfg_anal_strings) {\n \t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase R_ANAL_OP_TYPE_ADD:\n \t\t\tif (core->anal->cur && archIsArm) {\n \t\t\t\tut64 dst = ESIL->cur;\n \t\t\t\tif ((target && dst == ntarget) || !target) {\n \t\t\t\t\tif (CHECKREF (dst)) {\n \t\t\t\t\t\tint type = core_type_by_addr (core, dst);\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (cfg_anal_strings) {\n \t\t\t\t\tadd_string_ref (core, op.addr, dst);\n \t\t\t\t}\n \t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n \t\t\t\tut64 dst = ESIL->cur;\n \t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif ((target && dst == ntarget) || !target) {\n \t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n \t\t\t\t\t\tRFlagItem *f;\n \t\t\t\t\t\tchar *str;\n \t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n \t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n \t\t\t\t\t\t\tif (cfg_anal_strings) {\n \t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n \t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n \t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n \t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n \t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n \t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n \t\t\t\t\t\t\t\tfree (str2);\n \t\t\t\t\t\t\t\tfree (str);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\tcase R_ANAL_OP_TYPE_LOAD:\n \t\t\t{\n \t\t\t\tut64 dst = esilbreak_last_read;\n \t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n \t\t\t\t\tif (myvalid (mycore->io, dst)) {\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n \t\t\t\t\t\tif (cfg_anal_strings) {\n \t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tdst = esilbreak_last_data;\n \t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n \t\t\t\t\tif (myvalid (mycore->io, dst)) {\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n \t\t\t\t\t\tif (cfg_anal_strings) {\n \t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\tcase R_ANAL_OP_TYPE_JMP:\n \t\t\t{\n \t\t\t\tut64 dst = op.jump;\n \t\t\t\tif (CHECKREF (dst)) {\n \t\t\t\t\tif (myvalid (core->io, dst)) {\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\tcase R_ANAL_OP_TYPE_CALL:\n \t\t\t{\n \t\t\t\tut64 dst = op.jump;\n \t\t\t\tif (CHECKREF (dst)) {\n \t\t\t\t\tif (myvalid (core->io, dst)) {\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n \t\t\t\t\t}\n \t\t\t\t\tESIL->old = cur + op.size;\n \t\t\t\t\tgetpcfromstack (core, ESIL);\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\tcase R_ANAL_OP_TYPE_UJMP:\n \t\tcase R_ANAL_OP_TYPE_UCALL:\n \t\tcase R_ANAL_OP_TYPE_ICALL:\n \t\tcase R_ANAL_OP_TYPE_RCALL:\n \t\tcase R_ANAL_OP_TYPE_IRCALL:\n \t\tcase R_ANAL_OP_TYPE_MJMP:\n \t\t\t{\n \t\t\t\tut64 dst = core->anal->esil->jump_target;\n \t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n \t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n \t\t\t\t}\n \t\t\t\tif (CHECKREF (dst)) {\n \t\t\t\t\tif (myvalid (core->io, dst)) {\n \t\t\t\t\t\tRAnalRefType ref =\n \t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n \t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n \t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n \t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n \t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n #if 0\n \t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n \t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n \t\t\t\t\t\t}\n #endif\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tbreak;\n \t\t}\n \t\tr_anal_esil_stack_free (ESIL);\n repeat:\n \t\tif (!r_anal_get_block_at (core->anal, cur)) {\n \t\t\tsize_t fcn_i;\n \t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n \t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n \t\t\t\t\ti = fcn_i - 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (i >= iend) {\n \t\t\tbreak;\n \t\t}\n \t} while (get_next_i (&ictx, &i));\n// bug_start\n// bug_end\n \tr_list_free (ictx.bbl);\n \tr_list_free (ictx.path);\n \tr_list_free (ictx.switch_path);\n \tfree (buf);\n \tESIL->cb.hook_mem_read = NULL;\n \tESIL->cb.hook_mem_write = NULL;\n \tESIL->cb.hook_reg_write = NULL;\n \tESIL->user = NULL;\n \tr_anal_op_fini (&op);\n \tr_cons_break_pop ();\n \tr_reg_arena_pop (core->anal->reg);\n }\n \n", "target": "// fix_start\n\tchar *pcname = NULL;\n// fix_end\n// fix_start\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n// fix_end\n// fix_start\n\tchar *spname = strdup (kspname);\n// fix_end\n// fix_start\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n// fix_end\n// fix_start\n\tpcname = strdup (kpcname);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\tfree (pcname);\n\tfree (spname);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-0849", "cve_desc": "Use After Free in r_reg_get_name_idx in GitHub repository radareorg/radare2 prior to 5.6.6.", "project": "radare2", "idx": 208680}
{"source": " getcmdline_int(\n     int\t\tfirstc,\n     long\tcount UNUSED,\n     int\t\tindent,\n     int\t\tclear_ccline)\n {\n     static int\tdepth = 0;\n     int\t\tc;\n     int\t\ti;\n     int\t\tj;\n     int\t\tgotesc = FALSE;\n     int\t\tdo_abbr;\n     char_u\t*lookfor = NULL;\n     int\t\thiscnt;\n     int\t\thistype;\n #ifdef FEAT_SEARCH_EXTRA\n     incsearch_state_T\tis_state;\n #endif\n     int\t\tdid_wild_list = FALSE;\n     int\t\twim_index = 0;\n     int\t\tres;\n     int\t\tsave_msg_scroll = msg_scroll;\n     int\t\tsave_State = State;\n     int\t\tsome_key_typed = FALSE;\n     int\t\tignore_drag_release = TRUE;\n #ifdef FEAT_EVAL\n     int\t\tbreak_ctrl_c = FALSE;\n #endif\n     expand_T\txpc;\n     long\t*b_im_ptr = NULL;\n// bug_start\n// bug_end\n     cmdline_info_T save_ccline;\n     int\t\tdid_save_ccline = FALSE;\n     int\t\tcmdline_type;\n     int\t\twild_type;\n \n     ++depth;\n \n     if (ccline.cmdbuff != NULL)\n     {\n \tsave_cmdline(&save_ccline);\n \tdid_save_ccline = TRUE;\n     }\n     if (clear_ccline)\n \tCLEAR_FIELD(ccline);\n \n #ifdef FEAT_EVAL\n     if (firstc == -1)\n     {\n \tfirstc = NUL;\n \tbreak_ctrl_c = TRUE;\n     }\n #endif\n #ifdef FEAT_RIGHTLEFT\n     if (firstc == ':' || firstc == '=' || firstc == '>')\n \tcmd_hkmap = 0;\n #endif\n \n #ifdef FEAT_SEARCH_EXTRA\n     init_incsearch_state(&is_state);\n #endif\n \n     if (init_ccline(firstc, indent) != OK)\n \tgoto theend;\n \n     if (depth == 50)\n     {\n \temsg(_(e_command_too_recursive));\n \tgoto theend;\n     }\n \n     ExpandInit(&xpc);\n     ccline.xpc = &xpc;\n \n #ifdef FEAT_RIGHTLEFT\n     if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n \t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n \tcmdmsg_rl = TRUE;\n     else\n \tcmdmsg_rl = FALSE;\n #endif\n \n     redir_off = TRUE;\n     if (!cmd_silent)\n     {\n \ti = msg_scrolled;\n \tmsg_scrolled = 0;\n \tgotocmdline(TRUE);\n \tmsg_scrolled += i;\n \tredrawcmdprompt();\n \tset_cmdspos();\n     }\n     xpc.xp_context = EXPAND_NOTHING;\n     xpc.xp_backslash = XP_BS_NONE;\n #ifndef BACKSLASH_IN_FILENAME\n     xpc.xp_shell = FALSE;\n #endif\n \n #if defined(FEAT_EVAL)\n     if (ccline.input_fn)\n     {\n \txpc.xp_context = ccline.xp_context;\n \txpc.xp_pattern = ccline.cmdbuff;\n \txpc.xp_arg = ccline.xp_arg;\n     }\n #endif\n \n     msg_scroll = FALSE;\n \n     State = MODE_CMDLINE;\n \n     if (firstc == '/' || firstc == '?' || firstc == '@')\n     {\n \tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n \t    b_im_ptr = &curbuf->b_p_iminsert;\n \telse\n \t    b_im_ptr = &curbuf->b_p_imsearch;\n// bug_start\n// bug_end\n \tif (*b_im_ptr == B_IMODE_LMAP)\n \t    State |= MODE_LANGMAP;\n #ifdef HAVE_INPUT_METHOD\n \tim_set_active(*b_im_ptr == B_IMODE_IM);\n #endif\n     }\n #ifdef HAVE_INPUT_METHOD\n     else if (p_imcmdline)\n \tim_set_active(TRUE);\n #endif\n \n     setmouse();\n #ifdef CURSOR_SHAPE\n     ui_cursor_shape();\n #endif\n \n     settmode(TMODE_RAW);\n \n     cmdline_type = firstc == NUL ? '-' : firstc;\n     trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n #ifdef FEAT_EVAL\n     if (!debug_mode)\n \tmay_trigger_modechanged();\n #endif\n \n     init_history();\n     hiscnt = get_hislen();\n     histype = hist_char2type(firstc);\n \n #ifdef FEAT_DIGRAPHS\n     do_digraph(-1);\n #endif\n \n     if (did_emsg)\n \tredrawcmd();\n \n #ifdef FEAT_STL_OPT\n     if (!cmd_silent && msg_scrolled == 0)\n     {\n \tint\tfound_one = FALSE;\n \twin_T\t*wp;\n \n \tFOR_ALL_WINDOWS(wp)\n \t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n \t    {\n \t\twp->w_redr_status = TRUE;\n \t\tfound_one = TRUE;\n \t    }\n \n \tif (*p_tal != NUL)\n \t{\n \t    redraw_tabline = TRUE;\n \t    found_one = TRUE;\n \t}\n \n \tif (found_one)\n \t    redraw_statuslines();\n     }\n #endif\n \n     did_emsg = FALSE;\n     got_int = FALSE;\n \n     for (;;)\n     {\n \tint trigger_cmdlinechanged = TRUE;\n \tint end_wildmenu;\n \n \tredir_off = TRUE;\n #ifdef USE_ON_FLY_SCROLL\n \tdont_scroll = FALSE;\n #endif\n \tquit_more = FALSE;\n \n \tdid_emsg = FALSE;\n \n \tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n \n \tdo\n \t{\n \t    cursorcmd();\n \t    c = safe_vgetc();\n \t} while (c == K_IGNORE || c == K_NOP);\n \n \tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n \t{\n \t    int\t    clen = ccline.cmdlen;\n \n \t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n \t    {\n \t\tif (clen == ccline.cmdlen)\n \t\t    trigger_cmdlinechanged = FALSE;\n \t\tgoto cmdline_changed;\n \t    }\n \t}\n \n \tif (KeyTyped)\n \t{\n \t    some_key_typed = TRUE;\n #ifdef FEAT_RIGHTLEFT\n \t    if (cmd_hkmap)\n \t\tc = hkmap(c);\n \t    if (cmdmsg_rl && !KeyStuffed)\n \t    {\n \t\tswitch (c)\n \t\t{\n \t\t    case K_RIGHT:   c = K_LEFT; break;\n \t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n \t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n \t\t    case K_LEFT:    c = K_RIGHT; break;\n \t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n \t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n \t\t}\n \t    }\n #endif\n \t}\n \n \tif ((c == Ctrl_C\n #ifdef UNIX\n \t\t|| c == intr_char\n #endif\n \t\t\t\t)\n #if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n \t\t&& firstc != '@'\n #endif\n #ifdef FEAT_EVAL\n \t\t&& (!break_ctrl_c || exmode_active)\n #endif\n \t\t&& !global_busy)\n \t    got_int = FALSE;\n \n \tif (lookfor != NULL\n \t\t&& c != K_S_DOWN && c != K_S_UP\n \t\t&& c != K_DOWN && c != K_UP\n \t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n \t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n \t\t&& c != K_LEFT && c != K_RIGHT\n \t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n \t    VIM_CLEAR(lookfor);\n \n \tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n \t    c = Ctrl_P;\n \n \tif (p_wmnu)\n \t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n \n \tif (cmdline_pum_active())\n \t{\n \t    if (c == Ctrl_E || c == Ctrl_Y)\n \t    {\n \t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n \t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n \t\t\t\t\t\t\tfirstc != '@') == FAIL)\n \t\t    break;\n \t\tc = Ctrl_E;\n \t    }\n \t}\n \n \tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n \t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n \tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n \t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n \t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n \n \tif (end_wildmenu)\n \t{\n \t    if (cmdline_pum_active())\n \t\tcmdline_pum_remove();\n \t    if (xpc.xp_numfiles != -1)\n \t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n \t    did_wild_list = FALSE;\n \t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n \t\txpc.xp_context = EXPAND_NOTHING;\n \t    wim_index = 0;\n \t    wildmenu_cleanup(&ccline);\n \t}\n \n \tif (p_wmnu)\n \t    c = wildmenu_process_key(&ccline, c, &xpc);\n \n \tif (c == Ctrl_BSL)\n \t{\n \t    res = cmdline_handle_backslash_key(c, &gotesc);\n \t    if (res == CMDLINE_CHANGED)\n \t\tgoto cmdline_changed;\n \t    else if (res == CMDLINE_NOT_CHANGED)\n \t\tgoto cmdline_not_changed;\n \t    else if (res == GOTO_NORMAL_MODE)\n \t\tgoto returncmd;\n \t    c = Ctrl_BSL;\n \t}\n \n #ifdef FEAT_CMDWIN\n \tif (c == cedit_key || c == K_CMDWIN)\n \t{\n \t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n \t    {\n \t\tc = open_cmdwin();\n \t\tsome_key_typed = TRUE;\n \t    }\n \t}\n # ifdef FEAT_DIGRAPHS\n \telse\n # endif\n #endif\n #ifdef FEAT_DIGRAPHS\n \t    c = do_digraph(c);\n #endif\n \n \tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n \t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n \t{\n \t    if (exmode_active\n \t\t    && c != ESC\n \t\t    && ccline.cmdpos == ccline.cmdlen\n \t\t    && ccline.cmdpos > 0\n \t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n \t    {\n \t\tif (c == K_KENTER)\n \t\t    c = '\\n';\n \t    }\n \t    else\n \t    {\n \t\tgotesc = FALSE;\n \t\tif (ccheck_abbr(c + ABBR_OFF))\n \t\t    goto cmdline_changed;\n \t\tif (!cmd_silent)\n \t\t{\n \t\t    windgoto(msg_row, 0);\n \t\t    out_flush();\n \t\t}\n \t\tbreak;\n \t    }\n \t}\n \n \tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n \t{\n \t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n \t\t    &wim_index, &xpc, &gotesc);\n \t    if (res == CMDLINE_CHANGED)\n \t\tgoto cmdline_changed;\n \t}\n \n \tgotesc = FALSE;\n \n \tif (c == K_S_TAB && KeyTyped)\n \t{\n \t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n \t    {\n \t\tif (xpc.xp_numfiles > 1\n \t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n \t\t\t    || p_wmnu))\n \t\t{\n \t\t    showmatches(&xpc, p_wmnu\n \t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n \t\t}\n \t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n \t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n \t\t    goto cmdline_changed;\n \t    }\n \t}\n \n \tif (c == NUL || c == K_ZERO)\n \t    c = NL;\n \n \tdo_abbr = TRUE;\n \n \tswitch (c)\n \t{\n \tcase K_BS:\n \tcase Ctrl_H:\n \tcase K_DEL:\n \tcase K_KDEL:\n \tcase Ctrl_W:\n \t    res = cmdline_erase_chars(c, indent\n #ifdef FEAT_SEARCH_EXTRA\n \t\t    , &is_state\n #endif\n \t\t    );\n \t    if (res == CMDLINE_NOT_CHANGED)\n \t\tgoto cmdline_not_changed;\n \t    else if (res == GOTO_NORMAL_MODE)\n \t\tgoto returncmd;\n \t    goto cmdline_changed;\n \n \tcase K_INS:\n \tcase K_KINS:\n \t\tccline.overstrike = !ccline.overstrike;\n #ifdef CURSOR_SHAPE\n \t\tui_cursor_shape();\n #endif\n \t\tgoto cmdline_not_changed;\n \n \tcase Ctrl_HAT:\n// bug_start\n\t\tcmdline_toggle_langmap(b_im_ptr);\n// bug_end\n \t\tgoto cmdline_not_changed;\n \n \tcase Ctrl_U:\n \t\tj = ccline.cmdpos;\n \t\tccline.cmdlen -= j;\n \t\ti = ccline.cmdpos = 0;\n \t\twhile (i < ccline.cmdlen)\n \t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n \t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n #ifdef FEAT_SEARCH_EXTRA\n \t\tif (ccline.cmdlen == 0)\n \t\t    is_state.search_start = is_state.save_cursor;\n #endif\n \t\tredrawcmd();\n \t\tgoto cmdline_changed;\n \n #ifdef FEAT_CLIPBOARD\n \tcase Ctrl_Y:\n \t\tif (clip_star.state != SELECT_CLEARED)\n \t\t{\n \t\t    if (clip_star.state == SELECT_DONE)\n \t\t\tclip_copy_modeless_selection(TRUE);\n \t\t    goto cmdline_not_changed;\n \t\t}\n \t\tbreak;\n #endif\n \n \tcase ESC:\n \tcase Ctrl_C:\n \t\tif (exmode_active\n \t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n \t\t    goto cmdline_not_changed;\n \n \t\tgotesc = TRUE;\n \t\tgoto returncmd;\n \n \tcase Ctrl_R:\n \t\tres = cmdline_insert_reg(&gotesc);\n \t\tif (res == CMDLINE_NOT_CHANGED)\n \t\t    goto cmdline_not_changed;\n \t\telse if (res == GOTO_NORMAL_MODE)\n \t\t    goto returncmd;\n \t\tgoto cmdline_changed;\n \n \tcase Ctrl_D:\n \t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n \t\t    break;\n \n \t\tredrawcmd();\n \t\tcontinue;\n \n \tcase K_RIGHT:\n \tcase K_S_RIGHT:\n \tcase K_C_RIGHT:\n \t\tdo\n \t\t{\n \t\t    if (ccline.cmdpos >= ccline.cmdlen)\n \t\t\tbreak;\n \t\t    i = cmdline_charsize(ccline.cmdpos);\n \t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n \t\t\tbreak;\n \t\t    ccline.cmdspos += i;\n \t\t    if (has_mbyte)\n \t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n \t\t\t\t\t\t\t     + ccline.cmdpos);\n \t\t    else\n \t\t\t++ccline.cmdpos;\n \t\t}\n \t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n \t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n \t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n \t\tif (has_mbyte)\n \t\t    set_cmdspos_cursor();\n \t\tgoto cmdline_not_changed;\n \n \tcase K_LEFT:\n \tcase K_S_LEFT:\n \tcase K_C_LEFT:\n \t\tif (ccline.cmdpos == 0)\n \t\t    goto cmdline_not_changed;\n \t\tdo\n \t\t{\n \t\t    --ccline.cmdpos;\n \t\t    if (has_mbyte)\n \t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n \t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n \t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n \t\t}\n \t\twhile (ccline.cmdpos > 0\n \t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n \t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n \t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n \t\tif (has_mbyte)\n \t\t    set_cmdspos_cursor();\n \t\tgoto cmdline_not_changed;\n \n \tcase K_IGNORE:\n \t\tgoto cmdline_not_changed;\n \n #ifdef FEAT_GUI_MSWIN\n \tcase K_F4:\n \t    if (mod_mask == MOD_MASK_ALT)\n \t    {\n \t\tredrawcmd();\n \t\tgoto cmdline_not_changed;\n \t    }\n \t    break;\n #endif\n \n \tcase K_MIDDLEDRAG:\n \tcase K_MIDDLERELEASE:\n \t\tgoto cmdline_not_changed;\n \n \tcase K_MIDDLEMOUSE:\n # ifdef FEAT_GUI\n \t\tif (!gui.in_use)\n # endif\n \t\t    if (!mouse_has(MOUSE_COMMAND))\n \t\t\tgoto cmdline_not_changed;\n # ifdef FEAT_CLIPBOARD\n \t\tif (clip_star.available)\n \t\t    cmdline_paste('*', TRUE, TRUE);\n \t\telse\n # endif\n \t\t    cmdline_paste(0, TRUE, TRUE);\n \t\tredrawcmd();\n \t\tgoto cmdline_changed;\n \n # ifdef FEAT_DND\n \tcase K_DROP:\n \t\tcmdline_paste('~', TRUE, FALSE);\n \t\tredrawcmd();\n \t\tgoto cmdline_changed;\n # endif\n \n \tcase K_LEFTDRAG:\n \tcase K_LEFTRELEASE:\n \tcase K_RIGHTDRAG:\n \tcase K_RIGHTRELEASE:\n \t\tif (ignore_drag_release)\n \t\t    goto cmdline_not_changed;\n \tcase K_LEFTMOUSE:\n \tcase K_RIGHTMOUSE:\n \t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n \t\tgoto cmdline_not_changed;\n \n \tcase K_MOUSEDOWN:\n \tcase K_MOUSEUP:\n \tcase K_MOUSELEFT:\n \tcase K_MOUSERIGHT:\n \tcase K_X1MOUSE:\n \tcase K_X1DRAG:\n \tcase K_X1RELEASE:\n \tcase K_X2MOUSE:\n \tcase K_X2DRAG:\n \tcase K_X2RELEASE:\n \tcase K_MOUSEMOVE:\n \t\tgoto cmdline_not_changed;\n \n #ifdef FEAT_GUI\n \tcase K_LEFTMOUSE_NM:\n \tcase K_LEFTRELEASE_NM:\n \t\tgoto cmdline_not_changed;\n \n \tcase K_VER_SCROLLBAR:\n \t\tif (msg_scrolled == 0)\n \t\t{\n \t\t    gui_do_scroll();\n \t\t    redrawcmd();\n \t\t}\n \t\tgoto cmdline_not_changed;\n \n \tcase K_HOR_SCROLLBAR:\n \t\tif (msg_scrolled == 0)\n \t\t{\n \t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n \t\t    redrawcmd();\n \t\t}\n \t\tgoto cmdline_not_changed;\n #endif\n #ifdef FEAT_GUI_TABLINE\n \tcase K_TABLINE:\n \tcase K_TABMENU:\n \t\tif (gui_use_tabline())\n \t\t    gui_mch_set_curtab(tabpage_index(curtab));\n \t\tgoto cmdline_not_changed;\n #endif\n \n \tcase K_SELECT:\n \t\tgoto cmdline_not_changed;\n \n \tcase Ctrl_B:\n \tcase K_HOME:\n \tcase K_KHOME:\n \tcase K_S_HOME:\n \tcase K_C_HOME:\n \t\tccline.cmdpos = 0;\n \t\tset_cmdspos();\n \t\tgoto cmdline_not_changed;\n \n \tcase Ctrl_E:\n \tcase K_END:\n \tcase K_KEND:\n \tcase K_S_END:\n \tcase K_C_END:\n \t\tccline.cmdpos = ccline.cmdlen;\n \t\tset_cmdspos_cursor();\n \t\tgoto cmdline_not_changed;\n \n \tcase Ctrl_A:\n \t\tif (cmdline_pum_active())\n \t\t    cmdline_pum_cleanup(&ccline);\n \n \t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n \t\t    break;\n \t\txpc.xp_context = EXPAND_NOTHING;\n \t\tdid_wild_list = FALSE;\n \t\tgoto cmdline_changed;\n \n \tcase Ctrl_L:\n #ifdef FEAT_SEARCH_EXTRA\n \t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n \t\t    goto cmdline_not_changed;\n #endif\n \n \t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n \t\t    break;\n \t\tgoto cmdline_changed;\n \n \tcase Ctrl_N:\n \tcase Ctrl_P:\n \t\tif (xpc.xp_numfiles > 0)\n \t\t{\n \t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n \t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n \t\t\tbreak;\n \t\t    goto cmdline_not_changed;\n \t\t}\n \tcase K_UP:\n \tcase K_DOWN:\n \tcase K_S_UP:\n \tcase K_S_DOWN:\n \tcase K_PAGEUP:\n \tcase K_KPAGEUP:\n \tcase K_PAGEDOWN:\n \tcase K_KPAGEDOWN:\n \t\tif (cmdline_pum_active()\n \t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n \t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n \t\t{\n \t\t    wild_type = WILD_PAGEUP;\n \t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n \t\t\twild_type = WILD_PAGEDOWN;\n \t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n \t\t\tbreak;\n \t\t    goto cmdline_not_changed;\n \t\t}\n \t\telse\n \t\t{\n \t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n \t\t\t    &hiscnt, &xpc);\n \t\t    if (res == CMDLINE_CHANGED)\n \t\t\tgoto cmdline_changed;\n \t\t    else if (res == GOTO_NORMAL_MODE)\n \t\t\tgoto returncmd;\n \t\t}\n \t\tgoto cmdline_not_changed;\n \n #ifdef FEAT_SEARCH_EXTRA\n \tcase Ctrl_G:\n \tcase Ctrl_T:\n \t\tif (may_adjust_incsearch_highlighting(\n \t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n \t\t    goto cmdline_not_changed;\n \t\tbreak;\n #endif\n \n \tcase Ctrl_V:\n \tcase Ctrl_Q:\n \t\t{\n \t\t    ignore_drag_release = TRUE;\n \t\t    putcmdline('^', TRUE);\n \n \t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n \n \t\t    do_abbr = FALSE;\n \t\t    extra_char = NUL;\n \t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n \t\t    {\n \t\t\tdraw_cmdline(ccline.cmdpos,\n \t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n \t\t\tmsg_putchar(' ');\n \t\t\tcursorcmd();\n \t\t    }\n \t\t}\n \n \t\tbreak;\n \n #ifdef FEAT_DIGRAPHS\n \tcase Ctrl_K:\n \t\tignore_drag_release = TRUE;\n \t\tputcmdline('?', TRUE);\n # ifdef USE_ON_FLY_SCROLL\n \t\tdont_scroll = TRUE;\n # endif\n \t\tc = get_digraph(TRUE);\n \t\textra_char = NUL;\n \t\tif (c != NUL)\n \t\t    break;\n \n \t\tredrawcmd();\n \t\tgoto cmdline_not_changed;\n #endif\n \n #ifdef FEAT_RIGHTLEFT\n \tcase Ctrl__:\n \t\tif (!p_ari)\n \t\t    break;\n \t\tcmd_hkmap = !cmd_hkmap;\n \t\tgoto cmdline_not_changed;\n #endif\n \n \tcase K_PS:\n \t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n \t\tgoto cmdline_changed;\n \n \tdefault:\n #ifdef UNIX\n \t\tif (c == intr_char)\n \t\t{\n \t\t    gotesc = TRUE;\n \t\t    goto returncmd;\n \t\t}\n #endif\n \t\tif (!IS_SPECIAL(c))\n \t\t    mod_mask = 0x0;\n \t\tbreak;\n \t}\n \n \tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n \t\t&& (ccheck_abbr(\n \t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n \t\t    || c == Ctrl_RSB))\n \t    goto cmdline_changed;\n \n \tif (IS_SPECIAL(c) || mod_mask != 0)\n \t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n \telse\n \t{\n \t    if (has_mbyte)\n \t    {\n \t\tj = (*mb_char2bytes)(c, IObuff);\n \t\tIObuff[j] = NUL;\n \t\tput_on_cmdline(IObuff, j, TRUE);\n \t    }\n \t    else\n \t    {\n \t\tIObuff[0] = c;\n \t\tput_on_cmdline(IObuff, 1, TRUE);\n \t    }\n \t}\n \tgoto cmdline_changed;\n \n cmdline_not_changed:\n #ifdef FEAT_SEARCH_EXTRA\n \tif (!is_state.incsearch_postponed)\n \t    continue;\n #endif\n \n cmdline_changed:\n #ifdef FEAT_SEARCH_EXTRA\n \tif (is_state.winid != curwin->w_id)\n \t    init_incsearch_state(&is_state);\n #endif\n \tif (trigger_cmdlinechanged)\n \t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n \n #ifdef FEAT_SEARCH_EXTRA\n \tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n \t    may_do_incsearch_highlighting(firstc, count, &is_state);\n #endif\n \n #ifdef FEAT_RIGHTLEFT\n \tif (cmdmsg_rl\n # ifdef FEAT_ARABIC\n \t\t|| (p_arshape && !p_tbidi\n \t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n # endif\n \t\t)\n \t    if (vpeekc() == NUL)\n \t\tredrawcmd();\n #endif\n     }\n \n returncmd:\n \n #ifdef FEAT_RIGHTLEFT\n     cmdmsg_rl = FALSE;\n #endif\n \n     ExpandCleanup(&xpc);\n     ccline.xpc = NULL;\n \n #ifdef FEAT_SEARCH_EXTRA\n     finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n #endif\n \n     if (ccline.cmdbuff != NULL)\n     {\n \tif (ccline.cmdlen && firstc != NUL\n \t\t&& (some_key_typed || histype == HIST_SEARCH))\n \t{\n \t    add_to_history(histype, ccline.cmdbuff, TRUE,\n \t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n \t    if (firstc == ':')\n \t    {\n \t\tvim_free(new_last_cmdline);\n \t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n \t    }\n \t}\n \n \tif (gotesc)\n \t    abandon_cmdline();\n     }\n \n     msg_check();\n     msg_scroll = save_msg_scroll;\n     redir_off = FALSE;\n \n     if (some_key_typed)\n \tneed_wait_return = FALSE;\n \n     trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n \n     State = save_State;\n \n #ifdef FEAT_EVAL\n     if (!debug_mode)\n \tmay_trigger_modechanged();\n #endif\n \n #ifdef HAVE_INPUT_METHOD\n// bug_start\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n// bug_end\n \tim_save_status(b_im_ptr);\n     im_set_active(FALSE);\n #endif\n     setmouse();\n #ifdef CURSOR_SHAPE\n     ui_cursor_shape();\n #endif\n     sb_text_end_cmdline();\n \n theend:\n     {\n \tchar_u *p = ccline.cmdbuff;\n \n \t--depth;\n \tif (did_save_ccline)\n \t    restore_cmdline(&save_ccline);\n \telse\n \t    ccline.cmdbuff = NULL;\n \treturn p;\n     }\n }\n \n", "target": "// fix_start\n    buf_T\t*b_im_ptr_buf = NULL;\n// fix_end\n// fix_start\n\tb_im_ptr_buf = curbuf;\n// fix_end\n// fix_start\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n// fix_end\n// fix_start\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-3235", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0490.", "project": "vim", "idx": 208912}
{"source": " PlayerGeneric::~PlayerGeneric()\n {\n// bug_start\n\tif (mixer)\n\t\tdelete mixer;\n// bug_end\n \n \tif (player)\n \t{\n// bug_start\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n// bug_end\n \t\t\tmixer->removeDevice(player);\n \t\tdelete player;\n \t}\n// bug_start\n// bug_end\n \n \tdelete[] audioDriverName;\n \n \tdelete listener;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t\tif (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))\n// fix_end\n// fix_start\n\n\tif (mixer)\n\t\tdelete mixer;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-15569", "cve_desc": "PlayerGeneric.cpp in MilkyTracker through 1.02.00 has a use-after-free in the PlayerGeneric destructor.", "project": "MilkyTracker", "idx": 208987}
{"source": " virNodeDeviceGetMdevTypesCaps(const char *sysfspath,\n                               virMediatedDeviceTypePtr **mdev_types,\n                               size_t *nmdev_types)\n {\n     virMediatedDeviceTypePtr *types = NULL;\n     size_t ntypes = 0;\n     size_t i;\n \n     for (i = 0; i < *nmdev_types; i++)\n// bug_start\n       virMediatedDeviceTypeFree(*mdev_types[i]);\n// bug_end\n     VIR_FREE(*mdev_types);\n     *nmdev_types = 0;\n \n     if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)\n         return -1;\n \n     *mdev_types = g_steal_pointer(&types);\n     *nmdev_types = ntypes;\n \n     return 0;\n }\n \n", "target": "// fix_start\n       virMediatedDeviceTypeFree((*mdev_types)[i]);\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2021-3559", "cve_desc": "A flaw was found in libvirt in the virConnectListAllNodeDevices API in versions before 7.0.0. It only affects hosts with a PCI device and driver that supports mediated devices (e.g., GRID driver). This flaw could be used by an unprivileged client with a read-only connection to crash the libvirt daemon by executing the 'nodedev-list' virsh command. The highest threat from this vulnerability is to system availability.", "project": "libvirt", "idx": 209026}
{"source": " do_mouse(\n     oparg_T\t*oap,\n     int\t\tc,\n     int\t\tdir,\n     long\tcount,\n     int\t\tfixindent)\n {\n     static int\tdo_always = FALSE;\n     static int\tgot_click = FALSE;\n \n     int\t\twhich_button;\n     int\t\tis_click = FALSE;\n     int\t\tis_drag = FALSE;\n     int\t\tjump_flags = 0;\n     pos_T\tstart_visual;\n     int\t\tmoved;\n     int\t\tin_status_line;\n     static int\tin_tab_line = FALSE;\n     int\t\tin_sep_line;\n     int\t\tc1, c2;\n #if defined(FEAT_FOLDING)\n     pos_T\tsave_cursor;\n #endif\n     win_T\t*old_curwin = curwin;\n     static pos_T orig_cursor;\n     colnr_T\tleftcol, rightcol;\n     pos_T\tend_visual;\n     int\t\tdiff;\n     int\t\told_active = VIsual_active;\n     int\t\told_mode = VIsual_mode;\n     int\t\tregname;\n \n #if defined(FEAT_FOLDING)\n     save_cursor = curwin->w_cursor;\n #endif\n \n     if (do_always)\n \tdo_always = FALSE;\n     else\n #ifdef FEAT_GUI\n \tif (!gui.in_use)\n #endif\n \t{\n \t    if (VIsual_active)\n \t    {\n \t\tif (!mouse_has(MOUSE_VISUAL))\n \t\t    return FALSE;\n \t    }\n \t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n \t\treturn FALSE;\n \t}\n \n     for (;;)\n     {\n \twhich_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n \tif (is_drag)\n \t{\n \t    if (!KeyStuffed && vpeekc() != NUL)\n \t    {\n \t\tint nc;\n \t\tint save_mouse_row = mouse_row;\n \t\tint save_mouse_col = mouse_col;\n \n \t\tnc = safe_vgetc();\n \t\tif (c == nc)\n \t\t    continue;\n \t\tvungetc(nc);\n \t\tmouse_row = save_mouse_row;\n \t\tmouse_col = save_mouse_col;\n \t    }\n \t}\n \tbreak;\n     }\n \n     if (c == K_MOUSEMOVE)\n     {\n #ifdef FEAT_BEVAL_TERM\n \tui_may_remove_balloon();\n \tif (p_bevalterm)\n \t{\n \t    profile_setlimit(p_bdlay, &bevalexpr_due);\n \t    bevalexpr_due_set = TRUE;\n \t}\n #endif\n #ifdef FEAT_PROP_POPUP\n \tpopup_handle_mouse_moved();\n #endif\n \treturn FALSE;\n     }\n \n #ifdef FEAT_MOUSESHAPE\n     if (!is_drag && drag_status_line)\n     {\n \tdrag_status_line = FALSE;\n \tupdate_mouseshape(SHAPE_IDX_STATUS);\n     }\n     if (!is_drag && drag_sep_line)\n     {\n \tdrag_sep_line = FALSE;\n \tupdate_mouseshape(SHAPE_IDX_VSEP);\n     }\n #endif\n \n     if (is_click)\n \tgot_click = TRUE;\n     else\n     {\n \tif (!got_click)\n \t    return FALSE;\n \tif (!is_drag)\n \t{\n \t    got_click = FALSE;\n \t    if (in_tab_line)\n \t    {\n \t\tin_tab_line = FALSE;\n \t\treturn FALSE;\n \t    }\n \t}\n     }\n \n     if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n     {\n \tif (State & MODE_INSERT)\n \t    stuffcharReadbuff(Ctrl_O);\n \tif (count > 1)\n \t    stuffnumReadbuff(count);\n \tstuffcharReadbuff(Ctrl_T);\n \tgot_click = FALSE;\n \treturn FALSE;\n     }\n \n     if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n \treturn FALSE;\n \n     if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n \t\t\t\t\t\t\t     | MOD_MASK_META))\n \t    && (!is_click\n \t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n \t\t|| which_button == MOUSE_MIDDLE)\n \t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n \t\t&& mouse_model_popup()\n \t\t&& which_button == MOUSE_LEFT)\n \t    && !((mod_mask & MOD_MASK_ALT)\n \t\t&& !mouse_model_popup()\n \t\t&& which_button == MOUSE_RIGHT)\n \t    )\n \treturn FALSE;\n \n     if (!is_click && which_button == MOUSE_MIDDLE)\n \treturn FALSE;\n \n     if (oap != NULL)\n \tregname = oap->regname;\n     else\n \tregname = 0;\n \n     if (which_button == MOUSE_MIDDLE)\n     {\n \tif (State == MODE_NORMAL)\n \t{\n \t    if (oap != NULL && oap->op_type != OP_NOP)\n \t    {\n \t\tclearopbeep(oap);\n \t\treturn FALSE;\n \t    }\n \n \t    if (VIsual_active)\n \t    {\n \t\tif (VIsual_select)\n \t\t{\n \t\t    stuffcharReadbuff(Ctrl_G);\n \t\t    stuffReadbuff((char_u *)\"\\\"+p\");\n \t\t}\n \t\telse\n \t\t{\n \t\t    stuffcharReadbuff('y');\n \t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n \t\t}\n \t\tdo_always = TRUE;\n \t\treturn FALSE;\n \t    }\n \t}\n \n \telse if ((State & MODE_INSERT) == 0)\n \t    return FALSE;\n \n \tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n \t{\n \t    if (regname == '.')\n \t\tinsert_reg(regname, TRUE);\n \t    else\n \t    {\n #ifdef FEAT_CLIPBOARD\n \t\tif (clip_star.available && regname == 0)\n \t\t    regname = '*';\n #endif\n \t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n \t\t    insert_reg(regname, TRUE);\n \t\telse\n \t\t{\n \t\t    do_put(regname, NULL, BACKWARD, 1L,\n \t\t\t\t\t\t      fixindent | PUT_CURSEND);\n \n \t\t    AppendCharToRedobuff(Ctrl_R);\n \t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n \t\t    AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n \t\t}\n \t    }\n \t    return FALSE;\n \t}\n     }\n \n     if (!is_click)\n \tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n \n     start_visual.lnum = 0;\n \n// bug_start\n    if (mouse_row == 0 && firstwin->w_winrow > 0)\n    {\n\tif (is_drag)\n\t{\n\t    if (in_tab_line)\n\t    {\n// bug_end\n \t\tc1 = TabPageIdxs[mouse_col];\n// bug_start\n\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t? c1 - 1 : c1);\n\t    }\n// bug_end\n \t    return FALSE;\n \t}\n// bug_start\n\n\tif (is_click\n# ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n# endif\n\t\t&& mouse_col < Columns)\n\t{\n\t    in_tab_line = TRUE;\n\t    c1 = TabPageIdxs[mouse_col];\n\t    if (c1 >= 0)\n\t    {\n\t\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t{\n\t\t    end_visual_mode_keep_button();\n\t\t    tabpage_new();\n\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    goto_tabpage(c1);\n\n\t\t    if (curwin != old_curwin)\n\t\t\tend_visual_mode_keep_button();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttabpage_T\t*tp;\n\n\t\tif (c1 == -999)\n\t\t    tp = curtab;\n\t\telse\n\t\t    tp = find_tabpage(-c1);\n\t\tif (tp == curtab)\n\t\t{\n\t\t    if (first_tabpage->tp_next != NULL)\n\t\t\ttabpage_close(FALSE);\n\t\t}\n\t\telse if (tp != NULL)\n\t\t    tabpage_close_other(tp, FALSE);\n\t    }\n\t}\n\treturn TRUE;\n    }\n    else if (is_drag && in_tab_line)\n    {\n\tc1 = TabPageIdxs[mouse_col];\n\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\treturn FALSE;\n// bug_end\n     }\n \n     if (mouse_model_popup())\n     {\n \tif (which_button == MOUSE_RIGHT\n \t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n \t{\n #ifdef USE_POPUP_SETPOS\n # ifdef FEAT_GUI\n \t    if (gui.in_use)\n \t    {\n #  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n \t\t\t  || defined(FEAT_GUI_PHOTON)\n \t\tif (!is_click)\n \t\t    return FALSE;\n #  endif\n #  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n \t\tif (is_click || is_drag)\n \t\t    return FALSE;\n #  endif\n \t    }\n # endif\n # if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n \t    else\n # endif\n # if defined(FEAT_TERM_POPUP_MENU)\n \t    if (!is_click)\n \t\treturn FALSE;\n #endif\n \n \t    jump_flags = 0;\n \t    if (STRCMP(p_mousem, \"popup_setpos\") == 0)\n \t    {\n \t\tif (VIsual_active)\n \t\t{\n \t\t    pos_T    m_pos;\n \n \t\t    if (mouse_row < curwin->w_winrow\n \t\t\t || mouse_row\n \t\t\t\t  > (curwin->w_winrow + curwin->w_height))\n \t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n \t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n \t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n \t\t    else\n \t\t    {\n \t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n \t\t\t\t    && (LT_POS(m_pos, curwin->w_cursor)\n \t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n \t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n \t\t\t\t    && (LT_POS(m_pos, VIsual)\n \t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n \t\t\t{\n \t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n \t\t\t}\n \t\t\telse if (VIsual_mode == Ctrl_V)\n \t\t\t{\n \t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n \t\t\t\t\t\t     &leftcol, &rightcol);\n \t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n \t\t\t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n \t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n \t\t\t}\n \t\t    }\n \t\t}\n \t\telse\n \t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n \t    }\n \t    if (jump_flags)\n \t    {\n \t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n \t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n \t\tsetcursor();\n \t\tout_flush();\n \t    }\n # ifdef FEAT_MENU\n \t    show_popupmenu();\n \t    got_click = FALSE;\n # endif\n \t    return (jump_flags & CURSOR_MOVED) != 0;\n #else\n \t    return FALSE;\n #endif\n \t}\n \tif (which_button == MOUSE_LEFT\n \t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n \t{\n \t    which_button = MOUSE_RIGHT;\n \t    mod_mask &= ~MOD_MASK_SHIFT;\n \t}\n     }\n \n     if ((State & (MODE_NORMAL | MODE_INSERT))\n \t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n     {\n \tif (which_button == MOUSE_LEFT)\n \t{\n \t    if (is_click)\n \t    {\n \t\tif (VIsual_active)\n \t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n \t    }\n \t    else if (mouse_has(MOUSE_VISUAL))\n \t\tjump_flags |= MOUSE_MAY_VIS;\n \t}\n \telse if (which_button == MOUSE_RIGHT)\n \t{\n \t    if (is_click && VIsual_active)\n \t    {\n \t\tif (LT_POS(curwin->w_cursor, VIsual))\n \t\t{\n \t\t    start_visual = curwin->w_cursor;\n \t\t    end_visual = VIsual;\n \t\t}\n \t\telse\n \t\t{\n \t\t    start_visual = VIsual;\n \t\t    end_visual = curwin->w_cursor;\n \t\t}\n \t    }\n \t    jump_flags |= MOUSE_FOCUS;\n \t    if (mouse_has(MOUSE_VISUAL))\n \t\tjump_flags |= MOUSE_MAY_VIS;\n \t}\n     }\n \n     if (!is_drag && oap != NULL && oap->op_type != OP_NOP)\n     {\n \tgot_click = FALSE;\n \toap->motion_type = MCHAR;\n     }\n \n     if (!is_click && !is_drag)\n \tjump_flags |= MOUSE_RELEASED;\n \n     jump_flags = jump_to_mouse(jump_flags,\n \t\t\toap == NULL ? NULL : &(oap->inclusive), which_button);\n \n #ifdef FEAT_MENU\n     if (jump_flags & MOUSE_WINBAR)\n \treturn FALSE;\n #endif\n     moved = (jump_flags & CURSOR_MOVED);\n     in_status_line = (jump_flags & IN_STATUS_LINE);\n     in_sep_line = (jump_flags & IN_SEP_LINE);\n \n #ifdef FEAT_NETBEANS_INTG\n     if (isNetbeansBuffer(curbuf)\n \t\t\t    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))\n     {\n \tint key = KEY2TERMCAP1(c);\n \n \tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n \t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n \t    netbeans_button_release(which_button);\n     }\n #endif\n \n     if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n \tclearop(oap);\n \n #ifdef FEAT_FOLDING\n     if (mod_mask == 0\n \t    && !is_drag\n \t    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n \t    && which_button == MOUSE_LEFT)\n     {\n \tif (jump_flags & MOUSE_FOLD_OPEN)\n \t    openFold(curwin->w_cursor.lnum, 1L);\n \telse\n \t    closeFold(curwin->w_cursor.lnum, 1L);\n \tif (curwin == old_curwin)\n \t    curwin->w_cursor = save_cursor;\n     }\n #endif\n \n #if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n     if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n     {\n \tclip_modeless(which_button, is_click, is_drag);\n \treturn FALSE;\n     }\n #endif\n \n     if (VIsual_active && is_drag && get_scrolloff_value())\n     {\n \tif (mouse_row == 0)\n \t    mouse_dragging = 2;\n \telse\n \t    mouse_dragging = 1;\n     }\n \n     if (is_drag && mouse_row < 0 && !in_status_line)\n     {\n \tscroll_redraw(FALSE, 1L);\n \tmouse_row = 0;\n     }\n \n     if (start_visual.lnum)\n     {\n        if (mod_mask & MOD_MASK_ALT)\n \t   VIsual_mode = Ctrl_V;\n \n \tif (VIsual_mode == Ctrl_V)\n \t{\n \t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n \t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n \t\tend_visual.col = leftcol;\n \t    else\n \t\tend_visual.col = rightcol;\n \t    if (curwin->w_cursor.lnum >=\n \t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n \t\tend_visual.lnum = start_visual.lnum;\n \n \t    start_visual = curwin->w_cursor;\n \t    curwin->w_cursor = end_visual;\n \t    coladvance(end_visual.col);\n \t    VIsual = curwin->w_cursor;\n \t    curwin->w_cursor = start_visual;\n \t}\n \telse\n \t{\n \t    if (LT_POS(curwin->w_cursor, start_visual))\n \t\tVIsual = end_visual;\n \t    else if (LT_POS(end_visual, curwin->w_cursor))\n \t\tVIsual = start_visual;\n \t    else\n \t    {\n \t\tif (end_visual.lnum == start_visual.lnum)\n \t\t{\n \t\t    if (curwin->w_cursor.col - start_visual.col >\n \t\t\t\t    end_visual.col - curwin->w_cursor.col)\n \t\t\tVIsual = start_visual;\n \t\t    else\n \t\t\tVIsual = end_visual;\n \t\t}\n \n \t\telse\n \t\t{\n \t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n \t\t\t\t(end_visual.lnum - curwin->w_cursor.lnum);\n \n \t\t    if (diff > 0)\n \t\t\tVIsual = start_visual;\n \t\t    else if (diff < 0)\n \t\t\tVIsual = end_visual;\n \t\t    else\n \t\t    {\n \t\t\tif (curwin->w_cursor.col <\n \t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n \t\t\t    VIsual = end_visual;\n \t\t\telse\n \t\t\t    VIsual = start_visual;\n \t\t    }\n \t\t}\n \t    }\n \t}\n     }\n     else if ((State & MODE_INSERT) && VIsual_active)\n \tstuffcharReadbuff(Ctrl_O);\n \n     if (which_button == MOUSE_MIDDLE)\n     {\n #ifdef FEAT_CLIPBOARD\n \tif (clip_star.available && regname == 0)\n \t    regname = '*';\n #endif\n \tif (yank_register_mline(regname))\n \t{\n \t    if (mouse_past_bottom)\n \t\tdir = FORWARD;\n \t}\n \telse if (mouse_past_eol)\n \t    dir = FORWARD;\n \n \tif (fixindent)\n \t{\n \t    c1 = (dir == BACKWARD) ? '[' : ']';\n \t    c2 = 'p';\n \t}\n \telse\n \t{\n \t    c1 = (dir == FORWARD) ? 'p' : 'P';\n \t    c2 = NUL;\n \t}\n \tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n \n \tif (restart_edit != 0)\n \t    where_paste_started = curwin->w_cursor;\n \tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n     }\n \n #if defined(FEAT_QUICKFIX)\n     else if (((mod_mask & MOD_MASK_CTRL)\n \t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n \t    && bt_quickfix(curbuf))\n     {\n \tif (curwin->w_llist_ref == NULL)\n \t    do_cmdline_cmd((char_u *)\".cc\");\n \telse\n \t    do_cmdline_cmd((char_u *)\".ll\");\n \tgot_click = FALSE;\n     }\n #endif\n \n     else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n \t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n     {\n \tif (State & MODE_INSERT)\n \t    stuffcharReadbuff(Ctrl_O);\n \tstuffcharReadbuff(Ctrl_RSB);\n \tgot_click = FALSE;\n     }\n \n     else if ((mod_mask & MOD_MASK_SHIFT))\n     {\n \tif ((State & MODE_INSERT) || (VIsual_active && VIsual_select))\n \t    stuffcharReadbuff(Ctrl_O);\n \tif (which_button == MOUSE_LEFT)\n \t    stuffcharReadbuff('*');\n \telse\n \t    stuffcharReadbuff('#');\n     }\n \n     else if (in_status_line)\n     {\n #ifdef FEAT_MOUSESHAPE\n \tif ((is_drag || is_click) && !drag_status_line)\n \t{\n \t    drag_status_line = TRUE;\n \t    update_mouseshape(-1);\n \t}\n #endif\n     }\n     else if (in_sep_line)\n     {\n #ifdef FEAT_MOUSESHAPE\n \tif ((is_drag || is_click) && !drag_sep_line)\n \t{\n \t    drag_sep_line = TRUE;\n \t    update_mouseshape(-1);\n \t}\n #endif\n     }\n     else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n \t\t\t\t       && (State & (MODE_NORMAL | MODE_INSERT))\n \t     && mouse_has(MOUSE_VISUAL))\n     {\n \tif (is_click || !VIsual_active)\n \t{\n \t    if (VIsual_active)\n \t\torig_cursor = VIsual;\n \t    else\n \t    {\n \t\tcheck_visual_highlight();\n \t\tVIsual = curwin->w_cursor;\n \t\torig_cursor = VIsual;\n \t\tVIsual_active = TRUE;\n \t\tVIsual_reselect = TRUE;\n \t\tmay_start_select('o');\n \t\tsetmouse();\n \t    }\n \t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n \t    {\n \t\tif (mod_mask & MOD_MASK_ALT)\n \t\t    VIsual_mode = Ctrl_V;\n \t\telse\n \t\t    VIsual_mode = 'v';\n \t    }\n \t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n \t\tVIsual_mode = 'V';\n \t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n \t\tVIsual_mode = Ctrl_V;\n #ifdef FEAT_CLIPBOARD\n \t    clip_star.vmode = NUL;\n #endif\n \t}\n \tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n \t{\n \t    pos_T\t*pos = NULL;\n \t    int\t\tgc;\n \n \t    if (is_click)\n \t    {\n \t\tend_visual = curwin->w_cursor;\n \t\twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n \t\t    inc(&end_visual);\n \t\tif (oap != NULL)\n \t\t    oap->motion_type = MCHAR;\n \t\tif (oap != NULL\n \t\t\t&& VIsual_mode == 'v'\n \t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n \t\t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n \t\t\t&& (pos = findmatch(oap, NUL)) != NULL)\n \t\t{\n \t\t    curwin->w_cursor = *pos;\n \t\t    if (oap->motion_type == MLINE)\n \t\t\tVIsual_mode = 'V';\n \t\t    else if (*p_sel == 'e')\n \t\t    {\n \t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n \t\t\t    ++VIsual.col;\n \t\t\telse\n \t\t\t    ++curwin->w_cursor.col;\n \t\t    }\n \t\t}\n \t    }\n \n \t    if (pos == NULL && (is_click || is_drag))\n \t    {\n \t\tif (LT_POS(curwin->w_cursor, orig_cursor))\n \t\t{\n \t\t    find_start_of_word(&curwin->w_cursor);\n \t\t    find_end_of_word(&VIsual);\n \t\t}\n \t\telse\n \t\t{\n \t\t    find_start_of_word(&VIsual);\n \t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n \t\t\tcurwin->w_cursor.col +=\n \t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n \t\t    find_end_of_word(&curwin->w_cursor);\n \t\t}\n \t    }\n \t    curwin->w_set_curswant = TRUE;\n \t}\n \tif (is_click)\n \t    redraw_curbuf_later(UPD_INVERTED);\n     }\n     else if (VIsual_active && !old_active)\n     {\n \tif (mod_mask & MOD_MASK_ALT)\n \t    VIsual_mode = Ctrl_V;\n \telse\n \t    VIsual_mode = 'v';\n     }\n \n     if ((!VIsual_active && old_active && mode_displayed)\n \t    || (VIsual_active && p_smd && msg_silent == 0\n \t\t\t\t && (!old_active || VIsual_mode != old_mode)))\n \tredraw_cmdline = TRUE;\n \n     return moved;\n }\n \n", "target": "// fix_start\n    if (TabPageIdxs != NULL)\n    {\n\tif (mouse_row == 0 && firstwin->w_winrow > 0)\n\t{\n\t    if (is_drag)\n\t    {\n\t\tif (in_tab_line)\n\t\t{\n\t\t    c1 = TabPageIdxs[mouse_col];\n\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n\t\t}\n\t\treturn FALSE;\n\t    }\n\n\t    if (is_click\n# ifdef FEAT_CMDWIN\n\t\t    && cmdwin_type == 0\n# endif\n\t\t    && mouse_col < Columns)\n\t    {\n\t\tin_tab_line = TRUE;\n// fix_end\n// fix_start\n\t\tif (c1 >= 0)\n\t\t{\n\t\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t    {\n\t\t\tend_visual_mode_keep_button();\n\t\t\ttabpage_new();\n\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tgoto_tabpage(c1);\n\n\t\t\tif (curwin != old_curwin)\n\t\t\t    end_visual_mode_keep_button();\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*tp;\n\n\t\t    if (c1 == -999)\n\t\t\ttp = curtab;\n\t\t    else\n\t\t\ttp = find_tabpage(-c1);\n\t\t    if (tp == curtab)\n\t\t    {\n\t\t\tif (first_tabpage->tp_next != NULL)\n\t\t\t    tabpage_close(FALSE);\n\t\t    }\n\t\t    else if (tp != NULL)\n\t\t\ttabpage_close_other(tp, FALSE);\n\t\t}\n\t    }\n\t    return TRUE;\n\t}\n\telse if (is_drag && in_tab_line)\n\t{\n\t    c1 = TabPageIdxs[mouse_col];\n\t    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-2980", "cve_desc": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0259.", "project": "vim", "idx": 209102}
{"source": " void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n {\n \tminify = dominify;\n// bug_start\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n// bug_end\n \t}\n \tif (minify > 1)\n \t\tputchar('\\n');\n }\n \n", "target": "// fix_start\n\tif (prog) {\n\t\tif (prog->type == AST_LIST)\n\t\t\tpstmlist(-1, prog);\n\t\telse {\n\t\t\tpstm(0, prog);\n\t\t\tnl();\n\t\t}\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-30975", "cve_desc": "In Artifex MuJS through 1.2.0, jsP_dumpsyntax in jsdump.c has a NULL pointer dereference, as demonstrated by mujs-pp.", "project": "mujs", "idx": 209801}
{"source": " static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                     UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n {\n// bug_start\n// bug_end\n \tVideoClientContextPriv* priv = video->priv;\n// bug_start\n\tPresentationContext* ret = calloc(1, sizeof(*ret));\n// bug_end\n \tif (!ret)\n \t\treturn NULL;\n \n \tret->video = video;\n \tret->PresentationId = PresentationId;\n \n \tret->h264 = h264_context_new(FALSE);\n \tif (!ret->h264)\n \t{\n \t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n \t\tgoto error_h264;\n \t}\n \th264_context_reset(ret->h264, width, height);\n \n \tret->currentSample = Stream_New(NULL, 4096);\n \tif (!ret->currentSample)\n \t{\n \t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n \t\tgoto error_currentSample;\n \t}\n \n// bug_start\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);\n// bug_end\n \tif (!ret->surfaceData)\n \t{\n \t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n \t\tgoto error_surfaceData;\n \t}\n \n \tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n \tif (!ret->surface)\n \t{\n \t\tWLog_ERR(TAG, \"unable to create surface\");\n \t\tgoto error_surface;\n \t}\n \n \tret->yuv = yuv_context_new(FALSE);\n \tif (!ret->yuv)\n \t{\n \t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n \t\tgoto error_yuv;\n \t}\n \n \tyuv_context_reset(ret->yuv, width, height);\n \tret->refCounter = 1;\n \treturn ret;\n \n error_yuv:\n \tvideo->deleteSurface(video, ret->surface);\n error_surface:\n \tBufferPool_Return(priv->surfacePool, ret->surfaceData);\n error_surfaceData:\n \tStream_Free(ret->currentSample, TRUE);\n error_currentSample:\n \th264_context_free(ret->h264);\n error_h264:\n \tfree(ret);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tsize_t s;\n// fix_end\n// fix_start\n\tPresentationContext* ret;\n\ts = width * height * 4ULL;\n\tif (s > INT32_MAX)\n\t\treturn NULL;\n\n\tret = calloc(1, sizeof(*ret));\n// fix_end\n// fix_start\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, s);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-11038", "cve_desc": "In FreeRDP less than or equal to 2.0.0, an Integer Overflow to Buffer Overflow exists. When using /video redirection, a manipulated server can instruct the client to allocate a buffer with a smaller size than requested due to an integer overflow in size calculation. With later messages, the server can manipulate the client to write data out of bound to the previously allocated buffer. This has been patched in 2.1.0.", "project": "FreeRDP", "idx": 209931}
{"source": " struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,\n \t\t\t       const struct pci_device_id *ent,\n \t\t\t       const struct iwl_cfg_trans_params *cfg_trans)\n {\n \tstruct iwl_trans_pcie *trans_pcie;\n \tstruct iwl_trans *trans;\n \tint ret, addr_size;\n \n \tret = pcim_enable_device(pdev);\n \tif (ret)\n \t\treturn ERR_PTR(ret);\n \n \tif (cfg_trans->gen2)\n \t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n \t\t\t\t\t&pdev->dev, &trans_ops_pcie_gen2);\n \telse\n \t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n \t\t\t\t\t&pdev->dev, &trans_ops_pcie);\n \n \tif (!trans)\n \t\treturn ERR_PTR(-ENOMEM);\n \n \ttrans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n \n \ttrans_pcie->trans = trans;\n \ttrans_pcie->opmode_down = true;\n \tspin_lock_init(&trans_pcie->irq_lock);\n \tspin_lock_init(&trans_pcie->reg_lock);\n \tmutex_init(&trans_pcie->mutex);\n \tinit_waitqueue_head(&trans_pcie->ucode_write_waitq);\n// bug_start\n// bug_end\n \ttrans_pcie->tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page);\n \tif (!trans_pcie->tso_hdr_page) {\n \t\tret = -ENOMEM;\n \t\tgoto out_no_pci;\n \t}\n \ttrans_pcie->debug_rfkill = -1;\n \n \tif (!cfg_trans->base_params->pcie_l1_allowed) {\n \t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n \t\t\t\t       PCIE_LINK_STATE_L1 |\n \t\t\t\t       PCIE_LINK_STATE_CLKPM);\n \t}\n \n \ttrans_pcie->def_rx_queue = 0;\n \n \tif (cfg_trans->use_tfh) {\n \t\taddr_size = 64;\n \t\ttrans_pcie->max_tbs = IWL_TFH_NUM_TBS;\n \t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfh_tfd);\n \t} else {\n \t\taddr_size = 36;\n \t\ttrans_pcie->max_tbs = IWL_NUM_OF_TBS;\n \t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfd);\n \t}\n \ttrans->max_skb_frags = IWL_PCIE_MAX_FRAGS(trans_pcie);\n \n \tpci_set_master(pdev);\n \n \tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(addr_size));\n \tif (!ret)\n \t\tret = pci_set_consistent_dma_mask(pdev,\n \t\t\t\t\t\t  DMA_BIT_MASK(addr_size));\n \tif (ret) {\n \t\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n \t\tif (!ret)\n \t\t\tret = pci_set_consistent_dma_mask(pdev,\n \t\t\t\t\t\t\t  DMA_BIT_MASK(32));\n \t\tif (ret) {\n \t\t\tdev_err(&pdev->dev, \"No suitable DMA available\\n\");\n \t\t\tgoto out_no_pci;\n \t\t}\n \t}\n \n \tret = pcim_iomap_regions_request_all(pdev, BIT(0), DRV_NAME);\n \tif (ret) {\n \t\tdev_err(&pdev->dev, \"pcim_iomap_regions_request_all failed\\n\");\n \t\tgoto out_no_pci;\n \t}\n \n \ttrans_pcie->hw_base = pcim_iomap_table(pdev)[0];\n \tif (!trans_pcie->hw_base) {\n \t\tdev_err(&pdev->dev, \"pcim_iomap_table failed\\n\");\n \t\tret = -ENODEV;\n \t\tgoto out_no_pci;\n \t}\n \n \tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n \n \ttrans_pcie->pci_dev = pdev;\n \tiwl_disable_interrupts(trans);\n \n \ttrans->hw_rev = iwl_read32(trans, CSR_HW_REV);\n \tif (trans->hw_rev == 0xffffffff) {\n \t\tdev_err(&pdev->dev, \"HW_REV=0xFFFFFFFF, PCI issues?\\n\");\n \t\tret = -EIO;\n \t\tgoto out_no_pci;\n \t}\n \n \tif (cfg_trans->device_family >= IWL_DEVICE_FAMILY_8000) {\n \t\ttrans->hw_rev = (trans->hw_rev & 0xfff0) |\n \t\t\t\t(CSR_HW_REV_STEP(trans->hw_rev << 2) << 2);\n \n \t\tret = iwl_pcie_prepare_card_hw(trans);\n \t\tif (ret) {\n \t\t\tIWL_WARN(trans, \"Exit HW not ready\\n\");\n \t\t\tgoto out_no_pci;\n \t\t}\n \n \t\tret = iwl_finish_nic_init(trans, cfg_trans);\n \t\tif (ret)\n \t\t\tgoto out_no_pci;\n \n \t}\n \n \tIWL_DEBUG_INFO(trans, \"HW REV: 0x%0x\\n\", trans->hw_rev);\n \n \tiwl_pcie_set_interrupt_capa(pdev, trans, cfg_trans);\n \ttrans->hw_id = (pdev->device << 16) + pdev->subsystem_device;\n \tsnprintf(trans->hw_id_str, sizeof(trans->hw_id_str),\n \t\t \"PCI ID: 0x%04X:0x%04X\", pdev->device, pdev->subsystem_device);\n \n \tinit_waitqueue_head(&trans_pcie->wait_command_queue);\n \n \tinit_waitqueue_head(&trans_pcie->sx_waitq);\n \n \tif (trans_pcie->msix_enabled) {\n \t\tret = iwl_pcie_init_msix_handler(pdev, trans_pcie);\n \t\tif (ret)\n \t\t\tgoto out_no_pci;\n \t } else {\n \t\tret = iwl_pcie_alloc_ict(trans);\n \t\tif (ret)\n \t\t\tgoto out_no_pci;\n \n \t\tret = devm_request_threaded_irq(&pdev->dev, pdev->irq,\n \t\t\t\t\t\tiwl_pcie_isr,\n \t\t\t\t\t\tiwl_pcie_irq_handler,\n \t\t\t\t\t\tIRQF_SHARED, DRV_NAME, trans);\n \t\tif (ret) {\n \t\t\tIWL_ERR(trans, \"Error allocating IRQ %d\\n\", pdev->irq);\n \t\t\tgoto out_free_ict;\n \t\t}\n \t\ttrans_pcie->inta_mask = CSR_INI_SET_MASK;\n \t }\n \n// bug_start\n\ttrans_pcie->rba.alloc_wq = alloc_workqueue(\"rb_allocator\",\n\t\t\t\t\t\t   WQ_HIGHPRI | WQ_UNBOUND, 1);\n\tINIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);\n\n// bug_end\n #ifdef CONFIG_IWLWIFI_DEBUGFS\n \ttrans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED;\n \tmutex_init(&trans_pcie->fw_mon_data.mutex);\n #endif\n \n \treturn trans;\n \n out_free_ict:\n \tiwl_pcie_free_ict(trans);\n out_no_pci:\n \tfree_percpu(trans_pcie->tso_hdr_page);\n// bug_start\n// bug_end\n \tiwl_trans_free(trans);\n \treturn ERR_PTR(ret);\n }\n \n", "target": "// fix_start\n\n\ttrans_pcie->rba.alloc_wq = alloc_workqueue(\"rb_allocator\",\n\t\t\t\t\t\t   WQ_HIGHPRI | WQ_UNBOUND, 1);\n\tif (!trans_pcie->rba.alloc_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_trans;\n\t}\n\tINIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);\n\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\tdestroy_workqueue(trans_pcie->rba.alloc_wq);\nout_free_trans:\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2019-16234", "cve_desc": "drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.", "project": "linux", "idx": 209955}
{"source": " static void singlevar (LexState *ls, expdesc *var) {\n   TString *varname = str_checkname(ls);\n   FuncState *fs = ls->fs;\n   singlevaraux(fs, varname, var, 1);\n   if (var->k == VVOID) {\n     expdesc key;\n     singlevaraux(fs, ls->envn, var, 1);\n     lua_assert(var->k != VVOID);\n// bug_start\n// bug_end\n     codestring(&key, varname);\n     luaK_indexed(fs, var, &key);\n   }\n }\n \n", "target": "// fix_start\n    luaK_exp2anyregup(fs, var);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-28805", "cve_desc": "singlevar in lparser.c in Lua from (including) 5.4.0 up to (excluding) 5.4.4 lacks a certain luaK_exp2anyregup call, leading to a heap-based buffer over-read that might affect a system that compiles untrusted Lua code.", "project": "lua", "idx": 210050}
{"source": " cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n     uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n {\n \tconst cdf_section_header_t *shp;\n \tcdf_section_header_t sh;\n \tconst uint8_t *p, *q, *e;\n \tsize_t i, o4, nelements, j, slen, left;\n \tcdf_property_info_t *inp;\n \n \tif (offs > UINT32_MAX / 4) {\n \t\terrno = EFTYPE;\n \t\tgoto out;\n \t}\n \tshp = CAST(const cdf_section_header_t *,\n \t    cdf_offset(sst->sst_tab, offs));\n \tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n \t\tgoto out;\n \tsh.sh_len = CDF_TOLE4(shp->sh_len);\n \tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n \t\terrno = EFTYPE;\n \t\tgoto out;\n \t}\n \n \tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n \t\tgoto out;\n \n \tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n \tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n \t    sh.sh_properties));\n \tif (sh.sh_properties > CDF_PROP_LIMIT)\n \t\tgoto out;\n \tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n \tif (inp == NULL)\n \t\tgoto out;\n \tinp += *count;\n \t*count += sh.sh_properties;\n \tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n \te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n \tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n \t\tgoto out;\n \n \tfor (i = 0; i < sh.sh_properties; i++) {\n \t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n \t\t\tgoto out;\n \t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n \t\tleft = CAST(size_t, e - q);\n \t\tif (left < sizeof(uint32_t)) {\n \t\t\tDPRINTF((\"short info (no type)_\\n\"));\n \t\t\tgoto out;\n \t\t}\n \t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n \t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n \t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n \t\tif (inp[i].pi_type & CDF_VECTOR) {\n \t\t\tif (left < sizeof(uint32_t) * 2) {\n \t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n \t\t\t\tgoto out;\n \t\t\t}\n \t\t\tnelements = CDF_GETUINT32(q, 1);\n// bug_start\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n// bug_end\n \t\t\t\tgoto out;\n \t\t\t}\n \t\t\tslen = 2;\n \t\t} else {\n \t\t\tnelements = 1;\n \t\t\tslen = 1;\n \t\t}\n \t\to4 = slen * sizeof(uint32_t);\n \t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n \t\t\tgoto unknown;\n \t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n \t\tcase CDF_NULL:\n \t\tcase CDF_EMPTY:\n \t\t\tbreak;\n \t\tcase CDF_SIGNED16:\n \t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n \t\t\t\tgoto unknown;\n \t\t\tbreak;\n \t\tcase CDF_SIGNED32:\n \t\tcase CDF_BOOL:\n \t\tcase CDF_UNSIGNED32:\n \t\tcase CDF_FLOAT:\n \t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n \t\t\t\tgoto unknown;\n \t\t\tbreak;\n \t\tcase CDF_SIGNED64:\n \t\tcase CDF_UNSIGNED64:\n \t\tcase CDF_DOUBLE:\n \t\tcase CDF_FILETIME:\n \t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n \t\t\t\tgoto unknown;\n \t\t\tbreak;\n \t\tcase CDF_LENGTH32_STRING:\n \t\tcase CDF_LENGTH32_WSTRING:\n \t\t\tif (nelements > 1) {\n \t\t\t\tsize_t nelem = inp - *info;\n \t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n \t\t\t\tif (inp == NULL)\n \t\t\t\t\tgoto out;\n \t\t\t\tinp += nelem;\n \t\t\t}\n// bug_start\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n// bug_end\n \t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n \t\t\t    j++, i++)\n \t\t\t{\n \t\t\t\tuint32_t l;\n \n \t\t\t\tif (o4 + sizeof(uint32_t) > left)\n \t\t\t\t\tgoto out;\n \n \t\t\t\tl = CDF_GETUINT32(q, slen);\n \t\t\t\to4 += sizeof(uint32_t);\n \t\t\t\tif (o4 + l > left)\n \t\t\t\t\tgoto out;\n \n \t\t\t\tinp[i].pi_str.s_len = l;\n \t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n \t\t\t\t    CAST(const void *, &q[o4]));\n \n \t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n \t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n \t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n \t\t\t\t    left, inp[i].pi_str.s_buf));\n \n \t\t\t\tif (l & 1)\n \t\t\t\t\tl++;\n \n \t\t\t\tslen += l >> 1;\n \t\t\t\to4 = slen * sizeof(uint32_t);\n \t\t\t}\n \t\t\ti--;\n \t\t\tbreak;\n \t\tcase CDF_CLIPBOARD:\n \t\t\tif (inp[i].pi_type & CDF_VECTOR)\n \t\t\t\tgoto unknown;\n \t\t\tbreak;\n \t\tdefault:\n \t\tunknown:\n \t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n \t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n \t\t\t    inp[i].pi_type));\n \t\t\tbreak;\n \t\t}\n \t}\n \treturn 0;\n out:\n \tfree(*info);\n \t*info = NULL;\n \t*count = 0;\n \t*maxcount = 0;\n \terrno = EFTYPE;\n \treturn -1;\n }\n \n", "target": "// fix_start\n\t\t\tif (nelements > CDF_ELEMENT_LIMIT || nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == %\"\n\t\t\t\t    SIZE_T_FORMAT \"u\\n\", nelements));\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2019-18218", "cve_desc": "cdf_read_property_info in cdf.c in file through 5.37 does not restrict the number of CDF_VECTOR elements, which allows a heap-based buffer overflow (4-byte out-of-bounds write).", "project": "file", "idx": 210090}
{"source": " static void *seq_buf_alloc(unsigned long size)\n {\n// bug_start\n// bug_end\n \treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n }\n \n", "target": "// fix_start\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-33909", "cve_desc": "fs/seq_file.c in the Linux kernel 3.16 through 5.13.x before 5.13.4 does not properly restrict seq buffer allocations, leading to an integer overflow, an Out-of-bounds Write, and escalation to root by an unprivileged user, aka CID-8cae8cd89f05.", "project": "linux", "idx": 210203}
{"source": " static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n \t\t\t\t       int attr_len, bool log)\n {\n \n \tstruct sw_flow_actions *acts;\n \tint new_acts_size;\n \tsize_t req_size = NLA_ALIGN(attr_len);\n \tint next_offset = offsetof(struct sw_flow_actions, actions) +\n \t\t\t\t\t(*sfa)->actions_len;\n \n \tif (req_size <= (ksize(*sfa) - next_offset))\n \t\tgoto out;\n \n \tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n \n \tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n// bug_start\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n// bug_end\n \t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n \t\t\t\t  MAX_ACTIONS_BUFSIZE);\n \t\t\treturn ERR_PTR(-EMSGSIZE);\n \t\t}\n \t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n \t}\n \n \tacts = nla_alloc_flow_actions(new_acts_size);\n \tif (IS_ERR(acts))\n \t\treturn (void *)acts;\n \n \tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n \tacts->actions_len = (*sfa)->actions_len;\n \tacts->orig_len = (*sfa)->orig_len;\n \tkfree(*sfa);\n \t*sfa = acts;\n \n out:\n \t(*sfa)->actions_len += req_size;\n \treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n }\n \n", "target": "// fix_start\n\t\tif ((next_offset + req_size) > MAX_ACTIONS_BUFSIZE) {\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2022-2639", "cve_desc": "An integer coercion error was found in the openvswitch kernel module. Given a sufficiently large number of actions, while copying and reserving memory for a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This flaw allows a local user to crash or potentially escalate their privileges on the system.", "project": "linux", "idx": 210204}
{"source": " gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)\n {\n     char *pos = inbuf;\n     char *lpos = NULL;\n     char *tline = NULL;\n     LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);\n// bug_start\n    LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);\n// bug_end\n     char *name = NULL;\n     char *selector = NULL;\n     char *host = NULL;\n     char *port = NULL;\n     char *escaped_selector = NULL;\n     const char *icon_url = NULL;\n     char gtype;\n     StoreEntry *entry = NULL;\n \n// bug_start\n    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n// bug_end\n     memset(line, '\\0', TEMP_BUF_SIZE);\n \n     entry = gopherState->entry;\n \n     if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {\n         char *html_url = html_quote(entry->url());\n         gopherHTMLHeader(entry, \"Gopher Index %s\", html_url);\n         storeAppendPrintf(entry,\n                           \"<p>This is a searchable Gopher index. Use the search\\n\"\n                           \"function of your browser to enter search terms.\\n\"\n                           \"<ISINDEX>\\n\");\n         gopherHTMLFooter(entry);\n         entry->flush();\n         gopherState->HTML_header_added = 1;\n \n         return;\n     }\n \n     if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {\n         char *html_url = html_quote(entry->url());\n         gopherHTMLHeader(entry, \"CSO Search of %s\", html_url);\n         storeAppendPrintf(entry,\n                           \"<P>A CSO database usually contains a phonebook or\\n\"\n                           \"directory.  Use the search function of your browser to enter\\n\"\n                           \"search terms.</P><ISINDEX>\\n\");\n         gopherHTMLFooter(entry);\n         entry->flush();\n         gopherState->HTML_header_added = 1;\n \n         return;\n     }\n \n// bug_start\n    String outbuf;\n// bug_end\n \n     if (!gopherState->HTML_header_added) {\n         if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)\n             gopherHTMLHeader(entry, \"CSO Search Result\", NULL);\n         else\n             gopherHTMLHeader(entry, \"Gopher Menu\", NULL);\n \n         outbuf.append (\"<PRE>\");\n \n         gopherState->HTML_header_added = 1;\n \n         gopherState->HTML_pre = 1;\n     }\n \n     while (pos < inbuf + len) {\n         int llen;\n         int left = len - (pos - inbuf);\n         lpos = (char *)memchr(pos, '\\n', left);\n         if (lpos) {\n             ++lpos;\n             llen = lpos - pos;\n         } else {\n             llen = left;\n         }\n         if (gopherState->len + llen >= TEMP_BUF_SIZE) {\n             debugs(10, DBG_IMPORTANT, \"GopherHTML: Buffer overflow. Lost some data on URL: \" << entry->url()  );\n             llen = TEMP_BUF_SIZE - gopherState->len - 1;\n         }\n         if (!lpos) {\n             memcpy(gopherState->buf + gopherState->len, pos, llen);\n             gopherState->len += llen;\n             break;\n         }\n         if (gopherState->len != 0) {\n             memcpy(line, gopherState->buf, gopherState->len);\n             memcpy(line + gopherState->len, pos, llen);\n             llen += gopherState->len;\n             gopherState->len = 0;\n         } else {\n             memcpy(line, pos, llen);\n         }\n         line[llen + 1] = '\\0';\n         pos = lpos;\n \n \n         if (*line == '.') {\n             memset(line, '\\0', TEMP_BUF_SIZE);\n             continue;\n         }\n \n         switch (gopherState->conversion) {\n \n         case GopherStateData::HTML_INDEX_RESULT:\n \n         case GopherStateData::HTML_DIR: {\n             tline = line;\n             gtype = *tline;\n             ++tline;\n             name = tline;\n             selector = strchr(tline, TAB);\n \n             if (selector) {\n                 *selector = '\\0';\n                 ++selector;\n                 host = strchr(selector, TAB);\n \n                 if (host) {\n                     *host = '\\0';\n                     ++host;\n                     port = strchr(host, TAB);\n \n                     if (port) {\n                         char *junk;\n                         port[0] = ':';\n                         junk = strchr(host, TAB);\n \n                         if (junk)\n                             *junk++ = 0;\n                         else {\n                             junk = strchr(host, '\\r');\n \n                             if (junk)\n                                 *junk++ = 0;\n                             else {\n                                 junk = strchr(host, '\\n');\n \n                                 if (junk)\n                                     *junk++ = 0;\n                             }\n                         }\n \n                         if ((port[1] == '0') && (!port[2]))\n                             port[0] = 0;\n                     }\n \n                     escaped_selector = xstrdup(rfc1738_escape_part(selector));\n \n                     switch (gtype) {\n \n                     case GOPHER_DIRECTORY:\n                         icon_url = mimeGetIconURL(\"internal-menu\");\n                         break;\n \n                     case GOPHER_HTML:\n \n                     case GOPHER_FILE:\n                         icon_url = mimeGetIconURL(\"internal-text\");\n                         break;\n \n                     case GOPHER_INDEX:\n \n                     case GOPHER_CSO:\n                         icon_url = mimeGetIconURL(\"internal-index\");\n                         break;\n \n                     case GOPHER_IMAGE:\n \n                     case GOPHER_GIF:\n \n                     case GOPHER_PLUS_IMAGE:\n                         icon_url = mimeGetIconURL(\"internal-image\");\n                         break;\n \n                     case GOPHER_SOUND:\n \n                     case GOPHER_PLUS_SOUND:\n                         icon_url = mimeGetIconURL(\"internal-sound\");\n                         break;\n \n                     case GOPHER_PLUS_MOVIE:\n                         icon_url = mimeGetIconURL(\"internal-movie\");\n                         break;\n \n                     case GOPHER_TELNET:\n \n                     case GOPHER_3270:\n                         icon_url = mimeGetIconURL(\"internal-telnet\");\n                         break;\n \n                     case GOPHER_BIN:\n \n                     case GOPHER_MACBINHEX:\n \n                     case GOPHER_DOSBIN:\n \n                     case GOPHER_UUENCODED:\n                         icon_url = mimeGetIconURL(\"internal-binary\");\n                         break;\n \n                     case GOPHER_INFO:\n                         icon_url = NULL;\n                         break;\n \n                     default:\n                         icon_url = mimeGetIconURL(\"internal-unknown\");\n                         break;\n                     }\n \n// bug_start\n                    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n\n// bug_end\n                     if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {\n                         if (strlen(escaped_selector) != 0)\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, escaped_selector, rfc1738_escape_part(host),\n                                     *port ? \":\" : \"\", port, html_quote(name));\n// bug_end\n                         else\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                     port, html_quote(name));\n// bug_end\n \n                     } else if (gtype == GOPHER_INFO) {\n// bug_start\n                        snprintf(tmpbuf, TEMP_BUF_SIZE, \"\\t%s\\n\", html_quote(name));\n// bug_end\n                     } else {\n                         if (strncmp(selector, \"GET /\", 5) == 0) {\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n                                     icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n// bug_end\n                         } else {\n// bug_start\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                     icon_url, host, gtype, escaped_selector, html_quote(name));\n// bug_end\n                         }\n                     }\n \n                     safe_free(escaped_selector);\n// bug_start\n                    outbuf.append(tmpbuf);\n// bug_end\n                 } else {\n                     memset(line, '\\0', TEMP_BUF_SIZE);\n                     continue;\n                 }\n             } else {\n                 memset(line, '\\0', TEMP_BUF_SIZE);\n                 continue;\n             }\n \n             break;\n             }\n \n         case GopherStateData::HTML_CSO_RESULT: {\n             if (line[0] == '-') {\n                 int code, recno;\n                 char *s_code, *s_recno, *result;\n \n                 s_code = strtok(line + 1, \":\\n\");\n                 s_recno = strtok(NULL, \":\\n\");\n                 result = strtok(NULL, \"\\n\");\n \n                 if (!result)\n                     break;\n \n                 code = atoi(s_code);\n \n                 recno = atoi(s_recno);\n \n                 if (code != 200)\n                     break;\n \n                 if (gopherState->cso_recno != recno) {\n// bug_start\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n// bug_end\n                     gopherState->cso_recno = recno;\n                 } else {\n// bug_start\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"%s\\n\", html_quote(result));\n                }\n\n                outbuf.append(tmpbuf);\n// bug_end\n                 break;\n             } else {\n                 int code;\n                 char *s_code, *result;\n \n                 s_code = strtok(line, \":\");\n                 result = strtok(NULL, \"\\n\");\n \n                 if (!result)\n                     break;\n \n                 code = atoi(s_code);\n \n                 switch (code) {\n \n                 case 200: {\n                     break;\n                 }\n \n                 case 102:\n \n                 case 501:\n \n                 case 502: {\n// bug_start\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n                    outbuf.append(tmpbuf);\n// bug_end\n                     break;\n                 }\n \n                 }\n             }\n \n             }\n \n         default:\n             break;\n \n         }\n \n     }\n \n// bug_start\n    if (outbuf.size() > 0) {\n        entry->append(outbuf.rawBuf(), outbuf.size());\n// bug_end\n         entry->flush();\n     }\n \n// bug_start\n    outbuf.clean();\n// bug_end\n     return;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    SBuf outbuf;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n                                           icon_url, escaped_selector, rfc1738_escape_part(host),\n                                           *port ? \":\" : \"\", port, html_quote(name));\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n                                           icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                           port, html_quote(name));\n// fix_end\n// fix_start\n                        outbuf.appendf(\"\\t%s\\n\", html_quote(name));\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n                                           icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n                        } else if (gtype == GOPHER_WWW) {\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                           icon_url, rfc1738_escape_unescaped(selector), html_quote(name));\n// fix_end\n// fix_start\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                           icon_url, host, gtype, escaped_selector, html_quote(name));\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n// fix_end\n// fix_start\n                    outbuf.appendf(\"%s\\n\", html_quote(result));\n                }\n\n// fix_end\n// fix_start\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n// fix_end\n// fix_start\n    if (outbuf.length() > 0) {\n        entry->append(outbuf.rawContent(), outbuf.length());\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "cve": "CVE-2021-46784", "cve_desc": "In Squid 3.x through 3.5.28, 4.x through 4.17, and 5.x before 5.6, due to improper buffer management, a Denial of Service can occur when processing long Gopher server responses.", "project": "squid", "idx": 210206}
{"source": " static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n #define MonoColorType  1\n #define RGBColorType  3\n \n   char\n     property[MagickPathExtent];\n \n   CINInfo\n     cin;\n \n   Image\n     *image;\n \n   MagickBooleanType\n     status;\n \n   MagickOffsetType\n     offset;\n \n   QuantumInfo\n     *quantum_info;\n \n   QuantumType\n     quantum_type;\n \n   ssize_t\n     i;\n \n   Quantum\n     *q;\n \n   size_t\n     length;\n \n   ssize_t\n     count,\n     y;\n \n   unsigned char\n     magick[4],\n     *pixels;\n \n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   offset=0;\n   count=ReadBlob(image,4,magick);\n   offset+=count;\n   if ((count != 4) ||\n       ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   memset(&cin,0,sizeof(cin));\n   image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n     (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n   cin.file.image_offset=ReadBlobLong(image);\n// bug_start\n// bug_end\n   offset+=4;\n   cin.file.generic_length=ReadBlobLong(image);\n   offset+=4;\n   cin.file.industry_length=ReadBlobLong(image);\n   offset+=4;\n   cin.file.user_length=ReadBlobLong(image);\n   offset+=4;\n   cin.file.file_size=ReadBlobLong(image);\n   offset+=4;\n   offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n     cin.file.version);\n   (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n   (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n   offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n     cin.file.filename);\n   (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n   (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n   offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n     cin.file.create_date);\n   (void) CopyMagickString(property,cin.file.create_date,\n     sizeof(cin.file.create_date));\n   (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n   offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n     cin.file.create_time);\n   (void) CopyMagickString(property,cin.file.create_time,\n     sizeof(cin.file.create_time));\n   (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n   offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n     cin.file.reserve);\n   cin.image.orientation=(unsigned char) ReadBlobByte(image);\n   offset++;\n   if (cin.image.orientation != (unsigned char) (~0))\n     (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n       cin.image.orientation);\n   switch (cin.image.orientation)\n   {\n     default:\n     case 0: image->orientation=TopLeftOrientation; break;\n     case 1: image->orientation=TopRightOrientation; break;\n     case 2: image->orientation=BottomLeftOrientation; break;\n     case 3: image->orientation=BottomRightOrientation; break;\n     case 4: image->orientation=LeftTopOrientation; break;\n     case 5: image->orientation=RightTopOrientation; break;\n     case 6: image->orientation=LeftBottomOrientation; break;\n     case 7: image->orientation=RightBottomOrientation; break;\n   }\n   cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n   offset++;\n   offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n     cin.image.reserve1);\n   for (i=0; i < 8; i++)\n   {\n     cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n     offset++;\n     cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n     offset+=4;\n     cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n     offset+=4;\n     cin.image.channel[i].min_data=ReadBlobFloat(image);\n     offset+=4;\n     cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n     offset+=4;\n     cin.image.channel[i].max_data=ReadBlobFloat(image);\n     offset+=4;\n     cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n     offset+=4;\n   }\n   cin.image.white_point[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n     image->chromaticity.white_point.x=cin.image.white_point[0];\n   cin.image.white_point[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n     image->chromaticity.white_point.y=cin.image.white_point[1];\n   cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n     image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n   cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n     image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n   cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n     image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n   cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n     image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n   cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n     image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n   cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n     image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n   offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n     cin.image.label);\n   (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n   (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n   offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n     cin.image.reserve);\n   cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n   offset++;\n   cin.data_format.line_pad=ReadBlobLong(image);\n   offset+=4;\n   cin.data_format.channel_pad=ReadBlobLong(image);\n   offset+=4;\n   offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n     cin.data_format.reserve);\n   cin.origination.x_offset=ReadBlobSignedLong(image);\n   offset+=4;\n   if ((size_t) cin.origination.x_offset != ~0UL)\n     (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n       (double) cin.origination.x_offset);\n   cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n   offset+=4;\n   if ((size_t) cin.origination.y_offset != ~0UL)\n     (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n       (double) cin.origination.y_offset);\n   offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n     cin.origination.filename);\n   (void) CopyMagickString(property,cin.origination.filename,\n     sizeof(cin.origination.filename));\n   (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n   offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n     cin.origination.create_date);\n   (void) CopyMagickString(property,cin.origination.create_date,\n     sizeof(cin.origination.create_date));\n   (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n     exception);\n   offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n     cin.origination.create_time);\n   (void) CopyMagickString(property,cin.origination.create_time,\n     sizeof(cin.origination.create_time));\n   (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n     exception);\n   offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n     cin.origination.device);\n   (void) CopyMagickString(property,cin.origination.device,\n     sizeof(cin.origination.device));\n   (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n   offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n     cin.origination.model);\n   (void) CopyMagickString(property,cin.origination.model,\n     sizeof(cin.origination.model));\n   (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n   (void) memset(cin.origination.serial,0,\n     sizeof(cin.origination.serial));\n   offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n     cin.origination.serial);\n   (void) CopyMagickString(property,cin.origination.serial,\n     sizeof(cin.origination.serial));\n   (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n   cin.origination.x_pitch=ReadBlobFloat(image);\n   offset+=4;\n   cin.origination.y_pitch=ReadBlobFloat(image);\n   offset+=4;\n   cin.origination.gamma=ReadBlobFloat(image);\n   offset+=4;\n   if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n     image->gamma=cin.origination.gamma;\n   offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n     cin.origination.reserve);\n   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n     {\n       int\n         c;\n \n       cin.film.id=ReadBlobByte(image);\n       offset++;\n       c=cin.film.id;\n       if (c != ~0)\n         (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n       cin.film.type=ReadBlobByte(image);\n       offset++;\n       c=cin.film.type;\n       if (c != ~0)\n         (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n       cin.film.offset=ReadBlobByte(image);\n       offset++;\n       c=cin.film.offset;\n       if (c != ~0)\n         (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n           cin.film.offset);\n       cin.film.reserve1=ReadBlobByte(image);\n       offset++;\n       cin.film.prefix=ReadBlobLong(image);\n       offset+=4;\n       if (cin.film.prefix != ~0UL)\n         (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n           cin.film.prefix);\n       cin.film.count=ReadBlobLong(image);\n       offset+=4;\n       offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n         cin.film.format);\n       (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n       (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n       cin.film.frame_position=ReadBlobLong(image);\n       offset+=4;\n       if (cin.film.frame_position != ~0UL)\n         (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n           (double) cin.film.frame_position);\n       cin.film.frame_rate=ReadBlobFloat(image);\n       offset+=4;\n       if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n         (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n           cin.film.frame_rate);\n       offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n         cin.film.frame_id);\n       (void) CopyMagickString(property,cin.film.frame_id,\n         sizeof(cin.film.frame_id));\n       (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n       offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n         cin.film.slate_info);\n       (void) CopyMagickString(property,cin.film.slate_info,\n         sizeof(cin.film.slate_info));\n       (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n       offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n         cin.film.reserve);\n     }\n   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n     {\n       StringInfo\n         *profile;\n \n       if (cin.file.user_length > GetBlobSize(image))\n         ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n       profile=BlobToStringInfo((const unsigned char *) NULL,\n         cin.file.user_length);\n       if (profile == (StringInfo *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       offset+=ReadBlob(image,GetStringInfoLength(profile),\n         GetStringInfoDatum(profile));\n       (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n       profile=DestroyStringInfo(profile);\n     }\n   image->depth=cin.image.channel[0].bits_per_pixel;\n   image->columns=cin.image.channel[0].pixels_per_line;\n   image->rows=cin.image.channel[0].lines_per_image;\n   if (image_info->ping != MagickFalse)\n     {\n       (void) CloseBlob(image);\n       return(image);\n     }\n   if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n     ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n   {\n     int\n       c;\n \n     c=ReadBlobByte(image);\n     if (c == EOF)\n       break;\n   }\n   if (offset < (MagickOffsetType) cin.file.image_offset)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   status=SetImageExtent(image,image->columns,image->rows,exception);\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   (void) SetImageBackgroundColor(image,exception);\n   quantum_info=AcquireQuantumInfo(image_info,image);\n   if (quantum_info == (QuantumInfo *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n   SetQuantumQuantum(quantum_info,32);\n   SetQuantumPack(quantum_info,MagickFalse);\n   quantum_type=RGBQuantum;\n   length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n   if (cin.image.number_channels == 1)\n     {\n       quantum_type=GrayQuantum;\n       length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n     }\n   status=SetQuantumPad(image,quantum_info,0);\n   pixels=GetQuantumPixels(quantum_info);\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n     const void\n       *stream;\n \n     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n     if (q == (Quantum *) NULL)\n       break;\n     stream=ReadBlobStream(image,length,pixels,&count);\n     if ((size_t) count != length)\n       break;\n     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       quantum_type,(unsigned char *) stream,exception);\n     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       break;\n     if (image->previous == (Image *) NULL)\n       {\n         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n           image->rows);\n         if (status == MagickFalse)\n           break;\n       }\n   }\n   SetQuantumImageType(image,quantum_type);\n   quantum_info=DestroyQuantumInfo(quantum_info);\n   if (EOFBlob(image) != MagickFalse)\n     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n       image->filename);\n   SetImageColorspace(image,LogColorspace,exception);\n   (void) CloseBlob(image);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n  if (cin.file.image_offset < 712)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-28463", "cve_desc": "ImageMagick 7.1.0-27 is vulnerable to Buffer Overflow.", "project": "ImageMagick", "idx": 210252}
{"source": " sug_filltree(spellinfo_T *spin, slang_T *slang)\n {\n     char_u\t*byts;\n     idx_T\t*idxs;\n     int\t\tdepth;\n     idx_T\tarridx[MAXWLEN];\n     int\t\tcuri[MAXWLEN];\n     char_u\ttword[MAXWLEN];\n     char_u\ttsalword[MAXWLEN];\n     int\t\tc;\n     idx_T\tn;\n     unsigned\twords_done = 0;\n     int\t\twordcount[MAXWLEN];\n \n     spin->si_foldroot = wordtree_alloc(spin);\n     if (spin->si_foldroot == NULL)\n \treturn FAIL;\n \n     spin->si_sugtree = TRUE;\n \n     byts = slang->sl_fbyts;\n     idxs = slang->sl_fidxs;\n// bug_start\n// bug_end\n \n     arridx[0] = 0;\n     curi[0] = 1;\n     wordcount[0] = 0;\n \n     depth = 0;\n     while (depth >= 0 && !got_int)\n     {\n \tif (curi[depth] > byts[arridx[depth]])\n \t{\n \t    idxs[arridx[depth]] = wordcount[depth];\n \t    if (depth > 0)\n \t\twordcount[depth - 1] += wordcount[depth];\n \n \t    --depth;\n \t    line_breakcheck();\n \t}\n \telse\n \t{\n \n \t    n = arridx[depth] + curi[depth];\n \t    ++curi[depth];\n \n \t    c = byts[n];\n \t    if (c == 0)\n \t    {\n \t\ttword[depth] = NUL;\n \t\tspell_soundfold(slang, tword, TRUE, tsalword);\n \n \t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n \t\t\t\twords_done >> 16, words_done & 0xffff,\n \t\t\t\t\t\t\t   0) == FAIL)\n \t\t    return FAIL;\n \n \t\t++words_done;\n \t\t++wordcount[depth];\n \n \t\tspin->si_blocks_cnt = 0;\n \n \t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n \t\t{\n \t\t    ++n;\n \t\t    ++curi[depth];\n \t\t}\n \t    }\n \t    else\n \t    {\n \t\ttword[depth++] = c;\n \t\tarridx[depth] = idxs[n];\n \t\tcuri[depth] = 1;\n \t\twordcount[depth] = 0;\n \t    }\n \t}\n     }\n \n     smsg(_(\"Total number of words: %d\"), words_done);\n \n     return OK;\n }\n \n", "target": "// fix_start\n    if (byts == NULL || idxs == NULL)\n\treturn FAIL;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2923", "cve_desc": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0240.", "project": "vim", "idx": 210271}
{"source": " createRandomCursorExecutor(const CollectionPtr& coll,\n                            const boost::intrusive_ptr<ExpressionContext>& expCtx,\n                            long long sampleSize,\n                            long long numRecords,\n                            boost::optional<BucketUnpacker> bucketUnpacker) {\n     OperationContext* opCtx = expCtx->opCtx;\n \n     invariant(opCtx->lockState()->isCollectionLockedForMode(coll->ns(), MODE_IS));\n \n     static const double kMaxSampleRatioForRandCursor = 0.05;\n     if (!expCtx->ns.isTimeseriesBucketsCollection()) {\n         if (sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100) {\n             return std::pair{nullptr, false};\n         }\n     } else {\n         static const double kCoefficient = 0.01;\n         if (sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount) {\n             return std::pair{nullptr, false};\n         }\n     }\n \n     auto rsRandCursor = coll->getRecordStore()->getRandomCursor(opCtx);\n     if (!rsRandCursor) {\n         return std::pair{nullptr, false};\n     }\n \n     auto ws = std::make_unique<WorkingSet>();\n     std::unique_ptr<PlanStage> root =\n         std::make_unique<MultiIteratorStage>(expCtx.get(), ws.get(), coll);\n     static_cast<MultiIteratorStage*>(root.get())->addIterator(std::move(rsRandCursor));\n \n// bug_start\n    auto collectionFilter =\n        CollectionShardingState::get(opCtx, coll->ns())\n            ->getOwnershipFilter(\n                opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);\n\n// bug_end\n     TrialStage* trialStage = nullptr;\n \n     static const size_t kMaxPresampleSize = 100;\n// bug_start\n    if (collectionFilter.isSharded() && !expCtx->ns.isTimeseriesBucketsCollection()) {\n// bug_end\n         const auto minAdvancedToWorkRatio = std::max(\n             sampleSize / (numRecords * kMaxSampleRatioForRandCursor), kMaxSampleRatioForRandCursor);\n// bug_start\n// bug_end\n         auto randomCursorPlan = std::make_unique<ShardFilterStage>(\n             expCtx.get(), collectionFilter, ws.get(), std::move(root));\n         std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n         collScanPlan = std::make_unique<ShardFilterStage>(\n             expCtx.get(), collectionFilter, ws.get(), std::move(collScanPlan));\n         root = std::make_unique<TrialStage>(expCtx.get(),\n                                             ws.get(),\n                                             std::move(randomCursorPlan),\n                                             std::move(collScanPlan),\n                                             kMaxPresampleSize,\n                                             minAdvancedToWorkRatio);\n         trialStage = static_cast<TrialStage*>(root.get());\n     } else if (expCtx->ns.isTimeseriesBucketsCollection()) {\n         if (!(bucketUnpacker && numRecords)) {\n             return std::pair{nullptr, false};\n         }\n \n         static const auto kCoefficient = 0.02;\n         static const auto kMinBucketFullness = 0.25;\n         const auto minAdvancedToWorkRatio = std::max(\n             std::min(sampleSize / (kCoefficient * numRecords * gTimeseriesBucketMaxCount), 1.0),\n             kMinBucketFullness);\n \n         auto arhashPlan = std::make_unique<SampleFromTimeseriesBucket>(\n             expCtx.get(),\n             ws.get(),\n             std::move(root),\n             *bucketUnpacker,\n             kMaxPresampleSize + 5,\n             sampleSize,\n             gTimeseriesBucketMaxCount);\n \n         std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n \n         auto topkSortPlan = std::make_unique<UnpackTimeseriesBucket>(\n             expCtx.get(), ws.get(), std::move(collScanPlan), *bucketUnpacker);\n \n         root = std::make_unique<TrialStage>(expCtx.get(),\n                                             ws.get(),\n                                             std::move(arhashPlan),\n                                             std::move(topkSortPlan),\n                                             kMaxPresampleSize,\n                                             minAdvancedToWorkRatio);\n         trialStage = static_cast<TrialStage*>(root.get());\n     }\n \n     auto execStatus = plan_executor_factory::make(expCtx,\n                                                   std::move(ws),\n                                                   std::move(root),\n                                                   &coll,\n                                                   opCtx->inMultiDocumentTransaction()\n                                                       ? PlanYieldPolicy::YieldPolicy::INTERRUPT_ONLY\n                                                       : PlanYieldPolicy::YieldPolicy::YIELD_AUTO,\n                                                   QueryPlannerParams::RETURN_OWNED_DATA);\n     if (!execStatus.isOK()) {\n         return execStatus.getStatus();\n     }\n \n     return std::pair{std::move(execStatus.getValue()),\n                      !trialStage || !trialStage->pickedBackupPlan()};\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    if (auto css = CollectionShardingState::get(opCtx, coll->ns());\n        css->getCollectionDescription(opCtx).isSharded() &&\n        !expCtx->ns.isTimeseriesBucketsCollection()) {\n// fix_end\n// fix_start\n        auto collectionFilter = css->getOwnershipFilter(\n            opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2021-32037", "cve_desc": "An authorized user may trigger an invariant which may result in denial of service or server exit if a relevant aggregation request is sent to a shard. Usually, the requests are sent via mongos and special privileges are required in order to know the address of the shards and to log in to the shards of an auth enabled environment.", "project": "mongo", "idx": 210273}
{"source": " void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n {\n     if (!block) {\n         return;\n     }\n \n \n// bug_start\n    QLIST_REMOVE(block, next);\n// bug_end\n     uc->ram_list.mru_block = NULL;\n     reclaim_ramblock(uc, block);\n }\n \n", "target": "// fix_start\n    QLIST_REMOVE_RCU(block, next);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-29694", "cve_desc": "Unicorn Engine v2.0.0-rc7 and below was discovered to contain a NULL pointer dereference via qemu_ram_free.", "project": "unicorn", "idx": 210278}
{"source": " static int i2c_ddc_rx(I2CSlave *i2c)\n {\n     I2CDDCState *s = I2CDDC(i2c);\n \n     int value;\n// bug_start\n    value = s->edid_blob[s->reg];\n// bug_end\n     s->reg++;\n     return value;\n }\n \n", "target": "// fix_start\n    value = s->edid_blob[s->reg % sizeof(s->edid_blob)];\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-3812", "cve_desc": "QEMU, through version 2.10 and through version 3.1.0, is vulnerable to an out-of-bounds read of up to 128 bytes in the hw/i2c/i2c-ddc.c:i2c_ddc() function. A local attacker with permission to execute i2c commands could exploit this to read stack memory of the qemu process on the host.", "project": "qemu", "idx": 210282}
{"source": " vhost_user_set_inflight_fd(struct virtio_net **pdev,\n \t\t\t   struct vhu_msg_context *ctx,\n \t\t\t   int main_fd __rte_unused)\n {\n \tuint64_t mmap_size, mmap_offset;\n \tuint16_t num_queues, queue_size;\n \tstruct virtio_net *dev = *pdev;\n \tuint32_t pervq_inflight_size;\n \tstruct vhost_virtqueue *vq;\n \tvoid *addr;\n \tint fd, i;\n \tint numa_node = SOCKET_ID_ANY;\n// bug_start\n// bug_end\n \n \tfd = ctx->fds[0];\n \tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight) || fd < 0) {\n \t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid set_inflight_fd message size is %d,fd is %d\\n\",\n \t\t\tdev->ifname, ctx->msg.size, fd);\n \t\treturn RTE_VHOST_MSG_RESULT_ERR;\n \t}\n \n \tmmap_size = ctx->msg.payload.inflight.mmap_size;\n \tmmap_offset = ctx->msg.payload.inflight.mmap_offset;\n \tnum_queues = ctx->msg.payload.inflight.num_queues;\n \tqueue_size = ctx->msg.payload.inflight.queue_size;\n \n \tif (vq_is_packed(dev))\n \t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n \telse\n \t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n \n \tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd mmap_size: %\"PRIu64\"\\n\",\n \t\t\tdev->ifname, mmap_size);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd mmap_offset: %\"PRIu64\"\\n\",\n \t\t\tdev->ifname, mmap_offset);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd num_queues: %u\\n\", dev->ifname, num_queues);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd queue_size: %u\\n\", dev->ifname, queue_size);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd fd: %d\\n\", dev->ifname, fd);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd pervq_inflight_size: %d\\n\",\n \t\t\tdev->ifname, pervq_inflight_size);\n \n \tif (dev->nr_vring > 0)\n \t\tnuma_node = dev->virtqueue[0]->numa_node;\n \n \tif (!dev->inflight_info) {\n \t\tdev->inflight_info = rte_zmalloc_socket(\"inflight_info\",\n \t\t\t\tsizeof(struct inflight_mem_info), 0, numa_node);\n \t\tif (dev->inflight_info == NULL) {\n \t\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc dev inflight area\\n\",\n \t\t\t\t\tdev->ifname);\n \t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n \t\t}\n \t\tdev->inflight_info->fd = -1;\n \t}\n \n \tif (dev->inflight_info->addr) {\n \t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n \t\tdev->inflight_info->addr = NULL;\n \t}\n \n \taddr = mmap(0, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n \t\t    fd, mmap_offset);\n \tif (addr == MAP_FAILED) {\n \t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to mmap share memory.\\n\", dev->ifname);\n \t\treturn RTE_VHOST_MSG_RESULT_ERR;\n \t}\n \n \tif (dev->inflight_info->fd >= 0) {\n \t\tclose(dev->inflight_info->fd);\n \t\tdev->inflight_info->fd = -1;\n \t}\n \n \tdev->inflight_info->fd = fd;\n \tdev->inflight_info->addr = addr;\n \tdev->inflight_info->size = mmap_size;\n \n \tfor (i = 0; i < num_queues; i++) {\n \t\tvq = dev->virtqueue[i];\n \t\tif (!vq)\n \t\t\tcontinue;\n \n \t\tif (vq_is_packed(dev)) {\n \t\t\tvq->inflight_packed = addr;\n \t\t\tvq->inflight_packed->desc_num = queue_size;\n \t\t} else {\n \t\t\tvq->inflight_split = addr;\n \t\t\tvq->inflight_split->desc_num = queue_size;\n \t\t}\n \t\taddr = (void *)((char *)addr + pervq_inflight_size);\n \t}\n \n \treturn RTE_VHOST_MSG_RESULT_OK;\n }\n \n", "target": "// fix_start\n\n\tif (validate_msg_fds(dev, ctx, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-0669", "cve_desc": "A flaw was found in dpdk. This flaw allows a malicious vhost-user master to attach an unexpected number of fds as ancillary data to VHOST_USER_GET_INFLIGHT_FD / VHOST_USER_SET_INFLIGHT_FD messages that are not closed by the vhost-user slave. By sending such messages continuously, the vhost-user master exhausts available fd in the vhost-user slave process, leading to a denial of service.", "project": "dpdk", "idx": 210283}
{"source": " vhost_user_get_inflight_fd(struct virtio_net **pdev,\n \t\t\t   struct vhu_msg_context *ctx,\n \t\t\t   int main_fd __rte_unused)\n {\n \tstruct rte_vhost_inflight_info_packed *inflight_packed;\n \tuint64_t pervq_inflight_size, mmap_size;\n \tuint16_t num_queues, queue_size;\n \tstruct virtio_net *dev = *pdev;\n \tint fd, i, j;\n \tint numa_node = SOCKET_ID_ANY;\n \tvoid *addr;\n// bug_start\n// bug_end\n \n \tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight)) {\n \t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid get_inflight_fd message size is %d\\n\",\n \t\t\tdev->ifname, ctx->msg.size);\n \t\treturn RTE_VHOST_MSG_RESULT_ERR;\n \t}\n \n \tif (dev->nr_vring > 0)\n \t\tnuma_node = dev->virtqueue[0]->numa_node;\n \n \tif (dev->inflight_info == NULL) {\n \t\tdev->inflight_info = rte_zmalloc_socket(\"inflight_info\",\n \t\t\t\tsizeof(struct inflight_mem_info), 0, numa_node);\n \t\tif (!dev->inflight_info) {\n \t\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc dev inflight area\\n\",\n \t\t\t\t\tdev->ifname);\n \t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n \t\t}\n \t\tdev->inflight_info->fd = -1;\n \t}\n \n \tnum_queues = ctx->msg.payload.inflight.num_queues;\n \tqueue_size = ctx->msg.payload.inflight.queue_size;\n \n \tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd num_queues: %u\\n\",\n \t\tdev->ifname, ctx->msg.payload.inflight.num_queues);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd queue_size: %u\\n\",\n \t\tdev->ifname, ctx->msg.payload.inflight.queue_size);\n \n \tif (vq_is_packed(dev))\n \t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n \telse\n \t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n \n \tmmap_size = num_queues * pervq_inflight_size;\n \taddr = inflight_mem_alloc(dev, \"vhost-inflight\", mmap_size, &fd);\n \tif (!addr) {\n \t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc vhost inflight area\\n\", dev->ifname);\n \t\t\tctx->msg.payload.inflight.mmap_size = 0;\n \t\treturn RTE_VHOST_MSG_RESULT_ERR;\n \t}\n \tmemset(addr, 0, mmap_size);\n \n \tif (dev->inflight_info->addr) {\n \t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n \t\tdev->inflight_info->addr = NULL;\n \t}\n \n \tif (dev->inflight_info->fd >= 0) {\n \t\tclose(dev->inflight_info->fd);\n \t\tdev->inflight_info->fd = -1;\n \t}\n \n \tdev->inflight_info->addr = addr;\n \tdev->inflight_info->size = ctx->msg.payload.inflight.mmap_size = mmap_size;\n \tdev->inflight_info->fd = ctx->fds[0] = fd;\n \tctx->msg.payload.inflight.mmap_offset = 0;\n \tctx->fd_num = 1;\n \n \tif (vq_is_packed(dev)) {\n \t\tfor (i = 0; i < num_queues; i++) {\n \t\t\tinflight_packed =\n \t\t\t\t(struct rte_vhost_inflight_info_packed *)addr;\n \t\t\tinflight_packed->used_wrap_counter = 1;\n \t\t\tinflight_packed->old_used_wrap_counter = 1;\n \t\t\tfor (j = 0; j < queue_size; j++)\n \t\t\t\tinflight_packed->desc[j].next = j + 1;\n \t\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n \t\t}\n \t}\n \n \tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_size: %\"PRIu64\"\\n\",\n \t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_size);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_offset: %\"PRIu64\"\\n\",\n \t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_offset);\n \tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight fd: %d\\n\", dev->ifname, ctx->fds[0]);\n \n \treturn RTE_VHOST_MSG_RESULT_REPLY;\n }\n \n", "target": "// fix_start\n\n\tif (validate_msg_fds(dev, ctx, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-0669", "cve_desc": "A flaw was found in dpdk. This flaw allows a malicious vhost-user master to attach an unexpected number of fds as ancillary data to VHOST_USER_GET_INFLIGHT_FD / VHOST_USER_SET_INFLIGHT_FD messages that are not closed by the vhost-user slave. By sending such messages continuously, the vhost-user master exhausts available fd in the vhost-user slave process, leading to a denial of service.", "project": "dpdk", "idx": 210284}
{"source": " do_arg_all(\n     int\tcount,\n     int\tforceit,\n     int keep_tabs)\n {\n     int\t\ti;\n     win_T\t*wp, *wpnext;\n     char_u\t*opened;\n     int\t\topened_len;\n     int\t\tuse_firstwin = FALSE;\n     int\t\ttab_drop_empty_window = FALSE;\n     int\t\tsplit_ret = OK;\n     int\t\tp_ea_save;\n     alist_T\t*alist;\n     buf_T\t*buf;\n     tabpage_T\t*tpnext;\n     int\t\thad_tab = cmdmod.cmod_tab;\n     win_T\t*old_curwin, *last_curwin;\n     tabpage_T\t*old_curtab, *last_curtab;\n     win_T\t*new_curwin = NULL;\n     tabpage_T\t*new_curtab = NULL;\n// bug_start\n// bug_end\n \n #ifdef FEAT_CMDWIN\n     if (cmdwin_type != 0)\n     {\n \temsg(_(e_invalid_in_cmdline_window));\n \treturn;\n     }\n #endif\n     if (ARGCOUNT <= 0)\n     {\n \treturn;\n     }\n     setpcmark();\n \n     opened_len = ARGCOUNT;\n     opened = alloc_clear(opened_len);\n     if (opened == NULL)\n \treturn;\n \n     alist = curwin->w_alist;\n     ++alist->al_refcount;\n// bug_start\n// bug_end\n \n     old_curwin = curwin;\n     old_curtab = curtab;\n \n # ifdef FEAT_GUI\n     need_mouse_correct = TRUE;\n # endif\n \n     if (had_tab > 0)\n \tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n     for (;;)\n     {\n \ttpnext = curtab->tp_next;\n \tfor (wp = firstwin; wp != NULL; wp = wpnext)\n \t{\n \t    wpnext = wp->w_next;\n \t    buf = wp->w_buffer;\n \t    if (buf->b_ffname == NULL\n \t\t    || (!keep_tabs && (buf->b_nwindows > 1\n \t\t\t    || wp->w_width != Columns)))\n \t\ti = opened_len;\n \t    else\n \t    {\n \t\tfor (i = 0; i < opened_len; ++i)\n \t\t{\n \t\t    if (i < alist->al_ga.ga_len\n \t\t\t    && (AARGLIST(alist)[i].ae_fnum == buf->b_fnum\n \t\t\t\t|| fullpathcmp(alist_name(&AARGLIST(alist)[i]),\n \t\t\t\t\tbuf->b_ffname, TRUE, TRUE) & FPC_SAME))\n \t\t    {\n \t\t\tint weight = 1;\n \n \t\t\tif (old_curtab == curtab)\n \t\t\t{\n \t\t\t    ++weight;\n \t\t\t    if (old_curwin == wp)\n \t\t\t\t++weight;\n \t\t\t}\n \n \t\t\tif (weight > (int)opened[i])\n \t\t\t{\n \t\t\t    opened[i] = (char_u)weight;\n \t\t\t    if (i == 0)\n \t\t\t    {\n \t\t\t\tif (new_curwin != NULL)\n \t\t\t\t    new_curwin->w_arg_idx = opened_len;\n \t\t\t\tnew_curwin = wp;\n \t\t\t\tnew_curtab = curtab;\n \t\t\t    }\n \t\t\t}\n \t\t\telse if (keep_tabs)\n \t\t\t    i = opened_len;\n \n \t\t\tif (wp->w_alist != alist)\n \t\t\t{\n \t\t\t    alist_unlink(wp->w_alist);\n \t\t\t    wp->w_alist = alist;\n \t\t\t    ++wp->w_alist->al_refcount;\n \t\t\t}\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \t    }\n \t    wp->w_arg_idx = i;\n \n \t    if (i == opened_len && !keep_tabs)\n \t    {\n \t\tif (buf_hide(buf) || forceit || buf->b_nwindows > 1\n \t\t\t\t\t\t\t|| !bufIsChanged(buf))\n \t\t{\n \t\t    if (!buf_hide(buf) && buf->b_nwindows <= 1\n \t\t\t\t\t\t\t && bufIsChanged(buf))\n \t\t    {\n \t\t\tbufref_T    bufref;\n \n \t\t\tset_bufref(&bufref, buf);\n \n \t\t\t(void)autowrite(buf, FALSE);\n \n \t\t\tif (!win_valid(wp) || !bufref_valid(&bufref))\n \t\t\t{\n \t\t\t    wpnext = firstwin;\n \t\t\t    continue;\n \t\t\t}\n \t\t    }\n \t\t    if (ONE_WINDOW\n \t\t\t    && (first_tabpage->tp_next == NULL || !had_tab))\n \t\t\tuse_firstwin = TRUE;\n \t\t    else\n \t\t    {\n \t\t\twin_close(wp, !buf_hide(buf) && !bufIsChanged(buf));\n \n \t\t\tif (!win_valid(wpnext))\n \t\t\t    wpnext = firstwin;\n \t\t    }\n \t\t}\n \t    }\n \t}\n \n \tif (had_tab == 0 || tpnext == NULL)\n \t    break;\n \n \tif (!valid_tabpage(tpnext))\n \t    tpnext = first_tabpage;\n \n \tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n     }\n \n     if (count > opened_len || count <= 0)\n \tcount = opened_len;\n \n     ++autocmd_no_enter;\n     ++autocmd_no_leave;\n     last_curwin = curwin;\n     last_curtab = curtab;\n     win_enter(lastwin, FALSE);\n     if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1\n \t\t\t    && curbuf->b_ffname == NULL && !curbuf->b_changed)\n     {\n \tuse_firstwin = TRUE;\n \ttab_drop_empty_window = TRUE;\n     }\n \n     for (i = 0; i < count && !got_int; ++i)\n     {\n \tif (alist == &global_alist && i == global_alist.al_ga.ga_len - 1)\n \t    arg_had_last = TRUE;\n \tif (opened[i] > 0)\n \t{\n \t    if (curwin->w_arg_idx != i)\n \t    {\n \t\tFOR_ALL_WINDOWS(wpnext)\n \t\t{\n \t\t    if (wpnext->w_arg_idx == i)\n \t\t    {\n \t\t\tif (keep_tabs)\n \t\t\t{\n \t\t\t    new_curwin = wpnext;\n \t\t\t    new_curtab = curtab;\n \t\t\t}\n \t\t\telse if (wpnext->w_frame->fr_parent\n \t\t\t\t\t\t != curwin->w_frame->fr_parent)\n \t\t\t{\n \t\t\t    emsg(_(\"E249: window layout changed unexpectedly\"));\n \t\t\t    i = count;\n \t\t\t    break;\n \t\t\t}\n \t\t\telse\n \t\t\t    win_move_after(wpnext, curwin);\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \t    }\n \t}\n \telse if (split_ret == OK)\n \t{\n \t    if (tab_drop_empty_window && i == count - 1)\n \t\t--autocmd_no_enter;\n \t    if (!use_firstwin)\n \t    {\n \t\tp_ea_save = p_ea;\n \t\tp_ea = TRUE;\n \t\tsplit_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n \t\tp_ea = p_ea_save;\n \t\tif (split_ret == FAIL)\n \t\t    continue;\n \t    }\n \t    else\n \t\t--autocmd_no_leave;\n \n \t    curwin->w_arg_idx = i;\n \t    if (i == 0)\n \t    {\n \t\tnew_curwin = curwin;\n \t\tnew_curtab = curtab;\n \t    }\n \t    (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL,\n \t\t      ECMD_ONE,\n \t\t      ((buf_hide(curwin->w_buffer)\n \t\t\t   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)\n \t\t\t\t\t\t       + ECMD_OLDBUF, curwin);\n \t    if (tab_drop_empty_window && i == count - 1)\n \t\t++autocmd_no_enter;\n \t    if (use_firstwin)\n \t\t++autocmd_no_leave;\n \t    use_firstwin = FALSE;\n \t}\n \tui_breakcheck();\n \n \tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n \t    cmdmod.cmod_tab = 9999;\n     }\n \n     alist_unlink(alist);\n// bug_start\n// bug_end\n \n     --autocmd_no_enter;\n \n     if (last_curtab != new_curtab)\n     {\n \tif (valid_tabpage(last_curtab))\n \t    goto_tabpage_tp(last_curtab, TRUE, TRUE);\n \tif (win_valid(last_curwin))\n \t    win_enter(last_curwin, FALSE);\n     }\n     if (valid_tabpage(new_curtab))\n \tgoto_tabpage_tp(new_curtab, TRUE, TRUE);\n     if (win_valid(new_curwin))\n \twin_enter(new_curwin, FALSE);\n \n     --autocmd_no_leave;\n     vim_free(opened);\n }\n \n", "target": "// fix_start\n    int\t\tprev_arglist_locked = arglist_locked;\n// fix_end\n// fix_start\n    arglist_locked = TRUE;\n// fix_end\n// fix_start\n    arglist_locked = prev_arglist_locked;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-4166", "cve_desc": "vim is vulnerable to Out-of-bounds Read", "project": "vim", "idx": 210393}
{"source": "// bug_start\nfill_threshhold_buffer(byte *dest_strip, byte *src_strip, int src_width,\n// bug_end\n                        int left_offset, int left_width, int num_tiles,\n                        int right_width)\n {\n     byte *ptr_out_temp = dest_strip;\n     int ii;\n \n     memcpy(dest_strip, src_strip + left_offset, left_width);\n     ptr_out_temp += left_width;\n     for (ii = 0; ii < num_tiles; ii++){\n         memcpy(ptr_out_temp, src_strip, src_width);\n         ptr_out_temp += src_width;\n     }\n     memcpy(ptr_out_temp, src_strip, right_width);\n #ifdef PACIFY_VALGRIND\n     ptr_out_temp += right_width;\n     ii = (dest_strip-ptr_out_temp) % (LAND_BITS-1);\n     if (ii > 0)\n         memset(ptr_out_temp, 0, ii);\n #endif\n }\n \n", "target": "// fix_start\nfill_threshold_buffer(byte *dest_strip, byte *src_strip, int src_width,\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2016-10317", "cve_desc": "The fill_threshhold_buffer function in base/gxht_thresh.c in Artifex Software, Inc. Ghostscript 9.20 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted PostScript document.", "project": "ghostpdl", "idx": 210420}
{"source": " jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n {\n #define DATA_SIZE (LINE_SIZE * 8)\n \n     unsigned int cnt_2prn;\n     unsigned int count,tempcnt;\n     unsigned char vtp,cntc1,cntc2;\n     int line_size_color_plane;\n \n     byte data[DATA_SIZE];\n     byte plane_data[LINE_SIZE * 3];\n// bug_start\n// bug_end\n \n     gp_fputs(\"\\033@\",prn_stream);\n \n     {\n         int lnum;\n         int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n         int num_blank_lines = 0;\n \n         if (line_size > DATA_SIZE) {\n             emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                       line_size, DATA_SIZE);\n             return_error(gs_error_rangecheck);\n         }\n \n         for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n             byte *end_data = data + line_size;\n             gdev_prn_copy_scan_lines(pdev, lnum,\n                                      (byte *)data, line_size);\n             while ( end_data > data && end_data[-1] == 0 )\n                 end_data--;\n             if ( end_data == data ) {\n                 num_blank_lines++;\n             } else {\n                 int i;\n                 byte *odp;\n                 byte *row;\n// bug_start\n\n                memset(end_data, 0, 7);\n// bug_end\n \n                 for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                       i += 8, odp++\n                     ) {\n #define spread3(c)\\\n  { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                     static ulong spr40[8] = spread3(0x40);\n                     static ulong spr8[8] = spread3(8);\n                     static ulong spr2[8] = spread3(2);\n                     register byte *dp = data + i;\n                     register ulong pword =\n                                      (spr40[dp[0]] << 1) +\n                                      (spr40[dp[1]]) +\n                                      (spr40[dp[2]] >> 1) +\n                                      (spr8[dp[3]] << 1) +\n                                      (spr8[dp[4]]) +\n                                      (spr8[dp[5]] >> 1) +\n                                      (spr2[dp[6]]) +\n                                      (spr2[dp[7]] >> 1);\n                     odp[0] = (byte)(pword >> 16);\n                     odp[LINE_SIZE] = (byte)(pword >> 8);\n                     odp[LINE_SIZE*2] = (byte)(pword);\n                 }\n                 if ( num_blank_lines > 0 ) {\n                     while(num_blank_lines > 255) {\n                         gp_fputs(\"\\033e\\377\",prn_stream);\n                         num_blank_lines -= 255;\n                     }\n                     vtp = num_blank_lines;\n                     gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                     num_blank_lines = 0;\n                 }\n \n \n                 count = line_size / 3;\n                 line_size_color_plane = count / 3;\n                 cnt_2prn = line_size_color_plane * 3 + 5;\n                 tempcnt = cnt_2prn;\n                 cntc1 = (tempcnt & 0xFF00) >> 8;\n                 cntc2 = (tempcnt & 0x00FF);\n                 gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                 gp_fputc('\\000',prn_stream);\n                 gp_fputs(\"\\124\\124\",prn_stream);\n \n                 for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                       i < 3; row -= LINE_SIZE, i++ ) {\n                     int jj;\n                     byte ctemp;\n                     odp = row;\n                     for (jj=0; jj< line_size_color_plane; jj++) {\n                         ctemp = *odp;\n                         *odp++ = ~ctemp;\n                     }\n                     gp_fwrite(row, sizeof(byte),\n                               line_size_color_plane, prn_stream);\n                 }\n             }\n         }\n     }\n \n     gp_fputs(\"\\014\", prn_stream);\n \n     return 0;\n }\n \n", "target": "// fix_start\n\n    memset(data, 0x00, DATA_SIZE);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2020-16302", "cve_desc": "A buffer overflow vulnerability in jetp3852_print_page() in devices/gdev3852.c of Artifex Software GhostScript v9.50 allows a remote attacker to escalate privileges via a crafted PDF file. This is fixed in v9.51.", "project": "ghostpdl", "idx": 210453}
{"source": " static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n {\n \tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n \tstruct kiocb *kiocb = &req->rw.kiocb;\n \tstruct iov_iter __iter, *iter = &__iter;\n \tstruct io_async_rw *rw = req->async_data;\n \tssize_t io_size, ret, ret2;\n \tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n \n \tif (rw) {\n \t\titer = &rw->iter;\n \t\tiovec = NULL;\n \t} else {\n \t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n \t\tif (ret < 0)\n \t\t\treturn ret;\n \t}\n \tio_size = iov_iter_count(iter);\n \treq->result = io_size;\n \n \tif (!force_nonblock)\n \t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n \telse\n \t\tkiocb->ki_flags |= IOCB_NOWAIT;\n \n \tif (force_nonblock && !io_file_supports_async(req, READ)) {\n \t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n \t\treturn ret ?: -EAGAIN;\n \t}\n \n \tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n \tif (unlikely(ret)) {\n \t\tkfree(iovec);\n \t\treturn ret;\n \t}\n \n \tret = io_iter_do_read(req, iter);\n \n \tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n \t\treq->flags &= ~REQ_F_REISSUE;\n \t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n \t\t\tgoto done;\n \t\tif (req->flags & REQ_F_NOWAIT)\n \t\t\tgoto done;\n// bug_start\n// bug_end\n \t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n \t\tret = 0;\n \t} else if (ret == -EIOCBQUEUED) {\n \t\tgoto out_free;\n \t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n \t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n \t\tgoto done;\n \t}\n \n \tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n \tif (ret2)\n \t\treturn ret2;\n \n \tiovec = NULL;\n \trw = req->async_data;\n \titer = &rw->iter;\n \n \tdo {\n \t\tio_size -= ret;\n \t\trw->bytes_done += ret;\n \t\tif (!io_rw_should_retry(req)) {\n \t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n \t\t\treturn -EAGAIN;\n \t\t}\n \n \t\tret = io_iter_do_read(req, iter);\n \t\tif (ret == -EIOCBQUEUED)\n \t\t\treturn 0;\n \t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n \t} while (ret > 0 && ret < io_size);\n done:\n \tkiocb_done(kiocb, ret, issue_flags);\n out_free:\n \tif (iovec)\n \t\tkfree(iovec);\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tiov_iter_reexpand(iter, iter->count + iter->truncated);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-1508", "cve_desc": "An out-of-bounds read flaw was found in the Linux kernel\u2019s io_uring module in the way a user triggers the io_read() function with some special parameters. This flaw allows a local user to read some memory out of bounds.", "project": "linux", "idx": 210484}
{"source": " get_lisp_indent(void)\n {\n     pos_T\t*pos, realpos, paren;\n     int\t\tamount;\n     char_u\t*that;\n     colnr_T\tcol;\n     colnr_T\tfirsttry;\n     int\t\tparencount, quotecount;\n     int\t\tvi_lisp;\n \n     vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n \n     realpos = curwin->w_cursor;\n     curwin->w_cursor.col = 0;\n \n     if ((pos = findmatch(NULL, '(')) == NULL)\n \tpos = findmatch(NULL, '[');\n     else\n     {\n \tparen = *pos;\n \tpos = findmatch(NULL, '[');\n \tif (pos == NULL || LT_POSP(pos, &paren))\n \t    pos = &paren;\n     }\n     if (pos != NULL)\n     {\n \tamount = -1;\n \tparencount = 0;\n \n \twhile (--curwin->w_cursor.lnum >= pos->lnum)\n \t{\n \t    if (linewhite(curwin->w_cursor.lnum))\n \t\tcontinue;\n \t    for (that = ml_get_curline(); *that != NUL; ++that)\n \t    {\n \t\tif (*that == ';')\n \t\t{\n \t\t    while (*(that + 1) != NUL)\n \t\t\t++that;\n \t\t    continue;\n \t\t}\n \t\tif (*that == '\\\\')\n \t\t{\n \t\t    if (*(that + 1) != NUL)\n \t\t\t++that;\n \t\t    continue;\n \t\t}\n \t\tif (*that == '\"' && *(that + 1) != NUL)\n \t\t{\n \t\t    while (*++that && *that != '\"')\n \t\t    {\n \t\t\tif (*that == '\\\\')\n \t\t\t{\n \t\t\t    if (*++that == NUL)\n \t\t\t\tbreak;\n \t\t\t    if (that[1] == NUL)\n \t\t\t    {\n \t\t\t\t++that;\n \t\t\t\tbreak;\n \t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t    if (*that == NUL)\n \t\t\tbreak;\n \t\t}\n \t\tif (*that == '(' || *that == '[')\n \t\t    ++parencount;\n \t\telse if (*that == ')' || *that == ']')\n \t\t    --parencount;\n \t    }\n \t    if (parencount == 0)\n \t    {\n \t\tamount = get_indent();\n \t\tbreak;\n \t    }\n \t}\n \n \tif (amount == -1)\n \t{\n \t    curwin->w_cursor.lnum = pos->lnum;\n \t    curwin->w_cursor.col = pos->col;\n \t    col = pos->col;\n \n \t    that = ml_get_curline();\n \n \t    if (vi_lisp && get_indent() == 0)\n \t\tamount = 2;\n \t    else\n \t    {\n \t\tchar_u *line = that;\n \n \t\tamount = 0;\n \t\twhile (*that && col)\n \t\t{\n \t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n \t\t    col--;\n \t\t}\n \n \n \t\tif (!vi_lisp && (*that == '(' || *that == '[')\n \t\t\t\t\t\t      && lisp_match(that + 1))\n \t\t    amount += 2;\n \t\telse\n \t\t{\n// bug_start\n\t\t    that++;\n\t\t    amount++;\n// bug_end\n \t\t    firsttry = amount;\n \n \t\t    while (VIM_ISWHITE(*that))\n \t\t    {\n \t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n \t\t\t++that;\n \t\t    }\n \n \t\t    if (*that && *that != ';')\n \t\t    {\n \t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n \t\t\t    firsttry++;\n \n \t\t\tparencount = 0;\n \t\t\tquotecount = 0;\n \n \t\t\tif (vi_lisp\n \t\t\t\t|| (*that != '\"'\n \t\t\t\t    && *that != '\\''\n \t\t\t\t    && *that != '#'\n \t\t\t\t    && (*that < '0' || *that > '9')))\n \t\t\t{\n \t\t\t    while (*that\n \t\t\t\t    && (!VIM_ISWHITE(*that)\n \t\t\t\t\t|| quotecount\n \t\t\t\t\t|| parencount)\n \t\t\t\t    && (!((*that == '(' || *that == '[')\n \t\t\t\t\t    && !quotecount\n \t\t\t\t\t    && !parencount\n \t\t\t\t\t    && vi_lisp)))\n \t\t\t    {\n \t\t\t\tif (*that == '\"')\n \t\t\t\t    quotecount = !quotecount;\n \t\t\t\tif ((*that == '(' || *that == '[')\n \t\t\t\t\t\t\t       && !quotecount)\n \t\t\t\t    ++parencount;\n \t\t\t\tif ((*that == ')' || *that == ']')\n \t\t\t\t\t\t\t       && !quotecount)\n \t\t\t\t    --parencount;\n \t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n \t\t\t\t    amount += lbr_chartabsize_adv(\n \t\t\t\t\t\tline, &that, (colnr_T)amount);\n \t\t\t\tamount += lbr_chartabsize_adv(\n \t\t\t\t\t\tline, &that, (colnr_T)amount);\n \t\t\t    }\n \t\t\t}\n \t\t\twhile (VIM_ISWHITE(*that))\n \t\t\t{\n \t\t\t    amount += lbr_chartabsize(\n \t\t\t\t\t\t line, that, (colnr_T)amount);\n \t\t\t    that++;\n \t\t\t}\n \t\t\tif (!*that || *that == ';')\n \t\t\t    amount = firsttry;\n \t\t    }\n \t\t}\n \t    }\n \t}\n     }\n     else\n \tamount = 0;\n \n     curwin->w_cursor = realpos;\n \n     return amount;\n }\n \n", "target": "// fix_start\n\t\t    if (*that != NUL)\n\t\t    {\n\t\t\tthat++;\n\t\t\tamount++;\n\t\t    }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-2183", "cve_desc": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 210520}
{"source": " static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n \t\t\t\t       struct net_device *netdev)\n {\n \tstruct mcba_priv *priv = netdev_priv(netdev);\n \tstruct can_frame *cf = (struct can_frame *)skb->data;\n \tstruct mcba_usb_ctx *ctx = NULL;\n \tstruct net_device_stats *stats = &priv->netdev->stats;\n \tu16 sid;\n \tint err;\n \tstruct mcba_usb_msg_can usb_msg = {\n \t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n \t};\n \n \tif (can_dropped_invalid_skb(netdev, skb))\n \t\treturn NETDEV_TX_OK;\n \n \tctx = mcba_usb_get_free_ctx(priv, cf);\n \tif (!ctx)\n \t\treturn NETDEV_TX_BUSY;\n \n \tif (cf->can_id & CAN_EFF_FLAG) {\n \t\tsid = MCBA_SIDL_EXID_MASK;\n \t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n \t\tsid |= (cf->can_id & 0x30000) >> 16;\n \t\tput_unaligned_be16(sid, &usb_msg.sid);\n \n \t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n \t} else {\n \t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n \t\t\t\t   &usb_msg.sid);\n \t\tusb_msg.eid = 0;\n \t}\n \n \tusb_msg.dlc = cf->len;\n \n \tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n \n \tif (cf->can_id & CAN_RTR_FLAG)\n \t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n \n \tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n \n \terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n \tif (err)\n \t\tgoto xmit_failed;\n \n \treturn NETDEV_TX_OK;\n \n xmit_failed:\n \tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n \tmcba_usb_free_ctx(ctx);\n// bug_start\n\tdev_kfree_skb(skb);\n// bug_end\n \tstats->tx_dropped++;\n \n \treturn NETDEV_TX_OK;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2022-28389", "cve_desc": "mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free.", "project": "linux", "idx": 210527}
{"source": " expand_case_fold_string(Node* node, regex_t* reg)\n {\n #define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8\n \n   int r, n, len, alt_num;\n// bug_start\n// bug_end\n   UChar *start, *end, *p;\n// bug_start\n// bug_end\n   Node *top_root, *root, *snode, *prev_node;\n   OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n// bug_start\n// bug_end\n   StrNode* sn = STR_(node);\n \n   if (NODE_STRING_IS_AMBIG(node)) return 0;\n \n   start = sn->s;\n   end   = sn->end;\n   if (start >= end) return 0;\n \n   r = 0;\n   top_root = root = prev_node = snode = NULL_NODE;\n   alt_num = 1;\n   p = start;\n   while (p < end) {\n// bug_start\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag, p, end,\n                                           items);\n// bug_end\n     if (n < 0) {\n       r = n;\n       goto err;\n     }\n \n     len = enclen(reg->enc, p);\n \n// bug_start\n    if (n == 0) {\n// bug_end\n       if (IS_NULL(snode)) {\n         if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n           top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n           if (IS_NULL(root)) {\n             onig_node_free(prev_node);\n             goto mem_err;\n           }\n         }\n \n         prev_node = snode = onig_node_new_str(NULL, NULL);\n         if (IS_NULL(snode)) goto mem_err;\n         if (IS_NOT_NULL(root)) {\n           if (IS_NULL(onig_node_list_add(root, snode))) {\n             onig_node_free(snode);\n             goto mem_err;\n           }\n         }\n// bug_start\n// bug_end\n       }\n \n// bug_start\n      r = onig_node_str_cat(snode, p, p + len);\n      if (r != 0) goto err;\n// bug_end\n     }\n     else {\n       alt_num *= (n + 1);\n       if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\n \n       if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n         top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n         if (IS_NULL(root)) {\n           onig_node_free(prev_node);\n           goto mem_err;\n         }\n       }\n \n       r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\n       if (r < 0) goto mem_err;\n       if (r == 1) {\n         if (IS_NULL(root)) {\n           top_root = prev_node;\n         }\n         else {\n           if (IS_NULL(onig_node_list_add(root, prev_node))) {\n             onig_node_free(prev_node);\n             goto mem_err;\n           }\n         }\n \n         root = NODE_CAR(prev_node);\n       }\n       else {\n         if (IS_NOT_NULL(root)) {\n           if (IS_NULL(onig_node_list_add(root, prev_node))) {\n             onig_node_free(prev_node);\n             goto mem_err;\n           }\n         }\n       }\n \n       snode = NULL_NODE;\n     }\n \n     p += len;\n   }\n \n   if (p < end) {\n     Node *srem;\n \n     r = expand_case_fold_make_rem_string(&srem, p, end, reg);\n     if (r != 0) goto mem_err;\n \n     if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\n       top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n       if (IS_NULL(root)) {\n         onig_node_free(srem);\n         onig_node_free(prev_node);\n         goto mem_err;\n       }\n     }\n \n     if (IS_NULL(root)) {\n       prev_node = srem;\n     }\n     else {\n       if (IS_NULL(onig_node_list_add(root, srem))) {\n         onig_node_free(srem);\n         goto mem_err;\n       }\n     }\n   }\n \n   top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\n   swap_node(node, top_root);\n   onig_node_free(top_root);\n   return 0;\n \n  mem_err:\n   r = ONIGERR_MEMORY;\n \n  err:\n   onig_node_free(top_root);\n   return r;\n }\n \n", "target": "// fix_start\n  int is_ambig, fold_len;\n// fix_end\n// fix_start\n  UChar* foldp;\n// fix_end\n// fix_start\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n// fix_end\n// fix_start\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag,\n                                           p, end, items);\n// fix_end\n// fix_start\n    if (n == 0 || IS_NOT_NULL(snode) ||\n        is_good_case_fold_items_for_search(reg->enc, len, n, items)) {\n// fix_end\n// fix_start\n\n        is_ambig = -1;\n      }\n      else {\n        is_ambig = NODE_STRING_IS_AMBIG(snode);\n// fix_end\n// fix_start\n      if (n != 0) {\n        foldp = p;\n        fold_len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag,\n                                         &foldp, end, buf);\n        foldp = buf;\n      }\n      else {\n        foldp = p; fold_len = len;\n      }\n\n      if ((n != 0 && is_ambig == 0) || (n == 0 && is_ambig > 0)) {\n        if (IS_NULL(root) ) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(foldp, foldp + fold_len);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NULL(onig_node_list_add(root, snode))) {\n          onig_node_free(snode);\n          goto mem_err;\n        }\n      }\n      else {\n        r = onig_node_str_cat(snode, foldp, foldp + fold_len);\n        if (r != 0) goto err;\n      }\n\n      if (n != 0) NODE_STRING_SET_AMBIG(snode);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-19246", "cve_desc": "Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.", "project": "oniguruma", "idx": 210551}
{"source": " static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n \tD eprintf (\"Dragons at 0x%x\\n\", off);\n// bug_start\n\tut64 size = r_buf_size (buf);\n// bug_end\n \tif (off >= size) {\n \t\treturn NULL;\n \t}\n \tsize -= off;\n \tif (!size) {\n// bug_start\n// bug_end\n \t\treturn NULL;\n \t}\n \tut8 *b = malloc (size);\n \tif (!b) {\n \t\treturn NULL;\n \t}\n \tint available = r_buf_read_at (buf, off, b, size);\n \tif (available != size) {\n \t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n \t\treturn NULL;\n \t}\n #if 0\n \t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                          n_segments ----.          .--- how many sections ?\n \t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n \t             .---- how many symbols? 0xc7\n \t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n \t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n \t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n \t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n \t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n \t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n \t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n \t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n \t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n \t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n \t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n \t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n \t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n #endif\n \tint magicCombo = 0;\n \tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) {\n \t\tmagicCombo++;\n \t}\n \tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n \t\tmagicCombo++;\n \t}\n \tif (magicCombo != 2) {\n \t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n \t\tif (available != size) {\n \t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n \t\t\treturn NULL;\n \t\t}\n \t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) {\n \t\t\toff -= 8;\n \t\t} else {\n \t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n \t\t}\n \t}\n \tD eprintf (\"0x%08x  magic  OK\\n\", off);\n \tD {\n \t\tconst int e0ss = r_read_le32 (b + 12);\n \t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n \t}\n \tfree (b);\n \treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n }\n \n", "target": "// fix_start\n\tst64 size = r_buf_size (buf);\n// fix_end\n// fix_start\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-1061", "cve_desc": "Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2 prior to 5.6.8.", "project": "radare2", "idx": 210570}
{"source": " int cx23888_ir_probe(struct cx23885_dev *dev)\n {\n \tstruct cx23888_ir_state *state;\n \tstruct v4l2_subdev *sd;\n \tstruct v4l2_subdev_ir_parameters default_params;\n \tint ret;\n \n \tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n \tif (state == NULL)\n \t\treturn -ENOMEM;\n \n \tspin_lock_init(&state->rx_kfifo_lock);\n// bug_start\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n// bug_end\n \t\treturn -ENOMEM;\n// bug_start\n// bug_end\n \n \tstate->dev = dev;\n \tsd = &state->sd;\n \n \tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n \tv4l2_set_subdevdata(sd, state);\n \tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n \tsd->grp_id = CX23885_HW_888_IR;\n \n \tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n \tif (ret == 0) {\n \t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n \n \t\tmutex_init(&state->rx_params_lock);\n \t\tdefault_params = default_rx_params;\n \t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n \n \t\tmutex_init(&state->tx_params_lock);\n \t\tdefault_params = default_tx_params;\n \t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n \t} else {\n \t\tkfifo_free(&state->rx_kfifo);\n \t}\n \treturn ret;\n }\n \n", "target": "// fix_start\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE,\n\t\t\tGFP_KERNEL)) {\n\t\tkfree(state);\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19054", "cve_desc": "A memory leak in the cx23888_ir_probe() function in drivers/media/pci/cx23885/cx23888-ir.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering kfifo_alloc() failures, aka CID-a7b2df76b42b.", "project": "linux", "idx": 210571}
{"source": " static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n {\n \tstruct virtproc_info *vrp = vdev->priv;\n \tstruct virtio_rpmsg_channel *vch;\n \tstruct rpmsg_device *rpdev_ctrl;\n \tint err = 0;\n \n \tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n \tif (!vch)\n \t\treturn ERR_PTR(-ENOMEM);\n \n \tvch->vrp = vrp;\n \n \trpdev_ctrl = &vch->rpdev;\n \trpdev_ctrl->ops = &virtio_rpmsg_ops;\n \n \trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n \trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n \trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n \n \terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n \tif (err) {\n// bug_start\n\t\tkfree(vch);\n// bug_end\n \t\treturn ERR_PTR(err);\n \t}\n \n \treturn rpdev_ctrl;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2022-34494", "cve_desc": "rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.", "project": "linux", "idx": 210620}
{"source": " static void mkiss_close(struct tty_struct *tty)\n {\n \tstruct mkiss *ax;\n \n \twrite_lock_irq(&disc_data_lock);\n \tax = tty->disc_data;\n \ttty->disc_data = NULL;\n \twrite_unlock_irq(&disc_data_lock);\n \n \tif (!ax)\n \t\treturn;\n \n \tif (!refcount_dec_and_test(&ax->refcnt))\n \t\twait_for_completion(&ax->dead);\n \tnetif_stop_queue(ax->dev);\n \n// bug_start\n\tax->tty = NULL;\n\n// bug_end\n \tunregister_netdev(ax->dev);\n \n \tkfree(ax->rbuff);\n \tkfree(ax->xbuff);\n \n// bug_start\n// bug_end\n \tfree_netdev(ax->dev);\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\tax->tty = NULL;\n\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-1195", "cve_desc": "A use-after-free vulnerability was found in the Linux kernel in drivers/net/hamradio. This flaw allows a local attacker with a user privilege to cause a denial of service (DOS) when the mkiss or sixpack device is detached and reclaim resources early.", "project": "linux", "idx": 210636}
{"source": " static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n   BMPInfo\n     bmp_info;\n \n   Image\n     *image;\n \n   IndexPacket\n     index;\n \n   MagickBooleanType\n     status;\n \n   MagickOffsetType\n     offset,\n     start_position;\n \n   MemoryInfo\n     *pixel_info;\n \n   register IndexPacket\n     *indexes;\n \n   register PixelPacket\n     *q;\n \n   register ssize_t\n     i,\n     x;\n \n   register unsigned char\n     *p;\n \n   size_t\n     bit,\n     bytes_per_line,\n     length;\n \n   ssize_t\n     count,\n     y;\n \n   unsigned char\n     magick[12],\n     *pixels;\n \n   unsigned int\n     blue,\n     green,\n     offset_bits,\n     red;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   (void) memset(&bmp_info,0,sizeof(bmp_info));\n   bmp_info.ba_offset=0;\n   start_position=0;\n   offset_bits=0;\n   count=ReadBlob(image,2,magick);\n   if (count != 2)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   do\n   {\n     LongPixelPacket\n       shift;\n \n     PixelPacket\n       quantum_bits;\n \n     if (bmp_info.ba_offset == 0)\n       start_position=TellBlob(image)-2;\n     bmp_info.ba_offset=0;\n     while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n     {\n       bmp_info.file_size=ReadBlobLSBLong(image);\n       bmp_info.ba_offset=ReadBlobLSBLong(image);\n       bmp_info.offset_bits=ReadBlobLSBLong(image);\n       count=ReadBlob(image,2,magick);\n       if (count != 2)\n         break;\n     }\n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n         magick[0],magick[1]);\n     if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n         (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     bmp_info.file_size=ReadBlobLSBLong(image);\n     (void) ReadBlobLSBLong(image);\n \n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  File_size in header:  %u bytes\",bmp_info.file_size);\n \n     bmp_info.offset_bits=ReadBlobLSBLong(image);\n     bmp_info.size=ReadBlobLSBLong(image);\n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n         bmp_info.size);\n     if (bmp_info.size == 12)\n       {\n         (void) CopyMagickString(image->magick,\"BMP2\",MaxTextExtent);\n         bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n         bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n         bmp_info.planes=ReadBlobLSBShort(image);\n         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n         bmp_info.x_pixels=0;\n         bmp_info.y_pixels=0;\n         bmp_info.number_colors=0;\n         bmp_info.compression=BI_RGB;\n         bmp_info.image_size=0;\n         bmp_info.alpha_mask=0;\n         if (image->debug != MagickFalse)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Format: OS/2 Bitmap\");\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n               bmp_info.height);\n           }\n       }\n     else\n       {\n         if (bmp_info.size < 40)\n           ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n         bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n         bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n         bmp_info.planes=ReadBlobLSBShort(image);\n         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n         bmp_info.compression=ReadBlobLSBLong(image);\n         bmp_info.image_size=ReadBlobLSBLong(image);\n         bmp_info.x_pixels=ReadBlobLSBLong(image);\n         bmp_info.y_pixels=ReadBlobLSBLong(image);\n         bmp_info.number_colors=ReadBlobLSBLong(image);\n         bmp_info.colors_important=ReadBlobLSBLong(image);\n         if (image->debug != MagickFalse)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Format: MS Windows bitmap\");\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n               bmp_info.height);\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n             switch (bmp_info.compression)\n             {\n               case BI_RGB:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_RGB\");\n                 break;\n               }\n               case BI_RLE4:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_RLE4\");\n                 break;\n               }\n               case BI_RLE8:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_RLE8\");\n                 break;\n               }\n               case BI_BITFIELDS:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_BITFIELDS\");\n                 break;\n               }\n               case BI_PNG:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_PNG\");\n                 break;\n               }\n               case BI_JPEG:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_JPEG\");\n                 break;\n               }\n               default:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n               }\n             }\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Number of colors: %u\",bmp_info.number_colors);\n           }\n         bmp_info.red_mask=ReadBlobLSBLong(image);\n         bmp_info.green_mask=ReadBlobLSBLong(image);\n         bmp_info.blue_mask=ReadBlobLSBLong(image);\n         if (bmp_info.size > 40)\n           {\n             double\n               gamma;\n \n             bmp_info.alpha_mask=ReadBlobLSBLong(image);\n             bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n #           define BMP_DENOM ((double) 0x40000000)\n             bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n \n             gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n               bmp_info.red_primary.z;\n             gamma=PerceptibleReciprocal(gamma);\n             bmp_info.red_primary.x*=gamma;\n             bmp_info.red_primary.y*=gamma;\n             image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n             image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n \n             gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n               bmp_info.green_primary.z;\n             gamma=PerceptibleReciprocal(gamma);\n             bmp_info.green_primary.x*=gamma;\n             bmp_info.green_primary.y*=gamma;\n             image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n             image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n \n             gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n               bmp_info.blue_primary.z;\n             gamma=PerceptibleReciprocal(gamma);\n             bmp_info.blue_primary.x*=gamma;\n             bmp_info.blue_primary.y*=gamma;\n             image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n             image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n \n             bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n             bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n             bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n             image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n               bmp_info.gamma_scale.z)/3.0;\n           }\n         else\n           (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n \n         if (bmp_info.size > 108)\n           {\n             size_t\n               intent;\n \n             intent=ReadBlobLSBLong(image);\n             switch ((int) intent)\n             {\n               case LCS_GM_BUSINESS:\n               {\n                 image->rendering_intent=SaturationIntent;\n                 break;\n               }\n               case LCS_GM_GRAPHICS:\n               {\n                 image->rendering_intent=RelativeIntent;\n                 break;\n               }\n               case LCS_GM_IMAGES:\n               {\n                 image->rendering_intent=PerceptualIntent;\n                 break;\n               }\n               case LCS_GM_ABS_COLORIMETRIC:\n               {\n                 image->rendering_intent=AbsoluteIntent;\n                 break;\n               }\n             }\n             (void) ReadBlobLSBLong(image);\n             (void) ReadBlobLSBLong(image);\n             (void) ReadBlobLSBLong(image);\n           }\n       }\n     if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n       (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n         \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n     else\n       if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n         (void) ThrowMagickException(exception,GetMagickModule(),\n           CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n           image->filename);\n     if (bmp_info.width <= 0)\n       ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n     if (bmp_info.height == 0)\n       ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n     if (bmp_info.planes != 1)\n       ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n     if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n         (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n         (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     if (bmp_info.bits_per_pixel < 16 &&\n         bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n     if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     switch (bmp_info.compression)\n     {\n       case BI_RGB:\n         image->compression=NoCompression;\n         break;\n       case BI_RLE8:\n       case BI_RLE4:\n         image->compression=RLECompression;\n         break;\n       case BI_BITFIELDS:\n         break;\n       case BI_JPEG:\n         ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n       case BI_PNG:\n         ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n       default:\n         ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n     }\n     image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n     image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n     image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n     image->matte=((bmp_info.alpha_mask != 0) &&\n       (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;\n     if (bmp_info.bits_per_pixel < 16)\n       {\n         size_t\n           one;\n \n         image->storage_class=PseudoClass;\n         image->colors=bmp_info.number_colors;\n         one=1;\n         if (image->colors == 0)\n           image->colors=one << bmp_info.bits_per_pixel;\n       }\n     image->x_resolution=(double) bmp_info.x_pixels/100.0;\n     image->y_resolution=(double) bmp_info.y_pixels/100.0;\n     image->units=PixelsPerCentimeterResolution;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n       {\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n     if (image->storage_class == PseudoClass)\n       {\n         unsigned char\n           *bmp_colormap;\n \n         size_t\n           packet_size;\n \n         if (image->debug != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reading colormap of %.20g colors\",(double) image->colors);\n         if (AcquireImageColormap(image,image->colors) == MagickFalse)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n           image->colors,4*sizeof(*bmp_colormap));\n         if (bmp_colormap == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         if ((bmp_info.size == 12) || (bmp_info.size == 64))\n           packet_size=3;\n         else\n           packet_size=4;\n         offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n         if (offset < 0)\n           {\n             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n         count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n         if (count != (ssize_t) (packet_size*image->colors))\n           {\n             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n             ThrowReaderException(CorruptImageError,\n               \"InsufficientImageDataInFile\");\n           }\n         p=bmp_colormap;\n         for (i=0; i < (ssize_t) image->colors; i++)\n         {\n           image->colormap[i].blue=ScaleCharToQuantum(*p++);\n           image->colormap[i].green=ScaleCharToQuantum(*p++);\n           image->colormap[i].red=ScaleCharToQuantum(*p++);\n           if (packet_size == 4)\n             p++;\n         }\n         bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n       }\n     if (bmp_info.offset_bits == offset_bits)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     offset_bits=bmp_info.offset_bits;\n     offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n     if (offset < 0)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     if (bmp_info.compression == BI_RLE4)\n       bmp_info.bits_per_pixel<<=1;\n     bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n     length=(size_t) bytes_per_line*image->rows;\n     if (((MagickSizeType) length/8) > GetBlobSize(image))\n       ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n     if ((bmp_info.compression == BI_RGB) ||\n         (bmp_info.compression == BI_BITFIELDS))\n       {\n         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n           image->columns+256UL)*sizeof(*pixels));\n         if (pixel_info == (MemoryInfo *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n         if (image->debug != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reading pixels (%.20g bytes)\",(double) length);\n         count=ReadBlob(image,length,pixels);\n         if (count != (ssize_t) length)\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"InsufficientImageDataInFile\");\n           }\n       }\n     else\n       {\n         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n           image->columns+256UL)*sizeof(*pixels));\n         if (pixel_info == (MemoryInfo *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n         status=DecodeImage(image,bmp_info.compression,pixels,\n           image->columns*image->rows);\n         if (status == MagickFalse)\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"UnableToRunlengthDecodeImage\");\n           }\n       }\n     if (bmp_info.compression == BI_RGB)\n       {\n         if ((image->matte == MagickFalse) && (bmp_info.size == 40) &&\n             (bmp_info.bits_per_pixel == 32))\n           {\n             bytes_per_line=4*(image->columns);\n             for (y=(ssize_t) image->rows-1; y >= 0; y--)\n             {\n               p=pixels+(image->rows-y-1)*bytes_per_line;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (*(p+3) != 0)\n                   {\n                     image->matte=MagickTrue;\n                     y=-1;\n                     break;\n                   }\n                 p+=4;\n               }\n             }\n           }\n         bmp_info.alpha_mask=image->matte != MagickFalse ? 0xff000000U : 0U;\n         bmp_info.red_mask=0x00ff0000U;\n         bmp_info.green_mask=0x0000ff00U;\n         bmp_info.blue_mask=0x000000ffU;\n         if (bmp_info.bits_per_pixel == 16)\n           {\n             bmp_info.red_mask=0x00007c00U;\n             bmp_info.green_mask=0x000003e0U;\n             bmp_info.blue_mask=0x0000001fU;\n           }\n       }\n     (void) memset(&shift,0,sizeof(shift));\n     (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n     if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n       {\n         register size_t\n           sample;\n \n         if (bmp_info.red_mask != 0)\n           while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n           {\n             shift.red++;\n             if (shift.red > 32U)\n               break;\n           }\n         if (bmp_info.green_mask != 0)\n           while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n           {\n             shift.green++;\n             if (shift.green > 32U)\n               break;\n           }\n         if (bmp_info.blue_mask != 0)\n           while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n           {\n             shift.blue++;\n             if (shift.blue > 32U)\n               break;\n           }\n         if (bmp_info.alpha_mask != 0)\n           while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL) == 0)\n           {\n             shift.opacity++;\n             if (shift.opacity > 32U)\n               break;\n           }\n         sample=shift.red;\n         while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n         sample=shift.green;\n         while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.green=ClampToQuantum((MagickRealType) sample-shift.green);\n         sample=shift.blue;\n         while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.blue=ClampToQuantum((MagickRealType) sample-shift.blue);\n         sample=shift.opacity;\n         while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.opacity=ClampToQuantum((MagickRealType) sample-\n           shift.opacity);\n       }\n     switch (bmp_info.bits_per_pixel)\n     {\n       case 1:\n       {\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n           {\n             for (bit=0; bit < 8; bit++)\n             {\n               index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n               SetPixelIndex(indexes+x+bit,index);\n               q++;\n             }\n             p++;\n           }\n           if ((image->columns % 8) != 0)\n             {\n               for (bit=0; bit < (image->columns % 8); bit++)\n               {\n                 index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                 SetPixelIndex(indexes+x+bit,index);\n               }\n               p++;\n             }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         (void) SyncImage(image);\n         break;\n       }\n       case 4:\n       {\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n           {\n             (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),\n               &index,exception);\n             SetPixelIndex(indexes+x,index);\n             (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,\n               exception);\n             SetPixelIndex(indexes+x+1,index);\n             p++;\n           }\n           if ((image->columns % 2) != 0)\n             {\n               (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0xf),\n                 &index,exception);\n               SetPixelIndex(indexes+(x++),index);\n               p++;\n             }\n           if (x < (ssize_t) image->columns)\n             break;\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         (void) SyncImage(image);\n         break;\n       }\n       case 8:\n       {\n         if ((bmp_info.compression == BI_RLE8) ||\n             (bmp_info.compression == BI_RLE4))\n           bytes_per_line=image->columns;\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=(ssize_t) image->columns; x != 0; --x)\n           {\n             (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);\n             SetPixelIndex(indexes,index);\n             indexes++;\n             p++;\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         (void) SyncImage(image);\n         break;\n       }\n       case 16:\n       {\n         unsigned int\n           alpha,\n           pixel;\n \n         if (bmp_info.compression != BI_RGB &&\n             bmp_info.compression != BI_BITFIELDS)\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"UnrecognizedImageCompression\");\n           }\n         bytes_per_line=2*(image->columns+image->columns % 2);\n         image->storage_class=DirectClass;\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             pixel=(unsigned int) (*p++);\n             pixel|=(*p++) << 8;\n             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n             if (quantum_bits.red == 5)\n               red|=((red & 0xe000) >> 5);\n             if (quantum_bits.red <= 8)\n               red|=((red & 0xff00) >> 8);\n             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n             if (quantum_bits.green == 5)\n               green|=((green & 0xe000) >> 5);\n             if (quantum_bits.green == 6)\n               green|=((green & 0xc000) >> 6);\n             if (quantum_bits.green <= 8)\n               green|=((green & 0xff00) >> 8);\n             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n             if (quantum_bits.blue == 5)\n               blue|=((blue & 0xe000) >> 5);\n             if (quantum_bits.blue <= 8)\n               blue|=((blue & 0xff00) >> 8);\n             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n             SetPixelOpacity(q,OpaqueOpacity);\n             if (image->matte != MagickFalse)\n               {\n                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n                 if (quantum_bits.opacity <= 8)\n                   alpha|=((alpha & 0xff00) >> 8);\n                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n               }\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       case 24:\n       {\n         bytes_per_line=4*((image->columns*24+31)/32);\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             SetPixelBlue(q,ScaleCharToQuantum(*p++));\n             SetPixelGreen(q,ScaleCharToQuantum(*p++));\n             SetPixelRed(q,ScaleCharToQuantum(*p++));\n             SetPixelOpacity(q,OpaqueOpacity);\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       case 32:\n       {\n         if ((bmp_info.compression != BI_RGB) &&\n             (bmp_info.compression != BI_BITFIELDS))\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"UnrecognizedImageCompression\");\n           }\n         bytes_per_line=4*(image->columns);\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           unsigned int\n             alpha,\n             pixel;\n \n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             pixel=(unsigned int) (*p++);\n             pixel|=((unsigned int) *p++ << 8);\n             pixel|=((unsigned int) *p++ << 16);\n             pixel|=((unsigned int) *p++ << 24);\n             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n             if (quantum_bits.red == 8)\n               red|=(red >> 8);\n             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n             if (quantum_bits.green == 8)\n               green|=(green >> 8);\n             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n             if (quantum_bits.blue == 8)\n               blue|=(blue >> 8);\n             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n             SetPixelAlpha(q,OpaqueOpacity);\n             if (image->matte != MagickFalse)\n               {\n                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n                 if (quantum_bits.opacity == 8)\n                   alpha|=(alpha >> 8);\n                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n               }\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       default:\n       {\n         pixel_info=RelinquishVirtualMemory(pixel_info);\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n     }\n     pixel_info=RelinquishVirtualMemory(pixel_info);\n     if (y > 0)\n       break;\n     if (EOFBlob(image) != MagickFalse)\n       {\n         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n           image->filename);\n         break;\n       }\n     if (bmp_info.height < 0)\n       {\n         Image\n           *flipped_image;\n \n         flipped_image=FlipImage(image,exception);\n         if (flipped_image != (Image *) NULL)\n           {\n             DuplicateBlob(flipped_image,image);\n             ReplaceImageInList(&image, flipped_image);\n             image=flipped_image;\n           }\n       }\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     *magick='\\0';\n     if (bmp_info.ba_offset != 0)\n       {\n         offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n         if (offset < 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n     count=ReadBlob(image,2,magick);\n     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n       {\n         AcquireNextImage(image_info,image);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n// bug_start\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n// bug_end\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n           GetBlobSize(image));\n         if (status == MagickFalse)\n           break;\n       }\n   } while (IsBMP(magick,2) != MagickFalse);\n   (void) CloseBlob(image);\n// bug_start\n// bug_end\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n            status=MagickFalse;\n            break;\n// fix_end\n// fix_start\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-13133", "cve_desc": "ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadBMPImage in coders/bmp.c.", "project": "ImageMagick6", "idx": 210669}
{"source": " static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n   BMPInfo\n     bmp_info;\n \n   Image\n     *image;\n \n   IndexPacket\n     index;\n \n   MagickBooleanType\n     status;\n \n   MagickOffsetType\n     offset,\n     start_position;\n \n   MemoryInfo\n     *pixel_info;\n \n   register IndexPacket\n     *indexes;\n \n   register PixelPacket\n     *q;\n \n   register ssize_t\n     i,\n     x;\n \n   register unsigned char\n     *p;\n \n   size_t\n     bit,\n     bytes_per_line,\n     length;\n \n   ssize_t\n     count,\n     y;\n \n   unsigned char\n     magick[12],\n     *pixels;\n \n   unsigned int\n     blue,\n     green,\n     offset_bits,\n     red;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   (void) memset(&bmp_info,0,sizeof(bmp_info));\n   bmp_info.ba_offset=0;\n   start_position=0;\n   offset_bits=0;\n   count=ReadBlob(image,2,magick);\n   if (count != 2)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   do\n   {\n     LongPixelPacket\n       shift;\n \n     PixelPacket\n       quantum_bits;\n \n// bug_start\n    if (bmp_info.ba_offset == 0)\n      start_position=TellBlob(image)-2;\n// bug_end\n     bmp_info.ba_offset=0;\n     while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n     {\n       bmp_info.file_size=ReadBlobLSBLong(image);\n       bmp_info.ba_offset=ReadBlobLSBLong(image);\n       bmp_info.offset_bits=ReadBlobLSBLong(image);\n       count=ReadBlob(image,2,magick);\n       if (count != 2)\n         break;\n     }\n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n         magick[0],magick[1]);\n     if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n         (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     bmp_info.file_size=ReadBlobLSBLong(image);\n     (void) ReadBlobLSBLong(image);\n \n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  File_size in header:  %u bytes\",bmp_info.file_size);\n \n     bmp_info.offset_bits=ReadBlobLSBLong(image);\n     bmp_info.size=ReadBlobLSBLong(image);\n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n         bmp_info.size);\n     if (bmp_info.size == 12)\n       {\n         (void) CopyMagickString(image->magick,\"BMP2\",MaxTextExtent);\n         bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n         bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n         bmp_info.planes=ReadBlobLSBShort(image);\n         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n         bmp_info.x_pixels=0;\n         bmp_info.y_pixels=0;\n         bmp_info.number_colors=0;\n         bmp_info.compression=BI_RGB;\n         bmp_info.image_size=0;\n         bmp_info.alpha_mask=0;\n         if (image->debug != MagickFalse)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Format: OS/2 Bitmap\");\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n               bmp_info.height);\n           }\n       }\n     else\n       {\n         if (bmp_info.size < 40)\n           ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n         bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n         bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n         bmp_info.planes=ReadBlobLSBShort(image);\n         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n         bmp_info.compression=ReadBlobLSBLong(image);\n         bmp_info.image_size=ReadBlobLSBLong(image);\n         bmp_info.x_pixels=ReadBlobLSBLong(image);\n         bmp_info.y_pixels=ReadBlobLSBLong(image);\n         bmp_info.number_colors=ReadBlobLSBLong(image);\n         if (bmp_info.number_colors > GetBlobSize(image))\n           ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         bmp_info.colors_important=ReadBlobLSBLong(image);\n         if (image->debug != MagickFalse)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Format: MS Windows bitmap\");\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n               bmp_info.height);\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n             switch (bmp_info.compression)\n             {\n               case BI_RGB:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_RGB\");\n                 break;\n               }\n               case BI_RLE4:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_RLE4\");\n                 break;\n               }\n               case BI_RLE8:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_RLE8\");\n                 break;\n               }\n               case BI_BITFIELDS:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_BITFIELDS\");\n                 break;\n               }\n               case BI_PNG:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_PNG\");\n                 break;\n               }\n               case BI_JPEG:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: BI_JPEG\");\n                 break;\n               }\n               default:\n               {\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n               }\n             }\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Number of colors: %u\",bmp_info.number_colors);\n           }\n         bmp_info.red_mask=ReadBlobLSBLong(image);\n         bmp_info.green_mask=ReadBlobLSBLong(image);\n         bmp_info.blue_mask=ReadBlobLSBLong(image);\n         if (bmp_info.size > 40)\n           {\n             double\n               gamma;\n \n             bmp_info.alpha_mask=ReadBlobLSBLong(image);\n             bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n #           define BMP_DENOM ((double) 0x40000000)\n             bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n             bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n \n             gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n               bmp_info.red_primary.z;\n             gamma=PerceptibleReciprocal(gamma);\n             bmp_info.red_primary.x*=gamma;\n             bmp_info.red_primary.y*=gamma;\n             image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n             image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n \n             gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n               bmp_info.green_primary.z;\n             gamma=PerceptibleReciprocal(gamma);\n             bmp_info.green_primary.x*=gamma;\n             bmp_info.green_primary.y*=gamma;\n             image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n             image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n \n             gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n               bmp_info.blue_primary.z;\n             gamma=PerceptibleReciprocal(gamma);\n             bmp_info.blue_primary.x*=gamma;\n             bmp_info.blue_primary.y*=gamma;\n             image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n             image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n \n             bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n             bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n             bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n             image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n               bmp_info.gamma_scale.z)/3.0;\n           }\n         else\n           (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n \n         if (bmp_info.size > 108)\n           {\n             size_t\n               intent;\n \n             intent=ReadBlobLSBLong(image);\n             switch ((int) intent)\n             {\n               case LCS_GM_BUSINESS:\n               {\n                 image->rendering_intent=SaturationIntent;\n                 break;\n               }\n               case LCS_GM_GRAPHICS:\n               {\n                 image->rendering_intent=RelativeIntent;\n                 break;\n               }\n               case LCS_GM_IMAGES:\n               {\n                 image->rendering_intent=PerceptualIntent;\n                 break;\n               }\n               case LCS_GM_ABS_COLORIMETRIC:\n               {\n                 image->rendering_intent=AbsoluteIntent;\n                 break;\n               }\n             }\n             (void) ReadBlobLSBLong(image);\n             (void) ReadBlobLSBLong(image);\n             (void) ReadBlobLSBLong(image);\n           }\n       }\n     if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n       (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n         \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n     else\n       if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n         (void) ThrowMagickException(exception,GetMagickModule(),\n           CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n           image->filename);\n     if (bmp_info.width <= 0)\n       ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n     if (bmp_info.height == 0)\n       ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n     if (bmp_info.planes != 1)\n       ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n     if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n         (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n         (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     if (bmp_info.bits_per_pixel < 16 &&\n         bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n     if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n       ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n     switch (bmp_info.compression)\n     {\n       case BI_RGB:\n         image->compression=NoCompression;\n         break;\n       case BI_RLE8:\n       case BI_RLE4:\n         image->compression=RLECompression;\n         break;\n       case BI_BITFIELDS:\n         break;\n       case BI_JPEG:\n         ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n       case BI_PNG:\n         ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n       default:\n         ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n     }\n     image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n     image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n     image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n     image->matte=((bmp_info.alpha_mask != 0) &&\n       (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;\n     if (bmp_info.bits_per_pixel < 16)\n       {\n         size_t\n           one;\n \n         image->storage_class=PseudoClass;\n         image->colors=bmp_info.number_colors;\n         one=1;\n         if (image->colors == 0)\n           image->colors=one << bmp_info.bits_per_pixel;\n       }\n     image->x_resolution=(double) bmp_info.x_pixels/100.0;\n     image->y_resolution=(double) bmp_info.y_pixels/100.0;\n     image->units=PixelsPerCentimeterResolution;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n       {\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n     if (image->storage_class == PseudoClass)\n       {\n         unsigned char\n           *bmp_colormap;\n \n         size_t\n           packet_size;\n \n         if (image->debug != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reading colormap of %.20g colors\",(double) image->colors);\n         if (AcquireImageColormap(image,image->colors) == MagickFalse)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n           image->colors,4*sizeof(*bmp_colormap));\n         if (bmp_colormap == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         if ((bmp_info.size == 12) || (bmp_info.size == 64))\n           packet_size=3;\n         else\n           packet_size=4;\n         offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n         if (offset < 0)\n           {\n             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n         count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n         if (count != (ssize_t) (packet_size*image->colors))\n           {\n             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n             ThrowReaderException(CorruptImageError,\n               \"InsufficientImageDataInFile\");\n           }\n         p=bmp_colormap;\n         for (i=0; i < (ssize_t) image->colors; i++)\n         {\n           image->colormap[i].blue=ScaleCharToQuantum(*p++);\n           image->colormap[i].green=ScaleCharToQuantum(*p++);\n           image->colormap[i].red=ScaleCharToQuantum(*p++);\n           if (packet_size == 4)\n             p++;\n         }\n         bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n       }\n     if (bmp_info.offset_bits == offset_bits)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     offset_bits=bmp_info.offset_bits;\n     offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n     if (offset < 0)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     if (bmp_info.compression == BI_RLE4)\n       bmp_info.bits_per_pixel<<=1;\n     bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n     length=(size_t) bytes_per_line*image->rows;\n     if (((MagickSizeType) length/8) > GetBlobSize(image))\n       ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n     if ((bmp_info.compression == BI_RGB) ||\n         (bmp_info.compression == BI_BITFIELDS))\n       {\n         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n           image->columns+256UL)*sizeof(*pixels));\n         if (pixel_info == (MemoryInfo *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n         if (image->debug != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reading pixels (%.20g bytes)\",(double) length);\n         count=ReadBlob(image,length,pixels);\n         if (count != (ssize_t) length)\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"InsufficientImageDataInFile\");\n           }\n       }\n     else\n       {\n         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n           image->columns+256UL)*sizeof(*pixels));\n         if (pixel_info == (MemoryInfo *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n         status=DecodeImage(image,bmp_info.compression,pixels,\n           image->columns*image->rows);\n         if (status == MagickFalse)\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"UnableToRunlengthDecodeImage\");\n           }\n       }\n     if (bmp_info.compression == BI_RGB)\n       {\n         if ((image->matte == MagickFalse) && (bmp_info.size == 40) &&\n             (bmp_info.bits_per_pixel == 32))\n           {\n             bytes_per_line=4*(image->columns);\n             for (y=(ssize_t) image->rows-1; y >= 0; y--)\n             {\n               p=pixels+(image->rows-y-1)*bytes_per_line;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (*(p+3) != 0)\n                   {\n                     image->matte=MagickTrue;\n                     y=-1;\n                     break;\n                   }\n                 p+=4;\n               }\n             }\n           }\n         bmp_info.alpha_mask=image->matte != MagickFalse ? 0xff000000U : 0U;\n         bmp_info.red_mask=0x00ff0000U;\n         bmp_info.green_mask=0x0000ff00U;\n         bmp_info.blue_mask=0x000000ffU;\n         if (bmp_info.bits_per_pixel == 16)\n           {\n             bmp_info.red_mask=0x00007c00U;\n             bmp_info.green_mask=0x000003e0U;\n             bmp_info.blue_mask=0x0000001fU;\n           }\n       }\n     (void) memset(&shift,0,sizeof(shift));\n     (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n     if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n       {\n         register size_t\n           sample;\n \n         if (bmp_info.red_mask != 0)\n           while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n           {\n             shift.red++;\n             if (shift.red > 32U)\n               break;\n           }\n         if (bmp_info.green_mask != 0)\n           while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n           {\n             shift.green++;\n             if (shift.green > 32U)\n               break;\n           }\n         if (bmp_info.blue_mask != 0)\n           while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n           {\n             shift.blue++;\n             if (shift.blue > 32U)\n               break;\n           }\n         if (bmp_info.alpha_mask != 0)\n           while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL) == 0)\n           {\n             shift.opacity++;\n             if (shift.opacity > 32U)\n               break;\n           }\n         sample=shift.red;\n         while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n         sample=shift.green;\n         while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.green=ClampToQuantum((MagickRealType) sample-shift.green);\n         sample=shift.blue;\n         while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.blue=ClampToQuantum((MagickRealType) sample-shift.blue);\n         sample=shift.opacity;\n         while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n         {\n           sample++;\n           if (sample > 32U)\n             break;\n         }\n         quantum_bits.opacity=ClampToQuantum((MagickRealType) sample-\n           shift.opacity);\n       }\n     switch (bmp_info.bits_per_pixel)\n     {\n       case 1:\n       {\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n           {\n             for (bit=0; bit < 8; bit++)\n             {\n               index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n               SetPixelIndex(indexes+x+bit,index);\n               q++;\n             }\n             p++;\n           }\n           if ((image->columns % 8) != 0)\n             {\n               for (bit=0; bit < (image->columns % 8); bit++)\n               {\n                 index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                 SetPixelIndex(indexes+x+bit,index);\n               }\n               p++;\n             }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         (void) SyncImage(image);\n         break;\n       }\n       case 4:\n       {\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n           {\n             (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),\n               &index,exception);\n             SetPixelIndex(indexes+x,index);\n             (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,\n               exception);\n             SetPixelIndex(indexes+x+1,index);\n             p++;\n           }\n           if ((image->columns % 2) != 0)\n             {\n               (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0xf),\n                 &index,exception);\n               SetPixelIndex(indexes+(x++),index);\n               p++;\n             }\n           if (x < (ssize_t) image->columns)\n             break;\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         (void) SyncImage(image);\n         break;\n       }\n       case 8:\n       {\n         if ((bmp_info.compression == BI_RLE8) ||\n             (bmp_info.compression == BI_RLE4))\n           bytes_per_line=image->columns;\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=(ssize_t) image->columns; x != 0; --x)\n           {\n             (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);\n             SetPixelIndex(indexes,index);\n             indexes++;\n             p++;\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         (void) SyncImage(image);\n         break;\n       }\n       case 16:\n       {\n         unsigned int\n           alpha,\n           pixel;\n \n         if (bmp_info.compression != BI_RGB &&\n             bmp_info.compression != BI_BITFIELDS)\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"UnrecognizedImageCompression\");\n           }\n         bytes_per_line=2*(image->columns+image->columns % 2);\n         image->storage_class=DirectClass;\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             pixel=(unsigned int) (*p++);\n             pixel|=(*p++) << 8;\n             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n             if (quantum_bits.red == 5)\n               red|=((red & 0xe000) >> 5);\n             if (quantum_bits.red <= 8)\n               red|=((red & 0xff00) >> 8);\n             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n             if (quantum_bits.green == 5)\n               green|=((green & 0xe000) >> 5);\n             if (quantum_bits.green == 6)\n               green|=((green & 0xc000) >> 6);\n             if (quantum_bits.green <= 8)\n               green|=((green & 0xff00) >> 8);\n             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n             if (quantum_bits.blue == 5)\n               blue|=((blue & 0xe000) >> 5);\n             if (quantum_bits.blue <= 8)\n               blue|=((blue & 0xff00) >> 8);\n             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n             SetPixelOpacity(q,OpaqueOpacity);\n             if (image->matte != MagickFalse)\n               {\n                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n                 if (quantum_bits.opacity <= 8)\n                   alpha|=((alpha & 0xff00) >> 8);\n                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n               }\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       case 24:\n       {\n         bytes_per_line=4*((image->columns*24+31)/32);\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             SetPixelBlue(q,ScaleCharToQuantum(*p++));\n             SetPixelGreen(q,ScaleCharToQuantum(*p++));\n             SetPixelRed(q,ScaleCharToQuantum(*p++));\n             SetPixelOpacity(q,OpaqueOpacity);\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       case 32:\n       {\n         if ((bmp_info.compression != BI_RGB) &&\n             (bmp_info.compression != BI_BITFIELDS))\n           {\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(CorruptImageError,\n               \"UnrecognizedImageCompression\");\n           }\n         bytes_per_line=4*(image->columns);\n         for (y=(ssize_t) image->rows-1; y >= 0; y--)\n         {\n           unsigned int\n             alpha,\n             pixel;\n \n           p=pixels+(image->rows-y-1)*bytes_per_line;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             pixel=(unsigned int) (*p++);\n             pixel|=((unsigned int) *p++ << 8);\n             pixel|=((unsigned int) *p++ << 16);\n             pixel|=((unsigned int) *p++ << 24);\n             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n             if (quantum_bits.red == 8)\n               red|=(red >> 8);\n             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n             if (quantum_bits.green == 8)\n               green|=(green >> 8);\n             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n             if (quantum_bits.blue == 8)\n               blue|=(blue >> 8);\n             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n             SetPixelAlpha(q,OpaqueOpacity);\n             if (image->matte != MagickFalse)\n               {\n                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n                 if (quantum_bits.opacity == 8)\n                   alpha|=(alpha >> 8);\n                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n               }\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           offset=(MagickOffsetType) (image->rows-y-1);\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                 (image->rows-y),image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       default:\n       {\n         pixel_info=RelinquishVirtualMemory(pixel_info);\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n     }\n     pixel_info=RelinquishVirtualMemory(pixel_info);\n     if (y > 0)\n       break;\n     if (EOFBlob(image) != MagickFalse)\n       {\n         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n           image->filename);\n         break;\n       }\n     if (bmp_info.height < 0)\n       {\n         Image\n           *flipped_image;\n \n         flipped_image=FlipImage(image,exception);\n         if (flipped_image != (Image *) NULL)\n           {\n             DuplicateBlob(flipped_image,image);\n             ReplaceImageInList(&image, flipped_image);\n             image=flipped_image;\n           }\n       }\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     *magick='\\0';\n     if (bmp_info.ba_offset != 0)\n       {\n         offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n         if (offset < 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n     count=ReadBlob(image,2,magick);\n     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n       {\n         AcquireNextImage(image_info,image);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n             break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n           GetBlobSize(image));\n         if (status == MagickFalse)\n           break;\n       }\n   } while (IsBMP(magick,2) != MagickFalse);\n   (void) CloseBlob(image);\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n    start_position=TellBlob(image)-2;\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2018-18024", "cve_desc": "In ImageMagick 7.0.8-13 Q16, there is an infinite loop in the ReadBMPImage function of the coders/bmp.c file. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted bmp file.", "project": "ImageMagick6", "idx": 210692}
{"source": " static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n \tstruct inode **i)\n {\n \tsquashfs_dir_header_2 dirh;\n \tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n \t\t__attribute__((aligned));\n \tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n \tlong long start;\n \tint bytes;\n \tint dir_count, size;\n \tstruct dir_ent *new_dir;\n \tstruct dir *dir;\n \n \tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n \t\tblock_start, offset);\n \n \t*i = read_inode(block_start, offset);\n \n \tdir = malloc(sizeof(struct dir));\n \tif(dir == NULL)\n \t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n \n \tdir->dir_count = 0;\n \tdir->cur_entry = 0;\n \tdir->mode = (*i)->mode;\n \tdir->uid = (*i)->uid;\n \tdir->guid = (*i)->gid;\n \tdir->mtime = (*i)->time;\n \tdir->xattr = (*i)->xattr;\n \tdir->dirs = NULL;\n \n \tif ((*i)->data == 0)\n \t\treturn dir;\n \n \tstart = sBlk.s.directory_table_start + (*i)->start;\n \tbytes = lookup_entry(directory_table_hash, start);\n \tif(bytes == -1)\n \t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n \t\t\t\"found!\\n\", block_start);\n \n \tbytes += (*i)->offset;\n \tsize = (*i)->data + bytes;\n \n \twhile(bytes < size) {\n \t\tif(swap) {\n \t\t\tsquashfs_dir_header_2 sdirh;\n \t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n \t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n \t\t} else\n \t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n \n \t\tdir_count = dirh.count + 1;\n \t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n \t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n \t\tbytes += sizeof(dirh);\n \n \t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n \t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n \t\t\tgoto corrupted;\n \t\t}\n \n \t\twhile(dir_count--) {\n \t\t\tif(swap) {\n \t\t\t\tsquashfs_dir_entry_2 sdire;\n \t\t\t\tmemcpy(&sdire, directory_table + bytes,\n \t\t\t\t\tsizeof(sdire));\n \t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n \t\t\t} else\n \t\t\t\tmemcpy(dire, directory_table + bytes,\n \t\t\t\t\tsizeof(*dire));\n \t\t\tbytes += sizeof(*dire);\n \n \t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n \t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tmemcpy(dire->name, directory_table + bytes,\n \t\t\t\tdire->size + 1);\n \t\t\tdire->name[dire->size + 1] = '\\0';\n// bug_start\n// bug_end\n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);\n \t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n \t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n \t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n \t\t\t\tif(new_dir == NULL)\n \t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n \t\t\t\t\t\t\"realloc failed!\\n\");\n \t\t\t\tdir->dirs = new_dir;\n \t\t\t}\n \t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n \t\t\tdir->dirs[dir->dir_count].start_block =\n \t\t\t\tdirh.start_block;\n \t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n \t\t\tdir->dirs[dir->dir_count].type = dire->type;\n \t\t\tdir->dir_count ++;\n \t\t\tbytes += dire->size + 1;\n \t\t}\n \t}\n \n \treturn dir;\n \n corrupted:\n \tfree(dir->dirs);\n \tfree(dir);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2021-40153", "cve_desc": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.", "project": "squashfs-tools", "idx": 210700}
{"source": " static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n \tstruct inode **i)\n {\n// bug_start\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n// bug_end\n \t\t__attribute__((aligned));\n// bug_start\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n// bug_end\n \tlong long start;\n \tint bytes;\n \tint dir_count, size;\n \tstruct dir_ent *new_dir;\n \tstruct dir *dir;\n \n \tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n \t\tblock_start, offset);\n \n \t*i = read_inode(block_start, offset);\n \n \tdir = malloc(sizeof(struct dir));\n \tif(dir == NULL)\n \t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n \n \tdir->dir_count = 0;\n \tdir->cur_entry = 0;\n \tdir->mode = (*i)->mode;\n \tdir->uid = (*i)->uid;\n \tdir->guid = (*i)->gid;\n \tdir->mtime = (*i)->time;\n \tdir->xattr = (*i)->xattr;\n \tdir->dirs = NULL;\n \n// bug_start\n\tif ((*i)->data == 3)\n// bug_end\n \t\treturn dir;\n \n \tstart = sBlk.s.directory_table_start + (*i)->start;\n \tbytes = lookup_entry(directory_table_hash, start);\n// bug_start\n\n// bug_end\n \tif(bytes == -1)\n \t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n \t\t\t\"found!\\n\", block_start);\n \n \tbytes += (*i)->offset;\n// bug_start\n\tsize = (*i)->data + bytes - 3;\n// bug_end\n \n \twhile(bytes < size) {\n \t\tif(swap) {\n// bug_start\n\t\t\tsquashfs_dir_header_3 sdirh;\n// bug_end\n \t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n// bug_start\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n// bug_end\n \t\t} else\n \t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n \n \t\tdir_count = dirh.count + 1;\n \t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n \t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n \t\tbytes += sizeof(dirh);\n \n \t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n \t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n \t\t\tgoto corrupted;\n \t\t}\n \n \t\twhile(dir_count--) {\n \t\t\tif(swap) {\n// bug_start\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n// bug_end\n \t\t\t\tmemcpy(&sdire, directory_table + bytes,\n \t\t\t\t\tsizeof(sdire));\n// bug_start\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n// bug_end\n \t\t\t} else\n \t\t\t\tmemcpy(dire, directory_table + bytes,\n \t\t\t\t\tsizeof(*dire));\n \t\t\tbytes += sizeof(*dire);\n \n \t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n \t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tmemcpy(dire->name, directory_table + bytes,\n \t\t\t\tdire->size + 1);\n \t\t\tdire->name[dire->size + 1] = '\\0';\n// bug_start\n// bug_end\n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);\n \t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n \t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n \t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n \t\t\t\tif(new_dir == NULL)\n \t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n \t\t\t\t\t\t\"realloc failed!\\n\");\n \t\t\t\tdir->dirs = new_dir;\n \t\t\t}\n \t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n \t\t\tdir->dirs[dir->dir_count].start_block =\n \t\t\t\tdirh.start_block;\n \t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n \t\t\tdir->dirs[dir->dir_count].type = dire->type;\n \t\t\tdir->dir_count ++;\n \t\t\tbytes += dire->size + 1;\n \t\t}\n \t}\n \n \treturn dir;\n \n corrupted:\n \tfree(dir->dirs);\n \tfree(dir);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n// fix_end\n// fix_start\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n// fix_end\n// fix_start\n\tif ((*i)->data == 0)\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\tsize = (*i)->data + bytes;\n// fix_end\n// fix_start\n\t\t\tsquashfs_dir_header_2 sdirh;\n// fix_end\n// fix_start\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n// fix_end\n// fix_start\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n// fix_end\n// fix_start\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n// fix_end\n// fix_start\n\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2021-40153", "cve_desc": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.", "project": "squashfs-tools", "idx": 210701}
{"source": " static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n \tstruct inode **i)\n {\n \tstruct squashfs_dir_header dirh;\n \tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n \t\t__attribute__((aligned));\n \tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n \tlong long start;\n \tlong long bytes;\n \tint dir_count, size;\n \tstruct dir_ent *new_dir;\n \tstruct dir *dir;\n \n \tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n \t\tblock_start, offset);\n \n \t*i = read_inode(block_start, offset);\n \n \tdir = malloc(sizeof(struct dir));\n \tif(dir == NULL)\n \t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n \n \tdir->dir_count = 0;\n \tdir->cur_entry = 0;\n \tdir->mode = (*i)->mode;\n \tdir->uid = (*i)->uid;\n \tdir->guid = (*i)->gid;\n \tdir->mtime = (*i)->time;\n \tdir->xattr = (*i)->xattr;\n \tdir->dirs = NULL;\n \n \tif ((*i)->data == 3)\n \t\treturn dir;\n \n \tstart = sBlk.s.directory_table_start + (*i)->start;\n \tbytes = lookup_entry(directory_table_hash, start);\n \n \tif(bytes == -1)\n \t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %lld not \"\n \t\t\t\"found!\\n\", start);\n \n \tbytes += (*i)->offset;\n \tsize = (*i)->data + bytes - 3;\n \n \twhile(bytes < size) {\n \t\tSQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh);\n \n \t\tdir_count = dirh.count + 1;\n \t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n \t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n \t\tbytes += sizeof(dirh);\n \n \t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n \t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n \t\t\tgoto corrupted;\n \t\t}\n \n \t\twhile(dir_count--) {\n \t\t\tSQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire);\n \n \t\t\tbytes += sizeof(*dire);\n \n \t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n \t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n \t\t\t\tgoto corrupted;\n \t\t\t}\n \n \t\t\tmemcpy(dire->name, directory_table + bytes,\n \t\t\t\tdire->size + 1);\n \t\t\tdire->name[dire->size + 1] = '\\0';\n// bug_start\n// bug_end\n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);\n \t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n \t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n \t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n \t\t\t\tif(new_dir == NULL)\n \t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n \t\t\t\t\t\t\"realloc failed!\\n\");\n \t\t\t\tdir->dirs = new_dir;\n \t\t\t}\n \t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n \t\t\tdir->dirs[dir->dir_count].start_block =\n \t\t\t\tdirh.start_block;\n \t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n \t\t\tdir->dirs[dir->dir_count].type = dire->type;\n \t\t\tdir->dir_count ++;\n \t\t\tbytes += dire->size + 1;\n \t\t}\n \t}\n \n \treturn dir;\n \n corrupted:\n \tfree(dir->dirs);\n \tfree(dir);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2021-40153", "cve_desc": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.", "project": "squashfs-tools", "idx": 210702}
{"source": "\n", "target": "\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "cve": "CVE-2018-14665", "cve_desc": "A flaw was found in xorg-x11-server before 1.20.3. An incorrect permission check for -modulepath and -logfile options when starting Xorg. X server allows unprivileged users with the ability to log in to the system via physical console to escalate their privileges and run arbitrary code under root privileges.", "project": "xserver", "idx": 210834}
{"source": " SProcXkbSelectEvents(ClientPtr client)\n {\n     REQUEST(xkbSelectEventsReq);\n \n     swaps(&stuff->length);\n     REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n     swaps(&stuff->deviceSpec);\n     swaps(&stuff->affectWhich);\n     swaps(&stuff->clear);\n     swaps(&stuff->selectAll);\n     swaps(&stuff->affectMap);\n     swaps(&stuff->map);\n     if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n         union {\n             BOOL *b;\n             CARD8 *c8;\n             CARD16 *c16;\n             CARD32 *c32;\n         } from;\n         register unsigned bit, ndx, maskLeft, dataLeft, size;\n \n         from.c8 = (CARD8 *) &stuff[1];\n// bug_start\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n// bug_end\n         maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n         for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n             if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                 continue;\n             maskLeft &= ~bit;\n             if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                 continue;\n             switch (ndx) {\n             case XkbNewKeyboardNotify:\n             case XkbStateNotify:\n             case XkbNamesNotify:\n             case XkbAccessXNotify:\n             case XkbExtensionDeviceNotify:\n                 size = 2;\n                 break;\n             case XkbControlsNotify:\n             case XkbIndicatorStateNotify:\n             case XkbIndicatorMapNotify:\n                 size = 4;\n                 break;\n             case XkbBellNotify:\n             case XkbActionMessage:\n             case XkbCompatMapNotify:\n                 size = 1;\n                 break;\n             default:\n                 client->errorValue = _XkbErrCode2(0x1, bit);\n                 return BadValue;\n             }\n             if (dataLeft < (size * 2))\n                 return BadLength;\n             if (size == 2) {\n                 swaps(&from.c16[0]);\n                 swaps(&from.c16[1]);\n             }\n             else if (size == 4) {\n                 swapl(&from.c32[0]);\n                 swapl(&from.c32[1]);\n             }\n             else {\n                 size = 2;\n             }\n             from.c8 += (size * 2);\n             dataLeft -= (size * 2);\n         }\n         if (dataLeft > 2) {\n             ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                    dataLeft);\n             return BadLength;\n         }\n     }\n     return ProcXkbSelectEvents(client);\n }\n \n", "target": "// fix_start\n        dataLeft = (client->req_len * 4) - SIZEOF(xkbSelectEventsReq);\n// fix_end\n", "cwe": "CWE-191", "cwe_name": "Integer Underflow (Wrap or Wraparound)", "cve": "CVE-2020-14361", "cve_desc": "A flaw was found in X.Org Server before xorg-x11-server 1.20.9. An Integer underflow leading to heap-buffer overflow may lead to a privilege escalation vulnerability. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.", "project": "xserver", "idx": 210866}
{"source": " e1000_send_packet(E1000State *s, const uint8_t *buf, int size)\n {\n     static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,\n                                     PTC1023, PTC1522 };\n \n     NetClientState *nc = qemu_get_queue(s->nic);\n     if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {\n// bug_start\n        nc->info->receive(nc, buf, size);\n// bug_end\n     } else {\n         qemu_send_packet(nc, buf, size);\n     }\n     inc_tx_bcast_or_mcast_count(s, buf);\n     e1000x_increase_size_stats(s->mac_reg, PTCregs, size);\n }\n \n", "target": "// fix_start\n        qemu_receive_packet(nc, buf, size);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "project": "qemu", "idx": 210887}
{"source": " void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                        int group_id)\n {\n     int slot_id;\n     int generation;\n     unsigned long h_virt;\n \n     MemSlot *slot;\n \n// bug_start\n    if (group_id > info->num_memslots_groups) {\n// bug_end\n         spice_critical(\"group_id too big\");\n         return NULL;\n     }\n \n     slot_id = memslot_get_id(info, addr);\n// bug_start\n    if (slot_id > info->num_memslots) {\n// bug_end\n         print_memslots(info);\n         spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n         return NULL;\n     }\n \n     slot = &info->mem_slots[group_id][slot_id];\n \n     generation = memslot_get_generation(info, addr);\n     if (generation != slot->generation) {\n         print_memslots(info);\n         spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                        \"gen %d, slot_gen %d\",\n                        group_id, slot_id,\n                        generation, slot->generation);\n         return NULL;\n     }\n \n     h_virt = __get_clean_virt(info, addr);\n     h_virt += slot->address_delta;\n \n     if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n         return NULL;\n     }\n \n     return (void*)(uintptr_t)h_virt;\n }\n \n", "target": "// fix_start\n    if (group_id >= info->num_memslots_groups) {\n// fix_end\n// fix_start\n    if (slot_id >= info->num_memslots) {\n// fix_end\n", "cwe": "CWE-193", "cwe_name": "Off-by-one Error", "cve": "CVE-2019-3813", "cve_desc": "Spice, versions 0.5.2 through 0.14.1, are vulnerable to an out-of-bounds read due to an off-by-one error in memslot_get_virt. This may lead to a denial of service, or, in the worst case, code-execution by unauthenticated attackers.", "project": "spice", "idx": 210896}
{"source": " static void warnf(struct Configurable *config, const char *fmt, ...)\n {\n   if(!(config->conf & CONF_MUTE)) {\n     va_list ap;\n     int len;\n     char *ptr;\n     char print_buffer[256];\n \n     va_start(ap, fmt);\n     va_start(ap, fmt);\n     len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n     va_end(ap);\n \n     ptr = print_buffer;\n     while(len > 0) {\n       fputs(WARN_PREFIX, config->errors);\n \n       if(len > (int)WARN_TEXTWIDTH) {\n         int cut = WARN_TEXTWIDTH-1;\n \n         while(!ISSPACE(ptr[cut]) && cut) {\n           cut--;\n         }\n// bug_start\n// bug_end\n \n         fwrite(ptr, cut + 1, 1, config->errors);\n         fputs(\"\\n\", config->errors);\n         ptr += cut+1;\n         len -= cut;\n       }\n       else {\n         fputs(ptr, config->errors);\n         len = 0;\n       }\n     }\n   }\n }\n \n", "target": "// fix_start\n        if(0 == cut)\n          cut = WARN_TEXTWIDTH-1;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2018-16842", "cve_desc": "Curl versions 7.14.1 through 7.61.1 are vulnerable to a heap-based buffer over-read in the tool_msgs.c:voutf() function that may result in information exposure and denial of service.", "project": "curl", "idx": 210904}
{"source": " win_redr_status(win_T *wp, int ignore_pum UNUSED)\n {\n     int\t\trow;\n     char_u\t*p;\n     int\t\tlen;\n     int\t\tfillchar;\n     int\t\tattr;\n     int\t\tthis_ru_col;\n     static int  busy = FALSE;\n \n     if (busy)\n \treturn;\n     busy = TRUE;\n \n     row = statusline_row(wp);\n \n     wp->w_redr_status = FALSE;\n     if (wp->w_status_height == 0)\n     {\n \tredraw_cmdline = TRUE;\n     }\n     else if (!redrawing()\n \t    || (!ignore_pum && pum_visible()))\n     {\n \twp->w_redr_status = TRUE;\n     }\n #ifdef FEAT_STL_OPT\n     else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n     {\n \tredraw_custom_statusline(wp);\n     }\n #endif\n     else\n     {\n \tfillchar = fillchar_status(&attr, wp);\n \n \tget_trans_bufname(wp->w_buffer);\n \tp = NameBuff;\n \tlen = (int)STRLEN(p);\n \n// bug_start\n\tif (bt_help(wp->w_buffer)\n// bug_end\n #ifdef FEAT_QUICKFIX\n// bug_start\n\t\t|| wp->w_p_pvw\n// bug_end\n #endif\n// bug_start\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n// bug_end\n \t    *(p + len++) = ' ';\n \tif (bt_help(wp->w_buffer))\n \t{\n \t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n \t    len += (int)STRLEN(p + len);\n \t}\n #ifdef FEAT_QUICKFIX\n \tif (wp->w_p_pvw)\n \t{\n \t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n \t    len += (int)STRLEN(p + len);\n \t}\n #endif\n \tif (bufIsChanged(wp->w_buffer)\n #ifdef FEAT_TERMINAL\n \t\t&& !bt_terminal(wp->w_buffer)\n #endif\n \t\t)\n \t{\n \t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n \t    len += (int)STRLEN(p + len);\n \t}\n \tif (wp->w_buffer->b_p_ro)\n \t{\n \t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n \t    len += (int)STRLEN(p + len);\n \t}\n \n \tthis_ru_col = ru_col - (Columns - wp->w_width);\n \tif (this_ru_col < (wp->w_width + 1) / 2)\n \t    this_ru_col = (wp->w_width + 1) / 2;\n \tif (this_ru_col <= 1)\n \t{\n \t    p = (char_u *)\"<\";\n \t    len = 1;\n \t}\n \telse if (has_mbyte)\n \t{\n \t    int\tclen = 0, i;\n \n \t    clen = mb_string2cells(p, -1);\n \n \t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n \t\t    i += (*mb_ptr2len)(p + i))\n \t\tclen -= (*mb_ptr2cells)(p + i);\n \t    len = clen;\n \t    if (i > 0)\n \t    {\n \t\tp = p + i - 1;\n \t\t*p = '<';\n \t\t++len;\n \t    }\n \n \t}\n \telse if (len > this_ru_col - 1)\n \t{\n \t    p += len - (this_ru_col - 1);\n \t    *p = '<';\n \t    len = this_ru_col - 1;\n \t}\n \n \tscreen_puts(p, row, wp->w_wincol, attr);\n \tscreen_fill(row, row + 1, len + wp->w_wincol,\n \t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n \n \tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n \t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n \t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n \t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n \n #ifdef FEAT_CMDL_INFO\n \twin_redr_ruler(wp, TRUE, ignore_pum);\n #endif\n     }\n \n     if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n     {\n \tif (stl_connected(wp))\n \t    fillchar = fillchar_status(&attr, wp);\n \telse\n \t    fillchar = fillchar_vsep(&attr);\n \tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n     }\n     busy = FALSE;\n }\n \n", "target": "// fix_start\n\tif ((bt_help(wp->w_buffer)\n// fix_end\n// fix_start\n\t\t    || wp->w_p_pvw\n// fix_end\n// fix_start\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2022-0213", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "project": "vim", "idx": 210910}
{"source": " void jfs_evict_inode(struct inode *inode)\n {\n \tstruct jfs_inode_info *ji = JFS_IP(inode);\n \n \tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n \n \tif (!inode->i_nlink && !is_bad_inode(inode)) {\n \t\tdquot_initialize(inode);\n \n \t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n// bug_start\n// bug_end\n \t\t\ttruncate_inode_pages_final(&inode->i_data);\n \n \t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n \t\t\t\tjfs_free_zero_link(inode);\n \n// bug_start\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n// bug_end\n \t\t\t\tdiFree(inode);\n \n \t\t\tdquot_free_inode(inode);\n \t\t}\n \t} else {\n \t\ttruncate_inode_pages_final(&inode->i_data);\n \t}\n \tclear_inode(inode);\n \tdquot_drop(inode);\n \n \tBUG_ON(!list_empty(&ji->anon_inode_list));\n \n \tspin_lock_irq(&ji->ag_lock);\n \tif (ji->active_ag != -1) {\n \t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n \t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n \t\tji->active_ag = -1;\n \t}\n \tspin_unlock_irq(&ji->ag_lock);\n }\n \n", "target": "// fix_start\n\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;\n// fix_end\n// fix_start\n\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-3202", "cve_desc": "A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information.", "project": "linux", "idx": 210928}
{"source": " do_cmdline(\n     char_u\t*cmdline,\n     char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n     void\t*cookie,\n     int\t\tflags)\n {\n     char_u\t*next_cmdline;\n     char_u\t*cmdline_copy = NULL;\n     int\t\tused_getline = FALSE;\n     static int\trecursive = 0;\n     int\t\tmsg_didout_before_start = 0;\n     int\t\tcount = 0;\n     int\t\tdid_inc = FALSE;\n     int\t\tretval = OK;\n #ifdef FEAT_EVAL\n     cstack_T\tcstack;\n     garray_T\tlines_ga;\n     int\t\tcurrent_line = 0;\n     int\t\tcurrent_line_before = 0;\n     char_u\t*fname = NULL;\n     linenr_T\t*breakpoint = NULL;\n     int\t\t*dbg_tick = NULL;\n     struct dbg_stuff debug_saved;\n     int\t\tinitial_trylevel;\n     msglist_T\t**saved_msg_list = NULL;\n     msglist_T\t*private_msg_list = NULL;\n \n     char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n     void\t*cmd_cookie;\n     struct loop_cookie cmd_loop_cookie;\n     void\t*real_cookie;\n     int\t\tgetline_is_func;\n #else\n # define cmd_getline fgetline\n # define cmd_cookie cookie\n #endif\n     static int\tcall_depth = 0;\n #ifdef FEAT_EVAL\n     saved_msg_list = msg_list;\n     msg_list = &private_msg_list;\n #endif\n \n     if (call_depth >= 200\n #ifdef FEAT_EVAL\n \t    && call_depth >= p_mfd\n #endif\n \t    )\n     {\n \temsg(_(e_command_too_recursive));\n #ifdef FEAT_EVAL\n \tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n \tmsg_list = saved_msg_list;\n #endif\n \treturn FAIL;\n     }\n     ++call_depth;\n \n #ifdef FEAT_EVAL\n     CLEAR_FIELD(cstack);\n     cstack.cs_idx = -1;\n     ga_init2(&lines_ga, sizeof(wcmd_T), 10);\n \n     real_cookie = getline_cookie(fgetline, cookie);\n \n     getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n     if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n \t++ex_nesting_level;\n \n     if (getline_is_func)\n     {\n \tfname = func_name(real_cookie);\n \tbreakpoint = func_breakpoint(real_cookie);\n \tdbg_tick = func_dbg_tick(real_cookie);\n     }\n     else if (getline_equal(fgetline, cookie, getsourceline))\n     {\n \tfname = SOURCING_NAME;\n \tbreakpoint = source_breakpoint(real_cookie);\n \tdbg_tick = source_dbg_tick(real_cookie);\n     }\n \n     if (!recursive)\n     {\n \tforce_abort = FALSE;\n \tsuppress_errthrow = FALSE;\n     }\n \n     if (flags & DOCMD_EXCRESET)\n \tsave_dbg_stuff(&debug_saved);\n     else\n \tCLEAR_FIELD(debug_saved);\n \n     initial_trylevel = trylevel;\n \n     did_throw = FALSE;\n #endif\n #ifdef FEAT_EVAL\n     did_emsg_cumul += did_emsg;\n #endif\n     did_emsg = FALSE;\n \n     if (!(flags & DOCMD_KEYTYPED)\n \t\t\t       && !getline_equal(fgetline, cookie, getexline))\n \tKeyTyped = FALSE;\n \n     next_cmdline = cmdline;\n     do\n     {\n #ifdef FEAT_EVAL\n \tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n #endif\n \n \tif (next_cmdline == NULL\n #ifdef FEAT_EVAL\n \t\t&& !force_abort\n \t\t&& cstack.cs_idx < 0\n \t\t&& !(getline_is_func && func_has_abort(real_cookie))\n #endif\n \t\t\t\t\t\t\t)\n \t{\n #ifdef FEAT_EVAL\n \t    did_emsg_cumul += did_emsg;\n #endif\n \t    did_emsg = FALSE;\n \t}\n \n \n #ifdef FEAT_EVAL\n \tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n \t{\n \t    VIM_CLEAR(cmdline_copy);\n \n \t    if (getline_is_func)\n \t    {\n # ifdef FEAT_PROFILE\n \t\tif (do_profiling == PROF_YES)\n \t\t    func_line_end(real_cookie);\n # endif\n \t\tif (func_has_ended(real_cookie))\n \t\t{\n \t\t    retval = FAIL;\n \t\t    break;\n \t\t}\n \t    }\n #ifdef FEAT_PROFILE\n \t    else if (do_profiling == PROF_YES\n \t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n \t\tscript_line_end();\n #endif\n \n \t    if (source_finished(fgetline, cookie))\n \t    {\n \t\tretval = FAIL;\n \t\tbreak;\n \t    }\n \n \t    if (breakpoint != NULL && dbg_tick != NULL\n \t\t\t\t\t\t   && *dbg_tick != debug_tick)\n \t    {\n \t\t*breakpoint = dbg_find_breakpoint(\n \t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n \t\t\t\t\t\t\tfname, SOURCING_LNUM);\n \t\t*dbg_tick = debug_tick;\n \t    }\n \n \t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n \t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n \n \t    if (breakpoint != NULL && *breakpoint != 0\n \t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n \t    {\n \t\tdbg_breakpoint(fname, SOURCING_LNUM);\n \t\t*breakpoint = dbg_find_breakpoint(\n \t\t\t       getline_equal(fgetline, cookie, getsourceline),\n \t\t\t\t\t\t\tfname, SOURCING_LNUM);\n \t\t*dbg_tick = debug_tick;\n \t    }\n # ifdef FEAT_PROFILE\n \t    if (do_profiling == PROF_YES)\n \t    {\n \t\tif (getline_is_func)\n \t\t    func_line_start(real_cookie, SOURCING_LNUM);\n \t\telse if (getline_equal(fgetline, cookie, getsourceline))\n \t\t    script_line_start();\n \t    }\n # endif\n \t}\n #endif\n \n \tif (next_cmdline == NULL)\n \t{\n \t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n \t\tmsg_didout = TRUE;\n \t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n #ifdef FEAT_EVAL\n \t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n #else\n \t\t    0\n #endif\n \t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n \t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n \t    {\n \t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n \t\t    need_wait_return = FALSE;\n \t\tretval = FAIL;\n \t\tbreak;\n \t    }\n \t    used_getline = TRUE;\n \n \t    if (flags & DOCMD_KEEPLINE)\n \t    {\n \t\tvim_free(repeat_cmdline);\n \t\tif (count == 0)\n \t\t    repeat_cmdline = vim_strsave(next_cmdline);\n \t\telse\n \t\t    repeat_cmdline = NULL;\n \t    }\n \t}\n \n \telse if (cmdline_copy == NULL)\n \t{\n \t    next_cmdline = vim_strsave(next_cmdline);\n \t    if (next_cmdline == NULL)\n \t    {\n \t\temsg(_(e_out_of_memory));\n \t\tretval = FAIL;\n \t\tbreak;\n \t    }\n \t}\n \tcmdline_copy = next_cmdline;\n \n #ifdef FEAT_EVAL\n \tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n \t{\n \t    cmd_getline = get_loop_line;\n \t    cmd_cookie = (void *)&cmd_loop_cookie;\n \t    cmd_loop_cookie.lines_gap = &lines_ga;\n \t    cmd_loop_cookie.current_line = current_line;\n \t    cmd_loop_cookie.getline = fgetline;\n \t    cmd_loop_cookie.cookie = cookie;\n \t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n \n \t    if (current_line == lines_ga.ga_len\n \t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n \t    {\n \t\tretval = FAIL;\n \t\tbreak;\n \t    }\n \t    current_line_before = current_line;\n \t}\n \telse\n \t{\n \t    cmd_getline = fgetline;\n \t    cmd_cookie = cookie;\n \t}\n \n \tdid_endif = FALSE;\n #endif\n \n \tif (count++ == 0)\n \t{\n \t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n \t    {\n \t\tmsg_didout_before_start = msg_didout;\n \t\tmsg_didany = FALSE;\n \t\tmsg_start();\n \t\tmsg_scroll = TRUE;\n \t\t++no_wait_return;\n \t\t++RedrawingDisabled;\n \t\tdid_inc = TRUE;\n \t    }\n \t}\n \n \tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n \t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n \n \t++recursive;\n \tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n #ifdef FEAT_EVAL\n \t\t\t\t&cstack,\n #endif\n \t\t\t\tcmd_getline, cmd_cookie);\n \t--recursive;\n \n #ifdef FEAT_EVAL\n \tif (cmd_cookie == (void *)&cmd_loop_cookie)\n \t    current_line = cmd_loop_cookie.current_line;\n #endif\n \n \tif (next_cmdline == NULL)\n \t{\n \t    VIM_CLEAR(cmdline_copy);\n \n \t    if (getline_equal(fgetline, cookie, getexline)\n \t\t\t\t\t\t  && new_last_cmdline != NULL)\n \t    {\n \t\tvim_free(last_cmdline);\n \t\tlast_cmdline = new_last_cmdline;\n \t\tnew_last_cmdline = NULL;\n \t    }\n \t}\n \telse\n \t{\n \t    STRMOVE(cmdline_copy, next_cmdline);\n \t    next_cmdline = cmdline_copy;\n \t}\n \n \n #ifdef FEAT_EVAL\n \tif (did_emsg && !force_abort\n \t\t&& getline_equal(fgetline, cookie, get_func_line)\n \t\t\t\t\t      && !func_has_abort(real_cookie))\n \t{\n \t    did_emsg = FALSE;\n \t}\n \n \tif (cstack.cs_looplevel > 0)\n \t{\n \t    ++current_line;\n \n \t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n \t    {\n \t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n \n \t\tif (!did_emsg && !got_int && !did_throw\n \t\t\t&& cstack.cs_idx >= 0\n \t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n \t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n \t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n \t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n \t\t{\n \t\t    current_line = cstack.cs_line[cstack.cs_idx];\n \t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n \t\t    line_breakcheck();\n \n// bug_start\n\t\t    if (breakpoint != NULL)\n// bug_end\n \t\t    {\n \t\t\t*breakpoint = dbg_find_breakpoint(\n \t\t\t       getline_equal(fgetline, cookie, getsourceline),\n \t\t\t\t\t\t\t\t\tfname,\n \t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n \t\t\t*dbg_tick = debug_tick;\n \t\t    }\n \t\t}\n \t\telse\n \t\t{\n \t\t    if (cstack.cs_idx >= 0)\n \t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n \t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n \t\t}\n \t    }\n \n \t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n \t    {\n \t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n \t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n \t    }\n \t}\n \n \tif (breakpoint != NULL && has_watchexpr())\n \t{\n \t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n \t    *dbg_tick = debug_tick;\n \t}\n \n \tif (cstack.cs_looplevel == 0)\n \t{\n \t    if (lines_ga.ga_len > 0)\n \t    {\n \t\tSOURCING_LNUM =\n \t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n \t\tfree_cmdlines(&lines_ga);\n \t    }\n \t    current_line = 0;\n \t}\n \n \tif (cstack.cs_lflags & CSL_HAD_FINA)\n \t{\n \t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n \t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n \t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n \t\t    did_throw ? (void *)current_exception : NULL);\n \t    did_emsg = got_int = did_throw = FALSE;\n \t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n \t}\n \n \ttrylevel = initial_trylevel + cstack.cs_trylevel;\n \n \tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n \t    force_abort = FALSE;\n \n \t(void)do_intthrow(&cstack);\n #endif\n \n     }\n     while (!((got_int\n #ifdef FEAT_EVAL\n \t\t    || (did_emsg && (force_abort || in_vim9script()))\n \t\t    || did_throw\n #endif\n \t     )\n #ifdef FEAT_EVAL\n \t\t&& cstack.cs_trylevel == 0\n #endif\n \t    )\n \t    && !(did_emsg\n #ifdef FEAT_EVAL\n \t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n #endif\n \t\t&& used_getline\n \t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n \t\t\t       || getline_equal(fgetline, cookie, getexline)))\n \t    && (next_cmdline != NULL\n #ifdef FEAT_EVAL\n \t\t\t|| cstack.cs_idx >= 0\n #endif\n \t\t\t|| (flags & DOCMD_REPEAT)));\n \n     vim_free(cmdline_copy);\n     did_emsg_syntax = FALSE;\n #ifdef FEAT_EVAL\n     free_cmdlines(&lines_ga);\n     ga_clear(&lines_ga);\n \n     if (cstack.cs_idx >= 0)\n     {\n \tif (!got_int && !did_throw && !aborting()\n \t\t&& !(did_emsg && in_vim9script())\n \t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n \t\t\t&& !source_finished(fgetline, cookie))\n \t\t    || (getline_equal(fgetline, cookie, get_func_line)\n \t\t\t\t\t    && !func_has_ended(real_cookie))))\n \t{\n \t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n \t\temsg(_(e_missing_endtry));\n \t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n \t\temsg(_(e_missing_endwhile));\n \t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n \t\temsg(_(e_missing_endfor));\n \t    else\n \t\temsg(_(e_missing_endif));\n \t}\n \n \tdo\n \t{\n \t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n \n \t    if (idx >= 0)\n \t\t--idx;\n \t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n \t\t\t\t\t\t\t&cstack.cs_looplevel);\n \t}\n \twhile (cstack.cs_idx >= 0);\n \ttrylevel = initial_trylevel;\n     }\n \n     do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n \t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n \n     if (trylevel == 0)\n     {\n \tif (current_exception == NULL)\n \t    did_throw = FALSE;\n \n \tif (did_throw)\n \t    handle_did_throw();\n \n \telse if (got_int || (did_emsg && force_abort))\n \t    suppress_errthrow = TRUE;\n     }\n \n     if (did_throw)\n \tneed_rethrow = TRUE;\n     if ((getline_equal(fgetline, cookie, getsourceline)\n \t\t&& ex_nesting_level > source_level(real_cookie))\n \t    || (getline_equal(fgetline, cookie, get_func_line)\n \t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n     {\n \tif (!did_throw)\n \t    check_cstack = TRUE;\n     }\n     else\n     {\n \tif (getline_equal(fgetline, cookie, get_func_line))\n \t    --ex_nesting_level;\n \tif ((getline_equal(fgetline, cookie, getsourceline)\n \t\t    || getline_equal(fgetline, cookie, get_func_line))\n \t\t&& ex_nesting_level + 1 <= debug_break_level)\n \t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n \t\t    ? (char_u *)_(\"End of sourced file\")\n \t\t    : (char_u *)_(\"End of function\"));\n     }\n \n     if (flags & DOCMD_EXCRESET)\n \trestore_dbg_stuff(&debug_saved);\n \n     msg_list = saved_msg_list;\n \n     if (cstack.cs_emsg_silent_list != NULL)\n     {\n \teslist_T *elem, *temp;\n \n \tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n \t{\n \t    temp = elem->next;\n \t    vim_free(elem);\n \t}\n     }\n #endif\n \n     if (did_inc)\n     {\n \t--RedrawingDisabled;\n \t--no_wait_return;\n \tmsg_scroll = FALSE;\n \n \tif (retval == FAIL\n #ifdef FEAT_EVAL\n \t\t|| (did_endif && KeyTyped && !did_emsg)\n #endif\n \t\t\t\t\t    )\n \t{\n \t    need_wait_return = FALSE;\n \t    msg_didany = FALSE;\n \t}\n \telse if (need_wait_return)\n \t{\n \t    msg_didout |= msg_didout_before_start;\n \t    wait_return(FALSE);\n \t}\n     }\n \n #ifdef FEAT_EVAL\n     did_endif = FALSE;\n #else\n     if_level = 0;\n #endif\n \n     --call_depth;\n     return retval;\n }\n \n", "target": "// fix_start\n\t\t    if (breakpoint != NULL && lines_ga.ga_len > current_line)\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-3099", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0360.", "project": "vim", "idx": 210944}
{"source": " add_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n {\n// bug_start\n\tint rc = 0;\n// bug_end\n \tuid_t uid;\n \tchar *mount_user = NULL;\n \tstruct mntent mountent;\n// bug_start\n// bug_end\n \tFILE *pmntfile;\n \tsigset_t mask, oldmask;\n \n \tuid = getuid();\n \tif (uid != 0)\n \t\tmount_user = getusername(uid);\n \n \trc = setreuid(geteuid(), -1);\n \tif (rc != 0) {\n \t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n \t\t\t\tstrerror(errno));\n \t\treturn EX_FILEIO;\n \t}\n \n \trc = sigfillset(&mask);\n \tif (rc) {\n \t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n \t\treturn EX_FILEIO;\n \t}\n \n \trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n \tif (rc) {\n \t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n \t\treturn EX_FILEIO;\n \t}\n \n \trc = toggle_dac_capability(1, 1);\n \tif (rc)\n \t\treturn EX_FILEIO;\n \n \tatexit(unlock_mtab);\n \trc = lock_mtab();\n \tif (rc) {\n \t\tfprintf(stderr, \"cannot lock mtab\");\n \t\trc = EX_FILEIO;\n \t\tgoto add_mtab_exit;\n \t}\n \n \tpmntfile = setmntent(MOUNTED, \"a+\");\n \tif (!pmntfile) {\n \t\tfprintf(stderr, \"could not update mount table\\n\");\n \t\tunlock_mtab();\n \t\trc = EX_FILEIO;\n \t\tgoto add_mtab_exit;\n \t}\n \n// bug_start\n// bug_end\n \tmountent.mnt_fsname = devname;\n \tmountent.mnt_dir = mountpoint;\n \tmountent.mnt_type = (char *)(void *)fstype;\n \tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n \tif (mountent.mnt_opts) {\n \t\tif (flags & MS_RDONLY)\n \t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n \t\telse\n \t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n \n \t\tif (flags & MS_MANDLOCK)\n \t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n \t\tif (flags & MS_NOEXEC)\n \t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n \t\tif (flags & MS_NOSUID)\n \t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n \t\tif (flags & MS_NODEV)\n \t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n \t\tif (flags & MS_SYNCHRONOUS)\n \t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n \t\tif (mount_user) {\n \t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n \t\t\tstrlcat(mountent.mnt_opts, mount_user,\n \t\t\t\tMTAB_OPTIONS_LEN);\n \t\t}\n \t}\n \tmountent.mnt_freq = 0;\n \tmountent.mnt_passno = 0;\n \trc = addmntent(pmntfile, &mountent);\n \tif (rc) {\n \t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n// bug_start\n// bug_end\n \t\trc = EX_FILEIO;\n \t}\n// bug_start\n\tendmntent(pmntfile);\n// bug_end\n \tunlock_mtab();\n \tSAFE_FREE(mountent.mnt_opts);\n add_mtab_exit:\n \ttoggle_dac_capability(1, 0);\n \tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n \n \treturn rc;\n }\n \n", "target": "// fix_start\n\tint rc = 0, tmprc, fd;\n// fix_end\n// fix_start\n\tstruct stat statbuf;\n// fix_end\n// fix_start\n\tfd = fileno(pmntfile);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"mntent does not appear to be valid\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\trc = fstat(fd, &statbuf);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"unable to fstat open mtab\\n\");\n\t\tendmntent(pmntfile);\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n// fix_end\n// fix_start\n\t\tftruncate(fd, statbuf.st_size);\n// fix_end\n// fix_start\n\ttmprc = my_endmntent(pmntfile, statbuf.st_size);\n\tif (tmprc) {\n\t\tfprintf(stderr, \"error %d detected on close of mtab\\n\", tmprc);\n\t\trc = EX_FILEIO;\n\t}\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2011-1678", "cve_desc": "smbfs in Samba 3.5.8 and earlier attempts to use (1) mount.cifs to append to the /etc/mtab file and (2) umount.cifs to append to the /etc/mtab.tmp file without first checking whether resource limits would interfere, which allows local users to trigger corruption of the /etc/mtab file via a process with a small RLIMIT_FSIZE value, a related issue to CVE-2011-1089.", "project": "cifs-utils", "idx": 211090}
{"source": " extract_archive_thread (GSimpleAsyncResult *result,\n \t\t\tGObject            *object,\n \t\t\tGCancellable       *cancellable)\n {\n \tExtractData          *extract_data;\n \tLoadData             *load_data;\n \tGHashTable           *checked_folders;\n \tstruct archive       *a;\n \tstruct archive_entry *entry;\n \tint                   r;\n \n \textract_data = g_simple_async_result_get_op_res_gpointer (result);\n \tload_data = LOAD_DATA (extract_data);\n \n \tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n \tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n \n \ta = archive_read_new ();\n \tarchive_read_support_filter_all (a);\n \tarchive_read_support_format_all (a);\n \tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n \twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n \t\tconst char    *pathname;\n \t\tchar          *fullpath;\n// bug_start\n// bug_end\n \t\tGFile         *file;\n \t\tGFile         *parent;\n \t\tGOutputStream *ostream;\n \t\tconst void    *buffer;\n \t\tsize_t         buffer_size;\n \t\tint64_t        offset;\n \t\tGError        *local_error = NULL;\n \t\t__LA_MODE_T    filetype;\n \n \t\tif (g_cancellable_is_cancelled (cancellable))\n \t\t\tbreak;\n \n \t\tpathname = archive_entry_pathname (entry);\n \t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n \t\t\tarchive_read_data_skip (a);\n \t\t\tcontinue;\n \t\t}\n \n \t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n// bug_start\n\t\tfile = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (fullpath, extract_data->base_dir, extract_data->junk_paths));\n// bug_end\n \n \n \t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n \t\t\tGFileInfo *info;\n \n \t\t\tinfo = g_file_query_info (file,\n \t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n \t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n \t\t\t\t\t\t  cancellable,\n \t\t\t\t\t\t  &local_error);\n \t\t\tif (info != NULL) {\n \t\t\t\tgboolean skip = FALSE;\n \n \t\t\t\tif (! extract_data->overwrite) {\n \t\t\t\t\tskip = TRUE;\n \t\t\t\t}\n \t\t\t\telse if (extract_data->skip_older) {\n \t\t\t\t\tGTimeVal modification_time;\n \n \t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n \t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n \t\t\t\t\t\tskip = TRUE;\n \t\t\t\t}\n \n \t\t\t\tg_object_unref (info);\n \n \t\t\t\tif (skip) {\n \t\t\t\t\tg_object_unref (file);\n \n \t\t\t\t\tarchive_read_data_skip (a);\n \t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n \n \t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n \t\t\t\t\t\tr = ARCHIVE_EOF;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n \t\t\t\t\tload_data->error = local_error;\n \t\t\t\t\tg_object_unref (info);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tg_error_free (local_error);\n \t\t\t}\n \t\t}\n \n \t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n \n \n \t\tparent = g_file_get_parent (file);\n \n \t\tif ((parent != NULL)\n \t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n \t\t    && ! g_file_query_exists (parent, cancellable))\n \t\t{\n \t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n \t\t\t\tGFile *grandparent;\n \n \t\t\t\tgrandparent = g_object_ref (parent);\n \t\t\t\twhile (grandparent != NULL) {\n \t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n \t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n \t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tg_object_unref (parent);\n \n \n \t\tfiletype = archive_entry_filetype (entry);\n \n \t\tif (load_data->error == NULL) {\n \t\t\tconst char  *linkname;\n \n \t\t\tlinkname = archive_entry_hardlink (entry);\n \t\t\tif (linkname != NULL) {\n// bug_start\n\t\t\t\tchar  *link_fullpath;\n\t\t\t\tGFile *link_file;\n\t\t\t\tchar  *oldname;\n\t\t\t\tchar  *newname;\n\t\t\t\tint    r;\n// bug_end\n \n \t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n// bug_start\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (link_fullpath, extract_data->base_dir, extract_data->junk_paths));\n// bug_end\n \t\t\t\toldname = g_file_get_path (link_file);\n \t\t\t\tnewname = g_file_get_path (file);\n \n \t\t\t\tif ((oldname != NULL) && (newname != NULL))\n \t\t\t\t\tr = link (oldname, newname);\n \t\t\t\telse\n \t\t\t\t\tr = -1;\n \n \t\t\t\tif (r == 0) {\n \t\t\t\t\t__LA_INT64_T filesize;\n \n \t\t\t\t\tif (archive_entry_size_is_set (entry))\n \t\t\t\t\t\tfilesize = archive_entry_size (entry);\n \t\t\t\t\telse\n \t\t\t\t\t\tfilesize = -1;\n \n \t\t\t\t\tif (filesize > 0)\n \t\t\t\t\t\tfiletype = AE_IFREG;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tchar *uri;\n \t\t\t\t\tchar *msg;\n \n \t\t\t\t\turi = g_file_get_uri (file);\n \t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n \t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n \n \t\t\t\t\tg_free (msg);\n \t\t\t\t\tg_free (uri);\n \t\t\t\t}\n \n \t\t\t\tg_free (newname);\n \t\t\t\tg_free (oldname);\n \t\t\t\tg_object_unref (link_file);\n \t\t\t\tg_free (link_fullpath);\n \t\t\t}\n \t\t}\n \n \t\tif (load_data->error == NULL) {\n \t\t\tswitch (filetype) {\n \t\t\tcase AE_IFDIR:\n \t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n \t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n \t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n \t\t\t\t\tg_error_free (local_error);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n \t\t\t\tarchive_read_data_skip (a);\n \t\t\t\tbreak;\n \n \t\t\tcase AE_IFREG:\n \t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n \t\t\t\tif (ostream == NULL)\n \t\t\t\t\tbreak;\n \n \t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n \t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n \t\t\t\t}\n \t\t\t\t_g_object_unref (ostream);\n \n \t\t\t\tif (r != ARCHIVE_EOF)\n \t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n \t\t\t\telse\n \t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n \t\t\t\tbreak;\n \n \t\t\tcase AE_IFLNK:\n \t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n \t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n \t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n \t\t\t\t\tg_error_free (local_error);\n \t\t\t\t}\n \t\t\t\tarchive_read_data_skip (a);\n \t\t\t\tbreak;\n \n \t\t\tdefault:\n \t\t\t\tarchive_read_data_skip (a);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tg_object_unref (file);\n \t\tg_free (fullpath);\n \n \t\tif (load_data->error != NULL)\n \t\t\tbreak;\n \n \t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n \t\t\tr = ARCHIVE_EOF;\n \t\t\tbreak;\n \t\t}\n \t}\n \n \tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n \t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n \tif (load_data->error == NULL)\n \t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n \tif (load_data->error != NULL)\n \t\tg_simple_async_result_set_from_error (result, load_data->error);\n \n \tg_hash_table_unref (checked_folders);\n \tarchive_read_free (a);\n \textract_data_free (extract_data);\n }\n \n", "target": "// fix_start\n\t\tconst char    *relative_path;\n// fix_end\n// fix_start\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n// fix_end\n// fix_start\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n// fix_end\n// fix_start\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2013-4668", "cve_desc": "Directory traversal vulnerability in File Roller 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3, when libarchive is used, allows remote attackers to create arbitrary files via a crafted archive that is not properly handled in a \"Keep directory structure\" action, related to fr-archive-libarchive.c and fr-window.c.", "project": "file-roller", "idx": 211102}
{"source": " _fr_window_ask_overwrite_dialog (OverwriteData *odata)\n {\n// bug_start\n// bug_end\n \tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n \t\tconst char *base_name;\n \t\tGFile      *destination;\n \n// bug_start\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n// bug_end\n \n// bug_start\n\t\tg_object_unref (destination);\n// bug_end\n \n// bug_start\n\t\treturn;\n// bug_end\n \t}\n \n// bug_start\n\tif (odata->edata->file_list != NULL) {\n// bug_end\n \t\tif (odata->extract_all) {\n \t\t\t_g_string_list_free (odata->edata->file_list);\n \t\t\todata->edata->file_list = NULL;\n \t\t}\n \t\todata->edata->overwrite = FR_OVERWRITE_YES;\n \t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n \t}\n \telse {\n \t\tGtkWidget *d;\n \n \t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n \t\t\t\t\t     0,\n \t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n \t\t\t\t\t     _(\"Extraction not performed\"),\n \t\t\t\t\t     NULL,\n \t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n \t\t\t\t\t     NULL);\n \t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n \t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n \n \t\tfr_window_stop_batch (odata->window);\n \t}\n \n \tg_free (odata);\n }\n \n", "target": "// fix_start\n\tgboolean perform_extraction = TRUE;\n\n// fix_end\n// fix_start\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n// fix_end\n// fix_start\n\t\t\tg_object_unref (destination);\n// fix_end\n// fix_start\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n// fix_end\n// fix_start\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\n\tif (perform_extraction) {\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2013-4668", "cve_desc": "Directory traversal vulnerability in File Roller 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3, when libarchive is used, allows remote attackers to create arbitrary files via a crafted archive that is not properly handled in a \"Keep directory structure\" action, related to fr-archive-libarchive.c and fr-window.c.", "project": "file-roller", "idx": 211103}
{"source": " LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n {\n \tstatic const char module[] = \"LZWDecodeCompat\";\n \tLZWCodecState *sp = DecoderState(tif);\n \tchar *op = (char*) op0;\n \tlong occ = (long) occ0;\n \tchar *tp;\n \tunsigned char *bp;\n \tint code, nbits;\n// bug_start\n// bug_end\n \tlong nextbits, nextdata, nbitsmask;\n \tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\n \n \t(void) s;\n \tassert(sp != NULL);\n \n \tif ((tmsize_t) occ != occ0)\n \t        return (0);\n \n \tif (sp->dec_restart) {\n \t\tlong residue;\n \n \t\tcodep = sp->dec_codep;\n \t\tresidue = codep->length - sp->dec_restart;\n \t\tif (residue > occ) {\n \t\t\tsp->dec_restart += occ;\n \t\t\tdo {\n \t\t\t\tcodep = codep->next;\n \t\t\t} while (--residue > occ);\n \t\t\ttp = op + occ;\n \t\t\tdo {\n \t\t\t\t*--tp = codep->value;\n \t\t\t\tcodep = codep->next;\n \t\t\t} while (--occ);\n \t\t\treturn (1);\n \t\t}\n \t\top += residue;\n \t\tocc -= residue;\n \t\ttp = op;\n \t\tdo {\n \t\t\t*--tp = codep->value;\n \t\t\tcodep = codep->next;\n \t\t} while (--residue);\n \t\tsp->dec_restart = 0;\n \t}\n \n \tbp = (unsigned char *)tif->tif_rawcp;\n #ifdef LZW_CHECKEOS\n \tsp->dec_bitsleft = (((uint64)tif->tif_rawcc) << 3);\n #endif\n \tnbits = sp->lzw_nbits;\n \tnextdata = sp->lzw_nextdata;\n \tnextbits = sp->lzw_nextbits;\n \tnbitsmask = sp->dec_nbitsmask;\n \toldcodep = sp->dec_oldcodep;\n \tfree_entp = sp->dec_free_entp;\n \tmaxcodep = sp->dec_maxcodep;\n \n \twhile (occ > 0) {\n \t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n \t\tif (code == CODE_EOI)\n \t\t\tbreak;\n \t\tif (code == CODE_CLEAR) {\n \t\t\tdo {\n \t\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\n \t\t\t\t_TIFFmemset(free_entp, 0,\n \t\t\t\t\t    (CSIZE - CODE_FIRST) * sizeof (code_t));\n \t\t\t\tnbits = BITS_MIN;\n \t\t\t\tnbitsmask = MAXCODE(BITS_MIN);\n \t\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n \t\t\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n \t\t\t} while (code == CODE_CLEAR);\n \t\t\tif (code == CODE_EOI)\n \t\t\t\tbreak;\n \t\t\tif (code > CODE_CLEAR) {\n \t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n \t\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\n \t\t\t\t\t     tif->tif_row);\n \t\t\t\treturn (0);\n \t\t\t}\n \t\t\t*op++ = (char)code;\n \t\t\tocc--;\n \t\t\toldcodep = sp->dec_codetab + code;\n \t\t\tcontinue;\n \t\t}\n \t\tcodep = sp->dec_codetab + code;\n \n \t\tif (free_entp < &sp->dec_codetab[0] ||\n \t\t    free_entp >= &sp->dec_codetab[CSIZE]) {\n \t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n \t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\n \t\t\treturn (0);\n \t\t}\n \n \t\tfree_entp->next = oldcodep;\n \t\tif (free_entp->next < &sp->dec_codetab[0] ||\n \t\t    free_entp->next >= &sp->dec_codetab[CSIZE]) {\n \t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n \t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\n \t\t\treturn (0);\n \t\t}\n \t\tfree_entp->firstchar = free_entp->next->firstchar;\n \t\tfree_entp->length = free_entp->next->length+1;\n \t\tfree_entp->value = (codep < free_entp) ?\n \t\t    codep->firstchar : free_entp->firstchar;\n \t\tif (++free_entp > maxcodep) {\n \t\t\tif (++nbits > BITS_MAX)\n \t\t\t\tnbits = BITS_MAX;\n \t\t\tnbitsmask = MAXCODE(nbits);\n \t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n \t\t}\n \t\toldcodep = codep;\n \t\tif (code >= 256) {\n \t\t\tif(codep->length == 0) {\n \t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n \t\t\t\t    \"Wrong length of decoded \"\n \t\t\t\t    \"string: data probably corrupted at scanline %d\",\n \t\t\t\t    tif->tif_row);\n \t\t\t\treturn (0);\n \t\t\t}\n \t\t\tif (codep->length > occ) {\n \t\t\t\tsp->dec_codep = codep;\n \t\t\t\tdo {\n \t\t\t\t\tcodep = codep->next;\n \t\t\t\t} while (codep->length > occ);\n \t\t\t\tsp->dec_restart = occ;\n \t\t\t\ttp = op + occ;\n \t\t\t\tdo  {\n \t\t\t\t\t*--tp = codep->value;\n \t\t\t\t\tcodep = codep->next;\n \t\t\t\t}  while (--occ);\n \t\t\t\tbreak;\n \t\t\t}\n// bug_start\n\t\t\tassert(occ >= codep->length);\n\t\t\top += codep->length;\n\t\t\tocc -= codep->length;\n\t\t\ttp = op;\n// bug_end\n \t\t\tdo {\n// bug_start\n\t\t\t\t*--tp = codep->value;\n\t\t\t} while( (codep = codep->next) != NULL );\n// bug_end\n \t\t} else {\n \t\t\t*op++ = (char)code;\n \t\t\tocc--;\n \t\t}\n \t}\n \n \ttif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );\n \ttif->tif_rawcp = (uint8*) bp;\n \tsp->lzw_nbits = (unsigned short)nbits;\n \tsp->lzw_nextdata = nextdata;\n \tsp->lzw_nextbits = nextbits;\n \tsp->dec_nbitsmask = nbitsmask;\n \tsp->dec_oldcodep = oldcodep;\n \tsp->dec_free_entp = free_entp;\n \tsp->dec_maxcodep = maxcodep;\n \n \tif (occ > 0) {\n #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n \t\tTIFFErrorExt(tif->tif_clientdata, module,\n \t\t\t\"Not enough data at scanline %d (short %I64d bytes)\",\n \t\t\t     tif->tif_row, (unsigned __int64) occ);\n #else\n \t\tTIFFErrorExt(tif->tif_clientdata, module,\n \t\t\t\"Not enough data at scanline %d (short %llu bytes)\",\n \t\t\t     tif->tif_row, (unsigned long long) occ);\n #endif\n \t\treturn (0);\n \t}\n \treturn (1);\n }\n \n", "target": "// fix_start\n\tint len;\n// fix_end\n// fix_start\n\t\t\tlen = codep->length;\n\t\t\ttp = op + len;\n// fix_end\n// fix_start\n\t\t\t\tint t;\n\t\t\t\t--tp;\n\t\t\t\tt = codep->value;\n\t\t\t\tcodep = codep->next;\n\t\t\t\t*tp = (char)t;\n\t\t\t} while (codep && tp > op);\n\t\t\tassert(occ >= len);\n\t\t\top += len;\n\t\t\tocc -= len;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2018-8905", "cve_desc": "In LibTIFF 4.0.9, a heap-based buffer overflow occurs in the function LZWDecodeCompat in tif_lzw.c via a crafted TIFF file, as demonstrated by tiff2ps.", "project": "libtiff", "idx": 211110}
{"source": " static void atusb_disconnect(struct usb_interface *interface)\n {\n \tstruct atusb *atusb = usb_get_intfdata(interface);\n \n \tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n \n \tatusb->shutdown = 1;\n \tcancel_delayed_work_sync(&atusb->work);\n \n \tusb_kill_anchored_urbs(&atusb->rx_urbs);\n \tatusb_free_urbs(atusb);\n \tusb_kill_urb(atusb->tx_urb);\n \tusb_free_urb(atusb->tx_urb);\n \n \tieee802154_unregister_hw(atusb->hw);\n \n// bug_start\n// bug_end\n \tieee802154_free_hw(atusb->hw);\n \n \tusb_set_intfdata(interface, NULL);\n// bug_start\n\tusb_put_dev(atusb->usb_dev);\n// bug_end\n \n \tpr_debug(\"%s done\\n\", __func__);\n }\n \n", "target": "// fix_start\n\tusb_put_dev(atusb->usb_dev);\n\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2019-19525", "cve_desc": "In the Linux kernel before 5.3.6, there is a use-after-free bug that can be caused by a malicious USB device in the drivers/net/ieee802154/atusb.c driver, aka CID-7fd25e6fc035.", "project": "linux", "idx": 211113}
{"source": " static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n     if (indx == NULL) {\n         debug_print(\"%s\", \"INDX structure not initialized\\n\");\n         return MOBI_INIT_FAILED;\n     }\n     const size_t entry_offset = indx->entries_count;\n     const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n     mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n     size_t entry_number = curr_number + entry_offset;\n     if (entry_number >= indx->total_entries_count) {\n         debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n         return MOBI_DATA_CORRUPT;\n     }\n     const size_t buf_maxlen = buf->maxlen;\n     if (buf->offset + entry_length >= buf_maxlen) {\n         debug_print(\"Entry length too long: %zu\\n\", entry_length);\n         return MOBI_DATA_CORRUPT;\n     }\n     buf->maxlen = buf->offset + entry_length;\n     size_t label_length = mobi_buffer_get8(buf);\n     if (label_length > entry_length) {\n         debug_print(\"Label length too long: %zu\\n\", label_length);\n         return MOBI_DATA_CORRUPT;\n     }\n// bug_start\n    char text[INDX_LABEL_SIZEMAX];\n// bug_end\n     if (ordt->ordt2) {\n         label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n     } else {\n         label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n// bug_start\n// bug_end\n     }\n     indx->entries[entry_number].label = malloc(label_length + 1);\n     if (indx->entries[entry_number].label == NULL) {\n         debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n         return MOBI_MALLOC_FAILED;\n     }\n     strncpy(indx->entries[entry_number].label, text, label_length + 1);\n     unsigned char *control_bytes;\n     control_bytes = buf->data + buf->offset;\n     mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n     indx->entries[entry_number].tags_count = 0;\n     indx->entries[entry_number].tags = NULL;\n     if (tagx->tags_count > 0) {\n         typedef struct {\n             uint8_t tag;\n             uint8_t tag_value_count;\n             uint32_t value_count;\n             uint32_t value_bytes;\n         } MOBIPtagx;\n         MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n         if (ptagx == NULL) {\n             debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n             return MOBI_MALLOC_FAILED;\n         }\n         uint32_t ptagx_count = 0;\n         size_t len;\n         size_t i = 0;\n         while (i < tagx->tags_count) {\n             if (tagx->tags[i].control_byte == 1) {\n                 control_bytes++;\n                 i++;\n                 continue;\n             }\n             uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n             if (value != 0) {\n                 uint32_t value_count = MOBI_NOTSET;\n                 uint32_t value_bytes = MOBI_NOTSET;\n                 if (value == tagx->tags[i].bitmask) {\n                     if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                         len = 0;\n                         value_bytes = mobi_buffer_get_varlen(buf, &len);\n                     } else {\n                         value_count = 1;\n                     }\n                 } else {\n                     uint8_t mask = tagx->tags[i].bitmask;\n                     while ((mask & 1) == 0) {\n                         mask >>= 1;\n                         value >>= 1;\n                     }\n                     value_count = value;\n                 }\n                 ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                 ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                 ptagx[ptagx_count].value_count = value_count;\n                 ptagx[ptagx_count].value_bytes = value_bytes;\n                 ptagx_count++;\n             }\n             i++;\n         }\n         indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n         if (indx->entries[entry_number].tags == NULL) {\n             debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n             free(ptagx);\n             return MOBI_MALLOC_FAILED;\n         }\n         i = 0;\n         while (i < ptagx_count) {\n             uint32_t tagvalues_count = 0;\n             uint32_t tagvalues[INDX_TAGVALUES_MAX];\n             if (ptagx[i].value_count != MOBI_NOTSET) {\n                 size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                 while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                     len = 0;\n                     const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                     tagvalues[tagvalues_count++] = value_bytes;\n                 }\n             } else {\n                 len = 0;\n                 while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                     const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                     tagvalues[tagvalues_count++] = value_bytes;\n                 }\n             }\n             if (tagvalues_count) {\n                 const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                 indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                 if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                     debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                     free(ptagx);\n                     return MOBI_MALLOC_FAILED;\n                 }\n                 memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n             } else {\n                 indx->entries[entry_number].tags[i].tagvalues = NULL;\n             }\n             indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n             indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n             indx->entries[entry_number].tags_count++;\n             i++;\n         }\n         free(ptagx);\n     }\n     buf->maxlen = buf_maxlen;\n     return MOBI_SUCCESS;\n }\n \n", "target": "// fix_start\n    char text[INDX_LABEL_SIZEMAX + 1];\n// fix_end\n// fix_start\n        if (buf->error != MOBI_SUCCESS) {\n            debug_print(\"Buffer error reading label: %d\\n\", buf->error);\n            return MOBI_DATA_CORRUPT;\n        }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-1987", "cve_desc": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.", "project": "libmobi", "idx": 211126}
{"source": " static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n \tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n \tif (!result) {\n \t\treturn NULL;\n \t}\n \n \tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n// bug_start\n\t\tut32 total_slide_infos = 0;\n// bug_end\n \t\tut32 n_slide_infos[MAX_N_HDR];\n \n \t\tut32 i;\n \t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n \t\t\tut64 hdr_offset = cache->hdr_offset[i];\n \t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n \t\t\t\tgoto beach;\n \t\t\t}\n// bug_start\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n// bug_end\n \t\t}\n \n \t\tif (!total_slide_infos) {\n \t\t\tgoto beach;\n \t\t}\n \n \t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n \t\tif (!infos) {\n \t\t\tgoto beach;\n \t\t}\n \n \t\tut32 k = 0;\n \t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n \t\t\tut64 hdr_offset = cache->hdr_offset[i];\n \t\t\tif (!n_slide_infos[i]) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tut32 sio;\n \t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tut64 slide_infos_offset = sio;\n \t\t\tif (!slide_infos_offset) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tslide_infos_offset += hdr_offset;\n \n \t\t\tut32 j;\n \t\t\tRzDyldRebaseInfo *prev_info = NULL;\n \t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n \t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n \t\t\t\tcache_mapping_slide entry;\n \t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \n \t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n \t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n \t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n \t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n \t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n \t\t\t\t\tprev_info = infos[k].info;\n \t\t\t\t\tk++;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (!k) {\n \t\t\tfree(infos);\n \t\t\tgoto beach;\n \t\t}\n \n \t\tif (k < total_slide_infos) {\n \t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n \t\t\tif (!pruned_infos) {\n \t\t\t\tfree(infos);\n \t\t\t\tgoto beach;\n \t\t\t}\n \n \t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n \t\t\tfree(infos);\n \t\t\tinfos = pruned_infos;\n \t\t}\n \n \t\tresult->entries = infos;\n \t\tresult->length = k;\n \t\treturn result;\n \t}\n \n \tif (cache->hdr->mappingCount > 1) {\n \t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n \t\tif (!infos) {\n \t\t\tgoto beach;\n \t\t}\n \n \t\tinfos[0].start = cache->maps[1].fileOffset;\n \t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n \t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n \n \t\tresult->entries = infos;\n \t\tresult->length = 1;\n \t\treturn result;\n \t}\n \n beach:\n \tfree(result);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\t\tsize_t total_slide_infos = 0;\n// fix_end\n// fix_start\n\t\t\tut32 total = total_slide_infos + n_slide_infos[i];\n\t\t\tif (total < total_slide_infos) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos = total;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-36042", "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from dyld cache files. A user opening a malicious dyld cache file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.", "project": "rizin", "idx": 211136}
{"source": "     void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n     {\n         depth++;\n         bool bFirst  = true  ;\n \n         const size_t dirSize = 32;\n         DataBuf  dir(dirSize);\n         bool bPrint = option == kpsBasic || option == kpsRecursive;\n \n         do {\n             io.seek(start,BasicIo::beg);\n             io.read(dir.pData_, 2);\n             uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n \n             bool tooBig = dirLength > 500;\n             if ( tooBig ) throw Error(55);\n \n             if ( bFirst && bPrint ) {\n                 out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                 if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n             }\n \n             for ( int i = 0 ; i < dirLength ; i ++ ) {\n                 if ( bFirst && bPrint ) {\n                     out << Internal::indent(depth)\n                         << \" address |    tag                              |     \"\n                         << \" type |    count |    offset | value\\n\";\n                 }\n                 bFirst = false;\n \n                 io.read(dir.pData_, 12);\n                 uint16_t tag    = byteSwap2(dir,0,bSwap);\n                 uint16_t type   = byteSwap2(dir,2,bSwap);\n                 uint32_t count  = byteSwap4(dir,4,bSwap);\n                 uint32_t offset = byteSwap4(dir,8,bSwap);\n \n                 if ( !typeValid(type) ) {\n                     std::cerr << \"invalid type value detected in Image::printIFDStructure:  \" << type << std::endl;\n                     start = 0;\n                     throw Error(56);\n                     break;\n                 }\n \n                 std::string sp  = \"\" ;\n \n                 uint32_t kount  = isPrintXMP(tag,option) ? count\n                                 : isPrintICC(tag,option) ? count\n                                 : isStringType(type)     ? (count > 32 ? 32 : count)\n                                 : count > 5              ? 5\n                                 : count\n                                 ;\n                 uint32_t pad    = isStringType(type) ? 1 : 0;\n                 uint32_t size   = isStringType(type) ? 1\n                                 : is2ByteType(type)  ? 2\n                                 : is4ByteType(type)  ? 4\n                                 : is8ByteType(type)  ? 8\n                                 : 1\n                                 ;\n \n// bug_start\n                DataBuf  buf(size*count + pad+20);\n// bug_end\n                 std::memcpy(buf.pData_,dir.pData_+8,4);\n                 const bool bOffsetIsPointer = count*size > 4;\n \n                 if ( bOffsetIsPointer ) {\n                     size_t   restore = io.tell();\n                     io.seek(offset,BasicIo::beg);\n                     io.read(buf.pData_,count*size);\n                     io.seek(restore,BasicIo::beg);\n                 }\n \n                 if ( bPrint ) {\n                     const uint32_t address = start + 2 + i*12 ;\n                     const std::string offsetString = bOffsetIsPointer?\n                         Internal::stringFormat(\"%10u\", offset):\n                         \"\";\n \n                     out << Internal::indent(depth)\n                     << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                               ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                     if ( isShortType(type) ){\n                         for ( size_t k = 0 ; k < kount ; k++ ) {\n                             out << sp << byteSwap2(buf,k*size,bSwap);\n                             sp = \" \";\n                         }\n                     } else if ( isLongType(type) ){\n                         for ( size_t k = 0 ; k < kount ; k++ ) {\n                             out << sp << byteSwap4(buf,k*size,bSwap);\n                             sp = \" \";\n                         }\n \n                     } else if ( isRationalType(type) ){\n                         for ( size_t k = 0 ; k < kount ; k++ ) {\n                             uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                             uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                             out << sp << a << \"/\" << b;\n                             sp = \" \";\n                         }\n                     } else if ( isStringType(type) ) {\n                         out << sp << Internal::binaryToString(buf, kount);\n                     }\n \n                     sp = kount == count ? \"\" : \" ...\";\n                     out << sp << std::endl;\n \n                     if ( option == kpsRecursive && (tag == 0x8769  || tag == 0x014a  || type == tiffIfd) ) {\n                         for ( size_t k = 0 ; k < count ; k++ ) {\n                             size_t   restore = io.tell();\n                             uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                             printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                             io.seek(restore,BasicIo::beg);\n                         }\n                     } else if ( option == kpsRecursive && tag == 0x83bb  ) {\n                         size_t   restore = io.tell();\n                         io.seek(offset,BasicIo::beg);\n                         byte* bytes=new byte[count] ;\n                         io.read(bytes,count)        ;\n                         io.seek(restore,BasicIo::beg);\n                         IptcData::printStructure(out,bytes,count,depth);\n                         delete[] bytes;\n                     }  else if ( option == kpsRecursive && tag == 0x927c  && count > 10) {\n                         size_t   restore = io.tell();\n \n                         uint32_t jump= 10           ;\n                         byte     bytes[20]          ;\n                         const char* chars = (const char*) &bytes[0] ;\n                         io.seek(offset,BasicIo::beg);\n                         io.read(bytes,jump    )     ;\n                         bytes[jump]=0               ;\n                         if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                             byte* bytes=new byte[count-jump] ;\n                             io.read(bytes,count-jump)        ;\n                             MemIo memIo(bytes,count-jump)    ;\n                             printTiffStructure(memIo,out,option,depth);\n                             delete[] bytes                   ;\n                         } else {\n                             io.seek(0,BasicIo::beg);\n                             printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                         }\n \n                         io.seek(restore,BasicIo::beg);\n                     }\n                 }\n \n                 if ( isPrintXMP(tag,option) ) {\n                     buf.pData_[count]=0;\n                     out << (char*) buf.pData_;\n                 }\n                 if ( isPrintICC(tag,option) ) {\n                     out.write((const char*)buf.pData_,count);\n                 }\n             }\n             if ( start ) {\n                 io.read(dir.pData_, 4);\n                 start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n             }\n         } while (start) ;\n \n         if ( bPrint ) {\n             out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n         }\n         out.flush();\n         depth--;\n     }\n \n", "target": "// fix_start\n\n                long long allocate = (long long) (size*count + pad+20);\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(57);\n                }\n                DataBuf  buf(allocate);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2017-17723", "cve_desc": "In Exiv2 0.26, there is a heap-based buffer over-read in the Exiv2::Image::byteSwap4 function in image.cpp. Remote attackers can exploit this vulnerability to disclose memory data or cause a denial of service via a crafted TIFF file.", "project": "exiv2", "idx": 211179}
{"source": " apprentice_load(struct magic_set *ms, const char *fn, int action)\n {\n \tint errs = 0;\n \tuint32_t i, j;\n \tsize_t files = 0, maxfiles = 0;\n \tchar **filearr = NULL;\n \tstruct stat st;\n \tstruct magic_map *map;\n \tstruct magic_entry_set mset[MAGIC_SETS];\n \tphp_stream *dir;\n \tphp_stream_dirent d;\n \n \tTSRMLS_FETCH();\n \n \tmemset(mset, 0, sizeof(mset));\n \tms->flags |= MAGIC_CHECK;\n \n \n \tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n \t{\n \t\tfile_oomem(ms, sizeof(*map));\n \t\treturn NULL;\n \t}\n \n \tif (action == FILE_CHECK)\n \t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n \n \tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n \t\tint mflen;\n \t\tchar mfn[MAXPATHLEN];\n \n \t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n \t\tif (!dir) {\n \t\t\terrs++;\n \t\t\tgoto out;\n \t\t}\n \t\twhile (php_stream_readdir(dir, &d)) {\n \t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) {\n \t\t\t\tfile_oomem(ms,\n \t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n \t\t\t\terrs++;\n \t\t\t\tphp_stream_closedir(dir);\n \t\t\t\tgoto out;\n \t\t\t}\n \t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (files >= maxfiles) {\n \t\t\t\tsize_t mlen;\n \t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n \t\t\t\tmlen = maxfiles * sizeof(*filearr);\n \t\t\t\tif ((filearr = CAST(char **,\n \t\t\t\t    erealloc(filearr, mlen))) == NULL) {\n \t\t\t\t\tfile_oomem(ms, mlen);\n// bug_start\n\t\t\t\t\tefree(mfn);\n// bug_end\n \t\t\t\t\tphp_stream_closedir(dir);\n \t\t\t\t\terrs++;\n \t\t\t\t\tgoto out;\n \t\t\t\t}\n \t\t\t}\n \t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n \t\t}\n \t\tphp_stream_closedir(dir);\n \t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n \t\tfor (i = 0; i < files; i++) {\n \t\t\tload_1(ms, action, filearr[i], &errs, mset);\n \t\t\tefree(filearr[i]);\n \t\t}\n \t\tefree(filearr);\n \t} else\n \t\tload_1(ms, action, fn, &errs, mset);\n \tif (errs)\n \t\tgoto out;\n \n \tfor (j = 0; j < MAGIC_SETS; j++) {\n \t\tfor (i = 0; i < mset[j].count; ) {\n \t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n \t\t\t\ti++;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n \t\t}\n \t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n \t\t    apprentice_sort);\n \n \t\tset_last_default(ms, mset[j].me, mset[j].count);\n \n \t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n \t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n \t\t\terrs++;\n \t\t\tgoto out;\n \t\t}\n \t}\n \n out:\n \tfor (j = 0; j < MAGIC_SETS; j++)\n \t\tmagic_entry_free(mset[j].me, mset[j].count);\n \n \tif (errs) {\n \t\tfor (j = 0; j < MAGIC_SETS; j++) {\n \t\t\tif (map->magic[j])\n \t\t\t\tefree(map->magic[j]);\n \t\t}\n \t\tefree(map);\n \t\treturn NULL;\n \t}\n \treturn map;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-17", "cwe_name": "Code", "cve": "CVE-2014-9426", "cve_desc": "The apprentice_load function in libmagic/apprentice.c in the Fileinfo component in PHP through 5.6.4 attempts to perform a free operation on a stack-based character array, which allows remote attackers to cause a denial of service (memory corruption or application crash) or possibly have unspecified other impact via unknown vectors.  NOTE: this is disputed by the vendor because the standard erealloc behavior makes the free operation unreachable", "project": "php-src", "idx": 211181}
{"source": " static int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt,\n \t\t\t\t    bgp_size_t length)\n {\n \tuint8_t *end;\n \tstruct capability_mp_data mpc;\n \tstruct capability_header *hdr;\n \tuint8_t action;\n \tiana_afi_t pkt_afi;\n \tafi_t afi;\n \tiana_safi_t pkt_safi;\n \tsafi_t safi;\n \n \tend = pnt + length;\n \n \twhile (pnt < end) {\n \t\tif (pnt + 3 > end) {\n \t\t\tzlog_info(\"%s Capability length error\", peer->host);\n \t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n \t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n \t\t\treturn BGP_Stop;\n \t\t}\n \t\taction = *pnt;\n \t\thdr = (struct capability_header *)(pnt + 1);\n \n \t\tif (action != CAPABILITY_ACTION_SET\n \t\t    && action != CAPABILITY_ACTION_UNSET) {\n \t\t\tzlog_info(\"%s Capability Action Value error %d\",\n \t\t\t\t  peer->host, action);\n \t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n \t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n \t\t\treturn BGP_Stop;\n \t\t}\n \n \t\tif (bgp_debug_neighbor_events(peer))\n \t\t\tzlog_debug(\n \t\t\t\t\"%s CAPABILITY has action: %d, code: %u, length %u\",\n \t\t\t\tpeer->host, action, hdr->code, hdr->length);\n// bug_start\n// bug_end\n \n \t\tif ((pnt + hdr->length + 3) > end) {\n \t\t\tzlog_info(\"%s Capability length error\", peer->host);\n \t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n \t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n \t\t\treturn BGP_Stop;\n \t\t}\n \n \t\tmemcpy(&mpc, pnt + 3, sizeof(struct capability_mp_data));\n \t\tpnt += hdr->length + 3;\n \n \t\tif (hdr->code == CAPABILITY_CODE_MP) {\n \t\t\tpkt_afi = ntohs(mpc.afi);\n \t\t\tpkt_safi = mpc.safi;\n \n \t\t\tif (CHECK_FLAG(peer->flags,\n \t\t\t\t       PEER_FLAG_OVERRIDE_CAPABILITY))\n \t\t\t\tcontinue;\n \n \t\t\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,\n \t\t\t\t\t\t      &safi)) {\n \t\t\t\tif (bgp_debug_neighbor_events(peer))\n \t\t\t\t\tzlog_debug(\n \t\t\t\t\t\t\"%s Dynamic Capability MP_EXT afi/safi invalid (%s/%s)\",\n \t\t\t\t\t\tpeer->host,\n \t\t\t\t\t\tiana_afi2str(pkt_afi),\n \t\t\t\t\t\tiana_safi2str(pkt_safi));\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tif (bgp_debug_neighbor_events(peer))\n \t\t\t\tzlog_debug(\n \t\t\t\t\t\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %s/%s\",\n \t\t\t\t\tpeer->host,\n \t\t\t\t\taction == CAPABILITY_ACTION_SET\n \t\t\t\t\t\t? \"Advertising\"\n \t\t\t\t\t\t: \"Removing\",\n \t\t\t\t\tiana_afi2str(pkt_afi),\n \t\t\t\t\tiana_safi2str(pkt_safi));\n \n \t\t\tif (action == CAPABILITY_ACTION_SET) {\n \t\t\t\tpeer->afc_recv[afi][safi] = 1;\n \t\t\t\tif (peer->afc[afi][safi]) {\n \t\t\t\t\tpeer->afc_nego[afi][safi] = 1;\n \t\t\t\t\tbgp_announce_route(peer, afi, safi,\n \t\t\t\t\t\t\t   false);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tpeer->afc_recv[afi][safi] = 0;\n \t\t\t\tpeer->afc_nego[afi][safi] = 0;\n \n \t\t\t\tif (peer_active_nego(peer))\n \t\t\t\t\tbgp_clear_route(peer, afi, safi);\n \t\t\t\telse\n \t\t\t\t\treturn BGP_Stop;\n \t\t\t}\n \t\t} else {\n \t\t\tflog_warn(\n \t\t\t\tEC_BGP_UNRECOGNIZED_CAPABILITY,\n \t\t\t\t\"%s unrecognized capability code: %d - ignored\",\n \t\t\t\tpeer->host, hdr->code);\n \t\t}\n \t}\n \n \treturn BGP_PACKET_NOOP;\n }\n \n", "target": "// fix_start\n\n\t\tif (hdr->length < sizeof(struct capability_mp_data)) {\n\t\t\tzlog_info(\n\t\t\t\t\"%pBP Capability structure is not properly filled out, expected at least %zu bytes but header length specified is %d\",\n\t\t\t\tpeer, sizeof(struct capability_mp_data),\n\t\t\t\thdr->length);\n\t\t\treturn BGP_Stop;\n\t\t}\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-37032", "cve_desc": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "project": "frr", "idx": 211471}
{"source": " read_bitmap_file_data (FILE    *fstream,\n \t\t       guint   *width,\n \t\t       guint   *height,\n \t\t       guchar **data,\n \t\t       int     *x_hot,\n \t\t       int     *y_hot)\n {\n \tguchar *bits = NULL;\n \tchar line[MAX_SIZE];\n \tint size;\n \tchar name_and_type[MAX_SIZE];\n \tchar *type;\n \tint value;\n \tint version10p;\n \tint padding;\n \tint bytes_per_line;\n \tguint ww = 0;\n \tguint hh = 0;\n \tint hx = -1;\n \tint hy = -1;\n \n \tif (!initialized) {\n \t\tinit_hex_table ();\n \t}\n \n #define\tRETURN(code) { g_free (bits); return code; }\n \n \twhile (fgets (line, MAX_SIZE, fstream)) {\n \t\tif (strlen (line) == MAX_SIZE-1)\n \t\t\tRETURN (FALSE);\n \t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n \t\t\tif (!(type = strrchr (name_and_type, '_')))\n \t\t\t\ttype = name_and_type;\n \t\t\telse {\n \t\t\t\ttype++;\n \t\t\t}\n \n// bug_start\n\t\t\tif (!strcmp (\"width\", type))\n// bug_end\n \t\t\t\tww = (unsigned int) value;\n// bug_start\n\t\t\tif (!strcmp (\"height\", type))\n// bug_end\n \t\t\t\thh = (unsigned int) value;\n// bug_start\n// bug_end\n \t\t\tif (!strcmp (\"hot\", type)) {\n \t\t\t\tif (type-- == name_and_type\n \t\t\t\t    || type-- == name_and_type)\n \t\t\t\t\tcontinue;\n \t\t\t\tif (!strcmp (\"x_hot\", type))\n \t\t\t\t\thx = value;\n \t\t\t\tif (!strcmp (\"y_hot\", type))\n \t\t\t\t\thy = value;\n \t\t\t}\n \t\t\tcontinue;\n \t\t}\n \n \t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n \t\t\tversion10p = 1;\n \t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n \t\t\tversion10p = 0;\n \t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n \t\t\tversion10p = 0;\n \t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n \t\t\tversion10p = 0;\n \t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n \t\t\tversion10p = 0;\n \t\telse\n \t\t\tcontinue;\n \n \t\tif (!(type = strrchr (name_and_type, '_')))\n \t\t\ttype = name_and_type;\n \t\telse\n \t\t\ttype++;\n \n \t\tif (strcmp (\"bits[]\", type))\n \t\t\tcontinue;\n \n \t\tif (!ww || !hh)\n \t\t\tRETURN (FALSE);\n \n \t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n \t\t\tpadding = 1;\n \t\telse\n \t\t\tpadding = 0;\n \n \t\tbytes_per_line = (ww+7)/8 + padding;\n \n \t\tsize = bytes_per_line * hh;\n// bug_start\n// bug_end\n \t\tbits = g_malloc (size);\n \n \t\tif (version10p) {\n \t\t\tunsigned char *ptr;\n \t\t\tint bytes;\n \n \t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n \t\t\t\tif ((value = next_int (fstream)) < 0)\n \t\t\t\t\tRETURN (FALSE);\n \t\t\t\t*(ptr++) = value;\n \t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n \t\t\t\t\t*(ptr++) = value >> 8;\n \t\t\t}\n \t\t} else {\n \t\t\tunsigned char *ptr;\n \t\t\tint bytes;\n \n \t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n \t\t\t\tif ((value = next_int (fstream)) < 0)\n \t\t\t\t\tRETURN (FALSE);\n \t\t\t\t*ptr=value;\n \t\t\t}\n \t\t}\n \t\tbreak;\n \t}\n \n \tif (!bits)\n \t\tRETURN (FALSE);\n \n \t*data = bits;\n \t*width = ww;\n \t*height = hh;\n \tif (x_hot)\n \t\t*x_hot = hx;\n \tif (y_hot)\n \t\t*y_hot = hy;\n \n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n// fix_end\n// fix_start\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n// fix_end\n// fix_start\n                        }\n// fix_end\n// fix_start\n                if (size / bytes_per_line != hh)\n                        RETURN (FALSE);\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2012-2370", "cve_desc": "Multiple integer overflows in the read_bitmap_file_data function in io-xbm.c in gdk-pixbuf before 2.26.1 allow remote attackers to cause a denial of service (application crash) via a negative (1) height or (2) width in an XBM file, which triggers a heap-based buffer overflow.", "project": "gdk-pixbuf", "idx": 211473}
{"source": " int ZEXPORT inflate(strm, flush)\n z_streamp strm;\n int flush;\n {\n     struct inflate_state FAR *state;\n     z_const unsigned char FAR *next;\n     unsigned char FAR *put;\n     unsigned have, left;\n     unsigned long hold;\n     unsigned bits;\n     unsigned in, out;\n     unsigned copy;\n     unsigned char FAR *from;\n     code here;\n     code last;\n     unsigned len;\n     int ret;\n #ifdef GUNZIP\n     unsigned char hbuf[4];\n #endif\n     static const unsigned short order[19] =\n         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n \n     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n         (strm->next_in == Z_NULL && strm->avail_in != 0))\n         return Z_STREAM_ERROR;\n \n     state = (struct inflate_state FAR *)strm->state;\n     if (state->mode == TYPE) state->mode = TYPEDO;\n     LOAD();\n     in = have;\n     out = left;\n     ret = Z_OK;\n     for (;;)\n         switch (state->mode) {\n         case HEAD:\n             if (state->wrap == 0) {\n                 state->mode = TYPEDO;\n                 break;\n             }\n             NEEDBITS(16);\n #ifdef GUNZIP\n             if ((state->wrap & 2) && hold == 0x8b1f) {\n                 if (state->wbits == 0)\n                     state->wbits = 15;\n                 state->check = crc32(0L, Z_NULL, 0);\n                 CRC2(state->check, hold);\n                 INITBITS();\n                 state->mode = FLAGS;\n                 break;\n             }\n             if (state->head != Z_NULL)\n                 state->head->done = -1;\n             if (!(state->wrap & 1) ||\n #else\n             if (\n #endif\n                 ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                 strm->msg = (char *)\"incorrect header check\";\n                 state->mode = BAD;\n                 break;\n             }\n             if (BITS(4) != Z_DEFLATED) {\n                 strm->msg = (char *)\"unknown compression method\";\n                 state->mode = BAD;\n                 break;\n             }\n             DROPBITS(4);\n             len = BITS(4) + 8;\n             if (state->wbits == 0)\n                 state->wbits = len;\n             if (len > 15 || len > state->wbits) {\n                 strm->msg = (char *)\"invalid window size\";\n                 state->mode = BAD;\n                 break;\n             }\n             state->dmax = 1U << len;\n             state->flags = 0;\n             Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n             strm->adler = state->check = adler32(0L, Z_NULL, 0);\n             state->mode = hold & 0x200 ? DICTID : TYPE;\n             INITBITS();\n             break;\n #ifdef GUNZIP\n         case FLAGS:\n             NEEDBITS(16);\n             state->flags = (int)(hold);\n             if ((state->flags & 0xff) != Z_DEFLATED) {\n                 strm->msg = (char *)\"unknown compression method\";\n                 state->mode = BAD;\n                 break;\n             }\n             if (state->flags & 0xe000) {\n                 strm->msg = (char *)\"unknown header flags set\";\n                 state->mode = BAD;\n                 break;\n             }\n             if (state->head != Z_NULL)\n                 state->head->text = (int)((hold >> 8) & 1);\n             if ((state->flags & 0x0200) && (state->wrap & 4))\n                 CRC2(state->check, hold);\n             INITBITS();\n             state->mode = TIME;\n         case TIME:\n             NEEDBITS(32);\n             if (state->head != Z_NULL)\n                 state->head->time = hold;\n             if ((state->flags & 0x0200) && (state->wrap & 4))\n                 CRC4(state->check, hold);\n             INITBITS();\n             state->mode = OS;\n         case OS:\n             NEEDBITS(16);\n             if (state->head != Z_NULL) {\n                 state->head->xflags = (int)(hold & 0xff);\n                 state->head->os = (int)(hold >> 8);\n             }\n             if ((state->flags & 0x0200) && (state->wrap & 4))\n                 CRC2(state->check, hold);\n             INITBITS();\n             state->mode = EXLEN;\n         case EXLEN:\n             if (state->flags & 0x0400) {\n                 NEEDBITS(16);\n                 state->length = (unsigned)(hold);\n                 if (state->head != Z_NULL)\n                     state->head->extra_len = (unsigned)hold;\n                 if ((state->flags & 0x0200) && (state->wrap & 4))\n                     CRC2(state->check, hold);\n                 INITBITS();\n             }\n             else if (state->head != Z_NULL)\n                 state->head->extra = Z_NULL;\n             state->mode = EXTRA;\n         case EXTRA:\n             if (state->flags & 0x0400) {\n                 copy = state->length;\n                 if (copy > have) copy = have;\n                 if (copy) {\n// bug_start\n// bug_end\n                     if (state->head != Z_NULL &&\n// bug_start\n                        state->head->extra != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n// bug_end\n                         zmemcpy(state->head->extra + len, next,\n                                 len + copy > state->head->extra_max ?\n                                 state->head->extra_max - len : copy);\n                     }\n                     if ((state->flags & 0x0200) && (state->wrap & 4))\n                         state->check = crc32(state->check, next, copy);\n                     have -= copy;\n                     next += copy;\n                     state->length -= copy;\n                 }\n                 if (state->length) goto inf_leave;\n             }\n             state->length = 0;\n             state->mode = NAME;\n         case NAME:\n             if (state->flags & 0x0800) {\n                 if (have == 0) goto inf_leave;\n                 copy = 0;\n                 do {\n                     len = (unsigned)(next[copy++]);\n                     if (state->head != Z_NULL &&\n                             state->head->name != Z_NULL &&\n                             state->length < state->head->name_max)\n                         state->head->name[state->length++] = (Bytef)len;\n                 } while (len && copy < have);\n                 if ((state->flags & 0x0200) && (state->wrap & 4))\n                     state->check = crc32(state->check, next, copy);\n                 have -= copy;\n                 next += copy;\n                 if (len) goto inf_leave;\n             }\n             else if (state->head != Z_NULL)\n                 state->head->name = Z_NULL;\n             state->length = 0;\n             state->mode = COMMENT;\n         case COMMENT:\n             if (state->flags & 0x1000) {\n                 if (have == 0) goto inf_leave;\n                 copy = 0;\n                 do {\n                     len = (unsigned)(next[copy++]);\n                     if (state->head != Z_NULL &&\n                             state->head->comment != Z_NULL &&\n                             state->length < state->head->comm_max)\n                         state->head->comment[state->length++] = (Bytef)len;\n                 } while (len && copy < have);\n                 if ((state->flags & 0x0200) && (state->wrap & 4))\n                     state->check = crc32(state->check, next, copy);\n                 have -= copy;\n                 next += copy;\n                 if (len) goto inf_leave;\n             }\n             else if (state->head != Z_NULL)\n                 state->head->comment = Z_NULL;\n             state->mode = HCRC;\n         case HCRC:\n             if (state->flags & 0x0200) {\n                 NEEDBITS(16);\n                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                     strm->msg = (char *)\"header crc mismatch\";\n                     state->mode = BAD;\n                     break;\n                 }\n                 INITBITS();\n             }\n             if (state->head != Z_NULL) {\n                 state->head->hcrc = (int)((state->flags >> 9) & 1);\n                 state->head->done = 1;\n             }\n             strm->adler = state->check = crc32(0L, Z_NULL, 0);\n             state->mode = TYPE;\n             break;\n #endif\n         case DICTID:\n             NEEDBITS(32);\n             strm->adler = state->check = ZSWAP32(hold);\n             INITBITS();\n             state->mode = DICT;\n         case DICT:\n             if (state->havedict == 0) {\n                 RESTORE();\n                 return Z_NEED_DICT;\n             }\n             strm->adler = state->check = adler32(0L, Z_NULL, 0);\n             state->mode = TYPE;\n         case TYPE:\n             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n         case TYPEDO:\n             if (state->last) {\n                 BYTEBITS();\n                 state->mode = CHECK;\n                 break;\n             }\n             NEEDBITS(3);\n             state->last = BITS(1);\n             DROPBITS(1);\n             switch (BITS(2)) {\n             case 0:\n                 Tracev((stderr, \"inflate:     stored block%s\\n\",\n                         state->last ? \" (last)\" : \"\"));\n                 state->mode = STORED;\n                 break;\n             case 1:\n                 fixedtables(state);\n                 Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                         state->last ? \" (last)\" : \"\"));\n                 state->mode = LEN_;\n                 if (flush == Z_TREES) {\n                     DROPBITS(2);\n                     goto inf_leave;\n                 }\n                 break;\n             case 2:\n                 Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                         state->last ? \" (last)\" : \"\"));\n                 state->mode = TABLE;\n                 break;\n             case 3:\n                 strm->msg = (char *)\"invalid block type\";\n                 state->mode = BAD;\n             }\n             DROPBITS(2);\n             break;\n         case STORED:\n             BYTEBITS();\n             NEEDBITS(32);\n             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                 strm->msg = (char *)\"invalid stored block lengths\";\n                 state->mode = BAD;\n                 break;\n             }\n             state->length = (unsigned)hold & 0xffff;\n             Tracev((stderr, \"inflate:       stored length %u\\n\",\n                     state->length));\n             INITBITS();\n             state->mode = COPY_;\n             if (flush == Z_TREES) goto inf_leave;\n         case COPY_:\n             state->mode = COPY;\n         case COPY:\n             copy = state->length;\n             if (copy) {\n                 if (copy > have) copy = have;\n                 if (copy > left) copy = left;\n                 if (copy == 0) goto inf_leave;\n                 zmemcpy(put, next, copy);\n                 have -= copy;\n                 next += copy;\n                 left -= copy;\n                 put += copy;\n                 state->length -= copy;\n                 break;\n             }\n             Tracev((stderr, \"inflate:       stored end\\n\"));\n             state->mode = TYPE;\n             break;\n         case TABLE:\n             NEEDBITS(14);\n             state->nlen = BITS(5) + 257;\n             DROPBITS(5);\n             state->ndist = BITS(5) + 1;\n             DROPBITS(5);\n             state->ncode = BITS(4) + 4;\n             DROPBITS(4);\n #ifndef PKZIP_BUG_WORKAROUND\n             if (state->nlen > 286 || state->ndist > 30) {\n                 strm->msg = (char *)\"too many length or distance symbols\";\n                 state->mode = BAD;\n                 break;\n             }\n #endif\n             Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n             state->have = 0;\n             state->mode = LENLENS;\n         case LENLENS:\n             while (state->have < state->ncode) {\n                 NEEDBITS(3);\n                 state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                 DROPBITS(3);\n             }\n             while (state->have < 19)\n                 state->lens[order[state->have++]] = 0;\n             state->next = state->codes;\n             state->lencode = (const code FAR *)(state->next);\n             state->lenbits = 7;\n             ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                 &(state->lenbits), state->work);\n             if (ret) {\n                 strm->msg = (char *)\"invalid code lengths set\";\n                 state->mode = BAD;\n                 break;\n             }\n             Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n             state->have = 0;\n             state->mode = CODELENS;\n         case CODELENS:\n             while (state->have < state->nlen + state->ndist) {\n                 for (;;) {\n                     here = state->lencode[BITS(state->lenbits)];\n                     if ((unsigned)(here.bits) <= bits) break;\n                     PULLBYTE();\n                 }\n                 if (here.val < 16) {\n                     DROPBITS(here.bits);\n                     state->lens[state->have++] = here.val;\n                 }\n                 else {\n                     if (here.val == 16) {\n                         NEEDBITS(here.bits + 2);\n                         DROPBITS(here.bits);\n                         if (state->have == 0) {\n                             strm->msg = (char *)\"invalid bit length repeat\";\n                             state->mode = BAD;\n                             break;\n                         }\n                         len = state->lens[state->have - 1];\n                         copy = 3 + BITS(2);\n                         DROPBITS(2);\n                     }\n                     else if (here.val == 17) {\n                         NEEDBITS(here.bits + 3);\n                         DROPBITS(here.bits);\n                         len = 0;\n                         copy = 3 + BITS(3);\n                         DROPBITS(3);\n                     }\n                     else {\n                         NEEDBITS(here.bits + 7);\n                         DROPBITS(here.bits);\n                         len = 0;\n                         copy = 11 + BITS(7);\n                         DROPBITS(7);\n                     }\n                     if (state->have + copy > state->nlen + state->ndist) {\n                         strm->msg = (char *)\"invalid bit length repeat\";\n                         state->mode = BAD;\n                         break;\n                     }\n                     while (copy--)\n                         state->lens[state->have++] = (unsigned short)len;\n                 }\n             }\n \n             if (state->mode == BAD) break;\n \n             if (state->lens[256] == 0) {\n                 strm->msg = (char *)\"invalid code -- missing end-of-block\";\n                 state->mode = BAD;\n                 break;\n             }\n \n             state->next = state->codes;\n             state->lencode = (const code FAR *)(state->next);\n             state->lenbits = 9;\n             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                 &(state->lenbits), state->work);\n             if (ret) {\n                 strm->msg = (char *)\"invalid literal/lengths set\";\n                 state->mode = BAD;\n                 break;\n             }\n             state->distcode = (const code FAR *)(state->next);\n             state->distbits = 6;\n             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                             &(state->next), &(state->distbits), state->work);\n             if (ret) {\n                 strm->msg = (char *)\"invalid distances set\";\n                 state->mode = BAD;\n                 break;\n             }\n             Tracev((stderr, \"inflate:       codes ok\\n\"));\n             state->mode = LEN_;\n             if (flush == Z_TREES) goto inf_leave;\n         case LEN_:\n             state->mode = LEN;\n         case LEN:\n             if (have >= 6 && left >= 258) {\n                 RESTORE();\n                 inflate_fast(strm, out);\n                 LOAD();\n                 if (state->mode == TYPE)\n                     state->back = -1;\n                 break;\n             }\n             state->back = 0;\n             for (;;) {\n                 here = state->lencode[BITS(state->lenbits)];\n                 if ((unsigned)(here.bits) <= bits) break;\n                 PULLBYTE();\n             }\n             if (here.op && (here.op & 0xf0) == 0) {\n                 last = here;\n                 for (;;) {\n                     here = state->lencode[last.val +\n                             (BITS(last.bits + last.op) >> last.bits)];\n                     if ((unsigned)(last.bits + here.bits) <= bits) break;\n                     PULLBYTE();\n                 }\n                 DROPBITS(last.bits);\n                 state->back += last.bits;\n             }\n             DROPBITS(here.bits);\n             state->back += here.bits;\n             state->length = (unsigned)here.val;\n             if ((int)(here.op) == 0) {\n                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                         \"inflate:         literal '%c'\\n\" :\n                         \"inflate:         literal 0x%02x\\n\", here.val));\n                 state->mode = LIT;\n                 break;\n             }\n             if (here.op & 32) {\n                 Tracevv((stderr, \"inflate:         end of block\\n\"));\n                 state->back = -1;\n                 state->mode = TYPE;\n                 break;\n             }\n             if (here.op & 64) {\n                 strm->msg = (char *)\"invalid literal/length code\";\n                 state->mode = BAD;\n                 break;\n             }\n             state->extra = (unsigned)(here.op) & 15;\n             state->mode = LENEXT;\n         case LENEXT:\n             if (state->extra) {\n                 NEEDBITS(state->extra);\n                 state->length += BITS(state->extra);\n                 DROPBITS(state->extra);\n                 state->back += state->extra;\n             }\n             Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n             state->was = state->length;\n             state->mode = DIST;\n         case DIST:\n             for (;;) {\n                 here = state->distcode[BITS(state->distbits)];\n                 if ((unsigned)(here.bits) <= bits) break;\n                 PULLBYTE();\n             }\n             if ((here.op & 0xf0) == 0) {\n                 last = here;\n                 for (;;) {\n                     here = state->distcode[last.val +\n                             (BITS(last.bits + last.op) >> last.bits)];\n                     if ((unsigned)(last.bits + here.bits) <= bits) break;\n                     PULLBYTE();\n                 }\n                 DROPBITS(last.bits);\n                 state->back += last.bits;\n             }\n             DROPBITS(here.bits);\n             state->back += here.bits;\n             if (here.op & 64) {\n                 strm->msg = (char *)\"invalid distance code\";\n                 state->mode = BAD;\n                 break;\n             }\n             state->offset = (unsigned)here.val;\n             state->extra = (unsigned)(here.op) & 15;\n             state->mode = DISTEXT;\n         case DISTEXT:\n             if (state->extra) {\n                 NEEDBITS(state->extra);\n                 state->offset += BITS(state->extra);\n                 DROPBITS(state->extra);\n                 state->back += state->extra;\n             }\n #ifdef INFLATE_STRICT\n             if (state->offset > state->dmax) {\n                 strm->msg = (char *)\"invalid distance too far back\";\n                 state->mode = BAD;\n                 break;\n             }\n #endif\n             Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n             state->mode = MATCH;\n         case MATCH:\n             if (left == 0) goto inf_leave;\n             copy = out - left;\n             if (state->offset > copy) {\n                 copy = state->offset - copy;\n                 if (copy > state->whave) {\n                     if (state->sane) {\n                         strm->msg = (char *)\"invalid distance too far back\";\n                         state->mode = BAD;\n                         break;\n                     }\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                     Trace((stderr, \"inflate.c too far\\n\"));\n                     copy -= state->whave;\n                     if (copy > state->length) copy = state->length;\n                     if (copy > left) copy = left;\n                     left -= copy;\n                     state->length -= copy;\n                     do {\n                         *put++ = 0;\n                     } while (--copy);\n                     if (state->length == 0) state->mode = LEN;\n                     break;\n #endif\n                 }\n                 if (copy > state->wnext) {\n                     copy -= state->wnext;\n                     from = state->window + (state->wsize - copy);\n                 }\n                 else\n                     from = state->window + (state->wnext - copy);\n                 if (copy > state->length) copy = state->length;\n             }\n             else {\n                 from = put - state->offset;\n                 copy = state->length;\n             }\n             if (copy > left) copy = left;\n             left -= copy;\n             state->length -= copy;\n             do {\n                 *put++ = *from++;\n             } while (--copy);\n             if (state->length == 0) state->mode = LEN;\n             break;\n         case LIT:\n             if (left == 0) goto inf_leave;\n             *put++ = (unsigned char)(state->length);\n             left--;\n             state->mode = LEN;\n             break;\n         case CHECK:\n             if (state->wrap) {\n                 NEEDBITS(32);\n                 out -= left;\n                 strm->total_out += out;\n                 state->total += out;\n                 if ((state->wrap & 4) && out)\n                     strm->adler = state->check =\n                         UPDATE_CHECK(state->check, put - out, out);\n                 out = left;\n                 if ((state->wrap & 4) && (\n #ifdef GUNZIP\n                      state->flags ? hold :\n #endif\n                      ZSWAP32(hold)) != state->check) {\n                     strm->msg = (char *)\"incorrect data check\";\n                     state->mode = BAD;\n                     break;\n                 }\n                 INITBITS();\n                 Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n             }\n #ifdef GUNZIP\n             state->mode = LENGTH;\n         case LENGTH:\n             if (state->wrap && state->flags) {\n                 NEEDBITS(32);\n                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                     strm->msg = (char *)\"incorrect length check\";\n                     state->mode = BAD;\n                     break;\n                 }\n                 INITBITS();\n                 Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n             }\n #endif\n             state->mode = DONE;\n         case DONE:\n             ret = Z_STREAM_END;\n             goto inf_leave;\n         case BAD:\n             ret = Z_DATA_ERROR;\n             goto inf_leave;\n         case MEM:\n             return Z_MEM_ERROR;\n         case SYNC:\n         default:\n             return Z_STREAM_ERROR;\n         }\n \n   inf_leave:\n     RESTORE();\n     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n             (state->mode < CHECK || flush != Z_FINISH)))\n         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n             state->mode = MEM;\n             return Z_MEM_ERROR;\n         }\n     in -= strm->avail_in;\n     out -= strm->avail_out;\n     strm->total_in += in;\n     strm->total_out += out;\n     state->total += out;\n     if ((state->wrap & 4) && out)\n         strm->adler = state->check =\n             UPDATE_CHECK(state->check, strm->next_out - out, out);\n     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                       (state->mode == TYPE ? 128 : 0) +\n                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n         ret = Z_BUF_ERROR;\n     return ret;\n }\n \n", "target": "// fix_start\n                    len = state->head->extra_len - state->length;\n// fix_end\n// fix_start\n                        state->head->extra != Z_NULL &&\n                        len < state->head->extra_max) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-37434", "cve_desc": "zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).", "project": "zlib", "idx": 211506}
{"source": " n_start_visual_mode(int c)\n {\n #ifdef FEAT_CONCEAL\n     int cursor_line_was_concealed = curwin->w_p_cole > 0\n \t\t\t\t\t\t&& conceal_cursor_line(curwin);\n #endif\n \n     VIsual_mode = c;\n     VIsual_active = TRUE;\n     VIsual_reselect = TRUE;\n// bug_start\n    trigger_modechanged();\n// bug_end\n \n     if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n     {\n \tvalidate_virtcol();\n \tcoladvance(curwin->w_virtcol);\n     }\n     VIsual = curwin->w_cursor;\n \n #ifdef FEAT_FOLDING\n     foldAdjustVisual();\n #endif\n \n// bug_start\n// bug_end\n     setmouse();\n #ifdef FEAT_CONCEAL\n     conceal_check_cursor_line(cursor_line_was_concealed);\n #endif\n \n     if (p_smd && msg_silent == 0)\n \tredraw_cmdline = TRUE;\n #ifdef FEAT_CLIPBOARD\n     clip_star.vmode = NUL;\n #endif\n \n     if (curwin->w_redr_type < INVERTED)\n     {\n \tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n \tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n     }\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    trigger_modechanged();\n// fix_end\n", "cwe": "CWE-122", "cwe_name": "Heap-based Buffer Overflow", "cve": "CVE-2021-3968", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "project": "vim", "idx": 211563}
{"source": " static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {\n   char *name;\n   uint32_t i;\n \n   if (!len) return NULL;\n   if (len>400) len=400;\n// bug_start\n  name = cli_malloc(len);\n// bug_end\n   if (!name) {\n     cli_dbgmsg(\"SIS: OOM\\n\");\n     return NULL;\n   }\n   fseek(f, ptr, SEEK_SET);\n   if (fread(name, len, 1, f)!=1) {\n     cli_dbgmsg(\"SIS: Unable to read string\\n\");\n     free(name);\n     return NULL;\n   }\n   for (i = 0 ; i < len; i+=2) name[i/2] = name[i];\n   name[i/2]='\\0';\n   return name;\n }\n \n", "target": "// fix_start\n  name = cli_malloc(len+1);\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2013-2020", "cve_desc": "Integer underflow in the cli_scanpe function in pe.c in ClamAV before 0.97.8 allows remote attackers to cause a denial of service (crash) via a skewed offset larger than the size of the PE section in a UPX packed executable, which triggers an out-of-bounds read.", "project": "clamav-devel", "idx": 211567}
{"source": " reg_match_visual(void)\n {\n     pos_T\ttop, bot;\n     linenr_T    lnum;\n     colnr_T\tcol;\n     win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n     int\t\tmode;\n     colnr_T\tstart, end;\n     colnr_T\tstart2, end2;\n     colnr_T\tcols;\n     colnr_T\tcurswant;\n \n     if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n \treturn FALSE;\n \n     if (VIsual_active)\n     {\n \tif (LT_POS(VIsual, wp->w_cursor))\n \t{\n \t    top = VIsual;\n \t    bot = wp->w_cursor;\n \t}\n \telse\n \t{\n \t    top = wp->w_cursor;\n \t    bot = VIsual;\n \t}\n \tmode = VIsual_mode;\n \tcurswant = wp->w_curswant;\n     }\n     else\n     {\n \tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n \t{\n \t    top = curbuf->b_visual.vi_start;\n \t    bot = curbuf->b_visual.vi_end;\n \t}\n \telse\n \t{\n \t    top = curbuf->b_visual.vi_end;\n \t    bot = curbuf->b_visual.vi_start;\n \t}\n \tmode = curbuf->b_visual.vi_mode;\n \tcurswant = curbuf->b_visual.vi_curswant;\n     }\n     lnum = rex.lnum + rex.reg_firstlnum;\n     if (lnum < top.lnum || lnum > bot.lnum)\n \treturn FALSE;\n \n// bug_start\n// bug_end\n     if (mode == 'v')\n     {\n// bug_start\n\tcol = (colnr_T)(rex.input - rex.line);\n// bug_end\n \tif ((lnum == top.lnum && col < top.col)\n \t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n \t    return FALSE;\n     }\n     else if (mode == Ctrl_V)\n     {\n \tgetvvcol(wp, &top, &start, NULL, &end);\n \tgetvvcol(wp, &bot, &start2, NULL, &end2);\n \tif (start2 < start)\n \t    start = start2;\n \tif (end2 > end)\n \t    end = end2;\n \tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n \t    end = MAXCOL;\n// bug_start\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n// bug_end\n \tif (cols < start || cols > end - (*p_sel == 'e'))\n \t    return FALSE;\n     }\n     return TRUE;\n }\n \n", "target": "// fix_start\n    col = (colnr_T)(rex.input - rex.line);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-4192", "cve_desc": "vim is vulnerable to Use After Free", "project": "vim", "idx": 211695}
{"source": " glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n       glob_t *pglob)\n {\n   const char *filename;\n   char *dirname = NULL;\n   size_t dirlen;\n   int status;\n   size_t oldcount;\n   int meta;\n   int dirname_modified;\n   int malloc_dirname = 0;\n   glob_t dirs;\n   int retval = 0;\n   size_t alloca_used = 0;\n \n   if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n     {\n       __set_errno (EINVAL);\n       return -1;\n     }\n \n   if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n     flags |= GLOB_ONLYDIR;\n \n   if (!(flags & GLOB_DOOFFS))\n     pglob->gl_offs = 0;\n \n   if (!(flags & GLOB_APPEND))\n     {\n       pglob->gl_pathc = 0;\n       if (!(flags & GLOB_DOOFFS))\n         pglob->gl_pathv = NULL;\n       else\n         {\n           size_t i;\n \n           if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n             return GLOB_NOSPACE;\n \n           pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                               * sizeof (char *));\n           if (pglob->gl_pathv == NULL)\n             return GLOB_NOSPACE;\n \n           for (i = 0; i <= pglob->gl_offs; ++i)\n             pglob->gl_pathv[i] = NULL;\n         }\n     }\n \n   if (flags & GLOB_BRACE)\n     {\n       const char *begin;\n \n       if (flags & GLOB_NOESCAPE)\n         begin = strchr (pattern, '{');\n       else\n         {\n           begin = pattern;\n           while (1)\n             {\n               if (*begin == '\\0')\n                 {\n                   begin = NULL;\n                   break;\n                 }\n \n               if (*begin == '\\\\' && begin[1] != '\\0')\n                 ++begin;\n               else if (*begin == '{')\n                 break;\n \n               ++begin;\n             }\n         }\n \n       if (begin != NULL)\n         {\n           size_t firstc;\n           char *alt_start;\n           const char *p;\n           const char *next;\n           const char *rest;\n           size_t rest_len;\n           char *onealt;\n           size_t pattern_len = strlen (pattern) - 1;\n           int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n           if (alloca_onealt)\n             onealt = alloca_account (pattern_len, alloca_used);\n           else\n             {\n               onealt = malloc (pattern_len);\n               if (onealt == NULL)\n                 return GLOB_NOSPACE;\n             }\n \n           alt_start = mempcpy (onealt, pattern, begin - pattern);\n \n           next = next_brace_sub (begin + 1, flags);\n           if (next == NULL)\n             {\n             illegal_brace:\n               if (__glibc_unlikely (!alloca_onealt))\n                 free (onealt);\n               flags &= ~GLOB_BRACE;\n               goto no_brace;\n             }\n \n           rest = next;\n           while (*rest != '}')\n             {\n               rest = next_brace_sub (rest + 1, flags);\n               if (rest == NULL)\n                 goto illegal_brace;\n             }\n           rest_len = strlen (++rest) + 1;\n \n           firstc = pglob->gl_pathc;\n \n           p = begin + 1;\n           while (1)\n             {\n               int result;\n \n               mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n \n               result = glob (onealt,\n                              ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                               | GLOB_APPEND), errfunc, pglob);\n \n               if (result && result != GLOB_NOMATCH)\n                 {\n                   if (__glibc_unlikely (!alloca_onealt))\n                     free (onealt);\n                   if (!(flags & GLOB_APPEND))\n                     {\n                       globfree (pglob);\n                       pglob->gl_pathc = 0;\n                     }\n                   return result;\n                 }\n \n               if (*next == '}')\n                 break;\n \n               p = next + 1;\n               next = next_brace_sub (p, flags);\n               assert (next != NULL);\n             }\n \n           if (__glibc_unlikely (!alloca_onealt))\n             free (onealt);\n \n           if (pglob->gl_pathc != firstc)\n             return 0;\n           else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n             return GLOB_NOMATCH;\n         }\n     }\n \n  no_brace:\n   oldcount = pglob->gl_pathc + pglob->gl_offs;\n \n   filename = strrchr (pattern, '/');\n \n #if defined __MSDOS__ || defined WINDOWS32\n   if (filename == NULL)\n     filename = strchr (pattern, ':');\n #endif\n \n   dirname_modified = 0;\n   if (filename == NULL)\n     {\n       if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n         {\n           dirname = (char *) pattern;\n           dirlen = strlen (pattern);\n \n           filename = NULL;\n         }\n       else\n         {\n           if (__glibc_unlikely (pattern[0] == '\\0'))\n             {\n               dirs.gl_pathv = NULL;\n               goto no_matches;\n             }\n \n           filename = pattern;\n           dirname = (char *) \".\";\n           dirlen = 0;\n         }\n     }\n   else if (filename == pattern\n            || (filename == pattern + 1 && pattern[0] == '\\\\'\n                && (flags & GLOB_NOESCAPE) == 0))\n     {\n       dirname = (char *) \"/\";\n       dirlen = 1;\n       ++filename;\n     }\n   else\n     {\n       char *newp;\n       dirlen = filename - pattern;\n \n #if defined __MSDOS__ || defined WINDOWS32\n       if (*filename == ':'\n           || (filename > pattern + 1 && filename[-1] == ':'))\n         {\n           char *drive_spec;\n \n           ++dirlen;\n           drive_spec = __alloca (dirlen + 1);\n           *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n           if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n             return GLOB_NOMATCH;\n         }\n #endif\n \n       if (glob_use_alloca (alloca_used, dirlen + 1))\n         newp = alloca_account (dirlen + 1, alloca_used);\n       else\n         {\n           newp = malloc (dirlen + 1);\n           if (newp == NULL)\n             return GLOB_NOSPACE;\n           malloc_dirname = 1;\n         }\n       *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n       dirname = newp;\n       ++filename;\n \n #if defined __MSDOS__ || defined WINDOWS32\n       bool drive_root = (dirlen > 1\n                          && (dirname[dirlen - 1] == ':'\n                              || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                  && dirname[dirlen - 1] == '/')));\n #else\n       bool drive_root = false;\n #endif\n \n       if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n         {\n           int orig_flags = flags;\n           if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n             {\n               char *p = (char *) &dirname[dirlen - 1];\n \n               while (p > dirname && p[-1] == '\\\\') --p;\n               if ((&dirname[dirlen] - p) & 1)\n                 {\n                   *(char *) &dirname[--dirlen] = '\\0';\n                   flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                 }\n             }\n           int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n           if (val == 0)\n             pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                                | (flags & GLOB_MARK));\n           else if (val == GLOB_NOMATCH && flags != orig_flags)\n             {\n               dirs.gl_pathv = NULL;\n               flags = orig_flags;\n               oldcount = pglob->gl_pathc + pglob->gl_offs;\n               goto no_matches;\n             }\n           retval = val;\n           goto out;\n         }\n     }\n \n   if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n     {\n       if (dirname[1] == '\\0' || dirname[1] == '/'\n           || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n               && (dirname[2] == '\\0' || dirname[2] == '/')))\n         {\n           char *home_dir = getenv (\"HOME\");\n           int malloc_home_dir = 0;\n           if (home_dir == NULL || home_dir[0] == '\\0')\n             {\n #ifdef WINDOWS32\n               const char *home_drive = getenv (\"HOMEDRIVE\");\n               const char *home_path = getenv (\"HOMEPATH\");\n \n               if (home_drive != NULL && home_path != NULL)\n                 {\n                   size_t home_drive_len = strlen (home_drive);\n                   size_t home_path_len = strlen (home_path);\n                   char *mem = alloca (home_drive_len + home_path_len + 1);\n \n                   memcpy (mem, home_drive, home_drive_len);\n                   memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                   home_dir = mem;\n                 }\n               else\n                 home_dir = \"c:/users/default\";\n #else\n               int err;\n               struct passwd *p;\n               struct passwd pwbuf;\n               struct scratch_buffer s;\n               scratch_buffer_init (&s);\n               while (true)\n                 {\n                   p = NULL;\n                   err = __getlogin_r (s.data, s.length);\n                   if (err == 0)\n                     {\n # if defined HAVE_GETPWNAM_R || defined _LIBC\n                       size_t ssize = strlen (s.data) + 1;\n                       err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                         s.length - ssize, &p);\n # else\n                       p = getpwnam (s.data);\n                       if (p == NULL)\n                         err = errno;\n # endif\n                     }\n                   if (err != ERANGE)\n                     break;\n                   if (!scratch_buffer_grow (&s))\n                     {\n                       retval = GLOB_NOSPACE;\n                       goto out;\n                     }\n                 }\n               if (err == 0)\n                 {\n                   home_dir = strdup (p->pw_dir);\n                   malloc_home_dir = 1;\n                 }\n               scratch_buffer_free (&s);\n               if (err == 0 && home_dir == NULL)\n                 {\n                   retval = GLOB_NOSPACE;\n                   goto out;\n                 }\n #endif\n             }\n           if (home_dir == NULL || home_dir[0] == '\\0')\n             {\n               if (__glibc_unlikely (malloc_home_dir))\n                 free (home_dir);\n               if (flags & GLOB_TILDE_CHECK)\n                 {\n                   retval = GLOB_NOMATCH;\n                   goto out;\n                 }\n               else\n                 {\n                   home_dir = (char *) \"~\";\n                   malloc_home_dir = 0;\n                 }\n             }\n           if (dirname[1] == '\\0')\n             {\n               if (__glibc_unlikely (malloc_dirname))\n                 free (dirname);\n \n               dirname = home_dir;\n               dirlen = strlen (dirname);\n               malloc_dirname = malloc_home_dir;\n             }\n           else\n             {\n               char *newp;\n               size_t home_len = strlen (home_dir);\n               int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n               if (use_alloca)\n                 newp = alloca_account (home_len + dirlen, alloca_used);\n               else\n                 {\n                   newp = malloc (home_len + dirlen);\n                   if (newp == NULL)\n                     {\n                       if (__glibc_unlikely (malloc_home_dir))\n                         free (home_dir);\n                       retval = GLOB_NOSPACE;\n                       goto out;\n                     }\n                 }\n \n               mempcpy (mempcpy (newp, home_dir, home_len),\n                        &dirname[1], dirlen);\n \n               if (__glibc_unlikely (malloc_dirname))\n                 free (dirname);\n \n               dirname = newp;\n               dirlen += home_len - 1;\n               malloc_dirname = !use_alloca;\n \n               if (__glibc_unlikely (malloc_home_dir))\n                 free (home_dir);\n             }\n           dirname_modified = 1;\n         }\n       else\n         {\n #ifndef WINDOWS32\n           char *end_name = strchr (dirname, '/');\n           char *user_name;\n           int malloc_user_name = 0;\n           char *unescape = NULL;\n \n           if (!(flags & GLOB_NOESCAPE))\n             {\n               if (end_name == NULL)\n                 {\n                   unescape = strchr (dirname, '\\\\');\n                   if (unescape)\n                     end_name = strchr (unescape, '\\0');\n                 }\n               else\n                 unescape = memchr (dirname, '\\\\', end_name - dirname);\n             }\n           if (end_name == NULL)\n             user_name = dirname + 1;\n           else\n             {\n               char *newp;\n               if (glob_use_alloca (alloca_used, end_name - dirname))\n                 newp = alloca_account (end_name - dirname, alloca_used);\n               else\n                 {\n                   newp = malloc (end_name - dirname);\n                   if (newp == NULL)\n                     {\n                       retval = GLOB_NOSPACE;\n                       goto out;\n                     }\n                   malloc_user_name = 1;\n                 }\n               if (unescape != NULL)\n                 {\n                   char *p = mempcpy (newp, dirname + 1,\n                                      unescape - dirname - 1);\n                   char *q = unescape;\n                   while (*q != '\\0')\n                     {\n                       if (*q == '\\\\')\n                         {\n                           if (q[1] == '\\0')\n                             {\n                               if (filename == NULL)\n                                 *p++ = '\\\\';\n                               break;\n                             }\n                           ++q;\n                         }\n                       *p++ = *q++;\n                     }\n                   *p = '\\0';\n                 }\n               else\n// bug_start\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n// bug_end\n                   = '\\0';\n               user_name = newp;\n             }\n \n           {\n             struct passwd *p;\n             struct scratch_buffer pwtmpbuf;\n             scratch_buffer_init (&pwtmpbuf);\n \n #  if defined HAVE_GETPWNAM_R || defined _LIBC\n             struct passwd pwbuf;\n \n             while (getpwnam_r (user_name, &pwbuf,\n                                pwtmpbuf.data, pwtmpbuf.length, &p)\n                    == ERANGE)\n               {\n                 if (!scratch_buffer_grow (&pwtmpbuf))\n                   {\n                     retval = GLOB_NOSPACE;\n                     goto out;\n                   }\n               }\n #  else\n             p = getpwnam (user_name);\n #  endif\n \n             if (__glibc_unlikely (malloc_user_name))\n               free (user_name);\n \n             if (p != NULL)\n               {\n                 size_t home_len = strlen (p->pw_dir);\n                 size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                 char *d;\n \n                 if (__glibc_unlikely (malloc_dirname))\n                   free (dirname);\n                 malloc_dirname = 0;\n \n                 if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                   dirname = alloca_account (home_len + rest_len + 1,\n                                             alloca_used);\n                 else\n                   {\n                     dirname = malloc (home_len + rest_len + 1);\n                     if (dirname == NULL)\n                       {\n                         scratch_buffer_free (&pwtmpbuf);\n                         retval = GLOB_NOSPACE;\n                         goto out;\n                       }\n                     malloc_dirname = 1;\n                   }\n                 d = mempcpy (dirname, p->pw_dir, home_len);\n                 if (end_name != NULL)\n                   d = mempcpy (d, end_name, rest_len);\n                 *d = '\\0';\n \n                 dirlen = home_len + rest_len;\n                 dirname_modified = 1;\n               }\n             else\n               {\n                 if (flags & GLOB_TILDE_CHECK)\n                   {\n                     retval = GLOB_NOMATCH;\n                     goto out;\n                   }\n               }\n             scratch_buffer_free (&pwtmpbuf);\n           }\n #endif\n         }\n     }\n \n   if (filename == NULL)\n     {\n       size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n       char **new_gl_pathv;\n \n       if (newcount > SIZE_MAX / sizeof (char *) - 2)\n         {\n         nospace:\n           free (pglob->gl_pathv);\n           pglob->gl_pathv = NULL;\n           pglob->gl_pathc = 0;\n           retval = GLOB_NOSPACE;\n           goto out;\n         }\n \n       new_gl_pathv = realloc (pglob->gl_pathv,\n                               (newcount + 2) * sizeof (char *));\n       if (new_gl_pathv == NULL)\n         goto nospace;\n       pglob->gl_pathv = new_gl_pathv;\n \n       if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n         {\n           char *p;\n           pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n           if (pglob->gl_pathv[newcount] == NULL)\n             goto nospace;\n           p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n           p[0] = '/';\n           p[1] = '\\0';\n           if (__glibc_unlikely (malloc_dirname))\n             free (dirname);\n         }\n       else\n         {\n           if (__glibc_unlikely (malloc_dirname))\n             pglob->gl_pathv[newcount] = dirname;\n           else\n             {\n               pglob->gl_pathv[newcount] = strdup (dirname);\n               if (pglob->gl_pathv[newcount] == NULL)\n                 goto nospace;\n             }\n         }\n       pglob->gl_pathv[++newcount] = NULL;\n       ++pglob->gl_pathc;\n       pglob->gl_flags = flags;\n \n       return 0;\n     }\n \n   meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n   if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n     {\n       size_t i;\n \n       if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n         {\n           char *p = (char *) &dirname[dirlen - 1];\n \n           while (p > dirname && p[-1] == '\\\\') --p;\n           if ((&dirname[dirlen] - p) & 1)\n             *(char *) &dirname[--dirlen] = '\\0';\n         }\n \n       if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n         {\n           dirs.gl_opendir = pglob->gl_opendir;\n           dirs.gl_readdir = pglob->gl_readdir;\n           dirs.gl_closedir = pglob->gl_closedir;\n           dirs.gl_stat = pglob->gl_stat;\n           dirs.gl_lstat = pglob->gl_lstat;\n         }\n \n       status = glob (dirname,\n                      ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                 | GLOB_ALTDIRFUNC))\n                       | GLOB_NOSORT | GLOB_ONLYDIR),\n                      errfunc, &dirs);\n       if (status != 0)\n         {\n           if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n             {\n               retval = status;\n               goto out;\n             }\n           goto no_matches;\n         }\n \n       for (i = 0; i < dirs.gl_pathc; ++i)\n         {\n           size_t old_pathc;\n \n           old_pathc = pglob->gl_pathc;\n           status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                 ((flags | GLOB_APPEND)\n                                  & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                 errfunc, pglob, alloca_used);\n           if (status == GLOB_NOMATCH)\n             continue;\n \n           if (status != 0)\n             {\n               globfree (&dirs);\n               globfree (pglob);\n               pglob->gl_pathc = 0;\n               retval = status;\n               goto out;\n             }\n \n           if (prefix_array (dirs.gl_pathv[i],\n                             &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                             pglob->gl_pathc - old_pathc))\n             {\n               globfree (&dirs);\n               globfree (pglob);\n               pglob->gl_pathc = 0;\n               retval = GLOB_NOSPACE;\n               goto out;\n             }\n         }\n \n       flags |= GLOB_MAGCHAR;\n \n       if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n         {\n         no_matches:\n           if (flags & GLOB_NOCHECK)\n             {\n               size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n               char **new_gl_pathv;\n \n               if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                 {\n                 nospace2:\n                   globfree (&dirs);\n                   retval = GLOB_NOSPACE;\n                   goto out;\n                 }\n \n               new_gl_pathv = realloc (pglob->gl_pathv,\n                                       (newcount + 2) * sizeof (char *));\n               if (new_gl_pathv == NULL)\n                 goto nospace2;\n               pglob->gl_pathv = new_gl_pathv;\n \n               pglob->gl_pathv[newcount] = strdup (pattern);\n               if (pglob->gl_pathv[newcount] == NULL)\n                 {\n                   globfree (&dirs);\n                   globfree (pglob);\n                   pglob->gl_pathc = 0;\n                   retval = GLOB_NOSPACE;\n                   goto out;\n                 }\n \n               ++pglob->gl_pathc;\n               ++newcount;\n \n               pglob->gl_pathv[newcount] = NULL;\n               pglob->gl_flags = flags;\n             }\n           else\n             {\n               globfree (&dirs);\n               retval = GLOB_NOMATCH;\n               goto out;\n             }\n         }\n \n       globfree (&dirs);\n     }\n   else\n     {\n       size_t old_pathc = pglob->gl_pathc;\n       int orig_flags = flags;\n \n       if (meta & GLOBPAT_BACKSLASH)\n         {\n           char *p = strchr (dirname, '\\\\'), *q;\n           q = p;\n           do\n             {\n               if (*p == '\\\\')\n                 {\n                   *q = *++p;\n                   --dirlen;\n                 }\n               else\n                 *q = *p;\n               ++q;\n             }\n           while (*p++ != '\\0');\n           dirname_modified = 1;\n         }\n       if (dirname_modified)\n         flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n       status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                             alloca_used);\n       if (status != 0)\n         {\n           if (status == GLOB_NOMATCH && flags != orig_flags\n               && pglob->gl_pathc + pglob->gl_offs == oldcount)\n             {\n               dirs.gl_pathv = NULL;\n               flags = orig_flags;\n               goto no_matches;\n             }\n           retval = status;\n           goto out;\n         }\n \n       if (dirlen > 0)\n         {\n           if (prefix_array (dirname,\n                             &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                             pglob->gl_pathc - old_pathc))\n             {\n               globfree (pglob);\n               pglob->gl_pathc = 0;\n               retval = GLOB_NOSPACE;\n               goto out;\n             }\n         }\n     }\n \n   if (flags & GLOB_MARK)\n     {\n       size_t i;\n \n       for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n         if (is_dir (pglob->gl_pathv[i], flags, pglob))\n           {\n             size_t len = strlen (pglob->gl_pathv[i]) + 2;\n             char *new = realloc (pglob->gl_pathv[i], len);\n             if (new == NULL)\n               {\n                 globfree (pglob);\n                 pglob->gl_pathc = 0;\n                 retval = GLOB_NOSPACE;\n                 goto out;\n               }\n             strcpy (&new[len - 2], \"/\");\n             pglob->gl_pathv[i] = new;\n           }\n     }\n \n   if (!(flags & GLOB_NOSORT))\n     {\n       qsort (&pglob->gl_pathv[oldcount],\n              pglob->gl_pathc + pglob->gl_offs - oldcount,\n              sizeof (char *), collated_compare);\n     }\n \n  out:\n   if (__glibc_unlikely (malloc_dirname))\n     free (dirname);\n \n   return retval;\n }\n \n", "target": "// fix_start\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname - 1))\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2017-15670", "cve_desc": "The GNU C Library (aka glibc or libc6) before 2.27 contains an off-by-one error leading to a heap-based buffer overflow in the glob function in glob.c, related to the processing of home directories using the ~ operator followed by a long string.", "project": "gnulib", "idx": 211699}
{"source": " int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n \t\t\t\tu8 event, struct sk_buff *skb)\n {\n \tint r = 0;\n \tstruct device *dev = &hdev->ndev->dev;\n \tstruct nfc_evt_transaction *transaction;\n \n \tpr_debug(\"connectivity gate event: %x\\n\", event);\n \n \tswitch (event) {\n \tcase ST21NFCA_EVT_CONNECTIVITY:\n \t\tr = nfc_se_connectivity(hdev->ndev, host);\n \tbreak;\n \tcase ST21NFCA_EVT_TRANSACTION:\n \t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n \t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n \t\t\treturn -EPROTO;\n \n \t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n \t\tif (!transaction)\n \t\t\treturn -ENOMEM;\n \n \t\ttransaction->aid_len = skb->data[1];\n// bug_start\n// bug_end\n \t\tmemcpy(transaction->aid, &skb->data[2],\n \t\t       transaction->aid_len);\n \n \t\tif (skb->data[transaction->aid_len + 2] !=\n \t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n \t\t\treturn -EPROTO;\n \n \t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n// bug_start\n// bug_end\n \t\tmemcpy(transaction->params, skb->data +\n \t\t       transaction->aid_len + 4, transaction->params_len);\n \n \t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n \tbreak;\n \tdefault:\n \t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n \t\treturn 1;\n \t}\n \tkfree_skb(skb);\n \treturn r;\n }\n \n", "target": "// fix_start\n\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\n// fix_end\n// fix_start\n\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2022-26490", "cve_desc": "st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.", "project": "linux", "idx": 211700}
{"source": " cookedprint(\n \tint datatype,\n \tint length,\n \tconst char *data,\n \tint status,\n \tint quiet,\n \tFILE *fp\n \t)\n {\n \tchar *name;\n \tchar *value;\n \tchar output_raw;\n \tint fmt;\n \tl_fp lfp;\n \tsockaddr_u hval;\n \tu_long uval;\n \tint narr;\n \tsize_t len;\n \tl_fp lfparr[8];\n \tchar b[12];\n \tchar bn[2 * MAXVARLEN];\n \tchar bv[2 * MAXVALLEN];\n \n \tUNUSED_ARG(datatype);\n \n \tif (!quiet)\n \t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n \t\t\tstatustoa(datatype, status));\n \n \tstartoutput();\n \twhile (nextvar(&length, &data, &name, &value)) {\n \t\tfmt = varfmt(name);\n \t\toutput_raw = 0;\n \t\tswitch (fmt) {\n \n \t\tcase PADDING:\n \t\t\toutput_raw = '*';\n \t\t\tbreak;\n \n \t\tcase TS:\n \t\t\tif (!decodets(value, &lfp))\n \t\t\t\toutput_raw = '?';\n \t\t\telse\n \t\t\t\toutput(fp, name, prettydate(&lfp));\n \t\t\tbreak;\n \n \t\tcase HA:\n \t\tcase NA:\n \t\t\tif (!decodenetnum(value, &hval)) {\n \t\t\t\toutput_raw = '?';\n \t\t\t} else if (fmt == HA){\n \t\t\t\toutput(fp, name, nntohost(&hval));\n \t\t\t} else {\n \t\t\t\toutput(fp, name, stoa(&hval));\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase RF:\n \t\t\tif (decodenetnum(value, &hval)) {\n \t\t\t\tif (ISREFCLOCKADR(&hval))\n \t\t\t\t\toutput(fp, name,\n \t\t\t\t\t       refnumtoa(&hval));\n \t\t\t\telse\n \t\t\t\t\toutput(fp, name, stoa(&hval));\n \t\t\t} else if (strlen(value) <= 4) {\n \t\t\t\toutput(fp, name, value);\n \t\t\t} else {\n \t\t\t\toutput_raw = '?';\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase LP:\n \t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n \t\t\t\toutput_raw = '?';\n \t\t\t} else {\n \t\t\t\tb[0] = (0x2 & uval)\n \t\t\t\t\t   ? '1'\n \t\t\t\t\t   : '0';\n \t\t\t\tb[1] = (0x1 & uval)\n \t\t\t\t\t   ? '1'\n \t\t\t\t\t   : '0';\n \t\t\t\tb[2] = '\\0';\n \t\t\t\toutput(fp, name, b);\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase OC:\n \t\t\tif (!decodeuint(value, &uval)) {\n \t\t\t\toutput_raw = '?';\n \t\t\t} else {\n \t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n \t\t\t\toutput(fp, name, b);\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase AR:\n \t\t\tif (!decodearr(value, &narr, lfparr))\n \t\t\t\toutput_raw = '?';\n \t\t\telse\n \t\t\t\toutputarr(fp, name, narr, lfparr);\n \t\t\tbreak;\n \n \t\tcase FX:\n \t\t\tif (!decodeuint(value, &uval))\n \t\t\t\toutput_raw = '?';\n \t\t\telse\n \t\t\t\toutput(fp, name, tstflags(uval));\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n \t\t\t\tname, value, fmt);\n \t\t\toutput_raw = '?';\n \t\t\tbreak;\n \t\t}\n \n \t\tif (output_raw != 0) {\n \t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n// bug_start\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n// bug_end\n \t\t\tif (output_raw != '*') {\n// bug_start\n// bug_end\n \t\t\t\tlen = strlen(bv);\n \t\t\t\tbv[len] = output_raw;\n \t\t\t\tbv[len+1] = '\\0';\n// bug_start\n// bug_end\n \t\t\t}\n \t\t\toutput(fp, bn, bv);\n \t\t}\n \t}\n \tendoutput(fp);\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv) - 1);\n// fix_end\n// fix_start\n\t\t\t} else {\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv));\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2015-7852", "cve_desc": "ntpq in NTP 4.2.x before 4.2.8p4, and 4.3.x before 4.3.77 allows remote attackers to cause a denial of service (crash) via crafted mode 6 response packets.", "project": "ntp", "idx": 211773}
{"source": " static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n {\n \tjpc_enc_cp_t *cp;\n \tjas_tvparser_t *tvp;\n \tint ret;\n \tint numilyrrates;\n \tdouble *ilyrrates;\n \tint i;\n \tint tagid;\n \tjpc_enc_tcp_t *tcp;\n \tjpc_enc_tccp_t *tccp;\n \tjpc_enc_ccp_t *ccp;\n \tuint_fast16_t rlvlno;\n \tuint_fast16_t prcwidthexpn;\n \tuint_fast16_t prcheightexpn;\n \tbool enablemct;\n \tuint_fast32_t jp2overhead;\n \tuint_fast16_t lyrno;\n \tuint_fast32_t hsteplcm;\n \tuint_fast32_t vsteplcm;\n \tbool mctvalid;\n \n \ttvp = 0;\n \tcp = 0;\n \tilyrrates = 0;\n \tnumilyrrates = 0;\n \n \tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n \t\tgoto error;\n \t}\n \n \tprcwidthexpn = 15;\n \tprcheightexpn = 15;\n \tenablemct = true;\n \tjp2overhead = 0;\n \n \tcp->ccps = 0;\n \tcp->debug = 0;\n \tcp->imgareatlx = UINT_FAST32_MAX;\n \tcp->imgareatly = UINT_FAST32_MAX;\n \tcp->refgrdwidth = 0;\n \tcp->refgrdheight = 0;\n \tcp->tilegrdoffx = UINT_FAST32_MAX;\n \tcp->tilegrdoffy = UINT_FAST32_MAX;\n \tcp->tilewidth = 0;\n \tcp->tileheight = 0;\n \tcp->numcmpts = jas_image_numcmpts(image);\n \n \thsteplcm = 1;\n \tvsteplcm = 1;\n \tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n \t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n \t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n \t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n \t\t\tjas_eprintf(\"unsupported image type\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n \t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n \t}\n \n \tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n \t\tgoto error;\n \t}\n \tunsigned cmptno;\n \tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n \t  ++ccp) {\n \t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n \t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n \t\tccp->sampgrdsubstepx = 0;\n \t\tccp->sampgrdsubstepx = 0;\n \t\tccp->prec = jas_image_cmptprec(image, cmptno);\n \t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n \t\tccp->numstepsizes = 0;\n \t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n \t}\n \n \tcp->rawsize = jas_image_rawsize(image);\n \tif (cp->rawsize == 0) {\n \t\tgoto error;\n \t}\n \tcp->totalsize = UINT_FAST32_MAX;\n \n \ttcp = &cp->tcp;\n \ttcp->csty = 0;\n \ttcp->intmode = true;\n \ttcp->prg = JPC_COD_LRCPPRG;\n \ttcp->numlyrs = 1;\n \ttcp->ilyrrates = 0;\n \n \ttccp = &cp->tccp;\n \ttccp->csty = 0;\n \ttccp->maxrlvls = 6;\n \ttccp->cblkwidthexpn = 6;\n \ttccp->cblkheightexpn = 6;\n \ttccp->cblksty = 0;\n \ttccp->numgbits = 2;\n \n \tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n \t\tgoto error;\n \t}\n \n \twhile (!(ret = jas_tvparser_next(tvp))) {\n \t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n \t\t  jas_tvparser_gettag(tvp)))->id) {\n \t\tcase OPT_DEBUG:\n \t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_IMGAREAOFFX:\n \t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_IMGAREAOFFY:\n \t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_TILEGRDOFFX:\n \t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_TILEGRDOFFY:\n \t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_TILEWIDTH:\n \t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_TILEHEIGHT:\n \t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_PRCWIDTH:\n \t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n \t\t\tbreak;\n \t\tcase OPT_PRCHEIGHT:\n \t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n \t\t\tbreak;\n \t\tcase OPT_CBLKWIDTH:\n \t\t\ttccp->cblkwidthexpn =\n \t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n \t\t\tbreak;\n \t\tcase OPT_CBLKHEIGHT:\n \t\t\ttccp->cblkheightexpn =\n \t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n \t\t\tbreak;\n \t\tcase OPT_MODE:\n \t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n \t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n \t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n \t\t\t\t  jas_tvparser_getval(tvp));\n \t\t\t} else {\n \t\t\t\ttcp->intmode = (tagid == MODE_INT);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase OPT_PRG:\n \t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n \t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n \t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n \t\t\t\t  jas_tvparser_getval(tvp));\n \t\t\t} else {\n \t\t\t\ttcp->prg = tagid;\n \t\t\t}\n \t\t\tbreak;\n \t\tcase OPT_NOMCT:\n \t\t\tenablemct = false;\n \t\t\tbreak;\n \t\tcase OPT_MAXRLVLS:\n \t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n// bug_start\n// bug_end\n \t\t\tbreak;\n \t\tcase OPT_SOP:\n \t\t\tcp->tcp.csty |= JPC_COD_SOP;\n \t\t\tbreak;\n \t\tcase OPT_EPH:\n \t\t\tcp->tcp.csty |= JPC_COD_EPH;\n \t\t\tbreak;\n \t\tcase OPT_LAZY:\n \t\t\ttccp->cblksty |= JPC_COX_LAZY;\n \t\t\tbreak;\n \t\tcase OPT_TERMALL:\n \t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n \t\t\tbreak;\n \t\tcase OPT_SEGSYM:\n \t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n \t\t\tbreak;\n \t\tcase OPT_VCAUSAL:\n \t\t\ttccp->cblksty |= JPC_COX_VSC;\n \t\t\tbreak;\n \t\tcase OPT_RESET:\n \t\t\ttccp->cblksty |= JPC_COX_RESET;\n \t\t\tbreak;\n \t\tcase OPT_PTERM:\n \t\t\ttccp->cblksty |= JPC_COX_PTERM;\n \t\t\tbreak;\n \t\tcase OPT_NUMGBITS:\n \t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tcase OPT_RATE:\n \t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n \t\t\t  &cp->totalsize)) {\n \t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n \t\t\t\t  jas_tvparser_getval(tvp));\n \t\t\t}\n \t\t\tbreak;\n \t\tcase OPT_ILYRRATES:\n \t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n \t\t\t  &ilyrrates)) {\n \t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n \t\t\t\t  jas_tvparser_getval(tvp));\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase OPT_JP2OVERHEAD:\n \t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n \t\t\t jas_tvparser_gettag(tvp));\n \t\t\tbreak;\n \t\t}\n \t}\n \n \tjas_tvparser_destroy(tvp);\n \ttvp = 0;\n \n \tif (cp->totalsize != UINT_FAST32_MAX) {\n \t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n \t\t  (cp->totalsize - jp2overhead) : 0;\n \t}\n \n \tif (cp->imgareatlx == UINT_FAST32_MAX) {\n \t\tcp->imgareatlx = 0;\n \t} else {\n \t\tif (hsteplcm != 1) {\n \t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n \t\t}\n \t\tcp->imgareatlx *= hsteplcm;\n \t}\n \tif (cp->imgareatly == UINT_FAST32_MAX) {\n \t\tcp->imgareatly = 0;\n \t} else {\n \t\tif (vsteplcm != 1) {\n \t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n \t\t}\n \t\tcp->imgareatly *= vsteplcm;\n \t}\n \tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n \tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n \tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n \t\tcp->tilegrdoffx = cp->imgareatlx;\n \t}\n \tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n \t\tcp->tilegrdoffy = cp->imgareatly;\n \t}\n \tif (!cp->tilewidth) {\n \t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n \t}\n \tif (!cp->tileheight) {\n \t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n \t}\n \n \tif (cp->numcmpts == 3) {\n \t\tmctvalid = true;\n \t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n \t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n \t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n \t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n \t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n \t\t\t\tmctvalid = false;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tmctvalid = false;\n \t}\n \tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n \t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n \t}\n \tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n \t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n \t} else {\n \t\ttcp->mctid = JPC_MCT_NONE;\n \t}\n \ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n \n \tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n \t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n \t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n \t}\n \tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n \t\ttccp->csty |= JPC_COX_PRT;\n \t}\n \n \tif (!cp->tilewidth) {\n \t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n \t\t  cp->tilewidth);\n \t\tgoto error;\n \t}\n \tif (!cp->tileheight) {\n \t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n \t\t  cp->tileheight);\n \t\tgoto error;\n \t}\n \n \tif (cp->tilegrdoffx > cp->imgareatlx ||\n \t  cp->tilegrdoffy > cp->imgareatly ||\n \t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n \t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n \t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n \t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n \t\t  cp->tilegrdoffy);\n \t\tgoto error;\n \t}\n \n \tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n \t  cp->tilewidth);\n \tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n \t  cp->tileheight);\n \tcp->numtiles = cp->numhtiles * cp->numvtiles;\n \n \tif (ilyrrates && numilyrrates > 0) {\n \t\ttcp->numlyrs = numilyrrates + 1;\n \t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n \t\t  sizeof(jpc_fix_t)))) {\n \t\t\tgoto error;\n \t\t}\n \t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n \t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n \t\t}\n \t}\n \n \tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n \t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n \t\tgoto error;\n \t}\n \n \tif (prcwidthexpn > 15) {\n \t\tjas_eprintf(\"invalid precinct width\\n\");\n \t\tgoto error;\n \t}\n \n \tif (prcheightexpn > 15) {\n \t\tjas_eprintf(\"invalid precinct height\\n\");\n \t\tgoto error;\n \t}\n \n \tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n \t\tjas_eprintf(\"invalid code block width %d\\n\",\n \t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n \t\tgoto error;\n \t}\n \n \tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n \t\tjas_eprintf(\"invalid code block height %d\\n\",\n \t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n \t\tgoto error;\n \t}\n \n \tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n \t\tjas_eprintf(\"code block size too large\\n\");\n \t\tgoto error;\n \t}\n \n \tif (cp->tcp.numlyrs > 16384) {\n \t\tjas_eprintf(\"too many layers\\n\");\n \t\tgoto error;\n \t}\n \n \tif (cp->tccp.maxrlvls < 1) {\n \t\tjas_eprintf(\"must be at least one resolution level\\n\");\n \t\tgoto error;\n \t}\n \n \tif (cp->tccp.numgbits > 8) {\n \t\tjas_eprintf(\"invalid number of guard bits\\n\");\n \t\tgoto error;\n \t}\n \n \tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n \t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n \t}\n \n \tif (tcp->numlyrs > 1) {\n \t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n \t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n \t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t}\n \t\tif (cp->totalsize != UINT_FAST32_MAX) {\n \t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n \t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n \t\t\t\t  / cp->rawsize) {\n \t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n \t\t\t\t\tgoto error;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \tif (ilyrrates) {\n \t\tjas_free(ilyrrates);\n \t}\n \n \treturn cp;\n \n error:\n \n \tif (ilyrrates) {\n \t\tjas_free(ilyrrates);\n \t}\n \tif (tvp) {\n \t\tjas_tvparser_destroy(tvp);\n \t}\n \tif (cp) {\n \t\tjpc_enc_cp_destroy(cp);\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\t\tif(tccp->maxrlvls > JPC_MAXRLVLS) {\n\t\t\t\tjas_eprintf(\"invalid number of resolution levels upper than %d\\n\",JPC_MAXRLVLS);\n\t\t\t\tgoto error;\n\t\t\t}\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2020-27828", "cve_desc": "There's a flaw in jasper's jpc encoder in versions prior to 2.0.23. Crafted input provided to jasper by an attacker could cause an arbitrary out-of-bounds write. This could potentially affect data confidentiality, integrity, or application availability.", "project": "jasper", "idx": 211785}
{"source": " change_indent(\n     int\t\ttype,\n     int\t\tamount,\n     int\t\tround,\n     int\t\treplaced,\n     int\t\tcall_changed_bytes)\n {\n     int\t\tvcol;\n     int\t\tlast_vcol;\n     int\t\tinsstart_less;\n     int\t\tnew_cursor_col;\n     int\t\ti;\n     char_u\t*ptr;\n     int\t\tsave_p_list;\n     int\t\tstart_col;\n     colnr_T\tvc;\n     colnr_T\torig_col = 0;\n     char_u\t*new_line, *orig_line = NULL;\n \n     if (State & VREPLACE_FLAG)\n     {\n \torig_line = vim_strsave(ml_get_curline());\n \torig_col = curwin->w_cursor.col;\n     }\n \n     save_p_list = curwin->w_p_list;\n     curwin->w_p_list = FALSE;\n     vc = getvcol_nolist(&curwin->w_cursor);\n     vcol = vc;\n \n     start_col = curwin->w_cursor.col;\n \n     new_cursor_col = curwin->w_cursor.col;\n     beginline(BL_WHITE);\n     new_cursor_col -= curwin->w_cursor.col;\n \n     insstart_less = curwin->w_cursor.col;\n \n     if (new_cursor_col < 0)\n \tvcol = get_indent() - vcol;\n \n     if (new_cursor_col > 0)\n \tstart_col = -1;\n \n     if (type == INDENT_SET)\n \t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n     else\n     {\n \tint\tsave_State = State;\n \n \tif (State & VREPLACE_FLAG)\n \t    State = INSERT;\n \tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n \tState = save_State;\n     }\n     insstart_less -= curwin->w_cursor.col;\n \n     if (new_cursor_col >= 0)\n     {\n \tif (new_cursor_col == 0)\n \t    insstart_less = MAXCOL;\n \tnew_cursor_col += curwin->w_cursor.col;\n     }\n     else if (!(State & INSERT))\n \tnew_cursor_col = curwin->w_cursor.col;\n     else\n     {\n \tvcol = get_indent() - vcol;\n \tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n \n \tvcol = last_vcol = 0;\n \tnew_cursor_col = -1;\n \tptr = ml_get_curline();\n \twhile (vcol <= (int)curwin->w_virtcol)\n \t{\n \t    last_vcol = vcol;\n \t    if (has_mbyte && new_cursor_col >= 0)\n \t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n \t    else\n \t\t++new_cursor_col;\n// bug_start\n// bug_end\n \t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n \t}\n \tvcol = last_vcol;\n \n \tif (vcol != (int)curwin->w_virtcol)\n \t{\n \t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n \t    i = (int)curwin->w_virtcol - vcol;\n \t    ptr = alloc(i + 1);\n \t    if (ptr != NULL)\n \t    {\n \t\tnew_cursor_col += i;\n \t\tptr[i] = NUL;\n \t\twhile (--i >= 0)\n \t\t    ptr[i] = ' ';\n \t\tins_str(ptr);\n \t\tvim_free(ptr);\n \t    }\n \t}\n \n \tinsstart_less = MAXCOL;\n     }\n \n     curwin->w_p_list = save_p_list;\n \n     if (new_cursor_col <= 0)\n \tcurwin->w_cursor.col = 0;\n     else\n \tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n     curwin->w_set_curswant = TRUE;\n     changed_cline_bef_curs();\n \n     if (State & INSERT)\n     {\n \tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n \t{\n \t    if ((int)Insstart.col <= insstart_less)\n \t\tInsstart.col = 0;\n \t    else\n \t\tInsstart.col -= insstart_less;\n \t}\n \tif ((int)ai_col <= insstart_less)\n \t    ai_col = 0;\n \telse\n \t    ai_col -= insstart_less;\n     }\n \n     if (REPLACE_NORMAL(State) && start_col >= 0)\n     {\n \twhile (start_col > (int)curwin->w_cursor.col)\n \t{\n \t    replace_join(0);\n \t    --start_col;\n \t}\n \twhile (start_col < (int)curwin->w_cursor.col || replaced)\n \t{\n \t    replace_push(NUL);\n \t    if (replaced)\n \t    {\n \t\treplace_push(replaced);\n \t\treplaced = NUL;\n \t    }\n \t    ++start_col;\n \t}\n     }\n \n     if (State & VREPLACE_FLAG)\n     {\n \tif (orig_line == NULL)\n \t    return;\n \n \tnew_line = vim_strsave(ml_get_curline());\n \tif (new_line == NULL)\n \t    return;\n \n \tnew_line[curwin->w_cursor.col] = NUL;\n \n \tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n \tcurwin->w_cursor.col = orig_col;\n \n \tbackspace_until_column(0);\n \n \tins_bytes(new_line);\n \n \tvim_free(new_line);\n     }\n }\n \n", "target": "// fix_start\n\t    if (ptr[new_cursor_col] == NUL)\n\t\tbreak;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0714", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4436.", "project": "vim", "idx": 211842}
{"source": " static Image *ReadTIFFImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n {\n #define MaxPixelChannels  32\n #define ThrowTIFFException(severity,message) \\\n { \\\n   if (pixel_info != (MemoryInfo *) NULL) \\\n     pixel_info=RelinquishVirtualMemory(pixel_info); \\\n   if (quantum_info != (QuantumInfo *) NULL) \\\n     quantum_info=DestroyQuantumInfo(quantum_info); \\\n   TIFFClose(tiff); \\\n   ThrowReaderException(severity,message); \\\n }\n \n   const char\n     *option;\n \n   float\n     *chromaticity = (float *) NULL,\n     x_position,\n     y_position,\n     x_resolution,\n     y_resolution;\n \n   Image\n     *image;\n \n   int\n     tiff_status = 0;\n \n   MagickBooleanType\n     more_frames;\n \n   MagickStatusType\n     status;\n \n   MemoryInfo\n     *pixel_info = (MemoryInfo *) NULL;\n \n   QuantumInfo\n     *quantum_info;\n \n   QuantumType\n     quantum_type;\n \n   size_t\n     number_pixels;\n \n   ssize_t\n     i,\n     scanline_size,\n     y;\n \n   TIFF\n     *tiff;\n \n   TIFFMethodType\n     method;\n \n   uint16\n     compress_tag = 0,\n     bits_per_sample = 0,\n     endian = 0,\n     extra_samples = 0,\n     interlace = 0,\n     max_sample_value = 0,\n     min_sample_value = 0,\n     orientation = 0,\n     pages = 0,\n     photometric = 0,\n     *sample_info = NULL,\n     sample_format = 0,\n     samples_per_pixel = 0,\n     units = 0,\n     value = 0;\n \n   uint32\n     height,\n     rows_per_strip,\n     width;\n \n   unsigned char\n     *pixels;\n \n   void\n     *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   if (IsEventLogging() != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   (void) SetMagickThreadValue(tiff_exception,exception);\n   tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n     TIFFUnmapBlob);\n   if (tiff == (TIFF *) NULL)\n     {\n       if (exception->severity == UndefinedException)\n         ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   if (exception->severity > ErrorException)\n     {\n       TIFFClose(tiff);\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   if (image_info->number_scenes != 0)\n     {\n       if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n         {\n           for (i=0; i < (ssize_t) image_info->scene; i++)\n           {\n             status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n             if (status == MagickFalse)\n               {\n                 TIFFClose(tiff);\n                 image=DestroyImageList(image);\n                 return((Image *) NULL);\n               }\n             AcquireNextImage(image_info,image);\n             if (GetNextImageInList(image) == (Image *) NULL)\n               {\n                 TIFFClose(tiff);\n                 image=DestroyImageList(image);\n                 return((Image *) NULL);\n               }\n             image=SyncNextImageInList(image);\n           }\n         }\n     }\n   more_frames=MagickTrue;\n   do\n   {\n     photometric=PHOTOMETRIC_RGB;\n     if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n         (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n     if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n         ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n       }\n     if (samples_per_pixel > MaxPixelChannels)\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n       }\n     if (sample_format == SAMPLEFORMAT_IEEEFP)\n       (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n     switch (photometric)\n     {\n       case PHOTOMETRIC_MINISBLACK:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n         break;\n       }\n       case PHOTOMETRIC_MINISWHITE:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n         break;\n       }\n       case PHOTOMETRIC_PALETTE:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n         break;\n       }\n       case PHOTOMETRIC_RGB:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n         break;\n       }\n       case PHOTOMETRIC_CIELAB:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n         break;\n       }\n       case PHOTOMETRIC_LOGL:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n         break;\n       }\n       case PHOTOMETRIC_LOGLUV:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n         break;\n       }\n #if defined(PHOTOMETRIC_MASK)\n       case PHOTOMETRIC_MASK:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n         break;\n       }\n #endif\n       case PHOTOMETRIC_SEPARATED:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n         break;\n       }\n       case PHOTOMETRIC_YCBCR:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n         break;\n       }\n       default:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n         break;\n       }\n     }\n     if (image->debug != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n           (unsigned int) width,(unsigned int) height);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n           interlace);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"Bits per sample: %u\",bits_per_sample);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"Min sample value: %u\",min_sample_value);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"Max sample value: %u\",max_sample_value);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n           \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n       }\n     image->columns=(size_t) width;\n     image->rows=(size_t) height;\n     image->depth=(size_t) bits_per_sample;\n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n         (double) image->depth);\n     image->endian=MSBEndian;\n     if (endian == FILLORDER_LSB2MSB)\n       image->endian=LSBEndian;\n #if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n     if (TIFFIsBigEndian(tiff) == 0)\n       {\n         (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n         image->endian=LSBEndian;\n       }\n     else\n       {\n         (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n         image->endian=MSBEndian;\n       }\n #endif\n     if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n         (photometric == PHOTOMETRIC_MINISWHITE))\n       image->colorspace=GRAYColorspace;\n     if (photometric == PHOTOMETRIC_SEPARATED)\n       image->colorspace=CMYKColorspace;\n     if (photometric == PHOTOMETRIC_CIELAB)\n       image->colorspace=LabColorspace;\n     if ((photometric == PHOTOMETRIC_YCBCR) &&\n         (compress_tag != COMPRESSION_OJPEG) &&\n         (compress_tag != COMPRESSION_JPEG))\n       image->colorspace=YCbCrColorspace;\n     status=TIFFGetProfiles(tiff,image);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n     status=TIFFGetProperties(tiff,image);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n     option=GetImageOption(image_info,\"tiff:exif-properties\");\n     if ((option == (const char *) NULL) ||\n         (IsMagickTrue(option) != MagickFalse))\n       (void) TIFFGetEXIFProperties(tiff,image);\n     option=GetImageOption(image_info,\"tiff:gps-properties\");\n     if ((option == (const char *) NULL) ||\n         (IsMagickTrue(option) != MagickFalse))\n       (void) TIFFGetGPSProperties(tiff,image);\n     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n       {\n         image->x_resolution=x_resolution;\n         image->y_resolution=y_resolution;\n       }\n     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n       {\n         if (units == RESUNIT_INCH)\n           image->units=PixelsPerInchResolution;\n         if (units == RESUNIT_CENTIMETER)\n           image->units=PixelsPerCentimeterResolution;\n       }\n     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n       {\n         image->page.x=CastDoubleToLong(ceil(x_position*\n           image->x_resolution-0.5));\n         image->page.y=CastDoubleToLong(ceil(y_position*\n           image->y_resolution-0.5));\n       }\n     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n       image->orientation=(OrientationType) orientation;\n     if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n       {\n         if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n           {\n             image->chromaticity.white_point.x=chromaticity[0];\n             image->chromaticity.white_point.y=chromaticity[1];\n           }\n       }\n     if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n       {\n         if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n           {\n             image->chromaticity.red_primary.x=chromaticity[0];\n             image->chromaticity.red_primary.y=chromaticity[1];\n             image->chromaticity.green_primary.x=chromaticity[2];\n             image->chromaticity.green_primary.y=chromaticity[3];\n             image->chromaticity.blue_primary.x=chromaticity[4];\n             image->chromaticity.blue_primary.y=chromaticity[5];\n           }\n       }\n #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n     if ((compress_tag != COMPRESSION_NONE) &&\n         (TIFFIsCODECConfigured(compress_tag) == 0))\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CoderError,\"CompressNotSupported\");\n       }\n #endif\n     switch (compress_tag)\n     {\n       case COMPRESSION_NONE: image->compression=NoCompression; break;\n       case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n       case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n       case COMPRESSION_JPEG:\n       {\n          image->compression=JPEGCompression;\n #if defined(JPEG_SUPPORT)\n          {\n            char\n              sampling_factor[MaxTextExtent];\n \n            int\n              tiff_status;\n \n            uint16\n              horizontal,\n              vertical;\n \n            tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n              &vertical);\n            if (tiff_status == 1)\n              {\n                (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                  horizontal,vertical);\n                (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                  sampling_factor);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"Sampling Factors: %s\",sampling_factor);\n              }\n          }\n #endif\n         break;\n       }\n       case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n #if defined(COMPRESSION_LZMA)\n       case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n #endif\n       case COMPRESSION_LZW: image->compression=LZWCompression; break;\n       case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n       case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n #if defined(COMPRESSION_WEBP)\n       case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n #endif\n #if defined(COMPRESSION_ZSTD)\n       case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n #endif\n       default: image->compression=RLECompression; break;\n     }\n     quantum_info=(QuantumInfo *) NULL;\n     if ((photometric == PHOTOMETRIC_PALETTE) &&\n         (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n       {\n         size_t\n           colors;\n \n         colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n         if (AcquireImageColormap(image,colors) == MagickFalse)\n           {\n             TIFFClose(tiff);\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           }\n       }\n     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n       image->scene=value;\n     if (image->storage_class == PseudoClass)\n       {\n         int\n           tiff_status;\n \n         size_t\n           range;\n \n         uint16\n           *blue_colormap = (uint16 *) NULL,\n           *green_colormap = (uint16 *) NULL,\n           *red_colormap = (uint16 *) NULL;\n \n         tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n           &green_colormap,&blue_colormap);\n         if (tiff_status == 1)\n           {\n             if ((red_colormap != (uint16 *) NULL) &&\n                 (green_colormap != (uint16 *) NULL) &&\n                 (blue_colormap != (uint16 *) NULL))\n               {\n                 range=255;\n                 for (i=0; i < (ssize_t) image->colors; i++)\n                   if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                       (blue_colormap[i] >= 256))\n                     {\n                       range=65535;\n                       break;\n                     }\n                 for (i=0; i < (ssize_t) image->colors; i++)\n                 {\n                   image->colormap[i].red=ClampToQuantum(((double)\n                     QuantumRange*red_colormap[i])/range);\n                   image->colormap[i].green=ClampToQuantum(((double)\n                     QuantumRange*green_colormap[i])/range);\n                   image->colormap[i].blue=ClampToQuantum(((double)\n                     QuantumRange*blue_colormap[i])/range);\n                 }\n               }\n           }\n       }\n     if (image_info->ping != MagickFalse)\n       {\n         if (image_info->number_scenes != 0)\n           if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n             break;\n         goto next_tiff_frame;\n       }\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n     status=SetImageColorspace(image,image->colorspace);\n     status&=ResetImagePixels(image,exception);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n     quantum_info=AcquireQuantumInfo(image_info,image);\n     if (quantum_info == (QuantumInfo *) NULL)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     if (sample_format == SAMPLEFORMAT_UINT)\n       status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n     if (sample_format == SAMPLEFORMAT_INT)\n       status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n     if (sample_format == SAMPLEFORMAT_IEEEFP)\n       status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n     if (status == MagickFalse)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     status=MagickTrue;\n     switch (photometric)\n     {\n       case PHOTOMETRIC_MINISBLACK:\n       {\n         quantum_info->min_is_white=MagickFalse;\n         break;\n       }\n       case PHOTOMETRIC_MINISWHITE:\n       {\n         quantum_info->min_is_white=MagickTrue;\n         break;\n       }\n       default:\n         break;\n     }\n     extra_samples=0;\n     tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n       &sample_info,sans);\n     if (tiff_status == 1)\n       {\n         (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n         if (extra_samples == 0)\n           {\n             if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n               image->matte=MagickTrue;\n           }\n         else\n           for (i=0; i < extra_samples; i++)\n           {\n             image->matte=MagickTrue;\n             if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n               {\n                 SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                 (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n               }\n             else\n               if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                 {\n                   SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                   (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                 }\n           }\n       }\n     if (image->matte != MagickFalse)\n       (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n     method=ReadGenericMethod;\n     rows_per_strip=(uint32) image->rows;\n     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n       {\n         char\n           value[MaxTextExtent];\n \n         (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n           rows_per_strip);\n         (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n         method=ReadStripMethod;\n         if (rows_per_strip > (uint32) image->rows)\n           rows_per_strip=(uint32) image->rows;\n       }\n     if (TIFFIsTiled(tiff) != MagickFalse)\n       {\n         uint32\n           columns,\n           rows;\n \n         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n           ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n         if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n             (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n           ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n         method=ReadTileMethod;\n       }\n     if ((photometric == PHOTOMETRIC_LOGLUV) ||\n         (compress_tag == COMPRESSION_CCITTFAX3))\n       method=ReadGenericMethod;\n     if (image->compression == JPEGCompression)\n       method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n         samples_per_pixel);\n     quantum_info->endian=LSBEndian;\n     scanline_size=TIFFScanlineSize(tiff);\n     if (scanline_size <= 0)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n       pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n       rows_per_strip);\n     if ((double) scanline_size > 1.5*number_pixels)\n       ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n     number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n     pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n     if (pixel_info == (MemoryInfo *) NULL)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n     quantum_type=GrayQuantum;\n     if (image->storage_class == PseudoClass)\n       quantum_type=IndexQuantum;\n     if (interlace != PLANARCONFIG_SEPARATE)\n       {\n         size_t\n           pad;\n \n         pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n         if (image->matte != MagickFalse)\n           {\n             if (image->storage_class == PseudoClass)\n               quantum_type=IndexAlphaQuantum;\n             else\n               quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                 GrayAlphaQuantum;\n           }\n         if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n           {\n             quantum_type=RGBQuantum;\n             pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n               extra_samples-3,0);\n             if (image->matte != MagickFalse)\n               {\n                 quantum_type=RGBAQuantum;\n                 pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                   extra_samples-4,0);\n               }\n             if (image->colorspace == CMYKColorspace)\n               {\n                 quantum_type=CMYKQuantum;\n                 pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                   extra_samples-4,0);\n                 if (image->matte != MagickFalse)\n                   {\n                     quantum_type=CMYKAQuantum;\n                     pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                       extra_samples-5,0);\n                   }\n               }\n             status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n               3));\n             if (status == MagickFalse)\n               ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n           }\n       }\n     switch (method)\n     {\n       case ReadYCCKMethod:\n       {\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           int\n             status;\n \n           IndexPacket\n             *indexes;\n \n           PixelPacket\n             *magick_restrict q;\n \n           ssize_t\n             x;\n \n           unsigned char\n             *p;\n \n           status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n           if (status == -1)\n             break;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           p=pixels;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n               (1.402*(double) *(p+2))-179.456)));\n             SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n               (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n               135.45984)));\n             SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n               (1.772*(double) *(p+1))-226.816)));\n             SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n             q++;\n             p+=4;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                 image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       case ReadStripMethod:\n       {\n         unsigned char\n           *p;\n \n         size_t\n           extent;\n \n         ssize_t\n           stride,\n           strip_id;\n \n         tsize_t\n           strip_size;\n \n         unsigned char\n           *strip_pixels;\n \n// bug_start\n        extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff);\n// bug_end\n         strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n           sizeof(*strip_pixels));\n         if (strip_pixels == (unsigned char *) NULL)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n         stride=TIFFVStripSize(tiff,1);\n         strip_id=0;\n         p=strip_pixels;\n         for (i=0; i < (ssize_t) samples_per_pixel; i++)\n         {\n           size_t\n             rows_remaining;\n \n           switch (i)\n           {\n             case 0: break;\n             case 1: quantum_type=GreenQuantum; break;\n             case 2: quantum_type=BlueQuantum; break;\n             case 3:\n             {\n               quantum_type=AlphaQuantum;\n               if (image->colorspace == CMYKColorspace)\n                 quantum_type=BlackQuantum;\n               break;\n             }\n             case 4: quantum_type=AlphaQuantum; break;\n             default: break;\n           }\n           rows_remaining=0;\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             PixelPacket\n               *magick_restrict q;\n \n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n             if (q == (PixelPacket *) NULL)\n               break;\n             if (rows_remaining == 0)\n               {\n                 strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                   TIFFStripSize(tiff));\n                 if (strip_size == -1)\n                   break;\n                 rows_remaining=rows_per_strip;\n                 if ((y+rows_per_strip) > (ssize_t) image->rows)\n                   rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                     image->rows));\n                 p=strip_pixels;\n                 strip_id++;\n               }\n             (void) ImportQuantumPixels(image,(CacheView *) NULL,\n               quantum_info,quantum_type,p,exception);\n             p+=stride;\n             rows_remaining--;\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n             if (image->previous == (Image *) NULL)\n               {\n                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                   image->rows);\n                 if (status == MagickFalse)\n                   break;\n               }\n           }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n             break;\n         }\n         strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n         break;\n       }\n       case ReadTileMethod:\n       {\n         unsigned char\n           *p;\n \n         size_t\n           extent;\n \n         uint32\n           columns,\n           rows;\n \n         unsigned char\n           *tile_pixels;\n \n         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n           ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n         number_pixels=(MagickSizeType) columns*rows;\n         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n           TIFFTileSize(tiff));\n         tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n           sizeof(*tile_pixels));\n         if (tile_pixels == (unsigned char *) NULL)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n         for (i=0; i < (ssize_t) samples_per_pixel; i++)\n         {\n           switch (i)\n           {\n             case 0: break;\n             case 1: quantum_type=GreenQuantum; break;\n             case 2: quantum_type=BlueQuantum; break;\n             case 3:\n             {\n               quantum_type=AlphaQuantum;\n               if (image->colorspace == CMYKColorspace)\n                 quantum_type=BlackQuantum;\n               break;\n             }\n             case 4: quantum_type=AlphaQuantum; break;\n             default: break;\n           }\n           for (y=0; y < (ssize_t) image->rows; y+=rows)\n           {\n             ssize_t\n               x;\n \n             size_t\n               rows_remaining;\n \n             rows_remaining=image->rows-y;\n             if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n               rows_remaining=rows;\n             for (x=0; x < (ssize_t) image->columns; x+=columns)\n             {\n               size_t\n                 columns_remaining,\n                 row;\n \n               columns_remaining=image->columns-x;\n               if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                 columns_remaining=columns;\n               tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                 0,i);\n               if (tiff_status == -1)\n                 break;\n               p=tile_pixels;\n               for (row=0; row < rows_remaining; row++)\n               {\n                 PixelPacket\n                   *magick_restrict q;\n \n                 q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                   exception);\n                 if (q == (PixelPacket *) NULL)\n                   break;\n                 (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                   quantum_info,quantum_type,p,exception);\n                 p+=TIFFTileRowSize(tiff);\n                 if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                   break;\n               }\n             }\n           }\n           if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                 samples_per_pixel);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n         break;\n       }\n       case ReadGenericMethod:\n       default:\n       {\n         MemoryInfo\n           *generic_info = (MemoryInfo *) NULL;\n \n         uint32\n           *p;\n \n         uint32\n           *pixels;\n \n         if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         number_pixels=(MagickSizeType) image->columns*image->rows;\n         generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n         if (generic_info == (MemoryInfo *) NULL)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n         tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n           image->rows,(uint32 *) pixels,0);\n         if (tiff_status == -1)\n           {\n             generic_info=RelinquishVirtualMemory(generic_info);\n             break;\n           }\n         p=pixels+(image->columns*image->rows)-1;\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           ssize_t\n             x;\n \n           PixelPacket\n             *magick_restrict q;\n \n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           q+=image->columns-1;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n             SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n             SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n             if (image->matte == MagickFalse)\n               SetPixelOpacity(q,OpaqueOpacity);\n             else\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n             p--;\n             q--;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                 image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         generic_info=RelinquishVirtualMemory(generic_info);\n         break;\n       }\n     }\n     pixel_info=RelinquishVirtualMemory(pixel_info);\n     SetQuantumImageType(image,quantum_type);\n   next_tiff_frame:\n     if (quantum_info != (QuantumInfo *) NULL)\n       quantum_info=DestroyQuantumInfo(quantum_info);\n     if (tiff_status == -1)\n       {\n         status=MagickFalse;\n         break;\n       }\n     if (photometric == PHOTOMETRIC_CIELAB)\n       DecodeLabImage(image,exception);\n     if ((photometric == PHOTOMETRIC_LOGL) ||\n         (photometric == PHOTOMETRIC_MINISBLACK) ||\n         (photometric == PHOTOMETRIC_MINISWHITE))\n       {\n         image->type=GrayscaleType;\n         if (bits_per_sample == 1)\n           image->type=BilevelType;\n       }\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n     if (more_frames != MagickFalse)\n       {\n         AcquireNextImage(image_info,image);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n             break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n           image->scene);\n         if (status == MagickFalse)\n           break;\n       }\n   } while ((status != MagickFalse) && (more_frames != MagickFalse));\n   TIFFClose(tiff);\n   if ((image_info->number_scenes != 0) &&\n       (image_info->scene >= GetImageListLength(image)))\n     status=MagickFalse;\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   TIFFReadPhotoshopLayers(image_info,image,exception);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-3213", "cve_desc": "A heap buffer overflow issue was found in ImageMagick. When an application processes a malformed TIFF file, it could lead to undefined behavior or a crash causing a denial of service.", "project": "ImageMagick6", "idx": 211845}
{"source": " struct nft_flow_rule *nft_flow_rule_create(struct net *net,\n \t\t\t\t\t   const struct nft_rule *rule)\n {\n \tstruct nft_offload_ctx *ctx;\n \tstruct nft_flow_rule *flow;\n \tint num_actions = 0, err;\n \tstruct nft_expr *expr;\n \n \texpr = nft_expr_first(rule);\n \twhile (nft_expr_more(rule, expr)) {\n// bug_start\n\t\tif (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)\n// bug_end\n \t\t\tnum_actions++;\n \n \t\texpr = nft_expr_next(expr);\n \t}\n \n \tif (num_actions == 0)\n \t\treturn ERR_PTR(-EOPNOTSUPP);\n \n \tflow = nft_flow_rule_alloc(num_actions);\n \tif (!flow)\n \t\treturn ERR_PTR(-ENOMEM);\n \n \texpr = nft_expr_first(rule);\n \n \tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n \tif (!ctx) {\n \t\terr = -ENOMEM;\n \t\tgoto err_out;\n \t}\n \tctx->net = net;\n \tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n \n \twhile (nft_expr_more(rule, expr)) {\n \t\tif (!expr->ops->offload) {\n \t\t\terr = -EOPNOTSUPP;\n \t\t\tgoto err_out;\n \t\t}\n \t\terr = expr->ops->offload(ctx, flow, expr);\n \t\tif (err < 0)\n \t\t\tgoto err_out;\n \n \t\texpr = nft_expr_next(expr);\n \t}\n \tnft_flow_rule_transfer_vlan(ctx, flow);\n \n \tflow->proto = ctx->dep.l3num;\n \tkfree(ctx);\n \n \treturn flow;\n err_out:\n \tkfree(ctx);\n \tnft_flow_rule_destroy(flow);\n \n \treturn ERR_PTR(err);\n }\n \n", "target": "// fix_start\n\t\tif (expr->ops->offload_action &&\n\t\t    expr->ops->offload_action(expr))\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "cve": "CVE-2022-25636", "cve_desc": "net/netfilter/nf_dup_netdev.c in the Linux kernel 5.4 through 5.6.10 allows local users to gain privileges because of a heap out-of-bounds write. This is related to nf_tables_offload.", "project": "nf", "idx": 211868}
{"source": " addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n            const XML_Char *uri, BINDING **bindingsPtr) {\n   static const XML_Char xmlNamespace[]\n       = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n          ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n          ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n          ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n          ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n          ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n          ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n          ASCII_e,      '\\0'};\n   static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n   static const XML_Char xmlnsNamespace[]\n       = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n          ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n          ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n          ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n          ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n   static const int xmlnsLen\n       = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n \n   XML_Bool mustBeXML = XML_FALSE;\n   XML_Bool isXML = XML_TRUE;\n   XML_Bool isXMLNS = XML_TRUE;\n \n   BINDING *b;\n   int len;\n \n   if (*uri == XML_T('\\0') && prefix->name)\n     return XML_ERROR_UNDECLARING_PREFIX;\n \n   if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n       && prefix->name[1] == XML_T(ASCII_m)\n       && prefix->name[2] == XML_T(ASCII_l)) {\n     if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n         && prefix->name[5] == XML_T('\\0'))\n       return XML_ERROR_RESERVED_PREFIX_XMLNS;\n \n     if (prefix->name[3] == XML_T('\\0'))\n       mustBeXML = XML_TRUE;\n   }\n \n   for (len = 0; uri[len]; len++) {\n     if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n       isXML = XML_FALSE;\n \n     if (! mustBeXML && isXMLNS\n         && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n       isXMLNS = XML_FALSE;\n// bug_start\n// bug_end\n   }\n   isXML = isXML && len == xmlLen;\n   isXMLNS = isXMLNS && len == xmlnsLen;\n \n   if (mustBeXML != isXML)\n     return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                      : XML_ERROR_RESERVED_NAMESPACE_URI;\n \n   if (isXMLNS)\n     return XML_ERROR_RESERVED_NAMESPACE_URI;\n \n   if (parser->m_namespaceSeparator)\n     len++;\n   if (parser->m_freeBindingList) {\n     b = parser->m_freeBindingList;\n     if (len > b->uriAlloc) {\n       if (len > INT_MAX - EXPAND_SPARE) {\n         return XML_ERROR_NO_MEMORY;\n       }\n \n #if UINT_MAX >= SIZE_MAX\n       if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n         return XML_ERROR_NO_MEMORY;\n       }\n #endif\n \n       XML_Char *temp = (XML_Char *)REALLOC(\n           parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n       if (temp == NULL)\n         return XML_ERROR_NO_MEMORY;\n       b->uri = temp;\n       b->uriAlloc = len + EXPAND_SPARE;\n     }\n     parser->m_freeBindingList = b->nextTagBinding;\n   } else {\n     b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n     if (! b)\n       return XML_ERROR_NO_MEMORY;\n \n     if (len > INT_MAX - EXPAND_SPARE) {\n       return XML_ERROR_NO_MEMORY;\n     }\n #if UINT_MAX >= SIZE_MAX\n     if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n       return XML_ERROR_NO_MEMORY;\n     }\n #endif\n \n     b->uri\n         = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n     if (! b->uri) {\n       FREE(parser, b);\n       return XML_ERROR_NO_MEMORY;\n     }\n     b->uriAlloc = len + EXPAND_SPARE;\n   }\n   b->uriLen = len;\n   memcpy(b->uri, uri, len * sizeof(XML_Char));\n   if (parser->m_namespaceSeparator)\n     b->uri[len - 1] = parser->m_namespaceSeparator;\n   b->prefix = prefix;\n   b->attId = attId;\n   b->prevPrefixBinding = prefix->binding;\n   if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n     prefix->binding = NULL;\n   else\n     prefix->binding = b;\n   b->nextTagBinding = *bindingsPtr;\n   *bindingsPtr = b;\n   if (attId && parser->m_startNamespaceDeclHandler)\n     parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                         prefix->binding ? uri : 0);\n   return XML_ERROR_NONE;\n }\n \n", "target": "// fix_start\n\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {\n      return XML_ERROR_SYNTAX;\n    }\n// fix_end\n", "cwe": "CWE-668", "cwe_name": "Exposure of Resource to Wrong Sphere", "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "project": "libexpat", "idx": 211877}
{"source": " jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n {\n \tjp2_box_t *box;\n \tint found;\n \tjas_image_t *image;\n \tjp2_dec_t *dec;\n \tbool samedtype;\n \tint dtype;\n \tunsigned int i;\n \tjp2_cmap_t *cmapd;\n \tjp2_pclr_t *pclrd;\n \tjp2_cdef_t *cdefd;\n \tunsigned int channo;\n \tint newcmptno;\n \tint_fast32_t *lutents;\n #if 0\n \tjp2_cdefchan_t *cdefent;\n \tint cmptno;\n #endif\n \tjp2_cmapent_t *cmapent;\n \tjas_icchdr_t icchdr;\n \tjas_iccprof_t *iccprof;\n \n \tdec = 0;\n \tbox = 0;\n \timage = 0;\n \n \tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n \n \tif (!(dec = jp2_dec_create())) {\n \t\tgoto error;\n \t}\n \n \tif (!(box = jp2_box_get(in))) {\n \t\tjas_eprintf(\"error: cannot get box\\n\");\n \t\tgoto error;\n \t}\n \tif (box->type != JP2_BOX_JP) {\n \t\tjas_eprintf(\"error: expecting signature box\\n\");\n \t\tgoto error;\n \t}\n \tif (box->data.jp.magic != JP2_JP_MAGIC) {\n \t\tjas_eprintf(\"incorrect magic number\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \tif (!(box = jp2_box_get(in))) {\n \t\tgoto error;\n \t}\n \tif (box->type != JP2_BOX_FTYP) {\n \t\tjas_eprintf(\"expecting file type box\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \tfound = 0;\n \twhile ((box = jp2_box_get(in))) {\n \t\tif (jas_getdbglevel() >= 1) {\n \t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n \t\t}\n \t\tswitch (box->type) {\n \t\tcase JP2_BOX_JP2C:\n \t\t\tfound = 1;\n \t\t\tbreak;\n \t\tcase JP2_BOX_IHDR:\n \t\t\tif (!dec->ihdr) {\n \t\t\t\tdec->ihdr = box;\n \t\t\t\tbox = 0;\n \t\t\t}\n \t\t\tbreak;\n \t\tcase JP2_BOX_BPCC:\n \t\t\tif (!dec->bpcc) {\n \t\t\t\tdec->bpcc = box;\n \t\t\t\tbox = 0;\n \t\t\t}\n \t\t\tbreak;\n \t\tcase JP2_BOX_CDEF:\n \t\t\tif (!dec->cdef) {\n \t\t\t\tdec->cdef = box;\n \t\t\t\tbox = 0;\n \t\t\t}\n \t\t\tbreak;\n \t\tcase JP2_BOX_PCLR:\n \t\t\tif (!dec->pclr) {\n \t\t\t\tdec->pclr = box;\n \t\t\t\tbox = 0;\n \t\t\t}\n \t\t\tbreak;\n \t\tcase JP2_BOX_CMAP:\n \t\t\tif (!dec->cmap) {\n \t\t\t\tdec->cmap = box;\n \t\t\t\tbox = 0;\n \t\t\t}\n \t\t\tbreak;\n \t\tcase JP2_BOX_COLR:\n \t\t\tif (!dec->colr) {\n \t\t\t\tdec->colr = box;\n \t\t\t\tbox = 0;\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tif (box) {\n \t\t\tjp2_box_destroy(box);\n \t\t\tbox = 0;\n \t\t}\n \t\tif (found) {\n \t\t\tbreak;\n \t\t}\n \t}\n \n \tif (!found) {\n \t\tjas_eprintf(\"error: no code stream found\\n\");\n \t\tgoto error;\n \t}\n \n \tif (!(dec->image = jpc_decode(in, optstr))) {\n \t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n \t\tgoto error;\n \t}\n \n \tif (!dec->ihdr) {\n \t\tjas_eprintf(\"error: missing IHDR box\\n\");\n \t\tgoto error;\n \t}\n \n \tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n \t  jas_image_numcmpts(dec->image))) {\n \t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n \t}\n \n \tif (!jas_image_numcmpts(dec->image)) {\n \t\tjas_eprintf(\"error: no components\\n\");\n \t\tgoto error;\n \t}\n \n \tsamedtype = true;\n \tdtype = jas_image_cmptdtype(dec->image, 0);\n \tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n \t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n \t\t\tsamedtype = false;\n \t\t\tbreak;\n \t\t}\n \t}\n \n \tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n \t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n \t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n \t}\n \n \tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n \t\tjas_eprintf(\"error: unsupported compression type\\n\");\n \t\tgoto error;\n \t}\n \n \tif (dec->bpcc) {\n \t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n \t\t  dec->image))) {\n \t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n \t\t}\n \t\tif (!samedtype) {\n \t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n \t\t\t  ++i) {\n \t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n \t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n \t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n \t\t}\n \t}\n \n \tif (!dec->colr) {\n \t\tjas_eprintf(\"error: no COLR box\\n\");\n \t\tgoto error;\n \t}\n \n \tswitch (dec->colr->data.colr.method) {\n \tcase JP2_COLR_ENUM:\n \t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n \t\tbreak;\n \tcase JP2_COLR_ICC:\n \t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n \t\t  dec->colr->data.colr.iccplen);\n \t\tif (!iccprof) {\n \t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_iccprof_gethdr(iccprof, &icchdr);\n \t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n \t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n \t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n \t\tassert(dec->image->cmprof_);\n \t\tjas_iccprof_destroy(iccprof);\n \t\tbreak;\n \t}\n \n \tif (dec->cmap && !dec->pclr) {\n \t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n \t\tjp2_box_destroy(dec->cmap);\n \t\tdec->cmap = 0;\n \t}\n \n \tif (!dec->cmap && dec->pclr) {\n \t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n \t\tjp2_box_destroy(dec->pclr);\n \t\tdec->pclr = 0;\n \t}\n \n \tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n \t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n \n \tif (dec->cmap) {\n \t\tfor (i = 0; i < dec->numchans; ++i) {\n \t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n \t\t\t  jas_image_numcmpts(dec->image))) {\n \t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n \t\t\t  dec->pclr->data.pclr.numchans) {\n \t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t}\n \t}\n \n \tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n \t  sizeof(uint_fast16_t)))) {\n \t\tjas_eprintf(\"error: no memory\\n\");\n \t\tgoto error;\n \t}\n \n \tif (!dec->cmap) {\n \t\tfor (i = 0; i < dec->numchans; ++i) {\n \t\t\tdec->chantocmptlut[i] = i;\n \t\t}\n \t} else {\n \t\tcmapd = &dec->cmap->data.cmap;\n \t\tpclrd = &dec->pclr->data.pclr;\n \t\tcdefd = &dec->cdef->data.cdef;\n \t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n \t\t\tcmapent = &cmapd->ents[channo];\n \t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n \t\t\t\tdec->chantocmptlut[channo] = channo;\n \t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n \t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n \t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n \t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n \t\t\t\t}\n \t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n \t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n \t\t\t\t  pclrd->numlutents, lutents,\n \t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n \t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n \t\t\t\tjas_free(lutents);\n #if 0\n \t\t\t\tif (dec->cdef) {\n \t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n \t\t\t\t\tif (!cdefent) {\n \t\t\t\t\t\tabort();\n \t\t\t\t\t}\n \t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n \t\t\t\t} else {\n \t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n \t\t\t\t}\n #endif\n \t\t\t}\n \t\t}\n \t}\n \n \n \tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n \t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n \t}\n \n \tif (dec->cdef) {\n// bug_start\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n// bug_end\n \t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n \t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t\tjas_image_setcmpttype(dec->image,\n \t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n \t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n \t\t\t  dec->cdef->data.cdef.ents[i].type,\n \t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n \t\t}\n \t} else {\n \t\tfor (i = 0; i < dec->numchans; ++i) {\n \t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n \t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n \t\t}\n \t}\n \n \tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n \t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n \t\t\tjas_image_delcmpt(dec->image, i - 1);\n \t\t}\n \t}\n \n \tif (!jas_image_numcmpts(dec->image)) {\n \t\tjas_eprintf(\"error: no components\\n\");\n \t\tgoto error;\n \t}\n #if 0\n jas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n #endif\n \n \timage = dec->image;\n \tdec->image = 0;\n \n \tjp2_dec_destroy(dec);\n \n \treturn image;\n \n error:\n \tif (box) {\n \t\tjp2_box_destroy(box);\n \t}\n \tif (dec) {\n \t\tjp2_dec_destroy(dec);\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2017-9782", "cve_desc": "JasPer 2.0.12 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted image, related to the jp2_decode function in libjasper/jp2/jp2_dec.c.", "project": "jasper", "idx": 211915}
{"source": " static int ismt_access(struct i2c_adapter *adap, u16 addr,\n \t\t       unsigned short flags, char read_write, u8 command,\n \t\t       int size, union i2c_smbus_data *data)\n {\n \tint ret;\n \tunsigned long time_left;\n \tdma_addr_t dma_addr = 0;\n \tu8 dma_size = 0;\n \tenum dma_data_direction dma_direction = 0;\n \tstruct ismt_desc *desc;\n \tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n \tstruct device *dev = &priv->pci_dev->dev;\n \tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n \n \tdesc = &priv->hw[priv->head];\n \n \tmemset(priv->buffer, 0, sizeof(priv->buffer));\n \n \tmemset(desc, 0, sizeof(struct ismt_desc));\n \tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n \n \tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n \n \tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n \t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n \telse\n \t\tdesc->control = ISMT_DESC_FAIR;\n \n \tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n \t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n \t\tdesc->control |= ISMT_DESC_PEC;\n \n \tswitch (size) {\n \tcase I2C_SMBUS_QUICK:\n \t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n \t\tbreak;\n \n \tcase I2C_SMBUS_BYTE:\n \t\tif (read_write == I2C_SMBUS_WRITE) {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n \t\t\tdesc->control |= ISMT_DESC_CWRL;\n \t\t\tdesc->wr_len_cmd = command;\n \t\t} else {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n \t\t\tdma_size = 1;\n \t\t\tdma_direction = DMA_FROM_DEVICE;\n \t\t\tdesc->rd_len = 1;\n \t\t}\n \t\tbreak;\n \n \tcase I2C_SMBUS_BYTE_DATA:\n \t\tif (read_write == I2C_SMBUS_WRITE) {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n \t\t\tdesc->wr_len_cmd = 2;\n \t\t\tdma_size = 2;\n \t\t\tdma_direction = DMA_TO_DEVICE;\n \t\t\tdma_buffer[0] = command;\n \t\t\tdma_buffer[1] = data->byte;\n \t\t} else {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n \t\t\tdesc->control |= ISMT_DESC_CWRL;\n \t\t\tdesc->wr_len_cmd = command;\n \t\t\tdesc->rd_len = 1;\n \t\t\tdma_size = 1;\n \t\t\tdma_direction = DMA_FROM_DEVICE;\n \t\t}\n \t\tbreak;\n \n \tcase I2C_SMBUS_WORD_DATA:\n \t\tif (read_write == I2C_SMBUS_WRITE) {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n \t\t\tdesc->wr_len_cmd = 3;\n \t\t\tdma_size = 3;\n \t\t\tdma_direction = DMA_TO_DEVICE;\n \t\t\tdma_buffer[0] = command;\n \t\t\tdma_buffer[1] = data->word & 0xff;\n \t\t\tdma_buffer[2] = data->word >> 8;\n \t\t} else {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n \t\t\tdesc->wr_len_cmd = command;\n \t\t\tdesc->control |= ISMT_DESC_CWRL;\n \t\t\tdesc->rd_len = 2;\n \t\t\tdma_size = 2;\n \t\t\tdma_direction = DMA_FROM_DEVICE;\n \t\t}\n \t\tbreak;\n \n \tcase I2C_SMBUS_PROC_CALL:\n \t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n \t\tdesc->wr_len_cmd = 3;\n \t\tdesc->rd_len = 2;\n \t\tdma_size = 3;\n \t\tdma_direction = DMA_BIDIRECTIONAL;\n \t\tdma_buffer[0] = command;\n \t\tdma_buffer[1] = data->word & 0xff;\n \t\tdma_buffer[2] = data->word >> 8;\n \t\tbreak;\n \n \tcase I2C_SMBUS_BLOCK_DATA:\n \t\tif (read_write == I2C_SMBUS_WRITE) {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n \t\t\tdma_size = data->block[0] + 1;\n \t\t\tdma_direction = DMA_TO_DEVICE;\n \t\t\tdesc->wr_len_cmd = dma_size;\n \t\t\tdesc->control |= ISMT_DESC_BLK;\n \t\t\tdma_buffer[0] = command;\n \t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n \t\t} else {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n \t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n \t\t\tdma_direction = DMA_FROM_DEVICE;\n \t\t\tdesc->rd_len = dma_size;\n \t\t\tdesc->wr_len_cmd = command;\n \t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n \t\t}\n \t\tbreak;\n \n \tcase I2C_SMBUS_BLOCK_PROC_CALL:\n \t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n// bug_start\n// bug_end\n \t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n \t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n \t\tdesc->wr_len_cmd = data->block[0] + 1;\n \t\tdesc->rd_len = dma_size;\n \t\tdesc->control |= ISMT_DESC_BLK;\n \t\tdma_direction = DMA_BIDIRECTIONAL;\n \t\tdma_buffer[0] = command;\n \t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n \t\tbreak;\n \n \tcase I2C_SMBUS_I2C_BLOCK_DATA:\n \t\tif (data->block[0] < 1)\n \t\t\tdata->block[0] = 1;\n \n \t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n \t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n \n \t\tif (read_write == I2C_SMBUS_WRITE) {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n \t\t\tdma_size = data->block[0] + 1;\n \t\t\tdma_direction = DMA_TO_DEVICE;\n \t\t\tdesc->wr_len_cmd = dma_size;\n \t\t\tdesc->control |= ISMT_DESC_I2C;\n \t\t\tdma_buffer[0] = command;\n \t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n \t\t} else {\n \t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n \t\t\tdma_size = data->block[0];\n \t\t\tdma_direction = DMA_FROM_DEVICE;\n \t\t\tdesc->rd_len = dma_size;\n \t\t\tdesc->wr_len_cmd = command;\n \t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n \t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n \t\t}\n \t\tbreak;\n \n \tdefault:\n \t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n \t\t\tsize);\n \t\treturn -EOPNOTSUPP;\n \t}\n \n \tif (dma_size != 0) {\n \t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n \t\tdev_dbg(dev, \" data=%p\\n\", data);\n \t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n \t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n \t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n \n \t\tdma_addr = dma_map_single(dev,\n \t\t\t\t      dma_buffer,\n \t\t\t\t      dma_size,\n \t\t\t\t      dma_direction);\n \n \t\tif (dma_mapping_error(dev, dma_addr)) {\n \t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n \t\t\t\tdma_buffer);\n \t\t\treturn -EIO;\n \t\t}\n \n \t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n \n \t\tdesc->dptr_low = lower_32_bits(dma_addr);\n \t\tdesc->dptr_high = upper_32_bits(dma_addr);\n \t}\n \n \treinit_completion(&priv->cmp);\n \n \tismt_submit_desc(priv);\n \n \ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n \n \tif (dma_size != 0)\n \t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n \n \tif (unlikely(!time_left)) {\n \t\tdev_err(dev, \"completion wait timed out\\n\");\n \t\tret = -ETIMEDOUT;\n \t\tgoto out;\n \t}\n \n \tret = ismt_process_desc(desc, data, priv, size, read_write);\n \n out:\n \tpriv->head++;\n \tpriv->head %= ISMT_DESC_ENTRIES;\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-3077", "cve_desc": "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system.", "project": "linux", "idx": 212083}
{"source": " MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n     MOBI_RET ret;\n     const size_t offset = mobi_get_kf8offset(m);\n     if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n         debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n         return MOBI_DATA_CORRUPT;\n     }\n     const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n     const size_t huff_rec_count = *m->mh->huff_rec_count;\n     if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n         debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n         return MOBI_DATA_CORRUPT;\n     }\n     const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n     if (curr == NULL || huff_rec_count < 2) {\n         debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n         return MOBI_DATA_CORRUPT;\n     }\n     if (curr->size < HUFF_RECORD_MINSIZE) {\n         debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n         return MOBI_DATA_CORRUPT;\n     }\n     ret = mobi_parse_huff(huffcdic, curr);\n     if (ret != MOBI_SUCCESS) {\n         debug_print(\"%s\", \"HUFF parsing failed\\n\");\n         return ret;\n     }\n     curr = curr->next;\n     huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n     if (huffcdic->symbols == NULL) {\n         debug_print(\"%s\\n\", \"Memory allocation failed\");\n         return MOBI_MALLOC_FAILED;\n     }\n     size_t i = 0;\n     while (i < huff_rec_count - 1) {\n         if (curr == NULL) {\n             debug_print(\"%s\\n\", \"CDIC record not found\");\n             return MOBI_DATA_CORRUPT;\n         }\n         ret = mobi_parse_cdic(huffcdic, curr, i++);\n         if (ret != MOBI_SUCCESS) {\n             debug_print(\"%s\", \"CDIC parsing failed\\n\");\n             return ret;\n         }\n         curr = curr->next;\n     }\n// bug_start\n// bug_end\n     return MOBI_SUCCESS;\n }\n \n", "target": "// fix_start\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2021-3888", "cve_desc": "libmobi is vulnerable to Use of Out-of-range Pointer Offset", "project": "libmobi", "idx": 212144}
{"source": " disable_priv_mode ()\n {\n   int e;\n \n// bug_start\n// bug_end\n   if (setuid (current_user.uid) < 0)\n// bug_start\n// bug_end\n     {\n       e = errno;\n       sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n #if defined (EXIT_ON_SETUID_FAILURE)\n       if (e == EAGAIN)\n \texit (e);\n #endif\n     }\n// bug_start\n// bug_end\n   if (setgid (current_user.gid) < 0)\n// bug_start\n// bug_end\n     sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n \n   current_user.euid = current_user.uid;\n   current_user.egid = current_user.gid;\n }\n \n", "target": "// fix_start\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n// fix_end\n// fix_start\n#endif\n// fix_end\n// fix_start\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n// fix_end\n// fix_start\n#endif\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2019-18276", "cve_desc": "An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support \"saved UID\" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use \"enable -f\" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.", "project": "bash", "idx": 212152}
{"source": " static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n {\n     auth_client *auth_user = stream;\n// bug_start\n    size_t bytes = size * nmemb;\n// bug_end\n     client_t *client = auth_user->client;\n \n// bug_start\n    if (client)\n    {\n// bug_end\n         auth_t *auth = client->auth;\n         auth_url *url = auth->state;\n// bug_start\n        if (strncasecmp (ptr, url->auth_header, url->auth_header_len) == 0)\n// bug_end\n             client->authenticated = 1;\n// bug_start\n        if (strncasecmp (ptr, url->timelimit_header, url->timelimit_header_len) == 0)\n        {\n// bug_end\n             unsigned int limit = 0;\n// bug_start\n            sscanf ((char *)ptr+url->timelimit_header_len, \"%u\\r\\n\", &limit);\n            client->con->discon_time = time(NULL) + limit;\n// bug_end\n         }\n// bug_start\n        if (strncasecmp (ptr, \"icecast-auth-message: \", 22) == 0)\n        {\n            char *eol;\n            snprintf (url->errormsg, sizeof (url->errormsg), \"%s\", (char*)ptr+22);\n            eol = strchr (url->errormsg, '\\r');\n            if (eol == NULL)\n                eol = strchr (url->errormsg, '\\n');\n            if (eol)\n                *eol = '\\0';\n// bug_end\n         }\n     }\n \n// bug_start\n    return bytes;\n// bug_end\n }\n \n", "target": "// fix_start\n    size_t len = size * nmemb;\n// fix_end\n// fix_start\n    if (client) {\n// fix_end\n// fix_start\n\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n// fix_end\n// fix_start\n\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n// fix_end\n// fix_start\n\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n// fix_end\n// fix_start\n\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1;\n\n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n// fix_end\n// fix_start\n    return len;\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2018-18820", "cve_desc": "A buffer overflow was discovered in the URL-authentication backend of the Icecast before 2.4.4. If the backend is enabled, then any malicious HTTP client can send a request for that specific resource including a crafted header, leading to denial of service and potentially remote code execution.", "project": "icecast-server", "idx": 212339}
{"source": " http_isfiltered(const struct http *fm, unsigned u, unsigned how)\n {\n \tconst char *e;\n \tconst struct http_hdrflg *f;\n \n \tif (fm->hdf[u] & HDF_FILTER)\n \t\treturn (1);\n// bug_start\n// bug_end\n \te = strchr(fm->hd[u].b, ':');\n \tif (e == NULL)\n \t\treturn (0);\n \tf = http_hdr_flags(fm->hd[u].b, e);\n \treturn (f != NULL && f->flag & how);\n }\n \n", "target": "// fix_start\n\tif (u < HTTP_HDR_FIRST)\n\t\treturn (0);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-38150", "cve_desc": "In Varnish Cache 7.0.0, 7.0.1, 7.0.2, and 7.1.0, it is possible to cause the Varnish Server to assert and automatically restart through forged HTTP/1 backend responses. An attack uses a crafted reason phrase of the backend response status line. This is fixed in 7.0.3 and 7.1.1.", "project": "varnish-cache", "idx": 212407}
{"source": " static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n \t\t\t  struct netlink_ext_ack *extack)\n {\n \tstruct net *net = sock_net(skb->sk);\n \tstruct nlattr *tca[TCA_MAX + 1];\n \tchar name[IFNAMSIZ];\n \tstruct tcmsg *t;\n \tu32 protocol;\n \tu32 prio;\n \tbool prio_allocate;\n \tu32 parent;\n \tu32 chain_index;\n// bug_start\n\tstruct Qdisc *q = NULL;\n// bug_end\n \tstruct tcf_chain_info chain_info;\n// bug_start\n\tstruct tcf_chain *chain = NULL;\n// bug_end\n \tstruct tcf_block *block;\n \tstruct tcf_proto *tp;\n \tunsigned long cl;\n \tvoid *fh;\n \tint err;\n \tint tp_created;\n \tbool rtnl_held = false;\n \tu32 flags;\n \n \tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n replay:\n \ttp_created = 0;\n \n \terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n \t\t\t\t     rtm_tca_policy, extack);\n \tif (err < 0)\n \t\treturn err;\n \n \tt = nlmsg_data(n);\n \tprotocol = TC_H_MIN(t->tcm_info);\n \tprio = TC_H_MAJ(t->tcm_info);\n \tprio_allocate = false;\n \tparent = t->tcm_parent;\n \ttp = NULL;\n \tcl = 0;\n \tblock = NULL;\n// bug_start\n// bug_end\n \tflags = 0;\n \n \tif (prio == 0) {\n \t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n \t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n \t\t\tprio_allocate = true;\n \t\t} else {\n \t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n \t\t\treturn -ENOENT;\n \t\t}\n \t}\n \n \n \terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n \tif (err)\n \t\treturn err;\n \n \tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n \t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n \t\terr = -EINVAL;\n \t\tgoto errout;\n \t}\n \n \tif (rtnl_held ||\n \t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n \t    !tcf_proto_is_unlocked(name)) {\n \t\trtnl_held = true;\n \t\trtnl_lock();\n \t}\n \n \terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n \tif (err)\n \t\tgoto errout;\n \n \tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n \t\t\t\t extack);\n \tif (IS_ERR(block)) {\n \t\terr = PTR_ERR(block);\n \t\tgoto errout;\n \t}\n \tblock->classid = parent;\n \n \tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n \tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n \t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n \t\terr = -EINVAL;\n \t\tgoto errout;\n \t}\n \tchain = tcf_chain_get(block, chain_index, true);\n \tif (!chain) {\n \t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n \t\terr = -ENOMEM;\n \t\tgoto errout;\n \t}\n \n \tmutex_lock(&chain->filter_chain_lock);\n \ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n \t\t\t       prio, prio_allocate);\n \tif (IS_ERR(tp)) {\n \t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n \t\terr = PTR_ERR(tp);\n \t\tgoto errout_locked;\n \t}\n \n \tif (tp == NULL) {\n \t\tstruct tcf_proto *tp_new = NULL;\n \n \t\tif (chain->flushing) {\n \t\t\terr = -EAGAIN;\n \t\t\tgoto errout_locked;\n \t\t}\n \n \n \t\tif (tca[TCA_KIND] == NULL || !protocol) {\n \t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n \t\t\terr = -EINVAL;\n \t\t\tgoto errout_locked;\n \t\t}\n \n \t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n \t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n \t\t\terr = -ENOENT;\n \t\t\tgoto errout_locked;\n \t\t}\n \n \t\tif (prio_allocate)\n \t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n \t\t\t\t\t\t\t       &chain_info));\n \n \t\tmutex_unlock(&chain->filter_chain_lock);\n \t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n \t\t\t\t\t  rtnl_held, extack);\n \t\tif (IS_ERR(tp_new)) {\n \t\t\terr = PTR_ERR(tp_new);\n \t\t\tgoto errout_tp;\n \t\t}\n \n \t\ttp_created = 1;\n \t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n \t\t\t\t\t\trtnl_held);\n \t\tif (IS_ERR(tp)) {\n \t\t\terr = PTR_ERR(tp);\n \t\t\tgoto errout_tp;\n \t\t}\n \t} else {\n \t\tmutex_unlock(&chain->filter_chain_lock);\n \t}\n \n \tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n \t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n \t\terr = -EINVAL;\n \t\tgoto errout;\n \t}\n \n \tfh = tp->ops->get(tp, t->tcm_handle);\n \n \tif (!fh) {\n \t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n \t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n \t\t\terr = -ENOENT;\n \t\t\tgoto errout;\n \t\t}\n \t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n \t\ttfilter_put(tp, fh);\n \t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n \t\terr = -EEXIST;\n \t\tgoto errout;\n \t}\n \n \tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n \t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n \t\terr = -EINVAL;\n \t\tgoto errout;\n \t}\n \n \tif (!(n->nlmsg_flags & NLM_F_CREATE))\n \t\tflags |= TCA_ACT_FLAGS_REPLACE;\n \tif (!rtnl_held)\n \t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n \terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n \t\t\t      flags, extack);\n \tif (err == 0) {\n \t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n \t\t\t       RTM_NEWTFILTER, false, rtnl_held);\n \t\ttfilter_put(tp, fh);\n \t\tif (q)\n \t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n \t}\n \n errout:\n \tif (err && tp_created)\n \t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\n errout_tp:\n \tif (chain) {\n \t\tif (tp && !IS_ERR(tp))\n \t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n \t\tif (!tp_created)\n \t\t\ttcf_chain_put(chain);\n \t}\n \ttcf_block_release(q, block, rtnl_held);\n \n \tif (rtnl_held)\n \t\trtnl_unlock();\n \n \tif (err == -EAGAIN) {\n \t\trtnl_held = true;\n \t\tgoto replay;\n \t}\n \treturn err;\n \n errout_locked:\n \tmutex_unlock(&chain->filter_chain_lock);\n \tgoto errout;\n }\n \n", "target": "// fix_start\n\tstruct Qdisc *q;\n// fix_end\n// fix_start\n\tstruct tcf_chain *chain;\n// fix_end\n// fix_start\n\tq = NULL;\n\tchain = NULL;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-1055", "cve_desc": "A use-after-free exists in the Linux Kernel in tc_new_tfilter that could allow a local attacker to gain privilege escalation. The exploit requires unprivileged user namespaces. We recommend upgrading past commit 04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "project": "linux", "idx": 212414}
{"source": " do_tag(\n     char_u\t*tag,\n     int\t\ttype,\n     int\t\tcount,\n     int\t\tforceit,\n     int\t\tverbose)\n {\n     taggy_T\t*tagstack = curwin->w_tagstack;\n     int\t\ttagstackidx = curwin->w_tagstackidx;\n     int\t\ttagstacklen = curwin->w_tagstacklen;\n     int\t\tcur_match = 0;\n     int\t\tcur_fnum = curbuf->b_fnum;\n     int\t\toldtagstackidx = tagstackidx;\n     int\t\tprevtagstackidx = tagstackidx;\n     int\t\tprev_num_matches;\n     int\t\tnew_tag = FALSE;\n     int\t\ti;\n     int\t\tic;\n     int\t\tno_regexp = FALSE;\n     int\t\terror_cur_match = 0;\n     int\t\tsave_pos = FALSE;\n     fmark_T\tsaved_fmark;\n #ifdef FEAT_CSCOPE\n     int\t\tjumped_to_tag = FALSE;\n #endif\n     int\t\tnew_num_matches;\n     char_u\t**new_matches;\n     int\t\tuse_tagstack;\n     int\t\tskip_msg = FALSE;\n     char_u\t*buf_ffname = curbuf->b_ffname;\n     int\t\tuse_tfu = 1;\n     char_u\t*tofree = NULL;\n \n     static int\t\tnum_matches = 0;\n     static int\t\tmax_num_matches = 0;\n     static char_u\t**matches = NULL;\n     static int\t\tflags;\n \n #ifdef FEAT_EVAL\n     if (tfu_in_use)\n     {\n \temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n \treturn FALSE;\n     }\n #endif\n \n #ifdef EXITFREE\n     if (type == DT_FREE)\n     {\n \tFreeWild(num_matches, matches);\n # ifdef FEAT_CSCOPE\n \tcs_free_tags();\n # endif\n \tnum_matches = 0;\n \treturn FALSE;\n     }\n #endif\n \n     if (type == DT_HELP)\n     {\n \ttype = DT_TAG;\n \tno_regexp = TRUE;\n \tuse_tfu = 0;\n     }\n \n     prev_num_matches = num_matches;\n     free_string_option(nofile_fname);\n     nofile_fname = NULL;\n \n     CLEAR_POS(&saved_fmark.mark);\n     saved_fmark.fnum = 0;\n \n     if ((!p_tgst && *tag != NUL))\n     {\n \tuse_tagstack = FALSE;\n \tnew_tag = TRUE;\n #if defined(FEAT_QUICKFIX)\n \tif (g_do_tagpreview != 0)\n \t{\n \t    tagstack_clear_entry(&ptag_entry);\n \t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n \t\tgoto end_do_tag;\n \t}\n #endif\n     }\n     else\n     {\n #if defined(FEAT_QUICKFIX)\n \tif (g_do_tagpreview != 0)\n \t    use_tagstack = FALSE;\n \telse\n #endif\n \t    use_tagstack = TRUE;\n \n \tif (*tag != NUL\n \t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n #ifdef FEAT_QUICKFIX\n \t\t    || type == DT_LTAG\n #endif\n #ifdef FEAT_CSCOPE\n \t\t    || type == DT_CSCOPE\n #endif\n \t\t    ))\n \t{\n #if defined(FEAT_QUICKFIX)\n \t    if (g_do_tagpreview != 0)\n \t    {\n \t\tif (ptag_entry.tagname != NULL\n \t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n \t\t{\n \t\t    cur_match = ptag_entry.cur_match;\n \t\t    cur_fnum = ptag_entry.cur_fnum;\n \t\t}\n \t\telse\n \t\t{\n \t\t    tagstack_clear_entry(&ptag_entry);\n \t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n \t\t\tgoto end_do_tag;\n \t\t}\n \t    }\n \t    else\n #endif\n \t    {\n \t\twhile (tagstackidx < tagstacklen)\n \t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n \n \t\tif (++tagstacklen > TAGSTACKSIZE)\n \t\t{\n \t\t    tagstacklen = TAGSTACKSIZE;\n \t\t    tagstack_clear_entry(&tagstack[0]);\n \t\t    for (i = 1; i < tagstacklen; ++i)\n \t\t\ttagstack[i - 1] = tagstack[i];\n \t\t    --tagstackidx;\n \t\t}\n \n \t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n \t\t{\n \t\t    curwin->w_tagstacklen = tagstacklen - 1;\n \t\t    goto end_do_tag;\n \t\t}\n \t\tcurwin->w_tagstacklen = tagstacklen;\n \n \t\tsave_pos = TRUE;\n \t    }\n \n \t    new_tag = TRUE;\n \t}\n \telse\n \t{\n \t    if (\n #if defined(FEAT_QUICKFIX)\n \t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n #endif\n \t\t    tagstacklen == 0)\n \t    {\n \t\temsg(_(e_tag_stack_empty));\n \t\tgoto end_do_tag;\n \t    }\n \n \t    if (type == DT_POP)\n \t    {\n #ifdef FEAT_FOLDING\n \t\tint\told_KeyTyped = KeyTyped;\n #endif\n \t\tif ((tagstackidx -= count) < 0)\n \t\t{\n \t\t    emsg(_(e_at_bottom_of_tag_stack));\n \t\t    if (tagstackidx + count == 0)\n \t\t    {\n \t\t\ttagstackidx = 0;\n \t\t\tgoto end_do_tag;\n \t\t    }\n \t\t    tagstackidx = 0;\n \t\t}\n \t\telse if (tagstackidx >= tagstacklen)\n \t\t{\n \t\t    emsg(_(e_at_top_of_tag_stack));\n \t\t    goto end_do_tag;\n \t\t}\n \n \t\tsaved_fmark = tagstack[tagstackidx].fmark;\n \t\tif (saved_fmark.fnum != curbuf->b_fnum)\n \t\t{\n \t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n \t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n \t\t    {\n \t\t\ttagstackidx = oldtagstackidx;\n \t\t\tgoto end_do_tag;\n \t\t    }\n \t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n \t\t}\n \t\telse\n \t\t{\n \t\t    setpcmark();\n \t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n \t\t}\n \t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n \t\tcurwin->w_set_curswant = TRUE;\n \t\tcheck_cursor();\n #ifdef FEAT_FOLDING\n \t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n \t\t    foldOpenCursor();\n #endif\n \n \t\tFreeWild(num_matches, matches);\n #ifdef FEAT_CSCOPE\n \t\tcs_free_tags();\n #endif\n \t\tnum_matches = 0;\n \t\ttag_freematch();\n \t\tgoto end_do_tag;\n \t    }\n \n \t    if (type == DT_TAG\n #if defined(FEAT_QUICKFIX)\n \t\t    || type == DT_LTAG\n #endif\n \t       )\n \t    {\n #if defined(FEAT_QUICKFIX)\n \t\tif (g_do_tagpreview != 0)\n \t\t{\n \t\t    cur_match = ptag_entry.cur_match;\n \t\t    cur_fnum = ptag_entry.cur_fnum;\n \t\t}\n \t\telse\n #endif\n \t\t{\n \t\t    save_pos = TRUE;\n \t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n \t\t    {\n \t\t\ttagstackidx = tagstacklen - 1;\n \t\t\temsg(_(e_at_top_of_tag_stack));\n \t\t\tsave_pos = FALSE;\n \t\t    }\n \t\t    else if (tagstackidx < 0)\n \t\t    {\n \t\t\temsg(_(e_at_bottom_of_tag_stack));\n \t\t\ttagstackidx = 0;\n \t\t\tgoto end_do_tag;\n \t\t    }\n \t\t    cur_match = tagstack[tagstackidx].cur_match;\n \t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n \t\t}\n \t\tnew_tag = TRUE;\n \t    }\n \t    else\n \t    {\n \t\tprevtagstackidx = tagstackidx;\n \n #if defined(FEAT_QUICKFIX)\n \t\tif (g_do_tagpreview != 0)\n \t\t{\n \t\t    cur_match = ptag_entry.cur_match;\n \t\t    cur_fnum = ptag_entry.cur_fnum;\n \t\t}\n \t\telse\n #endif\n \t\t{\n \t\t    if (--tagstackidx < 0)\n \t\t\ttagstackidx = 0;\n \t\t    cur_match = tagstack[tagstackidx].cur_match;\n \t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n \t\t}\n \t\tswitch (type)\n \t\t{\n \t\t    case DT_FIRST: cur_match = count - 1; break;\n \t\t    case DT_SELECT:\n \t\t    case DT_JUMP:\n #ifdef FEAT_CSCOPE\n \t\t    case DT_CSCOPE:\n #endif\n \t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n \t\t    case DT_NEXT:  cur_match += count; break;\n \t\t    case DT_PREV:  cur_match -= count; break;\n \t\t}\n \t\tif (cur_match >= MAXCOL)\n \t\t    cur_match = MAXCOL - 1;\n \t\telse if (cur_match < 0)\n \t\t{\n \t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n \t\t    skip_msg = TRUE;\n \t\t    cur_match = 0;\n \t\t    cur_fnum = curbuf->b_fnum;\n \t\t}\n \t    }\n \t}\n \n #if defined(FEAT_QUICKFIX)\n \tif (g_do_tagpreview != 0)\n \t{\n \t    if (type != DT_SELECT && type != DT_JUMP)\n \t    {\n \t\tptag_entry.cur_match = cur_match;\n \t\tptag_entry.cur_fnum = cur_fnum;\n \t    }\n \t}\n \telse\n #endif\n \t{\n \t    saved_fmark = tagstack[tagstackidx].fmark;\n \t    if (save_pos)\n \t    {\n \t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n \t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n \t    }\n \n \t    curwin->w_tagstackidx = tagstackidx;\n \t    if (type != DT_SELECT && type != DT_JUMP)\n \t    {\n \t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n \t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n \t    }\n \t}\n     }\n \n     if (cur_fnum != curbuf->b_fnum)\n     {\n \tbuf_T *buf = buflist_findnr(cur_fnum);\n \n \tif (buf != NULL)\n \t    buf_ffname = buf->b_ffname;\n     }\n \n     for (;;)\n     {\n \tint\tother_name;\n \tchar_u\t*name;\n \n \tif (use_tagstack)\n \t{\n \t    name = vim_strsave(tagstack[tagstackidx].tagname);\n \t    vim_free(tofree);\n \t    tofree = name;\n \t}\n #if defined(FEAT_QUICKFIX)\n \telse if (g_do_tagpreview != 0)\n \t    name = ptag_entry.tagname;\n #endif\n \telse\n \t    name = tag;\n \tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n \tif (new_tag\n \t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n \t\t|| other_name)\n \t{\n \t    if (other_name)\n \t    {\n \t\tvim_free(tagmatchname);\n \t\ttagmatchname = vim_strsave(name);\n \t    }\n \n \t    if (type == DT_SELECT || type == DT_JUMP\n #if defined(FEAT_QUICKFIX)\n \t\t|| type == DT_LTAG\n #endif\n \t\t)\n \t\tcur_match = MAXCOL - 1;\n \t    if (type == DT_TAG)\n \t\tmax_num_matches = MAXCOL;\n \t    else\n \t\tmax_num_matches = cur_match + 1;\n \n \t    if (!no_regexp && *name == '/')\n \t    {\n \t\tflags = TAG_REGEXP;\n \t\t++name;\n \t    }\n \t    else\n \t\tflags = TAG_NOIC;\n \n #ifdef FEAT_CSCOPE\n \t    if (type == DT_CSCOPE)\n \t\tflags = TAG_CSCOPE;\n #endif\n \t    if (verbose)\n \t\tflags |= TAG_VERBOSE;\n \n \t    if (!use_tfu)\n \t\tflags |= TAG_NO_TAGFUNC;\n \n \t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n \t\t\t\t\t    max_num_matches, buf_ffname) == OK\n \t\t    && new_num_matches < max_num_matches)\n \t\tmax_num_matches = MAXCOL;\n \n// bug_start\n// bug_end\n \t    if (!new_tag && !other_name)\n \t    {\n \t\tint\t    j, k;\n \t\tint\t    idx = 0;\n \t\ttagptrs_T   tagp, tagp2;\n \n \t\tfor (j = 0; j < num_matches; ++j)\n \t\t{\n \t\t    parse_match(matches[j], &tagp);\n \t\t    for (i = idx; i < new_num_matches; ++i)\n \t\t    {\n \t\t\tparse_match(new_matches[i], &tagp2);\n \t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n \t\t\t{\n \t\t\t    char_u *p = new_matches[i];\n \t\t\t    for (k = i; k > idx; --k)\n \t\t\t\tnew_matches[k] = new_matches[k - 1];\n \t\t\t    new_matches[idx++] = p;\n \t\t\t    break;\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \t    FreeWild(num_matches, matches);\n \t    num_matches = new_num_matches;\n \t    matches = new_matches;\n \t}\n \n \tif (num_matches <= 0)\n \t{\n \t    if (verbose)\n \t\tsemsg(_(e_tag_not_found_str), name);\n #if defined(FEAT_QUICKFIX)\n \t    g_do_tagpreview = 0;\n #endif\n \t}\n \telse\n \t{\n \t    int ask_for_selection = FALSE;\n \n #ifdef FEAT_CSCOPE\n \t    if (type == DT_CSCOPE && num_matches > 1)\n \t    {\n \t\tcs_print_tags();\n \t\task_for_selection = TRUE;\n \t    }\n \t    else\n #endif\n \t    if (type == DT_TAG && *tag != NUL)\n \t\tcur_match = count > 0 ? count - 1 : 0;\n \t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n \t    {\n \t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n \t\task_for_selection = TRUE;\n \t    }\n #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n \t    else if (type == DT_LTAG)\n \t    {\n \t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n \t\t    goto end_do_tag;\n \t\tcur_match = 0;\n \t    }\n #endif\n \n \t    if (ask_for_selection == TRUE)\n \t    {\n \t\ti = prompt_for_number(NULL);\n \t\tif (i <= 0 || i > num_matches || got_int)\n \t\t{\n \t\t    if (use_tagstack)\n \t\t    {\n \t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n \t\t\ttagstackidx = prevtagstackidx;\n \t\t    }\n #ifdef FEAT_CSCOPE\n \t\t    cs_free_tags();\n \t\t    jumped_to_tag = TRUE;\n #endif\n \t\t    break;\n \t\t}\n \t\tcur_match = i - 1;\n \t    }\n \n \t    if (cur_match >= num_matches)\n \t    {\n \t\tif ((type == DT_NEXT || type == DT_FIRST)\n \t\t\t\t\t\t      && nofile_fname == NULL)\n \t\t{\n \t\t    if (num_matches == 1)\n \t\t\temsg(_(e_there_is_only_one_matching_tag));\n \t\t    else\n \t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n \t\t    skip_msg = TRUE;\n \t\t}\n \t\tcur_match = num_matches - 1;\n \t    }\n \t    if (use_tagstack)\n \t    {\n \t\ttagptrs_T   tagp;\n \n \t\ttagstack[tagstackidx].cur_match = cur_match;\n \t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n \n \t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n \t\t\t&& tagp.user_data)\n \t\t{\n \t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n \t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n \t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n \t\t}\n \n \t\t++tagstackidx;\n \t    }\n #if defined(FEAT_QUICKFIX)\n \t    else if (g_do_tagpreview != 0)\n \t    {\n \t\tptag_entry.cur_match = cur_match;\n \t\tptag_entry.cur_fnum = cur_fnum;\n \t    }\n #endif\n \n \t    if (nofile_fname != NULL && error_cur_match != cur_match)\n \t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n \n \n \t    ic = (matches[cur_match][0] & MT_IC_OFF);\n \t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n #ifdef FEAT_CSCOPE\n \t\t&& type != DT_CSCOPE\n #endif\n \t\t&& (num_matches > 1 || ic)\n \t\t&& !skip_msg)\n \t    {\n \t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n \t\t\t\tcur_match + 1,\n \t\t\t\tnum_matches,\n \t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n \t\tif (ic)\n \t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n \t\tif ((num_matches > prev_num_matches || new_tag)\n \t\t\t\t\t\t\t   && num_matches > 1)\n \t\t{\n \t\t    if (ic)\n \t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n \t\t    else\n \t\t\tmsg((char *)IObuff);\n \t\t    msg_scroll = TRUE;\n \t\t}\n \t\telse\n \t\t    give_warning(IObuff, ic);\n \t\tif (ic && !msg_scrolled && msg_silent == 0)\n \t\t{\n \t\t    out_flush();\n \t\t    ui_delay(1007L, TRUE);\n \t\t}\n \t    }\n \n #if defined(FEAT_EVAL)\n \t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n \t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n #endif\n \n \t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n \n #if defined(FEAT_EVAL)\n \t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n #endif\n \n \t    if (i == NOTAGFILE)\n \t    {\n \t\tif ((type == DT_PREV && cur_match > 0)\n \t\t\t|| ((type == DT_TAG || type == DT_NEXT\n \t\t\t\t\t\t\t  || type == DT_FIRST)\n \t\t\t    && (max_num_matches != MAXCOL\n \t\t\t\t\t     || cur_match < num_matches - 1)))\n \t\t{\n \t\t    error_cur_match = cur_match;\n \t\t    if (use_tagstack)\n \t\t\t--tagstackidx;\n \t\t    if (type == DT_PREV)\n \t\t\t--cur_match;\n \t\t    else\n \t\t    {\n \t\t\ttype = DT_NEXT;\n \t\t\t++cur_match;\n \t\t    }\n \t\t    continue;\n \t\t}\n \t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n \t    }\n \t    else\n \t    {\n \t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n \t\t    tagstackidx = curwin->w_tagstackidx;\n #ifdef FEAT_CSCOPE\n \t\tjumped_to_tag = TRUE;\n #endif\n \t    }\n \t}\n \tbreak;\n     }\n \n end_do_tag:\n     if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n \tcurwin->w_tagstackidx = tagstackidx;\n     postponed_split = 0;\n # ifdef FEAT_QUICKFIX\n     g_do_tagpreview = 0;\n # endif\n \n     vim_free(tofree);\n #ifdef FEAT_CSCOPE\n     return jumped_to_tag;\n #else\n     return FALSE;\n #endif\n }\n \n", "target": "// fix_start\n\t    if (tagstack != curwin->w_tagstack)\n\t    {\n\t\temsg(_(e_window_unexpectedly_close_while_searching_for_tags));\n\t\tFreeWild(new_num_matches, new_matches);\n\t\tbreak;\n\t    }\n\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-3134", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0389.", "project": "vim", "idx": 212433}
{"source": " static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n {\n// bug_start\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n// bug_end\n \tint err;\n \n \tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n \t\t\t\t\t smap->map.numa_node);\n \tif (!smap->elems)\n \t\treturn -ENOMEM;\n \n \terr = pcpu_freelist_init(&smap->freelist);\n \tif (err)\n \t\tgoto free_elems;\n \n \tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n \t\t\t       smap->map.max_entries);\n \treturn 0;\n \n free_elems:\n \tbpf_map_area_free(smap->elems);\n \treturn err;\n }\n \n", "target": "// fix_start\n\tu64 elem_size = sizeof(struct stack_map_bucket) +\n\t\t\t(u64)smap->map.value_size;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-41864", "cve_desc": "prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.", "project": "linux", "idx": 212436}
{"source": " static pj_status_t decode_errcode_attr(pj_pool_t *pool,\n \t\t\t\t       const pj_uint8_t *buf,\n \t\t\t\t       const pj_stun_msg_hdr *msghdr,\n \t\t\t\t       void **p_attr)\n {\n     pj_stun_errcode_attr *attr;\n     pj_str_t value;\n \n     PJ_UNUSED_ARG(msghdr);\n \n     attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n     GETATTRHDR(buf, &attr->hdr);\n \n     attr->err_code = buf[6] * 100 + buf[7];\n \n     value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n     value.slen = attr->hdr.length - 4;\n// bug_start\n// bug_end\n \n     pj_strdup(pool, &attr->reason, &value);\n \n     *p_attr = attr;\n \n     return PJ_SUCCESS;\n }\n \n", "target": "// fix_start\n    if (value.slen < 0)\n    \tvalue.slen = 0;\n// fix_end\n", "cwe": "CWE-191", "cwe_name": "Integer Underflow (Wrap or Wraparound)", "cve": "CVE-2021-37706", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming STUN message contains an ERROR-CODE attribute, the header length is not checked before performing a subtraction operation, potentially resulting in an integer underflow scenario. This issue affects all users that use STUN. A malicious actor located within the victim\u2019s network may forge and send a specially crafted UDP (STUN) message that could remotely execute arbitrary code on the victim\u2019s machine. Users are advised to upgrade as soon as possible. There are no known workarounds.", "project": "pjproject", "idx": 212818}
{"source": " pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)\n {\n     uint count = min(max_data,\n                      pcs->status.write_pos - pcs->status.read_pos);\n \n     if (count)\n         memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);\n     pcs->status.read_pos += count;\n     if (pcs->status.read_pos == pcs->status.write_pos) {\n         gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\");\n// bug_start\n// bug_end\n         pcs->status.write_pos = pcs->status.read_pos = 0;\n     }\n     return count;\n }\n \n", "target": "// fix_start\n        pcs->status.buffer = NULL;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-1350", "cve_desc": "A vulnerability classified as problematic was found in GhostPCL 9.55.0. This vulnerability affects the function chunk_free_object of the file gsmchunk.c. The manipulation with a malicious file leads to a memory corruption. The attack can be initiated remotely but requires user interaction. The exploit has been disclosed to the public as a POC and may be used. It is recommended to apply the patches to fix this issue.", "project": "ghostpdl", "idx": 212822}
{"source": "  */\n static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n {\n \tst_entry \t\t\t*ent1, *ent2;\n \twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n \tHashTable \t\t\t*target_hash;\n \tzend_class_entry \t**pce;\n \tzval\t\t\t\t*obj;\n \tzval\t\t\t\t*tmp;\n \tTSRMLS_FETCH();\n \n \tif (stack->top == 0) {\n \t\treturn;\n \t}\n \n \tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n \t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n \t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n \t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n \t\t!strcmp(name, EL_DATETIME)) {\n \t\twddx_stack_top(stack, (void**)&ent1);\n \n \t\tif (!ent1->data) {\n \t\t\tif (stack->top > 1) {\n \t\t\t\tstack->top--;\n \t\t\t} else {\n \t\t\t\tstack->done = 1;\n \t\t\t}\n \t\t\tefree(ent1);\n \t\t\treturn;\n \t\t}\n \n \t\tif (!strcmp(name, EL_BINARY)) {\n \t\t\tint new_len=0;\n \t\t\tunsigned char *new_str;\n \n \t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n \t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n// bug_start\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n// bug_end\n \t\t}\n \n \t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n \t\t\tzval *fname, *retval = NULL;\n \n \t\t\tMAKE_STD_ZVAL(fname);\n \t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n \n \t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n \n \t\t\tzval_dtor(fname);\n \t\t\tFREE_ZVAL(fname);\n \t\t\tif (retval) {\n \t\t\t\tzval_ptr_dtor(&retval);\n \t\t\t}\n \t\t}\n \n \t\tif (stack->top > 1) {\n \t\t\tstack->top--;\n \t\t\twddx_stack_top(stack, (void**)&ent2);\n \n \t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n \t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\tefree(ent1);\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n \t\t\t\ttarget_hash = HASH_OF(ent2->data);\n \n \t\t\t\tif (ent1->varname) {\n \t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n \t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n \t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n \t\t\t\t\t\tzend_bool incomplete_class = 0;\n \n \t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n \t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n \t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n \t\t\t\t\t\t\tincomplete_class = 1;\n \t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n \t\t\t\t\t\tobject_init_ex(obj, *pce);\n \n \t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n \t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n \t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n \t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n \n \t\t\t\t\t\tif (incomplete_class) {\n \t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n \n \t\t\t\t\t\tent2->data = obj;\n \n \t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n \t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n \n \t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n \t\t\t\t\t\tZ_DELREF_P(ent1->data);\n \t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n \t\t\t\t\t\tEG(scope) = old_scope;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n \t\t\t\t\t}\n \t\t\t\t\tefree(ent1->varname);\n \t\t\t\t} else\t{\n \t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n \t\t\t\t}\n \t\t\t}\n \t\t\tefree(ent1);\n \t\t} else {\n \t\t\tstack->done = 1;\n \t\t}\n \t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n \t\tefree(stack->varname);\n \t\tstack->varname = NULL;\n \t} else if (!strcmp(name, EL_FIELD)) {\n \t\tst_entry *ent;\n \t\twddx_stack_top(stack, (void **)&ent);\n \t\tefree(ent);\n \t\tstack->top--;\n \t}\n \n", "target": "// fix_start\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2016-7130", "cve_desc": "The php_wddx_pop_element function in ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid base64 binary value, as demonstrated by a wddx_deserialize call that mishandles a binary element in a wddxPacket XML document.", "project": "php-src", "idx": 212829}
{"source": " processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n \tchar **buff,\n \tconst int buffLen,\n \tstruct syslogTime *stTime,\n \tconst time_t ttGenTime,\n \tmulti_submit_t *pMultiSub,\n \tunsigned *const __restrict__ pnMsgs)\n {\n \tDEFiRet;\n \tchar c = **buff;\n \tint octatesToCopy, octatesToDiscard;\n \n \tif(pThis->inputState == eAtStrtFram) {\n \t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n \t\t\tpThis->inputState = eInOctetCnt;\n \t\t\tpThis->iOctetsRemain = 0;\n \t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n \t\t} else if(pThis->bSPFramingFix && c == ' ') {\n \t\t\t FINALIZE;\n \t\t} else {\n \t\t\tpThis->inputState = eInMsg;\n \t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n \t\t}\n \t}\n \n \tif(pThis->inputState == eInOctetCnt) {\n \t\tif(isdigit(c)) {\n// bug_start\n\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n// bug_end\n \t\t} else {\n \t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n \t\t\tif(c != ' ') {\n \t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n \t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n \t\t\t}\n \t\t\tif(pThis->iOctetsRemain < 1) {\n// bug_start\n\t\t\t\tDBGPRINTF(\"Framing Error: invalid octet count\\n\");\n// bug_end\n \t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n \t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n// bug_start\n// bug_end\n \t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n \t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n \t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n \t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n \t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n \t\t\t}\n \t\t\tpThis->inputState = eInMsg;\n// bug_start\n// bug_end\n \t\t}\n \t} else {\n \t\tassert(pThis->inputState == eInMsg);\n \n \t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n \t\t\tif(pThis->iMsg >= iMaxLine) {\n \t\t\t\tint i = 1;\n \t\t\t\tchar currBuffChar;\n \t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n \t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n \t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n \t\t\t\t\ti++;\n \t\t\t\t}\n \t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n \t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n \t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n \t\t\t\t++(*pnMsgs);\n \t\t\t}\n \n \t\t\tif ((c == '\\n')\n \t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n \t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n \t\t\t\t   ) {\n \t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n \t\t\t\t++(*pnMsgs);\n \t\t\t\tpThis->inputState = eAtStrtFram;\n \t\t\t} else {\n \t\t\t\tif(pThis->iMsg < iMaxLine) {\n \t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n \t\t\toctatesToCopy = pThis->iOctetsRemain;\n \t\t\toctatesToDiscard = 0;\n \t\t\tif (buffLen < octatesToCopy) {\n \t\t\t\toctatesToCopy = buffLen;\n \t\t\t}\n \t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n \t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n \t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n \t\t\t}\n \n \t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n \t\t\tpThis->iMsg += octatesToCopy;\n \t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n \t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n \t\t\tif (pThis->iOctetsRemain == 0) {\n \t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n \t\t\t\t++(*pnMsgs);\n \t\t\t\tpThis->inputState = eAtStrtFram;\n \t\t\t}\n \t\t}\n \n \t}\n \n finalize_it:\n \tRETiRet;\n }\n \n", "target": "// fix_start\n\t\t\tif(pThis->iOctetsRemain <= 200000000) {\n\t\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t\t} else {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t\t\"frame too large (at least %d%c), change to octet stuffing\",\n\t\t\t\t\t\tpThis->iOctetsRemain, c);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t\tpThis->inputState = eInMsg;\n\t\t\t}\n\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n// fix_end\n// fix_start\n\t\t\tpThis->iMsg = 0;\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2018-16881", "cve_desc": "A denial of service vulnerability was found in rsyslog in the imptcp module. An attacker could send a specially crafted message to the imptcp socket, which would cause rsyslog to crash. Versions before 8.27.0 are vulnerable.", "project": "rsyslog", "idx": 212834}
{"source": " qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n {\n     linenr_T\tlnum;\n     qfline_T\t*qfp;\n     int\t\told_KeyTyped = KeyTyped;\n     list_T\t*qftf_list = NULL;\n     listitem_T\t*qftf_li = NULL;\n \n     if (old_last == NULL)\n     {\n \tif (buf != curbuf)\n \t{\n \t    internal_error(\"qf_fill_buffer()\");\n \t    return;\n \t}\n \n \twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n \t    (void)ml_delete((linenr_T)1);\n     }\n \n// bug_start\n    if (qfl != NULL)\n// bug_end\n     {\n \tchar_u\t\tdirname[MAXPATHL];\n \tint\t\tinvalid_val = FALSE;\n \tint\t\tprev_bufnr = -1;\n \n \t*dirname = NUL;\n \n \tif (old_last == NULL)\n \t{\n \t    qfp = qfl->qf_start;\n \t    lnum = 0;\n \t}\n \telse\n \t{\n \t    if (old_last->qf_next != NULL)\n \t\tqfp = old_last->qf_next;\n \t    else\n \t\tqfp = old_last;\n \t    lnum = buf->b_ml.ml_line_count;\n \t}\n \n \tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n \t\t\t\t\t\t\t(long)qfl->qf_count);\n \tif (qftf_list != NULL)\n \t    qftf_li = qftf_list->lv_first;\n \n \twhile (lnum < qfl->qf_count)\n \t{\n \t    char_u\t*qftf_str = NULL;\n \n \t    if (qftf_li != NULL && !invalid_val)\n \t    {\n \t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n \t\tif (qftf_str == NULL)\n \t\t    invalid_val = TRUE;\n \t    }\n \n \t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n \t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n \t\tbreak;\n \n \t    prev_bufnr = qfp->qf_fnum;\n \t    ++lnum;\n \t    qfp = qfp->qf_next;\n \t    if (qfp == NULL)\n \t\tbreak;\n \n \t    if (qftf_li != NULL)\n \t\tqftf_li = qftf_li->li_next;\n \t}\n \n \tif (old_last == NULL)\n \t    (void)ml_delete(lnum + 1);\n     }\n \n     check_lnums(TRUE);\n \n     if (old_last == NULL)\n     {\n \t++curbuf_lock;\n \tset_option_value_give_err((char_u *)\"ft\",\n \t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n \tcurbuf->b_p_ma = FALSE;\n \n \tkeep_filetype = TRUE;\n \tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n \t\t\t\t\t\t\t       FALSE, curbuf);\n \tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n \t\t\t\t\t\t\t       FALSE, curbuf);\n \tkeep_filetype = FALSE;\n \t--curbuf_lock;\n \n \tredraw_curbuf_later(UPD_NOT_VALID);\n     }\n \n     KeyTyped = old_KeyTyped;\n }\n \n", "target": "// fix_start\n    if (qfl != NULL && qfl->qf_start != NULL)\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-3037", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0322.", "project": "vim", "idx": 212857}
{"source": " std::string controller::bookmark(\n \t\tconst std::string& url,\n \t\tconst std::string& title,\n \t\tconst std::string& description,\n \t\tconst std::string& feed_title)\n {\n \tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n \tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n \tif (bookmark_cmd.length() > 0) {\n// bug_start\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n// bug_end\n \t\t                                       bookmark_cmd,\n \t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n// bug_start\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n// bug_end\n \n \t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n \n \t\tif (is_interactive) {\n \t\t\tv->push_empty_formaction();\n \t\t\tstfl::reset();\n \t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n \t\t\tv->pop_current_formaction();\n \t\t\treturn \"\";\n \t\t} else {\n \t\t\tchar * my_argv[4];\n \t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n \t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n \t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n \t\t\tmy_argv[3] = nullptr;\n \t\t\treturn utils::run_program(my_argv, \"\");\n \t\t}\n \t} else {\n \t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n \t}\n }\n \n", "target": "// fix_start\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' '%s' '%s' '%s'\",\n// fix_end\n// fix_start\n\t\t                                       utils::replace_all(title,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(description,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(feed_title,\"'\", \"%27\"));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2017-12904", "cve_desc": "Improper Neutralization of Special Elements used in an OS Command in bookmarking function of Newsbeuter versions 0.7 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item that includes shell code in its title and/or URL.", "project": "newsbeuter", "idx": 212871}
{"source": " static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                                int size)\n {\n     NetClientState *nc = qemu_get_queue(s->nic);\n \n     if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n// bug_start\n        nc->info->receive(nc, buf, size);\n// bug_end\n     } else {\n         qemu_send_packet(nc, buf, size);\n     }\n }\n \n", "target": "// fix_start\n        qemu_receive_packet(nc, buf, size);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "project": "qemu", "idx": 212927}
{"source": " static int write_entry(struct mailbox *mailbox,\n                        unsigned int uid,\n                        const char *entry,\n                        const char *userid,\n                        const struct buf *value,\n                        int ignorequota,\n                        int silent,\n                        const struct annotate_metadata *mdata,\n                        int maywrite)\n \n {\n     char key[MAX_MAILBOX_PATH+1];\n     int keylen, r;\n     annotate_db_t *d = NULL;\n     struct buf oldval = BUF_INITIALIZER;\n     const char *mboxname = mailbox ? mailbox->name : \"\";\n     modseq_t modseq = mdata ? mdata->modseq : 0;\n \n     r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n     if (r)\n         return r;\n \n     annotate_begin(d);\n \n     keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n \n// bug_start\n// bug_end\n     if (mailbox) {\n// bug_start\n        struct annotate_metadata oldmdata;\n        r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n        if (r) goto out;\n\n        if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n            goto out;\n\n// bug_end\n         if (!ignorequota) {\n             quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n             qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n             r = mailbox_quota_check(mailbox, qdiffs);\n// bug_start\n            if (r) goto out;\n        }\n\n        if (!maywrite) {\n            r = IMAP_PERMISSION_DENIED;\n// bug_end\n             if (r) goto out;\n         }\n \n         mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n \n         if (uid && !mdata) {\n             modseq = mailbox->i.highestmodseq;\n         }\n     }\n \n     if (!value->len && !uid) {\n \n #if DEBUG\n         syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                 key_as_string(d, key, keylen), d->filename);\n #endif\n \n         do {\n             r = cyrusdb_delete(d->db, key, keylen, tid(d), 1);\n         } while (r == CYRUSDB_AGAIN);\n     }\n     else {\n         struct buf data = BUF_INITIALIZER;\n         unsigned char flags = 0;\n         if (!value->len || value->s == NULL) {\n             flags |= ANNOTATE_FLAG_DELETED;\n         }\n         else {\n             if (!userid) goto out;\n         }\n         make_entry(&data, value, modseq, flags);\n \n #if DEBUG\n         syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                 key_as_string(d, key, keylen), value->s, d->filename, modseq);\n #endif\n \n         do {\n             r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n         } while (r == CYRUSDB_AGAIN);\n         buf_free(&data);\n     }\n \n     if (!mailbox)\n         sync_log_annotation(\"\");\n \n out:\n     annotate_putdb(&d);\n     buf_free(&oldval);\n \n     return r;\n }\n \n", "target": "// fix_start\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-732", "cwe_name": "Incorrect Permission Assignment for Critical Resource", "cve": "CVE-2021-32056", "cve_desc": "Cyrus IMAP before 3.2.7, and 3.3.x and 3.4.x before 3.4.1, allows remote authenticated users to bypass intended access restrictions on server annotations and consequently cause replication to stall.", "project": "cyrus-imapd", "idx": 212934}
{"source": " static int ax25_release(struct socket *sock)\n {\n \tstruct sock *sk = sock->sk;\n \tax25_cb *ax25;\n \tax25_dev *ax25_dev;\n \n \tif (sk == NULL)\n \t\treturn 0;\n \n \tsock_hold(sk);\n \tlock_sock(sk);\n \tsock_orphan(sk);\n \tax25 = sk_to_ax25(sk);\n \tax25_dev = ax25->ax25_dev;\n \n \tif (sk->sk_type == SOCK_SEQPACKET) {\n \t\tswitch (ax25->state) {\n \t\tcase AX25_STATE_0:\n \t\t\trelease_sock(sk);\n \t\t\tax25_disconnect(ax25, 0);\n \t\t\tlock_sock(sk);\n \t\t\tax25_destroy_socket(ax25);\n \t\t\tbreak;\n \n \t\tcase AX25_STATE_1:\n \t\tcase AX25_STATE_2:\n \t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n \t\t\trelease_sock(sk);\n \t\t\tax25_disconnect(ax25, 0);\n \t\t\tlock_sock(sk);\n \t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n \t\t\t\tax25_destroy_socket(ax25);\n \t\t\tbreak;\n \n \t\tcase AX25_STATE_3:\n \t\tcase AX25_STATE_4:\n \t\t\tax25_clear_queues(ax25);\n \t\t\tax25->n2count = 0;\n \n \t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n \t\t\tcase AX25_PROTO_STD_SIMPLEX:\n \t\t\tcase AX25_PROTO_STD_DUPLEX:\n \t\t\t\tax25_send_control(ax25,\n \t\t\t\t\t\t  AX25_DISC,\n \t\t\t\t\t\t  AX25_POLLON,\n \t\t\t\t\t\t  AX25_COMMAND);\n \t\t\t\tax25_stop_t2timer(ax25);\n \t\t\t\tax25_stop_t3timer(ax25);\n \t\t\t\tax25_stop_idletimer(ax25);\n \t\t\t\tbreak;\n #ifdef CONFIG_AX25_DAMA_SLAVE\n \t\t\tcase AX25_PROTO_DAMA_SLAVE:\n \t\t\t\tax25_stop_t3timer(ax25);\n \t\t\t\tax25_stop_idletimer(ax25);\n \t\t\t\tbreak;\n #endif\n \t\t\t}\n \t\t\tax25_calculate_t1(ax25);\n \t\t\tax25_start_t1timer(ax25);\n \t\t\tax25->state = AX25_STATE_2;\n \t\t\tsk->sk_state                = TCP_CLOSE;\n \t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n \t\t\tsk->sk_state_change(sk);\n \t\t\tsock_set_flag(sk, SOCK_DESTROY);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tbreak;\n \t\t}\n \t} else {\n \t\tsk->sk_state     = TCP_CLOSE;\n \t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n \t\tsk->sk_state_change(sk);\n \t\tax25_destroy_socket(ax25);\n \t}\n \tif (ax25_dev) {\n// bug_start\n// bug_end\n \t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n \t\tax25_dev_put(ax25_dev);\n \t}\n \n \tsock->sk   = NULL;\n \trelease_sock(sk);\n \tsock_put(sk);\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-1205", "cve_desc": "A NULL pointer dereference flaw was found in the Linux kernel\u2019s Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.", "project": "linux", "idx": 212955}
{"source": " mbfl_filt_conv_big5_wchar(int c, mbfl_convert_filter *filter)\n {\n \tint k;\n \tint c1, w, c2;\n \n \tswitch (filter->status) {\n \tcase 0:\n \t\tif (filter->from->no_encoding == mbfl_no_encoding_cp950) {\n \t\t\tc1 = 0x80;\n \t\t} else {\n \t\t\tc1 = 0xa0;\n \t\t}\n \n \t\tif (c >= 0 && c <= 0x80) {\n \t\t\tCK((*filter->output_function)(c, filter->data));\n \t\t} else if (c == 0xff) {\n \t\t\tCK((*filter->output_function)(0xf8f8, filter->data));\n \t\t} else if (c > c1 && c < 0xff) {\n \t\t\tfilter->status = 1;\n \t\t\tfilter->cache = c;\n \t\t} else {\n \t\t\tw = c & MBFL_WCSGROUP_MASK;\n \t\t\tw |= MBFL_WCSGROUP_THROUGH;\n \t\t\tCK((*filter->output_function)(w, filter->data));\n \t\t}\n \t\tbreak;\n \n \tcase 1:\n \t\tfilter->status = 0;\n \t\tc1 = filter->cache;\n \t\tif ((c > 0x39 && c < 0x7f) | (c > 0xa0 && c < 0xff)) {\n \t\t\tif (c < 0x7f){\n \t\t\t\tw = (c1 - 0xa1)*157 + (c - 0x40);\n \t\t\t} else {\n \t\t\t\tw = (c1 - 0xa1)*157 + (c - 0xa1) + 0x3f;\n \t\t\t}\n \t\t\tif (w >= 0 && w < big5_ucs_table_size) {\n \t\t\t\tw = big5_ucs_table[w];\n \t\t\t} else {\n \t\t\t\tw = 0;\n \t\t\t}\n \n \t\t\tif (filter->from->no_encoding == mbfl_no_encoding_cp950) {\n// bug_start\n\t\t\t\tif (w <= 0 &&\n\t\t\t\t\t(((c1 >= 0xfa && c1 <= 0xfe) || (c1 >= 0x8e && c1 <= 0xa0) ||\n\t\t\t\t\t  (c1 >= 0x81 && c1 <= 0x8d) ||(c1 >= 0xc7 && c1 <= 0xc8))\n\t\t\t\t\t && ((c > 0x39 && c < 0x7f) || (c > 0xa0 && c < 0xff))) ||\n\t\t\t\t\t((c1 == 0xc6) && (c > 0xa0 && c < 0xff))) {\n// bug_end\n \t\t\t\t\tc2 = c1 << 8 | c;\n \t\t\t\t\tfor (k = 0; k < sizeof(cp950_pua_tbl)/(sizeof(unsigned short)*4); k++) {\n \t\t\t\t\t\tif (c2 >= cp950_pua_tbl[k][2] && c2 <= cp950_pua_tbl[k][3]) {\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tif ((cp950_pua_tbl[k][2] & 0xff) == 0x40) {\n \t\t\t\t\t\tw = 157*(c1 - (cp950_pua_tbl[k][2]>>8)) + c - (c >= 0xa1 ? 0x62 : 0x40)\n \t\t\t\t\t\t\t+ cp950_pua_tbl[k][0];\n \t\t\t\t\t} else {\n \t\t\t\t\t\tw = c2 - cp950_pua_tbl[k][2] + cp950_pua_tbl[k][0];\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (w <= 0) {\n \t\t\t\tw = (c1 << 8) | c;\n \t\t\t\tw &= MBFL_WCSPLANE_MASK;\n \t\t\t\tw |= MBFL_WCSPLANE_BIG5;\n \t\t\t}\n \t\t\tCK((*filter->output_function)(w, filter->data));\n \t\t} else if ((c >= 0 && c < 0x21) || c == 0x7f) {\n \t\t\tCK((*filter->output_function)(c, filter->data));\n \t\t} else {\n \t\t\tw = (c1 << 8) | c;\n \t\t\tw &= MBFL_WCSGROUP_MASK;\n \t\t\tw |= MBFL_WCSGROUP_THROUGH;\n \t\t\tCK((*filter->output_function)(w, filter->data));\n \t\t}\n \t\tbreak;\n \n \tdefault:\n \t\tfilter->status = 0;\n \t\tbreak;\n \t}\n \n \treturn c;\n }\n \n", "target": "// fix_start\n\t\t\t\tif (w <= 0 && is_in_cp950_pua(c1, c)) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-7060", "cve_desc": "When using certain mbstring functions to convert multibyte encodings, in PHP versions 7.2.x below 7.2.27, 7.3.x below 7.3.14 and 7.4.x below 7.4.2 it is possible to supply data that will cause function mbfl_filt_conv_big5_wchar to read past the allocated buffer. This may lead to information disclosure or crash.", "project": "php-src", "idx": 213037}
{"source": " void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n {\n \tstruct nci_dev *ndev = priv->ndev;\n \n// bug_start\n// bug_end\n \tif (priv->ndev->nfc_dev->fw_download_in_progress)\n \t\tnfcmrvl_fw_dnld_abort(priv);\n \n \tnfcmrvl_fw_dnld_deinit(priv);\n \n \tif (gpio_is_valid(priv->config.reset_n_io))\n \t\tgpio_free(priv->config.reset_n_io);\n \n// bug_start\n\tnci_unregister_device(ndev);\n// bug_end\n \tnci_free_device(ndev);\n \tkfree(priv);\n }\n \n", "target": "// fix_start\n\tnci_unregister_device(ndev);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-1734", "cve_desc": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.", "project": "linux", "idx": 213075}
{"source": " g_socket_client_connected_callback (GObject      *source,\n \t\t\t\t    GAsyncResult *result,\n \t\t\t\t    gpointer      user_data)\n {\n   ConnectionAttempt *attempt = user_data;\n   GSocketClientAsyncConnectData *data = attempt->data;\n   GSList *l;\n   GError *error = NULL;\n   GProxy *proxy;\n   const gchar *protocol;\n \n// bug_start\n  if (data && g_task_return_error_if_cancelled (data->task))\n// bug_end\n     {\n       g_object_unref (data->task);\n       connection_attempt_unref (attempt);\n       return;\n     }\n \n   if (attempt->timeout_source)\n     {\n       g_source_destroy (attempt->timeout_source);\n       g_clear_pointer (&attempt->timeout_source, g_source_unref);\n     }\n \n   if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n \t\t\t\t\t   result, &error))\n     {\n       if (!g_cancellable_is_cancelled (attempt->cancellable))\n         {\n           clarify_connect_error (error, data->connectable, attempt->address);\n           set_last_error (data, error);\n// bug_start\n// bug_end\n         }\n       else\n// bug_start\n        g_clear_error (&error);\n\n      if (data)\n// bug_end\n         {\n// bug_start\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data);\n// bug_end\n         }\n// bug_start\n      else\n        connection_attempt_unref (attempt);\n// bug_end\n \n       return;\n     }\n \n   data->socket = g_steal_pointer (&attempt->socket);\n   data->connection = g_steal_pointer (&attempt->connection);\n \n   for (l = data->connection_attempts; l; l = g_slist_next (l))\n     {\n       ConnectionAttempt *attempt_entry = l->data;\n       g_cancellable_cancel (attempt_entry->cancellable);\n// bug_start\n      attempt_entry->data = NULL;\n// bug_end\n       connection_attempt_unref (attempt_entry);\n     }\n   g_slist_free (data->connection_attempts);\n   data->connection_attempts = NULL;\n   connection_attempt_unref (attempt);\n \n   g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n   g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n \n   g_socket_set_blocking (data->socket, TRUE);\n \n   if (!data->proxy_addr)\n     {\n       g_socket_client_tls_handshake (data);\n       return;\n     }\n \n   protocol = g_proxy_address_get_protocol (data->proxy_addr);\n \n   if (!G_IS_TCP_CONNECTION (data->connection))\n     {\n       g_critical (\"Trying to proxy over non-TCP connection, this is \"\n           \"most likely a bug in GLib IO library.\");\n \n       g_set_error_literal (&data->last_error,\n           G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n           _(\"Proxying over a non-TCP connection is not supported.\"));\n \n// bug_start\n      enumerator_next_async (data);\n// bug_end\n     }\n   else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n     {\n       g_socket_client_async_connect_complete (data);\n     }\n   else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n     {\n       g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n       g_proxy_connect_async (proxy,\n                              data->connection,\n                              data->proxy_addr,\n                              g_task_get_cancellable (data->task),\n                              g_socket_client_proxy_connect_callback,\n                              data);\n       g_object_unref (proxy);\n     }\n   else\n     {\n       g_clear_error (&data->last_error);\n \n       g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n           _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n           protocol);\n \n// bug_start\n      enumerator_next_async (data);\n// bug_end\n     }\n }\n \n", "target": "// fix_start\n  if (g_cancellable_is_cancelled (attempt->cancellable) || task_completed_or_cancelled (data->task))\n// fix_end\n// fix_start\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data, FALSE);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n          g_clear_error (&error);\n          g_object_unref (data->task);\n          connection_attempt_unref (attempt);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n      enumerator_next_async (data, FALSE);\n// fix_end\n// fix_start\n      enumerator_next_async (data, FALSE);\n// fix_end\n", "cwe": "CWE-754", "cwe_name": "Improper Check for Unusual or Exceptional Conditions", "cve": "CVE-2019-9633", "cve_desc": "gio/gsocketclient.c in GNOME GLib 2.59.2 does not ensure that a parent GTask remains alive during the execution of a connection-attempting enumeration, which allows remote attackers to cause a denial of service (g_socket_client_connected_callback mishandling and application crash) via a crafted web site, as demonstrated by GNOME Web (aka Epiphany).", "project": "glib", "idx": 213370}
{"source": " spell_suggest(int count)\n {\n     char_u\t*line;\n     pos_T\tprev_cursor = curwin->w_cursor;\n     char_u\twcopy[MAXWLEN + 2];\n     char_u\t*p;\n     int\t\ti;\n     int\t\tc;\n     suginfo_T\tsug;\n     suggest_T\t*stp;\n     int\t\tmouse_used;\n     int\t\tneed_cap;\n     int\t\tlimit;\n     int\t\tselected = count;\n     int\t\tbadlen = 0;\n     int\t\tmsg_scroll_save = msg_scroll;\n     int\t\two_spell_save = curwin->w_p_spell;\n \n     if (!curwin->w_p_spell)\n     {\n \tdid_set_spelllang(curwin);\n \tcurwin->w_p_spell = TRUE;\n     }\n \n     if (*curwin->w_s->b_p_spl == NUL)\n     {\n \temsg(_(e_spell_checking_is_not_possible));\n \treturn;\n     }\n \n     if (VIsual_active)\n     {\n \tif (curwin->w_cursor.lnum != VIsual.lnum)\n \t{\n \t    vim_beep(BO_SPELL);\n \t    return;\n \t}\n \tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n \tif (badlen < 0)\n \t    badlen = -badlen;\n \telse\n \t    curwin->w_cursor.col = VIsual.col;\n \t++badlen;\n \tend_visual_mode();\n// bug_start\n// bug_end\n     }\n     else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n \t    || curwin->w_cursor.col > prev_cursor.col)\n     {\n \tcurwin->w_cursor = prev_cursor;\n \tline = ml_get_curline();\n \tp = line + curwin->w_cursor.col;\n \twhile (p > line && spell_iswordp_nmw(p, curwin))\n \t    MB_PTR_BACK(line, p);\n \twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n \t    MB_PTR_ADV(p);\n \n \tif (!spell_iswordp_nmw(p, curwin))\n \t{\n \t    beep_flush();\n \t    return;\n \t}\n \tcurwin->w_cursor.col = (colnr_T)(p - line);\n     }\n \n \n     need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n \n     line = vim_strsave(ml_get_curline());\n     if (line == NULL)\n \tgoto skip;\n \n     if (sps_limit > (int)Rows - 2)\n \tlimit = (int)Rows - 2;\n     else\n \tlimit = sps_limit;\n     spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n \t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n \n     if (sug.su_ga.ga_len == 0)\n \tmsg(_(\"Sorry, no suggestions\"));\n     else if (count > 0)\n     {\n \tif (count > sug.su_ga.ga_len)\n \t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n     }\n     else\n     {\n #ifdef FEAT_RIGHTLEFT\n \tcmdmsg_rl = curwin->w_p_rl;\n \tif (cmdmsg_rl)\n \t    msg_col = Columns - 1;\n #endif\n \n \tmsg_start();\n \tmsg_row = Rows - 1;\n \tlines_left = Rows;\n \tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n \t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n #ifdef FEAT_RIGHTLEFT\n \tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n \t{\n \t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n \t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n \t}\n #endif\n \tmsg_puts((char *)IObuff);\n \tmsg_clr_eos();\n \tmsg_putchar('\\n');\n \n \tmsg_scroll = TRUE;\n \tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n \t{\n \t    stp = &SUG(sug.su_ga, i);\n \n \t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n \t    if (sug.su_badlen > stp->st_orglen)\n \t\tvim_strncpy(wcopy + stp->st_wordlen,\n \t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n \t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n \t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n #ifdef FEAT_RIGHTLEFT\n \t    if (cmdmsg_rl)\n \t\trl_mirror(IObuff);\n #endif\n \t    msg_puts((char *)IObuff);\n \n \t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n \t    msg_puts((char *)IObuff);\n \n \t    if (sug.su_badlen < stp->st_orglen)\n \t    {\n \t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n \t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n \t\tmsg_puts((char *)IObuff);\n \t    }\n \n \t    if (p_verbose > 0)\n \t    {\n \t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n \t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n \t\t\tstp->st_salscore ? \"s \" : \"\",\n \t\t\tstp->st_score, stp->st_altscore);\n \t\telse\n \t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n \t\t\t    stp->st_score);\n #ifdef FEAT_RIGHTLEFT\n \t\tif (cmdmsg_rl)\n \t\t    rl_mirror(IObuff + 1);\n #endif\n \t\tmsg_advance(30);\n \t\tmsg_puts((char *)IObuff);\n \t    }\n \t    msg_putchar('\\n');\n \t}\n \n #ifdef FEAT_RIGHTLEFT\n \tcmdmsg_rl = FALSE;\n \tmsg_col = 0;\n #endif\n \tselected = prompt_for_number(&mouse_used);\n \tif (mouse_used)\n \t    selected -= lines_left;\n \tlines_left = Rows;\n \tmsg_scroll = msg_scroll_save;\n     }\n \n     if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n     {\n \tVIM_CLEAR(repl_from);\n \tVIM_CLEAR(repl_to);\n \n \tstp = &SUG(sug.su_ga, selected - 1);\n \tif (sug.su_badlen > stp->st_orglen)\n \t{\n \t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n \t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n \t\t    sug.su_badlen - stp->st_orglen,\n \t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n \t    repl_to = vim_strsave(IObuff);\n \t}\n \telse\n \t{\n \t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n \t    repl_to = vim_strsave(stp->st_word);\n \t}\n \n \tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n \tif (p != NULL)\n \t{\n \t    c = (int)(sug.su_badptr - line);\n \t    mch_memmove(p, line, c);\n \t    STRCPY(p + c, stp->st_word);\n \t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n \n \t    ResetRedobuff();\n \t    AppendToRedobuff((char_u *)\"ciw\");\n \t    AppendToRedobuffLit(p + c,\n \t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n \t    AppendCharToRedobuff(ESC);\n \n \t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n \t    curwin->w_cursor.col = c;\n \n \t    changed_bytes(curwin->w_cursor.lnum, c);\n \t}\n     }\n     else\n \tcurwin->w_cursor = prev_cursor;\n \n     spell_find_cleanup(&sug);\n skip:\n     vim_free(line);\n     curwin->w_p_spell = wo_spell_save;\n }\n \n", "target": "// fix_start\n\tline = ml_get_curline();\n\tif (badlen > STRLEN(line) - curwin->w_cursor.col)\n\t    badlen = STRLEN(line) - curwin->w_cursor.col;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0943", "cve_desc": "Heap-based Buffer Overflow occurs in vim in GitHub repository vim/vim prior to 8.2.4563.", "project": "vim", "idx": 213515}
{"source": " int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)\n {\n \tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n \tstruct cgroup_subsys *ss;\n \tstruct fs_parse_result result;\n \tint opt, i;\n \n \topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);\n \tif (opt == -ENOPARAM) {\n \t\tif (strcmp(param->key, \"source\") == 0) {\n// bug_start\n// bug_end\n \t\t\tif (fc->source)\n \t\t\t\treturn invalf(fc, \"Multiple sources not supported\");\n \t\t\tfc->source = param->string;\n \t\t\tparam->string = NULL;\n \t\t\treturn 0;\n \t\t}\n \t\tfor_each_subsys(ss, i) {\n \t\t\tif (strcmp(param->key, ss->legacy_name))\n \t\t\t\tcontinue;\n \t\t\tif (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))\n \t\t\t\treturn invalfc(fc, \"Disabled controller '%s'\",\n \t\t\t\t\t       param->key);\n \t\t\tctx->subsys_mask |= (1 << i);\n \t\t\treturn 0;\n \t\t}\n \t\treturn invalfc(fc, \"Unknown subsys name '%s'\", param->key);\n \t}\n \tif (opt < 0)\n \t\treturn opt;\n \n \tswitch (opt) {\n \tcase Opt_none:\n \t\tctx->none = true;\n \t\tbreak;\n \tcase Opt_all:\n \t\tctx->all_ss = true;\n \t\tbreak;\n \tcase Opt_noprefix:\n \t\tctx->flags |= CGRP_ROOT_NOPREFIX;\n \t\tbreak;\n \tcase Opt_clone_children:\n \t\tctx->cpuset_clone_children = true;\n \t\tbreak;\n \tcase Opt_cpuset_v2_mode:\n \t\tctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;\n \t\tbreak;\n \tcase Opt_xattr:\n \t\tctx->flags |= CGRP_ROOT_XATTR;\n \t\tbreak;\n \tcase Opt_release_agent:\n \t\tif (ctx->release_agent)\n \t\t\treturn invalfc(fc, \"release_agent respecified\");\n \t\tctx->release_agent = param->string;\n \t\tparam->string = NULL;\n \t\tbreak;\n \tcase Opt_name:\n \t\tif (cgroup_no_v1_named)\n \t\t\treturn -ENOENT;\n \t\tif (!param->size)\n \t\t\treturn invalfc(fc, \"Empty name\");\n \t\tif (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)\n \t\t\treturn invalfc(fc, \"Name too long\");\n \t\tfor (i = 0; i < param->size; i++) {\n \t\t\tchar c = param->string[i];\n \t\t\tif (isalnum(c))\n \t\t\t\tcontinue;\n \t\t\tif ((c == '.') || (c == '-') || (c == '_'))\n \t\t\t\tcontinue;\n \t\t\treturn invalfc(fc, \"Invalid name\");\n \t\t}\n \t\tif (ctx->name)\n \t\t\treturn invalfc(fc, \"name respecified\");\n \t\tctx->name = param->string;\n \t\tparam->string = NULL;\n \t\tbreak;\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\t\tif (param->type != fs_value_is_string)\n\t\t\t\treturn invalf(fc, \"Non-string source\");\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-4154", "cve_desc": "A use-after-free flaw was found in cgroup1_parse_param in kernel/cgroup/cgroup-v1.c in the Linux kernel's cgroup v1 parser. A local attacker with a user privilege could cause a privilege escalation by exploiting the fsconfig syscall parameter leading to a container breakout and a denial of service on the system.", "project": "linux", "idx": 213528}
{"source": " FindEmptyObjectSlot(\n \t\t    TPMI_DH_OBJECT  *handle\n \t\t    )\n {\n     UINT32               i;\n     OBJECT              *object;\n     for(i = 0; i < MAX_LOADED_OBJECTS; i++)\n \t{\n \t    object = &s_objects[i];\n \t    if(object->attributes.occupied == CLEAR)\n \t\t{\n \t\t    if(handle)\n \t\t\t*handle = i + TRANSIENT_FIRST;\n// bug_start\n\t\t    MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES));\n// bug_end\n \t\t    return object;\n \t\t}\n \t}\n     return NULL;\n }\n \n", "target": "// fix_start\n\t\t    MemorySet(object, 0, sizeof(*object));\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2021-3746", "cve_desc": "A flaw was found in the libtpms code that may cause access beyond the boundary of internal buffers. The vulnerability is triggered by specially-crafted TPM2 command packets that then trigger the issue when the state of the TPM2's volatile state is written. The highest threat from this vulnerability is to system availability. This issue affects libtpms versions before 0.8.5, before 0.7.9 and before 0.6.6.", "project": "libtpms", "idx": 213998}
{"source": " HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n {\n     rfbRREHeader hdr;\n     int i;\n     CARDBPP pix;\n     uint8_t *ptr;\n     int x, y, w, h;\n \n     if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n \treturn FALSE;\n \n     hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n \n     if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n \treturn FALSE;\n \n     client->GotFillRect(client, rx, ry, rw, rh, pix);\n \n// bug_start\n    if (hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n// bug_end\n \treturn FALSE;\n \n     ptr = (uint8_t *)client->buffer;\n \n     for (i = 0; i < hdr.nSubrects; i++) {\n \tpix = *(CARDBPP *)ptr;\n \tptr += BPP/8;\n \tx = *ptr++;\n \ty = *ptr++;\n \tw = *ptr++;\n \th = *ptr++;\n \n \tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n     }\n \n     return TRUE;\n }\n \n", "target": "// fix_start\n    if (hdr.nSubrects > RFB_BUFFER_SIZE / (4 + (BPP / 8)) || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2018-20020", "cve_desc": "LibVNC before commit 7b1ef0ffc4815cab9a96c7278394152bdc89dc4d contains heap out-of-bound write vulnerability inside structure in VNC client code that can result remote code execution", "project": "libvncserver", "idx": 214003}
{"source": " lzw_result lzw_decode(struct lzw_ctx *ctx,\n \t\tconst uint8_t ** const stack_pos_out)\n {\n \tlzw_result res;\n \tuint32_t code_new;\n \tuint32_t code_out;\n \tuint8_t last_value;\n \tuint8_t *stack_pos = ctx->stack_base;\n \tuint32_t clear_code = ctx->clear_code;\n \tuint32_t current_entry = ctx->current_entry;\n \tstruct lzw_dictionary_entry * const table = ctx->table;\n \n \tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n \tif (res != LZW_OK) {\n \t\treturn res;\n \t}\n \n \tif (code_new == clear_code) {\n \t\treturn lzw__clear_codes(ctx, stack_pos_out);\n \n \t} else if (code_new == ctx->eoi_code) {\n \t\treturn LZW_EOI_CODE;\n \n \t} else if (code_new > current_entry) {\n// bug_start\n// bug_end\n \t\treturn LZW_BAD_CODE;\n \n \t} else if (code_new < current_entry) {\n \t\tcode_out = code_new;\n \t\tlast_value = table[code_new].first_value;\n \t} else {\n \t\t*stack_pos++ = ctx->previous_code_first;\n \t\tcode_out = ctx->previous_code;\n \t\tlast_value = ctx->previous_code_first;\n \t}\n \n \tif (current_entry < (1 << LZW_CODE_MAX)) {\n \t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n \t\tentry->last_value     = last_value;\n \t\tentry->first_value    = ctx->previous_code_first;\n \t\tentry->previous_entry = ctx->previous_code;\n \t\tctx->current_entry++;\n \t}\n \n \tif (current_entry == ctx->current_code_size_max) {\n \t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n \t\t\tctx->current_code_size++;\n \t\t\tctx->current_code_size_max =\n \t\t\t\t\t(1 << ctx->current_code_size) - 1;\n \t\t}\n \t}\n \n \tctx->previous_code_first = table[code_new].first_value;\n \tctx->previous_code = code_new;\n \n \twhile (code_out > clear_code) {\n \t\tstruct lzw_dictionary_entry *entry = table + code_out;\n \t\t*stack_pos++ = entry->last_value;\n \t\tcode_out = entry->previous_entry;\n \t}\n \t*stack_pos++ = table[code_out].last_value;\n \n \t*stack_pos_out = stack_pos;\n \treturn LZW_OK;\n }\n \n", "target": "// fix_start\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-2061", "cve_desc": "Heap-based Buffer Overflow in GitHub repository hpjansson/chafa prior to 1.12.0.", "project": "chafa", "idx": 214124}
{"source": " composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n {\n \tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n \tstruct usb_request\t\t*req = cdev->req;\n \tint\t\t\t\tvalue = -EOPNOTSUPP;\n \tint\t\t\t\tstatus = 0;\n \tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n \tu8\t\t\t\tintf = w_index & 0xFF;\n \tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n \tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n \tstruct usb_function\t\t*f = NULL;\n \tu8\t\t\t\tendp;\n \n \tif (w_length > USB_COMP_EP0_BUFSIZ) {\n \t\tif (ctrl->bRequestType & USB_DIR_IN) {\n \t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n \n \t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n \t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n \t\t} else {\n \t\t\tgoto done;\n \t\t}\n \t}\n \n \treq->zero = 0;\n \treq->context = cdev;\n \treq->complete = composite_setup_complete;\n \treq->length = 0;\n \tgadget->ep0->driver_data = cdev;\n \n \tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n \t\tgoto unknown;\n \n \tswitch (ctrl->bRequest) {\n \n \tcase USB_REQ_GET_DESCRIPTOR:\n \t\tif (ctrl->bRequestType != USB_DIR_IN)\n \t\t\tgoto unknown;\n \t\tswitch (w_value >> 8) {\n \n \t\tcase USB_DT_DEVICE:\n \t\t\tcdev->desc.bNumConfigurations =\n \t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n \t\t\tcdev->desc.bMaxPacketSize0 =\n \t\t\t\tcdev->gadget->ep0->maxpacket;\n \t\t\tif (gadget_is_superspeed(gadget)) {\n \t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n \t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n \t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n \t\t\t\t} else {\n \t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (gadget->lpm_capable)\n \t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n \t\t\t\telse\n \t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n \t\t\t}\n \n \t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n \t\t\tmemcpy(req->buf, &cdev->desc, value);\n \t\t\tbreak;\n \t\tcase USB_DT_DEVICE_QUALIFIER:\n \t\t\tif (!gadget_is_dualspeed(gadget) ||\n \t\t\t    gadget->speed >= USB_SPEED_SUPER)\n \t\t\t\tbreak;\n \t\t\tdevice_qual(cdev);\n \t\t\tvalue = min_t(int, w_length,\n \t\t\t\tsizeof(struct usb_qualifier_descriptor));\n \t\t\tbreak;\n \t\tcase USB_DT_OTHER_SPEED_CONFIG:\n \t\t\tif (!gadget_is_dualspeed(gadget) ||\n \t\t\t    gadget->speed >= USB_SPEED_SUPER)\n \t\t\t\tbreak;\n \t\t\tfallthrough;\n \t\tcase USB_DT_CONFIG:\n \t\t\tvalue = config_desc(cdev, w_value);\n \t\t\tif (value >= 0)\n \t\t\t\tvalue = min(w_length, (u16) value);\n \t\t\tbreak;\n \t\tcase USB_DT_STRING:\n \t\t\tvalue = get_string(cdev, req->buf,\n \t\t\t\t\tw_index, w_value & 0xff);\n \t\t\tif (value >= 0)\n \t\t\t\tvalue = min(w_length, (u16) value);\n \t\t\tbreak;\n \t\tcase USB_DT_BOS:\n \t\t\tif (gadget_is_superspeed(gadget) ||\n \t\t\t    gadget->lpm_capable) {\n \t\t\t\tvalue = bos_desc(cdev);\n \t\t\t\tvalue = min(w_length, (u16) value);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase USB_DT_OTG:\n \t\t\tif (gadget_is_otg(gadget)) {\n \t\t\t\tstruct usb_configuration *config;\n \t\t\t\tint otg_desc_len = 0;\n \n \t\t\t\tif (cdev->config)\n \t\t\t\t\tconfig = cdev->config;\n \t\t\t\telse\n \t\t\t\t\tconfig = list_first_entry(\n \t\t\t\t\t\t\t&cdev->configs,\n \t\t\t\t\t\tstruct usb_configuration, list);\n \t\t\t\tif (!config)\n \t\t\t\t\tgoto done;\n \n \t\t\t\tif (gadget->otg_caps &&\n \t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n \t\t\t\t\totg_desc_len += sizeof(\n \t\t\t\t\t\tstruct usb_otg20_descriptor);\n \t\t\t\telse\n \t\t\t\t\totg_desc_len += sizeof(\n \t\t\t\t\t\tstruct usb_otg_descriptor);\n \n \t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n \t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tbreak;\n \n \tcase USB_REQ_SET_CONFIGURATION:\n \t\tif (ctrl->bRequestType != 0)\n \t\t\tgoto unknown;\n \t\tif (gadget_is_otg(gadget)) {\n \t\t\tif (gadget->a_hnp_support)\n \t\t\t\tDBG(cdev, \"HNP available\\n\");\n \t\t\telse if (gadget->a_alt_hnp_support)\n \t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n \t\t\telse\n \t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n \t\t}\n \t\tspin_lock(&cdev->lock);\n \t\tvalue = set_config(cdev, ctrl, w_value);\n \t\tspin_unlock(&cdev->lock);\n \t\tbreak;\n \tcase USB_REQ_GET_CONFIGURATION:\n \t\tif (ctrl->bRequestType != USB_DIR_IN)\n \t\t\tgoto unknown;\n \t\tif (cdev->config)\n \t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n \t\telse\n \t\t\t*(u8 *)req->buf = 0;\n \t\tvalue = min(w_length, (u16) 1);\n \t\tbreak;\n \n \tcase USB_REQ_SET_INTERFACE:\n \t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n \t\t\tgoto unknown;\n \t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n \t\t\tbreak;\n \t\tf = cdev->config->interface[intf];\n \t\tif (!f)\n \t\t\tbreak;\n \n \t\tif (w_value && !f->get_alt)\n \t\t\tbreak;\n \n \t\tspin_lock(&cdev->lock);\n \t\tvalue = f->set_alt(f, w_index, w_value);\n \t\tif (value == USB_GADGET_DELAYED_STATUS) {\n \t\t\tDBG(cdev,\n \t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n \t\t\t\t\t__func__, intf, f->name);\n \t\t\tcdev->delayed_status++;\n \t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n \t\t\t\t\tcdev->delayed_status);\n \t\t}\n \t\tspin_unlock(&cdev->lock);\n \t\tbreak;\n \tcase USB_REQ_GET_INTERFACE:\n \t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n \t\t\tgoto unknown;\n \t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n \t\t\tbreak;\n \t\tf = cdev->config->interface[intf];\n \t\tif (!f)\n \t\t\tbreak;\n \t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n \t\tif (value < 0)\n \t\t\tbreak;\n \t\t*((u8 *)req->buf) = value;\n \t\tvalue = min(w_length, (u16) 1);\n \t\tbreak;\n \tcase USB_REQ_GET_STATUS:\n \t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n \t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n \t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n \t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n \t\t\t\tgoto unknown;\n \t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n \t\t\tvalue = 1;\n \t\t\tbreak;\n \t\t}\n \n \t\tif (!gadget_is_superspeed(gadget))\n \t\t\tgoto unknown;\n \t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n \t\t\tgoto unknown;\n \t\tvalue = 2;\n \t\tput_unaligned_le16(0, req->buf);\n \t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n \t\t\tbreak;\n \t\tf = cdev->config->interface[intf];\n \t\tif (!f)\n \t\t\tbreak;\n \t\tstatus = f->get_status ? f->get_status(f) : 0;\n \t\tif (status < 0)\n \t\t\tbreak;\n \t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n \t\tbreak;\n \tcase USB_REQ_CLEAR_FEATURE:\n \tcase USB_REQ_SET_FEATURE:\n \t\tif (!gadget_is_superspeed(gadget))\n \t\t\tgoto unknown;\n \t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n \t\t\tgoto unknown;\n \t\tswitch (w_value) {\n \t\tcase USB_INTRF_FUNC_SUSPEND:\n \t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n \t\t\t\tbreak;\n \t\t\tf = cdev->config->interface[intf];\n \t\t\tif (!f)\n \t\t\t\tbreak;\n \t\t\tvalue = 0;\n \t\t\tif (f->func_suspend)\n \t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n \t\t\tif (value < 0) {\n \t\t\t\tERROR(cdev,\n \t\t\t\t      \"func_suspend() returned error %d\\n\",\n \t\t\t\t      value);\n \t\t\t\tvalue = 0;\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tbreak;\n \tdefault:\n unknown:\n \t\tif (cdev->use_os_string && cdev->os_desc_config &&\n \t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n \t\t    ctrl->bRequest == cdev->b_vendor_code) {\n \t\t\tstruct usb_configuration\t*os_desc_cfg;\n \t\t\tu8\t\t\t\t*buf;\n \t\t\tint\t\t\t\tinterface;\n \t\t\tint\t\t\t\tcount = 0;\n \n \t\t\treq = cdev->os_desc_req;\n \t\t\treq->context = cdev;\n \t\t\treq->complete = composite_setup_complete;\n \t\t\tbuf = req->buf;\n \t\t\tos_desc_cfg = cdev->os_desc_config;\n \t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n \t\t\tmemset(buf, 0, w_length);\n \t\t\tbuf[5] = 0x01;\n \t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n \t\t\tcase USB_RECIP_DEVICE:\n \t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n \t\t\t\t\tbreak;\n \t\t\t\tbuf[6] = w_index;\n \t\t\t\tcount = count_ext_compat(os_desc_cfg);\n \t\t\t\tbuf[8] = count;\n \t\t\t\tcount *= 24;\n \t\t\t\tcount += 16;\n \t\t\t\tput_unaligned_le32(count, buf);\n \t\t\t\tvalue = w_length;\n \t\t\t\tif (w_length > 0x10) {\n \t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n \t\t\t\t\tvalue = min_t(u16, w_length, value);\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase USB_RECIP_INTERFACE:\n \t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n \t\t\t\t\tbreak;\n \t\t\t\tinterface = w_value & 0xFF;\n// bug_start\n// bug_end\n \t\t\t\tbuf[6] = w_index;\n \t\t\t\tcount = count_ext_prop(os_desc_cfg,\n \t\t\t\t\tinterface);\n \t\t\t\tput_unaligned_le16(count, buf + 8);\n \t\t\t\tcount = len_ext_prop(os_desc_cfg,\n \t\t\t\t\tinterface);\n \t\t\t\tput_unaligned_le32(count, buf);\n \t\t\t\tvalue = w_length;\n \t\t\t\tif (w_length > 0x0A) {\n \t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n \t\t\t\t\t\t\t      interface, buf);\n \t\t\t\t\tif (value >= 0)\n \t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tgoto check_value;\n \t\t}\n \n \t\tVDBG(cdev,\n \t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n \t\t\tctrl->bRequestType, ctrl->bRequest,\n \t\t\tw_value, w_index, w_length);\n \n \t\tif (cdev->config) {\n \t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n \t\t\t\tif (f->req_match &&\n \t\t\t\t    f->req_match(f, ctrl, false))\n \t\t\t\t\tgoto try_fun_setup;\n \t\t} else {\n \t\t\tstruct usb_configuration *c;\n \t\t\tlist_for_each_entry(c, &cdev->configs, list)\n \t\t\t\tlist_for_each_entry(f, &c->functions, list)\n \t\t\t\t\tif (f->req_match &&\n \t\t\t\t\t    f->req_match(f, ctrl, true))\n \t\t\t\t\t\tgoto try_fun_setup;\n \t\t}\n \t\tf = NULL;\n \n \t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n \t\tcase USB_RECIP_INTERFACE:\n \t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n \t\t\t\tbreak;\n \t\t\tf = cdev->config->interface[intf];\n \t\t\tbreak;\n \n \t\tcase USB_RECIP_ENDPOINT:\n \t\t\tif (!cdev->config)\n \t\t\t\tbreak;\n \t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n \t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n \t\t\t\tif (test_bit(endp, f->endpoints))\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t\tif (&f->list == &cdev->config->functions)\n \t\t\t\tf = NULL;\n \t\t\tbreak;\n \t\t}\n try_fun_setup:\n \t\tif (f && f->setup)\n \t\t\tvalue = f->setup(f, ctrl);\n \t\telse {\n \t\t\tstruct usb_configuration\t*c;\n \n \t\t\tc = cdev->config;\n \t\t\tif (!c)\n \t\t\t\tgoto done;\n \n \t\t\tif (c->setup) {\n \t\t\t\tvalue = c->setup(c, ctrl);\n \t\t\t\tgoto done;\n \t\t\t}\n \n \t\t\tif (!list_is_singular(&c->functions))\n \t\t\t\tgoto done;\n \t\t\tf = list_first_entry(&c->functions, struct usb_function,\n \t\t\t\t\t     list);\n \t\t\tif (f->setup)\n \t\t\t\tvalue = f->setup(f, ctrl);\n \t\t}\n \n \t\tgoto done;\n \t}\n \n check_value:\n \tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n \t\treq->length = value;\n \t\treq->context = cdev;\n \t\treq->zero = value < w_length;\n \t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n \t\tif (value < 0) {\n \t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n \t\t\treq->status = 0;\n \t\t\tcomposite_setup_complete(gadget->ep0, req);\n \t\t}\n \t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n \t\tWARN(cdev,\n \t\t\t\"%s: Delayed status not supported for w_length != 0\",\n \t\t\t__func__);\n \t}\n \n done:\n \treturn value;\n }\n \n", "target": "// fix_start\n\t\t\t\tif (interface >= MAX_CONFIG_INTERFACES ||\n\t\t\t\t    !os_desc_cfg->interface[interface])\n\t\t\t\t\tbreak;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-25258", "cve_desc": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.", "project": "linux", "idx": 214160}
{"source": " static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n {\n \tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n \tstruct tipc_aead_key *skey = NULL;\n \tu16 key_gen = msg_key_gen(hdr);\n \tu16 size = msg_data_sz(hdr);\n \tu8 *data = msg_data(hdr);\n// bug_start\n// bug_end\n \n \tspin_lock(&rx->lock);\n \tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n \t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n \t\t       rx->skey, key_gen, rx->key_gen);\n// bug_start\n\t\tgoto exit;\n// bug_end\n \t}\n \n \tskey = kmalloc(size, GFP_ATOMIC);\n \tif (unlikely(!skey)) {\n \t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n// bug_start\n\t\tgoto exit;\n// bug_end\n \t}\n \n// bug_start\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n// bug_end\n \tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n \tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n \t       skey->keylen);\n// bug_start\n\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n// bug_end\n \n \trx->key_gen = key_gen;\n \trx->skey_mode = msg_key_mode(hdr);\n \trx->skey = skey;\n \trx->nokey = 0;\n \tmb();\n \n// bug_start\nexit:\n// bug_end\n \tspin_unlock(&rx->lock);\n \n// bug_start\n// bug_end\n \tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n \t\treturn true;\n \n \treturn false;\n }\n \n", "target": "// fix_start\n\tunsigned int keylen;\n\n\tif (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {\n\t\tpr_debug(\"%s: message data size is too small\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\tkeylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\n\tif (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||\n\t\t     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {\n\t\tpr_debug(\"%s: invalid MSG_CRYPTO key size\\n\", rx->name);\n\t\tgoto exit;\n\t}\n// fix_end\n// fix_start\n\t\tgoto exit_unlock;\n// fix_end\n// fix_start\n\t\tgoto exit_unlock;\n// fix_end\n// fix_start\n\tskey->keylen = keylen;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\nexit_unlock:\n// fix_end\n// fix_start\nexit:\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2021-43267", "cve_desc": "An issue was discovered in net/tipc/crypto.c in the Linux kernel before 5.14.16. The Transparent Inter-Process Communication (TIPC) functionality allows remote attackers to exploit insufficient validation of user-supplied sizes for the MSG_CRYPTO message type.", "project": "linux", "idx": 214276}
{"source": " R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tRBinJavaClassesAttribute *icattr;\n \tRBinJavaAttrInfo *attr = NULL;\n \tRBinJavaCPTypeObj *obj;\n \tut32 i = 0;\n \tut64 offset = 0, curpos;\n \tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n \toffset += 6;\n// bug_start\n// bug_end\n \tif (attr == NULL) {\n \t\treturn attr;\n \t}\n \tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n \tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n \toffset += 2;\n \tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n \tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n \t\tcurpos = buf_offset + offset;\n// bug_start\n\t\tif (offset + 8 > sz) {\n// bug_end\n \t\t\teprintf (\"Invalid amount of inner classes\\n\");\n \t\t\tbreak;\n \t\t}\n \t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n \t\tif (!icattr) {\n \t\t\tbreak;\n \t\t}\n \t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n \t\toffset += 2;\n \t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n \t\toffset += 2;\n \t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n \t\toffset += 2;\n \t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n \t\toffset += 2;\n \t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n \t\ticattr->file_offset = curpos;\n \t\ticattr->size = 8;\n \n \t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n \t\tif (obj == NULL) {\n \t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n \t\t}\n \t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n \t\tif (!icattr->name) {\n \t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n \t\t\tif (!obj) {\n \t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n \t\t\t}\n \t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n \t\t\tif (!icattr->name) {\n \t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n \t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n \t\t\t\tfree (icattr);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n \t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n \t}\n \tattr->size = offset;\n \treturn attr;\n }\n \n", "target": "// fix_start\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n// fix_end\n// fix_start\n\t\tif (buf_offset + offset + 8 > sz) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-0518", "cve_desc": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.2.", "project": "radare2", "idx": 214282}
{"source": " int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs,\n \t\t\t\t\t      off_t bl_len)\n {\n   const char *content_type = NULL;\n   string content_type_str;\n   map<string, string> response_attrs;\n   map<string, string>::iterator riter;\n   bufferlist metadata_bl;\n \n   string expires = get_s3_expiration_header(s, lastmod);\n \n   if (sent_header)\n     goto send_data;\n \n   if (custom_http_ret) {\n     set_req_state_err(s, 0);\n     dump_errno(s, custom_http_ret);\n   } else {\n     set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT\n                   : op_ret);\n     dump_errno(s);\n   }\n \n   if (op_ret)\n     goto done;\n \n   if (range_str)\n     dump_range(s, start, end, s->obj_size);\n \n   if (s->system_request &&\n       s->info.args.exists(RGW_SYS_PARAM_PREFIX \"prepend-metadata\")) {\n \n     dump_header(s, \"Rgwx-Object-Size\", (long long)total_len);\n \n     if (rgwx_stat) {\n       total_len = 0;\n     }\n \n     JSONFormatter jf;\n     jf.open_object_section(\"obj_metadata\");\n     encode_json(\"attrs\", attrs, &jf);\n     utime_t ut(lastmod);\n     encode_json(\"mtime\", ut, &jf);\n     jf.close_section();\n     stringstream ss;\n     jf.flush(ss);\n     metadata_bl.append(ss.str());\n     dump_header(s, \"Rgwx-Embedded-Metadata-Len\", metadata_bl.length());\n     total_len += metadata_bl.length();\n   }\n \n   if (s->system_request && !real_clock::is_zero(lastmod)) {\n     dump_epoch_header(s, \"Rgwx-Mtime\", lastmod);\n     uint64_t pg_ver = 0;\n     int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);\n     if (r < 0) {\n       ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n     }\n     dump_header(s, \"Rgwx-Obj-PG-Ver\", pg_ver);\n \n     uint32_t source_zone_short_id = 0;\n     r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);\n     if (r < 0) {\n       ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n     }\n     if (source_zone_short_id != 0) {\n       dump_header(s, \"Rgwx-Source-Zone-Short-Id\", source_zone_short_id);\n     }\n   }\n \n   for (auto &it : crypt_http_responses)\n     dump_header(s, it.first, it.second);\n \n   dump_content_length(s, total_len);\n   dump_last_modified(s, lastmod);\n   dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n   dump_header_if_nonempty(s, \"x-amz-expiration\", expires);\n \n   if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {\n     dump_header(s, \"x-rgw-object-type\", \"Appendable\");\n     dump_header(s, \"x-rgw-next-append-position\", s->obj_size);\n   } else {\n     dump_header(s, \"x-rgw-object-type\", \"Normal\");\n   }\n \n   if (! op_ret) {\n     if (! lo_etag.empty()) {\n       dump_etag(s, lo_etag);\n     } else {\n       auto iter = attrs.find(RGW_ATTR_ETAG);\n       if (iter != attrs.end()) {\n         dump_etag(s, iter->second.to_str());\n       }\n     }\n \n     for (struct response_attr_param *p = resp_attr_params; p->param; p++) {\n       bool exists;\n       string val = s->info.args.get(p->param, &exists);\n       if (exists) {\n \tif (s->auth.identity->is_anonymous()) {\n \t  return -ERR_INVALID_REQUEST;\n \t}\n// bug_start\n// bug_end\n \tif (strcmp(p->param, \"response-content-type\") != 0) {\n \t  response_attrs[p->http_attr] = val;\n \t} else {\n \t  content_type_str = val;\n \t  content_type = content_type_str.c_str();\n \t}\n       }\n     }\n \n     for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {\n       const char *name = iter->first.c_str();\n       map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);\n       if (aiter != rgw_to_http_attrs.end()) {\n         if (response_attrs.count(aiter->second) == 0) {\n \n           size_t len = iter->second.length();\n           string s(iter->second.c_str(), len);\n           while (len && !s[len - 1]) {\n             --len;\n             s.resize(len);\n           }\n           response_attrs[aiter->second] = s;\n         }\n       } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {\n         if (!content_type) {\n           content_type_str = rgw_bl_str(iter->second);\n           content_type = content_type_str.c_str();\n         }\n       } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {\n         dump_header(s, \"X-Object-Meta-Static-Large-Object\", \"True\");\n       } else if (strncmp(name, RGW_ATTR_META_PREFIX,\n \t\t\t sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {\n         name += sizeof(RGW_ATTR_PREFIX) - 1;\n         dump_header(s, name, iter->second);\n       } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {\n         RGWObjTags obj_tags;\n         try{\n           auto it = iter->second.cbegin();\n           obj_tags.decode(it);\n         } catch (buffer::error &err) {\n           ldpp_dout(this,0) << \"Error caught buffer::error couldn't decode TagSet \" << dendl;\n         }\n         dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());\n       } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){\n         RGWObjectRetention retention;\n         try {\n           decode(retention, iter->second);\n           dump_header(s, \"x-amz-object-lock-mode\", retention.get_mode());\n           dump_time_header(s, \"x-amz-object-lock-retain-until-date\", retention.get_retain_until_date());\n         } catch (buffer::error& err) {\n           ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectRetention\" << dendl;\n         }\n       } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {\n         RGWObjectLegalHold legal_hold;\n         try {\n           decode(legal_hold, iter->second);\n           dump_header(s, \"x-amz-object-lock-legal-hold\",legal_hold.get_status());\n         } catch (buffer::error& err) {\n           ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectLegalHold\" << dendl;\n         }\n       }\n     }\n   }\n \n done:\n   for (riter = response_attrs.begin(); riter != response_attrs.end();\n        ++riter) {\n     dump_header(s, riter->first, riter->second);\n   }\n \n   if (op_ret == -ERR_NOT_MODIFIED) {\n       end_header(s, this);\n   } else {\n       if (!content_type)\n           content_type = \"binary/octet-stream\";\n \n       end_header(s, this, content_type);\n   }\n \n   if (metadata_bl.length()) {\n     dump_body(s, metadata_bl);\n   }\n   sent_header = true;\n \n send_data:\n   if (get_data && !op_ret) {\n     int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);\n     if (r < 0)\n       return r;\n   }\n \n   return 0;\n }\n \n", "target": "// fix_start\n        if(str_has_cntrl(val)) {\n          return -ERR_INVALID_REQUEST;\n        }\n\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "cve": "CVE-2020-1760", "cve_desc": "A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.", "project": "ceph", "idx": 214335}
{"source": " static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n {\n \tstruct pfkey_sock *pfk = pfkey_sk(sk);\n \tstruct sk_buff *supp_skb;\n \n \tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n \t\treturn -EINVAL;\n \n \tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n \t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n \t\t\treturn -EEXIST;\n \t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n \t}\n \n// bug_start\n// bug_end\n \txfrm_probe_algs();\n \n \tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n// bug_start\n// bug_end\n \tif (!supp_skb) {\n \t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n \t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n \n \t\treturn -ENOBUFS;\n \t}\n \n \tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n \t\t\tsock_net(sk));\n \treturn 0;\n }\n \n", "target": "// fix_start\n\tmutex_lock(&pfkey_mutex);\n// fix_end\n// fix_start\n\tmutex_unlock(&pfkey_mutex);\n\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2022-3028", "cve_desc": "A race condition was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.", "project": "linux", "idx": 214336}
{"source": " int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n {\n \tstruct rtas_token_definition *d;\n \tstruct rtas_args args;\n \trtas_arg_t *orig_rets;\n \tgpa_t args_phys;\n \tint rc;\n \n \targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n \n \tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n \trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n \tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n \tif (rc)\n \t\tgoto fail;\n \n \torig_rets = args.rets;\n// bug_start\n// bug_end\n \targs.rets = &args.args[be32_to_cpu(args.nargs)];\n \n \tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n \n \trc = -ENOENT;\n \tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n \t\tif (d->token == be32_to_cpu(args.token)) {\n \t\t\td->handler->handler(vcpu, &args);\n \t\t\trc = 0;\n \t\t\tbreak;\n \t\t}\n \t}\n \n \tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n \n \tif (rc == 0) {\n \t\targs.rets = orig_rets;\n \t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n \t\tif (rc)\n \t\t\tgoto fail;\n \t}\n \n \treturn rc;\n \n fail:\n \treturn rc;\n }\n \n", "target": "// fix_start\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-37576", "cve_desc": "arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.", "project": "linux", "idx": 214339}
{"source": " int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n   unsigned int frame_start, frame_end, window_posn, match_offset, range;\n   unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n   int i, j, selector, extra, sym, match_length, ret;\n   unsigned short H, L, C, symf;\n \n   register unsigned int bit_buffer;\n   register unsigned char bits_left;\n   unsigned char bits_needed, bit_run;\n \n   if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n   if (qtm->error) return qtm->error;\n \n   i = qtm->o_end - qtm->o_ptr;\n   if ((off_t) i > out_bytes) i = (int) out_bytes;\n   if (i) {\n     if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n       return qtm->error = ret;\n     }\n     qtm->o_ptr  += i;\n     out_bytes   -= i;\n   }\n   if (out_bytes == 0) return CL_SUCCESS;\n \n   QTM_RESTORE_BITS;\n   window = qtm->window;\n   window_posn = qtm->window_posn;\n   frame_start = qtm->frame_start;\n   H = qtm->H;\n   L = qtm->L;\n   C = qtm->C;\n \n   while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n \n     if (!qtm->header_read) {\n       H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n       qtm->header_read = 1;\n     }\n \n     frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n     if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n       frame_end = frame_start + QTM_FRAME_SIZE;\n     }\n \n     while (window_posn < frame_end) {\n       QTM_GET_SYMBOL(qtm->model7, selector);\n       if (selector < 4) {\n \tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n \t                        ((selector == 1) ? &qtm->model1 :\n \t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                    &qtm->model3));\n \tQTM_GET_SYMBOL((*mdl), sym);\n \twindow[window_posn++] = sym;\n       }\n       else {\n \tswitch (selector) {\n \tcase 4:\n \t  QTM_GET_SYMBOL(qtm->model4, sym);\n \t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n \t  match_offset = qtm->position_base[sym] + extra + 1;\n \t  match_length = 3;\n \t  break;\n \n \tcase 5:\n \t  QTM_GET_SYMBOL(qtm->model5, sym);\n \t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n \t  match_offset = qtm->position_base[sym] + extra + 1;\n \t  match_length = 4;\n \t  break;\n \n \tcase 6:\n \t  QTM_GET_SYMBOL(qtm->model6len, sym);\n \t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n \t  match_length = qtm->length_base[sym] + extra + 5;\n \n \t  QTM_GET_SYMBOL(qtm->model6, sym);\n \t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n \t  match_offset = qtm->position_base[sym] + extra + 1;\n \t  break;\n \n \tdefault:\n \t  return qtm->error = CL_EFORMAT;\n \t}\n \n// bug_start\n// bug_end\n \trundest = &window[window_posn];\n \ti = match_length;\n \tif (match_offset > window_posn) {\n \t  j = match_offset - window_posn;\n \t  if (j > (int) qtm->window_size) {\n \t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n \t    return qtm->error = CL_EFORMAT;\n \t  }\n \t  runsrc = &window[qtm->window_size - j];\n \t  if (j < i) {\n \t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n \t    runsrc = window;\n \t  }\n \t  while (i-- > 0) *rundest++ = *runsrc++;\n \t}\n \telse {\n \t  runsrc = rundest - match_offset;\n \t  if(i > (int) (qtm->window_size - window_posn))\n \t    i = qtm->window_size - window_posn;\n \t  while (i-- > 0) *rundest++ = *runsrc++;\n \t}\n \twindow_posn += match_length;\n       }\n     }\n \n     qtm->o_end = &window[window_posn];\n \n     if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n       if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n \tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n \treturn qtm->error = CL_EFORMAT;\n       }\n \n       if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n       do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n       qtm->header_read = 0;\n \n       if (window_posn == qtm->window_size) {\n \ti = (qtm->o_end - qtm->o_ptr);\n \tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n \t  return qtm->error = ret;\n \t}\n \tout_bytes -= i;\n \tqtm->o_ptr = &window[0];\n \tqtm->o_end = &window[0];\n \twindow_posn = 0;\n       }\n \n       frame_start = window_posn;\n     }\n \n   }\n \n   if (out_bytes) {\n     i = (int) out_bytes;\n     if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n       return qtm->error = ret;\n     }\n     qtm->o_ptr += i;\n   }\n \n   QTM_STORE_BITS;\n   qtm->window_posn = window_posn;\n   qtm->frame_start = frame_start;\n   qtm->H = H;\n   qtm->L = L;\n   qtm->C = C;\n \n   return CL_SUCCESS;\n }\n \n", "target": "// fix_start\n\tif (window_posn + match_length > qtm->window_size) {\n\t  cli_dbgmsg(\"qtm_decompress: match ran over window wrap\\n\");\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "project": "clamav-devel", "idx": 214358}
{"source": "// bug_start\nvoid simplestring_addn(simplestring* target, const char* source, int add_len) {\n// bug_end\n    if(target && source) {\n       if(!target->str) {\n          simplestring_init_str(target);\n       }\n// bug_start\n// bug_end\n       if(target->len + add_len + 1 > target->size) {\n// bug_start\n         int newsize = target->len + add_len + 1;\n         int incr = target->size * 2;\n// bug_end\n \n// bug_start\n         newsize = newsize - (newsize % incr) + incr;\n// bug_end\n          target->str = (char*)realloc(target->str, newsize);\n \n          target->size = target->str ? newsize : 0;\n       }\n \n       if(target->str) {\n          if(add_len) {\n             memcpy(target->str + target->len, source, add_len);\n          }\n          target->len += add_len;\n          target->str[target->len] = 0;\n       }\n    }\n }\n \n", "target": "// fix_start\nvoid simplestring_addn(simplestring* target, const char* source, size_t add_len) {\n   size_t newsize = target->size, incr = 0;\n// fix_end\n// fix_start\n\n      if((SIZE_MAX - add_len) < target->len || (SIZE_MAX - add_len - 1) < target->len) {\n    \t  return;\n      }\n\n// fix_end\n// fix_start\n         newsize = target->len + add_len + 1;\n         incr = target->size * 2;\n// fix_end\n// fix_start\n         if (incr) {\n            newsize = newsize - (newsize % incr) + incr;\n         }\n         if(newsize < (target->len + add_len + 1)) {\n        \t return;\n         }\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2016-6296", "cve_desc": "Integer signedness error in the simplestring_addn function in simplestring.c in xmlrpc-epi through 0.54.2, as used in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a long first argument to the PHP xmlrpc_encode_request function.", "project": "php-src", "idx": 214364}
{"source": " static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n {\n \tstruct mlx5_fpga_device *fdev = conn->fdev;\n \tstruct mlx5_core_dev *mdev = fdev->mdev;\n \tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n \tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n \tstruct mlx5_wq_param wqp;\n \tstruct mlx5_cqe64 *cqe;\n \tint inlen, err, eqn;\n \tunsigned int irqn;\n \tvoid *cqc, *in;\n \t__be64 *pas;\n \tu32 i;\n \n \tcq_size = roundup_pow_of_two(cq_size);\n \tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n \n \twqp.buf_numa_node = mdev->priv.numa_node;\n \twqp.db_numa_node  = mdev->priv.numa_node;\n \n \terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n \t\t\t       &conn->cq.wq_ctrl);\n \tif (err)\n \t\treturn err;\n \n \tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n \t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n \t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n \t}\n \n \tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n \t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n \tin = kvzalloc(inlen, GFP_KERNEL);\n \tif (!in) {\n \t\terr = -ENOMEM;\n \t\tgoto err_cqwq;\n \t}\n \n \terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n// bug_start\n\tif (err)\n// bug_end\n \t\tgoto err_cqwq;\n// bug_start\n// bug_end\n \n \tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n \tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n \tMLX5_SET(cqc, cqc, c_eqn, eqn);\n \tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n \tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n \t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n \tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n \n \tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n \tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n \n \terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n \tkvfree(in);\n \n \tif (err)\n \t\tgoto err_cqwq;\n \n \tconn->cq.mcq.cqe_sz     = 64;\n \tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n \tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n \t*conn->cq.mcq.set_ci_db = 0;\n \t*conn->cq.mcq.arm_db    = 0;\n \tconn->cq.mcq.vector     = 0;\n \tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n \tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n \tconn->cq.mcq.irqn       = irqn;\n \tconn->cq.mcq.uar        = fdev->conn_res.uar;\n \ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n \t\t     (unsigned long)conn);\n \n \tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n \n \tgoto out;\n \n err_cqwq:\n \tmlx5_wq_destroy(&conn->cq.wq_ctrl);\n out:\n \treturn err;\n }\n \n", "target": "// fix_start\n\tif (err) {\n\t\tkvfree(in);\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19045", "cve_desc": "A memory leak in the mlx5_fpga_conn_create_cq() function in drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_vector2eqn() failures, aka CID-c8c2a057fdc7.", "project": "linux", "idx": 214909}
{"source": " static int qh_help(int sd, char *buf, unsigned int len)\n {\n \tstruct query_handler *qh = NULL;\n \n// bug_start\n\tif (!*buf || !strcmp(buf, \"help\")) {\n// bug_end\n \t\tnsock_printf_nul(sd,\n \t\t\t\"  help <name>   show help for handler <name>\\n\"\n \t\t\t\"  help list     list registered handlers\\n\");\n \t\treturn 0;\n \t}\n \n \tif (!strcmp(buf, \"list\")) {\n \n \t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n \t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n \t\t}\n \n \t\tnsock_printf(sd, \"%c\", 0);\n \t\treturn 0;\n \t}\n \n \tqh = qh_find_handler(buf);\n \tif (qh == NULL) {\n \n \t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n \n \t} else if (qh->handler(sd, \"help\", 4) > 200) {\n \n \t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n \t}\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif (buf == NULL || !strcmp(buf, \"help\")) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2018-13441", "cve_desc": "qh_help in Nagios Core version 4.4.1 and earlier is prone to a NULL pointer dereference vulnerability, which allows attacker to cause a local denial-of-service condition by sending a crafted payload to the listening UNIX socket.", "project": "nagioscore", "idx": 214948}
{"source": " compileRule(FileInfo *file, TranslationTableHeader **table,\n \t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n \tCharsString token;\n \tTranslationTableOpcode opcode;\n \tCharsString ruleChars;\n \tCharsString ruleDots;\n \tCharsString cells;\n \tCharsString scratchPad;\n \tCharsString emphClass;\n \tTranslationTableCharacterAttributes after = 0;\n \tTranslationTableCharacterAttributes before = 0;\n \tint noback, nofor, nocross;\n \tnoback = nofor = nocross = 0;\n doOpcode:\n \tif (!getToken(file, &token, NULL)) return 1;\n \tif (token.chars[0] == '#' || token.chars[0] == '<') return 1;\n \tif (file->lineNumber == 1 &&\n \t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n \t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n \t\tif (table)\n \t\t\tcompileHyphenation(file, &token, table);\n \t\telse\n \t\t\twhile (_lou_getALine(file))\n \t\t\t\t;\n \t\treturn 1;\n \t}\n \topcode = getOpcode(file, &token);\n \tswitch (opcode) {\n \tcase CTO_Macro: {\n \t\tconst Macro *macro;\n #ifdef ENABLE_MACROS\n \t\tif (!inScopeMacros) {\n \t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n \t\t\treturn 0;\n \t\t}\n \t\tif (compileMacro(file, &macro)) {\n \t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n \t\t\treturn 1;\n \t\t}\n \t\treturn 0;\n #else\n \t\tcompileError(file, \"Macro feature is disabled.\");\n \t\treturn 0;\n #endif\n \t}\n \tcase CTO_IncludeFile: {\n \t\tCharsString includedFile;\n \t\tif (!getToken(file, &token, \"include file name\")) return 0;\n \t\tif (!parseChars(file, &includedFile, &token)) return 0;\n \t\treturn includeFile(file, &includedFile, table, displayTable);\n \t}\n \tcase CTO_NoBack:\n \t\tif (nofor) {\n \t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n \t\t\treturn 0;\n \t\t}\n \t\tnoback = 1;\n \t\tgoto doOpcode;\n \tcase CTO_NoFor:\n \t\tif (noback) {\n \t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n \t\t\treturn 0;\n \t\t}\n \t\tnofor = 1;\n \t\tgoto doOpcode;\n \tcase CTO_Space:\n \t\treturn compileCharDef(\n \t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n \tcase CTO_Digit:\n \t\treturn compileCharDef(\n \t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n \tcase CTO_LitDigit:\n \t\treturn compileCharDef(\n \t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n \tcase CTO_Punctuation:\n \t\treturn compileCharDef(\n \t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n \tcase CTO_Math:\n \t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n \tcase CTO_Sign:\n \t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n \tcase CTO_Letter:\n \t\treturn compileCharDef(\n \t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n \tcase CTO_UpperCase:\n \t\treturn compileCharDef(\n \t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n \tcase CTO_LowerCase:\n \t\treturn compileCharDef(\n \t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n \tcase CTO_Grouping:\n \t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n \tcase CTO_Display:\n \t\tif (!displayTable) return 1;\n \t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n \t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n \t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n \t\t\treturn 0;\n \t\t}\n \t\treturn putCharDotsMapping(\n \t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n \tcase CTO_UpLow:\n \tcase CTO_None: {\n \t\tif (inScopeMacros) {\n \t\t\tconst MacroList *macros = *inScopeMacros;\n \t\t\twhile (macros) {\n \t\t\t\tconst Macro *m = macros->head;\n \t\t\t\tif (token.length == strlen(m->name) &&\n \t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n \t\t\t\t\tif (!inScopeMacros) {\n \t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t\tFileInfo tmpFile;\n \t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n \t\t\t\t\ttmpFile.fileName = file->fileName;\n \t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n \t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n \t\t\t\t\ttmpFile.encoding = noEncoding;\n \t\t\t\t\ttmpFile.status = 0;\n \t\t\t\t\ttmpFile.linepos = 0;\n \t\t\t\t\ttmpFile.linelen = 0;\n \t\t\t\t\tint argument_count = 0;\n \t\t\t\t\tCharsString *arguments =\n \t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n \t\t\t\t\twhile (argument_count < m->argument_count) {\n \t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n \t\t\t\t\t\t\targuments[argument_count++] = token;\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tif (argument_count < m->argument_count) {\n \t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t\tint i = 0;\n \t\t\t\t\tint subst = 0;\n \t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n \t\t\t\t\tfor (;;) {\n \t\t\t\t\t\twhile (i < next) {\n \t\t\t\t\t\t\twidechar c = m->definition[i++];\n \t\t\t\t\t\t\tif (c == '\\n') {\n \t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n \t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n \t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n \t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n \t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n \t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n \t\t\t\t\t\t\t\t\treturn 0;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n \t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n \t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n \t\t\t\t\t\t\t\tcompileError(file,\n \t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n \t\t\t\t\t\t\t\t\t\t\"expansion)\",\n \t\t\t\t\t\t\t\t\t\tMAXSTRING);\n \t\t\t\t\t\t\t\treturn 0;\n \t\t\t\t\t\t\t} else\n \t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (subst < m->substitution_count) {\n \t\t\t\t\t\t\tCharsString arg =\n \t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n \t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n \t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n \t\t\t\t\t\t\tsubst++;\n \t\t\t\t\t\t\tnext = subst < m->substitution_count\n \t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n \t\t\t\t\t\t\t\t\t: m->definition_length;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tif (!compileRule(\n \t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n \t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n \t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n \t\t\t\t\t\t\t\t\t\t_lou_showString(\n \t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n \t\t\t\t\t\t\t\treturn 0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn 1;\n \t\t\t\t}\n \t\t\t\tmacros = macros->tail;\n \t\t\t}\n \t\t}\n \t\tif (opcode == CTO_UpLow) {\n \t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n \t\t\treturn 0;\n \t\t}\n \t\tcompileError(file, \"opcode %s not defined.\",\n \t\t\t\t_lou_showString(token.chars, token.length, 0));\n \t\treturn 0;\n \t}\n \n \tdefault:\n \t\tif (!table) return 1;\n \t\tswitch (opcode) {\n \t\tcase CTO_Locale:\n \t\t\tcompileWarning(file,\n \t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n \t\t\t\t\t\"instead.\");\n \t\t\treturn 1;\n \t\tcase CTO_Undefined: {\n \t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n \t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n \t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\t(*table)->undefined = ruleOffset;\n \t\t\treturn 1;\n \t\t}\n \t\tcase CTO_Match: {\n \t\t\tint ok = 0;\n \t\t\twidechar *patterns = NULL;\n \t\t\tTranslationTableRule *rule;\n \t\t\tTranslationTableOffset ruleOffset;\n \t\t\tCharsString ptn_before, ptn_after;\n \t\t\tTranslationTableOffset patternsOffset;\n \t\t\tint len, mrk;\n \t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n \t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n \t\t\tif (!patterns) _lou_outOfMemory();\n \t\t\tmemset(patterns, 0xffff, patternsByteSize);\n \t\t\tnoback = 1;\n \t\t\tgetCharacters(file, &ptn_before);\n \t\t\tgetRuleCharsText(file, &ruleChars);\n \t\t\tgetCharacters(file, &ptn_after);\n \t\t\tgetRuleDotsPattern(file, &ruleDots);\n \t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n \t\t\t\t\t\t&rule, noback, nofor, table))\n \t\t\t\tgoto CTO_Match_cleanup;\n \t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n \t\t\t\tlen = _lou_pattern_compile(\n \t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n \t\t\telse\n \t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n \t\t\t\t\t\t&patterns[1], 13841, *table, file);\n \t\t\tif (!len) goto CTO_Match_cleanup;\n \t\t\tmrk = patterns[0] = len + 1;\n \t\t\t_lou_pattern_reverse(&patterns[1]);\n \t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n \t\t\t\tlen = _lou_pattern_compile(\n \t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n \t\t\telse\n \t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n \t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n \t\t\tif (!len) goto CTO_Match_cleanup;\n \t\t\tlen += mrk;\n \t\t\tif (!allocateSpaceInTranslationTable(\n \t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n \t\t\t\tgoto CTO_Match_cleanup;\n \t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n \t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n \t\t\trule->patterns = patternsOffset;\n \t\t\tok = 1;\n \t\tCTO_Match_cleanup:\n \t\t\tfree(patterns);\n \t\t\treturn ok;\n \t\t}\n \n \t\tcase CTO_BackMatch: {\n \t\t\tint ok = 0;\n \t\t\twidechar *patterns = NULL;\n \t\t\tTranslationTableRule *rule;\n \t\t\tTranslationTableOffset ruleOffset;\n \t\t\tCharsString ptn_before, ptn_after;\n \t\t\tTranslationTableOffset patternOffset;\n \t\t\tint len, mrk;\n \t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n \t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n \t\t\tif (!patterns) _lou_outOfMemory();\n \t\t\tmemset(patterns, 0xffff, patternsByteSize);\n \t\t\tnofor = 1;\n \t\t\tgetCharacters(file, &ptn_before);\n \t\t\tgetRuleCharsText(file, &ruleChars);\n \t\t\tgetCharacters(file, &ptn_after);\n \t\t\tgetRuleDotsPattern(file, &ruleDots);\n \t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n \t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\tgoto CTO_BackMatch_cleanup;\n \t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n \t\t\t\tlen = _lou_pattern_compile(\n \t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n \t\t\telse\n \t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n \t\t\t\t\t\t&patterns[1], 13841, *table, file);\n \t\t\tif (!len) goto CTO_BackMatch_cleanup;\n \t\t\tmrk = patterns[0] = len + 1;\n \t\t\t_lou_pattern_reverse(&patterns[1]);\n \t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n \t\t\t\tlen = _lou_pattern_compile(\n \t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n \t\t\telse\n \t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n \t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n \t\t\tif (!len) goto CTO_BackMatch_cleanup;\n \t\t\tlen += mrk;\n \t\t\tif (!allocateSpaceInTranslationTable(\n \t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n \t\t\t\tgoto CTO_BackMatch_cleanup;\n \t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n \t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n \t\t\trule->patterns = patternOffset;\n \t\t\tok = 1;\n \t\tCTO_BackMatch_cleanup:\n \t\t\tfree(patterns);\n \t\t\treturn ok;\n \t\t}\n \n \t\tcase CTO_CapsLetter:\n \t\tcase CTO_BegCapsWord:\n \t\tcase CTO_EndCapsWord:\n \t\tcase CTO_BegCaps:\n \t\tcase CTO_EndCaps:\n \t\tcase CTO_BegCapsPhrase:\n \t\tcase CTO_EndCapsPhrase:\n \t\tcase CTO_LenCapsPhrase:\n \t\tcase CTO_ModeLetter:\n \t\tcase CTO_BegModeWord:\n \t\tcase CTO_EndModeWord:\n \t\tcase CTO_BegMode:\n \t\tcase CTO_EndMode:\n \t\tcase CTO_BegModePhrase:\n \t\tcase CTO_EndModePhrase:\n \t\tcase CTO_LenModePhrase: {\n \t\t\tTranslationTableCharacterAttributes mode;\n \t\t\tint i;\n \t\t\tswitch (opcode) {\n \t\t\tcase CTO_CapsLetter:\n \t\t\tcase CTO_BegCapsWord:\n \t\t\tcase CTO_EndCapsWord:\n \t\t\tcase CTO_BegCaps:\n \t\t\tcase CTO_EndCaps:\n \t\t\tcase CTO_BegCapsPhrase:\n \t\t\tcase CTO_EndCapsPhrase:\n \t\t\tcase CTO_LenCapsPhrase:\n \t\t\t\tmode = CTC_UpperCase;\n \t\t\t\ti = 0;\n \t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n \t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n \t\t\t\tif (!characterClass) {\n \t\t\t\t\tcharacterClass =\n \t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n \t\t\t\t\tif (!characterClass) return 0;\n \t\t\t\t}\n \t\t\t\tmode = characterClass->attribute;\n \t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n \t\t\t\t\t\tmode <= CTC_LitDigit) {\n \t\t\t\t\tcompileError(file,\n \t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n \t\t\t\t\t\t\t\"attribute name.\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tif (mode == CTC_UpperCase)\n \t\t\t\t\ti = 0;\n \t\t\t\telse {\n \t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n \t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (i == MAX_MODES) {\n \t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (!(*table)->modes[i].value)\n \t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n \t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n \t\t\tswitch (opcode) {\n \t\t\tcase CTO_BegModePhrase: {\n \t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n \t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n \t\t\t\t\t\t\ttable))\n \t\t\t\t\treturn 0;\n \t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\tcase CTO_EndModePhrase: {\n \t\t\t\tTranslationTableOffset ruleOffset;\n \t\t\t\tswitch (compileBeforeAfter(file)) {\n \t\t\t\tcase 1:\n \t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n \t\t\t\t\t\tcompileError(\n \t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n \t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n \t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n \t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n \t\t\t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n \t\t\t\t\t\t\truleOffset;\n \t\t\t\t\treturn 1;\n \t\t\t\tcase 2:\n \t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n \t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n \t\t\t\t\t\tcompileError(\n \t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n \t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n \t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n \t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n \t\t\t\t\t\t\t\tnofor, table))\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n \t\t\t\t\t\t\truleOffset;\n \t\t\t\t\treturn 1;\n \t\t\t\tdefault:\n \t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tcase CTO_BegMode: {\n \t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n \t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n \t\t\t\t\treturn 0;\n \t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\tcase CTO_EndMode: {\n \t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n \t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n \t\t\t\t\treturn 0;\n \t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\tcase CTO_ModeLetter: {\n \t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n \t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n \t\t\t\t\t\t\ttable))\n \t\t\t\t\treturn 0;\n \t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\tcase CTO_BegModeWord: {\n \t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n \t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n \t\t\t\t\t\t\ttable))\n \t\t\t\t\treturn 0;\n \t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\tcase CTO_EndModeWord: {\n \t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n \t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n \t\t\t\t\t\t\ttable))\n \t\t\t\t\treturn 0;\n \t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\tcase CTO_LenModePhrase:\n \t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n \t\t\t\t\t\t\t   compileNumber(file);\n \t\t\tdefault:\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n \n \t\tcase CTO_EmphClass:\n \t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n \t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tint k, i;\n \t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n \t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n \t\t\ts[k++] = '\\0';\n \t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n \t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n \t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n \t\t\t\t\twarningCount++;\n \t\t\t\t\tfree(s);\n \t\t\t\t\treturn 1;\n \t\t\t\t}\n \t\t\tif (i == MAX_EMPH_CLASSES) {\n \t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n \t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n \t\t\t\terrorCount++;\n \t\t\t\tfree(s);\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tswitch (i) {\n \t\t\tcase 0:\n \t\t\t\tif (strcmp(s, \"italic\") != 0) {\n \t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n \t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n \t\t\t\t\t\t\t\"%s\",\n \t\t\t\t\t\t\ts);\n \t\t\t\t\terrorCount++;\n \t\t\t\t\tfree(s);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase 1:\n \t\t\t\tif (strcmp(s, \"underline\") != 0) {\n \t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n \t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n \t\t\t\t\t\t\t\"got \"\n \t\t\t\t\t\t\t\"%s\",\n \t\t\t\t\t\t\ts);\n \t\t\t\t\terrorCount++;\n \t\t\t\t\tfree(s);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase 2:\n \t\t\t\tif (strcmp(s, \"bold\") != 0) {\n \t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n \t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n \t\t\t\t\t\t\t\"%s\",\n \t\t\t\t\t\t\ts);\n \t\t\t\t\terrorCount++;\n \t\t\t\t\tfree(s);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\t(*table)->emphClassNames[i] = s;\n \t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n \t\t\t\t\t\t<< i,\n \t\t\t\t0, 0x1 << i, i };\n \t\t\treturn 1;\n \t\tcase CTO_EmphLetter:\n \t\tcase CTO_BegEmphWord:\n \t\tcase CTO_EndEmphWord:\n \t\tcase CTO_BegEmph:\n \t\tcase CTO_EndEmph:\n \t\tcase CTO_BegEmphPhrase:\n \t\tcase CTO_EndEmphPhrase:\n \t\tcase CTO_LenEmphPhrase:\n \t\tcase CTO_EmphModeChars:\n \t\tcase CTO_NoEmphChars: {\n \t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n \t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n \t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n \t\t\tint k, i;\n \t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n \t\t\ts[k++] = '\\0';\n \t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n \t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n \t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n \t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n \t\t\t\terrorCount++;\n \t\t\t\tfree(s);\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tint ok = 0;\n \t\t\tswitch (opcode) {\n \t\t\tcase CTO_EmphLetter: {\n \t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n \t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n \t\t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\t\tbreak;\n \t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n \t\t\t\tok = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase CTO_BegEmphWord: {\n \t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n \t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n \t\t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\t\tbreak;\n \t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n \t\t\t\tok = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase CTO_EndEmphWord: {\n \t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n \t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n \t\t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\t\tbreak;\n \t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n \t\t\t\tok = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase CTO_BegEmph: {\n \t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n \t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n \t\t\t\t\tcompileError(file,\n \t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n \t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n \t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n \t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n \t\t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\t\tbreak;\n \t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n \t\t\t\tok = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase CTO_EndEmph: {\n \t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n \t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n \t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n \t\t\t\t\tcompileError(file,\n \t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n \t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n \t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n \t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n \t\t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\t\tbreak;\n \t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n \t\t\t\tok = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase CTO_BegEmphPhrase: {\n \t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n \t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n \t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n \t\t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\t\tbreak;\n \t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n \t\t\t\tok = 1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase CTO_EndEmphPhrase:\n \t\t\t\tswitch (compileBeforeAfter(file)) {\n \t\t\t\tcase 1: {\n \t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n \t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n \t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n \t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n \t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n \t\t\t\t\tok = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase 2: {\n \t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n \t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tTranslationTableOffset ruleOffset =\n \t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n \t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n \t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n \t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n \t\t\t\t\tok = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tdefault:\n \t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase CTO_LenEmphPhrase:\n \t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n \t\t\t\t\tok = 1;\n \t\t\t\tbreak;\n \t\t\tcase CTO_EmphModeChars: {\n \t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n \t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n \t\t\t\tint len;\n \t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n \t\t\t\t\t;\n \t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n \t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tok = 1;\n \t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n \t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n \t\t\t\t\t\tok = 0;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase CTO_NoEmphChars: {\n \t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n \t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n \t\t\t\tint len;\n \t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n \t\t\t\t\t;\n \t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n \t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tok = 1;\n \t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n \t\t\t\t\t\tcompileError(file, \"Character undefined\");\n \t\t\t\t\t\tok = 0;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tdefault:\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tfree(s);\n \t\t\treturn ok;\n \t\t}\n \t\tcase CTO_LetterSign: {\n \t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n \t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n \t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\t(*table)->letterSign = ruleOffset;\n \t\t\treturn 1;\n \t\t}\n \t\tcase CTO_NoLetsignBefore:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n \t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tfor (int k = 0; k < ruleChars.length; k++)\n \t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n \t\t\t\t\t\truleChars.chars[k];\n \t\t\treturn 1;\n \t\tcase CTO_NoLetsign:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n \t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tfor (int k = 0; k < ruleChars.length; k++)\n \t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n \t\t\treturn 1;\n \t\tcase CTO_NoLetsignAfter:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n \t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tfor (int k = 0; k < ruleChars.length; k++)\n \t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n \t\t\t\t\t\truleChars.chars[k];\n \t\t\treturn 1;\n \t\tcase CTO_NumberSign: {\n \t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n \t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n \t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\t(*table)->numberSign = ruleOffset;\n \t\t\treturn 1;\n \t\t}\n \n \t\tcase CTO_NumericModeChars:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!c) {\n \t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n \t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tc->attributes |= CTC_NumericMode;\n \t\t\t\t(*table)->usesNumericMode = 1;\n \t\t\t}\n \t\t\treturn 1;\n \n \t\tcase CTO_MidEndNumericModeChars:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!c) {\n \t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n \t\t\t\t(*table)->usesNumericMode = 1;\n \t\t\t}\n \t\t\treturn 1;\n \n \t\tcase CTO_NumericNoContractChars:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!c) {\n \t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tc->attributes |= CTC_NumericNoContract;\n \t\t\t\t(*table)->usesNumericMode = 1;\n \t\t\t}\n \t\t\treturn 1;\n \n \t\tcase CTO_NoContractSign: {\n \t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n \t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n \t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\t(*table)->noContractSign = ruleOffset;\n \t\t\treturn 1;\n \t\t}\n \t\tcase CTO_SeqDelimiter:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!c) {\n \t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tc->attributes |= CTC_SeqDelimiter;\n \t\t\t\t(*table)->usesSequences = 1;\n \t\t\t}\n \t\t\treturn 1;\n \n \t\tcase CTO_SeqBeforeChars:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!c) {\n \t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tc->attributes |= CTC_SeqBefore;\n \t\t\t}\n \t\t\treturn 1;\n \n \t\tcase CTO_SeqAfterChars:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!c) {\n \t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tc->attributes |= CTC_SeqAfter;\n \t\t\t}\n \t\t\treturn 1;\n \n \t\tcase CTO_SeqAfterPattern:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n \t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tfor (int k = 0; k < ruleChars.length; k++)\n \t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n \t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n \t\t\treturn 1;\n \n \t\tcase CTO_SeqAfterExpression:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n// bug_start\n\t\t\tfor ((*table)->seqAfterExpressionLength = 0;\n\t\t\t\t\t(*table)->seqAfterExpressionLength < ruleChars.length;\n\t\t\t\t\t(*table)->seqAfterExpressionLength++)\n\t\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =\n\t\t\t\t\t\truleChars.chars[(*table)->seqAfterExpressionLength];\n\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;\n// bug_end\n \t\t\treturn 1;\n \n \t\tcase CTO_CapsModeChars:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!c) {\n \t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tc->attributes |= CTC_CapsMode;\n \t\t\t\t(*table)->hasCapsModeChars = 1;\n \t\t\t}\n \t\t\treturn 1;\n \n \t\tcase CTO_BegComp: {\n \t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n \t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n \t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\t(*table)->begComp = ruleOffset;\n \t\t\treturn 1;\n \t\t}\n \t\tcase CTO_EndComp: {\n \t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n \t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n \t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\t(*table)->endComp = ruleOffset;\n \t\t\treturn 1;\n \t\t}\n \t\tcase CTO_NoCross:\n \t\t\tif (nocross) {\n \t\t\t\tcompileError(\n \t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tnocross = 1;\n \t\t\tgoto doOpcode;\n \t\tcase CTO_Syllable:\n \t\t\t(*table)->syllables = 1;\n \t\tcase CTO_Always:\n \t\tcase CTO_LargeSign:\n \t\tcase CTO_WholeWord:\n \t\tcase CTO_PartWord:\n \t\tcase CTO_JoinNum:\n \t\tcase CTO_JoinableWord:\n \t\tcase CTO_LowWord:\n \t\tcase CTO_SuffixableWord:\n \t\tcase CTO_PrefixableWord:\n \t\tcase CTO_BegWord:\n \t\tcase CTO_BegMidWord:\n \t\tcase CTO_MidWord:\n \t\tcase CTO_MidEndWord:\n \t\tcase CTO_EndWord:\n \t\tcase CTO_PrePunc:\n \t\tcase CTO_PostPunc:\n \t\tcase CTO_BegNum:\n \t\tcase CTO_MidNum:\n \t\tcase CTO_EndNum:\n \t\tcase CTO_Repeated:\n \t\tcase CTO_RepWord:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n \t\t\tif (ruleDots.length == 0)\n \t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\t\tTranslationTableCharacter *c =\n \t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n \t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n \t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\tTranslationTableRule *r;\n \t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n \t\t\t\t\t\tnoback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\tif (nocross) r->nocross = 1;\n \t\t\treturn 1;\n \t\tcase CTO_RepEndWord:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tCharsString dots;\n \t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n \t\t\tint len = dots.length;\n \t\t\tfor (int k = 0; k < len - 1; k++) {\n \t\t\t\tif (dots.chars[k] == ',') {\n \t\t\t\t\tdots.length = k;\n \t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n \t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n \t\t\t\t\tk++;\n \t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n \t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n \t\t\t\t\t\t\tTranslationTableCharacter *c =\n \t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n \t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n \t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n \t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n \t\t\t\t\t\t\t\treturn 0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tCharsString x, y;\n \t\t\t\t\t\tx.length = 0;\n \t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n \t\t\t\t\t\tif (parseDots(file, &y, &x))\n \t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n \t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n \t\t\t\t\t}\n \t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n \t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn 0;\n \t\tcase CTO_CompDots:\n \t\tcase CTO_Comp6: {\n \t\t\tTranslationTableOffset ruleOffset;\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (ruleChars.length != 1) {\n \t\t\t\tcompileError(file, \"first operand must be 1 character\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tif (nofor || noback) {\n \t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n \t\t\t}\n \t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n \t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n \t\t\t\t\t\tNULL, noback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\treturn 1;\n \t\t}\n \t\tcase CTO_ExactDots:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (ruleChars.chars[0] != '@') {\n \t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tfor (int k = 1; k < ruleChars.length; k++)\n \t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n \t\t\tscratchPad.length = ruleChars.length - 1;\n \t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n \t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n \t\t\t\t\tnoback, nofor, table);\n \t\tcase CTO_CapsNoCont: {\n \t\t\tTranslationTableOffset ruleOffset;\n \t\t\truleChars.length = 1;\n \t\t\truleChars.chars[0] = 'a';\n \t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n \t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n \t\t\t\treturn 0;\n \t\t\t(*table)->capsNoCont = ruleOffset;\n \t\t\treturn 1;\n \t\t}\n \t\tcase CTO_Replace:\n \t\t\tif (getRuleCharsText(file, &ruleChars)) {\n \t\t\t\tif (atEndOfLine(file))\n \t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n \t\t\t\telse {\n \t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n \t\t\t\t\tif (ruleDots.chars[0] == '#')\n \t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n \t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n \t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n \t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (int k = 0; k < ruleChars.length; k++)\n \t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n \t\t\tfor (int k = 0; k < ruleDots.length; k++)\n \t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n \t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n \t\t\t\t\tnoback, nofor, table);\n \t\tcase CTO_Correct:\n \t\t\t(*table)->corrections = 1;\n \t\t\tgoto doPass;\n \t\tcase CTO_Pass2:\n \t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n \t\t\tgoto doPass;\n \t\tcase CTO_Pass3:\n \t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n \t\t\tgoto doPass;\n \t\tcase CTO_Pass4:\n \t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n \t\tdoPass:\n \t\tcase CTO_Context:\n \t\t\tif (!(nofor || noback)) {\n \t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n \t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n \t\tcase CTO_Contraction:\n \t\tcase CTO_NoCont:\n \t\tcase CTO_CompBrl:\n \t\tcase CTO_Literal:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n \t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n \t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n \t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n \t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n \t\t\t\t\tnoback, nofor, table);\n \t\tcase CTO_MultInd: {\n \t\t\truleChars.length = 0;\n \t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n \t\t\t\t\t!parseDots(file, &cells, &token))\n \t\t\t\treturn 0;\n \t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n \t\t\t\topcode = getOpcode(file, &token);\n \t\t\t\tif (opcode == CTO_None) {\n \t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n \t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n \t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n \t\t\t\tif (atEndOfLine(file)) break;\n \t\t\t}\n \t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n \t\t\t\t\tNULL, noback, nofor, table);\n \t\t}\n \n \t\tcase CTO_Class:\n \t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n \t\tcase CTO_Attribute: {\n \t\t\tif (nofor || noback) {\n \t\t\t\tcompileWarning(\n \t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n \t\t\t}\n \t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n \t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n \t\t\t\tcompileError(file,\n \t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tif (opcode == CTO_Class)\n \t\t\t\t(*table)->usesAttributeOrClass = 2;\n \t\t\telse\n \t\t\t\t(*table)->usesAttributeOrClass = 1;\n \t\t\tif (!getToken(file, &token, \"attribute name\")) {\n \t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n \t\t\t\treturn 0;\n \t\t\t}\n \n \t\t\tTranslationTableCharacterAttributes attribute = 0;\n \t\t\t{\n \t\t\t\tint attrNumber = -1;\n \t\t\t\tswitch (token.chars[0]) {\n \t\t\t\tcase '0':\n \t\t\t\tcase '1':\n \t\t\t\tcase '2':\n \t\t\t\tcase '3':\n \t\t\t\tcase '4':\n \t\t\t\tcase '5':\n \t\t\t\tcase '6':\n \t\t\t\tcase '7':\n \t\t\t\tcase '8':\n \t\t\t\tcase '9':\n \t\t\t\t\tattrNumber = token.chars[0] - '0';\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (attrNumber >= 0) {\n \t\t\t\t\tif (opcode == CTO_Class) {\n \t\t\t\t\t\tcompileError(file,\n \t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n \t\t\t\t\t\t\t\t\"attribute instead of class\");\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n \t\t\t\t\t\tcompileError(file,\n \t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n \t\t\t\t\t\t\t\t\"or a word containing only letters\");\n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n \t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n \t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n \t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n \t\t\t\t} else {\n \t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n \t\t\t\t\tif (!namedAttr) {\n \t\t\t\t\t\tnamedAttr = addCharacterClass(\n \t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n \t\t\t\t\t\tif (!namedAttr) return 0;\n \t\t\t\t\t}\n \t\t\t\t\tattribute = namedAttr->attribute;\n \t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n \t\t\t\t\t\tattribute |= CTC_Letter;\n \t\t\t\t}\n \t\t\t}\n \t\t\tCharsString characters;\n \t\t\tif (!getCharacters(file, &characters)) return 0;\n \t\t\tfor (int i = 0; i < characters.length; i++) {\n \t\t\t\tTranslationTableCharacter *character =\n \t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n \t\t\t\tcharacter->attributes |= attribute;\n \t\t\t\tif (character->basechar)\n \t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n \t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n \t\t\t\tif (character->definitionRule) {\n \t\t\t\t\tTranslationTableRule *defRule =\n \t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n \t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n \t\t\t\t\tif (defRule->dotslen == 1) {\n \t\t\t\t\t\tTranslationTableCharacter *dots =\n \t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n \t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn 1;\n \t\t}\n \n \t\t\t{\n \t\t\t\tTranslationTableCharacterAttributes *attributes;\n \t\t\t\tconst CharacterClass *class;\n \t\t\tcase CTO_After:\n \t\t\t\tattributes = &after;\n \t\t\t\tgoto doBeforeAfter;\n \t\t\tcase CTO_Before:\n \t\t\t\tattributes = &before;\n \t\t\tdoBeforeAfter:\n \t\t\t\tif (!(*table)->characterClasses) {\n \t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n \t\t\t\t}\n \t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n \t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n \t\t\t\t\tcompileError(file, \"attribute not defined\");\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n \t\t\t\t*attributes |= class->attribute;\n \t\t\t\tgoto doOpcode;\n \t\t\t}\n \t\tcase CTO_Base:\n \t\t\tif (nofor || noback) {\n \t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n \t\t\t}\n \t\t\tif (!getToken(file, &token, \"attribute name\")) {\n \t\t\t\tcompileError(\n \t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n \t\t\tif (!mode) {\n \t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n \t\t\t\tif (!mode) return 0;\n \t\t\t}\n \t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n \t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n \t\t\t\tcompileError(file,\n \t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n \t\t\t\t\t\t\"custom attribute name.\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tif (!getRuleCharsText(file, &token)) return 0;\n \t\t\tif (token.length != 1) {\n \t\t\t\tcompileError(file,\n \t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n \t\t\t\t\t\t\"required.\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tTranslationTableOffset characterOffset;\n \t\t\tTranslationTableCharacter *character =\n \t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n \t\t\tif (!getRuleCharsText(file, &token)) return 0;\n \t\t\tif (token.length != 1) {\n \t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tif (character->definitionRule) {\n \t\t\t\tTranslationTableRule *prevRule =\n \t\t\t\t\t\t(TranslationTableRule *)&(*table)\n \t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n \t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n \t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n \t\t\t\t\t\t\"precedence.\",\n \t\t\t\t\t\tfile->fileName, file->lineNumber,\n \t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n \t\t\t\tcharacter->definitionRule = 0;\n \t\t\t}\n \t\t\tTranslationTableOffset basechar;\n \t\t\tputChar(file, token.chars[0], table, &basechar);\n \t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n \t\t\tif (character->basechar) {\n \t\t\t\tif (character->basechar == basechar &&\n \t\t\t\t\t\tcharacter->mode == mode->attribute) {\n \t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n \t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n \t\t\t\t} else {\n \t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n \t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n \t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n \t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n \t\t\t\t\t\t\tprintSource(\n \t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n \t\t\t\t}\n \t\t\t}\n \t\t\tcharacter->basechar = basechar;\n \t\t\tcharacter->mode = mode->attribute;\n \t\t\tcharacter->sourceFile = file->sourceFile;\n \t\t\tcharacter->sourceLine = file->lineNumber;\n \t\t\treturn 1;\n \t\tcase CTO_EmpMatchBefore:\n \t\t\tbefore |= CTC_EmpMatch;\n \t\t\tgoto doOpcode;\n \t\tcase CTO_EmpMatchAfter:\n \t\t\tafter |= CTC_EmpMatch;\n \t\t\tgoto doOpcode;\n \n \t\tcase CTO_SwapCc:\n \t\tcase CTO_SwapCd:\n \t\tcase CTO_SwapDd:\n \t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n \t\tcase CTO_Hyphen:\n \t\tcase CTO_DecPoint:\n \t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n \t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n \t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n \t\t\t\tcompileError(file,\n \t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n \t\t\t\t\t\t\"required.\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n \t\t\t\t\tnoback, nofor, table);\n \t\tdefault:\n \t\t\tcompileError(file, \"unimplemented opcode.\");\n \t\t\treturn 0;\n \t\t}\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\t\tif ((ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqAfterExpression[k] = ruleChars.chars[k];\n\t\t\t(*table)->seqAfterExpression[ruleChars.length] = 0;\n\t\t\t(*table)->seqAfterExpressionLength = ruleChars.length;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-31783", "cve_desc": "Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c, as demonstrated by lou_trace.", "project": "liblouis", "idx": 214997}
{"source": " gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n {\n   GstCaps *caps;\n   guint avail;\n   GstFlowReturn res = GST_FLOW_OK;\n \n   GstFlxDec *flxdec;\n   FlxHeader *flxh;\n \n   g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n   flxdec = (GstFlxDec *) parent;\n   g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n \n   gst_adapter_push (flxdec->adapter, buf);\n   avail = gst_adapter_available (flxdec->adapter);\n \n   if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n     if (avail >= FlxHeaderSize) {\n       const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n       GstCaps *templ;\n \n       memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n       FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n       gst_adapter_unmap (flxdec->adapter);\n       gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n \n       flxh = &flxdec->hdr;\n \n       if (flxh->type != FLX_MAGICHDR_FLI &&\n           flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n         goto wrong_type;\n \n       GST_LOG (\"size      :  %d\", flxh->size);\n       GST_LOG (\"frames    :  %d\", flxh->frames);\n       GST_LOG (\"width     :  %d\", flxh->width);\n       GST_LOG (\"height    :  %d\", flxh->height);\n       GST_LOG (\"depth     :  %d\", flxh->depth);\n       GST_LOG (\"speed     :  %d\", flxh->speed);\n \n       flxdec->next_time = 0;\n \n       if (flxh->type == FLX_MAGICHDR_FLI) {\n         flxdec->frame_time = JIFFIE * flxh->speed;\n       } else if (flxh->speed == 0) {\n         flxdec->frame_time = GST_SECOND / 70;\n       } else {\n         flxdec->frame_time = flxh->speed * GST_MSECOND;\n       }\n \n       flxdec->duration = flxh->frames * flxdec->frame_time;\n       GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n           GST_TIME_ARGS (flxdec->duration));\n \n       templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n       caps = gst_caps_copy (templ);\n       gst_caps_unref (templ);\n       gst_caps_set_simple (caps,\n           \"width\", G_TYPE_INT, flxh->width,\n           \"height\", G_TYPE_INT, flxh->height,\n           \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n           (gint) flxdec->frame_time / 1000, NULL);\n \n       gst_pad_set_caps (flxdec->srcpad, caps);\n       gst_caps_unref (caps);\n \n       if (flxh->depth <= 8)\n         flxdec->converter =\n             flx_colorspace_converter_new (flxh->width, flxh->height);\n \n       if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n         GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n         GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n         GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n         GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n       }\n \n       flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n \n       flxdec->frame_data = g_malloc (flxdec->size);\n       flxdec->delta_data = g_malloc (flxdec->size);\n \n       flxdec->state = GST_FLXDEC_PLAYING;\n     }\n   } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n     GstBuffer *out;\n \n     while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n       FlxFrameChunk flxfh;\n       guchar *chunk;\n       const guint8 *data;\n       GstMapInfo map;\n \n       chunk = NULL;\n       data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n       memcpy (&flxfh, data, FlxFrameChunkSize);\n       FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n       gst_adapter_unmap (flxdec->adapter);\n \n       switch (flxfh.id) {\n         case FLX_FRAME_TYPE:\n           if (avail < flxfh.size)\n             goto need_more_data;\n \n           gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n \n           chunk = gst_adapter_take (flxdec->adapter,\n               flxfh.size - FlxFrameChunkSize);\n           FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n           if (((FlxFrameType *) chunk)->chunks == 0)\n             break;\n \n \n           out = gst_buffer_new_and_alloc (flxdec->size * 4);\n \n           if (!flx_decode_chunks (flxdec,\n                   ((FlxFrameType *) chunk)->chunks,\n                   chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n             GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                 (\"%s\", \"Could not decode chunk\"), NULL);\n             return GST_FLOW_ERROR;\n           }\n \n           memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n \n           gst_buffer_map (out, &map, GST_MAP_WRITE);\n           flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n               map.data);\n           gst_buffer_unmap (out, &map);\n \n           GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n           flxdec->next_time += flxdec->frame_time;\n \n           res = gst_pad_push (flxdec->srcpad, out);\n           break;\n         default:\n           if (avail < flxfh.size)\n             goto need_more_data;\n \n           gst_adapter_flush (flxdec->adapter, flxfh.size);\n           break;\n       }\n \n       g_free (chunk);\n \n       avail = gst_adapter_available (flxdec->adapter);\n     }\n   }\n need_more_data:\n   return res;\n \n wrong_type:\n   {\n     GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n         (\"not a flx file (type %x)\", flxh->type));\n// bug_start\n    gst_object_unref (flxdec);\n// bug_end\n     return GST_FLOW_ERROR;\n   }\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2016-9810", "cve_desc": "The gst_decode_chain_free_internal function in the flxdex decoder in gst-plugins-good in GStreamer before 1.10.2 allows remote attackers to cause a denial of service (invalid memory read and crash) via an invalid file, which triggers an incorrect unref call.", "project": "gst-plugins-good", "idx": 215038}
{"source": " static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n \t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n {\n \tstruct cgroup *cgrp;\n \n \tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n// bug_start\n// bug_end\n \n \tcgrp = cgroup_kn_lock_live(of->kn, false);\n \tif (!cgrp)\n \t\treturn -ENODEV;\n \tspin_lock(&release_agent_path_lock);\n \tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n \t\tsizeof(cgrp->root->release_agent_path));\n \tspin_unlock(&release_agent_path_lock);\n \tcgroup_kn_unlock(of->kn);\n \treturn nbytes;\n }\n \n", "target": "// fix_start\n\n\tif ((of->file->f_cred->user_ns != &init_user_ns) ||\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "cve": "CVE-2022-0492", "cve_desc": "A vulnerability was found in the Linux kernel\u2019s cgroup_release_agent_write in the kernel/cgroup/cgroup-v1.c function. This flaw, under certain circumstances, allows the use of the cgroups v1 release_agent feature to escalate privileges and bypass the namespace isolation unexpectedly.", "project": "linux", "idx": 215073}
{"source": " createRandomCursorExecutor(const CollectionPtr& coll,\n                            const boost::intrusive_ptr<ExpressionContext>& expCtx,\n                            long long sampleSize,\n                            long long numRecords,\n                            boost::optional<BucketUnpacker> bucketUnpacker) {\n     OperationContext* opCtx = expCtx->opCtx;\n \n     invariant(opCtx->lockState()->isCollectionLockedForMode(coll->ns(), MODE_IS));\n \n     static const double kMaxSampleRatioForRandCursor = 0.05;\n     if (!expCtx->ns.isTimeseriesBucketsCollection()) {\n         if (sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100) {\n             return std::pair{nullptr, false};\n         }\n     } else {\n         static const double kCoefficient = 0.01;\n         if (sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount) {\n             return std::pair{nullptr, false};\n         }\n     }\n \n     auto rsRandCursor = coll->getRecordStore()->getRandomCursor(opCtx);\n     if (!rsRandCursor) {\n         return std::pair{nullptr, false};\n     }\n \n     auto ws = std::make_unique<WorkingSet>();\n     std::unique_ptr<PlanStage> root =\n         std::make_unique<MultiIteratorStage>(expCtx.get(), ws.get(), coll);\n     static_cast<MultiIteratorStage*>(root.get())->addIterator(std::move(rsRandCursor));\n \n// bug_start\n    auto collectionFilter =\n        CollectionShardingState::get(opCtx, coll->ns())\n            ->getOwnershipFilter(\n                opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);\n\n// bug_end\n     TrialStage* trialStage = nullptr;\n \n     static const size_t kMaxPresampleSize = 100;\n// bug_start\n    if (collectionFilter.isSharded() && !expCtx->ns.isTimeseriesBucketsCollection()) {\n// bug_end\n         const auto minAdvancedToWorkRatio = std::max(\n             sampleSize / (numRecords * kMaxSampleRatioForRandCursor), kMaxSampleRatioForRandCursor);\n// bug_start\n// bug_end\n         auto randomCursorPlan = std::make_unique<ShardFilterStage>(\n             expCtx.get(), collectionFilter, ws.get(), std::move(root));\n         std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n         collScanPlan = std::make_unique<ShardFilterStage>(\n             expCtx.get(), collectionFilter, ws.get(), std::move(collScanPlan));\n         root = std::make_unique<TrialStage>(expCtx.get(),\n                                             ws.get(),\n                                             std::move(randomCursorPlan),\n                                             std::move(collScanPlan),\n                                             kMaxPresampleSize,\n                                             minAdvancedToWorkRatio);\n         trialStage = static_cast<TrialStage*>(root.get());\n     } else if (expCtx->ns.isTimeseriesBucketsCollection()) {\n         static const auto kCoefficient = 0.02;\n         static const auto kMinBucketFullness = 0.25;\n         const auto minAdvancedToWorkRatio = std::max(\n             std::min(sampleSize / (kCoefficient * numRecords * gTimeseriesBucketMaxCount), 1.0),\n             kMinBucketFullness);\n \n         auto arhashPlan = std::make_unique<SampleFromTimeseriesBucket>(\n             expCtx.get(),\n             ws.get(),\n             std::move(root),\n             *bucketUnpacker,\n             kMaxPresampleSize + 5,\n             sampleSize,\n             gTimeseriesBucketMaxCount);\n \n         std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n \n         auto topkSortPlan = std::make_unique<UnpackTimeseriesBucket>(\n             expCtx.get(), ws.get(), std::move(collScanPlan), *bucketUnpacker);\n \n         root = std::make_unique<TrialStage>(expCtx.get(),\n                                             ws.get(),\n                                             std::move(arhashPlan),\n                                             std::move(topkSortPlan),\n                                             kMaxPresampleSize,\n                                             minAdvancedToWorkRatio);\n         trialStage = static_cast<TrialStage*>(root.get());\n     }\n \n     auto execStatus = plan_executor_factory::make(expCtx,\n                                                   std::move(ws),\n                                                   std::move(root),\n                                                   &coll,\n                                                   opCtx->inMultiDocumentTransaction()\n                                                       ? PlanYieldPolicy::YieldPolicy::INTERRUPT_ONLY\n                                                       : PlanYieldPolicy::YieldPolicy::YIELD_AUTO,\n                                                   QueryPlannerParams::RETURN_OWNED_DATA);\n     if (!execStatus.isOK()) {\n         return execStatus.getStatus();\n     }\n \n     return std::pair{std::move(execStatus.getValue()),\n                      !trialStage || !trialStage->pickedBackupPlan()};\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    if (auto css = CollectionShardingState::get(opCtx, coll->ns());\n        css->getCollectionDescription(opCtx).isSharded() &&\n        !expCtx->ns.isTimeseriesBucketsCollection()) {\n// fix_end\n// fix_start\n        auto collectionFilter = css->getOwnershipFilter(\n            opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2021-32037", "cve_desc": "An authorized user may trigger an invariant which may result in denial of service or server exit if a relevant aggregation request is sent to a shard. Usually, the requests are sent via mongos and special privileges are required in order to know the address of the shards and to log in to the shards of an auth enabled environment.", "project": "mongo", "idx": 215103}
{"source": " setup_secureChannel(void) {\n     TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n     UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n     UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n \n// bug_start\n    testingConnection = createDummyConnection(65535, &sentData);\n// bug_end\n     UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n     testChannel.connection = &testingConnection;\n \n     testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n }\n \n", "target": "// fix_start\n    testingConnection =\n        createDummyConnection(UA_ConnectionConfig_default.sendBufferSize, &sentData);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-25761", "cve_desc": "The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before 1.3.1 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk.", "project": "open62541", "idx": 215142}
{"source": " void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n     size_t aoffset = (size_t) abs(offset);\n     unsigned char *source = buf->data + buf->offset;\n     if (offset >= 0) {\n         if (buf->offset + aoffset + len > buf->maxlen) {\n             debug_print(\"%s\", \"End of buffer\\n\");\n             buf->error = MOBI_BUFFER_END;\n             return;\n         }\n         source += aoffset;\n     } else {\n// bug_start\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n// bug_end\n             buf->error = MOBI_BUFFER_END;\n             return;\n         }\n         source -= aoffset;\n     }\n     memmove(buf->data + buf->offset, source, len);\n     buf->offset += len;\n }\n \n", "target": "// fix_start\n        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {\n            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-3751", "cve_desc": "libmobi is vulnerable to Out-of-bounds Write", "project": "libmobi", "idx": 215188}
{"source": " static void gem_transmit(CadenceGEMState *s)\n {\n     uint32_t desc[DESC_MAX_NUM_WORDS];\n     hwaddr packet_desc_addr;\n     uint8_t     *p;\n     unsigned    total_bytes;\n     int q = 0;\n \n     if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n         return;\n     }\n \n     DB_PRINT(\"\\n\");\n \n     p = s->tx_packet;\n     total_bytes = 0;\n \n     for (q = s->num_priority_queues - 1; q >= 0; q--) {\n         packet_desc_addr = gem_get_tx_desc_addr(s, q);\n \n         DB_PRINT(\"read descriptor 0x%\" HWADDR_PRIx \"\\n\", packet_desc_addr);\n         address_space_read(&s->dma_as, packet_desc_addr,\n                            MEMTXATTRS_UNSPECIFIED, desc,\n                            sizeof(uint32_t) * gem_get_desc_len(s, false));\n         while (tx_desc_get_used(desc) == 0) {\n \n             if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n                 return;\n             }\n             print_gem_tx_desc(desc, q);\n \n             if ((tx_desc_get_buffer(s, desc) == 0) ||\n                 (tx_desc_get_length(desc) == 0)) {\n                 DB_PRINT(\"Invalid TX descriptor @ 0x%\" HWADDR_PRIx \"\\n\",\n                          packet_desc_addr);\n                 break;\n             }\n \n             if (tx_desc_get_length(desc) > gem_get_max_buf_len(s, true) -\n                                                (p - s->tx_packet)) {\n                 qemu_log_mask(LOG_GUEST_ERROR, \"TX descriptor @ 0x%\" \\\n                          HWADDR_PRIx \" too large: size 0x%x space 0x%zx\\n\",\n                          packet_desc_addr, tx_desc_get_length(desc),\n                          gem_get_max_buf_len(s, true) - (p - s->tx_packet));\n                 gem_set_isr(s, q, GEM_INT_AMBA_ERR);\n                 break;\n             }\n \n             address_space_read(&s->dma_as, tx_desc_get_buffer(s, desc),\n                                MEMTXATTRS_UNSPECIFIED,\n                                p, tx_desc_get_length(desc));\n             p += tx_desc_get_length(desc);\n             total_bytes += tx_desc_get_length(desc);\n \n             if (tx_desc_get_last(desc)) {\n                 uint32_t desc_first[DESC_MAX_NUM_WORDS];\n                 hwaddr desc_addr = gem_get_tx_desc_addr(s, q);\n \n                 address_space_read(&s->dma_as, desc_addr,\n                                    MEMTXATTRS_UNSPECIFIED, desc_first,\n                                    sizeof(desc_first));\n                 tx_desc_set_used(desc_first);\n                 address_space_write(&s->dma_as, desc_addr,\n                                     MEMTXATTRS_UNSPECIFIED, desc_first,\n                                     sizeof(desc_first));\n                 if (tx_desc_get_wrap(desc)) {\n                     s->tx_desc_addr[q] = gem_get_tx_queue_base_addr(s, q);\n                 } else {\n                     s->tx_desc_addr[q] = packet_desc_addr +\n                                          4 * gem_get_desc_len(s, false);\n                 }\n                 DB_PRINT(\"TX descriptor next: 0x%08x\\n\", s->tx_desc_addr[q]);\n \n                 s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_TXCMPL;\n                 gem_set_isr(s, q, GEM_INT_TXCMPL);\n \n                 gem_update_int_status(s);\n \n                 if (s->regs[GEM_DMACFG] & GEM_DMACFG_TXCSUM_OFFL) {\n                     net_checksum_calculate(s->tx_packet, total_bytes, CSUM_ALL);\n                 }\n \n                 gem_transmit_updatestats(s, s->tx_packet, total_bytes);\n \n                 if (s->phy_loop || (s->regs[GEM_NWCTRL] &\n                                     GEM_NWCTRL_LOCALLOOP)) {\n// bug_start\n                    gem_receive(qemu_get_queue(s->nic), s->tx_packet,\n                                total_bytes);\n// bug_end\n                 } else {\n                     qemu_send_packet(qemu_get_queue(s->nic), s->tx_packet,\n                                      total_bytes);\n                 }\n \n                 p = s->tx_packet;\n                 total_bytes = 0;\n             }\n \n             if (tx_desc_get_wrap(desc)) {\n \n                 if (s->regs[GEM_DMACFG] & GEM_DMACFG_ADDR_64B) {\n                     packet_desc_addr = s->regs[GEM_TBQPH];\n                     packet_desc_addr <<= 32;\n                 } else {\n                     packet_desc_addr = 0;\n                 }\n                 packet_desc_addr |= gem_get_tx_queue_base_addr(s, q);\n             } else {\n                 packet_desc_addr += 4 * gem_get_desc_len(s, false);\n             }\n             DB_PRINT(\"read descriptor 0x%\" HWADDR_PRIx \"\\n\", packet_desc_addr);\n             address_space_read(&s->dma_as, packet_desc_addr,\n                                MEMTXATTRS_UNSPECIFIED, desc,\n                                sizeof(uint32_t) * gem_get_desc_len(s, false));\n         }\n \n         if (tx_desc_get_used(desc)) {\n             s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_USED;\n             if (q == 0) {\n                 gem_set_isr(s, 0, GEM_INT_TXUSED);\n             }\n             gem_update_int_status(s);\n         }\n     }\n }\n \n", "target": "// fix_start\n                    qemu_receive_packet(qemu_get_queue(s->nic), s->tx_packet,\n                                        total_bytes);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "project": "qemu", "idx": 215262}
{"source": " STATIC SSize_t\n S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                         SSize_t *minlenp, SSize_t *deltap,\n \t\t\tregnode *last,\n \t\t\tscan_data_t *data,\n \t\t\tI32 stopparen,\n                         U32 recursed_depth,\n \t\t\tregnode_ssc *and_withp,\n// bug_start\n\t\t\tU32 flags, U32 depth)\n// bug_end\n {\n     dVAR;\n     SSize_t min = 0;\n     I32 pars = 0, code;\n     regnode *scan = *scanp, *next;\n     SSize_t delta = 0;\n     int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n     int is_inf_internal = 0;\n     I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n     scan_data_t data_fake;\n     SV *re_trie_maxbuff = NULL;\n     regnode *first_non_open = scan;\n     SSize_t stopmin = SSize_t_MAX;\n     scan_frame *frame = NULL;\n     GET_RE_DEBUG_FLAGS_DECL;\n \n     PERL_ARGS_ASSERT_STUDY_CHUNK;\n     RExC_study_started= 1;\n \n     Zero(&data_fake, 1, scan_data_t);\n \n     if ( depth == 0 ) {\n         while (first_non_open && OP(first_non_open) == OPEN)\n             first_non_open=regnext(first_non_open);\n     }\n \n \n   fake_study_recurse:\n     DEBUG_r(\n         RExC_study_chunk_recursed_count++;\n     );\n     DEBUG_OPTIMISE_MORE_r(\n     {\n         Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n             depth, (long)stopparen,\n             (unsigned long)RExC_study_chunk_recursed_count,\n             (unsigned long)depth, (unsigned long)recursed_depth,\n             scan,\n             last);\n         if (recursed_depth) {\n             U32 i;\n             U32 j;\n             for ( j = 0 ; j < recursed_depth ; j++ ) {\n                 for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                     if (\n                         PAREN_TEST(RExC_study_chunk_recursed +\n                                    ( j * RExC_study_chunk_recursed_bytes), i )\n                         && (\n                             !j ||\n                             !PAREN_TEST(RExC_study_chunk_recursed +\n                                    (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                         )\n                     ) {\n                         Perl_re_printf( aTHX_ \" %d\",(int)i);\n                         break;\n                     }\n                 }\n                 if ( j + 1 < recursed_depth ) {\n                     Perl_re_printf( aTHX_  \",\");\n                 }\n             }\n         }\n         Perl_re_printf( aTHX_ \"\\n\");\n     }\n     );\n     while ( scan && OP(scan) != END && scan < last ){\n         UV min_subtract = 0;\n \tbool unfolded_multi_char = FALSE;\n// bug_start\n// bug_end\n         DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n         DEBUG_PEEP(\"Peep\", scan, depth, flags);\n \n \n// bug_start\n        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n// bug_end\n \n         rck_elide_nothing(scan);\n \n         if ( OP(scan) == DEFINEP ) {\n             SSize_t minlen = 0;\n             SSize_t deltanext = 0;\n             SSize_t fake_last_close = 0;\n             I32 f = SCF_IN_DEFINE;\n \n             StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n             scan = regnext(scan);\n             assert( OP(scan) == IFTHEN );\n             DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n \n             data_fake.last_closep= &fake_last_close;\n             minlen = *minlenp;\n             next = regnext(scan);\n             scan = NEXTOPER(NEXTOPER(scan));\n             DEBUG_PEEP(\"scan\", scan, depth, flags);\n             DEBUG_PEEP(\"next\", next, depth, flags);\n \n             (void)study_chunk(pRExC_state, &scan, &minlen,\n                               &deltanext, next, &data_fake, stopparen,\n// bug_start\n                              recursed_depth, NULL, f, depth+1);\n// bug_end\n \n             scan = next;\n         } else\n         if (\n             OP(scan) == BRANCH  ||\n             OP(scan) == BRANCHJ ||\n             OP(scan) == IFTHEN\n         ) {\n \t    next = regnext(scan);\n \t    code = OP(scan);\n \n \t    if (OP(next) == code || code == IFTHEN) {\n \t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n \t\tregnode_ssc accum;\n \t\tregnode * const startbranch=scan;\n \n                 if (flags & SCF_DO_SUBSTR) {\n                     scan_commit(pRExC_state, data, minlenp, is_inf);\n                 }\n \n                 if (flags & SCF_DO_STCLASS)\n \t\t    ssc_init_zero(pRExC_state, &accum);\n \n \t\twhile (OP(scan) == code) {\n \t\t    SSize_t deltanext, minnext, fake;\n \t\t    I32 f = 0;\n \t\t    regnode_ssc this_class;\n \n                     DEBUG_PEEP(\"Branch\", scan, depth, flags);\n \n \t\t    num++;\n                     StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n \t\t    if (data) {\n \t\t\tdata_fake.whilem_c = data->whilem_c;\n \t\t\tdata_fake.last_closep = data->last_closep;\n \t\t    }\n \t\t    else\n \t\t\tdata_fake.last_closep = &fake;\n \n \t\t    data_fake.pos_delta = delta;\n \t\t    next = regnext(scan);\n \n                     scan = NEXTOPER(scan);\n                     if (code != BRANCH)\n \t\t\tscan = NEXTOPER(scan);\n \n \t\t    if (flags & SCF_DO_STCLASS) {\n \t\t\tssc_init(pRExC_state, &this_class);\n \t\t\tdata_fake.start_class = &this_class;\n \t\t\tf = SCF_DO_STCLASS_AND;\n \t\t    }\n \t\t    if (flags & SCF_WHILEM_VISITED_POS)\n \t\t\tf |= SCF_WHILEM_VISITED_POS;\n \n \t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                       &deltanext, next, &data_fake, stopparen,\n// bug_start\n                                      recursed_depth, NULL, f, depth+1);\n// bug_end\n \n \t\t    if (min1 > minnext)\n \t\t\tmin1 = minnext;\n \t\t    if (deltanext == SSize_t_MAX) {\n \t\t\tis_inf = is_inf_internal = 1;\n \t\t\tmax1 = SSize_t_MAX;\n \t\t    } else if (max1 < minnext + deltanext)\n \t\t\tmax1 = minnext + deltanext;\n \t\t    scan = next;\n \t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n \t\t\tpars++;\n \t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n \t                if ( stopmin > minnext)\n \t                    stopmin = min + min1;\n \t                flags &= ~SCF_DO_SUBSTR;\n \t                if (data)\n \t                    data->flags |= SCF_SEEN_ACCEPT;\n \t            }\n \t\t    if (data) {\n \t\t\tif (data_fake.flags & SF_HAS_EVAL)\n \t\t\t    data->flags |= SF_HAS_EVAL;\n \t\t\tdata->whilem_c = data_fake.whilem_c;\n \t\t    }\n \t\t    if (flags & SCF_DO_STCLASS)\n \t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n \t\t}\n \t\tif (code == IFTHEN && num < 2)\n \t\t    min1 = 0;\n \t\tif (flags & SCF_DO_SUBSTR) {\n \t\t    data->pos_min += min1;\n \t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n \t\t        data->pos_delta = SSize_t_MAX;\n \t\t    else\n \t\t        data->pos_delta += max1 - min1;\n \t\t    if (max1 != min1 || is_inf)\n \t\t\tdata->cur_is_floating = 1;\n \t\t}\n \t\tmin += min1;\n \t\tif (delta == SSize_t_MAX\n \t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n \t\t    delta = SSize_t_MAX;\n \t\telse\n \t\t    delta += max1 - min1;\n \t\tif (flags & SCF_DO_STCLASS_OR) {\n \t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n \t\t    if (min1) {\n \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n \t\t\tflags &= ~SCF_DO_STCLASS;\n \t\t    }\n \t\t}\n \t\telse if (flags & SCF_DO_STCLASS_AND) {\n \t\t    if (min1) {\n \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n \t\t\tflags &= ~SCF_DO_STCLASS;\n \t\t    }\n \t\t    else {\n \t\t\tINIT_AND_WITHP;\n \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n \t\t\tflags &= ~SCF_DO_STCLASS_AND;\n \t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n \t\t\tflags |= SCF_DO_STCLASS_OR;\n \t\t    }\n \t\t}\n \n// bug_start\n                if (PERL_ENABLE_TRIE_OPTIMISATION &&\n                        OP( startbranch ) == BRANCH )\n                {\n// bug_end\n \n \t\t    int made=0;\n \t\t    if (!re_trie_maxbuff) {\n \t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n \t\t\tif (!SvIOK(re_trie_maxbuff))\n \t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n \t\t    }\n                     if ( SvIV(re_trie_maxbuff)>=0  ) {\n                         regnode *cur;\n                         regnode *first = (regnode *)NULL;\n                         regnode *last = (regnode *)NULL;\n                         regnode *tail = scan;\n                         U8 trietype = 0;\n                         U32 count=0;\n \n \n                         while ( OP( tail ) == TAIL ) {\n                             tail = regnext( tail );\n                         }\n \n \n                         DEBUG_TRIE_COMPILE_r({\n                             regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                             Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                               depth+1,\n                               \"Looking for TRIE'able sequences. Tail node is \",\n                               (UV) REGNODE_OFFSET(tail),\n                               SvPV_nolen_const( RExC_mysv )\n                             );\n                         });\n \n #define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                        ? NOTHING                                            \\\n                        : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\n                          ? EXACT                                            \\\n                          : (     EXACTFU == (X)                             \\\n                               || EXACTFU_ONLY8 == (X)                       \\\n                               || EXACTFUP == (X) )                          \\\n                            ? EXACTFU                                        \\\n                            : ( EXACTFAA == (X) )                            \\\n                              ? EXACTFAA                                     \\\n                              : ( EXACTL == (X) )                            \\\n                                ? EXACTL                                     \\\n                                : ( EXACTFLU8 == (X) )                       \\\n                                  ? EXACTFLU8                                \\\n                                  : 0 )\n \n                         for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                             regnode * const noper = NEXTOPER( cur );\n                             U8 noper_type = OP( noper );\n                             U8 noper_trietype = TRIE_TYPE( noper_type );\n #if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                             regnode * const noper_next = regnext( noper );\n                             U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                             U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n #endif\n \n                             DEBUG_TRIE_COMPILE_r({\n                                 regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                 Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                    depth+1,\n                                    REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n \n                                 regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                 Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                     REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n \n                                 if ( noper_next ) {\n                                   regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                   Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                     REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                 }\n                                 Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                    REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n \t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n \t\t\t\t);\n                             });\n \n                             if ( noper_trietype\n                                   &&\n                                   (\n                                         ( noper_trietype == NOTHING )\n                                         || ( trietype == NOTHING )\n                                         || ( trietype == noper_trietype )\n                                   )\n #ifdef NOJUMPTRIE\n                                   && noper_next >= tail\n #endif\n                                   && count < U16_MAX)\n                             {\n                                 if ( !first ) {\n                                     first = cur;\n \t\t\t\t    if ( noper_trietype == NOTHING ) {\n #if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n \t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                         U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n \t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n #endif\n \n                                         if ( noper_next_trietype ) {\n \t\t\t\t\t    trietype = noper_next_trietype;\n                                         } else if (noper_next_type)  {\n                                             first = NULL;\n                                         }\n                                     } else {\n                                         trietype = noper_trietype;\n                                     }\n                                 } else {\n                                     if ( trietype == NOTHING )\n                                         trietype = noper_trietype;\n                                     last = cur;\n                                 }\n \t\t\t\tif (first)\n \t\t\t\t    count++;\n                             }\n                             else {\n                                 if ( last ) {\n                                     if ( trietype && trietype != NOTHING )\n                                         make_trie( pRExC_state,\n                                                 startbranch, first, cur, tail,\n                                                 count, trietype, depth+1 );\n                                     last = NULL;\n                                 }\n                                 if ( noper_trietype\n #ifdef NOJUMPTRIE\n                                      && noper_next >= tail\n #endif\n                                 ){\n                                     count = 1;\n                                     first = cur;\n                                     trietype = noper_trietype;\n                                 } else if (first) {\n                                     count = 0;\n                                     first = NULL;\n                                     trietype = 0;\n                                 }\n                             }\n                         }\n                         DEBUG_TRIE_COMPILE_r({\n                             regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                             Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                               depth+1, SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                             Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                                REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                                PL_reg_name[trietype]\n                             );\n \n                         });\n                         if ( last && trietype ) {\n                             if ( trietype != NOTHING ) {\n                                 made= make_trie( pRExC_state, startbranch,\n                                                  first, scan, tail, count,\n                                                  trietype, depth+1 );\n #ifdef TRIE_STUDY_OPT\n                                 if ( ((made == MADE_EXACT_TRIE &&\n                                      startbranch == first)\n                                      || ( first_non_open == first )) &&\n                                      depth==0 ) {\n                                     flags |= SCF_TRIE_RESTUDY;\n                                     if ( startbranch == first\n                                          && scan >= tail )\n                                     {\n                                         RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                     }\n                                 }\n #endif\n                             } else {\n                                 if ( startbranch == first ) {\n                                     regnode *opt;\n                                     DEBUG_TRIE_COMPILE_r({\n                                         regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                         Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                           depth+1,\n                                           SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n \n                                     });\n                                     OP(startbranch)= NOTHING;\n                                     NEXT_OFF(startbranch)= tail - startbranch;\n                                     for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                         OP(opt)= OPTIMIZED;\n                                 }\n                             }\n                         }\n                     }\n \n                 }\n \n \t    }\n \t    else if ( code == BRANCHJ ) {\n \t\tscan = NEXTOPER(NEXTOPER(scan));\n \t    } else\n \t\tscan = NEXTOPER(scan);\n \t    continue;\n         } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n             I32 paren = 0;\n             regnode *start = NULL;\n             regnode *end = NULL;\n             U32 my_recursed_depth= recursed_depth;\n \n             if (OP(scan) != SUSPEND) {\n                 paren = ARG(scan);\n                 RExC_recurse[ARG2L(scan)] = scan;\n                 start = REGNODE_p(RExC_open_parens[paren]);\n                 end   = REGNODE_p(RExC_close_parens[paren]);\n \n                 if (\n                     ( flags & SCF_IN_DEFINE )\n                     ||\n                     (\n                         (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                         &&\n                         ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                     )\n                 ) {\n                     scan= regnext(scan);\n                     continue;\n                 }\n \n                 if (\n                     !recursed_depth\n                     ||\n                     !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                 ) {\n                     if (!recursed_depth) {\n                         Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                     } else {\n                         Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                              RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                              RExC_study_chunk_recursed_bytes, U8);\n                     }\n                     DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                     PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                     my_recursed_depth= recursed_depth + 1;\n                 } else {\n                     DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                     if (flags & SCF_DO_SUBSTR) {\n                         scan_commit(pRExC_state, data, minlenp, is_inf);\n                         data->cur_is_floating = 1;\n                     }\n                     is_inf = is_inf_internal = 1;\n                     if (flags & SCF_DO_STCLASS_OR)\n                         ssc_anything(data->start_class);\n                     flags &= ~SCF_DO_STCLASS;\n \n                     start= NULL;\n \t        }\n             } else {\n \t        paren = stopparen;\n                 start = scan + 2;\n \t        end = regnext(scan);\n \t    }\n             if (start) {\n                 scan_frame *newframe;\n                 assert(end);\n                 if (!RExC_frame_last) {\n                     Newxz(newframe, 1, scan_frame);\n                     SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                     RExC_frame_head= newframe;\n                     RExC_frame_count++;\n                 } else if (!RExC_frame_last->next_frame) {\n                     Newxz(newframe, 1, scan_frame);\n                     RExC_frame_last->next_frame= newframe;\n                     newframe->prev_frame= RExC_frame_last;\n                     RExC_frame_count++;\n                 } else {\n                     newframe= RExC_frame_last->next_frame;\n                 }\n                 RExC_frame_last= newframe;\n \n                 newframe->next_regnode = regnext(scan);\n                 newframe->last_regnode = last;\n                 newframe->stopparen = stopparen;\n                 newframe->prev_recursed_depth = recursed_depth;\n                 newframe->this_prev_frame= frame;\n// bug_start\n// bug_end\n \n                 DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                 DEBUG_PEEP(\"fnew\", scan, depth, flags);\n \n \t        frame = newframe;\n \t        scan =  start;\n \t        stopparen = paren;\n \t        last = end;\n                 depth = depth + 1;\n                 recursed_depth= my_recursed_depth;\n \n \t        continue;\n \t    }\n \t}\n \telse if (   OP(scan) == EXACT\n                  || OP(scan) == EXACT_ONLY8\n                  || OP(scan) == EXACTL)\n         {\n \t    SSize_t l = STR_LEN(scan);\n \t    UV uc;\n             assert(l);\n \t    if (UTF) {\n \t\tconst U8 * const s = (U8*)STRING(scan);\n \t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n \t\tl = utf8_length(s, s + l);\n \t    } else {\n \t\tuc = *((U8*)STRING(scan));\n \t    }\n \t    min += l;\n \t    if (flags & SCF_DO_SUBSTR) {\n \t\tif (data->last_end == -1) {\n \t\t    data->last_start_min = data->pos_min;\n  \t\t    data->last_start_max = is_inf\n  \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n \t\t}\n \t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n \t\tif (UTF)\n \t\t    SvUTF8_on(data->last_found);\n \t\t{\n \t\t    SV * const sv = data->last_found;\n \t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n \t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n \t\t    if (mg && mg->mg_len >= 0)\n \t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                               (U8*)STRING(scan)+STR_LEN(scan));\n \t\t}\n \t\tdata->last_end = data->pos_min + l;\n \t\tdata->pos_min += l;\n \t\tdata->flags &= ~SF_BEFORE_EOL;\n \t    }\n \n \t    if (flags & SCF_DO_STCLASS_AND) {\n                 ssc_cp_and(data->start_class, uc);\n                 ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                 ssc_clear_locale(data->start_class);\n \t    }\n \t    else if (flags & SCF_DO_STCLASS_OR) {\n                 ssc_add_cp(data->start_class, uc);\n \t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n \n                 ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n \t    }\n \t    flags &= ~SCF_DO_STCLASS;\n \t}\n         else if (PL_regkind[OP(scan)] == EXACT) {\n \t    SSize_t l = STR_LEN(scan);\n             const U8 * s = (U8*)STRING(scan);\n \n \t    if (flags & SCF_DO_SUBSTR) {\n \t\tassert(data);\n                 scan_commit(pRExC_state, data, minlenp, is_inf);\n \t    }\n \t    if (UTF) {\n \t\tl = utf8_length(s, s + l);\n \t    }\n \t    if (unfolded_multi_char) {\n                 RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n \t    }\n \t    min += l - min_subtract;\n             assert (min >= 0);\n             delta += min_subtract;\n \t    if (flags & SCF_DO_SUBSTR) {\n \t\tdata->pos_min += l - min_subtract;\n \t\tif (data->pos_min < 0) {\n                     data->pos_min = 0;\n                 }\n                 data->pos_delta += min_subtract;\n \t\tif (min_subtract) {\n \t\t    data->cur_is_floating = 1;\n \t\t}\n \t    }\n \n             if (flags & SCF_DO_STCLASS) {\n                 SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n \n                 assert(EXACTF_invlist);\n                 if (flags & SCF_DO_STCLASS_AND) {\n                     if (OP(scan) != EXACTFL)\n                         ssc_clear_locale(data->start_class);\n                     ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                     ANYOF_POSIXL_ZERO(data->start_class);\n                     ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                 }\n                 else {\n                     ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n \n                     ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                 }\n                 flags &= ~SCF_DO_STCLASS;\n                 SvREFCNT_dec(EXACTF_invlist);\n             }\n \t}\n \telse if (REGNODE_VARIES(OP(scan))) {\n \t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n \t    I32 fl = 0, f = flags;\n \t    regnode * const oscan = scan;\n \t    regnode_ssc this_class;\n \t    regnode_ssc *oclass = NULL;\n \t    I32 next_is_eval = 0;\n \n \t    switch (PL_regkind[OP(scan)]) {\n \t    case WHILEM:\n \t\tscan = NEXTOPER(scan);\n \t\tgoto finish;\n \t    case PLUS:\n \t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n \t\t    next = NEXTOPER(scan);\n \t\t    if (   OP(next) == EXACT\n                         || OP(next) == EXACT_ONLY8\n                         || OP(next) == EXACTL\n                         || (flags & SCF_DO_STCLASS))\n                     {\n \t\t\tmincount = 1;\n \t\t\tmaxcount = REG_INFTY;\n \t\t\tnext = regnext(scan);\n \t\t\tscan = NEXTOPER(scan);\n \t\t\tgoto do_curly;\n \t\t    }\n \t\t}\n \t\tif (flags & SCF_DO_SUBSTR)\n \t\t    data->pos_min++;\n \t\tmin++;\n \t    case STAR:\n                 next = NEXTOPER(scan);\n \n// bug_start\n                if (OP(next) == EXACTFU_S_EDGE) {\n// bug_end\n                     OP(next) = EXACTFU;\n                 }\n \n                 if (     STR_LEN(next) == 1\n                     &&   isALPHA_A(* STRING(next))\n                     && (         OP(next) == EXACTFAA\n                         || (     OP(next) == EXACTFU\n// bug_start\n                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next)))))\n                {\n// bug_end\n                     U8 mask = ~ ('A' ^ 'a');\n \n                     assert(isALPHA_A(* STRING(next)));\n \n                     OP(next) = ANYOFM;\n                     ARG_SET(next, *STRING(next) & mask);\n                     FLAGS(next) = mask;\n                 }\n \n \t\tif (flags & SCF_DO_STCLASS) {\n \t\t    mincount = 0;\n \t\t    maxcount = REG_INFTY;\n \t\t    next = regnext(scan);\n \t\t    scan = NEXTOPER(scan);\n \t\t    goto do_curly;\n \t\t}\n \t\tif (flags & SCF_DO_SUBSTR) {\n                     scan_commit(pRExC_state, data, minlenp, is_inf);\n \t\t    data->cur_is_floating = 1;\n \t\t}\n                 is_inf = is_inf_internal = 1;\n                 scan = regnext(scan);\n \t\tgoto optimize_curly_tail;\n \t    case CURLY:\n \t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n \t            && (scan->flags == stopparen))\n \t\t{\n \t\t    mincount = 1;\n \t\t    maxcount = 1;\n \t\t} else {\n \t\t    mincount = ARG1(scan);\n \t\t    maxcount = ARG2(scan);\n \t\t}\n \t\tnext = regnext(scan);\n \t\tif (OP(scan) == CURLYX) {\n \t\t    I32 lp = (data ? *(data->last_closep) : 0);\n \t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n \t\t}\n \t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n \t\tnext_is_eval = (OP(scan) == EVAL);\n \t      do_curly:\n \t\tif (flags & SCF_DO_SUBSTR) {\n                     if (mincount == 0)\n                         scan_commit(pRExC_state, data, minlenp, is_inf);\n \t\t    pos_before = data->pos_min;\n \t\t}\n \t\tif (data) {\n \t\t    fl = data->flags;\n \t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n \t\t    if (is_inf)\n \t\t\tdata->flags |= SF_IS_INF;\n \t\t}\n \t\tif (flags & SCF_DO_STCLASS) {\n \t\t    ssc_init(pRExC_state, &this_class);\n \t\t    oclass = data->start_class;\n \t\t    data->start_class = &this_class;\n \t\t    f |= SCF_DO_STCLASS_AND;\n \t\t    f &= ~SCF_DO_STCLASS_OR;\n \t\t}\n                if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n \t\t    f &= ~SCF_WHILEM_VISITED_POS;\n \n \t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                   last, data, stopparen, recursed_depth, NULL,\n                                   (mincount == 0\n                                    ? (f & ~SCF_DO_SUBSTR)\n                                    : f)\n// bug_start\n                                  ,depth+1);\n// bug_end\n \n \t\tif (flags & SCF_DO_STCLASS)\n \t\t    data->start_class = oclass;\n \t\tif (mincount == 0 || minnext == 0) {\n \t\t    if (flags & SCF_DO_STCLASS_OR) {\n \t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n \t\t    }\n \t\t    else if (flags & SCF_DO_STCLASS_AND) {\n \t\t\tINIT_AND_WITHP;\n \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n \t\t\tflags &= ~SCF_DO_STCLASS_AND;\n \t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n \t\t\tflags |= SCF_DO_STCLASS_OR;\n                         ANYOF_FLAGS(data->start_class)\n                                                 |= SSC_MATCHES_EMPTY_STRING;\n \t\t    }\n \t\t} else {\n \t\t    if (flags & SCF_DO_STCLASS_OR) {\n \t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n \t\t    }\n \t\t    else if (flags & SCF_DO_STCLASS_AND)\n \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n \t\t    flags &= ~SCF_DO_STCLASS;\n \t\t}\n \t\tif (!scan)\n \t\t    scan = next;\n \t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n \t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n \t\t    && (minnext == 0) && (deltanext == 0)\n \t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                     && maxcount <= REG_INFTY/3)\n \t\t{\n \t\t    _WARN_HELPER(RExC_precomp_end, packWARN(WARN_REGEXP),\n                         Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n                             \"Quantifier unexpected on zero-length expression \"\n                             \"in regex m/%\" UTF8f \"/\",\n \t\t\t     UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n \t\t\t\t  RExC_precomp)));\n                 }\n \n                 if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext )\n                     || min >= SSize_t_MAX - minnext * mincount )\n                 {\n                     FAIL(\"Regexp out of space\");\n                 }\n \n \t\tmin += minnext * mincount;\n \t\tis_inf_internal |= deltanext == SSize_t_MAX\n                          || (maxcount == REG_INFTY && minnext + deltanext > 0);\n \t\tis_inf |= is_inf_internal;\n                 if (is_inf) {\n \t\t    delta = SSize_t_MAX;\n                 } else {\n \t\t    delta += (minnext + deltanext) * maxcount\n                              - minnext * mincount;\n                 }\n \t\tif (  OP(oscan) == CURLYX && data\n \t\t      && data->flags & SF_IN_PAR\n \t\t      && !(data->flags & SF_HAS_EVAL)\n// bug_start\n\t\t      && !deltanext && minnext == 1 ) {\n// bug_end\n \t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n \t\t    regnode * const nxt1 = nxt;\n #ifdef DEBUGGING\n \t\t    regnode *nxt2;\n #endif\n \n \t\t    nxt = regnext(nxt);\n \t\t    if (!REGNODE_SIMPLE(OP(nxt))\n \t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n \t\t\t     && STR_LEN(nxt) == 1))\n \t\t\tgoto nogo;\n #ifdef DEBUGGING\n \t\t    nxt2 = nxt;\n #endif\n \t\t    nxt = regnext(nxt);\n \t\t    if (OP(nxt) != CLOSE)\n \t\t\tgoto nogo;\n \t\t    if (RExC_open_parens) {\n \n                         RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n \n                         RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n \t\t    }\n \t\t    oscan->flags = (U8)ARG(nxt);\n \t\t    OP(oscan) = CURLYN;\n \t\t    OP(nxt1) = NOTHING;\n \n #ifdef DEBUGGING\n \t\t    OP(nxt1 + 1) = OPTIMIZED;\n \t\t    NEXT_OFF(nxt1+ 1) = 0;\n \t\t    NEXT_OFF(nxt2) = 0;\n \t\t    OP(nxt) = OPTIMIZED;\n \t\t    OP(nxt + 1) = OPTIMIZED;\n \t\t    NEXT_OFF(nxt+ 1) = 0;\n #endif\n \t\t}\n \t      nogo:\n \n \t\tif (  OP(oscan) == CURLYX && data\n \t\t      && !(data->flags & SF_HAS_PAR)\n \t\t      && !(data->flags & SF_HAS_EVAL)\n \t\t      && !deltanext\n \t\t      && minnext != 0\n// bug_start\n\n// bug_end\n                       && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n// bug_start\n// bug_end\n \t\t) {\n \t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n \t\t    regnode *nxt2;\n \n \t\t    OP(oscan) = CURLYM;\n \t\t    while ( (nxt2 = regnext(nxt))\n \t\t\t    && (OP(nxt2) != WHILEM))\n \t\t\tnxt = nxt2;\n \t\t    OP(nxt2)  = SUCCEED;\n \t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n \t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n \n \t\t\toscan->flags = (U8)ARG(nxt);\n \t\t\tif (RExC_open_parens) {\n                             RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n \n                             RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt2)\n                                                          + 1;\n \t\t\t}\n \t\t\tOP(nxt1) = OPTIMIZED;\n \t\t\tOP(nxt) = OPTIMIZED;\n \n #ifdef DEBUGGING\n \t\t\tOP(nxt1 + 1) = OPTIMIZED;\n \t\t\tOP(nxt + 1) = OPTIMIZED;\n \t\t\tNEXT_OFF(nxt1 + 1) = 0;\n \t\t\tNEXT_OFF(nxt + 1) = 0;\n #endif\n #if 0\n \t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n \t\t\t    regnode *nnxt = regnext(nxt1);\n \t\t\t    if (nnxt == nxt) {\n \t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n \t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n \t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n \t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n \t\t\t\telse\n \t\t\t\t    OP(nxt) = NOTHING;\n \t\t\t    }\n \t\t\t    nxt1 = nnxt;\n \t\t\t}\n #endif\n \t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                     NULL, stopparen, recursed_depth, NULL, 0,\n// bug_start\n                                    depth+1);\n// bug_end\n \t\t    }\n \t\t    else\n \t\t\toscan->flags = 0;\n \t\t}\n \t\telse if ((OP(oscan) == CURLYX)\n \t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n \t\t\t && (maxcount == REG_INFTY)\n \t\t\t && data) {\n \t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n \n \t\t    if (OP(PREVOPER(nxt)) == NOTHING)\n \t\t\tnxt += ARG(nxt);\n                     nxt = PREVOPER(nxt);\n                     if (nxt->flags & 0xf) {\n                     } else if (++data->whilem_c < 16) {\n                         assert(data->whilem_c <= RExC_whilem_seen);\n                         nxt->flags = (U8)(data->whilem_c\n                             | (RExC_whilem_seen << 4));\n                     }\n \t\t}\n \t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n \t\t    pars++;\n \t\tif (flags & SCF_DO_SUBSTR) {\n \t\t    SV *last_str = NULL;\n                     STRLEN last_chrs = 0;\n \t\t    int counted = mincount != 0;\n \n                     if (data->last_end > 0 && mincount != 0) {\n \t\t\tSSize_t b = pos_before >= data->last_start_min\n \t\t\t    ? pos_before : data->last_start_min;\n \t\t\tSTRLEN l;\n \t\t\tconst char * const s = SvPV_const(data->last_found, l);\n \t\t\tSSize_t old = b - data->last_start_min;\n                         assert(old >= 0);\n \n \t\t\tif (UTF)\n \t\t\t    old = utf8_hop_forward((U8*)s, old,\n                                                (U8 *) SvEND(data->last_found))\n                                 - (U8*)s;\n \t\t\tl -= old;\n \t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                         last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                             (U8*)(s + old + l)) : l;\n \t\t\tif (deltanext == 0 && pos_before == b) {\n \t\t\t    if (mincount > 1) {\n \n \t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n \t\t\t\trepeatcpy(SvPVX(last_str) + l,\n \t\t\t\t\t  SvPVX_const(last_str), l,\n                                           mincount - 1);\n \t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n \t\t\t\tSvCUR_set(data->last_found,\n \t\t\t\t\t  SvCUR(data->last_found) - l);\n \t\t\t\tsv_catsv(data->last_found, last_str);\n \t\t\t\t{\n \t\t\t\t    SV * sv = data->last_found;\n \t\t\t\t    MAGIC *mg =\n \t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n \t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n \t\t\t\t    if (mg && mg->mg_len >= 0)\n \t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n \t\t\t\t}\n                                 last_chrs *= mincount;\n \t\t\t\tdata->last_end += l * (mincount - 1);\n \t\t\t    }\n \t\t\t} else {\n \t\t\t    data->last_start_min += minnext * (mincount - 1);\n \t\t\t    data->last_start_max =\n                               is_inf\n                                ? SSize_t_MAX\n \t\t\t       : data->last_start_max +\n                                  (maxcount - 1) * (minnext + data->pos_delta);\n \t\t\t}\n \t\t    }\n \t\t    data->pos_min += minnext * (mincount - counted);\n #if 0\n Perl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                               \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                               \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n     (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n     (UV)mincount);\n if (deltanext != SSize_t_MAX)\n Perl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n     (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n           - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n #endif\n \t\t    if (deltanext == SSize_t_MAX\n                         || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n \t\t        data->pos_delta = SSize_t_MAX;\n \t\t    else\n \t\t        data->pos_delta += - counted * deltanext +\n \t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n \t\t    if (mincount != maxcount) {\n                         scan_commit(pRExC_state, data, minlenp, is_inf);\n \t\t\tif (mincount && last_str) {\n \t\t\t    SV * const sv = data->last_found;\n \t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n \t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n \n \t\t\t    if (mg)\n \t\t\t\tmg->mg_len = -1;\n \t\t\t    sv_setsv(sv, last_str);\n \t\t\t    data->last_end = data->pos_min;\n \t\t\t    data->last_start_min = data->pos_min - last_chrs;\n \t\t\t    data->last_start_max = is_inf\n \t\t\t\t? SSize_t_MAX\n \t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n \t\t\t}\n \t\t\tdata->cur_is_floating = 1;\n \t\t    }\n \t\t    SvREFCNT_dec(last_str);\n \t\t}\n \t\tif (data && (fl & SF_HAS_EVAL))\n \t\t    data->flags |= SF_HAS_EVAL;\n \t      optimize_curly_tail:\n \t\trck_elide_nothing(oscan);\n \t\tcontinue;\n \n \t    default:\n #ifdef DEBUGGING\n                 Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                     OP(scan));\n #endif\n             case REF:\n             case CLUMP:\n \t\tif (flags & SCF_DO_SUBSTR) {\n                     scan_commit(pRExC_state, data, minlenp, is_inf);\n \t\t    data->cur_is_floating = 1;\n \t\t}\n \t\tis_inf = is_inf_internal = 1;\n \t\tif (flags & SCF_DO_STCLASS_OR) {\n                     if (OP(scan) == CLUMP) {\n                         ssc_match_all_cp(data->start_class);\n                     }\n                     else {\n                         ssc_anything(data->start_class);\n                     }\n                 }\n \t\tflags &= ~SCF_DO_STCLASS;\n \t\tbreak;\n \t    }\n \t}\n \telse if (OP(scan) == LNBREAK) {\n \t    if (flags & SCF_DO_STCLASS) {\n     \t        if (flags & SCF_DO_STCLASS_AND) {\n                     ssc_intersection(data->start_class,\n                                     PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                     ssc_clear_locale(data->start_class);\n                     ANYOF_FLAGS(data->start_class)\n                                                 &= ~SSC_MATCHES_EMPTY_STRING;\n                 }\n                 else if (flags & SCF_DO_STCLASS_OR) {\n                     ssc_union(data->start_class,\n                               PL_XPosix_ptrs[_CC_VERTSPACE],\n                               FALSE);\n \t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n \n                     ANYOF_FLAGS(data->start_class)\n                                                 &= ~SSC_MATCHES_EMPTY_STRING;\n                 }\n \t\tflags &= ~SCF_DO_STCLASS;\n             }\n \t    min++;\n             if (delta != SSize_t_MAX)\n                 delta++;\n             if (flags & SCF_DO_SUBSTR) {\n                 scan_commit(pRExC_state, data, minlenp, is_inf);\n     \t        data->pos_min += 1;\n                 if (data->pos_delta != SSize_t_MAX) {\n                     data->pos_delta += 1;\n                 }\n \t\tdata->cur_is_floating = 1;\n     \t    }\n \t}\n \telse if (REGNODE_SIMPLE(OP(scan))) {\n \n \t    if (flags & SCF_DO_SUBSTR) {\n                 scan_commit(pRExC_state, data, minlenp, is_inf);\n \t\tdata->pos_min++;\n \t    }\n \t    min++;\n \t    if (flags & SCF_DO_STCLASS) {\n                 bool invert = 0;\n                 SV* my_invlist = NULL;\n                 U8 namedclass;\n \n                 ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n \n \t\tswitch (OP(scan)) {\n \n \t\tdefault:\n #ifdef DEBUGGING\n                    Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                      OP(scan));\n #endif\n \t\tcase SANY:\n \t\t    if (flags & SCF_DO_STCLASS_OR)\n \t\t\tssc_match_all_cp(data->start_class);\n \t\t    break;\n \n \t\tcase REG_ANY:\n                     {\n                         SV* REG_ANY_invlist = _new_invlist(2);\n                         REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                             '\\n');\n                         if (flags & SCF_DO_STCLASS_OR) {\n                             ssc_union(data->start_class,\n                                       REG_ANY_invlist,\n                                       TRUE\n                                       );\n                         }\n                         else if (flags & SCF_DO_STCLASS_AND) {\n                             ssc_intersection(data->start_class,\n                                              REG_ANY_invlist,\n                                              TRUE\n                                              );\n                             ssc_clear_locale(data->start_class);\n                         }\n                         SvREFCNT_dec_NN(REG_ANY_invlist);\n \t\t    }\n \t\t    break;\n \n                 case ANYOFD:\n                 case ANYOFL:\n                 case ANYOFPOSIXL:\n                 case ANYOFH:\n                 case ANYOF:\n \t\t    if (flags & SCF_DO_STCLASS_AND)\n \t\t\tssc_and(pRExC_state, data->start_class,\n                                 (regnode_charclass *) scan);\n \t\t    else\n \t\t\tssc_or(pRExC_state, data->start_class,\n                                                           (regnode_charclass *) scan);\n \t\t    break;\n \n                 case NANYOFM:\n                 case ANYOFM:\n                   {\n                     SV* cp_list = get_ANYOFM_contents(scan);\n \n                     if (flags & SCF_DO_STCLASS_OR) {\n                         ssc_union(data->start_class, cp_list, invert);\n                     }\n                     else if (flags & SCF_DO_STCLASS_AND) {\n                         ssc_intersection(data->start_class, cp_list, invert);\n                     }\n \n                     SvREFCNT_dec_NN(cp_list);\n                     break;\n                   }\n \n \t\tcase NPOSIXL:\n                     invert = 1;\n \n \t\tcase POSIXL:\n                     namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                     if (flags & SCF_DO_STCLASS_AND) {\n                         bool was_there = cBOOL(\n                                           ANYOF_POSIXL_TEST(data->start_class,\n                                                                  namedclass));\n                         ANYOF_POSIXL_ZERO(data->start_class);\n                         if (was_there) {\n                             ANYOF_POSIXL_SET(data->start_class, namedclass);\n                         }\n                         data->start_class->invlist\n                                                 = sv_2mortal(_new_invlist(0));\n                     }\n                     else {\n                         int complement = namedclass + ((invert) ? -1 : 1);\n \n                         assert(flags & SCF_DO_STCLASS_OR);\n \n                         if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                             ssc_match_all_cp(data->start_class);\n                             ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                             ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                         }\n                         else {\n                             ANYOF_POSIXL_SET(data->start_class, namedclass);\n                         }\n                     }\n                     break;\n \n                 case NPOSIXA:\n                     invert = 1;\n \t\tcase POSIXA:\n                     my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n                     goto join_posix_and_ascii;\n \n \t\tcase NPOSIXD:\n \t\tcase NPOSIXU:\n                     invert = 1;\n \t\tcase POSIXD:\n \t\tcase POSIXU:\n                     my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)], NULL);\n \n                     if (OP(scan) == NPOSIXD) {\n                         _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                           &my_invlist);\n                     }\n \n                   join_posix_and_ascii:\n \n                     if (flags & SCF_DO_STCLASS_AND) {\n                         ssc_intersection(data->start_class, my_invlist, invert);\n                         ssc_clear_locale(data->start_class);\n                     }\n                     else {\n                         assert(flags & SCF_DO_STCLASS_OR);\n                         ssc_union(data->start_class, my_invlist, invert);\n                     }\n                     SvREFCNT_dec(my_invlist);\n \t\t}\n \t\tif (flags & SCF_DO_STCLASS_OR)\n \t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n \t\tflags &= ~SCF_DO_STCLASS;\n \t    }\n \t}\n \telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n \t    data->flags |= (OP(scan) == MEOL\n \t\t\t    ? SF_BEFORE_MEOL\n \t\t\t    : SF_BEFORE_SEOL);\n             scan_commit(pRExC_state, data, minlenp, is_inf);\n \n \t}\n \telse if (  PL_regkind[OP(scan)] == BRANCHJ\n \t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n \t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n         {\n             if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                 || OP(scan) == UNLESSM )\n             {\n \n                 SSize_t deltanext, minnext, fake = 0;\n                 regnode *nscan;\n                 regnode_ssc intrnl;\n                 int f = 0;\n \n                 StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                 if (data) {\n                     data_fake.whilem_c = data->whilem_c;\n                     data_fake.last_closep = data->last_closep;\n \t\t}\n                 else\n                     data_fake.last_closep = &fake;\n \t\tdata_fake.pos_delta = delta;\n                 if ( flags & SCF_DO_STCLASS && !scan->flags\n                      && OP(scan) == IFMATCH ) {\n                     ssc_init(pRExC_state, &intrnl);\n                     data_fake.start_class = &intrnl;\n                     f |= SCF_DO_STCLASS_AND;\n \t\t}\n                 if (flags & SCF_WHILEM_VISITED_POS)\n                     f |= SCF_WHILEM_VISITED_POS;\n                 next = regnext(scan);\n                 nscan = NEXTOPER(NEXTOPER(scan));\n \n                 minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                       last, &data_fake, stopparen,\n// bug_start\n                                      recursed_depth, NULL, f, depth+1);\n// bug_end\n                 if (scan->flags) {\n                     if (   deltanext < 0\n                         || deltanext > (I32) U8_MAX\n                         || minnext > (I32)U8_MAX\n                         || minnext + deltanext > (I32)U8_MAX)\n                     {\n \t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                               (UV)U8_MAX);\n                     }\n \n                     if (deltanext) {\n                         scan->next_off = deltanext;\n                         ckWARNexperimental(RExC_parse,\n                             WARN_EXPERIMENTAL__VLB,\n                             \"Variable length lookbehind is experimental\");\n                     }\n                     scan->flags = (U8)minnext + deltanext;\n                 }\n                 if (data) {\n                     if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                         pars++;\n                     if (data_fake.flags & SF_HAS_EVAL)\n                         data->flags |= SF_HAS_EVAL;\n                     data->whilem_c = data_fake.whilem_c;\n                 }\n                 if (f & SCF_DO_STCLASS_AND) {\n \t\t    if (flags & SCF_DO_STCLASS_OR) {\n \t\t\tssc_init(pRExC_state, data->start_class);\n \t\t    }  else {\n \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                         ANYOF_FLAGS(data->start_class)\n                                                    |= SSC_MATCHES_EMPTY_STRING;\n \t\t    }\n                 }\n \t    }\n #if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n             else {\n                 SSize_t deltanext, fake = 0;\n                 regnode *nscan;\n                 regnode_ssc intrnl;\n                 int f = 0;\n                 SSize_t *minnextp;\n                 Newx( minnextp, 1, SSize_t );\n                 SAVEFREEPV(minnextp);\n \n                 if (data) {\n                     StructCopy(data, &data_fake, scan_data_t);\n                     if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                         f |= SCF_DO_SUBSTR;\n                         if (scan->flags)\n                             scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                         data_fake.last_found=newSVsv(data->last_found);\n                     }\n                 }\n                 else\n                     data_fake.last_closep = &fake;\n                 data_fake.flags = 0;\n                 data_fake.substrs[0].flags = 0;\n                 data_fake.substrs[1].flags = 0;\n \t\tdata_fake.pos_delta = delta;\n                 if (is_inf)\n \t            data_fake.flags |= SF_IS_INF;\n                 if ( flags & SCF_DO_STCLASS && !scan->flags\n                      && OP(scan) == IFMATCH ) {\n                     ssc_init(pRExC_state, &intrnl);\n                     data_fake.start_class = &intrnl;\n                     f |= SCF_DO_STCLASS_AND;\n                 }\n                 if (flags & SCF_WHILEM_VISITED_POS)\n                     f |= SCF_WHILEM_VISITED_POS;\n                 next = regnext(scan);\n                 nscan = NEXTOPER(NEXTOPER(scan));\n \n                 *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                         &deltanext, last, &data_fake,\n                                         stopparen, recursed_depth, NULL,\n// bug_start\n                                        f, depth+1);\n// bug_end\n                 if (scan->flags) {\n                     assert(0);\n                     if (   deltanext < 0\n                         || deltanext > (I32) U8_MAX\n                         || *minnextp > (I32)U8_MAX\n                         || *minnextp + deltanext > (I32)U8_MAX)\n                     {\n \t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                               (UV)U8_MAX);\n                     }\n \n                     if (deltanext) {\n                         scan->next_off = deltanext;\n                     }\n                     scan->flags = (U8)*minnextp + deltanext;\n                 }\n \n                 *minnextp += min;\n \n                 if (f & SCF_DO_STCLASS_AND) {\n                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                     ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                 }\n                 if (data) {\n                     if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                         pars++;\n                     if (data_fake.flags & SF_HAS_EVAL)\n                         data->flags |= SF_HAS_EVAL;\n                     data->whilem_c = data_fake.whilem_c;\n                     if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                         int i;\n                         if (RExC_rx->minlen<*minnextp)\n                             RExC_rx->minlen=*minnextp;\n                         scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                         SvREFCNT_dec_NN(data_fake.last_found);\n \n                         for (i = 0; i < 2; i++) {\n                             if (data_fake.substrs[i].minlenp != minlenp) {\n                                 data->substrs[i].min_offset =\n                                             data_fake.substrs[i].min_offset;\n                                 data->substrs[i].max_offset =\n                                             data_fake.substrs[i].max_offset;\n                                 data->substrs[i].minlenp =\n                                             data_fake.substrs[i].minlenp;\n                                 data->substrs[i].lookbehind += scan->flags;\n                             }\n                         }\n                     }\n                 }\n \t    }\n #endif\n \t}\n \n \telse if (OP(scan) == OPEN) {\n \t    if (stopparen != (I32)ARG(scan))\n \t        pars++;\n \t}\n \telse if (OP(scan) == CLOSE) {\n \t    if (stopparen == (I32)ARG(scan)) {\n \t        break;\n \t    }\n \t    if ((I32)ARG(scan) == is_par) {\n \t\tnext = regnext(scan);\n \n \t\tif ( next && (OP(next) != WHILEM) && next < last)\n \t\t    is_par = 0;\n \t    }\n \t    if (data)\n \t\t*(data->last_closep) = ARG(scan);\n \t}\n \telse if (OP(scan) == EVAL) {\n \t\tif (data)\n \t\t    data->flags |= SF_HAS_EVAL;\n \t}\n \telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n \t    if (flags & SCF_DO_SUBSTR) {\n                 scan_commit(pRExC_state, data, minlenp, is_inf);\n \t\tflags &= ~SCF_DO_SUBSTR;\n \t    }\n \t    if (data && OP(scan)==ACCEPT) {\n \t        data->flags |= SCF_SEEN_ACCEPT;\n \t        if (stopmin > min)\n \t            stopmin = min;\n \t    }\n \t}\n \telse if (OP(scan) == LOGICAL && scan->flags == 2)\n \t{\n \t\tif (flags & SCF_DO_SUBSTR) {\n                     scan_commit(pRExC_state, data, minlenp, is_inf);\n \t\t    data->cur_is_floating = 1;\n \t\t}\n \t\tis_inf = is_inf_internal = 1;\n \t\tif (flags & SCF_DO_STCLASS_OR)\n \t\t    ssc_anything(data->start_class);\n \t\tflags &= ~SCF_DO_STCLASS;\n \t}\n \telse if (OP(scan) == GPOS) {\n             if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n \t        !(delta || is_inf || (data && data->pos_delta)))\n \t    {\n                 if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                     RExC_rx->intflags |= PREGf_ANCH_GPOS;\n \t        if (RExC_rx->gofs < (STRLEN)min)\n \t\t    RExC_rx->gofs = min;\n             } else {\n                 RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                 RExC_rx->gofs = 0;\n             }\n \t}\n #ifdef TRIE_STUDY_OPT\n #ifdef FULL_TRIE_STUDY\n         else if (PL_regkind[OP(scan)] == TRIE) {\n             regnode *trie_node= scan;\n             regnode *tail= regnext(scan);\n             reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n             SSize_t max1 = 0, min1 = SSize_t_MAX;\n             regnode_ssc accum;\n \n             if (flags & SCF_DO_SUBSTR) {\n                 scan_commit(pRExC_state, data, minlenp, is_inf);\n             }\n             if (flags & SCF_DO_STCLASS)\n                 ssc_init_zero(pRExC_state, &accum);\n \n             if (!trie->jump) {\n                 min1= trie->minlen;\n                 max1= trie->maxlen;\n             } else {\n                 const regnode *nextbranch= NULL;\n                 U32 word;\n \n                 for ( word=1 ; word <= trie->wordcount ; word++)\n                 {\n                     SSize_t deltanext=0, minnext=0, f = 0, fake;\n                     regnode_ssc this_class;\n \n                     StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                     if (data) {\n                         data_fake.whilem_c = data->whilem_c;\n                         data_fake.last_closep = data->last_closep;\n                     }\n                     else\n                         data_fake.last_closep = &fake;\n \t\t    data_fake.pos_delta = delta;\n                     if (flags & SCF_DO_STCLASS) {\n                         ssc_init(pRExC_state, &this_class);\n                         data_fake.start_class = &this_class;\n                         f = SCF_DO_STCLASS_AND;\n                     }\n                     if (flags & SCF_WHILEM_VISITED_POS)\n                         f |= SCF_WHILEM_VISITED_POS;\n \n                     if (trie->jump[word]) {\n                         if (!nextbranch)\n                             nextbranch = trie_node + trie->jump[0];\n                         scan= trie_node + trie->jump[word];\n                         minnext = study_chunk(pRExC_state, &scan, minlenp,\n                             &deltanext, (regnode *)nextbranch, &data_fake,\n// bug_start\n                            stopparen, recursed_depth, NULL, f, depth+1);\n// bug_end\n                     }\n                     if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                         nextbranch= regnext((regnode*)nextbranch);\n \n                     if (min1 > (SSize_t)(minnext + trie->minlen))\n                         min1 = minnext + trie->minlen;\n                     if (deltanext == SSize_t_MAX) {\n                         is_inf = is_inf_internal = 1;\n                         max1 = SSize_t_MAX;\n                     } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                         max1 = minnext + deltanext + trie->maxlen;\n \n                     if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                         pars++;\n                     if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                         if ( stopmin > min + min1)\n \t                    stopmin = min + min1;\n \t                flags &= ~SCF_DO_SUBSTR;\n \t                if (data)\n \t                    data->flags |= SCF_SEEN_ACCEPT;\n \t            }\n                     if (data) {\n                         if (data_fake.flags & SF_HAS_EVAL)\n                             data->flags |= SF_HAS_EVAL;\n                         data->whilem_c = data_fake.whilem_c;\n                     }\n                     if (flags & SCF_DO_STCLASS)\n                         ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                 }\n             }\n             if (flags & SCF_DO_SUBSTR) {\n                 data->pos_min += min1;\n                 data->pos_delta += max1 - min1;\n                 if (max1 != min1 || is_inf)\n                     data->cur_is_floating = 1;\n             }\n             min += min1;\n             if (delta != SSize_t_MAX) {\n                 if (SSize_t_MAX - (max1 - min1) >= delta)\n                     delta += max1 - min1;\n                 else\n                     delta = SSize_t_MAX;\n             }\n             if (flags & SCF_DO_STCLASS_OR) {\n                 ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                 if (min1) {\n                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                     flags &= ~SCF_DO_STCLASS;\n                 }\n             }\n             else if (flags & SCF_DO_STCLASS_AND) {\n                 if (min1) {\n                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                     flags &= ~SCF_DO_STCLASS;\n                 }\n                 else {\n \t\t    INIT_AND_WITHP;\n                     StructCopy(data->start_class, and_withp, regnode_ssc);\n                     flags &= ~SCF_DO_STCLASS_AND;\n                     StructCopy(&accum, data->start_class, regnode_ssc);\n                     flags |= SCF_DO_STCLASS_OR;\n                 }\n             }\n             scan= tail;\n             continue;\n         }\n #else\n \telse if (PL_regkind[OP(scan)] == TRIE) {\n \t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n \t    U8*bang=NULL;\n \n \t    min += trie->minlen;\n \t    delta += (trie->maxlen - trie->minlen);\n \t    flags &= ~SCF_DO_STCLASS;\n             if (flags & SCF_DO_SUBSTR) {\n                 scan_commit(pRExC_state, data, minlenp, is_inf);\n     \t        data->pos_min += trie->minlen;\n     \t        data->pos_delta += (trie->maxlen - trie->minlen);\n \t\tif (trie->maxlen != trie->minlen)\n \t\t    data->cur_is_floating = 1;\n     \t    }\n     \t    if (trie->jump)\n                flags &= ~SCF_DO_SUBSTR;\n \t}\n #endif\n #endif\n \n \tscan = regnext(scan);\n     }\n \n   finish:\n     if (frame) {\n         depth = depth - 1;\n \n         DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n         DEBUG_PEEP(\"fend\", scan, depth, flags);\n \n         last = frame->last_regnode;\n         scan = frame->next_regnode;\n         stopparen = frame->stopparen;\n         recursed_depth = frame->prev_recursed_depth;\n \n         RExC_frame_last = frame->prev_frame;\n         frame = frame->this_prev_frame;\n         goto fake_study_recurse;\n     }\n \n     assert(!frame);\n     DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n \n     *scanp = scan;\n     *deltap = is_inf_internal ? SSize_t_MAX : delta;\n \n     if (flags & SCF_DO_SUBSTR && is_inf)\n \tdata->pos_delta = SSize_t_MAX - data->pos_min;\n     if (is_par > (I32)U8_MAX)\n \tis_par = 0;\n     if (is_par && pars==1 && data) {\n \tdata->flags |= SF_IN_PAR;\n \tdata->flags &= ~SF_HAS_PAR;\n     }\n     else if (pars && data) {\n \tdata->flags |= SF_HAS_PAR;\n \tdata->flags &= ~SF_IN_PAR;\n     }\n     if (flags & SCF_DO_STCLASS_OR)\n \tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n     if (flags & SCF_TRIE_RESTUDY)\n         data->flags |= \tSCF_TRIE_RESTUDY;\n \n     DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n \n     {\n         SSize_t final_minlen= min < stopmin ? min : stopmin;\n \n         if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n             if (final_minlen > SSize_t_MAX - delta)\n                 RExC_maxlen = SSize_t_MAX;\n             else if (RExC_maxlen < final_minlen + delta)\n                 RExC_maxlen = final_minlen + delta;\n         }\n         return final_minlen;\n     }\n     NOT_REACHED;\n \n", "target": "// fix_start\n\t\t\tU32 flags, U32 depth, bool was_mutate_ok)\n// fix_end\n// fix_start\n        bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);\n// fix_end\n// fix_start\n        if (mutate_ok)\n            JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n// fix_end\n// fix_start\n                              recursed_depth, NULL, f, depth+1, mutate_ok);\n// fix_end\n// fix_start\n                                      recursed_depth, NULL, f, depth+1,\n                                      mutate_ok);\n// fix_end\n// fix_start\n                if (PERL_ENABLE_TRIE_OPTIMISATION\n                    && OP(startbranch) == BRANCH\n                    && mutate_ok\n                ) {\n// fix_end\n// fix_start\n                newframe->in_gosub = (\n                    (frame && frame->in_gosub) || OP(scan) == GOSUB\n                );\n// fix_end\n// fix_start\n                if (OP(next) == EXACTFU_S_EDGE && mutate_ok) {\n// fix_end\n// fix_start\n                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next))))\n                    &&   mutate_ok\n                ) {\n// fix_end\n// fix_start\n                                  , depth+1, mutate_ok);\n// fix_end\n// fix_start\n\t\t      && !deltanext && minnext == 1\n                      && mutate_ok\n                ) {\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n                      && mutate_ok\n// fix_end\n// fix_start\n                                    depth+1, mutate_ok);\n// fix_end\n// fix_start\n                                      recursed_depth, NULL, f, depth+1,\n                                      mutate_ok);\n// fix_end\n// fix_start\n                                        f, depth+1, mutate_ok);\n// fix_end\n// fix_start\n                            stopparen, recursed_depth, NULL, f, depth+1,\n                            mutate_ok);\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2020-12723", "cve_desc": "regcomp.c in Perl before 5.30.3 allows a buffer overflow via a crafted regular expression because of recursive S_study_chunk calls.", "project": "perl5", "idx": 215264}
{"source": " asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n {\n \tstruct rlimit new_rlim, *old_rlim;\n \tunsigned long it_prof_secs;\n \tint retval;\n \n \tif (resource >= RLIM_NLIMITS)\n \t\treturn -EINVAL;\n \tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n \t\treturn -EFAULT;\n \tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n \t\treturn -EINVAL;\n \told_rlim = current->signal->rlim + resource;\n \tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n \t    !capable(CAP_SYS_RESOURCE))\n \t\treturn -EPERM;\n \tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n \t\treturn -EPERM;\n \n \tretval = security_task_setrlimit(resource, &new_rlim);\n \tif (retval)\n \t\treturn retval;\n \n// bug_start\n// bug_end\n \ttask_lock(current->group_leader);\n \t*old_rlim = new_rlim;\n \ttask_unlock(current->group_leader);\n \n \tif (resource != RLIMIT_CPU)\n \t\tgoto out;\n \n \tif (new_rlim.rlim_cur == RLIM_INFINITY)\n \t\tgoto out;\n \n \tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n \tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n \t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n \t\tcputime_t cputime;\n \n// bug_start\n\t\tif (rlim_cur == 0) {\n\t\t\trlim_cur = 1;\n\t\t}\n// bug_end\n \t\tcputime = secs_to_cputime(rlim_cur);\n \t\tread_lock(&tasklist_lock);\n \t\tspin_lock_irq(&current->sighand->siglock);\n \t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n \t\tspin_unlock_irq(&current->sighand->siglock);\n \t\tread_unlock(&tasklist_lock);\n \t}\n out:\n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {\n\t\tnew_rlim.rlim_cur = 1;\n\t}\n\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2008-1294", "cve_desc": "Linux kernel 2.6.17, and other versions before 2.6.22, does not check when a user attempts to set RLIMIT_CPU to 0 until after the change is made, which allows local users to bypass intended resource limits.", "project": "linux-2.6", "idx": 215312}
{"source": " static int sctp_setsockopt_auth_key(struct sock *sk,\n \t\t\t\t    char __user *optval,\n \t\t\t\t    int optlen)\n {\n \tstruct sctp_authkey *authkey;\n \tstruct sctp_association *asoc;\n \tint ret;\n \n \tif (!sctp_auth_enable)\n \t\treturn -EACCES;\n \n \tif (optlen <= sizeof(struct sctp_authkey))\n \t\treturn -EINVAL;\n \n \tauthkey = kmalloc(optlen, GFP_KERNEL);\n \tif (!authkey)\n \t\treturn -ENOMEM;\n \n \tif (copy_from_user(authkey, optval, optlen)) {\n \t\tret = -EFAULT;\n \t\tgoto out;\n \t}\n \n// bug_start\n\tif (authkey->sca_keylength > optlen) {\n// bug_end\n \t\tret = -EINVAL;\n \t\tgoto out;\n \t}\n \n \tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n \tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n \t\tret = -EINVAL;\n \t\tgoto out;\n \t}\n \n \tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\n out:\n \tkfree(authkey);\n \treturn ret;\n }\n \n", "target": "// fix_start\n\tif (authkey->sca_keylength > optlen - sizeof(struct sctp_authkey)) {\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2008-3526", "cve_desc": "Integer overflow in the sctp_setsockopt_auth_key function in net/sctp/socket.c in the Stream Control Transmission Protocol (sctp) implementation in the Linux kernel 2.6.24-rc1 through 2.6.26.3 allows remote attackers to cause a denial of service (panic) or possibly have unspecified other impact via a crafted sca_keylength field associated with the SCTP_AUTH_KEY option.", "project": "linux-2.6", "idx": 215374}
{"source": "// bug_start\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n// bug_end\n \t\t\t\t     const struct sctp_endpoint *ep,\n \t\t\t\t     const struct sctp_association *asoc,\n \t\t\t\t     const sctp_subtype_t type,\n \t\t\t\t     void *arg,\n// bug_start\n\t\t\t\t     sctp_cmd_seq_t *commands) {\n\tstatic const char err_str[] = \"The following parameter had invalid length:\";\n// bug_end\n \n \treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n \t\t\t\t\tsizeof(err_str));\n }\n \n", "target": "// fix_start\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n// fix_end\n// fix_start\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2008-4618", "cve_desc": "The Stream Control Transmission Protocol (sctp) implementation in the Linux kernel before 2.6.27 does not properly handle a protocol violation in which a parameter has an invalid length, which allows attackers to cause a denial of service (panic) via unspecified vectors, related to sctp_sf_violation_paramlen, sctp_sf_abort_violation, sctp_make_abort_violation, and incorrect data types in function calls.", "project": "linux-2.6", "idx": 215391}
{"source": " int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n \t\t     struct hfs_find_data *fd)\n {\n \thfsplus_cat_entry tmp;\n \tint err;\n \tu16 type;\n \n \thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n \terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n \tif (err)\n \t\treturn err;\n \n \ttype = be16_to_cpu(tmp.type);\n \tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n \t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n \t\treturn -EIO;\n \t}\n \n// bug_start\n// bug_end\n \thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n \t\t\t\t &tmp.thread.nodeName);\n \treturn hfs_brec_find(fd);\n }\n \n", "target": "// fix_start\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tprintk(KERN_ERR \"hfs: catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2008-4933", "cve_desc": "Buffer overflow in the hfsplus_find_cat function in fs/hfsplus/catalog.c in the Linux kernel before 2.6.28-rc1 allows attackers to cause a denial of service (memory corruption or system crash) via an hfsplus filesystem image with an invalid catalog namelength field, related to the hfsplus_cat_build_key_uni function.", "project": "linux-2.6", "idx": 215399}
{"source": " int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n {\n \tstruct page *page;\n \tstruct address_space *mapping;\n \t__be32 *pptr, *curr, *end;\n \tu32 mask, start, len, n;\n \t__be32 val;\n \tint i;\n \n \tlen = *max;\n \tif (!len)\n \t\treturn size;\n \n \tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n \tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n \tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n \tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n// bug_start\n// bug_end\n \tpptr = kmap(page);\n \tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n \ti = offset % 32;\n \toffset &= ~(PAGE_CACHE_BITS - 1);\n \tif ((size ^ offset) / PAGE_CACHE_BITS)\n \t\tend = pptr + PAGE_CACHE_BITS / 32;\n \telse\n \t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n \n \tval = *curr;\n \tif (~val) {\n \t\tn = be32_to_cpu(val);\n \t\tmask = (1U << 31) >> i;\n \t\tfor (; i < 32; mask >>= 1, i++) {\n \t\t\tif (!(n & mask))\n \t\t\t\tgoto found;\n \t\t}\n \t}\n \tcurr++;\n \n \twhile (1) {\n \t\twhile (curr < end) {\n \t\t\tval = *curr;\n \t\t\tif (~val) {\n \t\t\t\tn = be32_to_cpu(val);\n \t\t\t\tmask = 1 << 31;\n \t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n \t\t\t\t\tif (!(n & mask))\n \t\t\t\t\t\tgoto found;\n \t\t\t\t}\n \t\t\t}\n \t\t\tcurr++;\n \t\t}\n \t\tkunmap(page);\n \t\toffset += PAGE_CACHE_BITS;\n \t\tif (offset >= size)\n \t\t\tbreak;\n \t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n \t\t\t\t\t NULL);\n// bug_start\n// bug_end\n \t\tcurr = pptr = kmap(page);\n \t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n \t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n \t\telse\n \t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n \t}\n \tdprint(DBG_BITMAP, \"bitmap full\\n\");\n \tstart = size;\n \tgoto out;\n \n found:\n \tstart = offset + (curr - pptr) * 32 + i;\n \tif (start >= size) {\n \t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n \t\tgoto out;\n \t}\n \tlen = min(size - start, len);\n \twhile (1) {\n \t\tn |= mask;\n \t\tif (++i >= 32)\n \t\t\tbreak;\n \t\tmask >>= 1;\n \t\tif (!--len || n & mask)\n \t\t\tgoto done;\n \t}\n \tif (!--len)\n \t\tgoto done;\n \t*curr++ = cpu_to_be32(n);\n \twhile (1) {\n \t\twhile (curr < end) {\n \t\t\tn = be32_to_cpu(*curr);\n \t\t\tif (len < 32)\n \t\t\t\tgoto last;\n \t\t\tif (n) {\n \t\t\t\tlen = 32;\n \t\t\t\tgoto last;\n \t\t\t}\n \t\t\t*curr++ = cpu_to_be32(0xffffffff);\n \t\t\tlen -= 32;\n \t\t}\n \t\tset_page_dirty(page);\n \t\tkunmap(page);\n \t\toffset += PAGE_CACHE_BITS;\n \t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n \t\t\t\t\t NULL);\n// bug_start\n// bug_end\n \t\tpptr = kmap(page);\n \t\tcurr = pptr;\n \t\tend = pptr + PAGE_CACHE_BITS / 32;\n \t}\n last:\n \tmask = 1U << 31;\n \tfor (i = 0; i < len; i++) {\n \t\tif (n & mask)\n \t\t\tbreak;\n \t\tn |= mask;\n \t\tmask >>= 1;\n \t}\n done:\n \t*curr = cpu_to_be32(n);\n \tset_page_dirty(page);\n \tkunmap(page);\n \t*max = offset + (curr - pptr) * 32 + i - start;\n \tHFSPLUS_SB(sb).free_blocks -= *max;\n \tsb->s_dirt = 1;\n \tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\n out:\n \tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n \treturn start;\n }\n \n", "target": "// fix_start\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n// fix_end\n// fix_start\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n// fix_end\n// fix_start\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2008-4934", "cve_desc": "The hfsplus_block_allocate function in fs/hfsplus/bitmap.c in the Linux kernel before 2.6.28-rc1 does not check a certain return value from the read_mapping_page function before calling kmap, which allows attackers to cause a denial of service (system crash) via a crafted hfsplus filesystem image.", "project": "linux-2.6", "idx": 215400}
{"source": " int unlzw(in, out)\n     int in, out;\n {\n     REG2   char_type  *stackp;\n     REG3   code_int   code;\n     REG4   int        finchar;\n     REG5   code_int   oldcode;\n     REG6   code_int   incode;\n     REG7   long       inbits;\n     REG8   long       posbits;\n     REG9   int        outpos;\n     REG11  unsigned   bitmask;\n     REG12  code_int   free_ent;\n     REG13  code_int   maxcode;\n     REG14  code_int   maxmaxcode;\n     REG15  int        n_bits;\n     REG16  int        rsize;\n \n #ifdef MAXSEG_64K\n     tab_prefix[0] = tab_prefix0;\n     tab_prefix[1] = tab_prefix1;\n #endif\n     maxbits = get_byte();\n     block_mode = maxbits & BLOCK_MODE;\n     if ((maxbits & LZW_RESERVED) != 0) {\n \tWARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n \t      program_name, ifname, maxbits & LZW_RESERVED));\n     }\n     maxbits &= BIT_MASK;\n     maxmaxcode = MAXCODE(maxbits);\n \n     if (maxbits > BITS) {\n \tfprintf(stderr,\n \t\t\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n \t\tprogram_name, ifname, maxbits, BITS);\n \texit_code = ERROR;\n \treturn ERROR;\n     }\n     rsize = insize;\n     maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n     bitmask = (1<<n_bits)-1;\n     oldcode = -1;\n     finchar = 0;\n     outpos = 0;\n     posbits = inptr<<3;\n \n     free_ent = ((block_mode) ? FIRST : 256);\n \n     clear_tab_prefixof();\n \n     for (code = 255 ; code >= 0 ; --code) {\n \ttab_suffixof(code) = (char_type)code;\n     }\n     do {\n \tREG1 int i;\n \tint  e;\n \tint  o;\n \n     resetbuf:\n// bug_start\n\te = insize-(o = (posbits>>3));\n// bug_end\n \n \tfor (i = 0 ; i < e ; ++i) {\n \t    inbuf[i] = inbuf[i+o];\n \t}\n \tinsize = e;\n \tposbits = 0;\n \n \tif (insize < INBUF_EXTRA) {\n \t    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ);\n \t    if (rsize == -1) {\n \t\tread_error();\n \t    }\n \t    insize += rsize;\n \t    bytes_in += (off_t)rsize;\n \t}\n \tinbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n \t\t  ((long)insize<<3)-(n_bits-1));\n \n \twhile (inbits > posbits) {\n \t    if (free_ent > maxcode) {\n \t\tposbits = ((posbits-1) +\n \t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n \t\t++n_bits;\n \t\tif (n_bits == maxbits) {\n \t\t    maxcode = maxmaxcode;\n \t\t} else {\n \t\t    maxcode = MAXCODE(n_bits)-1;\n \t\t}\n \t\tbitmask = (1<<n_bits)-1;\n \t\tgoto resetbuf;\n \t    }\n \t    input(inbuf,posbits,code,n_bits,bitmask);\n \t    Tracev((stderr, \"%d \", code));\n \n \t    if (oldcode == -1) {\n \t\tif (256 <= code)\n \t\t  gzip_error (\"corrupt input.\");\n \t\toutbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));\n \t\tcontinue;\n \t    }\n \t    if (code == CLEAR && block_mode) {\n \t\tclear_tab_prefixof();\n \t\tfree_ent = FIRST - 1;\n \t\tposbits = ((posbits-1) +\n \t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n \t\tmaxcode = MAXCODE(n_bits = INIT_BITS)-1;\n \t\tbitmask = (1<<n_bits)-1;\n \t\tgoto resetbuf;\n \t    }\n \t    incode = code;\n \t    stackp = de_stack;\n \n \t    if (code >= free_ent) {\n \t\tif (code > free_ent) {\n #ifdef DEBUG\n \t\t    char_type *p;\n \n \t\t    posbits -= n_bits;\n \t\t    p = &inbuf[posbits>>3];\n \t\t    fprintf(stderr,\n \t\t\t    \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n \t\t\t    code, free_ent, n_bits, insize);\n \t\t    fprintf(stderr,\n \t\t\t    \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n \t\t\t    posbits, p[-1],p[0],p[1],p[2],p[3]);\n #endif\n \t\t    if (!test && outpos > 0) {\n \t\t\twrite_buf(out, (char*)outbuf, outpos);\n \t\t\tbytes_out += (off_t)outpos;\n \t\t    }\n \t\t    gzip_error (to_stdout\n \t\t\t\t? \"corrupt input.\"\n \t\t\t\t: \"corrupt input. Use zcat to recover some data.\");\n \t\t}\n \t\t*--stackp = (char_type)finchar;\n \t\tcode = oldcode;\n \t    }\n \n \t    while ((cmp_code_int)code >= (cmp_code_int)256) {\n \t\t*--stackp = tab_suffixof(code);\n \t\tcode = tab_prefixof(code);\n \t    }\n \t    *--stackp =\t(char_type)(finchar = tab_suffixof(code));\n \n \t    {\n \t\tREG1 int\ti;\n \n \t\tif (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n \t\t    do {\n \t\t\tif (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n \n \t\t\tif (i > 0) {\n \t\t\t    memcpy(outbuf+outpos, stackp, i);\n \t\t\t    outpos += i;\n \t\t\t}\n \t\t\tif (outpos >= OUTBUFSIZ) {\n \t\t\t    if (!test) {\n \t\t\t\twrite_buf(out, (char*)outbuf, outpos);\n \t\t\t\tbytes_out += (off_t)outpos;\n \t\t\t    }\n \t\t\t    outpos = 0;\n \t\t\t}\n \t\t\tstackp+= i;\n \t\t    } while ((i = (de_stack-stackp)) > 0);\n \t\t} else {\n \t\t    memcpy(outbuf+outpos, stackp, i);\n \t\t    outpos += i;\n \t\t}\n \t    }\n \n \t    if ((code = free_ent) < maxmaxcode) {\n \n \t\ttab_prefixof(code) = (unsigned short)oldcode;\n \t\ttab_suffixof(code) = (char_type)finchar;\n \t\tfree_ent = code+1;\n \t    }\n \t    oldcode = incode;\n \t}\n     } while (rsize != 0);\n \n     if (!test && outpos > 0) {\n \twrite_buf(out, (char*)outbuf, outpos);\n \tbytes_out += (off_t)outpos;\n     }\n     return OK;\n }\n \n", "target": "// fix_start\n\to = posbits >> 3;\n\te = o <= insize ? insize - o : 0;\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2010-0001", "cve_desc": "Integer underflow in the unlzw function in unlzw.c in gzip before 1.4 on 64-bit platforms, as used in ncompress and probably others, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted archive that uses LZW compression, leading to an array index error.", "project": "gzip", "idx": 215549}
{"source": " bmexec_trans (kwset_t kwset, char const *text, size_t size)\n {\n   unsigned char const *d1;\n   char const *ep, *sp, *tp;\n   int d;\n   int len = kwset->mind;\n   char const *trans = kwset->trans;\n \n   if (len == 0)\n     return 0;\n   if (len > size)\n     return -1;\n   if (len == 1)\n     {\n       tp = memchr_kwset (text, size, kwset);\n       return tp ? tp - text : -1;\n     }\n \n   d1 = kwset->delta;\n   sp = kwset->target + len;\n   tp = text + len;\n   char gc1 = kwset->gc1;\n   char gc2 = kwset->gc2;\n \n   if (size > 12 * len)\n     for (ep = text + size - 11 * len; tp <= ep; )\n       {\n         char const *tp0 = tp;\n         d = d1[U(tp[-1])], tp += d;\n         d = d1[U(tp[-1])], tp += d;\n         if (d != 0)\n           {\n             d = d1[U(tp[-1])], tp += d;\n             d = d1[U(tp[-1])], tp += d;\n             d = d1[U(tp[-1])], tp += d;\n             if (d != 0)\n               {\n                 d = d1[U(tp[-1])], tp += d;\n                 d = d1[U(tp[-1])], tp += d;\n                 d = d1[U(tp[-1])], tp += d;\n                 if (d != 0)\n                   {\n                     d = d1[U(tp[-1])], tp += d;\n                     d = d1[U(tp[-1])], tp += d;\n \n                     int advance_heuristic = 16 * sizeof (long);\n                     if (advance_heuristic <= tp - tp0)\n                       goto big_advance;\n                     tp--;\n                     tp = memchr_kwset (tp, text + size - tp, kwset);\n                     if (! tp)\n                       return -1;\n                     tp++;\n// bug_start\n// bug_end\n                   }\n               }\n           }\n         if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n           return tp - text;\n       big_advance:;\n       }\n \n   ep = text + size;\n   d = d1[U(tp[-1])];\n   while (d <= ep - tp)\n     {\n       d = d1[U((tp += d)[-1])];\n       if (d != 0)\n         continue;\n       if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n         return tp - text;\n     }\n \n   return -1;\n }\n \n", "target": "// fix_start\n                    if (ep <= tp)\n                      break;\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2015-1345", "cve_desc": "The bmexec_trans function in kwset.c in grep 2.19 through 2.21 allows local users to cause a denial of service (out-of-bounds heap read and crash) via crafted input when using the -F option.", "project": "grep", "idx": 215921}
{"source": " ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n {\n   mp_limb_t u1, u0;\n   mp_size_t n;\n \n   n = 2*p->size;\n   u1 = rp[--n];\n   u0 = rp[n-1];\n \n   for (; n >= p->size; n--)\n     {\n       mp_limb_t q2, q1, q0, t, cy;\n \n       q1 = u1 - (u1 > u0);\n       q0 = u0 - u1;\n       t = u1 << 32;\n       q0 += t;\n       t = (u1 >> 32) + (q0 < t) + 1;\n       q1 += t;\n       q2 = q1 < t;\n \n       u1 = u0 + (q1 << 32) - q1;\n       t = -(mp_limb_t) (u1 > q0);\n       u1 -= t & 0xffffffff;\n       q1 += t;\n       q2 += t + (q1 < t);\n \n       assert (q2 < 2);\n \n       t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);\n       t += cnd_sub_n (q2, rp + n - 3, p->m, 1);\n       t += (-q2) & 0xffffffff;\n \n       u0 = rp[n-2];\n       cy = (u0 < t);\n       u0 -= t;\n       t = (u1 < cy);\n       u1 -= cy;\n// bug_start\n      u1 += cnd_add_n (t, rp + n - 4, p->m, 3);\n// bug_end\n       u1 -= (-t) & 0xffffffff;\n     }\n   rp[2] = u0;\n   rp[3] = u1;\n }\n \n", "target": "// fix_start\n\n      cy = cnd_add_n (t, rp + n - 4, p->m, 2);\n      u0 += cy;\n      u1 += (u0 < cy);\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "cve": "CVE-2015-8803", "cve_desc": "The ecc_256_modp function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8805.", "project": "nettle", "idx": 215948}
{"source": " pax_decode_header (struct tar_sparse_file *file)\n {\n   if (file->stat_info->sparse_major > 0)\n     {\n       uintmax_t u;\n       char nbuf[UINTMAX_STRSIZE_BOUND];\n       union block *blk;\n       char *p;\n       size_t i;\n       off_t start;\n \n #define COPY_BUF(b,buf,src) do                                     \\\n  {                                                                 \\\n    char *endp = b->buffer + BLOCKSIZE;                             \\\n    char *dst = buf;                                                \\\n    do                                                              \\\n      {                                                             \\\n        if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n          {                                                         \\\n            ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n \t          file->stat_info->orig_file_name));               \\\n            return false;                                           \\\n          }                                                         \\\n        if (src == endp)                                            \\\n \t {                                                         \\\n \t   set_next_block_after (b);                               \\\n            b = find_next_block ();                                 \\\n// bug_start\n// bug_end\n            src = b->buffer;                                        \\\n \t   endp = b->buffer + BLOCKSIZE;                           \\\n \t }                                                         \\\n        *dst = *src++;                                              \\\n      }                                                             \\\n    while (*dst++ != '\\n');                                         \\\n    dst[-1] = 0;                                                    \\\n  } while (0)\n \n       start = current_block_ordinal ();\n       set_next_block_after (current_header);\n       blk = find_next_block ();\n// bug_start\n// bug_end\n       p = blk->buffer;\n       COPY_BUF (blk,nbuf,p);\n       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n \t{\n \t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n \t\t  file->stat_info->orig_file_name));\n \t  return false;\n \t}\n       file->stat_info->sparse_map_size = u;\n       file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n \t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n       file->stat_info->sparse_map_avail = 0;\n       for (i = 0; i < file->stat_info->sparse_map_size; i++)\n \t{\n \t  struct sp_array sp;\n \n \t  COPY_BUF (blk,nbuf,p);\n \t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n \t    {\n \t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n \t\t      file->stat_info->orig_file_name));\n \t      return false;\n \t    }\n \t  sp.offset = u;\n \t  COPY_BUF (blk,nbuf,p);\n \t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n \t    {\n \t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n \t\t      file->stat_info->orig_file_name));\n \t      return false;\n \t    }\n \t  sp.numbytes = u;\n \t  sparse_add_map (file->stat_info, &sp);\n \t}\n       set_next_block_after (blk);\n \n       file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n     }\n \n   return true;\n }\n \n", "target": "// fix_start\n           if (!b)                                                 \\\n             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n// fix_end\n// fix_start\n      if (!blk)\n        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2019-9923", "cve_desc": "pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.", "project": "tar", "idx": 216027}
{"source": "     kssl_keytab_is_available(KSSL_CTX *kssl_ctx)\n {\n     krb5_context\t\tkrb5context = NULL;\n     krb5_keytab \t\tkrb5keytab = NULL;\n     krb5_keytab_entry           entry;\n     krb5_principal              princ = NULL;\n     krb5_error_code  \t\tkrb5rc = KRB5KRB_ERR_GENERIC;\n     int rc = 0;\n \n     if ((krb5rc = krb5_init_context(&krb5context)))\n         return(0);\n \n     if (kssl_ctx->keytab_file)\n     {\n         krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\n                                   &krb5keytab);\n         if (krb5rc)\n             goto exit;\n     }\n     else\n     {\n         krb5rc = krb5_kt_default(krb5context,&krb5keytab);\n         if (krb5rc)\n             goto exit;\n     }\n \n     krb5rc = krb5_sname_to_principal(krb5context, NULL,\n                                      kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,\n                                      KRB5_NT_SRV_HST, &princ);\n \n// bug_start\n// bug_end\n     krb5rc = krb5_kt_get_entry(krb5context, krb5keytab,\n                                 princ,\n                                 0 ,\n                                 0 ,\n                                 &entry);\n     if ( krb5rc == KRB5_KT_NOTFOUND ) {\n         rc = 1;\n         goto exit;\n     } else if ( krb5rc )\n         goto exit;\n \n     krb5_kt_free_entry(krb5context, &entry);\n     rc = 1;\n \n   exit:\n     if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);\n     if (princ)          krb5_free_principal(krb5context, princ);\n     if (krb5context)\tkrb5_free_context(krb5context);\n     return(rc);\n }\n \n", "target": "// fix_start\n    if (krb5rc)\n\tgoto exit;\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2010-0433", "cve_desc": "The kssl_keytab_is_available function in ssl/kssl.c in OpenSSL before 0.9.8n, when Kerberos is enabled but Kerberos configuration files cannot be opened, does not check a certain return value, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via SSL cipher negotiation, as demonstrated by a chroot installation of Dovecot or stunnel without Kerberos configuration files inside the chroot.", "project": "openssl", "idx": 216126}
{"source": " int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n   sftp_status_message status = NULL;\n   sftp_message msg = NULL;\n   sftp_attributes errno_attr = NULL;\n   struct sftp_attributes_struct attr;\n   ssh_buffer buffer;\n   ssh_string path;\n   uint32_t id;\n \n   buffer = ssh_buffer_new();\n   if (buffer == NULL) {\n     ssh_set_error_oom(sftp->session);\n     return -1;\n   }\n \n   path = ssh_string_from_char(directory);\n   if (path == NULL) {\n     ssh_set_error_oom(sftp->session);\n     ssh_buffer_free(buffer);\n     return -1;\n   }\n \n   ZERO_STRUCT(attr);\n   attr.permissions = mode;\n   attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n \n   id = sftp_get_new_id(sftp);\n   if (buffer_add_u32(buffer, id) < 0 ||\n       buffer_add_ssh_string(buffer, path) < 0 ||\n       buffer_add_attributes(buffer, &attr) < 0 ||\n       sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n     ssh_buffer_free(buffer);\n     ssh_string_free(path);\n// bug_start\n// bug_end\n   }\n   ssh_buffer_free(buffer);\n   ssh_string_free(path);\n \n   while (msg == NULL) {\n     if (sftp_read_and_dispatch(sftp) < 0) {\n       return -1;\n     }\n     msg = sftp_dequeue(sftp, id);\n   }\n \n   if (msg->packet_type == SSH_FXP_STATUS) {\n     status = parse_status_msg(msg);\n     sftp_message_free(msg);\n     if (status == NULL) {\n       return -1;\n     }\n     sftp_set_error(sftp, status->status);\n     switch (status->status) {\n       case SSH_FX_FAILURE:\n         errno_attr = sftp_lstat(sftp, directory);\n         if (errno_attr != NULL) {\n           SAFE_FREE(errno_attr);\n           sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n         }\n         break;\n       case SSH_FX_OK:\n         status_msg_free(status);\n         return 0;\n         break;\n       default:\n         break;\n     }\n     ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n         \"SFTP server: %s\", status->errormsg);\n     status_msg_free(status);\n     return -1;\n   } else {\n     ssh_set_error(sftp->session, SSH_FATAL,\n         \"Received message %d when attempting to make directory\",\n         msg->packet_type);\n     sftp_message_free(msg);\n   }\n \n   return -1;\n }\n \n", "target": "// fix_start\n    return -1;\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "cve": "CVE-2012-4559", "cve_desc": "Multiple double free vulnerabilities in the (1) agent_sign_data function in agent.c, (2) channel_request function in channels.c, (3) ssh_userauth_pubkey function in auth.c, (4) sftp_parse_attr_3 function in sftp.c, and (5) try_publickey_from_file function in keyfiles.c in libssh before 0.5.3 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via unspecified vectors.", "project": "libssh", "idx": 216202}
{"source": " int ssl3_get_new_session_ticket(SSL *s)\n {\n     int ok, al, ret = 0, ticklen;\n     long n;\n     const unsigned char *p;\n     unsigned char *d;\n \n     n = s->method->ssl_get_message(s,\n                                    SSL3_ST_CR_SESSION_TICKET_A,\n                                    SSL3_ST_CR_SESSION_TICKET_B,\n                                    SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n \n     if (!ok)\n         return ((int)n);\n \n     if (n < 6) {\n         al = SSL_AD_DECODE_ERROR;\n         SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n         goto f_err;\n     }\n \n     p = d = (unsigned char *)s->init_msg;\n// bug_start\n// bug_end\n     n2l(p, s->session->tlsext_tick_lifetime_hint);\n     n2s(p, ticklen);\n     if (ticklen + 6 != n) {\n         al = SSL_AD_DECODE_ERROR;\n         SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n         goto f_err;\n     }\n     if (s->session->tlsext_tick) {\n         OPENSSL_free(s->session->tlsext_tick);\n         s->session->tlsext_ticklen = 0;\n     }\n     s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n     if (!s->session->tlsext_tick) {\n         SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n         goto err;\n     }\n     memcpy(s->session->tlsext_tick, p, ticklen);\n     s->session->tlsext_ticklen = ticklen;\n     EVP_Digest(p, ticklen,\n                s->session->session_id, &s->session->session_id_length,\n # ifndef OPENSSL_NO_SHA256\n                EVP_sha256(), NULL);\n # else\n                EVP_sha1(), NULL);\n # endif\n     ret = 1;\n     return (ret);\n  f_err:\n     ssl3_send_alert(s, SSL3_AL_FATAL, al);\n  err:\n     s->state = SSL_ST_ERR;\n     return (-1);\n }\n \n", "target": "// fix_start\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            if (i & SSL_SESS_CACHE_NO_INTERNAL_STORE) {\n                if (s->session_ctx->remove_session_cb != NULL)\n                    s->session_ctx->remove_session_cb(s->session_ctx,\n                                                      s->session);\n            } else {\n                SSL_CTX_remove_session(s->session_ctx, s->session);\n            }\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2015-1791", "cve_desc": "Race condition in the ssl3_get_new_session_ticket function in ssl/s3_clnt.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b, when used for a multi-threaded client, allows remote attackers to cause a denial of service (double free and application crash) or possibly have unspecified other impact by providing a NewSessionTicket during an attempt to reuse a ticket that had been obtained earlier.", "project": "openssl", "idx": 216515}
{"source": " SCM_DEFINE (scm_mkdir, \"mkdir\", 1, 1, 0,\n             (SCM path, SCM mode),\n \t    \"Create a new directory named by @var{path}.  If @var{mode} is omitted\\n\"\n// bug_start\n\t    \"then the permissions of the directory file are set using the current\\n\"\n\t    \"umask.  Otherwise they are set to the decimal value specified with\\n\"\n\t    \"@var{mode}.  The return value is unspecified.\")\n// bug_end\n #define FUNC_NAME s_scm_mkdir\n {\n   int rv;\n// bug_start\n  mode_t mask;\n// bug_end\n \n// bug_start\n  if (SCM_UNBNDP (mode))\n    {\n      mask = umask (0);\n      umask (mask);\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, 0777 ^ mask));\n    }\n  else\n    {\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, scm_to_uint (mode)));\n    }\n// bug_end\n   if (rv != 0)\n     SCM_SYSERROR;\n// bug_start\n// bug_end\n   return SCM_UNSPECIFIED;\n }\n \n", "target": "// fix_start\n\t    \"then the permissions of the directory are set to @code{#o777}\\n\"\n\t    \"masked with the current umask (@pxref{Processes, @code{umask}}).\\n\"\n\t    \"Otherwise they are set to the value specified with @var{mode}.\\n\"\n\t    \"The return value is unspecified.\")\n// fix_end\n// fix_start\n  mode_t c_mode;\n// fix_end\n// fix_start\n  c_mode = SCM_UNBNDP (mode) ? 0777 : scm_to_uint (mode);\n\n  STRING_SYSCALL (path, c_path, rv = mkdir (c_path, c_mode));\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "CWE-275", "cwe_name": "Permission Issues", "cve": "CVE-2016-8605", "cve_desc": "The mkdir procedure of GNU Guile temporarily changed the process' umask to zero. During that time window, in a multithreaded application, other threads could end up creating files with insecure permissions. For example, mkdir without the optional mode argument would create directories as 0777. This is fixed in Guile 2.0.13. Prior versions are affected.", "project": "guile", "idx": 216637}
{"source": " auth_request_get_var_expand_table_full(const struct auth_request *auth_request,\n \t\t\t\t       auth_request_escape_func_t *escape_func,\n \t\t\t\t       unsigned int *count)\n {\n \tconst unsigned int auth_count =\n \t\tN_ELEMENTS(auth_request_var_expand_static_tab);\n \tstruct var_expand_table *tab, *ret_tab;\n// bug_start\n\tconst char *orig_user, *auth_user;\n// bug_end\n \n \tif (escape_func == NULL)\n \t\tescape_func = escape_none;\n \n \ttab = ret_tab = t_malloc((*count + auth_count) * sizeof(*tab));\n \tmemset(tab, 0, *count * sizeof(*tab));\n \ttab += *count;\n \t*count += auth_count;\n \n \tmemcpy(tab, auth_request_var_expand_static_tab,\n \t       auth_count * sizeof(*tab));\n \n// bug_start\n\ttab[0].value = escape_func(auth_request->user, auth_request);\n\ttab[1].value = escape_func(t_strcut(auth_request->user, '@'),\n// bug_end\n \t\t\t\t   auth_request);\n// bug_start\n\ttab[2].value = strchr(auth_request->user, '@');\n// bug_end\n \tif (tab[2].value != NULL)\n \t\ttab[2].value = escape_func(tab[2].value+1, auth_request);\n \ttab[3].value = escape_func(auth_request->service, auth_request);\n \tif (auth_request->local_ip.family != 0)\n \t\ttab[5].value = net_ip2addr(&auth_request->local_ip);\n \tif (auth_request->remote_ip.family != 0)\n \t\ttab[6].value = net_ip2addr(&auth_request->remote_ip);\n \ttab[7].value = dec2str(auth_request->client_pid);\n \tif (auth_request->mech_password != NULL) {\n \t\ttab[8].value = escape_func(auth_request->mech_password,\n \t\t\t\t\t   auth_request);\n \t}\n \tif (auth_request->userdb_lookup) {\n \t\ttab[9].value = auth_request->userdb == NULL ? \"\" :\n \t\t\tdec2str(auth_request->userdb->userdb->id);\n \t} else {\n \t\ttab[9].value = auth_request->passdb == NULL ? \"\" :\n \t\t\tdec2str(auth_request->passdb->passdb->id);\n \t}\n \ttab[10].value = auth_request->mech_name == NULL ? \"\" :\n \t\tescape_func(auth_request->mech_name, auth_request);\n \ttab[11].value = auth_request->secured ? \"secured\" : \"\";\n \ttab[12].value = dec2str(auth_request->local_port);\n \ttab[13].value = dec2str(auth_request->remote_port);\n \ttab[14].value = auth_request->valid_client_cert ? \"valid\" : \"\";\n \n \tif (auth_request->requested_login_user != NULL) {\n \t\tconst char *login_user = auth_request->requested_login_user;\n \n \t\ttab[15].value = escape_func(login_user, auth_request);\n \t\ttab[16].value = escape_func(t_strcut(login_user, '@'),\n \t\t\t\t\t    auth_request);\n \t\ttab[17].value = strchr(login_user, '@');\n \t\tif (tab[17].value != NULL) {\n \t\t\ttab[17].value = escape_func(tab[17].value+1,\n \t\t\t\t\t\t    auth_request);\n \t\t}\n \t}\n \ttab[18].value = auth_request->session_id == NULL ? NULL :\n \t\tescape_func(auth_request->session_id, auth_request);\n \tif (auth_request->real_local_ip.family != 0)\n \t\ttab[19].value = net_ip2addr(&auth_request->real_local_ip);\n \tif (auth_request->real_remote_ip.family != 0)\n \t\ttab[20].value = net_ip2addr(&auth_request->real_remote_ip);\n \ttab[21].value = dec2str(auth_request->real_local_port);\n \ttab[22].value = dec2str(auth_request->real_remote_port);\n// bug_start\n\ttab[23].value = strchr(auth_request->user, '@');\n// bug_end\n \tif (tab[23].value != NULL) {\n \t\ttab[23].value = escape_func(t_strcut(tab[23].value+1, '@'),\n \t\t\t\t\t    auth_request);\n \t}\n// bug_start\n\ttab[24].value = strrchr(auth_request->user, '@');\n// bug_end\n \tif (tab[24].value != NULL)\n \t\ttab[24].value = escape_func(tab[24].value+1, auth_request);\n \ttab[25].value = auth_request->master_user == NULL ? NULL :\n \t\tescape_func(auth_request->master_user, auth_request);\n \ttab[26].value = auth_request->session_pid == (pid_t)-1 ? NULL :\n \t\tdec2str(auth_request->session_pid);\n \n \torig_user = auth_request->original_username != NULL ?\n// bug_start\n\t\tauth_request->original_username : auth_request->user;\n// bug_end\n \ttab[27].value = escape_func(orig_user, auth_request);\n \ttab[28].value = escape_func(t_strcut(orig_user, '@'), auth_request);\n \ttab[29].value = strchr(orig_user, '@');\n \tif (tab[29].value != NULL)\n \t\ttab[29].value = escape_func(tab[29].value+1, auth_request);\n \n \tif (auth_request->master_user != NULL)\n \t\tauth_user = auth_request->master_user;\n \telse\n \t\tauth_user = orig_user;\n \ttab[30].value = escape_func(auth_user, auth_request);\n \ttab[31].value = escape_func(t_strcut(auth_user, '@'), auth_request);\n \ttab[32].value = strchr(auth_user, '@');\n \tif (tab[32].value != NULL)\n \t\ttab[32].value = escape_func(tab[32].value+1, auth_request);\n \tif (auth_request->local_name != NULL)\n \t\ttab[33].value = escape_func(auth_request->local_name, auth_request);\n \telse\n \t\ttab[33].value = \"\";\n \treturn ret_tab;\n }\n \n", "target": "// fix_start\n\tconst char *orig_user, *auth_user, *username;\n// fix_end\n// fix_start\n\tusername = auth_request->user != NULL ? auth_request->user : \"\";\n\ttab[0].value = escape_func(username, auth_request);\n\ttab[1].value = escape_func(t_strcut(username, '@'),\n// fix_end\n// fix_start\n\ttab[2].value = strchr(username, '@');\n// fix_end\n// fix_start\n\ttab[23].value = strchr(username, '@');\n// fix_end\n// fix_start\n\ttab[24].value = strrchr(username, '@');\n// fix_end\n// fix_start\n\t\tauth_request->original_username : username;\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2016-8652", "cve_desc": "The auth component in Dovecot before 2.2.27, when auth-policy is configured, allows a remote attackers to cause a denial of service (crash) by aborting authentication without setting a username.", "project": "core", "idx": 216654}
{"source": " static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n     TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n     void** value, uint64 maxcount)\n {\n \tint typesize;\n \tuint32 datasize;\n \tvoid* data;\n         uint64 target_count64;\n \ttypesize=TIFFDataWidth(direntry->tdir_type);\n \n         target_count64 = (direntry->tdir_count > maxcount) ?\n                 maxcount : direntry->tdir_count;\n \n \tif ((target_count64==0)||(typesize==0))\n \t{\n \t\t*value=0;\n \t\treturn(TIFFReadDirEntryErrOk);\n \t}\n         (void) desttypesize;\n \n \tif ((uint64)(2147483647/typesize)<target_count64)\n \t\treturn(TIFFReadDirEntryErrSizesan);\n \tif ((uint64)(2147483647/desttypesize)<target_count64)\n \t\treturn(TIFFReadDirEntryErrSizesan);\n \n \t*count=(uint32)target_count64;\n \tdatasize=(*count)*typesize;\n \tassert((tmsize_t)datasize>0);\n// bug_start\n\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\tif (data==0)\n\t\treturn(TIFFReadDirEntryErrAlloc);\n// bug_end\n \tif (!(tif->tif_flags&TIFF_BIGTIFF))\n \t{\n \t\tif (datasize<=4)\n \t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n \t\telse\n \t\t{\n \t\t\tenum TIFFReadDirEntryErr err;\n \t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n \t\t\tif (tif->tif_flags&TIFF_SWAB)\n \t\t\t\tTIFFSwabLong(&offset);\n// bug_start\n\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n// bug_end\n \t\t\tif (err!=TIFFReadDirEntryErrOk)\n \t\t\t{\n \t\t\t\t_TIFFfree(data);\n \t\t\t\treturn(err);\n \t\t\t}\n \t\t}\n \t}\n \telse\n \t{\n \t\tif (datasize<=8)\n \t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n \t\telse\n \t\t{\n \t\t\tenum TIFFReadDirEntryErr err;\n \t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n \t\t\tif (tif->tif_flags&TIFF_SWAB)\n \t\t\t\tTIFFSwabLong8(&offset);\n// bug_start\n\t\t\terr=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data);\n// bug_end\n \t\t\tif (err!=TIFFReadDirEntryErrOk)\n \t\t\t{\n \t\t\t\t_TIFFfree(data);\n \t\t\t\treturn(err);\n \t\t\t}\n \t\t}\n \t}\n \t*value=data;\n \treturn(TIFFReadDirEntryErrOk);\n }\n \n", "target": "// fix_start\n\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n// fix_end\n// fix_start\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n// fix_end\n// fix_start\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n// fix_end\n", "cwe": "CWE-770", "cwe_name": "Allocation of Resources Without Limits or Throttling", "cve": "CVE-2017-12944", "cve_desc": "The TIFFReadDirEntryArray function in tif_read.c in LibTIFF 4.0.8 mishandles memory allocation for short files, which allows remote attackers to cause a denial of service (allocation failure and application crash) in the TIFFFetchStripThing function in tif_dirread.c during a tiff2pdf invocation.", "project": "libtiff", "idx": 216701}
{"source": " static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                   void *ptr)\n {\n     EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n \n     switch(type) {\n     case EVP_CTRL_INIT:\n         if (actx == NULL)\n             actx = ctx->cipher_data\n                  = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n         if (actx == NULL) {\n             EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n             return 0;\n         }\n         actx->len.aad = 0;\n         actx->len.text = 0;\n         actx->aad = 0;\n         actx->mac_inited = 0;\n         actx->tag_len = 0;\n         actx->nonce_len = 12;\n         actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n         memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n         return 1;\n \n     case EVP_CTRL_COPY:\n         if (actx) {\n             EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n \n             dst->cipher_data =\n                    OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n             if (dst->cipher_data == NULL) {\n                 EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                 return 0;\n             }\n         }\n         return 1;\n \n     case EVP_CTRL_AEAD_SET_IVLEN:\n// bug_start\n        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n// bug_end\n             return 0;\n         actx->nonce_len = arg;\n         return 1;\n \n     case EVP_CTRL_AEAD_SET_IV_FIXED:\n         if (arg != 12)\n             return 0;\n         actx->nonce[0] = actx->key.counter[1]\n                        = CHACHA_U8TOU32((unsigned char *)ptr);\n         actx->nonce[1] = actx->key.counter[2]\n                        = CHACHA_U8TOU32((unsigned char *)ptr+4);\n         actx->nonce[2] = actx->key.counter[3]\n                        = CHACHA_U8TOU32((unsigned char *)ptr+8);\n         return 1;\n \n     case EVP_CTRL_AEAD_SET_TAG:\n         if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n             return 0;\n         if (ptr != NULL) {\n             memcpy(actx->tag, ptr, arg);\n             actx->tag_len = arg;\n         }\n         return 1;\n \n     case EVP_CTRL_AEAD_GET_TAG:\n         if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n             return 0;\n         memcpy(ptr, actx->tag, arg);\n         return 1;\n \n     case EVP_CTRL_AEAD_TLS1_AAD:\n         if (arg != EVP_AEAD_TLS1_AAD_LEN)\n             return 0;\n         {\n             unsigned int len;\n             unsigned char *aad = ptr;\n \n             memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n             aad = actx->tls_aad;\n             if (!ctx->encrypt) {\n                 if (len < POLY1305_BLOCK_SIZE)\n                     return 0;\n                 len -= POLY1305_BLOCK_SIZE;\n                 aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                 aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n             }\n             actx->tls_payload_length = len;\n \n             actx->key.counter[1] = actx->nonce[0];\n             actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n             actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n             actx->mac_inited = 0;\n \n             return POLY1305_BLOCK_SIZE;\n         }\n \n     case EVP_CTRL_AEAD_SET_MAC_KEY:\n         return 1;\n \n     default:\n         return -1;\n     }\n }\n \n", "target": "// fix_start\n        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n// fix_end\n", "cwe": "CWE-327", "cwe_name": "Use of a Broken or Risky Cryptographic Algorithm", "cve": "CVE-2019-1543", "cve_desc": "ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j).", "project": "openssl", "idx": 216726}
{"source": " static int smtp_command_parse_parameters(struct smtp_command_parser *parser)\n {\n \tconst unsigned char *p, *mp;\n \tuoff_t max_size = (parser->auth_response ?\n \t\tparser->limits.max_auth_size :\n \t\tparser->limits.max_parameters_size);\n// bug_start\n// bug_end\n \n \tp = parser->cur + parser->state.poff;\n \twhile (p < parser->end) {\n \t\tunichar_t ch;\n// bug_start\n\t\tint nch = 1;\n// bug_end\n \n \t\tif (parser->auth_response)\n \t\t\tch = *p;\n \t\telse {\n \t\t\tnch = uni_utf8_get_char_n(p, (size_t)(p - parser->end),\n \t\t\t\t\t\t  &ch);\n \t\t}\n// bug_start\n// bug_end\n \t\tif (nch < 0) {\n \t\t\tsmtp_command_parser_error(parser,\n \t\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n \t\t\t\t\"Invalid UTF-8 character in command parameters\");\n \t\t\treturn -1;\n \t\t}\n \t\tif ((parser->auth_response || (ch & 0x80) == 0x00) &&\n \t\t    !smtp_char_is_textstr((unsigned char)ch))\n \t\t\tbreak;\n \t\tp += nch;\n \t}\n \tif (max_size > 0 && (uoff_t)(p - parser->cur) > max_size) {\n \t\tsmtp_command_parser_error(parser,\n \t\t\tSMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG,\n \t\t\t\"%s line is too long\",\n \t\t\t(parser->auth_response ?\n \t\t\t\t\"AUTH response\" : \"Command\"));\n \t\treturn -1;\n \t}\n \tparser->state.poff = p - parser->cur;\n// bug_start\n\tif (p == parser->end)\n// bug_end\n \t\treturn 0;\n \n \tmp = p;\n \tif (mp > parser->cur) {\n \t\twhile (mp > parser->cur && (*(mp-1) == ' ' || *(mp-1) == '\\t'))\n \t\t\tmp--;\n \t}\n \n \tif (!parser->auth_response && mp > parser->cur && *parser->cur == ' ') {\n \t\tsmtp_command_parser_error(parser,\n \t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n \t\t\t\"Duplicate space after command name\");\n \t\treturn -1;\n \t}\n \n \tparser->state.cmd_params = i_strdup_until(parser->cur, mp);\n \tparser->cur = p;\n \tparser->state.poff = 0;\n \treturn 1;\n }\n \n", "target": "// fix_start\n\tint nch = 1;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tif (nch == 0)\n\t\t\tbreak;\n// fix_end\n// fix_start\n\tif (p == parser->end || nch == 0)\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2020-7046", "cve_desc": "lib-smtp in submission-login and lmtp in Dovecot 2.3.9 before 2.3.9.3 mishandles truncated UTF-8 data in command parameters, as demonstrated by the unauthenticated triggering of a submission-login infinite loop.", "project": "core", "idx": 216767}
{"source": " rpa_read_buffer(pool_t pool, const unsigned char **data,\n \t\tconst unsigned char *end, unsigned char **buffer)\n {\n \tconst unsigned char *p = *data;\n \tunsigned int len;\n \n \tif (p > end)\n \t\treturn 0;\n \n \tlen = *p++;\n// bug_start\n\tif (p + len > end)\n// bug_end\n \t\treturn 0;\n \n \t*buffer = p_malloc(pool, len);\n \tmemcpy(*buffer, p, len);\n \n \t*data += 1 + len;\n \n \treturn len;\n }\n \n", "target": "// fix_start\n\tif (p + len > end || len == 0)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-12674", "cve_desc": "In Dovecot before 2.3.11.3, sending a specially formatted RPA request will crash the auth service because a length of zero is mishandled.", "project": "core", "idx": 216800}
{"source": " int setup_tests(void)\n {\n     ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n// bug_start\n// bug_end\n     return 1;\n }\n \n", "target": "// fix_start\n    ADD_TEST(test_GENERAL_NAME_cmp);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-1971", "cve_desc": "The X.509 GeneralName type is a generic type for representing different types of names. One of those name types is known as EDIPartyName. OpenSSL provides a function GENERAL_NAME_cmp which compares different instances of a GENERAL_NAME to see if they are equal or not. This function behaves incorrectly when both GENERAL_NAMEs contain an EDIPARTYNAME. A NULL pointer dereference and a crash may occur leading to a possible denial of service attack. OpenSSL itself uses the GENERAL_NAME_cmp function for two purposes: 1) Comparing CRL distribution point names between an available CRL and a CRL distribution point embedded in an X509 certificate 2) When verifying that a timestamp response token signer matches the timestamp authority name (exposed via the API functions TS_RESP_verify_response and TS_RESP_verify_token) If an attacker can control both items being compared then that attacker could trigger a crash. For example if the attacker can trick a client or server into checking a malicious certificate against a malicious CRL then this may occur. Note that some applications automatically download CRLs based on a URL embedded in a certificate. This checking happens prior to the signatures on the certificate and CRL being verified. OpenSSL's s_server, s_client and verify tools have support for the \"-crl_download\" option which implements automatic CRL downloading and this attack has been demonstrated to work against those tools. Note that an unrelated bug means that affected versions of OpenSSL cannot parse or construct correct encodings of EDIPARTYNAME. However it is possible to construct a malformed EDIPARTYNAME that OpenSSL's parser will accept and hence trigger this attack. All OpenSSL 1.1.1 and 1.0.2 versions are affected by this issue. Other OpenSSL releases are out of support and have not been checked. Fixed in OpenSSL 1.1.1i (Affected 1.1.1-1.1.1h). Fixed in OpenSSL 1.0.2x (Affected 1.0.2-1.0.2w).", "project": "openssl", "idx": 216812}
{"source": " EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n {\n     int ok = 0, tmp;\n     EC_GROUP *ret = NULL, *dup = NULL;\n     BIGNUM *p = NULL, *a = NULL, *b = NULL;\n     EC_POINT *point = NULL;\n     long field_bits;\n     int curve_name = NID_undef;\n     BN_CTX *ctx = NULL;\n \n     if (!params->fieldID || !params->fieldID->fieldType ||\n         !params->fieldID->p.ptr) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n         goto err;\n     }\n \n     if (!params->curve || !params->curve->a ||\n         !params->curve->a->data || !params->curve->b ||\n         !params->curve->b->data) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n         goto err;\n     }\n     a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n     if (a == NULL) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n         goto err;\n     }\n     b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n     if (b == NULL) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n         goto err;\n     }\n \n     tmp = OBJ_obj2nid(params->fieldID->fieldType);\n     if (tmp == NID_X9_62_characteristic_two_field)\n #ifdef OPENSSL_NO_EC2M\n     {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n         goto err;\n     }\n #else\n     {\n         X9_62_CHARACTERISTIC_TWO *char_two;\n \n         char_two = params->fieldID->p.char_two;\n \n         field_bits = char_two->m;\n         if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n             goto err;\n         }\n \n         if ((p = BN_new()) == NULL) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n             goto err;\n         }\n \n         tmp = OBJ_obj2nid(char_two->type);\n \n         if (tmp == NID_X9_62_tpBasis) {\n             long tmp_long;\n \n             if (!char_two->p.tpBasis) {\n                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                 goto err;\n             }\n \n             tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n \n             if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                       EC_R_INVALID_TRINOMIAL_BASIS);\n                 goto err;\n             }\n \n             if (!BN_set_bit(p, (int)char_two->m))\n                 goto err;\n             if (!BN_set_bit(p, (int)tmp_long))\n                 goto err;\n             if (!BN_set_bit(p, 0))\n                 goto err;\n         } else if (tmp == NID_X9_62_ppBasis) {\n             X9_62_PENTANOMIAL *penta;\n \n             penta = char_two->p.ppBasis;\n             if (!penta) {\n                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                 goto err;\n             }\n \n             if (!\n                 (char_two->m > penta->k3 && penta->k3 > penta->k2\n                  && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                       EC_R_INVALID_PENTANOMIAL_BASIS);\n                 goto err;\n             }\n \n             if (!BN_set_bit(p, (int)char_two->m))\n                 goto err;\n             if (!BN_set_bit(p, (int)penta->k1))\n                 goto err;\n             if (!BN_set_bit(p, (int)penta->k2))\n                 goto err;\n             if (!BN_set_bit(p, (int)penta->k3))\n                 goto err;\n             if (!BN_set_bit(p, 0))\n                 goto err;\n         } else if (tmp == NID_X9_62_onBasis) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n             goto err;\n         } else {\n \n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n             goto err;\n         }\n \n         ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n     }\n #endif\n     else if (tmp == NID_X9_62_prime_field) {\n         if (!params->fieldID->p.prime) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n             goto err;\n         }\n         p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n         if (p == NULL) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n             goto err;\n         }\n \n         if (BN_is_negative(p) || BN_is_zero(p)) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n             goto err;\n         }\n \n         field_bits = BN_num_bits(p);\n         if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n             goto err;\n         }\n \n         ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n     } else {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n         goto err;\n     }\n \n     if (ret == NULL) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n         goto err;\n     }\n \n     if (params->curve->seed != NULL) {\n         OPENSSL_free(ret->seed);\n         if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n             goto err;\n         }\n         memcpy(ret->seed, params->curve->seed->data,\n                params->curve->seed->length);\n         ret->seed_len = params->curve->seed->length;\n     }\n \n// bug_start\n    if (!params->order || !params->base || !params->base->data) {\n// bug_end\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n         goto err;\n     }\n \n     if ((point = EC_POINT_new(ret)) == NULL)\n         goto err;\n \n     EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                        (params->base->data[0] & ~0x01));\n \n     if (!EC_POINT_oct2point(ret, point, params->base->data,\n                             params->base->length, NULL)) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n         goto err;\n     }\n \n     if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n         goto err;\n     }\n     if (BN_is_negative(a) || BN_is_zero(a)) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n         goto err;\n     }\n     if (BN_num_bits(a) > (int)field_bits + 1) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n         goto err;\n     }\n \n     if (params->cofactor == NULL) {\n         BN_free(b);\n         b = NULL;\n     } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n         goto err;\n     }\n     if (!EC_GROUP_set_generator(ret, point, a, b)) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n         goto err;\n     }\n \n     if ((ctx = BN_CTX_new()) == NULL) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n         goto err;\n     }\n     if ((dup = EC_GROUP_dup(ret)) == NULL\n             || EC_GROUP_set_seed(dup, NULL, 0) != 1\n             || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n         goto err;\n     }\n     if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n         EC_GROUP *named_group = NULL;\n \n #ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n         if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n             curve_name = NID_secp224r1;\n #endif\n \n         if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n             goto err;\n         }\n         EC_GROUP_free(ret);\n         ret = named_group;\n \n         EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n \n         if (params->curve->seed == NULL) {\n             if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                 goto err;\n         }\n     }\n \n     ok = 1;\n \n  err:\n     if (!ok) {\n         EC_GROUP_free(ret);\n         ret = NULL;\n     }\n     EC_GROUP_free(dup);\n \n     BN_free(p);\n     BN_free(a);\n     BN_free(b);\n     EC_POINT_free(point);\n \n     BN_CTX_free(ctx);\n \n     return ret;\n }\n \n", "target": "// fix_start\n    if (params->order == NULL\n            || params->base == NULL\n            || params->base->data == NULL\n            || params->base->length == 0) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-3712", "cve_desc": "ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's own \"d2i\" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the \"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the \"data\" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).", "project": "openssl", "idx": 216861}
{"source": " bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n {\n   SELECT_LEX_UNIT *next_unit= NULL;\n   for (SELECT_LEX_UNIT *un= first_inner_unit();\n        un;\n        un= next_unit ? next_unit : un->next_unit())\n   {\n     Item_subselect *subquery_predicate= un->item;\n     next_unit= NULL;\n \n     if (subquery_predicate)\n     {\n       if (!subquery_predicate->fixed)\n       {\n \tnext_unit= un->next_unit();\n \tun->exclude_level();\n \tif (next_unit)\n \t  continue;\n \tbreak;\n       }\n       if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n       {\n         Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n         if (in_subs->is_jtbm_merged)\n           continue;\n       }\n \n       if (const_only && !subquery_predicate->const_item())\n       {\n         continue;\n       }\n \n       bool empty_union_result= true;\n       bool is_correlated_unit= false;\n       bool first= true;\n       bool union_plan_saved= false;\n       for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n       {\n         JOIN *inner_join= sl->join;\n         if (first)\n           first= false;\n         else\n         {\n           if (!union_plan_saved)\n           {\n             union_plan_saved= true;\n             if (un->save_union_explain(un->thd->lex->explain))\n               return true;\n           }\n         }\n         if (!inner_join)\n           continue;\n         SELECT_LEX *save_select= un->thd->lex->current_select;\n         ulonglong save_options;\n         int res;\n         un->set_limit(un->global_parameters());\n         un->thd->lex->current_select= sl;\n         save_options= inner_join->select_options;\n         if (options & SELECT_DESCRIBE)\n         {\n           sl->set_explain_type(FALSE);\n           sl->options|= SELECT_DESCRIBE;\n           inner_join->select_options|= SELECT_DESCRIBE;\n         }\n         if ((res= inner_join->optimize()))\n           return TRUE;\n         if (!inner_join->cleaned)\n           sl->update_used_tables();\n         sl->update_correlated_cache();\n         is_correlated_unit|= sl->is_correlated;\n         inner_join->select_options= save_options;\n         un->thd->lex->current_select= save_select;\n \n         Explain_query *eq;\n         if ((eq= inner_join->thd->lex->explain))\n         {\n           Explain_select *expl_sel;\n           if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n           {\n             sl->set_explain_type(TRUE);\n             expl_sel->select_type= sl->type;\n           }\n         }\n \n         if (empty_union_result)\n         {\n           empty_union_result= inner_join->empty_result();\n         }\n         if (res)\n           return TRUE;\n       }\n       if (empty_union_result)\n         subquery_predicate->no_rows_in_result();\n// bug_start\n      if (!is_correlated_unit)\n// bug_end\n         un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n       subquery_predicate->is_correlated= is_correlated_unit;\n     }\n   }\n   return FALSE;\n }\n \n", "target": "// fix_start\n\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-46664", "cve_desc": "MariaDB through 10.5.9 allows an application crash in sub_select_postjoin_aggr for a NULL value of aggr.", "project": "server", "idx": 216903}
{"source": " void ha_maria::drop_table(const char *name)\n {\n// bug_start\n  DBUG_ASSERT(file->s->temporary);\n// bug_end\n   (void) ha_close();\n   (void) maria_delete_table_files(name, 1, MY_WME);\n }\n \n", "target": "// fix_start\n  DBUG_ASSERT(!file || file->s->temporary);\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "cve": "CVE-2021-46668", "cve_desc": "MariaDB through 10.5.9 allows an application crash via certain long SELECT DISTINCT statements that improperly interact with storage-engine resource limitations for temporary data structures.", "project": "server", "idx": 216906}
{"source": " bool open_table(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)\n {\n   TABLE *table;\n   const char *key;\n   uint\tkey_length;\n   const char *alias= table_list->alias.str;\n   uint flags= ot_ctx->get_flags();\n   MDL_ticket *mdl_ticket;\n   TABLE_SHARE *share;\n   uint gts_flags;\n   bool from_share= false;\n #ifdef WITH_PARTITION_STORAGE_ENGINE\n   int part_names_error=0;\n #endif\n   DBUG_ENTER(\"open_table\");\n \n   DBUG_ASSERT(!table_list->table);\n \n   if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))\n     DBUG_RETURN(TRUE);\n \n   if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed)\n   {\n     thd->send_kill_message();\n     DBUG_RETURN(TRUE);\n   }\n \n   if (table_list->mdl_request.is_write_lock_request() &&\n       thd->tx_read_only &&\n       !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK)))\n   {\n     my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));\n     DBUG_RETURN(true);\n   }\n \n   if (!table_list->db.str)\n   {\n     my_error(ER_NO_DB_ERROR, MYF(0));\n     DBUG_RETURN(true);\n   }\n \n   key_length= get_table_def_key(table_list, &key);\n \n   if (thd->locked_tables_mode &&\n       ! (flags & MYSQL_OPEN_GET_NEW_TABLE))\n   {\n     TABLE *best_table= 0;\n     int best_distance= INT_MIN;\n     for (table=thd->open_tables; table ; table=table->next)\n     {\n       if (table->s->table_cache_key.length == key_length &&\n \t  !memcmp(table->s->table_cache_key.str, key, key_length))\n       {\n         if (!my_strcasecmp(system_charset_info, table->alias.c_ptr(), alias) &&\n             table->query_id != thd->query_id &&\n             (thd->locked_tables_mode == LTM_LOCK_TABLES ||\n              table->query_id == 0))\n         {\n           int distance= ((int) table->reginfo.lock_type -\n                          (int) table_list->lock_type);\n \n           if ((best_distance < 0 && distance > best_distance) ||\n               (distance >= 0 && distance < best_distance))\n           {\n             best_distance= distance;\n             best_table= table;\n             if (best_distance == 0)\n             {\n               break;\n             }\n           }\n         }\n       }\n     }\n     if (best_table)\n     {\n       table= best_table;\n       table->query_id= thd->query_id;\n       table->init(thd, table_list);\n       DBUG_PRINT(\"info\",(\"Using locked table\"));\n #ifdef WITH_PARTITION_STORAGE_ENGINE\n       part_names_error= set_partitions_as_used(table_list, table);\n #endif\n       goto reset;\n     }\n \n     if (is_locked_view(thd, table_list))\n     {\n       if (table_list->sequence)\n       {\n         my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n         DBUG_RETURN(true);\n       }\n       DBUG_RETURN(FALSE);\n     }\n \n     if (thd->locked_tables_mode == LTM_PRELOCKED)\n       my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db.str, table_list->alias.str);\n     else\n       my_error(ER_TABLE_NOT_LOCKED, MYF(0), alias);\n     DBUG_RETURN(TRUE);\n   }\n \n \n   if (! (flags & MYSQL_OPEN_HAS_MDL_LOCK))\n   {\n     if (table_list->mdl_request.is_write_lock_request() &&\n         ! (flags & (MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK |\n                     MYSQL_OPEN_FORCE_SHARED_MDL |\n                     MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL |\n                     MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK)) &&\n         ! ot_ctx->has_protection_against_grl())\n     {\n       MDL_request protection_request;\n       MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n \n       if (thd->global_read_lock.can_acquire_protection())\n         DBUG_RETURN(TRUE);\n \n       protection_request.init(MDL_key::GLOBAL, \"\", \"\", MDL_INTENTION_EXCLUSIVE,\n                               MDL_STATEMENT);\n \n       thd->push_internal_handler(&mdl_deadlock_handler);\n       bool result= thd->mdl_context.acquire_lock(&protection_request,\n                                                  ot_ctx->get_timeout());\n       thd->pop_internal_handler();\n \n       if (result)\n         DBUG_RETURN(TRUE);\n \n       ot_ctx->set_has_protection_against_grl();\n     }\n \n     if (open_table_get_mdl_lock(thd, ot_ctx, &table_list->mdl_request,\n                                 flags, &mdl_ticket) ||\n         mdl_ticket == NULL)\n     {\n       DEBUG_SYNC(thd, \"before_open_table_wait_refresh\");\n       DBUG_RETURN(TRUE);\n     }\n     DEBUG_SYNC(thd, \"after_open_table_mdl_shared\");\n   }\n   else\n   {\n     mdl_ticket= table_list->mdl_request.ticket;\n   }\n \n   if (table_list->open_strategy == TABLE_LIST::OPEN_IF_EXISTS)\n   {\n     if (!ha_table_exists(thd, &table_list->db, &table_list->table_name))\n       DBUG_RETURN(FALSE);\n   }\n   else if (table_list->open_strategy == TABLE_LIST::OPEN_STUB)\n     DBUG_RETURN(FALSE);\n \n \n   if (table_list->i_s_requested_object & OPEN_TABLE_ONLY)\n     gts_flags= GTS_TABLE;\n   else if (table_list->i_s_requested_object &  OPEN_VIEW_ONLY)\n     gts_flags= GTS_VIEW;\n   else\n     gts_flags= GTS_TABLE | GTS_VIEW;\n \n retry_share:\n \n   share= tdc_acquire_share(thd, table_list, gts_flags, &table);\n \n   if (unlikely(!share))\n   {\n     if (thd->is_error())\n     {\n       if (table_list->parent_l)\n       {\n         thd->clear_error();\n         my_error(ER_WRONG_MRG_TABLE, MYF(0));\n       }\n       else if (table_list->belong_to_view)\n       {\n         TABLE_LIST *view= table_list->belong_to_view;\n         thd->clear_error();\n         my_error(ER_VIEW_INVALID, MYF(0),\n                  view->view_db.str, view->view_name.str);\n       }\n     }\n     DBUG_RETURN(TRUE);\n   }\n \n   if (share->is_view)\n   {\n     if (table_list->parent_l)\n     {\n       my_error(ER_WRONG_MRG_TABLE, MYF(0));\n       goto err_lock;\n     }\n     if (table_list->sequence)\n     {\n       my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str,\n                table_list->alias.str);\n       goto err_lock;\n     }\n     if (check_and_update_table_version(thd, table_list, share))\n       goto err_lock;\n \n     if (mysql_make_view(thd, share, table_list, false))\n       goto err_lock;\n \n \n     tdc_release_share(share);\n \n     DBUG_ASSERT(table_list->view);\n \n     DBUG_RETURN(FALSE);\n   }\n \n #ifdef WITH_WSREP\n   if (!((flags & MYSQL_OPEN_IGNORE_FLUSH) ||\n         (thd->wsrep_applier)))\n #else\n   if (!(flags & MYSQL_OPEN_IGNORE_FLUSH))\n #endif\n   {\n     if (share->tdc->flushed)\n     {\n       DBUG_PRINT(\"info\", (\"Found old share version: %lld  current: %lld\",\n                           share->tdc->version, tdc_refresh_version()));\n       if (table)\n         tc_release_table(table);\n       else\n         tdc_release_share(share);\n \n       MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n       bool wait_result;\n \n       thd->push_internal_handler(&mdl_deadlock_handler);\n       wait_result= tdc_wait_for_old_version(thd, table_list->db.str,\n                                             table_list->table_name.str,\n                                             ot_ctx->get_timeout(),\n                                             mdl_ticket->get_deadlock_weight());\n       thd->pop_internal_handler();\n \n       if (wait_result)\n         DBUG_RETURN(TRUE);\n \n       goto retry_share;\n     }\n \n     if (thd->open_tables && thd->open_tables->s->tdc->flushed)\n     {\n       if (table)\n         tc_release_table(table);\n       else\n         tdc_release_share(share);\n       (void)ot_ctx->request_backoff_action(Open_table_context::OT_REOPEN_TABLES,\n                                            NULL);\n       DBUG_RETURN(TRUE);\n     }\n   }\n \n   if (table)\n   {\n     DBUG_ASSERT(table->file != NULL);\n     MYSQL_REBIND_TABLE(table->file);\n #ifdef WITH_PARTITION_STORAGE_ENGINE\n     part_names_error= set_partitions_as_used(table_list, table);\n #endif\n   }\n   else\n   {\n     enum open_frm_error error;\n \n     if (!(table=(TABLE*) my_malloc(sizeof(*table),MYF(MY_WME))))\n       goto err_lock;\n \n     error= open_table_from_share(thd, share, &table_list->alias,\n                                  HA_OPEN_KEYFILE | HA_TRY_READ_ONLY,\n                                  EXTRA_RECORD,\n                                  thd->open_options, table, FALSE,\n                                  IF_PARTITIONING(table_list->partition_names,0));\n \n     if (unlikely(error))\n     {\n       my_free(table);\n \n       if (error == OPEN_FRM_DISCOVER)\n         (void) ot_ctx->request_backoff_action(Open_table_context::OT_DISCOVER,\n                                               table_list);\n       else if (share->crashed)\n       {\n         if (!(flags & MYSQL_OPEN_IGNORE_REPAIR))\n           (void) ot_ctx->request_backoff_action(Open_table_context::OT_REPAIR,\n                                                 table_list);\n         else\n           table_list->crashed= 1;\n       }\n       goto err_lock;\n     }\n     if (open_table_entry_fini(thd, share, table))\n     {\n       closefrm(table);\n       my_free(table);\n       goto err_lock;\n     }\n \n     tc_add_table(thd, table);\n     from_share= true;\n   }\n \n   table->mdl_ticket= mdl_ticket;\n   table->reginfo.lock_type=TL_READ;\n \n   table->init(thd, table_list);\n \n   table->next= thd->open_tables;\n   thd->set_open_tables(table);\n \n  reset:\n   DBUG_ASSERT(table->file->pushed_cond == NULL);\n   table_list->updatable= 1;\n   table_list->table= table;\n \n   if (!from_share && table->vcol_fix_expr(thd))\n// bug_start\n    goto err_lock;\n// bug_end\n \n #ifdef WITH_PARTITION_STORAGE_ENGINE\n   if (unlikely(table->part_info))\n   {\n     if (part_names_error)\n     {\n       table->file->print_error(part_names_error, MYF(0));\n       DBUG_RETURN(true);\n     }\n   }\n   else if (table_list->partition_names)\n   {\n     my_error(ER_PARTITION_CLAUSE_ON_NONPARTITIONED, MYF(0));\n     DBUG_RETURN(true);\n   }\n #endif\n   if (table_list->sequence && table->s->table_type != TABLE_TYPE_SEQUENCE)\n   {\n     my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n     DBUG_RETURN(true);\n   }\n \n   DBUG_RETURN(FALSE);\n \n err_lock:\n   tdc_release_share(share);\n \n   DBUG_PRINT(\"exit\", (\"failed\"));\n   DBUG_RETURN(TRUE);\n }\n \n", "target": "// fix_start\n    DBUG_RETURN(true);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-27376", "cve_desc": "MariaDB Server v10.6.5 and below was discovered to contain an use-after-free in the component Item_args::walk_arg, which is exploited via specially crafted SQL statements.", "project": "server", "idx": 216938}
{"source": " bool Item_equal::create_pushable_equalities(THD *thd,\n                                             List<Item> *equalities,\n                                             Pushdown_checker checker,\n                                             uchar *arg,\n                                             bool clone_const)\n {\n   Item *item;\n   Item *left_item= NULL;\n   Item *right_item = get_const();\n   Item_equal_fields_iterator it(*this);\n \n   while ((item=it++))\n   {\n     left_item= item;\n     if (checker && !((item->*checker) (arg)))\n       continue;\n     break;\n   }\n \n   if (!left_item)\n     return false;\n \n   if (right_item)\n   {\n     Item_func_eq *eq= 0;\n     Item *left_item_clone= left_item->build_clone(thd);\n     Item *right_item_clone= !clone_const ?\n                             right_item : right_item->build_clone(thd);\n     if (!left_item_clone || !right_item_clone)\n       return true;\n     eq= new (thd->mem_root) Item_func_eq(thd,\n                                          left_item_clone,\n                                          right_item_clone);\n     if (!eq ||  equalities->push_back(eq, thd->mem_root))\n       return true;\n     if (!clone_const)\n// bug_start\n      right_item->set_extraction_flag(IMMUTABLE_FL);\n// bug_end\n   }\n \n   while ((item=it++))\n   {\n     if (checker && !((item->*checker) (arg)))\n       continue;\n     Item_func_eq *eq= 0;\n     Item *left_item_clone= left_item->build_clone(thd);\n     Item *right_item_clone= item->build_clone(thd);\n     if (!(left_item_clone && right_item_clone))\n       return true;\n     left_item_clone->set_item_equal(NULL);\n     right_item_clone->set_item_equal(NULL);\n     eq= new (thd->mem_root) Item_func_eq(thd,\n                                          right_item_clone,\n                                          left_item_clone);\n     if (!eq || equalities->push_back(eq, thd->mem_root))\n       return true;\n   }\n   return false;\n }\n \n", "target": "// fix_start\n    {\n      int new_flag= IMMUTABLE_FL;\n      right_item->walk(&Item::set_extraction_flag_processor, false,\n                       (void*)&new_flag);\n    }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-27382", "cve_desc": "MariaDB Server v10.7 and below was discovered to contain a segmentation fault via the component Item_field::used_tables/update_depend_map_for_order.", "project": "server", "idx": 216945}
{"source": " static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n {\n   const size_t so_ext_len= sizeof(SO_EXT) - 1;\n// bug_start\n  if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n// bug_end\n                     SO_EXT))\n   {\n     char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n     memcpy(s, dl->str, dl->length);\n     strcpy(s + dl->length, SO_EXT);\n     dl->str= s;\n     dl->length+= so_ext_len;\n   }\n }\n \n", "target": "// fix_start\n  if (dl->length < so_ext_len ||\n      my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-27383", "cve_desc": "MariaDB Server v10.6 and below was discovered to contain an use-after-free in the component my_strcasecmp_8bit, which is exploited via specially crafted SQL statements.", "project": "server", "idx": 216946}
{"source": " multi_update::initialize_tables(JOIN *join)\n {\n   TABLE_LIST *table_ref;\n   DBUG_ENTER(\"initialize_tables\");\n \n   if (unlikely((thd->variables.option_bits & OPTION_SAFE_UPDATES) &&\n                error_if_full_join(join)))\n     DBUG_RETURN(1);\n// bug_start\n// bug_end\n   main_table=join->join_tab->table;\n   table_to_update= 0;\n \n   DBUG_ASSERT(fields->elements);\n   TABLE *first_table_for_update= ((Item_field *) fields->head())->field->table;\n \n   for (table_ref= update_tables; table_ref; table_ref= table_ref->next_local)\n   {\n     TABLE *table=table_ref->table;\n     uint cnt= table_ref->shared;\n     List<Item> temp_fields;\n     ORDER     group;\n     TMP_TABLE_PARAM *tmp_param;\n \n     if (ignore)\n       table->file->extra(HA_EXTRA_IGNORE_DUP_KEY);\n     if (table == main_table)\n     {\n       if (safe_update_on_fly(thd, join->join_tab, table_ref, all_tables))\n       {\n \ttable_to_update= table;\n         has_vers_fields= table->vers_check_update(*fields);\n \tcontinue;\n       }\n     }\n     table->prepare_for_position();\n     join->map2table[table->tablenr]->keep_current_rowid= true;\n \n     if (table_ref->check_option && !join->select_lex->uncacheable)\n     {\n       SELECT_LEX_UNIT *tmp_unit;\n       SELECT_LEX *sl;\n       for (tmp_unit= join->select_lex->first_inner_unit();\n            tmp_unit;\n            tmp_unit= tmp_unit->next_unit())\n       {\n         for (sl= tmp_unit->first_select(); sl; sl= sl->next_select())\n         {\n           if (sl->master_unit()->item)\n           {\n             join->select_lex->uncacheable|= UNCACHEABLE_CHECKOPTION;\n             goto loop_end;\n           }\n         }\n       }\n     }\n loop_end:\n \n     if (table == first_table_for_update && table_ref->check_option)\n     {\n       table_map unupdated_tables= table_ref->check_option->used_tables() &\n                                   ~first_table_for_update->map;\n       List_iterator<TABLE_LIST> ti(*leaves);\n       TABLE_LIST *tbl_ref;\n       while ((tbl_ref= ti++) && unupdated_tables)\n       {\n         if (unupdated_tables & tbl_ref->table->map)\n           unupdated_tables&= ~tbl_ref->table->map;\n         else\n           continue;\n         if (unupdated_check_opt_tables.push_back(tbl_ref->table))\n           DBUG_RETURN(1);\n       }\n     }\n \n     tmp_param= tmp_table_param+cnt;\n \n \n     List_iterator_fast<TABLE> tbl_it(unupdated_check_opt_tables);\n     TABLE *tbl= table;\n     do\n     {\n       LEX_CSTRING field_name;\n       field_name.str= tbl->alias.c_ptr();\n       field_name.length= strlen(field_name.str);\n       tbl->prepare_for_position();\n       join->map2table[tbl->tablenr]->keep_current_rowid= true;\n \n       Item_temptable_rowid *item=\n         new (thd->mem_root) Item_temptable_rowid(tbl);\n       if (!item)\n          DBUG_RETURN(1);\n       item->fix_fields(thd, 0);\n       if (temp_fields.push_back(item, thd->mem_root))\n         DBUG_RETURN(1);\n     } while ((tbl= tbl_it++));\n \n     temp_fields.append(fields_for_table[cnt]);\n \n     bzero((char*) &group, sizeof(group));\n     group.direction= ORDER::ORDER_ASC;\n     group.item= (Item**) temp_fields.head_ref();\n \n     tmp_param->quick_group= 1;\n     tmp_param->field_count= temp_fields.elements;\n     tmp_param->func_count=  temp_fields.elements - 1;\n     calc_group_buffer(tmp_param, &group);\n     my_bool save_big_tables= thd->variables.big_tables;\n     thd->variables.big_tables= FALSE;\n     tmp_tables[cnt]=create_tmp_table(thd, tmp_param, temp_fields,\n                                      (ORDER*) &group, 0, 0,\n                                      TMP_TABLE_ALL_COLUMNS, HA_POS_ERROR, &empty_clex_str);\n     thd->variables.big_tables= save_big_tables;\n     if (!tmp_tables[cnt])\n       DBUG_RETURN(1);\n     tmp_tables[cnt]->file->extra(HA_EXTRA_WRITE_CACHE);\n   }\n   join->tmp_table_keep_current_rowid= TRUE;\n   DBUG_RETURN(0);\n }\n \n", "target": "// fix_start\n  if (join->implicit_grouping)\n  {\n    my_error(ER_INVALID_GROUP_FUNC_USE, MYF(0));\n    DBUG_RETURN(1);\n  }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-27448", "cve_desc": "There is an Assertion failure in MariaDB Server v10.9 and below via 'node->pcur->rel_pos == BTR_PCUR_ON' at /row/row0mysql.cc.", "project": "server", "idx": 216965}
{"source": " static void do_viewlog(HttpRequest req, HttpResponse res) {\n         if (is_readonly(req)) {\n                 send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                 return;\n         }\n         do_head(res, \"_viewlog\", \"View log\", 100);\n         if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                 FILE *f = fopen(Run.files.log, \"r\");\n                 if (f) {\n                         size_t n;\n                         char buf[512];\n                         StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                         while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                 buf[n] = 0;\n// bug_start\n                                StringBuffer_append(res->outputbuffer, \"%s\", buf);\n// bug_end\n                         }\n                         fclose(f);\n                         StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                 } else {\n                         StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                 }\n         } else {\n                 StringBuffer_append(res->outputbuffer,\n                                     \"<b>Cannot view logfile:</b><br>\");\n                 if (! (Run.flags & Run_Log))\n                         StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                 else\n                         StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n         }\n         do_foot(res);\n }\n \n", "target": "// fix_start\n                                escapeHTML(res->outputbuffer, buf);\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "cve": "CVE-2019-11454", "cve_desc": "Persistent cross-site scripting (XSS) in http/cervlet.c in Tildeslash Monit before 5.25.3 allows a remote unauthenticated attacker to introduce arbitrary JavaScript via manipulation of an unsanitized user field of the Authorization header for HTTP Basic Authentication, which is mishandled during an _viewlog operation.", "project": "monit", "idx": 217176}
{"source": "// bug_start\nResult ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\n// bug_end\n {\n     auto* zei = entries.getUnchecked (index);\n \n    #if JUCE_WINDOWS\n     auto entryPath = zei->entry.filename;\n    #else\n     auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n    #endif\n \n     if (entryPath.isEmpty())\n         return Result::ok();\n \n     auto targetFile = targetDirectory.getChildFile (entryPath);\n \n// bug_start\n// bug_end\n     if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n         return targetFile.createDirectory();\n \n     std::unique_ptr<InputStream> in (createStreamForEntry (index));\n \n     if (in == nullptr)\n         return Result::fail (\"Failed to open the zip file for reading\");\n \n     if (targetFile.exists())\n     {\n// bug_start\n        if (! shouldOverwriteFiles)\n// bug_end\n             return Result::ok();\n \n         if (! targetFile.deleteFile())\n             return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n     }\n// bug_start\n// bug_end\n \n     if (! targetFile.getParentDirectory().createDirectory())\n         return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n \n     if (zei->entry.isSymbolicLink)\n     {\n         String originalFilePath (in->readEntireStreamAsString()\n                                     .replaceCharacter (L'/', File::getSeparatorChar()));\n \n         if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n             return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n     }\n     else\n     {\n         FileOutputStream out (targetFile);\n \n         if (out.failedToOpen())\n             return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n \n         out << *in;\n     }\n \n     targetFile.setCreationTime (zei->entry.fileTime);\n     targetFile.setLastModificationTime (zei->entry.fileTime);\n     targetFile.setLastAccessTime (zei->entry.fileTime);\n \n     return Result::ok();\n }\n \n", "target": "// fix_start\nResult ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n// fix_end\n// fix_start\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n\n// fix_end\n// fix_start\n        if (overwriteFiles == OverwriteFiles::no)\n// fix_end\n// fix_start\n\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n// fix_end\n", "cwe": "CWE-59", "cwe_name": "Improper Link Resolution Before File Access ('Link Following')", "cve": "CVE-2021-23521", "cve_desc": "This affects the package juce-framework/JUCE before 6.1.5. This vulnerability is triggered when a malicious archive is crafted with an entry containing a symbolic link. When extracted, the symbolic link is followed outside of the target dir allowing writing arbitrary files on the target host. In some cases, this can allow an attacker to execute arbitrary code. The vulnerable code is in the ZipFile::uncompressEntry function in juce_ZipFile.cpp and is executed when the archive is extracted upon calling uncompressTo() on a ZipFile object.", "project": "JUCE", "idx": 217459}
{"source": " int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n {\n    int      KwdCod, res, *PtrVer, *PtrDim, err;\n    int64_t  MshIdx;\n    char     str[ GmfStrSiz ];\n    va_list  VarArg;\n    GmfMshSct *msh;\n \n \n    if(!(msh = calloc(1, sizeof(GmfMshSct))))\n       return(0);\n \n    MshIdx = (int64_t)msh;\n \n    if( (err = setjmp(msh->err)) != 0)\n    {\n #ifdef GMFDEBUG\n       printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n #endif\n       if(msh->hdl != NULL)\n          fclose(msh->hdl);\n \n       if(msh->FilDes != 0)\n #ifdef GMF_WINDOWS\n          _close(msh->FilDes);\n #else\n          close(msh->FilDes);\n #endif\n \n       free(msh);\n       return(0);\n    }\n \n    if(strlen(FilNam) + 7 >= GmfStrSiz)\n       longjmp(msh->err, -4);\n \n    strcpy(msh->FilNam, FilNam);\n \n    msh->mod = mod;\n    msh->buf = (void *)msh->DblBuf;\n    msh->FltBuf = (void *)msh->DblBuf;\n    msh->IntBuf = (void *)msh->DblBuf;\n \n    if(strstr(msh->FilNam, \".meshb\"))\n       msh->typ |= (Bin | MshFil);\n    else if(strstr(msh->FilNam, \".mesh\"))\n       msh->typ |= (Asc | MshFil);\n    else if(strstr(msh->FilNam, \".solb\"))\n       msh->typ |= (Bin | SolFil);\n    else if(strstr(msh->FilNam, \".sol\"))\n       msh->typ |= (Asc | SolFil);\n    else\n       longjmp(msh->err, -5);\n \n    if(msh->mod == GmfRead)\n    {\n \n \n       va_start(VarArg, mod);\n       PtrVer = va_arg(VarArg, int *);\n       PtrDim = va_arg(VarArg, int *);\n       va_end(VarArg);\n \n       if(msh->typ & Bin)\n       {\n #ifdef WITH_GMF_AIO\n          msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n \n          if(msh->FilDes <= 0)\n             longjmp(msh->err, -6);\n \n          if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n             longjmp(msh->err, -7);\n #else\n          if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n             longjmp(msh->err, -8);\n \n          safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n #endif\n \n          if( (msh->cod != 1) && (msh->cod != 16777216) )\n             longjmp(msh->err, -9);\n \n          ScaWrd(msh, (unsigned char *)&msh->ver);\n \n          if( (msh->ver < 1) || (msh->ver > 4) )\n             longjmp(msh->err, -10);\n \n          if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n             longjmp(msh->err, -11);\n \n          ScaWrd(msh, (unsigned char *)&KwdCod);\n \n          if(KwdCod != GmfDimension)\n             longjmp(msh->err, -12);\n \n          GetPos(msh);\n          ScaWrd(msh, (unsigned char *)&msh->dim);\n       }\n       else\n       {\n          if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n             longjmp(msh->err, -13);\n \n          do\n          {\n// bug_start\n            res = fscanf(msh->hdl, \"%s\", str);\n// bug_end\n          }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n \n          if(res == EOF)\n             longjmp(msh->err, -14);\n \n          safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n \n          if( (msh->ver < 1) || (msh->ver > 4) )\n             longjmp(msh->err, -15);\n \n          do\n          {\n// bug_start\n            res = fscanf(msh->hdl, \"%s\", str);\n// bug_end\n          }while( (res != EOF) && strcmp(str, \"Dimension\") );\n \n          if(res == EOF)\n             longjmp(msh->err, -16);\n \n          safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n       }\n \n       if( (msh->dim != 2) && (msh->dim != 3) )\n          longjmp(msh->err, -17);\n \n       (*PtrVer) = msh->ver;\n       (*PtrDim) = msh->dim;\n \n       if(msh->ver == 1)\n          msh->FltSiz = 32;\n       else\n          msh->FltSiz = 64;\n \n \n       if(!ScaKwdTab(msh))\n          return(0);\n \n       return(MshIdx);\n    }\n    else if(msh->mod == GmfWrite)\n    {\n \n \n       msh->cod = 1;\n \n       va_start(VarArg, mod);\n       msh->ver = va_arg(VarArg, int);\n       msh->dim = va_arg(VarArg, int);\n       va_end(VarArg);\n \n       if( (msh->ver < 1) || (msh->ver > 4) )\n          longjmp(msh->err, -18);\n \n       if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n          longjmp(msh->err, -19);\n \n       if( (msh->dim != 2) && (msh->dim != 3) )\n          longjmp(msh->err, -20);\n \n       if(msh->ver == 1)\n          msh->FltSiz = 32;\n       else\n          msh->FltSiz = 64;\n \n       if(msh->typ & Bin)\n       {\n #ifdef WITH_GMF_AIO\n          msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n \n          if(msh->FilDes <= 0)\n             longjmp(msh->err, -21);\n #else\n          if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n             longjmp(msh->err, -22);\n #endif\n       }\n       else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n          longjmp(msh->err, -23);\n \n \n \n       if(msh->typ & Asc)\n       {\n          fprintf(msh->hdl, \"%s %d\\n\\n\",\n                GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n          fprintf(msh->hdl, \"%s %d\\n\",\n                GmfKwdFmt[ GmfDimension ][0], msh->dim);\n       }\n       else\n       {\n          RecWrd(msh, (unsigned char *)&msh->cod);\n          RecWrd(msh, (unsigned char *)&msh->ver);\n          GmfSetKwd(MshIdx, GmfDimension, 0);\n          RecWrd(msh, (unsigned char *)&msh->dim);\n       }\n \n       return(MshIdx);\n    }\n    else\n    {\n       free(msh);\n       return(0);\n    }\n }\n \n", "target": "// fix_start\n            res = fscanf(msh->hdl, \"%100s\", str);\n// fix_end\n// fix_start\n            res = fscanf(msh->hdl, \"%100s\", str);\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-46225", "cve_desc": "A buffer overflow in the GmfOpenMesh() function of libMeshb v7.61 allows attackers to cause a Denial of Service (DoS) via a crafted MESH file.", "project": "libMeshb", "idx": 217547}
{"source": " int parse(char *elf) {\n     int fd;\n     struct stat st;\n     uint8_t *elf_map;\n     int count;\n     char *tmp;\n     char *name;\n     char flag[4];\n \n     MODE = get_elf_class(elf);\n \n     fd = open(elf, O_RDONLY);\n     if (fd < 0) {\n         perror(\"open\");\n         return -1;\n     }\n \n     if (fstat(fd, &st) < 0) {\n         perror(\"fstat\");\n         return -1;\n     }\n \n     elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n     if (elf_map == MAP_FAILED) {\n         perror(\"mmap\");\n         return -1;\n     }\n \n     if (MODE == ELFCLASS32) {\n         Elf32_Ehdr *ehdr;\n         ehdr = (Elf32_Ehdr *)elf_map;\n \n         INFO(\"ELF Header\\n\");\n         switch (ehdr->e_type) {\n             case ET_NONE:\n                 tmp = \"An unknown type\";\n                 break;\n \n             case ET_REL:\n                 tmp = \"A relocatable file\";\n                 break;\n \n             case ET_EXEC:\n                 tmp = \"An executable file\";\n                 break;\n \n             case ET_DYN:\n                 tmp = \"A shared object\";\n                 break;\n \n             case ET_CORE:\n                 tmp = \"A core file\";\n                 break;\n \n             default:\n                 tmp = \"An unknown type\";\n                 break;\n         }\n         PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n \n         switch (ehdr->e_type) {\n             case EM_NONE:\n                 tmp = \"An unknown machine\";\n                 break;\n \n             case EM_M32:\n                 tmp = \"AT&T WE 32100\";\n                 break;\n \n             case EM_SPARC:\n                 tmp = \"Sun Microsystems SPARC\";\n                 break;\n \n             case EM_386:\n                 tmp = \"Intel 80386\";\n                 break;\n \n             case EM_68K:\n                 tmp = \"Motorola 68000\";\n                 break;\n \n             case EM_88K:\n                 tmp = \"Motorola 88000\";\n                 break;\n \n             case EM_860:\n                 tmp = \"Intel 80860\";\n                 break;\n \n             case EM_MIPS:\n                 tmp = \"MIPS RS3000 (big-endian only)\";\n                 break;\n \n             case EM_PARISC:\n                 tmp = \"HP/PA\";\n                 break;\n \n             case EM_SPARC32PLUS:\n                 tmp = \"SPARC with enhanced instruction set\";\n                 break;\n \n             case EM_PPC:\n                 tmp = \"PowerPC\";\n                 break;\n \n             case EM_PPC64:\n                 tmp = \"PowerPC 64-bit\";\n                 break;\n \n             case EM_S390:\n                 tmp = \"IBM S/390\";\n                 break;\n \n             case EM_ARM:\n                 tmp = \"Advanced RISC Machines\";\n                 break;\n \n             case EM_SH:\n                 tmp = \"Renesas SuperH\";\n                 break;\n \n             case EM_SPARCV9:\n                 tmp = \"SPARC v9 64-bit\";\n                 break;\n \n             case EM_IA_64:\n                 tmp = \"Intel Itanium\";\n                 break;\n \n             case EM_X86_64:\n                 tmp = \"AMD x86-64\";\n                 break;\n \n             case EM_VAX:\n                 tmp = \"DEC Vax\";\n                 break;\n \n             default:\n                 tmp = \"An unknown machine\";\n                 break;\n         }\n         PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n \n         switch (ehdr->e_version) {\n             case EV_NONE:\n                 tmp = \"Invalid version\";\n                 break;\n \n             case EV_CURRENT:\n                 tmp = \"Current version\";\n                 break;\n \n             default:\n                 tmp = \"Known version\";\n                 break;\n         }\n         PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n         PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n         PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n         PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n         PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n         PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n         PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n         PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n         PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n         PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n         PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n \n         Elf32_Shdr *shdr;\n         Elf32_Phdr *phdr;\n         Elf32_Shdr shstrtab;\n \n         shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n         phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n         shstrtab = shdr[ehdr->e_shstrndx];\n \n         INFO(\"Section Header Table\\n\");\n         PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n         for (int i = 0; i < ehdr->e_shnum; i++) {\n             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n// bug_start\n// bug_end\n \n             switch (shdr[i].sh_type) {\n                 case SHT_NULL:\n                     tmp = \"SHT_NULL\";\n                     break;\n \n                 case SHT_PROGBITS:\n                     tmp = \"SHT_PROGBITS\";\n                     break;\n \n                 case SHT_SYMTAB:\n                     tmp = \"SHT_SYMTAB\";\n                     break;\n \n                 case SHT_STRTAB:\n                     tmp = \"SHT_STRTAB\";\n                     break;\n \n                 case SHT_RELA:\n                     tmp = \"SHT_RELA\";\n                     break;\n \n                 case SHT_HASH:\n                     tmp = \"SHT_HASH\";\n                     break;\n \n                 case SHT_DYNAMIC:\n                     tmp = \"SHT_DYNAMIC\";\n                     break;\n \n                 case SHT_NOTE:\n                     tmp = \"SHT_NOTE\";\n                     break;\n \n                 case SHT_NOBITS:\n                     tmp = \"SHT_NOBITS\";\n                     break;\n \n                 case SHT_REL:\n                     tmp = \"SHT_REL\";\n                     break;\n \n                 case SHT_SHLIB:\n                     tmp = \"SHT_SHLIB\";\n                     break;\n \n                 case SHT_DYNSYM:\n                     tmp = \"SHT_DYNSYM\";\n                     break;\n \n                 case SHT_LOPROC:\n                     tmp = \"SHT_LOPROC\";\n                     break;\n \n                 case SHT_HIPROC:\n                     tmp = \"SHT_HIPROC\";\n                     break;\n \n                 case SHT_LOUSER:\n                     tmp = \"SHT_LOUSER\";\n                     break;\n \n                 case SHT_HIUSER:\n                     tmp = \"SHT_HIUSER\";\n                     break;\n \n                 default:\n                     break;\n             }\n \n             if (strlen(name) > 15) {\n                 strcpy(&name[15 - 6], \"[...]\");\n             }\n             strcpy(flag, \"   \");\n             flag2str_sh(shdr[i].sh_flags, flag);\n             PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                             flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n         }\n \n         INFO(\"Program Header Table\\n\");\n         PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n         for (int i = 0; i < ehdr->e_phnum; i++) {\n             switch (phdr[i].p_type) {\n                 case PT_NULL:\n                     tmp = \"PT_NULL\";\n                     break;\n \n                 case PT_LOAD:\n                     tmp = \"PT_LOAD\";\n                     break;\n \n                 case PT_DYNAMIC:\n                     tmp = \"PT_DYNAMIC\";\n                     break;\n \n                 case PT_INTERP:\n                     tmp = \"PT_INTERP\";\n                     break;\n \n                 case PT_NOTE:\n                     tmp = \"PT_NOTE\";\n                     break;\n \n                 case PT_SHLIB:\n                     tmp = \"PT_SHLIB\";\n                     break;\n \n                 case PT_PHDR:\n                     tmp = \"PT_PHDR\";\n                     break;\n \n                 case PT_LOPROC:\n                     tmp = \"PT_LOPROC\";\n                     break;\n \n                 case PT_HIPROC:\n                     tmp = \"PT_HIPROC\";\n                     break;\n \n                 case PT_GNU_STACK:\n                     tmp = \"PT_GNU_STACK\";\n                     break;\n \n                 default:\n                     break;\n             }\n             strcpy(flag, \"   \");\n             flag2str(phdr[i].p_flags, flag);\n             PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align);\n         }\n \n         INFO(\"Section to segment mapping\\n\");\n         for (int i = 0; i < ehdr->e_phnum; i++) {\n             printf(\"     [%2d]\", i);\n             for (int j = 0; j < ehdr->e_shnum; j++) {\n                 name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                 if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                     if (shdr[j].sh_flags >> 1 & 0x1) {\n                         printf(\" %s\", name);\n                     }\n                 }\n             }\n             printf(\"\\n\");\n         }\n \n         INFO(\"Dynamic link information\\n\");\n         int dynstr;\n         int dynamic;\n         Elf32_Dyn *dyn;\n         for (int i = 0; i < ehdr->e_shnum; i++) {\n             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n             if (!strcmp(name, \".dynstr\")) {\n                 dynstr = i;\n             }\n             if (!strcmp(name, \".dynamic\")) {\n                 dynamic = i;\n             }\n         }\n \n         char value[50];\n         name = \"\";\n         dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n         count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n         INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n         PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n \n         for(int i = 0; i < count; i++) {\n             tmp = \"\";\n             memset(value, 0, 50);\n             snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n             switch (dyn[i].d_tag) {\n                 case DT_NULL:\n                     tmp = \"DT_NULL\";\n                     break;\n \n                 case DT_NEEDED:\n                     tmp = \"DT_NEEDED\";\n                     name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                     snprintf(value, 50, \"Shared library: [%s]\", name);\n                     break;\n \n                 case DT_PLTRELSZ:\n                     tmp = \"DT_PLTRELSZ\";\n                     break;\n \n                 case DT_PLTGOT:\n                     tmp = \"DT_PLTGOT\";\n                     break;\n \n                 case DT_HASH:\n                     tmp = \"DT_HASH\";\n                     break;\n \n                 case DT_STRTAB:\n                     tmp = \"DT_STRTAB\";\n                     break;\n \n                 case DT_SYMTAB:\n                     tmp = \"DT_SYMTAB\";\n                     break;\n \n                 case DT_RELA:\n                     tmp = \"DT_RELA\";\n                     break;\n \n                 case DT_RELASZ:\n                     tmp = \"DT_RELASZ\";\n                     break;\n \n                 case DT_RELAENT:\n                     tmp = \"DT_RELAENT\";\n                     break;\n \n                 case DT_STRSZ:\n                     tmp = \"DT_STRSZ\";\n                     break;\n \n                 case DT_SYMENT:\n                     tmp = \"DT_SYMENT\";\n                     break;\n \n                 case DT_INIT:\n                     tmp = \"DT_INIT\";\n                     break;\n \n                 case DT_FINI:\n                     tmp = \"DT_FINI\";\n                     break;\n \n                 case DT_SONAME:\n                     tmp = \"DT_SONAME\";\n                     break;\n \n                 case DT_RPATH:\n                     tmp = \"DT_RPATH\";\n                     break;\n \n                 case DT_SYMBOLIC:\n                     tmp = \"DT_SYMBOLIC\";\n                     break;\n \n                 case DT_REL:\n                     tmp = \"DT_REL\";\n                     break;\n \n                 case DT_RELSZ:\n                     tmp = \"DT_RELSZ\";\n                     break;\n \n                 case DT_RELENT:\n                     tmp = \"DT_RELENT\";\n                     break;\n \n                 case DT_PLTREL:\n                     tmp = \"DT_PLTREL\";\n                     break;\n \n                 case DT_DEBUG:\n                     tmp = \"DT_DEBUG\";\n                     break;\n \n                 case DT_TEXTREL:\n                     tmp = \"DT_TEXTREL\";\n                     break;\n \n                 case DT_JMPREL:\n                     tmp = \"DT_JMPREL\";\n                     break;\n \n                 case DT_BIND_NOW:\n                     tmp = \"DT_BIND_NOW\";\n                     break;\n \n                 case DT_INIT_ARRAY:\n                     tmp = \"DT_INIT_ARRAY\";\n                     break;\n \n                 case DT_FINI_ARRAY:\n                     tmp = \"DT_FINI_ARRAY\";\n                     break;\n \n                 case DT_INIT_ARRAYSZ:\n                     tmp = \"DT_INIT_ARRAYSZ\";\n                     break;\n \n                 case DT_FINI_ARRAYSZ:\n                     tmp = \"DT_FINI_ARRAYSZ\";\n                     break;\n \n                 case DT_RUNPATH:\n                     tmp = \"DT_RUNPATH\";\n                     break;\n \n                 case DT_FLAGS:\n                     tmp = \"DT_FLAGS\";\n                     snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                     break;\n \n                 case DT_ENCODING:\n                     tmp = \"DT_ENCODING\";\n                     break;\n \n                 case DT_PREINIT_ARRAYSZ:\n                     tmp = \"DT_PREINIT_ARRAYSZ\";\n                     break;\n \n                 case DT_SYMTAB_SHNDX:\n                     tmp = \"DT_SYMTAB_SHNDX\";\n                     break;\n \n                 case DT_NUM:\n                     tmp = \"DT_NUM\";\n                     break;\n \n                 case DT_LOOS:\n                     tmp = \"DT_LOOS\";\n                     break;\n \n                 case DT_HIOS:\n                     tmp = \"DT_HIOS\";\n                     break;\n \n                 case DT_LOPROC:\n                     tmp = \"DT_LOPROC\";\n                     break;\n \n                 case DT_HIPROC:\n                     tmp = \"DT_HIPROC\";\n                     break;\n \n                 case DT_PROCNUM:\n                     tmp = \"DT_LOPROC\";\n                     break;\n \n \n                 case DT_VALRNGLO:\n                     tmp = \"DT_VALRNGLO\";\n                     break;\n \n                 case DT_GNU_PRELINKED:\n                     tmp = \"DT_GNU_PRELINKED\";\n                     break;\n \n                 case DT_GNU_CONFLICTSZ:\n                     tmp = \"DT_GNU_CONFLICTSZ\";\n                     break;\n \n                 case DT_GNU_LIBLISTSZ:\n                     tmp = \"DT_GNU_LIBLISTSZ\";\n                     break;\n \n                 case DT_CHECKSUM:\n                     tmp = \"DT_CHECKSUM\";\n                     break;\n \n                 case DT_PLTPADSZ:\n                     tmp = \"DT_PLTPADSZ\";\n                     break;\n \n                 case DT_MOVEENT:\n                     tmp = \"DT_MOVEENT\";\n                     break;\n \n                 case DT_MOVESZ:\n                     tmp = \"DT_MOVESZ\";\n                     break;\n \n                 case DT_FEATURE_1:\n                     tmp = \"DT_FEATURE_1\";\n                     break;\n \n                 case DT_POSFLAG_1:\n                     tmp = \"DT_POSFLAG_1\";\n                     break;\n \n                 case DT_SYMINSZ:\n                     tmp = \"DT_SYMINSZ\";\n                     break;\n \n                 case DT_SYMINENT:\n                     tmp = \"DT_SYMINENT\";\n                     break;\n \n                 case DT_ADDRRNGLO:\n                     tmp = \"DT_ADDRRNGLO\";\n                     break;\n \n                 case DT_GNU_HASH:\n                     tmp = \"DT_GNU_HASH\";\n                     break;\n \n                 case DT_TLSDESC_PLT:\n                     tmp = \"DT_TLSDESC_PLT\";\n                     break;\n \n                 case DT_TLSDESC_GOT:\n                     tmp = \"DT_TLSDESC_GOT\";\n                     break;\n \n                 case DT_GNU_CONFLICT:\n                     tmp = \"DT_GNU_CONFLICT\";\n                     break;\n \n                 case DT_GNU_LIBLIST:\n                     tmp = \"DT_GNU_LIBLIST\";\n                     break;\n \n                 case DT_CONFIG:\n                     tmp = \"DT_CONFIG\";\n                     break;\n \n                 case DT_DEPAUDIT:\n                     tmp = \"DT_DEPAUDIT\";\n                     break;\n \n                 case DT_AUDIT:\n                     tmp = \"DT_AUDIT\";\n                     break;\n \n                 case DT_PLTPAD:\n                     tmp = \"DT_PLTPAD\";\n                     break;\n \n                 case DT_MOVETAB:\n                     tmp = \"DT_MOVETAB\";\n                     break;\n \n                 case DT_SYMINFO:\n                     tmp = \"DT_SYMINFO\";\n                     break;\n \n                 case DT_VERSYM:\n                     tmp = \"DT_VERSYM\";\n                     break;\n \n                 case DT_RELACOUNT:\n                     tmp = \"DT_RELACOUNT\";\n                     break;\n \n                 case DT_RELCOUNT:\n                     tmp = \"DT_RELCOUNT\";\n                     break;\n \n                 case DT_FLAGS_1:\n                     tmp = \"DT_FLAGS_1\";\n                     switch (dyn[i].d_un.d_val) {\n                         case DF_1_PIE:\n                             snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                             break;\n \n                         default:\n                             snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                             break;\n                     }\n \n                     break;\n \n                 case DT_VERDEF:\n                     tmp = \"DT_VERDEF\";\n                     break;\n \n                 case DT_VERDEFNUM:\n                     tmp = \"DT_VERDEFNUM\";\n                     break;\n \n                 case DT_VERNEED:\n                     tmp = \"DT_VERNEED\";\n                     break;\n \n                 case DT_VERNEEDNUM:\n                     tmp = \"DT_VERNEEDNUM\";\n                     break;\n \n                 default:\n                     break;\n             }\n             PRINT_DYN(dyn[i].d_tag, tmp, value);\n         }\n     }\n \n     if (MODE == ELFCLASS64) {\n         Elf64_Ehdr *ehdr;\n         ehdr = (Elf64_Ehdr *)elf_map;\n \n         INFO(\"ELF Header\\n\");\n         switch (ehdr->e_type) {\n             case ET_NONE:\n                 tmp = \"An unknown type\";\n                 break;\n \n             case ET_REL:\n                 tmp = \"A relocatable file\";\n                 break;\n \n             case ET_EXEC:\n                 tmp = \"An executable file\";\n                 break;\n \n             case ET_DYN:\n                 tmp = \"A shared object\";\n                 break;\n \n             case ET_CORE:\n                 tmp = \"A core file\";\n                 break;\n \n             default:\n                 tmp = \"An unknown type\";\n                 break;\n         }\n         PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n \n         switch (ehdr->e_type) {\n             case EM_NONE:\n                 tmp = \"An unknown machine\";\n                 break;\n \n             case EM_M32:\n                 tmp = \"AT&T WE 32100\";\n                 break;\n \n             case EM_SPARC:\n                 tmp = \"Sun Microsystems SPARC\";\n                 break;\n \n             case EM_386:\n                 tmp = \"Intel 80386\";\n                 break;\n \n             case EM_68K:\n                 tmp = \"Motorola 68000\";\n                 break;\n \n             case EM_88K:\n                 tmp = \"Motorola 88000\";\n                 break;\n \n             case EM_860:\n                 tmp = \"Intel 80860\";\n                 break;\n \n             case EM_MIPS:\n                 tmp = \"MIPS RS3000 (big-endian only)\";\n                 break;\n \n             case EM_PARISC:\n                 tmp = \"HP/PA\";\n                 break;\n \n             case EM_SPARC32PLUS:\n                 tmp = \"SPARC with enhanced instruction set\";\n                 break;\n \n             case EM_PPC:\n                 tmp = \"PowerPC\";\n                 break;\n \n             case EM_PPC64:\n                 tmp = \"PowerPC 64-bit\";\n                 break;\n \n             case EM_S390:\n                 tmp = \"IBM S/390\";\n                 break;\n \n             case EM_ARM:\n                 tmp = \"Advanced RISC Machines\";\n                 break;\n \n             case EM_SH:\n                 tmp = \"Renesas SuperH\";\n                 break;\n \n             case EM_SPARCV9:\n                 tmp = \"SPARC v9 64-bit\";\n                 break;\n \n             case EM_IA_64:\n                 tmp = \"Intel Itanium\";\n                 break;\n \n             case EM_X86_64:\n                 tmp = \"AMD x86-64\";\n                 break;\n \n             case EM_VAX:\n                 tmp = \"DEC Vax\";\n                 break;\n \n             default:\n                 tmp = \"An unknown machine\";\n                 break;\n         }\n         PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n \n         switch (ehdr->e_version) {\n             case EV_NONE:\n                 tmp = \"Invalid version\";\n                 break;\n \n             case EV_CURRENT:\n                 tmp = \"Current version\";\n                 break;\n \n             default:\n                 tmp = \"Known version\";\n                 break;\n         }\n         PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n         PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n         PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n         PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n         PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n         PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n         PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n         PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n         PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n         PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n         PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n \n         Elf64_Shdr *shdr;\n         Elf64_Phdr *phdr;\n         Elf64_Shdr shstrtab;\n \n         shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n         phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n         shstrtab = shdr[ehdr->e_shstrndx];\n \n         INFO(\"Section Header Table\\n\");\n         PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n         for (int i = 0; i < ehdr->e_shnum; i++) {\n             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n// bug_start\n// bug_end\n \n             switch (shdr[i].sh_type) {\n                 case SHT_NULL:\n                     tmp = \"SHT_NULL\";\n                     break;\n \n                 case SHT_PROGBITS:\n                     tmp = \"SHT_PROGBITS\";\n                     break;\n \n                 case SHT_SYMTAB:\n                     tmp = \"SHT_SYMTAB\";\n                     break;\n \n                 case SHT_STRTAB:\n                     tmp = \"SHT_STRTAB\";\n                     break;\n \n                 case SHT_RELA:\n                     tmp = \"SHT_RELA\";\n                     break;\n \n                 case SHT_HASH:\n                     tmp = \"SHT_HASH\";\n                     break;\n \n                 case SHT_DYNAMIC:\n                     tmp = \"SHT_DYNAMIC\";\n                     break;\n \n                 case SHT_NOTE:\n                     tmp = \"SHT_NOTE\";\n                     break;\n \n                 case SHT_NOBITS:\n                     tmp = \"SHT_NOBITS\";\n                     break;\n \n                 case SHT_REL:\n                     tmp = \"SHT_REL\";\n                     break;\n \n                 case SHT_SHLIB:\n                     tmp = \"SHT_SHLIB\";\n                     break;\n \n                 case SHT_DYNSYM:\n                     tmp = \"SHT_DYNSYM\";\n                     break;\n \n                 case SHT_LOPROC:\n                     tmp = \"SHT_LOPROC\";\n                     break;\n \n                 case SHT_HIPROC:\n                     tmp = \"SHT_HIPROC\";\n                     break;\n \n                 case SHT_LOUSER:\n                     tmp = \"SHT_LOUSER\";\n                     break;\n \n                 case SHT_HIUSER:\n                     tmp = \"SHT_HIUSER\";\n                     break;\n \n                 default:\n                     break;\n             }\n \n             if (strlen(name) > 15) {\n                 strcpy(&name[15 - 6], \"[...]\");\n             }\n             strcpy(flag, \"   \");\n             flag2str_sh(shdr[i].sh_flags, flag);\n             PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                             flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n         }\n \n         INFO(\"Program Header Table\\n\");\n         PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n         for (int i = 0; i < ehdr->e_phnum; i++) {\n             switch (phdr[i].p_type) {\n                 case PT_NULL:\n                     tmp = \"PT_NULL\";\n                     break;\n \n                 case PT_LOAD:\n                     tmp = \"PT_LOAD\";\n                     break;\n \n                 case PT_DYNAMIC:\n                     tmp = \"PT_DYNAMIC\";\n                     break;\n \n                 case PT_INTERP:\n                     tmp = \"PT_INTERP\";\n                     break;\n \n                 case PT_NOTE:\n                     tmp = \"PT_NOTE\";\n                     break;\n \n                 case PT_SHLIB:\n                     tmp = \"PT_SHLIB\";\n                     break;\n \n                 case PT_PHDR:\n                     tmp = \"PT_PHDR\";\n                     break;\n \n                 case PT_LOPROC:\n                     tmp = \"PT_LOPROC\";\n                     break;\n \n                 case PT_HIPROC:\n                     tmp = \"PT_HIPROC\";\n                     break;\n \n                 case PT_GNU_STACK:\n                     tmp = \"PT_GNU_STACK\";\n                     break;\n \n                 default:\n                     break;\n             }\n             strcpy(flag, \"   \");\n             flag2str(phdr[i].p_flags, flag);\n             PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align);\n         }\n \n         INFO(\"Section to segment mapping\\n\");\n         for (int i = 0; i < ehdr->e_phnum; i++) {\n             printf(\"     [%2d]\", i);\n             for (int j = 0; j < ehdr->e_shnum; j++) {\n                 name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                 if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                     if (shdr[j].sh_flags >> 1 & 0x1) {\n                         printf(\" %s\", name);\n                     }\n                 }\n             }\n             printf(\"\\n\");\n         }\n \n         INFO(\"Dynamic link information\\n\");\n         int dynstr;\n         int dynamic;\n         Elf64_Dyn *dyn;\n         for (int i = 0; i < ehdr->e_shnum; i++) {\n             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n             if (!strcmp(name, \".dynstr\")) {\n                 dynstr = i;\n             }\n             if (!strcmp(name, \".dynamic\")) {\n                 dynamic = i;\n             }\n         }\n \n         char value[50];\n         name = \"\";\n         dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n         count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n         INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n         PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n \n         for(int i = 0; i < count; i++) {\n             tmp = \"\";\n             memset(value, 0, 50);\n             snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n             switch (dyn[i].d_tag) {\n                 case DT_NULL:\n                     tmp = \"DT_NULL\";\n                     break;\n \n                 case DT_NEEDED:\n                     tmp = \"DT_NEEDED\";\n                     name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                     snprintf(value, 50, \"Shared library: [%s]\", name);\n                     break;\n \n                 case DT_PLTRELSZ:\n                     tmp = \"DT_PLTRELSZ\";\n                     break;\n \n                 case DT_PLTGOT:\n                     tmp = \"DT_PLTGOT\";\n                     break;\n \n                 case DT_HASH:\n                     tmp = \"DT_HASH\";\n                     break;\n \n                 case DT_STRTAB:\n                     tmp = \"DT_STRTAB\";\n                     break;\n \n                 case DT_SYMTAB:\n                     tmp = \"DT_SYMTAB\";\n                     break;\n \n                 case DT_RELA:\n                     tmp = \"DT_RELA\";\n                     break;\n \n                 case DT_RELASZ:\n                     tmp = \"DT_RELASZ\";\n                     break;\n \n                 case DT_RELAENT:\n                     tmp = \"DT_RELAENT\";\n                     break;\n \n                 case DT_STRSZ:\n                     tmp = \"DT_STRSZ\";\n                     break;\n \n                 case DT_SYMENT:\n                     tmp = \"DT_SYMENT\";\n                     break;\n \n                 case DT_INIT:\n                     tmp = \"DT_INIT\";\n                     break;\n \n                 case DT_FINI:\n                     tmp = \"DT_FINI\";\n                     break;\n \n                 case DT_SONAME:\n                     tmp = \"DT_SONAME\";\n                     break;\n \n                 case DT_RPATH:\n                     tmp = \"DT_RPATH\";\n                     break;\n \n                 case DT_SYMBOLIC:\n                     tmp = \"DT_SYMBOLIC\";\n                     break;\n \n                 case DT_REL:\n                     tmp = \"DT_REL\";\n                     break;\n \n                 case DT_RELSZ:\n                     tmp = \"DT_RELSZ\";\n                     break;\n \n                 case DT_RELENT:\n                     tmp = \"DT_RELENT\";\n                     break;\n \n                 case DT_PLTREL:\n                     tmp = \"DT_PLTREL\";\n                     break;\n \n                 case DT_DEBUG:\n                     tmp = \"DT_DEBUG\";\n                     break;\n \n                 case DT_TEXTREL:\n                     tmp = \"DT_TEXTREL\";\n                     break;\n \n                 case DT_JMPREL:\n                     tmp = \"DT_JMPREL\";\n                     break;\n \n                 case DT_BIND_NOW:\n                     tmp = \"DT_BIND_NOW\";\n                     break;\n \n                 case DT_INIT_ARRAY:\n                     tmp = \"DT_INIT_ARRAY\";\n                     break;\n \n                 case DT_FINI_ARRAY:\n                     tmp = \"DT_FINI_ARRAY\";\n                     break;\n \n                 case DT_INIT_ARRAYSZ:\n                     tmp = \"DT_INIT_ARRAYSZ\";\n                     break;\n \n                 case DT_FINI_ARRAYSZ:\n                     tmp = \"DT_FINI_ARRAYSZ\";\n                     break;\n \n                 case DT_RUNPATH:\n                     tmp = \"DT_RUNPATH\";\n                     break;\n \n                 case DT_FLAGS:\n                     tmp = \"DT_FLAGS\";\n                     snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                     break;\n \n                 case DT_ENCODING:\n                     tmp = \"DT_ENCODING\";\n                     break;\n \n                 case DT_PREINIT_ARRAYSZ:\n                     tmp = \"DT_PREINIT_ARRAYSZ\";\n                     break;\n \n                 case DT_SYMTAB_SHNDX:\n                     tmp = \"DT_SYMTAB_SHNDX\";\n                     break;\n \n                 case DT_NUM:\n                     tmp = \"DT_NUM\";\n                     break;\n \n                 case DT_LOOS:\n                     tmp = \"DT_LOOS\";\n                     break;\n \n                 case DT_HIOS:\n                     tmp = \"DT_HIOS\";\n                     break;\n \n                 case DT_LOPROC:\n                     tmp = \"DT_LOPROC\";\n                     break;\n \n                 case DT_HIPROC:\n                     tmp = \"DT_HIPROC\";\n                     break;\n \n                 case DT_PROCNUM:\n                     tmp = \"DT_LOPROC\";\n                     break;\n \n \n                 case DT_VALRNGLO:\n                     tmp = \"DT_VALRNGLO\";\n                     break;\n \n                 case DT_GNU_PRELINKED:\n                     tmp = \"DT_GNU_PRELINKED\";\n                     break;\n \n                 case DT_GNU_CONFLICTSZ:\n                     tmp = \"DT_GNU_CONFLICTSZ\";\n                     break;\n \n                 case DT_GNU_LIBLISTSZ:\n                     tmp = \"DT_GNU_LIBLISTSZ\";\n                     break;\n \n                 case DT_CHECKSUM:\n                     tmp = \"DT_CHECKSUM\";\n                     break;\n \n                 case DT_PLTPADSZ:\n                     tmp = \"DT_PLTPADSZ\";\n                     break;\n \n                 case DT_MOVEENT:\n                     tmp = \"DT_MOVEENT\";\n                     break;\n \n                 case DT_MOVESZ:\n                     tmp = \"DT_MOVESZ\";\n                     break;\n \n                 case DT_FEATURE_1:\n                     tmp = \"DT_FEATURE_1\";\n                     break;\n \n                 case DT_POSFLAG_1:\n                     tmp = \"DT_POSFLAG_1\";\n                     break;\n \n                 case DT_SYMINSZ:\n                     tmp = \"DT_SYMINSZ\";\n                     break;\n \n                 case DT_SYMINENT:\n                     tmp = \"DT_SYMINENT\";\n                     break;\n \n                 case DT_ADDRRNGLO:\n                     tmp = \"DT_ADDRRNGLO\";\n                     break;\n \n                 case DT_GNU_HASH:\n                     tmp = \"DT_GNU_HASH\";\n                     break;\n \n                 case DT_TLSDESC_PLT:\n                     tmp = \"DT_TLSDESC_PLT\";\n                     break;\n \n                 case DT_TLSDESC_GOT:\n                     tmp = \"DT_TLSDESC_GOT\";\n                     break;\n \n                 case DT_GNU_CONFLICT:\n                     tmp = \"DT_GNU_CONFLICT\";\n                     break;\n \n                 case DT_GNU_LIBLIST:\n                     tmp = \"DT_GNU_LIBLIST\";\n                     break;\n \n                 case DT_CONFIG:\n                     tmp = \"DT_CONFIG\";\n                     break;\n \n                 case DT_DEPAUDIT:\n                     tmp = \"DT_DEPAUDIT\";\n                     break;\n \n                 case DT_AUDIT:\n                     tmp = \"DT_AUDIT\";\n                     break;\n \n                 case DT_PLTPAD:\n                     tmp = \"DT_PLTPAD\";\n                     break;\n \n                 case DT_MOVETAB:\n                     tmp = \"DT_MOVETAB\";\n                     break;\n \n                 case DT_SYMINFO:\n                     tmp = \"DT_SYMINFO\";\n                     break;\n \n                 case DT_VERSYM:\n                     tmp = \"DT_VERSYM\";\n                     break;\n \n                 case DT_RELACOUNT:\n                     tmp = \"DT_RELACOUNT\";\n                     break;\n \n                 case DT_RELCOUNT:\n                     tmp = \"DT_RELCOUNT\";\n                     break;\n \n                 case DT_FLAGS_1:\n                     tmp = \"DT_FLAGS_1\";\n                     switch (dyn[i].d_un.d_val) {\n                         case DF_1_PIE:\n                             snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                             break;\n \n                         default:\n                             snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                             break;\n                     }\n \n                     break;\n \n                 case DT_VERDEF:\n                     tmp = \"DT_VERDEF\";\n                     break;\n \n                 case DT_VERDEFNUM:\n                     tmp = \"DT_VERDEFNUM\";\n                     break;\n \n                 case DT_VERNEED:\n                     tmp = \"DT_VERNEED\";\n                     break;\n \n                 case DT_VERNEEDNUM:\n                     tmp = \"DT_VERNEEDNUM\";\n                     break;\n \n                 default:\n                     break;\n             }\n             PRINT_DYN(dyn[i].d_tag, tmp, value);\n         }\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n            if (validated_offset(name, elf_map, elf_map + st.st_size)) {\n                ERROR(\"Corrupt file format\\n\");\n                return -1;\n            }\n// fix_end\n// fix_start\n            if (validated_offset(name, elf_map, elf_map + st.st_size)) {\n                ERROR(\"Corrupt file format\\n\");\n                return -1;\n            }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-21711", "cve_desc": "elfspirit is an ELF static analysis and injection framework that parses, manipulates, and camouflages ELF files. When analyzing the ELF file format in versions prior to 1.1, there is an out-of-bounds read bug, which can lead to application crashes or information leakage. By constructing a special format ELF file, the information of any address can be leaked. elfspirit version 1.1 contains a patch for this issue.", "project": "elfspirit", "idx": 217551}
